Compiling Program: C:\Projects\DF20\DbUpdateFramework\AppSrc\DUFCodeGenerator.src
Memory Available: 2147483646
1>    CompilerLevelWarning All On
1>Use DFAllEnt.pkg
Using pre-compiled package DFALLENT.PKG
Including file: dfallent.pkd    (C:\Program Files\DataFlex 24.0\Pkg\dfallent.pkd)
73440>Use cCJStandardCommandBarSystem.pkg
Including file: cCJStandardCommandBarSystem.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCJStandardCommandBarSystem.pkg)
73440>>>// these are all the packages used in a standard MDI menubar/toolbar system
73440>>>
73440>>>Use cCJCommandBarSystem.pkg
73440>>>Use cCJStandardMenuItemClasses.pkg
Including file: cCJStandardMenuItemClasses.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCJStandardMenuItemClasses.pkg)
73440>>>>>Use Dfpanel.pkg
73440>>>>>Use cCJCommandBarSystem.pkg
73440>>>>>Use LanguageText.pkg
73440>>>>>
73440>>>>>
73440>>>>>Class cCJUndoMenuItem is a cCJMenuItem
73441>>>>>    
73441>>>>>    Procedure Construct_Object
73443>>>>>        Forward Send Construct_Object
73445>>>>>        Set psCaption   to C_$CaptionUndo
73446>>>>>        Set psToolTip to C_$ToolTipUndo
73447>>>>>        Set psDescription to C_$DescUndo
73448>>>>>        Set psImage to "ActionUndo.ico"
73449>>>>>        Set pbActiveUpdate to True
73450>>>>>        Set psCategory to C_$CategoryEdit
73451>>>>>        Set psShortcut to C_$Key_Ctrl_Z
73452>>>>>    End_Procedure
73453>>>>>    
73453>>>>>    Procedure OnExecute Variant vCommandBarControl
73455>>>>>        Send Undo of (focus(Self))
73456>>>>>    End_Procedure
73457>>>>>    
73457>>>>>    Function IsEnabled Returns Boolean
73459>>>>>        Boolean bEnabled
73459>>>>>        Get CanUndo of (Focus(Self)) to bEnabled
73460>>>>>        Function_Return bEnabled
73461>>>>>    End_Function
73462>>>>>    
73462>>>>>End_Class
73463>>>>>
73463>>>>>
73463>>>>>Class cCJDeleteEditMenuItem is a cCJMenuItem
73464>>>>>    
73464>>>>>    Procedure Construct_Object
73466>>>>>        Forward Send Construct_Object
73468>>>>>        Set psCaption   to C_$CaptionDelete
73469>>>>>        Set psToolTip to C_$ToolTipDelete
73470>>>>>        Set psDescription to C_$DescDelete
73471>>>>>        Set psImage to "actionDelete.ico"
73472>>>>>        Set psShortcut to C_$Key_Delete
73473>>>>>        Set pbActiveUpdate to True
73474>>>>>        Set psCategory to C_$CategoryEdit
73475>>>>>    End_Procedure
73476>>>>>    
73476>>>>>    
73476>>>>>    Procedure OnExecute Variant vCommandBarControl
73478>>>>>        Send Delete of (focus(Self))
73479>>>>>    End_Procedure
73480>>>>>    
73480>>>>>    Function IsEnabled Returns Boolean
73482>>>>>        Boolean bEnabled
73482>>>>>        Get CanDelete of (Focus(Self)) to bEnabled
73483>>>>>        Function_Return bEnabled
73484>>>>>    End_Function
73485>>>>>    
73485>>>>>End_Class
73486>>>>>
73486>>>>>
73486>>>>>Class cCJCutMenuItem is a cCJMenuItem
73487>>>>>    
73487>>>>>    Procedure Construct_Object
73489>>>>>        Forward Send Construct_Object
73491>>>>>        Set psCaption   to C_$CaptionCut
73492>>>>>        Set psToolTip to C_$TooltipCut
73493>>>>>        Set psDescription to C_$DescCut
73494>>>>>        Set psImage to "actionCut.ico"
73495>>>>>        Set psShortcut to C_$Key_Ctrl_X
73496>>>>>        Set pbActiveUpdate to True
73497>>>>>        Set psCategory to C_$CategoryEdit
73498>>>>>    End_Procedure
73499>>>>>    
73499>>>>>    
73499>>>>>    Procedure OnExecute Variant vCommandBarControl
73501>>>>>        Send Cut of (focus(Self))
73502>>>>>    End_Procedure
73503>>>>>    
73503>>>>>    Function IsEnabled Returns Boolean
73505>>>>>        Boolean bEnabled
73505>>>>>        Get CanCut of (Focus(Self)) to bEnabled
73506>>>>>        Function_Return bEnabled
73507>>>>>    End_Function
73508>>>>>    
73508>>>>>End_Class
73509>>>>>
73509>>>>>
73509>>>>>Class cCJCopyMenuItem is a cCJMenuItem
73510>>>>>    
73510>>>>>    Procedure Construct_Object
73512>>>>>        Forward Send Construct_Object
73514>>>>>        Set psCaption   to C_$CaptionCopy
73515>>>>>        Set psToolTip to C_$ToolTipCopy
73516>>>>>        Set psDescription to C_$DescCopy
73517>>>>>        Set psImage to "actionCopy.ico"
73518>>>>>        Set psShortcut to C_$Key_Ctrl_C
73519>>>>>        Set pbActiveUpdate to True
73520>>>>>        Set psCategory to C_$CategoryEdit
73521>>>>>    End_Procedure
73522>>>>>    
73522>>>>>    
73522>>>>>    Procedure OnExecute Variant vCommandBarControl
73524>>>>>        Send Copy of (focus(Self))
73525>>>>>    End_Procedure
73526>>>>>    
73526>>>>>    Function IsEnabled Returns Boolean
73528>>>>>        Boolean bEnabled
73528>>>>>        Get CanCopy of (Focus(Self)) to bEnabled
73529>>>>>        Function_Return bEnabled
73530>>>>>    End_Function
73531>>>>>    
73531>>>>>End_Class
73532>>>>>
73532>>>>>
73532>>>>>Class cCJPasteMenuItem is a cCJMenuItem
73533>>>>>    
73533>>>>>    Procedure Construct_Object
73535>>>>>        Forward Send Construct_Object
73537>>>>>        Set psCaption   to C_$CaptionPaste
73538>>>>>        Set psToolTip to C_$ToolTipPaste
73539>>>>>        Set psDescription to C_$DescPaste
73540>>>>>        Set psImage to "actionPaste.ico"
73541>>>>>        Set pbActiveUpdate to True
73542>>>>>        Set psShortcut to C_$Key_Ctrl_V
73543>>>>>        Set psCategory to C_$CategoryEdit
73544>>>>>    End_Procedure
73545>>>>>    
73545>>>>>    
73545>>>>>    Procedure OnExecute Variant vCommandBarControl
73547>>>>>        Send Paste of (focus(Self))
73548>>>>>    End_Procedure
73549>>>>>    
73549>>>>>    Function IsEnabled Returns Boolean
73551>>>>>        Boolean bEnabled
73551>>>>>        Get CanPaste of (Focus(Self)) to bEnabled
73552>>>>>        Function_Return bEnabled
73553>>>>>    End_Function
73554>>>>>    
73554>>>>>End_Class
73555>>>>>
73555>>>>>Class cCJSelectAllMenuItem is a cCJMenuItem
73556>>>>>    
73556>>>>>    Procedure Construct_Object
73558>>>>>        Forward Send Construct_Object
73560>>>>>        Set psCaption   to C_$CaptionSelectAll
73561>>>>>        Set psToolTip to C_$ToolTipSelectAll
73562>>>>>        Set psDescription to C_$DescSelectAll
73563>>>>>        Set pbActiveUpdate to True
73564>>>>>        Set psShortcut to C_$Key_Ctrl_A
73565>>>>>        Set psCategory to C_$CategoryEdit
73566>>>>>    End_Procedure
73567>>>>>    
73567>>>>>    
73567>>>>>    Procedure OnExecute Variant vCommandBarControl
73569>>>>>        Send Select_All of (focus(Self))
73570>>>>>    End_Procedure
73571>>>>>    
73571>>>>>    Function IsEnabled Returns Boolean
73573>>>>>        Boolean bEnabled
73573>>>>>        Get CanSelect of (Focus(Self)) to bEnabled
73574>>>>>        Function_Return bEnabled
73575>>>>>    End_Function
73576>>>>>    
73576>>>>>End_Class
73577>>>>>
73577>>>>>
73577>>>>>Class cCJExitMenuItem is a cCJMenuItem
73578>>>>>    
73578>>>>>    Procedure Construct_Object
73580>>>>>        Forward Send Construct_Object
73582>>>>>        Set psCaption to C_$CaptionExit
73583>>>>>        Set psToolTip to C_$ToolTipExit
73584>>>>>        Set psDescription to C_$ToolTipExit
73585>>>>>        Set psShortcut to C_$Key_Alt_F4
73586>>>>>        Set psCategory to C_$CategoryFile
73587>>>>>    End_Procedure
73588>>>>>    
73588>>>>>    Procedure OnExecute Variant vCommandBarControl
73590>>>>>        Send Exit_Application of Desktop
73591>>>>>    End_Procedure
73592>>>>>    
73592>>>>>End_Class
73593>>>>>
73593>>>>>Class cCJHelpMenuItem is a cCJMenuItem
73594>>>>>    
73594>>>>>    Procedure Construct_Object
73596>>>>>        Forward Send Construct_Object
73598>>>>>        Set psCaption to C_$CaptionHelp
73599>>>>>        Set psDescription to C_$ToolTipHelp
73600>>>>>        Set psToolTip to C_$DescHelp
73601>>>>>        Set psImage to "ActionHelp.ico"
73602>>>>>        Set psShortcut to "F1"
73603>>>>>        Set psCategory to C_$CategoryHelp
73604>>>>>    End_Procedure
73605>>>>>    
73605>>>>>    Procedure OnExecute Variant vCommandBarControl
73607>>>>>        Send Help of (Focus(Self))
73608>>>>>    End_Procedure
73609>>>>>    
73609>>>>>End_Class
73610>>>>>
73610>>>>>Class cCJStatusbarMenuItem is a cCJMenuItem
73611>>>>>    
73611>>>>>    Procedure Construct_Object
73613>>>>>        Forward Send Construct_Object
73615>>>>>        Set psCaption to C_$CaptionAddStatusbar
73616>>>>>        Set psToolTip to C_$ToolTipAddStatusbar
73617>>>>>        Set psDescription to  C_$DescAddStatusbar
73618>>>>>        Set psCategory to C_$CategoryWindow
73619>>>>>    End_Procedure
73620>>>>>    
73620>>>>>    Procedure OnExecute Variant vCommandBarControl
73622>>>>>        Handle hoCommandBars hoClientArea
73622>>>>>        Get CommandBarSystemObject to hoCommandBars
73623>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73624>>>>>        If hoClientArea Begin
73626>>>>>            // the clientarea's parent panel has message
73626>>>>>            Send Toggle_StatusBar of (Parent(hoClientArea))
73627>>>>>        End
73627>>>>>>
73627>>>>>    End_Procedure
73628>>>>>    
73628>>>>>    Function IsChecked Returns Boolean
73630>>>>>        Boolean bOn
73630>>>>>        Handle hoCommandBars hoClientArea
73630>>>>>        Get CommandBarSystemObject to hoCommandBars
73631>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73632>>>>>        If hoClientArea Begin
73634>>>>>            // the clientarea's parent panel has message
73634>>>>>            Get StatusBar_State of (Parent(hoClientArea)) to bOn
73635>>>>>        End
73635>>>>>>
73635>>>>>        Function_Return bOn
73636>>>>>    End_Function
73637>>>>>End_Class
73638>>>>>
73638>>>>>Class cCJAutoArrangeIconsMenuItem is a cCJMenuItem
73639>>>>>    
73639>>>>>    Procedure Construct_Object
73641>>>>>        Forward Send Construct_Object
73643>>>>>        Set psCaption to C_$CaptionAutoArrangeIcons
73644>>>>>        Set psToolTip to C_$ToolTipAutoArrangeIcons
73645>>>>>        Set psDescription to C_$DescAutoArrangeIcons
73646>>>>>        Set psCategory to C_$CategoryWindow
73647>>>>>    End_Procedure
73648>>>>>    
73648>>>>>    Procedure OnExecute Variant vCommandBarControl
73650>>>>>        Handle hoCommandBars hoClientArea
73650>>>>>        Get CommandBarSystemObject to hoCommandBars
73651>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73652>>>>>        If hoClientArea Begin
73654>>>>>            // the clientarea's parent panel has message
73654>>>>>            Send Toggle_Auto_Arrange_Icons of (Parent(hoClientArea))
73655>>>>>        End
73655>>>>>>
73655>>>>>    End_Procedure
73656>>>>>    
73656>>>>>    Function IsChecked Returns Boolean
73658>>>>>        Boolean bOn
73658>>>>>        Handle hoCommandBars hoClientArea
73658>>>>>        Get CommandBarSystemObject to hoCommandBars
73659>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73660>>>>>        If hoClientArea Begin
73662>>>>>            // the clientarea's parent panel has message
73662>>>>>            Get Auto_Arrange_Icons_State of (Parent(hoClientArea)) to bOn
73663>>>>>        End
73663>>>>>>
73663>>>>>        Function_Return bOn
73664>>>>>    End_Function
73665>>>>>End_Class
73666>>>>>
73666>>>>>Class cCJRestoreMenusMenuItem is a cCJMenuItem
73667>>>>>    
73667>>>>>    Procedure Construct_Object
73669>>>>>        Forward Send Construct_Object
73671>>>>>        Set psCaption to C_$CaptionRestoreMenus
73672>>>>>        Set psToolTip to C_$ToolTipRestoreMenus
73673>>>>>        Set psDescription to C_$DescRestoreMenus
73674>>>>>        Set psCategory to C_$CategoryWindow
73675>>>>>    End_Procedure
73676>>>>>    
73676>>>>>    Procedure OnExecute Variant vCommandBarControl
73678>>>>>        Handle hoCommandBars
73678>>>>>        Get CommandBarSystemObject to hoCommandBars
73679>>>>>        Send RestoreLayout of hoCommandBars
73680>>>>>    End_Procedure
73681>>>>>    
73681>>>>>End_Class
73682>>>>>
73682>>>>>Class cCJCascadeMenuItem is a cCJMenuItem
73683>>>>>    
73683>>>>>    Procedure Construct_Object
73685>>>>>        Forward Send Construct_Object
73687>>>>>        Set psCaption to C_$CaptionCascade
73688>>>>>        Set psToolTip to C_$ToolTipCascade
73689>>>>>        Set psDescription to  C_$DescCascade
73690>>>>>        Set psImage to "ActionCascade.ico"
73691>>>>>        Set psCategory to C_$CategoryWindow
73692>>>>>    End_Procedure
73693>>>>>    
73693>>>>>    Procedure OnExecute Variant vCommandBarControl
73695>>>>>        Handle hoCommandBars hoClientArea
73695>>>>>        Get CommandBarSystemObject to hoCommandBars
73696>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73697>>>>>        If hoClientArea Begin
73699>>>>>            Send Cascade_Windows of hoClientArea
73700>>>>>        End
73700>>>>>>
73700>>>>>    End_Procedure
73701>>>>>End_Class
73702>>>>>
73702>>>>>Class cCJTileHorizontally is a cCJMenuItem
73703>>>>>    
73703>>>>>    Procedure Construct_Object
73705>>>>>        Forward Send Construct_Object
73707>>>>>        Set psCaption to C_$CaptionTileHorizontally
73708>>>>>        Set psToolTip to C_$ToolTipTileHorizontally
73709>>>>>        Set psDescription to  C_$DescTileHorizontally
73710>>>>>        Set psImage to "ActionTileHorizontally.ico"
73711>>>>>        Set psCategory to C_$CategoryWindow
73712>>>>>    End_Procedure
73713>>>>>    
73713>>>>>    Procedure OnExecute Variant vCommandBarControl
73715>>>>>        Handle hoCommandBars hoClientArea
73715>>>>>        Get CommandBarSystemObject to hoCommandBars
73716>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73717>>>>>        If hoClientArea Begin
73719>>>>>            Send Tile_Windows_Horizontal of hoClientArea
73720>>>>>        End
73720>>>>>>
73720>>>>>    End_Procedure
73721>>>>>End_Class
73722>>>>>
73722>>>>>Class cCJTileVertically is a cCJMenuItem
73723>>>>>    
73723>>>>>    Procedure Construct_Object
73725>>>>>        Forward Send Construct_Object
73727>>>>>        Set psCaption to C_$CaptionTileVertically
73728>>>>>        Set psToolTip to C_$ToolTipTileVertically
73729>>>>>        Set psDescription to  C_$DescTileVertically
73730>>>>>        Set psImage to "ActionTileVertically.ico"
73731>>>>>        Set psCategory to C_$CategoryWindow
73732>>>>>    End_Procedure
73733>>>>>    
73733>>>>>    Procedure OnExecute Variant vCommandBarControl
73735>>>>>        Handle hoCommandBars hoClientArea
73735>>>>>        Get CommandBarSystemObject to hoCommandBars
73736>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73737>>>>>        If hoClientArea Begin
73739>>>>>            Send Tile_Windows_Vertical of hoClientArea
73740>>>>>        End
73740>>>>>>
73740>>>>>    End_Procedure
73741>>>>>End_Class
73742>>>>>
73742>>>>>Class cCJMinimizeWindowsMenuItem is a cCJMenuItem
73743>>>>>    
73743>>>>>    Procedure Construct_Object
73745>>>>>        Forward Send Construct_Object
73747>>>>>        Set psCaption to C_$CaptionMinimizeWindows
73748>>>>>        Set psToolTip to C_$ToolTipMinimizeWindows
73749>>>>>        Set psDescription to  C_$DescMinimizeWindows
73750>>>>>        Set psCategory to C_$CategoryWindow
73751>>>>>    End_Procedure
73752>>>>>    
73752>>>>>    Procedure OnExecute Variant vCommandBarControl
73754>>>>>        Handle hoCommandBars hoClientArea
73754>>>>>        Get CommandBarSystemObject to hoCommandBars
73755>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73756>>>>>        If hoClientArea Begin
73758>>>>>            // the clientarea's parent panel has message
73758>>>>>            Send Minimize_all_Windows of (Parent(hoClientArea))
73759>>>>>        End
73759>>>>>>
73759>>>>>    End_Procedure
73760>>>>>End_Class
73761>>>>>
73761>>>>>
73761>>>>>Class cCJRestoreWindowsMenuItem is a cCJMenuItem
73762>>>>>    
73762>>>>>    Procedure Construct_Object
73764>>>>>        Forward Send Construct_Object
73766>>>>>        Set psCaption to C_$CaptionRestoreWindows
73767>>>>>        Set psToolTip to C_$ToolTipRestoreWindows
73768>>>>>        Set psDescription to  C_$DescRestoreWindows
73769>>>>>        Set psCategory to C_$CategoryWindow
73770>>>>>    End_Procedure
73771>>>>>    
73771>>>>>    Procedure OnExecute Variant vCommandBarControl
73773>>>>>        Handle hoCommandBars hoClientArea
73773>>>>>        Get CommandBarSystemObject to hoCommandBars
73774>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73775>>>>>        If hoClientArea Begin
73777>>>>>            // the clientarea's parent panel has message
73777>>>>>            Send Restore_all_Windows of (Parent(hoClientArea))
73778>>>>>        End
73778>>>>>>
73778>>>>>    End_Procedure
73779>>>>>End_Class
73780>>>>>
73780>>>>>Class cCJArrangeIconsMenuItem is a cCJMenuItem
73781>>>>>    
73781>>>>>    Procedure Construct_Object
73783>>>>>        Forward Send Construct_Object
73785>>>>>        Set psCaption to C_$CaptionArrangeIcons
73786>>>>>        Set psToolTip to C_$ToolTipArrangeIcons
73787>>>>>        Set psDescription to  C_$DescArrangeIcons
73788>>>>>        Set psCategory to C_$CategoryWindow
73789>>>>>    End_Procedure
73790>>>>>    
73790>>>>>    Procedure OnExecute Variant vCommandBarControl
73792>>>>>        Handle hoCommandBars hoClientArea
73792>>>>>        Get CommandBarSystemObject to hoCommandBars
73793>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73794>>>>>        If hoClientArea Begin
73796>>>>>            Send Arrange_Icons of hoClientArea
73797>>>>>        End
73797>>>>>>
73797>>>>>    End_Procedure
73798>>>>>    
73798>>>>>End_Class
73799>>>Use cCJAboutMenuItem.pkg
Including file: cCJAboutMenuItem.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCJAboutMenuItem.pkg)
73799>>>>>Use cCJCommandBarSystem.pkg
73799>>>>>Use LanguageText.pkg
73799>>>>>
73799>>>>>// It is expected that if you use this class that you provide an about object that is
73799>>>>>// activated via activate_about such as DfAbout.pkg. We don't use this for you automatically
73799>>>>>// because you may wish to create your own custom about package.
73799>>>>>
73799>>>>>Class cCJAboutMenuItem is a cCJMenuItem    
73800>>>>>
73800>>>>>    Procedure Construct_Object
73802>>>>>        Forward Send Construct_Object
73804>>>>>        Set psCaption to C_$CaptionAbout
73805>>>>>        Set psDescription to C_$ToolTipAbout
73806>>>>>        Set psToolTip to C_$DescAbout
73807>>>>>        Set psImage to "ActionAbout.ico"
73808>>>>>        Set psCategory to C_$CategoryHelp
73809>>>>>    End_Procedure
73810>>>>>    
73810>>>>>    Procedure OnExecute Variant vCommandBarControl
73812>>>>>        Handle hoCommandBars hoClientArea
73812>>>>>        Get CommandBarSystemObject to hoCommandBars
73813>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73814>>>>>        If hoClientArea Begin
73816>>>>>            Send Activate_About of hoClientArea
73817>>>>>        End
73817>>>>>>
73817>>>>>    End_Procedure
73818>>>>>
73818>>>>>End_Class
73819>>>>>
73819>>>>>
73819>>>Use cCJDeoMenuItemClasses.pkg
73819>>>Use cCJMDIWindowsMenuItem.pkg
Including file: cCJMDIWindowsMenuItem.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCJMDIWindowsMenuItem.pkg)
73819>>>>>Use cCJCommandBarSystem.pkg
73819>>>>>
73819>>>>>Register_Function Client_ID Returns Integer
73819>>>>>
73819>>>>>// only used by cCJMDIWIndowsMenuItem
73819>>>>>Class cCJMDIWindowItem is a cCJMenuItem
73820>>>>>    
73820>>>>>    Procedure Construct_Object
73822>>>>>        Forward Send Construct_Object
73824>>>>>        Property Handle phWindow 0 // object id of view
73825>>>>>        Set pbControlFlagNoMovable to True
73826>>>>>        Set pbActiveUpdate to True
73827>>>>>    End_Procedure
73828>>>>>    
73828>>>>>    Procedure OnExecute Variant vCommandBarControl
73830>>>>>        Handle hWindow
73830>>>>>        Get phWindow to hWindow
73831>>>>>        Send Activate_View of hWindow
73832>>>>>    End_Procedure
73833>>>>>    
73833>>>>>End_Class
73834>>>>>
73834>>>>>
73834>>>>>Class cCJMDIWindowsMenuItem is a cCJMenuItem
73835>>>>>    
73835>>>>>    Procedure Construct_Object
73837>>>>>        Forward Send Construct_Object
73839>>>>>        Property Handle[] phArrayOfWindows
73840>>>>>        Set peControlType to xtpControlPopup
73841>>>>>        Set psCategory to C_$CategoryWindow
73842>>>>>    End_Procedure
73843>>>>>    
73843>>>>>    // This adds MDI windows to the existing menu items.
73843>>>>>    // This removes any existing windows menus and always adds a new set to the end
73843>>>>>    
73843>>>>>    Procedure OnPopupInit Variant vCommandBarControl Handle hCommandBarControls
73845>>>>>        Handle  hClientArea hView
73845>>>>>        String  sLabel
73845>>>>>        Integer i iWindows
73845>>>>>        Handle[] hArrayOfWindows
73846>>>>>        Variant vItem
73846>>>>>        
73846>>>>>        // delete all windows actions and menu items. Assume we have an array of DF action objects for the windows
73846>>>>>        // also assume that destroying an action removes all menu instances of that action
73846>>>>>        Get phArrayOfWindows to hArrayOfWindows
73847>>>>>        Move (SizeOfArray(hArrayOfWindows)) to iWindows
73848>>>>>        For i from 0 to (iWindows-1)
73854>>>>>>
73854>>>>>            Send Destroy of hArrayOfWindows[i] // assume this removes all menu items of this action
73855>>>>>        Loop
73856>>>>>>
73856>>>>>        Move (ResizeArray(hArrayOfWindows,0)) to hArrayOfWindows
73857>>>>>        
73857>>>>>        // Add all views to this menu. Create the action and add the item
73857>>>>>        Move 0 to i
73858>>>>>        Get Client_Id to hClientArea // object id of client area
73859>>>>>        If (hClientArea > 0) Begin
73861>>>>>            Get Next_Mdi_Dialog of hClientArea True to hView // find first view
73862>>>>>            While (hView <> 0)
73866>>>>>                If (Active_State(hView)) Begin
73868>>>>>                    // create the action
73868>>>>>                    Get Create U_cCJMDIWindowItem to hArrayOfWindows[i]
73869>>>>>                    Get Label of hView to sLabel // caption bar (name) of view
73870>>>>>                    Set psCaption of hArrayOfWindows[i] to sLabel
73871>>>>>                    Set psDescription of hArrayOfWindows[i] to ("Make this view (" - trim(sLabel) - ") the active window.")
73872>>>>>                    If (current_scope(desktop)=hView and View_mode(hView)<>VIEWMODE_ICONIZE) Begin
73874>>>>>                        Set pbChecked of hArrayOfWindows[i] to True
73875>>>>>                    End
73875>>>>>>
73875>>>>>                    Set phWindow of hArrayOfWindows[i] to hView // used by custom OnExecute
73876>>>>>                    If (i=0) Begin
73878>>>>>                        Set pbControlBeginGroup of hArrayOfWindows[i] to True
73879>>>>>                    End
73879>>>>>>
73879>>>>>                    // Create a menu item for this action
73879>>>>>                    Get AddDynamicControl of hArrayOfWindows[i] hCommandBarControls to vItem
73880>>>>>                    Increment i
73881>>>>>                End
73881>>>>>>
73881>>>>>                Get Next_Mdi_Dialog of hClientArea False to hView // find next
73882>>>>>            Loop
73883>>>>>>
73883>>>>>        End
73883>>>>>>
73883>>>>>        
73883>>>>>        Set phArrayOfWindows to hArrayOfWindows
73884>>>>>        
73884>>>>>    End_Procedure
73885>>>>>    
73885>>>>>End_Class
73886>Use cCJCommandBarSystem.pkg
73886>Use Dferror.pkg
73886>Use Colr_dlg.pkg
Including file: Colr_dlg.pkg    (C:\Program Files\DataFlex 24.0\Pkg\Colr_dlg.pkg)
73886>>>Use VDFBase.pkg
73886>>>Use DLL.pkg
73886>>>Use RGB.pkg
73886>>>Use GlobalFunctionsProcedures.pkg
73886>>>
73886>>>Define CC_RGBINIT         for 1
73886>>>Define CC_FULLOPEN        for 2
73886>>>Define CC_PREVENTFULLOPEN for 4
73886>>>
73886>>>// When called directly, lpTemplateName of lpCC must refer to a WString type.
73886>>>External_Function ChooseColorW 'ChooseColorW' COMDLG32.dll Pointer lpCC Returns Integer
73887>>>
73887>>>// Wrapper Function ChooseColor
73887>>>Function ChooseColor Global ;    Pointer lpCC ;    Returns Integer
73889>>>    
73889>>>    // lpCC is a pointer to a ChooseColor struct, which contains a pointer to a string.
73889>>>    // The string must be converted to UTF-16 and afterwards back to UTF-8.
73889>>>    Integer iResult iVoid
73889>>>    Pointer pCC pOrigTemplateName
73889>>>    tWinChooseColor tCC
73889>>>    tWinChooseColor tCC
73889>>>    UWide uwTemplateName
73889>>>    UWide uwTemplateName
73889>>>
73889>>>    // Copy the struct to a local struct that can be modified to UTF-16.
73889>>>    Move (AddressOf(tCC)) to pCC
73890>>>    Move (CopyMemory(pCC, lpCC, SizeOfType(tWinChooseColor))) to iVoid
73891>>>
73891>>>    // Change lpTemplateName to UTF-16. This address is pointing to the original string.
73891>>>    Move tCC.lpTemplateName to pOrigTemplateName
73892>>>    Move (StringToWide(pOrigTemplateName, (&uwTemplateName))) to tCC.lpTemplateName
73893>>>
73893>>>    // Call the function using the local struct
73893>>>    Move (ChooseColorW(pCC)) to iResult
73894>>>    
73894>>>    // The struct is now filled with data. Revert strings back to UTF-8 and then copy the struct back to the original memory location.
73894>>>    
73894>>>    // Copy the string to the original location
73894>>>    Move pOrigTemplateName to tCC.lpTemplateName
73895>>>    Send WideToString (&uwTemplateName) tCC.lpTemplateName 
73896>>>    
73896>>>    // Copy the struct back to the incoming one
73896>>>    Move (CopyMemory(lpCC, pCC, SizeOfType(tWinChooseColor))) to iVoid
73897>>>    
73897>>>    Function_Return iResult
73898>>>End_Function
73899>>>
73899>>>
73899>>>Class ColorDialog is a cObject
73900>>>    Procedure Construct_Object
73902>>>        Integer iLoop
73902>>>        Handle hoCustomColors
73902>>>        
73902>>>        Forward Send Construct_Object
73904>>>        
73904>>>        Property Boolean FullOpen_State        True
73905>>>        Property Boolean PreventFullOpen_State False
73906>>>        Property Boolean SelectedColor_State   True
73907>>>        Property Integer SelectedColor         0
73908>>>        
73908>>>        Property Handle phoCustomColors (Create(Self, U_Array)) // create an array to hold the custom colors
73909>>>        
73909>>>        // Set all custom colors to white...
73909>>>        Get phoCustomColors to hoCustomColors
73910>>>        For iLoop from 0 to 15
73916>>>>
73916>>>            Set Value of hoCustomColors iLoop to clWhite
73917>>>        Loop
73918>>>>
73918>>>        
73918>>>    End_Procedure
73919>>>    
73919>>>    Procedure Set Custom_Color Integer iItem Integer rgbColor
73921>>>        Set Value of (phoCustomColors(Self)) iItem to rgbColor
73922>>>    End_Procedure
73923>>>    
73923>>>    Function Custom_Color Integer iItem Returns Integer
73925>>>        Function_Return (Integer_Value(phoCustomColors(Self), iItem))
73926>>>    End_Function
73927>>>    
73927>>>    Procedure AssignCustomColors Handle hoSourceColorDialog
73929>>>        // Copies the custom colors from another ColorDialog instance
73929>>>        Integer iColor
73929>>>        
73929>>>        For iColor from 0 to 15
73935>>>>
73935>>>            Set Custom_Color iColor to (Value(hoSourceColorDialog, iColor))
73936>>>        Loop
73937>>>>
73937>>>    End_Procedure
73938>>>    
73938>>>    Function Value Integer iItem Returns String
73940>>>        // Provides support for the AssignCustomColors procedure, which requires
73940>>>        // that a "Get Value" interface is supported
73940>>>        Function_Return (Custom_Color(Self, iItem))
73941>>>    End_Function
73942>>>    
73942>>>    Function OwnerHandle Returns Handle
73944>>>        Handle hWnd
73944>>>        Handle hoObj
73944>>>        Get Focus of desktop to hoObj // start with the focus
73945>>>        Move (gOwnerWindowHandle(hoObj)) to hWnd // global function finds the right handle for us
73946>>>        Function_Return hWnd
73947>>>    End_Function
73948>>>    
73948>>>    Function Show_Dialog Returns Boolean
73950>>>        //Shows the dialog. Returns True if the OK button was clicked.
73950>>>        Handle  hContainer hoCustomColors
73950>>>        Boolean bSelected bFullOpen bNoOpen bSelColor
73950>>>        Integer rgbColor iFlags iLoop
73950>>>        String sCC sColors
73950>>>        tWinChooseColor ChseColor
73950>>>        tWinChooseColor ChseColor
73950>>>        
73950>>>        Get OwnerHandle to hContainer
73951>>>        
73951>>>        Get phoCustomColors to hoCustomColors
73952>>>        
73952>>>        Move '' to sColors
73953>>>        For iLoop from 0 to 15
73959>>>>
73959>>>            Get Value of hoCustomColors iLoop to rgbColor
73960>>>            Move (sColors + DWORDToBytes(rgbColor)) to sColors
73961>>>        Loop
73962>>>>
73962>>>        
73962>>>        Get FullOpen_State        to bFullOpen
73963>>>        Get PreventFullOpen_State to bNoOpen
73964>>>        Get SelectedColor_State   to bSelColor
73965>>>        Get SelectedColor         to rgbColor
73966>>>        
73966>>>        Move 0 to iFlags
73967>>>        If bFullOpen ;            Move (iFlags +CC_FULLOPEN)        to iFlags
73970>>>        If bNoOpen ;            Move (iFlags +CC_PREVENTFULLOPEN) to iFlags
73973>>>        If bSelColor ;            Move (iFlags +CC_RGBINIT)         to iFlags
73976>>>        
73976>>>        Move (SizeOfType(tWinChooseColor))     to ChseColor.lStructSize
73977>>>        Move hContainer           to ChseColor.hWndOWner
73978>>>        Move rgbColor             to ChseColor.rgbResult
73979>>>        Move (AddressOf(sColors)) to ChseColor.lpCustColors
73980>>>        Move iFlags               to ChseColor.flags
73981>>>        
73981>>>        Move (ChooseColorW(AddressOf(ChseColor))) to bSelected
73982>>>        
73982>>>        If bSelected Begin
73984>>>            For iLoop from 0 to 15
73990>>>>
73990>>>                Move (DeRefDw(AddressOf(sColors), iLoop *4)) to rgbColor
73991>>>                Set Value of hoCustomColors iLoop to rgbColor
73992>>>            Loop
73993>>>>
73993>>>            Move ChseColor.rgbResult to rgbColor
73994>>>            Set SelectedColor to rgbColor
73995>>>        End
73995>>>>
73995>>>        Function_Return bSelected
73996>>>    End_Function
73997>>>    
73997>>>End_Class
73998>Use Cursor.pkg
73998>Use cDbUpdateHandler.pkg
Including file: cDbUpdateHandler.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateHandler.pkg)
73998>>>//****************************************************************************
73998>>>// $Module type: Class
73998>>>// $Module name: cDbUpdateHandler
73998>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
73998>>>// Web-site    : http://www.rdctools.com
73998>>>// Created     : 2016-09-27 @ 09:33 (Military date format: YY-MM-DD)
73998>>>//
73998>>>// Purpose     : A framework for doing automated code based updates of a database from within
73998>>>//               a program, when it is started.
73998>>>//
73998>>>// Description : Place _one_ object of this class right after the cApplication object.
73998>>>//               Then inside this object place a series of cDbUpdateVersion objects
73998>>>//               as childs. One child object for each new database update.
73998>>>//
73998>>>//               - OnPreUpdate is a pre-processing event called
73998>>>//               before any database changes are started.
73998>>>//               - OnPostUpdate is a post-processing event called after all
73998>>>//               database changes have taken place.
73998>>>//
73998>>>// Note        : If tables have been opened prior to an object of this class
73998>>>//               (e.g. in the cApplication object), those tables will be closed.
73998>>>//               In that case you need to use the OnPostUpdate hook event to re-open
73998>>>//               tables after the last update has finished.
73998>>>//
73998>>>// Security    : Before an update is attempted; three things are checked to ensure the
73998>>>//               database is not in use. Aka nobody else is running the application.
73998>>>//               - All tables are tested for "Open in Exclusive_Mode"
73998>>>//               - The DataFlex license User Count is checked - cannot be more than 1, unless the
73998>>>//                 pbCheckDataFlexUserCount is set to False (Default = True)
73998>>>//               - A special user count file ("DbUpdateUserCount.ucf") is created in the Programs
73998>>>//                 folder and a bit-lock is performed for each start of the application and this
73998>>>//                 user counter is checked before an update is attempted.
73998>>>//                 Important: Even if it seems like both garters & suspenders are used to guard
73998>>>//                            against the database being "in use", there is no such guarantee! The
73998>>>//                            database could e.g. be open in "Microsoft SQL Server Management Studio"
73998>>>//                            and there is no way of telling. SO BE CAUTIOUS before attempting an update!
73998>>>//                 A second "user count file" is also used - "DbUpdateLock.ucf". It is used to
73998>>>//                 lock everybody else out (with a Stop box) while the database is being updated. The lock will
73998>>>//                 automatically be released after the update is completed.
73998>>>//
73998>>>//
73998>>>// Usage       :  Use cDbUpdateHandler.pkg
73998>>>//                Object oDatabaseUpdateHandler is a cDbUpdateHandler
73998>>>//                    // Declare the table that contains a "database version" field.
73998>>>//                    Declare_Datafile Sys
73998>>>//                    // Either one of these syntaxes is fine:
73998>>>//                    Set Data_File_Field to File_Field Sys.DbUpdateVersion
73998>>>//                    Set Data_File_Field to (RefTable(Sys)) (RefTable(Sys.DbUpdateVersion))
73998>>>//
73998>>>//                    // Don't forget to increase the pnVersionNumber property for each
73998>>>//                    // cDbUpdateVersion object!
73998>>>//                    // The VersionTableColumn field/column specified above will be updated automatically
73998>>>//                    // with the value of pnVersionNumber after each update has been finished.
73998>>>//                    Object oVersionUpdate1.1 is a cDbUpdateVersion
73998>>>//                        Set pnVersionNumber to 1.1
73998>>>//                        Use VersionUpdate1_1.pkg
73998>>>//                    End_Object
73998>>>//
73998>>>//                    Object oVersionUpdate1.2 is a cDbUpdateVersion
73998>>>//                        Set pnVersionNumber to 1.2
73998>>>//                        Use VersionUpdate1_2.pkg
73998>>>//                    End_Object
73998>>>//
73998>>>//                End_Object
73998>>>//
73998>>>//
73998>>>// $Rev History:
73998>>>//    2016-09-27  Module header created
73998>>>//    2016-09-28  Removed the Master/Alias logic. All update code must
73998>>>//                take place before any tables have been opened, or errors
73998>>>//                could occur if the client database is out of sync with the
73998>>>//                compiled program.
73998>>>//                Added user counting checks + lockout while database is being
73998>>>//                updated.
73998>>>//    2016-10-03  Changed the class name from cDatabaseUpdateHandler to cDbUpdateHandler,
73998>>>//                as it is more in line with the child class cDbUpdateVersion name.
73998>>>//    2016-10-06  Moved constant declarations, structs etc. to separate cDbUpdateHandler.inc file
73998>>>//****************************************************************************
73998>>>Use VdfBase.pkg
73998>>>Use Dferror.pkg
73998>>>Use seq_chnl.pkg
73998>>>Use Datadict.pkg
73998>>>Use DUFLanguageConstants.inc
Including file: DUFLanguageConstants.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DUFLanguageConstants.inc)
73998>>>>>// *** The Database Update Framework Include file for Languages ***
73998>>>>>// Language constant declarations for all classes included in "DUF - The Database Update Framework"
73998>>>>>// They have all been placed in this central spot to make translations to various languages more convenient.
73998>>>>>//
73998>>>>>Use LanguageText.Pkg
73998>>>>>
73998>>>>>    // *** cSQLConnectionsIniFile.pkg Class Language Constants ***
73998>>>>>    Define CS_DUF_DuplicateConnectionIDPre  for "Cannot register connection ID"
73998>>>>>    Define CS_DUF_DuplicateConnectionIDPost for "This ID already exists."
73998>>>>>    // *** cSQLConnectionsHandler.pkg Class Language Constants ***
73998>>>>>    Define CS_DUF_SetupErrorcConnection     for "Cannot login to the database server as the cConnection hasn't been setup properly. Can't continue. Program will now exit."
73998>>>>>    Define CS_DUF_CannotLoginToServer       for "Could not login to the database server. Can't continue. Program will now exit."
73998>>>>>    Define CS_DUF_ErrorText                 for "\n\nError Text:"
73998>>>>>    // *** cDbUpdateFunctionLibrary.pkg Class Language Constants ***
73998>>>>>    Define CS_DUF_ConnectError              for "SQL error. Could not connect to the SQL database manager"
73998>>>>>    Define CS_DUF_AttachError               for "Could not attach to the database:"
73998>>>>>    Define CS_DUF_DeletingIndex             for "Deleting index"
73998>>>>>    Define CS_DUF_CopyingData               for "Copying data"
73998>>>>>    Define CS_DUF_CreatingIndex             for "Creating index"
73998>>>>>    Define CS_DUF_LoginToDbServerFailed     for  "Login failed to the database server. The following connect string was used:\n"
73998>>>>>    Define CS_DUF_DoYouWantToExit           for "Do you want to stop the database update and exit?"  
73998>>>>>    Define CS_DUF_NoIntFilesFound           for "No .int files found! Nothing was changed."
73998>>>>>    // *** cDbUpdateVersion.pkg Class Language Constants ***
73998>>>>>    Define CS_DUF_UpdateVersion             for "Updating database"
73998>>>>>    Define CS_DUF_UpdateFromVersion         for "from version"
73998>>>>>    Define CS_DUF_UpdateToVersion           for "to version:"
73998>>>>>    Define CS_DUF_DbUpdateTableMissing      for "Cannot open the 'DbVersion' table that is used when updating the database! Cannot continue!"
73998>>>>>    // *** cDbUpdateHandler.inc Language Constants ***
73998>>>>>    Define CS_DUF_DatabaseInUseShort        for "There are others using the application/database. Are you sure you still want to update the database?"
73998>>>>>    Define CS_DUF_DatabaseNeedsUpdate       for ("The database needs to be updated." + "\n\nATTENTION! The database may not be in use while this work is performed. Make sure that nobody else is using the application before clicking 'Yes' below.\n\n" + "Start update now?")
73998>>>>>    Define CS_DUF_HeaderUpdateText          for "Important!"
73998>>>>>    Define CS_DUF_DatabaseInUseText         for "There are others using the application/database or at least one table could NOT be opened exclusively. Please close all other applications using the database and try again. The Application will now close."
73998>>>>>    Define CS_DUF_WorkingHeaderText         for "Working!"
73998>>>>>    Define CS_DUF_WorkingUpdateText         for "The database is being updated. Please wait..."
73998>>>>>    Define CS_DUF_DatabaseUpdatedText       for "Ready! The database was updated."
73998>>>>>    Define CS_DUF_DatabaseCheckedText       for "Ready! The database was checked but no updates was needed."
73998>>>>>    Define CS_DUF_DbUpdatedErrorText        for "One or more errors occured while the database was updated. Please check the logfile in the data-folder.\n\nThe program will now close."
73998>>>>>    Define CS_DUF_UpdateInProgressTxt       for ("System locked!\n\nThe database is being updated. Please try again later...\n\n" * "The program will now close.")
73998>>>>>    // *** cDbUpdateHandler.pkg Class Language Constants ***
73998>>>>>    Define CS_DUF_DatabaseConnStringSpec    for "The database specified in the connection string: '"
73998>>>>>    Define CS_DUF_DatabaseDoesntExist       for "' doesn't exist!\n\nYou need to create it with a database management software or by using the 'SqlDatabaseCreate' function, which can be used in the 'OnPreUpdate' event of the cDbUpdateHandler object.\n\nThe program will now exit."
73998>>>>>    // *** cDbUpdateLogFile.pkg Class Language Constants ***   
73998>>>>>    Define CS_DUF_LogFileNotFound           for "Could not locate the log file:\n\n"
73998>>>>>
73998>>>>>
73998>>>>>
73998>>>>>
73998>>>>>
73998>>>>>
73998>>>>>
73998>>>>>
73998>>>>>
73998>>>>>
73998>>>>>
73998>>>>>
73998>>>Use DUFStatusPanel.pkg
Including file: DUFStatusPanel.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DUFStatusPanel.pkg)
73998>>>>>// StatPnl.pkg - creates the standard status_panel object.
73998>>>>>//
73998>>>>>//
73998>>>>>// This is the default Status Panel object used by any of the Visual DataFlex classes that
73998>>>>>// invoke the standard status panel. The standard has always been that the package name
73998>>>>>// is StatPnl.pkg and the name of the object is Status_Panel. As of 12.0, there are major
73998>>>>>// changes in the way the status panel operates The Sentinel based external status panel used in
73998>>>>>// prior revisions has been replace with status panel that is part of the application.
73998>>>>>// This should work much better and faster than the old sentinel based solution.
73998>>>>>// While the way this operates has changed, the interface has not and therefore this should work
73998>>>>>// with most applications.
73998>>>>>//
73998>>>>>// As of 12.0, we have added a global handle that contains the object ID of this status panel.
73998>>>>>// This variable ghoStatusPanel can be used in place of the object name Status_Panel. This provides
73998>>>>>// a cleaner more robust interface.
73998>>>>>//
73998>>>>>//
73998>>>>>// Compatibility Note:
73998>>>>>//
73998>>>>>// When used in the standard way, this change will require no changes. A developer will only need to
73998>>>>>// change their code if they've modified the sentinel program, which was a difficult thing to do.
73998>>>>>//
73998>>>>>// If for some reason you application will not work using this as a replacement for the old status
73998>>>>>// panel, you've probably done something special with the old status-panel. If you don't want to
73998>>>>>// figure out how to use the new one and you want to continue using the old one you are going to need
73998>>>>>// to add some code to include the old status panel in your application. Add the following to your project (your src).
73998>>>>>//
73998>>>>>// Use StatPnl.pkg    // Make sure you load the new status panel object first. this is not optional!
73998>>>>>// Use OldStatPnl.pkg // load the old status panel. Status_Panel is now this old object
73998>>>>>//
73998>>>>>// If you do this, you will lose access to the new status-panel via Status_Panel. However, you
73998>>>>>// can still access the new object via the ghoStatusPanel handle.
73998>>>>>//
73998>>>>>//
73998>>>>>// Creating your own Status Panel objects
73998>>>>>//
73998>>>>>// If a developer wishes to create a custom panel, they should use this package as their template.
73998>>>>>// This panel can be visually modeled and changed any way you wish. Just save your new custom panel
73998>>>>>// with a different file and object name and direct your status panel request to the new object.
73998>>>>>//
73998>>>>>// If the new panel changes the interface and updates objects that are not currently defined, you
73998>>>>>// want to make sure you send the message ProcessEvents after you've updated the object. This allows
73998>>>>>// the object to paint when inside of a tight loop. For example, if you wanted to add a progress
73998>>>>>// bar (cProgressBar) you would want to Send ProcessEvents after you update the progress bar.
73998>>>>>// e.g.
73998>>>>>//       Procedure UpdateStatusBar
73998>>>>>//           Send DoAdvance of oProgressBar
73998>>>>>//           Send ProcessEvents
73998>>>>>//       End_Procedure
73998>>>>>//
73998>>>>>// of course, if you use the standard interfaces in status bar and your forward send these
73998>>>>>// messages this will be done for you.
73998>>>>>//
73998>>>>>// the standard Interface for status panels are:
73998>>>>>//
73998>>>>>// Send Initialize_StatusPanel - initializes values for caption, title & message
73998>>>>>// Send Start_StatusPanel      - start the status panel
73998>>>>>// Send Stop_StatusPanel       - stop the status panel
73998>>>>>// Send Update_StatusPanel     - update the status panel's action area
73998>>>>>// Get  Check_StatusPanel      - check for cancel (if cancel or pbCancel is set, close the panel)
73998>>>>>//
73998>>>>>// Get/Set Caption_Text - updates the caption bar
73998>>>>>// Get/Set Title_Text   - updates the title area
73998>>>>>// Get/Set Message_Text - updates the Message area
73998>>>>>// Get/Set Action_Text  - updates the action area
73998>>>>>// Get/Set Button_Text  - updates the button area
73998>>>>>//
73998>>>>>// Get/Set Allow_cancel_state - determines if panel can be canceled
73998>>>>>// Send EnableCancelButton - code you should provide to enable/disable cancel button
73998>>>>>//
73998>>>>>// ghoStatusPanel - global handle that points to the standard status panel.
73998>>>>>Use cProcessStatusPanel.pkg
73998>>>>>Use cCJSkinFramework.pkg
Including file: cCJSkinFramework.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCJSkinFramework.pkg)
73998>>>>>>>Use windows.pkg
73998>>>>>>>Use cCJComSkinFramework.pkg
Including file: cCJComSkinFramework.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCJComSkinFramework.pkg)
73998>>>>>>>>>// DataFlex COM proxy classes generated from C:\Program Files (x86)\Codejock Software\ActiveX\Xtreme SuitePro ActiveX v22.0.0\Bin\Codejock.SkinFramework.Unicode.x64.v22.0.0.ocx
73998>>>>>>>>>Use FlexCom20.pkg
73998>>>>>>>>>
73998>>>>>>>>>// Changes to Imported package
73998>>>>>>>>>//     OLEXTPxx to XTPxx
73998>>>>>>>>>//     OLExtpxx to xtpxx
73998>>>>>>>>>//     OLESkinFramework to SkinFramework
73998>>>>>>>>>//     OLESTDxxx and OLEXPxxxx to STD/XP
73998>>>>>>>>>//     cCom classes to cCJ
73998>>>>>>>>>//     cCJAutomationObject back to cComAutomationObject
73998>>>>>>>>>//     cCJActiveXControl back to cComActiveXControl
73998>>>>>>>>>//     cCJSkinFramework to cCJComSkinFramework
73998>>>>>>>>>//     Use statements as noted below (classes moved to these files)
73998>>>>>>>>>//     Set classlibrary of all cComAutomation objects to Windows (for class doc)
73998>>>>>>>>>
73998>>>>>>>>>// These have been extracted from this class and moved into seperate packages
73998>>>>>>>>>// because other Codejock classes use these.
73998>>>>>>>>>Use cCJColorManager.pkg     // cCJColorManager
73998>>>>>>>>>
73998>>>>>>>>>
73998>>>>>>>>>Define SkinFrameworkApplyOptions for Integer
73998>>>>>>>>>    Define xtpSkinApplyMetrics for 1
73998>>>>>>>>>    Define xtpSkinApplyFrame for 2
73998>>>>>>>>>    Define xtpSkinApplyColors for 4
73998>>>>>>>>>    Define xtpSkinApplyMenus for 8
73998>>>>>>>>>
73998>>>>>>>>>// CLSID: {C0DE2200-28D7-4F2C-87A7-7266367B4655}
73998>>>>>>>>>// Dispatch interface for SkinFramework Control
73998>>>>>>>>>Class cCJ_DSkinFramework is a Mixin
73999>>>>>>>>>
73999>>>>>>>>>    Function ComApplyOptions Returns SkinFrameworkApplyOptions
74001>>>>>>>>>        SkinFrameworkApplyOptions retVal
74001>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to retVal
74002>>>>>>>>>        Function_Return retVal
74003>>>>>>>>>    End_Function
74004>>>>>>>>>
74004>>>>>>>>>    Procedure Set ComApplyOptions SkinFrameworkApplyOptions value
74006>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to value
74007>>>>>>>>>    End_Procedure
74008>>>>>>>>>
74008>>>>>>>>>    Function ComAutoApplyNewWindows Returns Boolean
74010>>>>>>>>>        Boolean retVal
74010>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to retVal
74011>>>>>>>>>        Function_Return retVal
74012>>>>>>>>>    End_Function
74013>>>>>>>>>
74013>>>>>>>>>    Procedure Set ComAutoApplyNewWindows Boolean value
74015>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to value
74016>>>>>>>>>    End_Procedure
74017>>>>>>>>>
74017>>>>>>>>>    Function ComAutoApplyNewThreads Returns Boolean
74019>>>>>>>>>        Boolean retVal
74019>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to retVal
74020>>>>>>>>>        Function_Return retVal
74021>>>>>>>>>    End_Function
74022>>>>>>>>>
74022>>>>>>>>>    Procedure Set ComAutoApplyNewThreads Boolean value
74024>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to value
74025>>>>>>>>>    End_Procedure
74026>>>>>>>>>
74026>>>>>>>>>    Function ComLoadSkin String llResourcePath String llIniFileName Returns Boolean
74028>>>>>>>>>        Handle hDispatchDriver
74028>>>>>>>>>        Boolean retVal
74028>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74029>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
74030>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
74031>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
74032>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_BOOL to retVal
74033>>>>>>>>>        Function_Return retVal
74034>>>>>>>>>    End_Function
74035>>>>>>>>>
74035>>>>>>>>>    Procedure ComApplyWindow OLE_HANDLE llhWnd
74037>>>>>>>>>        Handle hDispatchDriver
74037>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74038>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
74039>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
74040>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 3 OLE_VT_VOID
74041>>>>>>>>>    End_Procedure
74042>>>>>>>>>
74042>>>>>>>>>    Procedure ComEnableThemeDialogTexture OLE_HANDLE llhWnd Integer llFlags
74044>>>>>>>>>        Handle hDispatchDriver
74044>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74045>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
74046>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
74047>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llFlags
74048>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 4 OLE_VT_VOID
74049>>>>>>>>>    End_Procedure
74050>>>>>>>>>
74050>>>>>>>>>    Procedure ComRemoveWindow OLE_HANDLE llhWnd
74052>>>>>>>>>        Handle hDispatchDriver
74052>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74053>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
74054>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
74055>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 6 OLE_VT_VOID
74056>>>>>>>>>    End_Procedure
74057>>>>>>>>>
74057>>>>>>>>>    Procedure ComRemoveAllWindows
74059>>>>>>>>>        Handle hDispatchDriver
74059>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74060>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 7 OLE_VT_VOID
74061>>>>>>>>>    End_Procedure
74062>>>>>>>>>
74062>>>>>>>>>    Procedure ComAddWindowClass String llClassName String llBaseClassName
74064>>>>>>>>>        Handle hDispatchDriver
74064>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74065>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
74066>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
74067>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llBaseClassName
74068>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 8 OLE_VT_VOID
74069>>>>>>>>>    End_Procedure
74070>>>>>>>>>
74070>>>>>>>>>    Procedure ComRemoveWindowClass String llClassName
74072>>>>>>>>>        Handle hDispatchDriver
74072>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74073>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
74074>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
74075>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 9 OLE_VT_VOID
74076>>>>>>>>>    End_Procedure
74077>>>>>>>>>
74077>>>>>>>>>    Function ComEnumerateSkinDirectory String llPath Boolean llRecursive Returns Variant
74079>>>>>>>>>        Handle hDispatchDriver
74079>>>>>>>>>        Variant retVal
74079>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74080>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
74081>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
74082>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BOOL llRecursive
74083>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 11 OLE_VT_DISPATCH to retVal
74084>>>>>>>>>        Function_Return retVal
74085>>>>>>>>>    End_Function
74086>>>>>>>>>
74086>>>>>>>>>    Function ComEnumerateSkinFile String llPath Returns Variant
74088>>>>>>>>>        Handle hDispatchDriver
74088>>>>>>>>>        Variant retVal
74088>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74089>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
74090>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
74091>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 12 OLE_VT_DISPATCH to retVal
74092>>>>>>>>>        Function_Return retVal
74093>>>>>>>>>    End_Function
74094>>>>>>>>>
74094>>>>>>>>>    Function ComGetColor XTPColorManagerColor llIndex Returns OLE_COLOR
74096>>>>>>>>>        Handle hDispatchDriver
74096>>>>>>>>>        OLE_COLOR retVal
74096>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74097>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
74098>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
74099>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 14 OLE_VT_I4 to retVal
74100>>>>>>>>>        Function_Return retVal
74101>>>>>>>>>    End_Function
74102>>>>>>>>>
74102>>>>>>>>>    Procedure ComExcludeModule String llModuleName
74104>>>>>>>>>        Handle hDispatchDriver
74104>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74105>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
74106>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llModuleName
74107>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 15 OLE_VT_VOID
74108>>>>>>>>>    End_Procedure
74109>>>>>>>>>
74109>>>>>>>>>    Function ComCreateSchema String llResourcePath String llIniFileName Returns Variant
74111>>>>>>>>>        Handle hDispatchDriver
74111>>>>>>>>>        Variant retVal
74111>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74112>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
74113>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
74114>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
74115>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 16 OLE_VT_DISPATCH to retVal
74116>>>>>>>>>        Function_Return retVal
74117>>>>>>>>>    End_Function
74118>>>>>>>>>
74118>>>>>>>>>    Procedure ComSetWindowTheme OLE_HANDLE llhWnd Variant llSchema
74120>>>>>>>>>        Handle hDispatchDriver
74120>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74121>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
74122>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
74123>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llSchema
74124>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 17 OLE_VT_VOID
74125>>>>>>>>>    End_Procedure
74126>>>>>>>>>
74126>>>>>>>>>    Procedure ComAboutBox
74128>>>>>>>>>        Handle hDispatchDriver
74128>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74129>>>>>>>>>        Send InvokeComMethod to hDispatchDriver -552 OLE_VT_VOID
74130>>>>>>>>>    End_Procedure
74131>>>>>>>>>End_Class
74132>>>>>>>>>
74132>>>>>>>>>// CLSID: {C0DE2200-4463-4030-B324-AC6A8075FEC8}
74132>>>>>>>>>// Event interface for SkinFramework Control
74132>>>>>>>>>Class cCJ_DSkinFrameworkEvents is a Mixin
74133>>>>>>>>>
74133>>>>>>>>>    Procedure RegisterComEvents
74135>>>>>>>>>    End_Procedure
74136>>>>>>>>>End_Class
74137>>>>>>>>>
74137>>>>>>>>>// CoClass
74137>>>>>>>>>// ProgID: Codejock.SkinFramework.22.0.0
74137>>>>>>>>>// CLSID: {C0DE2200-2217-42EE-B1B0-82C890431F17}
74137>>>>>>>>>// SkinFramework Control
74137>>>>>>>>>Class cCJComSkinFramework is a cComActiveXControl
74138>>>>>>>>>    Import_Class_Protocol cCJ_DSkinFramework
74139>>>>>>>>>    Import_Class_Protocol cCJ_DSkinFrameworkEvents
74140>>>>>>>>>
74140>>>>>>>>>    Procedure Construct_Object
74142>>>>>>>>>        Forward Send Construct_Object
74144>>>>>>>>>        Set psProgID to "{C0DE2200-2217-42EE-B1B0-82C890431F17}"
74145>>>>>>>>>        Set psEventId to "{C0DE2200-4463-4030-B324-AC6A8075FEC8}"
74146>>>>>>>>>        Set psLicenseKey to ("Skin Framework Control Copyright (c) 1998-2022 Codejock Software"+ Character(13)+ Character(10)+;                             "PRODUCT-ID: Codejock.SkinFramework.ActiveX.v22.0"+ Character(13)+ Character(10)+;                             "VALIDATE-CODE: GGE-OLD-QQR-EJS")
74147>>>>>>>>>        Set peAutoCreate to acAutoCreate
74148>>>>>>>>>    End_Procedure
74149>>>>>>>>>End_Class
74150>>>>>>>>>
74150>>>>>>>>>// CLSID: {C0DE2200-CA9A-4AA9-8601-0AB7F551AA3D}
74150>>>>>>>>>// SkinFramework Global Settings
74150>>>>>>>>>Class cCJISkinFrameworkGlobalSettings is a Mixin
74151>>>>>>>>>
74151>>>>>>>>>    Function ComLicense Returns String
74153>>>>>>>>>        String retVal
74153>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to retVal
74154>>>>>>>>>        Function_Return retVal
74155>>>>>>>>>    End_Function
74156>>>>>>>>>
74156>>>>>>>>>    Procedure Set ComLicense String value
74158>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to value
74159>>>>>>>>>    End_Procedure
74160>>>>>>>>>
74160>>>>>>>>>    Function ComTitle Returns String
74162>>>>>>>>>        String retVal
74162>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to retVal
74163>>>>>>>>>        Function_Return retVal
74164>>>>>>>>>    End_Function
74165>>>>>>>>>
74165>>>>>>>>>    Procedure Set ComTitle String value
74167>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to value
74168>>>>>>>>>    End_Procedure
74169>>>>>>>>>
74169>>>>>>>>>    // Set this value to True to force using legacy SkinFramework core that has been in use up to version 19
74169>>>>>>>>>    Function ComUseLegacyCore Returns Boolean
74171>>>>>>>>>        Boolean retVal
74171>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 110 OLE_VT_BOOL to retVal
74172>>>>>>>>>        Function_Return retVal
74173>>>>>>>>>    End_Function
74174>>>>>>>>>
74174>>>>>>>>>    // Set this value to True to force using legacy SkinFramework core that has been in use up to version 19
74174>>>>>>>>>    Procedure Set ComUseLegacyCore Boolean value
74176>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 110 OLE_VT_BOOL to value
74177>>>>>>>>>    End_Procedure
74178>>>>>>>>>
74178>>>>>>>>>    Function ComVersion Returns String
74180>>>>>>>>>        Handle hDispatchDriver
74180>>>>>>>>>        String retVal
74180>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74181>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 104 OLE_VT_BSTR to retVal
74182>>>>>>>>>        Function_Return retVal
74183>>>>>>>>>    End_Function
74184>>>>>>>>>
74184>>>>>>>>>    Function ComUnicode Returns Boolean
74186>>>>>>>>>        Handle hDispatchDriver
74186>>>>>>>>>        Boolean retVal
74186>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74187>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 105 OLE_VT_BOOL to retVal
74188>>>>>>>>>        Function_Return retVal
74189>>>>>>>>>    End_Function
74190>>>>>>>>>
74190>>>>>>>>>    Function ComOcxPath Returns String
74192>>>>>>>>>        Handle hDispatchDriver
74192>>>>>>>>>        String retVal
74192>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74193>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 106 OLE_VT_BSTR to retVal
74194>>>>>>>>>        Function_Return retVal
74195>>>>>>>>>    End_Function
74196>>>>>>>>>End_Class
74197>>>>>>>>>
74197>>>>>>>>>// CoClass
74197>>>>>>>>>// ProgID: Codejock.SkinFrameworkGlobalSettings.22.0.0
74197>>>>>>>>>// CLSID: {C0DE2200-F744-4373-B38D-29CE83EF0EE5}
74197>>>>>>>>>// SkinFramework Global Settings
74197>>>>>>>>>Class cCJComSkinFrameworkGlobalSettings is a cComAutomationObject
74198>>>>>>>>>    Import_Class_Protocol cCJISkinFrameworkGlobalSettings
74199>>>>>>>>>
74199>>>>>>>>>    Procedure Construct_Object
74201>>>>>>>>>        Forward Send Construct_Object
74203>>>>>>>>>        Set psProgID to "{C0DE2200-F744-4373-B38D-29CE83EF0EE5}"
74204>>>>>>>>>        Set peAutoCreate to acNoAutoCreate
74205>>>>>>>>>    End_Procedure
74206>>>>>>>>>End_Class
74207>>>>>>>>>
74207>>>>>>>>>// CLSID: {C0DE2200-1038-498E-A936-361F08B4C4AA}
74207>>>>>>>>>Class cCJSkinIniFile is a cComAutomationObject
74208>>>>>>>>>
74208>>>>>>>>>    Function ComColorScheme Returns String
74210>>>>>>>>>        String retVal
74210>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
74211>>>>>>>>>        Function_Return retVal
74212>>>>>>>>>    End_Function
74213>>>>>>>>>
74213>>>>>>>>>    Procedure Set ComColorScheme String value
74215>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
74216>>>>>>>>>    End_Procedure
74217>>>>>>>>>
74217>>>>>>>>>    Function ComFontSize Returns String
74219>>>>>>>>>        String retVal
74219>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
74220>>>>>>>>>        Function_Return retVal
74221>>>>>>>>>    End_Function
74222>>>>>>>>>
74222>>>>>>>>>    Procedure Set ComFontSize String value
74224>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
74225>>>>>>>>>    End_Procedure
74226>>>>>>>>>
74226>>>>>>>>>    Function ComIniFileName Returns String
74228>>>>>>>>>        String retVal
74228>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to retVal
74229>>>>>>>>>        Function_Return retVal
74230>>>>>>>>>    End_Function
74231>>>>>>>>>
74231>>>>>>>>>    Procedure Set ComIniFileName String value
74233>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to value
74234>>>>>>>>>    End_Procedure
74235>>>>>>>>>End_Class
74236>>>>>>>>>
74236>>>>>>>>>// CLSID: {C0DE2200-4834-499E-95B4-30E0C3F43A10}
74236>>>>>>>>>Class cCJSkinDescription is a cComAutomationObject
74237>>>>>>>>>
74237>>>>>>>>>    Function ComName Returns String
74239>>>>>>>>>        String retVal
74239>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
74240>>>>>>>>>        Function_Return retVal
74241>>>>>>>>>    End_Function
74242>>>>>>>>>
74242>>>>>>>>>    Procedure Set ComName String value
74244>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
74245>>>>>>>>>    End_Procedure
74246>>>>>>>>>
74246>>>>>>>>>    Function ComPath Returns String
74248>>>>>>>>>        String retVal
74248>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
74249>>>>>>>>>        Function_Return retVal
74250>>>>>>>>>    End_Function
74251>>>>>>>>>
74251>>>>>>>>>    Procedure Set ComPath String value
74253>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
74254>>>>>>>>>    End_Procedure
74255>>>>>>>>>
74255>>>>>>>>>    Function ComCount Returns Integer
74257>>>>>>>>>        Handle hDispatchDriver
74257>>>>>>>>>        Integer retVal
74257>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74258>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
74259>>>>>>>>>        Function_Return retVal
74260>>>>>>>>>    End_Function
74261>>>>>>>>>
74261>>>>>>>>>    Function ComIniFile Integer llIndex Returns Variant
74263>>>>>>>>>        Handle hDispatchDriver
74263>>>>>>>>>        Variant retVal
74263>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74264>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
74265>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
74266>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
74267>>>>>>>>>        Function_Return retVal
74268>>>>>>>>>    End_Function
74269>>>>>>>>>
74269>>>>>>>>>    Function Com_NewEnum Returns Variant
74271>>>>>>>>>        Handle hDispatchDriver
74271>>>>>>>>>        Variant retVal
74271>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74272>>>>>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
74273>>>>>>>>>        Function_Return retVal
74274>>>>>>>>>    End_Function
74275>>>>>>>>>End_Class
74276>>>>>>>>>
74276>>>>>>>>>// CLSID: {C0DE2200-FB37-4B08-A2B9-F6F8B253D697}
74276>>>>>>>>>Class cCJSkinDescriptions is a cComAutomationObject
74277>>>>>>>>>
74277>>>>>>>>>    Function ComCount Returns Integer
74279>>>>>>>>>        Handle hDispatchDriver
74279>>>>>>>>>        Integer retVal
74279>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74280>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
74281>>>>>>>>>        Function_Return retVal
74282>>>>>>>>>    End_Function
74283>>>>>>>>>
74283>>>>>>>>>    Function ComSkin Integer llIndex Returns Variant
74285>>>>>>>>>        Handle hDispatchDriver
74285>>>>>>>>>        Variant retVal
74285>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74286>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
74287>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
74288>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
74289>>>>>>>>>        Function_Return retVal
74290>>>>>>>>>    End_Function
74291>>>>>>>>>
74291>>>>>>>>>    Function Com_NewEnum Returns Variant
74293>>>>>>>>>        Handle hDispatchDriver
74293>>>>>>>>>        Variant retVal
74293>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74294>>>>>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
74295>>>>>>>>>        Function_Return retVal
74296>>>>>>>>>    End_Function
74297>>>>>>>>>End_Class
74298>>>>>>>>>
74298>>>>>>>>>// CLSID: {C0DE2200-C56F-43C0-BCF1-8193B35FE4C4}
74298>>>>>>>>>Class cCJSkinSchema is a cComAutomationObject
74299>>>>>>>>>
74299>>>>>>>>>    Function ComGetColor XTPColorManagerColor llIndex Returns OLE_COLOR
74301>>>>>>>>>        Handle hDispatchDriver
74301>>>>>>>>>        OLE_COLOR retVal
74301>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
74302>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
74303>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
74304>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_I4 to retVal
74305>>>>>>>>>        Function_Return retVal
74306>>>>>>>>>    End_Function
74307>>>>>>>>>End_Class
74308>>>>>>>Use cApplication.pkg
74308>>>>>>>
74308>>>>>>>Struct tSkinInformation
74308>>>>>>>    String sName     // description of the skin
74308>>>>>>>    String sSkinfile // file path. Can be relative or full
74308>>>>>>>    String sSkinIni  // section name
74308>>>>>>>End_Struct
74308>>>>>>>
74308>>>>>>>
74308>>>>>>>Class cCJSkinFramework is a cCJComSkinFramework
74309>>>>>>>    
74309>>>>>>>    Procedure Construct_Object
74311>>>>>>>        Forward Send Construct_Object
74313>>>>>>>        
74313>>>>>>>        Property String psSkinFile ""
74314>>>>>>>        Property String psSkinIni ""
74315>>>>>>>        Property Boolean pbLoadPreference False
74316>>>>>>>        
74316>>>>>>>        Set peAutoCreate to acAutoCreate
74317>>>>>>>        
74317>>>>>>>        Move Self to ghoSkinFramework
74318>>>>>>>    End_Procedure
74319>>>>>>>    
74319>>>>>>>    // return the default skin path, which is the programs directory.
74319>>>>>>>    // This requires an application object.
74319>>>>>>>    // If you want to different skin path, override this.
74319>>>>>>>    Function SkinPath Returns String
74321>>>>>>>        String sPath sPaths
74321>>>>>>>        Handle hoWorkspace
74321>>>>>>>        If ghoApplication Begin
74323>>>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
74324>>>>>>>            Get psProgramPath of hoWorkspace to sPaths
74325>>>>>>>            Get PathAtIndex of hoWorkspace sPaths 1 to sPath
74326>>>>>>>        End
74326>>>>>>>>
74326>>>>>>>        Else Begin
74327>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
74328>>>>>>>>
74328>>>>>>>        End
74328>>>>>>>>
74328>>>>>>>        Function_Return sPath
74329>>>>>>>    End_Function
74330>>>>>>>    
74330>>>>>>>    // Returns the Qualified name of psSkinFile. If the file is already qualified it just
74330>>>>>>>    // returns itself. If it is not, it uses SkinPath to get the path.
74330>>>>>>>    Function SkinQFile Returns String
74332>>>>>>>        String sFile sPath sSep
74332>>>>>>>        Boolean bQualified
74332>>>>>>>        Get psSkinFile to sFile
74333>>>>>>>        If not (IsFileNameQualified(sFile)) Begin
74335>>>>>>>            Get SkinPath to sPath
74336>>>>>>>            Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
74337>>>>>>>            Move (sPath - sSep - sFile) to sFile
74338>>>>>>>        End
74338>>>>>>>>
74338>>>>>>>        Function_Return sFile
74339>>>>>>>    End_Function
74340>>>>>>>    
74340>>>>>>>    // defines the default VDF window class mapping.
74340>>>>>>>    Procedure OnAddVDFWindowClasses
74342>>>>>>>        Send ComAddWindowClass "DFlistbox"               "ListBox"
74343>>>>>>>        Send ComAddWindowClass "DFentry"                 "Edit"
74344>>>>>>>        Send ComAddWindowClass "DFtextbox"               "Edit"
74345>>>>>>>        Send ComAddWindowClass "DFRichEditCtrl"          "Edit"
74346>>>>>>>        Send ComAddWindowClass "DFcombobox"              "ComboBox"
74347>>>>>>>        Send ComAddWindowClass "DFformlist"              "Edit"
74348>>>>>>>        Send ComAddWindowClass "DFFormListHeader"        "SysHeader32"
74349>>>>>>>        Send ComAddWindowClass "DFbutton"                "Button"
74350>>>>>>>        Send ComAddWindowClass "HPromptBtn"              "Button"
74351>>>>>>>        Send ComAddWindowClass "Hspinbtn"                "msctls_updown32"
74352>>>>>>>        Send ComAddWindowClass "DFSysTabControl32"       "SysTabControl32"
74353>>>>>>>        Send ComAddWindowClass "DFMDIClient"             "MDIClient"
74354>>>>>>>        Send ComAddWindowClass "DFedit"                  "edit"
74355>>>>>>>        Send ComAddWindowClass "DFlistedit"              "edit"
74356>>>>>>>        Send ComAddWindowClass "DFscrollbar"             "scrollbar"
74357>>>>>>>        Send ComAddWindowClass "DFgroup"                 "Button"
74358>>>>>>>        Send ComAddWindowClass "DFComboGrid"             "ComboBox"
74359>>>>>>>        // External class
74359>>>>>>>        Send ComAddWindowClass "cVdfAnimation"           "SysAnimate32"
74360>>>>>>>        Send ComAddWindowClass "cVdfProgressBar"         "msctls_progress32"
74361>>>>>>>        Send ComAddWindowClass "cVdfStatusBar"           "msctls_statusbar32"
74362>>>>>>>        Send ComAddWindowClass "cVdfToolbar"             "ToolbarWindow32"
74363>>>>>>>        Send ComAddWindowClass "cObsoleteVdfProgressBar" "msctls_progress32"
74364>>>>>>>        Send ComAddWindowClass "cVdfTrackBar"            "msctls_trackbar32"
74365>>>>>>>        Send ComAddWindowClass "cObsoleteBasicStatusBar" "msctls_statusbar32"
74366>>>>>>>        Send ComAddWindowClass "cVdfTreeView"            "SysTreeView32"
74367>>>>>>>    End_Procedure
74368>>>>>>>    
74368>>>>>>>    // Used to support developer designed class mappings (e.g. COM controls)
74368>>>>>>>    Procedure OnAddCustomWindowClasses
74370>>>>>>>    End_Procedure
74371>>>>>>>    
74371>>>>>>>    // called when object is created during end_construct_object.
74371>>>>>>>    Procedure OnCreate
74373>>>>>>>        Integer iOpts
74373>>>>>>>        Boolean bUseWindowsFont
74373>>>>>>>        Forward Send OnCreate
74375>>>>>>>        
74375>>>>>>>        // if we are using the windows fonts we will disable the apply metrics which
74375>>>>>>>        // never really looked good anyway. This test only exists or legacy purposes
74375>>>>>>>        Get pbUseWindowsFont of Desktop to bUseWindowsFont
74376>>>>>>>        If bUseWindowsFont Begin
74378>>>>>>>            Get ComApplyOptions to iOpts
74379>>>>>>>            Set ComApplyOptions to (RemoveBitValue(xtpSkinApplyMetrics, iOpts))
74380>>>>>>>        End
74380>>>>>>>>
74380>>>>>>>        
74380>>>>>>>        // this works around a CJ issue where skins applied to other threads causes an exception upon close down.
74380>>>>>>>        // We saw this with our mssql driver but it could occur elsewhere. This has been reported in the CJ newsgroup
74380>>>>>>>        // and this was the suggested workaround.
74380>>>>>>>        Set ComAutoApplyNewThreads to False
74381>>>>>>>        
74381>>>>>>>        Send OnAddVDFWindowClasses
74382>>>>>>>        Send OnAddCustomWindowClasses
74383>>>>>>>        
74383>>>>>>>        // if preferences are used, it will set psSkinFile and psSkinIni
74383>>>>>>>        If (pbLoadPreference(Self)) Begin
74385>>>>>>>            Send LoadSkinPreference
74386>>>>>>>        End
74386>>>>>>>>
74386>>>>>>>        // if a skin file name exists, we apply the skin.
74386>>>>>>>        If (psSkinFile(Self)<>"") Begin
74388>>>>>>>            Send ApplySkin
74389>>>>>>>        End
74389>>>>>>>>
74389>>>>>>>    End_Procedure
74390>>>>>>>    
74390>>>>>>>    // called by framework as part of application exit.
74390>>>>>>>    Procedure Broadcast_Notify_Exit_Application
74392>>>>>>>        Send Notify_Exit_Application
74393>>>>>>>    End_Procedure
74394>>>>>>>    
74394>>>>>>>    Procedure Notify_Exit_Application
74396>>>>>>>        If (pbLoadPreference(Self)) Begin
74398>>>>>>>            Send SaveSkinPreference
74399>>>>>>>        End
74399>>>>>>>>
74399>>>>>>>    End_Procedure
74400>>>>>>>    
74400>>>>>>>    Procedure NotifyPreApplySkin
74402>>>>>>>        Broadcast Send OnPreApplySkin of Desktop True
74404>>>>>>>    End_Procedure
74405>>>>>>>    
74405>>>>>>>    Procedure NotifyPostApplySkin
74407>>>>>>>        Broadcast Send OnPostApplySkin of Desktop True
74409>>>>>>>    End_Procedure
74410>>>>>>>    
74410>>>>>>>    // returns an array of all skins in the path. If path is "", use the default path.
74410>>>>>>>    // If the default path is used, returns the file names as relative names, else use full path.
74410>>>>>>>    Function EnumerateSkins String sPath Boolean bRecursive Returns tSkinInformation[]
74412>>>>>>>        tSkinInformation[] Skins
74412>>>>>>>        tSkinInformation[] Skins
74413>>>>>>>        String sSkinName sSkinFile sDefaultPath sSep
74413>>>>>>>        Variant vSkinDescriptions vSkinDescription vSkinIniFile
74413>>>>>>>        Handle hSkinDescriptions hSkinDescription hSkinIniFile
74413>>>>>>>        Integer iSkinsCount iSkinFilesCount iNumSkins iNumSkinFiles iArrayItem
74413>>>>>>>        Integer iPos iDfltLen
74413>>>>>>>        Boolean bUseRelativePath
74413>>>>>>>        
74413>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
74414>>>>>>>        
74414>>>>>>>        Get SkinPath to sDefaultPath
74415>>>>>>>        If (sPath="") Begin
74417>>>>>>>            Move sDefaultPath to sPath
74418>>>>>>>        End
74418>>>>>>>>
74418>>>>>>>        Move (Uppercase(sDefaultPath)) to sDefaultPath
74419>>>>>>>        Move (Length(sDefaultPath)) to iDfltLen
74420>>>>>>>        Move (sDefaultPath=Uppercase(sPath)) to bUseRelativePath
74421>>>>>>>        
74421>>>>>>>        Get ComEnumerateSkinDirectory sPath bRecursive to vSkinDescriptions
74422>>>>>>>        If (not(IsNullComObject(vSkinDescriptions))) Begin
74424>>>>>>>            
74424>>>>>>>            Get Create U_cCJSkinDescriptions to hSkinDescriptions
74425>>>>>>>            Get Create U_cCJSkinDescription to hSkinDescription
74426>>>>>>>            Get Create U_cCJSkinIniFile to hSkinIniFile
74427>>>>>>>            
74427>>>>>>>            Set pvComObject of hSkinDescriptions to vSkinDescriptions
74428>>>>>>>            Get ComCount of hSkinDescriptions to iNumSkinFiles
74429>>>>>>>            
74429>>>>>>>            For iSkinFilesCount from 0 to (iNumSkinFiles-1)
74435>>>>>>>>
74435>>>>>>>                Get ComSkin of hSkinDescriptions iSkinFilesCount to vSkinDescription
74436>>>>>>>                Set pvComObject of hSkinDescription to vSkinDescription
74437>>>>>>>                
74437>>>>>>>                Get ComCount of hSkinDescription to iNumSkins
74438>>>>>>>                
74438>>>>>>>                For iSkinsCount from 0 to (iNumSkins-1)
74444>>>>>>>>
74444>>>>>>>                    Get ComIniFile of hSkinDescription iSkinsCount to vSkinIniFile
74445>>>>>>>                    Set pvComObject of hSkinIniFile to vSkinIniFile
74446>>>>>>>                    
74446>>>>>>>                    Get ComName of hSkinDescription to Skins[iArrayItem].sName
74447>>>>>>>                    Get ComPath of hSkinDescription to sSkinFile
74448>>>>>>>                    If bUseRelativePath Begin
74450>>>>>>>                        Move (pos(sDefaultPath,uppercase(sSkinFile))) to iPos
74451>>>>>>>                        If iPos Begin
74453>>>>>>>                            Move (Remove(sSkinFile,iPos,iDfltLen)) to sSkinFile
74454>>>>>>>                            While (Left(sSkinFile,1)=sSep)
74458>>>>>>>                                Move (Remove(sSkinFile,1,1)) to sSkinFile
74459>>>>>>>                            Loop
74460>>>>>>>>
74460>>>>>>>                        End
74460>>>>>>>>
74460>>>>>>>                    End
74460>>>>>>>>
74460>>>>>>>                    Move sSkinFile to Skins[iArrayItem].sSkinfile
74461>>>>>>>                    Get ComIniFileName of hSkinIniFile to Skins[iArrayItem].sSkinIni
74462>>>>>>>                    
74462>>>>>>>                    Increment iArrayItem
74463>>>>>>>                Loop
74464>>>>>>>>
74464>>>>>>>            Loop
74465>>>>>>>>
74465>>>>>>>            
74465>>>>>>>            Send Destroy of hSkinDescriptions
74466>>>>>>>            Send Destroy of hSkinDescription
74467>>>>>>>            Send Destroy of hSkinIniFile
74468>>>>>>>            
74468>>>>>>>        End
74468>>>>>>>>
74468>>>>>>>        Function_Return Skins
74469>>>>>>>    End_Function
74470>>>>>>>    
74470>>>>>>>    // Save the skin preference. This requires an application object.
74470>>>>>>>    // Only do this if the application object allows it.
74470>>>>>>>    // This is called during startup if pbLoadPreference is True
74470>>>>>>>    // Suitable for override
74470>>>>>>>    Procedure SaveSkinPreference
74472>>>>>>>        String sSkin sIni
74472>>>>>>>        If ghoApplication Begin
74474>>>>>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
74476>>>>>>>                Get psSkinFile to sSkin
74477>>>>>>>                Get psSkinIni to sIni
74478>>>>>>>                Send WriteString of ghoApplication "Preferences" "SkinFile" sSkin
74479>>>>>>>                Send WriteString of ghoApplication "Preferences" "SkinIni" sIni
74480>>>>>>>            End
74480>>>>>>>>
74480>>>>>>>        End
74480>>>>>>>>
74480>>>>>>>        Else Begin
74481>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
74482>>>>>>>>
74482>>>>>>>        End
74482>>>>>>>>
74482>>>>>>>    End_Procedure
74483>>>>>>>    
74483>>>>>>>    // Load the skin preference. This requires an application object.
74483>>>>>>>    // Only do this if the application object allows it.
74483>>>>>>>    // This is called during startup if pbLoadPreference is True
74483>>>>>>>    // Suitable for override
74483>>>>>>>    Procedure LoadSkinPreference
74485>>>>>>>        String sSkin sIni
74485>>>>>>>        Boolean bExists
74485>>>>>>>        If ghoApplication Begin
74487>>>>>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
74489>>>>>>>                Get ValueExists of ghoApplication "Preferences" "SkinFile" to bExists
74490>>>>>>>                If bExists Begin
74492>>>>>>>                    Get ReadString of ghoApplication "Preferences" "SkinFile" "" to sSkin
74493>>>>>>>                    Get ReadString of ghoApplication "Preferences" "SkinIni" "" to sIni
74494>>>>>>>                    Set psSkinFile to sSkin
74495>>>>>>>                    Set psSkinIni to sIni
74496>>>>>>>                End
74496>>>>>>>>
74496>>>>>>>            End
74496>>>>>>>>
74496>>>>>>>        End
74496>>>>>>>>
74496>>>>>>>        Else Begin
74497>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
74498>>>>>>>>
74498>>>>>>>        End
74498>>>>>>>>
74498>>>>>>>    End_Procedure
74499>>>>>>>    
74499>>>>>>>    // Can be called to apply the current skin.
74499>>>>>>>    Procedure ApplySkin
74501>>>>>>>        Boolean bOk
74501>>>>>>>        String sSkin sIni
74501>>>>>>>        If (IsComObjectCreated(Self)) Begin
74503>>>>>>>            Get SkinQFile to sSkin
74504>>>>>>>            Get psSkinIni to sIni
74505>>>>>>>            
74505>>>>>>>            Send NotifyPreApplySkin
74506>>>>>>>            // when skins are used we don't want to use built in Visual Styles
74506>>>>>>>            Send EnableVisualStyles of Desktop (sSkin="")
74507>>>>>>>            Get ComLoadSkin sSkin sIni to bOK
74508>>>>>>>            If (sSkin<>"" and not(bOk)) Begin
74510>>>>>>>                // if not ok, no skin was appied. Enable visual styles
74510>>>>>>>                Send EnableVisualStyles of Desktop True
74511>>>>>>>            End
74511>>>>>>>>
74511>>>>>>>            Send NotifyPostApplySkin
74512>>>>>>>        End
74512>>>>>>>>
74512>>>>>>>    End_Procedure
74513>>>>>>>    
74513>>>>>>>    
74513>>>>>>>End_Class
74514>>>>>Use cProgressBar.pkg
Including file: cProgressBar.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cProgressBar.pkg)
74514>>>>>>>Use Windows.pkg
74514>>>>>>>Use cWinControl.pkg
Including file: cWinControl.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cWinControl.pkg)
74514>>>>>>>>>Use Windows.pkg
74514>>>>>>>>>
74514>>>>>>>>>// Key State Masks for Mouse Messages
74514>>>>>>>>>
74514>>>>>>>>>Define MK_LBUTTON  for |CI$0001
74514>>>>>>>>>Define MK_RBUTTON  for |CI$0002
74514>>>>>>>>>Define MK_SHIFT    for |CI$0004
74514>>>>>>>>>Define MK_CONTROL  for |CI$0008
74514>>>>>>>>>Define MK_MBUTTON  for |CI$0010
74514>>>>>>>>>Define MK_XBUTTON1 for |CI$0020
74514>>>>>>>>>Define MK_XBUTTON2 for |CI$0040
74514>>>>>>>>>
74514>>>>>>>>>Enum_List // Mouse Key Flags
74514>>>>>>>>>    Define mkLeft    for MK_LBUTTON
74514>>>>>>>>>    Define mkMiddle  for MK_MBUTTON
74514>>>>>>>>>    Define mkRight   for MK_RBUTTON
74514>>>>>>>>>    Define mkX1      for MK_XBUTTON1
74514>>>>>>>>>    Define mkX2      for MK_XBUTTON2
74514>>>>>>>>>    Define mkShift   for MK_SHIFT
74514>>>>>>>>>    Define mkControl for MK_CONTROL
74514>>>>>>>>>End_Enum_List
74514>>>>>>>>>
74514>>>>>>>>>Enum_List // Mouse Buttons. Used in OnMouseXXX messages
74514>>>>>>>>>    Define mbLeft
74514>>>>>>>>>    Define mbMiddle
74514>>>>>>>>>    Define mbRight
74514>>>>>>>>>    Define mbX1
74514>>>>>>>>>    Define mbX2
74514>>>>>>>>>End_Enum_List
74514>>>>>>>>>
74514>>>>>>>>>Class cWinControl is a DfBaseControl
74515>>>>>>>>>    Procedure Construct_Object
74517>>>>>>>>>        Forward Send Construct_Object
74519>>>>>>>>>        Property Integer private_pbEnabled True
74520>>>>>>>>>        Property Integer private_pbVisible True
74521>>>>>>>>>    End_Procedure
74522>>>>>>>>>    
74522>>>>>>>>>    Procedure End_Construct_Object
74524>>>>>>>>>        Forward Send End_Construct_Object
74526>>>>>>>>>        
74526>>>>>>>>>        Set External_Message WM_LBUTTONDOWN   to msg_OnWmLButtonDown
74527>>>>>>>>>        Set External_Message WM_MBUTTONDOWN   to msg_OnWmMButtonDown
74528>>>>>>>>>        Set External_Message WM_RBUTTONDOWN   to msg_OnWmRButtonDown
74529>>>>>>>>>        Set External_Message WM_LBUTTONUP     to msg_OnWmLButtonUp
74530>>>>>>>>>        Set External_Message WM_MBUTTONUP     to msg_OnWmMButtonUp
74531>>>>>>>>>        Set External_Message WM_RBUTTONUP     to msg_OnWmRButtonUp
74532>>>>>>>>>        Set External_Message WM_LBUTTONDBLCLK to msg_OnWmLButtonDblClk
74533>>>>>>>>>        Set External_Message WM_MBUTTONDBLCLK to msg_OnWmMButtonDblClk
74534>>>>>>>>>        Set External_Message WM_RBUTTONDBLCLK to msg_OnWmRButtonDblClk
74535>>>>>>>>>        Set External_Message WM_MOUSEMOVE     to msg_OnWmMouseMove
74536>>>>>>>>>    End_Procedure
74537>>>>>>>>>    
74537>>>>>>>>>    Procedure Notify Longptr wParam Longptr lParam
74539>>>>>>>>>        //Intentionally cancelled
74539>>>>>>>>>    End_Procedure
74540>>>>>>>>>    
74540>>>>>>>>>    Procedure Command Longptr wParam Longptr lParam
74542>>>>>>>>>        //Intentionally cancelled
74542>>>>>>>>>    End_Procedure
74543>>>>>>>>>    
74543>>>>>>>>>    Procedure DoRecreateWindow
74545>>>>>>>>>        // Recreates the window
74545>>>>>>>>>        If (Window_Handle(Self)) Begin
74547>>>>>>>>>            // attempt to do this without disturbing the focus tree.
74547>>>>>>>>>            Send Page_delete // prior to 8.3 this was Send Page_Object 0
74548>>>>>>>>>            Send Page 1      //                       Send Page_Object 1
74549>>>>>>>>>        End
74549>>>>>>>>>>
74549>>>>>>>>>    End_Procedure
74550>>>>>>>>>    
74550>>>>>>>>>    Procedure DoUpdateWindow
74552>>>>>>>>>        // Forces windows to update the window by bypassing WM_PAINT
74552>>>>>>>>>        Handle hWnd
74552>>>>>>>>>        
74552>>>>>>>>>        Get Window_Handle to hWnd
74553>>>>>>>>>        If hWnd ;            Move (UpdateWindow(hWnd)) to hWnd
74556>>>>>>>>>    End_Procedure
74557>>>>>>>>>    
74557>>>>>>>>>    Procedure Page Integer iState
74559>>>>>>>>>        Set Window_Style to WS_DISABLED (private_pbEnabled(Self) =False)
74560>>>>>>>>>        Set Window_Style to WS_VISIBLE (private_pbVisible(Self))
74561>>>>>>>>>        Forward Send Page iState
74563>>>>>>>>>    End_Procedure
74564>>>>>>>>>    
74564>>>>>>>>>    Procedure OnWmLButtonUp Integer wParam Integer lParam
74566>>>>>>>>>        Integer x y eButton
74566>>>>>>>>>        
74566>>>>>>>>>        Move (Hi(lParam))  to y
74567>>>>>>>>>        Move (Low(lParam)) to x
74568>>>>>>>>>        
74568>>>>>>>>>        Send OnMouseUp mbLeft x y wParam
74569>>>>>>>>>    End_Procedure
74570>>>>>>>>>    
74570>>>>>>>>>    Procedure OnWmMButtonUp Integer wParam Integer lParam
74572>>>>>>>>>        Integer x y eButton
74572>>>>>>>>>        
74572>>>>>>>>>        Move (Hi(lParam))  to y
74573>>>>>>>>>        Move (Low(lParam)) to x
74574>>>>>>>>>        
74574>>>>>>>>>        Send OnMouseUp mbMiddle x y wParam
74575>>>>>>>>>    End_Procedure
74576>>>>>>>>>    
74576>>>>>>>>>    Procedure OnWmRButtonUp Integer wParam Integer lParam
74578>>>>>>>>>        Integer x y eButton
74578>>>>>>>>>        
74578>>>>>>>>>        Move (Hi(lParam))  to y
74579>>>>>>>>>        Move (Low(lParam)) to x
74580>>>>>>>>>        
74580>>>>>>>>>        Send OnMouseUp mbRight x y wParam
74581>>>>>>>>>    End_Procedure
74582>>>>>>>>>    
74582>>>>>>>>>    Procedure OnWmLButtonDown Integer wParam Integer lParam
74584>>>>>>>>>        Integer x y eButton fKeys
74584>>>>>>>>>        
74584>>>>>>>>>        Move (Hi(lParam))  to y
74585>>>>>>>>>        Move (Low(lParam)) to x
74586>>>>>>>>>        
74586>>>>>>>>>        Send OnMouseDown mbLeft x y wParam
74587>>>>>>>>>    End_Procedure
74588>>>>>>>>>    Procedure OnWmMButtonDown Integer wParam Integer lParam
74590>>>>>>>>>        Integer x y eButton
74590>>>>>>>>>        
74590>>>>>>>>>        Move (Hi(lParam))  to y
74591>>>>>>>>>        Move (Low(lParam)) to x
74592>>>>>>>>>        
74592>>>>>>>>>        Send OnMouseDown mbMiddle x y wParam
74593>>>>>>>>>    End_Procedure
74594>>>>>>>>>    Procedure OnWmRButtonDown Integer wParam Integer lParam
74596>>>>>>>>>        Integer x y eButton
74596>>>>>>>>>        
74596>>>>>>>>>        Move (Hi(lParam))  to y
74597>>>>>>>>>        Move (Low(lParam)) to x
74598>>>>>>>>>        
74598>>>>>>>>>        Send OnMouseDown mbRight x y wParam
74599>>>>>>>>>    End_Procedure
74600>>>>>>>>>    
74600>>>>>>>>>    Procedure OnWmLButtonDblClk Integer wParam Integer lParam
74602>>>>>>>>>        Integer x y eButton
74602>>>>>>>>>        
74602>>>>>>>>>        Move (Hi(lParam))  to y
74603>>>>>>>>>        Move (Low(lParam)) to x
74604>>>>>>>>>        
74604>>>>>>>>>        Send OnMouseDoubleClick mbLeft x y wParam
74605>>>>>>>>>    End_Procedure
74606>>>>>>>>>    Procedure OnWmMButtonDblClk Integer wParam Integer lParam
74608>>>>>>>>>        Integer x y eButton
74608>>>>>>>>>        
74608>>>>>>>>>        Move (Hi(lParam))  to y
74609>>>>>>>>>        Move (Low(lParam)) to x
74610>>>>>>>>>        
74610>>>>>>>>>        Send OnMouseDoubleClick mbMiddle x y wParam
74611>>>>>>>>>    End_Procedure
74612>>>>>>>>>    Procedure OnWmRButtonDblClk Integer wParam Integer lParam
74614>>>>>>>>>        Integer x y eButton
74614>>>>>>>>>        
74614>>>>>>>>>        Move (Hi(lParam))  to y
74615>>>>>>>>>        Move (Low(lParam)) to x
74616>>>>>>>>>        
74616>>>>>>>>>        Send OnMouseDoubleClick mbRight x y wParam
74617>>>>>>>>>    End_Procedure
74618>>>>>>>>>    
74618>>>>>>>>>    Procedure OnWmMouseMove Integer wParam Integer lParam
74620>>>>>>>>>        Integer x y eButton
74620>>>>>>>>>        
74620>>>>>>>>>        Move (Hi(lParam))  to y
74621>>>>>>>>>        Move (Low(lParam)) to x
74622>>>>>>>>>        
74622>>>>>>>>>        Send OnMouseMove x y wParam
74623>>>>>>>>>    End_Procedure
74624>>>>>>>>>    
74624>>>>>>>>>    Procedure OnMouseDown Integer eButton Integer x Integer y Integer fKeys
74626>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
74626>>>>>>>>>        //String sButton
74626>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
74626>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
74626>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
74626>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
74626>>>>>>>>>        
74626>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
74626>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
74626>>>>>>>>>        //Showln 'OnMouseDown ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
74626>>>>>>>>>    End_Procedure
74627>>>>>>>>>    
74627>>>>>>>>>    Procedure OnMouseUp Integer eButton Integer x Integer y Integer fKeys
74629>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
74629>>>>>>>>>        //String sButton
74629>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
74629>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
74629>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
74629>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
74629>>>>>>>>>        
74629>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
74629>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
74629>>>>>>>>>        //Showln 'OnMouseUp ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
74629>>>>>>>>>    End_Procedure
74630>>>>>>>>>    
74630>>>>>>>>>    Procedure OnMouseDoubleClick Integer eButton Integer x Integer y Integer fKeys
74632>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
74632>>>>>>>>>        //String sButton
74632>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
74632>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
74632>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
74632>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
74632>>>>>>>>>        
74632>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
74632>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
74632>>>>>>>>>        //Showln 'OnMouseDblClk ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
74632>>>>>>>>>    End_Procedure
74633>>>>>>>>>    
74633>>>>>>>>>    Procedure OnMouseMove Integer x Integer y Integer fKeys
74635>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
74635>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
74635>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
74635>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
74635>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
74635>>>>>>>>>        
74635>>>>>>>>>        //Showln 'OnMouseMove ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
74635>>>>>>>>>    End_Procedure
74636>>>>>>>>>    
74636>>>>>>>>>    Procedure Set pbEnabled Boolean bEnabled
74638>>>>>>>>>        Handle hWnd
74638>>>>>>>>>        
74638>>>>>>>>>        If (bEnabled <> private_pbEnabled(Self)) Begin
74640>>>>>>>>>            Set private_pbEnabled to bEnabled
74641>>>>>>>>>            Get Window_Handle to hWnd
74642>>>>>>>>>            If hWnd ;                Move (EnableWindow(hWnd, bEnabled)) to hWnd
74645>>>>>>>>>        End
74645>>>>>>>>>>
74645>>>>>>>>>    End_Procedure
74646>>>>>>>>>    Function pbEnabled Returns Boolean
74648>>>>>>>>>        Function_Return (private_pbEnabled(Self))
74649>>>>>>>>>    End_Function
74650>>>>>>>>>    
74650>>>>>>>>>    Procedure Set pbVisible Boolean bVisible
74652>>>>>>>>>        Handle  hWnd
74652>>>>>>>>>        Integer iVoid
74652>>>>>>>>>        
74652>>>>>>>>>        If (bVisible <> private_pbVisible(Self)) Begin
74654>>>>>>>>>            Set private_pbVisible to bVisible
74655>>>>>>>>>            Get Window_Handle to hWnd
74656>>>>>>>>>            If hWnd ;                Move (ShowWindow(hWnd, If (bVisible, SW_SHOWNA, SW_HIDE))) to iVoid
74659>>>>>>>>>        End
74659>>>>>>>>>>
74659>>>>>>>>>    End_Procedure
74660>>>>>>>>>    Function pbVisible Returns Boolean
74662>>>>>>>>>        Function_Return (private_pbVisible(Self))
74663>>>>>>>>>    End_Function
74664>>>>>>>>>    
74664>>>>>>>>>End_Class
74665>>>>>>>Use CommCtrl.pkg
74665>>>>>>>
74665>>>>>>>//{ OverrideProperty=pbEnabled DesignTime=False }
74665>>>>>>>Class cProgressBar is a cWinControl
74666>>>>>>>    
74666>>>>>>>    Procedure Construct_Object
74668>>>>>>>        Forward Send Construct_Object
74670>>>>>>>        Property Integer private_piMinimum
74671>>>>>>>        Property Integer private_piMaximum   100
74672>>>>>>>        Property Integer private_piAdvanceBy 10
74673>>>>>>>        Property Integer private_piPosition
74674>>>>>>>        Property Integer private_pbVertical  False
74675>>>>>>>        Property Integer private_pbSmooth    False
74676>>>>>>>        Property Integer private_piBackColor clDefault
74677>>>>>>>        Property Integer private_piBarColor  clDefault
74678>>>>>>>        
74678>>>>>>>        Send Define_ToolTip_Support_Mixin
74679>>>>>>>        
74679>>>>>>>        Set External_Class_Name 'cVdfProgressBar' to 'msctls_progress32'
74680>>>>>>>        Set Focus_Mode to NonFocusable
74681>>>>>>>        Set Skip_State to True
74682>>>>>>>        Set pbUseFormWindowHandle to False     // Must come after Define_ToolTip_Support_Mixin
74683>>>>>>>    End_Procedure
74684>>>>>>>    
74684>>>>>>>    Import_Class_Protocol ToolTip_Support_Mixin
74685>>>>>>>    
74685>>>>>>>    Procedure Set piMinimum Integer iMin
74687>>>>>>>        Integer iMax
74687>>>>>>>        
74687>>>>>>>        Set private_piMinimum to iMin
74688>>>>>>>        Get private_piMaximum to iMax
74689>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
74690>>>>>>>    End_Procedure
74691>>>>>>>    Function piMinimum Returns Integer
74693>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETRANGE, 1, 0))
74696>>>>>>>        Else;            Function_Return (private_piMinimum(Self))
74698>>>>>>>    End_Function
74699>>>>>>>    
74699>>>>>>>    Procedure Set piMaximum Integer iMax
74701>>>>>>>        Integer iMin
74701>>>>>>>        
74701>>>>>>>        Set private_piMaximum to iMax
74702>>>>>>>        Get private_piMinimum to iMin
74703>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
74704>>>>>>>    End_Procedure
74705>>>>>>>    Function piMaximum Returns Integer
74707>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETRANGE, 0, 0))
74710>>>>>>>        Else;            Function_Return (private_piMaximum(Self))
74712>>>>>>>    End_Function
74713>>>>>>>    
74713>>>>>>>    Procedure Set piAdvanceBy Integer iAdvanceBy
74715>>>>>>>        Set private_piAdvanceBy to iAdvanceBy
74716>>>>>>>        Send Windows_Message PBM_SETSTEP iAdvanceBy 0
74717>>>>>>>    End_Procedure
74718>>>>>>>    Function piAdvanceBy Returns Integer
74720>>>>>>>        Function_Return (private_piAdvanceBy(Self))
74721>>>>>>>    End_Function
74722>>>>>>>    
74722>>>>>>>    Procedure Set piPosition Integer iPos
74724>>>>>>>        Set private_piPosition to iPos
74725>>>>>>>        Send Windows_Message PBM_SETPOS iPos 0
74726>>>>>>>    End_Procedure
74727>>>>>>>    
74727>>>>>>>    Function piPosition Returns Integer
74729>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETPOS, 0, 0))
74732>>>>>>>        Else;            Function_Return (private_piPosition(Self))
74734>>>>>>>    End_Function
74735>>>>>>>    
74735>>>>>>>    Procedure Set pbVertical Boolean bVertical
74737>>>>>>>        If (private_pbVertical(Self) <> bVertical) Begin
74739>>>>>>>            Set private_pbVertical to bVertical
74740>>>>>>>            Send DoRecreateWindow
74741>>>>>>>        End
74741>>>>>>>>
74741>>>>>>>    End_Procedure
74742>>>>>>>    
74742>>>>>>>    Function pbVertical Returns Boolean
74744>>>>>>>        Function_Return (private_pbVertical(Self))
74745>>>>>>>    End_Function
74746>>>>>>>    
74746>>>>>>>    Procedure Set pbSmooth Boolean bSmooth
74748>>>>>>>        If (private_pbSmooth(Self) <> bSmooth) Begin
74750>>>>>>>            Set private_pbSmooth to bSmooth
74751>>>>>>>            Send DoRecreateWindow
74752>>>>>>>        End
74752>>>>>>>>
74752>>>>>>>    End_Procedure
74753>>>>>>>    Function pbSmooth Returns Boolean
74755>>>>>>>        Function_Return (private_pbSmooth(Self))
74756>>>>>>>    End_Function
74757>>>>>>>    
74757>>>>>>>    Procedure Set piBackColor Integer rgbColor
74759>>>>>>>        Set private_piBackColor to rgbColor
74760>>>>>>>        Send Windows_Message PBM_SETBKCOLOR 0 rgbColor
74761>>>>>>>    End_Procedure
74762>>>>>>>    Function piBackColor Returns Integer
74764>>>>>>>        Function_Return (private_piBackColor(Self))
74765>>>>>>>    End_Function
74766>>>>>>>    
74766>>>>>>>    Procedure Set piBarColor Integer rgbColor
74768>>>>>>>        Set private_piBarColor to rgbColor
74769>>>>>>>        Send Windows_Message PBM_SETBARCOLOR 0 rgbColor
74770>>>>>>>    End_Procedure
74771>>>>>>>    Function piBarColor Returns Integer
74773>>>>>>>        Function_Return (private_piBarColor(Self))
74774>>>>>>>    End_Function
74775>>>>>>>    
74775>>>>>>>    Procedure DoAdvance
74777>>>>>>>        Send Windows_Message PBM_STEPIT 0 0
74778>>>>>>>    End_Procedure
74779>>>>>>>    
74779>>>>>>>    Procedure DoAdvanceBy  Integer iAdvanceBy
74781>>>>>>>        Send Windows_Message PBM_DELTAPOS iAdvanceBy 0
74782>>>>>>>    End_Procedure
74783>>>>>>>    
74783>>>>>>>    Procedure private_DoInitWindow
74785>>>>>>>        Set piBarColor  to (private_piBarColor(Self))
74786>>>>>>>        Set piBackColor to (private_piBackColor(Self))
74787>>>>>>>        Set piAdvanceBy to (private_piAdvanceBy(Self))
74788>>>>>>>        Set piMinimum   to (private_piMinimum(Self))
74789>>>>>>>        Set piMaximum   to (private_piMaximum(Self))
74790>>>>>>>        Set piPosition  to (private_piPosition(Self))
74791>>>>>>>    End_Procedure
74792>>>>>>>    
74792>>>>>>>    Procedure Page_Object Integer iState
74794>>>>>>>        Handle hWnd
74794>>>>>>>        
74794>>>>>>>        Get Window_Handle to hWnd
74795>>>>>>>        If (hWnd=0 and iState) Begin
74797>>>>>>>            Set Window_Style to PBS_VERTICAL (private_pbVertical(Self))
74798>>>>>>>            Set Window_Style to PBS_SMOOTH   (private_pbSmooth(Self))
74799>>>>>>>            Forward Send Page_Object True
74801>>>>>>>        End
74801>>>>>>>>
74801>>>>>>>        Else ;            Forward Send Page_Object iState
74804>>>>>>>        
74804>>>>>>>        // Handle tooltip support....
74804>>>>>>>        If (iState = 0) Begin
74806>>>>>>>            Send RequestDeleteToolTip
74807>>>>>>>        End
74807>>>>>>>>
74807>>>>>>>        Else Begin
74808>>>>>>>            Send RequestAddToolTip
74809>>>>>>>        End
74809>>>>>>>>
74809>>>>>>>    End_Procedure
74810>>>>>>>    
74810>>>>>>>    Procedure Page Integer iState
74812>>>>>>>        Forward Send Page iState
74814>>>>>>>        If (iState =1);            Send private_DoInitWindow
74817>>>>>>>    End_Procedure
74818>>>>>>>    
74818>>>>>>>    // Called by Page_Object. Handles tooltip creation. We use a dedicated
74818>>>>>>>    // method to perform AddToolTip because it is often the case that Page_Object
74818>>>>>>>    // is implemented in a mixin class.
74818>>>>>>>    Procedure RequestAddToolTip
74820>>>>>>>        Send AddToolTip
74821>>>>>>>    End_Procedure
74822>>>>>>>    
74822>>>>>>>    
74822>>>>>>>    // Called by Page_Object. Handles tooltip removal.
74822>>>>>>>    Procedure RequestDeleteToolTip
74824>>>>>>>        Send DeleteToolTip
74825>>>>>>>    End_Procedure
74826>>>>>>>End_Class
74827>>>>>Use Windows.pkg
74827>>>>>Use DUFLanguageConstants.inc
74827>>>>>Use Statpnl.pkg
74827>>>>>
74827>>>>>
74827>>>>>    Global_Variable Handle ghoProgressBar // will contain the ID of the embedded progress bar.
74827>>>>>
74827>>>>>    Global_Variable Handle ghoProgressBarOverall // will contain the ID of the embedded progress bar with overall results
74827>>>>>
74827>>>>>Object Status_Panel is a cProcessStatusPanel
74829>>>>>    Set Size to 152 222
74830>>>>>    Set Border_Style to Border_Dialog
74831>>>>>    Set Icon to "Default.ico"
74832>>>>>    Move Self to ghoStatusPanel // this can be used throughout the applicaton to access this object
74833>>>>>
74833>>>>>    Property Boolean Cancel_Button_Visible_State True
74835>>>>>
74835>>>>>    Procedure Activate
74838>>>>>        Integer iSizeBefore
74838>>>>>        Get GuiSize to iSizeBefore
74839>>>>>        Forward Send Activate
74841>>>>>        Set GuiSize to (Hi(iSizeBefore)) (Low(iSizeBefore))
74842>>>>>    End_Procedure
74843>>>>>
74843>>>>>    Procedure End_Construct_Object
74846>>>>>        Forward Send End_Construct_Object
74848>>>>>        Set Label of oTitleTxt      to ""
74849>>>>>        Set Label of oTableNameTxt  to ""
74850>>>>>        Set Label of oMessageTxt    to ""
74851>>>>>        Set Label of oActionTxt     to ""
74852>>>>>    End_Procedure
74853>>>>>
74853>>>>>    Object oTitleTxt is a TextBox
74855>>>>>        Set Location to 5 21
74856>>>>>        Set Size to 8 179
74857>>>>>        Set Auto_Size_State to False
74858>>>>>        Set Justification_Mode  to jMode_Center
74859>>>>>        Set Label to "This is the Title Text"
74860>>>>>    End_Object
74861>>>>>
74861>>>>>    Object oTableNameTxt is a TextBox
74863>>>>>        Set Size to 19 204
74864>>>>>        Set Location to 18 9
74865>>>>>        Set Auto_Size_State to False
74866>>>>>        Set Justification_Mode to JMode_Left
74867>>>>>        Set Label to "This is the TableName Text"
74868>>>>>    End_Object
74869>>>>>
74869>>>>>    Object oMessageTxt is a TextBox
74871>>>>>        Set Location to 39 9
74872>>>>>        Set Size to 19 204
74873>>>>>        Set Auto_Size_State to False
74874>>>>>        Set Justification_Mode to JMode_Left
74875>>>>>        Set Label to "This is the Message text"
74876>>>>>    End_Object
74877>>>>>
74877>>>>>    Object oActionTxt is a TextBox
74879>>>>>        Set Size to 16 204
74880>>>>>        Set Location to 60 9
74881>>>>>        Set Auto_Size_State to False
74882>>>>>        Set Justification_Mode to JMode_Left
74883>>>>>        Set Label to "This is the Action Text"
74884>>>>>    End_Object
74885>>>>>
74885>>>>>    Object oStopButton is a Button
74887>>>>>        Set Location to 123 82
74888>>>>>        Set Label to C_$Cancel
74889>>>>>
74889>>>>>        Procedure OnClick 
74892>>>>>            Integer iRetval
74892>>>>>            Get YesNo_Box CS_DUF_DoYouWantToExit to iRetval
74893>>>>>            If (iRetval = MBR_Yes) Begin
74895>>>>>                Send Exit_Application
74896>>>>>            End
74896>>>>>>
74896>>>>>        End_Procedure
74897>>>>>
74897>>>>>    End_Object
74898>>>>>
74898>>>>>    Object oPercentage_tb is a TextBox
74900>>>>>        Set Location to 74 196
74901>>>>>        Set Size to 10 25
74902>>>>>//        Set Label to "% Done"
74902>>>>>    End_Object
74903>>>>>
74903>>>>>    Object oCopyRight is a TextBox
74905>>>>>        Set Location to 140 21
74906>>>>>        Set Size to 9 197
74907>>>>>        Set FontPointHeight to 8
74908>>>>>        Set Auto_Size_State to False
74909>>>>>        Set Justification_Mode  to jMode_Center
74910>>>>>        Set Label to "Copyright 2001-2024 RDC Tools International"
74911>>>>>    End_Object
74912>>>>>
74912>>>>>    Object oProgressBar is a cProgressBar
74914>>>>>        Set Size to 10 179
74915>>>>>        Set Location to 83 22
74916>>>>>        Set pbVisible to True // default
74917>>>>>        Move Self to ghoProgressBar // this can be used throughout your application to access the progress bar
74918>>>>>    End_Object
74919>>>>>
74919>>>>>    Procedure Set Progress_Bar_Visible_State Boolean bVisible
74922>>>>>        Set pbVisible of ghoProgressBar to bVisible
74923>>>>>    End_Procedure
74924>>>>>
74924>>>>>    Function Progress_Bar_Visible_State Returns Boolean
74927>>>>>        Boolean bVisible
74927>>>>>        Get pbVisible of ghoProgressBar to bVisible
74928>>>>>        Function_Return (bVisible)
74929>>>>>    End_Function
74930>>>>>
74930>>>>>    Object oProgressBarOverall is a cProgressBar
74932>>>>>        Set Size to 10 179
74933>>>>>        Set Location to 107 22
74934>>>>>        Set pbVisible to True // default
74935>>>>>        Move Self to ghoProgressBarOverall // this can be used throughout your application to access the progress bar
74936>>>>>    End_Object
74937>>>>>
74937>>>>>    Object oOverallProgress_tb is a TextBox
74939>>>>>        Set Size to 10 65
74940>>>>>        Set Location to 95 24
74941>>>>>        Set Label to "Overall Progress"
74942>>>>>    End_Object
74943>>>>>
74943>>>>>    Procedure Set Progress_Bar_Overall_Visible_State Boolean bVisible
74946>>>>>        Set pbVisible of ghoProgressBarOverall to bVisible
74947>>>>>    End_Procedure
74948>>>>>
74948>>>>>    Function Progress_Bar_Overall_Visible_State Returns Boolean
74951>>>>>        Boolean bVisible
74951>>>>>        Get pbVisible of ghoProgressBarOverall to bVisible
74952>>>>>        Function_Return (bVisible)
74953>>>>>    End_Function
74954>>>>>
74954>>>>>    // These messages bind the standard cProcessStatusPanel interface to the actual
74954>>>>>    // objects defined within this instance of the status panel.
74954>>>>>
74954>>>>>    // note: all of the messages that change text should be forwarded
74954>>>>>    // as the forwarded messages allows the panel to paint when in a tight loop
74954>>>>>
74954>>>>>    Procedure Set Message_Text String sText
74957>>>>>        Set Label of oMessageTxt to sText
74958>>>>>        Forward Set Message_Text to sText
74960>>>>>    End_Procedure
74961>>>>>
74961>>>>>    Function Message_Text Returns String
74964>>>>>        Function_Return (Label(oMessageTxt))
74965>>>>>    End_Function
74966>>>>>
74966>>>>>    Procedure Set Action_Text String sText
74969>>>>>        Set Label of oActionTxt to sText
74970>>>>>        Forward Set Action_Text to sText
74972>>>>>    End_Procedure
74973>>>>>
74973>>>>>    Function Action_Text Returns String
74976>>>>>        Function_Return (Label(oActionTxt))
74977>>>>>    End_Function
74978>>>>>
74978>>>>>    Procedure Set Button_Text String sText
74981>>>>>        Set Label of oStopButton to sText
74982>>>>>        Forward Set Button_Text to sText
74984>>>>>    End_Procedure
74985>>>>>
74985>>>>>    Function Button_Text Returns String
74988>>>>>        Function_Return (Label(oStopButton))
74989>>>>>    End_Function
74990>>>>>
74990>>>>>    Procedure Set Title_Text String sText
74993>>>>>        Set Label of oTitleTxt to sText
74994>>>>>        Forward Set Title_Text to sText
74996>>>>>    End_Procedure
74997>>>>>
74997>>>>>    Function Title_Text Returns String
75000>>>>>        Function_Return (Label(oTitleTxt))
75001>>>>>    End_Function
75002>>>>>
75002>>>>>    Procedure Set TableName_Text String sText
75005>>>>>        Set Label of oTableNameTxt to sText
75006>>>>>    End_Procedure
75007>>>>>
75007>>>>>    Function TableName_Text Returns String
75010>>>>>        Function_Return (Label(oTableNameTxt))
75011>>>>>    End_Function
75012>>>>>
75012>>>>>    Procedure Set License_Text String sText
75015>>>>>//        Set Label of oLicense_txt to sText
75015>>>>>    End_Procedure
75016>>>>>
75016>>>>>    // gets called when status panel is activated passing whether a button
75016>>>>>    // should appear
75016>>>>>    Procedure EnableCancelButton Boolean bEnable
75019>>>>>        Boolean bVisible
75019>>>>>        Get Cancel_Button_Visible_State to bVisible
75020>>>>>        If (bEnable = False) Begin
75022>>>>>            Set Visible_State of oStopButton to bVisible
75023>>>>>        End
75023>>>>>>
75023>>>>>        Set Enabled_State of oStopButton to bEnable
75024>>>>>    End_Procedure
75025>>>>>
75025>>>>>    Procedure Reset_StatusPanel
75028>>>>>        Set Allow_Cancel_State of ghoStatusPanel to True
75029>>>>>        Set Cancel_Button_Visible_State of ghoStatusPanel to True
75030>>>>>        Set Progress_Bar_Visible_State  of ghoStatusPanel to True
75031>>>>>        Set Progress_Bar_Overall_Visible_State of ghoProgressBarOverall to False
75032>>>>>    End_Procedure
75033>>>>>
75033>>>>>//    Object oProgressBar is a cProgressBar
75033>>>>>//        Move Self to ghoProgressBar
75033>>>>>//        Set Location to 1 25
75033>>>>>//        Set Size to 9 173
75033>>>>>//        Set piMinimum        to 0
75033>>>>>//        Set piMaximum        to 2000
75033>>>>>//        Set piAdvanceBy      to 100
75033>>>>>//        Set pbSmooth to True
75033>>>>>//
75033>>>>>//        // For some weird reason the application skin makes the coloring of the progressbar
75033>>>>>//        // to malfunction. By telling the CodeJock SkinFramework to skip this object, the
75033>>>>>//        // color will show correctly.
75033>>>>>//        Procedure Page Integer iPageObject
75033>>>>>//            Handle hWin
75033>>>>>//            Forward Send Page iPageObject
75033>>>>>//            If (ghoSkinFramework <> 0) Begin
75033>>>>>//                Get Window_Handle to hWin
75033>>>>>//                Send ComRemoveWindow of ghoSkinFramework hWin
75033>>>>>//            End
75033>>>>>//        End_Procedure
75033>>>>>//    End_Object
75033>>>>>
75033>>>>>End_Object
75034>>>>>
75034>>>Use cDbUpdateHandler.inc // Contains cDbUpdateHandler class constants, structs etc.
Including file: cDbUpdateHandler.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateHandler.inc)
75034>>>>>// Constant declarations, structs etc. for the cDbUdpateHandler class.
75034>>>>>//
75034>>>>>Use VdfBase.pkg
75034>>>>>Use cApplication.pkg
75034>>>>>Use seq_chnl.pkg
75034>>>>>Use vWin32fh.pkg
Including file: vwin32fh.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh\vwin32fh.pkg)
75034>>>>>>>// This code is part of VDF GUIdance
75034>>>>>>>// Visit us @ http://www.vdf-guidance.com
75034>>>>>>>// e-Mail us @ info@vdf-guidance.com
75034>>>>>>>// VDF GUIdance is a mutual project of
75034>>>>>>>// Frank Vandervelpen - Vandervelpen Systems and
75034>>>>>>>// Wil van Antwerpen  - Antwise Solutions
75034>>>>>>>// All software source code should be used <<AS IS>> without any warranty.
75034>>>>>>>//
75034>>>>>>>//
75034>>>>>>>// *** Windows 32bit file handling wrapper class ***
75034>>>>>>>//
75034>>>>>>>
75034>>>>>>>
75034>>>>>>>Use File_Dlg.pkg      // Contains OpenDialog class definition
75034>>>>>>>Use cvFileDialogs.pkg
Including file: cvFileDialogs.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh\cvFileDialogs.pkg)
75034>>>>>>>>>//***************************************************************************
75034>>>>>>>>>//*
75034>>>>>>>>>//* Class:        cvSaveAsDialog
75034>>>>>>>>>//* Package Name: cvFileDialogs.pkg
75034>>>>>>>>>//*
75034>>>>>>>>>//***************************************************************************
75034>>>>>>>>>
75034>>>>>>>>>Use File_dlg.pkg
75034>>>>>>>>>
75034>>>>>>>>>// *WvA: 13-01-1999 Created
75034>>>>>>>>>// The Class cSelectFile_Dialog is created to support the function Select_File
75034>>>>>>>>>// This function opens the Windows standard file open dialog and returns the selected
75034>>>>>>>>>// file_name.
75034>>>>>>>>>Class cvSelectFile_Dialog is an OpenDialog
75035>>>>>>>>>
75035>>>>>>>>>    Procedure Construct_Object Integer iImage_Id
75037>>>>>>>>>        Forward Send Construct_Object iImage_Id
75039>>>>>>>>>        Set HideReadOnly_State to True
75040>>>>>>>>>    End_Procedure
75041>>>>>>>>>
75041>>>>>>>>>    Function SelectedFileName Returns String
75043>>>>>>>>>        String sFileName
75043>>>>>>>>>        Move "" to sFileName
75044>>>>>>>>>        If (Show_Dialog(Self)) Begin
75046>>>>>>>>>            Move (RTrim(File_Name(Self))) to sFileName
75047>>>>>>>>>        End
75047>>>>>>>>>>
75047>>>>>>>>>        Function_Return sFileName
75048>>>>>>>>>    End_Function
75049>>>>>>>>>End_Class
75050>>>>>>>>>
75050>>>>>>>>>// *WvA: 13-01-1999 Created
75050>>>>>>>>>// This function opens the Windows standard file open dialog and returns the selected
75050>>>>>>>>>// file_name. Returns '' if the user didn't make a selection.
75050>>>>>>>>>// **WvA: 17-10-2003 Cleaned up and added code to destroy the dynamically created
75050>>>>>>>>>//                   file-open dialog
75050>>>>>>>>>Function vSelect_File Global String sSupportedFileTypes String sCaptionText String sInitialFolder Returns String
75052>>>>>>>>>    String sSelectedFile
75052>>>>>>>>>    Integer hoOpenFileDialog
75052>>>>>>>>>
75052>>>>>>>>>    Object oOpenFileDialog is a cvSelectFile_Dialog
75054>>>>>>>>>
75054>>>>>>>>>        Set Dialog_Caption    to sCaptionText
75055>>>>>>>>>        Set Filter_String     to sSupportedFileTypes
75056>>>>>>>>>        Set Initial_Folder    to sInitialFolder
75057>>>>>>>>>
75057>>>>>>>>>        Move Self       to hoOpenFileDialog
75058>>>>>>>>>    End_Object
75059>>>>>>>>>
75059>>>>>>>>>    Get SelectedFileName of hoOpenFileDialog to sSelectedFile
75060>>>>>>>>>    Send Destroy_Object to hoOpenFileDialog
75061>>>>>>>>>    Function_Return sSelectedFile
75062>>>>>>>>>End_Function
75063>>>>>>>>>
75063>>>>>>>>>Class cvSaveAsDialog is a SaveAsDialog
75064>>>>>>>>>
75064>>>>>>>>>    Procedure Construct_Object
75066>>>>>>>>>        Forward Send Construct_Object
75068>>>>>>>>>        Set HideReadOnly_State to True
75069>>>>>>>>>    End_Procedure
75070>>>>>>>>>
75070>>>>>>>>>    Function SelectedFileName Returns String
75072>>>>>>>>>        String sFileName
75072>>>>>>>>>        Move "" to sFileName
75073>>>>>>>>>        If (Show_Dialog(Self)) Begin
75075>>>>>>>>>            Move (RTrim(File_Name(Self))) to sFileName
75076>>>>>>>>>        End
75076>>>>>>>>>>
75076>>>>>>>>>        Function_Return sFileName
75077>>>>>>>>>    End_Function
75078>>>>>>>>>
75078>>>>>>>>>End_Class
75079>>>>>>>>>
75079>>>>>>>>>// Added optional default filename as suggested by Nils
75079>>>>>>>>>Function vSelectSaveFile Global String sSupportedFileTypes String sCaptionText String sInitialFolder String sDefaultFileName Returns String
75081>>>>>>>>>    String sSelectedFile
75081>>>>>>>>>    Integer hoDialog
75081>>>>>>>>>
75081>>>>>>>>>    Move "" to sSelectedFile
75082>>>>>>>>>    Get Create (RefClass(cvSaveAsDialog)) to hoDialog
75083>>>>>>>>>    If (hoDialog) Begin
75085>>>>>>>>>    //Set NoChangeDir_State Of hoDialog To True
75085>>>>>>>>>        Set Dialog_Caption    of hoDialog to sCaptionText
75086>>>>>>>>>        Set Filter_String     of hoDialog to sSupportedFileTypes
75087>>>>>>>>>        Set Initial_Folder    of hoDialog to sInitialFolder
75088>>>>>>>>>        If (Num_Arguments = 4) Begin
75090>>>>>>>>>            Set File_Title        of hoDialog to sDefaultFileName
75091>>>>>>>>>        End
75091>>>>>>>>>>
75091>>>>>>>>>        Get SelectedFileName  of hoDialog to sSelectedFile
75092>>>>>>>>>        Send Destroy of hoDialog
75093>>>>>>>>>    End
75093>>>>>>>>>>
75093>>>>>>>>>    Function_Return sSelectedFile
75094>>>>>>>>>End_Function
75095>>>>>>>Use Seq_chnl.pkg
75095>>>>>>>
75095>>>>>>>Use windows.pkg
75095>>>>>>>Use Dll.pkg
75095>>>>>>>
75095>>>>>>>Use vWin32fhW.pkg     // WinAPI Unicode version
Including file: vwin32fhW.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh\vwin32fhW.pkg)
75095>>>>>>>>>// This code is part of VDF GUIdance
75095>>>>>>>>>// Visit us @ http://www.vdf-guidance.com
75095>>>>>>>>>// e-Mail us @ info@vdf-guidance.com
75095>>>>>>>>>// VDF GUIdance is a mutual project of
75095>>>>>>>>>// Frank Vandervelpen - Vandervelpen Systems and
75095>>>>>>>>>// Wil van Antwerpen  - Antwise Solutions
75095>>>>>>>>>// All software source code should be used <<AS IS>> without any warranty.
75095>>>>>>>>>//
75095>>>>>>>>>//
75095>>>>>>>>>// *** Windows 32bit file handling wrapper class ***
75095>>>>>>>>>// Unicode variant
75095>>>>>>>>>
75095>>>>>>>>>Use vWin32fhW.h       // Header file with WinAPI Unicode declarations
Including file: vwin32fhW.h    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh\vwin32fhW.h)
75095>>>>>>>>>>>//TH-Header
75095>>>>>>>>>>>//*****************************************************************************************
75095>>>>>>>>>>>// Copyright (c)  2004 KURANT Project
75095>>>>>>>>>>>// All rights reserved.
75095>>>>>>>>>>>//
75095>>>>>>>>>>>// $FileName    : G:\Projects\vWin32fh\vWin32fh.h
75095>>>>>>>>>>>// $ProjectName : Windows 32 bits file handling
75095>>>>>>>>>>>// $Authors     : Wil van Antwerpen
75095>>>>>>>>>>>// $Created     : 19.02.2004  19:25
75095>>>>>>>>>>>// $Type        : BSD (as in do with it whatever you like)
75095>>>>>>>>>>>//
75095>>>>>>>>>>>// Contents:
75095>>>>>>>>>>>//  This file contains the Windows API external function call definitions and
75095>>>>>>>>>>>//  constants as they are used in the vWin32fh package.
75095>>>>>>>>>>>//*****************************************************************************************
75095>>>>>>>>>>>//TH-RevisionStart
75095>>>>>>>>>>>//TH-RevisionEnd
75095>>>>>>>>>>>
75095>>>>>>>>>>>Define CS_DDE_ERR_FILE_NOT_FOUND  For "The specified file was not found.\n"
75095>>>>>>>>>>>Define CS_DDE_ERR_PATH_NOT_FOUND  For "The specified path was not found.\n"
75095>>>>>>>>>>>Define CS_DDE_ERR_BAD_FORMAT      For "The .EXE file is invalid.\n"
75095>>>>>>>>>>>Define CS_DDE_ERR_ACCESSDENIED    For "The operating system denied access to the specified file.\n"
75095>>>>>>>>>>>Define CS_DDE_ERR_ASSOCINCOMPLETE For "The filename association is incomplete or invalid.\n"
75095>>>>>>>>>>>Define CS_DDE_ERR_DDEBUSY         For "The DDE transaction could not be completed because other DDE\ntransactions were being processed.\n"
75095>>>>>>>>>>>Define CS_DDE_ERR_DDEFAIL         For "The DDE transaction failed.\n"
75095>>>>>>>>>>>Define CS_DDE_ERR_DDETIMEOUT      For "The DDE transaction could not be completed,\nbecause the request timed out.\n"
75095>>>>>>>>>>>Define CS_DDE_ERR_DLLNOTFOUND     For "The specified dynamic-link library was not found.\n"
75095>>>>>>>>>>>Define CS_DDE_ERR_NOASSOC         For "There is no application associated with the given filename extension.\n"
75095>>>>>>>>>>>Define CS_DDE_ERR_OOM             For "There is not enough free memory available to complete the operation.\n"
75095>>>>>>>>>>>Define CS_DDE_ERR_PNF             For "The specified path was not found.\n"
75095>>>>>>>>>>>Define CS_DDE_ERR_SHARE           For "A sharing violation occurred.\n"
75095>>>>>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE1   For "Unknown DDE-error occurred.\nErrornumber"
75095>>>>>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
75095>>>>>>>>>>>Define CS_DDE_ERR_HANDL_PAKTC     For "\nPress a key to continue...\n\n"
75095>>>>>>>>>>>Define CS_DDE_ERR_HANDL_CAPTION   For "a DDE-error occurred"
75095>>>>>>>>>>>
75095>>>>>>>>>>>
75095>>>>>>>>>>>Define vMax_Path     For |CI260
75095>>>>>>>>>>>Define vMinChar      For |CI$80
75095>>>>>>>>>>>Define vMaxChar      For |CI$7F
75095>>>>>>>>>>>Define vMinShort     For |CI$8000
75095>>>>>>>>>>>Define vMaxShort     For |CI$7FFF
75095>>>>>>>>>>>Define vMinLong      For |CI$80000000
75095>>>>>>>>>>>Define vMaxLong      For |CI$7FFFFFFF
75095>>>>>>>>>>>Define vMaxByte      For |CI$FF
75095>>>>>>>>>>>Define vMaxWord      For |CI$FFFF
75095>>>>>>>>>>>Define vMaxDword     For |CI$FFFFFFFF
75095>>>>>>>>>>>
75095>>>>>>>>>>>
75095>>>>>>>>>>>
75095>>>>>>>>>>>// For FindFirstFile
75095>>>>>>>>>>>Define vINVALID_HANDLE_VALUE   For |CI-1
75095>>>>>>>>>>>Define vINVALID_FILE_SIZE      For |CI$FFFFFFFF
75095>>>>>>>>>>>Define vERROR_NO_MORE_FILES    For |CI18
75095>>>>>>>>>>>
75095>>>>>>>>>>>// The defines below can be used to find out what kind of error has occurred if
75095>>>>>>>>>>>// the API-call ShellExecute is used.
75095>>>>>>>>>>>Define vERROR_FILE_NOT_FOUND   For |CI0002
75095>>>>>>>>>>>Define vERROR_PATH_NOT_FOUND   For |CI0003
75095>>>>>>>>>>>Define vERROR_BAD_FORMAT       For |CI0011
75095>>>>>>>>>>>Define vSE_ERR_ACCESSDENIED    For |CI0005
75095>>>>>>>>>>>Define vSE_ERR_ASSOCINCOMPLETE For |CI0027
75095>>>>>>>>>>>Define vSE_ERR_DDEBUSY         For |CI0030
75095>>>>>>>>>>>Define vSE_ERR_DDEFAIL         For |CI0029
75095>>>>>>>>>>>Define vSE_ERR_DDETIMEOUT      For |CI0028
75095>>>>>>>>>>>Define vSE_ERR_DLLNOTFOUND     For |CI0032
75095>>>>>>>>>>>Define vSE_ERR_FNF             For |CI0002
75095>>>>>>>>>>>Define vSE_ERR_NOASSOC         For |CI0031
75095>>>>>>>>>>>Define vSE_ERR_OOM             For |CI0008
75095>>>>>>>>>>>Define vSE_ERR_PNF             For |CI0003
75095>>>>>>>>>>>Define vSE_ERR_SHARE           For |CI0026
75095>>>>>>>>>>>
75095>>>>>>>>>>>
75095>>>>>>>>>>>// C-Structure
75095>>>>>>>>>>>//typedef struct _browseinfo {
75095>>>>>>>>>>>//    HWND hwndOwner;
75095>>>>>>>>>>>//    LPCITEMIDLIST pidlRoot;
75095>>>>>>>>>>>//    LPSTR pszDisplayName;
75095>>>>>>>>>>>//    LPCSTR lpszTitle;
75095>>>>>>>>>>>//    UINT ulFlags;
75095>>>>>>>>>>>//    BFFCALLBACK lpfn;
75095>>>>>>>>>>>//    LPARAM lParam;
75095>>>>>>>>>>>//    int iImage;
75095>>>>>>>>>>>//} BROWSEINFO, *PBROWSEINFO, *LPBROWSEINFO;
75095>>>>>>>>>>>
75095>>>>>>>>>>>//declare C structure struct_browseinfo
75095>>>>>>>>>>>//as documented in MSDN under Windows Shell API
75095>>>>>>>>>>>Struct tvBrowseInfo
75095>>>>>>>>>>>  Handle    hWndOwner
75095>>>>>>>>>>>  Pointer   pIDLRoot
75095>>>>>>>>>>>  Pointer   pszDisplayName
75095>>>>>>>>>>>  Pointer   lpszTitle
75095>>>>>>>>>>>  DWord     ulFlags
75095>>>>>>>>>>>  Pointer   lpfnCallback
75095>>>>>>>>>>>  LongPtr   lParam
75095>>>>>>>>>>>  DWord     iImage
75095>>>>>>>>>>>End_Struct // tvBrowseInfo
75095>>>>>>>>>>>
75095>>>>>>>>>>>// Browsing for directory.
75095>>>>>>>>>>>Define vBIF_RETURNONLYFSDIRS   For |CI$0001  // For finding a folder to start document searching
75095>>>>>>>>>>>Define vBIF_DONTGOBELOWDOMAIN  For |CI$0002  // For starting the Find Computer
75095>>>>>>>>>>>Define vBIF_STATUSTEXT         For |CI$0004  // Includes a status area in the dialog box.
75095>>>>>>>>>>>                                            // The callback function can set the status text by
75095>>>>>>>>>>>                                            // sending messages to the dialog box.
75095>>>>>>>>>>>Define vBIF_RETURNFSANCESTORS  For |CI$0008  // Only returns file system ancestors.
75095>>>>>>>>>>>
75095>>>>>>>>>>>Define vBIF_BROWSEFORCOMPUTER  For |CI$1000  // Browsing for Computers.
75095>>>>>>>>>>>Define vBIF_BROWSEFORPRINTER   For |CI$2000  // Browsing for Printers
75095>>>>>>>>>>>
75095>>>>>>>>>>>// message from browser
75095>>>>>>>>>>>//Define BFFM_INITIALIZED        1
75095>>>>>>>>>>>//Define BFFM_SELCHANGED         2
75095>>>>>>>>>>>
75095>>>>>>>>>>>// messages to browser
75095>>>>>>>>>>>//Define BFFM_SETSTATUSTEXT      (WM_USER + 100)
75095>>>>>>>>>>>//Define BFFM_ENABLEOK           (WM_USER + 101)
75095>>>>>>>>>>>//Define BFFM_SETSELECTION       (WM_USER + 102)
75095>>>>>>>>>>>
75095>>>>>>>>>>>
75095>>>>>>>>>>>External_function vWin32_SHBrowseForFolder "SHBrowseForFolderW" shell32.dll ;  Pointer lpsBrowseInfo Returns dWord
75096>>>>>>>>>>>
75096>>>>>>>>>>>External_function vWin32_SHGetPathFromIDList "SHGetPathFromIDListW" shell32.dll ;  Pointer pidList Pointer lpBuffer Returns dWord
75097>>>>>>>>>>>
75097>>>>>>>>>>>External_function vWin32_CoTaskMemFree "CoTaskMemFree" ole32.dll Pointer pV Returns Integer
75098>>>>>>>>>>>
75098>>>>>>>>>>>
75098>>>>>>>>>>>
75098>>>>>>>>>>>
75098>>>>>>>>>>>Struct tvSecurity_attributes
75098>>>>>>>>>>>  DWord   nLength
75098>>>>>>>>>>>  Pointer lpDescriptor
75098>>>>>>>>>>>  Integer bInheritHandle
75098>>>>>>>>>>>End_Struct // tvSecurity_attributes
75098>>>>>>>>>>>
75098>>>>>>>>>>>//nLength:
75098>>>>>>>>>>>// Specifies the size, in bytes, of this structure. Set this value to the size of the
75098>>>>>>>>>>>// SECURITY_ATTRIBUTES structure.
75098>>>>>>>>>>>// Windows NT: Some functions that use the SECURITY_ATTRIBUTES structure do not verify the
75098>>>>>>>>>>>// value of the nLength member. However, an application should still set it properly.
75098>>>>>>>>>>>// That ensures current, future, and cross-platform compatibility.
75098>>>>>>>>>>>//
75098>>>>>>>>>>>//lpSecurityDescriptor:
75098>>>>>>>>>>>// Points to a security descriptor for the object that controls the sharing of it.
75098>>>>>>>>>>>// If NULL is specified for this member, the object may be assigned the default security
75098>>>>>>>>>>>// descriptor of the calling process.
75098>>>>>>>>>>>//
75098>>>>>>>>>>>//bInheritHandle:
75098>>>>>>>>>>>// Specifies whether the returned handle is inherited when a new process is created.
75098>>>>>>>>>>>// If this member is TRUE, the new process inherits the handle.
75098>>>>>>>>>>>
75098>>>>>>>>>>>
75098>>>>>>>>>>>// BOOL CreateDirectory(
75098>>>>>>>>>>>//    LPCTSTR lpPathName,
75098>>>>>>>>>>>//    LPSECURITY_ATTRIBUTES lpSecurityAttributes  // pointer to a security descriptor
75098>>>>>>>>>>>//   );
75098>>>>>>>>>>>//
75098>>>>>>>>>>>// lpPathName
75098>>>>>>>>>>>//  Points to a null-terminated string that specifies the path of the directory
75098>>>>>>>>>>>//  to be created.
75098>>>>>>>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
75098>>>>>>>>>>>//  This limit is related to how the CreateDirectory function parses paths.
75098>>>>>>>>>>>// lpSecurityAttributes
75098>>>>>>>>>>>//  Pointer to a SECURITY_ATTRIBUTES structure als called a security descriptor that
75098>>>>>>>>>>>//  determines whether the returned handle can be inherited by child processes.
75098>>>>>>>>>>>//  If lpSecurityAttributes is NULL, the handle cannot be inherited.
75098>>>>>>>>>>>// Returns:
75098>>>>>>>>>>>//  If the function succeeds, the return value is nonzero.
75098>>>>>>>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
75098>>>>>>>>>>>External_function vWin32_CreateDirectory "CreateDirectoryW" kernel32.dll ;  WString sPathName Pointer lpSecurity_Attributes Returns Integer
75099>>>>>>>>>>>
75099>>>>>>>>>>>
75099>>>>>>>>>>>// lpPathName
75099>>>>>>>>>>>//  Points to a null-terminated string that specifies the path of the directory
75099>>>>>>>>>>>//  to be removed.
75099>>>>>>>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
75099>>>>>>>>>>>// Returns:
75099>>>>>>>>>>>//  If the function succeeds, the return value is nonzero.
75099>>>>>>>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
75099>>>>>>>>>>>External_function vWin32_RemoveDirectory "RemoveDirectoryW" kernel32.dll ;  WString sPathName Returns Integer
75100>>>>>>>>>>>
75100>>>>>>>>>>>
75100>>>>>>>>>>>
75100>>>>>>>>>>>// The ShellExecute function opens or prints a specified file. The file can be an
75100>>>>>>>>>>>// executable file or a document file.
75100>>>>>>>>>>>//
75100>>>>>>>>>>>// Operation can be one of the following:
75100>>>>>>>>>>>//    "OPEN"  The function opens the file specified by lpFile.
75100>>>>>>>>>>>//            The file can be an executable file or a document file.
75100>>>>>>>>>>>//            The file can be a folder to open.
75100>>>>>>>>>>>//    "PRINT" The function prints the file specified by lpFile.
75100>>>>>>>>>>>//            The file should be a document file. If the file is an executable file,
75100>>>>>>>>>>>//            the function opens the file, as if "open" had been specified.
75100>>>>>>>>>>>//  "EXPLORE" The function explores the folder specified by lpFile.
75100>>>>>>>>>>>//
75100>>>>>>>>>>>// Return Values:
75100>>>>>>>>>>>//
75100>>>>>>>>>>>// If the function succeeds, the return value is the instance handle of the application that
75100>>>>>>>>>>>// was run, or the handle of a dynamic data exchange (DDE) server application.
75100>>>>>>>>>>>// If the function fails, the return value is an error value that is less than or equal to 32.
75100>>>>>>>>>>>//
75100>>>>>>>>>>>// The following table lists these error values:
75100>>>>>>>>>>>// Public Const ERROR_FILE_NOT_FOUND = 2&
75100>>>>>>>>>>>// Public Const ERROR_PATH_NOT_FOUND = 3&
75100>>>>>>>>>>>// Public Const ERROR_BAD_FORMAT = 11&
75100>>>>>>>>>>>// Public Const SE_ERR_ACCESSDENIED = 5
75100>>>>>>>>>>>// Public Const SE_ERR_ASSOCINCOMPLETE = 27
75100>>>>>>>>>>>// Public Const SE_ERR_DDEBUSY = 30
75100>>>>>>>>>>>// Public Const SE_ERR_DDEFAIL = 29
75100>>>>>>>>>>>// Public Const SE_ERR_DDETIMEOUT = 28
75100>>>>>>>>>>>// Public Const SE_ERR_DLLNOTFOUND = 32
75100>>>>>>>>>>>// Public Const SE_ERR_FNF = 2
75100>>>>>>>>>>>// Public Const SE_ERR_NOASSOC = 31
75100>>>>>>>>>>>// Public Const SE_ERR_OOM = 8
75100>>>>>>>>>>>// Public Const SE_ERR_PNF = 3
75100>>>>>>>>>>>// Public Const SE_ERR_SHARE = 26
75100>>>>>>>>>>>
75100>>>>>>>>>>>
75100>>>>>>>>>>>
75100>>>>>>>>>>>// Code to open the program that is associated with the selected file.
75100>>>>>>>>>>>//
75100>>>>>>>>>>>// External function call used in Procedure DoStartDocument
75100>>>>>>>>>>>External_function vWin32_ShellExecute "ShellExecuteW" shell32.dll ;  Handle  hWnd ;  WString wsOperation ;  WString wsFile ;  WString wsParameters ;  WString wsDirectory ;  Dword   iShowCmd Returns Handle
75101>>>>>>>>>>>
75101>>>>>>>>>>>
75101>>>>>>>>>>>
75101>>>>>>>>>>>
75101>>>>>>>>>>>Define vFO_MOVE                For |CI$0001
75101>>>>>>>>>>>Define vFO_COPY                For |CI$0002
75101>>>>>>>>>>>Define vFO_DELETE              For |CI$0003
75101>>>>>>>>>>>Define vFO_RENAME              For |CI$0004
75101>>>>>>>>>>>
75101>>>>>>>>>>>Define vFOF_MULTIDESTFILES     For |CI$0001
75101>>>>>>>>>>>Define vFOF_CONFIRMMOUSE       For |CI$0002
75101>>>>>>>>>>>Define vFOF_SILENT             For |CI$0004  // don't create progress/report
75101>>>>>>>>>>>Define vFOF_RENAMEONCOLLISION  For |CI$0008
75101>>>>>>>>>>>Define vFOF_NOCONFIRMATION     For |CI$0010  // Don't prompt the user.
75101>>>>>>>>>>>Define vFOF_WANTMAPPINGHANDLE  For |CI$0020  // Fill in SHFILEOPSTRUCT.hNameMappings
75101>>>>>>>>>>>                                          // Must be freed using SHFreeNameMappings
75101>>>>>>>>>>>Define vFOF_ALLOWUNDO          For |CI$0040
75101>>>>>>>>>>>Define vFOF_FILESONLY          For |CI$0080  // on *.*, do only files
75101>>>>>>>>>>>Define vFOF_SIMPLEPROGRESS     For |CI$0100  // means don't show names of files
75101>>>>>>>>>>>Define vFOF_NOCONFIRMMKDIR     For |CI$0200  // don't confirm making any needed dirs
75101>>>>>>>>>>>
75101>>>>>>>>>>>Struct tvShFileOpStruct
75101>>>>>>>>>>>  Handle   hWnd
75101>>>>>>>>>>>  UInteger wFunc
75101>>>>>>>>>>>  Pointer  pFrom
75101>>>>>>>>>>>  Pointer  pTo
75101>>>>>>>>>>>  Short    fFlags
75101>>>>>>>>>>>  Integer  fAnyOperationsAborted
75101>>>>>>>>>>>  Pointer  hNameMappings
75101>>>>>>>>>>>  Pointer  lpszProgressTitle      // only used if FOF_SIMPLEPROGRESS
75101>>>>>>>>>>>End_Struct // tvShFileOpStruct
75101>>>>>>>>>>>
75101>>>>>>>>>>>// hwnd
75101>>>>>>>>>>>//   Handle of the dialog box to use to display information about the status of the operation.
75101>>>>>>>>>>>
75101>>>>>>>>>>>// wFunc
75101>>>>>>>>>>>//   Operation to perform. This member can be one of the following values:
75101>>>>>>>>>>>//     FO_COPY     Copies the files specified by pFrom to the location specified by pTo.
75101>>>>>>>>>>>//     FO_DELETE   Deletes the files specified by pFrom (pTo is ignored).
75101>>>>>>>>>>>//     FO_MOVE     Moves the files specified by pFrom to the location specified by pTo.
75101>>>>>>>>>>>//     FO_RENAME   Renames the files specified by pFrom.
75101>>>>>>>>>>>
75101>>>>>>>>>>>// pFrom
75101>>>>>>>>>>>//   Pointer to a buffer that specifies one or more source file names. Multiple names must
75101>>>>>>>>>>>//   be null-separated. The list of names must be double null-terminated.
75101>>>>>>>>>>>
75101>>>>>>>>>>>// pTo
75101>>>>>>>>>>>//   Pointer to a buffer that contains the name of the destination file or directory. The
75101>>>>>>>>>>>//   buffer can contain mutiple destination file names if the fFlags member specifies
75101>>>>>>>>>>>//   FOF_MULTIDESTFILES. Multiple names must be null-separated. The list of names must be
75101>>>>>>>>>>>//   double null-terminated.
75101>>>>>>>>>>>
75101>>>>>>>>>>>// fAnyOperationsAborted
75101>>>>>>>>>>>//   Value that receives TRUE if the user aborted any file operations before they
75101>>>>>>>>>>>//   were completed or FALSE otherwise.
75101>>>>>>>>>>>
75101>>>>>>>>>>>
75101>>>>>>>>>>>// Performs a copy, move, rename, or delete operation on a file system object.
75101>>>>>>>>>>>// This can be a file or a folder.
75101>>>>>>>>>>>// With thanks to Andrew S Kaplan
75101>>>>>>>>>>>External_function vWin32_SHFileOperation "SHFileOperationW" Shell32.dll ;        Pointer lpFileOp Returns Integer
75102>>>>>>>>>>>
75102>>>>>>>>>>>
75102>>>>>>>>>>>// Thanks To Oliver Nelson for posting this code on the newsgroups
75102>>>>>>>>>>>External_function vWin32_GetWindowsDirectory "GetWindowsDirectoryW" kernel32.dll ;                           Pointer lpBuffer Integer nSize Returns Integer
75103>>>>>>>>>>>
75103>>>>>>>>>>>
75103>>>>>>>>>>>
75103>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
75103>>>>>>>>>>>//External_Function vWin32_GetTempFileName "GetTempFileNameA" Kernel32.Dll ;
75103>>>>>>>>>>>//   Pointer lpPathName ;
75103>>>>>>>>>>>//   Pointer lpPrefixString ;
75103>>>>>>>>>>>//   Integer uUnique ;
75103>>>>>>>>>>>//   Pointer lpTempFileName ;
75103>>>>>>>>>>>//   Returns Integer
75103>>>>>>>>>>>// **WvA: 28-04-2005 Changed string parameter type into pointers
75103>>>>>>>>>>>External_function vWin32_GetTempFileName "GetTempFileNameW" kernel32.dll WString sPath ;        WString sPrefix Integer iUnique Pointer lpTempFileName Returns Integer
75104>>>>>>>>>>>
75104>>>>>>>>>>>External_function vWin32_GetTempPath "GetTempPathW" Kernel32.Dll ;   Dword nBufferLength ;   Pointer lpBuffer ;   Returns Integer
75105>>>>>>>>>>>
75105>>>>>>>>>>>External_function vWin32_DeleteFile "DeleteFileW" Kernel32.Dll ;   WString sFileName ;   Returns Integer
75106>>>>>>>>>>>
75106>>>>>>>>>>>// from:
75106>>>>>>>>>>>// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/shellcc/platform/shell/reference/enums/csidl.asp
75106>>>>>>>>>>>//
75106>>>>>>>>>>>Define vCSIDL_FLAG_CREATE       For |CI$8000 // IE5+, use this to create a special folder
75106>>>>>>>>>>>Define vCSIDL_ADMIN_TOOLS       For |CI$0030 // IE5+, The file system directory that is used to store administrative tools for an individual user
75106>>>>>>>>>>>Define vCSIDL_ALT_STARTUP       For |CI$001D // The file system directory that corresponds to the user's nonlocalized Startup program group
75106>>>>>>>>>>>Define vCSIDL_APPDATA           For |CI$001A // Version 4.71. The file system directory that serves as a common repository for application-specific data. A typical path is C:\Documents and Settings\<username>\Application Data
75106>>>>>>>>>>>Define vCSIDL_BITBUCKET         For |CI$000A // The virtual folder containing the objects in the user's Recycle Bin
75106>>>>>>>>>>>Define vCSIDL_CDBURN_AREA       For |CI$003B // IE6+ The file system directory acting as a staging area for files waiting to be written to CD. A typical path is C:\Documents and Settings\<username>\Local Settings\Application Data\Microsoft\CD Burning
75106>>>>>>>>>>>Define vCSIDL_COMMON_ADMINTOOLS For |CI$002F // IE5+ The file system directory containing administrative tools for all users of the computer
75106>>>>>>>>>>>Define vCSIDL_COMMON_ALTSTARTUP For |CI$001E // The file system directory that corresponds to the nonlocalized Startup program group for all users
75106>>>>>>>>>>>Define vCSIDL_COMMON_APPDATA    For |CI$0023 // IE5+ The file system directory containing application data for all users. A typical path is C:\Documents and Settings\All Users\Application Data
75106>>>>>>>>>>>Define vCSIDL_COMMON_DESKTOPDIRECTORY for |CI$0019 // WinNT+ Only, The file system directory that contains files and folders that appear on the desktop for all users. A typical path is C:\Documents and Settings\All Users\Desktop
75106>>>>>>>>>>>Define vCSIDL_COMMON_DOCUMENTS  For |CI$002E // IE5+ The file system directory that contains documents that are common to all users. A typical paths is C:\Documents and Settings\All Users\Documents
75106>>>>>>>>>>>Define vCSIDL_COMMON_FAVORITES  For |CI$001F // The file system directory that serves as a common repository for favorite items common to all users
75106>>>>>>>>>>>Define vCSIDL_COMMON_MUSIC      For |CI$0035 // IE6+ The file system directory that serves as a repository for music files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Music
75106>>>>>>>>>>>Define vCSIDL_COMMON_PICTURES   For |CI$0036 // The file system directory that serves as a repository for image files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Pictures
75106>>>>>>>>>>>Define vCSIDL_COMMON_PROGRAMS   For |CI$0017 // WinNT+ The file system directory that contains the directories for the common program groups that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs
75106>>>>>>>>>>>Define vCSIDL_COMMON_STARTMENU  For |CI$0016 // WinNT+ The file system directory that contains the programs and folders that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu
75106>>>>>>>>>>>Define vCSIDL_COMMON_STARTUP    For |CI$0018 // WinNT+ The file system directory that contains the programs that appear in the Startup folder for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs\Startup
75106>>>>>>>>>>>Define vCSIDL_COMMON_TEMPLATES  For |CI$002D // WinNT+ The file system directory that contains the templates that are available to all users. A typical path is C:\Documents and Settings\All Users\Templates
75106>>>>>>>>>>>Define vCSIDL_COMMON_VIDEO      For |CI$0037 // IE6+ The file system directory that serves as a repository for video files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Videos
75106>>>>>>>>>>>Define vCSIDL_COMPUTERSNEARME   For |CI$003D // The folder representing other machines in your workgroup
75106>>>>>>>>>>>Define vCSIDL_CONNECTIONS       For |CI$0031 // The virtual folder representing Network Connections, containing network and dial-up connections
75106>>>>>>>>>>>Define vCSIDL_CONTROLS          For |CI$0003 // The virtual folder containing icons for the Control Panel applications
75106>>>>>>>>>>>Define vCSIDL_COOKIES           For |CI$0021 // The file system directory that serves as a common repository for Internet cookies. A typical path is C:\Documents and Settings\username\Cookies
75106>>>>>>>>>>>Define vCSIDL_DESKTOP           For |CI$0000 // The virtual folder representing the Windows desktop, the root of the namespace
75106>>>>>>>>>>>Define vCSIDL_DESKTOPDIRECTORY  For |CI$0010 // The file system directory used to physically store file objects on the desktop (not to be confused with the desktop folder itself). A typical path is C:\Documents and Settings\username\Desktop
75106>>>>>>>>>>>Define vCSIDL_DRIVES            For |CI$0011 // The virtual folder representing My Computer, containing everything on the local computer: storage devices, printers, and Control Panel. The folder may also contain mapped network drives
75106>>>>>>>>>>>Define vCSIDL_FAVORITES         For |CI$0006 // The file system directory that serves as a common repository for the user's favorite items. A typical path is C:\Documents and Settings\username\Favorites
75106>>>>>>>>>>>Define vCSIDL_FONTS             For |CI$0014 // A virtual folder containing fonts. A typical path is C:\Windows\Fonts
75106>>>>>>>>>>>Define vCSIDL_HISTORY           For |CI$0022 // The file system directory that serves as a common repository for Internet history items
75106>>>>>>>>>>>Define vCSIDL_INTERNET          For |CI$0001 // A virtual folder representing the Internet
75106>>>>>>>>>>>Define vCSIDL_INTERNET_CACHE    For |CI$0020 // Comctl4.72+, The file system directory that serves as a common repository for temporary Internet files. A typical path is C:\Documents and Settings\username\Local Settings\Temporary Internet Files
75106>>>>>>>>>>>Define vCSIDL_LOCAL_APPDATA     For |CI$001C // IE5+ The file system directory that serves as a data repository for local (nonroaming) applications. A typical path is C:\Documents and Settings\username\Local Settings\Application Data
75106>>>>>>>>>>>Define vCSIDL_MYDOCUMENTS       For |CI$000C // IE6+ The virtual folder representing the My Documents desktop item
75106>>>>>>>>>>>Define vCSIDL_MYMUSIC           For |CI$000D // The file system directory that serves as a common repository for music files. A typical path is C:\Documents and Settings\User\My Documents\My Music
75106>>>>>>>>>>>Define vCSIDL_MYPICTURES        For |CI$0027 // IE5+ The file system directory that serves as a common repository for image files. A typical path is C:\Documents and Settings\username\My Documents\My Pictures
75106>>>>>>>>>>>Define vCSIDL_MYVIDEO           For |CI$000E // IE6+ The file system directory that serves as a common repository for video files. A typical path is C:\Documents and Settings\username\My Documents\My Videos
75106>>>>>>>>>>>Define vCSIDL_NETHOOD           For |CI$0013 // A file system directory containing the link objects that may exist in the My Network Places virtual folder. It is not the same as CSIDL_NETWORK, which represents the network namespace root. A typical path is C:\Documents and Settings\username\NetHood
75106>>>>>>>>>>>Define vCSIDL_NETWORK           For |CI$0012 // A virtual folder representing Network Neighborhood, the root of the network namespace hierarchy
75106>>>>>>>>>>>Define vCSIDL_PERSONAL          For |CI$0005 // (Documents folder) IE6 The virtual folder representing the My Documents desktop item.
75106>>>>>>>>>>>                                             // This is equivalent to CSIDL_MYDOCUMENTS. Previous to Version 6.0. The file system directory used to physically store a user's common repository of documents. A typical path is C:\Documents and Settings\username\My Documents
75106>>>>>>>>>>>Define vCSIDL_PHOTOALBUMS       For |CI$0045 // Vista+ The virtual folder used to store photo albums, typically username\My Pictures\Photo Albums
75106>>>>>>>>>>>Define vCSIDL_PLAYLISTS         For |CI$003F // Vista+ The virtual folder used to store play albums, typically username\My Music\Playlists
75106>>>>>>>>>>>Define vCSIDL_PRINTERS          For |CI$0004 // The virtual folder containing installed printers
75106>>>>>>>>>>>Define vCSIDL_PRINTHOOD         For |CI$001B // The file system directory that contains the link objects that can exist in the Printers virtual folder. A typical path is C:\Documents and Settings\username\PrintHood
75106>>>>>>>>>>>Define vCSIDL_PROFILE           For |CI$0028 // IE5+ The user's profile folder. A typical path is C:\Documents and Settings\username
75106>>>>>>>>>>>Define vCSIDL_PROGRAM_FILES     For |CI$0026 // IE5+ The Program Files folder. A typical path is C:\Program Files
75106>>>>>>>>>>>Define vCSIDL_PROGRAM_FILESx86  for |CI$002A // The Program Files folder for x86 programs. A typical path is C:\Program Files (x86)
75106>>>>>>>>>>>Define vCSIDL_PROGRAM_FILES_COMMON For |CI$002B // IE5+, WinNT+ A folder for components that are shared across applications. A typical path is C:\Program Files\Common
75106>>>>>>>>>>>Define vCSIDL_PROGRAMS          For |CI$0002 // The file system directory that contains the user's program groups (which are themselves file system directories). A typical path is C:\Documents and Settings\username\Start Menu\Programs
75106>>>>>>>>>>>Define vCSIDL_RECENT            For |CI$0008 // The file system directory that contains shortcuts to the user's most recently used documents. A typical path is C:\Documents and Settings\username\My Recent Documents
75106>>>>>>>>>>>Define vCSIDL_RESOURCES         For |CI$0038 // undocumented
75106>>>>>>>>>>>Define vCSIDL_SAMPLE_MUSIC      For |CI$0040 // Vista+, The file system directory that contains sample music. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Music
75106>>>>>>>>>>>Define vCSIDL_SAMPLE_PLAYLISTS  For |CI$0041 // Vista+, The file system directory that contains sample playlists. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Playlists
75106>>>>>>>>>>>Define vCSIDL_SAMPLE_PICTURES   For |CI$0042 // Vista+, The file system directory that contains sample pictures. A typical path is C:\Documents and Settings\username\My Documents\My Pictures\Sample Pictures
75106>>>>>>>>>>>Define vCSIDL_SAMPLE_VIDEOS     For |CI$0043 // Vista+, The file system directory that contains sample videos. A typical path is C:\Documents and Settings\username\My Documents\My Videos\Sample Videos
75106>>>>>>>>>>>Define vCSIDL_SENDTO            For |CI$0009 // The file system directory that contains Send To menu items. A typical path is C:\Documents and Settings\username\SendTo
75106>>>>>>>>>>>Define vCSIDL_STARTMENU         For |CI$000B // The file system directory containing Start menu items. A typical path is C:\Documents and Settings\username\Start Menu
75106>>>>>>>>>>>Define vCSIDL_STARTUP           For |CI$0007 // The file system directory that corresponds to the user's Startup program group. The system starts these programs whenever any user logs onto Windows NT or starts Windows 95. A typical path is C:\Documents and Settings\username\Start Menu\Programs\Startup
75106>>>>>>>>>>>Define vCSIDL_SYSTEM            For |CI$0025 // The Windows System folder. A typical path is C:\Windows\System32
75106>>>>>>>>>>>Define vCSIDL_SYSTEMX86         For |CI$0029 //
75106>>>>>>>>>>>Define vCSIDL_TEMPLATES         For |CI$0015 // The file system directory that serves as a common repository for document templates. A typical path is C:\Documents and Settings\username\Templates
75106>>>>>>>>>>>Define vCSIDL_WINDOWS           For |CI$0024 // The Windows directory or SYSROOT. This corresponds to the %windir% or %SYSTEMROOT% environment variables. A typical path is C:\Windows
75106>>>>>>>>>>>
75106>>>>>>>>>>>
75106>>>>>>>>>>>//HRESULT SHGetFolderPath(
75106>>>>>>>>>>>//    HWND hwndOwner,
75106>>>>>>>>>>>//    int nFolder,
75106>>>>>>>>>>>//    HANDLE hToken,
75106>>>>>>>>>>>//    DWORD dwFlags,
75106>>>>>>>>>>>//    LPTSTR pszPath
75106>>>>>>>>>>>//);
75106>>>>>>>>>>>// This function is a superset of SHGetSpecialFolderPath, included with earlier versions of
75106>>>>>>>>>>>// the shell. It is implemented in a redistributable DLL, SHFolder.dll, that also simulates
75106>>>>>>>>>>>// many of the new shell folders on older platforms such as Windows 95, Windows 98, and
75106>>>>>>>>>>>// Windows NT 4.0. This DLL always calls the current platform's version of this function.
75106>>>>>>>>>>>// If that fails, it will try to simulate the appropriate behavior.
75106>>>>>>>>>>>//
75106>>>>>>>>>>>External_function vWin32_SHGetFolderPath "SHGetFolderPathW" SHFolder.Dll ;   Pointer hWnd ;   Integer nFolder ;   Pointer hToken ;   DWord   dwFlags ;   Pointer lpszPath ;   Returns Integer
75107>>>>>>>>>>>
75107>>>>>>>>>>>
75107>>>>>>>>>>>
75107>>>>>>>>>>>Struct tvWin32FindData
75107>>>>>>>>>>> Dword            dwFileAttributes
75107>>>>>>>>>>> Dword            ftCreationLowDateTime
75107>>>>>>>>>>> Dword            ftCreationHighDateTime
75107>>>>>>>>>>> dword            ftLastAccessLowDateTime
75107>>>>>>>>>>> Dword            ftLastAccessHighDateTime
75107>>>>>>>>>>> Dword            ftLastWriteLowDateTime
75107>>>>>>>>>>> Dword            ftLastWriteHighDateTime
75107>>>>>>>>>>> Dword            nFileSizeHigh
75107>>>>>>>>>>> Dword            nFileSizeLow
75107>>>>>>>>>>> Dword            dwReserved0
75107>>>>>>>>>>> Dword            dwReserved1
75107>>>>>>>>>>> Short[vMax_Path] cFileName
75107>>>>>>>>>>> Short[14]        cAlternateFileName
75107>>>>>>>>>>>End_Struct
75107>>>>>>>>>>>
75107>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
75107>>>>>>>>>>>// lpFileName      : address of name of file to search for
75107>>>>>>>>>>>// lpFindFileData  : address of returned information
75107>>>>>>>>>>>External_function vWin32_FindFirstFile "FindFirstFileW"  Kernel32.dll WString sFileName ;          Pointer lpFindFileData Returns Handle
75108>>>>>>>>>>>
75108>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
75108>>>>>>>>>>>// hFindFile       : handle of search
75108>>>>>>>>>>>// lpFindFileData  : address of structure for data on found file
75108>>>>>>>>>>>External_function vWin32_FindNextFile "FindNextFileW" Kernel32.dll Handle hFindFile ;          Pointer lpFindFileData Returns Integer
75109>>>>>>>>>>>
75109>>>>>>>>>>>
75109>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
75109>>>>>>>>>>>//  hFindFile      : file search handle
75109>>>>>>>>>>>External_function vWin32_FindClose "FindClose" Kernel32.dll Handle hFindFile Returns Integer
75110>>>>>>>>>>>
75110>>>>>>>>>>>
75110>>>>>>>>>>>
75110>>>>>>>>>>>Struct tvFileTime
75110>>>>>>>>>>>  DWord dwLowDateTime
75110>>>>>>>>>>>  DWord dwHighDateTime
75110>>>>>>>>>>>End_Struct
75110>>>>>>>>>>>
75110>>>>>>>>>>>
75110>>>>>>>>>>>Struct tvSystemTime
75110>>>>>>>>>>>  UShort wYear
75110>>>>>>>>>>>  UShort wMonth
75110>>>>>>>>>>>  UShort wDayOfWeek
75110>>>>>>>>>>>  UShort wDay
75110>>>>>>>>>>>  UShort wHour
75110>>>>>>>>>>>  UShort wMinute
75110>>>>>>>>>>>  UShort wSecond
75110>>>>>>>>>>>  UShort wMilliSeconds
75110>>>>>>>>>>>End_Struct
75110>>>>>>>>>>>
75110>>>>>>>>>>>
75110>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
75110>>>>>>>>>>>//  lpFileTime     : pointer to file time to convert
75110>>>>>>>>>>>//  lpSystemTime   : pointer to structure to receive system time
75110>>>>>>>>>>>External_function vWin32_FileTimeToSystemTime "FileTimeToSystemTime" Kernel32.Dll ;          Pointer lpFileTime Pointer lpsystemTime Returns Integer
75111>>>>>>>>>>>
75111>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
75111>>>>>>>>>>>// This function formats the time in a picture-string passed
75111>>>>>>>>>>>//
75111>>>>>>>>>>>// Picture      Meaning
75111>>>>>>>>>>>//    h         Hours with no leading zero for single-digit hours; 12-hour clock
75111>>>>>>>>>>>//    hh        Hours with leading zero for single-digit hours; 12-hour clock
75111>>>>>>>>>>>//    H         Hours with no leading zero for single-digit hours; 24-hour clock
75111>>>>>>>>>>>//    HH        Hours with leading zero for single-digit hours; 24-hour clock
75111>>>>>>>>>>>//    m         Minutes with no leading zero for single-digit minutes
75111>>>>>>>>>>>//    mm        Minutes with leading zero for single-digit minutes
75111>>>>>>>>>>>//    s         Seconds with no leading zero for single-digit seconds
75111>>>>>>>>>>>//    ss        Seconds with leading zero for single-digit seconds
75111>>>>>>>>>>>//    t         One character time marker string, such as A or P
75111>>>>>>>>>>>//    tt        Multicharacter time marker string, such as AM or PM
75111>>>>>>>>>>>//
75111>>>>>>>>>>>// For example, to get the time string  "11:29:40 PM"
75111>>>>>>>>>>>//    use the following picture string: "hh" : "mm" : "ss tt"
75111>>>>>>>>>>>
75111>>>>>>>>>>>External_function vWin32_GetTimeFormat "GetTimeFormatW" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpTimeStr ;  Integer cchTime Returns Integer
75112>>>>>>>>>>>
75112>>>>>>>>>>>
75112>>>>>>>>>>>// Courtesy Of Vincent Oorsprong
75112>>>>>>>>>>>// This function formats the date in a picture-string passed
75112>>>>>>>>>>>//
75112>>>>>>>>>>>// Picture      Meaning
75112>>>>>>>>>>>//    d         Day of month as digits with no leading zero for single-digit days.
75112>>>>>>>>>>>//    dd        Day of month as digits with leading zero for single-digit days.
75112>>>>>>>>>>>//    ddd       Day of week as a three-letter abbreviation. The function uses the
75112>>>>>>>>>>>//              LOCALE_SABBREVOAYMAME value associated with the specified locale.
75112>>>>>>>>>>>//    dddd      Day of week as its full name. The function uses the LOCALE_SDAYNAME
75112>>>>>>>>>>>//              value associated with the specified locale.
75112>>>>>>>>>>>//    M         Month as digits with no leading zero for single-digit months.
75112>>>>>>>>>>>//    MM        Month as digits with leading zero for single-digit months.
75112>>>>>>>>>>>//    MMM       Month as a three-letter abbreviation. The function uses the
75112>>>>>>>>>>>//              LOCALE_SABBREVMONTHNAME value associated with the specified locale.
75112>>>>>>>>>>>//    MMMM      Month as its full name. The function uses the LOCALE_SMONTHNAME value
75112>>>>>>>>>>>//              associated with the specified locale.
75112>>>>>>>>>>>//    y         Year as last two digits, but with no leading zero for years less than 10.
75112>>>>>>>>>>>//    yy        Year as last two digits, but with leading zero for years less than 10.
75112>>>>>>>>>>>//    yyyy      Year represented hy full four digits.
75112>>>>>>>>>>>//    gg        Period/era string. The function uses the CAL_SERASTRING value associated
75112>>>>>>>>>>>//              with the specified locale. This element is ignored if the date to be formatted
75112>>>>>>>>>>>//              does not have an associated era or period string.
75112>>>>>>>>>>>// For example, to get the date string  "Wed, Aug 31 94"
75112>>>>>>>>>>>// use the following picture string:    "ddd","MMM dd yy"
75112>>>>>>>>>>>
75112>>>>>>>>>>>External_function vWin32_GetDateFormat "GetDateFormatW" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpDateStr ;  Integer cchDate Returns Integer
75113>>>>>>>>>>>
75113>>>>>>>>>>>Define LOCALE_NOUSEROVERRIDE    For |CI$80000000  //  do not use user overrides
75113>>>>>>>>>>>Define TIME_NOMIHUTESORSECONDS  For |CI$00000001  //  do not use minutes or seconds
75113>>>>>>>>>>>Define TIME_NOSECONDS           For |CI$00000002  //  do not use seconds
75113>>>>>>>>>>>Define TIME_NOTIMEMARKER        For |CI$00000004  //  do not use time marker
75113>>>>>>>>>>>Define TIME_FORCE24HOURFORMAT   For |CI$00000008  //  always use 24 hour format
75113>>>>>>>>>>>
75113>>>>>>>>>>>//  Date Flags for GetDateFormatW.
75113>>>>>>>>>>>//
75113>>>>>>>>>>>Define DATE_SHORTDATE           For |CI$00000001  //  use short date picture
75113>>>>>>>>>>>Define DATE_LONGDATE            For |CI$00000002  //  use long date picture
75113>>>>>>>>>>>Define DATE_USE_ALT_CALENDAR    For |CI$00000004  //  use alternate calendar (if any)
75113>>>>>>>>>>>
75113>>>>>>>>>>>
75113>>>>>>>>>>>External_function vWin32_SetLastError "SetLastError" Kernel32.Dll Dword dwLastError Returns Integer
75114>>>>>>>>>>>
75114>>>>>>>>>>>
75114>>>>>>>>>>>// **WvA: 20-02-2004
75114>>>>>>>>>>>// While i was testing the format capabilities i stumbled over a very
75114>>>>>>>>>>>// weird problem where it looks like that the integer value gets somehow translated
75114>>>>>>>>>>>// incorrectly into an unsigned integer.
75114>>>>>>>>>>>// I don't have the time to dive into this.. so added a workaround (and removed it again)
75114>>>>>>>>>>>// It does smell a bit fishy though
75114>>>>>>>>>>>// Tested it with the same results on both VDF7 and VDF9.1
75114>>>>>>>>>>>
75114>>>>>>>>>>>Define SHFMT_ID_DEFAULT        For |CI$0000FFFF // The default format ID
75114>>>>>>>>>>>Define SHFMT_OPT_DEFAULT       For |CI$00000000 // The default "Quick Format" option.
75114>>>>>>>>>>>Define SHFMT_OPT_FULL          For |CI$00000001 // Deselects the "Quick Format" option, providing a full format instead. This is useful when an unformatted disk is detected.
75114>>>>>>>>>>>Define SHFMT_OPT_SYSONLY       For |CI$00000002 // Selects the "Create an MS-DOS startup disk" option, creating a system boot disk.
75114>>>>>>>>>>>
75114>>>>>>>>>>>// Possible errors that can be returned by the shellformat function
75114>>>>>>>>>>>Define SHFMT_ERROR             For (|CI$FFFFFFFF+1) // An error occurred during the last format or no drive parameter passed. This does not indicate that the disk is unformatable.
75114>>>>>>>>>>>Define SHFMT_CANCEL            For (|CI$FFFFFFFE+1) // The last format was canceled.
75114>>>>>>>>>>>Define SHFMT_NOFORMAT          For (|CI$FFFFFFFD+1) // The drive cannot be formatted.
75114>>>>>>>>>>>
75114>>>>>>>>>>>
75114>>>>>>>>>>> // Courtesy Of Steve Walter,
75114>>>>>>>>>>> // USA Software, Inc
75114>>>>>>>>>>> // Format a disk
75114>>>>>>>>>>> // Called By:  Move (vWin32_ShFormatDrive(hWnd,0,$FFFF,1)) To dwReturn
75114>>>>>>>>>>>External_function vWin32_ShFormatDrive "SHFormatDrive" shell32.dll Handle hWnd ;         Integer iDrive Integer iFormatID Integer iOptions Returns DWORD
75115>>>>>>>>>>>
75115>>>>>>>>>>>// Michael Mullan.  I Wanted to create all the folders in one statement...
75115>>>>>>>>>>>
75115>>>>>>>>>>>// SHCreateDirectoryEx
75115>>>>>>>>>>>
75115>>>>>>>>>>>//    Note  This function is available through Microsoft Windows XP Service Pack 2 (SP2) and Windows Server 2003.
75115>>>>>>>>>>>//    It might be altered or unavailable in subsequent versions of Windows.
75115>>>>>>>>>>>//
75115>>>>>>>>>>>//    This function creates a file system folder whose fully qualified path is given by pszPath. If one or more
75115>>>>>>>>>>>//    of the intermediate folders do not exist, they are created as well. SHCreateDirectoryEx also verifies that
75115>>>>>>>>>>>//    the files are visible. If they are not visible, expect one of the following:
75115>>>>>>>>>>>//
75115>>>>>>>>>>>//        * If hwnd is set to a valid window handle, a message box is displayed warning the user that he or she
75115>>>>>>>>>>>//        might not be able to access the files. If the user chooses not to proceed, the function returns
75115>>>>>>>>>>>//        ERROR_CANCELLED.
75115>>>>>>>>>>>//        * If hwnd is set to NULL, no user interface is displayed and the function returns ERROR_CANCELLED.
75115>>>>>>>>>>>
75115>>>>>>>>>>>//        Returns ERROR_SUCCESS if successful. If the operation fails, other error codes can be returned,
75115>>>>>>>>>>>//        including those listed here. For values not specifically listed, see System Error Codes.
75115>>>>>>>>>>>//      161  ERROR_BAD_PATHNAME                The pszPath parameter was set to a relative path.
75115>>>>>>>>>>>//      206  ERROR_FILENAME_EXCED_RANGE     The path pointed to by pszPath is too long.
75115>>>>>>>>>>>//      3    ERROR_PATH_NOT_FOUND            The system cannot find the path pointed to by pszPath. The path may contain an invalid entry.
75115>>>>>>>>>>>//      80   ERROR_FILE_EXISTS                The directory exists.
75115>>>>>>>>>>>//      183  ERROR_ALREADY_EXISTS            The directory exists.
75115>>>>>>>>>>>//      1223 ERROR_CANCELLED                The user canceled the operation.
75115>>>>>>>>>>>
75115>>>>>>>>>>>//        int SHCreateDirectoryEx(
75115>>>>>>>>>>>//            HWND hwnd,
75115>>>>>>>>>>>//            LPCTSTR pszPath,
75115>>>>>>>>>>>//            const SECURITY_ATTRIBUTES *psa
75115>>>>>>>>>>>//        );
75115>>>>>>>>>>>
75115>>>>>>>>>>>External_function vWin32_SHCreateDirectoryEx "SHCreateDirectoryExW" shell32.dll Handle hWnd;                  WString wPath  Pointer lpSecurity_Attributes Returns Integer
75116>>>>>>>>>>>
75116>>>>>>>>>>> External_Function vWin32_PathIsDirectory "PathIsDirectoryW" SHLWAPI.DLL WString wPath Returns Integer
75117>>>>>>>>>
75117>>>>>>>>>
75117>>>>>>>>>
75117>>>>>>>>>// Does the directory exist? - No = false, Yes = True
75117>>>>>>>>>// This also works with UNC path encoding and wildcards
75117>>>>>>>>>Function vFolderExists Global String sFolderName Returns Boolean
75119>>>>>>>>>    Boolean bFolderExists
75119>>>>>>>>>    Boolean bStop
75119>>>>>>>>>    String  sFolder sTmp
75119>>>>>>>>>    Integer iCh
75119>>>>>>>>>
75119>>>>>>>>>    If (sFolderName = "") Begin
75121>>>>>>>>>        Function_Return False
75122>>>>>>>>>    End
75122>>>>>>>>>>
75122>>>>>>>>>
75122>>>>>>>>>    Move True  to bFolderExists
75123>>>>>>>>>    Move False to bStop
75124>>>>>>>>>    Move "dir:" to sFolder
75125>>>>>>>>>    Append sFolder sFolderName
75126>>>>>>>>>    Get Seq_New_Channel to iCh  // get free channel for input
75127>>>>>>>>>    If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
75129>>>>>>>>>        Error DFERR_PROGRAM "No I/O channel available for process (vFolderExists)"
75130>>>>>>>>>>
75130>>>>>>>>>        Function_Return False
75131>>>>>>>>>    End
75131>>>>>>>>>>
75131>>>>>>>>>    Direct_Input channel iCh sFolder
75133>>>>>>>>>    Repeat
75133>>>>>>>>>>
75133>>>>>>>>>        Readln channel iCh sTmp
75135>>>>>>>>>        Move (SeqEof) to bStop
75136>>>>>>>>>        If (Trim(sTmp)="") Begin
75138>>>>>>>>>            Move False to bFolderExists
75139>>>>>>>>>        End
75139>>>>>>>>>>
75139>>>>>>>>>        Else Begin
75140>>>>>>>>>            Move True to bFolderExists
75141>>>>>>>>>            Move True to bStop
75142>>>>>>>>>        End
75142>>>>>>>>>>
75142>>>>>>>>>    Until (bStop)
75144>>>>>>>>>    Close_Input channel iCh
75146>>>>>>>>>    Send Seq_Release_Channel iCh
75147>>>>>>>>>    Function_Return bFolderExists
75148>>>>>>>>>End_Function
75149>>>>>>>>>
75149>>>>>>>>>// returns folder name if a folder was selected, otherwise returns ""
75149>>>>>>>>>Function vSHBrowseForFolder Global String sDialogTitle Returns String
75151>>>>>>>>>    String  sPath
75151>>>>>>>>>    WString sFolder sTitle
75151>>>>>>>>>    Pointer lpItemIdList
75151>>>>>>>>>    Integer iFolderSelected iRetval
75151>>>>>>>>>    tvBrowseInfo BrowseInfo
75151>>>>>>>>>    tvBrowseInfo BrowseInfo
75151>>>>>>>>>
75151>>>>>>>>>    Move "" to sPath
75152>>>>>>>>>    If (sDialogTitle<>"") Begin
75154>>>>>>>>>        Move sDialogTitle to sTitle
75155>>>>>>>>>        // Torben Lund suggested converting the string with toansi. Doing it like that
75155>>>>>>>>>        // disables showing some commonly used ascii characters like ascii 137 ()
75155>>>>>>>>>        // These chars are correctly shown if no toansi is used.
75155>>>>>>>>>        // I can imagine that he wanted to path to be ANSI, but as long as it isa just
75155>>>>>>>>>        // selected it will always be valid.
75155>>>>>>>>>        Move (AddressOf(sTitle)) to BrowseInfo.lpszTitle
75156>>>>>>>>>    End
75156>>>>>>>>>>
75156>>>>>>>>>
75156>>>>>>>>>    Move vBIF_RETURNONLYFSDIRS to BrowseInfo.ulFlags
75157>>>>>>>>>
75157>>>>>>>>>    // Torben Lund added line below. Move handle of focus object to structure before
75157>>>>>>>>>    // calling function. Otherwise, the folderdialog will be started as a seperate task.
75157>>>>>>>>>    Move (window_handle(focus(desktop))) to BrowseInfo.hWndOwner
75158>>>>>>>>>
75158>>>>>>>>>    // null 128 chars into var (make space)
75158>>>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
75159>>>>>>>>>
75159>>>>>>>>>    // select folder
75159>>>>>>>>>    Move (vWin32_SHBrowseForFolder(AddressOf(BrowseInfo))) to lpItemIdList
75160>>>>>>>>>    // get selected folder name
75160>>>>>>>>>    Move (vWin32_SHGetPathFromIDList(lpItemIdList, AddressOf(sFolder))) to iFolderSelected
75161>>>>>>>>>
75161>>>>>>>>>    // release memory resources that are used by the ItemIdList
75161>>>>>>>>>    Move (vWin32_CoTaskMemFree(lpItemIdList)) to iRetval
75162>>>>>>>>>
75162>>>>>>>>>    If (iFolderSelected<>0) Begin
75164>>>>>>>>>        Move (CString(sFolder)) to sPath
75165>>>>>>>>>    End
75165>>>>>>>>>>
75165>>>>>>>>>    Function_Return  sPath
75166>>>>>>>>>End_Function
75167>>>>>>>>>
75167>>>>>>>>>// returns 0 if the folder is created.
75167>>>>>>>>>//         1 if the API-call returned an error.
75167>>>>>>>>>Function vCreateDirectory Global String sNewFolder Returns Integer
75169>>>>>>>>>    Integer  iRetval bFolderCreated
75169>>>>>>>>>    WString  sFolder
75169>>>>>>>>>    tvSecurity_attributes SA
75169>>>>>>>>>    tvSecurity_attributes SA
75169>>>>>>>>>
75169>>>>>>>>>    Move False to bFolderCreated
75170>>>>>>>>>    If (sNewFolder <> "") Begin
75172>>>>>>>>>        Move (SizeOfType(tvSecurity_attributes)) to SA.nLength
75173>>>>>>>>>        Move  0                                  to SA.lpDescriptor
75174>>>>>>>>>        Move  1                                  to SA.bInheritHandle
75175>>>>>>>>>        Move (sNewFolder+Character(0)) to sFolder
75176>>>>>>>>>        Move (vWin32_CreateDirectory(sFolder, AddressOf(SA))) to bFolderCreated
75177>>>>>>>>>    End
75177>>>>>>>>>>
75177>>>>>>>>>
75177>>>>>>>>>    If (bFolderCreated=false) Begin
75179>>>>>>>>>        Move 1 to iRetVal
75180>>>>>>>>>    End
75180>>>>>>>>>>
75180>>>>>>>>>    Function_Return iRetVal
75181>>>>>>>>>End_Function
75182>>>>>>>>>
75182>>>>>>>>>// **WvA: 03-02-2002 Function created.
75182>>>>>>>>>// With this function one can remove a directory.
75182>>>>>>>>>// returns 0 if the folder is removed.
75182>>>>>>>>>//         1 if the API-call returned an error (Use GetLastError API to get the details)
75182>>>>>>>>>//         2 if the folder did not exist
75182>>>>>>>>>//         3 if the sFolder parameter passed is equal to ""
75182>>>>>>>>>Function vRemoveDirectory Global String sFolder Returns Integer
75184>>>>>>>>>    Boolean bRemoved
75184>>>>>>>>>    WString sPath
75184>>>>>>>>>    Integer iRetval
75184>>>>>>>>>
75184>>>>>>>>>    Move 0     to iRetVal
75185>>>>>>>>>    Move False to bRemoved
75186>>>>>>>>>    Move (Trim(sFolder)) to sFolder
75187>>>>>>>>>    If (sFolder="") Begin
75189>>>>>>>>>        Move 3 to iRetVal
75190>>>>>>>>>    End
75190>>>>>>>>>>
75190>>>>>>>>>    If (vFolderExists(sFolder)=False) Begin
75192>>>>>>>>>        Move 2 to iRetVal
75193>>>>>>>>>    End
75193>>>>>>>>>>
75193>>>>>>>>>    If (iRetVal=0) Begin
75195>>>>>>>>>        // null MAX_PATH chars into var (make space)
75195>>>>>>>>>        Move (Repeat(Character(0), vMAX_PATH)) to sPath
75196>>>>>>>>>        //
75196>>>>>>>>>        Move (Insert(sFolder,sPath,1)) to sPath
75197>>>>>>>>>        Move (vWin32_RemoveDirectory(sPath)) to bRemoved
75198>>>>>>>>>    End
75198>>>>>>>>>>
75198>>>>>>>>>
75198>>>>>>>>>    If (iRetVal=0 And bRemoved=False) Begin
75200>>>>>>>>>        Move 1 to iRetVal
75201>>>>>>>>>    End
75201>>>>>>>>>>
75201>>>>>>>>>    Function_Return iRetVal
75202>>>>>>>>>End_Function
75203>>>>>>>>>
75203>>>>>>>>>// This will perform an operation on a file (e.g. open) with the application
75203>>>>>>>>>// registered in the Windows Registry to open that type of file (via its extension)
75203>>>>>>>>>// sOperation would be "OPEN" (it could also be "PRINT" etc).
75203>>>>>>>>>Procedure vShellExecute Global String sOperation String sDocument String sParameters String sPath
75205>>>>>>>>>    Handle  hInstance hWnd
75205>>>>>>>>>    // remove any leading/trailing spaces in the string
75205>>>>>>>>>    Move (Trim(sDocument)) to sDocument
75206>>>>>>>>>    Move (Trim(sPath))     to sPath
75207>>>>>>>>>    // Make the strings readable for windows API, by converting them to null-terminated
75207>>>>>>>>>    Append sOperation   (Character(0))
75208>>>>>>>>>    Append sDocument    (Character(0))
75209>>>>>>>>>    Append sParameters  (Character(0))
75210>>>>>>>>>    Append sPath        (Character(0))
75211>>>>>>>>>
75211>>>>>>>>>    Get Window_Handle to hWnd
75212>>>>>>>>>    Move (vWin32_ShellExecute (hWnd, sOperation, sDocument, sParameters, sPath, 1)) to hInstance
75213>>>>>>>>>    If (hInstance <= 32) Begin
75215>>>>>>>>>        Send vDDE_Error_Handler hInstance
75216>>>>>>>>>    End
75216>>>>>>>>>>
75216>>>>>>>>>End_Procedure
75217>>>>>>>>>
75217>>>>>>>>>Class cShellFileOperations is a Array
75218>>>>>>>>>
75218>>>>>>>>>    Procedure Construct_Object
75220>>>>>>>>>        Forward Send Construct_Object
75222>>>>>>>>>        Property Integer piDeleteFlags        0
75223>>>>>>>>>        Property Integer piCopyFlags          0
75224>>>>>>>>>        Property Integer piMoveFlags          0
75225>>>>>>>>>        Property Integer piRenameFlags        0
75226>>>>>>>>>
75226>>>>>>>>>        Set piDeleteFlags to (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
75227>>>>>>>>>        Set piCopyFlags   to (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR Ior vFOF_NOCONFIRMATION)
75228>>>>>>>>>        Set piMoveFlags   to (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR iOr vFOF_NOCONFIRMATION)
75229>>>>>>>>>        Set piRenameFlags to (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
75230>>>>>>>>>    End_Procedure
75231>>>>>>>>>
75231>>>>>>>>>    // This function uses the shell API to perform a file operation on the
75231>>>>>>>>>    // files supplied.
75231>>>>>>>>>    //
75231>>>>>>>>>    Function FileOperation String sSource String sDestination Integer eOperation Integer iFlags Returns Integer
75233>>>>>>>>>        Integer  iRetVal
75233>>>>>>>>>        Integer  iUserAbort
75233>>>>>>>>>        WString  wsSource wsDestination
75233>>>>>>>>>        tvShFileOpStruct FOS
75233>>>>>>>>>        tvShFileOpStruct FOS
75233>>>>>>>>>
75233>>>>>>>>>        Move (sSource+Character(0)+Character(0))      to wsSource
75234>>>>>>>>>        Move (sDestination+Character(0)+Character(0)) to wsDestination
75235>>>>>>>>>
75235>>>>>>>>>        If (eOperation <> vFO_DELETE) Begin
75237>>>>>>>>>            Move (AddressOf(wsDestination)) to FOS.pTo
75238>>>>>>>>>        End
75238>>>>>>>>>>
75238>>>>>>>>>
75238>>>>>>>>>        Move eOperation            to FOS.wFunc
75239>>>>>>>>>        Move (AddressOf(wsSource)) to FOS.pFrom
75240>>>>>>>>>        Move iFlags                to FOS.fFlags
75241>>>>>>>>>
75241>>>>>>>>>        Move (vWin32_SHFileOperation(AddressOf(FOS))) to iRetVal
75242>>>>>>>>>        Move FOS.fAnyOperationsAborted to iUserAbort
75243>>>>>>>>>        If (iUserAbort <> 0) Begin
75245>>>>>>>>>            Move 80 to iRetVal  // file Operation Aborted by USER
75246>>>>>>>>>        End
75246>>>>>>>>>>
75246>>>>>>>>>        Function_Return (iRetVal)
75247>>>>>>>>>    End_Function
75248>>>>>>>>>
75248>>>>>>>>>    Function sfoDeleteFile String sFileName Returns Integer
75250>>>>>>>>>        Integer  iRetVal
75250>>>>>>>>>        Integer  iFlags
75250>>>>>>>>>
75250>>>>>>>>>        Get piDeleteFlags to iFlags
75251>>>>>>>>>        Get FileOperation sFileName "" vFO_DELETE iFlags to iRetVal
75252>>>>>>>>>        Function_Return iRetVal
75253>>>>>>>>>    End_Function
75254>>>>>>>>>
75254>>>>>>>>>    Function sfoCopyFile String sSource String sDestination Returns Integer
75256>>>>>>>>>        Integer  iRetVal
75256>>>>>>>>>        Integer  iFlags
75256>>>>>>>>>
75256>>>>>>>>>        Get piCopyFlags to iFlags
75257>>>>>>>>>        Get FileOperation sSource sDestination vFO_COPY iFlags to iRetVal
75258>>>>>>>>>        Function_Return iRetVal
75259>>>>>>>>>    End_Function
75260>>>>>>>>>
75260>>>>>>>>>    Function sfoMoveFile String sSource String sDestination Returns Integer
75262>>>>>>>>>        Integer  iRetVal
75262>>>>>>>>>        Integer  iFlags
75262>>>>>>>>>
75262>>>>>>>>>        Get piMoveFlags to iFlags
75263>>>>>>>>>        Get FileOperation sSource sDestination vFO_MOVE iFlags to iRetVal
75264>>>>>>>>>        Function_Return iRetVal
75265>>>>>>>>>    End_Function
75266>>>>>>>>>
75266>>>>>>>>>    // Rename a file or folder
75266>>>>>>>>>    // Returns a nonzero value if the operation failed.
75266>>>>>>>>>    Function sfoRenameFile String sSource String sDestination Returns Integer
75268>>>>>>>>>        Integer  iRetVal
75268>>>>>>>>>        Integer  iFlags
75268>>>>>>>>>
75268>>>>>>>>>        Get piRenameFlags to iFlags
75269>>>>>>>>>        Get FileOperation sSource sDestination vFO_RENAME iFlags to iRetVal
75270>>>>>>>>>        Function_Return iRetVal
75271>>>>>>>>>    End_Function
75272>>>>>>>>>
75272>>>>>>>>>
75272>>>>>>>>>    //Example:
75272>>>>>>>>>    // Get sfoFormatDisk 'A' 0 To dReturnVal    // Formats drive A in QuickFormat
75272>>>>>>>>>    //                                          mode.
75272>>>>>>>>>
75272>>>>>>>>>End_Class
75273>>>>>>>>>
75273>>>>>>>>>Object oShellFileOperations is a cShellFileOperations
75275>>>>>>>>>End_Object
75276>>>>>>>>>
75276>>>>>>>>>// Restore to the old way of working with the shell file operations.
75276>>>>>>>>>// or.. to put lay man terms, allow any of the operations vDeleteFile
75276>>>>>>>>>// vCopyFile/vMoveFile/vRenameFile to have an UNDO
75276>>>>>>>>>Procedure vWin32fhCompatibilityMode
75278>>>>>>>>>    Integer hoSFO
75278>>>>>>>>>    Integer iFlags
75278>>>>>>>>>
75278>>>>>>>>>    Move (vFOF_SILENT Ior vFOF_NOCONFIRMATION Ior vFOF_ALLOWUNDO) to iFlags
75279>>>>>>>>>    Move (oShellFileOperations(Self)) to hoSFO
75280>>>>>>>>>
75280>>>>>>>>>    Set piDeleteFlags of hoSFO to iFlags
75281>>>>>>>>>    Set piCopyFlags   of hoSFO to iFlags
75282>>>>>>>>>    Set piMoveFlags   of hoSFO to iFlags
75283>>>>>>>>>    Set piRenameFlags of hoSFO to iFlags
75284>>>>>>>>>End_Procedure
75285>>>>>>>>>
75285>>>>>>>>>// Delete a file or folder
75285>>>>>>>>>// Returns a nonzero value if the operation failed.
75285>>>>>>>>>Function vDeleteFile Global String sFileName Returns Integer
75287>>>>>>>>>    Integer  iRetVal
75287>>>>>>>>>
75287>>>>>>>>>    Get sfoDeleteFile of (oShellFileOperations(Self)) sFileName to iRetVal
75288>>>>>>>>>    Function_Return iRetVal
75289>>>>>>>>>End_Function
75290>>>>>>>>>
75290>>>>>>>>>// Copy a file or folder
75290>>>>>>>>>// Returns a nonzero value if the operation failed.
75290>>>>>>>>>Function vCopyFile Global String sSource String sDestination Returns Integer
75292>>>>>>>>>    Integer  iRetVal
75292>>>>>>>>>
75292>>>>>>>>>    Get sfoCopyFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
75293>>>>>>>>>    Function_Return iRetVal
75294>>>>>>>>>End_Function
75295>>>>>>>>>
75295>>>>>>>>>// Move a file or folder
75295>>>>>>>>>// Returns a nonzero value if the operation failed.
75295>>>>>>>>>Function vMoveFile Global String sSource String sDestination Returns Integer
75297>>>>>>>>>    Integer  iRetVal
75297>>>>>>>>>
75297>>>>>>>>>    Get sfoMoveFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
75298>>>>>>>>>    Function_Return iRetVal
75299>>>>>>>>>End_Function
75300>>>>>>>>>
75300>>>>>>>>>// Rename a file or folder
75300>>>>>>>>>// Returns a nonzero value if the operation failed.
75300>>>>>>>>>Function vRenameFile Global String sSource String sDestination Returns Integer
75302>>>>>>>>>    Integer  iRetVal
75302>>>>>>>>>
75302>>>>>>>>>    Get sfoRenameFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
75303>>>>>>>>>    Function_Return iRetVal
75304>>>>>>>>>End_Function
75305>>>>>>>>>
75305>>>>>>>>>Function vGetWindowsDirectory Returns String
75307>>>>>>>>>    WString wDirectory
75307>>>>>>>>>    Integer iRetVal
75307>>>>>>>>>
75307>>>>>>>>>    Move (ZeroString(vMAX_PATH)) to wDirectory
75308>>>>>>>>>    Move (vWin32_GetWindowsDirectory(AddressOf(wDirectory), vMAX_PATH)) to iRetVal
75309>>>>>>>>>    If (iRetVal > vMAX_PATH) Begin
75311>>>>>>>>>        Move (ZeroString(iRetval)) to wDirectory
75312>>>>>>>>>        Move (vWin32_GetWindowsDirectory(AddressOf(wDirectory), iRetVal)) to iRetVal
75313>>>>>>>>>    End
75313>>>>>>>>>>
75313>>>>>>>>>    Function_Return (CString(wDirectory))
75314>>>>>>>>>End_Function
75315>>>>>>>>>
75315>>>>>>>>>Function vGetTempPath Returns String
75317>>>>>>>>>    Integer iRetVal
75317>>>>>>>>>    WString wTempPath
75317>>>>>>>>>
75317>>>>>>>>>    Move (ZeroString(vMAX_PATH)) to wTempPath
75318>>>>>>>>>    Move (vWin32_GetTempPath(vMAX_PATH, AddressOf(wTempPath))) to iRetVal
75319>>>>>>>>>    If (iRetVal > vMAX_PATH) Begin
75321>>>>>>>>>        Move (ZeroString(iRetval)) to wTempPath
75322>>>>>>>>>        Move (vWin32_GetTempPath(iRetVal, AddressOf(wTempPath))) to iRetVal
75323>>>>>>>>>    End
75323>>>>>>>>>>
75323>>>>>>>>>    Function_Return (CString(wTempPath))
75324>>>>>>>>>End_Function
75325>>>>>>>>>
75325>>>>>>>>>// Courtesy of Marco Kuipers
75325>>>>>>>>>Function vMakeTempFile Returns String
75327>>>>>>>>>    Integer iRetval
75327>>>>>>>>>    String  sTempPath
75327>>>>>>>>>    String  sTempFileName
75327>>>>>>>>>    String  sPrefixString
75327>>>>>>>>>    WString wsTempFileName
75327>>>>>>>>>
75327>>>>>>>>>    Get vGetTempPath to sTempPath
75328>>>>>>>>>    If (sTempPath = "") Begin
75330>>>>>>>>>        Get vGetWindowsDirectory to sTempPath  // first fallback
75331>>>>>>>>>        If (sTempPath<>"") Begin
75333>>>>>>>>>            Move (sTempPath+"\Temp\") to sTempPath
75334>>>>>>>>>        End
75334>>>>>>>>>>
75334>>>>>>>>>    End
75334>>>>>>>>>>
75334>>>>>>>>>
75334>>>>>>>>>    If (sTempPath = "") Begin
75336>>>>>>>>>        // second fallback we really do not want to get here as to be fair using current folder as temp
75336>>>>>>>>>        // makes little sense. Leaving this in as it was old behavior.
75336>>>>>>>>>        Get_Current_Directory to sTempPath
75337>>>>>>>>>    End
75337>>>>>>>>>>
75337>>>>>>>>>
75337>>>>>>>>>    Move (Trim(sTempPath)+Character(0)) to sTempPath
75338>>>>>>>>>    If (Length(sTempPath)>(vMax_Path-14)) Begin
75340>>>>>>>>>        Error DFERR_PROGRAM ("Temporary path"+sTempPath+"is too long, cannot create temporary files.")
75341>>>>>>>>>>
75341>>>>>>>>>    End
75341>>>>>>>>>>
75341>>>>>>>>>
75341>>>>>>>>>    Move (ZeroString(vMax_Path)) to wsTempFileName
75342>>>>>>>>>    Move ("tmp"+Character(0))    to sPrefixString
75343>>>>>>>>>    Move (vWin32_GetTempFileName (sTempPath, sPrefixString, 0, AddressOf(wsTempFileName))) to iRetval
75344>>>>>>>>>    If (iRetval = 0) Begin  // The api call returns 0 if an error occurs
75346>>>>>>>>>    //Get ShowLastError to iRetval
75346>>>>>>>>>        Move "" to sTempFileName
75347>>>>>>>>>    End
75347>>>>>>>>>>
75347>>>>>>>>>    Move (Cstring(wsTempFileName)) to sTempFileName
75348>>>>>>>>>    Function_Return sTempFileName
75349>>>>>>>>>End_Function
75350>>>>>>>>>
75350>>>>>>>>>// This function creates a uniquely named temporary file in folder sPath
75350>>>>>>>>>// The file created will have a prefix based on the first 3 characters in sPrefix
75350>>>>>>>>>// Note that you will have to cleanup the tempfile yourself as the function
75350>>>>>>>>>// does not take care of that.
75350>>>>>>>>>Function vCreateTempFileInPath String sPath String sPrefix Returns String
75352>>>>>>>>>    Integer iRetVal
75352>>>>>>>>>    String  sTempFileName
75352>>>>>>>>>    WString wTempFileName
75352>>>>>>>>>
75352>>>>>>>>>    Move (sPath+Character(0))   to sPath
75353>>>>>>>>>    Move (sPrefix+Character(0)) to sPrefix
75354>>>>>>>>>    Move (Pad("", vMAX_PATH))   to wTempFileName
75355>>>>>>>>>
75355>>>>>>>>>    Move (vWin32_GetTempFileName(sPath, sPrefix, 0, AddressOf(wTempFileName))) to iRetVal
75356>>>>>>>>>    Move (Trim(Cstring(wTempFileName))) to sTempFileName
75357>>>>>>>>>    Function_Return sTempFileName
75358>>>>>>>>>End_Function
75359>>>>>>>>>
75359>>>>>>>>>//
75359>>>>>>>>>// Get a specific shell folder for example to get the desktop folder
75359>>>>>>>>>// simply call this function and pass it vCSIDL_DESKTOP
75359>>>>>>>>>//
75359>>>>>>>>>Function vSHGetFolderPath Integer eFolder Returns String
75361>>>>>>>>>    Integer iVoid
75361>>>>>>>>>    Handle  hWnd
75361>>>>>>>>>    String  sFolder
75361>>>>>>>>>    WString wFolder
75361>>>>>>>>>
75361>>>>>>>>>    Move (Window_Handle(focus(desktop))) to hWnd
75362>>>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to wFolder
75363>>>>>>>>>    Move (vWin32_SHGetFolderPath(hWnd,eFolder, 0, 0,AddressOf(wFolder))) To iVoid
75364>>>>>>>>>    Move (CString(wFolder)) to sFolder
75365>>>>>>>>>    Function_Return sFolder
75366>>>>>>>>>End_Function
75367>>>>>>>>>
75367>>>>>>>>>// Courtesy Of Vincent Oorsprong
75367>>>>>>>>>Function vConvertFileDateTime Global DWord dwLowDateTime DWord dwHighDateTime Returns String
75369>>>>>>>>>    String  sFileDateTime
75369>>>>>>>>>    WString wFormattedTime wFormattedDate
75369>>>>>>>>>    Integer iSuccess iLenCcTime iDataLength iLenCcDate
75369>>>>>>>>>    tvFileTime   FileTime
75369>>>>>>>>>    tvFileTime   FileTime
75369>>>>>>>>>    tvSystemTime SystemTime
75369>>>>>>>>>    tvSystemTime SystemTime
75369>>>>>>>>>
75369>>>>>>>>>    Move "" to sFileDateTime
75370>>>>>>>>>    Move dwLowDateTime  to FileTime.dwLowDateTime
75371>>>>>>>>>    Move dwHighDateTime to FileTime.dwHighDateTime
75372>>>>>>>>>
75372>>>>>>>>>    Move 0 to SystemTime.wYear
75373>>>>>>>>>
75373>>>>>>>>>    Move (vWin32_FileTimeToSystemTime (AddressOf(FileTime), AddressOf(SystemTime))) to iSuccess
75374>>>>>>>>>    If (iSuccess = 1) Begin
75376>>>>>>>>>        Move (ZeroString(255))               to wFormattedTime
75377>>>>>>>>>        Move (SizeOfWString(wFormattedTime)) to iLenCcTime
75378>>>>>>>>>        Move (vWin32_GetTimeFormat (LOCALE_USER_DEFAULT, 0, AddressOf(SystemTime), 0, AddressOf(wFormattedTime), iLenCcTime)) to iDataLength
75379>>>>>>>>>        Move (ZeroString(255))               to wFormattedDate
75380>>>>>>>>>        Move (SizeOfWString(wFormattedDate)) to iLenCcDate
75381>>>>>>>>>        Move (vWin32_GetDateFormat (LOCALE_USER_DEFAULT, 0, AddressOf(SystemTime), 0, AddressOf(wFormattedDate), iLenCcDate)) to iDataLength
75382>>>>>>>>>        Move (Cstring (wFormattedDate)  * Cstring (wFormattedTime)) to sFileDateTime
75383>>>>>>>>>    End
75383>>>>>>>>>>
75383>>>>>>>>>    Function_Return sFileDateTime
75384>>>>>>>>>End_Function
75385>>>>>>>>>
75385>>>>>>>>>// **WvA:
75385>>>>>>>>>// A windows replacement for the standard function FileExists.
75385>>>>>>>>>// This version will also return (true) for a file when it is open by an application.
75385>>>>>>>>>// Note that you can apply normal windows mask-signs in the filename such as * and ?
75385>>>>>>>>>// Example: Get vFilePathExists "C:\config.sy?"
75385>>>>>>>>>// This will return true if you have a file matching these conditions. (aka config.sys)
75385>>>>>>>>>Function vFilePathExists Global String sFilePathMask Returns Integer
75387>>>>>>>>>    String  sDirSep
75387>>>>>>>>>    Handle  hFindFile
75387>>>>>>>>>    Integer iVoid
75387>>>>>>>>>    tvWin32FindData FindData
75387>>>>>>>>>    tvWin32FindData FindData
75387>>>>>>>>>
75387>>>>>>>>>    Move vINVALID_HANDLE_VALUE to hFindFile
75388>>>>>>>>>    Move (Trim(sFilePathMask)) to sFilePathMask
75389>>>>>>>>>
75389>>>>>>>>>    If (Length(sFilePathMask)>0) Begin
75391>>>>>>>>>        // 2014-09-29 NGS Remove any trailing dir separators, as they make the function fail.
75391>>>>>>>>>        Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep
75392>>>>>>>>>        While (Right(sFilePathMask, 1) = sDirSep)
75396>>>>>>>>>            Move (Left(sFilePathMask, Length(sFilePathMask) -1)) to sFilePathMask
75397>>>>>>>>>        Loop
75398>>>>>>>>>>
75398>>>>>>>>>
75398>>>>>>>>>        Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
75399>>>>>>>>>        Move (vWin32_FindFirstFile (sFilePathMask, AddressOf(FindData))) to hFindFile
75400>>>>>>>>>        Move (vWin32_FindClose (hFindFile)) to iVoid
75401>>>>>>>>>    End
75401>>>>>>>>>>
75401>>>>>>>>>    Function_Return (hFindFile <> vINVALID_HANDLE_VALUE)
75402>>>>>>>>>End_Function
75403>>>>>>>>>
75403>>>>>>>>>
75403>>>>>>>>>//
75403>>>>>>>>>// Returns the amount of files in the folder (if it exists)
75403>>>>>>>>>// Returns -1 if folder doesn't exist.
75403>>>>>>>>>// The files "." and ".." are not counted.
75403>>>>>>>>>//
75403>>>>>>>>>Function vFolderFileCount Global String sFolderName Returns Integer
75405>>>>>>>>>    Boolean bFound
75405>>>>>>>>>    Handle  hFindFile
75405>>>>>>>>>    Integer iCount  iVoid
75405>>>>>>>>>    Integer iSuccess
75405>>>>>>>>>    String  sFileName
75405>>>>>>>>>    tvWin32FindData FindData
75405>>>>>>>>>    tvWin32FindData FindData
75405>>>>>>>>>
75405>>>>>>>>>    Move -1 to iCount
75406>>>>>>>>>    Get vFolderFormat sFolderName to sFolderName
75407>>>>>>>>>    Move (sFolderName+"*") to sFolderName // match any filename in the folder
75408>>>>>>>>>    Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
75409>>>>>>>>>    Move (vWin32_FindFirstFile (sFolderName, AddressOf(FindData))) to hFindFile
75410>>>>>>>>>    Move (hFindFile<>vINVALID_HANDLE_VALUE) to bFound
75411>>>>>>>>>    If (bFound) Begin
75413>>>>>>>>>        Move 0 to iCount
75414>>>>>>>>>    End
75414>>>>>>>>>>
75414>>>>>>>>>    While (bFound)
75418>>>>>>>>>        Increment iCount
75419>>>>>>>>>        Move (PointerToWString(AddressOf(FindData.cFileName))) to sFileName
75420>>>>>>>>>        If (sFileName="." or sFileName="..") Begin
75422>>>>>>>>>            Decrement iCount
75423>>>>>>>>>        End
75423>>>>>>>>>>
75423>>>>>>>>>        Move (vWin32_FindNextFile(hFindFile, AddressOf(FindData))) to iSuccess
75424>>>>>>>>>        Move (iSuccess<>0) to bFound
75425>>>>>>>>>    Loop
75426>>>>>>>>>>
75426>>>>>>>>>    Move (vWin32_FindClose (hFindFile)) to iVoid
75427>>>>>>>>>    Function_Return iCount
75428>>>>>>>>>End_Function
75429>>>>>>>>>
75429>>>>>>>>>// Create the folder, including intermediate directories.
75429>>>>>>>>>// Don't panic if the folder already exists.
75429>>>>>>>>>// Michael Mullan June 2009.
75429>>>>>>>>>Function vshCreateDirectoryEX Global String sNewFolder Returns Integer
75431>>>>>>>>>    String  sFolder
75431>>>>>>>>>    Integer iRetval iFolderCreated
75431>>>>>>>>>    tvSecurity_attributes SA
75431>>>>>>>>>    tvSecurity_attributes SA
75431>>>>>>>>>
75431>>>>>>>>>    Move 0 to iFolderCreated
75432>>>>>>>>>
75432>>>>>>>>>    // null MAX_PATH chars into var (make space)
75432>>>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
75433>>>>>>>>>    If (sNewFolder <> "") Begin
75435>>>>>>>>>
75435>>>>>>>>>        Move (SizeOfType(tvSecurity_attributes)) to SA.nLength
75436>>>>>>>>>        Move  0  to SA.lpDescriptor
75437>>>>>>>>>        Move  1  to SA.bInheritHandle
75438>>>>>>>>>
75438>>>>>>>>>        //
75438>>>>>>>>>        Move (sNewFolder+"") to sFolder
75439>>>>>>>>>        Move (vWin32_SHCreateDirectoryEx(0,sFolder, AddressOf(SA))) to iFolderCreated
75440>>>>>>>>>    End
75440>>>>>>>>>>
75440>>>>>>>>>
75440>>>>>>>>>    If (iFolderCreated <> 0) Begin
75442>>>>>>>>>        Move 1 to iRetVal
75443>>>>>>>>>        Case Begin
75443>>>>>>>>>            Case (iFolderCreated = 161)
75445>>>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_BAD_PATHNAME)")
75446>>>>>>>>>>
75446>>>>>>>>>                Case Break
75447>>>>>>>>>            Case (iFolderCreated = 206)
75450>>>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_FILENAME_EXCED_RANGE)")
75451>>>>>>>>>>
75451>>>>>>>>>                Case Break
75452>>>>>>>>>            Case (iFolderCreated = 3)
75455>>>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_PATH_NOT_FOUND)")
75456>>>>>>>>>>
75456>>>>>>>>>                Case Break
75457>>>>>>>>>            Case (iFolderCreated = 80)
75460>>>>>>>>>                Move 0 to iRetval // "ERROR_FILE_EXISTS"     not really an error
75461>>>>>>>>>                Case Break
75462>>>>>>>>>            Case (iFolderCreated = 183)
75465>>>>>>>>>                Move 0 to iRetval //  "ERROR_ALREADY_EXISTS"     not really an error
75466>>>>>>>>>                Case Break
75467>>>>>>>>>            Case (iFolderCreated = 1223)
75470>>>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_CANCELLED)")
75471>>>>>>>>>>
75471>>>>>>>>>                Case Break
75472>>>>>>>>>            Case Else
75472>>>>>>>>>                Error DFERR_OPERATOR ("Folder Creation Error # " + String(ifoldercreated) + "\n" + sNewFolder + "(FILE_CREATION_ERROR)")
75473>>>>>>>>>>
75473>>>>>>>>>        Case End
75473>>>>>>>>>    End
75473>>>>>>>>>>
75473>>>>>>>>>    Function_Return iRetVal
75474>>>>>>>>>End_Function
75475>>>>>>>>>
75475>>>>>>>>>Function vWin32_APIFileSize Global String sFileName Returns Integer
75477>>>>>>>>>    DWord   dwFileSizeHigh dwFileSizeLow
75477>>>>>>>>>    Integer iFileSize iVoid
75477>>>>>>>>>    Handle  hFindFile
75477>>>>>>>>>    tvWin32FindData FindData
75477>>>>>>>>>    tvWin32FindData FindData
75477>>>>>>>>>
75477>>>>>>>>>    Move (sFileName+"") to sFileName
75478>>>>>>>>>    Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
75479>>>>>>>>>    Move (vWin32_FindFirstFile (sFileName, AddressOf(FindData))) to hFindFile
75480>>>>>>>>>    If (hFindFile<>vINVALID_HANDLE_VALUE) Begin
75482>>>>>>>>>        Move FindData.nFileSizeHigh to dwFileSizeHigh
75483>>>>>>>>>        Move FindData.nFileSizeLow  to dwFileSizeLow
75484>>>>>>>>>    End
75484>>>>>>>>>>
75484>>>>>>>>>    Move (vWin32_FindClose(hFindFile)) to iVoid
75485>>>>>>>>>    Move ((dwFileSizeHigh * vMaxDword) + dwFileSizeLow) to iFileSize
75486>>>>>>>>>
75486>>>>>>>>>    Function_Return iFileSize
75487>>>>>>>>>End_Function
75488>>>>>>>>>
75488>>>>>>>>>//
75488>>>>>>>>>// Based on code in Peter Crook's Browse folder workspace
75488>>>>>>>>>// http://support.dataaccess.com/Forums/showthread.php?54383-Browse-for-Folder-package&p=282249#post282249
75488>>>>>>>>>//
75488>>>>>>>>>//=============================================================================
75488>>>>>>>>>// Verifies that a path is a valid directory.
75488>>>>>>>>>//
75488>>>>>>>>>// Returns TRUE if the path is a valid directory, or FALSE otherwise.
75488>>>>>>>>>//
75488>>>>>>>>>// Parameters:
75488>>>>>>>>>//      sPath - Address of the path to verify.
75488>>>>>>>>>//=============================================================================
75488>>>>>>>>>Function vPathIsDirectory Global String sPath Returns Boolean
75490>>>>>>>>>    Integer iResult
75490>>>>>>>>>    Boolean bRetVal
75490>>>>>>>>>
75490>>>>>>>>>    Move false to bRetVal
75491>>>>>>>>>    Move (sPath - Character (0)) to sPath
75492>>>>>>>>>    Move (vWin32_PathIsDirectory (sPath)) to iResult
75493>>>>>>>>>    If (iResult<>0) Begin
75495>>>>>>>>>        Move True to bRetVal
75496>>>>>>>>>    End
75496>>>>>>>>>>
75496>>>>>>>>>
75496>>>>>>>>>    Function_Return bRetVal
75497>>>>>>>>>End_Function
75498>>>>>>>>>
75498>>>>>>>
75498>>>>>>>//
75498>>>>>>>// Gets the string from the right of the last sStopChar in sFrom
75498>>>>>>>// If sStopChar has no occurences in the string an empty string is
75498>>>>>>>// returned.
75498>>>>>>>Function StringFromRightOfChar Global String sFrom String sStopChar Returns String
75500>>>>>>>    String  sRetVal
75500>>>>>>>    String  sChar
75500>>>>>>>    Integer iLength
75500>>>>>>>    Integer iPos
75500>>>>>>>    Boolean bStopChar
75500>>>>>>>    Move "" to sRetval
75501>>>>>>>    Move (Length(sFrom)) to iLength
75502>>>>>>>    If ((iLength>0) And (Pos(sStopChar,sFrom) <> 0)) Begin
75504>>>>>>>        Move iLength   to iPos
75505>>>>>>>        Move (False)   to bStopChar
75506>>>>>>>        While Not bStopChar
75510>>>>>>>            Move (Mid(sFrom,1,iPos)) to sChar
75511>>>>>>>            Decrement iPos
75512>>>>>>>            If ((sChar=sStopChar) Or (iPos<1)) Begin
75514>>>>>>>                Move (True) to bStopChar
75515>>>>>>>            End
75515>>>>>>>>
75515>>>>>>>            Else Begin
75516>>>>>>>                Move (sChar+sRetVal) to sRetVal
75517>>>>>>>            End
75517>>>>>>>>
75517>>>>>>>        Loop
75518>>>>>>>>
75518>>>>>>>    End
75518>>>>>>>>
75518>>>>>>>    Function_Return sRetVal
75519>>>>>>>End_Function
75520>>>>>>>
75520>>>>>>>// Pre:  sFileName contains the complete path of the file.
75520>>>>>>>// Post: returns the complete path of the file.
75520>>>>>>>// This function is inspired on function SEQ_ExtractPathFromFileName of Sture Andersen.
75520>>>>>>>Function ParseFolderName Global String sFileName Returns String
75522>>>>>>>    String sFile
75522>>>>>>>    String sFolderName
75522>>>>>>>    String sDirSep // this is "\" for windows, or "/" for unix
75522>>>>>>>
75522>>>>>>>    Move "" to sFolderName
75523>>>>>>>    Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
75524>>>>>>>    If sDirSep In sFileName Begin
75526>>>>>>>        Move (StringFromRightOfChar(sFileName,sDirSep)) to sFile
75527>>>>>>>        Move (Left(sFileName,Length(sFileName)-Length(sFile))) to sFolderName
75528>>>>>>>    End
75528>>>>>>>>
75528>>>>>>>    Else If ":" In sFileName Begin
75531>>>>>>>        Move (StringFromRightOfChar(sFileName,":")) to sFile
75532>>>>>>>        Move (Replace(sFile,sFileName,"")) to sFolderName
75533>>>>>>>    End
75533>>>>>>>>
75533>>>>>>>    Function_Return sFolderName
75534>>>>>>>End_Function
75535>>>>>>>
75535>>>>>>>// Pre:  sFileName contains the complete path of the file.
75535>>>>>>>// post: The returned filename has it's path removed, but will have a extension
75535>>>>>>>Function ParseFileName Global String sFileName Returns String
75537>>>>>>>    String sFolderName
75537>>>>>>>    String sDirSep // this is "\" for windows, or "/" for unix
75537>>>>>>>
75537>>>>>>>    Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep
75538>>>>>>>    Get ParseFolderName sFileName to sFolderName
75539>>>>>>>    If (sFolderName <> "") Begin
75541>>>>>>>        Move (Replace(sFolderName,sFileName,"")) to sFileName
75542>>>>>>>    End
75542>>>>>>>>
75542>>>>>>>    Move (Replace(sDirSep,sFileName,"")) to sFileName
75543>>>>>>>    Function_Return sFilename
75544>>>>>>>End_Function
75545>>>>>>>
75545>>>>>>>// Pre:  sFileName may contain the complete path of the file.
75545>>>>>>>//       or contain multiple dots in the filename, so temp.gif.bak will
75545>>>>>>>//       return "bak" as the extension and not "gif"
75545>>>>>>>// Post: returns the extension only, this extension can be a valid unixlike extension
75545>>>>>>>//       such as "html" or "java"
75545>>>>>>>Function ParseFileExtension Global String sFileName Returns String
75547>>>>>>>    String  sFileExtension
75547>>>>>>>    Get ParseFileName sFileName to sFileName // takes care of corner case with path containing a ".". eg. c:\frank.cheng\hello
75548>>>>>>>    Get StringFromRightOfChar sFileName "." to sFileExtension
75549>>>>>>>    Function_Return sFileExtension
75550>>>>>>>End_Function
75551>>>>>>>
75551>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
75551>>>>>>>
75551>>>>>>>Function DDE_Error_To_String Integer iErrorID Returns String
75553>>>>>>>    String sMessage
75553>>>>>>>    Case Begin
75553>>>>>>>        Case (iErrorID = vERROR_FILE_NOT_FOUND)
75555>>>>>>>            Move CS_DDE_ERR_FILE_NOT_FOUND to sMessage
75556>>>>>>>            Case Break
75557>>>>>>>        Case (iErrorID = vERROR_PATH_NOT_FOUND)
75560>>>>>>>            Move CS_DDE_ERR_PATH_NOT_FOUND to sMessage
75561>>>>>>>            Case Break
75562>>>>>>>        Case (iErrorID = vERROR_BAD_FORMAT)
75565>>>>>>>            Move CS_DDE_ERR_BAD_FORMAT to sMessage
75566>>>>>>>            Case Break
75567>>>>>>>        Case (iErrorID = vSE_ERR_ACCESSDENIED)
75570>>>>>>>            Move CS_DDE_ERR_ACCESSDENIED to sMessage
75571>>>>>>>            Case Break
75572>>>>>>>        Case (iErrorID = vSE_ERR_ASSOCINCOMPLETE)
75575>>>>>>>            Move CS_DDE_ERR_ASSOCINCOMPLETE to sMessage
75576>>>>>>>            Case Break
75577>>>>>>>        Case (iErrorID = vSE_ERR_DDEBUSY)
75580>>>>>>>            Move CS_DDE_ERR_DDEBUSY to sMessage
75581>>>>>>>            Case Break
75582>>>>>>>        Case (iErrorID = vSE_ERR_DDEFAIL)
75585>>>>>>>            Move CS_DDE_ERR_DDEFAIL to sMessage
75586>>>>>>>            Case Break
75587>>>>>>>        Case (iErrorID = vSE_ERR_DDETIMEOUT)
75590>>>>>>>            Move CS_DDE_ERR_DDETIMEOUT to sMessage
75591>>>>>>>            Case Break
75592>>>>>>>        Case (iErrorID = vSE_ERR_DLLNOTFOUND)
75595>>>>>>>            Move CS_DDE_ERR_DLLNOTFOUND to sMessage
75596>>>>>>>            Case Break
75597>>>>>>>        Case (iErrorID = vSE_ERR_NOASSOC)
75600>>>>>>>            Move CS_DDE_ERR_NOASSOC to sMessage
75601>>>>>>>            Case Break
75602>>>>>>>        Case ((iErrorID = vSE_ERR_OOM) Or (iErrorID = 0))
75605>>>>>>>            Move CS_DDE_ERR_OOM to sMessage
75606>>>>>>>            Case Break
75607>>>>>>>        Case (iErrorID = vSE_ERR_PNF)
75610>>>>>>>            Move CS_DDE_ERR_PNF to sMessage
75611>>>>>>>            Case Break
75612>>>>>>>        Case (iErrorID = vSE_ERR_SHARE)
75615>>>>>>>            Move CS_DDE_ERR_SHARE to sMessage
75616>>>>>>>            Case Break
75617>>>>>>>        Case Else
75617>>>>>>>            Move CS_DDE_ERR_UNKNOWN_LINE1 to sMessage
75618>>>>>>>            Move (sMessage*Trim(iErrorID)*CS_DDE_ERR_UNKNOWN_LINE2) to sMessage
75619>>>>>>>            Case Break
75620>>>>>>>    Case End
75620>>>>>>>    Function_Return sMessage
75621>>>>>>>End_Function
75622>>>>>>>
75622>>>>>>>Procedure vDDE_Error_Handler Integer iErrorID
75624>>>>>>>    String sMessage
75624>>>>>>>    Get DDE_Error_To_String iErrorID to sMessage
75625>>>>>>>    Append sMessage CS_DDE_ERR_HANDL_PAKTC //  "Press a key to continue..."
75626>>>>>>>    Send Stop_Box sMessage CS_DDE_ERR_HANDL_CAPTION
75627>>>>>>>End_Procedure
75628>>>>>>>
75628>>>>>>>
75628>>>>>>>// This function informs the user that he entered a yet unknown folder and
75628>>>>>>>// asks if he/she wants to create the folder (Yes/No)
75628>>>>>>>// Choice: "Yes" - this creates the folder
75628>>>>>>>//                 if successful, the function returns false
75628>>>>>>>//                 else it will be true.
75628>>>>>>>// Choice: "No"  - returns TRUE, This allows the programmer to take action
75628>>>>>>>//                 For example: to stop a save
75628>>>>>>>// Precondition: A foldername must be entered. We do not check for empty paths
75628>>>>>>>// This function returns a non-zero value if the folder isn't created afterwards
75628>>>>>>>Function vVerifyNewFolder Global String sFolderName Returns Integer
75630>>>>>>>    Integer bIsNotValid
75630>>>>>>>    Integer iUsers_Choice
75630>>>>>>>    String  sMessage
75630>>>>>>>
75630>>>>>>>    If (vFolderExists(sFolderName) Eq 0) Begin
75632>>>>>>>        Move "The folder '" to sMessage
75633>>>>>>>        Append sMessage sFolderName
75634>>>>>>>        Append sMessage "' does not yet exist,\n"
75635>>>>>>>        Append sMessage "Do you want to create it now?"
75636>>>>>>>        Get YesNo_Box sMessage "Confirm" MB_DefButton1 to iUsers_Choice
75637>>>>>>>        Case Begin
75637>>>>>>>            Case (iUsers_Choice = MBR_Yes)
75639>>>>>>>                Move (vCreateDirectory(sFolderName)) to bIsNotValid
75640>>>>>>>                If bIsNotValid Begin
75642>>>>>>>                    Move "An error occurred while trying to create folder '" to sMessage
75643>>>>>>>                    Append sMessage sFolderName "'.\n\n"
75645>>>>>>>                    Send Info_Box sMessage "Info"
75646>>>>>>>                End
75646>>>>>>>>
75646>>>>>>>                Case Break
75647>>>>>>>            Case (iUsers_Choice = MBR_No)
75650>>>>>>>                Move dfTrue to bIsNotValid // Cancel the save
75651>>>>>>>                Case Break
75652>>>>>>>        Case End
75652>>>>>>>    End
75652>>>>>>>>
75652>>>>>>>    Function_Return bIsNotValid
75653>>>>>>>End_Function
75654>>>>>>>
75654>>>>>>>// **WvA
75654>>>>>>>// Formats a foldername by first trimming it and after that by sticking a
75654>>>>>>>// directory separator (/\) to the end if it doesn't have one there already.
75654>>>>>>>// The folder may contain a drive letter or UNC encoding.
75654>>>>>>>Function vFolderFormat Global String sFolderName Returns String
75656>>>>>>>    String sDirSep
75656>>>>>>>    Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep  // normally \ (backslash)
75657>>>>>>>    Move (Trim(sFolderName)) to sFolderName
75658>>>>>>>    If (Right(sFolderName,1)<>sDirSep) Begin
75660>>>>>>>        Move (sFolderName+sDirSep) to sFolderName
75661>>>>>>>    End
75661>>>>>>>>
75661>>>>>>>    Function_Return sFolderName
75662>>>>>>>End_Function
75663>>>>>>>
75663>>>>>>>//
75663>>>>>>>// Gets the parent path of the currently supplied path
75663>>>>>>>// Returns "" when we are at the root folder.
75663>>>>>>>//
75663>>>>>>>Function vParentPath Global String sPath Returns String
75665>>>>>>>    String sStrip sDirSep
75665>>>>>>>
75665>>>>>>>    Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
75666>>>>>>>    Move (Trim(sPath)) to sPath
75667>>>>>>>    If (Right(sPath,1) = sDirSep) Begin
75669>>>>>>>        Move (Left(sPath,Length(sPath)-1)) to sPath
75670>>>>>>>    End
75670>>>>>>>>
75670>>>>>>>    If (Pos(sDirSep, sPath)) Begin
75672>>>>>>>        Move (StringFromRightOfChar(sPath, sDirSep)) to sStrip
75673>>>>>>>        Move (Left(sPath,Length(sPath)-Length(sStrip))) to sPath
75674>>>>>>>    End
75674>>>>>>>>
75674>>>>>>>    Else Begin
75675>>>>>>>        Move "" to sPath
75676>>>>>>>    End
75676>>>>>>>>
75676>>>>>>>    Function_Return sPath
75677>>>>>>>End_Function
75678>>>>>Use DUFLanguageConstants.inc
75678>>>>>
75678>>>>>Define CS_IntFilesTableRootName for "IntFilesTable"
75678>>>>>Define CS_FilelistZipFile       for "FilelistBackupFile.zip"
75678>>>>>Define CS_FilelistBackupFile    for "FilelistBackupFile.cfg"
75678>>>>>
75678>>>>>Struct tDUFIntFile
75678>>>>>    Integer iID
75678>>>>>    String sIntFileName
75678>>>>>    String sIntLineText
75678>>>>>End_Struct
75678>>>>>
75678>>>>>Struct tDbVersionInfo
75678>>>>>    Number nVersionNumber
75678>>>>>    Handle hObject
75678>>>>>End_Struct
75678>>>>>
75678>>>>>Struct tDbUpdateError
75678>>>>>    Number nUpdateVersion
75678>>>>>    Integer iError
75678>>>>>    String  sOrgErrorText
75678>>>>>    String  sErrorText
75678>>>>>    Integer iErrorLine
75678>>>>>    Boolean bError  
75678>>>>>    Handle  hTable 
75678>>>>>    String  sTableRootName
75678>>>>>    Integer iField
75678>>>>>    Boolean bShortFormat
75678>>>>>End_Struct
75678>>>>>
75678>>>>>//  DF_FILE_ALIAS_DEFAULT if no master or alias
75678>>>>>//  DF_FILE_IS_MASTER if master
75678>>>>>//  DF_FILE_IS_ALIAS if alias
75678>>>>>Struct tDbUpdateHandlerMasterAlias
75678>>>>>    Handle hTable
75678>>>>>    Integer iMode
75678>>>>>End_Struct
75678>>>>>
75678>>>>>// Used as a start for error handing. Used by Error_Report_Mode property
75678>>>>>Enumeration_List
75678>>>>>    Define DUF_ERROR_REPORT    // Report Error on screen
75678>>>>>    Define DUF_ERROR_NO_REPORT // Show no Error..
75678>>>>>End_Enumeration_List
75678>>>>>
75678>>>>>    Define DATAFLEX_ID for "DATAFLEX"
75678>>>>>
75678>>>>>// Global handle to a cDatabaseUpdateHandler object that can be used to
75678>>>>>// communicate with the object from anywhere in a program.
75678>>>>>    Global_Variable Handle ghoDbUpdateHandler
75678>>>>>    Move 0 to ghoDbUpdateHandler
75679>>>>>
75679>>>>>// NOTE: If the DbVersion table should _not_ be used and you
75679>>>>>// instead set the "Set Data_File_Field to (RefTable(MyTable)) (RefTable(MyTable.DbUpdateVersion))"
75679>>>>>// in the cDbUpdateHandler object; Add a "Define DUF_Use_DbVersion" to your code,
75679>>>>>// _before_ the "Use cDbUpdateHandler.pkg" line.
75679>>>>>//#IFNDEF DUF_Use_Custom_DbVersion
75679>>>>>//    Declare_Datafile DbVersion
75679>>>>>//#ENDIF
75679>>>Use cDbUpdateLogFile.pkg
Including file: cDbUpdateLogFile.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateLogFile.pkg)
75679>>>>>//****************************************************************************
75679>>>>>// $Module type: Class
75679>>>>>// $Module name: cDbUpdateLogFile
75679>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
75679>>>>>// Web-site    : http://www.rdctools.com
75679>>>>>// Created     : 2016-10-05 @ 18:58 (Military date format: YY-MM-DD)
75679>>>>>//
75679>>>>>// Description : This logic was moved from the cDbUpdateHandler class so that it would
75679>>>>>//               be easier to change to where errors/status messages are written/saved. As it is less likely
75679>>>>>//               that this class is to change; each developer can decide if the errors instead
75679>>>>>//               should be saved to a database table, or something entirely different.
75679>>>>>//               The default is to write the errors to a Ascii-file in the Data folder.
75679>>>>>//
75679>>>>>// $Rev History:
75679>>>>>//    2016-10-05  Module header created
75679>>>>>//****************************************************************************
75679>>>>>Use UI
75679>>>>>Use vWin32fh.pkg
75679>>>>>
75679>>>>>
75679>>>>>    Define CS_DatabaseUpdateFramework for " ***  The Database Update Framework (DUF) ***"
75679>>>>>
75679>>>>>Define CS_SuccessfulUpdate for "The database was updated successfully!"
75679>>>>>
75679>>>>>Class cDbUpdateLogFile is a cObject
75680>>>>>
75680>>>>>    Procedure Construct_Object
75682>>>>>        Forward Send Construct_Object
75684>>>>>
75684>>>>>        // Error handling:
75684>>>>>        Property tDbUpdateError[] paDbUpdateErrorArray
75685>>>>>        Property Integer piChannel -1
75686>>>>>
75686>>>>>        // This property is set by the cDbUpdateHandler object,
75686>>>>>        // when the update process starts.
75686>>>>>        Property DateTime pdtUpdateStart
75687>>>>>
75687>>>>>        // Gets set to False if the log contains data
75687>>>>>        Property Boolean pbEmptyLogFile True
75688>>>>>
75688>>>>>        // Gets set to True after the error log header text
75688>>>>>        // has been written.
75688>>>>>        Property Boolean pbHeaderWritten False
75689>>>>>
75689>>>>>        // If all activities should be logged- not just errors.
75689>>>>>        Property Boolean pbVerboseState False
75690>>>>>
75690>>>>>        // File name for the error log where all errors
75690>>>>>        // after a run is written to (appended).
75690>>>>>        // It is saved in the Data folder.
75690>>>>>        Property String psLogTextFile   "DUFUpdateLog.txt"
75691>>>>>        // If this property is set to "" in object code, the
75691>>>>>        // "shell" command parameter will be used to let Windows decide
75691>>>>>        // with which program to open the logfile.
75691>>>>>        Property String psEditorProgram ""
75692>>>>>
75692>>>>>        Property Boolean pbUseDataTableLog False
75693>>>>>
75693>>>>>        // If true an error will be written to file immediately when
75693>>>>>        // it occurs. This can be handy if a large update generates a lots
75693>>>>>        // of errors and the application crasches before finished, thus
75693>>>>>        // the errors will not be written.
75693>>>>>        Property Boolean pbQuickWrite True
75694>>>>>    End_Procedure
75695>>>>>
75695>>>>>    Procedure End_Construct_Object
75697>>>>>        Forward Send End_Construct_Object
75699>>>>>
75699>>>>>    End_Procedure
75700>>>>>
75700>>>>>    Procedure LogError Number nVersion Integer iError String sErrorText Integer iErrorLine Boolean bError Boolean bShortFormatIn
75702>>>>>        tDbUpdateError[] DbUpdateErrorArray DbUpdateErrorArrayEmpty
75702>>>>>        tDbUpdateError[] DbUpdateErrorArray DbUpdateErrorArrayEmpty
75704>>>>>        Boolean bShortFormat
75704>>>>>        Integer iSize
75704>>>>>        Handle hCurrentTable
75704>>>>>        Integer iCurrentField           
75704>>>>>        String sOrgErrorText sTableRootName
75704>>>>>        
75704>>>>>        Move False to bShortFormat
75705>>>>>        If (num_arguments > 5) Begin
75707>>>>>            Move bShortFormatIn to bShortFormat
75708>>>>>        End
75708>>>>>>
75708>>>>>        // Only do once.
75708>>>>>        If (pbHeaderWritten(Self) = False) Begin
75710>>>>>            Send WriteHeaderData
75711>>>>>            Set pbHeaderWritten to True
75712>>>>>        End
75712>>>>>>
75712>>>>>
75712>>>>>        Get Private.phCurrentTable to hCurrentTable  
75713>>>>>        Get Private.piCurrentField to iCurrentField  
75714>>>>>        If (iError > 0) Begin
75716>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hCurrentTable to sTableRootName
75719>>>>>            Get FetchErrorDescription iError to sOrgErrorText 
75720>>>>>        End
75720>>>>>>
75720>>>>>        Get paDbUpdateErrorArray to DbUpdateErrorArray
75721>>>>>        Move (SizeOfArray(DbUpdateErrorArray)) to iSize
75722>>>>>        Move nVersion       to DbUpdateErrorArray[iSize].nUpdateVersion
75723>>>>>        Move iError         to DbUpdateErrorArray[iSize].iError
75724>>>>>        Move iErrorLine     to DbUpdateErrorArray[iSize].iErrorLine
75725>>>>>        Move True           to DbUpdateErrorArray[iSize].bError  
75726>>>>>        Move sOrgErrorText  to DbUpdateErrorArray[iSize].sOrgErrorText
75727>>>>>        Move sErrorText     to DbUpdateErrorArray[iSize].sErrorText
75728>>>>>        Move hCurrentTable  to DbUpdateErrorArray[iSize].hTable            
75729>>>>>        Move sTableRootName to DbUpdateErrorArray[iSize].sTableRootName
75730>>>>>        Move iCurrentField  to DbUpdateErrorArray[iSize].iField  
75731>>>>>        Move bShortFormat   to DbUpdateErrorArray[iSize].bShortFormat
75732>>>>>
75732>>>>>        If (bError = False) Begin
75734>>>>>            Move False to DbUpdateErrorArray[iSize].bError
75735>>>>>        End
75735>>>>>>
75735>>>>>        Set paDbUpdateErrorArray to DbUpdateErrorArray
75736>>>>>
75736>>>>>        If (pbUseDataTableLog(Self) = True) Begin
75738>>>>>            If (pbQuickWrite(Self) = True) Begin
75740>>>>>                Send OnWriteRow_DataTable
75741>>>>>                // If we are writing error for error flush the
75741>>>>>                // error array when latest error has been written.
75741>>>>>                Set paDbUpdateErrorArray to DbUpdateErrorArrayEmpty
75742>>>>>            End
75742>>>>>>
75742>>>>>            Procedure_Return
75743>>>>>        End
75743>>>>>>
75743>>>>>        Else Begin
75744>>>>>            If (pbQuickWrite(Self) = True) Begin
75746>>>>>                Send WriteErrorLog
75747>>>>>                // Flush the error log array
75747>>>>>                Set paDbUpdateErrorArray to DbUpdateErrorArrayEmpty
75748>>>>>            End
75748>>>>>>
75748>>>>>        End
75748>>>>>>
75748>>>>>    End_Procedure   
75749>>>>>    
75749>>>>>    Function FetchErrorDescription Integer iError Returns String
75751>>>>>        String sErrorText         
75751>>>>>        Move "" to sErrorText
75752>>>>>        If (iError > 0) Begin
75754>>>>>            Move (Error_Text(Desktop, iError)) to sErrorText 
75755>>>>>        End
75755>>>>>>
75755>>>>>        Function_Return sErrorText
75756>>>>>    End_Function
75757>>>>>
75757>>>>>    // Hook procedure for writing header text prior starting the update work to
75757>>>>>    // a database table. This does nothing by default.
75757>>>>>    // Don't forget to Open your "error log table" first (!) as all
75757>>>>>    // tables have been closed at this stage. Put anything
75757>>>>>    // you want to indicate that the update process is just started.
75757>>>>>    Procedure OnWriteHeader_DataTable DateTime dtUpdateStart
75759>>>>>        Delegate Send OnErrorWriteHeader_DataTable dtUpdateStart
75761>>>>>    End_Procedure
75762>>>>>
75762>>>>>    Procedure OnWriteRow_DataTable
75764>>>>>        tDbUpdateError[] DbUpdateErrorArray
75764>>>>>        tDbUpdateError[] DbUpdateErrorArray
75765>>>>>        Get paDbUpdateErrorArray to DbUpdateErrorArray
75766>>>>>        If (SizeOfArray(DbUpdateErrorArray) > 0) Begin
75768>>>>>            Delegate Send OnErrorWriteRow_DataTable DbUpdateErrorArray
75770>>>>>        End
75770>>>>>>
75770>>>>>    End_Procedure
75771>>>>>
75771>>>>>    Function psLogTextFileWithPath Returns String
75773>>>>>        String sPath sFileName sFullFileName
75773>>>>>        
75773>>>>>        Get psDataPathFirstPart to sPath
75774>>>>>        Get psLogTextFile to sFileName
75775>>>>>        Move (sPath + sFileName) to sFullFileName
75776>>>>>        Function_Return sFullFileName
75777>>>>>    End_Function                     
75778>>>>>    
75778>>>>>    Procedure WriteHeaderData
75780>>>>>        String sFileName
75780>>>>>        Integer iCh iSize
75780>>>>>        Boolean bQuickWrite
75780>>>>>        DateTime dtUpdateStart
75780>>>>>
75780>>>>>        Move (CurrentDateTime()) to dtUpdateStart
75781>>>>>        If (pbUseDataTableLog(Self) = True) Begin
75783>>>>>            Send OnWriteHeader_DataTable dtUpdateStart
75784>>>>>            Procedure_Return
75785>>>>>        End
75785>>>>>>
75785>>>>>
75785>>>>>        Get piChannel to iCh
75786>>>>>        If (iCh < 0) Begin
75788>>>>>            Get Seq_New_Channel to iCh
75789>>>>>            If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
75791>>>>>                Error DFERR_PROGRAM "No free channel for writing output!"
75792>>>>>>
75792>>>>>                Procedure_Return
75793>>>>>            End
75793>>>>>>
75793>>>>>            Set piChannel to iCh
75794>>>>>        End
75794>>>>>>
75794>>>>>
75794>>>>>        Get psLogTextFileWithPath to sFileName
75795>>>>>        Get vWin32_APIFileSize sFileName to iSize
75796>>>>>        Get pbQuickWrite to bQuickWrite
75797>>>>>        
75797>>>>>        If (bQuickWrite = True) Begin
75799>>>>>            Append_Output channel iCh sFileName
75801>>>>>                If (bQuickWrite = True) Begin
75803>>>>>                    If (iSize = 0) Begin
75805>>>>>                        Writeln channel iCh CS_DatabaseUpdateFramework
75808>>>>>                        Set pbEmptyLogFile to False
75809>>>>>                    End
75809>>>>>>
75809>>>>>                    Writeln channel iCh
75811>>>>>                    Writeln channel iCh ("Database Update Started:      " + String(dtUpdateStart))
75814>>>>>                End
75814>>>>>>
75814>>>>>            Close_Output channel iCh
75816>>>>>        End
75816>>>>>>
75816>>>>>    End_Procedure
75817>>>>>
75817>>>>>    // Returns the first datapath found in the psDataPath property.
75817>>>>>    // The returned path always ends with a "\"
75817>>>>>    Function psDataPathFirstPart Returns String
75819>>>>>        String sDataPath
75819>>>>>        Integer iCount
75819>>>>>
75819>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
75820>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
75821>>>>>        If (iCount > 1) Begin
75823>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
75824>>>>>        End
75824>>>>>>
75824>>>>>        If (sDataPath <> "") Begin
75826>>>>>            Get vFolderFormat sDataPath to sDataPath
75827>>>>>        End
75827>>>>>>
75827>>>>>
75827>>>>>        Function_Return sDataPath
75828>>>>>    End_Function
75829>>>>>
75829>>>>>    // Called from the cDbUpdateHandler object after all updates have been done.
75829>>>>>    Procedure WriteErrorLog
75831>>>>>        tDbUpdateError[] aDbUpdateErrorArray
75831>>>>>        tDbUpdateError[] aDbUpdateErrorArray
75832>>>>>        String sFileName sErrorNo sVersion sErrorText sText sRootName sOrgErrorText
75832>>>>>        Integer iCount iSize iCh iError iErrorLine iField
75832>>>>>        Boolean bUseDataTable bQuickWrite
75832>>>>>        DateTime dtUpdateStart dtUpdateEnd
75832>>>>>        TimeSpan tsElapsed
75832>>>>>        Number nVersion                                  
75832>>>>>        Handle hTable
75832>>>>>
75832>>>>>        If (pbHeaderWritten(Self) = False) Begin
75834>>>>>            Send WriteHeaderData
75835>>>>>            Set pbHeaderWritten to True
75836>>>>>        End
75836>>>>>>
75836>>>>>
75836>>>>>        Get pbUseDataTableLog to bUseDataTable
75837>>>>>        If (bUseDataTable = True) Begin
75839>>>>>            Send OnWriteRow_DataTable
75840>>>>>            Procedure_Return
75841>>>>>        End
75841>>>>>>
75841>>>>>
75841>>>>>        Get piChannel to iCh
75842>>>>>        If (iCh < 0) Begin
75844>>>>>            Get Seq_New_Channel to iCh
75845>>>>>            If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
75847>>>>>                Error DFERR_PROGRAM "No free channel for writing output!"
75848>>>>>>
75848>>>>>                Procedure_Return
75849>>>>>            End
75849>>>>>>
75849>>>>>            Set piChannel to iCh
75850>>>>>        End
75850>>>>>>
75850>>>>>
75850>>>>>        Get psLogTextFileWithPath to sFileName
75851>>>>>
75851>>>>>        Get paDbUpdateErrorArray to aDbUpdateErrorArray
75852>>>>>        Move (SizeOfArray(aDbUpdateErrorArray)) to iSize
75853>>>>>        Decrement iSize
75854>>>>>
75854>>>>>        Get pdtUpdateStart to dtUpdateStart
75855>>>>>        If (IsNullDateTime(dtUpdateStart) = False) Begin
75857>>>>>            Move (CurrentDateTime()) to dtUpdateEnd
75858>>>>>            Move (dtUpdateEnd - dtUpdateStart) to tsElapsed
75859>>>>>        End
75859>>>>>>
75859>>>>>        Get pbQuickWrite to bQuickWrite
75860>>>>>
75860>>>>>        Append_Output channel iCh sFileName
75862>>>>>        If (bQuickWrite = True and iSize < 0) Begin
75864>>>>>            Writeln channel iCh ("Database Update Finished:  " + String(dtUpdateEnd) * "Time Elapsed:" * String(tsElapsed))
75867>>>>>        End
75867>>>>>>
75867>>>>>        Else If (bQuickWrite = False) Begin
75870>>>>>            Writeln channel iCh
75872>>>>>            Writeln channel iCh ("Database Update Started:" * String(dtUpdateStart) * "and finished at:" * String(dtUpdateEnd) * "Time Elapsed:" * String(tsElapsed))
75875>>>>>        End   
75875>>>>>>
75875>>>>>        If (iSize >= 0) Begin
75877>>>>>            If (aDbUpdateErrorArray[0].bShortFormat = False) Begin
75879>>>>>                Writeln channel iCh "[Err No:] [pnVersionNumber:] [Status Text:]"
75882>>>>>            End
75882>>>>>>
75882>>>>>        End
75882>>>>>>
75882>>>>>
75882>>>>>        For iCount from 0 to iSize  
75888>>>>>>
75888>>>>>            Move aDbUpdateErrorArray[iCount].iError         to iError
75889>>>>>            Move aDbUpdateErrorArray[iCount].nUpdateVersion to nVersion
75890>>>>>            Move aDbUpdateErrorArray[iCount].sErrorText     to sErrorText
75891>>>>>            Move aDbUpdateErrorArray[iCount].iErrorLine     to iErrorLine  
75892>>>>>            Move aDbUpdateErrorArray[iCount].hTable         to hTable
75893>>>>>            Move aDbUpdateErrorArray[iCount].sTableRootName to sRootName
75894>>>>>            Move aDbUpdateErrorArray[iCount].iField         to iField
75895>>>>>            
75895>>>>>            Get PadLeft (String(iError)) 8 to sErrorNo
75896>>>>>            If (aDbUpdateErrorArray[iCount].bError = True) Begin
75898>>>>>                Get PadLeft (String(nVersion)) (27 - Length(sErrorNo)) to sVersion
75899>>>>>                Move (sErrorNo + sVersion + "   " + sErrorText * "[ErrLine:" * String(iErrorLine) + "]" + "    (Table:" * sRootName * String(hTable) + "." + String(iField) + ")") to sText
75900>>>>>            End
75900>>>>>>
75900>>>>>            Else Begin
75901>>>>>                Get PadLeft (String(nVersion)) 27 to sVersion
75902>>>>>                Move (sVersion + "   " + sErrorText) to sText
75903>>>>>            End
75903>>>>>>
75903>>>>>            Writeln channel iCh sText
75906>>>>>            If (aDbUpdateErrorArray[iCount].sOrgErrorText <> "") Begin
75908>>>>>                Move ("   (" + aDbUpdateErrorArray[iCount].sOrgErrorText + ")") to sOrgErrorText
75909>>>>>                Move (Utf8ToAnsi(sOrgErrorText)) to sOrgErrorText       
75910>>>>>                Writeln channel iCh sOrgErrorText
75913>>>>>            End
75913>>>>>>
75913>>>>>            If (sText contains CS_SuccessfulUpdate) Begin
75915>>>>>                Writeln channel iCh
75917>>>>>            End
75917>>>>>>
75917>>>>>        Loop
75918>>>>>>
75918>>>>>        Close_Output channel iCh
75920>>>>>
75920>>>>>        Send Seq_Release_Channel iCh
75921>>>>>        Set piChannel to -1
75922>>>>>
75922>>>>>    End_Procedure
75923>>>>>
75923>>>>>    // The character to pad is optional. If nothing, spaces are used.
75923>>>>>    // Example:
75923>>>>>    // Move (PadLeft(45672,10,"0")) to sString -> "0000045672"
75923>>>>>    //  or:
75923>>>>>    // Move (PadLeft("Test",10)) to sString -> " Test"
75923>>>>>    // Courtesy of Pieter van Dieren. Collected from DAWs' Newsgroups.
75923>>>>>    Function PadLeft String sString Integer iLength String sOptChar Returns String
75925>>>>>        String sChar
75925>>>>>
75925>>>>>        If (Num_Arguments >= 3) Begin
75927>>>>>            Move sOptChar to sChar
75928>>>>>        End
75928>>>>>>
75928>>>>>        Else Begin
75929>>>>>            Move " " to sChar
75930>>>>>        End
75930>>>>>>
75930>>>>>
75930>>>>>        While (Length(sString) < iLength)
75934>>>>>            Move (sChar + sString) to sString
75935>>>>>        Loop
75936>>>>>>
75936>>>>>
75936>>>>>        Function_Return sString
75937>>>>>    End_Function
75938>>>>>
75938>>>>>    Procedure ShowErrorLog
75940>>>>>        String sPath sFileName sEditorProgram
75940>>>>>        Boolean bExists
75940>>>>>
75940>>>>>        Get psLogTextFileWithPath to sFileName
75941>>>>>        Get vFilePathExists sFileName to bExists
75942>>>>>        If (bExists = True) Begin
75944>>>>>            Get psEditorProgram to sEditorProgram
75945>>>>>            If (sEditorProgram <> "") Begin
75947>>>>>                Runprogram Background (psEditorProgram(Self)) (sPath + sFileName)
75948>>>>>            End
75948>>>>>>
75948>>>>>            Else Begin
75949>>>>>                Runprogram Shell Background sFileName
75950>>>>>            End
75950>>>>>>
75950>>>>>        End
75950>>>>>>
75950>>>>>        Else Begin
75951>>>>>            Send Info_Box (CS_DUF_LogFileNotFound + String(sFileName))
75952>>>>>        End
75952>>>>>>
75952>>>>>    End_Procedure
75953>>>>>
75953>>>>>End_Class
75954>>>Use cDbUpdateVersion.pkg
Including file: cDbUpdateVersion.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateVersion.pkg)
75954>>>>>//****************************************************************************
75954>>>>>// $Module type: Class
75954>>>>>// $Module name: cDbUpdateVersion
75954>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
75954>>>>>// Web-site    : http://www.rdctools.com
75954>>>>>// Created     : 2016-09-27 @ 09:33 (Military date format: YY-MM-DD)
75954>>>>>//
75954>>>>>// Description : Child class to cDbUpdateHandler.
75954>>>>>//               Put an object of this class inside the global ghoDbUpdateHandler object.
75954>>>>>//               Set the pnVersionNumber to a version number.
75954>>>>>//               Inside the cDbUpdateVersion object put a "Use MyNewDbUpdatePackage.pkg"
75954>>>>>//               Add one cVersion object for each update of the database to the ghoDbUpdateHandler object.
75954>>>>>//               Place your code in the "OnUpdate" event that alters the database.
75954>>>>>//
75954>>>>>// $Rev History:
75954>>>>>//    2016-09-27  Module header created
75954>>>>>//****************************************************************************
75954>>>>>Use UI
75954>>>>>Use DUFLanguageConstants.inc
75954>>>>>Use cDbUpdateFunctionLibrary.pkg
Including file: cDbUpdateFunctionLibrary.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary.pkg)
75954>>>>>>>//****************************************************************************
75954>>>>>>>// $Module type: Class
75954>>>>>>>// $Module name: cDbUpdateFunctionLibrary
75954>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
75954>>>>>>>// Web-site    : http://www.rdctools.com
75954>>>>>>>// Created     : 2014-09-05 @ 09:50 (Military date format: YY-MM-DD)
75954>>>>>>>//
75954>>>>>>>// Description : The class consists of a function library for database manipulations, aka make changes to a database.
75954>>>>>>>//               It has top level functions that uses the DataFlex db API, _but_ also specialized
75954>>>>>>>//               functions to make db changes to Sql databases with DAW drivers,
75954>>>>>>>//               with the help of Sql-scripts.
75954>>>>>>>//
75954>>>>>>>// $Rev History:
75954>>>>>>>//    2014-09-05  Module header created
75954>>>>>>>//
75954>>>>>>>//****************************************************************************
75954>>>>>>>//
75954>>>>>>>// Martin Moleman on SQL Server and DateTime2 (Don't use DataTime any longer !)
75954>>>>>>>// One remark about your change: I would not change to datetime2(7) (7 decimals) but to
75954>>>>>>>// datetime2(3) (3 decimals = milliseconds) or If you don't need the milliseconds datetime2(0).
75954>>>>>>>// The reason is that the DataFlex DateTime type only allows 3 decimals. When using 7
75954>>>>>>>// decimals you may Get truncation that again may cause problems with finding.
75954>>>>>>>//
75954>>>>>>>// Important! The conversion from DateTime to Date or datetime2 will also convert all dummy zero Date values from 1753-01-01 to 0001-01-01.
75954>>>>>>>// This is important to realize. The conversion will actually change the data in the database (done by the driver)
75954>>>>>>>
75954>>>>>>>
75954>>>>>>>// DF_DATABASE_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA
75954>>>>>>>// Determines for all DataFlex data types, which SQL native types willbe used when creating new columns.
75954>>>>>>>// Set_Attribute DF_DATABASE_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA of {driverNumber} {databaseHandle} ;
75954>>>>>>>// to {MAP_DF_TO_SQL_TYPE_SQL2000|MAP_DF_TO_SQL_TYPE_SQL2005|MAP_DF_TO_SQL_TYPE_SQL2008|MAP_DF_TO_SQL_TYPE_SQL2012}
75954>>>>>>>//
75954>>>>>>>Use cBaseDbUpdateFuncLib.pkg
Including file: cBaseDbUpdateFuncLib.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cBaseDbUpdateFuncLib.pkg)
75954>>>>>>>>>//****************************************************************************
75954>>>>>>>>>// $Module type: Class
75954>>>>>>>>>// $Module name: cBaseDbUpdateFuncLib
75954>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
75954>>>>>>>>>// Web-site    : http://www.rdctools.com
75954>>>>>>>>>// Created     : 2023-11-06 @ 09:50 (Military date format: YY-MM-DD)
75954>>>>>>>>>//
75954>>>>>>>>>// Description : The class consists of the basis/parent for the cDbUpdateFunctionLibrary class
75954>>>>>>>>>//               It contains helper functions for the cDbUpdateFunctionLibrary class
75954>>>>>>>>>//
75954>>>>>>>>>// $Rev History:
75954>>>>>>>>>//    2023-11-06  Module header created
75954>>>>>>>>>//
75954>>>>>>>>>//****************************************************************************
75954>>>>>>>>>Use cApplication.pkg
75954>>>>>>>>>Use seq_chnl.pkg
75954>>>>>>>>>Use GlobalFunctionsProcedures.pkg
75954>>>>>>>>>Use Datadict.pkg                        // Declaration of DF_FILE_SQL_TABLE_NAME
75954>>>>>>>>>Use Dfcursor.pkg
75954>>>>>>>>>Use DUFStatusPanel.pkg
75954>>>>>>>>>Use cDbUpdateFunctionLibrary_Mixin.pkg  // Properties used by the cDbUpdateFunctionLibrary class.
Including file: cDbUpdateFunctionLibrary_Mixin.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary_Mixin.pkg)
75954>>>>>>>>>>>// *** Mixin Class For the cDbUpdateFunctionLibrary Class ***
75954>>>>>>>>>>>//
75954>>>>>>>>>>>// We need to create a mixin class for the library.
75954>>>>>>>>>>>// Why? Because we import the library to the cDbUpdateVersion class; that imports
75954>>>>>>>>>>>// all messages (functions & procedures) but all Properties are "lost", aka not imported by
75954>>>>>>>>>>>// the Import_Class_Protocol command. So we need a way to create our properties somewhere else...
75954>>>>>>>>>>>// Note: This class should _not_ have a construct_object defined.
75954>>>>>>>>>>>//
75954>>>>>>>>>>>Use VdfBase.pkg
75954>>>>>>>>>>>Use WinUuid.pkg
Including file: WinUuid.pkg    (C:\Program Files\DataFlex 24.0\Pkg\WinUuid.pkg)
75954>>>>>>>>>>>>>Use Unicode.Pkg
75954>>>>>>>>>>>>>
75954>>>>>>>>>>>>>External_Function WinAPI_UuidCreate "UuidCreate" Rpcrt4.dll ;    Pointer Uuid ;    Returns Integer
75955>>>>>>>>>>>>>
75955>>>>>>>>>>>>>External_Function WinAPI_UuidToString  "UuidToStringW" Rpcrt4.dll ;    Pointer pUuid ;    Pointer lpUUIDString ;    Returns Integer
75956>>>>>>>>>>>>>
75956>>>>>>>>>>>>>External_Function WinAPI_UuidCreateSequential "UuidCreateSequential" Rpcrt4.dll ;    Pointer pUuid ;    Returns Integer
75957>>>>>>>>>>>>>
75957>>>>>>>>>>>>>External_Function WinAPI_RpcStringFree "RpcStringFreeW" Rpcrt4.dll ;    Pointer pStr ;    Returns Integer
75958>>>>>>>>>>>>>
75958>>>>>>>>>>>>>
75958>>>>>>>>>>>>>// Returns a 'random' Universally Unique Identifier string as a 32 digit hex number.
75958>>>>>>>>>>>>>Function RandomHexUUID Global Returns String
75960>>>>>>>>>>>>>    Pointer pUUID pUUIDStr
75960>>>>>>>>>>>>>    Integer iRetval iOffset iChar
75960>>>>>>>>>>>>>    String sUUID
75960>>>>>>>>>>>>>    
75960>>>>>>>>>>>>>    Move (Alloc(16)) to pUUID
75961>>>>>>>>>>>>>    
75961>>>>>>>>>>>>>    Move (WinAPI_UuidCreate (pUUID)) to iRetval
75962>>>>>>>>>>>>>    
75962>>>>>>>>>>>>>    If (iRetval = 0) Begin
75964>>>>>>>>>>>>>        Move 0 to pUUIDStr
75965>>>>>>>>>>>>>        
75965>>>>>>>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
75966>>>>>>>>>>>>>        If (iRetval = 0) Begin
75968>>>>>>>>>>>>>            Move (PointerToWString(pUUIDStr)) to sUUID
75969>>>>>>>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
75970>>>>>>>>>>>>>            
75970>>>>>>>>>>>>>            Move (Uppercase (sUUID)) to sUUID
75971>>>>>>>>>>>>>        End
75971>>>>>>>>>>>>>>
75971>>>>>>>>>>>>>    End
75971>>>>>>>>>>>>>>
75971>>>>>>>>>>>>>    
75971>>>>>>>>>>>>>    Move (Free(pUUID)) to iRetval
75972>>>>>>>>>>>>>    
75972>>>>>>>>>>>>>    Function_Return sUUID
75973>>>>>>>>>>>>>End_Function
75974>>>>>>>>>>>>>
75974>>>>>>>>>>>>>
75974>>>>>>>>>>>>>// Returns a sequential Universally Unique Identifier string as a 32 digit hex number.
75974>>>>>>>>>>>>>Function SeqHexUUID Global Returns String
75976>>>>>>>>>>>>>    Pointer pUUID pUUIDStr
75976>>>>>>>>>>>>>    Integer iRetval iOffset iChar
75976>>>>>>>>>>>>>    String sUUID
75976>>>>>>>>>>>>>    
75976>>>>>>>>>>>>>    Move (Alloc(16)) to pUUID
75977>>>>>>>>>>>>>    
75977>>>>>>>>>>>>>    Move (WinAPI_UuidCreateSequential (pUUID)) to iRetval
75978>>>>>>>>>>>>>    
75978>>>>>>>>>>>>>    If (iRetval = 0) Begin
75980>>>>>>>>>>>>>        Move 0 to pUUIDStr
75981>>>>>>>>>>>>>        
75981>>>>>>>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
75982>>>>>>>>>>>>>        If (iRetval = 0) Begin
75984>>>>>>>>>>>>>            Move (PointerToWString(pUUIDStr)) to sUUID
75985>>>>>>>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
75986>>>>>>>>>>>>>            
75986>>>>>>>>>>>>>            Move (Uppercase (sUUID)) to sUUID
75987>>>>>>>>>>>>>        End
75987>>>>>>>>>>>>>>
75987>>>>>>>>>>>>>    End
75987>>>>>>>>>>>>>>
75987>>>>>>>>>>>>>    
75987>>>>>>>>>>>>>    Move (Free(pUUID)) to iRetval
75988>>>>>>>>>>>>>    
75988>>>>>>>>>>>>>    Function_Return sUUID
75989>>>>>>>>>>>>>End_Function
75990>>>>>>>>>>>Use cli.pkg
75990>>>>>>>>>>>Use sql.pkg
75990>>>>>>>>>>>Use MSSqldrv.pkg
Including file: MSSqldrv.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\MSSqldrv.pkg)
75990>>>>>>>>>>>>>//     Package that declares MS SQL driver constants and functions.
75990>>>>>>>>>>>>>//     This package can be used by developers who want to add Data Access
75990>>>>>>>>>>>>>//     MS SQL Client specific code to a DataFlex application.
75990>>>>>>>>>>>>>
75990>>>>>>>>>>>>>Use Cli.pkg
75990>>>>>>>>>>>>>Use SQL.pkg
75990>>>>>>>>>>>>>
75990>>>>>>>>>>>>>//   Driver Indentification
75990>>>>>>>>>>>>>
75990>>>>>>>>>>>>>//   Error number constants
75990>>>>>>>>>>>>>
75990>>>>>>>>>>>>>
75990>>>>>>>>>>>>>//   Possible DF_DRIVER_SQLSERVER_CLIENT_VERSION values
75990>>>>>>>>>>>>>
75990>>>>>>>>>>>>>
75990>>>>>>>>>>>>>
75990>>>>>>>>>>>>>
75990>>>>>>>>>>>>>
75990>>>>>>>>>>>>>
75990>>>>>>>>>>>>>// SQL Server spcific types.
75990>>>>>>>>>>>>>Define SQL_SS_TIMESTAMPOFFSET   for   (-155) //SQL server datetimeoffset type */
75990>>>>>>>>>>>>>Define SQL_SS_TIME2             for   (-154) //SQL server time type */
75990>>>>>>>>>>>>>Define SQL_SS_XML               for   (-152) //SQL server xml type */
75990>>>>>>>>>>>>>Define SQL_SS_VARIANT           for   (-150) //SQL server variant type */
75990>>>>>>>>>>>>>
75990>>>>>>>>>>>>>// SQL Server spcific types.
75990>>>>>>>>>>>>>Define SQL_TYPE_TIMESTAMP2      for   (-200) //SQL server datetime2 type */
75990>>>>>>>>>>>>>Define SQL_VARCHARMAX           for   (-201) //SQL server varchar(max) type */
75990>>>>>>>>>>>>>Define SQL_WVARCHARMAX          for   (-202) //SQL server wvarchar(max) type */
75990>>>>>>>>>>>>>Define SQL_VARBINARYMAX         for   (-203) //SQL server varbinary(max) type */
75990>>>>>>>>>>>>>Define SQL_TYPE_MONEY           for   (-204) //SQL server money type */
75990>>>>>>>>>>>>>Define SQL_TYPE_SMALLMONEY      for   (-205) //SQL server smallmoney type */
75990>>>>>>>>>>>>>Define SQL_TYPE_SMALLDATETIME   for   (-206) //SQL server smalldatetype type */
75990>>>>>>>>>>>>>
75990>>>>>>>>>>>>>
75990>>>>>>>>>>>>>//   MSSQL_SetConstraint <FileNum> <ConstraintText>
75990>>>>>>>>>>>>>//
75990>>>>>>>>>>>>>//     Setup a constraint for a file.
75990>>>>>>>>>>>>>
75990>>>>>>>>>>>>>
75990>>>>>>>>>>>>>Class cMSSQLHandler is a cCLIHandler
75991>>>>>>>>>>>>>    
75991>>>>>>>>>>>>>    Procedure Construct_Object
75993>>>>>>>>>>>>>        Forward Send Construct_Object
75995>>>>>>>>>>>>>        
75995>>>>>>>>>>>>>        Set psDriverID to MSSQLDRV_ID
75996>>>>>>>>>>>>>    End_Procedure
75997>>>>>>>>>>>>>    
75997>>>>>>>>>>>>>    
75997>>>>>>>>>>>>>    
75997>>>>>>>>>>>>>    //   Extract the list from the out connect string.
75997>>>>>>>>>>>>>    Function ExtractList String sOutConnStr Integer hoStore Returns Integer
75999>>>>>>>>>>>>>        String  sItem
75999>>>>>>>>>>>>>        Integer iStart
75999>>>>>>>>>>>>>        Integer iEnd
75999>>>>>>>>>>>>>        
75999>>>>>>>>>>>>>        If (hoStore = 0) ;            Move Current_object to hoStore
76002>>>>>>>>>>>>>        
76002>>>>>>>>>>>>>        Send Delete_Data to hoStore
76003>>>>>>>>>>>>>        Move (Pos("{", sOutConnStr)) to iStart
76004>>>>>>>>>>>>>        While (iStart > 0)
76008>>>>>>>>>>>>>            Move (Right(sOutConnStr, Length(sOutConnStr) - iStart)) to sOutConnStr
76009>>>>>>>>>>>>>            If (Left(sOutConnStr, 1) = "}") ;                Move 0 to iStart
76012>>>>>>>>>>>>>            Else Begin
76013>>>>>>>>>>>>>                Move (Pos(",", sOutConnStr)) to iStart
76014>>>>>>>>>>>>>                Move (Pos("}", sOutConnStr)) to iEnd
76015>>>>>>>>>>>>>                If ((iStart = 0) or (iEnd < iStart)) ;                    Move iEnd to iStart
76018>>>>>>>>>>>>>                
76018>>>>>>>>>>>>>                If (iStart > 0) ;                    Set Value of hoStore  (Item_Count(Current_Object)) to (Left(sOutConnStr, iStart - 1))
76021>>>>>>>>>>>>>                
76021>>>>>>>>>>>>>                If (iStart = iEnd) ;                    Move 0 to iStart
76024>>>>>>>>>>>>>            End
76024>>>>>>>>>>>>>>
76024>>>>>>>>>>>>>        Loop
76025>>>>>>>>>>>>>>
76025>>>>>>>>>>>>>        
76025>>>>>>>>>>>>>        Function_Return (Item_Count(hoStore))
76026>>>>>>>>>>>>>    End_Procedure
76027>>>>>>>>>>>>>    
76027>>>>>>>>>>>>>    
76027>>>>>>>>>>>>>    
76027>>>>>>>>>>>>>    //   Call the driver's browse connect function
76027>>>>>>>>>>>>>    Function BrowseConnect String sInConnStr Returns String
76029>>>>>>>>>>>>>        String  sDriver
76029>>>>>>>>>>>>>        String  sOutConnStr
76029>>>>>>>>>>>>>        Integer iArg
76029>>>>>>>>>>>>>        Integer iRetval
76029>>>>>>>>>>>>>        
76029>>>>>>>>>>>>>        Get psDriverID to sDriver
76030>>>>>>>>>>>>>        If (sDriver <> "") Begin
76032>>>>>>>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
76033>>>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
76038>>>>>>>>>>>>>        End
76038>>>>>>>>>>>>>>
76038>>>>>>>>>>>>>        
76038>>>>>>>>>>>>>        Function_Return sOutConnStr
76039>>>>>>>>>>>>>    End_Function// BrowseConnect
76040>>>>>>>>>>>>>    
76040>>>>>>>>>>>>>    
76040>>>>>>>>>>>>>    Function BrowseConnectLocal String sInConnStr Returns String
76042>>>>>>>>>>>>>        String  sDriver
76042>>>>>>>>>>>>>        String  sOutConnStr
76042>>>>>>>>>>>>>        Integer iArg
76042>>>>>>>>>>>>>        Integer iRetval
76042>>>>>>>>>>>>>        
76042>>>>>>>>>>>>>        Move 1 to iArg // Browses only local
76043>>>>>>>>>>>>>        
76043>>>>>>>>>>>>>        Get psDriverID to sDriver
76044>>>>>>>>>>>>>        If (sDriver <> "") Begin
76046>>>>>>>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
76047>>>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
76052>>>>>>>>>>>>>        End
76052>>>>>>>>>>>>>>
76052>>>>>>>>>>>>>        
76052>>>>>>>>>>>>>        Function_Return sOutConnStr
76053>>>>>>>>>>>>>    End_Function// BrowseConnect
76054>>>>>>>>>>>>>    
76054>>>>>>>>>>>>>    
76054>>>>>>>>>>>>>    Function EnumerateServersNetworkOrLocal Integer iNetworkLocal  Returns Integer
76056>>>>>>>>>>>>>        String  sServerList
76056>>>>>>>>>>>>>        Integer iNumServers
76056>>>>>>>>>>>>>        Integer iDriver
76056>>>>>>>>>>>>>        Integer iClientVersion
76056>>>>>>>>>>>>>        String  sDriver
76056>>>>>>>>>>>>>        
76056>>>>>>>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriver
76057>>>>>>>>>>>>>        
76057>>>>>>>>>>>>>        If (iDriver) Begin
76059>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
76062>>>>>>>>>>>>>            
76062>>>>>>>>>>>>>            Get SqlServerClientDriverName iClientVersion to sDriver
76063>>>>>>>>>>>>>            
76063>>>>>>>>>>>>>            Move ("DRIVER={" + sDriver + "};") to sDriver
76064>>>>>>>>>>>>>            If (iNetworkLocal = 0) Begin
76066>>>>>>>>>>>>>                Get BrowseConnect sDriver to sServerList
76067>>>>>>>>>>>>>            End
76067>>>>>>>>>>>>>>
76067>>>>>>>>>>>>>            Else Begin
76068>>>>>>>>>>>>>                Get BrowseConnectLocal sDriver to sServerList
76069>>>>>>>>>>>>>            End
76069>>>>>>>>>>>>>>
76069>>>>>>>>>>>>>            Get ExtractList sServerList Current_object to iNumServers
76070>>>>>>>>>>>>>        End
76070>>>>>>>>>>>>>>
76070>>>>>>>>>>>>>        
76070>>>>>>>>>>>>>        Function_Return iNumServers
76071>>>>>>>>>>>>>    End_Function
76072>>>>>>>>>>>>>    
76072>>>>>>>>>>>>>    //   Enumerate the available SQL Server database servers
76072>>>>>>>>>>>>>    //   This function will return all SQL Server instances on the network.
76072>>>>>>>>>>>>>    //   This may take a long time.
76072>>>>>>>>>>>>>    //   To enumerate only local SQL Server instances use EnumerateServersLocal
76072>>>>>>>>>>>>>    Function EnumerateServers Returns Integer
76074>>>>>>>>>>>>>        Integer iNumServers
76074>>>>>>>>>>>>>        Integer iNetworkLocal
76074>>>>>>>>>>>>>        
76074>>>>>>>>>>>>>        Move 0 to iNetworkLocal // 0 = enumerate network servers
76075>>>>>>>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
76076>>>>>>>>>>>>>
76076>>>>>>>>>>>>>        Function_Return iNumServers
76077>>>>>>>>>>>>>    End_Function
76078>>>>>>>>>>>>>    
76078>>>>>>>>>>>>>    //   Enumerate the available SQL Server database servers
76078>>>>>>>>>>>>>    //   This function will return only return SQL Server instance on the local machine
76078>>>>>>>>>>>>>    //   To enumerate all SQL Server instances in a network use EnumerateServers
76078>>>>>>>>>>>>>    Function EnumerateServersLocal Returns Integer
76080>>>>>>>>>>>>>        Integer iNumServers
76080>>>>>>>>>>>>>        Integer iNetworkLocal
76080>>>>>>>>>>>>>        
76080>>>>>>>>>>>>>        Move 1 to iNetworkLocal // 1 = enumerate local servers
76081>>>>>>>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
76082>>>>>>>>>>>>>        
76082>>>>>>>>>>>>>        Function_Return iNumServers
76083>>>>>>>>>>>>>    End_Function
76084>>>>>>>>>>>>>    
76084>>>>>>>>>>>>>    //   Enumerate database in a given server.
76084>>>>>>>>>>>>>    Function EnumerateDatabases String sServer String sUser String sPassWord Returns Integer
76086>>>>>>>>>>>>>        Integer hoSQL
76086>>>>>>>>>>>>>        String  sConnect
76086>>>>>>>>>>>>>        String  sDatabase
76086>>>>>>>>>>>>>        Integer hdbc
76086>>>>>>>>>>>>>        Integer hstmt
76086>>>>>>>>>>>>>        Integer iFetchResult iDriver iClientVersion
76086>>>>>>>>>>>>>        
76086>>>>>>>>>>>>>        If (Num_Arguments < 3) ;            Move "" to sPassWord
76089>>>>>>>>>>>>>        If (Num_Arguments < 2) ;            Move "" to sUser
76092>>>>>>>>>>>>>        
76092>>>>>>>>>>>>>        If (sUser <> "") ;            Move ("SERVER=" + Trim(sServer) + ";UID=" + Trim(sUser) + ";PWD=" + Trim(sPassword) + ";") to sConnect
76095>>>>>>>>>>>>>        Else ;            Move ("SERVER=" + Trim(sServer) + ";Trusted_Connection=yes") to sConnect
76097>>>>>>>>>>>>>
76097>>>>>>>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriver
76098>>>>>>>>>>>>>        Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
76101>>>>>>>>>>>>>        If (iClientVersion >= 18) Begin
76103>>>>>>>>>>>>>            Append sConnect ";Encrypt=Optional;TrustServerCertificate=Yes"
76104>>>>>>>>>>>>>            Move (Replaces(" ", sConnect, "")) to sConnect
76105>>>>>>>>>>>>>        End
76105>>>>>>>>>>>>>>
76105>>>>>>>>>>>>>        
76105>>>>>>>>>>>>>        Object oEnumDBSQLmanager is a cSQLHandleManager
76107>>>>>>>>>>>>>            Move Current_Object to hoSQL
76108>>>>>>>>>>>>>        End_Object
76109>>>>>>>>>>>>>        
76109>>>>>>>>>>>>>        If (hoSQL <> 0) Begin
76111>>>>>>>>>>>>>            Get SQLConnect of hoSQL "MSSQLDRV" sConnect to hdbc
76112>>>>>>>>>>>>>            If (hdbc <> 0) Begin
76114>>>>>>>>>>>>>                Get SQLOpen of hdbc to hstmt
76115>>>>>>>>>>>>>                If (hstmt <> 0) Begin
76117>>>>>>>>>>>>>                    //   We could do a direct select on the sysdatabases table but we use
76117>>>>>>>>>>>>>                    //   the stored procedure sp_database instead. SQL Server recommends this
76117>>>>>>>>>>>>>                    //   approach in case meta data might change, the stored procedure will
76117>>>>>>>>>>>>>                    //   stay the same.
76117>>>>>>>>>>>>>                    Send SQLSetProcedureName to hstmt "sp_databases"
76118>>>>>>>>>>>>>                    Send SQLCall to hstmt
76119>>>>>>>>>>>>>                    Repeat
76119>>>>>>>>>>>>>>
76119>>>>>>>>>>>>>                        Get SQLFetch of hstmt to iFetchResult
76120>>>>>>>>>>>>>                        If (iFetchResult <> 0) Begin
76122>>>>>>>>>>>>>                            Get SQLColumnValue of hstmt 1 to sDatabase
76123>>>>>>>>>>>>>                            Set Value  (Item_Count(Current_Object)) to sDatabase
76124>>>>>>>>>>>>>                        End
76124>>>>>>>>>>>>>>
76124>>>>>>>>>>>>>                    Until (iFetchResult = 0)
76126>>>>>>>>>>>>>                    
76126>>>>>>>>>>>>>                    Send SQLClose to hstmt
76127>>>>>>>>>>>>>                End
76127>>>>>>>>>>>>>>
76127>>>>>>>>>>>>>                Send SQLDisconnect to hdbc
76128>>>>>>>>>>>>>            End
76128>>>>>>>>>>>>>>
76128>>>>>>>>>>>>>        End
76128>>>>>>>>>>>>>>
76128>>>>>>>>>>>>>        Send Destroy_Object to hoSQL
76129>>>>>>>>>>>>>        
76129>>>>>>>>>>>>>        Function_Return (Item_Count(Current_Object))
76130>>>>>>>>>>>>>    End_Function
76131>>>>>>>>>>>>>    
76131>>>>>>>>>>>>>    Function SqlServerClientVersionName Integer iClientVersion  Returns String
76133>>>>>>>>>>>>>        String  sSqlServerClientVersionName
76133>>>>>>>>>>>>>        
76133>>>>>>>>>>>>>        Case Begin
76133>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2019CLIENT)
76135>>>>>>>>>>>>>                Move SQLSERVER2019CLIENTNAME to sSqlServerClientVersionName
76136>>>>>>>>>>>>>                Case Break
76137>>>>>>>>>>>>>            
76137>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
76140>>>>>>>>>>>>>                Move SQLSERVER2017CLIENTNAME to sSqlServerClientVersionName
76141>>>>>>>>>>>>>                Case Break
76142>>>>>>>>>>>>>                
76142>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
76145>>>>>>>>>>>>>                Move SQLSERVER2016CLIENTNAME to sSqlServerClientVersionName
76146>>>>>>>>>>>>>                Case Break
76147>>>>>>>>>>>>>            
76147>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
76150>>>>>>>>>>>>>                Move SQLSERVER2014CLIENTNAME to sSqlServerClientVersionName
76151>>>>>>>>>>>>>                Case Break
76152>>>>>>>>>>>>>            
76152>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
76155>>>>>>>>>>>>>                Move SQLSERVER2012CLIENTNAME to sSqlServerClientVersionName
76156>>>>>>>>>>>>>                Case Break
76157>>>>>>>>>>>>>            
76157>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
76160>>>>>>>>>>>>>                Move SQLSERVER2008CLIENTNAME to sSqlServerClientVersionName
76161>>>>>>>>>>>>>                Case Break
76162>>>>>>>>>>>>>            
76162>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
76165>>>>>>>>>>>>>                Move SQLSERVER2005CLIENTNAME to sSqlServerClientVersionName
76166>>>>>>>>>>>>>                Case Break
76167>>>>>>>>>>>>>            
76167>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
76170>>>>>>>>>>>>>                Move SQLSERVER2000CLIENTNAME to sSqlServerClientVersionName
76171>>>>>>>>>>>>>                Case Break
76172>>>>>>>>>>>>>            
76172>>>>>>>>>>>>>            Case Else
76172>>>>>>>>>>>>>                Move (SFormat("%1 (version %2) ",SQLSERVERUNKNOWNCLIENTNAME,iClientVersion)) to sSqlServerClientVersionName
76173>>>>>>>>>>>>>        Case End
76173>>>>>>>>>>>>>        
76173>>>>>>>>>>>>>        Function_Return sSqlServerClientVersionName
76174>>>>>>>>>>>>>    End_Function
76175>>>>>>>>>>>>>
76175>>>>>>>>>>>>>    Function SqlServerClientDriverName Integer iClientVersion  Returns String
76177>>>>>>>>>>>>>        String  sSqlServerClientDriverName
76177>>>>>>>>>>>>>        
76177>>>>>>>>>>>>>        Case Begin
76177>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2019CLIENT)
76179>>>>>>>>>>>>>                Move SQLSERVER2019DRVRSTR to sSqlServerClientDriverName
76180>>>>>>>>>>>>>                Case Break
76181>>>>>>>>>>>>>
76181>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
76184>>>>>>>>>>>>>                Move SQLSERVER2017DRVRSTR to sSqlServerClientDriverName
76185>>>>>>>>>>>>>                Case Break
76186>>>>>>>>>>>>>                
76186>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
76189>>>>>>>>>>>>>                Move SQLSERVER2016DRVRSTR to sSqlServerClientDriverName
76190>>>>>>>>>>>>>                Case Break
76191>>>>>>>>>>>>>            
76191>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
76194>>>>>>>>>>>>>                Move SQLSERVER2014DRVRSTR to sSqlServerClientDriverName
76195>>>>>>>>>>>>>                Case Break
76196>>>>>>>>>>>>>            
76196>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
76199>>>>>>>>>>>>>                Move SQLSERVER2012DRVRSTR to sSqlServerClientDriverName
76200>>>>>>>>>>>>>                Case Break
76201>>>>>>>>>>>>>            
76201>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
76204>>>>>>>>>>>>>                Move SQLSERVER2008DRVRSTR to sSqlServerClientDriverName
76205>>>>>>>>>>>>>                Case Break
76206>>>>>>>>>>>>>            
76206>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
76209>>>>>>>>>>>>>                Move SQLSERVER2005DRVRSTR to sSqlServerClientDriverName
76210>>>>>>>>>>>>>                Case Break
76211>>>>>>>>>>>>>            
76211>>>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
76214>>>>>>>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
76215>>>>>>>>>>>>>                Case Break
76216>>>>>>>>>>>>>            
76216>>>>>>>>>>>>>            Case Else
76216>>>>>>>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
76217>>>>>>>>>>>>>        Case End
76217>>>>>>>>>>>>>        
76217>>>>>>>>>>>>>        Function_Return sSqlServerClientDriverName
76218>>>>>>>>>>>>>    End_Function
76219>>>>>>>>>>>>>    
76219>>>>>>>>>>>>>End_Class
76220>>>>>>>>>>>Use db2_drv.pkg
Including file: db2_drv.pkg    (C:\Program Files\DataFlex 24.0\Pkg\db2_drv.pkg)
76220>>>>>>>>>>>>>// DB2_DRV.PKG                                                          
76220>>>>>>>>>>>>>//   Package that declares DB2 driver constants and functions.          
76220>>>>>>>>>>>>>//   This package can be used by developers who want to add DB2 driver  
76220>>>>>>>>>>>>>//   specific code to a DataFlex application.                           
76220>>>>>>>>>>>>>
76220>>>>>>>>>>>>>Use Cli.pkg
76220>>>>>>>>>>>>>
76220>>>>>>>>>>>>>// Driver attributes
76220>>>>>>>>>>>>>
76220>>>>>>>>>>>>>
76220>>>>>>>>>>>>>// Driver Indentification
76220>>>>>>>>>>>>>
76220>>>>>>>>>>>>>// Error number constants
76220>>>>>>>>>>>>>
76220>>>>>>>>>>>>>// Call driver function identifiers
76220>>>>>>>>>>>>>
76220>>>>>>>>>>>>>// DB2 specific data types
76220>>>>>>>>>>>>>Define SQL_CLOB           for   (-99)
76220>>>>>>>>>>>>>Define SQL_BLOB           for   (-98)
76220>>>>>>>>>>>>>Define SQL_XML            for   (-370)
76220>>>>>>>>>>>>>// DB2 Graphic types are Unicode types
76220>>>>>>>>>>>>>Define SQL_GRAPHIC        for   (-95)
76220>>>>>>>>>>>>>Define SQL_VARGRAPHIC     for   (-96)
76220>>>>>>>>>>>>>Define SQL_LONGVARGRAPHIC for   (-97)
76220>>>>>>>>>>>>>Define SQL_DBCLOB         for   (-350)
76220>>>>>>>>>>>>>
76220>>>>>>>>>>>>>
76220>>>>>>>>>>>>>// Extra DB2 commands
76220>>>>>>>>>>>>>
76220>>>>>>>>>>>>>
76220>>>>>>>>>>>>>// DB2_SetConstraint <FileNum> <ConstraintText>                         
76220>>>>>>>>>>>>>//   Setup a constraint for a file.                                     
76220>>>>>>>>>>>>>
76220>>>>>>>>>>>>>
76220>>>>>>>>>>>>>
76220>>>>>>>>>>>>>Class cDB2Handler is a cCLIHandler
76221>>>>>>>>>>>>>    
76221>>>>>>>>>>>>>    Procedure Construct_Object
76223>>>>>>>>>>>>>        Forward Send Construct_Object
76225>>>>>>>>>>>>>        
76225>>>>>>>>>>>>>        Set psDriverID to DB2_DRV_ID
76226>>>>>>>>>>>>>    End_Procedure
76227>>>>>>>>>>>>>    
76227>>>>>>>>>>>>>    
76227>>>>>>>>>>>>>    
76227>>>>>>>>>>>>>    // Reset the datasource list to the beginning
76227>>>>>>>>>>>>>    Procedure SeedDataSources
76229>>>>>>>>>>>>>        String  sDriver
76229>>>>>>>>>>>>>        String  sVoid
76229>>>>>>>>>>>>>        Integer iRetval
76229>>>>>>>>>>>>>        
76229>>>>>>>>>>>>>        Get psDriverID to sDriver
76230>>>>>>>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid SQL_FETCH_ALL Result iRetval
76237>>>>>>>>>>>>>    End_Procedure
76238>>>>>>>>>>>>>    
76238>>>>>>>>>>>>>    
76238>>>>>>>>>>>>>    
76238>>>>>>>>>>>>>    // Call the driver's data sources function
76238>>>>>>>>>>>>>    Function DataSources Returns String
76240>>>>>>>>>>>>>        String  sDriver
76240>>>>>>>>>>>>>        String  sDataSource
76240>>>>>>>>>>>>>        String  sDescription
76240>>>>>>>>>>>>>        Integer iLength
76240>>>>>>>>>>>>>        Integer iRetval
76240>>>>>>>>>>>>>        
76240>>>>>>>>>>>>>        Get psDriverID to sDriver
76241>>>>>>>>>>>>>        If (sDriver <> "") Begin
76243>>>>>>>>>>>>>            Move 8192 to iLength
76244>>>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDataSource
76245>>>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDescription
76246>>>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
76251>>>>>>>>>>>>>        End
76251>>>>>>>>>>>>>>
76251>>>>>>>>>>>>>        
76251>>>>>>>>>>>>>        If (sDataSource <> "" or sDescription <> "") ;            Function_Return (sDataSource - (If(sDescription <> "", "," *  sDescription, "")))
76254>>>>>>>>>>>>>        Else ;            Function_Return ""
76256>>>>>>>>>>>>>    End_Function
76257>>>>>>>>>>>>>    
76257>>>>>>>>>>>>>End_Class
76258>>>>>>>>>>>Use odbc_drv.pkg
Including file: odbc_drv.pkg    (C:\Program Files\DataFlex 24.0\Pkg\odbc_drv.pkg)
76258>>>>>>>>>>>>>//   Package that declares ODBC driver constants and functions.         
76258>>>>>>>>>>>>>//   This package can be used by developers who want to add Data Access 
76258>>>>>>>>>>>>>//   ODBC Client specific code to a DataFlex application.               
76258>>>>>>>>>>>>>
76258>>>>>>>>>>>>>Use Cli.pkg
76258>>>>>>>>>>>>>
76258>>>>>>>>>>>>>// Driver Indentification
76258>>>>>>>>>>>>>
76258>>>>>>>>>>>>>// Error number constants
76258>>>>>>>>>>>>>
76258>>>>>>>>>>>>>// Call driver function identifiers
76258>>>>>>>>>>>>>
76258>>>>>>>>>>>>>Class cODBCHandler is a cCLIHandler
76259>>>>>>>>>>>>>    
76259>>>>>>>>>>>>>    Procedure Construct_Object
76261>>>>>>>>>>>>>        Forward Send Construct_Object
76263>>>>>>>>>>>>>        
76263>>>>>>>>>>>>>        Set psDriverID to ODBC_DRV_ID
76264>>>>>>>>>>>>>    End_Procedure
76265>>>>>>>>>>>>>    
76265>>>>>>>>>>>>>    
76265>>>>>>>>>>>>>    
76265>>>>>>>>>>>>>    // Setup the type of data sources returned by the datasources function
76265>>>>>>>>>>>>>    Procedure Set DataSourceType Integer iNewType
76267>>>>>>>>>>>>>        String  sDriver
76267>>>>>>>>>>>>>        String  sVoid
76267>>>>>>>>>>>>>        Integer iRetval
76267>>>>>>>>>>>>>        
76267>>>>>>>>>>>>>        Get psDriverID to sDriver
76268>>>>>>>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid iNewType Result iRetval
76275>>>>>>>>>>>>>    End_Procedure
76276>>>>>>>>>>>>>    
76276>>>>>>>>>>>>>    
76276>>>>>>>>>>>>>    // Call the driver's data sources function
76276>>>>>>>>>>>>>    Function DataSources Returns String
76278>>>>>>>>>>>>>        String  sDriver
76278>>>>>>>>>>>>>        String  sDataSource
76278>>>>>>>>>>>>>        String  sDescription
76278>>>>>>>>>>>>>        Integer iLength
76278>>>>>>>>>>>>>        Integer iRetval
76278>>>>>>>>>>>>>        
76278>>>>>>>>>>>>>        Get psDriverID to sDriver
76279>>>>>>>>>>>>>        If (sDriver <> "") Begin
76281>>>>>>>>>>>>>            Move 8192 to iLength
76282>>>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDataSource
76283>>>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDescription
76284>>>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
76289>>>>>>>>>>>>>        End
76289>>>>>>>>>>>>>>
76289>>>>>>>>>>>>>        
76289>>>>>>>>>>>>>        If (sDataSource <> "" or sDescription <> "") ;            Function_Return (sDataSource - (If(sDescription <> "", "," * sDescription, "")))
76292>>>>>>>>>>>>>        Else ;            Function_Return ""
76294>>>>>>>>>>>>>    End_Function
76295>>>>>>>>>>>>>    
76295>>>>>>>>>>>>>End_Class
76296>>>>>>>>>>>>>
76296>>>>>>>>>>>Use DFBTRDRV.PKG
Including file: DFBTRDRV.PKG    (C:\Program Files\DataFlex 24.0\Pkg\DFBTRDRV.PKG)
76296>>>>>>>>>>>>>// $File title : Package for the DataFlex Connectivity Kit for Pervasive.SQL
76296>>>>>>>>>>>>>// Notice      : This package contains constants and commands, used to call
76296>>>>>>>>>>>>>//               specific functions in the DFBTRDRV.
76296>>>>>>>>>>>>>Use Ui
76296>>>>>>>>>>>>>//
76296>>>>>>>>>>>>>// Driver Indentification
76296>>>>>>>>>>>>>//
76296>>>>>>>>>>>>>
76296>>>>>>>>>>>>>// Driver attributes
76296>>>>>>>>>>>>>//
76296>>>>>>>>>>>>>// Call_Driver functions ID's
76296>>>>>>>>>>>>>//
76296>>>>>>>>>>>>>//
76296>>>>>>>>>>>>>// DFBTRFN_CONVERT_FILE options
76296>>>>>>>>>>>>>//
76296>>>>>>>>>>>>>
76296>>>>>>>>>>>>>//
76296>>>>>>>>>>>>>// DFBTRFN_SET_OWNER options
76296>>>>>>>>>>>>>//
76296>>>>>>>>>>>>>
76296>>>>>>>>>>>>>//
76296>>>>>>>>>>>>>// DFBTRFN_SET_TRANSACTION_TYPE options
76296>>>>>>>>>>>>>//
76296>>>>>>>>>>>>>
76296>>>>>>>>>>>>>
76296>>>>>>>>>>>>>//
76296>>>>>>>>>>>>>// Command to create all vars which may be needed
76296>>>>>>>>>>>>>// in other commands.
76296>>>>>>>>>>>>>//
76296>>>>>>>>>>>>>
76296>>>>>>>>>>>>>
76296>>>>>>>>>>>>>
76296>>>>>>>>>>>>>//
76296>>>>>>>>>>>>>// Command to set the owner of a Btrieve file.
76296>>>>>>>>>>>>>// File must have been opened.
76296>>>>>>>>>>>>>// Filenumber needs to be passed.
76296>>>>>>>>>>>>>// To clear set the owner to "".
76296>>>>>>>>>>>>>// Examples:
76296>>>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret"
76296>>>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY CALLBACK MyCallBack
76296>>>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" ENCRYPT
76296>>>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY ENCRYPT CALLBACK MyCallBack
76296>>>>>>>>>>>>>// To clear:
76296>>>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to ""
76296>>>>>>>>>>>>>//
76296>>>>>>>>>>>>>
76296>>>>>>>>>>>>>
76296>>>>>>>>>>>>>
76296>>>>>>>>>>>>>//
76296>>>>>>>>>>>>>// Command to parse DFBTR_SET_OWNVER
76296>>>>>>>>>>>>>// options.
76296>>>>>>>>>>>>>//
76296>>>>>>>>>>>>>
76296>>>>>>>>>>>>>
76296>>>>>>>>>>>>>
76296>>>>>>>>>>>>>//
76296>>>>>>>>>>>>>// Command to parse for Callback
76296>>>>>>>>>>>>>//
76296>>>>>>>>>>>>>
76296>>>>>>>>>>>>>
76296>>>>>>>>>>>>>
76296>>>>>>>>>>>>>//
76296>>>>>>>>>>>>>// Command to clear the owner of a Btrieve file.
76296>>>>>>>>>>>>>// File must have been opened.
76296>>>>>>>>>>>>>// Filenumber needs to be passed.
76296>>>>>>>>>>>>>// Examples:
76296>>>>>>>>>>>>>//      DFBTR_CLEAR_OWNER MyFileNumber
76296>>>>>>>>>>>>>//
76296>>>>>>>>>>>>>
76296>>>>>>>>>>>>>
76296>>>>>>>>>>>>>
76296>>>>>>>>>>>>>//
76296>>>>>>>>>>>>>// Command to add a owner name to the internal list of ownernames
76296>>>>>>>>>>>>>// which will be tries when opening files.
76296>>>>>>>>>>>>>//
76296>>>>>>>>>>>>>
76296>>>>>>>>>>>>>
76296>>>>>>>>>>>>>
76296>>>>>>>>>>>>>//
76296>>>>>>>>>>>>>// Command to remove all owners from the internal list of ownernames
76296>>>>>>>>>>>>>//
76296>>>>>>>>>>>>>
76296>>>>>>>>>>>>>
76296>>>>>>>>>>>>>//
76296>>>>>>>>>>>>>// Command to set the owner name to be used when opening the DDF files.
76296>>>>>>>>>>>>>// The DDF owner is required when Pervasive.SQL security is turned on.
76296>>>>>>>>>>>>>// The DDF owner is equal to the password of the Master user in Pervasive.SQL
76296>>>>>>>>>>>>>// This command overwrites the DDF_OWNER setting in DFBTRDRV.INT
76296>>>>>>>>>>>>>//
76296>>>>>>>>>>>>>
76296>>>>>>>>>>>>>//
76296>>>>>>>>>>>>>// Command to change the transaction type.
76296>>>>>>>>>>>>>// Valid types are:
76296>>>>>>>>>>>>>//     DFBTRTT_NONE
76296>>>>>>>>>>>>>//     DFBTRTT_EXCLUSIVE
76296>>>>>>>>>>>>>//     DFBTRTT_CONCURRENT
76296>>>>>>>>>>>>>//
76296>>>>>>>>>>>>>//
76296>>>>>>>>>>>>>
76296>>>>>>>>>>>>>
76296>>>>>>>>>>>>>
76296>>>>>>>>>>>>>//
76296>>>>>>>>>>>>>// Command to get the current transaction type.
76296>>>>>>>>>>>>>//
76296>>>>>>>>>>>>>
76296>>>>>>>>>>>>>//
76296>>>>>>>>>>>>>// Command to set explicit_locking
76296>>>>>>>>>>>>>//
76296>>>>>>>>>>>>>
76296>>>>>>>>>>>>>//
76296>>>>>>>>>>>>>// Command to get explicit locking
76296>>>>>>>>>>>>>//
76296>>>>>>>>>>>>>
76296>>>>>>>>>>>>>//
76296>>>>>>>>>>>>>// Command to set detection for incompatible positive signs in numeric fields
76296>>>>>>>>>>>>>//
76296>>>>>>>>>>>>>
76296>>>>>>>>>>>>>//
76296>>>>>>>>>>>>>// Command to get detection for incompatible positive signs in numeric fields
76296>>>>>>>>>>>>>//
76296>>>>>>>>>>>>>
76296>>>>>>>>>>>>>// Purpose: An instance of this class can be used as a broker object to
76296>>>>>>>>>>>>>//          call several Dfbtrdrv releated methods.
76296>>>>>>>>>>>>>
76296>>>>>>>>>>>>>Class cDFBtrDrvHandler is an Array
76297>>>>>>>>>>>>>    
76297>>>>>>>>>>>>>    Procedure Construct_Object Integer iImage
76299>>>>>>>>>>>>>        Forward Send Construct_object iImage
76301>>>>>>>>>>>>>        
76301>>>>>>>>>>>>>        Property String  psDriverID "DFBTRDRV"
76302>>>>>>>>>>>>>    End_Procedure
76303>>>>>>>>>>>>>    
76303>>>>>>>>>>>>>    //  The revsion of a Dfbtrdrv Connectivity Kit
76303>>>>>>>>>>>>>    //
76303>>>>>>>>>>>>>    
76303>>>>>>>>>>>>>    Function CKRevision Returns String
76305>>>>>>>>>>>>>        String  sDriverID
76305>>>>>>>>>>>>>        String  sRevision
76305>>>>>>>>>>>>>        String  sVoid
76305>>>>>>>>>>>>>        Integer iRetval
76305>>>>>>>>>>>>>        
76305>>>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
76305>>>>>>>>>>>>>        // This error would otherwise be raised when we have an older
76305>>>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
76305>>>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
76306>>>>>>>>>>>>>        Get psDriverID to sDriverID
76307>>>>>>>>>>>>>        Move (Repeat(" ", 255)) to sRevision
76308>>>>>>>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
76313>>>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
76314>>>>>>>>>>>>>        If (Trim(sRevision) = "") Begin
76316>>>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
76316>>>>>>>>>>>>>            Move "0.0.0.0" to sRevision
76317>>>>>>>>>>>>>        End
76317>>>>>>>>>>>>>>
76317>>>>>>>>>>>>>        Function_Return sRevision
76318>>>>>>>>>>>>>    End_Function
76319>>>>>>>>>>>>>    
76319>>>>>>>>>>>>>    Function CkUsesUri Returns Integer
76321>>>>>>>>>>>>>        String  sDriverID
76321>>>>>>>>>>>>>        String  sVoid1
76321>>>>>>>>>>>>>        String  sVoid2
76321>>>>>>>>>>>>>        Integer iRetval
76321>>>>>>>>>>>>>        
76321>>>>>>>>>>>>>        Get psDriverID to sDriverID
76322>>>>>>>>>>>>>        
76322>>>>>>>>>>>>>        Move 0 to iRetval
76323>>>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
76323>>>>>>>>>>>>>        // This error would otherwise be raised when we have an older
76323>>>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKUSESURI function
76323>>>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
76324>>>>>>>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKUSESURI Callback 0 Passing sVoid1 sVoid2 0 Result iRetval
76329>>>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
76330>>>>>>>>>>>>>        
76330>>>>>>>>>>>>>        Function_Return iRetval
76331>>>>>>>>>>>>>    End_Function
76332>>>>>>>>>>>>>    
76332>>>>>>>>>>>>>    
76332>>>>>>>>>>>>>    
76332>>>>>>>>>>>>>    // Extract the Nth part of a a.b.c.d revsion string.
76332>>>>>>>>>>>>>    //
76332>>>>>>>>>>>>>    // Returns : The part version number or -1 if there is no such part number.
76332>>>>>>>>>>>>>    //
76332>>>>>>>>>>>>>    
76332>>>>>>>>>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
76334>>>>>>>>>>>>>        Integer iPartRev
76334>>>>>>>>>>>>>        Integer iCurrentPart
76334>>>>>>>>>>>>>        Integer iSeparatorPos
76334>>>>>>>>>>>>>        
76334>>>>>>>>>>>>>        If (iPartNum > 4) ;            Function_Return -1
76337>>>>>>>>>>>>>        
76337>>>>>>>>>>>>>        Move 0 to iCurrentPart
76338>>>>>>>>>>>>>        Repeat
76338>>>>>>>>>>>>>>
76338>>>>>>>>>>>>>            Move (Pos(".", sRevision)) to iSeparatorPos
76339>>>>>>>>>>>>>            If (iSeparatorPos > 0) Begin
76341>>>>>>>>>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) to iPartRev
76342>>>>>>>>>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) to sRevision
76343>>>>>>>>>>>>>                Increment iCurrentPart
76344>>>>>>>>>>>>>            End
76344>>>>>>>>>>>>>>
76344>>>>>>>>>>>>>            Else If (sRevision <> "") Begin
76347>>>>>>>>>>>>>                Move sRevision to iPartRev
76348>>>>>>>>>>>>>                Move "" to sRevision
76349>>>>>>>>>>>>>                Increment iCurrentPart
76350>>>>>>>>>>>>>            End
76350>>>>>>>>>>>>>>
76350>>>>>>>>>>>>>            Else ;                Move -1 to iPartRev
76352>>>>>>>>>>>>>        Until (iCurrentPart >= iPartNum or iPartRev = -1)
76354>>>>>>>>>>>>>        
76354>>>>>>>>>>>>>        Function_Return iPartRev
76355>>>>>>>>>>>>>    End_Function
76356>>>>>>>>>>>>>    
76356>>>>>>>>>>>>>    
76356>>>>>>>>>>>>>    
76356>>>>>>>>>>>>>    //
76356>>>>>>>>>>>>>    //  Returns the major revision of the CK
76356>>>>>>>>>>>>>    //
76356>>>>>>>>>>>>>    
76356>>>>>>>>>>>>>    Function CKMajorRevision Returns Integer
76358>>>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 1, CKRevision(Current_Object)))
76359>>>>>>>>>>>>>    End_Function
76360>>>>>>>>>>>>>    
76360>>>>>>>>>>>>>    
76360>>>>>>>>>>>>>    
76360>>>>>>>>>>>>>    //  Returns the minor revision of the CK
76360>>>>>>>>>>>>>    //
76360>>>>>>>>>>>>>    
76360>>>>>>>>>>>>>    Function CKMinorRevision Returns Integer
76362>>>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 2, CKRevision(Current_Object)))
76363>>>>>>>>>>>>>    End_Function
76364>>>>>>>>>>>>>    
76364>>>>>>>>>>>>>    
76364>>>>>>>>>>>>>    //  Returns the release revision of the CK
76364>>>>>>>>>>>>>    //
76364>>>>>>>>>>>>>    
76364>>>>>>>>>>>>>    Function CKReleaseRevision Returns Integer
76366>>>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 3, CKRevision(Current_Object)))
76367>>>>>>>>>>>>>    End_Function
76368>>>>>>>>>>>>>    
76368>>>>>>>>>>>>>    
76368>>>>>>>>>>>>>    //  Returns the major revision of the CK
76368>>>>>>>>>>>>>    //
76368>>>>>>>>>>>>>    
76368>>>>>>>>>>>>>    Function CKBuildRevision Returns Integer
76370>>>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 4, CKRevision(Current_Object)))
76371>>>>>>>>>>>>>    End_Function
76372>>>>>>>>>>>>>    
76372>>>>>>>>>>>>>    
76372>>>>>>>>>>>>>    //  Determines if the CK conforms to a passed minimal revsion.
76372>>>>>>>>>>>>>    //
76372>>>>>>>>>>>>>    
76372>>>>>>>>>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
76374>>>>>>>>>>>>>        If (iMajor < CKMajorRevision(Current_object)) ;            Function_Return (True)
76377>>>>>>>>>>>>>        Else If (iMajor = CKMajorRevision(Current_object)) Begin
76380>>>>>>>>>>>>>            If (iMinor < CKMinorRevision(Current_object)) ;                Function_Return (True)
76383>>>>>>>>>>>>>            Else If (iMinor = CKMinorRevision(Current_object)) Begin
76386>>>>>>>>>>>>>                If (iRelease < CKReleaseRevision(Current_object)) ;                    Function_Return (True)
76389>>>>>>>>>>>>>                Else If (iRelease = CKReleaseRevision(Current_object) and iBuild <= CKBuildRevision(Current_object)) ;                    Function_Return (True)
76393>>>>>>>>>>>>>            End
76393>>>>>>>>>>>>>>
76393>>>>>>>>>>>>>        End
76393>>>>>>>>>>>>>>
76393>>>>>>>>>>>>>        
76393>>>>>>>>>>>>>        Function_Return (False)
76394>>>>>>>>>>>>>    End_Function
76395>>>>>>>>>>>>>    
76395>>>>>>>>>>>>>    //   Functions to query the Pervasive.SQL version:
76395>>>>>>>>>>>>>    //       PSQLRequesterVersionInfo    Integer iFileNum Returns String
76395>>>>>>>>>>>>>    //       PSQLLocalEngineVersionInfo  Integer iFileNum Returns String
76395>>>>>>>>>>>>>    //       PSQLServerEngineVersionInfo Integer iFileNum Returns String
76395>>>>>>>>>>>>>    //
76395>>>>>>>>>>>>>    //   All 3 functions return the version of a Pervasive.SQL component
76395>>>>>>>>>>>>>    //   in the following format:
76395>>>>>>>>>>>>>    //       <version>.<revision>.<type>
76395>>>>>>>>>>>>>    //   possible values for <type>:
76395>>>>>>>>>>>>>    //       9 for 32-bit Windows workstation/workgroup engine or Linux
76395>>>>>>>>>>>>>    //         server using Workgroup authentication mode
76395>>>>>>>>>>>>>    //       C for client cache engine
76395>>>>>>>>>>>>>    //       D for DOS workstation
76395>>>>>>>>>>>>>    //       N for client Requester
76395>>>>>>>>>>>>>    //       S for NetWare server
76395>>>>>>>>>>>>>    //       T for 32-bit Windows server engine
76395>>>>>>>>>>>>>    //       U for Linux server using PAM or BTPASSWD authentication
76395>>>>>>>>>>>>>    //
76395>>>>>>>>>>>>>    //   example:
76395>>>>>>>>>>>>>    //       8.50.T
76395>>>>>>>>>>>>>    //   will be returned for a Pervasive.SQL 8.5 Server Engine running on
76395>>>>>>>>>>>>>    //   32-bits Windows server.
76395>>>>>>>>>>>>>    //
76395>>>>>>>>>>>>>    //   The FileNumber parameter must specify an opened table or 0.
76395>>>>>>>>>>>>>    //   For PSQLServerEngineVersionInfo the FileNumber can not be 0.
76395>>>>>>>>>>>>>    //
76395>>>>>>>>>>>>>    //   If the version information is not available or can not be obtained
76395>>>>>>>>>>>>>    //   the functions will return "0.0.0"
76395>>>>>>>>>>>>>    
76395>>>>>>>>>>>>>    //  Returns the version information of the
76395>>>>>>>>>>>>>    //           Pervasive.SQL Client requester.
76395>>>>>>>>>>>>>    
76395>>>>>>>>>>>>>    Function PSQLRequesterVersionInfo Integer iFileNum Returns String
76397>>>>>>>>>>>>>        
76397>>>>>>>>>>>>>        String  sDriverID
76397>>>>>>>>>>>>>        String  sVersion
76397>>>>>>>>>>>>>        String  sVoid
76397>>>>>>>>>>>>>        Integer iRetval
76397>>>>>>>>>>>>>        
76397>>>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
76397>>>>>>>>>>>>>        // This error would otherwise be raised when we have an older
76397>>>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
76397>>>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
76398>>>>>>>>>>>>>        Get psDriverID to sDriverID
76399>>>>>>>>>>>>>        Move (Repeat(" ", 255)) to sVersion
76400>>>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLREQUESTERVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
76405>>>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
76406>>>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
76408>>>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
76408>>>>>>>>>>>>>            Move "0.0.0" to sVersion
76409>>>>>>>>>>>>>        End
76409>>>>>>>>>>>>>>
76409>>>>>>>>>>>>>        Function_Return sVersion
76410>>>>>>>>>>>>>    End_Function
76411>>>>>>>>>>>>>    
76411>>>>>>>>>>>>>    //           Pervasive.SQL Engine
76411>>>>>>>>>>>>>    
76411>>>>>>>>>>>>>    Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
76413>>>>>>>>>>>>>        
76413>>>>>>>>>>>>>        String  sDriverID
76413>>>>>>>>>>>>>        String  sVersion
76413>>>>>>>>>>>>>        String  sVoid
76413>>>>>>>>>>>>>        Integer iRetval
76413>>>>>>>>>>>>>        
76413>>>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
76413>>>>>>>>>>>>>        // This error would otherwise be raised when we have an older
76413>>>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
76413>>>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
76414>>>>>>>>>>>>>        Get psDriverID to sDriverID
76415>>>>>>>>>>>>>        Move (Repeat(" ", 255)) to sVersion
76416>>>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLLOCALENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
76421>>>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
76422>>>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
76424>>>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
76424>>>>>>>>>>>>>            Move "0.0.0" to sVersion
76425>>>>>>>>>>>>>        End
76425>>>>>>>>>>>>>>
76425>>>>>>>>>>>>>        Function_Return sVersion
76426>>>>>>>>>>>>>    End_Function
76427>>>>>>>>>>>>>    
76427>>>>>>>>>>>>>    //  Returns the version information of the
76427>>>>>>>>>>>>>    //           Pervasive.SQL Server Engine
76427>>>>>>>>>>>>>    
76427>>>>>>>>>>>>>    Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
76429>>>>>>>>>>>>>        
76429>>>>>>>>>>>>>        String  sDriverID
76429>>>>>>>>>>>>>        String  sVersion
76429>>>>>>>>>>>>>        String  sVoid
76429>>>>>>>>>>>>>        Integer iRetval
76429>>>>>>>>>>>>>        
76429>>>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
76429>>>>>>>>>>>>>        // This error would otherwise be raised when we have an older
76429>>>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
76429>>>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
76430>>>>>>>>>>>>>        Get psDriverID to sDriverID
76431>>>>>>>>>>>>>        Move (Repeat(" ", 255)) to sVersion
76432>>>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLSERVERENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
76437>>>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
76438>>>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
76440>>>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
76440>>>>>>>>>>>>>            Move "0.0.0" to sVersion
76441>>>>>>>>>>>>>        End
76441>>>>>>>>>>>>>>
76441>>>>>>>>>>>>>        Function_Return sVersion
76442>>>>>>>>>>>>>    End_Function
76443>>>>>>>>>>>>>    
76443>>>>>>>>>>>>>End_Class
76444>>>>>>>>>>>>>
76444>>>>>>>>>>>>>
76444>>>>>>>>>>>Use cSQLConnectionIniFile.inc
Including file: cSQLConnectionIniFile.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionIniFile.inc)
76444>>>>>>>>>>>>>//****************************************************************************
76444>>>>>>>>>>>>>// $Module type: Include file
76444>>>>>>>>>>>>>// $Module name: cSQLConnectionIniFile.inc
76444>>>>>>>>>>>>>//
76444>>>>>>>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International.
76444>>>>>>>>>>>>>// Copyright (c) 2012 RDC Tools International
76444>>>>>>>>>>>>>// E-mail      : support@rdctools.com
76444>>>>>>>>>>>>>// Web-site    : http://www.rdctools.com
76444>>>>>>>>>>>>>//
76444>>>>>>>>>>>>>// Created     : 2017-01-18 @ 13:04 (Military date format - Year-Month-Day)
76444>>>>>>>>>>>>>//
76444>>>>>>>>>>>>>// Note        : Header file with constant declarations for the cSQLConnectionIniFile class.
76444>>>>>>>>>>>>>//
76444>>>>>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
76444>>>>>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
76444>>>>>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
76444>>>>>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
76444>>>>>>>>>>>>>// in the help folder for more details.
76444>>>>>>>>>>>>>//
76444>>>>>>>>>>>>>Use Winkern.pkg
76444>>>>>>>>>>>>>Use cIniFile.pkg
76444>>>>>>>>>>>>>    Use cCryptographerEx.pkg
Including file: cCryptographerEx.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCryptographerEx.pkg)
76444>>>>>>>>>>>>>>>Use VdfBase.pkg
76444>>>>>>>>>>>>>>>
76444>>>>>>>>>>>>>>>Use CryptographerConstants.pkg
Including file: CryptographerConstants.pkg    (C:\Program Files\DataFlex 24.0\Pkg\CryptographerConstants.pkg)
76444>>>>>>>>>>>>>>>>>//   Author  : Ulbe Stellema
76444>>>>>>>>>>>>>>>>>// Algorithm classes
76444>>>>>>>>>>>>>>>>>Define ALG_CLASS_ANY                    for |CI$00000000 // (0)
76444>>>>>>>>>>>>>>>>>Define ALG_CLASS_SIGNATURE              for |CI$00002000 // (1 << 13)
76444>>>>>>>>>>>>>>>>>Define ALG_CLASS_MSG_ENCRYPT            for |CI$00004000 // (2 << 13)
76444>>>>>>>>>>>>>>>>>Define ALG_CLASS_DATA_ENCRYPT           for |CI$00006000 // (3 << 13)
76444>>>>>>>>>>>>>>>>>Define ALG_CLASS_HASH                   for |CI$00008000 // (4 << 13)
76444>>>>>>>>>>>>>>>>>Define ALG_CLASS_KEY_EXCHANGE           for |CI$0000A000 // (5 << 13)
76444>>>>>>>>>>>>>>>>>Define ALG_CLASS_ALL                    for |CI$0000E000 // (7 << 13)
76444>>>>>>>>>>>>>>>>>
76444>>>>>>>>>>>>>>>>>// Algorithm types
76444>>>>>>>>>>>>>>>>>Define ALG_TYPE_ANY                     for |CI$00000000 // (0)
76444>>>>>>>>>>>>>>>>>Define ALG_TYPE_DSS                     for |CI$00000200 // (1 << 9)
76444>>>>>>>>>>>>>>>>>Define ALG_TYPE_RSA                     for |CI$00000400 // (2 << 9)
76444>>>>>>>>>>>>>>>>>Define ALG_TYPE_BLOCK                   for |CI$00000600 // (3 << 9)
76444>>>>>>>>>>>>>>>>>Define ALG_TYPE_STREAM                  for |CI$00000800 // (4 << 9)
76444>>>>>>>>>>>>>>>>>Define ALG_TYPE_DH                      for |CI$00000A00 // (5 << 9)
76444>>>>>>>>>>>>>>>>>Define ALG_TYPE_SECURECHANNEL           for |CI$00000C00 // (6 << 9)
76444>>>>>>>>>>>>>>>>>
76444>>>>>>>>>>>>>>>>>// Generic sub-ids
76444>>>>>>>>>>>>>>>>>Define ALG_SID_ANY                      for |CI$00000000 // (0)
76444>>>>>>>>>>>>>>>>>
76444>>>>>>>>>>>>>>>>>// RSA sub-ids
76444>>>>>>>>>>>>>>>>>Define ALG_SID_RSA_ANY                  for 0
76444>>>>>>>>>>>>>>>>>Define ALG_SID_RSA_PKCS                 for 1
76444>>>>>>>>>>>>>>>>>Define ALG_SID_RSA_MSATWORK             for 2
76444>>>>>>>>>>>>>>>>>Define ALG_SID_RSA_ENTRUST              for 3
76444>>>>>>>>>>>>>>>>>Define ALG_SID_RSA_PGP                  for 4
76444>>>>>>>>>>>>>>>>>
76444>>>>>>>>>>>>>>>>>// DSS sub-ids
76444>>>>>>>>>>>>>>>>>Define ALG_SID_DSS_ANY                  for 0
76444>>>>>>>>>>>>>>>>>Define ALG_SID_DSS_PKCS                 for 1
76444>>>>>>>>>>>>>>>>>Define ALG_SID_DSS_DMS                  for 2
76444>>>>>>>>>>>>>>>>>
76444>>>>>>>>>>>>>>>>>// DES sub_ids
76444>>>>>>>>>>>>>>>>>Define ALG_SID_DES                      for 1
76444>>>>>>>>>>>>>>>>>Define ALG_SID_3DES                     for 3
76444>>>>>>>>>>>>>>>>>Define ALG_SID_DESX                     for 4
76444>>>>>>>>>>>>>>>>>Define ALG_SID_IDEA                     for 5
76444>>>>>>>>>>>>>>>>>Define ALG_SID_CAST                     for 6
76444>>>>>>>>>>>>>>>>>Define ALG_SID_SAFERSK64                for 7
76444>>>>>>>>>>>>>>>>>Define ALG_SID_SAFERSK128               for 8
76444>>>>>>>>>>>>>>>>>Define ALG_SID_3DES_112                 for 9
76444>>>>>>>>>>>>>>>>>Define ALG_SID_CYLINK_MEK               for 12
76444>>>>>>>>>>>>>>>>>Define ALG_SID_RC5                      for 13
76444>>>>>>>>>>>>>>>>>Define ALG_SID_AES_128                  for 14
76444>>>>>>>>>>>>>>>>>Define ALG_SID_AES_192                  for 15
76444>>>>>>>>>>>>>>>>>Define ALG_SID_AES_256                  for 16
76444>>>>>>>>>>>>>>>>>Define ALG_SID_AES                      for 17
76444>>>>>>>>>>>>>>>>>
76444>>>>>>>>>>>>>>>>>// Fortezza sub-ids
76444>>>>>>>>>>>>>>>>>Define ALG_SID_SKIPJACK                 for 10
76444>>>>>>>>>>>>>>>>>Define ALG_SID_TEK                      for 11
76444>>>>>>>>>>>>>>>>>
76444>>>>>>>>>>>>>>>>>// RC2 sub-ids
76444>>>>>>>>>>>>>>>>>Define ALG_SID_RC2                      for 2
76444>>>>>>>>>>>>>>>>>
76444>>>>>>>>>>>>>>>>>// Stream cipher sub-ids
76444>>>>>>>>>>>>>>>>>Define ALG_SID_RC4                      for 1
76444>>>>>>>>>>>>>>>>>Define ALG_SID_SEAL                     for 2
76444>>>>>>>>>>>>>>>>>
76444>>>>>>>>>>>>>>>>>// Diffie-Hellman sub-ids
76444>>>>>>>>>>>>>>>>>Define ALG_SID_DH_SANDF                 for 1
76444>>>>>>>>>>>>>>>>>Define ALG_SID_DH_EPHEM                 for 2
76444>>>>>>>>>>>>>>>>>Define ALG_SID_AGREED_KEY_ANY           for 3
76444>>>>>>>>>>>>>>>>>Define ALG_SID_KEA                      for 4
76444>>>>>>>>>>>>>>>>>
76444>>>>>>>>>>>>>>>>>// Hash sub ids
76444>>>>>>>>>>>>>>>>>Define ALG_SID_MD2                      for 1
76444>>>>>>>>>>>>>>>>>Define ALG_SID_MD4                      for 2
76444>>>>>>>>>>>>>>>>>Define ALG_SID_MD5                      for 3
76444>>>>>>>>>>>>>>>>>Define ALG_SID_SHA                      for 4
76444>>>>>>>>>>>>>>>>>Define ALG_SID_SHA1                     for 4
76444>>>>>>>>>>>>>>>>>Define ALG_SID_MAC                      for 5
76444>>>>>>>>>>>>>>>>>Define ALG_SID_RIPEMD                   for 6
76444>>>>>>>>>>>>>>>>>Define ALG_SID_RIPEMD160                for 7
76444>>>>>>>>>>>>>>>>>Define ALG_SID_SSL3SHAMD5               for 8
76444>>>>>>>>>>>>>>>>>Define ALG_SID_HMAC                     for 9
76444>>>>>>>>>>>>>>>>>Define ALG_SID_TLS1PRF                  for 10
76444>>>>>>>>>>>>>>>>>Define ALG_SID_HASH_REPLACE_OWF         for 11
76444>>>>>>>>>>>>>>>>>Define ALG_SID_SHA_256                  for 12
76444>>>>>>>>>>>>>>>>>Define ALG_SID_SHA_384                  for 13
76444>>>>>>>>>>>>>>>>>Define ALG_SID_SHA_512                  for 14
76444>>>>>>>>>>>>>>>>>
76444>>>>>>>>>>>>>>>>>// secure channel sub ids
76444>>>>>>>>>>>>>>>>>Define ALG_SID_SSL3_MASTER              for 1
76444>>>>>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_MASTER_HASH     for 2
76444>>>>>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_MAC_KEY         for 3
76444>>>>>>>>>>>>>>>>>Define ALG_SID_PCT1_MASTER              for 4
76444>>>>>>>>>>>>>>>>>Define ALG_SID_SSL2_MASTER              for 5
76444>>>>>>>>>>>>>>>>>Define ALG_SID_TLS1_MASTER              for 6
76444>>>>>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_ENC_KEY         for 7
76444>>>>>>>>>>>>>>>>>
76444>>>>>>>>>>>>>>>>>// algorithm identifier definitions
76444>>>>>>>>>>>>>>>>>Define CALG_MD2                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD2)
76444>>>>>>>>>>>>>>>>>Define CALG_MD4                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD4)
76444>>>>>>>>>>>>>>>>>Define CALG_MD5                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD5)
76444>>>>>>>>>>>>>>>>>Define CALG_SHA                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA)
76444>>>>>>>>>>>>>>>>>Define CALG_SHA1                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA1)
76444>>>>>>>>>>>>>>>>>Define CALG_MAC                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MAC)
76444>>>>>>>>>>>>>>>>>Define CALG_RSA_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
76444>>>>>>>>>>>>>>>>>Define CALG_DSS_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_DSS ior ALG_SID_DSS_ANY)
76444>>>>>>>>>>>>>>>>>Define CALG_NO_SIGN                     for (ALG_CLASS_SIGNATURE ior ALG_TYPE_ANY ior ALG_SID_ANY)
76444>>>>>>>>>>>>>>>>>Define CALG_RSA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
76444>>>>>>>>>>>>>>>>>Define CALG_DES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DES)
76444>>>>>>>>>>>>>>>>>Define CALG_3DES_112                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES_112)
76444>>>>>>>>>>>>>>>>>Define CALG_3DES                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES)
76444>>>>>>>>>>>>>>>>>Define CALG_DESX                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DESX)
76444>>>>>>>>>>>>>>>>>Define CALG_RC2                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC2)
76444>>>>>>>>>>>>>>>>>Define CALG_RC4                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_RC4)
76444>>>>>>>>>>>>>>>>>Define CALG_SEAL                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_SEAL)
76444>>>>>>>>>>>>>>>>>Define CALG_DH_SF                       for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_SANDF)
76444>>>>>>>>>>>>>>>>>Define CALG_DH_EPHEM                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_EPHEM)
76444>>>>>>>>>>>>>>>>>Define CALG_AGREEDKEY_ANY               for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_AGREED_KEY_ANY)
76444>>>>>>>>>>>>>>>>>Define CALG_KEA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_KEA)
76444>>>>>>>>>>>>>>>>>Define CALG_HUGHES_MD5                  for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_ANY ior ALG_SID_MD5)
76444>>>>>>>>>>>>>>>>>Define CALG_SKIPJACK                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_SKIPJACK)
76444>>>>>>>>>>>>>>>>>Define CALG_TEK                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_TEK)
76444>>>>>>>>>>>>>>>>>Define CALG_CYLINK_MEK                  for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_CYLINK_MEK)
76444>>>>>>>>>>>>>>>>>Define CALG_SSL3_SHAMD5                 for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SSL3SHAMD5)
76444>>>>>>>>>>>>>>>>>Define CALG_SSL3_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL3_MASTER)
76444>>>>>>>>>>>>>>>>>Define CALG_SCHANNEL_MASTER_HASH        for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MASTER_HASH)
76444>>>>>>>>>>>>>>>>>Define CALG_SCHANNEL_MAC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MAC_KEY)
76444>>>>>>>>>>>>>>>>>Define CALG_SCHANNEL_ENC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_ENC_KEY)
76444>>>>>>>>>>>>>>>>>Define CALG_PCT1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_PCT1_MASTER)
76444>>>>>>>>>>>>>>>>>Define CALG_SSL2_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL2_MASTER)
76444>>>>>>>>>>>>>>>>>Define CALG_TLS1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_TLS1_MASTER)
76444>>>>>>>>>>>>>>>>>Define CALG_RC5                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC5)
76444>>>>>>>>>>>>>>>>>Define CALG_HMAC                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HMAC)
76444>>>>>>>>>>>>>>>>>Define CALG_TLS1PRF                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_TLS1PRF)
76444>>>>>>>>>>>>>>>>>Define CALG_HASH_REPLACE_OWF            for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HASH_REPLACE_OWF)
76444>>>>>>>>>>>>>>>>>Define CALG_AES_128                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_128)
76444>>>>>>>>>>>>>>>>>Define CALG_AES_192                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_192)
76444>>>>>>>>>>>>>>>>>Define CALG_AES_256                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_256)
76444>>>>>>>>>>>>>>>>>Define CALG_AES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES)
76444>>>>>>>>>>>>>>>>>Define CALG_SHA_256                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_256)
76444>>>>>>>>>>>>>>>>>Define CALG_SHA_384                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_384)
76444>>>>>>>>>>>>>>>>>Define CALG_SHA_512                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_512)
76444>>>>>>>>>>>>>>>>>
76444>>>>>>>>>>>>>>>>>// Providers
76444>>>>>>>>>>>>>>>>>Define MS_DEF_PROV                      for "Microsoft Base Cryptographic Provider v1.0"
76444>>>>>>>>>>>>>>>>>Define MS_ENHANCED_PROV                 for "Microsoft Enhanced Cryptographic Provider v1.0"
76444>>>>>>>>>>>>>>>>>Define MS_STRONG_PROV                   for "Microsoft Strong Cryptographic Provider"
76444>>>>>>>>>>>>>>>>>Define MS_DEF_RSA_SIG_PROV              for "Microsoft RSA Signature Cryptographic Provider"
76444>>>>>>>>>>>>>>>>>Define MS_DEF_RSA_SCHANNEL_PROV         for "Microsoft RSA SChannel Cryptographic Provider"
76444>>>>>>>>>>>>>>>>>Define MS_DEF_DSS_PROV                  for "Microsoft Base DSS Cryptographic Provider"
76444>>>>>>>>>>>>>>>>>Define MS_DEF_DSS_DH_PROV               for "Microsoft Base DSS and Diffie-Hellman Cryptographic Provider"
76444>>>>>>>>>>>>>>>>>Define MS_ENH_DSS_DH_PROV               for "Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider"
76444>>>>>>>>>>>>>>>>>Define MS_DEF_DH_SCHANNEL_PROV          for "Microsoft DH SChannel Cryptographic Provider"
76444>>>>>>>>>>>>>>>>>Define MS_SCARD_PROV                    for "Microsoft Base Smart Card Crypto Provider"
76444>>>>>>>>>>>>>>>>>Define MS_ENH_RSA_AES_PROV              for "Microsoft Enhanced RSA and AES Cryptographic Provider"
76444>>>>>>>>>>>>>>>>>
76444>>>>>>>>>>>>>>>>>// dwFlags definitions for CryptAcquireContext
76444>>>>>>>>>>>>>>>>>Define CRYPT_VERIFYCONTEXT              for |CI$F0000000
76444>>>>>>>>>>>>>>>>>Define CRYPT_NEWKEYSET                  for |CI$00000008
76444>>>>>>>>>>>>>>>>>Define CRYPT_DELETEKEYSET               for |CI$00000010
76444>>>>>>>>>>>>>>>>>Define CRYPT_MACHINE_KEYSET             for |CI$00000020
76444>>>>>>>>>>>>>>>>>Define CRYPT_SILENT                     for |CI$00000040
76444>>>>>>>>>>>>>>>>>
76444>>>>>>>>>>>>>>>>>// dwFlag definitions for CryptGenKey
76444>>>>>>>>>>>>>>>>>Define CRYPT_EXPORTABLE                 for |CI$00000001
76444>>>>>>>>>>>>>>>>>Define CRYPT_USER_PROTECTED             for |CI$00000002
76444>>>>>>>>>>>>>>>>>Define CRYPT_CREATE_SALT                for |CI$00000004
76444>>>>>>>>>>>>>>>>>Define CRYPT_UPDATE_KEY                 for |CI$00000008
76444>>>>>>>>>>>>>>>>>Define CRYPT_NO_SALT                    for |CI$00000010
76444>>>>>>>>>>>>>>>>>Define CRYPT_PREGEN                     for |CI$00000040
76444>>>>>>>>>>>>>>>>>Define CRYPT_RECIPIENT                  for |CI$00000010
76444>>>>>>>>>>>>>>>>>Define CRYPT_INITIATOR                  for |CI$00000040
76444>>>>>>>>>>>>>>>>>Define CRYPT_ONLINE                     for |CI$00000080
76444>>>>>>>>>>>>>>>>>Define CRYPT_SF                         for |CI$00000100
76444>>>>>>>>>>>>>>>>>Define CRYPT_CREATE_IV                  for |CI$00000200
76444>>>>>>>>>>>>>>>>>Define CRYPT_KEK                        for |CI$00000400
76444>>>>>>>>>>>>>>>>>Define CRYPT_DATA_KEY                   for |CI$00000800
76444>>>>>>>>>>>>>>>>>Define CRYPT_VOLATILE                   for |CI$00001000
76444>>>>>>>>>>>>>>>>>Define CRYPT_SGCKEY                     for |CI$00002000
76444>>>>>>>>>>>>>>>>>Define CRYPT_ARCHIVABLE                 for |CI$00004000
76444>>>>>>>>>>>>>>>>>
76444>>>>>>>>>>>>>>>>>// Provider types
76444>>>>>>>>>>>>>>>>>Define PROV_RSA_FULL                    for 1
76444>>>>>>>>>>>>>>>>>Define PROV_RSA_SIG                     for 2
76444>>>>>>>>>>>>>>>>>Define PROV_DSS                         for 3
76444>>>>>>>>>>>>>>>>>Define PROV_FORTEZZA                    for 4
76444>>>>>>>>>>>>>>>>>Define PROV_MS_EXCHANGE                 for 5
76444>>>>>>>>>>>>>>>>>Define PROV_SSL                         for 6
76444>>>>>>>>>>>>>>>>>Define PROV_RSA_SCHANNEL                for 12
76444>>>>>>>>>>>>>>>>>Define PROV_DSS_DH                      for 13
76444>>>>>>>>>>>>>>>>>Define PROV_EC_ECDSA_SIG                for 14
76444>>>>>>>>>>>>>>>>>Define PROV_EC_ECNRA_SIG                for 15
76444>>>>>>>>>>>>>>>>>Define PROV_EC_ECDSA_FULL               for 16
76444>>>>>>>>>>>>>>>>>Define PROV_EC_ECNRA_FULL               for 17
76444>>>>>>>>>>>>>>>>>Define PROV_DH_SCHANNEL                 for 18
76444>>>>>>>>>>>>>>>>>Define PROV_SPYRUS_LYNKS                for 20
76444>>>>>>>>>>>>>>>>>Define PROV_RNG                         for 21
76444>>>>>>>>>>>>>>>>>Define PROV_INTEL_SEC                   for 22
76444>>>>>>>>>>>>>>>>>Define PROV_REPLACE_OWF                 for 23
76444>>>>>>>>>>>>>>>>>Define PROV_RSA_AES                     for 24
76444>>>>>>>>>>>>>>>>>
76444>>>>>>>>>>>>>>>>>// KP_MODE
76444>>>>>>>>>>>>>>>>>// KP_MODE
76444>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CBC                   for 1       // Cipher block chaining
76444>>>>>>>>>>>>>>>>>Define CRYPT_MODE_ECB                   for 2       // Electronic code book
76444>>>>>>>>>>>>>>>>>Define CRYPT_MODE_OFB                   for 3       // Output feedback mode
76444>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CFB                   for 4       // Cipher feedback mode
76444>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CTS                   for 5       // Ciphertext stealing mode
76444>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CBCI                  for 6       // ANSI CBC Interleaved
76444>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CFBP                  for 7       // ANSI CFB Pipelined
76444>>>>>>>>>>>>>>>>>Define CRYPT_MODE_OFBP                  for 8       // ANSI OFB Pipelined
76444>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CBCOFM                for 9       // ANSI CBC + OF Masking
76444>>>>>>>>>>>>>>>>>Define CRYPT_MODE_CBCOFMI               for 10      // ANSI CBC + OFM Interleaved
76444>>>>>>>>>>>>>>>>>
76444>>>>>>>>>>>>>>>>>// dwParam definitions for CryptGetKeyParam
76444>>>>>>>>>>>>>>>>>Define KP_IV                            for 1       // Initialization vector
76444>>>>>>>>>>>>>>>>>Define KP_SALT                          for 2       // Salt value
76444>>>>>>>>>>>>>>>>>Define KP_PADDING                       for 3       // Padding values
76444>>>>>>>>>>>>>>>>>Define KP_MODE                          for 4       // Mode of the cipher
76444>>>>>>>>>>>>>>>>>Define KP_MODE_BITS                     for 5       // Number of bits to feedback
76444>>>>>>>>>>>>>>>>>Define KP_PERMISSIONS                   for 6       // Key permissions DWORD
76444>>>>>>>>>>>>>>>>>Define KP_ALGID                         for 7       // Key algorithm
76444>>>>>>>>>>>>>>>>>Define KP_BLOCKLEN                      for 8       // Block size of the cipher
76444>>>>>>>>>>>>>>>>>Define KP_KEYLEN                        for 9       // Length of key in bits
76444>>>>>>>>>>>>>>>>>Define KP_SALT_EX                       for 10      // Length of salt in bytes
76444>>>>>>>>>>>>>>>>>Define KP_P                             for 11      // DSS/Diffie-Hellman P value
76444>>>>>>>>>>>>>>>>>Define KP_G                             for 12      // DSS/Diffie-Hellman G value
76444>>>>>>>>>>>>>>>>>Define KP_Q                             for 13      // DSS Q value
76444>>>>>>>>>>>>>>>>>Define KP_X                             for 14      // Diffie-Hellman X value
76444>>>>>>>>>>>>>>>>>Define KP_Y                             for 15      // Y value
76444>>>>>>>>>>>>>>>>>Define KP_RA                            for 16      // Fortezza RA value
76444>>>>>>>>>>>>>>>>>Define KP_RB                            for 17      // Fortezza RB value
76444>>>>>>>>>>>>>>>>>Define KP_INFO                          for 18      // for putting information into an RSA envelope
76444>>>>>>>>>>>>>>>>>Define KP_EFFECTIVE_KEYLEN              for 19      // setting and getting RC2 effective key length
76444>>>>>>>>>>>>>>>>>Define KP_SCHANNEL_ALG                  for 20      // for setting the Secure Channel algorithms
76444>>>>>>>>>>>>>>>>>Define KP_CLIENT_RANDOM                 for 21      // for setting the Secure Channel client random data
76444>>>>>>>>>>>>>>>>>Define KP_SERVER_RANDOM                 for 22      // for setting the Secure Channel server random data
76444>>>>>>>>>>>>>>>>>Define KP_RP                            for 23
76444>>>>>>>>>>>>>>>>>Define KP_PRECOMP_MD5                   for 24
76444>>>>>>>>>>>>>>>>>Define KP_PRECOMP_SHA                   for 25
76444>>>>>>>>>>>>>>>>>Define KP_CERTIFICATE                   for 26      // for setting Secure Channel certificate data (PCT1)
76444>>>>>>>>>>>>>>>>>Define KP_CLEAR_KEY                     for 27      // for setting Secure Channel clear key data (PCT1)
76444>>>>>>>>>>>>>>>>>Define KP_PUB_EX_LEN                    for 28
76444>>>>>>>>>>>>>>>>>Define KP_PUB_EX_VAL                    for 29
76444>>>>>>>>>>>>>>>>>Define KP_KEYVAL                        for 30
76444>>>>>>>>>>>>>>>>>Define KP_ADMIN_PIN                     for 31
76444>>>>>>>>>>>>>>>>>Define KP_KEYEXCHANGE_PIN               for 32
76444>>>>>>>>>>>>>>>>>Define KP_SIGNATURE_PIN                 for 33
76444>>>>>>>>>>>>>>>>>Define KP_PREHASH                       for 34
76444>>>>>>>>>>>>>>>>>Define KP_ROUNDS                        for 35
76444>>>>>>>>>>>>>>>>>Define KP_OAEP_PARAMS                   for 36      // for setting OAEP params on RSA keys
76444>>>>>>>>>>>>>>>>>Define KP_CMS_KEY_INFO                  for 37
76444>>>>>>>>>>>>>>>>>Define KP_CMS_DH_KEY_INFO               for 38
76444>>>>>>>>>>>>>>>>>Define KP_PUB_PARAMS                    for 39      // for setting public parameters
76444>>>>>>>>>>>>>>>>>Define KP_VERIFY_PARAMS                 for 40      // for verifying DSA and DH parameters
76444>>>>>>>>>>>>>>>>>Define KP_HIGHEST_VERSION               for 41      // for TLS protocol version setting
76444>>>>>>>>>>>>>>>>>Define KP_GET_USE_COUNT                 for 42      // for use with PP_CRYPT_COUNT_KEY_USE contexts
76444>>>>>>>>>>>>>>>>>
76444>>>>>>>>>>>>>>>>>// dwParam definitions for CryptGetHashParam
76444>>>>>>>>>>>>>>>>>Define HP_ALGID                         for |CI$0001  // Hash algorithm
76444>>>>>>>>>>>>>>>>>Define HP_HASHVAL                       for |CI$0002  // Hash value
76444>>>>>>>>>>>>>>>>>Define HP_HASHSIZE                      for |CI$0004  // Hash value size
76444>>>>>>>>>>>>>>>>>Define HP_HMAC_INFO                     for |CI$0005  // information for creating an HMA
76444>>>>>>>>>>>>>>>>>
76444>>>>>>>>>>>>>>>>>// key BLOB types
76444>>>>>>>>>>>>>>>>>Define KEYSTATEBLOB                     for |CI$0C
76444>>>>>>>>>>>>>>>>>Define OPAQUEKEYBLOB                    for |CI$09
76444>>>>>>>>>>>>>>>>>Define PLAINTEXTKEYBLOB                 for |CI$08
76444>>>>>>>>>>>>>>>>>Define PRIVATEKEYBLOB                   for |CI$07
76444>>>>>>>>>>>>>>>>>Define PUBLICKEYBLOB                    for |CI$06
76444>>>>>>>>>>>>>>>>>Define PUBLICKEYBLOBEX                  for |CI$0A
76444>>>>>>>>>>>>>>>>>Define SIMPLEBLOB                       for |CI$01
76444>>>>>>>>>>>>>>>>>Define SYMMETRICWRAPKEYBLOB             for |CI$0B
76444>>>>>>>>>>>>>>>>>
76444>>>>>>>>>>>>>>>>>Define CUR_BLOB_VERSION                 for 2
76444>>>>>>>>>>>>>>>>>
76444>>>>>>>>>>>>>>>>>// KP_PADDING
76444>>>>>>>>>>>>>>>>>Define PKCS5_PADDING                    for 1       // PKCS 5 (sec 6.2) padding method
76444>>>>>>>>>>>>>>>>>Define RANDOM_PADDING                   for 2
76444>>>>>>>>>>>>>>>>>Define ZERO_PADDING                     for 3
76444>>>>>>>>>>>>>>>>>
76444>>>>>>>>>>>>>>>>>//  Structure cryptimportkey
76444>>>>>>>>>>>>>>>>>Struct PUBLICKEYSTRUC
76444>>>>>>>>>>>>>>>>>    UChar    bType
76444>>>>>>>>>>>>>>>>>    UChar    bVersion
76444>>>>>>>>>>>>>>>>>    UShort   reserved
76444>>>>>>>>>>>>>>>>>    UInteger aiKeyAlg
76444>>>>>>>>>>>>>>>>>End_Struct
76444>>>>>>>>>>>>>>>>>
76444>>>>>>>>>>>>>>>>>Struct tPLAINTEXTKEYBLOB
76444>>>>>>>>>>>>>>>>>    PUBLICKEYSTRUC hdr
76444>>>>>>>>>>>>>>>>>    PUBLICKEYSTRUC hdr
76444>>>>>>>>>>>>>>>>>    UInteger       dwKeySize
76444>>>>>>>>>>>>>>>>>//    UChar[]        rgbKeyData
76444>>>>>>>>>>>>>>>>>End_Struct
76444>>>>>>>>>>>>>>>>>
76444>>>>>>>>>>>>>>>>>
76444>>>>>>>>>>>>>>>>>
76444>>>>>>>>>>>>>>>>>//  Structure for specifying the inner and outer strings when calculating HMAC hash (use with CryptSetHashParam)
76444>>>>>>>>>>>>>>>>>Struct HMAC_INFO
76444>>>>>>>>>>>>>>>>>    UInteger HashAlgid
76444>>>>>>>>>>>>>>>>>    Pointer pbInnerString
76444>>>>>>>>>>>>>>>>>    DWord cbInnerString
76444>>>>>>>>>>>>>>>>>    Pointer pbOuterString
76444>>>>>>>>>>>>>>>>>    DWord cbOuterString
76444>>>>>>>>>>>>>>>>>End_Struct
76444>>>>>>>>>>>>>>>>>
76444>>>>>>>>>>>>>>>>>Struct BLOBHEADER
76444>>>>>>>>>>>>>>>>>    UChar   bType
76444>>>>>>>>>>>>>>>>>    UChar   bVersion
76444>>>>>>>>>>>>>>>>>    Short   reserved
76444>>>>>>>>>>>>>>>>>    Integer aiKeyAlg
76444>>>>>>>>>>>>>>>>>End_Struct
76444>>>>>>>>>>>>>>>>>
76444>>>>>>>>>>>>>>>>>Struct CryptoBlob
76444>>>>>>>>>>>>>>>>>    BLOBHEADER  header
76444>>>>>>>>>>>>>>>>>    BLOBHEADER  header
76444>>>>>>>>>>>>>>>>>    Integer     cbKeySize
76444>>>>>>>>>>>>>>>>>    UChar[32]   rgbKeyData
76444>>>>>>>>>>>>>>>>>End_Struct
76444>>>>>>>>>>>>>>>>>
76444>>>>>>>>>>>>>>>>>
76444>>>>>>>>>>>>>>>>>// Note: lpContainer and lpProvider refer to WString types.
76444>>>>>>>>>>>>>>>>>External_Function CryptAcquireContextW "CryptAcquireContextW" advapi32.dll ;    Pointer phProv ;    Pointer lpContainer ;    Pointer lpProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
76445>>>>>>>>>>>>>>>>>
76445>>>>>>>>>>>>>>>>>// Compatibilty wrapper Function CryptAcquireContext
76445>>>>>>>>>>>>>>>>>Function CryptAcquireContext Global ;    Pointer phProv ;    Pointer szContainer ;    Pointer szProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
76447>>>>>>>>>>>>>>>>>    
76447>>>>>>>>>>>>>>>>>    Boolean bResult
76447>>>>>>>>>>>>>>>>>    UWide   uwContainer uwProvider
76447>>>>>>>>>>>>>>>>>    UWide   uwContainer uwProvider
76447>>>>>>>>>>>>>>>>>
76447>>>>>>>>>>>>>>>>>    Send StringToWide szContainer (&uwContainer)
76448>>>>>>>>>>>>>>>>>    Send StringToWide szProvider (&uwProvider)
76449>>>>>>>>>>>>>>>>>    
76449>>>>>>>>>>>>>>>>>    Move (CryptAcquireContextW (phProv, uwContainer.lpUText, uwProvider.lpUText, dwProvType, dwFlags)) to bResult                   
76450>>>>>>>>>>>>>>>>>
76450>>>>>>>>>>>>>>>>>    Function_Return bResult
76451>>>>>>>>>>>>>>>>>End_Function
76452>>>>>>>>>>>>>>>>>
76452>>>>>>>>>>>>>>>>>External_Function CryptReleaseContext "CryptReleaseContext" advapi32.dll ;    Handle hProv ;    Integer dwFlags ;    Returns Boolean
76453>>>>>>>>>>>>>>>>>
76453>>>>>>>>>>>>>>>>>External_Function CryptCreateHash "CryptCreateHash" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hKey ;    Integer dwFlags ;    Pointer phHash ;    Returns Boolean
76454>>>>>>>>>>>>>>>>>
76454>>>>>>>>>>>>>>>>>External_Function CryptDestroyHash "CryptDestroyHash" advapi32.dll ;    Handle hHash ;    Returns Boolean
76455>>>>>>>>>>>>>>>>>
76455>>>>>>>>>>>>>>>>>External_Function CryptHashData "CryptHashData" advapi32.dll ;    Handle hHash ;    Pointer pbData ;    Integer dwDataLen ;    Integer dwFlags ;    Returns Boolean
76456>>>>>>>>>>>>>>>>>
76456>>>>>>>>>>>>>>>>>External_Function CryptDeriveKey "CryptDeriveKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hBaseData ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
76457>>>>>>>>>>>>>>>>>
76457>>>>>>>>>>>>>>>>>External_Function CryptGetHashParam "CryptGetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    DWord dwFlags ;    Returns Integer
76458>>>>>>>>>>>>>>>>>
76458>>>>>>>>>>>>>>>>>External_Function CryptDestroyKey "CryptDestroyKey" advapi32.dll ;    Handle hKey ;    Returns Boolean
76459>>>>>>>>>>>>>>>>>
76459>>>>>>>>>>>>>>>>>External_Function CryptImportKey "CryptImportKey" advapi32.dll ;    Handle hProv ;    Pointer pbData ;    Integer dwDataLen ;    Handle hPubKey ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
76460>>>>>>>>>>>>>>>>>
76460>>>>>>>>>>>>>>>>>External_Function CryptGetKeyParam "CryptGetKeyParam" advapi32.dll ;    Handle hKey ;    Integer dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwFlags ;    Returns Boolean
76461>>>>>>>>>>>>>>>>>    
76461>>>>>>>>>>>>>>>>>External_Function CryptSetKeyParam "CryptSetKeyParam" advapi32.dll ;    Handle   hKey ;    UInteger dwParam ;    Pointer  pbdata ;    UInteger dwFlags ;    Returns  Boolean
76462>>>>>>>>>>>>>>>>>
76462>>>>>>>>>>>>>>>>>External_Function CryptEncrypt "CryptEncrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwBufLen ;    Returns Boolean
76463>>>>>>>>>>>>>>>>>
76463>>>>>>>>>>>>>>>>>External_Function CryptDecrypt "CryptDecrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
76464>>>>>>>>>>>>>>>>>
76464>>>>>>>>>>>>>>>>>External_Function CryptGenRandom "CryptGenRandom" advapi32.dll ;    Handle hProv ;    DWord dwLen ;    Pointer pbBuffer ;    Returns Boolean
76465>>>>>>>>>>>>>>>>>    
76465>>>>>>>>>>>>>>>>>External_Function CryptSetHashParam "CryptSetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Integer dwFlags ;    Returns Boolean
76466>>>>>>>>>>>>>>>>>    
76466>>>>>>>>>>>>>>>>>External_Function CryptGenKey "CryptGenKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
76467>>>>>>>>>>>>>>>>>    
76467>>>>>>>>>>>>>>>>>External_Function CryptExportKey "CryptExportKey" advapi32.dll ;    Handle hKey ;    Handle hExpKey ;    Integer dwBlobType ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
76468>>>>>>>>>>>>>>>
76468>>>>>>>>>>>>>>>Class cCryptographerEx is a cObject
76469>>>>>>>>>>>>>>>    
76469>>>>>>>>>>>>>>>    Procedure Construct_Object
76471>>>>>>>>>>>>>>>        Forward Send Construct_Object
76473>>>>>>>>>>>>>>>        
76473>>>>>>>>>>>>>>>        Property String     psProvider  MS_ENHANCED_PROV
76474>>>>>>>>>>>>>>>        Property Integer    piProvider  PROV_RSA_FULL
76475>>>>>>>>>>>>>>>        Property Integer    piCipher    CALG_RC4
76476>>>>>>>>>>>>>>>        Property Integer    piHash      CALG_MD5
76477>>>>>>>>>>>>>>>        
76477>>>>>>>>>>>>>>>        // Private properties
76477>>>>>>>>>>>>>>>        Property Handle     Private_phProv
76478>>>>>>>>>>>>>>>        
76478>>>>>>>>>>>>>>>        // Block cipher properties
76478>>>>>>>>>>>>>>>        Property UChar[]    paKey
76479>>>>>>>>>>>>>>>        Property UChar[]    paIV
76480>>>>>>>>>>>>>>>        Property Integer    piKeyAlg        PLAINTEXTKEYBLOB
76481>>>>>>>>>>>>>>>        Property Integer    piKeyType       CALG_AES_256
76482>>>>>>>>>>>>>>>        Property Integer    piKeyPadding    PKCS5_PADDING
76483>>>>>>>>>>>>>>>        Property Integer    piKeyMode       CRYPT_MODE_CBC
76484>>>>>>>>>>>>>>>        Property Integer    piBlockSize     16
76485>>>>>>>>>>>>>>>    End_Procedure
76486>>>>>>>>>>>>>>>    
76486>>>>>>>>>>>>>>>    
76486>>>>>>>>>>>>>>>    // Acquire key container handle
76486>>>>>>>>>>>>>>>    Function AcquireContext Returns Handle
76488>>>>>>>>>>>>>>>        Integer iProvider
76488>>>>>>>>>>>>>>>        WString wProvider
76488>>>>>>>>>>>>>>>        Handle hProv
76488>>>>>>>>>>>>>>>        Boolean bOk
76488>>>>>>>>>>>>>>>        Pointer pProv
76488>>>>>>>>>>>>>>>        
76488>>>>>>>>>>>>>>>        Move 0 to hProv
76489>>>>>>>>>>>>>>>        Get piProvider to iProvider
76490>>>>>>>>>>>>>>>        Get psProvider to wProvider
76491>>>>>>>>>>>>>>>        
76491>>>>>>>>>>>>>>>        //  Determine address to be passed as provider
76491>>>>>>>>>>>>>>>        If (Trim(wProvider) <> "") Begin
76493>>>>>>>>>>>>>>>            Move (AddressOf(wProvider)) to pProv
76494>>>>>>>>>>>>>>>        End
76494>>>>>>>>>>>>>>>>
76494>>>>>>>>>>>>>>>        Else Begin
76495>>>>>>>>>>>>>>>            Move 0 to pProv
76496>>>>>>>>>>>>>>>        End
76496>>>>>>>>>>>>>>>>
76496>>>>>>>>>>>>>>>        
76496>>>>>>>>>>>>>>>        //  Acquire Crypto Context. Note: pProv is pointer to UTF16 string.
76496>>>>>>>>>>>>>>>        Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_VERIFYCONTEXT)) to bOk
76497>>>>>>>>>>>>>>>        If (not(bOk) or hProv = 0) Begin
76499>>>>>>>>>>>>>>>            Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_NEWKEYSET ior CRYPT_VERIFYCONTEXT)) to bOk
76500>>>>>>>>>>>>>>>        End
76500>>>>>>>>>>>>>>>>
76500>>>>>>>>>>>>>>>        
76500>>>>>>>>>>>>>>>        If (not(bOk) or hProv = 0) Begin
76502>>>>>>>>>>>>>>>            // Fallback to original
76502>>>>>>>>>>>>>>>            Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,0)) to bOk
76503>>>>>>>>>>>>>>>            
76503>>>>>>>>>>>>>>>            If (not(bOk) or hProv = 0) Begin
76505>>>>>>>>>>>>>>>                Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_NEWKEYSET)) to bOk
76506>>>>>>>>>>>>>>>            End
76506>>>>>>>>>>>>>>>>
76506>>>>>>>>>>>>>>>        End
76506>>>>>>>>>>>>>>>>
76506>>>>>>>>>>>>>>>        Set Private_phProv to hProv
76507>>>>>>>>>>>>>>>        
76507>>>>>>>>>>>>>>>        Function_Return hProv
76508>>>>>>>>>>>>>>>    End_Function
76509>>>>>>>>>>>>>>>    
76509>>>>>>>>>>>>>>>    // Releases key container handle
76509>>>>>>>>>>>>>>>    Function ReleaseContext Handle hProv Returns Boolean
76511>>>>>>>>>>>>>>>        Function_Return (CryptReleaseContext(hProv,0))
76512>>>>>>>>>>>>>>>    End_Function
76513>>>>>>>>>>>>>>>    
76513>>>>>>>>>>>>>>>    // Creates hash object
76513>>>>>>>>>>>>>>>    Function CreateHash Handle hProv Returns Handle
76515>>>>>>>>>>>>>>>        Integer iAlgorithm
76515>>>>>>>>>>>>>>>        Handle hHash
76515>>>>>>>>>>>>>>>        Boolean bOk
76515>>>>>>>>>>>>>>>        
76515>>>>>>>>>>>>>>>        Move 0 to hHash
76516>>>>>>>>>>>>>>>        Get piHash to iAlgorithm
76517>>>>>>>>>>>>>>>        Move (CryptCreateHash(hProv,iAlgorithm,0,0,AddressOf(hHash))) to bOk
76518>>>>>>>>>>>>>>>        
76518>>>>>>>>>>>>>>>        Function_Return hHash
76519>>>>>>>>>>>>>>>    End_Function
76520>>>>>>>>>>>>>>>    
76520>>>>>>>>>>>>>>>    // Destroys the hash object
76520>>>>>>>>>>>>>>>    Function DestroyHash Handle hHash Returns Boolean
76522>>>>>>>>>>>>>>>        Function_Return (CryptDestroyHash(hHash))
76523>>>>>>>>>>>>>>>    End_Function
76524>>>>>>>>>>>>>>>    
76524>>>>>>>>>>>>>>>    // Adds data to hash object
76524>>>>>>>>>>>>>>>    Function HashData Handle hHash UChar[] ucData Returns Boolean
76526>>>>>>>>>>>>>>>        Function_Return (CryptHashData(hHash,AddressOf(ucData), SizeOfArray(ucData),0))
76527>>>>>>>>>>>>>>>    End_Function
76528>>>>>>>>>>>>>>>    
76528>>>>>>>>>>>>>>>    // Generates session key
76528>>>>>>>>>>>>>>>    Function DeriveKey Handle hProv Handle hHash Returns Handle
76530>>>>>>>>>>>>>>>        Integer iAlgorithm
76530>>>>>>>>>>>>>>>        Handle hKey
76530>>>>>>>>>>>>>>>        Boolean bOk
76530>>>>>>>>>>>>>>>        
76530>>>>>>>>>>>>>>>        Move 0 to hKey
76531>>>>>>>>>>>>>>>        Get piCipher to iAlgorithm
76532>>>>>>>>>>>>>>>        Move (CryptDeriveKey(hProv,iAlgorithm,hHash,CRYPT_EXPORTABLE,AddressOf(hKey))) to bOk
76533>>>>>>>>>>>>>>>        
76533>>>>>>>>>>>>>>>        Function_Return hKey
76534>>>>>>>>>>>>>>>    End_Function
76535>>>>>>>>>>>>>>>    
76535>>>>>>>>>>>>>>>    // Imports a plain text key
76535>>>>>>>>>>>>>>>    Function ImportPlainTextKey Handle hProv UChar[] ucaKey Returns Handle
76537>>>>>>>>>>>>>>>        tPLAINTEXTKEYBLOB blobhead
76537>>>>>>>>>>>>>>>        tPLAINTEXTKEYBLOB blobhead
76537>>>>>>>>>>>>>>>        Boolean   bSuccess
76537>>>>>>>>>>>>>>>        Handle    hKey
76537>>>>>>>>>>>>>>>        Integer   iHeadSize iKeySize
76537>>>>>>>>>>>>>>>        UChar[]   ucaKeyblob
76538>>>>>>>>>>>>>>>        Integer iVoid
76538>>>>>>>>>>>>>>>        
76538>>>>>>>>>>>>>>>        Move (SizeOfType(tPLAINTEXTKEYBLOB)) to iHeadSize
76539>>>>>>>>>>>>>>>        Move (SizeOfArray(ucaKey)) to iKeySize
76540>>>>>>>>>>>>>>>        
76540>>>>>>>>>>>>>>>        Move PLAINTEXTKEYBLOB to blobhead.hdr.bType
76541>>>>>>>>>>>>>>>        Move CUR_BLOB_VERSION   to blobhead.hdr.bVersion
76542>>>>>>>>>>>>>>>        Get piCipher            to blobhead.hdr.aiKeyAlg
76543>>>>>>>>>>>>>>>        Move iKeySize           to blobhead.dwKeySize
76544>>>>>>>>>>>>>>>        
76544>>>>>>>>>>>>>>>        Move (ResizeArray(ucaKeyblob, iHeadSize)) to ucaKeyblob
76545>>>>>>>>>>>>>>>        Move (CopyMemory(AddressOf(ucaKeyblob), AddressOf(blobhead), iHeadSize)) to iVoid
76546>>>>>>>>>>>>>>>        Move (AppendArray(ucaKeyblob, ucaKey)) to ucaKeyblob
76547>>>>>>>>>>>>>>>        
76547>>>>>>>>>>>>>>>        Move 0 to hKey
76548>>>>>>>>>>>>>>>        Move (CryptImportKey(hProv, AddressOf(ucaKeyblob), SizeOfArray(ucaKeyblob), 0, 0, AddressOf(hKey))) to bSuccess
76549>>>>>>>>>>>>>>>        If (not(bSuccess)) Begin
76551>>>>>>>>>>>>>>>            Move (ShowLastError()) to iVoid
76552>>>>>>>>>>>>>>>        End
76552>>>>>>>>>>>>>>>>
76552>>>>>>>>>>>>>>>        
76552>>>>>>>>>>>>>>>        Function_Return hKey
76553>>>>>>>>>>>>>>>    End_Function
76554>>>>>>>>>>>>>>>    
76554>>>>>>>>>>>>>>>    // Destroys the key
76554>>>>>>>>>>>>>>>    Function DestroyKey Handle hKey Returns Boolean
76556>>>>>>>>>>>>>>>        Function_Return (CryptDestroyKey(hKey))
76557>>>>>>>>>>>>>>>    End_Function
76558>>>>>>>>>>>>>>>    
76558>>>>>>>>>>>>>>>    // Retrieves key data
76558>>>>>>>>>>>>>>>    Function KeyParameter Handle hKey Integer iQuery Returns Integer
76560>>>>>>>>>>>>>>>        Integer iBuffer iLen
76560>>>>>>>>>>>>>>>        Boolean bOk
76560>>>>>>>>>>>>>>>        
76560>>>>>>>>>>>>>>>        Move (SizeOfType(Integer)) to iLen
76561>>>>>>>>>>>>>>>        Move (CryptGetKeyParam(hKey,iQuery,AddressOf(iBuffer),AddressOf(iLen),0)) to bOk
76562>>>>>>>>>>>>>>>        Function_Return iBuffer
76563>>>>>>>>>>>>>>>    End_Function
76564>>>>>>>>>>>>>>>    
76564>>>>>>>>>>>>>>>    // Retrieves a hash value
76564>>>>>>>>>>>>>>>    Function HashValue Handle lhHash Returns UChar[]
76566>>>>>>>>>>>>>>>        UChar[] ucHash
76567>>>>>>>>>>>>>>>        Integer liResult
76567>>>>>>>>>>>>>>>        DWord   dwDataLen
76567>>>>>>>>>>>>>>>        
76567>>>>>>>>>>>>>>>        Move 0 to dwDataLen
76568>>>>>>>>>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,0,AddressOf(dwDataLen),0)) to liResult
76569>>>>>>>>>>>>>>>        If (liResult = 0) ;            Function_Return ""
76572>>>>>>>>>>>>>>>        
76572>>>>>>>>>>>>>>>        Move (ResizeArray(ucHash, dwDataLen, 0)) to ucHash
76573>>>>>>>>>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,AddressOf(ucHash),AddressOf(dwDataLen),0)) to liResult
76574>>>>>>>>>>>>>>>        If (liResult = 0) ;            Function_Return ""
76577>>>>>>>>>>>>>>>        
76577>>>>>>>>>>>>>>>        Function_Return ucHash
76578>>>>>>>>>>>>>>>    End_Function
76579>>>>>>>>>>>>>>>
76579>>>>>>>>>>>>>>>    // Encrypts data
76579>>>>>>>>>>>>>>>    Function Encrypt UChar[] ucPassword UChar[] ucData Returns UChar[]
76581>>>>>>>>>>>>>>>        Handle hProv hHash hKey
76581>>>>>>>>>>>>>>>        Integer iAlgorithm iDataLen iCipherLen iErr
76581>>>>>>>>>>>>>>>        Boolean bOk
76581>>>>>>>>>>>>>>>        
76581>>>>>>>>>>>>>>>        Get AcquireContext to hProv
76582>>>>>>>>>>>>>>>        If (hProv) Begin
76584>>>>>>>>>>>>>>>            Get CreateHash hProv to hHash
76585>>>>>>>>>>>>>>>            If (hHash) Begin
76587>>>>>>>>>>>>>>>                Get HashData hHash ucPassword to bOk
76588>>>>>>>>>>>>>>>                If (bOk) Begin
76590>>>>>>>>>>>>>>>                    Get piCipher to iAlgorithm
76591>>>>>>>>>>>>>>>                    Get DeriveKey hProv hHash to hKey
76592>>>>>>>>>>>>>>>                End
76592>>>>>>>>>>>>>>>>
76592>>>>>>>>>>>>>>>                Get DestroyHash hHash to bOk
76593>>>>>>>>>>>>>>>            End
76593>>>>>>>>>>>>>>>>
76593>>>>>>>>>>>>>>>            
76593>>>>>>>>>>>>>>>            If (hKey) Begin
76595>>>>>>>>>>>>>>>                //  First call to determine resulting data size
76595>>>>>>>>>>>>>>>                Move (SizeOfArray(ucData)) to iDataLen
76596>>>>>>>>>>>>>>>                Move (SizeOfArray(ucData)) to iCipherLen
76597>>>>>>>>>>>>>>>                Move (CryptEncrypt(hKey, 0, True, 0, 0, AddressOf(iCipherLen), iDataLen)) to bOk
76598>>>>>>>>>>>>>>>                
76598>>>>>>>>>>>>>>>                //  Reserve space in string
76598>>>>>>>>>>>>>>>                If (iDataLen < iCipherLen) Begin
76600>>>>>>>>>>>>>>>                    Move (ResizeArray(ucData, iCipherLen, 0)) to ucData
76601>>>>>>>>>>>>>>>                End
76601>>>>>>>>>>>>>>>>
76601>>>>>>>>>>>>>>>                
76601>>>>>>>>>>>>>>>                //  Call to really decrypt
76601>>>>>>>>>>>>>>>                Move (CryptEncrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iDataLen),SizeOfArray(ucData))) to bOk
76602>>>>>>>>>>>>>>>                //If (not(bOk)) Begin
76602>>>>>>>>>>>>>>>                //Move "" to sData
76602>>>>>>>>>>>>>>>                //Move (GetLastError()) to iErr
76602>>>>>>>>>>>>>>>                //End
76602>>>>>>>>>>>>>>>                
76602>>>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
76603>>>>>>>>>>>>>>>            End 
76603>>>>>>>>>>>>>>>>
76603>>>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
76604>>>>>>>>>>>>>>>        End 
76604>>>>>>>>>>>>>>>>
76604>>>>>>>>>>>>>>>        Function_Return ucData
76605>>>>>>>>>>>>>>>    End_Function
76606>>>>>>>>>>>>>>>    
76606>>>>>>>>>>>>>>>    // Decrypts data
76606>>>>>>>>>>>>>>>    Function Decrypt UChar[] ucPassword UChar[] ucData Returns UChar[]
76608>>>>>>>>>>>>>>>        Handle hProv hHash hKey
76608>>>>>>>>>>>>>>>        Integer iAlgorithm iDataLen
76608>>>>>>>>>>>>>>>        Boolean bOk
76608>>>>>>>>>>>>>>>        
76608>>>>>>>>>>>>>>>        Get AcquireContext to hProv
76609>>>>>>>>>>>>>>>        If (hProv) Begin
76611>>>>>>>>>>>>>>>            Get CreateHash hProv to hHash
76612>>>>>>>>>>>>>>>            If (hHash) Begin
76614>>>>>>>>>>>>>>>                Get HashData hHash ucPassword to bOk
76615>>>>>>>>>>>>>>>                If (bOk) Begin
76617>>>>>>>>>>>>>>>                    Get piCipher to iAlgorithm
76618>>>>>>>>>>>>>>>                    Get DeriveKey hProv hHash to hKey
76619>>>>>>>>>>>>>>>                End
76619>>>>>>>>>>>>>>>>
76619>>>>>>>>>>>>>>>                Get DestroyHash hHash to bOk
76620>>>>>>>>>>>>>>>            End
76620>>>>>>>>>>>>>>>>
76620>>>>>>>>>>>>>>>            
76620>>>>>>>>>>>>>>>            If (hKey) Begin
76622>>>>>>>>>>>>>>>                Move (SizeOfArray(ucData)) to iDataLen
76623>>>>>>>>>>>>>>>                Move (CryptDecrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iDataLen))) to bOk
76624>>>>>>>>>>>>>>>                //  Resulting data can be shorter as the input string, in that case we shorten the result string
76624>>>>>>>>>>>>>>>                If (SizeOfArray (ucData) > iDataLen) Begin
76626>>>>>>>>>>>>>>>                    Move (ResizeArray(ucData, iDataLen)) to ucData
76627>>>>>>>>>>>>>>>                End
76627>>>>>>>>>>>>>>>>
76627>>>>>>>>>>>>>>>                
76627>>>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
76628>>>>>>>>>>>>>>>            End
76628>>>>>>>>>>>>>>>>
76628>>>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
76629>>>>>>>>>>>>>>>        End
76629>>>>>>>>>>>>>>>>
76629>>>>>>>>>>>>>>>        Function_Return ucData
76630>>>>>>>>>>>>>>>    End_Function
76631>>>>>>>>>>>>>>>    
76631>>>>>>>>>>>>>>>    // Creates a key
76631>>>>>>>>>>>>>>>    Function CreateKey Handle hProv Returns Handle
76633>>>>>>>>>>>>>>>        Integer iAlg iType iByte iLength iSize
76633>>>>>>>>>>>>>>>        CryptoBlob keyBlob
76633>>>>>>>>>>>>>>>        CryptoBlob keyBlob
76633>>>>>>>>>>>>>>>        Boolean bOk
76633>>>>>>>>>>>>>>>        Handle hKey
76633>>>>>>>>>>>>>>>        UChar[] aKey
76634>>>>>>>>>>>>>>>
76634>>>>>>>>>>>>>>>        Get paKey to aKey
76635>>>>>>>>>>>>>>>        Get piKeyAlg to iAlg
76636>>>>>>>>>>>>>>>        Get piKeyType to iType
76637>>>>>>>>>>>>>>>        Move iAlg                   to keyBlob.header.bType
76638>>>>>>>>>>>>>>>        Move CUR_BLOB_VERSION       to keyBlob.header.bVersion
76639>>>>>>>>>>>>>>>        Move iType                  to keyBlob.header.aiKeyAlg
76640>>>>>>>>>>>>>>>        Move (SizeOfArray(aKey))    to keyBlob.cbKeySize
76641>>>>>>>>>>>>>>>        
76641>>>>>>>>>>>>>>>        Move (SizeOfArray(aKey)-1) to iLength
76642>>>>>>>>>>>>>>>        For iByte from 0 to iLength
76648>>>>>>>>>>>>>>>>
76648>>>>>>>>>>>>>>>            Move aKey[iByte] to keyBlob.rgbKeyData[iByte]
76649>>>>>>>>>>>>>>>        Loop
76650>>>>>>>>>>>>>>>>
76650>>>>>>>>>>>>>>>        
76650>>>>>>>>>>>>>>>        Move 0 to hKey
76651>>>>>>>>>>>>>>>        Move (CryptImportKey(hProv,AddressOf(keyBlob),SizeOfType(CryptoBlob),0,0,AddressOf(hKey))) to bOk
76652>>>>>>>>>>>>>>>        Function_Return hKey
76653>>>>>>>>>>>>>>>    End_Function
76654>>>>>>>>>>>>>>>    
76654>>>>>>>>>>>>>>>    // Sets the key parameters
76654>>>>>>>>>>>>>>>    Function SetKeyParameters Handle hKey Returns Boolean
76656>>>>>>>>>>>>>>>        Integer iPadding iMode
76656>>>>>>>>>>>>>>>        Boolean bOk
76656>>>>>>>>>>>>>>>        UChar[] aIV
76657>>>>>>>>>>>>>>>        
76657>>>>>>>>>>>>>>>        //Move (SizeOfArray(aIV)-1) to iLength
76657>>>>>>>>>>>>>>>        //For iByte from 0 to iLength
76657>>>>>>>>>>>>>>>        //    Move iByte to aIV[iByte]
76657>>>>>>>>>>>>>>>        //Loop
76657>>>>>>>>>>>>>>>
76657>>>>>>>>>>>>>>>        // Set initialization vector
76657>>>>>>>>>>>>>>>        Get paIV to aIV
76658>>>>>>>>>>>>>>>        Move (CryptSetKeyParam(hKey,KP_IV,AddressOf(aIV),0)) to bOk
76659>>>>>>>>>>>>>>>        If (bOk) Begin
76661>>>>>>>>>>>>>>>            // Set padding
76661>>>>>>>>>>>>>>>            Get piKeyPadding to iPadding
76662>>>>>>>>>>>>>>>            Move (CryptSetKeyParam(hKey,KP_PADDING,AddressOf(iPadding),0)) to bOk
76663>>>>>>>>>>>>>>>            If (bOk) Begin
76665>>>>>>>>>>>>>>>                // Set move
76665>>>>>>>>>>>>>>>                Get piKeyMode to iMode
76666>>>>>>>>>>>>>>>                Move (CryptSetKeyParam(hKey,KP_MODE,AddressOf(iMode),0)) to bOk
76667>>>>>>>>>>>>>>>            End
76667>>>>>>>>>>>>>>>>
76667>>>>>>>>>>>>>>>        End
76667>>>>>>>>>>>>>>>>
76667>>>>>>>>>>>>>>>        Function_Return bOk        
76668>>>>>>>>>>>>>>>    End_Function
76669>>>>>>>>>>>>>>>    
76669>>>>>>>>>>>>>>>    // Encrypts using block cipher
76669>>>>>>>>>>>>>>>    Function BlockEncrypt UChar[] ucData Returns UChar[]
76671>>>>>>>>>>>>>>>        Handle hProv hKey
76671>>>>>>>>>>>>>>>        Integer iLen iSize iBlocks
76671>>>>>>>>>>>>>>>        Boolean bOk
76671>>>>>>>>>>>>>>>        
76671>>>>>>>>>>>>>>>        Get AcquireContext to hProv
76672>>>>>>>>>>>>>>>        If (hProv) Begin
76674>>>>>>>>>>>>>>>            // Create key
76674>>>>>>>>>>>>>>>            Get CreateKey hProv to hKey
76675>>>>>>>>>>>>>>>            If (hKey) Begin
76677>>>>>>>>>>>>>>>                Get SetKeyParameters hKey to bOk
76678>>>>>>>>>>>>>>>                If (bOk) Begin
76680>>>>>>>>>>>>>>>                    // Buffer for block ciphers can be up to block length larger
76680>>>>>>>>>>>>>>>                    Get piBlockSize to iSize
76681>>>>>>>>>>>>>>>                    Move (SizeOfArray(ucData)) to iLen
76682>>>>>>>>>>>>>>>                    
76682>>>>>>>>>>>>>>>                    Move ((iLen/iSize)+1) to iBlocks
76683>>>>>>>>>>>>>>>                    Move (ResizeArray(ucData,iBlocks*iSize)) to ucData
76684>>>>>>>>>>>>>>>                    Move (CryptEncrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iLen),SizeOfArray(ucData))) to bOk
76685>>>>>>>>>>>>>>>                End
76685>>>>>>>>>>>>>>>>
76685>>>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
76686>>>>>>>>>>>>>>>            End
76686>>>>>>>>>>>>>>>>
76686>>>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
76687>>>>>>>>>>>>>>>        End
76687>>>>>>>>>>>>>>>>
76687>>>>>>>>>>>>>>>        Function_Return ucData
76688>>>>>>>>>>>>>>>    End_Function
76689>>>>>>>>>>>>>>>    
76689>>>>>>>>>>>>>>>    // Decrypts using block cipher
76689>>>>>>>>>>>>>>>    Function BlockDecrypt UChar[] ucData Returns UChar[]
76691>>>>>>>>>>>>>>>        Handle hProv hKey
76691>>>>>>>>>>>>>>>        Integer iLen
76691>>>>>>>>>>>>>>>        Boolean bOk
76691>>>>>>>>>>>>>>>        
76691>>>>>>>>>>>>>>>        Get AcquireContext to hProv
76692>>>>>>>>>>>>>>>        If (hProv) Begin
76694>>>>>>>>>>>>>>>            // Create key
76694>>>>>>>>>>>>>>>            Get CreateKey hProv to hKey
76695>>>>>>>>>>>>>>>            If (hKey) Begin
76697>>>>>>>>>>>>>>>                Get SetKeyParameters hKey to bOk
76698>>>>>>>>>>>>>>>                If (bOk) Begin
76700>>>>>>>>>>>>>>>                    Move (SizeOfArray(ucData)) to iLen
76701>>>>>>>>>>>>>>>                    Move (CryptDecrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iLen))) to bOk
76702>>>>>>>>>>>>>>>                    Move (ResizeArray(ucData,iLen)) to ucData
76703>>>>>>>>>>>>>>>                End
76703>>>>>>>>>>>>>>>>
76703>>>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
76704>>>>>>>>>>>>>>>            End
76704>>>>>>>>>>>>>>>>
76704>>>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
76705>>>>>>>>>>>>>>>        End
76705>>>>>>>>>>>>>>>>
76705>>>>>>>>>>>>>>>        Function_Return ucData
76706>>>>>>>>>>>>>>>    End_Function
76707>>>>>>>>>>>>>>>    
76707>>>>>>>>>>>>>>>    
76707>>>>>>>>>>>>>>>    //  Generates random data.
76707>>>>>>>>>>>>>>>    Function GenerateRandom Integer iBytes Returns UChar[]
76709>>>>>>>>>>>>>>>        Handle hProv
76709>>>>>>>>>>>>>>>        UChar[] uaResult
76710>>>>>>>>>>>>>>>        Boolean bRes
76710>>>>>>>>>>>>>>>        
76710>>>>>>>>>>>>>>>        Get AcquireContext to hProv
76711>>>>>>>>>>>>>>>        
76711>>>>>>>>>>>>>>>        Move (ResizeArray(uaResult, iBytes)) to uaResult
76712>>>>>>>>>>>>>>>        Move (CryptGenRandom(hProv, iBytes, AddressOf(uaResult))) to bRes
76713>>>>>>>>>>>>>>>        
76713>>>>>>>>>>>>>>>        Get ReleaseContext hProv to bRes
76714>>>>>>>>>>>>>>>        
76714>>>>>>>>>>>>>>>        Function_Return uaResult
76715>>>>>>>>>>>>>>>    End_Function
76716>>>>>>>>>>>>>>>    
76716>>>>>>>>>>>>>>>    //  Generates random data and does a base64 encoding to properly present it as a string.
76716>>>>>>>>>>>>>>>    Function GenerateRandomString Integer iLength Returns String
76718>>>>>>>>>>>>>>>        String sResult
76718>>>>>>>>>>>>>>>        UChar[] ucData
76719>>>>>>>>>>>>>>>        Pointer pBase64
76719>>>>>>>>>>>>>>>        Integer iVoid
76719>>>>>>>>>>>>>>>        
76719>>>>>>>>>>>>>>>        Get GenerateRandom iLength to ucData
76720>>>>>>>>>>>>>>>        
76720>>>>>>>>>>>>>>>        Move (Base64Encode(AddressOf(ucData), iLength)) to pBase64
76721>>>>>>>>>>>>>>>        Move (PointerToString(pBase64)) to sResult
76722>>>>>>>>>>>>>>>        Move (Free(pBase64)) to iVoid
76723>>>>>>>>>>>>>>>        
76723>>>>>>>>>>>>>>>        Function_Return (Left(sResult, iLength))
76724>>>>>>>>>>>>>>>    End_Function
76725>>>>>>>>>>>>>>>    
76725>>>>>>>>>>>>>>>End_Class
76726>>>>>>>>>>>>>Use Base64Functions.pkg
Including file: Base64Functions.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\Base64Functions.pkg)
76726>>>>>>>>>>>>>>>//> This package enables base64 encoding and decoding of strings:
76726>>>>>>>>>>>>>>>//>
76726>>>>>>>>>>>>>>>//>     Get EncodeString of oBase64Functions sValue to sValue
76726>>>>>>>>>>>>>>>//>     Get DecodeString of oBase64Functions sValue to sValue
76726>>>>>>>>>>>>>>>//>
76726>>>>>>>>>>>>>>>//> Remember to set the "max argument size" if dealing with very large
76726>>>>>>>>>>>>>>>//> strings.
76726>>>>>>>>>>>>>>>//>
76726>>>>>>>>>>>>>>>//> For 17.1 and later the functionality of this package is based on two functions (Base64Encode and
76726>>>>>>>>>>>>>>>//> Base64Decode) that are built into the runtime.
76726>>>>>>>>>>>>>>>//>
76726>>>>>>>>>>>>>>>//> But for versions up to and including 17.0 it's based on the vdfBase64.dll file that was obtained
76726>>>>>>>>>>>>>>>//> from DAE that have kindly allowed me to distribute it to other DF developers. Programs including
76726>>>>>>>>>>>>>>>//> this package will give off an error on start-up if vdfBase64.dll is not found in the /bin folder
76726>>>>>>>>>>>>>>>//> if the VDF runtime. You will find the DLL in the /programs folder of the StureApsPublicLib workspace
76726>>>>>>>>>>>>>>>
76726>>>>>>>>>>>>>>>Use VdfBase.pkg
76726>>>>>>>>>>>>>>>
76726>>>>>>>>>>>>>>>// Functions in vdfBase64.dll
76726>>>>>>>>>>>>>>>External_Function xxBase64Encode "vdfbase64Encode" vdfBase64.dll Pointer pBuffer Returns Integer
76727>>>>>>>>>>>>>>>External_Function xxBase64Decode "vdfbase64Decode" vdfBase64.dll Pointer pBuffer Returns Integer
76728>>>>>>>>>>>>>>>External_Function xxBase64Free   "vdfbase64Free"   vdfBase64.dll Pointer pBuffer Returns Integer
76729>>>>>>>>>>>>>>>
76729>>>>>>>>>>>>>>>// Structure
76729>>>>>>>>>>>>>>>Struct txxfBase64Buffer
76729>>>>>>>>>>>>>>>    Pointer pData
76729>>>>>>>>>>>>>>>    Integer iLength
76729>>>>>>>>>>>>>>>End_Struct 
76729>>>>>>>>>>>>>>>
76729>>>>>>>>>>>>>>>Global_Variable Integer oBase64Functions
76729>>>>>>>>>>>>>>>
76729>>>>>>>>>>>>>>>Object _oBase64Functions is a cObject
76731>>>>>>>>>>>>>>>    Move Self to oBase64Functions
76732>>>>>>>>>>>>>>>
76732>>>>>>>>>>>>>>>
76732>>>>>>>>>>>>>>>    Function EncodeString String sValue Returns String
76735>>>>>>>>>>>>>>>        Address pBase64
76735>>>>>>>>>>>>>>>        String sResult
76735>>>>>>>>>>>>>>>        Integer iVoid
76735>>>>>>>>>>>>>>>        Move (Base64Encode(AddressOf(sValue), Length(sValue))) to pBase64
76736>>>>>>>>>>>>>>>        Move (PointerToString(pBase64)) to sResult
76737>>>>>>>>>>>>>>>        Move (Free(pBase64)) to iVoid
76738>>>>>>>>>>>>>>>        Function_Return sResult
76739>>>>>>>>>>>>>>>    End_Function
76740>>>>>>>>>>>>>>>
76740>>>>>>>>>>>>>>>    Function DecodeString String sValue Returns String
76743>>>>>>>>>>>>>>>        Address pBinary
76743>>>>>>>>>>>>>>>        String sBinary
76743>>>>>>>>>>>>>>>        Integer iVoid iLen
76743>>>>>>>>>>>>>>>        Move (Base64Decode(AddressOf(sValue), &iLen)) to pBinary
76744>>>>>>>>>>>>>>>        Move (Repeat(Character(0), iLen)) to sBinary
76745>>>>>>>>>>>>>>>        Move (MemCopy(AddressOf(sBinary), pBinary, iLen)) to iVoid
76746>>>>>>>>>>>>>>>        Move (Free(pBinary)) to iVoid
76747>>>>>>>>>>>>>>>        Function_Return sBinary
76748>>>>>>>>>>>>>>>    End_Function
76749>>>>>>>>>>>>>>>
76749>>>>>>>>>>>>>>>End_Object
76750>>>>>>>>>>>>>Use MSSqldrv.pkg
76750>>>>>>>>>>>>>Use db2_drv.pkg
76750>>>>>>>>>>>>>Use odbc_drv.pkg
76750>>>>>>>>>>>>>Use DFBtrDrv.pkg
76750>>>>>>>>>>>>>Use vWin32fh.pkg
76750>>>>>>>>>>>>>
76750>>>>>>>>>>>>>Use DUFLanguageConstants.inc
76750>>>>>>>>>>>>>
76750>>>>>>>>>>>>>
76750>>>>>>>>>>>>>// Create a new PSQL identifier for the Btrieve driver.
76750>>>>>>>>>>>>>    Define PSQLDRV_ID for "DFBTRDRV"
76750>>>>>>>>>>>>>
76750>>>>>>>>>>>>>// SQL Back-ends (iSQLDbType in the tSQLKeywords struct).
76750>>>>>>>>>>>>>// They can have slightly different SQL keywords.
76750>>>>>>>>>>>>>// Note: If a new type is added to the list,
76750>>>>>>>>>>>>>//       the struct array xxx must be adjusted
76750>>>>>>>>>>>>>//       so that it is filled with all SQL
76750>>>>>>>>>>>>>//       keywords for that new type.
76750>>>>>>>>>>>>>Enum_List  
76750>>>>>>>>>>>>>        Define EN_DbTypeDataFlex   for 0
76750>>>>>>>>>>>>>        Define EN_DbTypeMSSQL      for 1
76750>>>>>>>>>>>>>        Define EN_DbTypeMySQL      for 2
76750>>>>>>>>>>>>>        Define EN_DbTypeOracle     for 3
76750>>>>>>>>>>>>>        Define EN_DbTypeDB2        for 4
76750>>>>>>>>>>>>>        Define EN_DbTypePostgre    for 5
76750>>>>>>>>>>>>>        Define EN_DbTypePervasive  for 6
76750>>>>>>>>>>>>>End_Enum_List
76750>>>>>>>>>>>>>
76750>>>>>>>>>>>>>// We need to have our "own" constants for the standard DataFlex data types.
76750>>>>>>>>>>>>>// These can be used with SQL functions such as e.g. SQLColumnAdd, instead
76750>>>>>>>>>>>>>// of using one of the driver specific integer constants such as e.g. "SQL_VARCHAR".
76750>>>>>>>>>>>>>Define CS_DbTypeDataFlex    for "DataFlex Embedded"
76750>>>>>>>>>>>>>Define CS_DbTypeMSSQL       for "Microsoft SQL Server"
76750>>>>>>>>>>>>>Define CS_DbTypeMySQL       for "MySQL"
76750>>>>>>>>>>>>>Define CS_DbTypeOracle      for "Oracle"
76750>>>>>>>>>>>>>Define CS_DbTypeDB2         for "IBM DB2"
76750>>>>>>>>>>>>>Define CS_DbTypePostgre     for "PostgreSQL"
76750>>>>>>>>>>>>>Define CS_DbTypePervasive   for "Pervasive.SQL (Btrieve)"
76750>>>>>>>>>>>>>
76750>>>>>>>>>>>>>
76750>>>>>>>>>>>>>// SQLConnection.ini constants:
76750>>>>>>>>>>>>>    Define CS_SQLConnectionIDText       for "DFConnectionId"
76750>>>>>>>>>>>>>
76750>>>>>>>>>>>>>Define CS_SQLIniFileName                for "SQLConnections.ini"
76750>>>>>>>>>>>>>Define CS_SQLDF19IniFileName            for "DFConnId.ini"
76750>>>>>>>>>>>>>Define CS_SQLIniConnectionSection       for "SQL Connections" // Obsolete!
76750>>>>>>>>>>>>>Define CS_SQLIniSectionName             for "Connection"
76750>>>>>>>>>>>>>Define CS_SQLODBCIniSectionName         for "ODBC"
76750>>>>>>>>>>>>>
76750>>>>>>>>>>>>>// DF 19 ini-file settings:
76750>>>>>>>>>>>>>Define CS_SQLIniConnectionIdKeyword     for "Id"
76750>>>>>>>>>>>>>Define CS_SQLIniDriverKeyword           for "Driver"
76750>>>>>>>>>>>>>Define CS_SQLIniConnectionKeyWord       for "Connection"
76750>>>>>>>>>>>>>Define CS_SQLIniUIDKeyword              for "UID"
76750>>>>>>>>>>>>>Define CS_SQLIniPWDKeyword              for "PWD"
76750>>>>>>>>>>>>>Define CS_SQLIniDFPWDKeyword            for "DFPWD"
76750>>>>>>>>>>>>>Define CS_SQLIniServerKeyword           for "SERVER"
76750>>>>>>>>>>>>>Define CS_SQLIniDSNKeyword              for "DSN"
76750>>>>>>>>>>>>>Define CS_SQLIniFileDSNKeyword          for "FILEDSN"
76750>>>>>>>>>>>>>Define CS_SQLIniDatabaseKeyword         for "DATABASE"
76750>>>>>>>>>>>>>Define CS_SQLIniTrustedKeyword          for "Trusted_Connection" 
76750>>>>>>>>>>>>>Define CS_SQLIniDisabledKeyword         for "Disabled"
76750>>>>>>>>>>>>>
76750>>>>>>>>>>>>>// Database Update Framework extended settings:
76750>>>>>>>>>>>>>Define CS_SQLIniDbTypeKeyword           for "DbType"
76750>>>>>>>>>>>>>Define CS_SQLIniSchemaKeyword           for "Schema"
76750>>>>>>>>>>>>>Define CS_SQLIniBaseTableSpaceKeyword   for "Base Table Space"
76750>>>>>>>>>>>>>Define CS_SQLIniLongTableSpaceKeyword   for "Long Table Space"
76750>>>>>>>>>>>>>Define CS_SQLIniIndexTableSpaceKeyword  for "Index Table Space"
76750>>>>>>>>>>>>>Define CS_SQLIniSilentLoginKeyword      for "Silent Login"
76750>>>>>>>>>>>>>Define CS_SQLIniDisabledKeyword         for "Disabled"      // For compatability with DF19.
76750>>>>>>>>>>>>>
76750>>>>>>>>>>>>>Define CS_SQLIniConnectionPWD           for "PWD"
76750>>>>>>>>>>>>>Define CS_SQLIniConnectionYes           for "Yes"
76750>>>>>>>>>>>>>Define CS_SQLIniConnectionNo            for "No"
76750>>>>>>>>>>>>>
76750>>>>>>>>>>>>>Struct tSQLConnection
76750>>>>>>>>>>>>>    Boolean bEnabled                // 1. There can only be one active/enabled connection at a time.
76750>>>>>>>>>>>>>    String sConnectionID            // 2. The name of the connection ID.
76750>>>>>>>>>>>>>    Integer iDbType                 // 3. Database type; "MS-SQL Server", "DB2", "Oracle", "MySQL", "PostgreSQL"
76750>>>>>>>>>>>>>    String sDriverID                // 4. Name of the driver. E.g. MSSQLDRV, DB2_DRV, ODBC_DRV or PSQLDRV_ID.
76750>>>>>>>>>>>>>    String sServer                  // 5. SQL Server/DSN/ODBC source name. (In DF19 this is the "sString" member of the tConnection struct.)
76750>>>>>>>>>>>>>    String sDatabase                // 6. SQL Database
76750>>>>>>>>>>>>>    String sConnectionString        // 7. Full connection string as is needed by e.g. the login command.
76750>>>>>>>>>>>>>    Boolean bTrusted                // 8. Trusted connection (then is UID & PWD not used)
76750>>>>>>>>>>>>>    String sUserID                  // 9. User ID
76750>>>>>>>>>>>>>    String sPassword                // 10. Password
76750>>>>>>>>>>>>>    String sSchema                  // 11. DB2 (and perhaps ODBC specific)
76750>>>>>>>>>>>>>    String sBaseTableSpace          // 12. DB2 specific
76750>>>>>>>>>>>>>    String sLongTableSpace          // 13. DB2 specific
76750>>>>>>>>>>>>>    String sIndexTableSpace         // 14. DB2 specific
76750>>>>>>>>>>>>>    Boolean bSilentLogin            // 15. True=Silent login. (i.e. don't show Database login dialog if database login to fails). Same as driver "Options" parameter.
76750>>>>>>>>>>>>>    Boolean bError                  // 16. Set to true on error.
76750>>>>>>>>>>>>>    Boolean bDAWConnection          // 17. True if a DFConnId.ini file (from DAW) has been used instead of a DUF SQLConnections.ini file.
76750>>>>>>>>>>>>>End_Struct
76750>>>>>>>>>>>Use cDbUpdateFunctionLibrary.inc
Including file: cDbUpdateFunctionLibrary.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary.inc)
76750>>>>>>>>>>>>>Use DUFLanguageConstants.inc
76750>>>>>>>>>>>>>
76750>>>>>>>>>>>>>Register_Function paSQLQueryMessages Returns String[]
76750>>>>>>>>>>>>>Register_Procedure Set paSQLQueryMessages String[] aSQLQueryMessages
76750>>>>>>>>>>>>>
76750>>>>>>>>>>>>>
76750>>>>>>>>>>>>>
76750>>>>>>>>>>>>>    Define CS_OEM_Txt for "OEM"
76750>>>>>>>>>>>>>
76750>>>>>>>>>>>>>    Define CS_ANSI_Txt for "ANSI"
76750>>>>>>>>>>>>>
76750>>>>>>>>>>>>>    Define CS_DFCONNID for "DFCONNID"
76750>>>>>>>>>>>>>
76750>>>>>>>>>>>>>    Define CS_SERVER for "SERVER"
76750>>>>>>>>>>>>>
76750>>>>>>>>>>>>>    Define CS_SERVER_NAME for "SERVER_NAME"
76750>>>>>>>>>>>>>
76750>>>>>>>>>>>>>    Define CS_DRIVER_NAME for "DRIVER_NAME"
76750>>>>>>>>>>>>>
76750>>>>>>>>>>>>>    Define CS_DATABASE_NAME for "DATABASE_NAME"
76750>>>>>>>>>>>>>
76750>>>>>>>>>>>>>    Define CS_SCHEMA_NAME for "SCHEMA_NAME"
76750>>>>>>>>>>>>>
76750>>>>>>>>>>>>>    Define CS_TABLE_CHARACTER_FORMAT for "TABLE_CHARACTER_FORMAT"
76750>>>>>>>>>>>>>
76750>>>>>>>>>>>>>    Define CS_USE_DUMMY_ZERO_DATE for "USE_DUMMY_ZERO_DATE"
76750>>>>>>>>>>>>>
76750>>>>>>>>>>>>>    Define CS_SYSTEM_FILE for "SYSTEM_FILE"
76750>>>>>>>>>>>>>
76750>>>>>>>>>>>>>    Define CS_RECNUM_TABLE for "RECNUM_TABLE"
76750>>>>>>>>>>>>>
76750>>>>>>>>>>>>>    Define CS_PRIMARY_INDEX for "PRIMARY_INDEX"
76750>>>>>>>>>>>>>
76750>>>>>>>>>>>>>    Define CS_INDEX_NUMBER for "INDEX_NUMBER"
76750>>>>>>>>>>>>>
76750>>>>>>>>>>>>>    Define CS_INDEX_NAME for "INDEX_NAME"
76750>>>>>>>>>>>>>
76750>>>>>>>>>>>>>    Define CS_DUFLowestAllowedDateValue for "01/01/1753"
76750>>>>>>>>>>>>>    Define CS_DUFLowestSQLDateValue     for "1753-01-01"
76750>>>>>>>>>>>>>
76750>>>>>>>>>>>>>    Define CS_DUFBackupDataFolder for "BackupData"
76750>>>>>>>>>>>>>
76750>>>>>>>>>>>>>// Global handle to a cDatabaseUpdateHandler object
76750>>>>>>>>>>>>>
76750>>>>>>>>>>>>>    Global_Variable Handle ghoDbUpdateFunctionLibrary  
76750>>>>>>>>>>>>>    Move 0 to ghoDbUpdateFunctionLibrary
76751>>>>>>>>>>>>>
76751>>>>>>>>>>>>>Struct tSQLScriptArray
76751>>>>>>>>>>>>>    Boolean bError
76751>>>>>>>>>>>>>    Boolean bArgumentSizeChanged
76751>>>>>>>>>>>>>    Integer iOrgArgumentSize
76751>>>>>>>>>>>>>    String[] sSQLScriptArray
76751>>>>>>>>>>>>>End_Struct
76751>>>>>>>>>>>>>
76751>>>>>>>>>>>>>Struct tSqlErrorArray
76751>>>>>>>>>>>>>    String[]  sSqlErrorArray
76751>>>>>>>>>>>>>    String[]  sSqlStatementArray
76751>>>>>>>>>>>>>    Integer[] iSqlErrorArray
76751>>>>>>>>>>>>>End_Struct
76751>>>>>>>>>>>>>
76751>>>>>>>>>>>>>Struct tSqlColumnNew
76751>>>>>>>>>>>>>    String  sBaseColumnName
76751>>>>>>>>>>>>>    String  sBaseTableName
76751>>>>>>>>>>>>>    String  sLabel
76751>>>>>>>>>>>>>    Integer iSqlType
76751>>>>>>>>>>>>>    Integer iSize
76751>>>>>>>>>>>>>    Integer iPrecision
76751>>>>>>>>>>>>>    Integer iDFType
76751>>>>>>>>>>>>>    Integer iDFNativeType
76751>>>>>>>>>>>>>End_Struct
76751>>>>>>>>>>>>>
76751>>>>>>>>>>>>>Struct tColumnType
76751>>>>>>>>>>>>>    String  sSQLType
76751>>>>>>>>>>>>>    Integer iSQLType
76751>>>>>>>>>>>>>    Boolean bCanEditSize
76751>>>>>>>>>>>>>    Integer iDefaultSize
76751>>>>>>>>>>>>>    Integer iMinSize
76751>>>>>>>>>>>>>    Number  nMaxSize
76751>>>>>>>>>>>>>    String  sDataFlexType
76751>>>>>>>>>>>>>    Integer iDataFlexType
76751>>>>>>>>>>>>>    Boolean bNativeDataType
76751>>>>>>>>>>>>>    String  sPrecision
76751>>>>>>>>>>>>>End_Struct
76751>>>>>>>>>>>>>
76751>>>>>>>>>>>>>// Used to store/retreive SQL keywords in a struct array.
76751>>>>>>>>>>>>>// Various SQL back-ends can have slightly different
76751>>>>>>>>>>>>>// keywords.
76751>>>>>>>>>>>>>Struct tSQLKeyWords
76751>>>>>>>>>>>>>    Integer iSQLWord
76751>>>>>>>>>>>>>    Integer iSQLDbType
76751>>>>>>>>>>>>>    String  sSQLPhrase // Can be more than one word.
76751>>>>>>>>>>>>>End_Struct
76751>>>>>>>>>>>>>
76751>>>>>>>>>>>>>Struct tSQLRelation
76751>>>>>>>>>>>>>    Integer iFileNumber
76751>>>>>>>>>>>>>    Integer iFieldNumber
76751>>>>>>>>>>>>>    String  sFileName
76751>>>>>>>>>>>>>    String  sFieldName
76751>>>>>>>>>>>>>End_Struct
76751>>>>>>>>>>>>>
76751>>>>>>>>>>>>>Struct tSQLLoggedInUser
76751>>>>>>>>>>>>>    String sUser
76751>>>>>>>>>>>>>    String sProgram
76751>>>>>>>>>>>>>End_Struct
76751>>>>>>>>>>>>>
76751>>>>>>>>>>>>>// Used as a start for error handing. Used by Error_Report_Mode property
76751>>>>>>>>>>>>>
76751>>>>>>>>>>>>>// We need to re-define the standard constants because several driver constants
76751>>>>>>>>>>>>>// have the same value and we need to be able to distinguish which data type to use when
76751>>>>>>>>>>>>>// SQL Back-ends (iSQLDbType in the tSQLKeywords struct).
76751>>>>>>>>>>>>>// They can have slightly different SQL keywords.
76751>>>>>>>>>>>>>// Note: If a new type is added to the list,
76751>>>>>>>>>>>>>//       the struct array xxx must be adjusted
76751>>>>>>>>>>>>>//       so that it is filled with all SQL
76751>>>>>>>>>>>>>//       keywords for that new type.
76751>>>>>>>>>>>>>Enum_List
76751>>>>>>>>>>>>>//    Define EN_DbTypeMSSQL
76751>>>>>>>>>>>>>//    Define EN_DbTypeMySQL
76751>>>>>>>>>>>>>//    Define EN_DbTypeOracle
76751>>>>>>>>>>>>>//    Define EN_DbTypeDB2
76751>>>>>>>>>>>>>//    Define EN_DbTypePostgre
76751>>>>>>>>>>>>>//    Define EN_DbTypeDataFlex // Embedded database.
76751>>>>>>>>>>>>>End_Enum_List
76751>>>>>>>>>>>>>
76751>>>>>>>>>>>>>// We need to have our "own" constants for the standard DataFlex data types.
76751>>>>>>>>>>>>>// These can be used with SQL functions such as e.g. SQLColumnAdd, instead
76751>>>>>>>>>>>>>// of using one of the driver specific integer constants such as e.g. "SQL_VARCHAR".
76751>>>>>>>>>>>>>Define CS_DbTypeMSSQL       for "Microsoft SQL Server"
76751>>>>>>>>>>>>>Define CS_DbTypeMySQL       for "MySQL"
76751>>>>>>>>>>>>>Define CS_DbTypeOracle      for "Oracle"
76751>>>>>>>>>>>>>Define CS_DbTypeDB2         for "IBM DB2"
76751>>>>>>>>>>>>>Define CS_DbTypePostgre     for "PostgreSQL"
76751>>>>>>>>>>>>>Define CS_DbTypeDataFlex    for "DataFlex Embedded"
76751>>>>>>>>>>>>>
76751>>>>>>>>>>>>>// We need to re-define the standard constants because several driver constants
76751>>>>>>>>>>>>>// have the same value and we need to be able to distinguish which data type to use when
76751>>>>>>>>>>>>>// e.g. creating a column with embedded SQL (ESQL).
76751>>>>>>>>>>>>>Enum_List
76751>>>>>>>>>>>>>    Define DF_ASCII_DUF     for -1500 // All of these are DF_xxx constant values - 1500
76751>>>>>>>>>>>>>    Define DF_BCD_DUF       for -1499
76751>>>>>>>>>>>>>    Define DF_DATE_DUF      for -1498
76751>>>>>>>>>>>>>    Define DF_TEXT_DUF      for -1495
76751>>>>>>>>>>>>>    Define DF_BINARY_DUF    for -1494
76751>>>>>>>>>>>>>    Define DF_DATETIME_DUF  for -1493
76751>>>>>>>>>>>>>End_Enum_List
76751>>>>>>>>>>>>>
76751>>>>>>>>>>>>>    Define SQL_TEXT for (DF_TEXT + 1024)
76751>>>>>>>>>>>>>
76751>>>>>>>>>>>>>Define SQL_CHARBIT          for (DF_BINARY + 1024)
76751>>>>>>>>>>>>>Define SQL_LONGVARCHARBIT   for (DF_BINARY + 1025)
76751>>>>>>>>>>>>>Define SQL_VARCHARBIT       for (DF_BINARY + 1026)
76751>>>>>>>>>>>>>
76751>>>>>>>>>>>>>// These are not defined pre DF 18:
76751>>>>>>>>>>>>>
76751>>>>>>>>>>>>>Struct tSQLIntTableInfo
76751>>>>>>>>>>>>>    String sDriverName
76751>>>>>>>>>>>>>    String sServerName
76751>>>>>>>>>>>>>    String sDatabaseName
76751>>>>>>>>>>>>>    String sSchemaName
76751>>>>>>>>>>>>>    Boolean bRecnumTable
76751>>>>>>>>>>>>>    Integer iPrimaryIndex
76751>>>>>>>>>>>>>    Integer iGenerateRecordIdMethod  // RIM_NONE, RIM_IDENTITY_COLUMN,  RIM_DISPENSER_TABLE, RIM_EXTERNAL
76751>>>>>>>>>>>>>    String sTableCharacterFormat
76751>>>>>>>>>>>>>    Boolean bUseDummyZeroDate
76751>>>>>>>>>>>>>    Integer iFileDummyUpdateColumn // Init value to -1 if not exists (value can be in range 1 - number of columns)
76751>>>>>>>>>>>>>    Integer iFileBlockSize         // Init value to -1 if not exists
76751>>>>>>>>>>>>>    Integer iFileMaxRowsFetched    // Init value to -1 if not exists
76751>>>>>>>>>>>>>    Integer iFileGetRidAfterCreate // Init value to -1. But is boolean!
76751>>>>>>>>>>>>>    Integer iFileJitBinding        // Init value to -1. But is boolean!
76751>>>>>>>>>>>>>    String sRefindAfterSave        // Yes or No (how to handle?)
76751>>>>>>>>>>>>>    String sSystemFile             // Yes or No (how to handle?)
76751>>>>>>>>>>>>>    String sFileIndexTablespace
76751>>>>>>>>>>>>>    String sFileLongTablespace
76751>>>>>>>>>>>>>    String sTableTablespace
76751>>>>>>>>>>>>>End_Struct
76751>>>>>>>>>>>>>
76751>>>>>>>>>>>>>Struct tSQLIntColumnInfo
76751>>>>>>>>>>>>>    Integer iFieldNumber
76751>>>>>>>>>>>>>    Integer iFieldIndex
76751>>>>>>>>>>>>>    Integer iFieldRelatedFile
76751>>>>>>>>>>>>>    Integer iFieldRelatedField
76751>>>>>>>>>>>>>    Integer iIndexNumber
76751>>>>>>>>>>>>>    Integer iIndexNumberSegments
76751>>>>>>>>>>>>>    Integer iIndexSegmentField1
76751>>>>>>>>>>>>>    Integer iIndexSegmentField2
76751>>>>>>>>>>>>>    Integer iIndexSegmentFieldn
76751>>>>>>>>>>>>>    String  sIndexName
76751>>>>>>>>>>>>>End_Struct
76751>>>>>>>>>>>>>
76751>>>>>>>>>>>>>Struct tAPIColumn
76751>>>>>>>>>>>>>    Integer iFieldNumber
76751>>>>>>>>>>>>>    String  sFieldName
76751>>>>>>>>>>>>>    Integer iType
76751>>>>>>>>>>>>>    String  sType
76751>>>>>>>>>>>>>    Integer iLength
76751>>>>>>>>>>>>>    Integer iPrecision
76751>>>>>>>>>>>>>    Integer iOptions
76751>>>>>>>>>>>>>    Boolean bIsSQLType
76751>>>>>>>>>>>>>    Boolean bAllowNULL
76751>>>>>>>>>>>>>    String  sDefaultValue
76751>>>>>>>>>>>>>    Boolean bShouldChange
76751>>>>>>>>>>>>>    Boolean bCancel
76751>>>>>>>>>>>>>    Boolean bError
76751>>>>>>>>>>>>>End_Struct
76751>>>>>>>>>>>>>
76751>>>>>>>>>>>>>Struct tAPIColumnCompare
76751>>>>>>>>>>>>>    Integer iFieldNumber
76751>>>>>>>>>>>>>    // FROM database:
76751>>>>>>>>>>>>>    Boolean bExistsFrom
76751>>>>>>>>>>>>>    String  sFieldNameFrom
76751>>>>>>>>>>>>>    Integer iTypeFrom
76751>>>>>>>>>>>>>    String  sTypeFrom
76751>>>>>>>>>>>>>    Integer iLengthFrom
76751>>>>>>>>>>>>>    Integer iPrecisionFrom
76751>>>>>>>>>>>>>    Integer iOptionsFrom
76751>>>>>>>>>>>>>    Boolean bIsSQLTypeFrom
76751>>>>>>>>>>>>>    Boolean bAllowNULLFrom
76751>>>>>>>>>>>>>    String  sDefaultValueFrom
76751>>>>>>>>>>>>>    Boolean bShouldChangeFrom
76751>>>>>>>>>>>>>    Boolean bCancelFrom
76751>>>>>>>>>>>>>    Boolean bErrorFrom
76751>>>>>>>>>>>>>    // TO database:
76751>>>>>>>>>>>>>    Boolean bExistsTo
76751>>>>>>>>>>>>>    Integer iFieldNumberTo
76751>>>>>>>>>>>>>    String  sFieldNameTo
76751>>>>>>>>>>>>>    Integer iTypeTo
76751>>>>>>>>>>>>>    String  sTypeTo
76751>>>>>>>>>>>>>    Integer iLengthTo
76751>>>>>>>>>>>>>    Integer iPrecisionTo
76751>>>>>>>>>>>>>    Integer iOptionsTo
76751>>>>>>>>>>>>>    Boolean bIsSQLTypeTo
76751>>>>>>>>>>>>>    Boolean bAllowNULLTo
76751>>>>>>>>>>>>>    String  sDefaultValueTo
76751>>>>>>>>>>>>>    Boolean bShouldChangeTo
76751>>>>>>>>>>>>>    Boolean bCancelTo
76751>>>>>>>>>>>>>    Boolean bErrorTo
76751>>>>>>>>>>>>>End_Struct
76751>>>>>>>>>>>>>
76751>>>>>>>>>>>>>Struct tAPIRelation
76751>>>>>>>>>>>>>    Handle  hTableFrom
76751>>>>>>>>>>>>>    Integer iColumnFrom
76751>>>>>>>>>>>>>    Handle  hTableTo
76751>>>>>>>>>>>>>    Integer iColumnTo
76751>>>>>>>>>>>>>    String  sLogicalNameFrom
76751>>>>>>>>>>>>>    String  sLogicalNameTo
76751>>>>>>>>>>>>>    String  sFieldNameFrom
76751>>>>>>>>>>>>>    String  sFieldNameTo
76751>>>>>>>>>>>>>    Boolean bShouldChange
76751>>>>>>>>>>>>>    Boolean bCancel
76751>>>>>>>>>>>>>    Boolean bError
76751>>>>>>>>>>>>>End_Struct
76751>>>>>>>>>>>>>
76751>>>>>>>>>>>>>Struct tAPIRelationCompare
76751>>>>>>>>>>>>>    // Common:
76751>>>>>>>>>>>>>    Handle  hTableFrom
76751>>>>>>>>>>>>>    Integer iColumnFrom
76751>>>>>>>>>>>>>    Handle  hTableTo
76751>>>>>>>>>>>>>    Integer iColumnTo
76751>>>>>>>>>>>>>    // FROM database:
76751>>>>>>>>>>>>>    Boolean bExistsFrom
76751>>>>>>>>>>>>>    String  sLogicalNameFrom_From
76751>>>>>>>>>>>>>    String  sLogicalNameTo_From
76751>>>>>>>>>>>>>    String  sFieldNameFrom_From
76751>>>>>>>>>>>>>    String  sFieldNameTo_From
76751>>>>>>>>>>>>>    Boolean bShouldChange_From
76751>>>>>>>>>>>>>    Boolean bCancel_From
76751>>>>>>>>>>>>>    Boolean bError_From
76751>>>>>>>>>>>>>    // TO database:
76751>>>>>>>>>>>>>    Boolean bExistsTo
76751>>>>>>>>>>>>>    String  sLogicalNameFrom_To
76751>>>>>>>>>>>>>    String  sLogicalNameTo_To
76751>>>>>>>>>>>>>    String  sFieldNameFrom_To
76751>>>>>>>>>>>>>    String  sFieldNameTo_To
76751>>>>>>>>>>>>>    Boolean bShouldChange_To
76751>>>>>>>>>>>>>    Boolean bCancel_To
76751>>>>>>>>>>>>>    Boolean bError_To
76751>>>>>>>>>>>>>End_Struct
76751>>>>>>>>>>>>>
76751>>>>>>>>>>>>>Struct tAPIIndexSegment
76751>>>>>>>>>>>>>    Integer iFieldNumber
76751>>>>>>>>>>>>>    String  sFieldName
76751>>>>>>>>>>>>>    Boolean bUppercase
76751>>>>>>>>>>>>>    Boolean bAscending
76751>>>>>>>>>>>>>    Boolean bShouldChange
76751>>>>>>>>>>>>>    Boolean bCancel
76751>>>>>>>>>>>>>    Boolean bError
76751>>>>>>>>>>>>>End_Struct
76751>>>>>>>>>>>>>
76751>>>>>>>>>>>>>Struct tAPIIndex
76751>>>>>>>>>>>>>    Integer iIndexNumber
76751>>>>>>>>>>>>>    Integer iPrimaryIndex
76751>>>>>>>>>>>>>    String  sSQLIndexName
76751>>>>>>>>>>>>>    Integer iSQLIndexType
76751>>>>>>>>>>>>>    Boolean bIsSQLClustered
76751>>>>>>>>>>>>>    Boolean bIsSQLPrimaryKey
76751>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArray
76751>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArray
76751>>>>>>>>>>>>>    Boolean bShouldChange
76751>>>>>>>>>>>>>    Boolean bCancel
76751>>>>>>>>>>>>>    Boolean bError
76751>>>>>>>>>>>>>End_Struct
76751>>>>>>>>>>>>>
76751>>>>>>>>>>>>>Struct tAPIIndexCompare
76751>>>>>>>>>>>>>    // Common:
76751>>>>>>>>>>>>>    Integer iIndexNumber
76751>>>>>>>>>>>>>    // FROM database:
76751>>>>>>>>>>>>>    Boolean bExistsFrom
76751>>>>>>>>>>>>>    Integer iPrimaryIndexFrom
76751>>>>>>>>>>>>>    String  sSQLIndexNameFrom
76751>>>>>>>>>>>>>    Integer iSQLIndexTypeFrom
76751>>>>>>>>>>>>>    Boolean bIsSQLClusteredFrom
76751>>>>>>>>>>>>>    Boolean bIsSQLPrimaryKeyFrom
76751>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayFrom
76751>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayFrom
76751>>>>>>>>>>>>>    Boolean bShouldChangeFrom
76751>>>>>>>>>>>>>    Boolean bCancelFrom
76751>>>>>>>>>>>>>    Boolean bErrorFrom
76751>>>>>>>>>>>>>    // TO database:
76751>>>>>>>>>>>>>    Boolean bExistsTo
76751>>>>>>>>>>>>>    Integer iPrimaryIndexTo
76751>>>>>>>>>>>>>    String  sSQLIndexNameTo
76751>>>>>>>>>>>>>    Integer iSQLIndexTypeTo
76751>>>>>>>>>>>>>    Boolean bIsSQLClusteredTo
76751>>>>>>>>>>>>>    Boolean bIsSQLPrimaryKeyTo
76751>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayTo
76751>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayTo
76751>>>>>>>>>>>>>    Boolean bShouldChangeTo
76751>>>>>>>>>>>>>    Boolean bCancelTo
76751>>>>>>>>>>>>>    Boolean bErrorTo
76751>>>>>>>>>>>>>End_Struct
76751>>>>>>>>>>>>>
76751>>>>>>>>>>>>>Struct tAPITableNameInfo
76751>>>>>>>>>>>>>    Integer iTableNumber
76751>>>>>>>>>>>>>    String  sRootName
76751>>>>>>>>>>>>>    String  sLogicalName
76751>>>>>>>>>>>>>    String  sDisplayName
76751>>>>>>>>>>>>>    String  sDriverID
76751>>>>>>>>>>>>>    Boolean bIsAlias
76751>>>>>>>>>>>>>    Boolean bIsSQL
76751>>>>>>>>>>>>>    Boolean bIsSystemFile
76751>>>>>>>>>>>>>    Boolean bShouldChange
76751>>>>>>>>>>>>>    Boolean bCancel
76751>>>>>>>>>>>>>    Boolean bError
76751>>>>>>>>>>>>>End_Struct
76751>>>>>>>>>>>>>
76751>>>>>>>>>>>>>Struct tAPITableNameInfoCompare
76751>>>>>>>>>>>>>    Integer iTableNumber
76751>>>>>>>>>>>>>    // FROM
76751>>>>>>>>>>>>>    Boolean bExistsFrom
76751>>>>>>>>>>>>>    String  sRootNameFrom
76751>>>>>>>>>>>>>    String  sLogicalNameFrom
76751>>>>>>>>>>>>>    String  sDisplayNameFrom
76751>>>>>>>>>>>>>    String  sDriverIDFrom
76751>>>>>>>>>>>>>    Boolean bIsAliasFrom
76751>>>>>>>>>>>>>    Boolean bIsSQLFrom
76751>>>>>>>>>>>>>    Boolean bIsSystemFileFrom
76751>>>>>>>>>>>>>    // TO database:
76751>>>>>>>>>>>>>    Boolean bExistsTo
76751>>>>>>>>>>>>>    String  sRootNameTo
76751>>>>>>>>>>>>>    String  sLogicalNameTo
76751>>>>>>>>>>>>>    String  sDisplayNameTo
76751>>>>>>>>>>>>>    String  sDriverIDTo
76751>>>>>>>>>>>>>    Boolean bIsAliasTo
76751>>>>>>>>>>>>>    Boolean bIsSQLTo
76751>>>>>>>>>>>>>    Boolean bIsSystemFileTo // *** Implement!
76751>>>>>>>>>>>>>    Boolean bShouldChange
76751>>>>>>>>>>>>>    Boolean bCancel
76751>>>>>>>>>>>>>    Boolean bError
76751>>>>>>>>>>>>>End_Struct
76751>>>>>>>>>>>>>
76751>>>>>>>>>>>>>Struct tAPITable
76751>>>>>>>>>>>>>    Handle hTable
76751>>>>>>>>>>>>>    Boolean bFromTable
76751>>>>>>>>>>>>>    Boolean bToTable
76751>>>>>>>>>>>>>    tAPITableNameInfo ApiTableInfo
76751>>>>>>>>>>>>>    tAPITableNameInfo ApiTableInfo
76751>>>>>>>>>>>>>    tAPIColumn[]      aApiColumns
76751>>>>>>>>>>>>>    tAPIColumn[]      aApiColumns
76751>>>>>>>>>>>>>    tAPIIndex[]       aApiIndexes
76751>>>>>>>>>>>>>    tAPIIndex[]       aApiIndexes
76751>>>>>>>>>>>>>    tAPIRelation[]    aApiRelations
76751>>>>>>>>>>>>>    tAPIRelation[]    aApiRelations
76751>>>>>>>>>>>>>    Boolean bShouldChange
76751>>>>>>>>>>>>>    Boolean bCancel
76751>>>>>>>>>>>>>    Boolean bError
76751>>>>>>>>>>>>>End_Struct
76751>>>>>>>>>>>>>
76751>>>>>>>>>>>>>Struct tAPITableCompare
76751>>>>>>>>>>>>>    Handle hTable
76751>>>>>>>>>>>>>    // FROM database:
76751>>>>>>>>>>>>>    Boolean bExistsFrom
76751>>>>>>>>>>>>>    // TO database:
76751>>>>>>>>>>>>>    Boolean bExistsTo
76751>>>>>>>>>>>>>    // Both:
76751>>>>>>>>>>>>>    tAPITableNameInfoCompare APITableNameInfoCompare
76751>>>>>>>>>>>>>    tAPITableNameInfoCompare APITableNameInfoCompare
76751>>>>>>>>>>>>>    tAPIColumnCompare[]     aAPIColumnsCompare
76751>>>>>>>>>>>>>    tAPIColumnCompare[]     aAPIColumnsCompare
76751>>>>>>>>>>>>>    tAPIIndexCompare[]      aAPIIndexesCompare
76751>>>>>>>>>>>>>    tAPIIndexCompare[]      aAPIIndexesCompare
76751>>>>>>>>>>>>>    tAPIRelationCompare[]   aAPIRelationsCompare
76751>>>>>>>>>>>>>    tAPIRelationCompare[]   aAPIRelationsCompare
76751>>>>>>>>>>>>>    Boolean bShouldChange   // Not implemented yet (!)
76751>>>>>>>>>>>>>    Boolean bCancel         // User cancel
76751>>>>>>>>>>>>>    Boolean bError          // Error occured while collecting data
76751>>>>>>>>>>>>>End_Struct
76751>>>>>>>>>>>>>
76751>>>>>>>>>>>>>Struct tAPITableBooleans
76751>>>>>>>>>>>>>    Boolean bApiTableUpdateAuto
76751>>>>>>>>>>>>>    Boolean bCompareDate_DateTime
76751>>>>>>>>>>>>>    Boolean bCompareIndexAscending
76751>>>>>>>>>>>>>    Boolean bCompareIndexUppercase
76751>>>>>>>>>>>>>    Boolean bCompareFilelistUppercase
76751>>>>>>>>>>>>>End_Struct
76751>>>>>>>>>>>>>
76751>>>>>>>>>>>>>Define C_tAPIColumn_None for 0
76751>>>>>>>>>>>>>Define C_tAPIColumn_Identity for 1
76751>>>>>>>>>>>>>
76751>>>>>>>>>>>>>// SQL Key-Word Constants:  CI_SQLSelect CI_SQLName CI_SQLFrom  CI_SQLSys
76751>>>>>>>>>>>>>// Used by the _SqlFindKeyWord function to return a proper keyword depending on the backend SQL,
76751>>>>>>>>>>>>>// i.e. one of the EN_DbTypeXXX members from the Enum_list above.
76751>>>>>>>>>>>>>// E.g. the CI_SQLAlterTable is only defined once, but the _SqlFindKeyWord function can return
76751>>>>>>>>>>>>>// different wording content depending on the EN_xxx value also passed to the function.
76751>>>>>>>>>>>>>Enum_List
76751>>>>>>>>>>>>>    Define CI_SQLAlterDatabase         //for "ALTER DATABASE"
76751>>>>>>>>>>>>>    Define CI_SQLSingle_User           //for "SINGLE_USER"
76751>>>>>>>>>>>>>    Define CI_SQLMulti_User            //for "USER_USER"
76751>>>>>>>>>>>>>    Define CI_SQLRollback              //for "ROLLBACK"
76751>>>>>>>>>>>>>    Define CI_SQLIMMEDIATE             //for "IMMEDIATE"
76751>>>>>>>>>>>>>    Define CI_SQLAlterTable            //for "ALTER TABLE"
76751>>>>>>>>>>>>>    Define CI_SQLAlterColumn           //for "ALTER COLUMN"
76751>>>>>>>>>>>>>    Define CI_SQLRenameColumn          //for "RENAME COLUMN"
76751>>>>>>>>>>>>>    Define CI_SQLColumn                //for "COLUMN"
76751>>>>>>>>>>>>>    Define CI_SQLSelect                //for "SELECT"
76751>>>>>>>>>>>>>    Define CI_SQLWhere                 //for "WHERE"
76751>>>>>>>>>>>>>    Define CI_SQLInfoSchema            //for "INFORMATION_SCHEMA.COLUMNS"
76751>>>>>>>>>>>>>    Define CI_SQLTable_Name            //for "TABLE_NAME"
76751>>>>>>>>>>>>>    Define CI_SQLTable                 //for "TABLE"
76751>>>>>>>>>>>>>    Define CI_SQLSys                   //for "SYS"
76751>>>>>>>>>>>>>    Define CI_SQLSp_Help               //for "SP_HELP"
76751>>>>>>>>>>>>>    Define CI_SQLFrom                  //for "FROM"
76751>>>>>>>>>>>>>    Define CI_SQLAdd                   //for "ADD"
76751>>>>>>>>>>>>>    Define CI_SQLDropColumn            //for "DROP"
76751>>>>>>>>>>>>>    Define CI_SQLCreateDatabase        //for "CREATE DATABASE"
76751>>>>>>>>>>>>>    Define CI_SQLDatabaseCollation     //for "COLLATE"
76751>>>>>>>>>>>>>    Define CI_SQLCreateTable           //for "CREATE TABLE"
76751>>>>>>>>>>>>>    Define CI_SQLDropTable             //for "DROP TABLE"
76751>>>>>>>>>>>>>    Define CI_SQLCreateView            //for "CREATE VIEW"
76751>>>>>>>>>>>>>    Define CI_SQLRenameTable           //for "RENAME TABLE"
76751>>>>>>>>>>>>>//    Define CI_SQLSelectFromWhereName   //for "SELECT name from [master].[dbo].[sysdatabases] where name"
76751>>>>>>>>>>>>>    Define CI_SQLDropView              //for "DROP VIEW"
76751>>>>>>>>>>>>>    Define CI_SQLSetNoCountOn          //for "SET NOCOUNT ON"
76751>>>>>>>>>>>>>    Define CI_SQLTo                    //for "TO"
76751>>>>>>>>>>>>>    Define CI_SQLGO                    //for "GO"
76751>>>>>>>>>>>>>    Define CI_SQLUse                   //for "USE"
76751>>>>>>>>>>>>>    Define CI_SQLDBO                   //for "DBO"
76751>>>>>>>>>>>>>
76751>>>>>>>>>>>>>    Define CI_SQLName                  //for "NAME"
76751>>>>>>>>>>>>>    Define CI_SQLMaster                //for "MASTER"
76751>>>>>>>>>>>>>    Define CI_SQLDatabases             //for "DATABASES"
76751>>>>>>>>>>>>>    Define CI_SQLSysIndexes            //for "SYS.INDEXES"
76751>>>>>>>>>>>>>    Define CI_SQLObjectID              //for "OBJECT_ID"
76751>>>>>>>>>>>>>    Define CI_SQLID                    //for "ID"
76751>>>>>>>>>>>>>    Define CI_SQLAND                   //for "AND"
76751>>>>>>>>>>>>>    Define CI_SQLUpdate                //for "UPDATE"
76751>>>>>>>>>>>>>    Define CI_SQLSet                   //for "SET"
76751>>>>>>>>>>>>>    Define CI_SQLWith                  //for "WITH"
76751>>>>>>>>>>>>>    Define CI_SQLNotNull               //for "NOT NULL"
76751>>>>>>>>>>>>>    Define CI_SQL_SAFE_UPDATES         //for "SQL_SAFE_UPDATES"  
76751>>>>>>>>>>>>>    Define CI_SQLDescription          //for "SELECT name, description from sys.fn_helpcollations()" (Enumerates all collates)
76751>>>>>>>>>>>>>End_Enum_List
76751>>>>>>>>>>>>>
76751>>>>>>>>>>>>>
76751>>>>>>>>>>>
76751>>>>>>>>>>>Class cDbUpdateFunctionLibrary_Mixin is a Mixin
76752>>>>>>>>>>>
76752>>>>>>>>>>>    Procedure CreateDbUpdateLibraryProperties
76754>>>>>>>>>>>        Handle hoSQLManagerMT
76754>>>>>>>>>>>
76754>>>>>>>>>>>        Property String private.psUseDatabase ""
76755>>>>>>>>>>>
76755>>>>>>>>>>>        // These are used by the Error routine to show the Table# & Field# if something goes wrong:
76755>>>>>>>>>>>        Property Handle  private.phCurrentTable 0
76756>>>>>>>>>>>        Property Integer private.piCurrentField 0
76757>>>>>>>>>>>
76757>>>>>>>>>>>        Property Handle phoCLIHandler      (Create(Self,RefClass(cCLIHandler)))
76758>>>>>>>>>>>        Property Handle phoSQLManager      (Create(Self,RefClass(cSQLHandleManager)))
76759>>>>>>>>>>>
76759>>>>>>>>>>>        Property Handle phoSQLManagerMT
76760>>>>>>>>>>>
76760>>>>>>>>>>>        Property Handle phoMSSQLHandler    (Create(Self,RefClass(cMSSQLHandler)))
76761>>>>>>>>>>>        Property Handle phoDB2SQLHandler   (Create(Self,RefClass(cDB2Handler)))
76762>>>>>>>>>>>        Property Handle phoODBCSQLHandler  (Create(Self,RefClass(cODBCHandler)))
76763>>>>>>>>>>>        Property Handle phoSQLConnectionHandler 0
76764>>>>>>>>>>>        Property tSQLKeyWords[] paSQLKeywordArray
76765>>>>>>>>>>>
76765>>>>>>>>>>>        Property Boolean pbHandleQueryErrors True
76766>>>>>>>>>>>
76766>>>>>>>>>>>        Property tSqlColumnNew[] paQueryColumns
76767>>>>>>>>>>>        Property String[] paSQLFetchResults
76768>>>>>>>>>>>
76768>>>>>>>>>>>        // Error handling
76768>>>>>>>>>>>        Property Integer Error_Report_Mode DUF_ERROR_REPORT
76769>>>>>>>>>>>        Property Boolean pbSqlError False
76770>>>>>>>>>>>        Property tSqlErrorArray paSqlErrorArray
76771>>>>>>>>>>>        Property Boolean pbProcessingError False
76772>>>>>>>>>>>
76772>>>>>>>>>>>        // Statistics on query
76772>>>>>>>>>>>        Property TimeSpan ptsTotalQueryTime
76773>>>>>>>>>>>        Property TimeSpan ptsQueryExec
76774>>>>>>>>>>>        Property TimeSpan ptsFetchResults
76775>>>>>>>>>>>        Property Integer piColumns 0
76776>>>>>>>>>>>        Property Integer piRows 0
76777>>>>>>>>>>>        Property Integer piRowType 0
76778>>>>>>>>>>>        Property String[] paQueryMessages
76779>>>>>>>>>>>        Property String psSQLStatementString
76780>>>>>>>>>>>
76780>>>>>>>>>>>        Property Integer[] paTableConvertExceptions
76781>>>>>>>>>>>
76781>>>>>>>>>>>        Property Integer[] paTableDateCorrectionExceptions
76782>>>>>>>>>>>
76782>>>>>>>>>>>        // Number of SQL statements (chunks) to be executed when executing a really big
76782>>>>>>>>>>>        // SQL file that has been compiled into the program. It is way faster to divide
76782>>>>>>>>>>>        // the statements in smaller chunks than to execute them all at the same time.
76782>>>>>>>>>>>        Property Integer piChunkMax 500
76783>>>>>>>>>>>
76783>>>>>>>>>>>        // Fill the paSQLKeywordArray array with values;
76783>>>>>>>>>>>        Send SetupSQLKeywordArray
76784>>>>>>>>>>>    End_Procedure
76785>>>>>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
76785>>>>>>>>>>>>
76785>>>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
76787>>>>>>>>>>>>    Integer iStart iEnd
76787>>>>>>>>>>>>    String sRetval
76787>>>>>>>>>>>>
76787>>>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
76788>>>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
76789>>>>>>>>>>>>    If (iStart = 0) Begin
76791>>>>>>>>>>>>        Function_Return ""
76792>>>>>>>>>>>>    End
76792>>>>>>>>>>>>>
76792>>>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
76793>>>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
76794>>>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
76796>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
76797>>>>>>>>>>>>    End
76797>>>>>>>>>>>>>
76797>>>>>>>>>>>>    Else Begin
76798>>>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
76799>>>>>>>>>>>>    End
76799>>>>>>>>>>>>>
76799>>>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
76801>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
76802>>>>>>>>>>>>        Decrement iEnd
76803>>>>>>>>>>>>    End
76803>>>>>>>>>>>>>
76803>>>>>>>>>>>>    If (iEnd <> 0) Begin
76805>>>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
76806>>>>>>>>>>>>    End
76806>>>>>>>>>>>>>
76806>>>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
76807>>>>>>>>>>>>
76807>>>>>>>>>>>>    Function_Return (Trim(sRetval))
76808>>>>>>>>>>>>End_Function
76809>>>>>>>>>>>>
76809>>>>>>>>>>>>
76809>>>>>>>>>>>
76809>>>>>>>>>>>    // Custom array find function. It compares both the iSQLWord & iSQLDbType params.
76809>>>>>>>>>>>    Function CompareFindSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
76811>>>>>>>>>>>        If (SQLKeywords1.iSQLWord = SQLKeywords2.iSQLWord and SQLKeywords1.iSQLDbType = SQLKeywords2.iSQLDbType) Begin
76813>>>>>>>>>>>            Function_Return (EQ)
76814>>>>>>>>>>>        End
76814>>>>>>>>>>>>
76814>>>>>>>>>>>        Function_Return (GT)
76815>>>>>>>>>>>    End_Function
76816>>>>>>>>>>>
76816>>>>>>>>>>>    // Custom array sort function. It compares both the iSQLWord & iSQLDbType params.
76816>>>>>>>>>>>    Function CompareSortSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
76818>>>>>>>>>>>        If (SQLKeywords1.iSQLWord   < SQLKeywords2.iSQLWord) ;            Function_Return (LT)
76821>>>>>>>>>>>        If (SQLKeywords1.iSQLWord   > SQLKeywords2.iSQLWord) ;            Function_Return (GT)
76824>>>>>>>>>>>        If (SQLKeywords1.iSQLDbType < SQLKeywords2.iSQLDbType) ;            Function_Return (LT)
76827>>>>>>>>>>>        If (SQLKeywords1.iSQLDbType > SQLKeywords2.iSQLDbType) ;            Function_Return (GT)
76830>>>>>>>>>>>
76830>>>>>>>>>>>        Function_Return (EQ)
76831>>>>>>>>>>>    End_Function
76832>>>>>>>>>>>
76832>>>>>>>>>>>    Procedure Add_Element Integer iSQLKeywordConstant Integer iEN_dbType String sSQLKeyword
76834>>>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
76834>>>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
76835>>>>>>>>>>>        Integer iSize
76835>>>>>>>>>>>
76835>>>>>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
76836>>>>>>>>>>>        Move (SizeOfArray(SQLKeywordArray)) to iSize
76837>>>>>>>>>>>        Move iSQLKeywordConstant to SQLKeywordArray[iSize].iSQLWord
76838>>>>>>>>>>>        Move iEN_dbType          to SQLKeywordArray[iSize].iSQLDbType
76839>>>>>>>>>>>        Move sSQLKeyword         to SQLKeywordArray[iSize].sSQLPhrase
76840>>>>>>>>>>>
76840>>>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArray
76841>>>>>>>>>>>    End_Procedure
76842>>>>>>>>>>>
76842>>>>>>>>>>>    // Creates a struct array with all SQL keywords
76842>>>>>>>>>>>    // for all EN_xxx SQL back-ends. Various back-ends can
76842>>>>>>>>>>>    // have slightly different wording.
76842>>>>>>>>>>>    // If a new EN_dbTypexxx type is added; additions
76842>>>>>>>>>>>    // needs to be done for every keyword group below.
76842>>>>>>>>>>>    Procedure SetupSQLKeywordArray
76844>>>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
76844>>>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
76846>>>>>>>>>>>
76846>>>>>>>>>>>        // This should only be called once; but in case it is
76846>>>>>>>>>>>        // we delete the array first.
76846>>>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArray
76847>>>>>>>>>>>
76847>>>>>>>>>>>        // ToDo: *** Not all SQL Key-words has been checked for other backends than MS-SQL ***
76847>>>>>>>>>>>        //
76847>>>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeMSSQL    "ALTER DATABASE"
76848>>>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeMySQL    "ALTER DATABASE"
76849>>>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeOracle   "ALTER DATABASE"
76850>>>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeDB2      "ALTER DATABASE"
76851>>>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypePostgre  "ALTER DATABASE"
76852>>>>>>>>>>>
76852>>>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeMSSQL    "SINGLE_USER"
76853>>>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeMySQL    "SINGLE_USER"
76854>>>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeOracle   "SINGLE_USER"
76855>>>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeDB2      "SINGLE_USER"
76856>>>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypePostgre  "SINGLE_USER"
76857>>>>>>>>>>>
76857>>>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeMSSQL    "MULTI_USER"
76858>>>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeMySQL    "MULTI_USER"
76859>>>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeOracle   "MULTI_USER"
76860>>>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeDB2      "MULTI_USER"
76861>>>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypePostgre  "MULTI_USER"
76862>>>>>>>>>>>
76862>>>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeMSSQL    "ROLLBACK"
76863>>>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeMySQL    "ROLLBACK"
76864>>>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeOracle   "ROLLBACK"
76865>>>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeDB2      "ROLLBACK"
76866>>>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypePostgre  "ROLLBACK"
76867>>>>>>>>>>>
76867>>>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeMSSQL    "IMMEDIATE"
76868>>>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeMySQL    "IMMEDIATE"
76869>>>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeOracle   "IMMEDIATE"
76870>>>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeDB2      "IMMEDIATE"
76871>>>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypePostgre  "IMMEDIATE"
76872>>>>>>>>>>>
76872>>>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMSSQL    "ALTER TABLE"
76873>>>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMySQL    "ALTER TABLE"
76874>>>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeOracle   "ALTER TABLE"
76875>>>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeDB2      "ALTER TABLE"
76876>>>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypePostgre  "ALTER TABLE"
76877>>>>>>>>>>>
76877>>>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMSSQL           "ADD"
76878>>>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMySQL           "ADD"
76879>>>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeOracle          "ADD"
76880>>>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeDB2             "ADD"
76881>>>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypePostgre         "ADD"
76882>>>>>>>>>>>
76882>>>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMSSQL        "UPDATE"
76883>>>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMySQL        "UPDATE"
76884>>>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeOracle       "UPDATE"
76885>>>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeDB2          "UPDATE"
76886>>>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypePostgre      "UPDATE"
76887>>>>>>>>>>>
76887>>>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMSSQL       "NOT NULL"
76888>>>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMySQL       "NOT NULL"
76889>>>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeOracle      "" // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
76890>>>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeDB2         "DEFAULT NOT NULL"
76891>>>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypePostgre     "NOT NULL"
76892>>>>>>>>>>>
76892>>>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_DbTypeMSSQL   ""
76893>>>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeMySQL   "SQL_SAFE_UPDATES"
76894>>>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeOracle  ""
76895>>>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeDB2     ""
76896>>>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypePostgre ""
76897>>>>>>>>>>>
76897>>>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMSSQL           "SET"
76898>>>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMySQL           "SET"
76899>>>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeOracle          "SET"
76900>>>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeDB2             "SET"
76901>>>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypePostgre         "SET"
76902>>>>>>>>>>>
76902>>>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeMSSQL          "WITH"
76903>>>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeMySQL          "WITH"
76904>>>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeOracle         "WITH"
76905>>>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeDB2            "WITH"
76906>>>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypePostgre        "WITH"
76907>>>>>>>>>>>
76907>>>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMSSQL    "CREATE DATABASE"
76908>>>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMySQL    "CREATE DATABASE"
76909>>>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeOracle   "CREATE DATABASE"
76910>>>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeDB2      "CREATE DATABASE"
76911>>>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypePostgre  "CREATE DATABASE"
76912>>>>>>>>>>>
76912>>>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeMSSQL    "COLLATE"
76913>>>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeMySQL    "COLLATE"
76914>>>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeOracle   "COLLATE"
76915>>>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeDB2      "COLLATE"
76916>>>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypePostgre  "COLLATE"
76917>>>>>>>>>>>
76917>>>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMSSQL    "CREATE VIEW"
76918>>>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMySQL    "CREATE VIEW"
76919>>>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeOracle   "CREATE VIEW"
76920>>>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeDB2      "CREATE VIEW"
76921>>>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypePostgre  "CREATE VIEW"
76922>>>>>>>>>>>
76922>>>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMSSQL      "DROP VIEW"
76923>>>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMySQL      "DROP VIEW"
76924>>>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeOracle     "DROP VIEW"
76925>>>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeDB2        "DROP VIEW"
76926>>>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypePostgre    "DROP VIEW"
76927>>>>>>>>>>>
76927>>>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMSSQL   "CREATE TABLE"
76928>>>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMySQL   "CREATE TABLE"
76929>>>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeOracle  "CREATE TABLE"
76930>>>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeDB2     "CREATE TABLE"
76931>>>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypePostgre "CREATE TABLE"
76932>>>>>>>>>>>
76932>>>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMSSQL     "DROP TABLE"
76933>>>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMySQL     "DROP TABLE"
76934>>>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeOracle    "DROP TABLE"
76935>>>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeDB2       "DROP TABLE"
76936>>>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypePostgre   "DROP TABLE"
76937>>>>>>>>>>>
76937>>>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMSSQL   "EXEC sp_rename"
76938>>>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMySQL   "RENAME TABLE"
76939>>>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeOracle  "RENAME TABLE"
76940>>>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeDB2     "RENAME TABLE"
76941>>>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypePostgre "RENAME TO"
76942>>>>>>>>>>>
76942>>>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMSSQL    "DROP COLUMN"
76943>>>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMySQL    "DROP COLUMN"
76944>>>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeOracle   "DROP COLUMN"
76945>>>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeDB2      "DROP COLUMN"
76946>>>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypePostgre  "DROP COLUMN"
76947>>>>>>>>>>>
76947>>>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMSSQL        "COLUMN"
76948>>>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMySQL        "COLUMN"
76949>>>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeOracle       "COLUMN"
76950>>>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeDB2          "COLUMN"
76951>>>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypePostgre      "COLUMN"
76952>>>>>>>>>>>
76952>>>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMSSQL   "ALTER COLUMN"
76953>>>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMySQL   "MODIFY"
76954>>>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeOracle  "MODIFY"
76955>>>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeDB2     "ALTER COLUMN"
76956>>>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypePostgre "ALTER COLUMN"
76957>>>>>>>>>>>
76957>>>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMSSQL   "EXEC sp_RENAME"
76958>>>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMySQL   "CHANGE"
76959>>>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeOracle  "RENAME COLUMN"
76960>>>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeDB2     "RENAME COLUMN"
76961>>>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypePostgre "RENAME COLUMN"
76962>>>>>>>>>>>
76962>>>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMSSQL        "SELECT"
76963>>>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMySQL        "SELECT"
76964>>>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeOracle       "SELECT"
76965>>>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeDB2          "SELECT"
76966>>>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypePostgre      "SELECT"
76967>>>>>>>>>>>
76967>>>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMSSQL         "WHERE"
76968>>>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMySQL         "WHERE"
76969>>>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeOracle        "WHERE"
76970>>>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeDB2           "WHERE"
76971>>>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypePostgre       "WHERE"
76972>>>>>>>>>>>
76972>>>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMSSQL          "FROM"
76973>>>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMySQL          "FROM"
76974>>>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeOracle         "FROM"
76975>>>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeDB2            "FROM"
76976>>>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypePostgre        "FROM"
76977>>>>>>>>>>>
76977>>>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMSSQL    "INFORMATION_SCHEMA.COLUMNS"
76978>>>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMySQL    "INFORMATION_SCHEMA.COLUMNS"
76979>>>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeOracle   "INFORMATION_SCHEMA.COLUMNS"
76980>>>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeDB2      "INFORMATION_SCHEMA.COLUMNS"
76981>>>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypePostgre  "INFORMATION_SCHEMA.COLUMNS"
76982>>>>>>>>>>>
76982>>>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMSSQL    "TABLE_NAME"
76983>>>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMySQL    "TABLE_NAME"
76984>>>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeOracle   "TABLE_NAME"
76985>>>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeDB2      "TABLE_NAME"
76986>>>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypePostgre  "TABLE_NAME"
76987>>>>>>>>>>>
76987>>>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMSSQL         "TABLE"
76988>>>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMySQL         "TABLE"
76989>>>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeOracle        "TABLE"
76990>>>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeDB2           "TABLE"
76991>>>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypePostgre       "TABLE"
76992>>>>>>>>>>>
76992>>>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMSSQL           "SYS"
76993>>>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMySQL           "SYS"
76994>>>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeOracle          "SYS"
76995>>>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeDB2             "SYS"
76996>>>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypePostgre         "SYS"
76997>>>>>>>>>>>
76997>>>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMSSQL       "SP_HELP"
76998>>>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMySQL       "SP_HELP"
76999>>>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeOracle      "SP_HELP"
77000>>>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeDB2         "SP_HELP"
77001>>>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypePostgre     "SP_HELP"
77002>>>>>>>>>>>
77002>>>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMSSQL      "SET NOCOUNT ON"
77003>>>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMySQL      "SET NOCOUNT ON"
77004>>>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeOracle     "SET NOCOUNT ON"
77005>>>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeDB2        "SET NOCOUNT ON"
77006>>>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypePostgre    "SET NOCOUNT ON"
77007>>>>>>>>>>>
77007>>>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMSSQL            "TO"
77008>>>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMySQL            "TO"
77009>>>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeOracle           "TO"
77010>>>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeDB2              "TO"
77011>>>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypePostgre          "TO"
77012>>>>>>>>>>>
77012>>>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMSSQL            "GO"
77013>>>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMySQL            "GO"
77014>>>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeOracle           "GO"
77015>>>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeDB2              "GO"
77016>>>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypePostgre          "GO"
77017>>>>>>>>>>>
77017>>>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMSSQL           "USE"
77018>>>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMySQL           "USE"
77019>>>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeOracle          "USE"
77020>>>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeDB2             "USE"
77021>>>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypePostgre         "USE"
77022>>>>>>>>>>>
77022>>>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMSSQL           "dbo"
77023>>>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMySQL           "dbo"
77024>>>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeOracle          "dbo"
77025>>>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeDB2             "dbo"
77026>>>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypePostgre         "dbo"
77027>>>>>>>>>>>
77027>>>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMSSQL        "MASTER"
77028>>>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMySQL        "MASTER"
77029>>>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeOracle       "MASTER"
77030>>>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeDB2          "MASTER"
77031>>>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypePostgre      "MASTER"
77032>>>>>>>>>>>
77032>>>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeMSSQL          "NAME"
77033>>>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeMySQL          "NAME"
77034>>>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeOracle         "NAME"
77035>>>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeDB2            "NAME"
77036>>>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypePostgre        "NAME"
77037>>>>>>>>>>>
77037>>>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMSSQL     "DATABASES"
77038>>>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMySQL     "DATABASES"
77039>>>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeOracle    "DATABASES"
77040>>>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeDB2       "DATABASES"
77041>>>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypePostgre   "DATABASES"
77042>>>>>>>>>>>
77042>>>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMSSQL    "SYS.INDEXES"
77043>>>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMySQL    "SYS.INDEXES"
77044>>>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeOracle   "SYS.INDEXES"
77045>>>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeDB2      "SYS.INDEXES"
77046>>>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypePostgre  "SYS.INDEXES"
77047>>>>>>>>>>>
77047>>>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMSSQL      "OBJECT_ID"
77048>>>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMySQL      "OBJECT_ID"
77049>>>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeOracle     "OBJECT_ID"
77050>>>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeDB2        "OBJECT_ID"
77051>>>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypePostgre    "OBJECT_ID"
77052>>>>>>>>>>>
77052>>>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeMSSQL            "ID"
77053>>>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeMySQL            "ID"
77054>>>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeOracle           "ID"
77055>>>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeDB2              "ID"
77056>>>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypePostgre          "ID"
77057>>>>>>>>>>>
77057>>>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMSSQL           "AND"
77058>>>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMySQL           "AND"
77059>>>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeOracle          "AND"
77060>>>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeDB2             "AND"
77061>>>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypePostgre         "AND"
77062>>>>>>>>>>>
77062>>>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeMSSQL   "DESCRIPTION"
77063>>>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeMySQL   "DESCRIPTION"
77064>>>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeOracle  "DESCRIPTION"
77065>>>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeDB2     "DESCRIPTION"
77066>>>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypePostgre "DESCRIPTION"
77067>>>>>>>>>>>
77067>>>>>>>>>>>        // In case we didn't put the above in order (and we don't need to); we sort the struct array.
77067>>>>>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
77068>>>>>>>>>>>        Move (SortArray(SQLKeywordArray, Self, (RefFunc(CompareSortSQLKeyWords)))) to SQLKeywordArraySorted
77069>>>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArraySorted
77070>>>>>>>>>>>
77070>>>>>>>>>>>    End_Procedure
77071>>>>>>>>>>>
77071>>>>>>>>>>>End_Class
77072>>>>>>>>>Use cSQLConnectionHandler.pkg
Including file: cSQLConnectionHandler.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionHandler.pkg)
77072>>>>>>>>>>>//****************************************************************************
77072>>>>>>>>>>>// $Module type: Class
77072>>>>>>>>>>>// $Module name: cSQLConnectionHandler.pkg
77072>>>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
77072>>>>>>>>>>>// Web-site    : http://www.rdctools.com
77072>>>>>>>>>>>// Created     : 2015-08-11 @ 16:02 (Military date format: YY-MM-DD)
77072>>>>>>>>>>>//
77072>>>>>>>>>>>// Description : A handler class for using CLI connection ID's to login to a database server.
77072>>>>>>>>>>>//
77072>>>>>>>>>>>// $Rev History:
77072>>>>>>>>>>>//    2015-08-11  Module header created
77072>>>>>>>>>>>//    2016-09-26  Changed name of the objecthandle from ghoCreateConnectionID to ghoSQLConnectionHandler.
77072>>>>>>>>>>>//                Added a new structure for passing connection data back & forth.
77072>>>>>>>>>>>//                Added better error handling.
77072>>>>>>>>>>>//                Added a decompose message for the connection string.
77072>>>>>>>>>>>//    2017-01-09  Added support for Mertech drivers
77072>>>>>>>>>>>//                Big overhaul to comply better with "Managed Connections" (DF 19)
77072>>>>>>>>>>>//                These changes make the class compatible with DFConnId.ini (can read/write DAW connection ini-files)
77072>>>>>>>>>>>//    2017-02-12  Reworked the whole connection property interface.
77072>>>>>>>>>>>//                Now there is one struct property that is the at cencter of a connection.
77072>>>>>>>>>>>//    2023-11-06 *** REMOVED ALL SUPPORT FOR MERTECH DRIVERS ***
77072>>>>>>>>>>>//****************************************************************************
77072>>>>>>>>>>>Use cli.pkg
77072>>>>>>>>>>>Use MSSqldrv.pkg
77072>>>>>>>>>>>Use db2_drv.pkg
77072>>>>>>>>>>>Use odbc_drv.pkg
77072>>>>>>>>>>>Use cSQLConnectionIniFile.pkg
Including file: cSQLConnectionIniFile.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionIniFile.pkg)
77072>>>>>>>>>>>>>//****************************************************************************
77072>>>>>>>>>>>>>// $Module type: Class
77072>>>>>>>>>>>>>// $Module name: cSQLConnectionIniFile.pkg
77072>>>>>>>>>>>>>//
77072>>>>>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
77072>>>>>>>>>>>>>// Copyright (c) 2012 RDC Tools International
77072>>>>>>>>>>>>>// E-mail      : support@rdctools.com
77072>>>>>>>>>>>>>// Web-site    : http://www.rdctools.com
77072>>>>>>>>>>>>>//
77072>>>>>>>>>>>>>// Created     : 2012-09-20 @ 18:04 (Military date format - Year-Month-Day)
77072>>>>>>>>>>>>>//
77072>>>>>>>>>>>>>// Note        : The file must be USEd after declaration of the ghoApplication object, as it uses
77072>>>>>>>>>>>>>//               properties of that object.
77072>>>>>>>>>>>>>//
77072>>>>>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
77072>>>>>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
77072>>>>>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
77072>>>>>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
77072>>>>>>>>>>>>>// in the help folder for more details.
77072>>>>>>>>>>>>>//
77072>>>>>>>>>>>>>Use cSQLConnectionIniFile.inc
77072>>>>>>>>>>>>>Use cDbUpdateDatabaseDriver.pkg
Including file: cDbUpdateDatabaseDriver.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateDatabaseDriver.pkg)
77072>>>>>>>>>>>>>>>Use cSQLConnectionIniFile.inc
77072>>>>>>>>>>>>>>>
77072>>>>>>>>>>>>>>>Class cDbUpdateGenericDatabaseDriver is a cObject
77073>>>>>>>>>>>>>>>    Procedure Construct_Object
77075>>>>>>>>>>>>>>>        Forward Send Construct_Object
77077>>>>>>>>>>>>>>>        Property String psDriverID DATAFLEX_ID
77078>>>>>>>>>>>>>>>    End_Procedure
77079>>>>>>>>>>>>>>>
77079>>>>>>>>>>>>>>>    Function ServerKeyword String sServer Returns String
77081>>>>>>>>>>>>>>>        String sRetval
77081>>>>>>>>>>>>>>>        If (Uppercase(sServer) contains ("." + CS_SQLIniDSNKeyword)) Begin
77083>>>>>>>>>>>>>>>            Move CS_SQLIniFileDSNKeyword to sRetval    
77084>>>>>>>>>>>>>>>        End                                        
77084>>>>>>>>>>>>>>>>
77084>>>>>>>>>>>>>>>        Else Begin
77085>>>>>>>>>>>>>>>            Move CS_SQLIniDSNKeyword to sRetval
77086>>>>>>>>>>>>>>>        End
77086>>>>>>>>>>>>>>>>
77086>>>>>>>>>>>>>>>            
77086>>>>>>>>>>>>>>>        Function_Return sRetval
77087>>>>>>>>>>>>>>>    End_Function
77088>>>>>>>>>>>>>>>
77088>>>>>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
77090>>>>>>>>>>>>>>>        String sConnect sServerKeyWord sDriverID
77090>>>>>>>>>>>>>>>        Integer iClientVersion
77090>>>>>>>>>>>>>>>        
77090>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
77091>>>>>>>>>>>>>>>        Get ServerKeyword sServer to sServerKeyWord
77092>>>>>>>>>>>>>>>        Move (sConnect + sServerKeyWord + "=" + sServer) to sConnect
77093>>>>>>>>>>>>>>>        If (sServerKeyWord = CS_SQLIniDSNKeyword or sServerKeyWord = CS_SQLIniFileDSNKeyword) Begin
77095>>>>>>>>>>>>>>>            Move "" to sDatabase
77096>>>>>>>>>>>>>>>        End
77096>>>>>>>>>>>>>>>>
77096>>>>>>>>>>>>>>>        
77096>>>>>>>>>>>>>>>        If (sDatabase <> "") Begin
77098>>>>>>>>>>>>>>>            Move (sConnect + ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
77099>>>>>>>>>>>>>>>        End
77099>>>>>>>>>>>>>>>>
77099>>>>>>>>>>>>>>>        If (bTrusted = True) Begin
77101>>>>>>>>>>>>>>>            Move (sConnect + ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
77102>>>>>>>>>>>>>>>        End
77102>>>>>>>>>>>>>>>>
77102>>>>>>>>>>>>>>>        Else Begin
77103>>>>>>>>>>>>>>>            Move (sConnect + ";" + CS_SQLIniUIDKeyword + "=" + sUserID + ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
77104>>>>>>>>>>>>>>>        End
77104>>>>>>>>>>>>>>>>
77104>>>>>>>>>>>>>>>        
77104>>>>>>>>>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
77106>>>>>>>>>>>>>>>            Get SQLClientVersionInteger MSSQLDRV_ID to iClientVersion
77107>>>>>>>>>>>>>>>            If (iClientVersion >= 18) Begin
77109>>>>>>>>>>>>>>>                Append sConnect ";Encrypt=Optional;TrustServerCertificate=Yes"
77110>>>>>>>>>>>>>>>                Move (Replaces(" ", sConnect, "")) to sConnect
77111>>>>>>>>>>>>>>>            End
77111>>>>>>>>>>>>>>>>
77111>>>>>>>>>>>>>>>        End
77111>>>>>>>>>>>>>>>>
77111>>>>>>>>>>>>>>>        
77111>>>>>>>>>>>>>>>        Function_Return sConnect
77112>>>>>>>>>>>>>>>    End_Function
77113>>>>>>>>>>>>>>>
77113>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77115>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
77115>>>>>>>>>>>>>>>        String sDriverID
77115>>>>>>>>>>>>>>>
77115>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
77116>>>>>>>>>>>>>>>        If (sDriverID = DATAFLEX_ID or sDriverID = "") Begin
77118>>>>>>>>>>>>>>>            Function_Return True
77119>>>>>>>>>>>>>>>        End
77119>>>>>>>>>>>>>>>>
77119>>>>>>>>>>>>>>>        Move 0 to LastErr  // Do NOT use the Err flag, it will be set true by the login command although it is successful.
77120>>>>>>>>>>>>>>>        If (bTrusted = False and sDatabase <> "") Begin
77122>>>>>>>>>>>>>>>            Move (SFormat("SERVER=%1;DATABASE=%2", sServer, sDatabase)) to sServer
77123>>>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID  
77125>>>>>>>>>>>>>>>        End
77125>>>>>>>>>>>>>>>>
77125>>>>>>>>>>>>>>>        Else Begin
77126>>>>>>>>>>>>>>>            Login sConnectionString "" "" sDriverID
77128>>>>>>>>>>>>>>>        End
77128>>>>>>>>>>>>>>>>
77128>>>>>>>>>>>>>>>        Move (LastErr = 0) to bLoginSuccessful
77129>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
77130>>>>>>>>>>>>>>>    End_Function
77131>>>>>>>>>>>>>>>
77131>>>>>>>>>>>>>>>    Function SQLClientVersionInteger String sDriverID Returns Integer
77133>>>>>>>>>>>>>>>        Integer iNumberOfDrivers iCount iDriver iClientVersion
77133>>>>>>>>>>>>>>>        String sDriver
77133>>>>>>>>>>>>>>>        
77133>>>>>>>>>>>>>>>        Move 0 to iDriver
77134>>>>>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
77137>>>>>>>>>>>>>>>        If (iNumberOfDrivers = 1) Begin
77139>>>>>>>>>>>>>>>            Load_Driver sDriverID
77140>>>>>>>>>>>>>>>            Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
77143>>>>>>>>>>>>>>>        End
77143>>>>>>>>>>>>>>>>
77143>>>>>>>>>>>>>>>        For iCount from 1 to iNumberOfDrivers
77149>>>>>>>>>>>>>>>>
77149>>>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sDriver
77152>>>>>>>>>>>>>>>            If (Uppercase(sDriver) = Uppercase(sDriverID)) Begin
77154>>>>>>>>>>>>>>>                Move iCount to iDriver
77155>>>>>>>>>>>>>>>                Move iNumberOfDrivers to iCount // We're done.
77156>>>>>>>>>>>>>>>            End
77156>>>>>>>>>>>>>>>>
77156>>>>>>>>>>>>>>>        Loop
77157>>>>>>>>>>>>>>>>
77157>>>>>>>>>>>>>>>    
77157>>>>>>>>>>>>>>>        // This info is (at current) only available for the MS SQL driver:
77157>>>>>>>>>>>>>>>        If (iDriver <> 0 and sDriverID = MSSQLDRV_ID) Begin
77159>>>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
77162>>>>>>>>>>>>>>>        End
77162>>>>>>>>>>>>>>>>
77162>>>>>>>>>>>>>>>        Function_Return iClientVersion
77163>>>>>>>>>>>>>>>    End_Function
77164>>>>>>>>>>>>>>>    
77164>>>>>>>>>>>>>>>End_Class
77165>>>>>>>>>>>>>>>
77165>>>>>>>>>>>>>>>Class cDbUpdateMSSQLDriver is a cDbUpdateGenericDatabaseDriver
77166>>>>>>>>>>>>>>>    Function ServerKeyword String sServer Returns String
77168>>>>>>>>>>>>>>>        Function_Return CS_SQLIniServerKeyword
77169>>>>>>>>>>>>>>>    End_Function
77170>>>>>>>>>>>>>>>
77170>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77172>>>>>>>>>>>>>>>        Integer iClientVersion
77172>>>>>>>>>>>>>>>        String sConnect
77172>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
77172>>>>>>>>>>>>>>>        
77172>>>>>>>>>>>>>>>        Move (sConnect * "SERVER=" + sServer) to sConnect
77173>>>>>>>>>>>>>>>        If (sDatabase <> "") Begin
77175>>>>>>>>>>>>>>>            Move (sConnect * ";DATABASE=" + sDatabase) to sConnect
77176>>>>>>>>>>>>>>>        End
77176>>>>>>>>>>>>>>>>
77176>>>>>>>>>>>>>>>        If (bTrusted = True) Begin
77178>>>>>>>>>>>>>>>            Move (sConnect * ";TRUSTED_CONNECTION=Yes") to sConnect
77179>>>>>>>>>>>>>>>        End
77179>>>>>>>>>>>>>>>>
77179>>>>>>>>>>>>>>>        Else Begin
77180>>>>>>>>>>>>>>>            Move (sConnect * ";UID=" + sUserID * ";PWD=" + sPassword) to sConnect
77181>>>>>>>>>>>>>>>        End
77181>>>>>>>>>>>>>>>>
77181>>>>>>>>>>>>>>>
77181>>>>>>>>>>>>>>>        Get SQLClientVersionInteger MSSQLDRV_ID to iClientVersion
77182>>>>>>>>>>>>>>>        If (iClientVersion >= 18) Begin
77184>>>>>>>>>>>>>>>            Append sConnect ";Encrypt=Optional;TrustServerCertificate=Yes"
77185>>>>>>>>>>>>>>>            Move (Replaces(" ", sConnect, "")) to sConnect
77186>>>>>>>>>>>>>>>        End
77186>>>>>>>>>>>>>>>>
77186>>>>>>>>>>>>>>>        
77186>>>>>>>>>>>>>>>        Login sConnect "" "" MSSQLDRV_ID
77188>>>>>>>>>>>>>>>
77188>>>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
77189>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
77190>>>>>>>>>>>>>>>    End_Function
77191>>>>>>>>>>>>>>>
77191>>>>>>>>>>>>>>>    Function SQLClientVersionInteger String sDriverID Returns Integer
77193>>>>>>>>>>>>>>>        Integer iNumberOfDrivers iCount iDriver iClientVersion
77193>>>>>>>>>>>>>>>        String sDriver
77193>>>>>>>>>>>>>>>        
77193>>>>>>>>>>>>>>>        Move 0 to iDriver
77194>>>>>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
77197>>>>>>>>>>>>>>>        If (iNumberOfDrivers = 1) Begin
77199>>>>>>>>>>>>>>>            Load_Driver sDriverID
77200>>>>>>>>>>>>>>>            Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
77203>>>>>>>>>>>>>>>        End
77203>>>>>>>>>>>>>>>>
77203>>>>>>>>>>>>>>>        For iCount from 1 to iNumberOfDrivers
77209>>>>>>>>>>>>>>>>
77209>>>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sDriver
77212>>>>>>>>>>>>>>>            If (Uppercase(sDriver) = Uppercase(sDriverID)) Begin
77214>>>>>>>>>>>>>>>                Move iCount to iDriver
77215>>>>>>>>>>>>>>>                Move iNumberOfDrivers to iCount // We're done.
77216>>>>>>>>>>>>>>>            End
77216>>>>>>>>>>>>>>>>
77216>>>>>>>>>>>>>>>        Loop
77217>>>>>>>>>>>>>>>>
77217>>>>>>>>>>>>>>>    
77217>>>>>>>>>>>>>>>        // This info is (at current) only available for the MS SQL driver:
77217>>>>>>>>>>>>>>>        If (iDriver <> 0 and sDriverID = MSSQLDRV_ID) Begin
77219>>>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
77222>>>>>>>>>>>>>>>        End
77222>>>>>>>>>>>>>>>>
77222>>>>>>>>>>>>>>>        Function_Return iClientVersion
77223>>>>>>>>>>>>>>>    End_Function
77224>>>>>>>>>>>>>>>    
77224>>>>>>>>>>>>>>>End_Class
77225>>>>>>>>>>>>>>>
77225>>>>>>>>>>>>>>>Class cDbUpdateODBCDriver is a cDbUpdateGenericDatabaseDriver
77226>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77228>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
77228>>>>>>>>>>>>>>>        String sDriverID
77228>>>>>>>>>>>>>>>
77228>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
77229>>>>>>>>>>>>>>>        Move (Trim(sDriverID)) to sDriverID
77230>>>>>>>>>>>>>>>        If (sDriverID = DATAFLEX_ID or sDriverID = "") Begin
77232>>>>>>>>>>>>>>>            Function_Return True
77233>>>>>>>>>>>>>>>        End
77233>>>>>>>>>>>>>>>>
77233>>>>>>>>>>>>>>>        Move 0 to LastErr  // Do NOT use the Err flag, it will be set true by the login command although it is successful.
77234>>>>>>>>>>>>>>>        If (bTrusted = False) Begin
77236>>>>>>>>>>>>>>>            If (Uppercase(sServer) contains ("." + String(CS_SQLIniDSNKeyword))) Begin
77238>>>>>>>>>>>>>>>                Move (CS_SQLIniFileDSNKeyword + "=" + sServer) to sServer
77239>>>>>>>>>>>>>>>            End
77239>>>>>>>>>>>>>>>>
77239>>>>>>>>>>>>>>>            Else If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
77242>>>>>>>>>>>>>>>                Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
77243>>>>>>>>>>>>>>>            End
77243>>>>>>>>>>>>>>>>
77243>>>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID  
77245>>>>>>>>>>>>>>>        End
77245>>>>>>>>>>>>>>>>
77245>>>>>>>>>>>>>>>        Else Begin
77246>>>>>>>>>>>>>>>            Login sConnectionString "" "" sDriverID
77248>>>>>>>>>>>>>>>        End
77248>>>>>>>>>>>>>>>>
77248>>>>>>>>>>>>>>>        Move (LastErr = 0) to bLoginSuccessful
77249>>>>>>>>>>>>>>>
77249>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
77250>>>>>>>>>>>>>>>    End_Function
77251>>>>>>>>>>>>>>>End_Class
77252>>>>>>>>>>>>>>>
77252>>>>>>>>>>>>>>>Class cDbUpdateDB2Driver is a cDbUpdateGenericDatabaseDriver
77253>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77255>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
77255>>>>>>>>>>>>>>>        String sDriverID
77255>>>>>>>>>>>>>>>
77255>>>>>>>>>>>>>>>        Move False to Err
77256>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
77257>>>>>>>>>>>>>>>        If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
77259>>>>>>>>>>>>>>>            Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
77260>>>>>>>>>>>>>>>        End
77260>>>>>>>>>>>>>>>>
77260>>>>>>>>>>>>>>>        Login sServer sUserId sPassword sDriverID
77262>>>>>>>>>>>>>>>
77262>>>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
77263>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
77264>>>>>>>>>>>>>>>    End_Function
77265>>>>>>>>>>>>>>>End_Class
77266>>>>>>>>>>>>>>>
77266>>>>>>>>>>>>>>>Class cDbUpdatePSQLDriver is a cDbUpdateGenericDatabaseDriver
77267>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77269>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
77269>>>>>>>>>>>>>>>        String sDriverID
77269>>>>>>>>>>>>>>>
77269>>>>>>>>>>>>>>>        Move False to Err
77270>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
77271>>>>>>>>>>>>>>>//        If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
77271>>>>>>>>>>>>>>>//            Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
77271>>>>>>>>>>>>>>>//        End
77271>>>>>>>>>>>>>>>        Login sServer sUserId sPassword sDriverID
77273>>>>>>>>>>>>>>>
77273>>>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
77274>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
77275>>>>>>>>>>>>>>>    End_Function
77276>>>>>>>>>>>>>>>End_Class
77277>>>>>>>>>>>>>>>
77277>>>>>>>>>>>>>>>Class cDbUpdateDataFlexDriver is a cDbUpdateGenericDatabaseDriver
77278>>>>>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
77280>>>>>>>>>>>>>>>        Function_Return ""
77281>>>>>>>>>>>>>>>    End_Function
77282>>>>>>>>>>>>>>>End_Class
77283>>>>>>>>>>>>>>>
77283>>>>>>>>>>>>>>>Class cDbUpdateDatabaseDriver is a cObject
77284>>>>>>>>>>>>>>>    Procedure Construct_Object
77286>>>>>>>>>>>>>>>        Forward Send Construct_Object
77288>>>>>>>>>>>>>>>        Property String psDriverID DATAFLEX_ID
77289>>>>>>>>>>>>>>>        Property Handle phoDriverSpecificObject
77290>>>>>>>>>>>>>>>    End_Procedure
77291>>>>>>>>>>>>>>>
77291>>>>>>>>>>>>>>>    Function CreateDriver Returns Handle
77293>>>>>>>>>>>>>>>        String sDriverID sObjectName
77293>>>>>>>>>>>>>>>        Handle hoDriver hcDriverClass
77293>>>>>>>>>>>>>>>
77293>>>>>>>>>>>>>>>        Get psDriverID to sDriverID
77294>>>>>>>>>>>>>>>        Case Begin
77294>>>>>>>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
77296>>>>>>>>>>>>>>>                Move (RefClass(cDbUpdateMSSQLDriver))    to hcDriverClass
77297>>>>>>>>>>>>>>>                Move "oDbUpdateMSSQLDriver" to sObjectName
77298>>>>>>>>>>>>>>>                Case Break
77299>>>>>>>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
77302>>>>>>>>>>>>>>>                Move (RefClass(cDbUpdateODBCDriver))     to hcDriverClass
77303>>>>>>>>>>>>>>>                Move "oDbUpdateODBCDriver" to sObjectName
77304>>>>>>>>>>>>>>>                Case Break
77305>>>>>>>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
77308>>>>>>>>>>>>>>>                Move (RefClass(cDbUpdateDB2Driver))      to hcDriverClass
77309>>>>>>>>>>>>>>>                Move "oDbUpdateDB2Driver" to sObjectName
77310>>>>>>>>>>>>>>>                Case Break               
77311>>>>>>>>>>>>>>>            Case Else
77311>>>>>>>>>>>>>>>                // DATAFLEX_ID = Default driver
77311>>>>>>>>>>>>>>>                Move (RefClass(cDbUpdateDataFlexDriver)) to hcDriverClass
77312>>>>>>>>>>>>>>>                Move "oDbUpdateDataFlexDriver" to sObjectName
77313>>>>>>>>>>>>>>>                Move DATAFLEX_ID to sDriverID
77314>>>>>>>>>>>>>>>        Case End
77314>>>>>>>>>>>>>>>
77314>>>>>>>>>>>>>>>        Get Create hcDriverClass to hoDriver
77315>>>>>>>>>>>>>>>        Set Name of hoDriver to sObjectName
77316>>>>>>>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
77317>>>>>>>>>>>>>>>        Set phoDriverSpecificObject to hoDriver
77318>>>>>>>>>>>>>>>
77318>>>>>>>>>>>>>>>        Function_Return hoDriver
77319>>>>>>>>>>>>>>>    End_Function
77320>>>>>>>>>>>>>>>
77320>>>>>>>>>>>>>>>    Procedure DestroyDriver
77322>>>>>>>>>>>>>>>        If (phoDriverSpecificObject(Self)) Begin
77324>>>>>>>>>>>>>>>            Send Destroy of (phoDriverSpecificObject(Self))
77325>>>>>>>>>>>>>>>        End
77325>>>>>>>>>>>>>>>>
77325>>>>>>>>>>>>>>>    End_Procedure
77326>>>>>>>>>>>>>>>
77326>>>>>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
77328>>>>>>>>>>>>>>>        String sConnect
77328>>>>>>>>>>>>>>>        Handle hoDriver
77328>>>>>>>>>>>>>>>
77328>>>>>>>>>>>>>>>        Get phoDriverSpecificObject to hoDriver
77329>>>>>>>>>>>>>>>        If (hoDriver = 0) Begin
77331>>>>>>>>>>>>>>>            Get CreateDriver to hoDriver
77332>>>>>>>>>>>>>>>        End
77332>>>>>>>>>>>>>>>>
77332>>>>>>>>>>>>>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
77333>>>>>>>>>>>>>>>        Send DestroyDriver
77334>>>>>>>>>>>>>>>        Function_Return sConnect
77335>>>>>>>>>>>>>>>    End_Function
77336>>>>>>>>>>>>>>>
77336>>>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
77338>>>>>>>>>>>>>>>        Boolean bLoginSuccessful
77338>>>>>>>>>>>>>>>        Handle hoDriver
77338>>>>>>>>>>>>>>>
77338>>>>>>>>>>>>>>>        Get phoDriverSpecificObject to hoDriver
77339>>>>>>>>>>>>>>>        If (hoDriver = 0) Begin
77341>>>>>>>>>>>>>>>            Get CreateDriver to hoDriver
77342>>>>>>>>>>>>>>>        End
77342>>>>>>>>>>>>>>>>
77342>>>>>>>>>>>>>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
77343>>>>>>>>>>>>>>>        Send DestroyDriver
77344>>>>>>>>>>>>>>>        Function_Return bLoginSuccessful
77345>>>>>>>>>>>>>>>    End_Function
77346>>>>>>>>>>>>>>>
77346>>>>>>>>>>>>>>>End_Class
77347>>>>>>>>>>>>>
77347>>>>>>>>>>>>>    Use cLoginEncryption.pkg
Including file: cLoginEncryption.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cLoginEncryption.pkg)
77347>>>>>>>>>>>>>>>Use cCryptographerEx.pkg
77347>>>>>>>>>>>>>>>
77347>>>>>>>>>>>>>>>Class cLoginEncryption is a cObject
77348>>>>>>>>>>>>>>>    
77348>>>>>>>>>>>>>>>    Procedure Construct_Object
77350>>>>>>>>>>>>>>>        Forward Send Construct_Object
77352>>>>>>>>>>>>>>>        // this must be set to a multi (40ish) character random key
77352>>>>>>>>>>>>>>>        Property String psEncryptPassword ""
77353>>>>>>>>>>>>>>>        
77353>>>>>>>>>>>>>>>        Object oDataCrypter is a cCryptographerEx
77355>>>>>>>>>>>>>>>            Set piHash to CALG_SHA_256
77356>>>>>>>>>>>>>>>            Set piCipher to CALG_AES_256
77357>>>>>>>>>>>>>>>            Set psProvider to "" //  Not providing a specific provider gives the default provider for the provider type
77358>>>>>>>>>>>>>>>            Set piProvider to PROV_RSA_AES
77359>>>>>>>>>>>>>>>        End_Object
77360>>>>>>>>>>>>>>>    End_Procedure
77361>>>>>>>>>>>>>>>    
77361>>>>>>>>>>>>>>>    // This can be augmented to return a password encryption key using any
77361>>>>>>>>>>>>>>>    // hidden mechanism desired.
77361>>>>>>>>>>>>>>>    Function GetEncryptionPassword Returns String
77363>>>>>>>>>>>>>>>        String sPassword
77363>>>>>>>>>>>>>>>        Get psEncryptPassword to sPassword
77364>>>>>>>>>>>>>>>        Function_Return sPassword
77365>>>>>>>>>>>>>>>    End_Function
77366>>>>>>>>>>>>>>>    
77366>>>>>>>>>>>>>>>    // Encrypts a string into an unreadable hash that can later be decrypted using DecryptKey.
77366>>>>>>>>>>>>>>>    //
77366>>>>>>>>>>>>>>>    // Params:
77366>>>>>>>>>>>>>>>    //   sPlainText     String to encrypt.
77366>>>>>>>>>>>>>>>    // Returns:
77366>>>>>>>>>>>>>>>    //   Base64 encoded hash.
77366>>>>>>>>>>>>>>>    Function EncryptPassword String sPlainText Returns String
77368>>>>>>>>>>>>>>>        String sEncryptPassword sBase64
77368>>>>>>>>>>>>>>>        UChar[] ucBinary
77369>>>>>>>>>>>>>>>        Pointer pBase64
77369>>>>>>>>>>>>>>>        Integer iVoid
77369>>>>>>>>>>>>>>>        
77369>>>>>>>>>>>>>>>        //  Encrypt Key
77369>>>>>>>>>>>>>>>        Get GetEncryptionPassword to sEncryptPassword
77370>>>>>>>>>>>>>>>        If (sEncryptPassword = "") Begin
77372>>>>>>>>>>>>>>>            Error DFERR_PROGRAM "No encryption password set"
77373>>>>>>>>>>>>>>>>
77373>>>>>>>>>>>>>>>        End
77373>>>>>>>>>>>>>>>>
77373>>>>>>>>>>>>>>>        
77373>>>>>>>>>>>>>>>        Get Encrypt of oDataCrypter (StringToUCharArray(sEncryptPassword)) (StringToUCharArray(sPlainText)) to ucBinary
77374>>>>>>>>>>>>>>>        
77374>>>>>>>>>>>>>>>        If (SizeOfArray(ucBinary) = 0) Begin
77376>>>>>>>>>>>>>>>            Error DFERR_PROGRAM "Unable to encrypt database login password"
77377>>>>>>>>>>>>>>>>
77377>>>>>>>>>>>>>>>            Function_Return ""
77378>>>>>>>>>>>>>>>        End
77378>>>>>>>>>>>>>>>>
77378>>>>>>>>>>>>>>>        
77378>>>>>>>>>>>>>>>        //  Encode binary hash to Base64
77378>>>>>>>>>>>>>>>        Move (Base64Encode(AddressOf(ucBinary), SizeOfArray(ucBinary))) to pBase64
77379>>>>>>>>>>>>>>>        Move (PointerToString(pBase64)) to sBase64
77380>>>>>>>>>>>>>>>        Move (Free(pBase64)) to iVoid
77381>>>>>>>>>>>>>>>        
77381>>>>>>>>>>>>>>>        Function_Return sBase64
77382>>>>>>>>>>>>>>>    End_Function
77383>>>>>>>>>>>>>>>    
77383>>>>>>>>>>>>>>>    
77383>>>>>>>>>>>>>>>    // Decrypts the unreadable hash generated by EncryptKey into a readable string.
77383>>>>>>>>>>>>>>>    //
77383>>>>>>>>>>>>>>>    // Params:
77383>>>>>>>>>>>>>>>    //   sBase64EncryptedPassword       Base64 Encrypted password
77383>>>>>>>>>>>>>>>    // Returns:
77383>>>>>>>>>>>>>>>    //   Readable plain text password
77383>>>>>>>>>>>>>>>    Function DecryptPassword String sBase64EncryptedPassword Returns String
77385>>>>>>>>>>>>>>>        String sEncryptPassword
77385>>>>>>>>>>>>>>>        UChar[] ucBinary ucPlain
77387>>>>>>>>>>>>>>>        Boolean bIsHex
77387>>>>>>>>>>>>>>>        Integer iLen iVoid
77387>>>>>>>>>>>>>>>        Pointer pBinary
77387>>>>>>>>>>>>>>>        
77387>>>>>>>>>>>>>>>        If (sBase64EncryptedPassword <> "") Begin
77389>>>>>>>>>>>>>>>            //  Decode from Base64
77389>>>>>>>>>>>>>>>            Move (Base64Decode(AddressOf(sBase64EncryptedPassword), &iLen)) to pBinary
77390>>>>>>>>>>>>>>>            
77390>>>>>>>>>>>>>>>            Move (ResizeArray(ucBinary, iLen, 0)) to ucBinary
77391>>>>>>>>>>>>>>>            Move (MemCopy(AddressOf(ucBinary), pBinary, iLen)) to iVoid
77392>>>>>>>>>>>>>>>                        
77392>>>>>>>>>>>>>>>            Move (Free(pBinary)) to iVoid
77393>>>>>>>>>>>>>>>            
77393>>>>>>>>>>>>>>>            //  Encrypted binary hash to string
77393>>>>>>>>>>>>>>>            Get GetEncryptionPassword to sEncryptPassword
77394>>>>>>>>>>>>>>>            Get Decrypt of oDataCrypter (StringToUCharArray(sEncryptPassword)) ucBinary to ucPlain
77395>>>>>>>>>>>>>>>        End
77395>>>>>>>>>>>>>>>>
77395>>>>>>>>>>>>>>>        
77395>>>>>>>>>>>>>>>        Function_Return (UCharArrayToString(ucPlain))
77396>>>>>>>>>>>>>>>    End_Function
77397>>>>>>>>>>>>>>>End_Class
77398>>>>>>>>>>>>>
77398>>>>>>>>>>>>>Class cSQLConnectionIniFile is a cIniFile
77399>>>>>>>>>>>>>    Procedure Construct_Object
77401>>>>>>>>>>>>>        Forward Send Construct_Object
77403>>>>>>>>>>>>>
77403>>>>>>>>>>>>>        Property String Private_psIniFilePath
77404>>>>>>>>>>>>>        Property String Private_psIniFileName CS_SQLIniFileName
77405>>>>>>>>>>>>>        Property String psIniSectionName (CS_SQLIniSectionName + "1")
77406>>>>>>>>>>>>>
77406>>>>>>>>>>>>>        Property Boolean pbDFConnId False
77407>>>>>>>>>>>>>
77407>>>>>>>>>>>>>        // *** You really want to change this value! ***
77407>>>>>>>>>>>>>        // It is used when encrypting/decrypting passwords.
77407>>>>>>>>>>>>>        Property String psHashString "zx!2139(LI0+?ips7433"
77408>>>>>>>>>>>>>
77408>>>>>>>>>>>>>    End_Procedure
77409>>>>>>>>>>>>>
77409>>>>>>>>>>>>>    Procedure End_Construct_Object
77411>>>>>>>>>>>>>        Forward Send End_Construct_Object
77413>>>>>>>>>>>>>    End_Procedure
77414>>>>>>>>>>>>>
77414>>>>>>>>>>>>>    Procedure Set psIniFilePath String sPath
77416>>>>>>>>>>>>>        String sIniFile
77416>>>>>>>>>>>>>        Get vFolderFormat sPath to sPath
77417>>>>>>>>>>>>>        Set private_psIniFilePath to sPath
77418>>>>>>>>>>>>>        Get psIniFileName to sIniFile
77419>>>>>>>>>>>>>        Set psFileName to (sPath + sIniFile)
77420>>>>>>>>>>>>>    End_Procedure
77421>>>>>>>>>>>>>
77421>>>>>>>>>>>>>    Function psIniFilePath Returns String
77423>>>>>>>>>>>>>        Function_Return (private_psIniFilePath(Self))
77424>>>>>>>>>>>>>    End_Function
77425>>>>>>>>>>>>>
77425>>>>>>>>>>>>>    Procedure Set psIniFileName String sFileName
77427>>>>>>>>>>>>>        String sPath
77427>>>>>>>>>>>>>        Get psIniFilePath to sPath
77428>>>>>>>>>>>>>        Set psFileName to (sPath + sFileName)
77429>>>>>>>>>>>>>        Set private_psIniFileName to sFileName
77430>>>>>>>>>>>>>    End_Procedure
77431>>>>>>>>>>>>>
77431>>>>>>>>>>>>>    Function psIniFileName Returns String
77433>>>>>>>>>>>>>        Function_Return (private_psIniFileName(Self))
77434>>>>>>>>>>>>>    End_Function
77435>>>>>>>>>>>>>
77435>>>>>>>>>>>>>    // *** Generalized messages to Get & Set values of the ini file.
77435>>>>>>>>>>>>>    // Sets a value in the program's ini file (write)
77435>>>>>>>>>>>>>    // Pass a section name, the value name parameter and the value itself to be written.
77435>>>>>>>>>>>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
77437>>>>>>>>>>>>>        String sIniFile sPath
77437>>>>>>>>>>>>>
77437>>>>>>>>>>>>>        Get psIniFilePath to sPath
77438>>>>>>>>>>>>>        Get psIniFileName to sIniFile
77439>>>>>>>>>>>>>        Move (sPath + sIniFile) to sIniFile
77440>>>>>>>>>>>>>        Set psFileName to sIniFile
77441>>>>>>>>>>>>>        Send WriteString sSection sValueName sValue
77442>>>>>>>>>>>>>    End_Procedure
77443>>>>>>>>>>>>>
77443>>>>>>>>>>>>>    // Get a value from program's ini-file (read)
77443>>>>>>>>>>>>>    // Pass a section name and the name of the value parameter & a default value.
77443>>>>>>>>>>>>>    // Returns the value
77443>>>>>>>>>>>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
77445>>>>>>>>>>>>>        String sValue sIniFile sPath
77445>>>>>>>>>>>>>
77445>>>>>>>>>>>>>        Get psIniFilePath to sPath
77446>>>>>>>>>>>>>        Get psIniFileName to sIniFile
77447>>>>>>>>>>>>>        Move (sPath + sIniFile) to sIniFile
77448>>>>>>>>>>>>>        Set psFileName to sIniFile
77449>>>>>>>>>>>>>        Get ReadString sSection sValueName sDefaultValue to sValue
77450>>>>>>>>>>>>>
77450>>>>>>>>>>>>>        Function_Return sValue
77451>>>>>>>>>>>>>    End_Function
77452>>>>>>>>>>>>>
77452>>>>>>>>>>>>>    // Sort function that first sorts on bEnabled & then on the connection string.
77452>>>>>>>>>>>>>    Function SortActiveFirst tSQLConnection SQLConnectionRow1 tSQLConnection SQLConnectionRow2 Returns Integer
77454>>>>>>>>>>>>>        If (SQLConnectionRow1.bEnabled > SQLConnectionRow2.bEnabled) ;            Function_Return (LT)
77457>>>>>>>>>>>>>        If (SQLConnectionRow1.bEnabled < SQLConnectionRow2.bEnabled) ;            Function_Return (GT)
77460>>>>>>>>>>>>>
77460>>>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionID < SQLConnectionRow2.sConnectionID) ;            Function_Return (LT)
77463>>>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionID > SQLConnectionRow2.sConnectionID) ;            Function_Return (GT)
77466>>>>>>>>>>>>>
77466>>>>>>>>>>>>>        If (SQLConnectionRow1.iDbType < SQLConnectionRow2.iDbType) ;            Function_Return (LT)
77469>>>>>>>>>>>>>        If (SQLConnectionRow1.iDbType > SQLConnectionRow2.iDbType) ;            Function_Return (GT)
77472>>>>>>>>>>>>>
77472>>>>>>>>>>>>>        If (SQLConnectionRow1.sServer < SQLConnectionRow2.sServer) ;            Function_Return (LT)
77475>>>>>>>>>>>>>        If (SQLConnectionRow1.sServer > SQLConnectionRow2.sServer) ;            Function_Return (GT)
77478>>>>>>>>>>>>>
77478>>>>>>>>>>>>>        If (SQLConnectionRow1.sDatabase < SQLConnectionRow2.sDatabase) ;            Function_Return (LT)
77481>>>>>>>>>>>>>        If (SQLConnectionRow1.sDatabase > SQLConnectionRow2.sDatabase) ;            Function_Return (GT)
77484>>>>>>>>>>>>>
77484>>>>>>>>>>>>>        If (SQLConnectionRow1.sDriverID < SQLConnectionRow2.sDriverID) ;            Function_Return (LT)
77487>>>>>>>>>>>>>        If (SQLConnectionRow1.sDriverID > SQLConnectionRow2.sDriverID) ;            Function_Return (GT)
77490>>>>>>>>>>>>>
77490>>>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionString < SQLConnectionRow2.sConnectionString) ;            Function_Return (LT)
77493>>>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionString > SQLConnectionRow2.sConnectionString) ;            Function_Return (GT)
77496>>>>>>>>>>>>>
77496>>>>>>>>>>>>>        Function_Return (EQ)
77497>>>>>>>>>>>>>    End_Function
77498>>>>>>>>>>>>>
77498>>>>>>>>>>>>>    Function SQLIniFileNumberOfConnections Returns Integer
77500>>>>>>>>>>>>>        Handle hoSections
77500>>>>>>>>>>>>>        Integer iItems
77500>>>>>>>>>>>>>
77500>>>>>>>>>>>>>        Send ReadSections hoSections
77501>>>>>>>>>>>>>        Move (Item_Count(hoSections)) to iItems
77502>>>>>>>>>>>>>        Function_Return iItems
77503>>>>>>>>>>>>>    End_Function
77504>>>>>>>>>>>>>
77504>>>>>>>>>>>>>    // The normal connection string looks something like this;
77504>>>>>>>>>>>>>    // "SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
77504>>>>>>>>>>>>>    // ...but the full connection string looks like this;
77504>>>>>>>>>>>>>    // "DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
77504>>>>>>>>>>>>>//    Function SQLIniFileAddConnection String sFullConnectionString Returns Boolean
77504>>>>>>>>>>>>>//        String sSection
77504>>>>>>>>>>>>>//        Integer iCount
77504>>>>>>>>>>>>>//
77504>>>>>>>>>>>>>//        Move False to Err
77504>>>>>>>>>>>>>//        Get psIniSectionName to sSection
77504>>>>>>>>>>>>>//        Get SQLIniFileNumberOfConnections to iCount
77504>>>>>>>>>>>>>//        Increment iCount
77504>>>>>>>>>>>>>//        Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to sFullConnectionString
77504>>>>>>>>>>>>>//
77504>>>>>>>>>>>>>//        Function_Return (Err = False)
77504>>>>>>>>>>>>>//    End_Function
77504>>>>>>>>>>>>>
77504>>>>>>>>>>>>>    Function SQLIniFileDeleteAllConnections Returns Boolean
77506>>>>>>>>>>>>>        Integer iCount
77506>>>>>>>>>>>>>        Boolean bExists
77506>>>>>>>>>>>>>        String sSection
77506>>>>>>>>>>>>>
77506>>>>>>>>>>>>>        Move False to Err
77507>>>>>>>>>>>>>        Move 1 to iCount
77508>>>>>>>>>>>>>        Get psIniSectionName to sSection
77509>>>>>>>>>>>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
77510>>>>>>>>>>>>>        While (bExists = True)
77514>>>>>>>>>>>>>            Send DeleteSection (CS_SQLIniSectionName + String(iCount))
77515>>>>>>>>>>>>>            Increment iCount
77516>>>>>>>>>>>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
77517>>>>>>>>>>>>>        Loop
77518>>>>>>>>>>>>>>
77518>>>>>>>>>>>>>        Function_Return (Err = False)
77519>>>>>>>>>>>>>    End_Function
77520>>>>>>>>>>>>>
77520>>>>>>>>>>>>>    Function SQLIniFileDeleteConnection Integer iItem Returns Boolean
77522>>>>>>>>>>>>>        Integer iCount
77522>>>>>>>>>>>>>        String sSection
77522>>>>>>>>>>>>>        Boolean bExists
77522>>>>>>>>>>>>>
77522>>>>>>>>>>>>>        Move False to Err
77523>>>>>>>>>>>>>        Move 1 to iCount
77524>>>>>>>>>>>>>        Get psIniSectionName to sSection
77525>>>>>>>>>>>>>        Get KeyExists sSection CS_SQLIniConnectionIdKeyword to bExists
77526>>>>>>>>>>>>>        While (bExists = True)
77530>>>>>>>>>>>>>            If (iCount = iItem) Begin
77532>>>>>>>>>>>>>                Send DeleteSection sSection
77533>>>>>>>>>>>>>//                Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to ""
77533>>>>>>>>>>>>>                Move 9999 to iCount // Just some ridiculously high number to get out of the loop as we're done.
77534>>>>>>>>>>>>>            End
77534>>>>>>>>>>>>>>
77534>>>>>>>>>>>>>            Increment iCount
77535>>>>>>>>>>>>>            Get KeyExists sSection (CS_SQLIniSectionName + String(iCount)) to bExists
77536>>>>>>>>>>>>>        Loop
77537>>>>>>>>>>>>>>
77537>>>>>>>>>>>>>
77537>>>>>>>>>>>>>        Function_Return (Err = False)
77538>>>>>>>>>>>>>    End_Function
77539>>>>>>>>>>>>>
77539>>>>>>>>>>>>>    // Returns all connection details for the passed Connection ID as a tSQLConnection
77539>>>>>>>>>>>>>    // If it fails the returned struct member SQLConnection.bError = True.
77539>>>>>>>>>>>>>    Function SQLIniFileConnectionID String sConnectionID Returns tSQLConnection
77541>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77541>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77542>>>>>>>>>>>>>        tSQLConnection   SQLConnection
77542>>>>>>>>>>>>>        tSQLConnection   SQLConnection
77542>>>>>>>>>>>>>        Integer iIndex
77542>>>>>>>>>>>>>
77542>>>>>>>>>>>>>        Get SQLIniFileConnectionIDIndex sConnectionID to iIndex
77543>>>>>>>>>>>>>        If (iIndex = -1) Begin
77545>>>>>>>>>>>>>            Move True to SQLConnection.bError
77546>>>>>>>>>>>>>            Function_Return SQLConnection
77547>>>>>>>>>>>>>        End
77547>>>>>>>>>>>>>>
77547>>>>>>>>>>>>>
77547>>>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
77548>>>>>>>>>>>>>        Move SQLConnectionsArray[iIndex -1] to SQLConnection
77549>>>>>>>>>>>>>
77549>>>>>>>>>>>>>        Function_Return SQLConnection
77550>>>>>>>>>>>>>    End_Function
77551>>>>>>>>>>>>>
77551>>>>>>>>>>>>>    // Returns -1 if the passed connection ID was not found, else the item number.
77551>>>>>>>>>>>>>    Function SQLIniFileConnectionIDIndex String sConnectionID Returns Integer
77553>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77553>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77554>>>>>>>>>>>>>        Integer iRetval iCount iSize
77554>>>>>>>>>>>>>        String sValue
77554>>>>>>>>>>>>>        Boolean bExists
77554>>>>>>>>>>>>>
77554>>>>>>>>>>>>>        Move -1 to iRetval
77555>>>>>>>>>>>>>
77555>>>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
77556>>>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
77557>>>>>>>>>>>>>        Decrement iSize
77558>>>>>>>>>>>>>        For iCount from 0 to iSize
77564>>>>>>>>>>>>>>
77564>>>>>>>>>>>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
77565>>>>>>>>>>>>>            Move (Uppercase(sValue) = Uppercase(sConnectionID)) to bExists
77566>>>>>>>>>>>>>            If (bExists) Begin
77568>>>>>>>>>>>>>                Move (iCount + 1) to iRetval // The [ConnectionX] keys are one-based (starts at 1) but the loop starts at zero.
77569>>>>>>>>>>>>>                Move iSize to iCount         // We're done!
77570>>>>>>>>>>>>>            End
77570>>>>>>>>>>>>>>
77570>>>>>>>>>>>>>        Loop
77571>>>>>>>>>>>>>>
77571>>>>>>>>>>>>>
77571>>>>>>>>>>>>>        Function_Return iRetval
77572>>>>>>>>>>>>>    End_Function
77573>>>>>>>>>>>>>
77573>>>>>>>>>>>>>    // Checks if the passed sConnectionID exists more than once in the passed struct array.
77573>>>>>>>>>>>>>    // Used to check that ConnectionID's are unique.
77573>>>>>>>>>>>>>    Function IsConnectionIDDuplicate String sConnectionID Returns Boolean
77575>>>>>>>>>>>>>        Integer iCount iSize iItems
77575>>>>>>>>>>>>>        String sValue
77575>>>>>>>>>>>>>        Boolean bExists
77575>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77575>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77576>>>>>>>>>>>>>
77576>>>>>>>>>>>>>        Move 0 to iItems
77577>>>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
77578>>>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
77579>>>>>>>>>>>>>        Decrement iSize
77580>>>>>>>>>>>>>        For iCount from 0 to iSize
77586>>>>>>>>>>>>>>
77586>>>>>>>>>>>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
77587>>>>>>>>>>>>>            Move (sValue = sConnectionID) to bExists
77588>>>>>>>>>>>>>            If (bExists) Begin
77590>>>>>>>>>>>>>                Increment iItems
77591>>>>>>>>>>>>>            End
77591>>>>>>>>>>>>>>
77591>>>>>>>>>>>>>        Loop
77592>>>>>>>>>>>>>>
77592>>>>>>>>>>>>>
77592>>>>>>>>>>>>>        Function_Return (iItems > 1)
77593>>>>>>>>>>>>>    End_Function
77594>>>>>>>>>>>>>
77594>>>>>>>>>>>>>    // To update the SQLConnections.ini file with a new default Connection ID.
77594>>>>>>>>>>>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
77596>>>>>>>>>>>>>        Boolean bOK
77596>>>>>>>>>>>>>        Integer iSize iCount
77596>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77596>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77597>>>>>>>>>>>>>        tSQLConnection SQLConnection
77597>>>>>>>>>>>>>        tSQLConnection SQLConnection
77597>>>>>>>>>>>>>        String sConnectionString
77597>>>>>>>>>>>>>
77597>>>>>>>>>>>>>        Move False to Err
77598>>>>>>>>>>>>>        Get psConnectionString to sConnectionString
77599>>>>>>>>>>>>>
77599>>>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
77600>>>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
77601>>>>>>>>>>>>>        Decrement iSize
77602>>>>>>>>>>>>>        // Set all current connection to inactive.
77602>>>>>>>>>>>>>        For iCount from 0 to iSize
77608>>>>>>>>>>>>>>
77608>>>>>>>>>>>>>            Move False to SQLConnectionsArray[iCount].bEnabled
77609>>>>>>>>>>>>>        Loop
77610>>>>>>>>>>>>>>
77610>>>>>>>>>>>>>
77610>>>>>>>>>>>>>        Get SQLIniFileConnectionID sConnectionID to SQLConnection
77611>>>>>>>>>>>>>        Move True              to SQLConnection.bEnabled
77612>>>>>>>>>>>>>        Move sConnectionString to SQLConnection.sConnectionString
77613>>>>>>>>>>>>>        Move (InsertInArray(SQLConnectionsArray, 0, SQLConnection)) to SQLConnectionsArray
77614>>>>>>>>>>>>>        Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
77615>>>>>>>>>>>>>
77615>>>>>>>>>>>>>        Function_Return (bOK = True)
77616>>>>>>>>>>>>>    End_Function
77617>>>>>>>>>>>>>
77617>>>>>>>>>>>>>    // Used for updating an existing connection with new data.
77617>>>>>>>>>>>>>    // Returns True if successful.
77617>>>>>>>>>>>>>    Function SQLIniFileUpdateConnection tSQLConnection SQLConnection Returns Boolean
77619>>>>>>>>>>>>>        Boolean bOK
77619>>>>>>>>>>>>>        Integer iItem iSize iCount
77619>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77619>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77620>>>>>>>>>>>>>
77620>>>>>>>>>>>>>        Move False to Err
77621>>>>>>>>>>>>>        Move -1 to iItem
77622>>>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
77623>>>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
77624>>>>>>>>>>>>>        Decrement iSize
77625>>>>>>>>>>>>>        // Set all current connection to inactive.
77625>>>>>>>>>>>>>        For iCount from 0 to iSize
77631>>>>>>>>>>>>>>
77631>>>>>>>>>>>>>            Move False to SQLConnectionsArray[iCount].bEnabled
77632>>>>>>>>>>>>>            If (SQLConnectionsArray[iCount].sConnectionID = SQLConnection.sConnectionID) Begin
77634>>>>>>>>>>>>>                Move iCount to iItem
77635>>>>>>>>>>>>>            End
77635>>>>>>>>>>>>>>
77635>>>>>>>>>>>>>        Loop
77636>>>>>>>>>>>>>>
77636>>>>>>>>>>>>>
77636>>>>>>>>>>>>>        If (iItem <> -1) Begin
77638>>>>>>>>>>>>>            Move True to SQLConnection.bEnabled
77639>>>>>>>>>>>>>            Move SQLConnection to SQLConnectionsArray[iItem]
77640>>>>>>>>>>>>>            Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
77641>>>>>>>>>>>>>        End
77641>>>>>>>>>>>>>>
77641>>>>>>>>>>>>>
77641>>>>>>>>>>>>>        Function_Return (bOK = True)
77642>>>>>>>>>>>>>    End_Function
77643>>>>>>>>>>>>>
77643>>>>>>>>>>>>>    Function SQLIniFileReadConnections Returns tSQLConnection[]
77645>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77645>>>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
77646>>>>>>>>>>>>>        String sSection sValue
77646>>>>>>>>>>>>>        Integer iCount
77646>>>>>>>>>>>>>        Boolean bExists
77646>>>>>>>>>>>>>
77646>>>>>>>>>>>>>        Get psIniSectionName to sSection
77647>>>>>>>>>>>>>        Get SectionExists sSection to bExists
77648>>>>>>>>>>>>>        If (bExists = False) Begin
77650>>>>>>>>>>>>>            Function_Return SQLConnectionsArray
77651>>>>>>>>>>>>>        End
77651>>>>>>>>>>>>>>
77651>>>>>>>>>>>>>        Get SectionExists CS_SQLIniConnectionSection to bExists
77652>>>>>>>>>>>>>        If (bExists = True) Begin
77654>>>>>>>>>>>>>            Error DFERR_PROGRAM "Sorry, the format for the SQLConnections.ini file has been changed and this file has the old format that is no longer valid and thus cannot be read. You need to re-enter your connection(s)."
77655>>>>>>>>>>>>>>
77655>>>>>>>>>>>>>        End
77655>>>>>>>>>>>>>>
77655>>>>>>>>>>>>>
77655>>>>>>>>>>>>>        Move 1 to iCount // The section name "[ConnectionXX]" starts with "1"
77656>>>>>>>>>>>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
77657>>>>>>>>>>>>>
77657>>>>>>>>>>>>>        While (bExists = True)                 
77661>>>>>>>>>>>>>            // 2018-07-14 Change to allow disabling all connections in test environment.
77661>>>>>>>>>>>>>            // We always put the enabled/active connection at the top
77661>>>>>>>>>>>>>//            Move (iCount = 1) to bEnabled
77661>>>>>>>>>>>>>//            Move bEnabled to SQLConnectionsArray[iCount].bEnabled
77661>>>>>>>>>>>>>
77661>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionIdKeyword ""        to SQLConnectionsArray[iCount].sConnectionID
77662>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDriverKeyword       ""        to SQLConnectionsArray[iCount].sDriverID
77663>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDisabledKeyword     ""        to sValue
77664>>>>>>>>>>>>>            Move (If(Uppercase(sValue) = "YES", False, True))                                               to SQLConnectionsArray[iCount].bEnabled
77665>>>>>>>>>>>>>
77665>>>>>>>>>>>>>            // The iDbType might be missing from the ini-file. This is e.g. the case when a DAW Managed Connection "DFConnId.ini" file is read.
77665>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDbTypeKeyword       "99"      to sValue
77666>>>>>>>>>>>>>            If (sValue = "99") Begin
77668>>>>>>>>>>>>>                Get SqlUtilDbTypeFromDriver SQLConnectionsArray[iCount].sDriverID to sValue
77669>>>>>>>>>>>>>            End
77669>>>>>>>>>>>>>>
77669>>>>>>>>>>>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].iDbType
77670>>>>>>>>>>>>>
77670>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionKeyWord   ""        to SQLConnectionsArray[iCount].sConnectionString
77671>>>>>>>>>>>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnectionsArray[iCount].sServer
77672>>>>>>>>>>>>>            If (SQLConnectionsArray[iCount].sServer = "") Begin
77674>>>>>>>>>>>>>                Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniFileDSNKeyword +"=") to SQLConnectionsArray[iCount].sServer
77675>>>>>>>>>>>>>            End
77675>>>>>>>>>>>>>>
77675>>>>>>>>>>>>>            If (SQLConnectionsArray[iCount].sServer = "") Begin
77677>>>>>>>>>>>>>                Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDSNKeyword +"=")   to SQLConnectionsArray[iCount].sServer
77678>>>>>>>>>>>>>            End
77678>>>>>>>>>>>>>>
77678>>>>>>>>>>>>>
77678>>>>>>>>>>>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnectionsArray[iCount].sDatabase
77679>>>>>>>>>>>>>
77679>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniTrustedKeyword      ""        to sValue
77680>>>>>>>>>>>>>            Move (If(Uppercase(sValue) = "YES", True, False))                                               to SQLConnectionsArray[iCount].bTrusted
77681>>>>>>>>>>>>>
77681>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniUIDKeyword          ""        to SQLConnectionsArray[iCount].sUserID
77682>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDFPWDKeyword        ""        to sValue
77683>>>>>>>>>>>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
77685>>>>>>>>>>>>>                Get DecryptPassword sValue to sValue
77686>>>>>>>>>>>>>            End
77686>>>>>>>>>>>>>>
77686>>>>>>>>>>>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].sPassword
77687>>>>>>>>>>>>>
77687>>>>>>>>>>>>>            // Here we reconstruct the connection string to be complete with all params;
77687>>>>>>>>>>>>>            Get ConstructConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                          SQLConnectionsArray[iCount].bTrusted SQLConnectionsArray[iCount].sUserID SQLConnectionsArray[iCount].sPassword ;                                          to SQLConnectionsArray[iCount].sConnectionString
77688>>>>>>>>>>>>>
77688>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSchemaKeyword          ""     to SQLConnectionsArray[iCount].sSchema
77689>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniBaseTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sBaseTableSpace
77690>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniLongTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sLongTableSpace
77691>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniIndexTableSpaceKeyword ""     to SQLConnectionsArray[iCount].sIndexTableSpace
77692>>>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSilentLoginKeyword     ""     to sValue
77693>>>>>>>>>>>>>            Move (If(Uppercase(sValue) = "YES", True, False))                                               to SQLConnectionsArray[iCount].bSilentLogin
77694>>>>>>>>>>>>>
77694>>>>>>>>>>>>>            Increment iCount
77695>>>>>>>>>>>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
77696>>>>>>>>>>>>>        Loop
77697>>>>>>>>>>>>>>
77697>>>>>>>>>>>>>
77697>>>>>>>>>>>>>        // Lastly, we remove the very first array item as it is empty (we started at 1 because that is the first [Connection#])
77697>>>>>>>>>>>>>        If (SizeOfArray(SQLConnectionsArray) > 0) Begin
77699>>>>>>>>>>>>>            Move (RemoveFromArray(SQLConnectionsArray, 0)) to SQLConnectionsArray
77700>>>>>>>>>>>>>        End
77700>>>>>>>>>>>>>>
77700>>>>>>>>>>>>>
77700>>>>>>>>>>>>>        Function_Return SQLConnectionsArray
77701>>>>>>>>>>>>>    End_Function
77702>>>>>>>>>>>>>
77702>>>>>>>>>>>>>    Function SQLIniFileWriteConnections tSQLConnection[] SQLConnectionsArray Returns Boolean
77704>>>>>>>>>>>>>        Integer iCount iSize
77704>>>>>>>>>>>>>        Boolean bOK
77704>>>>>>>>>>>>>        String sSection sValue
77704>>>>>>>>>>>>>
77704>>>>>>>>>>>>>        // First we need to _remove_ all current connections from the ini-file.
77704>>>>>>>>>>>>>        Move 0 to iCount
77705>>>>>>>>>>>>>        Get SQLIniFileDeleteAllConnections to bOK
77706>>>>>>>>>>>>>        If (bOK = False) Begin
77708>>>>>>>>>>>>>            Function_Return False
77709>>>>>>>>>>>>>        End
77709>>>>>>>>>>>>>>
77709>>>>>>>>>>>>>
77709>>>>>>>>>>>>>        Move False to Err
77710>>>>>>>>>>>>>        Get psIniSectionName to sSection
77711>>>>>>>>>>>>>        // Sorting will make sure we have the active connection record as the first connection item in the ini-file.
77711>>>>>>>>>>>>>        Move (SortArray(SQLConnectionsArray, Self, (RefFunc(SortActiveFirst)))) to SQLConnectionsArray
77712>>>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
77713>>>>>>>>>>>>>        Decrement iSize
77714>>>>>>>>>>>>>
77714>>>>>>>>>>>>>        For iCount from 0 to iSize
77720>>>>>>>>>>>>>>
77720>>>>>>>>>>>>>            // DF 19 compatible settings:
77720>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionIdKeyword   to SQLConnectionsArray[iCount].sConnectionID
77721>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDriverKeyword         to SQLConnectionsArray[iCount].sDriverID
77722>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDisabledKeyword       to (If(SQLConnectionsArray[iCount].bEnabled = 0, "Yes", "No"))
77723>>>>>>>>>>>>>            
77723>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniUIDKeyword            to SQLConnectionsArray[iCount].sUserID
77724>>>>>>>>>>>>>
77724>>>>>>>>>>>>>            Move SQLConnectionsArray[iCount].sPassword to sValue
77725>>>>>>>>>>>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
77727>>>>>>>>>>>>>                Get EncryptPassword sValue to sValue
77728>>>>>>>>>>>>>            End
77728>>>>>>>>>>>>>>
77728>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDFPWDKeyword          to sValue
77729>>>>>>>>>>>>>
77729>>>>>>>>>>>>>            If (SQLConnectionsArray[iCount].bTrusted = True) Begin
77731>>>>>>>>>>>>>                Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniTrustedKeyword    to CS_SQLIniConnectionYes
77732>>>>>>>>>>>>>            End
77732>>>>>>>>>>>>>>
77732>>>>>>>>>>>>>
77732>>>>>>>>>>>>>            Get ConstructShortConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                            to SQLConnectionsArray[iCount].sConnectionString
77733>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionKeyWord     to SQLConnectionsArray[iCount].sConnectionString
77734>>>>>>>>>>>>>
77734>>>>>>>>>>>>>            // The Database Update Framework extended settings:
77734>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDbTypeKeyword          to SQLConnectionsArray[iCount].iDbType
77735>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSchemaKeyword          to SQLConnectionsArray[iCount].sSchema
77736>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniBaseTableSpaceKeyword  to SQLConnectionsArray[iCount].sBaseTableSpace
77737>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniLongTableSpaceKeyword  to SQLConnectionsArray[iCount].sLongTableSpace
77738>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniIndexTableSpaceKeyword to SQLConnectionsArray[iCount].sIndexTableSpace
77739>>>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSilentLoginKeyword     to (If(SQLConnectionsArray[iCount].bSilentLogin = 1, "Yes", "No"))
77740>>>>>>>>>>>>>        Loop
77741>>>>>>>>>>>>>>
77741>>>>>>>>>>>>>
77741>>>>>>>>>>>>>        Function_Return (bOK and Err = False)
77742>>>>>>>>>>>>>    End_Function
77743>>>>>>>>>>>>>
77743>>>>>>>>>>>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
77743>>>>>>>>>>>>>    //
77743>>>>>>>>>>>>>    // SQL utility function that returns a database type (string) constant
77743>>>>>>>>>>>>>    // corresponding to the passed iDbType.
77743>>>>>>>>>>>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
77745>>>>>>>>>>>>>        String sRetval
77745>>>>>>>>>>>>>        If (iDbType = EN_dbTypeMSSQL) Begin
77747>>>>>>>>>>>>>            Move CS_dbTypeMSSQL to sRetval
77748>>>>>>>>>>>>>        End
77748>>>>>>>>>>>>>>
77748>>>>>>>>>>>>>        If (iDbType = EN_dbTypeMySQL) Begin
77750>>>>>>>>>>>>>            Move CS_dbTypeMySQL to sRetval
77751>>>>>>>>>>>>>        End
77751>>>>>>>>>>>>>>
77751>>>>>>>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
77753>>>>>>>>>>>>>            Move CS_dbTypeOracle to sRetval
77754>>>>>>>>>>>>>        End
77754>>>>>>>>>>>>>>
77754>>>>>>>>>>>>>        If (iDbType = EN_dbTypeDB2) Begin
77756>>>>>>>>>>>>>            Move CS_dbTypeDB2 to sRetval
77757>>>>>>>>>>>>>        End
77757>>>>>>>>>>>>>>
77757>>>>>>>>>>>>>        If (iDbType = EN_dbTypePostgre) Begin
77759>>>>>>>>>>>>>            Move CS_dbTypePostgre to sRetval
77760>>>>>>>>>>>>>        End
77760>>>>>>>>>>>>>>
77760>>>>>>>>>>>>>        If (iDbType = EN_DbTypePervasive) Begin
77762>>>>>>>>>>>>>            Move CS_DbTypePervasive to sRetval
77763>>>>>>>>>>>>>        End
77763>>>>>>>>>>>>>>
77763>>>>>>>>>>>>>        Function_Return sRetval
77764>>>>>>>>>>>>>    End_Function
77765>>>>>>>>>>>>>
77765>>>>>>>>>>>>>    // SQL utility function that returns a database type constant (integer)
77765>>>>>>>>>>>>>    // corresponding to the passed sDbType string constant.
77765>>>>>>>>>>>>>    Function SqlUtilDbTypeToInteger String sDbType  Returns Integer
77767>>>>>>>>>>>>>        Integer iRetval
77767>>>>>>>>>>>>>        If (sDbType = CS_DbTypeDataFlex) Begin
77769>>>>>>>>>>>>>            Move EN_DbTypeDataFlex to iRetval
77770>>>>>>>>>>>>>        End
77770>>>>>>>>>>>>>>
77770>>>>>>>>>>>>>        If (sDbType = CS_dbTypeMSSQL) Begin
77772>>>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
77773>>>>>>>>>>>>>        End
77773>>>>>>>>>>>>>>
77773>>>>>>>>>>>>>        If (sDbType = CS_dbTypeMySQL) Begin
77775>>>>>>>>>>>>>            Move EN_dbTypeMySQL to iRetval
77776>>>>>>>>>>>>>        End
77776>>>>>>>>>>>>>>
77776>>>>>>>>>>>>>        If (sDbType = CS_dbTypeOracle) Begin
77778>>>>>>>>>>>>>            Move EN_dbTypeOracle to iRetval
77779>>>>>>>>>>>>>        End
77779>>>>>>>>>>>>>>
77779>>>>>>>>>>>>>        If (sDbType = CS_dbTypeDB2) Begin
77781>>>>>>>>>>>>>            Move EN_dbTypeDB2 to iRetval
77782>>>>>>>>>>>>>        End
77782>>>>>>>>>>>>>>
77782>>>>>>>>>>>>>        If (sDbType = CS_dbTypePostgre) Begin
77784>>>>>>>>>>>>>            Move EN_dbTypePostgre to iRetval
77785>>>>>>>>>>>>>        End
77785>>>>>>>>>>>>>>
77785>>>>>>>>>>>>>        If (sDbType = CS_DbTypePervasive) Begin
77787>>>>>>>>>>>>>            Move EN_DbTypePervasive to iRetval
77788>>>>>>>>>>>>>        End
77788>>>>>>>>>>>>>>
77788>>>>>>>>>>>>>        Function_Return iRetval
77789>>>>>>>>>>>>>    End_Function
77790>>>>>>>>>>>>>
77790>>>>>>>>>>>>>    // Pass an integer DbType and function returns the database type integer as a string value.
77790>>>>>>>>>>>>>    // Used e.g. when reading a connection ini-file to display the database type in
77790>>>>>>>>>>>>>    // the SQL Connection program's grid.
77790>>>>>>>>>>>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
77792>>>>>>>>>>>>>        String sRetval
77792>>>>>>>>>>>>>        If (iDbType = EN_dbTypeMSSQL) Begin
77794>>>>>>>>>>>>>            Move "EN_dbTypeMSSQL" to sRetval
77795>>>>>>>>>>>>>        End
77795>>>>>>>>>>>>>>
77795>>>>>>>>>>>>>        If (iDbType = EN_dbTypeMySQL) Begin
77797>>>>>>>>>>>>>            Move "EN_dbTypeMySQL" to sRetval
77798>>>>>>>>>>>>>        End
77798>>>>>>>>>>>>>>
77798>>>>>>>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
77800>>>>>>>>>>>>>            Move "EN_dbTypeOracle" to sRetval
77801>>>>>>>>>>>>>        End
77801>>>>>>>>>>>>>>
77801>>>>>>>>>>>>>        If (iDbType = EN_dbTypeDB2) Begin
77803>>>>>>>>>>>>>            Move "EN_dbTypeDB2" to sRetval
77804>>>>>>>>>>>>>        End
77804>>>>>>>>>>>>>>
77804>>>>>>>>>>>>>        If (iDbType = EN_dbTypePostgre) Begin
77806>>>>>>>>>>>>>            Move "EN_dbTypePostgre" to sRetval
77807>>>>>>>>>>>>>        End
77807>>>>>>>>>>>>>>
77807>>>>>>>>>>>>>        If (iDbType = EN_DbTypePervasive) Begin
77809>>>>>>>>>>>>>            Move "EN_dbTypePervasive" to sRetval
77810>>>>>>>>>>>>>        End
77810>>>>>>>>>>>>>>
77810>>>>>>>>>>>>>        Function_Return sRetval
77811>>>>>>>>>>>>>    End_Function
77812>>>>>>>>>>>>>
77812>>>>>>>>>>>>>    // Pass a driver id and the function will return
77812>>>>>>>>>>>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
77812>>>>>>>>>>>>>    // quite work and always returns "MS SQL Server"
77812>>>>>>>>>>>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
77814>>>>>>>>>>>>>        Integer iRetval
77814>>>>>>>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
77816>>>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
77817>>>>>>>>>>>>>        End
77817>>>>>>>>>>>>>>
77817>>>>>>>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
77819>>>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
77820>>>>>>>>>>>>>        End
77820>>>>>>>>>>>>>>
77820>>>>>>>>>>>>>        If (sDriverID = DB2_DRV_ID) Begin
77822>>>>>>>>>>>>>            Move EN_dbTypeDB2 to iRetval
77823>>>>>>>>>>>>>        End
77823>>>>>>>>>>>>>>
77823>>>>>>>>>>>>>        If (sDriverID = DFBTRDRV_ID) Begin
77825>>>>>>>>>>>>>            Move EN_DbTypePervasive to iRetval
77826>>>>>>>>>>>>>        End
77826>>>>>>>>>>>>>>
77826>>>>>>>>>>>>>        Function_Return iRetval
77827>>>>>>>>>>>>>    End_Function
77828>>>>>>>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
77828>>>>>>>>>>>>>>
77828>>>>>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
77830>>>>>>>>>>>>>>    Integer iStart iEnd
77830>>>>>>>>>>>>>>    String sRetval
77830>>>>>>>>>>>>>>
77830>>>>>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
77831>>>>>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
77832>>>>>>>>>>>>>>    If (iStart = 0) Begin
77834>>>>>>>>>>>>>>        Function_Return ""
77835>>>>>>>>>>>>>>    End
77835>>>>>>>>>>>>>>>
77835>>>>>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
77836>>>>>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
77837>>>>>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
77839>>>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
77840>>>>>>>>>>>>>>    End
77840>>>>>>>>>>>>>>>
77840>>>>>>>>>>>>>>    Else Begin
77841>>>>>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
77842>>>>>>>>>>>>>>    End
77842>>>>>>>>>>>>>>>
77842>>>>>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
77844>>>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
77845>>>>>>>>>>>>>>        Decrement iEnd
77846>>>>>>>>>>>>>>    End
77846>>>>>>>>>>>>>>>
77846>>>>>>>>>>>>>>    If (iEnd <> 0) Begin
77848>>>>>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
77849>>>>>>>>>>>>>>    End
77849>>>>>>>>>>>>>>>
77849>>>>>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
77850>>>>>>>>>>>>>>
77850>>>>>>>>>>>>>>    Function_Return (Trim(sRetval))
77851>>>>>>>>>>>>>>End_Function
77852>>>>>>>>>>>>>>
77852>>>>>>>>>>>>>>
77852>>>>>>>>>>>>>
77852>>>>>>>>>>>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
77854>>>>>>>>>>>>>        String sConnect
77854>>>>>>>>>>>>>        Handle hoDriver
77854>>>>>>>>>>>>>
77854>>>>>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver 
77855>>>>>>>>>>>>>        Set Name of hoDriver to "oDbUpdateDatabaseDriver"
77856>>>>>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
77857>>>>>>>>>>>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
77858>>>>>>>>>>>>>        Send Destroy of hoDriver
77859>>>>>>>>>>>>>
77859>>>>>>>>>>>>>        Function_Return sConnect
77860>>>>>>>>>>>>>    End_Function
77861>>>>>>>>>>>>>
77861>>>>>>>>>>>>>    // Short connection string used when writing to ini-file. This is to be compatible with DF19 DFConnId.ini files that uses this short format.
77861>>>>>>>>>>>>>    Function ConstructShortConnectionString String sDriverID String sServer String sDatabase Returns String
77863>>>>>>>>>>>>>        String sConnect
77863>>>>>>>>>>>>>
77863>>>>>>>>>>>>>        Case Begin
77863>>>>>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
77865>>>>>>>>>>>>>                Move (sConnect * CS_SQLIniServerKeyword + "=" + sServer) to sConnect
77866>>>>>>>>>>>>>                If (sDatabase <> "") Begin
77868>>>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
77869>>>>>>>>>>>>>                End
77869>>>>>>>>>>>>>>
77869>>>>>>>>>>>>>                Case Break
77870>>>>>>>>>>>>>
77870>>>>>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
77873>>>>>>>>>>>>>                If (Uppercase(sServer) contains ".DSN") Begin
77875>>>>>>>>>>>>>                    Move (CS_SQLIniFileDSNKeyword + "=" + sServer) to sConnect
77876>>>>>>>>>>>>>                End
77876>>>>>>>>>>>>>>
77876>>>>>>>>>>>>>                Else If (not(Uppercase(sServer) contains "DSN")) Begin
77879>>>>>>>>>>>>>                    Move (CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
77880>>>>>>>>>>>>>                End
77880>>>>>>>>>>>>>>
77880>>>>>>>>>>>>>
77880>>>>>>>>>>>>>                If (sDatabase <> "") Begin
77882>>>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
77883>>>>>>>>>>>>>                End
77883>>>>>>>>>>>>>>
77883>>>>>>>>>>>>>                Case Break
77884>>>>>>>>>>>>>
77884>>>>>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
77887>>>>>>>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
77888>>>>>>>>>>>>>                If (sDatabase <> "") Begin
77890>>>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
77891>>>>>>>>>>>>>                End
77891>>>>>>>>>>>>>>
77891>>>>>>>>>>>>>                Case Break
77892>>>>>>>>>>>>>
77892>>>>>>>>>>>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
77895>>>>>>>>>>>>>                Break
77896>>>>>>>>>>>>>
77896>>>>>>>>>>>>>            Case Else
77896>>>>>>>>>>>>>                Move "" to sConnect
77897>>>>>>>>>>>>>        Case End
77897>>>>>>>>>>>>>
77897>>>>>>>>>>>>>        Function_Return sConnect
77898>>>>>>>>>>>>>    End_Function
77899>>>>>>>>>>>>>
77899>>>>>>>>>>>>>    // Use Base64
77899>>>>>>>>>>>>>    Function EncryptPassword String sPassword Returns String
77901>>>>>>>>>>>>>        String sRetval
77901>>>>>>>>>>>>>        Handle hoLoginEncryption
77901>>>>>>>>>>>>>
77901>>>>>>>>>>>>>        Get Create (RefClass(cLoginEncryption)) to hoLoginEncryption
77902>>>>>>>>>>>>>        Set psEncryptPassword of hoLoginEncryption to (psHashString(Self))
77903>>>>>>>>>>>>>        Get EncryptPassword of hoLoginEncryption sPassword to sRetval
77904>>>>>>>>>>>>>        Send Destroy of hoLoginEncryption
77905>>>>>>>>>>>>>          
77905>>>>>>>>>>>>>        Function_Return sRetval
77906>>>>>>>>>>>>>    End_Function
77907>>>>>>>>>>>>>
77907>>>>>>>>>>>>>    Function DecryptPassword String sPassword Returns String
77909>>>>>>>>>>>>>        String sRetval
77909>>>>>>>>>>>>>        Handle hoLoginEncryption
77909>>>>>>>>>>>>>
77909>>>>>>>>>>>>>        Get Create (RefClass(cLoginEncryption)) to hoLoginEncryption
77910>>>>>>>>>>>>>        Set psEncryptPassword of hoLoginEncryption to (psHashString(Self))
77911>>>>>>>>>>>>>        Get DecryptPassword of hoLoginEncryption sPassword to sRetval
77912>>>>>>>>>>>>>        Send Destroy of hoLoginEncryption
77913>>>>>>>>>>>>>
77913>>>>>>>>>>>>>        Function_Return sRetval
77914>>>>>>>>>>>>>    End_Function
77915>>>>>>>>>>>>>
77915>>>>>>>>>>>>>    // Returns the full path of the Application (no trailing "\")
77915>>>>>>>>>>>>>    Function ApplicationPath Returns String
77917>>>>>>>>>>>>>        String sApplicationFileName sPath
77917>>>>>>>>>>>>>        Integer iNumChars iRetval
77917>>>>>>>>>>>>>
77917>>>>>>>>>>>>>        Move (Repeat(Character(0), 1024))    to sApplicationFileName
77918>>>>>>>>>>>>>        Move (GetModuleFileName(0, AddressOf(sApplicationFileName), 1024)) to iNumChars
77919>>>>>>>>>>>>>        Move (CString(sApplicationFileName)) to sApplicationFileName
77920>>>>>>>>>>>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to iRetval
77921>>>>>>>>>>>>>        Move (CString(sApplicationFileName)) to sPath
77922>>>>>>>>>>>>>
77922>>>>>>>>>>>>>        Function_Return sPath
77923>>>>>>>>>>>>>    End_Function
77924>>>>>>>>>>>>>
77924>>>>>>>>>>>>>    // Pass a filename including the extension. The return value
77924>>>>>>>>>>>>>    // will be the path of of the first found "sSearchFileName in the workspace.
77924>>>>>>>>>>>>>    // If not found in the workspace it will be search "globally" by the Get_File_Path command.
77924>>>>>>>>>>>>>    Function SearchLocallyThenGloballyForFile String sSearchFileName Returns String
77926>>>>>>>>>>>>>        Boolean bExists
77926>>>>>>>>>>>>>        Handle hoPaths hoIniFile
77926>>>>>>>>>>>>>        String[] asWorkSpaceFiles
77927>>>>>>>>>>>>>        String sProgramsPath sSection sFileName sRelativePath sRelativePaths sPath sDirSep sProgramsDir
77927>>>>>>>>>>>>>        Integer iSize iCount iPath iNoOfPaths iCountPath
77927>>>>>>>>>>>>>        
77927>>>>>>>>>>>>>        Get psIniFilePath to sProgramsPath
77928>>>>>>>>>>>>>        Get vFolderFormat sProgramsPath to sProgramsPath 
77929>>>>>>>>>>>>>        Move (Lowercase(sSearchFileName)) to sSearchFileName
77930>>>>>>>>>>>>>        Get vFilePathExists (sProgramsPath + sSearchFileName) to bExists   
77931>>>>>>>>>>>>>        If (bExists = True) Begin
77933>>>>>>>>>>>>>            Function_Return sProgramsPath
77934>>>>>>>>>>>>>        End                      
77934>>>>>>>>>>>>>>
77934>>>>>>>>>>>>>    
77934>>>>>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
77935>>>>>>>>>>>>>        If (Right(sProgramsPath, 1) ="\") Begin
77937>>>>>>>>>>>>>            Move (Left(sProgramsPath, Length(sProgramsPath) -1)) to sProgramsPath        
77938>>>>>>>>>>>>>        End                                              
77938>>>>>>>>>>>>>>
77938>>>>>>>>>>>>>        Get StringFromRightOfChar sProgramsPath sDirSep to sProgramsDir
77939>>>>>>>>>>>>>        
77939>>>>>>>>>>>>>        Move False to bExists
77940>>>>>>>>>>>>>        Get Create (RefClass(Array)) to hoPaths
77941>>>>>>>>>>>>>        Get WorkspaceIniFiles sProgramsPath to asWorkspaceFiles
77942>>>>>>>>>>>>>        Move (SizeOfArray(asWorkspaceFiles)) to iSize
77943>>>>>>>>>>>>>        Decrement iSize       
77944>>>>>>>>>>>>>        
77944>>>>>>>>>>>>>        For iCount from 0 to iSize
77950>>>>>>>>>>>>>>
77950>>>>>>>>>>>>>            Move asWorkspaceFiles[iCount] to sFileName
77951>>>>>>>>>>>>>            Get Create (Refclass(cIniFile)) to hoIniFile
77952>>>>>>>>>>>>>            Set psFileName of hoIniFile to sFileName
77953>>>>>>>>>>>>>            Send ReadSection of hoIniFile "Workspace" hoPaths
77954>>>>>>>>>>>>>            For iPath from 0 to (Item_Count(hoPaths) -1)
77960>>>>>>>>>>>>>>
77960>>>>>>>>>>>>>                Get Value of hoPaths iPath to sSection    
77961>>>>>>>>>>>>>                Get ReadString of hoIniFile "Workspace" sSection "" to sRelativePath 
77962>>>>>>>>>>>>>                // Check if there are more than one path specified;
77962>>>>>>>>>>>>>                Get CountOfPaths of (phoWorkspace(ghoApplication)) sRelativePath to iNoOfPaths
77963>>>>>>>>>>>>>                If (iNoOfPaths > 1) Begin         
77965>>>>>>>>>>>>>                    Move sRelativePath to sRelativePaths
77966>>>>>>>>>>>>>                    For iCountPath from 1 to iNoOfPaths
77972>>>>>>>>>>>>>>
77972>>>>>>>>>>>>>                        Get PathAtIndex of (phoWorkspace(ghoApplication)) sRelativePaths iCountPath to sRelativePath
77973>>>>>>>>>>>>>                        Get FullPathNames of (phoWorkspace(ghoApplication)) sRelativePath to sPath   
77974>>>>>>>>>>>>>                        Move (Replace((sDirSep + sProgramsDir + sDirSep), sPath, sDirSep)) to sPath
77975>>>>>>>>>>>>>                        Get vFolderFormat sPath to sPath
77976>>>>>>>>>>>>>                        Get vFilePathExists (sPath + sSearchFileName) to bExists
77977>>>>>>>>>>>>>                        If (bExists = True) Begin
77979>>>>>>>>>>>>>                            Move iNoOfPaths to iCountPath
77980>>>>>>>>>>>>>                            Move (Item_Count(hoPaths)) to iPath // We're done.
77981>>>>>>>>>>>>>                            Move iSize to iCount
77982>>>>>>>>>>>>>                        End                                                    
77982>>>>>>>>>>>>>>
77982>>>>>>>>>>>>>                    Loop
77983>>>>>>>>>>>>>>
77983>>>>>>>>>>>>>                End
77983>>>>>>>>>>>>>>
77983>>>>>>>>>>>>>                Else Begin
77984>>>>>>>>>>>>>                    Get FullPathNames of (phoWorkspace(ghoApplication)) sRelativePath to sPath   
77985>>>>>>>>>>>>>                    Move (Replace((sDirSep + sProgramsDir + sDirSep), sPath, sDirSep)) to sPath
77986>>>>>>>>>>>>>                    Get vFolderFormat sPath to sPath
77987>>>>>>>>>>>>>                    Get vFilePathExists (sPath + sSearchFileName) to bExists
77988>>>>>>>>>>>>>                    If (bExists = True) Begin
77990>>>>>>>>>>>>>                        Move (Item_Count(hoPaths)) to iPath // We're done.
77991>>>>>>>>>>>>>                        Move iSize to iCount
77992>>>>>>>>>>>>>                    End                                                    
77992>>>>>>>>>>>>>>
77992>>>>>>>>>>>>>                End
77992>>>>>>>>>>>>>>
77992>>>>>>>>>>>>>            Loop
77993>>>>>>>>>>>>>>
77993>>>>>>>>>>>>>            If (bExists = False) Begin
77995>>>>>>>>>>>>>                Move "" to sPath    
77996>>>>>>>>>>>>>            End
77996>>>>>>>>>>>>>>
77996>>>>>>>>>>>>>            Send Destroy of hoIniFile          
77997>>>>>>>>>>>>>        Loop        
77998>>>>>>>>>>>>>>
77998>>>>>>>>>>>>>        Send Destroy of hoPaths
77999>>>>>>>>>>>>>        
77999>>>>>>>>>>>>>        // Then not found in workspace, look for the file in DFSysPath;
77999>>>>>>>>>>>>>        If (sPath = "") Begin
78001>>>>>>>>>>>>>            Get_File_Path sSearchFileName to sFileName   
78002>>>>>>>>>>>>>            Get ParseFolderName sFileName to sPath
78003>>>>>>>>>>>>>        End                  
78003>>>>>>>>>>>>>>
78003>>>>>>>>>>>>>        
78003>>>>>>>>>>>>>        Function_Return sPath    
78004>>>>>>>>>>>>>    End_Function
78005>>>>>>>>>>>>>    
78005>>>>>>>>>>>>>    // Pass the path to the workspace Programs folder - returns a string array
78005>>>>>>>>>>>>>    // with one or more .ws file names.
78005>>>>>>>>>>>>>    // First checks if there is a .sws file - and if so reads the name of the
78005>>>>>>>>>>>>>    // workspace file (.ws) and returns it as a string array.
78005>>>>>>>>>>>>>    // If _no_ .sws file is found, enumerates the passed sProgramsPath variable
78005>>>>>>>>>>>>>    Function WorkspaceIniFiles String sProgramsPath Returns String[]
78007>>>>>>>>>>>>>        String[] asSWSFiles asWorkspaceFiles   
78009>>>>>>>>>>>>>        String sFile sHomePath sDirSep
78009>>>>>>>>>>>>>        Integer iCh iSize
78009>>>>>>>>>>>>>        Boolean bExists      
78009>>>>>>>>>>>>>        Handle hoIniFile 
78009>>>>>>>>>>>>>        
78009>>>>>>>>>>>>>        Move (ResizeArray(asSWSFiles, 0)) to asSWSFiles
78010>>>>>>>>>>>>>        Move (ResizeArray(asWorkspaceFiles, 0)) to asWorkspaceFiles
78011>>>>>>>>>>>>>        If (Right(sProgramsPath, 1) ="\") Begin
78013>>>>>>>>>>>>>            Move (Left(sProgramsPath, Length(sProgramsPath) -1)) to sProgramsPath        
78014>>>>>>>>>>>>>        End                                              
78014>>>>>>>>>>>>>>
78014>>>>>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
78015>>>>>>>>>>>>>        Get StringFromRightOfChar sProgramsPath sDirSep to sHomePath
78016>>>>>>>>>>>>>        Move (Replace(sHomePath, sProgramsPath, "")) to sHomePath
78017>>>>>>>>>>>>>        Get vFolderFormat sHomePath to sHomePath 
78018>>>>>>>>>>>>>        
78018>>>>>>>>>>>>>        // First check if theres an .sws file. If there is we will open it and
78018>>>>>>>>>>>>>        // read the name of the .ws file name.
78018>>>>>>>>>>>>>        File_Exist (sHomePath + "*.sws") bExists
78019>>>>>>>>>>>>>        If (bExists = True) Begin
78021>>>>>>>>>>>>>            Get Seq_Open_input_Channel ("dir:" + sHomePath + "*.sws") to iCh
78022>>>>>>>>>>>>>            If (iCh < 0) Begin
78024>>>>>>>>>>>>>                Function_Return asSWSFiles
78025>>>>>>>>>>>>>            End                                 
78025>>>>>>>>>>>>>>
78025>>>>>>>>>>>>>            
78025>>>>>>>>>>>>>            Repeat
78025>>>>>>>>>>>>>>
78025>>>>>>>>>>>>>                Readln channel iCh sFile
78027>>>>>>>>>>>>>                If (Trim(sFile) <> "") Begin
78029>>>>>>>>>>>>>                    Move sFile to asSWSFiles[SizeOfArray(asSWSFiles)]
78030>>>>>>>>>>>>>                End
78030>>>>>>>>>>>>>>
78030>>>>>>>>>>>>>            Until (SeqEof = True)
78032>>>>>>>>>>>>>            Send Seq_Close_Channel iCh    
78033>>>>>>>>>>>>>            
78033>>>>>>>>>>>>>            Move (SizeOfArray(asSWSFiles)) to iSize
78034>>>>>>>>>>>>>            If (iSize <> 0) Begin
78036>>>>>>>>>>>>>                Get Create (RefClass(cIniFile)) to hoIniFile  
78037>>>>>>>>>>>>>                // Use the file with that is last as it might have the DataFlex version in it,
78037>>>>>>>>>>>>>                // and thus is the latest one and it is more likely it is accurate (?)...
78037>>>>>>>>>>>>>                Move asSWSFiles[SizeOfArray(asSWSFiles) -1] to sFile
78038>>>>>>>>>>>>>                Set psFileName of hoIniFile to (sHomePath + sFile)
78039>>>>>>>>>>>>>                Get ReadString of hoIniFile "WorkspacePaths" "ConfigFile" "" to sFile
78040>>>>>>>>>>>>>                If (sFile <> "") Begin
78042>>>>>>>>>>>>>                    Move (Replace(".", sFile, sHomePath)) to sFile
78043>>>>>>>>>>>>>                    Move (Replace((sDirSep + String(sDirSep)), sFile, sDirSep)) to sFile
78044>>>>>>>>>>>>>                    File_Exist sFile bExists
78045>>>>>>>>>>>>>                    If (bExists = True) Begin
78047>>>>>>>>>>>>>                        Move sFile to asWorkspaceFiles[0] 
78048>>>>>>>>>>>>>                    End
78048>>>>>>>>>>>>>>
78048>>>>>>>>>>>>>                End
78048>>>>>>>>>>>>>>
78048>>>>>>>>>>>>>                Send Destroy of hoIniFile
78049>>>>>>>>>>>>>            End
78049>>>>>>>>>>>>>>
78049>>>>>>>>>>>>>        End
78049>>>>>>>>>>>>>>
78049>>>>>>>>>>>>>        
78049>>>>>>>>>>>>>        // If no .sws file exists, enumerate the .ws files from the Programs folder:    
78049>>>>>>>>>>>>>        If (SizeOfArray(asWorkspaceFiles) = 0) Begin
78051>>>>>>>>>>>>>            Get vFolderFormat sProgramsPath to sProgramsPath 
78052>>>>>>>>>>>>>            File_Exist (sProgramsPath + "*.ws") bExists
78053>>>>>>>>>>>>>            If (bExists = False) Begin
78055>>>>>>>>>>>>>                Function_Return asWorkspaceFiles
78056>>>>>>>>>>>>>            End
78056>>>>>>>>>>>>>>
78056>>>>>>>>>>>>>        
78056>>>>>>>>>>>>>            Get Seq_Open_input_Channel ("dir:" + sProgramsPath + "*.ws") to iCh
78057>>>>>>>>>>>>>            If (iCh < 0) Begin
78059>>>>>>>>>>>>>                Function_Return asWorkspaceFiles
78060>>>>>>>>>>>>>            End                                 
78060>>>>>>>>>>>>>>
78060>>>>>>>>>>>>>            
78060>>>>>>>>>>>>>            Repeat
78060>>>>>>>>>>>>>>
78060>>>>>>>>>>>>>                Readln channel iCh sFile
78062>>>>>>>>>>>>>                If (Trim(sFile) <> "") Begin
78064>>>>>>>>>>>>>                    Move sFile to asWorkspaceFiles[SizeOfArray(asWorkspaceFiles)]
78065>>>>>>>>>>>>>                End
78065>>>>>>>>>>>>>>
78065>>>>>>>>>>>>>            Until (SeqEof = True)
78067>>>>>>>>>>>>>            Send Seq_Close_Channel iCh
78068>>>>>>>>>>>>>        End
78068>>>>>>>>>>>>>>
78068>>>>>>>>>>>>>        
78068>>>>>>>>>>>>>        Function_Return asWorkspaceFiles
78069>>>>>>>>>>>>>    End_Function
78070>>>>>>>>>>>>>
78070>>>>>>>>>>>>>End_Class
78071>>>>>>>>>>>Use cDbUpdateDatabaseDriver.pkg
78071>>>>>>>>>>>Use vWin32fh.pkg
78071>>>>>>>>>>>
78071>>>>>>>>>>>// The cConnection class is the new SQL connections class for DF 19.
78071>>>>>>>>>>>// If an object of the cConnection class hasn't been instantiated we use a "dummy" class in its place.
78071>>>>>>>>>>>
78071>>>>>>>>>>>// We're making references to this object handle so we need it defined
78071>>>>>>>>>>>// here as well as for the cDbUpdateHandler class
78071>>>>>>>>>>>
78071>>>>>>>>>>>    Global_Variable Handle ghoSQLConnectionHandler
78071>>>>>>>>>>>    Move 0 to ghoSQLConnectionHandler
78072>>>>>>>>>>>
78072>>>>>>>>>>>Class cSQLConnectionHandler is a cObject
78073>>>>>>>>>>>
78073>>>>>>>>>>>    Procedure Construct_Object
78075>>>>>>>>>>>        Handle ho
78075>>>>>>>>>>>        Forward Send Construct_Object
78077>>>>>>>>>>>        Move Self to ghoSQLConnectionHandler
78078>>>>>>>>>>>
78078>>>>>>>>>>>        Property Handle phoSQLConnectionIniFile 
78079>>>>>>>>>>>        Get  Create (RefClass(cSQLConnectionIniFile)) to ho
78080>>>>>>>>>>>        Set Name of ho to "oSQLConnectionIniFile"
78081>>>>>>>>>>>        Set phoSQLConnectionIniFile to ho
78082>>>>>>>>>>>        
78082>>>>>>>>>>>
78082>>>>>>>>>>>        // These properties are used by the cDbUpdateVersion and cDbUpdateFunctionLibrary classes,
78082>>>>>>>>>>>        // but put here so they can be set/get in both class objects. Those classes has "relay"
78082>>>>>>>>>>>        // methods to this class.
78082>>>>>>>>>>>        Property Boolean pbUseConnectionID True
78083>>>>>>>>>>>        Property Boolean pbToANSI          True
78084>>>>>>>>>>>        Property Boolean pbRecnum          True
78085>>>>>>>>>>>        Property Boolean pbCopyData        True
78086>>>>>>>>>>>        Property Boolean pbApiTableUpdateAuto    False
78087>>>>>>>>>>>        Property Boolean pbCompareDate_DateTime  False
78088>>>>>>>>>>>        Property Boolean pbCompareIndexAscending False
78089>>>>>>>>>>>        Property Boolean pbCompareIndexUppercase False
78090>>>>>>>>>>>
78090>>>>>>>>>>>        // Driver default value settings:
78090>>>>>>>>>>>        // Note: When the object is created the corresponding values
78090>>>>>>>>>>>        // from the driver .int files are read.
78090>>>>>>>>>>>        // Sample: Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of {driverNumber} to {StringVariable}
78090>>>>>>>>>>>        Property String psDriverDefaultValueASCII    ""
78091>>>>>>>>>>>        Property String psDriverDefaultValueBinary   ""
78092>>>>>>>>>>>        Property String psDriverDefaultValueDate     ""
78093>>>>>>>>>>>        Property String psDriverDefaultValueDateTime ""
78094>>>>>>>>>>>        Property String psDriverDefaultValueNumeric  ""
78095>>>>>>>>>>>        Property String psDriverDefaultValueText     ""
78096>>>>>>>>>>>
78096>>>>>>>>>>>        // Driver "nullability" settings:
78096>>>>>>>>>>>        // Note: When the object is created the corresponding values
78096>>>>>>>>>>>        // from the driver .int files are read.
78096>>>>>>>>>>>        // Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII of {driverNumber} to {BooleanVariable}
78096>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableASCII    False
78097>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableBinary   False
78098>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableDate     False
78099>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableDateTime False
78100>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableNumeric  False
78101>>>>>>>>>>>        Property Boolean pbDriverDefaultNullableText     False
78102>>>>>>>>>>>
78102>>>>>>>>>>>        // *** This is the central point of connection data for the Database Update Framework ***
78102>>>>>>>>>>>        //     It is private because the get/set version also updates the DAW
78102>>>>>>>>>>>        //     driver interfaces.
78102>>>>>>>>>>>        //     There are also procedure/function pairs to set/get individual data members
78102>>>>>>>>>>>        //     of the struct they are all routed throu this struct property.
78102>>>>>>>>>>>        Property tSQLConnection Private.pSQLConnection
78103>>>>>>>>>>>
78103>>>>>>>>>>>    End_Procedure
78104>>>>>>>>>>>
78104>>>>>>>>>>>    Procedure End_Construct_Object
78106>>>>>>>>>>>        tSQLConnection SQLConnection
78106>>>>>>>>>>>        tSQLConnection SQLConnection
78106>>>>>>>>>>>
78106>>>>>>>>>>>        Forward Send End_Construct_Object
78108>>>>>>>>>>>
78108>>>>>>>>>>>        // Now is the time to read and apply SQL connection settings.
78108>>>>>>>>>>>        Get SetupSQLConnection True True to SQLConnection
78109>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78110>>>>>>>>>>>    End_Procedure
78111>>>>>>>>>>>
78111>>>>>>>>>>>    // *** Properties ***
78111>>>>>>>>>>>    // All connection related "properties" (get/set pairs) are really done by changing the
78111>>>>>>>>>>>    // private.pSQLConnection struct connection property. These "properties" are
78111>>>>>>>>>>>    // merely here for conveniance.
78111>>>>>>>>>>>    //
78111>>>>>>>>>>>    // The pSQLConnection get/set are here so we have a "central hub"
78111>>>>>>>>>>>    // where we update data to/from the DAW driver interfaces and this framework.
78111>>>>>>>>>>>    // This struct property contains all the connection data.
78111>>>>>>>>>>>    //
78111>>>>>>>>>>>    Procedure Set pSQLConnection tSQLConnection SQLConnection
78113>>>>>>>>>>>        Boolean bOK
78113>>>>>>>>>>>
78113>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78114>>>>>>>>>>>
78114>>>>>>>>>>>        // When starting a program we might not have a connection id yet:
78114>>>>>>>>>>>        If (SQLConnection.sDriverID = DATAFLEX_ID) Begin
78116>>>>>>>>>>>//        If (SQLConnection.sConnectionID = "" or SQLConnection.sDriverID = DATAFLEX_ID) Begin
78116>>>>>>>>>>>            Procedure_Return
78117>>>>>>>>>>>        End
78117>>>>>>>>>>>>
78117>>>>>>>>>>>
78117>>>>>>>>>>>        // If a DAW DFConnId.ini file was read instead of the DUF SQLConnections.ini file we should by now
78117>>>>>>>>>>>        // be logged in already and don't want to do it again.
78117>>>>>>>>>>>        If (SQLConnection.bDAWConnection = False) Begin
78119>>>>>>>>>>>            // After we have set the class property we need to tell the DAW
78119>>>>>>>>>>>            // driver interfaces about the change & make a new login.
78119>>>>>>>>>>>            Get SQLLogin SQLConnection to bOK
78120>>>>>>>>>>>            If (bOK = False) Begin
78122>>>>>>>>>>>                Error DFERR_PROGRAM "Login error."
78123>>>>>>>>>>>>
78123>>>>>>>>>>>            End
78123>>>>>>>>>>>>
78123>>>>>>>>>>>        End
78123>>>>>>>>>>>>
78123>>>>>>>>>>>
78123>>>>>>>>>>>        // Now is the time to setup our driver default values by reading the driver .int file:
78123>>>>>>>>>>>        Send SetupDriverDefaults SQLConnection.sDriverID
78124>>>>>>>>>>>
78124>>>>>>>>>>>    End_Procedure
78125>>>>>>>>>>>
78125>>>>>>>>>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
78125>>>>>>>>>>>    // attempt to load the driver.
78125>>>>>>>>>>>    // Returns true if the passed driver is SQL based.
78125>>>>>>>>>>>    Function IsSQLDriver String sDriverID Returns Boolean
78127>>>>>>>>>>>        Boolean bOK
78127>>>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
78128>>>>>>>>>>>        Function_Return bOK
78129>>>>>>>>>>>    End_Function
78130>>>>>>>>>>>
78130>>>>>>>>>>>    // Reads the driver .int file and sets class properties of the cDbUpdateFunctionLibrary accordingly.
78130>>>>>>>>>>>    Procedure SetupDriverDefaults String sDriverID
78132>>>>>>>>>>>        String sAttributeValue
78132>>>>>>>>>>>        Integer iDriverID
78132>>>>>>>>>>>        Boolean bNULL bSQLDriver
78132>>>>>>>>>>>
78132>>>>>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
78133>>>>>>>>>>>        If (bSQLDriver = False) Begin
78135>>>>>>>>>>>            Procedure_Return
78136>>>>>>>>>>>        End                                      
78136>>>>>>>>>>>>
78136>>>>>>>>>>>        
78136>>>>>>>>>>>        Get DriverIndex sDriverID to iDriverID
78137>>>>>>>>>>>
78137>>>>>>>>>>>        // Driver default values for various data types:
78137>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_ASCII of iDriverID      to sAttributeValue
78140>>>>>>>>>>>        Set psDriverDefaultValueASCII                                   to sAttributeValue
78141>>>>>>>>>>>
78141>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_BINARY of iDriverID     to sAttributeValue
78144>>>>>>>>>>>        Set psDriverDefaultValueBinary                                  to sAttributeValue
78145>>>>>>>>>>>
78145>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATE of iDriverID       to sAttributeValue
78148>>>>>>>>>>>        Set psDriverDefaultValueDate                                    to sAttributeValue
78149>>>>>>>>>>>
78149>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATETIME of iDriverID   to sAttributeValue
78152>>>>>>>>>>>        Set psDriverDefaultValueDateTime                                to sAttributeValue
78153>>>>>>>>>>>
78153>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of iDriverID    to sAttributeValue
78156>>>>>>>>>>>        Set psDriverDefaultValueNumeric                                 to sAttributeValue
78157>>>>>>>>>>>
78157>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_TEXT of iDriverID       to sAttributeValue
78160>>>>>>>>>>>        Set psDriverDefaultValueText                                    to sAttributeValue
78161>>>>>>>>>>>
78161>>>>>>>>>>>        // The default setting for the "nullability" of newly created ASCII columns.
78161>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII      of iDriverID to bNULL
78164>>>>>>>>>>>        Set pbDriverDefaultNullableASCII to bNULL
78165>>>>>>>>>>>
78165>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_BINARY     of iDriverID to bNULL
78168>>>>>>>>>>>        Set pbDriverDefaultNullableBinary to bNULL
78169>>>>>>>>>>>
78169>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATE       of iDriverID to bNULL
78172>>>>>>>>>>>        Set pbDriverDefaultNullableDate to bNULL
78173>>>>>>>>>>>
78173>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATETIME   of iDriverID to bNULL
78176>>>>>>>>>>>        Set pbDriverDefaultNullableDateTime to bNULL
78177>>>>>>>>>>>
78177>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_NUMERIC    of iDriverID to bNULL
78180>>>>>>>>>>>        Set pbDriverDefaultNullableNumeric to bNULL
78181>>>>>>>>>>>
78181>>>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_TEXT       of iDriverID to bNULL
78184>>>>>>>>>>>        Set pbDriverDefaultNullableText to bNULL
78185>>>>>>>>>>>
78185>>>>>>>>>>>    End_Procedure
78186>>>>>>>>>>>
78186>>>>>>>>>>>    Function SQLLogin tSQLConnection SQLConnection Returns Boolean
78188>>>>>>>>>>>        Boolean bOK bIsDaw
78188>>>>>>>>>>>        String sConnectionString
78188>>>>>>>>>>>        Handle hoErrorObj hoDriver hoIniFile
78188>>>>>>>>>>>        Integer iDriverID
78188>>>>>>>>>>>
78188>>>>>>>>>>>        Move False to bOK
78189>>>>>>>>>>>        Get IsDAWSQLDriver SQLConnection.sDriverID to bIsDaw
78190>>>>>>>>>>>
78190>>>>>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
78191>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to sConnectionString
78192>>>>>>>>>>>        Get DriverIndex SQLConnection.sDriverID to iDriverID
78193>>>>>>>>>>>        If (iDriverID = 0) Begin
78195>>>>>>>>>>>            Move hoErrorObj to Error_Object_Id
78196>>>>>>>>>>>            Function_Return False
78197>>>>>>>>>>>        End
78197>>>>>>>>>>>>
78197>>>>>>>>>>>
78197>>>>>>>>>>>        Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriverID to SQLConnection.bSilentLogin
78200>>>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
78201>>>>>>>>>>>        Set psDriverID of hoDriver to SQLConnection.sDriverID
78202>>>>>>>>>>>        Get DbLogin    of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
78203>>>>>>>>>>>        Send Destroy   of hoDriver
78204>>>>>>>>>>>
78204>>>>>>>>>>>        Function_Return bOK
78205>>>>>>>>>>>    End_Function
78206>>>>>>>>>>>
78206>>>>>>>>>>>    Function pSQLConnection Returns tSQLConnection
78208>>>>>>>>>>>        tSQLConnection SQLConnection
78208>>>>>>>>>>>        tSQLConnection SQLConnection
78208>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78209>>>>>>>>>>>        Function_Return SQLConnection
78210>>>>>>>>>>>    End_Function
78211>>>>>>>>>>>
78211>>>>>>>>>>>    Procedure Set psConnectionID String sValue
78213>>>>>>>>>>>        tSQLConnection SQLConnection
78213>>>>>>>>>>>        tSQLConnection SQLConnection
78213>>>>>>>>>>>
78213>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78214>>>>>>>>>>>        If (SQLConnection.sConnectionID = "") Begin
78216>>>>>>>>>>>            Move sValue to SQLConnection.sConnectionID
78217>>>>>>>>>>>        End
78217>>>>>>>>>>>>
78217>>>>>>>>>>>
78217>>>>>>>>>>>        // Else we might want to change the current connection ID
78217>>>>>>>>>>>        Else If (SQLConnection.sConnectionID <> "" and SQLConnection.sConnectionID <> sValue) Begin
78220>>>>>>>>>>>            Move False to Err
78221>>>>>>>>>>>            Logout SQLConnection.sDriverID
78222>>>>>>>>>>>            // This will also make a login to the new server.
78222>>>>>>>>>>>            Get SQLIniFileConnectionID of (phoSQLConnectionIniFile(Self)) sValue to SQLConnection
78223>>>>>>>>>>>        End
78223>>>>>>>>>>>>
78223>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78224>>>>>>>>>>>    End_Procedure
78225>>>>>>>>>>>
78225>>>>>>>>>>>    Function psConnectionID Returns String
78227>>>>>>>>>>>        tSQLConnection SQLConnection
78227>>>>>>>>>>>        tSQLConnection SQLConnection
78227>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78228>>>>>>>>>>>        Function_Return SQLConnection.sConnectionID
78229>>>>>>>>>>>    End_Function
78230>>>>>>>>>>>
78230>>>>>>>>>>>    // Note: If the psDriverID + other connection properties are to be changed,
78230>>>>>>>>>>>    //       the psDriverID *must* be the first property that is changed!
78230>>>>>>>>>>>    //       Otherwise errors might be raised by the driver when e.g. the format
78230>>>>>>>>>>>    //       for a connection string has the wrong format for that driver.
78230>>>>>>>>>>>    Procedure Set psDriverID String sValue
78232>>>>>>>>>>>        tSQLConnection SQLConnection
78232>>>>>>>>>>>        tSQLConnection SQLConnection
78232>>>>>>>>>>>        Get pSQLConnection to SQLConnection
78233>>>>>>>>>>>        Move sValue        to SQLConnection.sDriverID
78234>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78235>>>>>>>>>>>        If (sValue <> DATAFLEX_ID) Begin
78237>>>>>>>>>>>            Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
78238>>>>>>>>>>>        End
78238>>>>>>>>>>>>
78238>>>>>>>>>>>    End_Procedure
78239>>>>>>>>>>>
78239>>>>>>>>>>>    Function psDriverID Returns String
78241>>>>>>>>>>>        tSQLConnection SQLConnection
78241>>>>>>>>>>>        tSQLConnection SQLConnection
78241>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78242>>>>>>>>>>>        If (SQLConnection.sDriverID = "") Begin
78244>>>>>>>>>>>            Move DATAFLEX_ID to SQLConnection.sDriverID // Default is the DataFlex driver.
78245>>>>>>>>>>>        End
78245>>>>>>>>>>>>
78245>>>>>>>>>>>        Function_Return SQLConnection.sDriverID
78246>>>>>>>>>>>    End_Function
78247>>>>>>>>>>>
78247>>>>>>>>>>>    Procedure Set psConnectionString String sValue
78249>>>>>>>>>>>        tSQLConnection SQLConnection
78249>>>>>>>>>>>        tSQLConnection SQLConnection
78249>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78250>>>>>>>>>>>        Move sValue        to SQLConnection.sConnectionString
78251>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78252>>>>>>>>>>>    End_Procedure
78253>>>>>>>>>>>
78253>>>>>>>>>>>    Function psConnectionString Returns String
78255>>>>>>>>>>>        tSQLConnection SQLConnection
78255>>>>>>>>>>>        tSQLConnection SQLConnection
78255>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78256>>>>>>>>>>>        Function_Return SQLConnection.sConnectionString
78257>>>>>>>>>>>    End_Function
78258>>>>>>>>>>>
78258>>>>>>>>>>>    Procedure Set psServer String sValue
78260>>>>>>>>>>>        tSQLConnection SQLConnection
78260>>>>>>>>>>>        tSQLConnection SQLConnection
78260>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78261>>>>>>>>>>>        Move sValue        to SQLConnection.sServer
78262>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
78263>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78264>>>>>>>>>>>    End_Procedure
78265>>>>>>>>>>>
78265>>>>>>>>>>>    Function psServer Returns String
78267>>>>>>>>>>>        tSQLConnection SQLConnection
78267>>>>>>>>>>>        tSQLConnection SQLConnection
78267>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78268>>>>>>>>>>>        Function_Return SQLConnection.sServer
78269>>>>>>>>>>>    End_Function
78270>>>>>>>>>>>
78270>>>>>>>>>>>    Procedure Set psDatabase String sValue
78272>>>>>>>>>>>        tSQLConnection SQLConnection
78272>>>>>>>>>>>        tSQLConnection SQLConnection
78272>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78273>>>>>>>>>>>        Move sValue        to SQLConnection.sDatabase
78274>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
78275>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78276>>>>>>>>>>>    End_Procedure
78277>>>>>>>>>>>
78277>>>>>>>>>>>    Function psDatabase Returns String
78279>>>>>>>>>>>        tSQLConnection SQLConnection
78279>>>>>>>>>>>        tSQLConnection SQLConnection
78279>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78280>>>>>>>>>>>        Function_Return SQLConnection.sDatabase
78281>>>>>>>>>>>    End_Function
78282>>>>>>>>>>>
78282>>>>>>>>>>>    Procedure Set psUserID String sValue
78284>>>>>>>>>>>        tSQLConnection SQLConnection
78284>>>>>>>>>>>        tSQLConnection SQLConnection
78284>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78285>>>>>>>>>>>        Move sValue        to SQLConnection.sUserID
78286>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
78287>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78288>>>>>>>>>>>    End_Procedure
78289>>>>>>>>>>>
78289>>>>>>>>>>>    Function psUserID Returns String
78291>>>>>>>>>>>        tSQLConnection SQLConnection
78291>>>>>>>>>>>        tSQLConnection SQLConnection
78291>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78292>>>>>>>>>>>        Function_Return SQLConnection.sUserID
78293>>>>>>>>>>>    End_Function
78294>>>>>>>>>>>
78294>>>>>>>>>>>    // This is the uncrypted password
78294>>>>>>>>>>>    Procedure Set psPassword String sValue
78296>>>>>>>>>>>        tSQLConnection SQLConnection
78296>>>>>>>>>>>        tSQLConnection SQLConnection
78296>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78297>>>>>>>>>>>        Move sValue        to SQLConnection.sPassword
78298>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
78299>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78300>>>>>>>>>>>    End_Procedure
78301>>>>>>>>>>>
78301>>>>>>>>>>>    Function psPassword Returns String
78303>>>>>>>>>>>        tSQLConnection SQLConnection
78303>>>>>>>>>>>        tSQLConnection SQLConnection
78303>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78304>>>>>>>>>>>        Function_Return SQLConnection.sPassword
78305>>>>>>>>>>>    End_Function
78306>>>>>>>>>>>
78306>>>>>>>>>>>    Procedure Set pbTrusted Boolean bValue
78308>>>>>>>>>>>        tSQLConnection SQLConnection
78308>>>>>>>>>>>        tSQLConnection SQLConnection
78308>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78309>>>>>>>>>>>        Move bValue        to SQLConnection.bTrusted
78310>>>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
78311>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78312>>>>>>>>>>>    End_Procedure
78313>>>>>>>>>>>
78313>>>>>>>>>>>    Function pbTrusted Returns Boolean
78315>>>>>>>>>>>        tSQLConnection SQLConnection
78315>>>>>>>>>>>        tSQLConnection SQLConnection
78315>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78316>>>>>>>>>>>        Function_Return SQLConnection.bTrusted
78317>>>>>>>>>>>    End_Function
78318>>>>>>>>>>>
78318>>>>>>>>>>>    // *** All of these properties are special to the Database Update Framework ***
78318>>>>>>>>>>>    //     Thus they are not propagated to the DAW classes and that is why
78318>>>>>>>>>>>    //     the Private.pSQLConnection property is set instead of the going throu
78318>>>>>>>>>>>    //     the central pSQLConnection "hub".
78318>>>>>>>>>>>    Procedure Set pbSilentLogin Boolean bValue
78320>>>>>>>>>>>        tSQLConnection SQLConnection
78320>>>>>>>>>>>        tSQLConnection SQLConnection
78320>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78321>>>>>>>>>>>        Move bValue to SQLConnection.bTrusted
78322>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78323>>>>>>>>>>>    End_Procedure
78324>>>>>>>>>>>
78324>>>>>>>>>>>    Function pbSilentLogin Returns Boolean
78326>>>>>>>>>>>        tSQLConnection SQLConnection
78326>>>>>>>>>>>        tSQLConnection SQLConnection
78326>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78327>>>>>>>>>>>        Function_Return SQLConnection.bSilentLogin
78328>>>>>>>>>>>    End_Function
78329>>>>>>>>>>>
78329>>>>>>>>>>>    Procedure Set piDbType Integer iValue
78331>>>>>>>>>>>        tSQLConnection SQLConnection
78331>>>>>>>>>>>        tSQLConnection SQLConnection
78331>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78332>>>>>>>>>>>        Move iValue to SQLConnection.iDbType
78333>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78334>>>>>>>>>>>    End_Procedure
78335>>>>>>>>>>>
78335>>>>>>>>>>>    Function piDbType Returns Integer
78337>>>>>>>>>>>        tSQLConnection SQLConnection
78337>>>>>>>>>>>        tSQLConnection SQLConnection
78337>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78338>>>>>>>>>>>        Function_Return SQLConnection.iDbType
78339>>>>>>>>>>>    End_Function
78340>>>>>>>>>>>
78340>>>>>>>>>>>    Procedure Set psBaseTableSpace String sValue
78342>>>>>>>>>>>        tSQLConnection SQLConnection
78342>>>>>>>>>>>        tSQLConnection SQLConnection
78342>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78343>>>>>>>>>>>        Move sValue to SQLConnection.sBaseTableSpace
78344>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78345>>>>>>>>>>>    End_Procedure
78346>>>>>>>>>>>
78346>>>>>>>>>>>    Function psBaseTableSpace Returns String
78348>>>>>>>>>>>        tSQLConnection SQLConnection
78348>>>>>>>>>>>        tSQLConnection SQLConnection
78348>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78349>>>>>>>>>>>        Function_Return SQLConnection.sBaseTableSpace
78350>>>>>>>>>>>    End_Function
78351>>>>>>>>>>>
78351>>>>>>>>>>>    Procedure Set psIndexTableSpace String sValue
78353>>>>>>>>>>>        tSQLConnection SQLConnection
78353>>>>>>>>>>>        tSQLConnection SQLConnection
78353>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78354>>>>>>>>>>>        Move sValue to SQLConnection.sIndexTableSpace
78355>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78356>>>>>>>>>>>    End_Procedure
78357>>>>>>>>>>>
78357>>>>>>>>>>>    Function psIndexTableSpace Returns String
78359>>>>>>>>>>>        tSQLConnection SQLConnection
78359>>>>>>>>>>>        tSQLConnection SQLConnection
78359>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78360>>>>>>>>>>>        Function_Return SQLConnection.sIndexTableSpace
78361>>>>>>>>>>>    End_Function
78362>>>>>>>>>>>
78362>>>>>>>>>>>    Procedure Set psLongTableSpace String sValue
78364>>>>>>>>>>>        tSQLConnection SQLConnection
78364>>>>>>>>>>>        tSQLConnection SQLConnection
78364>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78365>>>>>>>>>>>        Move sValue to SQLConnection.sLongTableSpace
78366>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78367>>>>>>>>>>>    End_Procedure
78368>>>>>>>>>>>
78368>>>>>>>>>>>    Function psLongTableSpace Returns String
78370>>>>>>>>>>>        tSQLConnection SQLConnection
78370>>>>>>>>>>>        tSQLConnection SQLConnection
78370>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78371>>>>>>>>>>>        Function_Return SQLConnection.sLongTableSpace
78372>>>>>>>>>>>    End_Function
78373>>>>>>>>>>>
78373>>>>>>>>>>>    Procedure Set psSchema String sValue
78375>>>>>>>>>>>        tSQLConnection SQLConnection
78375>>>>>>>>>>>        tSQLConnection SQLConnection
78375>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78376>>>>>>>>>>>        Move sValue to SQLConnection.sSchema
78377>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78378>>>>>>>>>>>    End_Procedure
78379>>>>>>>>>>>
78379>>>>>>>>>>>    Function psSchema Returns String
78381>>>>>>>>>>>        tSQLConnection SQLConnection
78381>>>>>>>>>>>        tSQLConnection SQLConnection
78381>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78382>>>>>>>>>>>        Function_Return SQLConnection.sSchema
78383>>>>>>>>>>>    End_Function
78384>>>>>>>>>>>
78384>>>>>>>>>>>    Procedure Set pbEnabled Boolean bValue
78386>>>>>>>>>>>        tSQLConnection SQLConnection
78386>>>>>>>>>>>        tSQLConnection SQLConnection
78386>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78387>>>>>>>>>>>        Move bValue to SQLConnection.bEnabled
78388>>>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
78389>>>>>>>>>>>    End_Procedure
78390>>>>>>>>>>>
78390>>>>>>>>>>>    Function pbEnabled Returns Boolean
78392>>>>>>>>>>>        tSQLConnection SQLConnection
78392>>>>>>>>>>>        tSQLConnection SQLConnection
78392>>>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
78393>>>>>>>>>>>        Function_Return SQLConnection.bEnabled
78394>>>>>>>>>>>    End_Function
78395>>>>>>>>>>>
78395>>>>>>>>>>>
78395>>>>>>>>>>>    // ************************************
78395>>>>>>>>>>>    Function SetupSQLConnection Boolean bReadDFConnSettings Boolean bReadSQLConnections Returns tSQLConnection
78397>>>>>>>>>>>        tSQLConnection SQLConnection
78397>>>>>>>>>>>        tSQLConnection SQLConnection
78397>>>>>>>>>>>
78397>>>>>>>>>>>        // If this object was created by the cDbUpdateHandler class we will
78397>>>>>>>>>>>        // deferr reading SQL connection values until later.
78397>>>>>>>>>>>        If (bReadDFConnSettings = True) Begin
78399>>>>>>>>>>>            // This is the new SQL login logic for DF 19 and up; "Managed Connections"
78399>>>>>>>>>>>            If (ghoConnection > 0) Begin
78401>>>>>>>>>>>                Get ReadcConnections to SQLConnection
78402>>>>>>>>>>>            End
78402>>>>>>>>>>>>
78402>>>>>>>>>>>
78402>>>>>>>>>>>            // In addition to the above; there might be other values set even if a cConnection
78402>>>>>>>>>>>            // object is used.
78402>>>>>>>>>>>            If (bReadSQLConnections = True) Begin
78404>>>>>>>>>>>                Get ReadSQLConnectionsIniSettings to SQLConnection
78405>>>>>>>>>>>            End
78405>>>>>>>>>>>>
78405>>>>>>>>>>>        End
78405>>>>>>>>>>>>
78405>>>>>>>>>>>
78405>>>>>>>>>>>        Function_Return SQLConnection
78406>>>>>>>>>>>    End_Function
78407>>>>>>>>>>>
78407>>>>>>>>>>>    // This is for the new cConnection class used by DF 19 and up (only).
78407>>>>>>>>>>>    Function ReadcConnections Returns tSQLConnection
78409>>>>>>>>>>>        tConnection Connection
78409>>>>>>>>>>>        tConnection Connection
78409>>>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
78409>>>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
78409>>>>>>>>>>>        Integer iRetval iDbType
78409>>>>>>>>>>>        Boolean bOK bConnected
78409>>>>>>>>>>>        String sConnectionID
78409>>>>>>>>>>>
78409>>>>>>>>>>>            tConnection[] Connections
78409>>>>>>>>>>>            tConnection[] Connections
78410>>>>>>>>>>>            // - If the DF 19 cConnection class has been used in the cApplication object
78410>>>>>>>>>>>            // - and there are multiple connection id's defined for the same driver. This is
78410>>>>>>>>>>>            //   because otherwise we can't possibly know which connection id to use... So
78410>>>>>>>>>>>            //   we then generate an error and abort the program...
78410>>>>>>>>>>>            Get IsSinglecConnection (&sConnectionID) to bOK
78411>>>>>>>>>>>            If (bOK = False) Begin
78413>>>>>>>>>>>                Error DFERR_PROGRAM ("Programming error. The psConnectionID must be set in the cDbUpdateVersion object when a cConnect object is used in the cApplication object, and there are multiple connections defined. Program will now exit!")
78414>>>>>>>>>>>>
78414>>>>>>>>>>>                Abort
78415>>>>>>>>>>>>
78415>>>>>>>>>>>            End
78415>>>>>>>>>>>>
78415>>>>>>>>>>>            If (sConnectionID = "") Begin
78417>>>>>>>>>>>                Get ConnectionIDs of ghoConnection to Connections
78418>>>>>>>>>>>                If (SizeOfArray(Connections) > 0) Begin
78420>>>>>>>>>>>                    Move Connections[0].sId to sConnectionID
78421>>>>>>>>>>>                End
78421>>>>>>>>>>>>
78421>>>>>>>>>>>            End
78421>>>>>>>>>>>>
78421>>>>>>>>>>>
78421>>>>>>>>>>>            Move 0 to iRetval
78422>>>>>>>>>>>            // DAW DF19 connection info:
78422>>>>>>>>>>>            // We first check that the connection is OK:
78422>>>>>>>>>>>            Get ConnectionIdIndex of ghoConnection sConnectionID to iRetval
78423>>>>>>>>>>>            // It might happen that no connection has been setup although the object exists, in case we do nothing.
78423>>>>>>>>>>>            If (iRetval = -1) Begin
78425>>>>>>>>>>>                Function_Return SQLConnectionEmpty
78426>>>>>>>>>>>            End
78426>>>>>>>>>>>>
78426>>>>>>>>>>>
78426>>>>>>>>>>>            If (sConnectionID <> "") Begin
78428>>>>>>>>>>>                Get ConnectionIdInfo of ghoConnection sConnectionID to Connection
78429>>>>>>>>>>>            End
78429>>>>>>>>>>>>
78429>>>>>>>>>>>            If (Connection.sId = "") Begin
78431>>>>>>>>>>>                Move True to SQLConnectionEmpty.bError
78432>>>>>>>>>>>                Function_Return SQLConnectionEmpty
78433>>>>>>>>>>>            End
78433>>>>>>>>>>>>
78433>>>>>>>>>>>
78433>>>>>>>>>>>            // DUF connection info struct property:
78433>>>>>>>>>>>            Get Private.pSQLConnection                       to SQLConnection
78434>>>>>>>>>>>
78434>>>>>>>>>>>            Move Connection.sId to sConnectionID
78435>>>>>>>>>>>            Get IsConnectionIdLoggedIn of ghoConnection sConnectionID to bConnected
78436>>>>>>>>>>>
78436>>>>>>>>>>>            If (bConnected = False) Begin
78438>>>>>>>>>>>                Get LoginConnectionId of ghoConnection sConnectionID to iRetval
78439>>>>>>>>>>>                If (iRetval <> 0) Begin
78441>>>>>>>>>>>                    Send UserError CS_DUF_CannotLoginToServer
78442>>>>>>>>>>>                    Send Exit_Application
78443>>>>>>>>>>>                End
78443>>>>>>>>>>>>
78443>>>>>>>>>>>                Move True                                   to SQLConnection.bDAWConnection
78444>>>>>>>>>>>                // We need to get the DAW connection info again as it might have
78444>>>>>>>>>>>                // been changed in the DAW db login dialog.
78444>>>>>>>>>>>                Get ConnectionIdInfo of ghoConnection sConnectionID to Connection
78445>>>>>>>>>>>            End
78445>>>>>>>>>>>>
78445>>>>>>>>>>>
78445>>>>>>>>>>>            Move True                                        to SQLConnection.bEnabled
78446>>>>>>>>>>>            Move Connection.bTrustedConnection               to SQLConnection.bTrusted
78447>>>>>>>>>>>
78447>>>>>>>>>>>            // Not used in DUF:
78447>>>>>>>>>>>            // Move Connection.iDriverIndex                    to SQLConnection.iDriverIndex
78447>>>>>>>>>>>
78447>>>>>>>>>>>            Move (If(Connection.iOptions = 0, False, True))  to SQLConnection.bSilentLogin
78448>>>>>>>>>>>            Move Connection.sConnectionString                to SQLConnection.sConnectionString
78449>>>>>>>>>>>            Move Connection.sDriver                          to SQLConnection.sDriverID
78450>>>>>>>>>>>            Move Connection.sId                              to SQLConnection.sConnectionID
78451>>>>>>>>>>>            Move Connection.sUID                             to SQLConnection.sUserID
78452>>>>>>>>>>>            Move Connection.sPWD                             to SQLConnection.sPassword
78453>>>>>>>>>>>
78453>>>>>>>>>>>            // Not used in DUF:
78453>>>>>>>>>>>            // Move Connection.sSection to SQLConnection.xxx
78453>>>>>>>>>>>
78453>>>>>>>>>>>            // The rest of the properties of the SQLConnection struct should have been
78453>>>>>>>>>>>            // setup in the cDbUpdateHandler object, and we should be able to reach them through delegation:
78453>>>>>>>>>>>            If (Connection.sDriver <> ODBC_DRV_ID) Begin
78455>>>>>>>>>>>                Get ParseKeyWord Connection.sString (CS_SQLIniServerKeyword + "=")       to SQLConnection.sServer
78456>>>>>>>>>>>            End
78456>>>>>>>>>>>>
78456>>>>>>>>>>>            If (Connection.sDriver = ODBC_DRV_ID) Begin
78458>>>>>>>>>>>                Get ParseKeyWord Connection.sString (CS_SQLIniDSNKeyword + "=")          to SQLConnection.sServer
78459>>>>>>>>>>>                If (SQLConnection.sServer = "") Begin
78461>>>>>>>>>>>                    Get ParseKeyWord Connection.sString (CS_SQLIniFileDSNKeyword  + "=") to SQLConnection.sServer
78462>>>>>>>>>>>                End
78462>>>>>>>>>>>>
78462>>>>>>>>>>>            End
78462>>>>>>>>>>>>
78462>>>>>>>>>>>
78462>>>>>>>>>>>            Get ParseKeyWord Connection.sString (CS_SQLIniDatabaseKeyword  + "=")        to SQLConnection.sDatabase
78463>>>>>>>>>>>
78463>>>>>>>>>>>            // The DbType is a bit special. If the piDbType has _not_ been setup in object code we try to derave
78463>>>>>>>>>>>            // the value from the driver id:
78463>>>>>>>>>>>            Get SqlUtilDbTypeFromDriver of (phoSQLConnectionIniFile(Self)) Connection.sDriver to SQLConnection.iDbType
78464>>>>>>>>>>>            // ...but in case it has been explicitly set in the object we use that value.
78464>>>>>>>>>>>            Get piDbType                                     to iDbType
78465>>>>>>>>>>>            If (iDbType <> SQLConnection.iDbType) Begin
78467>>>>>>>>>>>                Move iDbType to SQLConnection.iDbType
78468>>>>>>>>>>>            End
78468>>>>>>>>>>>>
78468>>>>>>>>>>>            Get psBaseTableSpace                             to SQLConnection.sBaseTableSpace
78469>>>>>>>>>>>            Get psLongTableSpace                             to SQLConnection.sLongTableSpace
78470>>>>>>>>>>>            Get psIndexTableSpace                            to SQLConnection.sIndexTableSpace
78471>>>>>>>>>>>            Get psSchema                                     to SQLConnection.sSchema
78472>>>>>>>>>>>
78472>>>>>>>>>>>            // We finally set the struct property to the newly fetched values.
78472>>>>>>>>>>>            Set pSQLConnection to SQLConnection
78473>>>>>>>>>>>
78473>>>>>>>>>>>        Function_Return SQLConnection
78474>>>>>>>>>>>    End_Function
78475>>>>>>>>>>>
78475>>>>>>>>>>>    // Returns True if the psConnectionID has been set in the cDbUpateHandler object,
78475>>>>>>>>>>>    // or the DAW cConnect array of registered connection only contains one active/enabled
78475>>>>>>>>>>>    // connection id for a particular driver.
78475>>>>>>>>>>>    // So either the psConnectionID or the psDriverID can have been set in the cDbUpdateHandler
78475>>>>>>>>>>>    // object. We can then match a connection id from the DAW cConnect class array.
78475>>>>>>>>>>>    // Returns False if there are multiple connections that are enabled or the psConnectionID has
78475>>>>>>>>>>>    // been set in the cDbUpdateHandler object but it cannot be found amongst the registered
78475>>>>>>>>>>>    // connections of the DAW cConnect class.
78475>>>>>>>>>>>    Function IsSinglecConnection String ByRef sConnectionID Returns Boolean
78477>>>>>>>>>>>        tConnection[] ConnIdArray
78477>>>>>>>>>>>        tConnection[] ConnIdArray
78478>>>>>>>>>>>        Integer iCount iSize iConnectionIDCounter
78478>>>>>>>>>>>        Boolean bEnabled bFound
78478>>>>>>>>>>>        String sConnectionID2 sDriverID sDriverConn
78478>>>>>>>>>>>
78478>>>>>>>>>>>        Move False to bFound
78479>>>>>>>>>>>        If (ghoConnection > 0) Begin
78481>>>>>>>>>>>
78481>>>>>>>>>>>            // The property of the cDbUpdateHandler container object
78481>>>>>>>>>>>            Get psDriverID to sDriverID
78482>>>>>>>>>>>
78482>>>>>>>>>>>            Move 0 to iConnectionIDCounter
78483>>>>>>>>>>>            // This is the the DAW cConnect array with all registered connection id's.
78483>>>>>>>>>>>                Get ConnectionIDs of ghoConnection to ConnIdArray
78484>>>>>>>>>>>            Move (SizeOfArray(ConnIdArray)) to iSize
78485>>>>>>>>>>>            Decrement iSize
78486>>>>>>>>>>>            For iCount from 0 to iSize
78492>>>>>>>>>>>>
78492>>>>>>>>>>>                Move ConnIdArray[iCount].sDriver to sDriverConn
78493>>>>>>>>>>>                Move ConnIdArray[iCount].sId to sConnectionID2
78494>>>>>>>>>>>                Move (ConnIdArray[iCount].bDisabled = False) to bEnabled
78495>>>>>>>>>>>                // If no psConnectionID specified in the cDbUpdateHandler, we check if there is a driver
78495>>>>>>>>>>>                // connection in the DAW cConnect object _and_ that there is only one!
78495>>>>>>>>>>>                If (sConnectionID = "") Begin
78497>>>>>>>>>>>                    Move (sDriverID = sDriverConn and bEnabled = True) to bFound
78498>>>>>>>>>>>                End
78498>>>>>>>>>>>>
78498>>>>>>>>>>>                Else Begin
78499>>>>>>>>>>>                    If (Uppercase(sConnectionID) = Uppercase(sConnectionID2)) Begin
78501>>>>>>>>>>>                        Move iSize to iCount // Then we've found what we were looking for and we're out of here...
78502>>>>>>>>>>>                    End
78502>>>>>>>>>>>>
78502>>>>>>>>>>>                End
78502>>>>>>>>>>>>
78502>>>>>>>>>>>
78502>>>>>>>>>>>                If (bFound = True) Begin
78504>>>>>>>>>>>                    Increment iConnectionIDCounter
78505>>>>>>>>>>>                End
78505>>>>>>>>>>>>
78505>>>>>>>>>>>            Loop
78506>>>>>>>>>>>>
78506>>>>>>>>>>>            Move (iConnectionIDCounter <= 1 and sDriverConn <> "" and sConnectionID2 <> "") to bFound
78507>>>>>>>>>>>            If (bFound = True) Begin
78509>>>>>>>>>>>                Move sConnectionID2 to sConnectionID
78510>>>>>>>>>>>            End
78510>>>>>>>>>>>>
78510>>>>>>>>>>>        End
78510>>>>>>>>>>>>
78510>>>>>>>>>>>
78510>>>>>>>>>>>        // Special case; a cConnection object has been setup in the cApplication,
78510>>>>>>>>>>>        // but no DFConn.ini record has been created.
78510>>>>>>>>>>>        If (iSize = -1) Begin
78512>>>>>>>>>>>            Move True to bFound
78513>>>>>>>>>>>        End
78513>>>>>>>>>>>>
78513>>>>>>>>>>>
78513>>>>>>>>>>>        Function_Return bFound
78514>>>>>>>>>>>    End_Function
78515>>>>>>>>>>>
78515>>>>>>>>>>>    // Send on object creation to read the default connection string settings, and
78515>>>>>>>>>>>    // create a connection to the server.
78515>>>>>>>>>>>    Function ReadSQLConnectionsIniSettings Returns tSQLConnection
78517>>>>>>>>>>>        String sPath sFileName
78517>>>>>>>>>>>        Boolean bExists bActive
78517>>>>>>>>>>>        tSQLConnection[] SQLConnectionArray
78517>>>>>>>>>>>        tSQLConnection[] SQLConnectionArray
78518>>>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
78518>>>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
78518>>>>>>>>>>>        Handle hoIniFile
78518>>>>>>>>>>>        Integer iSize iCount iRetval
78518>>>>>>>>>>>
78518>>>>>>>>>>>        Get psIniFilePath to sPath
78519>>>>>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
78520>>>>>>>>>>>        If (sPath = "") Begin
78522>>>>>>>>>>>            Get ApplicationPath of hoIniFile to sPath
78523>>>>>>>>>>>            Set psIniFilePath   of hoIniFile to sPath
78524>>>>>>>>>>>        End
78524>>>>>>>>>>>>
78524>>>>>>>>>>>        Get vFolderFormat sPath to sPath
78525>>>>>>>>>>>        Get psIniFileName to sFileName
78526>>>>>>>>>>>        Get vFilePathExists (sPath + sFileName) to bExists
78527>>>>>>>>>>>
78527>>>>>>>>>>>        Get SQLIniFileReadConnections of hoIniFile to SQLConnectionArray
78528>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionArray)) to iSize
78529>>>>>>>>>>>        If (iSize = 0) Begin
78531>>>>>>>>>>>            // This may have been set by the "ReadcConnections" function,
78531>>>>>>>>>>>            // if a cConnection object has been setup for DataFlex 19 or later
78531>>>>>>>>>>>            // in the cApplication object.
78531>>>>>>>>>>>            Get pSQLConnection to SQLConnection
78532>>>>>>>>>>>            If (SQLConnection.sConnectionID = "") Begin
78534>>>>>>>>>>>                Function_Return SQLConnectionEmpty
78535>>>>>>>>>>>            End
78535>>>>>>>>>>>>
78535>>>>>>>>>>>            Move SQLConnection to SQLConnectionArray[0] 
78536>>>>>>>>>>>            Move 1 to iSize
78537>>>>>>>>>>>        End
78537>>>>>>>>>>>>
78537>>>>>>>>>>>
78537>>>>>>>>>>>        Move False to bActive
78538>>>>>>>>>>>        // The first connection should be the one that is active, but all connections might have been disabled.
78538>>>>>>>>>>>        Decrement iSize
78539>>>>>>>>>>>        For iCount from 0 to iSize
78545>>>>>>>>>>>>
78545>>>>>>>>>>>            Move SQLConnectionArray[iCount] to SQLConnection
78546>>>>>>>>>>>            If (SQLConnection.bEnabled = True) Begin
78548>>>>>>>>>>>                Move True to bActive
78549>>>>>>>>>>>                Move iSize to iCount // We've found the enabled item, so we're out of here.
78550>>>>>>>>>>>            End
78550>>>>>>>>>>>>
78550>>>>>>>>>>>        Loop
78551>>>>>>>>>>>>
78551>>>>>>>>>>>
78551>>>>>>>>>>>        // In case all connections have been disabled, we're out of here.
78551>>>>>>>>>>>        If (bActive = False) Begin
78553>>>>>>>>>>>            Function_Return SQLConnectionEmpty
78554>>>>>>>>>>>        End
78554>>>>>>>>>>>>
78554>>>>>>>>>>>
78554>>>>>>>>>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID ;             SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted ;             SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bSilentLogin False
78555>>>>>>>>>>>
78555>>>>>>>>>>>        Set pSQLConnection to SQLConnection
78556>>>>>>>>>>>        Get AutoSetConnectionID to iRetval
78557>>>>>>>>>>>
78557>>>>>>>>>>>        Function_Return SQLConnection
78558>>>>>>>>>>>    End_Function
78559>>>>>>>>>>>
78559>>>>>>>>>>>    Procedure Set psIniFilePath String sPath
78561>>>>>>>>>>>        Set psIniFilePath of (phoSQLConnectionIniFile(Self)) to sPath
78562>>>>>>>>>>>    End_Procedure
78563>>>>>>>>>>>
78563>>>>>>>>>>>    Function psIniFilePath Returns String
78565>>>>>>>>>>>        String sRetval
78565>>>>>>>>>>>        Get psIniFilePath of (phoSQLConnectionIniFile(Self)) to sRetval
78566>>>>>>>>>>>        Function_Return sRetval
78567>>>>>>>>>>>    End_Function
78568>>>>>>>>>>>
78568>>>>>>>>>>>    Procedure Set psIniFileName String sFileName
78570>>>>>>>>>>>        Set psIniFileName of (phoSQLConnectionIniFile(Self)) to sFileName
78571>>>>>>>>>>>    End_Procedure
78572>>>>>>>>>>>
78572>>>>>>>>>>>    Function psIniFileName Returns String
78574>>>>>>>>>>>        String sRetval
78574>>>>>>>>>>>        Get psIniFileName of (phoSQLConnectionIniFile(Self)) to sRetval
78575>>>>>>>>>>>        Function_Return sRetval
78576>>>>>>>>>>>    End_Function
78577>>>>>>>>>>>
78577>>>>>>>>>>>    Procedure Set psIniSectionName String sSection
78579>>>>>>>>>>>        Set psIniSectionName of (phoSQLConnectionIniFile(Self)) to sSection
78580>>>>>>>>>>>    End_Procedure
78581>>>>>>>>>>>
78581>>>>>>>>>>>    Function psIniSectionName Returns String
78583>>>>>>>>>>>        String sRetval
78583>>>>>>>>>>>        Get psIniSectionName of (phoSQLConnectionIniFile(Self)) to sRetval
78584>>>>>>>>>>>        Function_Return sRetval
78585>>>>>>>>>>>    End_Function
78586>>>>>>>>>>>
78586>>>>>>>>>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
78588>>>>>>>>>>>        Handle ho
78588>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78589>>>>>>>>>>>        Set IniFileValue of ho to sSection sValueName sValue
78590>>>>>>>>>>>    End_Procedure
78591>>>>>>>>>>>
78591>>>>>>>>>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
78593>>>>>>>>>>>        Handle ho
78593>>>>>>>>>>>        String sRetval
78593>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78594>>>>>>>>>>>        Get IniFileValue of ho sSection sValueName sDefaultValue to sRetval
78595>>>>>>>>>>>        Function_Return sRetval
78596>>>>>>>>>>>    End_Function
78597>>>>>>>>>>>
78597>>>>>>>>>>>    Function SectionExists String sSection Returns Boolean
78599>>>>>>>>>>>        Handle ho
78599>>>>>>>>>>>        Boolean bRetval
78599>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78600>>>>>>>>>>>        Get SectionExists of ho sSection to bRetval
78601>>>>>>>>>>>        Function_Return bRetval
78602>>>>>>>>>>>    End_Function
78603>>>>>>>>>>>
78603>>>>>>>>>>>    Function KeyExists String sSection String sKey Returns Boolean
78605>>>>>>>>>>>        Handle ho
78605>>>>>>>>>>>        Boolean bRetval
78605>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78606>>>>>>>>>>>        Get KeyExists of ho sSection sKey to bRetval
78607>>>>>>>>>>>        Function_Return bRetval
78608>>>>>>>>>>>    End_Function
78609>>>>>>>>>>>
78609>>>>>>>>>>>    Function EncryptPassword String sPassword Returns String
78611>>>>>>>>>>>        Handle ho
78611>>>>>>>>>>>        String sRetval
78611>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78612>>>>>>>>>>>        Get EncryptPassword of ho sPassword to sRetval
78613>>>>>>>>>>>        Function_Return sRetval
78614>>>>>>>>>>>    End_Function
78615>>>>>>>>>>>
78615>>>>>>>>>>>    Function DecryptPassword String sPassword Returns String
78617>>>>>>>>>>>        Handle ho
78617>>>>>>>>>>>        String sRetval
78617>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78618>>>>>>>>>>>        Get DecryptPassword of ho sPassword to sRetval
78619>>>>>>>>>>>        Function_Return sRetval
78620>>>>>>>>>>>    End_Function
78621>>>>>>>>>>>
78621>>>>>>>>>>>    // *** Main Connection Message ***
78621>>>>>>>>>>>    Procedure CreateSQLConnection String sDriverID String sConnectionID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Boolean bSilent Boolean bExitProgram
78623>>>>>>>>>>>        Handle hoDriver
78623>>>>>>>>>>>        String sConnectionString sError
78623>>>>>>>>>>>        Boolean bLoginSuccessful
78623>>>>>>>>>>>
78623>>>>>>>>>>>        Get ConstructConnectionString sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnectionString
78624>>>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
78625>>>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
78626>>>>>>>>>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
78627>>>>>>>>>>>        If (bLoginSuccessful = False) Begin
78629>>>>>>>>>>>            Error DFERR_PROGRAM (CS_DUF_CannotLoginToServer * CS_DUF_ErrorText * String(sError) + "\nConnectionID = " * sConnectionID + "\nConnection String = " * sConnectionString)   
78630>>>>>>>>>>>>
78630>>>>>>>>>>>            If (bExitProgram = True) Begin
78632>>>>>>>>>>>                Send Exit_Application
78633>>>>>>>>>>>            End
78633>>>>>>>>>>>>
78633>>>>>>>>>>>        End
78633>>>>>>>>>>>>
78633>>>>>>>>>>>        Send Destroy of hoDriver
78634>>>>>>>>>>>    End_Procedure
78635>>>>>>>>>>>
78635>>>>>>>>>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
78637>>>>>>>>>>>        Integer iRetval
78637>>>>>>>>>>>        Handle hoCLI
78637>>>>>>>>>>>        String sDriverID
78637>>>>>>>>>>>
78637>>>>>>>>>>>        Get psDriverID to sDriverID
78638>>>>>>>>>>>        Get Create (Refclass(cCLIHandler)) to hoCLI
78639>>>>>>>>>>>        If (hoCLI <> 0) Begin
78641>>>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
78642>>>>>>>>>>>            Get RedirectConnection of hoCLI sOldConnection sNewConnection to iRetval
78643>>>>>>>>>>>            Send Destroy of hoCLI
78644>>>>>>>>>>>        End
78644>>>>>>>>>>>>
78644>>>>>>>>>>>
78644>>>>>>>>>>>        Function_Return iRetval
78645>>>>>>>>>>>    End_Function
78646>>>>>>>>>>>
78646>>>>>>>>>>>    Procedure CreateConnParamsFromConnectionString String sDriverID String sConnectionString
78648>>>>>>>>>>>        tSQLConnection SQLConnection
78648>>>>>>>>>>>        tSQLConnection SQLConnection
78648>>>>>>>>>>>
78648>>>>>>>>>>>        Set psDriverID to sDriverID
78649>>>>>>>>>>>        Get DeComposeConnectionString sDriverID sConnectionString to SQLConnection
78650>>>>>>>>>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID SQLConnection.sServer;                                 SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted False
78651>>>>>>>>>>>    End_Procedure
78652>>>>>>>>>>>
78652>>>>>>>>>>>    // This is needed when e.g. the connection id we have specified in the program code
78652>>>>>>>>>>>    // also exists in e.g. the MSSQLDRV.ini file (can either be local in the Data folder
78652>>>>>>>>>>>    // or the one in the DataFlex Bin folder.)
78652>>>>>>>>>>>    // We then need to delete the current one before creating a new one.
78652>>>>>>>>>>>    // This is because the parameters may differ between the program code and the
78652>>>>>>>>>>>    // MSSQLDRV.ini file in a deployed environment. Also DataFlex will generate an error
78652>>>>>>>>>>>    // when one tries to create a Connection ID that already exists.
78652>>>>>>>>>>>    Procedure RemoveExistingConnectionID String sDriverID String sConnectionID
78654>>>>>>>>>>>        Integer iResult iDriver iNumConn iConn
78654>>>>>>>>>>>        Handle hoCLI
78654>>>>>>>>>>>        String sID
78654>>>>>>>>>>>
78654>>>>>>>>>>>        If (sDriverID = "" or sConnectionID = "") Begin
78656>>>>>>>>>>>            Procedure_Return
78657>>>>>>>>>>>        End
78657>>>>>>>>>>>>
78657>>>>>>>>>>>
78657>>>>>>>>>>>        Move 0 to iResult
78658>>>>>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
78659>>>>>>>>>>>        If (hoCLI <> 0) Begin
78661>>>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
78662>>>>>>>>>>>            Get DriverIndex sDriverID to iDriver
78663>>>>>>>>>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
78666>>>>>>>>>>>            Decrement iNumConn
78667>>>>>>>>>>>            For iConn from 0 to iNumConn
78673>>>>>>>>>>>>
78673>>>>>>>>>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
78676>>>>>>>>>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
78678>>>>>>>>>>>                    Get DeleteConnectionID of hoCLI sConnectionID -1 to iResult
78679>>>>>>>>>>>                End
78679>>>>>>>>>>>>
78679>>>>>>>>>>>            Loop
78680>>>>>>>>>>>>
78680>>>>>>>>>>>            Send Destroy of hoCLI
78681>>>>>>>>>>>        End
78681>>>>>>>>>>>>
78681>>>>>>>>>>>
78681>>>>>>>>>>>    End_Procedure
78682>>>>>>>>>>>
78682>>>>>>>>>>>    Function ExistingConnectionSettings String sDriverID String sConnectionID Returns tSQLConnection
78684>>>>>>>>>>>        Integer iResult iDriver iNumConn iConn
78684>>>>>>>>>>>        Handle hoCLI
78684>>>>>>>>>>>        String sID sConnectionString sVal sDatabase
78684>>>>>>>>>>>        tSQLConnection SQLConnection
78684>>>>>>>>>>>        tSQLConnection SQLConnection
78684>>>>>>>>>>>        Boolean bTrusted
78684>>>>>>>>>>>
78684>>>>>>>>>>>        Move 0 to iResult
78685>>>>>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
78686>>>>>>>>>>>        If (hoCLI <> 0) Begin
78688>>>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
78689>>>>>>>>>>>            Get DriverIndex sDriverID to iDriver
78690>>>>>>>>>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
78693>>>>>>>>>>>            Decrement iNumConn
78694>>>>>>>>>>>            For iConn from 0 to iNumConn
78700>>>>>>>>>>>>
78700>>>>>>>>>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
78703>>>>>>>>>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
78705>>>>>>>>>>>                    Move sDriverID                                                      to SQLConnection.sDriverID      // For completeness only...
78706>>>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn              to SQLConnection.sConnectionID  // For completeness only...
78709>>>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iConn       to sConnectionString
78712>>>>>>>>>>>                    Move sConnectionString                                              to SQLConnection.sConnectionString
78713>>>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_OPTIONS of iDriver iConn      to SQLConnection.bSilentLogin
78716>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnection.sServer
78717>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnection.sDatabase
78718>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to SQLConnection.sUserID
78719>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to SQLConnection.sPassword
78720>>>>>>>>>>>
78720>>>>>>>>>>>                    Case Begin
78720>>>>>>>>>>>                        Case (sDriverID = MSSQLDRV_ID)
78722>>>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=") to sVal
78723>>>>>>>>>>>                            Move (If(Uppercase(sVal) = Uppercase(CS_SQLIniConnectionYes), True, False)) to bTrusted
78724>>>>>>>>>>>                            Move bTrusted                                               to SQLConnection.bTrusted
78725>>>>>>>>>>>                            Case Break
78726>>>>>>>>>>>                        Case (sDriverID = DB2_DRV_ID)
78729>>>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
78730>>>>>>>>>>>                            Case Break
78731>>>>>>>>>>>                        Case (sDriverID = ODBC_DRV_ID)
78734>>>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
78735>>>>>>>>>>>                            If (SQLConnection.sServer = "") Begin
78737>>>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniFileDSNKeyword  + "=") to SQLConnection.sServer
78738>>>>>>>>>>>                            End
78738>>>>>>>>>>>>
78738>>>>>>>>>>>                            Case Break
78739>>>>>>>>>>>                        Case Else
78739>>>>>>>>>>>                            Error ("Wrong driver ID passed:" * sDriverID)
78740>>>>>>>>>>>>
78740>>>>>>>>>>>                            Case Break
78741>>>>>>>>>>>                    Case End
78741>>>>>>>>>>>                End
78741>>>>>>>>>>>>
78741>>>>>>>>>>>            Loop
78742>>>>>>>>>>>>
78742>>>>>>>>>>>            Send Destroy of hoCLI
78743>>>>>>>>>>>        End
78743>>>>>>>>>>>>
78743>>>>>>>>>>>
78743>>>>>>>>>>>        Function_Return SQLConnection
78744>>>>>>>>>>>    End_Function
78745>>>>>>>>>>>
78745>>>>>>>>>>>    Function DriverIndex String sDriverID Returns Integer
78747>>>>>>>>>>>        String  sCurrentDriver
78747>>>>>>>>>>>        Integer iNumberOfDrivers iDriver iCount
78747>>>>>>>>>>>
78747>>>>>>>>>>>        Move 0 to iDriver
78748>>>>>>>>>>>        Move 0 to iCount
78749>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
78752>>>>>>>>>>>        For iCount from 1 to iNumberOfDrivers
78758>>>>>>>>>>>>
78758>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
78761>>>>>>>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
78763>>>>>>>>>>>                Function_Return iCount
78764>>>>>>>>>>>            End
78764>>>>>>>>>>>>
78764>>>>>>>>>>>        Loop
78765>>>>>>>>>>>>
78765>>>>>>>>>>>
78765>>>>>>>>>>>        // If driver not previously loaded; attempt to do so now.
78765>>>>>>>>>>>        If (iDriver = 0) Begin
78767>>>>>>>>>>>            Move 0 to LastErr
78768>>>>>>>>>>>            Load_Driver sDriverID
78769>>>>>>>>>>>            // If driver could not be loaded.
78769>>>>>>>>>>>            If (LastErr = DFERR_CANT_LOAD_DLL) Begin
78771>>>>>>>>>>>                Move -1 to iCount
78772>>>>>>>>>>>            End
78772>>>>>>>>>>>>
78772>>>>>>>>>>>        End
78772>>>>>>>>>>>>
78772>>>>>>>>>>>        Function_Return iCount
78773>>>>>>>>>>>    End_Function
78774>>>>>>>>>>>
78774>>>>>>>>>>>    // This will update connection settings of the cCLIHandler object with that passed struct values.
78774>>>>>>>>>>>    Procedure UpdateConnectionString tSQLConnection SQLConnection
78776>>>>>>>>>>>        String sDriverID sConnectionID sServer sDatabase sUserID sPassword
78776>>>>>>>>>>>        Boolean bTrusted bSilent
78776>>>>>>>>>>>        Integer iRetval
78776>>>>>>>>>>>
78776>>>>>>>>>>>        Move SQLConnection.sDriverID     to sDriverID
78777>>>>>>>>>>>        Move SQLConnection.sConnectionID to sConnectionID
78778>>>>>>>>>>>        Move SQLConnection.sServer       to sServer
78779>>>>>>>>>>>        Move SQLConnection.sDatabase     to sDatabase
78780>>>>>>>>>>>        Move SQLConnection.bTrusted      to bTrusted
78781>>>>>>>>>>>        Move SQLConnection.sUserID       to sUserID
78782>>>>>>>>>>>        Move SQLConnection.sPassword     to sPassword
78783>>>>>>>>>>>        Move SQLConnection.bSilentLogin  to bSilent
78784>>>>>>>>>>>
78784>>>>>>>>>>>        Send CreateSQLConnection sDriverID sConnectionID sServer sDatabase bTrusted sUserID sPassword bSilent False
78785>>>>>>>>>>>        // Note that this message will first delete the current ConnectionID if it exists; which is needed by the cCLIHandler logic.
78785>>>>>>>>>>>        Get AutoSetConnectionID to iRetval
78786>>>>>>>>>>>    End_Procedure
78787>>>>>>>>>>>
78787>>>>>>>>>>>    // Called when the object is constructed.
78787>>>>>>>>>>>    // It will check the psDriverID for a ConnectionID and save it
78787>>>>>>>>>>>    // as psConnectionID property. It is later used whenever a login to
78787>>>>>>>>>>>    // the database is needed.
78787>>>>>>>>>>>    Function AutoSetConnectionID Returns Boolean
78789>>>>>>>>>>>        String sConnectionID sDriverID sConnectionString
78789>>>>>>>>>>>        Integer iDriver iRetval
78789>>>>>>>>>>>        Handle hoCLI
78789>>>>>>>>>>>        Boolean bOK bSilent
78789>>>>>>>>>>>
78789>>>>>>>>>>>        Get pbSilentLogin      to bSilent
78790>>>>>>>>>>>        Get psConnectionID     to sConnectionID
78791>>>>>>>>>>>        Get psConnectionString to sConnectionString
78792>>>>>>>>>>>        // Get the driver Connection ID string & set the psConnectionString property.
78792>>>>>>>>>>>        Get psDriverID to sDriverID
78793>>>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
78794>>>>>>>>>>>        If (bOK = False) Begin
78796>>>>>>>>>>>            Function_Return False
78797>>>>>>>>>>>        End
78797>>>>>>>>>>>>
78797>>>>>>>>>>>
78797>>>>>>>>>>>        Get DriverIndex sDriverID          to iDriver
78798>>>>>>>>>>>        // If driver not loaded; load it.
78798>>>>>>>>>>>        If (iDriver = 0) Begin
78800>>>>>>>>>>>            Load_Driver sDriverID
78801>>>>>>>>>>>            Get DriverIndex sDriverID      to iDriver
78802>>>>>>>>>>>        End
78802>>>>>>>>>>>>
78802>>>>>>>>>>>        // This shouldn't be possible; unless the driver.dll file is missing or something...
78802>>>>>>>>>>>        If (iDriver = 0) Begin
78804>>>>>>>>>>>            Error DFERR_PROGRAM ("The database driver could not be loaded! Connection to database failed." * sDriverID)
78805>>>>>>>>>>>>
78805>>>>>>>>>>>            Function_Return False
78806>>>>>>>>>>>        End           
78806>>>>>>>>>>>>
78806>>>>>>>>>>>            Set_Attribute DF_DRIVER_LOGIN_ON_OPEN of iDriver to True
78809>>>>>>>>>>>        
78809>>>>>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
78810>>>>>>>>>>>        Set psDriverID of hoCLI            to sDriverID
78811>>>>>>>>>>>        // Delete the connection first; in case it exists
78811>>>>>>>>>>>        Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
78812>>>>>>>>>>>        Get CreateConnectionID of hoCLI sConnectionID sConnectionString bSilent to iRetval 
78813>>>>>>>>>>>        Send Destroy of hoCLI
78814>>>>>>>>>>>
78814>>>>>>>>>>>        Function_Return (iRetval = 0)
78815>>>>>>>>>>>    End_Function
78816>>>>>>>>>>>
78816>>>>>>>>>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
78818>>>>>>>>>>>        Boolean bOK
78818>>>>>>>>>>>
78818>>>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
78819>>>>>>>>>>>
78819>>>>>>>>>>>        If (bOK = False) Begin
78821>>>>>>>>>>>            Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV_ID, DB2_DRV_ID or ODBC_DRV_ID"
78822>>>>>>>>>>>>
78822>>>>>>>>>>>            Function_Return False
78823>>>>>>>>>>>        End
78823>>>>>>>>>>>>
78823>>>>>>>>>>>
78823>>>>>>>>>>>        Function_Return True
78824>>>>>>>>>>>    End_Function
78825>>>>>>>>>>>
78825>>>>>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
78827>>>>>>>>>>>        Boolean bOK
78827>>>>>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
78828>>>>>>>>>>>        Function_Return bOK
78829>>>>>>>>>>>    End_Function
78830>>>>>>>>>>>
78830>>>>>>>>>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
78832>>>>>>>>>>>        Handle hoIniFile
78832>>>>>>>>>>>        String sConnect
78832>>>>>>>>>>>
78832>>>>>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
78833>>>>>>>>>>>        Get ConstructConnectionString of hoIniFile sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnect
78834>>>>>>>>>>>
78834>>>>>>>>>>>        Function_Return sConnect
78835>>>>>>>>>>>    End_Function
78836>>>>>>>>>>>
78836>>>>>>>>>>>    // Sample sConnString: "SERVER=(local)\SQLEXPRESS;UID=dbuser;PWD=secret;DATABASE=OrderEntry;, 0"
78836>>>>>>>>>>>    // Pass a complete driver connection string
78836>>>>>>>>>>>    // Returns the following as a struct:
78836>>>>>>>>>>>    //   sServer, sDatabase, sUser, sPassword & True if Trusted_Connection is used.
78836>>>>>>>>>>>    // Finally also returns a boolean TRUE if trusted_connection=yes, else false is returned.
78836>>>>>>>>>>>    //
78836>>>>>>>>>>>    Function DeComposeConnectionString String sDriverID String sConnectionString Returns tSQLConnection
78838>>>>>>>>>>>        tSQLConnection SQLConnection
78838>>>>>>>>>>>        tSQLConnection SQLConnection
78838>>>>>>>>>>>        String sValue sConnectionID sServer sDatabase sUserID sPassword
78838>>>>>>>>>>>        Boolean bTrusted bSilent bOK
78838>>>>>>>>>>>        Integer iPos
78838>>>>>>>>>>>
78838>>>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
78839>>>>>>>>>>>        If (bOK = False) Begin
78841>>>>>>>>>>>            Function_Return SQLConnection
78842>>>>>>>>>>>        End
78842>>>>>>>>>>>>
78842>>>>>>>>>>>
78842>>>>>>>>>>>        Move False to bTrusted
78843>>>>>>>>>>>        Move False to bSilent
78844>>>>>>>>>>>
78844>>>>>>>>>>>        Case Begin
78844>>>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
78846>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to sServer
78847>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
78848>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
78849>>>>>>>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
78850>>>>>>>>>>>                If (bTrusted = False) Begin
78852>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
78853>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
78854>>>>>>>>>>>                End
78854>>>>>>>>>>>>
78854>>>>>>>>>>>                Case Break
78855>>>>>>>>>>>
78855>>>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
78858>>>>>>>>>>>                If (uppercase(sConnectionString) contains ("." + CS_SQLIniDSNKeyword)) Begin
78860>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniFileDSNKeyword + "=")  to sServer
78861>>>>>>>>>>>                End
78861>>>>>>>>>>>>
78861>>>>>>>>>>>                Else Begin
78862>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
78863>>>>>>>>>>>                End
78863>>>>>>>>>>>>
78863>>>>>>>>>>>
78863>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
78864>>>>>>>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
78865>>>>>>>>>>>                If (bTrusted = False) Begin
78867>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
78868>>>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
78869>>>>>>>>>>>                End
78869>>>>>>>>>>>>
78869>>>>>>>>>>>                Case Break
78870>>>>>>>>>>>
78870>>>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
78873>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
78874>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
78875>>>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
78876>>>>>>>>>>>                Case Break
78877>>>>>>>>>>>
78877>>>>>>>>>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
78880>>>>>>>>>>>                Break
78881>>>>>>>>>>>        Case End
78881>>>>>>>>>>>
78881>>>>>>>>>>>        Get ParseKeyWord sConnectionString (Uppercase(CS_SQLConnectionIDText))  to sConnectionID
78882>>>>>>>>>>>
78882>>>>>>>>>>>        // bSilent?
78882>>>>>>>>>>>        Move (Pos(",0", sConnectionString))                                     to iPos
78883>>>>>>>>>>>        If (iPos = 0) Begin
78885>>>>>>>>>>>            Move (Pos(",1", sConnectionString))                                 to iPos
78886>>>>>>>>>>>        End
78886>>>>>>>>>>>>
78886>>>>>>>>>>>        If (iPos = 0) Begin
78888>>>>>>>>>>>            Move "0"                                                            to sValue
78889>>>>>>>>>>>        End
78889>>>>>>>>>>>>
78889>>>>>>>>>>>        Else Begin
78890>>>>>>>>>>>            Move (Mid(sConnectionString, 1, (iPos +1)))                         to sValue
78891>>>>>>>>>>>        End
78891>>>>>>>>>>>>
78891>>>>>>>>>>>        Move (If(sValue = 1, True, False))                                      to bSilent
78892>>>>>>>>>>>
78892>>>>>>>>>>>        Move (Trim(sDriverID))                                                  to SQLConnection.sDriverID
78893>>>>>>>>>>>        Move (Trim(sConnectionID))                                              to SQLConnection.sConnectionID
78894>>>>>>>>>>>        Move (Trim(sConnectionString))                                          to SQLConnection.sConnectionString
78895>>>>>>>>>>>        Move (Trim(sServer))                                                    to SQLConnection.sServer
78896>>>>>>>>>>>        Move (Trim(sDatabase))                                                  to SQLConnection.sDatabase
78897>>>>>>>>>>>        Move bTrusted                                                           to SQLConnection.bTrusted
78898>>>>>>>>>>>        Move (Trim(sUserID))                                                    to SQLConnection.sUserID
78899>>>>>>>>>>>        Move (Trim(sPassword))                                                  to SQLConnection.sPassword
78900>>>>>>>>>>>        Move bSilent                                                            to SQLConnection.bSilentLogin
78901>>>>>>>>>>>
78901>>>>>>>>>>>        Function_Return SQLConnection
78902>>>>>>>>>>>    End_Function
78903>>>>>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
78903>>>>>>>>>>>>
78903>>>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
78905>>>>>>>>>>>>    Integer iStart iEnd
78905>>>>>>>>>>>>    String sRetval
78905>>>>>>>>>>>>
78905>>>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
78906>>>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
78907>>>>>>>>>>>>    If (iStart = 0) Begin
78909>>>>>>>>>>>>        Function_Return ""
78910>>>>>>>>>>>>    End
78910>>>>>>>>>>>>>
78910>>>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
78911>>>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
78912>>>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
78914>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
78915>>>>>>>>>>>>    End
78915>>>>>>>>>>>>>
78915>>>>>>>>>>>>    Else Begin
78916>>>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
78917>>>>>>>>>>>>    End
78917>>>>>>>>>>>>>
78917>>>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
78919>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
78920>>>>>>>>>>>>        Decrement iEnd
78921>>>>>>>>>>>>    End
78921>>>>>>>>>>>>>
78921>>>>>>>>>>>>    If (iEnd <> 0) Begin
78923>>>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
78924>>>>>>>>>>>>    End
78924>>>>>>>>>>>>>
78924>>>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
78925>>>>>>>>>>>>
78925>>>>>>>>>>>>    Function_Return (Trim(sRetval))
78926>>>>>>>>>>>>End_Function
78927>>>>>>>>>>>>
78927>>>>>>>>>>>>
78927>>>>>>>>>>>
78927>>>>>>>>>>>    // To update the SQLSettings.ini file with updated connection data (SQLConnection struct data).
78927>>>>>>>>>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
78929>>>>>>>>>>>        Handle ho
78929>>>>>>>>>>>        Integer iIndex
78929>>>>>>>>>>>        Boolean bRetval bOK
78929>>>>>>>>>>>        tSQLConnection SQLConnection
78929>>>>>>>>>>>        tSQLConnection SQLConnection
78929>>>>>>>>>>>
78929>>>>>>>>>>>        Get pSQLConnection to SQLConnection
78930>>>>>>>>>>>        Get phoSQLConnectionIniFile to ho
78931>>>>>>>>>>>        Get SQLIniFileConnectionIDIndex of ho sConnectionID to iIndex
78932>>>>>>>>>>>        If (iIndex = -1) Begin
78934>>>>>>>>>>>            Function_Return False
78935>>>>>>>>>>>        End
78935>>>>>>>>>>>>
78935>>>>>>>>>>>
78935>>>>>>>>>>>        Get SQLIniFileUpdateConnection of ho SQLConnection to bRetval
78936>>>>>>>>>>>        Send UpdateConnectionString SQLConnection
78937>>>>>>>>>>>        If (ghoConnection > 0) Begin
78939>>>>>>>>>>>            Get ConnectionIdIndex of ghoConnection SQLConnection.sConnectionID to iIndex
78940>>>>>>>>>>>            If (iIndex <> -1) Begin
78942>>>>>>>>>>>                Get RedirectConnectionId of ghoConnection SQLConnection.sConnectionID (SQLConnection.sServer + ";" + CS_SQLIniDatabaseKeyword + "=" + SQLConnection.sDatabase) SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted True to bOK
78943>>>>>>>>>>>            End
78943>>>>>>>>>>>>
78943>>>>>>>>>>>        End
78943>>>>>>>>>>>>
78943>>>>>>>>>>>
78943>>>>>>>>>>>        Function_Return bRetval
78944>>>>>>>>>>>    End_Function
78945>>>>>>>>>>>
78945>>>>>>>>>>>End_Class
78946>>>>>>>>>Use vWin32fh.pkg
78946>>>>>>>>>Use Dfabout.pkg
Including file: DfAbout.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\DFAbout\DfAbout.pkg)
78946>>>>>>>>>>>Use LanguageText.pkg
78946>>>>>>>>>>>Use Windows.pkg
78946>>>>>>>>>>>Use Dfclient.pkg
78946>>>>>>>>>>>Use DFbitmap.pkg
78946>>>>>>>>>>>Use GlobalFunctionsProcedures.pkg
78946>>>>>>>>>>>Use cRichEdit.pkg
78946>>>>>>>>>>>Use cTextEdit.pkg
78946>>>>>>>>>>>Use cRichEdit.pkg
78946>>>>>>>>>>>Use gFormatNumbers.pkg
Including file: gFormatNumbers.pkg    (C:\Program Files\DataFlex 24.0\Pkg\gFormatNumbers.pkg)
78946>>>>>>>>>>>>>Use cFormatter.pkg
Including file: cFormatter.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cFormatter.pkg)
78946>>>>>>>>>>>>>>>Use VDFBase.pkg
78946>>>>>>>>>>>>>>>
78946>>>>>>>>>>>>>>>Class cFormatter is an cObject
78947>>>>>>>>>>>>>>>    
78947>>>>>>>>>>>>>>>    Procedure Construct_object
78949>>>>>>>>>>>>>>>        Integer iCh
78949>>>>>>>>>>>>>>>        Forward Send construct_object
78951>>>>>>>>>>>>>>>        Property String  psCurrencySymbol
78952>>>>>>>>>>>>>>>        Set psCurrencySymbol to (Default_Currency_Symbol())
78953>>>>>>>>>>>>>>>        
78953>>>>>>>>>>>>>>>        Property String  psLeft
78954>>>>>>>>>>>>>>>        Property String  psright
78955>>>>>>>>>>>>>>>        Property Integer pbThousandsSep
78956>>>>>>>>>>>>>>>        Property Integer piPoints
78957>>>>>>>>>>>>>>>        
78957>>>>>>>>>>>>>>>        Property String  psCurPosLeft
78958>>>>>>>>>>>>>>>        Property String  psCurPosright
78959>>>>>>>>>>>>>>>        Property Integer pbCurPosThousandsSep
78960>>>>>>>>>>>>>>>        Property Integer piCurPosPoints
78961>>>>>>>>>>>>>>>        
78961>>>>>>>>>>>>>>>        Property String  psCurNegLeft
78962>>>>>>>>>>>>>>>        Property String  psCurNegright
78963>>>>>>>>>>>>>>>        Property Integer pbCurNegThousandsSep
78964>>>>>>>>>>>>>>>        Property Integer piCurNegPoints
78965>>>>>>>>>>>>>>>        
78965>>>>>>>>>>>>>>>        Property String  psNumPosLeft
78966>>>>>>>>>>>>>>>        Property String  psNumPosright
78967>>>>>>>>>>>>>>>        Property Integer pbNumPosThousandsSep
78968>>>>>>>>>>>>>>>        Property Integer piNumPosPoints
78969>>>>>>>>>>>>>>>        
78969>>>>>>>>>>>>>>>        Property String  psNumNegLeft
78970>>>>>>>>>>>>>>>        Property String  psNumNegright
78971>>>>>>>>>>>>>>>        Property Integer pbNumNegThousandsSep
78972>>>>>>>>>>>>>>>        Property Integer piNumNegPoints
78973>>>>>>>>>>>>>>>        
78973>>>>>>>>>>>>>>>        Send SetFormat "$,#.##;($,#.##)" True  // currency
78974>>>>>>>>>>>>>>>        Send SetFormat  ",#.*"           False // numeric
78975>>>>>>>>>>>>>>>        
78975>>>>>>>>>>>>>>>    End_Procedure
78976>>>>>>>>>>>>>>>    
78976>>>>>>>>>>>>>>>    // internal
78976>>>>>>>>>>>>>>>    // parse passed format string and set temporary properties with result
78976>>>>>>>>>>>>>>>    Procedure ParseFormat String sFmt
78978>>>>>>>>>>>>>>>        
78978>>>>>>>>>>>>>>>        String sLeft sRight sDigit
78978>>>>>>>>>>>>>>>        Integer bSep iPos i iDigits
78978>>>>>>>>>>>>>>>        
78978>>>>>>>>>>>>>>>        // replace any literals. A "/" followed by anything.
78978>>>>>>>>>>>>>>>        // some literals are special. $ . , / #
78978>>>>>>>>>>>>>>>        Move (Replaces("/$",sFmt,Character(1)))    to sFmt
78979>>>>>>>>>>>>>>>        Move (Replaces("/.",sFmt,Character(2)))    to sFmt
78980>>>>>>>>>>>>>>>        Move (Replaces("/,",sFmt,Character(3)))    to sFmt
78981>>>>>>>>>>>>>>>        Move (Replaces("/"+"/",sFmt,Character(4))) to sFmt
78982>>>>>>>>>>>>>>>        Move (Replaces("/#",sFmt,Character(5)))    to sFmt
78983>>>>>>>>>>>>>>>        Move (Character(9)) to sDigit
78984>>>>>>>>>>>>>>>        Move (Replaces("#",sFmt,sDigit))           to sFmt
78985>>>>>>>>>>>>>>>        Move (Replaces("/",sFmt,""))               to sFmt // replace all others
78986>>>>>>>>>>>>>>>        
78986>>>>>>>>>>>>>>>        Move (Pos(",",sFmt))                 to bSep // if we have any , we use thousand seps
78987>>>>>>>>>>>>>>>        If bSep ;            Move (Replaces(",",sFmt,"")) to sFmt // remove all ,
78990>>>>>>>>>>>>>>>        
78990>>>>>>>>>>>>>>>        Move (Replaces("$",sFmt,psCurrencySymbol(Self))) to sFmt // replace any $ with currency symbol
78991>>>>>>>>>>>>>>>        
78991>>>>>>>>>>>>>>>        Move (Pos(".",sFmt)) to iPos                 // position of decimal
78992>>>>>>>>>>>>>>>        
78992>>>>>>>>>>>>>>>        // Move all the special literals back into place before parsing
78992>>>>>>>>>>>>>>>        Move (Replaces(Character(1),sFmt,"$")) to sFmt
78993>>>>>>>>>>>>>>>        Move (Replaces(Character(2),sFmt,".")) to sFmt
78994>>>>>>>>>>>>>>>        Move (Replaces(Character(3),sFmt,",")) to sFmt
78995>>>>>>>>>>>>>>>        Move (Replaces(Character(4),sFmt,"/")) to sFmt
78996>>>>>>>>>>>>>>>        Move (Replaces(Character(5),sFmt,"#")) to sFmt
78997>>>>>>>>>>>>>>>        
78997>>>>>>>>>>>>>>>        If (iPos>0) Begin                      // if we have a decimanl point
78999>>>>>>>>>>>>>>>            Move 1 to i                        // look for first non # to right and count the #s
79000>>>>>>>>>>>>>>>            If (mid(sFmt,1,iPos+i)="*") Begin  // the "*" is special. It means as many as you want
79002>>>>>>>>>>>>>>>                Move -2 to iDigits
79003>>>>>>>>>>>>>>>                Increment i
79004>>>>>>>>>>>>>>>            End
79004>>>>>>>>>>>>>>>>
79004>>>>>>>>>>>>>>>            While (mid(sFmt,1,iPos+i)=sDigit)
79008>>>>>>>>>>>>>>>                Increment i
79009>>>>>>>>>>>>>>>            Loop
79010>>>>>>>>>>>>>>>>
79010>>>>>>>>>>>>>>>            Move (Mid(sFmt,255,iPos+i)) to sRight // everything to the right of the last # is format stuff
79011>>>>>>>>>>>>>>>            If (iDigits=0) ;                Move (i-1) to iDigits
79014>>>>>>>>>>>>>>>            //
79014>>>>>>>>>>>>>>>            Move 1 to i                           // find the first non-# to the left of the point
79015>>>>>>>>>>>>>>>            While (mid(sFmt,1,iPos-i)=sDigit)     // everything to the left is format stuff
79019>>>>>>>>>>>>>>>                Increment i
79020>>>>>>>>>>>>>>>            Loop
79021>>>>>>>>>>>>>>>>
79021>>>>>>>>>>>>>>>            Move (left(sFmt,iPos-i)) to sLeft
79022>>>>>>>>>>>>>>>        End
79022>>>>>>>>>>>>>>>>
79022>>>>>>>>>>>>>>>        Else Begin                             // we have no decinal
79023>>>>>>>>>>>>>>>            Move 0 to iDigits                  // so points is none
79024>>>>>>>>>>>>>>>            Move (Pos(sDigit,sFmt)) to iPos    // find first #.
79025>>>>>>>>>>>>>>>            If (iPos=0) Begin                  // if none, entire string is left format stuff..wierd!
79027>>>>>>>>>>>>>>>                Move sFmt to sLeft
79028>>>>>>>>>>>>>>>                Move ""   to sRight
79029>>>>>>>>>>>>>>>            End
79029>>>>>>>>>>>>>>>>
79029>>>>>>>>>>>>>>>            Else Begin
79030>>>>>>>>>>>>>>>                Move (left(sFmt,iPos-1)) to sLeft // all char to left of first # is left format stuff
79031>>>>>>>>>>>>>>>                Move 1 to i
79032>>>>>>>>>>>>>>>                While (mid(sFmt,1,iPos+i)=sDigit) // find last #, all char to right is right format
79036>>>>>>>>>>>>>>>                    Increment i
79037>>>>>>>>>>>>>>>                Loop
79038>>>>>>>>>>>>>>>>
79038>>>>>>>>>>>>>>>                Move (Mid(sFmt,255,i+iPos)) to sRight
79039>>>>>>>>>>>>>>>            End
79039>>>>>>>>>>>>>>>>
79039>>>>>>>>>>>>>>>        End
79039>>>>>>>>>>>>>>>>
79039>>>>>>>>>>>>>>>        // set temporary format properties and exit
79039>>>>>>>>>>>>>>>        Set pbThousandsSep to bSep
79040>>>>>>>>>>>>>>>        Set psLeft         to sLeft
79041>>>>>>>>>>>>>>>        Set psRight        to sRight
79042>>>>>>>>>>>>>>>        Set piPoints       to iDigits
79043>>>>>>>>>>>>>>>    End_Procedure
79044>>>>>>>>>>>>>>>    
79044>>>>>>>>>>>>>>>    // Public: Sets a format string. Pass full format for Positve and negative in sFmt. Pass
79044>>>>>>>>>>>>>>>    //         bCurrency true is this is a currency format, false if a numeric format
79044>>>>>>>>>>>>>>>    //
79044>>>>>>>>>>>>>>>    //  e.g. Send SetFormat "$,#.##;($,#.##)" True
79044>>>>>>>>>>>>>>>    Procedure SetFormat String sFmt Integer bCurrency
79046>>>>>>>>>>>>>>>        String sPos sNeg
79046>>>>>>>>>>>>>>>        Integer iPos
79046>>>>>>>>>>>>>>>        
79046>>>>>>>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
79047>>>>>>>>>>>>>>>        If iPos Begin
79049>>>>>>>>>>>>>>>            Move (left(sFmt,iPos-1))    to sPos
79050>>>>>>>>>>>>>>>            Move (mid(sFmt,255,iPos+1)) to sNeg
79051>>>>>>>>>>>>>>>        End
79051>>>>>>>>>>>>>>>>
79051>>>>>>>>>>>>>>>        Else Begin
79052>>>>>>>>>>>>>>>            Move sFmt         to sPos
79053>>>>>>>>>>>>>>>            Move ("-" + sFmt) to sNeg
79054>>>>>>>>>>>>>>>        End
79054>>>>>>>>>>>>>>>>
79054>>>>>>>>>>>>>>>        Send ParseFormat sPos
79055>>>>>>>>>>>>>>>        If bCurrency Begin
79057>>>>>>>>>>>>>>>            Set pbCurPosThousandsSep to (pbThousandsSep(Self))
79058>>>>>>>>>>>>>>>            Set psCurPosLeft         to (psLeft(Self))
79059>>>>>>>>>>>>>>>            Set psCurPosRight        to (psRight(Self))
79060>>>>>>>>>>>>>>>            Set piCurPosPoints       to (piPoints(Self))
79061>>>>>>>>>>>>>>>        End
79061>>>>>>>>>>>>>>>>
79061>>>>>>>>>>>>>>>        Else Begin
79062>>>>>>>>>>>>>>>            Set pbNumPosThousandsSep to (pbThousandsSep(Self))
79063>>>>>>>>>>>>>>>            Set psNumPosLeft         to (psLeft(Self))
79064>>>>>>>>>>>>>>>            Set psNumPosRight        to (psRight(Self))
79065>>>>>>>>>>>>>>>            Set piNumPosPoints       to (piPoints(Self))
79066>>>>>>>>>>>>>>>        End
79066>>>>>>>>>>>>>>>>
79066>>>>>>>>>>>>>>>        
79066>>>>>>>>>>>>>>>        Send ParseFormat sNeg
79067>>>>>>>>>>>>>>>        If bCurrency Begin
79069>>>>>>>>>>>>>>>            Set pbCurNegThousandsSep to (pbThousandsSep(Self))
79070>>>>>>>>>>>>>>>            Set psCurNegLeft         to (psLeft(Self))
79071>>>>>>>>>>>>>>>            Set psCurNegRight        to (psRight(Self))
79072>>>>>>>>>>>>>>>            Set piCurNegPoints       to (piPoints(Self))
79073>>>>>>>>>>>>>>>        End
79073>>>>>>>>>>>>>>>>
79073>>>>>>>>>>>>>>>        Else Begin
79074>>>>>>>>>>>>>>>            Set pbNumNegThousandsSep to (pbThousandsSep(Self))
79075>>>>>>>>>>>>>>>            Set psNumNegLeft         to (psLeft(Self))
79076>>>>>>>>>>>>>>>            Set psNumNegRight        to (psRight(Self))
79077>>>>>>>>>>>>>>>            Set piNumNegPoints       to (piPoints(Self))
79078>>>>>>>>>>>>>>>        End
79078>>>>>>>>>>>>>>>>
79078>>>>>>>>>>>>>>>    End_Procedure
79079>>>>>>>>>>>>>>>    
79079>>>>>>>>>>>>>>>    // low level formatting. Pass parameters
79079>>>>>>>>>>>>>>>    Function Format_Num Number nNumber Integer iPoints Integer bSep ;            String sPrefix String sSuffix Returns String
79081>>>>>>>>>>>>>>>        String  sLeft sRight sNumber sSep sDec
79081>>>>>>>>>>>>>>>        Integer iDec iLen iCh
79081>>>>>>>>>>>>>>>        
79081>>>>>>>>>>>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iCh
79084>>>>>>>>>>>>>>>        Move (Character(iCh)) to sDec
79085>>>>>>>>>>>>>>>        
79085>>>>>>>>>>>>>>>        Move (abs(nNumber)) to sNumber
79086>>>>>>>>>>>>>>>        Move (Pos(sDec,sNumber)) to iDec
79087>>>>>>>>>>>>>>>        Move (If(iDec=0, sNumber, left(sNumber,iDec-1))) to sLeft
79088>>>>>>>>>>>>>>>        Move (If(iDec=0, "", mid(sNumber,255,iDec+1)))   to sRight
79089>>>>>>>>>>>>>>>        // format for decimal separator
79089>>>>>>>>>>>>>>>        If (iPoints>=0) ; // if -2, leave it alone, it should not be -1            Move (left(sRight+Repeat("0",iPoints),iPoints)) to sRight
79092>>>>>>>>>>>>>>>        
79092>>>>>>>>>>>>>>>        // format for thousand sep.
79092>>>>>>>>>>>>>>>        If bSep Begin
79094>>>>>>>>>>>>>>>            Get_Attribute DF_THOUSANDS_SEPARATOR to iCh
79097>>>>>>>>>>>>>>>            Move (Character(iCh)) to sSep
79098>>>>>>>>>>>>>>>            Move (Length(sLeft)) to iLen
79099>>>>>>>>>>>>>>>            While (iLen>3)
79103>>>>>>>>>>>>>>>                Move (insert(sSep,sLeft,iLen-2)) to sLeft
79104>>>>>>>>>>>>>>>                Move (iLen-3) to iLen
79105>>>>>>>>>>>>>>>            Loop
79106>>>>>>>>>>>>>>>>
79106>>>>>>>>>>>>>>>        End
79106>>>>>>>>>>>>>>>>
79106>>>>>>>>>>>>>>>        // if decimal points or -2 (allow anything) and there are points to show
79106>>>>>>>>>>>>>>>        If (iPoints>0 or (iPoints=-2 and sRight<>"")) ;            Move (sLeft + sDec + sright) to sLeft
79109>>>>>>>>>>>>>>>        Function_Return (sPrefix + sLeft+ sSuffix)
79110>>>>>>>>>>>>>>>    End_Function
79111>>>>>>>>>>>>>>>    
79111>>>>>>>>>>>>>>>    // Public: Format for currency
79111>>>>>>>>>>>>>>>    Function FormatCur Number nNumber Integer iPoints Returns String
79113>>>>>>>>>>>>>>>        String  sLeft sRight
79113>>>>>>>>>>>>>>>        Integer bSep
79113>>>>>>>>>>>>>>>        If (nNumber<0) Begin
79115>>>>>>>>>>>>>>>            Get pbCurNegThousandsSep to bSep
79116>>>>>>>>>>>>>>>            Get psCurNegLeft         to sLeft
79117>>>>>>>>>>>>>>>            Get psCurNegRight        to sRight
79118>>>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piCurNegPoints       to iPoints
79121>>>>>>>>>>>>>>>        End
79121>>>>>>>>>>>>>>>>
79121>>>>>>>>>>>>>>>        Else Begin
79122>>>>>>>>>>>>>>>            Get pbCurPosThousandsSep to bSep
79123>>>>>>>>>>>>>>>            Get psCurPosLeft         to sLeft
79124>>>>>>>>>>>>>>>            Get psCurPosRight        to sRight
79125>>>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piCurPosPoints       to iPoints
79128>>>>>>>>>>>>>>>        End
79128>>>>>>>>>>>>>>>>
79128>>>>>>>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
79129>>>>>>>>>>>>>>>    End_Function
79130>>>>>>>>>>>>>>>    
79130>>>>>>>>>>>>>>>    // Public: Format for numeric
79130>>>>>>>>>>>>>>>    Function FormatNum Number nNumber Integer iPoints Returns String
79132>>>>>>>>>>>>>>>        String  sLeft sRight
79132>>>>>>>>>>>>>>>        Integer bSep
79132>>>>>>>>>>>>>>>        If (nNumber<0) Begin
79134>>>>>>>>>>>>>>>            Get pbNumNegThousandsSep to bSep
79135>>>>>>>>>>>>>>>            Get psNumNegLeft         to sLeft
79136>>>>>>>>>>>>>>>            Get psNumNegRight        to sRight
79137>>>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piNumNegPoints       to iPoints
79140>>>>>>>>>>>>>>>        End
79140>>>>>>>>>>>>>>>>
79140>>>>>>>>>>>>>>>        Else Begin
79141>>>>>>>>>>>>>>>            Get pbNumPosThousandsSep to bSep
79142>>>>>>>>>>>>>>>            Get psNumPosLeft         to sLeft
79143>>>>>>>>>>>>>>>            Get psNumPosRight        to sRight
79144>>>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piNumPosPoints       to iPoints
79147>>>>>>>>>>>>>>>        End
79147>>>>>>>>>>>>>>>>
79147>>>>>>>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
79148>>>>>>>>>>>>>>>    End_Function
79149>>>>>>>>>>>>>>>    
79149>>>>>>>>>>>>>>>    
79149>>>>>>>>>>>>>>>    // Public: Format passing format string
79149>>>>>>>>>>>>>>>    Function FormatVal Number nNumber String sFmt Returns String
79151>>>>>>>>>>>>>>>        Integer iPos bIsNeg
79151>>>>>>>>>>>>>>>        String  sLeft sRight
79151>>>>>>>>>>>>>>>        Integer iPoints bSep
79151>>>>>>>>>>>>>>>        Move (nNumber<0) to bIsNeg
79152>>>>>>>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
79153>>>>>>>>>>>>>>>        Case Begin
79153>>>>>>>>>>>>>>>            Case (iPos and not(bIsNeg)) ;                Move (left(sFmt,iPos-1))    to sFmt
79156>>>>>>>>>>>>>>>            Case (iPos and bIsNeg) ;                Move (mid(sFmt,255,iPos+1)) to sFmt
79160>>>>>>>>>>>>>>>            Case (not(iPos) and not(bIsNeg)) ;                Move sFmt                   to sFmt
79164>>>>>>>>>>>>>>>            Case Else ;                Move ("-" + sFmt)           to sFmt
79166>>>>>>>>>>>>>>>        Case End
79166>>>>>>>>>>>>>>>        Send ParseFormat sFmt
79167>>>>>>>>>>>>>>>        Get pbThousandsSep to bSep
79168>>>>>>>>>>>>>>>        Get psLeft         to sLeft
79169>>>>>>>>>>>>>>>        Get psRight        to sRight
79170>>>>>>>>>>>>>>>        Get piPoints       to iPoints
79171>>>>>>>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
79172>>>>>>>>>>>>>>>    End_Function
79173>>>>>>>>>>>>>>>    
79173>>>>>>>>>>>>>>>End_Class
79174>>>>>>>>>>>>>
79174>>>>>>>>>>>>>Global_Variable Handle ghoFormatter
79174>>>>>>>>>>>>>Get Create of desktop U_cFormatter to ghoFormatter
79175>>>>>>>>>>>>>
79175>>>>>>>>>>>>>Function FormatNumber Global Number nNum Integer iPoints Returns String
79177>>>>>>>>>>>>>    Function_Return (FormatNum(ghoFormatter, nNum,iPoints))
79178>>>>>>>>>>>>>End_Function
79179>>>>>>>>>>>>>
79179>>>>>>>>>>>>>Function FormatCurrency Global Number nNum Integer iPoints Returns String
79181>>>>>>>>>>>>>    Function_Return (FormatCur(ghoFormatter, nNum,iPoints))
79182>>>>>>>>>>>>>End_Function
79183>>>>>>>>>>>>>
79183>>>>>>>>>>>>>Function FormatValue Global Number nNum String sFmt Returns String
79185>>>>>>>>>>>>>    Function_Return (FormatVal(ghoFormatter, nNum,sFmt))
79186>>>>>>>>>>>>>End_Function
79187>>>>>>>>>>>>>
79187>>>>>>>>>>>>>Procedure SetCurrencyFormat Global String sFmt
79189>>>>>>>>>>>>>    Send SetFormat of ghoFormatter sFmt True
79190>>>>>>>>>>>>>End_Procedure
79191>>>>>>>>>>>>>
79191>>>>>>>>>>>>>Procedure SetNumberFormat Global String sFmt
79193>>>>>>>>>>>>>    Send SetFormat of ghoFormatter sFmt False
79194>>>>>>>>>>>>>End_Procedure
79195>>>>>>>>>>>>>
79195>>>>>>>>>>>>>
79195>>>>>>>>>>>Use tWinStructs.pkg
79195>>>>>>>>>>>
79195>>>>>>>>>>>Use cli.pkg
79195>>>>>>>>>>>Use DFBTRDRV.PKG
79195>>>>>>>>>>>Use MSSqldrv.pkg
79195>>>>>>>>>>>Use db2_drv.pkg
79195>>>>>>>>>>>Use odbc_drv.pkg
79195>>>>>>>>>>>Use seq_chnl.pkg
79195>>>>>>>>>>>
79195>>>>>>>>>>>Register_Function phoWorkspace Returns Handle
79195>>>>>>>>>>>Register_Function Help_filename Returns String
79195>>>>>>>>>>>Register_Function GetHelpFile Returns String
79195>>>>>>>>>>>Register_Function pbEnterKeyAsTabKey Returns Boolean
79195>>>>>>>>>>>
79195>>>>>>>>>>>// *** Constant Declarations: ***
79195>>>>>>>>>>>//
79195>>>>>>>>>>>
79195>>>>>>>>>>>
79195>>>>>>>>>>>
79195>>>>>>>>>>>
79195>>>>>>>>>>>
79195>>>>>>>>>>>
79195>>>>>>>>>>>// 2016-12-12, Samuel:  Added section for Portuguese
79195>>>>>>>>>>>
79195>>>>>>>>>>>
79195>>>>>>>>>>>
79195>>>>>>>>>>>
79195>>>>>>>>>>>
79195>>>>>>>>>>>
79195>>>>>>>>>>>
79195>>>>>>>>>>>
79195>>>>>>>>>>>
79195>>>>>>>>>>>// System icon menu constants. If the upper left hand
79195>>>>>>>>>>>// icon in dialogs is clicked, shadow all menu items except Move & Close.
79195>>>>>>>>>>>    Define SC_RESTORE  for |CI$F120
79195>>>>>>>>>>>    Define SC_MOVE     for |CI$F010
79195>>>>>>>>>>>    Define SC_SIZE     for |CI$F000
79195>>>>>>>>>>>    Define SC_MINIMIZE for |CI$F020
79195>>>>>>>>>>>    Define SC_MAXIMIZE for |CI$F030
79195>>>>>>>>>>>    Define SC_CLOSE    for |CI$F060
79195>>>>>>>>>>>    Define SC_KEYMENU  for |CI$F100
79195>>>>>>>>>>>    Define SC_NEXTWINDOW for |CI$F040
79195>>>>>>>>>>>    Define SC_PREVWINDOW for |CI$F050
79195>>>>>>>>>>>
79195>>>>>>>>>>>Define CS_SignProgram        for "signtool.exe"
79195>>>>>>>>>>>Define CS_TempCertBatchFile  for "certinfo.bat"
79195>>>>>>>>>>>Define CS_VerifyCredentials  for "verify"
79195>>>>>>>>>>>Define CS_VerifyFileParam    for "/a"
79195>>>>>>>>>>>Define CS_DefAuthVerPolicy   for "/pa"
79195>>>>>>>>>>>Define SEE_MASK_NOCLOSEPROCESS for 64 //(0x00000040)
79195>>>>>>>>>>>
79195>>>>>>>>>>>// *** Struct Declarations: ***
79195>>>>>>>>>>>Struct AboutSHELLEXECUTEINFO
79195>>>>>>>>>>>    DWord   cbSize
79195>>>>>>>>>>>    Integer fMask
79195>>>>>>>>>>>    Handle  hwnd
79195>>>>>>>>>>>    Pointer lpVerb
79195>>>>>>>>>>>    Pointer lpFile
79195>>>>>>>>>>>    Pointer lpParameters
79195>>>>>>>>>>>    Pointer lpDirectory
79195>>>>>>>>>>>    Integer nShow
79195>>>>>>>>>>>    Pointer hInstApp
79195>>>>>>>>>>>    Pointer lpIDList
79195>>>>>>>>>>>    Pointer lpClass
79195>>>>>>>>>>>    Handle  hkeyClass
79195>>>>>>>>>>>    DWord   dwHotKey
79195>>>>>>>>>>>    Handle  hIconMonitor // Union
79195>>>>>>>>>>>    //Handle  hMonitor     // Union
79195>>>>>>>>>>>    Handle  hProcess
79195>>>>>>>>>>>End_Struct
79195>>>>>>>>>>>
79195>>>>>>>>>>>
79195>>>>>>>>>>>// OBSOLETE STRUCTURE AND WINDOWS API CALL. KEPT FOR BACKWARDS COMPATIBILITY
79195>>>>>>>>>>>//Type MEMORYSTATUS
79195>>>>>>>>>>>//   Field MEMORYSTATUS.dwLength         as DWord // sizeof(MEMORYSTATUS)
79195>>>>>>>>>>>//   Field MEMORYSTATUS.dwMemoryLoad     as DWord // percent Of memory in use
79195>>>>>>>>>>>//   Field MEMORYSTATUS.dwTotalPhys      as DWord // bytes Of physical memory
79195>>>>>>>>>>>//   Field MEMORYSTATUS.dwAvailPhys      as DWord // free physical memory bytes
79195>>>>>>>>>>>//   Field MEMORYSTATUS.dwTotalPageFile  as DWord // bytes Of paging file
79195>>>>>>>>>>>//   Field MEMORYSTATUS.dwAvailPageFile  as DWord // free bytes Of paging file
79195>>>>>>>>>>>//   Field MEMORYSTATUS.dwTotalVirtual   as DWord // user bytes Of address space
79195>>>>>>>>>>>//   Field MEMORYSTATUS.dwAvailVirtual   as DWord // free user bytes
79195>>>>>>>>>>>//End_Type
79195>>>>>>>>>>>
79195>>>>>>>>>>>// *** External Function calls: ***
79195>>>>>>>>>>>//
79195>>>>>>>>>>>    External_Function GetSystemMenu "GetSystemMenu" User32.dll Handle hWnd Boolean bRevert Returns Handle
79196>>>>>>>>>>>
79196>>>>>>>>>>>    External_Function GetRemoveMenu "RemoveMenu" user32.dll Handle hWnd UInteger uPosition UInteger uFlags Returns Handle
79197>>>>>>>>>>>
79197>>>>>>>>>>>// Do not call directly, use the wrapper function instead
79197>>>>>>>>>>>External_Function WNetGetUserW "WNetGetUserW" MPR.DLL ;    Pointer lpName ;    Pointer lpUser_Name ;    Pointer lpLength ;    Returns DWord
79198>>>>>>>>>>>
79198>>>>>>>>>>>    // Wrapper Function WNetGetUser
79198>>>>>>>>>>>    Function WNetGetUser Global ;        Pointer lpName ;        Pointer lpUser_Name ;        Pointer lpLength ;        Returns DWord
79200>>>>>>>>>>>
79200>>>>>>>>>>>        DWord   dwResult
79200>>>>>>>>>>>        UWide   uwName uwUserName
79200>>>>>>>>>>>        UWide   uwName uwUserName
79200>>>>>>>>>>>
79200>>>>>>>>>>>        Send StringToWide lpName (&uwName)
79201>>>>>>>>>>>
79201>>>>>>>>>>>        Send WideSetBuffer lpUser_Name lpLength (&uwUserName)
79202>>>>>>>>>>>
79202>>>>>>>>>>>        Move (WNetGetUserW (uwName.lpUText, uwUserName.lpUText, lpLength)) to dwResult
79203>>>>>>>>>>>
79203>>>>>>>>>>>        Send WideToString (&uwUserName) lpUser_Name
79204>>>>>>>>>>>
79204>>>>>>>>>>>        Function_Return dwResult
79205>>>>>>>>>>>    End_Function
79206>>>>>>>>>>>
79206>>>>>>>>>>>
79206>>>>>>>>>>>    External_Function GlobalMemoryStatus "GlobalMemoryStatus" Kernel32.Dll Pointer lpsMemoryStatus Returns Integer
79207>>>>>>>>>>>
79207>>>>>>>>>>>    External_Function GlobalMemoryStatusEx "GlobalMemoryStatusEx" Kernel32.Dll Pointer lpMemoryStatus Returns Integer
79208>>>>>>>>>>>
79208>>>>>>>>>>>External_Function AboutShellExecuteEx "ShellExecuteEx" Shell32.dll Pointer pExecInfo Returns Integer
79209>>>>>>>>>>>
79209>>>>>>>>>>>External_Function AboutWaitForSingleObject "WaitForSingleObject" Kernel32.dll ;  Handle hHandle ;  DWord dwMilliseconds ;  Returns DWord
79210>>>>>>>>>>>
79210>>>>>>>>>>>External_Function AboutCloseHandle "CloseHandle" Kernel32.dll Handle hHandle Returns Integer
79211>>>>>>>>>>>
79211>>>>>>>>>>>// *** Global/Desktop Function Declarations: ***
79211>>>>>>>>>>>
79211>>>>>>>>>>>Function ComputerName Desktop Returns String
79213>>>>>>>>>>>    String sName
79213>>>>>>>>>>>    Get_Environment "COMPUTERNAME" to sName
79214>>>>>>>>>>>>
79214>>>>>>>>>>>    Function_Return sName
79215>>>>>>>>>>>End_Function
79216>>>>>>>>>>>
79216>>>>>>>>>>>Function Network_User_Name Desktop Returns String
79218>>>>>>>>>>>    WString wName
79218>>>>>>>>>>>    Integer iRetval iLength
79218>>>>>>>>>>>
79218>>>>>>>>>>>    Move 0 to iLength
79219>>>>>>>>>>>    Move (WNetGetUserW (0, 0, AddressOf (iLength))) to iRetval
79220>>>>>>>>>>>    Move (ZeroString(iLength)) to wName
79221>>>>>>>>>>>    Move (WNetGetUserW (0, AddressOf (wName), AddressOf (iLength))) to iRetval
79222>>>>>>>>>>>
79222>>>>>>>>>>>    If (iRetval = NO_ERROR) Begin
79224>>>>>>>>>>>        Function_Return (CString (wName))
79225>>>>>>>>>>>    End
79225>>>>>>>>>>>>
79225>>>>>>>>>>>
79225>>>>>>>>>>>    Function_Return "User Unknown"
79226>>>>>>>>>>>End_Function
79227>>>>>>>>>>>
79227>>>>>>>>>>>Function SQLClientVersion Desktop String sDriverID Integer iClient Returns String
79229>>>>>>>>>>>    String sClient sDriver sClientDriver
79229>>>>>>>>>>>    Integer iNumberOfDrivers iDriver iCount iClientVersion
79229>>>>>>>>>>>    Handle hoMsqlDrv
79229>>>>>>>>>>>
79229>>>>>>>>>>>    Move 0 to iDriver
79230>>>>>>>>>>>    Move "" to sClient
79231>>>>>>>>>>>    Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
79234>>>>>>>>>>>    For iCount from 1 to iNumberOfDrivers
79240>>>>>>>>>>>>
79240>>>>>>>>>>>        Get_Attribute DF_DRIVER_NAME of iCount to sDriver
79243>>>>>>>>>>>        If (Uppercase(sDriver) = Uppercase(sDriverID)) Begin
79245>>>>>>>>>>>            Move iCount to iDriver
79246>>>>>>>>>>>            Move iNumberOfDrivers to iCount // We're done.
79247>>>>>>>>>>>        End
79247>>>>>>>>>>>>
79247>>>>>>>>>>>    Loop
79248>>>>>>>>>>>>
79248>>>>>>>>>>>
79248>>>>>>>>>>>    // This info is (at current) only available for the MS SQL driver:
79248>>>>>>>>>>>    If (sDriverID = MSSQLDRV_ID) Begin
79250>>>>>>>>>>>        Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
79253>>>>>>>>>>>        Get Create (RefClass(cMSSQLHandler)) to hoMsqlDrv
79254>>>>>>>>>>>        Get SqlServerClientVersionName of hoMsqlDrv iClientVersion to sClientDriver
79255>>>>>>>>>>>        Send Destroy of hoMsqlDrv
79256>>>>>>>>>>>        Move (SFormat("MSSQLDRV Client Version: %1", sClientDriver)) to sClient
79257>>>>>>>>>>>    End
79257>>>>>>>>>>>>
79257>>>>>>>>>>>
79257>>>>>>>>>>>    Function_Return sClient
79258>>>>>>>>>>>End_Function
79259>>>>>>>>>>>
79259>>>>>>>>>>>// *** Class Declarations: ***
79259>>>>>>>>>>>//
79259>>>>>>>>>>>Class cBitmapContainerDFLink is a BitmapContainer
79260>>>>>>>>>>>    Procedure Mouse_Click Integer iWindowNumber Integer iPosition
79262>>>>>>>>>>>        Send Mouse_Up iWindowNumber iPosition
79263>>>>>>>>>>>    End_Procedure
79264>>>>>>>>>>>    Procedure Mouse_Up Integer iWindowNumber Integer iPosition
79266>>>>>>>>>>>        Forward Send Mouse_Up iWindowNumber iPosition
79268>>>>>>>>>>>        Send Show_HomePage "http://www.dataaccess.com/"
79269>>>>>>>>>>>    End_Procedure
79270>>>>>>>>>>>End_Class
79271>>>>>>>>>>>
79271>>>>>>>>>>>Class cCopyEditorContentButton is a Button
79272>>>>>>>>>>>    Procedure Construct_Object
79274>>>>>>>>>>>        Forward Send Construct_Object
79276>>>>>>>>>>>        Property Handle phoEditorHandle
79277>>>>>>>>>>>        Set psToolTip to C_$DescCopy
79278>>>>>>>>>>>    End_Procedure
79279>>>>>>>>>>>
79279>>>>>>>>>>>    Procedure CopyToWindowsClipboard
79281>>>>>>>>>>>        Handle hoEditor
79281>>>>>>>>>>>        Boolean bCanCopy
79281>>>>>>>>>>>        Address aEditorAddress
79281>>>>>>>>>>>
79281>>>>>>>>>>>        Get phoEditorHandle to hoEditor
79282>>>>>>>>>>>        Send Select_All of hoEditor
79283>>>>>>>>>>>        Get CanCopy of hoEditor to bCanCopy
79284>>>>>>>>>>>        If (bCanCopy = True) Begin
79286>>>>>>>>>>>            Get paValue of hoEditor to aEditorAddress
79287>>>>>>>>>>>            Send Copy   of hoEditor
79288>>>>>>>>>>>            // Remove the selection after text is copied to the clipboard.
79288>>>>>>>>>>>            Send Beginning_of_Data of hoEditor
79289>>>>>>>>>>>            Send Info_Box C_$CopyToClipboard_Text
79290>>>>>>>>>>>        End
79290>>>>>>>>>>>>
79290>>>>>>>>>>>    End_Procedure
79291>>>>>>>>>>>End_Class
79292>>>>>>>>>>>
79292>>>>>>>>>>>Class SysinfoDisplay is a cTextEdit
79293>>>>>>>>>>>    Procedure Construct_Object
79295>>>>>>>>>>>        Forward Send Construct_Object
79297>>>>>>>>>>>
79297>>>>>>>>>>>        Set Size to 100 245
79298>>>>>>>>>>>        Set Location to 6 6
79299>>>>>>>>>>>        Set Border_Style to Border_None
79300>>>>>>>>>>>        Set Read_Only_State to True
79301>>>>>>>>>>>        Set pbWrap to True
79302>>>>>>>>>>>        Set peAnchors to anAll
79303>>>>>>>>>>>    End_Procedure
79304>>>>>>>>>>>
79304>>>>>>>>>>>    // Augmented class message to adjust certain text strings that are wrong...
79304>>>>>>>>>>>
79304>>>>>>>>>>>    Procedure AppendTextLn String sText
79306>>>>>>>>>>>        String sWorkspaceWSFile
79306>>>>>>>>>>>
79306>>>>>>>>>>>        // Only works for English:
79306>>>>>>>>>>>        If (ghoApplication > 0) Begin
79308>>>>>>>>>>>            If (sText contains "Workspace Name") Begin
79310>>>>>>>>>>>                Move "Workspace Config Filename:" to sText
79311>>>>>>>>>>>                Get psWorkspaceWSFile of (phoWorkspace(ghoApplication)) to sWorkspaceWSFile
79312>>>>>>>>>>>                Move (sText * sWorkspaceWSFile) to sText
79313>>>>>>>>>>>            End
79313>>>>>>>>>>>>
79313>>>>>>>>>>>        End
79313>>>>>>>>>>>>
79313>>>>>>>>>>>        Send AppendText sText
79314>>>>>>>>>>>        Send AppendText (character(10))
79315>>>>>>>>>>>    End_Procedure
79316>>>>>>>>>>>
79316>>>>>>>>>>>    //    This method will show the name Of the current directory in the system
79316>>>>>>>>>>>    //    information box
79316>>>>>>>>>>>    Procedure Show_Current_Directory
79318>>>>>>>>>>>        String sDir
79318>>>>>>>>>>>
79318>>>>>>>>>>>        Get_Current_Directory To sDir
79319>>>>>>>>>>>
79319>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$CurrentDirectory, sDir))
79320>>>>>>>>>>>    End_Procedure
79321>>>>>>>>>>>
79321>>>>>>>>>>>    Procedure Show_Windows_Directory
79323>>>>>>>>>>>        String sWindir
79323>>>>>>>>>>>
79323>>>>>>>>>>>        Get_Windows_Directory To sWindir
79324>>>>>>>>>>>
79324>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$WindowsDirectory, sWindir))
79325>>>>>>>>>>>    End_Procedure
79326>>>>>>>>>>>
79326>>>>>>>>>>>    Procedure Show_Current_User
79328>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$Computer_Name, ComputerName (Self)))
79329>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$NetworkUserName, Network_User_Name (Self)))
79330>>>>>>>>>>>    End_Procedure
79331>>>>>>>>>>>
79331>>>>>>>>>>>    Procedure Show_Number_Format
79333>>>>>>>>>>>        Integer iFormat
79333>>>>>>>>>>>        String sFormatText
79333>>>>>>>>>>>
79333>>>>>>>>>>>        Get_Attribute DF_THOUSANDS_SEPARATOR to iFormat
79336>>>>>>>>>>>        Move (Character (iFormat)) To sFormatText
79337>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$ThousandsSeparator, sFormatText, iFormat))
79338>>>>>>>>>>>
79338>>>>>>>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iFormat
79341>>>>>>>>>>>        Move (Character (iFormat)) to sFormatText
79342>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$DecimalSeparator, sFormatText))
79343>>>>>>>>>>>    End_Procedure
79344>>>>>>>>>>>
79344>>>>>>>>>>>    Procedure Show_Filelist_Name
79346>>>>>>>>>>>        String sFilename
79346>>>>>>>>>>>
79346>>>>>>>>>>>        Get_Attribute DF_FILELIST_NAME to sFilename
79349>>>>>>>>>>>
79349>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$CurrentFilelist, sFilename))
79350>>>>>>>>>>>    End_Procedure
79351>>>>>>>>>>>
79351>>>>>>>>>>>    Procedure Show_Lock_Delay
79353>>>>>>>>>>>        Integer iLockdelay
79353>>>>>>>>>>>
79353>>>>>>>>>>>        Get_Attribute DF_LOCK_DELAY to iLockdelay
79356>>>>>>>>>>>
79356>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingDelay, iLockDelay))
79357>>>>>>>>>>>    End_Procedure
79358>>>>>>>>>>>
79358>>>>>>>>>>>    Procedure Show_Lock_Timeout
79360>>>>>>>>>>>        Integer iLockTimeout
79360>>>>>>>>>>>
79360>>>>>>>>>>>        Get_Attribute DF_LOCK_TIMEOUT to iLockTimeout
79363>>>>>>>>>>>
79363>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingTimeout, iLockTimeOut))
79364>>>>>>>>>>>    End_Procedure
79365>>>>>>>>>>>
79365>>>>>>>>>>>    Procedure Show_Screen_Size
79367>>>>>>>>>>>        Integer iYscreensize iXscreensize
79367>>>>>>>>>>>
79367>>>>>>>>>>>        Move (GetSystemMetrics (SM_CXSCREEN)) To iXscreensize
79368>>>>>>>>>>>        Move (GetSystemMetrics (SM_CYSCREEN)) To iYscreensize
79369>>>>>>>>>>>
79369>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$VideoResolution, iXscreensize, iYscreensize))
79370>>>>>>>>>>>    End_Procedure
79371>>>>>>>>>>>
79371>>>>>>>>>>>    Procedure Show_Page_Size
79373>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$PageEndFormFeed, Pageend, Pagefeed))
79374>>>>>>>>>>>    End_procedure
79375>>>>>>>>>>>
79375>>>>>>>>>>>    Procedure Show_Date
79377>>>>>>>>>>>        Date dToday
79377>>>>>>>>>>>
79377>>>>>>>>>>>        Move (CurrentDateTime()) to dToday
79378>>>>>>>>>>>
79378>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$CurrentSystemDate, String (dToday)))
79379>>>>>>>>>>>    End_procedure
79380>>>>>>>>>>>
79380>>>>>>>>>>>    Procedure Show_Date_Format
79382>>>>>>>>>>>        Integer iDateFormat
79382>>>>>>>>>>>        String sDateFormat
79382>>>>>>>>>>>
79382>>>>>>>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
79385>>>>>>>>>>>        Case Begin
79385>>>>>>>>>>>            Case (iDateFormat = DF_DATE_USA)
79387>>>>>>>>>>>                Move C_$USA To sDateFormat
79388>>>>>>>>>>>                Case Break
79389>>>>>>>>>>>            Case (iDateFormat = DF_DATE_EUROPEAN)
79392>>>>>>>>>>>                Move C_$European To sDateFormat
79393>>>>>>>>>>>                Case Break
79394>>>>>>>>>>>            Case (iDateFormat = DF_DATE_MILITARY)
79397>>>>>>>>>>>                Move C_$Military To sDateFormat
79398>>>>>>>>>>>                Case Break
79399>>>>>>>>>>>            Case Else
79399>>>>>>>>>>>                Move C_$UnknownDateType To sDateFormat
79400>>>>>>>>>>>                Case Break
79401>>>>>>>>>>>        Case End
79401>>>>>>>>>>>
79401>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$DateFormat, sDateformat))
79402>>>>>>>>>>>    End_Procedure
79403>>>>>>>>>>>
79403>>>>>>>>>>>    // 2013-08-14 NGS
79403>>>>>>>>>>>    // Unformatted numeric values shown doesn't look good. These looks much better.
79403>>>>>>>>>>>    Procedure Show_Systemresources
79405>>>>>>>>>>>        tWinMemoryStatusEx MemoryStatusInfo
79405>>>>>>>>>>>        tWinMemoryStatusEx MemoryStatusInfo
79405>>>>>>>>>>>        Integer iRetval
79405>>>>>>>>>>>        Number nValue
79405>>>>>>>>>>>        String sValue
79405>>>>>>>>>>>
79405>>>>>>>>>>>        Move (SizeOfType (tWinMemoryStatusEx)) to MemoryStatusInfo.dwLength
79406>>>>>>>>>>>        Move (GlobalMemoryStatusEx (AddressOf (MemoryStatusInfo))) to iRetval
79407>>>>>>>>>>>        If (iRetval = 0) Begin
79409>>>>>>>>>>>            Move (ShowLastError ()) to iRetval
79410>>>>>>>>>>>            Procedure_Return
79411>>>>>>>>>>>        End
79411>>>>>>>>>>>>
79411>>>>>>>>>>>
79411>>>>>>>>>>>        Send AppendTextLn ""
79412>>>>>>>>>>>        Move MemoryStatusInfo.ullTotalPhys to nValue
79413>>>>>>>>>>>
79413>>>>>>>>>>>        // Show memory in Gigabytes:
79413>>>>>>>>>>>        Move (nValue/1024/1024/1024) to nValue
79414>>>>>>>>>>>        Move (Round(nValue)) to nValue
79415>>>>>>>>>>>        Get FormatNumber nValue 2 to sValue
79416>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailableMemory, (sValue * "GB")))
79417>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$MemoryUtilization, String(MemoryStatusInfo.dwMemoryLoad) * "%"))
79418>>>>>>>>>>>
79418>>>>>>>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, Real (MemoryStatusInfo.ullAvailPhys) / Real (MemoryStatusInfo.ullTotalPhys) * 100.0))
79418>>>>>>>>>>>        Move (Real(MemoryStatusInfo.ullAvailPhys) / Real(MemoryStatusInfo.ullTotalPhys) * 100.0) to nValue
79419>>>>>>>>>>>        Move (Round(nValue)) to nValue
79420>>>>>>>>>>>        Get FormatNumber nValue 0 to sValue
79421>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, (sValue * "%")))
79422>>>>>>>>>>>
79422>>>>>>>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, Real (MemoryStatusInfo.ullAvailPageFile) / Real (MemoryStatusInfo.ullTotalPageFile) * 100.0))
79422>>>>>>>>>>>        Move (Real(MemoryStatusInfo.ullAvailPageFile) / Real(MemoryStatusInfo.ullTotalPageFile) * 100.0) to nValue
79423>>>>>>>>>>>        Move (Round(nValue)) to nValue
79424>>>>>>>>>>>        Get FormatNumber nValue 0 to sValue
79425>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, (sValue * "%")))
79426>>>>>>>>>>>
79426>>>>>>>>>>>//        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, Real (MemoryStatusInfo.ullAvailVirtual) / Real (MemoryStatusInfo.ullTotalVirtual) * 100.0))
79426>>>>>>>>>>>        Move (Real(MemoryStatusInfo.ullAvailVirtual) / Real(MemoryStatusInfo.ullTotalVirtual) * 100.0) to nValue
79427>>>>>>>>>>>        Move (Round(nValue)) to nValue
79428>>>>>>>>>>>        Get FormatNumber nValue 0 to sValue
79429>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, (sValue * "%")))
79430>>>>>>>>>>>
79430>>>>>>>>>>>        // Add an empty row after the memory information:
79430>>>>>>>>>>>        Send AppendTextLn ""
79431>>>>>>>>>>>    End_Procedure
79432>>>>>>>>>>>
79432>>>>>>>>>>>    Procedure Show_Registration
79434>>>>>>>>>>>        String sRegName
79434>>>>>>>>>>>        Integer iSN iUsersMax iUserCount
79434>>>>>>>>>>>
79434>>>>>>>>>>>        Registration sRegName iSN
79435>>>>>>>>>>>>
79435>>>>>>>>>>>        Get_Licensed_Max_Users to iUsersMax
79436>>>>>>>>>>>        Get_Current_User_Count to iUserCount
79437>>>>>>>>>>>
79437>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$Serial, iSN))
79438>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$RegName, sRegName))
79439>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$Current_User_Count, iUserCount))
79440>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$Max_Licensed_User_Count, iUsersMax))
79441>>>>>>>>>>>    End_Procedure
79442>>>>>>>>>>>
79442>>>>>>>>>>>    //****************************************************************************
79442>>>>>>>>>>>    // If workspaces are used, we will send the message EnumerateWorkspaceData
79442>>>>>>>>>>>    // To the workspace object passing the an object and message To send back
79442>>>>>>>>>>>    // To this object. It is expected that the workspace object will send this
79442>>>>>>>>>>>    // message for every line Of information it wants displayed (passing the
79442>>>>>>>>>>>    // information To be displayed
79442>>>>>>>>>>>    //****************************************************************************
79442>>>>>>>>>>>    Register_Procedure EnumerateWorkspaceData Integer hObjId Integer hmMessId
79442>>>>>>>>>>>
79442>>>>>>>>>>>    Procedure Show_ServicePack
79444>>>>>>>>>>>        String sKey sVersion sDataFlex
79444>>>>>>>>>>>        Handle hoRegistry
79444>>>>>>>>>>>        Boolean bExists bOpened
79444>>>>>>>>>>>
79444>>>>>>>>>>>        Move "DataFlex"        to sDataFlex
79445>>>>>>>>>>>
79445>>>>>>>>>>>        Get Create (RefClass(cRegistry)) to hoRegistry
79446>>>>>>>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
79447>>>>>>>>>>>        Set pfAccessRights of hoRegistry to KEY_READ
79448>>>>>>>>>>>        Get KeyExists of hoRegistry "SOFTWARE\Wow6432Node" to bExists
79449>>>>>>>>>>>
79449>>>>>>>>>>>        If (bExists) Begin
79451>>>>>>>>>>>            Move ("SOFTWARE\Wow6432Node\Data Access Worldwide\" + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
79452>>>>>>>>>>>        End
79452>>>>>>>>>>>>
79452>>>>>>>>>>>        Else Begin
79453>>>>>>>>>>>            Move ("SOFTWARE\Data Access Worldwide\"             + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
79454>>>>>>>>>>>        End
79454>>>>>>>>>>>>
79454>>>>>>>>>>>        Get KeyExists of hoRegistry sKey to bExists
79455>>>>>>>>>>>        If (bExists) Begin
79457>>>>>>>>>>>            Get OpenKey of hoRegistry sKey to bOpened
79458>>>>>>>>>>>            If (bOpened) Begin
79460>>>>>>>>>>>                Get ValueExists of hoRegistry "CurrentVersionDescription" to bExists
79461>>>>>>>>>>>                If (bExists) Begin
79463>>>>>>>>>>>                    Get ReadString of hoRegistry "CurrentVersionDescription" to sVersion
79464>>>>>>>>>>>                End
79464>>>>>>>>>>>>
79464>>>>>>>>>>>                Send CloseKey of hoRegistry
79465>>>>>>>>>>>            End
79465>>>>>>>>>>>>
79465>>>>>>>>>>>        End
79465>>>>>>>>>>>>
79465>>>>>>>>>>>        Send Destroy of hoRegistry
79466>>>>>>>>>>>
79466>>>>>>>>>>>        If (sVersion <> "") Begin
79468>>>>>>>>>>>           Send AppendTextLn sVersion
79469>>>>>>>>>>>           Send AppendTextLn ""
79470>>>>>>>>>>>        End
79470>>>>>>>>>>>>
79470>>>>>>>>>>>    End_Procedure
79471>>>>>>>>>>>
79471>>>>>>>>>>>    Procedure Show_WorkspaceInformation
79473>>>>>>>>>>>        Integer hoWorkspace
79473>>>>>>>>>>>
79473>>>>>>>>>>>        If (ghoApplication <> 0) Begin
79475>>>>>>>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
79476>>>>>>>>>>>            If (hoWorkspace <> 0) Begin
79478>>>>>>>>>>>                Send EnumerateWorkspaceData of hoWorkspace Self msg_AppendTextLn
79479>>>>>>>>>>>            End
79479>>>>>>>>>>>>
79479>>>>>>>>>>>        End
79479>>>>>>>>>>>>
79479>>>>>>>>>>>    End_Procedure
79480>>>>>>>>>>>
79480>>>>>>>>>>>    //****************************************************************************
79480>>>>>>>>>>>    // If connection ids are used, we will send the message EnumerateConnections
79480>>>>>>>>>>>    // to the connection manager object passing the an object and message to send
79480>>>>>>>>>>>    // back to this object. It is expected that the connection manager object will
79480>>>>>>>>>>>    // send this message for every line Of information it wants displayed (passing
79480>>>>>>>>>>>    // the information To be displayed
79480>>>>>>>>>>>    //****************************************************************************
79480>>>>>>>>>>>    Register_Procedure EnumerateConnections Integer hObjId Integer hmMessId
79480>>>>>>>>>>>
79480>>>>>>>>>>>    Procedure Show_ConnectionIdInformation
79482>>>>>>>>>>>        If (ghoConnection > 0) Begin
79484>>>>>>>>>>>            Send EnumerateConnections of ghoConnection Self (RefProc(AppendTextLn))
79485>>>>>>>>>>>            Send AppendTextLn ""
79486>>>>>>>>>>>        End
79486>>>>>>>>>>>>
79486>>>>>>>>>>>    End_Procedure
79487>>>>>>>>>>>
79487>>>>>>>>>>>    Function VersionStr Integer iVer Integer iRev Integer iBld Returns String
79489>>>>>>>>>>>        Function_Return (String (iVer) - "." - String (iRev) - "." - String (iBld))
79490>>>>>>>>>>>    End_Function
79491>>>>>>>>>>>
79491>>>>>>>>>>>    Procedure Show_Versions
79493>>>>>>>>>>>        Integer iVersion iRevision iBuild
79493>>>>>>>>>>>
79493>>>>>>>>>>>        Version_information iVersion iRevision iBuild
79495>>>>>>>>>>>
79495>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$RuntimeVersion, VersionStr(self,iVersion,iRevision,iBuild) ))
79496>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$PackageVersion, VersionStr(self,PKG_VERSION, PKG_REVISION, PKG_BUILD) ))
79497>>>>>>>>>>>        Send AppendTextLn (SFormat (C_$FMACVersion, VersionStr(self,FMAC_VERSION, FMAC_REVISION, FMAC_BUILD) ))
79498>>>>>>>>>>>        Send AppendTextLn "This is a 32-bit exe file"
79499>>>>>>>>>>>    End_Procedure
79500>>>>>>>>>>>
79500>>>>>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
79502>>>>>>>>>>>        Boolean bOK
79502>>>>>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
79503>>>>>>>>>>>        Function_Return bOK
79504>>>>>>>>>>>    End_Function
79505>>>>>>>>>>>
79505>>>>>>>>>>>    //***
79505>>>>>>>>>>>    //*** BW
79505>>>>>>>>>>>    //*** Procedure: Show_Drivers
79505>>>>>>>>>>>    //*** Purpose  : Show loaded database drivers
79505>>>>>>>>>>>    //***
79505>>>>>>>>>>>
79505>>>>>>>>>>>//#IF (Required_FMAC_Build > 106)
79505>>>>>>>>>>>//    #Warning -3
79505>>>>>>>>>>>//#ENDIF
79505>>>>>>>>>>>    Procedure Show_Drivers
79507>>>>>>>>>>>        String sDriverID sVersion sClient sValue
79507>>>>>>>>>>>        Integer iNumberOfDrivers iDriver iClient iUsersMax iSerialNo iNumServers iCount
79507>>>>>>>>>>>        Handle hoCLIHandler hoBtrvHandler
79507>>>>>>>>>>>        Boolean bStudioLicense bIsDAWDriver
79507>>>>>>>>>>>
79507>>>>>>>>>>>        Move False to bStudioLicense
79508>>>>>>>>>>>
79508>>>>>>>>>>>        Get Create (RefClass(cCLIHandler))      to hoCLIHandler
79509>>>>>>>>>>>        Get Create (RefClass(cDFBtrDrvHandler)) to hoBtrvHandler
79510>>>>>>>>>>>
79510>>>>>>>>>>>        // For testing purposes:
79510>>>>>>>>>>>//        Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
79510>>>>>>>>>>>//        Load_Driver MSSQLDRV_ID
79510>>>>>>>>>>>//        Load_Driver ODBC_DRV_ID
79510>>>>>>>>>>>//        Load_Driver DB2_DRV_ID
79510>>>>>>>>>>>//        Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
79510>>>>>>>>>>>//
79510>>>>>>>>>>>        Move False to Err
79511>>>>>>>>>>>
79511>>>>>>>>>>>        // Loop through all loaded drivers.
79511>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
79514>>>>>>>>>>>        If (iNumberOfDrivers > 1) Begin
79516>>>>>>>>>>>            Send AppendTextLn ""
79517>>>>>>>>>>>        End
79517>>>>>>>>>>>>
79517>>>>>>>>>>>        For iDriver from 1 to iNumberOfDrivers
79523>>>>>>>>>>>>
79523>>>>>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
79524>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iDriver to sDriverID
79527>>>>>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
79528>>>>>>>>>>>            Get IsDAWSQLDriver  sDriverID to bIsDAWDriver
79529>>>>>>>>>>>
79529>>>>>>>>>>>            If (sDriverID = DFBTRDRV_ID or bIsDAWDriver = True) Begin
79531>>>>>>>>>>>
79531>>>>>>>>>>>                // Pervasive/Btrieve database
79531>>>>>>>>>>>                If (sDriverID = DFBTRDRV_ID) Begin
79533>>>>>>>>>>>                    Get CKRevision of hoBtrvHandler to sVersion
79534>>>>>>>>>>>                    Get PSQLLocalEngineVersionInfo of hoBtrvHandler 0 to sClient
79535>>>>>>>>>>>                    If (sClient <> "0.0.0") Begin
79537>>>>>>>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Local_Engine_Version, sClient))
79538>>>>>>>>>>>                    End
79538>>>>>>>>>>>>
79538>>>>>>>>>>>                    Get PSQLServerEngineVersionInfo of hoBtrvHandler 0 to sClient
79539>>>>>>>>>>>                    If (sClient <> "0.0.0") Begin
79541>>>>>>>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Server_Engine_Version, sClient))
79542>>>>>>>>>>>                    End
79542>>>>>>>>>>>>
79542>>>>>>>>>>>                End
79542>>>>>>>>>>>>
79542>>>>>>>>>>>
79542>>>>>>>>>>>                Else Begin
79543>>>>>>>>>>>                    Set psDriverID of hoCLIHandler to sDriverID
79544>>>>>>>>>>>                    Move 0 to iNumServers
79545>>>>>>>>>>>                    If (sDriverID <> DATAFLEX_ID) Begin
79547>>>>>>>>>>>                        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iNumServers
79550>>>>>>>>>>>                    End
79550>>>>>>>>>>>>
79550>>>>>>>>>>>
79550>>>>>>>>>>>                    If (bIsDAWDriver = True) Begin
79552>>>>>>>>>>>                        If (sDriverID = MSSQLDRV_ID) Begin
79554>>>>>>>>>>>                            Get SQLClientVersion sDriverID iClient to sClient
79555>>>>>>>>>>>                        End
79555>>>>>>>>>>>>
79555>>>>>>>>>>>                        Get CKRevision of hoCLIHandler to sVersion
79556>>>>>>>>>>>                    End
79556>>>>>>>>>>>>
79556>>>>>>>>>>>
79556>>>>>>>>>>>                    // If the serialnumber is = 0, it means that the
79556>>>>>>>>>>>                    // Studio licens is in use and there is no
79556>>>>>>>>>>>                    // number of max users defined because the driver is
79556>>>>>>>>>>>                    // relying on the info from the VDF license.
79556>>>>>>>>>>>                    If (bStudioLicense = False) Begin
79558>>>>>>>>>>>                        Get SerialNumber of hoCLIHandler to iSerialNo
79559>>>>>>>>>>>                        Move (iSerialNo = 0) to bStudioLicense
79560>>>>>>>>>>>                    End
79560>>>>>>>>>>>>
79560>>>>>>>>>>>                End
79560>>>>>>>>>>>>
79560>>>>>>>>>>>                Send AppendTextLn (SFormat (C_$DatabaseDriver, (sDriverID * "-" * (C_$Version + ": " + sVersion))))
79561>>>>>>>>>>>                If (sClient <> "" and sDriverID = MSSQLDRV_ID) Begin
79563>>>>>>>>>>>                    Send AppendTextLn (C_$SQL_Client_Text * sClient)
79564>>>>>>>>>>>                End
79564>>>>>>>>>>>>
79564>>>>>>>>>>>                If (iNumServers <> 0) Begin
79566>>>>>>>>>>>                    For iCount from 1 to iNumServers
79572>>>>>>>>>>>>
79572>>>>>>>>>>>                        Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
79575>>>>>>>>>>>                        If (not(sValue contains ";PWD=")) Begin
79577>>>>>>>>>>>                            Send AppendTextLn ("    " + C_$SQLServerText * sValue)
79578>>>>>>>>>>>                        End
79578>>>>>>>>>>>>
79578>>>>>>>>>>>                    Loop
79579>>>>>>>>>>>>
79579>>>>>>>>>>>                End
79579>>>>>>>>>>>>
79579>>>>>>>>>>>            End
79579>>>>>>>>>>>>
79579>>>>>>>>>>>        Loop
79580>>>>>>>>>>>>
79580>>>>>>>>>>>
79580>>>>>>>>>>>        Send AppendTextLn ""
79581>>>>>>>>>>>        If (bStudioLicense = False) Begin
79583>>>>>>>>>>>            Get MaxUsers of hoCLIHandler to iUsersMax
79584>>>>>>>>>>>            Send AppendTextLn (SFormat (C_$Max_DbDriver_Licensed_User_Count, iUsersMax))
79585>>>>>>>>>>>        End
79585>>>>>>>>>>>>
79585>>>>>>>>>>>        Else Begin
79586>>>>>>>>>>>            Send AppendTextLn C_$DF_Studio_License_Text
79587>>>>>>>>>>>        End
79587>>>>>>>>>>>>
79587>>>>>>>>>>>        Send Destroy of hoCLIHandler
79588>>>>>>>>>>>        Send Destroy of hoBtrvHandler
79589>>>>>>>>>>>    End_Procedure
79590>>>>>>>>>>>
79590>>>>>>>>>>>    Procedure Show_HelpFile
79592>>>>>>>>>>>        String sHelpFile
79592>>>>>>>>>>>        Integer eHelpType
79592>>>>>>>>>>>
79592>>>>>>>>>>>        If (ghoApplication <> 0) Begin
79594>>>>>>>>>>>            Get peHelpType Of ghoApplication To eHelpType
79595>>>>>>>>>>>            If (eHelpType = htHtmlHelp and ghoHtmlHelp) Begin
79597>>>>>>>>>>>                Get GetHelpFile Of ghoHtmlHelp To sHelpFile
79598>>>>>>>>>>>            End
79598>>>>>>>>>>>>
79598>>>>>>>>>>>            Else If (eHelpType = htWinHelp and Help_object_id) Begin
79601>>>>>>>>>>>                Get Help_filename Of Help_object_id To sHelpFile
79602>>>>>>>>>>>            End
79602>>>>>>>>>>>>
79602>>>>>>>>>>>            Else Begin
79603>>>>>>>>>>>                Move C_$ThereIsNoHelpfileDefined To sHelpFile
79604>>>>>>>>>>>            End
79604>>>>>>>>>>>>
79604>>>>>>>>>>>
79604>>>>>>>>>>>            Send AppendTextLn (SFormat (C_$HelpFile, sHelpFile))
79605>>>>>>>>>>>        End
79605>>>>>>>>>>>>
79605>>>>>>>>>>>    End_Procedure
79606>>>>>>>>>>>
79606>>>>>>>>>>>    Procedure Show_EnterAsTab
79608>>>>>>>>>>>        Boolean bEnterKeyAsTabKey
79608>>>>>>>>>>>        String sText
79608>>>>>>>>>>>
79608>>>>>>>>>>>        If (ghoApplication <> 0) Begin
79610>>>>>>>>>>>            Get pbEnterKeyAsTabKey Of ghoApplication To bEnterKeyAsTabKey
79611>>>>>>>>>>>            If (bEnterKeyAsTabKey) Begin
79613>>>>>>>>>>>                Move "True" To sText
79614>>>>>>>>>>>            End
79614>>>>>>>>>>>>
79614>>>>>>>>>>>            Else Begin
79615>>>>>>>>>>>                Move "False" To sText
79616>>>>>>>>>>>            End
79616>>>>>>>>>>>>
79616>>>>>>>>>>>            Send AppendTextLn (SFormat (C_$EnterKeyNavForward, sText))
79617>>>>>>>>>>>        End
79617>>>>>>>>>>>>
79617>>>>>>>>>>>    End_Procedure
79618>>>>>>>>>>>
79618>>>>>>>>>>>    //    During activation we will remove the old information and add the newly
79618>>>>>>>>>>>    //    found systeminformation
79618>>>>>>>>>>>    Procedure Add_Focus Integer hoRoot
79620>>>>>>>>>>>        Forward Send Add_Focus hoRoot
79622>>>>>>>>>>>
79622>>>>>>>>>>>        Send Delete_Data
79623>>>>>>>>>>>
79623>>>>>>>>>>>        Set Changed_State To False
79624>>>>>>>>>>>        Set Read_Only_State To True
79625>>>>>>>>>>>
79625>>>>>>>>>>>        Send Show_Registration
79626>>>>>>>>>>>        Send Show_Drivers
79627>>>>>>>>>>>        Send Show_ServicePack
79628>>>>>>>>>>>        Send Show_Versions
79629>>>>>>>>>>>        Send AppendTextLn ""
79630>>>>>>>>>>>
79630>>>>>>>>>>>        If (ghoApplication <> 0) Begin
79632>>>>>>>>>>>            Send Show_WorkSpaceInformation
79633>>>>>>>>>>>            Send Show_HelpFile
79634>>>>>>>>>>>            Send AppendTextLn ""
79635>>>>>>>>>>>        End
79635>>>>>>>>>>>>
79635>>>>>>>>>>>        Else Begin
79636>>>>>>>>>>>            Send AppendTextLn ""
79637>>>>>>>>>>>        End
79637>>>>>>>>>>>>
79637>>>>>>>>>>>
79637>>>>>>>>>>>        If (ghoConnection <> 0) Begin
79639>>>>>>>>>>>            Send Show_ConnectionIdInformation
79640>>>>>>>>>>>        End
79640>>>>>>>>>>>>
79640>>>>>>>>>>>
79640>>>>>>>>>>>        Send Show_Current_User
79641>>>>>>>>>>>        Send Show_Windows_Directory
79642>>>>>>>>>>>        Send Show_Current_Directory
79643>>>>>>>>>>>
79643>>>>>>>>>>>        // This is already shown in the workspace details,
79643>>>>>>>>>>>        // unless no workspace object is present:
79643>>>>>>>>>>>        If (ghoApplication = 0) Begin
79645>>>>>>>>>>>            Send Show_Filelist_Name
79646>>>>>>>>>>>        End
79646>>>>>>>>>>>>
79646>>>>>>>>>>>
79646>>>>>>>>>>>        If (ghoApplication <> 0) Begin
79648>>>>>>>>>>>            Send AppendTextLn ""
79649>>>>>>>>>>>            Send Show_EnterAsTab
79650>>>>>>>>>>>        End
79650>>>>>>>>>>>>
79650>>>>>>>>>>>
79650>>>>>>>>>>>        Send Show_Screen_Size
79651>>>>>>>>>>>        Send Show_Page_Size
79652>>>>>>>>>>>        Send Show_Number_Format
79653>>>>>>>>>>>        Send Show_Date_Format
79654>>>>>>>>>>>        Send Show_Lock_Delay
79655>>>>>>>>>>>        Send Show_Lock_Timeout
79656>>>>>>>>>>>        Send Show_Date
79657>>>>>>>>>>>        Send Show_Systemresources
79658>>>>>>>>>>>        Send Beginning_of_Data
79659>>>>>>>>>>>
79659>>>>>>>>>>>        Set Icon to 'default.ico'
79660>>>>>>>>>>>    End_Procedure
79661>>>>>>>>>>>End_Class
79662>>>>>>>>>>>
79662>>>>>>>>>>>Class SysInfoDialog is a ModalPanel
79663>>>>>>>>>>>    Procedure Construct_Object
79665>>>>>>>>>>>        Forward Send Construct_Object
79667>>>>>>>>>>>
79667>>>>>>>>>>>        Set Label to C_$SystemInformation
79668>>>>>>>>>>>        Set Size to 140 267
79669>>>>>>>>>>>        Set Locate_Mode to CENTER_ON_PARENT
79670>>>>>>>>>>>        Set Border_Style to Border_Thick
79671>>>>>>>>>>>        Set Sysmenu_Icon to False
79672>>>>>>>>>>>
79672>>>>>>>>>>>        // "+1" will make the panel to paint correctly.
79672>>>>>>>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)) +1)
79673>>>>>>>>>>>
79673>>>>>>>>>>>        // 2014-09-14 NGS
79673>>>>>>>>>>>        // Added a container object around the cTexteditor
79673>>>>>>>>>>>        // object to get a border around the text.
79673>>>>>>>>>>>        Object oSysinfoDisplayContainer is a Container3d
79675>>>>>>>>>>>            Set Location to 2 4
79676>>>>>>>>>>>            Set Size to 110 255
79677>>>>>>>>>>>            Set Border_Style to Border_ClientEdge
79678>>>>>>>>>>>            Set Color to clWhite
79679>>>>>>>>>>>            Set peAnchors to anAll
79680>>>>>>>>>>>
79680>>>>>>>>>>>            Object oSysinfoDisplay is a SysInfoDisplay
79682>>>>>>>>>>>            End_Object
79683>>>>>>>>>>>
79683>>>>>>>>>>>        End_Object
79684>>>>>>>>>>>
79684>>>>>>>>>>>        Object oCloseButton is a Button
79686>>>>>>>>>>>            Set Label to C_$Close
79687>>>>>>>>>>>            Set Location to 120 210
79688>>>>>>>>>>>            CompilerWarnings Off
79688>>>>>>>>>>>            Set Message Item 0 to msg_Close_Panel
79689>>>>>>>>>>>            CompilerWarnings On
79689>>>>>>>>>>>            Set Default_State To True
79690>>>>>>>>>>>            // In case someone likes to make the AboutDialog's Border_Style to thick,
79690>>>>>>>>>>>            // and changes its peAnchors, we might as well prepare this object
79690>>>>>>>>>>>            // for that situation.
79690>>>>>>>>>>>            Set peAnchors to anBottomRight
79691>>>>>>>>>>>        End_Object
79692>>>>>>>>>>>
79692>>>>>>>>>>>        Object oCopyButton is a cCopyEditorContentButton
79694>>>>>>>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
79695>>>>>>>>>>>            Set Size to 14 50
79696>>>>>>>>>>>            Set Location to 120 158
79697>>>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79697>>>>>>>>>>>            // we might as well prepare the object for it.
79697>>>>>>>>>>>            Set peAnchors to anBottomRight
79698>>>>>>>>>>>            Set phoEditorHandle to (oSysinfoDisplay(Self))
79699>>>>>>>>>>>        End_Object
79700>>>>>>>>>>>
79700>>>>>>>>>>>        On_Key kCancel Send Close_Panel
79701>>>>>>>>>>>    End_Procedure
79702>>>>>>>>>>>
79702>>>>>>>>>>>    Procedure Page Integer iPageObject
79704>>>>>>>>>>>        Handle hMenu
79704>>>>>>>>>>>        Integer iPrevState
79704>>>>>>>>>>>
79704>>>>>>>>>>>        Forward Send Page iPageObject
79706>>>>>>>>>>>
79706>>>>>>>>>>>        // Ok, this seems to have been fixed in VDF 17.1!
79706>>>>>>>>>>>        //
79706>>>>>>>>>>>    End_Procedure
79707>>>>>>>>>>>
79707>>>>>>>>>>>End_Class
79708>>>>>>>>>>>
79708>>>>>>>>>>>Class cAboutEdit is an cRichEdit
79709>>>>>>>>>>>    Procedure Construct_Object
79711>>>>>>>>>>>        Forward Send Construct_Object
79713>>>>>>>>>>>
79713>>>>>>>>>>>        Property String psContentText
79714>>>>>>>>>>>
79714>>>>>>>>>>>        Set Size to 77 153
79715>>>>>>>>>>>        Set Location to 8 60
79716>>>>>>>>>>>        Set Read_Only_State to True
79717>>>>>>>>>>>        Set Skip_State to True
79718>>>>>>>>>>>        // Font size is calculated in "Twips", which are 1/1440 of an inch,
79718>>>>>>>>>>>        // or 1/20 of a printer's point.
79718>>>>>>>>>>>        Set piRightMargin to (0.1 * 1440)
79719>>>>>>>>>>>        Set Border_Style  to Border_None
79720>>>>>>>>>>>    End_Procedure
79721>>>>>>>>>>>
79721>>>>>>>>>>>    // Adds a line of text to the edit object
79721>>>>>>>>>>>    Procedure Add_Line String sText
79723>>>>>>>>>>>        String sContentText
79723>>>>>>>>>>>        Get psContentText to sContentText
79724>>>>>>>>>>>        Move (sContentText + String(sText)) to sContentText
79725>>>>>>>>>>>        Set psContentText to sContentText
79726>>>>>>>>>>>    End_Procedure
79727>>>>>>>>>>>
79727>>>>>>>>>>>    // Compared to Add_Line above, this adds an extra empty line after the passed value.
79727>>>>>>>>>>>    // Note that we use a property psContentText and add to it,
79727>>>>>>>>>>>    // because the object isn't paged yet when we add these
79727>>>>>>>>>>>    // values and the COM edit object needs to be paged
79727>>>>>>>>>>>    // for the text to become visible. See Also: Procedure Page below.
79727>>>>>>>>>>>    Procedure Add_LineLn String sText
79729>>>>>>>>>>>        String sContentText sCR
79729>>>>>>>>>>>
79729>>>>>>>>>>>        Move (Character(10) + String(Character(13))) to sCR
79730>>>>>>>>>>>        Get psContentText to sContentText
79731>>>>>>>>>>>        Move (sContentText + String(sText) + sCR) to sContentText
79732>>>>>>>>>>>        Set psContentText to sContentText
79733>>>>>>>>>>>    End_Procedure
79734>>>>>>>>>>>
79734>>>>>>>>>>>    Procedure OnLinkClicked Integer iPositionStart Integer iPositionEnd
79736>>>>>>>>>>>        String sLinkText
79736>>>>>>>>>>>        Get TextRange iPositionStart iPositionEnd to sLinkText
79737>>>>>>>>>>>        Send Show_HomePage sLinkText
79738>>>>>>>>>>>    End_Procedure
79739>>>>>>>>>>>
79739>>>>>>>>>>>    Procedure Page Integer iPageObject
79741>>>>>>>>>>>        String sContentText
79741>>>>>>>>>>>
79741>>>>>>>>>>>        Forward Send Page iPageObject
79743>>>>>>>>>>>        Get psContentText to sContentText
79744>>>>>>>>>>>        Send AppendText sContentText
79745>>>>>>>>>>>        send Beginning_of_Data
79746>>>>>>>>>>>    End_Procedure
79747>>>>>>>>>>>
79747>>>>>>>>>>>End_Class
79748>>>>>>>>>>>
79748>>>>>>>>>>>Class AboutDialog is a ModalPanel
79749>>>>>>>>>>>    Procedure Construct_Object
79751>>>>>>>>>>>
79751>>>>>>>>>>>        Forward Send Construct_Object
79753>>>>>>>>>>>
79753>>>>>>>>>>>        Set Label to C_$About
79754>>>>>>>>>>>        Set Size to 118 230
79755>>>>>>>>>>>        Set Locate_Mode to CENTER_ON_PARENT
79756>>>>>>>>>>>        Set Border_Style to Border_Thick
79757>>>>>>>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
79758>>>>>>>>>>>
79758>>>>>>>>>>>        Object oSysInfoDialog is a SysInfoDialog
79760>>>>>>>>>>>        End_Object
79761>>>>>>>>>>>
79761>>>>>>>>>>>        Object oBox is a Container3d
79763>>>>>>>>>>>            Set Border_Style to Border_Normal
79764>>>>>>>>>>>            Set Size to 90 220
79765>>>>>>>>>>>            Set Location to 4 5
79766>>>>>>>>>>>            Set Color to clWhite
79767>>>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79767>>>>>>>>>>>            // we might as well prepare the object for it.
79767>>>>>>>>>>>            Set peAnchors to anAll
79768>>>>>>>>>>>
79768>>>>>>>>>>>            Object oAboutGraphic is a BitmapContainer
79770>>>>>>>>>>>                Set Border_Style To Border_None
79771>>>>>>>>>>>                Set Bitmap_Style to Bitmap_Center
79772>>>>>>>>>>>                Set Color to clWhite
79773>>>>>>>>>>>                Set Size to 45 50
79774>>>>>>>>>>>                Set Location to 0 3
79775>>>>>>>>>>>            End_Object
79776>>>>>>>>>>>
79776>>>>>>>>>>>            Object oPoweredByDFGraphic is a cBitmapContainerDFLink
79778>>>>>>>>>>>                Set Border_Style to Border_None
79779>>>>>>>>>>>                Set Bitmap_Style to Bitmap_Center
79780>>>>>>>>>>>                Set Color to clWhite
79781>>>>>>>>>>>                Set Size to 30 55
79782>>>>>>>>>>>                Set Location to 50 3
79783>>>>>>>>>>>            End_Object
79784>>>>>>>>>>>
79784>>>>>>>>>>>            Object oInfoList_Editor is an cAboutEdit
79786>>>>>>>>>>>                // In case someone wants to set the AboutDialog's Border_Style to thick,
79786>>>>>>>>>>>                // we might as well prepare the object for it.
79786>>>>>>>>>>>                Set peAnchors to anAll
79787>>>>>>>>>>>            End_Object
79788>>>>>>>>>>>
79788>>>>>>>>>>>            // These objects are here for backwards compatability only.
79788>>>>>>>>>>>            // They are not used.
79788>>>>>>>>>>>            Object oProductName is a TextBox
79790>>>>>>>>>>>                Set Label To C_$ProductName
79791>>>>>>>>>>>                Set Size To 10 45
79792>>>>>>>>>>>                Set Location To 8 53
79793>>>>>>>>>>>                Set Visible_State to False
79794>>>>>>>>>>>                Set Focus_Mode to NonFocusable
79795>>>>>>>>>>>            End_Object
79796>>>>>>>>>>>
79796>>>>>>>>>>>            Object oVersion is a TextBox
79798>>>>>>>>>>>                Set Label To C_$Version
79799>>>>>>>>>>>                Set Size To 10 25
79800>>>>>>>>>>>                Set Location To 21 53
79801>>>>>>>>>>>                Set Visible_State to False
79802>>>>>>>>>>>                Set Focus_Mode to NonFocusable
79803>>>>>>>>>>>            End_Object
79804>>>>>>>>>>>
79804>>>>>>>>>>>            Object oCopyright is a TextBox
79806>>>>>>>>>>>                Set Label To C_$Copyright
79807>>>>>>>>>>>                Set Size To 10 31
79808>>>>>>>>>>>                Set Location To 34 53
79809>>>>>>>>>>>                Set Visible_State to False
79810>>>>>>>>>>>                Set Focus_Mode to NonFocusable
79811>>>>>>>>>>>            End_Object
79812>>>>>>>>>>>
79812>>>>>>>>>>>            Object oAuthor is a TextBox
79814>>>>>>>>>>>                Set Label To C_$Author
79815>>>>>>>>>>>                Set Size To 10 22
79816>>>>>>>>>>>                Set Location To 46 53
79817>>>>>>>>>>>                Set Visible_State to False
79818>>>>>>>>>>>                Set Focus_Mode to NonFocusable
79819>>>>>>>>>>>            End_Object
79820>>>>>>>>>>>
79820>>>>>>>>>>>        End_Object
79821>>>>>>>>>>>
79821>>>>>>>>>>>        Object oOKButton is a Button
79823>>>>>>>>>>>            On_Item C_$Close Send Close_Panel
79824>>>>>>>>>>>            Set Location to 98 176
79825>>>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79825>>>>>>>>>>>            // we might as well prepare the object for it.
79825>>>>>>>>>>>            Set peAnchors to anBottomRight
79826>>>>>>>>>>>        End_Object
79827>>>>>>>>>>>
79827>>>>>>>>>>>        Object oSysInfoButton is a Button
79829>>>>>>>>>>>            On_Item C_$SystemInfo Send Show_Sysinfo
79830>>>>>>>>>>>            Set Location to 98 123
79831>>>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79831>>>>>>>>>>>            // we might as well prepare the object for it.
79831>>>>>>>>>>>            Set peAnchors to anBottomRight
79832>>>>>>>>>>>        End_Object
79833>>>>>>>>>>>
79833>>>>>>>>>>>        Object oCopyButton is a cCopyEditorContentButton
79835>>>>>>>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
79836>>>>>>>>>>>            Set Size to 14 50
79837>>>>>>>>>>>            Set Location to 98 70
79838>>>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
79838>>>>>>>>>>>            // we might as well prepare the object for it.
79838>>>>>>>>>>>            Set peAnchors to anBottomRight
79839>>>>>>>>>>>            Set phoEditorHandle to (oInfoList_Editor(Self))
79840>>>>>>>>>>>        End_Object
79841>>>>>>>>>>>
79841>>>>>>>>>>>        On_Key Kcancel Send KeyAction of oOKButton
79842>>>>>>>>>>>        Set Logo   to "DacAbout.bmp"  // Square bitmaps of 80x80 work best
79843>>>>>>>>>>>        Set LogoDF to "DF32.bmp"
79844>>>>>>>>>>>//        Set LogoVDF to "PoweredByOrange.bmp"
79844>>>>>>>>>>>    End_Procedure
79845>>>>>>>>>>>
79845>>>>>>>>>>>    Procedure Page Integer iPageObject
79847>>>>>>>>>>>        Handle hMenu
79847>>>>>>>>>>>        Integer iPrevState
79847>>>>>>>>>>>
79847>>>>>>>>>>>        Forward Send Page iPageObject
79849>>>>>>>>>>>        // Due to a bug in the ModalPanel class, we need to set the icon here:
79849>>>>>>>>>>>        Set Icon to "Default.ico"
79850>>>>>>>>>>>
79850>>>>>>>>>>>        // Shadow upper left corner menu items: (icon menu items)
79850>>>>>>>>>>>        Move (GetSystemMenu(Window_Handle(Self), False)) to hMenu
79851>>>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_RESTORE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79852>>>>>>>>>>>        // The "Move" menu command may come in handy to have.
79852>>>>>>>>>>>        // Move (EnableMenuItem(hMenu, SC_MOVE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79852>>>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_SIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79853>>>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_MINIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79854>>>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_MAXIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79855>>>>>>>>>>>        // The "Close" menu command may be good to have.
79855>>>>>>>>>>>        // Move (EnableMenuItem(hMenu, SC_CLOSE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
79855>>>>>>>>>>>    End_Procedure
79856>>>>>>>>>>>
79856>>>>>>>>>>>    Procedure Set ProductName String sText
79858>>>>>>>>>>>        Set Value of oProductName to sText
79859>>>>>>>>>>>    End_Procedure
79860>>>>>>>>>>>
79860>>>>>>>>>>>    Procedure Set Copyright String sText
79862>>>>>>>>>>>        Set Value of oCopyright to sText
79863>>>>>>>>>>>    End_Procedure
79864>>>>>>>>>>>
79864>>>>>>>>>>>    Procedure Set Author String sText
79866>>>>>>>>>>>        Set Value of oAuthor to sText
79867>>>>>>>>>>>    End_Procedure
79868>>>>>>>>>>>
79868>>>>>>>>>>>    Procedure Set Version String sVersion
79870>>>>>>>>>>>        Handle hoVersionInfo
79870>>>>>>>>>>>        Boolean bIncluded
79870>>>>>>>>>>>        Integer iMajor iMinor iRelease iBuild
79870>>>>>>>>>>>//        Date dCompileDate
79870>>>>>>>>>>>        String sCertInfo sCompileDateAndTime
79870>>>>>>>>>>>
79870>>>>>>>>>>>        If (sVersion = "") Begin
79872>>>>>>>>>>>            // This automatically shows the program version of the program, if available.
79872>>>>>>>>>>>            // It will be displayed as the second item in the edit object.
79872>>>>>>>>>>>            If (ghoApplication <> 0) Begin
79874>>>>>>>>>>>                Get phoVersionInfo of ghoApplication to hoVersionInfo
79875>>>>>>>>>>>                If (hoVersionInfo <> 0) Begin
79877>>>>>>>>>>>                    Get pbIncluded of hoVersionInfo to bIncluded
79878>>>>>>>>>>>                    If (bIncluded) Begin
79880>>>>>>>>>>>                        Get piVersionMajor of hoVersionInfo to iMajor
79881>>>>>>>>>>>                        Get piVersionMinor of hoVersionInfo to iMinor
79882>>>>>>>>>>>                        Get piVersionRelease of hoVersionInfo to iRelease
79883>>>>>>>>>>>                        Get piVersionBuild of hoVersionInfo to iBuild
79884>>>>>>>>>>>                        Move (SFormat (C_$VERSION + ": %1.%2.%3.%4", iMajor, iMinor, iRelease, iBuild)) to sVersion
79885>>>>>>>>>>>                    End
79885>>>>>>>>>>>>
79885>>>>>>>>>>>                End
79885>>>>>>>>>>>>
79885>>>>>>>>>>>            End
79885>>>>>>>>>>>>
79885>>>>>>>>>>>        End
79885>>>>>>>>>>>>
79885>>>>>>>>>>>
79885>>>>>>>>>>>        // Display the compiled date as the next row in the edit object, after the program version.
79885>>>>>>>>>>>        Get psCompileDateAndTime of ghoApplication to sCompileDateAndTime
79886>>>>>>>>>>>        If (sCompileDateAndTime <> "") Begin
79888>>>>>>>>>>>            Send Add_Lineln (sVersion + (Character(13)) + C_$Compile_Date * String(sCompileDateAndTime))
79889>>>>>>>>>>>        End
79889>>>>>>>>>>>>
79889>>>>>>>>>>>//        Get GetCompileDate to dCompileDate
79889>>>>>>>>>>>//        If (sVersion <> "") Begin
79889>>>>>>>>>>>//            Send Add_Lineln (sVersion + (Character(13)) + C_$Compile_Date * String(dCompileDate))
79889>>>>>>>>>>>//        End
79889>>>>>>>>>>>
79889>>>>>>>>>>>        Get IsProgramDigitallySigned to sCertInfo
79890>>>>>>>>>>>        If (sCertInfo <> "-1") Begin
79892>>>>>>>>>>>            If (sCertInfo <> "") Begin
79894>>>>>>>>>>>                Send Add_LineLn sCertInfo
79895>>>>>>>>>>>            End
79895>>>>>>>>>>>>
79895>>>>>>>>>>>            Else Begin
79896>>>>>>>>>>>                Send Add_LineLn "The program has NOT been digitally signed, or there is a problem with the digical certificate."
79897>>>>>>>>>>>            End
79897>>>>>>>>>>>>
79897>>>>>>>>>>>        End
79897>>>>>>>>>>>>
79897>>>>>>>>>>>    End_Procedure
79898>>>>>>>>>>>
79898>>>>>>>>>>>    Function IsDate String sDate Returns Boolean
79900>>>>>>>>>>>        Boolean bIsDate
79900>>>>>>>>>>>        String sGoodCharacters sChar
79900>>>>>>>>>>>        Integer iCount iLength
79900>>>>>>>>>>>
79900>>>>>>>>>>>        Move True to bIsDate
79901>>>>>>>>>>>        Move "0123456789-/" to sGoodCharacters
79902>>>>>>>>>>>        Move (Length(sDate)) to iLength
79903>>>>>>>>>>>        For iCount from 1 to iLength
79909>>>>>>>>>>>>
79909>>>>>>>>>>>            Move (Left(sDate, 1)) to sChar
79910>>>>>>>>>>>            Move (Mid(sDate, 12, 2)) to sDate
79911>>>>>>>>>>>            Move (sGoodCharacters contains sChar) to bIsDate
79912>>>>>>>>>>>            If (bIsDate = False) Begin
79914>>>>>>>>>>>                Move iLength to iCount
79915>>>>>>>>>>>            End
79915>>>>>>>>>>>>
79915>>>>>>>>>>>        Loop
79916>>>>>>>>>>>>
79916>>>>>>>>>>>        Function_Return bIsDate
79917>>>>>>>>>>>    End_Function
79918>>>>>>>>>>>
79918>>>>>>>>>>>    Function GetCompileDate Returns Date
79920>>>>>>>>>>>        Date dCompileDate
79920>>>>>>>>>>>        String sAppFilename sProgram sData sCompileDate
79920>>>>>>>>>>>        Integer iChannel iPos iDateFormat iCount iSize
79920>>>>>>>>>>>        Boolean bIsValid   
79920>>>>>>>>>>>        
79920>>>>>>>>>>>        Move 0 to dCompileDate
79921>>>>>>>>>>>        // Get full path to the current running executable
79921>>>>>>>>>>>        Get GetApplicationFileName of ghoApplication to sAppFilename
79922>>>>>>>>>>>        Get GetApplicationName     of ghoApplication to sProgram
79923>>>>>>>>>>>
79923>>>>>>>>>>>        //Read the current file  up to where the data we're interesting in is (this was hand calced and so could vary)
79923>>>>>>>>>>>        Get Seq_Open_Input_Channel ("binary:" * sAppFilename) to iChannel
79924>>>>>>>>>>>
79924>>>>>>>>>>>        Read_Block channel iChannel sData 9000000   // This must be big enough to reach the compile date location
79926>>>>>>>>>>>        Move (Pos(sProgram, sData)) to iPos
79927>>>>>>>>>>>        If (iPos > 0) Begin
79929>>>>>>>>>>>            // The compile date is 10 characters long and starts 3 characters after the program name
79929>>>>>>>>>>>            Move (Mid(sData, 10, iPos + Length(sProgram) + 3)) to sCompileDate  // In US format
79930>>>>>>>>>>>
79930>>>>>>>>>>>            // If the current date format is non US, we need to temporary
79930>>>>>>>>>>>            // change the format and then move the string to the date variable.
79930>>>>>>>>>>>            Get_Attribute DF_DATE_FORMAT to iDateFormat
79933>>>>>>>>>>>            Set_Attribute DF_DATE_FORMAT to DF_DATE_USA  
79936>>>>>>>>>>>            Send Ignore_Error of Error_Object_Id 16 
79937>>>>>>>>>>>            If (Left(sCompileDate, 1) = "0") Begin
79939>>>>>>>>>>>                Move ("1" + String(sCompileDate)) to sCompileDate
79940>>>>>>>>>>>            End
79940>>>>>>>>>>>>
79940>>>>>>>>>>>            Move (Date(sCompileDate))    to dCompileDate
79941>>>>>>>>>>>            Send Trap_Error of Error_Object_Id 16
79942>>>>>>>>>>>            Set_Attribute DF_DATE_FORMAT to iDateFormat // Reset date format
79945>>>>>>>>>>>        End
79945>>>>>>>>>>>>
79945>>>>>>>>>>>        Else Begin
79946>>>>>>>>>>>            Error DFERR_PROGRAM "Compile Date location in .exe not found"
79947>>>>>>>>>>>>
79947>>>>>>>>>>>        End
79947>>>>>>>>>>>>
79947>>>>>>>>>>>
79947>>>>>>>>>>>        Send Seq_Close_Channel iChannel
79948>>>>>>>>>>>
79948>>>>>>>>>>>        Function_Return dCompileDate
79949>>>>>>>>>>>    End_Function
79950>>>>>>>>>>>
79950>>>>>>>>>>>    // A variant of the ShellExecute Win API, but it waits until the process that is started
79950>>>>>>>>>>>    // (the passed program), has been finished
79950>>>>>>>>>>>    // The DOS box does also _not_ flash briefly.
79950>>>>>>>>>>>    Procedure RunProgramWait String sProgram String sParameter
79952>>>>>>>>>>>        Handle hProcess
79952>>>>>>>>>>>        Integer iVoid
79952>>>>>>>>>>>        AboutSHELLEXECUTEINFO sInfo
79952>>>>>>>>>>>        AboutSHELLEXECUTEINFO sInfo
79952>>>>>>>>>>>
79952>>>>>>>>>>>        Move (SizeOfType(AboutSHELLEXECUTEINFO)) to sInfo.cbSize
79953>>>>>>>>>>>
79953>>>>>>>>>>>        Move SEE_MASK_NOCLOSEPROCESS to sInfo.fMask
79954>>>>>>>>>>>        Move SW_SHOW                 to sInfo.nShow
79955>>>>>>>>>>>
79955>>>>>>>>>>>        Move (AddressOf(sProgram))   to sInfo.lpFile
79956>>>>>>>>>>>        Move (AddressOf(sParameter)) to sInfo.lpParameters
79957>>>>>>>>>>>        // This will "hide" the DOS box from showing (no flasing box):
79957>>>>>>>>>>>        Move 0                       to sInfo.nShow
79958>>>>>>>>>>>
79958>>>>>>>>>>>        Move (AboutShellExecuteEx(AddressOf(sInfo))) to iVoid
79959>>>>>>>>>>>        Move sInfo.hProcess to hProcess
79960>>>>>>>>>>>        If (hProcess) Begin
79962>>>>>>>>>>>            Move (AboutWaitForSingleObject(hProcess, -1)) to iVoid
79963>>>>>>>>>>>            Move (AboutCloseHandle(hProcess)) to iVoid
79964>>>>>>>>>>>        End
79964>>>>>>>>>>>>
79964>>>>>>>>>>>    End_Procedure
79965>>>>>>>>>>>
79965>>>>>>>>>>>    Function AddFolderDelimiter String sPath Returns String
79967>>>>>>>>>>>        String sDirSep
79967>>>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
79968>>>>>>>>>>>        Move (Trim(sPath)) to sPath
79969>>>>>>>>>>>        If (Right(sPath, 1) <> sDirSep) Begin
79971>>>>>>>>>>>            Move (sPath + sDirSep) to sPath
79972>>>>>>>>>>>        End
79972>>>>>>>>>>>>
79972>>>>>>>>>>>        Function_Return sPath
79973>>>>>>>>>>>    End_Function
79974>>>>>>>>>>>
79974>>>>>>>>>>>    // Returns an empty string if the current program is not digitally signed,
79974>>>>>>>>>>>    // or there is a problem with the certificate.
79974>>>>>>>>>>>    // Note: A copy of the Microsoft signtool.exe program must reside in the Programs folder,
79974>>>>>>>>>>>    //       else nothing is shown in the About object. (Size 355 KB)
79974>>>>>>>>>>>    Function IsProgramDigitallySigned Returns String
79976>>>>>>>>>>>        Boolean bExists
79976>>>>>>>>>>>        String sPath sProgram sParams sRetval
79976>>>>>>>>>>>        Integer iCh
79976>>>>>>>>>>>
79976>>>>>>>>>>>        Move "" to sRetval
79977>>>>>>>>>>>        Get psProgramPath of (phoWorkspace(ghoApplication)) to sPath
79978>>>>>>>>>>>        Get AddFolderDelimiter sPath to sPath
79979>>>>>>>>>>>        File_Exist (sPath + CS_SignProgram) bExists
79980>>>>>>>>>>>        If (bExists = False) Begin
79982>>>>>>>>>>>            Function_Return "-1"
79983>>>>>>>>>>>        End
79983>>>>>>>>>>>>
79983>>>>>>>>>>>
79983>>>>>>>>>>>        Get GetApplicationFileName of ghoApplication to sProgram
79984>>>>>>>>>>>        Move (CS_VerifyCredentials * CS_DefAuthVerPolicy) to sParams
79985>>>>>>>>>>>        Move (sParams * '"' + sProgram + '"') to sParams
79986>>>>>>>>>>>        Move (sParams * String("| clip"))    to sParams
79987>>>>>>>>>>>        Get Seq_New_Channel to iCh
79988>>>>>>>>>>>        Direct_Output channel iCh (sPath + CS_TempCertBatchFile)
79990>>>>>>>>>>>            Writeln channel iCh ('"' + sPath + CS_SignProgram + '"' * sParams)
79993>>>>>>>>>>>        Close_Output channel iCh
79995>>>>>>>>>>>        // New ShellExecute based message that waits for the passed process to end.
79995>>>>>>>>>>>        Send RunProgramWait (sPath + CS_TempCertBatchFile) ""
79996>>>>>>>>>>>        Direct_Input channel iCh "CLIPBOARD:"
79998>>>>>>>>>>>            Readln channel iCh sRetval
80000>>>>>>>>>>>            Readln channel iCh sRetval
80002>>>>>>>>>>>            Readln channel iCh sRetval
80004>>>>>>>>>>>            Readln channel iCh sRetval
80006>>>>>>>>>>>        Close_Input channel iCh
80008>>>>>>>>>>>        Send Seq_Release_Channel iCh
80009>>>>>>>>>>>        If (Lowercase(sRetval) contains "authenticode") Begin
80011>>>>>>>>>>>            Move "This program has been digitally signed and the certificate is valid." to sRetval
80012>>>>>>>>>>>        End
80012>>>>>>>>>>>>
80012>>>>>>>>>>>        Else Begin
80013>>>>>>>>>>>            Move "" to sRetval
80014>>>>>>>>>>>        End
80014>>>>>>>>>>>>
80014>>>>>>>>>>>//        Get DeleteFile (sPath + CS_TempCertBatchFile) to iRetval
80014>>>>>>>>>>>        EraseFile (sPath + CS_TempCertBatchFile)
80015>>>>>>>>>>>>
80015>>>>>>>>>>>        Function_Return sRetval
80016>>>>>>>>>>>    End_Function
80017>>>>>>>>>>>
80017>>>>>>>>>>>    Procedure Add_LineLn String sValue
80019>>>>>>>>>>>        Send Add_LineLn of oInfoList_Editor sValue
80020>>>>>>>>>>>    End_Procedure
80021>>>>>>>>>>>
80021>>>>>>>>>>>    Procedure Add_Line String sValue
80023>>>>>>>>>>>        Send Add_Line of oInfoList_Editor sValue
80024>>>>>>>>>>>    End_Procedure
80025>>>>>>>>>>>
80025>>>>>>>>>>>    Procedure Set Logo string sLogo
80027>>>>>>>>>>>        // Square bitmaps of 80x80 work best
80027>>>>>>>>>>>        Set Bitmap of oAboutGraphic to sLogo
80028>>>>>>>>>>>    End_Procedure
80029>>>>>>>>>>>
80029>>>>>>>>>>>    Procedure Set LogoDF String sLogo
80031>>>>>>>>>>>        Set Bitmap of oPoweredByDFGraphic to sLogo
80032>>>>>>>>>>>    End_Procedure
80033>>>>>>>>>>>
80033>>>>>>>>>>>    Procedure Show_Sysinfo
80035>>>>>>>>>>>        Send Popup_Modal of oSysinfoDialog
80036>>>>>>>>>>>    End_Procedure
80037>>>>>>>>>>>
80037>>>>>>>>>>>    Procedure Show_HomePage String sWebpage
80039>>>>>>>>>>>        Handle hWnd
80039>>>>>>>>>>>        Get Window_Handle to hWnd
80040>>>>>>>>>>>        Runprogram Shell Background (Trim(sWebpage))
80041>>>>>>>>>>>    End_Procedure
80042>>>>>>>>>>>
80042>>>>>>>>>>>End_Class
80043>>>>>>>>>
80043>>>>>>>>>    Function piOrgErrorHandlerID Returns Integer
80045>>>>>>>>>    End_Function
80046>>>>>>>>>
80046>>>>>>>>>Class cBaseDbUpdateFuncLib is a cObject
80047>>>>>>>>>    Import_Class_Protocol cDbUpdateFunctionLibrary_Mixin
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
80048>>>>>>>>>>
80048>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
80050>>>>>>>>>>    Integer iStart iEnd
80050>>>>>>>>>>    String sRetval
80050>>>>>>>>>>
80050>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
80051>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
80052>>>>>>>>>>    If (iStart = 0) Begin
80054>>>>>>>>>>        Function_Return ""
80055>>>>>>>>>>    End
80055>>>>>>>>>>>
80055>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
80056>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
80057>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
80059>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
80060>>>>>>>>>>    End
80060>>>>>>>>>>>
80060>>>>>>>>>>    Else Begin
80061>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
80062>>>>>>>>>>    End
80062>>>>>>>>>>>
80062>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
80064>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
80065>>>>>>>>>>        Decrement iEnd
80066>>>>>>>>>>    End
80066>>>>>>>>>>>
80066>>>>>>>>>>    If (iEnd <> 0) Begin
80068>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
80069>>>>>>>>>>    End
80069>>>>>>>>>>>
80069>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
80070>>>>>>>>>>
80070>>>>>>>>>>    Function_Return (Trim(sRetval))
80071>>>>>>>>>>End_Function
80072>>>>>>>>>>
80072>>>>>>>>>>
80072>>>>>>>>>    
80072>>>>>>>>>    Procedure Construct_Object
80074>>>>>>>>>        Handle ho
80074>>>>>>>>>        Forward Send Construct_Object
80076>>>>>>>>>        Move Self to ghoDbUpdateFunctionLibrary
80077>>>>>>>>>        
80077>>>>>>>>>        Send CreateDbUpdateLibraryProperties
80078>>>>>>>>>        Property String private.psCollation "Latin1_General_CS_AS"
80079>>>>>>>>>
80079>>>>>>>>>        // If no ghoSQLConnectionHandler object has been created prior to this object,
80079>>>>>>>>>        // we will create one as it is used for all ConnectionID, ConnectionString
80079>>>>>>>>>        // etc settings.
80079>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80081>>>>>>>>>            Get Create (RefClass(cSQLConnectionHandler)) to ho
80082>>>>>>>>>            Set Name of ho to "oSQLConnectionHandler"
80083>>>>>>>>>            Set phoSQLConnectionHandler to ho
80084>>>>>>>>>        End
80084>>>>>>>>>>
80084>>>>>>>>>
80084>>>>>>>>>    End_Procedure
80085>>>>>>>>>
80085>>>>>>>>>    Procedure End_Construct_Object
80087>>>>>>>>>        Forward Send End_Construct_Object
80089>>>>>>>>>
80089>>>>>>>>>    End_Procedure
80090>>>>>>>>>
80090>>>>>>>>>    // Latin1_General_CI_AS = General Insensitive collation
80090>>>>>>>>>    // Latin1_General_CS_AS = General Case Sensitive collation, AS= Accent Sensitive.
80090>>>>>>>>>    // For MS-SQL See: https://docs.microsoft.com/en-us/sql/t-sql/statements/windows-collation-name-transact-sql?view=sql-server-2017
80090>>>>>>>>>    // Good read about which collation to select:
80090>>>>>>>>>    // https://social.msdn.microsoft.com/Forums/sqlserver/en-US/bfdc32d3-3d36-4d63-8d87-6ee972fd8130/on-sqllatin1generalcp1cias-sql-server-2008-default-collation?forum=transactsql
80090>>>>>>>>>    Procedure Set psCollation String sCollation
80092>>>>>>>>>        Set private.psCollation to sCollation
80093>>>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
80095>>>>>>>>>            Set psCollation of ghoDbUpdateHandler to sCollation
80096>>>>>>>>>        End
80096>>>>>>>>>>
80096>>>>>>>>>    End_Procedure
80097>>>>>>>>>
80097>>>>>>>>>    Function psCollation Returns String
80099>>>>>>>>>        String sCollation
80099>>>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
80101>>>>>>>>>            Get psCollation of ghoDbUpdateHandler to sCollation
80102>>>>>>>>>        End   
80102>>>>>>>>>>
80102>>>>>>>>>        Else Begin
80103>>>>>>>>>            Get private.psCollation to sCollation
80104>>>>>>>>>        End
80104>>>>>>>>>>
80104>>>>>>>>>        Function_Return sCollation
80105>>>>>>>>>    End_Function
80106>>>>>>>>>
80106>>>>>>>>>    // Array sorting helper functions:
80106>>>>>>>>>    Function __UtilRelationArrayCompare tAPIRelation RelationCurrent tAPIRelation RelationNew Returns Integer
80108>>>>>>>>>        If (RelationCurrent.hTableFrom  = RelationNew.hTableFrom and ;            RelationCurrent.iColumnFrom = RelationNew.iColumnFrom and ;            RelationCurrent.hTableTo    = RelationNew.hTableTo and ;            RelationCurrent.iColumnTo   = RelationNew.iColumnTo) Begin
80110>>>>>>>>>            Function_Return (EQ)
80111>>>>>>>>>        End
80111>>>>>>>>>>
80111>>>>>>>>>
80111>>>>>>>>>        Function_Return (GT)
80112>>>>>>>>>    End_Function
80113>>>>>>>>>
80113>>>>>>>>>    Function __SearchRelationCompare tAPIRelationCompare RelationCompareCurrent tAPIRelationCompare RelationCompareNew Returns Integer
80115>>>>>>>>>        If (RelationCompareCurrent.hTableFrom  = RelationCompareNew.hTableFrom and ;            RelationCompareCurrent.iColumnFrom = RelationCompareNew.iColumnFrom and ;            RelationCompareCurrent.hTableTo    = RelationCompareNew.hTableTo and ;            RelationCompareCurrent.iColumnTo   = RelationCompareNew.iColumnTo) ;            Function_Return (EQ)
80118>>>>>>>>>
80118>>>>>>>>>        Function_Return (GT)
80119>>>>>>>>>    End_Function
80120>>>>>>>>>
80120>>>>>>>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
80120>>>>>>>>>    // Note that it first removes any driver prefixes in the rootname.
80120>>>>>>>>>    Function _ApiTableFilelistNamesCompare Boolean bCompareFilelistUppercase tAPITableNameInfo APITableInfo Returns Boolean
80122>>>>>>>>>        String sRootNameFrom sRootNameTo sDisplayNameTo sLogicalNameTo
80122>>>>>>>>>        Handle hTable
80122>>>>>>>>>        Boolean bIsSame
80122>>>>>>>>>
80122>>>>>>>>>        Move APITableInfo.iTableNumber      to hTable
80123>>>>>>>>>        Get _TableNameOnly APITableInfo.sRootName     to sRootNameFrom
80124>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo
80127>>>>>>>>>        Get _TableNoPrefix sRootNameTo                to sRootNameTo
80128>>>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo
80131>>>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayNameTo
80134>>>>>>>>>        Get _TableNoPrefix sDisplayNameTo             to sDisplayNameTo
80135>>>>>>>>>
80135>>>>>>>>>        If (bCompareFilelistUppercase = True) Begin
80137>>>>>>>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(APITableInfo.sLogicalName) = Uppercase(sLogicalNameTo) and ;                  Uppercase(APITableInfo.sDisplayName) = Uppercase(sDisplayNameTo)) to bIsSame
80138>>>>>>>>>        End
80138>>>>>>>>>>
80138>>>>>>>>>        Else Begin
80139>>>>>>>>>            Move (sRootNameFrom = sRootNameTo and APITableInfo.sLogicalName = sLogicalNameTo and APITableInfo.sDisplayName = sDisplayNameTo) to bIsSame
80140>>>>>>>>>        End
80140>>>>>>>>>>
80140>>>>>>>>>
80140>>>>>>>>>        Function_Return bIsSame
80141>>>>>>>>>    End_Function
80142>>>>>>>>>
80142>>>>>>>>>    Function AutoSetConnectionID String sConnectionID Returns Boolean
80144>>>>>>>>>        Integer iRetval
80144>>>>>>>>>        Move 1 to iRetval
80145>>>>>>>>>        If (ghoSQLConnectionHandler <> 0) Begin
80147>>>>>>>>>            Set psConnectionID of ghoSQLConnectionHandler to sConnectionID
80148>>>>>>>>>            Get AutoSetConnectionID of ghoSQLConnectionHandler to iRetval
80149>>>>>>>>>        End
80149>>>>>>>>>>
80149>>>>>>>>>        Function_Return (iRetval = 0)
80150>>>>>>>>>    End_Function
80151>>>>>>>>>
80151>>>>>>>>>    Function _AddFolderDelimiter String sPath Returns String
80153>>>>>>>>>        String sDirSep
80153>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
80154>>>>>>>>>        Move (Trim(sPath)) to sPath
80155>>>>>>>>>        If (Right(sPath, 1) <> sDirSep) Begin
80157>>>>>>>>>            Move (sPath + sDirSep) to sPath
80158>>>>>>>>>        End
80158>>>>>>>>>>
80158>>>>>>>>>        Function_Return sPath
80159>>>>>>>>>    End_Function
80160>>>>>>>>>
80160>>>>>>>>>    Procedure _SqlColumnInfo Handle hoStmt
80162>>>>>>>>>        Integer i iCols iItem
80162>>>>>>>>>        tSqlColumnNew[] aQueryColumns
80162>>>>>>>>>        tSqlColumnNew[] aQueryColumns
80163>>>>>>>>>
80163>>>>>>>>>        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
80164>>>>>>>>>        For i from 1 to iCols
80170>>>>>>>>>>
80170>>>>>>>>>            Move (SizeOfArray(aQueryColumns)) to iItem
80171>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASECOLUMNNAME to aQueryColumns[iItem].sBaseColumnName
80172>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASETABLENAME  to aQueryColumns[iItem].sBaseTableName
80173>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_LABEL          to aQueryColumns[iItem].sLabel
80174>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SQLTYPE        to aQueryColumns[iItem].iSqlType
80175>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_DFTYPE         to aQueryColumns[iItem].iDFType
80176>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SIZE           to aQueryColumns[iItem].iSize
80177>>>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_PRECISION      to aQueryColumns[iItem].iPrecision
80178>>>>>>>>>        Loop
80179>>>>>>>>>>
80179>>>>>>>>>        Set piColumns to iCols
80180>>>>>>>>>        Set paQueryColumns to aQueryColumns
80181>>>>>>>>>    End_Procedure
80182>>>>>>>>>
80182>>>>>>>>>    // *** Property Messages ***
80182>>>>>>>>>    //
80182>>>>>>>>>    // These "properties" are settings for the cSQLConnectionHandler class, but have been
80182>>>>>>>>>    // "duplicated" here so connection properties can be relayed to the ghoSQLConnectionHandler object
80182>>>>>>>>>    //
80182>>>>>>>>>    Function pSQLConnection Returns tSQLConnection
80184>>>>>>>>>        tSQLConnection SQLConnection
80184>>>>>>>>>        tSQLConnection SQLConnection
80184>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80186>>>>>>>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
80186>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80187>>>>>>>>>>
80187>>>>>>>>>            Function_Return
80188>>>>>>>>>        End
80188>>>>>>>>>>
80188>>>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
80189>>>>>>>>>        Function_Return SQLConnection
80190>>>>>>>>>    End_Function
80191>>>>>>>>>
80191>>>>>>>>>    // * Dummy function for the Studio's Code Explorer *
80191>>>>>>>>>    Function OTHER_CLASS_PROPERTIES Returns Boolean
80193>>>>>>>>>        Function_Return False
80194>>>>>>>>>    End_Function
80195>>>>>>>>>
80195>>>>>>>>>    Procedure Set psServer String sValue
80197>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80199>>>>>>>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
80199>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80200>>>>>>>>>>
80200>>>>>>>>>            Procedure_Return
80201>>>>>>>>>        End
80201>>>>>>>>>>
80201>>>>>>>>>        Set psServer of ghoSQLConnectionHandler to sValue
80202>>>>>>>>>    End_Procedure
80203>>>>>>>>>
80203>>>>>>>>>    Function psServer Returns String
80205>>>>>>>>>        String sValue
80205>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80207>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80208>>>>>>>>>>
80208>>>>>>>>>            Function_Return
80209>>>>>>>>>        End
80209>>>>>>>>>>
80209>>>>>>>>>        Get psServer of ghoSQLConnectionHandler to sValue
80210>>>>>>>>>        Function_Return sValue
80211>>>>>>>>>    End_Function
80212>>>>>>>>>
80212>>>>>>>>>    Procedure Set psDatabase String sValue
80214>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80216>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80217>>>>>>>>>>
80217>>>>>>>>>            Procedure_Return
80218>>>>>>>>>        End
80218>>>>>>>>>>
80218>>>>>>>>>        Set psDatabase of ghoSQLConnectionHandler to sValue
80219>>>>>>>>>    End_Procedure
80220>>>>>>>>>
80220>>>>>>>>>    Function psDatabase Returns String
80222>>>>>>>>>        String sValue
80222>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80224>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80225>>>>>>>>>>
80225>>>>>>>>>            Function_Return
80226>>>>>>>>>        End
80226>>>>>>>>>>
80226>>>>>>>>>        Get psDatabase of ghoSQLConnectionHandler to sValue
80227>>>>>>>>>        Function_Return sValue
80228>>>>>>>>>    End_Function
80229>>>>>>>>>
80229>>>>>>>>>    Procedure Set psUserID String sValue
80231>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80233>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80234>>>>>>>>>>
80234>>>>>>>>>            Procedure_Return
80235>>>>>>>>>        End
80235>>>>>>>>>>
80235>>>>>>>>>        Set psUserID of ghoSQLConnectionHandler to sValue
80236>>>>>>>>>    End_Procedure
80237>>>>>>>>>
80237>>>>>>>>>    Function psUserID Returns String
80239>>>>>>>>>        String sValue
80239>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80241>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80242>>>>>>>>>>
80242>>>>>>>>>            Function_Return
80243>>>>>>>>>        End
80243>>>>>>>>>>
80243>>>>>>>>>        Get psUserID of ghoSQLConnectionHandler to sValue
80244>>>>>>>>>        Function_Return sValue
80245>>>>>>>>>    End_Function
80246>>>>>>>>>
80246>>>>>>>>>    Procedure Set psPassword String sValue
80248>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80250>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80251>>>>>>>>>>
80251>>>>>>>>>            Procedure_Return
80252>>>>>>>>>        End
80252>>>>>>>>>>
80252>>>>>>>>>        Set psPassword of ghoSQLConnectionHandler to sValue
80253>>>>>>>>>    End_Procedure
80254>>>>>>>>>
80254>>>>>>>>>    Function psPassword Returns String
80256>>>>>>>>>        String sValue
80256>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80258>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80259>>>>>>>>>>
80259>>>>>>>>>            Function_Return
80260>>>>>>>>>        End
80260>>>>>>>>>>
80260>>>>>>>>>        Get psPassword of ghoSQLConnectionHandler to sValue
80261>>>>>>>>>        Function_Return sValue
80262>>>>>>>>>    End_Function
80263>>>>>>>>>
80263>>>>>>>>>    Procedure Set pbTrusted Boolean bValue
80265>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80267>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80268>>>>>>>>>>
80268>>>>>>>>>            Procedure_Return
80269>>>>>>>>>        End
80269>>>>>>>>>>
80269>>>>>>>>>        Set pbTrusted of ghoSQLConnectionHandler to bValue
80270>>>>>>>>>    End_Procedure
80271>>>>>>>>>
80271>>>>>>>>>    Function pbTrusted Returns Boolean
80273>>>>>>>>>        Boolean bValue
80273>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80275>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80276>>>>>>>>>>
80276>>>>>>>>>            Function_Return
80277>>>>>>>>>        End
80277>>>>>>>>>>
80277>>>>>>>>>        Get pbTrusted of ghoSQLConnectionHandler to bValue
80278>>>>>>>>>        Function_Return bValue
80279>>>>>>>>>    End_Function
80280>>>>>>>>>
80280>>>>>>>>>    Procedure Set pbSilentLogin Boolean bValue
80282>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80284>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80285>>>>>>>>>>
80285>>>>>>>>>            Procedure_Return
80286>>>>>>>>>        End
80286>>>>>>>>>>
80286>>>>>>>>>        Set pbSilentLogin of ghoSQLConnectionHandler to bValue
80287>>>>>>>>>    End_Procedure
80288>>>>>>>>>
80288>>>>>>>>>    Function pbSilentLogin Returns Boolean
80290>>>>>>>>>        Boolean bValue
80290>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80292>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80293>>>>>>>>>>
80293>>>>>>>>>            Function_Return
80294>>>>>>>>>        End
80294>>>>>>>>>>
80294>>>>>>>>>        Get pbSilentLogin of ghoSQLConnectionHandler to bValue
80295>>>>>>>>>        Function_Return bValue
80296>>>>>>>>>    End_Function
80297>>>>>>>>>
80297>>>>>>>>>    Procedure Set psConnectionID String sValue
80299>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80301>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80302>>>>>>>>>>
80302>>>>>>>>>            Procedure_Return
80303>>>>>>>>>        End
80303>>>>>>>>>>
80303>>>>>>>>>        Set psConnectionID of ghoSQLConnectionHandler to sValue
80304>>>>>>>>>    End_Procedure
80305>>>>>>>>>
80305>>>>>>>>>    Function psConnectionID Returns String
80307>>>>>>>>>        String sValue
80307>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80309>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80310>>>>>>>>>>
80310>>>>>>>>>            Function_Return
80311>>>>>>>>>        End
80311>>>>>>>>>>
80311>>>>>>>>>        Get psConnectionID of ghoSQLConnectionHandler to sValue
80312>>>>>>>>>        Function_Return sValue
80313>>>>>>>>>    End_Function
80314>>>>>>>>>
80314>>>>>>>>>    Procedure Set psConnectionString String sValue
80316>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80318>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80319>>>>>>>>>>
80319>>>>>>>>>            Procedure_Return
80320>>>>>>>>>        End
80320>>>>>>>>>>
80320>>>>>>>>>        Set psConnectionString of ghoSQLConnectionHandler to sValue
80321>>>>>>>>>    End_Procedure
80322>>>>>>>>>
80322>>>>>>>>>    Function psConnectionString Returns String
80324>>>>>>>>>        String sValue
80324>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80326>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80327>>>>>>>>>>
80327>>>>>>>>>            Function_Return
80328>>>>>>>>>        End
80328>>>>>>>>>>
80328>>>>>>>>>        Get psConnectionString of ghoSQLConnectionHandler to sValue
80329>>>>>>>>>        Function_Return sValue
80330>>>>>>>>>    End_Function
80331>>>>>>>>>
80331>>>>>>>>>    // The normal connection string looks something like this;
80331>>>>>>>>>    // SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
80331>>>>>>>>>    // ...and the full connection string looks like this;
80331>>>>>>>>>    // DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
80331>>>>>>>>>    Function psFullConnectionString Returns String
80333>>>>>>>>>        String sConnectionID sConnectionString
80333>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80335>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80336>>>>>>>>>>
80336>>>>>>>>>            Function_Return
80337>>>>>>>>>        End
80337>>>>>>>>>>
80337>>>>>>>>>        Get psConnectionID     of ghoSQLConnectionHandler to sConnectionID
80338>>>>>>>>>        Move (Trim(sConnectionID)) to sConnectionID
80339>>>>>>>>>        Get psConnectionString of ghoSQLConnectionHandler to sConnectionString
80340>>>>>>>>>        Function_Return (CS_SQLConnectionIDText * sConnectionID + "," * String(sConnectionString))
80341>>>>>>>>>    End_Function
80342>>>>>>>>>
80342>>>>>>>>>    Function piConnectionOptions Returns Integer
80344>>>>>>>>>        Integer iValue
80344>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80346>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80347>>>>>>>>>>
80347>>>>>>>>>            Function_Return
80348>>>>>>>>>        End
80348>>>>>>>>>>
80348>>>>>>>>>        Get piConnectionOptions of ghoSQLConnectionHandler to iValue
80349>>>>>>>>>        Function_Return iValue
80350>>>>>>>>>    End_Function
80351>>>>>>>>>
80351>>>>>>>>>    Procedure Set psSchema String sValue
80353>>>>>>>>>        tSQLConnection SQLConnection
80353>>>>>>>>>        tSQLConnection SQLConnection
80353>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80355>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80356>>>>>>>>>>
80356>>>>>>>>>            Procedure_Return
80357>>>>>>>>>        End
80357>>>>>>>>>>
80357>>>>>>>>>        Set psSchema of ghoSQLConnectionHandler to sValue
80358>>>>>>>>>    End_Procedure
80359>>>>>>>>>
80359>>>>>>>>>    Function psSchema Returns String
80361>>>>>>>>>        String sRetval
80361>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80363>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80364>>>>>>>>>>
80364>>>>>>>>>            Function_Return
80365>>>>>>>>>        End
80365>>>>>>>>>>
80365>>>>>>>>>        Get psSchema of ghoSQLConnectionHandler to sRetval
80366>>>>>>>>>        Function_Return sRetval
80367>>>>>>>>>    End_Function
80368>>>>>>>>>
80368>>>>>>>>>    Procedure Set psBaseTableSpace String sValue
80370>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80372>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80373>>>>>>>>>>
80373>>>>>>>>>            Procedure_Return
80374>>>>>>>>>        End
80374>>>>>>>>>>
80374>>>>>>>>>        Set psBaseTableSpace of ghoSQLConnectionHandler to sValue
80375>>>>>>>>>    End_Procedure
80376>>>>>>>>>
80376>>>>>>>>>    Function psBaseTableSpace Returns String
80378>>>>>>>>>        String sRetval
80378>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80380>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80381>>>>>>>>>>
80381>>>>>>>>>            Function_Return
80382>>>>>>>>>        End
80382>>>>>>>>>>
80382>>>>>>>>>        Get psBaseTableSpace of ghoSQLConnectionHandler to sRetval
80383>>>>>>>>>        Function_Return sRetval
80384>>>>>>>>>    End_Function
80385>>>>>>>>>
80385>>>>>>>>>    Procedure Set psLongTableSpace String sValue
80387>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80389>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80390>>>>>>>>>>
80390>>>>>>>>>            Procedure_Return
80391>>>>>>>>>        End
80391>>>>>>>>>>
80391>>>>>>>>>        Set psLongTableSpace of ghoSQLConnectionHandler to sValue
80392>>>>>>>>>    End_Procedure
80393>>>>>>>>>
80393>>>>>>>>>    Function psLongTableSpace Returns String
80395>>>>>>>>>        String sRetval
80395>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80397>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80398>>>>>>>>>>
80398>>>>>>>>>            Function_Return
80399>>>>>>>>>        End
80399>>>>>>>>>>
80399>>>>>>>>>        Get psLongTableSpace of ghoSQLConnectionHandler to sRetval
80400>>>>>>>>>        Function_Return sRetval
80401>>>>>>>>>    End_Function
80402>>>>>>>>>
80402>>>>>>>>>    Procedure Set psIndexTableSpace String sValue
80404>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80406>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80407>>>>>>>>>>
80407>>>>>>>>>            Procedure_Return
80408>>>>>>>>>        End
80408>>>>>>>>>>
80408>>>>>>>>>        Set psIndexTableSpace of ghoSQLConnectionHandler to sValue
80409>>>>>>>>>    End_Procedure
80410>>>>>>>>>
80410>>>>>>>>>    Function psIndexTableSpace Returns String
80412>>>>>>>>>        String sRetval
80412>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80414>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80415>>>>>>>>>>
80415>>>>>>>>>            Function_Return
80416>>>>>>>>>        End
80416>>>>>>>>>>
80416>>>>>>>>>        Get psIndexTableSpace of ghoSQLConnectionHandler to sRetval
80417>>>>>>>>>        Function_Return sRetval
80418>>>>>>>>>    End_Function
80419>>>>>>>>>
80419>>>>>>>>>    Procedure Set pbUseConnectionID Boolean bState
80421>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80423>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80424>>>>>>>>>>
80424>>>>>>>>>            Procedure_Return
80425>>>>>>>>>        End
80425>>>>>>>>>>
80425>>>>>>>>>        Set pbUseConnectionID of ghoSQLConnectionHandler to bState
80426>>>>>>>>>    End_Procedure
80427>>>>>>>>>
80427>>>>>>>>>    Function pbUseConnectionID Returns Boolean
80429>>>>>>>>>        Boolean bState
80429>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80431>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80432>>>>>>>>>>
80432>>>>>>>>>            Function_Return
80433>>>>>>>>>        End
80433>>>>>>>>>>
80433>>>>>>>>>        Get pbUseConnectionID of ghoSQLConnectionHandler to bState
80434>>>>>>>>>        Function_Return bState
80435>>>>>>>>>    End_Function
80436>>>>>>>>>
80436>>>>>>>>>    Procedure Set pbToANSI Boolean bState
80438>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80440>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80441>>>>>>>>>>
80441>>>>>>>>>            Procedure_Return
80442>>>>>>>>>        End
80442>>>>>>>>>>
80442>>>>>>>>>        Set pbToANSI of ghoSQLConnectionHandler to bState
80443>>>>>>>>>    End_Procedure
80444>>>>>>>>>
80444>>>>>>>>>    Function pbToANSI Returns Boolean
80446>>>>>>>>>        Boolean bState
80446>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80448>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80449>>>>>>>>>>
80449>>>>>>>>>            Function_Return
80450>>>>>>>>>        End
80450>>>>>>>>>>
80450>>>>>>>>>        Get pbToANSI of ghoSQLConnectionHandler to bState
80451>>>>>>>>>        Function_Return bState
80452>>>>>>>>>    End_Function
80453>>>>>>>>>
80453>>>>>>>>>    Procedure Set pbRecnum Boolean bState
80455>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80457>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80458>>>>>>>>>>
80458>>>>>>>>>            Procedure_Return
80459>>>>>>>>>        End
80459>>>>>>>>>>
80459>>>>>>>>>        Set pbRecnum of ghoSQLConnectionHandler to bState
80460>>>>>>>>>    End_Procedure
80461>>>>>>>>>
80461>>>>>>>>>    Function pbRecnum Returns Boolean
80463>>>>>>>>>        Boolean bState
80463>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80465>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80466>>>>>>>>>>
80466>>>>>>>>>            Function_Return
80467>>>>>>>>>        End
80467>>>>>>>>>>
80467>>>>>>>>>        Get pbRecnum of ghoSQLConnectionHandler to bState
80468>>>>>>>>>        Function_Return bState
80469>>>>>>>>>    End_Function
80470>>>>>>>>>
80470>>>>>>>>>    Procedure Set pbCopyData Boolean bState
80472>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80474>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80475>>>>>>>>>>
80475>>>>>>>>>            Procedure_Return
80476>>>>>>>>>        End
80476>>>>>>>>>>
80476>>>>>>>>>        Set pbCopyData of ghoSQLConnectionHandler to bState
80477>>>>>>>>>    End_Procedure
80478>>>>>>>>>
80478>>>>>>>>>    Function pbCopyData Returns Boolean
80480>>>>>>>>>        Boolean bState
80480>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80482>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80483>>>>>>>>>>
80483>>>>>>>>>            Function_Return
80484>>>>>>>>>        End
80484>>>>>>>>>>
80484>>>>>>>>>        Get pbCopyData of ghoSQLConnectionHandler to bState
80485>>>>>>>>>        Function_Return bState
80486>>>>>>>>>    End_Function
80487>>>>>>>>>
80487>>>>>>>>>    Procedure Set pbApiTableUpdateAuto Boolean bState
80489>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80491>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80492>>>>>>>>>>
80492>>>>>>>>>            Procedure_Return
80493>>>>>>>>>        End
80493>>>>>>>>>>
80493>>>>>>>>>        Set pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
80494>>>>>>>>>    End_Procedure
80495>>>>>>>>>
80495>>>>>>>>>    Function pbApiTableUpdateAuto Returns Boolean
80497>>>>>>>>>        Boolean bState
80497>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80499>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80500>>>>>>>>>>
80500>>>>>>>>>            Function_Return
80501>>>>>>>>>        End
80501>>>>>>>>>>
80501>>>>>>>>>        Get pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
80502>>>>>>>>>        Function_Return bState
80503>>>>>>>>>    End_Function
80504>>>>>>>>>
80504>>>>>>>>>    Procedure Set pbCompareDate_DateTime Boolean bState
80506>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80508>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80509>>>>>>>>>>
80509>>>>>>>>>            Procedure_Return
80510>>>>>>>>>        End
80510>>>>>>>>>>
80510>>>>>>>>>        Set pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
80511>>>>>>>>>    End_Procedure
80512>>>>>>>>>
80512>>>>>>>>>    Function pbCompareDate_DateTime Returns Boolean
80514>>>>>>>>>        Boolean bState
80514>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80516>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80517>>>>>>>>>>
80517>>>>>>>>>            Function_Return
80518>>>>>>>>>        End
80518>>>>>>>>>>
80518>>>>>>>>>        Get pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
80519>>>>>>>>>        Function_Return bState
80520>>>>>>>>>    End_Function
80521>>>>>>>>>
80521>>>>>>>>>    Procedure Set pbCompareIndexAscending Boolean bState
80523>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80525>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80526>>>>>>>>>>
80526>>>>>>>>>            Procedure_Return
80527>>>>>>>>>        End
80527>>>>>>>>>>
80527>>>>>>>>>        Set pbCompareIndexAscending of ghoSQLConnectionHandler to bState
80528>>>>>>>>>    End_Procedure
80529>>>>>>>>>
80529>>>>>>>>>    Function pbCompareIndexAscending Returns Boolean
80531>>>>>>>>>        Boolean bState
80531>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80533>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80534>>>>>>>>>>
80534>>>>>>>>>            Function_Return
80535>>>>>>>>>        End
80535>>>>>>>>>>
80535>>>>>>>>>        Get pbCompareIndexAscending of ghoSQLConnectionHandler to bState
80536>>>>>>>>>        Function_Return bState
80537>>>>>>>>>    End_Function
80538>>>>>>>>>
80538>>>>>>>>>    Procedure Set pbCompareIndexUppercase Boolean bState
80540>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80542>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80543>>>>>>>>>>
80543>>>>>>>>>            Procedure_Return
80544>>>>>>>>>        End
80544>>>>>>>>>>
80544>>>>>>>>>        Set pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
80545>>>>>>>>>    End_Procedure
80546>>>>>>>>>
80546>>>>>>>>>    Function pbCompareIndexUppercase Returns Boolean
80548>>>>>>>>>        Boolean bState
80548>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80550>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
80551>>>>>>>>>>
80551>>>>>>>>>            Function_Return
80552>>>>>>>>>        End
80552>>>>>>>>>>
80552>>>>>>>>>        Get pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
80553>>>>>>>>>        Function_Return bState
80554>>>>>>>>>    End_Function
80555>>>>>>>>>
80555>>>>>>>>>    Procedure Set psDriverDefaultValueASCII String sValue
80557>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80559>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80560>>>>>>>>>>
80560>>>>>>>>>            Procedure_Return
80561>>>>>>>>>        End
80561>>>>>>>>>>
80561>>>>>>>>>        Set psDriverDefaultValueASCII of ghoSQLConnectionHandler to sValue
80562>>>>>>>>>    End_Procedure
80563>>>>>>>>>
80563>>>>>>>>>    Function psDriverDefaultValueASCII Returns String
80565>>>>>>>>>        String sRetval
80565>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80567>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80568>>>>>>>>>>
80568>>>>>>>>>            Function_Return
80569>>>>>>>>>        End
80569>>>>>>>>>>
80569>>>>>>>>>        Get psDriverDefaultValueASCII of ghoSQLConnectionHandler to sRetval
80570>>>>>>>>>        Function_Return sRetval
80571>>>>>>>>>    End_Function
80572>>>>>>>>>
80572>>>>>>>>>    Procedure Set psDriverDefaultValueBinary String sValue
80574>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80576>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80577>>>>>>>>>>
80577>>>>>>>>>            Procedure_Return
80578>>>>>>>>>        End
80578>>>>>>>>>>
80578>>>>>>>>>        Set psDriverDefaultValueBinary of ghoSQLConnectionHandler to sValue
80579>>>>>>>>>    End_Procedure
80580>>>>>>>>>
80580>>>>>>>>>    Function psDriverDefaultValueBinary Returns String
80582>>>>>>>>>        String sRetval
80582>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80584>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80585>>>>>>>>>>
80585>>>>>>>>>            Function_Return
80586>>>>>>>>>        End
80586>>>>>>>>>>
80586>>>>>>>>>        Get psDriverDefaultValueBinary of ghoSQLConnectionHandler to sRetval
80587>>>>>>>>>        Function_Return sRetval
80588>>>>>>>>>    End_Function
80589>>>>>>>>>
80589>>>>>>>>>    Procedure Set psDriverDefaultValueDate String sValue
80591>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80593>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80594>>>>>>>>>>
80594>>>>>>>>>            Procedure_Return
80595>>>>>>>>>        End
80595>>>>>>>>>>
80595>>>>>>>>>        Set psDriverDefaultValueDate of ghoSQLConnectionHandler to sValue
80596>>>>>>>>>    End_Procedure
80597>>>>>>>>>
80597>>>>>>>>>    Function psDriverDefaultValueDate Returns String
80599>>>>>>>>>        String sRetval
80599>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80601>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80602>>>>>>>>>>
80602>>>>>>>>>            Function_Return
80603>>>>>>>>>        End
80603>>>>>>>>>>
80603>>>>>>>>>        Get psDriverDefaultValueDate of ghoSQLConnectionHandler to sRetval
80604>>>>>>>>>        Function_Return sRetval
80605>>>>>>>>>    End_Function
80606>>>>>>>>>
80606>>>>>>>>>    Procedure Set psDriverDefaultValueDateTime String sValue
80608>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80610>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80611>>>>>>>>>>
80611>>>>>>>>>            Procedure_Return
80612>>>>>>>>>        End
80612>>>>>>>>>>
80612>>>>>>>>>        Set psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sValue
80613>>>>>>>>>    End_Procedure
80614>>>>>>>>>
80614>>>>>>>>>    Function psDriverDefaultValueDateTime Returns String
80616>>>>>>>>>        String sRetval
80616>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80618>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80619>>>>>>>>>>
80619>>>>>>>>>            Function_Return
80620>>>>>>>>>        End
80620>>>>>>>>>>
80620>>>>>>>>>        Get psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sRetval
80621>>>>>>>>>        Function_Return sRetval
80622>>>>>>>>>    End_Function
80623>>>>>>>>>
80623>>>>>>>>>    Procedure Set psDriverDefaultValueNumeric String sValue
80625>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80627>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80628>>>>>>>>>>
80628>>>>>>>>>            Procedure_Return
80629>>>>>>>>>        End
80629>>>>>>>>>>
80629>>>>>>>>>        Set psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sValue
80630>>>>>>>>>    End_Procedure
80631>>>>>>>>>
80631>>>>>>>>>    Function psDriverDefaultValueNumeric Returns String
80633>>>>>>>>>        String sRetval
80633>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80635>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80636>>>>>>>>>>
80636>>>>>>>>>            Function_Return
80637>>>>>>>>>        End
80637>>>>>>>>>>
80637>>>>>>>>>        Get psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sRetval
80638>>>>>>>>>        Function_Return sRetval
80639>>>>>>>>>    End_Function
80640>>>>>>>>>
80640>>>>>>>>>    Procedure Set psDriverDefaultValueText String sValue
80642>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80644>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80645>>>>>>>>>>
80645>>>>>>>>>            Procedure_Return
80646>>>>>>>>>        End
80646>>>>>>>>>>
80646>>>>>>>>>        Set psDriverDefaultValueText of ghoSQLConnectionHandler to sValue
80647>>>>>>>>>    End_Procedure
80648>>>>>>>>>
80648>>>>>>>>>    Function psDriverDefaultValueText Returns String
80650>>>>>>>>>        String sRetval
80650>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80652>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80653>>>>>>>>>>
80653>>>>>>>>>            Function_Return
80654>>>>>>>>>        End
80654>>>>>>>>>>
80654>>>>>>>>>        Get psDriverDefaultValueText of ghoSQLConnectionHandler to sRetval
80655>>>>>>>>>        Function_Return sRetval
80656>>>>>>>>>    End_Function
80657>>>>>>>>>
80657>>>>>>>>>    Procedure Set pbDriverDefaultNullableASCII Boolean bState
80659>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80661>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80662>>>>>>>>>>
80662>>>>>>>>>            Procedure_Return
80663>>>>>>>>>        End
80663>>>>>>>>>>
80663>>>>>>>>>        Set pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
80664>>>>>>>>>    End_Procedure
80665>>>>>>>>>
80665>>>>>>>>>    Function pbDriverDefaultNullableASCII Returns Boolean
80667>>>>>>>>>        Boolean bState
80667>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80669>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80670>>>>>>>>>>
80670>>>>>>>>>            Function_Return
80671>>>>>>>>>        End
80671>>>>>>>>>>
80671>>>>>>>>>        Get pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
80672>>>>>>>>>        Function_Return bState
80673>>>>>>>>>    End_Function
80674>>>>>>>>>
80674>>>>>>>>>    Procedure Set pbDriverDefaultNullableBinary Boolean bState
80676>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80678>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80679>>>>>>>>>>
80679>>>>>>>>>            Procedure_Return
80680>>>>>>>>>        End
80680>>>>>>>>>>
80680>>>>>>>>>        Set pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
80681>>>>>>>>>    End_Procedure
80682>>>>>>>>>
80682>>>>>>>>>    Function pbDriverDefaultNullableBinary Returns Boolean
80684>>>>>>>>>        Boolean bState
80684>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80686>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80687>>>>>>>>>>
80687>>>>>>>>>            Function_Return
80688>>>>>>>>>        End
80688>>>>>>>>>>
80688>>>>>>>>>        Get pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
80689>>>>>>>>>        Function_Return bState
80690>>>>>>>>>    End_Function
80691>>>>>>>>>
80691>>>>>>>>>    Procedure Set pbDriverDefaultNullableDate Boolean bState
80693>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80695>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80696>>>>>>>>>>
80696>>>>>>>>>            Procedure_Return
80697>>>>>>>>>        End
80697>>>>>>>>>>
80697>>>>>>>>>        Set pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
80698>>>>>>>>>    End_Procedure
80699>>>>>>>>>
80699>>>>>>>>>    Function pbDriverDefaultNullableDate Returns Boolean
80701>>>>>>>>>        Boolean bState
80701>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80703>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80704>>>>>>>>>>
80704>>>>>>>>>            Function_Return
80705>>>>>>>>>        End
80705>>>>>>>>>>
80705>>>>>>>>>        Get pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
80706>>>>>>>>>        Function_Return bState
80707>>>>>>>>>    End_Function
80708>>>>>>>>>
80708>>>>>>>>>    Procedure Set pbDriverDefaultNullableDateTime Boolean bState
80710>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80712>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80713>>>>>>>>>>
80713>>>>>>>>>            Procedure_Return
80714>>>>>>>>>        End
80714>>>>>>>>>>
80714>>>>>>>>>        Set pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
80715>>>>>>>>>    End_Procedure
80716>>>>>>>>>
80716>>>>>>>>>    Function pbDriverDefaultNullableDateTime Returns Boolean
80718>>>>>>>>>        Boolean bState
80718>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80720>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80721>>>>>>>>>>
80721>>>>>>>>>            Function_Return
80722>>>>>>>>>        End
80722>>>>>>>>>>
80722>>>>>>>>>        Get pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
80723>>>>>>>>>        Function_Return bState
80724>>>>>>>>>    End_Function
80725>>>>>>>>>
80725>>>>>>>>>    Procedure Set pbDriverDefaultNullableNumeric Boolean bState
80727>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80729>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80730>>>>>>>>>>
80730>>>>>>>>>            Procedure_Return
80731>>>>>>>>>        End
80731>>>>>>>>>>
80731>>>>>>>>>        Set pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
80732>>>>>>>>>    End_Procedure
80733>>>>>>>>>
80733>>>>>>>>>    Function pbDriverDefaultNullableNumeric Returns Boolean
80735>>>>>>>>>        Boolean bState
80735>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80737>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80738>>>>>>>>>>
80738>>>>>>>>>            Function_Return
80739>>>>>>>>>        End
80739>>>>>>>>>>
80739>>>>>>>>>        Get pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
80740>>>>>>>>>        Function_Return bState
80741>>>>>>>>>    End_Function
80742>>>>>>>>>
80742>>>>>>>>>    Procedure Set pbDriverDefaultNullableText Boolean bState
80744>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80746>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80747>>>>>>>>>>
80747>>>>>>>>>            Procedure_Return
80748>>>>>>>>>        End
80748>>>>>>>>>>
80748>>>>>>>>>        Set pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
80749>>>>>>>>>    End_Procedure
80750>>>>>>>>>
80750>>>>>>>>>    Function pbDriverDefaultNullableText Returns Boolean
80752>>>>>>>>>        Boolean bState
80752>>>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
80754>>>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
80755>>>>>>>>>>
80755>>>>>>>>>            Function_Return
80756>>>>>>>>>        End
80756>>>>>>>>>>
80756>>>>>>>>>        Get pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
80757>>>>>>>>>        Function_Return bState
80758>>>>>>>>>    End_Function
80759>>>>>>>>>
80759>>>>>>>>>    // Note: If the psDriverID + other connection properties are to be changed,
80759>>>>>>>>>    //       the psDriverID *must* be the first property that gets changed!
80759>>>>>>>>>    //       Otherwise errors might be raised by the driver when e.g. the format
80759>>>>>>>>>    //       for a connection string has the wrong format for that driver.
80759>>>>>>>>>    Procedure Set psDriverID String sValue
80761>>>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
80762>>>>>>>>>        Delegate Set psDriverID to sValue
80764>>>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
80765>>>>>>>>>        Set psDriverID of ghoSQLConnectionHandler to sValue
80766>>>>>>>>>    End_Procedure
80767>>>>>>>>>
80767>>>>>>>>>    Function psDriverID Returns String
80769>>>>>>>>>        String sDriverID
80769>>>>>>>>>
80769>>>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
80770>>>>>>>>>        // This should get it from the parent object (when using the cDbUpdateHandler class)
80770>>>>>>>>>        Delegate Get psDriverID to sDriverID
80772>>>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
80773>>>>>>>>>        Move False to Err
80774>>>>>>>>>
80774>>>>>>>>>        // ...and in case it didn't use property of this class. Then the library is
80774>>>>>>>>>        // probably used as "utilites" from a special made program and
80774>>>>>>>>>        // the ghoSQLConnectionHandler must have been setup
80774>>>>>>>>>        If (sDriverID = "") Begin
80776>>>>>>>>>            Get psDriverID of ghoSQLConnectionHandler to sDriverID
80777>>>>>>>>>        End
80777>>>>>>>>>>
80777>>>>>>>>>        Function_Return sDriverID
80778>>>>>>>>>    End_Function
80779>>>>>>>>>
80779>>>>>>>>>    Procedure Set piDbType Integer iValue
80781>>>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
80782>>>>>>>>>        Delegate Set piDbType to iValue
80784>>>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
80785>>>>>>>>>        Set piDbType of ghoSQLConnectionHandler to iValue
80786>>>>>>>>>    End_Procedure
80787>>>>>>>>>
80787>>>>>>>>>    Function piDbType Returns Integer
80789>>>>>>>>>        Integer iRetval
80789>>>>>>>>>        Get piDbType of ghoSQLConnectionHandler to iRetval
80790>>>>>>>>>        Function_Return iRetval
80791>>>>>>>>>    End_Function
80792>>>>>>>>>
80792>>>>>>>>>    // Returns the index for the passed sTableName
80792>>>>>>>>>    // Returns >= 0 if successful. It is e.g. needed to get the SchemaName for a table.
80792>>>>>>>>>    Function _SqlUtilEnumerateTableIndex String sTableName String sDriverID Returns Integer
80794>>>>>>>>>        Integer iIndex iSize iCount
80794>>>>>>>>>        String[] sTablesArray
80795>>>>>>>>>        String sDatabase sSchema sVal sConnectionString
80795>>>>>>>>>
80795>>>>>>>>>        Move -1 to iIndex
80796>>>>>>>>>        Get psConnectionString to sConnectionString
80797>>>>>>>>>        Get psDatabase to sDatabase
80798>>>>>>>>>        Get psSchema   to sSchema
80799>>>>>>>>>        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
80800>>>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
80801>>>>>>>>>        Decrement iSize
80802>>>>>>>>>        For iCount from 0 to iSize
80808>>>>>>>>>>
80808>>>>>>>>>            Move sTablesArray[iCount] to sVal
80809>>>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
80811>>>>>>>>>                Move iCount to iIndex // We found it!
80812>>>>>>>>>                Move iSize to iCount  // End the loop
80813>>>>>>>>>            End
80813>>>>>>>>>>
80813>>>>>>>>>        Loop
80814>>>>>>>>>>
80814>>>>>>>>>
80814>>>>>>>>>        Function_Return iIndex
80815>>>>>>>>>    End_Function
80816>>>>>>>>>
80816>>>>>>>>>    // Returns all schemas as a string array for the passed driver id.
80816>>>>>>>>>    Function SqlUtilEnumerateSchemas String sDriverID Returns String[]
80818>>>>>>>>>        String[] sReturnArray
80819>>>>>>>>>        Boolean bOK
80819>>>>>>>>>
80819>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80820>>>>>>>>>        If (bOK = False) Begin
80822>>>>>>>>>            Function_Return sReturnArray
80823>>>>>>>>>        End
80823>>>>>>>>>>
80823>>>>>>>>>
80823>>>>>>>>>        Case Begin
80823>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
80825>>>>>>>>>                Get _SqlEnumerateEsqlDAW "select schemaname from syscat.schemata" 1 to sReturnArray
80826>>>>>>>>>                Case Break
80827>>>>>>>>>
80827>>>>>>>>>            Case Else
80827>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateSchemas function."
80828>>>>>>>>>>
80828>>>>>>>>>                Case Break
80829>>>>>>>>>        Case End
80829>>>>>>>>>
80829>>>>>>>>>        Function_Return sReturnArray
80830>>>>>>>>>    End_Function
80831>>>>>>>>>
80831>>>>>>>>>    // Returns a string array with all tables for the current database.
80831>>>>>>>>>    Function _SqlUtilEnumerateTables String sDriverID String sDatabase String sSchema Returns String[]
80833>>>>>>>>>        String[] sReturnArray sArray
80835>>>>>>>>>        String sConnectionString sSelect
80835>>>>>>>>>        Integer iSize iCount iDbType
80835>>>>>>>>>        Boolean bOK
80835>>>>>>>>>
80835>>>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
80837>>>>>>>>>            Function_Return sArray
80838>>>>>>>>>        End
80838>>>>>>>>>>
80838>>>>>>>>>
80838>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80839>>>>>>>>>        If (bOK = False) Begin
80841>>>>>>>>>            Function_Return sReturnArray
80842>>>>>>>>>        End
80842>>>>>>>>>>
80842>>>>>>>>>        If (sSchema = "") Begin
80844>>>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
80845>>>>>>>>>        End
80845>>>>>>>>>>
80845>>>>>>>>>
80845>>>>>>>>>        Get psConnectionString to sConnectionString
80846>>>>>>>>>
80846>>>>>>>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
80846>>>>>>>>>        // the dbType.
80846>>>>>>>>>        Get piDbType to iDbType
80847>>>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
80849>>>>>>>>>            If (iDbType = EN_DbTypeMSSQL) Begin
80851>>>>>>>>>                Move MSSQLDRV_ID to sDriverID
80852>>>>>>>>>            End
80852>>>>>>>>>>
80852>>>>>>>>>            If (iDbType = EN_DbTypeDB2) Begin
80854>>>>>>>>>                Move DB2_DRV_ID to sDriverID
80855>>>>>>>>>            End
80855>>>>>>>>>>
80855>>>>>>>>>            If (iDbType = EN_DbTypePostgre) Begin
80857>>>>>>>>>                Move ODBC_DRV_ID to sDriverID
80858>>>>>>>>>            End
80858>>>>>>>>>>
80858>>>>>>>>>        End
80858>>>>>>>>>>
80858>>>>>>>>>
80858>>>>>>>>>        Case Begin
80858>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
80860>>>>>>>>>                Get _SqlTableArrayDAW to sReturnArray
80861>>>>>>>>>                Case Break
80862>>>>>>>>>
80862>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
80865>>>>>>>>>                Get _SqlTableArrayDAW to sReturnArray
80866>>>>>>>>>                Case Break
80867>>>>>>>>>
80867>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
80870>>>>>>>>>                Get _SqlTableArrayDAW to sReturnArray
80871>>>>>>>>>                Case Break
80872>>>>>>>>>
80872>>>>>>>>>            Case Else
80872>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to _SqlUtilEnumerateTables function."
80873>>>>>>>>>>
80873>>>>>>>>>                Case Break
80874>>>>>>>>>        Case End
80874>>>>>>>>>
80874>>>>>>>>>        Function_Return sReturnArray
80875>>>>>>>>>    End_Function
80876>>>>>>>>>
80876>>>>>>>>>    // Returns all table spaces as a string array for the passed driver id.
80876>>>>>>>>>    Function _SqlUtilEnumerateTablespaces String sDriverID Returns String[]
80878>>>>>>>>>        String[] sReturnArray
80879>>>>>>>>>        Boolean bOK
80879>>>>>>>>>
80879>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80880>>>>>>>>>        If (bOK = False) Begin
80882>>>>>>>>>            Function_Return sReturnArray
80883>>>>>>>>>        End
80883>>>>>>>>>>
80883>>>>>>>>>
80883>>>>>>>>>        Case Begin
80883>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
80885>>>>>>>>>                Get _SqlEnumerateEsqlDAW "select tablespace_name from dba_tablespaces" 1 to sReturnArray
80886>>>>>>>>>                Case Break
80887>>>>>>>>>
80887>>>>>>>>>            Case Else
80887>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to _SqlUtilEnumerateTablespaces function."
80888>>>>>>>>>>
80888>>>>>>>>>                Case Break
80889>>>>>>>>>        Case End
80889>>>>>>>>>
80889>>>>>>>>>        Function_Return sReturnArray
80890>>>>>>>>>    End_Function
80891>>>>>>>>>
80891>>>>>>>>>    // Returns a string array with all table columns/fields for the passed table handle and driver id.
80891>>>>>>>>>    Function _SqlUtilEnumerateColumns String sDriverID String sTableName Returns String[]
80893>>>>>>>>>        String[] sReturnArray
80894>>>>>>>>>        String sConnectionString sSelect sSchema
80894>>>>>>>>>        Boolean bOK
80894>>>>>>>>>        Integer iDbType
80894>>>>>>>>>
80894>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80895>>>>>>>>>        If (bOK = False) Begin
80897>>>>>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
80898>>>>>>>>>>
80898>>>>>>>>>            Function_Return sReturnArray
80899>>>>>>>>>        End
80899>>>>>>>>>>
80899>>>>>>>>>
80899>>>>>>>>>        Get psConnectionString to sConnectionString
80900>>>>>>>>>        Get psSchema to sSchema
80901>>>>>>>>>
80901>>>>>>>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
80901>>>>>>>>>        // the dbType.
80901>>>>>>>>>        Get piDbType to iDbType
80902>>>>>>>>>
80902>>>>>>>>>        Case Begin
80902>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
80904>>>>>>>>>                If (iDbType = EN_DbTypeMySQL) Begin
80906>>>>>>>>>                    Move ("SHOW COLUMNS FROM" * sTableName) to sSelect
80907>>>>>>>>>                End
80907>>>>>>>>>>
80907>>>>>>>>>                If (iDbType = EN_DbTypePostgre) Begin
80909>>>>>>>>>                    Move ("select column_name, data_type, character_maximum_length from INFORMATION_SCHEMA.COLUMNS where table_name = '" +sTableName + "'") to sSelect
80910>>>>>>>>>                End
80910>>>>>>>>>>
80910>>>>>>>>>                If (iDbType = EN_DbTypeMSSQL) Begin
80912>>>>>>>>>                    Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
80913>>>>>>>>>                End
80913>>>>>>>>>>
80913>>>>>>>>>
80913>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
80914>>>>>>>>>                Case Break
80915>>>>>>>>>
80915>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
80918>>>>>>>>>                Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
80919>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
80920>>>>>>>>>                Case Break
80921>>>>>>>>>
80921>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
80924>>>>>>>>>                Move ("SELECT colname from syscat.columns WHERE tabschema = '" + sSchema + "'" * "AND tabname = '" + sTableName + "'") to sSelect
80925>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
80926>>>>>>>>>                Case Break
80927>>>>>>>>>
80927>>>>>>>>>            Case Else
80927>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to _SqlUtilEnumerateColumns function."
80928>>>>>>>>>>
80928>>>>>>>>>                Case Break
80929>>>>>>>>>        Case End
80929>>>>>>>>>
80929>>>>>>>>>        Function_Return sReturnArray
80930>>>>>>>>>    End_Function
80931>>>>>>>>>
80931>>>>>>>>>
80931>>>>>>>>>    // Returns a string array with all table indexes for the passed table handle and driver id.
80931>>>>>>>>>    Function _SqlUtilEnumerateIndexes String sTableName String sDriverID Returns String[]
80933>>>>>>>>>        String[] sReturnArray sReturnArray2
80935>>>>>>>>>        String sConnectionString sSelect sSchema
80935>>>>>>>>>        Boolean bOK
80935>>>>>>>>>        Integer iCount iSize
80935>>>>>>>>>
80935>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80936>>>>>>>>>        If (bOK = False) Begin
80938>>>>>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
80939>>>>>>>>>>
80939>>>>>>>>>            Function_Return sReturnArray
80940>>>>>>>>>        End
80940>>>>>>>>>>
80940>>>>>>>>>
80940>>>>>>>>>        Get psConnectionString to sConnectionString
80941>>>>>>>>>        Get psSchema to sSchema
80942>>>>>>>>>
80942>>>>>>>>>        Case Begin
80942>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
80944>>>>>>>>>                Move ("select * from sys.indexes where object_id = (select object_id from sys.objects where name = '" + sTableName + "')") to sSelect
80945>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
80946>>>>>>>>>                Case Break
80947>>>>>>>>>
80947>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
80950>>>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
80951>>>>>>>>>>
80951>>>>>>>>>//                Move () to sSelect
80951>>>>>>>>>//                Get _SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
80951>>>>>>>>>                Case Break
80952>>>>>>>>>
80952>>>>>>>>>            Case Else
80952>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to _SqlUtilEnumerateIndexes function."
80953>>>>>>>>>>
80953>>>>>>>>>                Case Break
80954>>>>>>>>>        Case End
80954>>>>>>>>>
80954>>>>>>>>>        Move (SizeOfArray(sReturnArray)) to iSize
80955>>>>>>>>>        Decrement iSize
80956>>>>>>>>>        For iCount from 0 to iSize
80962>>>>>>>>>>
80962>>>>>>>>>            If (Trim(sReturnArray[iCount]) <> "") Begin
80964>>>>>>>>>                Move sReturnArray[iCount] to sReturnArray2[SizeOfArray(sReturnArray2)]
80965>>>>>>>>>            End
80965>>>>>>>>>>
80965>>>>>>>>>        Loop
80966>>>>>>>>>>
80966>>>>>>>>>
80966>>>>>>>>>        Function_Return sReturnArray2
80967>>>>>>>>>    End_Function
80968>>>>>>>>>
80968>>>>>>>>>    // Returns a string array with all table names the passed table handle has relation ships with.
80968>>>>>>>>>    // The format of the array is "TableName.FieldName"
80968>>>>>>>>>    Function _SqlUtilEnumerateRelations String sTableName String sDriverID Returns tSQLRelation[]
80970>>>>>>>>>        String[] sFileNameArray sFieldNameArray
80972>>>>>>>>>        tSQLRelation[] sRelationsArray
80972>>>>>>>>>        tSQLRelation[] sRelationsArray
80973>>>>>>>>>        String sConnectionString sSelect sSchema sFileName sFieldName
80973>>>>>>>>>        Boolean bOK
80973>>>>>>>>>        Integer iCount iSize iLength
80973>>>>>>>>>
80973>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80974>>>>>>>>>        If (bOK = False) Begin
80976>>>>>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
80977>>>>>>>>>>
80977>>>>>>>>>            Function_Return sRelationsArray
80978>>>>>>>>>        End
80978>>>>>>>>>>
80978>>>>>>>>>
80978>>>>>>>>>        Get psConnectionString to sConnectionString
80979>>>>>>>>>        Get psSchema to sSchema
80980>>>>>>>>>
80980>>>>>>>>>        Case Begin
80980>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
80982>>>>>>>>>                Move ("SELECT object_name(parent_object_id), object_name(referenced_object_id), name from sys.foreign_keys WHERE parent_object_id = object_id( '" + sTableName + "')") to sSelect
80983>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 2 to sFileNameArray
80984>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
80985>>>>>>>>>                Case Break
80986>>>>>>>>>
80986>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
80989>>>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
80990>>>>>>>>>>
80990>>>>>>>>>//                Move () to sSelect
80990>>>>>>>>>//                Get _SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
80990>>>>>>>>>//                Get _SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
80990>>>>>>>>>                Case Break
80991>>>>>>>>>
80991>>>>>>>>>            Case Else
80991>>>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to the _SqlUtilEnumerateRelations function."
80992>>>>>>>>>>
80992>>>>>>>>>                Case Break
80993>>>>>>>>>        Case End
80993>>>>>>>>>
80993>>>>>>>>>        Move (Length(sTableName)) to iLength
80994>>>>>>>>>        Move (iLength + 4)        to iLength // The related to field key has the format "FK_TableName + FieldName"
80995>>>>>>>>>        Move (SizeOfArray(sFileNameArray)) to iSize
80996>>>>>>>>>        Decrement iSize
80997>>>>>>>>>        For iCount from 0 to iSize
81003>>>>>>>>>>
81003>>>>>>>>>            If (Trim(sFileNameArray[iCount]) <> "") Begin
81005>>>>>>>>>                Move sFileNameArray[iCount]         to sFileName
81006>>>>>>>>>                Move sFieldNameArray[iCount]        to sFieldName
81007>>>>>>>>>                Move (Mid(sFieldName, 99, iLength)) to sFieldName
81008>>>>>>>>>                Move sFileName  to sRelationsArray[iCount].sFileName
81009>>>>>>>>>                Move sFieldName to sRelationsArray[iCount].sFieldName
81010>>>>>>>>>            End
81010>>>>>>>>>>
81010>>>>>>>>>        Loop
81011>>>>>>>>>>
81011>>>>>>>>>
81011>>>>>>>>>        Function_Return sRelationsArray
81012>>>>>>>>>    End_Function
81013>>>>>>>>>
81013>>>>>>>>>    Function SqlUtilEnumerateLoggedInUsers String sDriverID String sDatabase Returns tSQLLoggedInUser[]
81015>>>>>>>>>        tSQLLoggedInUser[] SQLLoggedInUser
81015>>>>>>>>>        tSQLLoggedInUser[] SQLLoggedInUser
81016>>>>>>>>>        String[] sUsers sPrograms
81018>>>>>>>>>        String sSelect
81018>>>>>>>>>        Integer iSize iCount
81018>>>>>>>>>
81018>>>>>>>>>        Case Begin
81018>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
81020>>>>>>>>>                Move ("SELECT RTRIM(SP.nt_username) AS Inlog, RTRIM(SP.program_name) as Programma from master.dbo.sysprocesses SP INNER JOIN master.dbo.sysdatabases SD ON SP.dbid = SD.dbid WHERE (SP.nt_username <> '') and (SP.nt_username <> 'SYSTEM') and (SD.name = '" ;                + sDatabase + "') ORDER by Inlog") to sSelect
81021>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 1 to sUsers
81022>>>>>>>>>                Get _SqlEnumerateEsqlDAW sSelect 2 to sPrograms
81023>>>>>>>>>                Case Break
81024>>>>>>>>>            Case Else
81024>>>>>>>>>                Error DFERR_PROGRAM ("Not implemented yet for this driver (" + sDriverID + ")")
81025>>>>>>>>>>
81025>>>>>>>>>        Case End
81025>>>>>>>>>
81025>>>>>>>>>        Move (SizeOfArray(sUsers)) to iSize
81026>>>>>>>>>        Decrement iSize
81027>>>>>>>>>        For iCount from 0 to iSize
81033>>>>>>>>>>
81033>>>>>>>>>            Move sUsers[iCount]    to SQLLoggedInUser[iCount].sUser
81034>>>>>>>>>            Move sPrograms[iCount] to SQLLoggedInUser[iCount].sProgram
81035>>>>>>>>>        Loop
81036>>>>>>>>>>
81036>>>>>>>>>
81036>>>>>>>>>        Function_Return SQLLoggedInUser
81037>>>>>>>>>    End_Function
81038>>>>>>>>>
81038>>>>>>>>>    // Returns an array with all ".int" files for the passed sDataPath, _except_ for the driver .int files;
81038>>>>>>>>>    // "MSSQLDRV.int", "DB2_DRV.int" & "ODBC_DRV.int".
81038>>>>>>>>>    Function SqlUtilEnumerateIntFiles String sDataPath Returns String[]
81040>>>>>>>>>        String[] sFilesData
81041>>>>>>>>>        Boolean bExists
81041>>>>>>>>>        Integer iCh
81041>>>>>>>>>        String sFileName sExt
81041>>>>>>>>>
81041>>>>>>>>>        Get vFolderExists sDataPath to bExists
81042>>>>>>>>>        If (bExists = True) Begin
81044>>>>>>>>>            Move (Utf8ToAnsi(Trim(sDataPath))) to sDataPath
81045>>>>>>>>>            Move ("dir:" + sDataPath)      to sDataPath
81046>>>>>>>>>            Get Seq_New_Channel to iCh  // get free channel for input
81047>>>>>>>>>            Direct_Input channel iCh sDataPath
81049>>>>>>>>>                Repeat
81049>>>>>>>>>>
81049>>>>>>>>>                    Readln channel iCh sFileName
81051>>>>>>>>>                    Get ParseFileExtension sFileName to sExt
81052>>>>>>>>>                    If (Uppercase(sExt) = "INT") Begin
81054>>>>>>>>>                        If (not(Uppercase(sFileName) contains "MSSQLDRV" and Uppercase(sFileName) contains "DB2_DRV" and Uppercase(sFileName) contains "ODBC_DRV")) Begin
81056>>>>>>>>>                            Move sFileName to sFilesData[SizeOfArray(sFilesData)]
81057>>>>>>>>>                        End
81057>>>>>>>>>>
81057>>>>>>>>>                    End
81057>>>>>>>>>>
81057>>>>>>>>>                Until (SeqEof = True)
81059>>>>>>>>>            Close_Input channel iCh
81061>>>>>>>>>            Send Seq_Release_Channel iCh
81062>>>>>>>>>        End
81062>>>>>>>>>>
81062>>>>>>>>>        Function_Return sFilesData
81063>>>>>>>>>    End_Function
81064>>>>>>>>>
81064>>>>>>>>>    // Only done for MSSQLDRV_ID so far...
81064>>>>>>>>>    Function _SqlEnumerateDatabaseCollations String sDriverID Returns String[]
81066>>>>>>>>>        String sSQL sConnectionID sConnectionString sSelect sName sPre
81066>>>>>>>>>        String sDescription sFrom sSys sValue sPrevious
81066>>>>>>>>>        Handle hStmt hoSQLManager hoSQLConnect
81066>>>>>>>>>        Integer iFetchResult iRows iColumn iPos
81066>>>>>>>>>        tSQLConnection SQLConnection
81066>>>>>>>>>        tSQLConnection SQLConnection
81066>>>>>>>>>        String[] asCollations
81067>>>>>>>>>        
81067>>>>>>>>>        If (sDriverID = "") Begin
81069>>>>>>>>>            Error DFERR_PROGRAM "The database driver ID was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
81070>>>>>>>>>>
81070>>>>>>>>>            Function_Return asCollations
81071>>>>>>>>>        End
81071>>>>>>>>>>
81071>>>>>>>>>
81071>>>>>>>>>        // Only done for MSSQLDRV_ID so far...
81071>>>>>>>>>        If (sDriverID <> MSSQLDRV_ID) Begin
81073>>>>>>>>>            Function_Return asCollations
81074>>>>>>>>>        End                 
81074>>>>>>>>>>
81074>>>>>>>>>
81074>>>>>>>>>        Get phoSQLManager to hoSQLManager
81075>>>>>>>>>        Get psConnectionID     to sConnectionID
81076>>>>>>>>>        Get psConnectionString to sConnectionString
81077>>>>>>>>>        Move 0 to LastErr
81078>>>>>>>>>
81078>>>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81079>>>>>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hoSQLConnect
81080>>>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81081>>>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
81083>>>>>>>>>            Error DFERR_PROGRAM ("Login failed to the database server. The following connect string was used:\n" + sConnectionString)
81084>>>>>>>>>>
81084>>>>>>>>>            Function_Return asCollations
81085>>>>>>>>>        End
81085>>>>>>>>>>
81085>>>>>>>>>
81085>>>>>>>>>        Get SqlOpen of hoSQLConnect to hStmt
81086>>>>>>>>>
81086>>>>>>>>>        If (hStmt = 0) Begin
81088>>>>>>>>>            Send SqlDisconnect of hoSQLManager
81089>>>>>>>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
81090>>>>>>>>>>
81090>>>>>>>>>            Function_Return asCollations
81091>>>>>>>>>        End
81091>>>>>>>>>>
81091>>>>>>>>>
81091>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSelect      to sSelect
81092>>>>>>>>>        Get _SqlFindKeyWord CI_SQLName        to sName
81093>>>>>>>>>        Get _SqlFindKeyWord CI_SQLDescription to sDescription
81094>>>>>>>>>        Get _SqlFindKeyWord CI_SQLFrom        to sFrom
81095>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSys         to sSys
81096>>>>>>>>>
81096>>>>>>>>>        // MS-SQL Syntax:  
81096>>>>>>>>>        // SELECT name, description
81096>>>>>>>>>        //   from sys.fn_helpcollations();
81096>>>>>>>>>        Move (sSelect  * String(sName) * String(",") * String(sDescription) * String(sFrom) * String(sSys) * String(".fn_helpcollations();")) to sSQL
81097>>>>>>>>>
81097>>>>>>>>>        Move 1 to iColumn
81098>>>>>>>>>        Send SqlExecDirect of hStmt sSQL
81099>>>>>>>>>        Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_ROWCOUNT to iRows
81100>>>>>>>>>        Repeat
81100>>>>>>>>>>
81100>>>>>>>>>            Get SQLFetch of hStmt to iFetchResult
81101>>>>>>>>>            If (iFetchResult <> 0) Begin
81103>>>>>>>>>                Get SQLColumnValue of hStmt iColumn to sValue 
81104>>>>>>>>>                If (sValue <> sPrevious) Begin         
81106>>>>>>>>>                    // We need to skip all collations starting with "SQL" because they
81106>>>>>>>>>                    // are obsolete and for pre-SQL Server 2000.
81106>>>>>>>>>                    Move (Pos("SQL", Uppercase(sValue))) to iPos
81107>>>>>>>>>                    If (iPos <> 1) Begin
81109>>>>>>>>>                        Move (Trim(sValue)) to asCollations[SizeOfArray(asCollations)
81110>>>>>>>>>                    End
81110>>>>>>>>>>
81110>>>>>>>>>                End
81110>>>>>>>>>>
81110>>>>>>>>>                Move sValue to sPrevious
81111>>>>>>>>>            End
81111>>>>>>>>>>
81111>>>>>>>>>        Until (iFetchResult = 0)
81113>>>>>>>>>        Send SQLClose of hStmt
81114>>>>>>>>>        Send SQLDisconnect of hoSQLConnect
81115>>>>>>>>>
81115>>>>>>>>>        Function_Return asCollations
81116>>>>>>>>>    End_Function
81117>>>>>>>>>
81117>>>>>>>>>    // To enumerate SQL database resources with ESQL and return the result as a string array,
81117>>>>>>>>>    // for DAW drivers.
81117>>>>>>>>>    // Returns: A string array.
81117>>>>>>>>>    Function _SqlEnumerateEsqlDAW String sStmt Integer iColumn Returns String[]
81119>>>>>>>>>        String[] sReturnArray
81120>>>>>>>>>        String sValue sPrevious
81120>>>>>>>>>        Handle hoSQLHandler hoSQLConnect hstmt
81120>>>>>>>>>        Integer iFetchResult iRows
81120>>>>>>>>>        tSQLConnection SQLConnection
81120>>>>>>>>>        tSQLConnection SQLConnection
81120>>>>>>>>>
81120>>>>>>>>>        Get phoSQLManager to hoSQLHandler
81121>>>>>>>>>
81121>>>>>>>>>        If (hoSQLHandler <> 0) Begin
81123>>>>>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
81124>>>>>>>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
81125>>>>>>>>>
81125>>>>>>>>>            If (hoSQLConnect <> 0) Begin
81127>>>>>>>>>                Get SQLOpen of hoSQLConnect to hstmt
81128>>>>>>>>>                If (hstmt <> 0) Begin
81130>>>>>>>>>                    Send SqlExecDirect of hstmt sStmt
81131>>>>>>>>>                    Get SqlStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
81132>>>>>>>>>                    Repeat
81132>>>>>>>>>>
81132>>>>>>>>>                        Get SQLFetch of hstmt to iFetchResult
81133>>>>>>>>>                        If (iFetchResult <> 0) Begin
81135>>>>>>>>>                            Get SQLColumnValue of hstmt iColumn to sValue
81136>>>>>>>>>                            If (sValue <> sPrevious) Begin
81138>>>>>>>>>                                Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
81139>>>>>>>>>                            End
81139>>>>>>>>>>
81139>>>>>>>>>                            Move sValue to sPrevious
81140>>>>>>>>>                        End
81140>>>>>>>>>>
81140>>>>>>>>>                    Until (iFetchResult = 0)
81142>>>>>>>>>                    Send SQLClose of hstmt
81143>>>>>>>>>                End
81143>>>>>>>>>>
81143>>>>>>>>>                Send SQLDisconnect of hoSQLConnect
81144>>>>>>>>>            End
81144>>>>>>>>>>
81144>>>>>>>>>        End
81144>>>>>>>>>>
81144>>>>>>>>>
81144>>>>>>>>>        Function_Return sReturnArray
81145>>>>>>>>>    End_Function
81146>>>>>>>>>
81146>>>>>>>>>    Function _SqlDatabasesArrayDB2 Returns String[]
81148>>>>>>>>>        String[] sReturnArray
81149>>>>>>>>>        String sDataSource
81149>>>>>>>>>        Handle hoSQLHandler
81149>>>>>>>>>        Integer iItem
81149>>>>>>>>>
81149>>>>>>>>>        Get phoDB2SQLHandler to hoSQLHandler
81150>>>>>>>>>        Send SeedDataSources of hoSQLHandler
81151>>>>>>>>>
81151>>>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81152>>>>>>>>>
81152>>>>>>>>>        Repeat
81152>>>>>>>>>>
81152>>>>>>>>>            Get DataSources of hoSQLHandler to sDataSource
81153>>>>>>>>>            Move (Replaces(",", sDataSource, "")) to sDataSource
81154>>>>>>>>>            Move (Trim(sDataSource)) to sReturnArray[iItem]
81155>>>>>>>>>            Increment iItem
81156>>>>>>>>>        Until (sDataSource = "")
81158>>>>>>>>>
81158>>>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81159>>>>>>>>>
81159>>>>>>>>>        Function_Return sReturnArray
81160>>>>>>>>>    End_Function
81161>>>>>>>>>
81161>>>>>>>>>    Function _SqlDatabaseSourcesArrayODBC Returns String[]
81163>>>>>>>>>        String[] sReturnArray
81164>>>>>>>>>        String sDataSource
81164>>>>>>>>>        Handle hoSQLHandler
81164>>>>>>>>>        Integer iItem
81164>>>>>>>>>
81164>>>>>>>>>        Get phoODBCSQLHandler to hoSQLHandler
81165>>>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81166>>>>>>>>>
81166>>>>>>>>>        Send SeedDataSources of hoSQLHandler
81167>>>>>>>>>
81167>>>>>>>>>        Repeat
81167>>>>>>>>>>
81167>>>>>>>>>            Get DataSources of hoSQLHandler to sDataSource
81168>>>>>>>>>            If (Trim(sDataSource) <> "" and not(sDataSource contains "*.")) Begin
81170>>>>>>>>>                Move (Trim(sDataSource)) to sReturnArray[iItem]
81171>>>>>>>>>                Increment iItem
81172>>>>>>>>>            End
81172>>>>>>>>>>
81172>>>>>>>>>        Until (sDataSource = "")
81174>>>>>>>>>
81174>>>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81175>>>>>>>>>
81175>>>>>>>>>        Function_Return sReturnArray
81176>>>>>>>>>    End_Function
81177>>>>>>>>>
81177>>>>>>>>>    Function _SqlDatabasesArrayODBC Returns tSQLIntTableInfo[]
81179>>>>>>>>>        String[] sDataSources
81180>>>>>>>>>        tSQLConnection SQLConnection
81180>>>>>>>>>        tSQLConnection SQLConnection
81180>>>>>>>>>        tSQLIntTableInfo[] sReturnArray
81180>>>>>>>>>        tSQLIntTableInfo[] sReturnArray
81181>>>>>>>>>        Integer iDataSources iCount iItem
81181>>>>>>>>>        String sConnection sServer sDatabase sKey sSubKey
81181>>>>>>>>>        Handle hoIniFile hoRegistry hoODBCDataSources
81181>>>>>>>>>        Boolean bExists bKeyOpened
81181>>>>>>>>>
81181>>>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
81182>>>>>>>>>        Move SQLConnection.sConnectionString to sConnection
81183>>>>>>>>>        Move SQLConnection.sServer           to sServer
81184>>>>>>>>>
81184>>>>>>>>>        // FileDSN - read DATABASE name from DSN ini-file
81184>>>>>>>>>        If (Uppercase(sServer) contains ("." + String(CS_SQLIniDSNKeyword))) Begin
81186>>>>>>>>>            Get Create (RefClass(cIniFile)) to hoIniFile
81187>>>>>>>>>            Set psFileName of hoIniFile to sServer
81188>>>>>>>>>            Get ReadString of hoIniFile CS_SQLODBCIniSectionName CS_SQLIniDatabaseKeyword "" to sDatabase
81189>>>>>>>>>            Move sDatabase to sReturnArray[0].sDatabaseName
81190>>>>>>>>>            Send Destroy of hoIniFile
81191>>>>>>>>>        End
81191>>>>>>>>>>
81191>>>>>>>>>
81191>>>>>>>>>        // DSN - read DATABASE name from the registry
81191>>>>>>>>>        Else Begin
81192>>>>>>>>>            Get Create (RefClass(cRegistry)) to hoRegistry
81193>>>>>>>>>
81193>>>>>>>>>            // We start with checking the "System DNS" area in the registry as it is the
81193>>>>>>>>>            // most probably place the info is kept that we're after.
81193>>>>>>>>>            Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
81194>>>>>>>>>            Set pfAccessRights of hoRegistry to Key_Read
81195>>>>>>>>>            Get KeyExists of hoRegistry "SOFTWARE\Wow6432Node" to bExists
81196>>>>>>>>>            If (bExists = True) Begin
81198>>>>>>>>>                Move "SOFTWARE\Wow6432Node\ODBC\ODBC.INI" to sKey
81199>>>>>>>>>            End
81199>>>>>>>>>>
81199>>>>>>>>>            Else Begin
81200>>>>>>>>>                Move "SOFTWARE\ODBC\ODBC.INI" to sKey
81201>>>>>>>>>            End
81201>>>>>>>>>>
81201>>>>>>>>>
81201>>>>>>>>>            Get KeyExists of hoRegistry sKey to bExists
81202>>>>>>>>>            If (bExists) Begin
81204>>>>>>>>>                Get OpenKey of hoRegistry sKey to bKeyOpened
81205>>>>>>>>>                If (bKeyOpened) Begin
81207>>>>>>>>>                    Get Create (RefClass(Array)) to hoODBCDataSources
81208>>>>>>>>>                    Get GetSubkeys of hoRegistry hoODBCDataSources to iDataSources
81209>>>>>>>>>                    If (iDataSources > 0) Begin
81211>>>>>>>>>                        Move (ResizeArray(sDataSources, iDataSources)) to sDataSources
81212>>>>>>>>>                        Decrement iDataSources
81213>>>>>>>>>                        for iCount from 0 to iDataSources
81219>>>>>>>>>>
81219>>>>>>>>>                            Get Value of hoODBCDataSources iCount to sDataSources[iCount]
81220>>>>>>>>>                        Loop
81221>>>>>>>>>>
81221>>>>>>>>>                        Move 0 to iItem
81222>>>>>>>>>                        for iCount from 0 to iDataSources
81228>>>>>>>>>>
81228>>>>>>>>>                            Move sDataSources[iCount] to sSubKey
81229>>>>>>>>>                            Get OpenKey of hoRegistry (sKey + "\" + String(sSubKey)) to bKeyOpened
81230>>>>>>>>>                            If (bKeyOpened = True) Begin
81232>>>>>>>>>                                Get ValueExists of hoRegistry CS_SQLIniDatabaseKeyword to bExists
81233>>>>>>>>>                                If (bExists = True) Begin
81235>>>>>>>>>                                    Move sSubKey to sReturnArray[iItem].sServerName
81236>>>>>>>>>                                    Get ReadString of hoRegistry CS_SQLIniDatabaseKeyword to sReturnArray[iItem].sDatabaseName
81237>>>>>>>>>                                    Increment iItem
81238>>>>>>>>>                                End
81238>>>>>>>>>>
81238>>>>>>>>>                            End
81238>>>>>>>>>>
81238>>>>>>>>>                        Loop
81239>>>>>>>>>>
81239>>>>>>>>>                    End
81239>>>>>>>>>>
81239>>>>>>>>>                    Send CloseKey of hoRegistry
81240>>>>>>>>>                    Send Destroy of hoODBCDataSources
81241>>>>>>>>>                End
81241>>>>>>>>>>
81241>>>>>>>>>            End
81241>>>>>>>>>>
81241>>>>>>>>>
81241>>>>>>>>>            // We then check the "User DNS" area in the registry.
81241>>>>>>>>>            Set phRootKey of hoRegistry to HKEY_CURRENT_USER
81242>>>>>>>>>            Set pfAccessRights of hoRegistry to Key_Read
81243>>>>>>>>>            Move "SOFTWARE\ODBC\ODBC.INI" to sKey
81244>>>>>>>>>            Get KeyExists of hoRegistry sKey to bExists
81245>>>>>>>>>
81245>>>>>>>>>            If (bExists) Begin
81247>>>>>>>>>                Get OpenKey of hoRegistry sKey to bKeyOpened
81248>>>>>>>>>                If (bKeyOpened) Begin
81250>>>>>>>>>                    Get Create (RefClass(Array)) to hoODBCDataSources
81251>>>>>>>>>                    Get GetSubkeys of hoRegistry hoODBCDataSources to iDataSources
81252>>>>>>>>>                    If (iDataSources > 0) Begin
81254>>>>>>>>>                        Move (ResizeArray(sDataSources, iDataSources)) to sDataSources
81255>>>>>>>>>                        Decrement iDataSources
81256>>>>>>>>>                        for iCount from 0 to iDataSources
81262>>>>>>>>>>
81262>>>>>>>>>                            Get Value of hoODBCDataSources iCount to sDataSources[iCount]
81263>>>>>>>>>                        Loop
81264>>>>>>>>>>
81264>>>>>>>>>                        for iCount from 0 to iDataSources
81270>>>>>>>>>>
81270>>>>>>>>>                            Move sDataSources[iCount] to sSubKey
81271>>>>>>>>>                            Get OpenKey of hoRegistry (sKey + "\" + String(sSubKey)) to bKeyOpened
81272>>>>>>>>>                            If (bKeyOpened = True) Begin
81274>>>>>>>>>                                Get ValueExists of hoRegistry CS_SQLIniDatabaseKeyword to bExists
81275>>>>>>>>>                                If (bExists = True) Begin
81277>>>>>>>>>                                    Move sSubKey to sReturnArray[iItem].sServerName
81278>>>>>>>>>                                    Get ReadString of hoRegistry CS_SQLIniDatabaseKeyword to sReturnArray[iItem].sDatabaseName
81279>>>>>>>>>                                    Increment iItem
81280>>>>>>>>>                                End
81280>>>>>>>>>>
81280>>>>>>>>>                            End
81280>>>>>>>>>>
81280>>>>>>>>>                        Loop
81281>>>>>>>>>>
81281>>>>>>>>>                    End
81281>>>>>>>>>>
81281>>>>>>>>>                    Send CloseKey of hoRegistry
81282>>>>>>>>>                    Send Destroy of hoODBCDataSources
81283>>>>>>>>>                End
81283>>>>>>>>>>
81283>>>>>>>>>            End
81283>>>>>>>>>>
81283>>>>>>>>>
81283>>>>>>>>>            Send Destroy of hoRegistry
81284>>>>>>>>>        End
81284>>>>>>>>>>
81284>>>>>>>>>
81284>>>>>>>>>        Function_Return sReturnArray
81285>>>>>>>>>    End_Function
81286>>>>>>>>>
81286>>>>>>>>>    // We might have a split Sql script where the info about which database to use is
81286>>>>>>>>>    // put on top of the Sql script, we then need to save it to be able to retrieve it later and
81286>>>>>>>>>    // insert it for scriplets to come after the first one.
81286>>>>>>>>>    Function _SqlFormatStatement String sStmt Returns String
81288>>>>>>>>>        String sUseDatabase sTmp sUseKeyWord sCreateViewKeyWord sDBOKeyWord sNoCountKeyWord sDriverID
81288>>>>>>>>>        Integer iStart iEnd iDbType
81288>>>>>>>>>        Boolean bOK
81288>>>>>>>>>
81288>>>>>>>>>        Get piDbType to iDbType
81289>>>>>>>>>        Get psDriverID to sDriverID
81290>>>>>>>>>        Get _SqlFindKeyWord CI_SQLUse          to sUseKeyWord
81291>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
81292>>>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateView   to sCreateViewKeyWord
81293>>>>>>>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBOKeyWord
81294>>>>>>>>>        Move (Replaces(" ", sStmt, "")) to sTmp
81295>>>>>>>>>        If (Uppercase(sTmp) contains (sUseKeyWord +"[")) Begin
81297>>>>>>>>>            Move (Pos("[", (Uppercase(sTmp)))) to iStart
81298>>>>>>>>>            Move (Pos("]", sTmp)) to iEnd
81299>>>>>>>>>            Move (Mid(sTmp, (iEnd -iStart +1), iStart)) to sUseDatabase
81300>>>>>>>>>            Move (sUseKeyWord * sUseDatabase + " ") to sUseDatabase
81301>>>>>>>>>            Set Private.psUseDatabase to sUseDatabase
81302>>>>>>>>>        End
81302>>>>>>>>>>
81302>>>>>>>>>        Else Begin
81303>>>>>>>>>            Move (Uppercase(sStmt)) to sTmp
81304>>>>>>>>>
81304>>>>>>>>>            // A "Create View" statement _must_ be the very first words in a Sql statement.
81304>>>>>>>>>            If (not(sTmp contains sCreateViewKeyWord)) Begin
81306>>>>>>>>>                Get Private.psUseDatabase to sUseDatabase
81307>>>>>>>>>                Move (Insert(sUseDatabase, sStmt, 1)) to sStmt
81308>>>>>>>>>            End
81308>>>>>>>>>>
81308>>>>>>>>>
81308>>>>>>>>>            // This is a bit special to place here but was done so because it was easier that way.
81308>>>>>>>>>            // We will get an error when trying to create a view if it already exists.
81308>>>>>>>>>            // So to avoid such errors; we first remove it & then recreate it.
81308>>>>>>>>>            Else If (sTmp contains sCreateViewKeyWord) Begin
81311>>>>>>>>>                // Make sure we only have one space between statements/words.
81311>>>>>>>>>                Move (Replaces("  ", sTmp, " ")) to sTmp
81312>>>>>>>>>                Move (Replace(sCreateViewKeyWord, sTmp, "")) to sTmp
81313>>>>>>>>>                Move (Trim(sTmp)) to sTmp
81314>>>>>>>>>                Move (Pos(" ", sTmp)) to iEnd
81315>>>>>>>>>                Move (Left(sTmp, iEnd)) to sTmp
81316>>>>>>>>>                If ((not(sTmp contains ("[" + sDBOKeyWord + "]."))) and (not(sTmp contains (sDBOKeyWord + ".")))) Begin
81318>>>>>>>>>                    Move (sDBOKeyWord + "." + Trim(sTmp)) to sTmp
81319>>>>>>>>>                End
81319>>>>>>>>>>
81319>>>>>>>>>                Move (Trim(sTmp)) to sTmp
81320>>>>>>>>>                // Remove data view as it already exists!
81320>>>>>>>>>                Get _SqlViewRemove sDriverID sTmp to bOK
81321>>>>>>>>>            End
81321>>>>>>>>>>
81321>>>>>>>>>        End
81321>>>>>>>>>>
81321>>>>>>>>>
81321>>>>>>>>>        Function_Return sStmt
81322>>>>>>>>>    End_Function
81323>>>>>>>>>
81323>>>>>>>>>    // First deletes the data cache file and then drops the passed Sql data view.
81323>>>>>>>>>    Function _SqlViewRemove String sDataView Returns Boolean
81325>>>>>>>>>        String sDriverID sSQLString sDropViewKeyWord
81325>>>>>>>>>        Integer iRetval
81325>>>>>>>>>        Boolean bOK
81325>>>>>>>>>
81325>>>>>>>>>        Get psDriverID to sDriverID
81326>>>>>>>>>        Get _UtilDeleteCacheFile sDataView to iRetval
81327>>>>>>>>>
81327>>>>>>>>>        Get _SqlFindKeyWord CI_SQLDropView to sDropViewKeyWord
81328>>>>>>>>>        Move (sDropViewKeyWord * String(sDataView)) to sSQLString
81329>>>>>>>>>        Set psSQLStatementString to sSQLString
81330>>>>>>>>>
81330>>>>>>>>>        // As we don't check if the view exist or not, it might happen
81330>>>>>>>>>        // that it doesn't and that would through an error, so guard for that eventuality (just ignore it).
81330>>>>>>>>>        Move False to Err
81331>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
81332>>>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
81333>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
81334>>>>>>>>>        Move 0 to LastErr
81335>>>>>>>>>
81335>>>>>>>>>        // We also need to remove the cache-file since the table has been changed
81335>>>>>>>>>        Get _UtilDeleteCacheFile sDataView to bOK
81336>>>>>>>>>
81336>>>>>>>>>        Function_Return (Err = False)
81337>>>>>>>>>    End_Function
81338>>>>>>>>>
81338>>>>>>>>>    // Returns the proper Sql language key word(s) for the passed SQL key-word constant
81338>>>>>>>>>    Function _SqlFindKeyWord Integer iSQLKeywordConstant Returns String
81340>>>>>>>>>        String sRetval
81340>>>>>>>>>        Integer iDbType iIndex
81340>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
81340>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
81341>>>>>>>>>        tSQLKeyWords   SQLKeyWords
81341>>>>>>>>>        tSQLKeyWords   SQLKeyWords
81341>>>>>>>>>
81341>>>>>>>>>        // Sql back-end type. E.g. MS-SQL, MySQL, Oracle, DB2...
81341>>>>>>>>>        Move "" to sRetval
81342>>>>>>>>>        Get piDbType to iDbType
81343>>>>>>>>>        Move iDbType             to SQLKeyWords.iSQLDbType
81344>>>>>>>>>        Move iSQLKeywordConstant to SQLKeyWords.iSQLWord
81345>>>>>>>>>
81345>>>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
81346>>>>>>>>>        Move (SearchArray(SQLKeyWords, SQLKeywordArray, Self, RefFunc(CompareFindSQLKeyWords))) to iIndex
81347>>>>>>>>>        If (iIndex >= 0) Begin
81349>>>>>>>>>            Move SQLKeywordArray[iIndex].sSQLPhrase to sRetval
81350>>>>>>>>>        End
81350>>>>>>>>>>
81350>>>>>>>>>
81350>>>>>>>>>        Function_Return sRetval
81351>>>>>>>>>    End_Function
81352>>>>>>>>>
81352>>>>>>>>>    // Function will "clean/sanitize" the script by removing all comments and blank lines.
81352>>>>>>>>>    Function _SqlUtilSanitizeScript tSQLScriptArray SqlScriptArray Returns tSQLScriptArray[]
81354>>>>>>>>>        String[] sSQLScriptArray
81355>>>>>>>>>        String sText sLine sTmp sCommentStart sCommentEnd sDashComment
81355>>>>>>>>>        Integer iSize iCount
81355>>>>>>>>>        Boolean bCommentStart bCommentEnd bDashComment
81355>>>>>>>>>
81355>>>>>>>>>        Move False to bCommentStart
81356>>>>>>>>>        Move False to bCommentEnd
81357>>>>>>>>>        Move False to bDashComment
81358>>>>>>>>>        Move "/*"  to sCommentStart   // These are the standard comment start & stop tokens...
81359>>>>>>>>>        Move "*/"  to sCommentEnd
81360>>>>>>>>>        Move "--"  to sDashComment    // ...but a comment can also start with two dashes "--".
81361>>>>>>>>>
81361>>>>>>>>>        Move (SizeOfArray(SqlScriptArray.sSQLScriptArray)) to iSize
81362>>>>>>>>>        Decrement iSize
81363>>>>>>>>>        Move "" to sText
81364>>>>>>>>>
81364>>>>>>>>>        for iCount from 0 to iSize
81370>>>>>>>>>>
81370>>>>>>>>>            Move SqlScriptArray.sSQLScriptArray[iCount] to sLine
81371>>>>>>>>>            Move (Trim(sLine)) to sTmp
81372>>>>>>>>>            If (sTmp <> "") Begin
81374>>>>>>>>>                Move (Left(sTmp, 2) = sDashComment) to bDashComment
81375>>>>>>>>>                If (bCommentStart = False) Begin
81377>>>>>>>>>                    Move (Left(sTmp, 2) = sCommentStart) to bCommentStart
81378>>>>>>>>>                    If (bCommentStart = False) Begin
81380>>>>>>>>>                    End
81380>>>>>>>>>>
81380>>>>>>>>>                End
81380>>>>>>>>>>
81380>>>>>>>>>                Move (sTmp contains sCommentEnd) to bCommentEnd
81381>>>>>>>>>                If (bCommentEnd = True) Begin
81383>>>>>>>>>                    Move False to bCommentStart
81384>>>>>>>>>                End
81384>>>>>>>>>>
81384>>>>>>>>>                If (bDashComment = False and bCommentStart = False and bCommentEnd = False) Begin
81386>>>>>>>>>                    Move sLine to sSQLScriptArray[SizeOfArray(sSQLScriptArray)]
81387>>>>>>>>>                End
81387>>>>>>>>>>
81387>>>>>>>>>            End
81387>>>>>>>>>>
81387>>>>>>>>>        Loop
81388>>>>>>>>>>
81388>>>>>>>>>
81388>>>>>>>>>        // Update the retval struct array:
81388>>>>>>>>>        Move sSQLScriptArray to SqlScriptArray.sSQLScriptArray
81389>>>>>>>>>        Function_Return SqlScriptArray
81390>>>>>>>>>    End_Function
81391>>>>>>>>>
81391>>>>>>>>>    // Helper function that builds a string like;
81391>>>>>>>>>    // "SELECT name from [Master].[sys].[databases] where name"
81391>>>>>>>>>    Function _SqlSelectFromWhereName Returns String
81393>>>>>>>>>        String sRetval sSelect sName sFrom sMaster sSys sDatabases sWhere sDBO
81393>>>>>>>>>
81393>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSelect       to sSelect
81394>>>>>>>>>        Get _SqlFindKeyWord CI_SQLName         to sName
81395>>>>>>>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBO
81396>>>>>>>>>        Get _SqlFindKeyWord CI_SQLFrom         to sFrom
81397>>>>>>>>>        Get _SqlFindKeyWord CI_SQLMaster       to sMaster
81398>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSys          to sSys
81399>>>>>>>>>        Get _SqlFindKeyWord CI_SQLDatabases    to sDatabases
81400>>>>>>>>>        Get _SqlFindKeyWord CI_SQLWhere        to sWhere
81401>>>>>>>>>        Move (sSelect * sName * sFrom * "[" + sMaster + "].[" + sDBO + "].[" + sSys + sDatabases + "]" * sWhere * sName) to sRetval
81402>>>>>>>>>        Function_Return sRetval
81403>>>>>>>>>    End_Function
81404>>>>>>>>>
81404>>>>>>>>>    // Helper function to create a SQL statement like;
81404>>>>>>>>>    // "SELECT * FROM SYS.INDEXES WHERE NAME = MyIndexName AND OBJECT_ID = OBJECT_ID([MySchmaName].[MyTableName])"
81404>>>>>>>>>    // Used for checking if an index exists.
81404>>>>>>>>>    Function _SqlQueryIfIndexExists String sSchemaName String sTableName String sIndexName Returns String
81406>>>>>>>>>        String sRetval sSelect sFrom sSysIndexes sWhere sObjectID sAnd sName
81406>>>>>>>>>
81406>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSelect to sSelect
81407>>>>>>>>>        Get _SqlFindKeyWord CI_SQLFrom to sFrom
81408>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSysIndexes to sSysIndexes
81409>>>>>>>>>        Get _SqlFindKeyWord CI_SQLWhere to sWhere
81410>>>>>>>>>        Get _SqlFindKeyWord CI_SQLObjectID to sObjectID
81411>>>>>>>>>        Get _SqlFindKeyWord CI_SQLAND to sAnd
81412>>>>>>>>>        Get _SqlFindKeyWord CI_SQLName to sName
81413>>>>>>>>>
81413>>>>>>>>>        Move (sSelect * String("*") * sFrom * sSysIndexes * sWhere * sName * "=" * sIndexName * sAnd * sObjectID * "=([" + sSchemaName + "].[" + sTableName + "])") to sRetval
81414>>>>>>>>>
81414>>>>>>>>>        Function_Return sRetval
81415>>>>>>>>>    End_Function
81416>>>>>>>>>
81416>>>>>>>>>    // Formats a columns iLenght & iDecimal parameters as SQL expects them in a string.
81416>>>>>>>>>    // E.g. (4,2), where 4 is the iLength and 2 the iDecimals param.
81416>>>>>>>>>    Function _SqlFormatLengthAndDecimalAsString Integer iLength Integer iDecimals Returns String
81418>>>>>>>>>        String sRetval
81418>>>>>>>>>        If (iLength <> 0) Begin
81420>>>>>>>>>            Move ("(" + String(iLength)) to sRetval
81421>>>>>>>>>            If (iDecimals <> 0) Begin
81423>>>>>>>>>                Move (sRetval + "," + String(iDecimals)) to sRetval
81424>>>>>>>>>            End
81424>>>>>>>>>>
81424>>>>>>>>>            Move (sRetval + ")") to sRetval
81425>>>>>>>>>        End
81425>>>>>>>>>>
81425>>>>>>>>>        Function_Return sRetval
81426>>>>>>>>>    End_Function
81427>>>>>>>>>
81427>>>>>>>>>    // Checks that the passed sDriverID is defined.
81427>>>>>>>>>    // Also checks if the driver has been loaded; else it gets loaded.
81427>>>>>>>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
81429>>>>>>>>>        Boolean bOK
81429>>>>>>>>>        Integer iDriver
81429>>>>>>>>>
81429>>>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
81431>>>>>>>>>            Function_Return False
81432>>>>>>>>>        End
81432>>>>>>>>>>
81432>>>>>>>>>
81432>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
81433>>>>>>>>>
81433>>>>>>>>>        If (bOK = False) Begin
81435>>>>>>>>>            Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV, DB2_DRV, or ODBC_DRV"
81436>>>>>>>>>>
81436>>>>>>>>>            Function_Return False
81437>>>>>>>>>        End
81437>>>>>>>>>>
81437>>>>>>>>>
81437>>>>>>>>>        Get DriverIndex sDriverID to iDriver
81438>>>>>>>>>        If (iDriver = 0) Begin
81440>>>>>>>>>            Load_Driver sDriverID
81441>>>>>>>>>        End
81441>>>>>>>>>>
81441>>>>>>>>>
81441>>>>>>>>>        Function_Return True
81442>>>>>>>>>    End_Function
81443>>>>>>>>>
81443>>>>>>>>>    // Checks that the length parameter has been passed correctly.
81443>>>>>>>>>    // This is only of concern for certain SQL data types.
81443>>>>>>>>>    Function _SqlCheckLengthParamForDataType Integer iDataType Integer iLen Returns Boolean
81445>>>>>>>>>        Integer iLength
81445>>>>>>>>>        Boolean bOK bCheckTypeLength
81445>>>>>>>>>
81445>>>>>>>>>        If (num_arguments > 1) Begin
81447>>>>>>>>>            Move iLen to iLength
81448>>>>>>>>>        End
81448>>>>>>>>>>
81448>>>>>>>>>        Move (iDataType = SQL_DECIMAL   or iDataType = SQL_NUMERIC or iDataType = SQL_FLOAT   or iDataType = SQL_INTEGER or;              iDataType = SQL_VARBINARY or iDataType = SQL_BINARY  or iDataType = SQL_VARCHAR or iDataType = SQL_CHAR or;              iDataType = SQL_BIGINT    or iDataType = SQL_REAL) to bCheckTypeLength
81449>>>>>>>>>
81449>>>>>>>>>        If (bCheckTypeLength = True) Begin
81451>>>>>>>>>            Move (iLength > 0) to bOK
81452>>>>>>>>>        End
81452>>>>>>>>>>
81452>>>>>>>>>
81452>>>>>>>>>        Function_Return (bOK = True)
81453>>>>>>>>>    End_Function
81454>>>>>>>>>
81454>>>>>>>>>    Function _SqlProperTableName String sTableName Returns String
81456>>>>>>>>>        String sVal sSchema sDriverID
81456>>>>>>>>>        Integer iDbType
81456>>>>>>>>>
81456>>>>>>>>>        If (Trim(sTableName) = "") Begin
81458>>>>>>>>>            Function_Return ""
81459>>>>>>>>>        End
81459>>>>>>>>>>
81459>>>>>>>>>
81459>>>>>>>>>        Get psDriverID to sDriverID
81460>>>>>>>>>        Get piDbType   to iDbType
81461>>>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
81463>>>>>>>>>            Get psUserID to sSchema
81464>>>>>>>>>            // Not sure about this uppercasing but it seems like Oracle wants that?
81464>>>>>>>>>            Move (Uppercase(sSchema)) to sSchema
81465>>>>>>>>>            Move ('"' + sSchema + '"."' + sTableName + '"') to sTableName
81466>>>>>>>>>            Function_Return sTableName
81467>>>>>>>>>        End
81467>>>>>>>>>>
81467>>>>>>>>>        If (iDbType = EN_DbTypeMySQL) Begin
81469>>>>>>>>>            Get psDatabase to sVal
81470>>>>>>>>>            Move (sVal + "." + sTableName) to sTableName
81471>>>>>>>>>            Function_Return sTableName
81472>>>>>>>>>        End
81472>>>>>>>>>>
81472>>>>>>>>>        If (iDbType = EN_DbTypePostgre) Begin
81474>>>>>>>>>            Move ('"' + sTableName + '"') to sTableName
81475>>>>>>>>>            Function_Return sTableName
81476>>>>>>>>>        End
81476>>>>>>>>>>
81476>>>>>>>>>
81476>>>>>>>>>        Get psSchema to sSchema
81477>>>>>>>>>        If (sSchema = "") Begin
81479>>>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
81480>>>>>>>>>        End
81480>>>>>>>>>>
81480>>>>>>>>>
81480>>>>>>>>>        Move (Uppercase(sTableName)) to sVal
81481>>>>>>>>>        If (not(sVal contains (sSchema + "."))) Begin
81483>>>>>>>>>            If (iDbType = EN_dbTypeDB2) Begin
81485>>>>>>>>>                Move (Lowercase(sSchema) + "." + sTableName) to sTableName
81486>>>>>>>>>            End
81486>>>>>>>>>>
81486>>>>>>>>>            Else Begin
81487>>>>>>>>>                Move (sSchema + "." + sTableName) to sTableName
81488>>>>>>>>>            End
81488>>>>>>>>>>
81488>>>>>>>>>        End
81488>>>>>>>>>>
81488>>>>>>>>>
81488>>>>>>>>>        Function_Return sTableName
81489>>>>>>>>>    End_Function
81490>>>>>>>>>
81490>>>>>>>>>    // SQL column names can be case-sensitive. This function is used to check that
81490>>>>>>>>>    // the passed sFieldName has the correct spelling.
81490>>>>>>>>>    // Used with Embedded SQL statement calls.
81490>>>>>>>>>    // If the spelling or fieldname doesn't exist, the return value is "" (blank).
81490>>>>>>>>>    Function _SqlFindColumnName String sTableName String sColumnName Returns String
81492>>>>>>>>>        String sRetval sValue sDriverID
81492>>>>>>>>>        String[] sColumnNamesArray
81493>>>>>>>>>        Integer iCount iColumns
81493>>>>>>>>>
81493>>>>>>>>>        Move "" to sRetval
81494>>>>>>>>>        Get psDriverID to sDriverID
81495>>>>>>>>>        Get _SqlUtilEnumerateColumns sDriverID sTableName to sColumnNamesArray
81496>>>>>>>>>        Move (SizeOfArray(sColumnNamesArray)) to iColumns
81497>>>>>>>>>        Decrement iColumns
81498>>>>>>>>>
81498>>>>>>>>>        For iCount from 0 to iColumns
81504>>>>>>>>>>
81504>>>>>>>>>            Move sColumnNamesArray[iCount] to sValue
81505>>>>>>>>>            If (Uppercase(sColumnName) = Uppercase(sValue)) Begin
81507>>>>>>>>>                Move sValue to sRetval
81508>>>>>>>>>                Move iColumns to iCount // We're done.
81509>>>>>>>>>            End
81509>>>>>>>>>>
81509>>>>>>>>>        Loop
81510>>>>>>>>>>
81510>>>>>>>>>
81510>>>>>>>>>        Function_Return sRetval
81511>>>>>>>>>    End_Function
81512>>>>>>>>>
81512>>>>>>>>>    Function _SqlDatabasesArrayMSSQL Returns String[]
81514>>>>>>>>>        String[] sReturnArray
81515>>>>>>>>>        Handle hoSQLHandler
81515>>>>>>>>>        Integer iCount iSize iItem
81515>>>>>>>>>        String sServer
81515>>>>>>>>>        tSQLConnection SQLConnection
81515>>>>>>>>>        tSQLConnection SQLConnection
81515>>>>>>>>>
81515>>>>>>>>>        Get phoMSSQLHandler to hoSQLHandler
81516>>>>>>>>>        Send Delete_Data    of hoSQLHandler
81517>>>>>>>>>        Get pSQLConnection  of ghoSQLConnectionHandler to SQLConnection
81518>>>>>>>>>
81518>>>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81519>>>>>>>>>        Get EnumerateDatabases of hoSQLHandler SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to iSize
81520>>>>>>>>>        Decrement iSize
81521>>>>>>>>>
81521>>>>>>>>>        For iCount from 0 to iSize
81527>>>>>>>>>>
81527>>>>>>>>>            Get String_Value of hoSQLHandler iCount to sServer
81528>>>>>>>>>            Move (Trim(sServer)) to sReturnArray[iItem]
81529>>>>>>>>>            Increment iItem
81530>>>>>>>>>        Loop
81531>>>>>>>>>>
81531>>>>>>>>>
81531>>>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81532>>>>>>>>>
81532>>>>>>>>>        Function_Return sReturnArray
81533>>>>>>>>>    End_Function
81534>>>>>>>>>
81534>>>>>>>>>    Function _SqlTableArrayDAW Returns String[]
81536>>>>>>>>>        String[] sReturnArray
81537>>>>>>>>>        String sTable sTableType sSchema sDefSchema sComment sTableKeyWord sSysKeyWord sConnectionString
81537>>>>>>>>>        Handle hoSQLHandler
81537>>>>>>>>>        Integer iCount iSize iItem iPos
81537>>>>>>>>>        Boolean bOK
81537>>>>>>>>>        tSQLConnection SQLConnection
81537>>>>>>>>>        tSQLConnection SQLConnection
81537>>>>>>>>>
81537>>>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
81538>>>>>>>>>        If (SQLConnection.sConnectionString = "") Begin
81540>>>>>>>>>            Function_Return sReturnArray
81541>>>>>>>>>        End
81541>>>>>>>>>>
81541>>>>>>>>>
81541>>>>>>>>>        Move SQLConnection.sSchema      to sDefSchema
81542>>>>>>>>>        Move (Uppercase(sDefSchema))    to sDefSchema
81543>>>>>>>>>        Get _SqlFindKeyWord CI_SQLTable to sTableKeyWord
81544>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSys   to sSysKeyWord
81545>>>>>>>>>
81545>>>>>>>>>        Get phoCLIHandler to hoSQLHandler
81546>>>>>>>>>        Set psDriverID    of hoSQLHandler to SQLConnection.sDriverID
81547>>>>>>>>>        Send Delete_Data  of hoSQLHandler
81548>>>>>>>>>
81548>>>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81549>>>>>>>>>        Move SQLConnection.sConnectionString to sConnectionString
81550>>>>>>>>>        // 2020-03-14 This was not correct when testing a MS-SQL ODBC driver connection from CMOS.
81550>>>>>>>>>//        If (SQLConnection.sDriverID = ODBC_DRV_ID) Begin
81550>>>>>>>>>//            If (Uppercase(sConnectionString) contains CS_SQLIniDSNKeyword) Begin
81550>>>>>>>>>//                Move (Pos(";", sConnectionString)) to iPos
81550>>>>>>>>>//                If (iPos > 0) Begin
81550>>>>>>>>>//                    Move (Left(sConnectionString, (iPos - 1))) to sConnectionString
81550>>>>>>>>>//                    Move (Trim(sConnectionString)) to sConnectionString
81550>>>>>>>>>//                End
81550>>>>>>>>>//            End
81550>>>>>>>>>//        End
81550>>>>>>>>>
81550>>>>>>>>>        Get EnumerateTables of hoSQLHandler sConnectionString to iSize
81551>>>>>>>>>        Move False to Err
81552>>>>>>>>>        Move 0 to iItem
81553>>>>>>>>>
81553>>>>>>>>>        // Note that the enumeration starts from table no 1. (not zero)
81553>>>>>>>>>        For iCount from 1 to iSize
81559>>>>>>>>>>
81559>>>>>>>>>            Get TableName    of hoSQLHandler iCount to sTable
81560>>>>>>>>>            Get TableType    of hoSQLHandler iCount to sTableType
81561>>>>>>>>>            Get SchemaName   of hoSQLHandler iCount to sSchema
81562>>>>>>>>>            If (sSchema = "") Begin
81564>>>>>>>>>                Get _SqlFindKeyWord CI_SQLDBO to sSchema
81565>>>>>>>>>            End
81565>>>>>>>>>>
81565>>>>>>>>>            Get TableComment of hoSQLHandler iCount to sComment
81566>>>>>>>>>            Move (Trim(sTable)) to sTable
81567>>>>>>>>>            If (SQLConnection.sDriverID = DB2_DRV_ID) Begin
81569>>>>>>>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) = sDefSchema) to bOK
81570>>>>>>>>>            End
81570>>>>>>>>>>
81570>>>>>>>>>            Else Begin
81571>>>>>>>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) <> sSysKeyWord and Uppercase(sSchema) <> "SYSTOOLS") to bOK
81572>>>>>>>>>            End
81572>>>>>>>>>>
81572>>>>>>>>>            If (bOK = True) Begin
81574>>>>>>>>>                Move sTable to sReturnArray[iItem]
81575>>>>>>>>>                Increment iItem
81576>>>>>>>>>            End
81576>>>>>>>>>>
81576>>>>>>>>>        Loop
81577>>>>>>>>>>
81577>>>>>>>>>
81577>>>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
81578>>>>>>>>>
81578>>>>>>>>>        Function_Return sReturnArray
81579>>>>>>>>>    End_Function
81580>>>>>>>>>
81580>>>>>>>>>    Function _SqlProcedureArrayDAW String sStmt String sArgument Returns String[]
81582>>>>>>>>>        String[] sReturnArray
81583>>>>>>>>>        String sValue
81583>>>>>>>>>        Handle hoSQLHandler hoSQLConnect hStmt
81583>>>>>>>>>        Integer iRetval iCols iFetchResult
81583>>>>>>>>>        tSQLConnection SQLConnection
81583>>>>>>>>>        tSQLConnection SQLConnection
81583>>>>>>>>>
81583>>>>>>>>>        Get phoSQLManager to hoSQLHandler
81584>>>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
81585>>>>>>>>>        Get SqlConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
81586>>>>>>>>>
81586>>>>>>>>>        If (hoSQLConnect <> 0) Begin
81588>>>>>>>>>            Get SqlOpen of hoSQLConnect to hStmt
81589>>>>>>>>>            If (hStmt <> 0) Begin
81591>>>>>>>>>                Send SqlSetProcedurename of hStmt sStmt
81592>>>>>>>>>                If (sArgument <> "") Begin
81594>>>>>>>>>                    Send SqlSetArgument  of hStmt 1 sArgument
81595>>>>>>>>>                End
81595>>>>>>>>>>
81595>>>>>>>>>
81595>>>>>>>>>                Send SqlCall             of hStmt
81596>>>>>>>>>                Get SqlReturnValue       of hStmt to iRetval
81597>>>>>>>>>                If (iRetval = 0) Begin
81599>>>>>>>>>                    Repeat
81599>>>>>>>>>>
81599>>>>>>>>>                        Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
81600>>>>>>>>>                        If (iCols > 0) Begin
81602>>>>>>>>>                            Repeat
81602>>>>>>>>>>
81602>>>>>>>>>                                Get SqlFetch of hStmt to iFetchResult
81603>>>>>>>>>                                If (iFetchResult <> 0) Begin
81605>>>>>>>>>                                    Get SqlColumnValue of hStmt 1 to sValue
81606>>>>>>>>>                                    Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)]
81607>>>>>>>>>                                End
81607>>>>>>>>>>
81607>>>>>>>>>                            Until (iFetchResult = 0)
81609>>>>>>>>>                        End
81609>>>>>>>>>>
81609>>>>>>>>>                        Get SqlNextResultSet of hStmt to iRetval
81610>>>>>>>>>                    Until (iRetval = 0)
81612>>>>>>>>>                    Send SqlClose of hStmt
81613>>>>>>>>>                End
81613>>>>>>>>>>
81613>>>>>>>>>            End
81613>>>>>>>>>>
81613>>>>>>>>>            Send SqlDisconnect of hoSQLConnect
81614>>>>>>>>>        End
81614>>>>>>>>>>
81614>>>>>>>>>        Function_Return sReturnArray
81615>>>>>>>>>    End_Function
81616>>>>>>>>>
81616>>>>>>>>>    Function _SqlUtilUpdateIntFile Integer hTable Returns Boolean
81618>>>>>>>>>        String sOrgFormat sNewFormat sRootName sDatabaseName sPhysicalFileName sDriverID sDataPath
81618>>>>>>>>>        Boolean bOpened bOK
81618>>>>>>>>>
81618>>>>>>>>>        // For some reason this .int file update screws up of CodeMast & CodeType .int files
81618>>>>>>>>>        // which makes the program unable to run because they can't be opened.
81618>>>>>>>>>        // ToDo: This needs further investigation but for now we just skip CodeMast & CodeType .int files update...
81618>>>>>>>>>        // Also note that there is another helper function "UtilTableCreateCodeMastCodeTypeIntFiles" to create
81618>>>>>>>>>        // proper .int files for the two tables.
81618>>>>>>>>>        If (Uppercase(sDatabaseName) = "CODETYPE" or Uppercase(sDatabaseName) = "CODEMAST") Begin
81620>>>>>>>>>            Function_Return True
81621>>>>>>>>>        End
81621>>>>>>>>>>
81621>>>>>>>>>
81621>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
81624>>>>>>>>>        Get _TableNameOnly sRootName to sDatabaseName
81625>>>>>>>>>        Move CS_OEM_Txt  to sOrgFormat
81626>>>>>>>>>        Move CS_ANSI_Txt to sNewFormat
81627>>>>>>>>>        Get AutoConnectionIDLogin to bOK
81628>>>>>>>>>
81628>>>>>>>>>        // It seems this can be called to quickly; causing a 13001 error "Cannot open cache file for write"
81628>>>>>>>>>        Sleep 1
81629>>>>>>>>>
81629>>>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
81632>>>>>>>>>        If (bOpened = False) Begin
81634>>>>>>>>>            Open hTable
81636>>>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpened
81639>>>>>>>>>        End
81639>>>>>>>>>>
81639>>>>>>>>>        If (bOpened = False) Begin
81641>>>>>>>>>            Function_Return False
81642>>>>>>>>>        End
81642>>>>>>>>>>
81642>>>>>>>>>
81642>>>>>>>>>        Get psDriverID to sDriverID
81643>>>>>>>>>
81643>>>>>>>>>        Move False to Err
81644>>>>>>>>>        Get_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
81647>>>>>>>>>        Move (Uppercase(sOrgFormat)) to sOrgFormat
81648>>>>>>>>>        // Lets swap the OEM/ANSI format, just to make a change in Structure_Start below (and back),
81648>>>>>>>>>        // to "touch" the table so the driver feels there has been a change and updates the .int file.
81648>>>>>>>>>        Move (If(sOrgFormat = CS_OEM_Txt, CS_ANSI_Txt, CS_OEM_Txt)) to sNewFormat
81649>>>>>>>>>
81649>>>>>>>>>        Move False to Err
81650>>>>>>>>>
81650>>>>>>>>>        If (hTable > 0) Begin
81652>>>>>>>>>            Structure_Start hTable
81653>>>>>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
81656>>>>>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
81659>>>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
81661>>>>>>>>>        End
81661>>>>>>>>>>
81661>>>>>>>>>        Else Begin
81662>>>>>>>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
81665>>>>>>>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
81668>>>>>>>>>        End
81668>>>>>>>>>>
81668>>>>>>>>>        Function_Return (Err = False)
81669>>>>>>>>>    End_Function
81670>>>>>>>>>
81670>>>>>>>>>    // Subfunction to the ApiTableUpdate function (et al)
81670>>>>>>>>>    Function _UtilTableCheckChangeFilelistNames tAPITableNameInfo APITableNameInfoFrom Boolean bIsSQLTableTo Returns Boolean
81672>>>>>>>>>        Handle hTable
81672>>>>>>>>>        String sConnectionID
81672>>>>>>>>>        Boolean bTableExists bSameTableNames bANSI bOK
81672>>>>>>>>>
81672>>>>>>>>>        Get _ApiTableFilelistNamesCompare True APITableNameInfoFrom to bSameTableNames
81673>>>>>>>>>        If (bSameTableNames = True) Begin
81675>>>>>>>>>            Function_Return True
81676>>>>>>>>>        End
81676>>>>>>>>>>
81676>>>>>>>>>
81676>>>>>>>>>        Move True to bOK
81677>>>>>>>>>        Move APITableNameInfoFrom.iTableNumber  to hTable
81678>>>>>>>>>        Set Private.phCurrentTable              to hTable
81679>>>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME         of hTable to APITableNameInfoFrom.sRootName
81682>>>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME      of hTable to APITableNameInfoFrom.sLogicalName
81685>>>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME      of hTable to APITableNameInfoFrom.sDisplayName
81688>>>>>>>>>
81688>>>>>>>>>        If (APITableNameInfoFrom.bIsSQL = True) Begin
81690>>>>>>>>>            Get psConnectionID to sConnectionID
81691>>>>>>>>>            Get _UtilTableExists hTable to bTableExists
81692>>>>>>>>>            If (bTableExists = True) Begin
81694>>>>>>>>>                Get _SqlUtilUpdateIntFile hTable to bOK
81695>>>>>>>>>            End
81695>>>>>>>>>>
81695>>>>>>>>>            Else Begin
81696>>>>>>>>>                Get pbToANSI to bANSI
81697>>>>>>>>>                Get _SqlUtilCreateIntFile hTable APITableNameInfoFrom.sDriverID sConnectionID bANSI False to bOK
81698>>>>>>>>>            End
81698>>>>>>>>>>
81698>>>>>>>>>        End
81698>>>>>>>>>>
81698>>>>>>>>>
81698>>>>>>>>>        Function_Return bOK
81699>>>>>>>>>    End_Function
81700>>>>>>>>>
81700>>>>>>>>>    // The table must already exist in the filelist for this function to work.
81700>>>>>>>>>    // It creates a rudimentary .int file in the first Data folder of the psDataPath property.
81700>>>>>>>>>    Function _SqlUtilCreateIntFile Handle hTable String sDriverID String sConnectionID Boolean bAnsi Boolean bSysFile Returns Boolean
81702>>>>>>>>>        Boolean bOK bExists bUseConnectionID 
81702>>>>>>>>>        String sDataPath sRootName sLogicalName sPhysicalFileName sConnectionString sDatabaseName sSchemaName sANSI_OEM
81702>>>>>>>>>        String[] sIndexArray
81703>>>>>>>>>        Integer iCount iCh iSize
81703>>>>>>>>>
81703>>>>>>>>>        Move (Trim(sConnectionID) <> "") to bUseConnectionID
81704>>>>>>>>>        Get psConnectionString to sConnectionString
81705>>>>>>>>>
81705>>>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
81706>>>>>>>>>        If (bANSI = False) Begin
81708>>>>>>>>>            Move CS_OEM_Txt to sANSI_OEM
81709>>>>>>>>>        End
81709>>>>>>>>>>
81709>>>>>>>>>
81709>>>>>>>>>        Get psDataPathFirstPart to sDataPath
81710>>>>>>>>>        Get vFolderExists sDataPath to bOK
81711>>>>>>>>>        If (bOK = False) Begin
81713>>>>>>>>>            Error DFERR_PROGRAM "Function _SqlUtilCreateIntFile; psDataPath not found!"
81714>>>>>>>>>>
81714>>>>>>>>>            Function_Return False
81715>>>>>>>>>        End
81715>>>>>>>>>>
81715>>>>>>>>>        Get vFolderFormat sDataPath to sDataPath
81716>>>>>>>>>
81716>>>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
81719>>>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
81722>>>>>>>>>        Get _TableNameOnly sRootName to sDatabaseName
81723>>>>>>>>>        Move sLogicalName  to sPhysicalFileName
81724>>>>>>>>>        Move (sPhysicalFileName + ".int") to sPhysicalFileName
81725>>>>>>>>>
81725>>>>>>>>>        Get psSchema hTable to sSchemaName
81726>>>>>>>>>        If (sSchemaName = "") Begin
81728>>>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchemaName
81729>>>>>>>>>        End
81729>>>>>>>>>>
81729>>>>>>>>>
81729>>>>>>>>>        // If the .int file already exists; we rename it to "FileName" + ".bak"
81729>>>>>>>>>        Get vFilePathExists (sDataPath + sPhysicalFileName) to bExists
81730>>>>>>>>>        If (bExists = True) Begin
81732>>>>>>>>>            Get vRenameFile (sDataPath + sPhysicalFileName) (sDataPath + sPhysicalFileName + ".bak") to bOK
81733>>>>>>>>>        End
81733>>>>>>>>>>
81733>>>>>>>>>
81733>>>>>>>>>        Get _UtilDeleteCacheFile sRootName to bOK
81734>>>>>>>>>        Get _SqlUtilEnumerateIndexes sRootName sDriverID to sIndexArray
81735>>>>>>>>>
81735>>>>>>>>>        Get Seq_Open_Output_Channel (sDataPath + sPhysicalFileName) to iCh
81736>>>>>>>>>            Writeln channel iCh CS_DRIVER_NAME     " " sDriverID
81741>>>>>>>>>            If (bUseConnectionID = True) Begin
81743>>>>>>>>>                Writeln channel iCh CS_SERVER_NAME " " CS_DFCONNID "=" sConnectionID
81750>>>>>>>>>            End
81750>>>>>>>>>>
81750>>>>>>>>>            Else Begin
81751>>>>>>>>>                Writeln channel iCh CS_SERVER_NAME " " CS_SERVER "=" sConnectionString
81758>>>>>>>>>            End
81758>>>>>>>>>>
81758>>>>>>>>>            Writeln channel iCh CS_DATABASE_NAME          " " sDatabaseName
81763>>>>>>>>>            Writeln channel iCh CS_SCHEMA_NAME            " " (Lowercase(sSchemaName))
81768>>>>>>>>>            // There seems to be a new order how these are set from DF19.
81768>>>>>>>>>            If (bSysFile = True) Begin
81770>>>>>>>>>                Writeln channel iCh CS_RECNUM_TABLE       " " "NO"
81775>>>>>>>>>            End
81775>>>>>>>>>>
81775>>>>>>>>>            Writeln channel iCh CS_TABLE_CHARACTER_FORMAT " " sANSI_OEM
81780>>>>>>>>>            Writeln channel iCh CS_USE_DUMMY_ZERO_DATE    " " "YES" // ToDo: We maybe need to paramerize this setting?
81785>>>>>>>>>            If (bSysFile = True) Begin
81787>>>>>>>>>                Writeln channel iCh CS_SYSTEM_FILE        " " "YES"
81792>>>>>>>>>            End
81792>>>>>>>>>>
81792>>>>>>>>>
81792>>>>>>>>>            If (bSysFile = False) Begin
81794>>>>>>>>>                Move (SizeOfArray(sIndexArray)) to iSize
81795>>>>>>>>>                Move (SortArray(sIndexArray)) to sIndexArray
81796>>>>>>>>>                If (iSize > 0) Begin
81798>>>>>>>>>                    Writeln channel iCh (CS_PRIMARY_INDEX * String("0"))
81801>>>>>>>>>                    Writeln channel iCh // Just an empty line
81803>>>>>>>>>                End
81803>>>>>>>>>>
81803>>>>>>>>>                Decrement iSize
81804>>>>>>>>>                for iCount from 0 to iSize
81810>>>>>>>>>>
81810>>>>>>>>>                    Writeln channel iCh (CS_INDEX_NUMBER * String(iCount))
81813>>>>>>>>>                    Writeln channel iCh (CS_INDEX_NAME   * String(sIndexArray[iCount]))
81816>>>>>>>>>                    Writeln channel iCh
81818>>>>>>>>>                Loop
81819>>>>>>>>>>
81819>>>>>>>>>            End
81819>>>>>>>>>>
81819>>>>>>>>>        Send Seq_Close_Channel iCh
81820>>>>>>>>>
81820>>>>>>>>>        // Wait a sec for Windows to finish writing the file:
81820>>>>>>>>>        Sleep 1
81821>>>>>>>>>
81821>>>>>>>>>        Function_Return (bOK = True)
81822>>>>>>>>>    End_Function
81823>>>>>>>>>
81823>>>>>>>>>    Function _UtilDeleteCacheFile String sTableName Returns Boolean
81825>>>>>>>>>        String sDataPath sDriverID
81825>>>>>>>>>        Boolean bOK
81825>>>>>>>>>        Integer iPos
81825>>>>>>>>>
81825>>>>>>>>>        If (sTableName contains ".") Begin
81827>>>>>>>>>            Move (Pos(".", sTableName)) to iPos
81828>>>>>>>>>            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
81829>>>>>>>>>        End
81829>>>>>>>>>>
81829>>>>>>>>>
81829>>>>>>>>>        Get psDriverID to sDriverID
81830>>>>>>>>>        Get psDataPathFirstPart to sDataPath
81831>>>>>>>>>        // First delete the cache file:
81831>>>>>>>>>        Get vDeleteFile (sDataPath + sTableName + ".cch") to bOK
81832>>>>>>>>>
81832>>>>>>>>>        Function_Return bOK
81833>>>>>>>>>    End_Function
81834>>>>>>>>>
81834>>>>>>>>>    // Checks that the passed hTable number both exists in Filelist.cfg and
81834>>>>>>>>>    // that the embedded .dat file exists on disk _or_ that the SQL table exists
81834>>>>>>>>>    // if it is an SQL table
81834>>>>>>>>>    Function _UtilTableExists Handle hTable Returns Boolean
81836>>>>>>>>>        Boolean bExists bIsSQLTable
81836>>>>>>>>>        String sDataPath sRootName
81836>>>>>>>>>
81836>>>>>>>>>        Get _UtilTableNumberIsInUse hTable to bExists
81837>>>>>>>>>        If (bExists = False) Begin
81839>>>>>>>>>            Function_Return False
81840>>>>>>>>>        End
81840>>>>>>>>>>
81840>>>>>>>>>
81840>>>>>>>>>        Move False to bIsSQLTable
81841>>>>>>>>>        If (hTable > 0) Begin
81843>>>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
81846>>>>>>>>>            Move (sRootName contains ":") to bIsSQLTable
81847>>>>>>>>>        End
81847>>>>>>>>>>
81847>>>>>>>>>        If (bIsSQLTable = True) Begin
81849>>>>>>>>>            Get _UtilTableIsSql hTable to bExists
81850>>>>>>>>>            Function_Return bExists
81851>>>>>>>>>        End
81851>>>>>>>>>>
81851>>>>>>>>>        Else Begin
81852>>>>>>>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
81853>>>>>>>>>            Get vFolderFormat sDataPath to sDataPath
81854>>>>>>>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bExists
81855>>>>>>>>>        End
81855>>>>>>>>>>
81855>>>>>>>>>
81855>>>>>>>>>        Function_Return bExists
81856>>>>>>>>>    End_Function
81857>>>>>>>>>
81857>>>>>>>>>    // Pass a table handle
81857>>>>>>>>>    // Returns True if the table exists in filelist.cfg.
81857>>>>>>>>>    Function _UtilTableNumberIsInUse Handle hCheckTable Returns Boolean
81859>>>>>>>>>        Handle hTable
81859>>>>>>>>>        Boolean bFound
81859>>>>>>>>>
81859>>>>>>>>>        Move False to bFound
81860>>>>>>>>>        Move 0 to hTable
81861>>>>>>>>>        Repeat
81861>>>>>>>>>>
81861>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
81864>>>>>>>>>            If (hTable > 0) Begin
81866>>>>>>>>>                If (hTable = hCheckTable) Begin
81868>>>>>>>>>                    Move True to bFound
81869>>>>>>>>>                End
81869>>>>>>>>>>
81869>>>>>>>>>            End
81869>>>>>>>>>>
81869>>>>>>>>>            If (bFound = True) ;                Break
81872>>>>>>>>>        Until (hTable = 0)
81874>>>>>>>>>
81874>>>>>>>>>        Function_Return (bFound = True)
81875>>>>>>>>>    End_Function
81876>>>>>>>>>
81876>>>>>>>>>    // DataFlex Embedded Database Data Types:
81876>>>>>>>>>    // Helper function for _UtilEnumerateColumnTypes
81876>>>>>>>>>    Function _UtilEnumerateDataFlexTypes Returns tColumnType[]
81878>>>>>>>>>        tColumnType[] ColumnType
81878>>>>>>>>>        tColumnType[] ColumnType
81879>>>>>>>>>        Integer i
81879>>>>>>>>>
81879>>>>>>>>>        Move DF_ASCII           to ColumnType[i].iSQLType
81880>>>>>>>>>        Move "ASCII"            to ColumnType[i].sSQLType
81881>>>>>>>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
81882>>>>>>>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
81883>>>>>>>>>        Move "254"              to ColumnType[i].sPrecision
81884>>>>>>>>>        Increment i
81885>>>>>>>>>
81885>>>>>>>>>        Move DF_BCD             to ColumnType[i].iSQLType
81886>>>>>>>>>        Move "Numeric"          to ColumnType[i].sSQLType
81887>>>>>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
81888>>>>>>>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
81889>>>>>>>>>        Move "14.8"             to ColumnType[i].sPrecision
81890>>>>>>>>>        Increment i
81891>>>>>>>>>
81891>>>>>>>>>        Move DF_DATE            to ColumnType[i].iSQLType
81892>>>>>>>>>        Move "Date"             to ColumnType[i].sSQLType
81893>>>>>>>>>        Move DF_DATE            to ColumnType[i].iDataFlexType
81894>>>>>>>>>        Move "Date"             to ColumnType[i].sDataFlexType
81895>>>>>>>>>        Move "6.0"              to ColumnType[i].sPrecision
81896>>>>>>>>>        Move True               to ColumnType[i].bCanEditSize
81897>>>>>>>>>        Increment i
81898>>>>>>>>>
81898>>>>>>>>>        Move DF_TEXT            to ColumnType[i].iSQLType
81899>>>>>>>>>        Move "Text"             to ColumnType[i].sSQLType
81900>>>>>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
81901>>>>>>>>>        Move "Text"             to ColumnType[i].sDataFlexType
81902>>>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
81903>>>>>>>>>        Increment i
81904>>>>>>>>>
81904>>>>>>>>>        Move DF_BINARY          to ColumnType[i].iSQLType
81905>>>>>>>>>        Move "Binary"           to ColumnType[i].sSQLType
81906>>>>>>>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
81907>>>>>>>>>        Move "Binary"           to ColumnType[i].sDataFlexType
81908>>>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
81909>>>>>>>>>        Increment i
81910>>>>>>>>>
81910>>>>>>>>>        Move DF_DATETIME        to ColumnType[i].iSQLType
81911>>>>>>>>>        Move "DateTime"         to ColumnType[i].sSQLType
81912>>>>>>>>>        Move DF_DATETIME        to ColumnType[i].iDataFlexType
81913>>>>>>>>>        Move "DateTime"         to ColumnType[i].sDataFlexType
81914>>>>>>>>>        Move "23"               to ColumnType[i].sPrecision
81915>>>>>>>>>        Move True               to ColumnType[i].bCanEditSize
81916>>>>>>>>>        Increment i
81917>>>>>>>>>
81917>>>>>>>>>        Move DF_OVERLAP         to ColumnType[i].iSQLType
81918>>>>>>>>>        Move "Overlap"          to ColumnType[i].sSQLType
81919>>>>>>>>>        Move DF_OVERLAP         to ColumnType[i].iDataFlexType
81920>>>>>>>>>        Move "Overlap"          to ColumnType[i].sDataFlexType
81921>>>>>>>>>        Move "0.0"              to ColumnType[i].sPrecision
81922>>>>>>>>>
81922>>>>>>>>>        Function_Return ColumnType
81923>>>>>>>>>    End_Function
81924>>>>>>>>>
81924>>>>>>>>>    Function _UtilEnumerateDB2Types Returns tColumnType[]
81926>>>>>>>>>        tColumnType[] aColumnType
81926>>>>>>>>>        tColumnType[] aColumnType
81927>>>>>>>>>        Integer i
81927>>>>>>>>>
Including file: DB2_DRV_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DB2_DRV_DriverDef.inc)
81927>>>>>>>>>>// Generated By The Database Update Framework
81927>>>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.1\bin\MSSQLDRV_DriverDef.xml
81927>>>>>>>>>>// Driver COLUMN DATA TYPES
81927>>>>>>>>>>//
81927>>>>>>>>>>// Created: 2019-07-18 18:57:13.935
81927>>>>>>>>>>
81927>>>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
81928>>>>>>>>>>            Move -5                                      to aColumnType[i].iSQLType
81929>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81930>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81931>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
81932>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81933>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
81934>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
81935>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
81936>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
81937>>>>>>>>>>            Increment i
81938>>>>>>>>>>
81938>>>>>>>>>>            Move "binary"                                to aColumnType[i].sSQLType
81939>>>>>>>>>>            Move -2                                      to aColumnType[i].iSQLType
81940>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81941>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81942>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
81943>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81944>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
81945>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81946>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81947>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
81948>>>>>>>>>>            Increment i
81949>>>>>>>>>>
81949>>>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
81950>>>>>>>>>>            Move -7                                      to aColumnType[i].iSQLType
81951>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
81952>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81953>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
81954>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
81955>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
81956>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81957>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81958>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
81959>>>>>>>>>>            Increment i
81960>>>>>>>>>>
81960>>>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
81961>>>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
81962>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81963>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81964>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
81965>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
81966>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
81967>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81968>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81969>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
81970>>>>>>>>>>            Increment i
81971>>>>>>>>>>
81971>>>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
81972>>>>>>>>>>            Move 91                                      to aColumnType[i].iSQLType
81973>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
81974>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81975>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
81976>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
81977>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
81978>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81979>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81980>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
81981>>>>>>>>>>            Increment i
81982>>>>>>>>>>
81982>>>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
81983>>>>>>>>>>            Move 93                                      to aColumnType[i].iSQLType
81984>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
81985>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81986>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
81987>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
81988>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
81989>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
81990>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
81991>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
81992>>>>>>>>>>            Increment i
81993>>>>>>>>>>
81993>>>>>>>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
81994>>>>>>>>>>            Move -200                                    to aColumnType[i].iSQLType
81995>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
81996>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
81997>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
81998>>>>>>>>>>            Move 23                                      to aColumnType[i].iMinSize
81999>>>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
82000>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82001>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82002>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
82003>>>>>>>>>>            Increment i
82004>>>>>>>>>>
82004>>>>>>>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
82005>>>>>>>>>>            Move -155                                    to aColumnType[i].iSQLType
82006>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82007>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82008>>>>>>>>>>            Move 34                                      to aColumnType[i].iDefaultSize
82009>>>>>>>>>>            Move 34                                      to aColumnType[i].iMinSize
82010>>>>>>>>>>            Move 34                                      to aColumnType[i].nMaxSize
82011>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82012>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82013>>>>>>>>>>            Move 34                                      to aColumnType[i].sPrecision
82014>>>>>>>>>>            Increment i
82015>>>>>>>>>>
82015>>>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
82016>>>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
82017>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82018>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82019>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82020>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82021>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82022>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82023>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82024>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82025>>>>>>>>>>            Increment i
82026>>>>>>>>>>
82026>>>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
82027>>>>>>>>>>            Move 6                                       to aColumnType[i].iSQLType
82028>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82029>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82030>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82031>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82032>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82033>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82034>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82035>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82036>>>>>>>>>>            Increment i
82037>>>>>>>>>>
82037>>>>>>>>>>            Move "image"                                 to aColumnType[i].sSQLType
82038>>>>>>>>>>            Move -4                                      to aColumnType[i].iSQLType
82039>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82040>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82041>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82042>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82043>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82044>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82045>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82046>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82047>>>>>>>>>>            Increment i
82048>>>>>>>>>>
82048>>>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
82049>>>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
82050>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82051>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82052>>>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
82053>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82054>>>>>>>>>>            Move 10                                      to aColumnType[i].nMaxSize
82055>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82056>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82057>>>>>>>>>>            Move 10                                      to aColumnType[i].sPrecision
82058>>>>>>>>>>            Increment i
82059>>>>>>>>>>
82059>>>>>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
82060>>>>>>>>>>            Move -204                                    to aColumnType[i].iSQLType
82061>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82062>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82063>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82064>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82065>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82066>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82067>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82068>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82069>>>>>>>>>>            Increment i
82070>>>>>>>>>>
82070>>>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
82071>>>>>>>>>>            Move -8                                      to aColumnType[i].iSQLType
82072>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82073>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82074>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82075>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82076>>>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
82077>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82078>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82079>>>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
82080>>>>>>>>>>            Increment i
82081>>>>>>>>>>
82081>>>>>>>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
82082>>>>>>>>>>            Move -10                                     to aColumnType[i].iSQLType
82083>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82084>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82085>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82086>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82087>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82088>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82089>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82090>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82091>>>>>>>>>>            Increment i
82092>>>>>>>>>>
82092>>>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
82093>>>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
82094>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82095>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82096>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82097>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82098>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82099>>>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
82100>>>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
82101>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
82102>>>>>>>>>>            Increment i
82103>>>>>>>>>>
82103>>>>>>>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
82104>>>>>>>>>>            Move -9                                      to aColumnType[i].iSQLType
82105>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82106>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82107>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82108>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82109>>>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
82110>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82111>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82112>>>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
82113>>>>>>>>>>            Increment i
82114>>>>>>>>>>
82114>>>>>>>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
82115>>>>>>>>>>            Move -202                                    to aColumnType[i].iSQLType
82116>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82117>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82118>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82119>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82120>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82121>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82122>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82123>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82124>>>>>>>>>>            Increment i
82125>>>>>>>>>>
82125>>>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
82126>>>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
82127>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82128>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82129>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82130>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82131>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82132>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82133>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82134>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82135>>>>>>>>>>            Increment i
82136>>>>>>>>>>
82136>>>>>>>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
82137>>>>>>>>>>            Move -206                                    to aColumnType[i].iSQLType
82138>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82139>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82140>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82141>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82142>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82143>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82144>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82145>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82146>>>>>>>>>>            Increment i
82147>>>>>>>>>>
82147>>>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
82148>>>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
82149>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82150>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82151>>>>>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
82152>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82153>>>>>>>>>>            Move 5                                       to aColumnType[i].nMaxSize
82154>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82155>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82156>>>>>>>>>>            Move 5                                       to aColumnType[i].sPrecision
82157>>>>>>>>>>            Increment i
82158>>>>>>>>>>
82158>>>>>>>>>>            Move "smallmoney"                            to aColumnType[i].sSQLType
82159>>>>>>>>>>            Move -205                                    to aColumnType[i].iSQLType
82160>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82161>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82162>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82163>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82164>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82165>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82166>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82167>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82168>>>>>>>>>>            Increment i
82169>>>>>>>>>>
82169>>>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
82170>>>>>>>>>>            Move -1                                      to aColumnType[i].iSQLType
82171>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82172>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82173>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82174>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82175>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82176>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82177>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82178>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82179>>>>>>>>>>            Increment i
82180>>>>>>>>>>
82180>>>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
82181>>>>>>>>>>            Move -154                                    to aColumnType[i].iSQLType
82182>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82183>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82184>>>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
82185>>>>>>>>>>            Move 10                                      to aColumnType[i].iMinSize
82186>>>>>>>>>>            Move 19                                      to aColumnType[i].nMaxSize
82187>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82188>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82189>>>>>>>>>>            Move 19                                      to aColumnType[i].sPrecision
82190>>>>>>>>>>            Increment i
82191>>>>>>>>>>
82191>>>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
82192>>>>>>>>>>            Move -6                                      to aColumnType[i].iSQLType
82193>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82194>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82195>>>>>>>>>>            Move 3                                       to aColumnType[i].iDefaultSize
82196>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82197>>>>>>>>>>            Move 3                                       to aColumnType[i].nMaxSize
82198>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82199>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82200>>>>>>>>>>            Move 3                                       to aColumnType[i].sPrecision
82201>>>>>>>>>>            Increment i
82202>>>>>>>>>>
82202>>>>>>>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
82203>>>>>>>>>>            Move -11                                     to aColumnType[i].iSQLType
82204>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82205>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82206>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82207>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82208>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82209>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82210>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82211>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82212>>>>>>>>>>            Increment i
82213>>>>>>>>>>
82213>>>>>>>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
82214>>>>>>>>>>            Move -3                                      to aColumnType[i].iSQLType
82215>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82216>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82217>>>>>>>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
82218>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82219>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
82220>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82221>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82222>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
82223>>>>>>>>>>            Increment i
82224>>>>>>>>>>
82224>>>>>>>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
82225>>>>>>>>>>            Move -203                                    to aColumnType[i].iSQLType
82226>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82227>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82228>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82229>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82230>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82231>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82232>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82233>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82234>>>>>>>>>>            Increment i
82235>>>>>>>>>>
82235>>>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
82236>>>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
82237>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82238>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82239>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82240>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82241>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
82242>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82243>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82244>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
82245>>>>>>>>>>            Increment i
82246>>>>>>>>>>
82246>>>>>>>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
82247>>>>>>>>>>            Move -201                                    to aColumnType[i].iSQLType
82248>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82249>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82250>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82251>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82252>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82253>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82254>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82255>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82256>>>>>>>>>>            Increment i
82257>>>>>>>>>>
82257>>>>>>>>>>            Move "xml"                                   to aColumnType[i].sSQLType
82258>>>>>>>>>>            Move -152                                    to aColumnType[i].iSQLType
82259>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82260>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82261>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82262>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82263>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82264>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82265>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82266>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82267>>>>>>>>>>            Increment i
82268>>>>>>>>>>
82268>>>>>>>>>>
82268>>>>>>>>>//        Move SQL_DBCLOB         to ColumnType[i].iSQLType
82268>>>>>>>>>//        Move "DBCLOB"           to ColumnType[i].sSQLType
82268>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82268>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82268>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82268>>>>>>>>>//        Increment i
82268>>>>>>>>>//
82268>>>>>>>>>//        Move SQL_BIGINT         to ColumnType[i].iSQLType
82268>>>>>>>>>//        Move "BIGINT"           to ColumnType[i].sSQLType
82268>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82268>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82268>>>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
82268>>>>>>>>>//        Increment i
82268>>>>>>>>>//
82268>>>>>>>>>//        Move SQL_BLOB           to ColumnType[i].iSQLType
82268>>>>>>>>>//        Move "BLOB"             to ColumnType[i].sSQLType
82268>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82268>>>>>>>>>//        Move "BINARY"           to ColumnType[i].sDataFlexType
82268>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82268>>>>>>>>>//        Increment i
82268>>>>>>>>>//
82268>>>>>>>>>//        Move SQL_CHAR           to ColumnType[i].iSQLType
82268>>>>>>>>>//        Move "CHAR"             to ColumnType[i].sSQLType
82268>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82268>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82268>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
82268>>>>>>>>>//        Increment i
82268>>>>>>>>>//
82268>>>>>>>>>//        // ToDo: We need to change the sType when using this!
82268>>>>>>>>>//        Move SQL_CHARBIT            to ColumnType[i].iSQLType
82268>>>>>>>>>//        Move "CHAR FOR BIT DATA"    to ColumnType[i].sSQLType
82268>>>>>>>>>//        Move DF_BINARY              to ColumnType[i].iDataFlexType
82268>>>>>>>>>//        Move "Binary"               to ColumnType[i].sDataFlexType
82268>>>>>>>>>//        Move "254"                  to ColumnType[i].sPrecision
82268>>>>>>>>>//        Increment i
82268>>>>>>>>>//
82268>>>>>>>>>//        Move SQL_DATE           to ColumnType[i].iSQLType
82268>>>>>>>>>//        Move "DATE"             to ColumnType[i].sSQLType
82268>>>>>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
82268>>>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
82268>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
82268>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82268>>>>>>>>>//        Increment i
82268>>>>>>>>>//
82268>>>>>>>>>//        Move SQL_CLOB           to ColumnType[i].iSQLType
82268>>>>>>>>>//        Move "CLOB"             to ColumnType[i].sSQLType
82268>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82268>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82268>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82268>>>>>>>>>//        Increment i
82268>>>>>>>>>//
82268>>>>>>>>>//        Move SQL_DECIMAL        to ColumnType[i].iSQLType
82268>>>>>>>>>//        Move "DECIMAL"          to ColumnType[i].sSQLType
82268>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82268>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82268>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82268>>>>>>>>>//        Increment i
82268>>>>>>>>>//
82268>>>>>>>>>//        Move SQL_DOUBLE         to ColumnType[i].iSQLType
82268>>>>>>>>>//        Move "DOUBLE"           to ColumnType[i].sSQLType
82268>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82268>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82268>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82268>>>>>>>>>//        Increment i
82268>>>>>>>>>//
82268>>>>>>>>>//        Move SQL_FLOAT          to ColumnType[i].iSQLType
82268>>>>>>>>>//        Move "FLOAT"            to ColumnType[i].sSQLType
82268>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82268>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82268>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82268>>>>>>>>>//        Increment i
82268>>>>>>>>>//
82268>>>>>>>>>//        Move SQL_GRAPHIC        to ColumnType[i].iSQLType
82268>>>>>>>>>//        Move "GRAPHIC"          to ColumnType[i].sSQLType
82268>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82268>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82268>>>>>>>>>//        Move "255"              to ColumnType[i].sPrecision
82268>>>>>>>>>//        Increment i
82268>>>>>>>>>//
82268>>>>>>>>>//        Move SQL_INTEGER        to ColumnType[i].iSQLType
82268>>>>>>>>>//        Move "INTEGER"          to ColumnType[i].sSQLType
82268>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82268>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82268>>>>>>>>>//        Move "9.0"              to ColumnType[i].sPrecision
82268>>>>>>>>>//        Increment i
82268>>>>>>>>>//
82268>>>>>>>>>//        Move SQL_LONGVARCHAR    to ColumnType[i].iSQLType
82268>>>>>>>>>//        Move "LONG VARCHAR"     to ColumnType[i].sSQLType
82268>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82268>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82268>>>>>>>>>//        Move "32000"            to ColumnType[i].sPrecision
82268>>>>>>>>>//        Increment i
82268>>>>>>>>>//
82268>>>>>>>>>//        Move SQL_LONGVARCHARBIT to ColumnType[i].iSQLType
82268>>>>>>>>>//        Move "LONG VARCHAR BIT" to ColumnType[i].sSQLType
82268>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82268>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82268>>>>>>>>>//        Move "32000"            to ColumnType[i].sPrecision
82268>>>>>>>>>//        Increment i
82268>>>>>>>>>//
82268>>>>>>>>>//        Move SQL_LONGVARGRAPHIC to ColumnType[i].iSQLType
82268>>>>>>>>>//        Move "LONG VARGRAPHIC"  to ColumnType[i].sSQLType
82268>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82268>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82268>>>>>>>>>//        Move "32000"            to ColumnType[i].sPrecision
82268>>>>>>>>>//        Increment i
82268>>>>>>>>>//
82268>>>>>>>>>//        Move SQL_NUMERIC        to ColumnType[i].iSQLType
82268>>>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sSQLType
82268>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82268>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82268>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82268>>>>>>>>>//        Increment i
82268>>>>>>>>>//
82268>>>>>>>>>//        Move SQL_REAL           to ColumnType[i].iSQLType
82268>>>>>>>>>//        Move "REAL"             to ColumnType[i].sSQLType
82268>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82268>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82268>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82268>>>>>>>>>//        Increment i
82268>>>>>>>>>//
82268>>>>>>>>>//        Move SQL_SMALLINT       to ColumnType[i].iSQLType
82268>>>>>>>>>//        Move "SMALLINT"         to ColumnType[i].sSQLType
82268>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82268>>>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
82268>>>>>>>>>//        Move "5.0"              to ColumnType[i].sPrecision
82268>>>>>>>>>//        Increment i
82268>>>>>>>>>//
82268>>>>>>>>>//        Move SQL_TIME           to ColumnType[i].iSQLType
82268>>>>>>>>>//        Move "TIME"             to ColumnType[i].sSQLType
82268>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82268>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82268>>>>>>>>>//        Move "19.0"             to ColumnType[i].sPrecision
82268>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82268>>>>>>>>>//        Increment i
82268>>>>>>>>>//
82268>>>>>>>>>//        Move SQL_TIMESTAMP      to ColumnType[i].iSQLType
82268>>>>>>>>>//        Move "TIMESTAMP"        to ColumnType[i].sSQLType
82268>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
82268>>>>>>>>>//        Move "DATETIME"         to ColumnType[i].sDataFlexType
82268>>>>>>>>>//        Move "23.6"             to ColumnType[i].sPrecision
82268>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82268>>>>>>>>>//        Increment i
82268>>>>>>>>>//
82268>>>>>>>>>//        Move SQL_VARCHAR        to ColumnType[i].iSQLType
82268>>>>>>>>>//        Move "VARCHAR"          to ColumnType[i].sSQLType
82268>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82268>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82268>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82268>>>>>>>>>//        Increment i
82268>>>>>>>>>//
82268>>>>>>>>>//        // ToDo: We need to change the sType when using this!
82268>>>>>>>>>//        Move SQL_VARCHARBIT         to ColumnType[i].iSQLType
82268>>>>>>>>>//        Move "VARCHAR FOR BIT DATA" to ColumnType[i].sSQLType
82268>>>>>>>>>//        Move DF_TEXT                to ColumnType[i].iDataFlexType
82268>>>>>>>>>//        Move "TEXT"                 to ColumnType[i].sDataFlexType
82268>>>>>>>>>//        Move "16384"                to ColumnType[i].sPrecision
82268>>>>>>>>>//        Increment i
82268>>>>>>>>>//
82268>>>>>>>>>//        Move SQL_VARGRAPHIC     to ColumnType[i].iSQLType
82268>>>>>>>>>//        Move "VARGRAPHIC"       to ColumnType[i].sSQLType
82268>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82268>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82268>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82268>>>>>>>>>//
82268>>>>>>>>>//        Move SQL_XML            to ColumnType[i].iSQLType
82268>>>>>>>>>//        Move "XML"              to ColumnType[i].sSQLType
82268>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82268>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82268>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82268>>>>>>>>>
82268>>>>>>>>>        Function_Return aColumnType
82269>>>>>>>>>    End_Function
82270>>>>>>>>>
82270>>>>>>>>>    // Microsoft SQL Server Database Data Types:
82270>>>>>>>>>    // Helper function for _UtilEnumerateColumnTypes
82270>>>>>>>>>    Function _UtilEnumerateMSSQLTypes String sDriverID Returns tColumnType[]
82272>>>>>>>>>        tColumnType[] aColumnType
82272>>>>>>>>>        tColumnType[] aColumnType
82273>>>>>>>>>        Integer i
82273>>>>>>>>>
82273>>>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
Including file: MSSQLDRV_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\MSSQLDRV_DriverDef.inc)
82275>>>>>>>>>>// Generated By The Database Update Framework
82275>>>>>>>>>>// Driver XML File: C:\Program Files\DataFlex 20.0\Lib\MSSQLDRV_DriverDef.xml
82275>>>>>>>>>>// Driver COLUMN DATA TYPES
82275>>>>>>>>>>//
82275>>>>>>>>>>// Created: 2019-11-15 21:57:51.001
82275>>>>>>>>>>
82275>>>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
82276>>>>>>>>>>            Move -5                                      to aColumnType[i].iSQLType
82277>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82278>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82279>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82280>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82281>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82282>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82283>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82284>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82285>>>>>>>>>>            Increment i
82286>>>>>>>>>>
82286>>>>>>>>>>            Move "binary"                                to aColumnType[i].sSQLType
82287>>>>>>>>>>            Move -2                                      to aColumnType[i].iSQLType
82288>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82289>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82290>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82291>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82292>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
82293>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82294>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82295>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
82296>>>>>>>>>>            Increment i
82297>>>>>>>>>>
82297>>>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
82298>>>>>>>>>>            Move -7                                      to aColumnType[i].iSQLType
82299>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82300>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82301>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82302>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82303>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82304>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82305>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82306>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82307>>>>>>>>>>            Increment i
82308>>>>>>>>>>
82308>>>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
82309>>>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
82310>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82311>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82312>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82313>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82314>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
82315>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82316>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82317>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
82318>>>>>>>>>>            Increment i
82319>>>>>>>>>>
82319>>>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
82320>>>>>>>>>>            Move 91                                      to aColumnType[i].iSQLType
82321>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82322>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82323>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82324>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82325>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82326>>>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
82327>>>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
82328>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
82329>>>>>>>>>>            Increment i
82330>>>>>>>>>>
82330>>>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
82331>>>>>>>>>>            Move 93                                      to aColumnType[i].iSQLType
82332>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82333>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82334>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82335>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82336>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82337>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82338>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82339>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
82340>>>>>>>>>>            Increment i
82341>>>>>>>>>>
82341>>>>>>>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
82342>>>>>>>>>>            Move -200                                    to aColumnType[i].iSQLType
82343>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82344>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82345>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
82346>>>>>>>>>>            Move 23                                      to aColumnType[i].iMinSize
82347>>>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
82348>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82349>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82350>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
82351>>>>>>>>>>            Increment i
82352>>>>>>>>>>
82352>>>>>>>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
82353>>>>>>>>>>            Move -155                                    to aColumnType[i].iSQLType
82354>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82355>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82356>>>>>>>>>>            Move 34                                      to aColumnType[i].iDefaultSize
82357>>>>>>>>>>            Move 34                                      to aColumnType[i].iMinSize
82358>>>>>>>>>>            Move 34                                      to aColumnType[i].nMaxSize
82359>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82360>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82361>>>>>>>>>>            Move 34                                      to aColumnType[i].sPrecision
82362>>>>>>>>>>            Increment i
82363>>>>>>>>>>
82363>>>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
82364>>>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
82365>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82366>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82367>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82368>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82369>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82370>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82371>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82372>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82373>>>>>>>>>>            Increment i
82374>>>>>>>>>>
82374>>>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
82375>>>>>>>>>>            Move 6                                       to aColumnType[i].iSQLType
82376>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82377>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82378>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82379>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82380>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82381>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82382>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82383>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82384>>>>>>>>>>            Increment i
82385>>>>>>>>>>
82385>>>>>>>>>>            Move "image"                                 to aColumnType[i].sSQLType
82386>>>>>>>>>>            Move -4                                      to aColumnType[i].iSQLType
82387>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82388>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82389>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82390>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82391>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82392>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82393>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82394>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82395>>>>>>>>>>            Increment i
82396>>>>>>>>>>
82396>>>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
82397>>>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
82398>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82399>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82400>>>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
82401>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82402>>>>>>>>>>            Move 10                                      to aColumnType[i].nMaxSize
82403>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82404>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82405>>>>>>>>>>            Move 10                                      to aColumnType[i].sPrecision
82406>>>>>>>>>>            Increment i
82407>>>>>>>>>>
82407>>>>>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
82408>>>>>>>>>>            Move -204                                    to aColumnType[i].iSQLType
82409>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82410>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82411>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82412>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82413>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82414>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82415>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82416>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82417>>>>>>>>>>            Increment i
82418>>>>>>>>>>
82418>>>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
82419>>>>>>>>>>            Move -8                                      to aColumnType[i].iSQLType
82420>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82421>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82422>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82423>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82424>>>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
82425>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82426>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82427>>>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
82428>>>>>>>>>>            Increment i
82429>>>>>>>>>>
82429>>>>>>>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
82430>>>>>>>>>>            Move -10                                     to aColumnType[i].iSQLType
82431>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82432>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82433>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82434>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82435>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82436>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82437>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82438>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82439>>>>>>>>>>            Increment i
82440>>>>>>>>>>
82440>>>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
82441>>>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
82442>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82443>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82444>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82445>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82446>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82447>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82448>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82449>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82450>>>>>>>>>>            Increment i
82451>>>>>>>>>>
82451>>>>>>>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
82452>>>>>>>>>>            Move -9                                      to aColumnType[i].iSQLType
82453>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82454>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82455>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82456>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82457>>>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
82458>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82459>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82460>>>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
82461>>>>>>>>>>            Increment i
82462>>>>>>>>>>
82462>>>>>>>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
82463>>>>>>>>>>            Move -202                                    to aColumnType[i].iSQLType
82464>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82465>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82466>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82467>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82468>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82469>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82470>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82471>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82472>>>>>>>>>>            Increment i
82473>>>>>>>>>>
82473>>>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
82474>>>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
82475>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82476>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82477>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82478>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82479>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82480>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82481>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82482>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82483>>>>>>>>>>            Increment i
82484>>>>>>>>>>
82484>>>>>>>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
82485>>>>>>>>>>            Move -206                                    to aColumnType[i].iSQLType
82486>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82487>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82488>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82489>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82490>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82491>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82492>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82493>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82494>>>>>>>>>>            Increment i
82495>>>>>>>>>>
82495>>>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
82496>>>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
82497>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82498>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82499>>>>>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
82500>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82501>>>>>>>>>>            Move 5                                       to aColumnType[i].nMaxSize
82502>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82503>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82504>>>>>>>>>>            Move 5                                       to aColumnType[i].sPrecision
82505>>>>>>>>>>            Increment i
82506>>>>>>>>>>
82506>>>>>>>>>>            Move "smallmoney"                            to aColumnType[i].sSQLType
82507>>>>>>>>>>            Move -205                                    to aColumnType[i].iSQLType
82508>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82509>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82510>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82511>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82512>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82513>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82514>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82515>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82516>>>>>>>>>>            Increment i
82517>>>>>>>>>>
82517>>>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
82518>>>>>>>>>>            Move -1                                      to aColumnType[i].iSQLType
82519>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82520>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82521>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82522>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82523>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82524>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82525>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82526>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82527>>>>>>>>>>            Increment i
82528>>>>>>>>>>
82528>>>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
82529>>>>>>>>>>            Move -154                                    to aColumnType[i].iSQLType
82530>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82531>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82532>>>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
82533>>>>>>>>>>            Move 10                                      to aColumnType[i].iMinSize
82534>>>>>>>>>>            Move 19                                      to aColumnType[i].nMaxSize
82535>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82536>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82537>>>>>>>>>>            Move 19                                      to aColumnType[i].sPrecision
82538>>>>>>>>>>            Increment i
82539>>>>>>>>>>
82539>>>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
82540>>>>>>>>>>            Move -6                                      to aColumnType[i].iSQLType
82541>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82542>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82543>>>>>>>>>>            Move 3                                       to aColumnType[i].iDefaultSize
82544>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82545>>>>>>>>>>            Move 3                                       to aColumnType[i].nMaxSize
82546>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82547>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82548>>>>>>>>>>            Move 3                                       to aColumnType[i].sPrecision
82549>>>>>>>>>>            Increment i
82550>>>>>>>>>>
82550>>>>>>>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
82551>>>>>>>>>>            Move -11                                     to aColumnType[i].iSQLType
82552>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82553>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82554>>>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
82555>>>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
82556>>>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
82557>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82558>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82559>>>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
82560>>>>>>>>>>            Increment i
82561>>>>>>>>>>
82561>>>>>>>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
82562>>>>>>>>>>            Move -3                                      to aColumnType[i].iSQLType
82563>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82564>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82565>>>>>>>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
82566>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82567>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
82568>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82569>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82570>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
82571>>>>>>>>>>            Increment i
82572>>>>>>>>>>
82572>>>>>>>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
82573>>>>>>>>>>            Move -203                                    to aColumnType[i].iSQLType
82574>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82575>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82576>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82577>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82578>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82579>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82580>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82581>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82582>>>>>>>>>>            Increment i
82583>>>>>>>>>>
82583>>>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
82584>>>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
82585>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82586>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82587>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82588>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82589>>>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
82590>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82591>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82592>>>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
82593>>>>>>>>>>            Increment i
82594>>>>>>>>>>
82594>>>>>>>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
82595>>>>>>>>>>            Move -201                                    to aColumnType[i].iSQLType
82596>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82597>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82598>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82599>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82600>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82601>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82602>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82603>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82604>>>>>>>>>>            Increment i
82605>>>>>>>>>>
82605>>>>>>>>>>            Move "xml"                                   to aColumnType[i].sSQLType
82606>>>>>>>>>>            Move -152                                    to aColumnType[i].iSQLType
82607>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82608>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82609>>>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
82610>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82611>>>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
82612>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82613>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82614>>>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
82615>>>>>>>>>>            Increment i
82616>>>>>>>>>>
82616>>>>>>>>>>
82616>>>>>>>>>
82616>>>>>>>>>//            Move SQL_BIGINT         to ColumnType[i].iSQLType
82616>>>>>>>>>//            Move "bigint"           to ColumnType[i].sSQLType
82616>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82616>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82616>>>>>>>>>//            Move "14.0"             to ColumnType[i].sPrecision
82616>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82616>>>>>>>>>//            Increment i
82616>>>>>>>>>//
82616>>>>>>>>>//            Move SQL_BINARY         to ColumnType[i].iSQLType
82616>>>>>>>>>//            Move "binary"           to ColumnType[i].sSQLType
82616>>>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
82616>>>>>>>>>//            Move "Binary"           to ColumnType[i].sDataFlexType
82616>>>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
82616>>>>>>>>>//            Increment i
82616>>>>>>>>>//
82616>>>>>>>>>//            Move SQL_BIT            to ColumnType[i].iSQLType
82616>>>>>>>>>//            Move "bit"              to ColumnType[i].sSQLType
82616>>>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
82616>>>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
82616>>>>>>>>>//            Move "1.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
82616>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82616>>>>>>>>>//            Increment i
82616>>>>>>>>>//
82616>>>>>>>>>//            Move SQL_CHAR           to ColumnType[i].iSQLType
82616>>>>>>>>>//            Move "char"             to ColumnType[i].sSQLType
82616>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82616>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82616>>>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
82616>>>>>>>>>//            Increment i
82616>>>>>>>>>//
82616>>>>>>>>>//            Move SQL_DATE           to ColumnType[i].iSQLType
82616>>>>>>>>>//            Move "date"             to ColumnType[i].sSQLType
82616>>>>>>>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
82616>>>>>>>>>//            Move "Date"             to ColumnType[i].sDataFlexType
82616>>>>>>>>>//            Move "6.0"              to ColumnType[i].sPrecision
82616>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82616>>>>>>>>>//            Increment i
82616>>>>>>>>>//
82616>>>>>>>>>//            Move SQL_DATETIME       to ColumnType[i].iSQLType
82616>>>>>>>>>//            Move "datetime"         to ColumnType[i].sSQLType
82616>>>>>>>>>//            Move DF_DATETIME        to ColumnType[i].iDataFlexType
82616>>>>>>>>>//            Move "DateTime"         to ColumnType[i].sDataFlexType
82616>>>>>>>>>//            Move "23.3"             to ColumnType[i].sPrecision
82616>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82616>>>>>>>>>//            Increment i
82616>>>>>>>>>//
82616>>>>>>>>>//            Move SQL_TYPE_TIMESTAMP2 to ColumnType[i].iSQLType
82616>>>>>>>>>//            Move "datetime2"         to ColumnType[i].sSQLType
82616>>>>>>>>>//            Move DF_DATETIME         to ColumnType[i].iDataFlexType
82616>>>>>>>>>//            Move "DateTime"          to ColumnType[i].sDataFlexType
82616>>>>>>>>>//            Move "23.6"              to ColumnType[i].sPrecision
82616>>>>>>>>>//            Move True                to ColumnType[i].bCanEditSize
82616>>>>>>>>>//            Increment i
82616>>>>>>>>>//
82616>>>>>>>>>//            Move SQL_SS_TIMESTAMPOFFSET to ColumnType[i].iSQLType
82616>>>>>>>>>//            Move "datetimeoffset"       to ColumnType[i].sSQLType
82616>>>>>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
82616>>>>>>>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
82616>>>>>>>>>//            Move "34.0"                 to ColumnType[i].sPrecision
82616>>>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
82616>>>>>>>>>//            Increment i
82616>>>>>>>>>//
82616>>>>>>>>>//            Move SQL_DECIMAL        to ColumnType[i].iSQLType
82616>>>>>>>>>//            Move "decimal"          to ColumnType[i].sSQLType
82616>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82616>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82616>>>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
82616>>>>>>>>>//            Increment i
82616>>>>>>>>>//
82616>>>>>>>>>//            Move SQL_FLOAT          to ColumnType[i].iSQLType
82616>>>>>>>>>//            Move "float"            to ColumnType[i].sSQLType
82616>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82616>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82616>>>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
82616>>>>>>>>>//            Increment i
82616>>>>>>>>>//
82616>>>>>>>>>//            Move SQL_INTEGER        to ColumnType[i].iSQLType
82616>>>>>>>>>//            Move "int"              to ColumnType[i].sSQLType
82616>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82616>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82616>>>>>>>>>//            Move "8.0"              to ColumnType[i].sPrecision
82616>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82616>>>>>>>>>//            Increment i
82616>>>>>>>>>//
82616>>>>>>>>>//            Move SQL_TYPE_MONEY     to ColumnType[i].iSQLType
82616>>>>>>>>>//            Move "money"            to ColumnType[i].sSQLType
82616>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82616>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82616>>>>>>>>>//            Move "15.4"             to ColumnType[i].sPrecision // Studio 18.0 (!)
82616>>>>>>>>>//            Increment i
82616>>>>>>>>>//
82616>>>>>>>>>//            Move SQL_WCHAR          to ColumnType[i].iSQLType
82616>>>>>>>>>//            Move "nchar"            to ColumnType[i].sSQLType
82616>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82616>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82616>>>>>>>>>//            Move "4000"             to ColumnType[i].sPrecision
82616>>>>>>>>>//            Increment i
82616>>>>>>>>>//
82616>>>>>>>>>//            Move SQL_WLONGVARCHAR   to ColumnType[i].iSQLType
82616>>>>>>>>>//            Move "ntext"            to ColumnType[i].sSQLType
82616>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82616>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82616>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82616>>>>>>>>>//            Increment i
82616>>>>>>>>>//
82616>>>>>>>>>//            Move SQL_NUMERIC        to ColumnType[i].iSQLType
82616>>>>>>>>>//            Move "numeric"          to ColumnType[i].sSQLType
82616>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82616>>>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
82616>>>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
82616>>>>>>>>>//            Increment i
82616>>>>>>>>>//
82616>>>>>>>>>//            Move SQL_WVARCHAR       to ColumnType[i].iSQLType
82616>>>>>>>>>//            Move "nvarchar"         to ColumnType[i].sSQLType
82616>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82616>>>>>>>>>//            Move "Text"             to ColumnType[i].sDataFlexType
82616>>>>>>>>>//            Move "4000"             to ColumnType[i].sPrecision
82616>>>>>>>>>//            Increment i
82616>>>>>>>>>//
82616>>>>>>>>>//            Move SQL_VARCHARMAX     to ColumnType[i].iSQLType
82616>>>>>>>>>//            Move "nvarchar(max)"    to ColumnType[i].sSQLType
82616>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82616>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82616>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82616>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82616>>>>>>>>>//            Increment i
82616>>>>>>>>>//
82616>>>>>>>>>//            Move SQL_REAL           to ColumnType[i].iSQLType
82616>>>>>>>>>//            Move "real"             to ColumnType[i].sSQLType
82616>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82616>>>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
82616>>>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
82616>>>>>>>>>//            Increment i
82616>>>>>>>>>//
82616>>>>>>>>>//            Move SQL_TYPE_SMALLDATETIME to ColumnType[i].iSQLType
82616>>>>>>>>>//            Move "smalldatetime"        to ColumnType[i].sSQLType
82616>>>>>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
82616>>>>>>>>>//            Move "DATETIME"             to ColumnType[i].sDataFlexType
82616>>>>>>>>>//            Move "23.0"                 to ColumnType[i].sPrecision
82616>>>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
82616>>>>>>>>>//            Increment i
82616>>>>>>>>>//
82616>>>>>>>>>//            Move SQL_SMALLINT       to ColumnType[i].iSQLType
82616>>>>>>>>>//            Move "smallint"         to ColumnType[i].sSQLType
82616>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82616>>>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
82616>>>>>>>>>//            Move "4.0"              to ColumnType[i].sPrecision
82616>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82616>>>>>>>>>//            Increment i
82616>>>>>>>>>//
82616>>>>>>>>>//            Move SQL_TYPE_SMALLMONEY to ColumnType[i].iSQLType
82616>>>>>>>>>//            Move "smallmoney"        to ColumnType[i].sSQLType
82616>>>>>>>>>//            Move DF_BCD              to ColumnType[i].iDataFlexType
82616>>>>>>>>>//            Move "NUMERIC"           to ColumnType[i].sDataFlexType
82616>>>>>>>>>//            Move "10.0"              to ColumnType[i].sPrecision
82616>>>>>>>>>//            Increment i
82616>>>>>>>>>//
82616>>>>>>>>>//            Move SQL_TEXT           to ColumnType[i].iSQLType
82616>>>>>>>>>//            Move "text"             to ColumnType[i].sSQLType
82616>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82616>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82616>>>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
82616>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82616>>>>>>>>>//            Increment i
82616>>>>>>>>>//
82616>>>>>>>>>//            Move SQL_TIME           to ColumnType[i].iSQLType
82616>>>>>>>>>//            Move "time"             to ColumnType[i].sSQLType
82616>>>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
82616>>>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
82616>>>>>>>>>//            Move "19.0"             to ColumnType[i].sPrecision
82616>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82616>>>>>>>>>//            Increment i
82616>>>>>>>>>//
82616>>>>>>>>>//            Move SQL_TINYINT        to ColumnType[i].iSQLType
82616>>>>>>>>>//            Move "tinyint"          to ColumnType[i].sSQLType
82616>>>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
82616>>>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
82616>>>>>>>>>//            Move "2.0"              to ColumnType[i].sPrecision
82616>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82616>>>>>>>>>//            Increment i
82616>>>>>>>>>//
82616>>>>>>>>>//            Move SQL_GUID           to ColumnType[i].iSQLType
82616>>>>>>>>>//            Move "uniqueidentifier" to ColumnType[i].sSQLType
82616>>>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
82616>>>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
82616>>>>>>>>>//            Move "36"               to ColumnType[i].sPrecision
82616>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82616>>>>>>>>>//            Increment i
82616>>>>>>>>>//
82616>>>>>>>>>//            Move SQL_VARBINARY      to ColumnType[i].iSQLType
82616>>>>>>>>>//            Move "varbinary"        to ColumnType[i].sSQLType
82616>>>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
82616>>>>>>>>>//            Move "BINARY"           to ColumnType[i].sDataFlexType
82616>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82616>>>>>>>>>//            Increment i
82616>>>>>>>>>//
82616>>>>>>>>>//            Move SQL_LONGVARBINARY  to ColumnType[i].iSQLType
82616>>>>>>>>>//            Move "varbinary(max)"   to ColumnType[i].sSQLType
82616>>>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
82616>>>>>>>>>//            Move "BINARY"           to ColumnType[i].sDataFlexType
82616>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82616>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82616>>>>>>>>>//            Increment i
82616>>>>>>>>>//
82616>>>>>>>>>//            Move SQL_VARCHAR        to ColumnType[i].iSQLType
82616>>>>>>>>>//            Move "varchar"          to ColumnType[i].sSQLType
82616>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType // ToDo: Under 255 = ASCII type! How to deal with this?
82616>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82616>>>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
82616>>>>>>>>>//            Increment i
82616>>>>>>>>>//
82616>>>>>>>>>//            Move SQL_LONGVARCHAR    to ColumnType[i].iSQLType
82616>>>>>>>>>//            Move "varchar(max)"     to ColumnType[i].sSQLType
82616>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82616>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82616>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82616>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82616>>>>>>>>>//            Increment i
82616>>>>>>>>>//
82616>>>>>>>>>//            Move SQL_SS_XML         to ColumnType[i].iSQLType
82616>>>>>>>>>//            Move "xml"              to ColumnType[i].sSQLType
82616>>>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
82616>>>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
82616>>>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
82616>>>>>>>>>//            Increment i
82616>>>>>>>>>//
82616>>>>>>>>>//            Move SQL_TYPE_DATE      to ColumnType[i].iSQLType
82616>>>>>>>>>//            Move "DATE"             to ColumnType[i].sSQLType
82616>>>>>>>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
82616>>>>>>>>>//            Move "date"             to ColumnType[i].sDataFlexType
82616>>>>>>>>>//            Move "6.0"              to ColumnType[i].sPrecision
82616>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82616>>>>>>>>>//            Increment i
82616>>>>>>>>>//
82616>>>>>>>>>//            Move SQL_TYPE_TIME      to ColumnType[i].iSQLType
82616>>>>>>>>>//            Move "time"             to ColumnType[i].sSQLType
82616>>>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
82616>>>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
82616>>>>>>>>>//            Move "8.7"              to ColumnType[i].sPrecision
82616>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82616>>>>>>>>>//            Increment i
82616>>>>>>>>>//
82616>>>>>>>>>//            Move SQL_TYPE_TIMESTAMP to ColumnType[i].iSQLType
82616>>>>>>>>>//            Move "datetime"         to ColumnType[i].sSQLType
82616>>>>>>>>>//            Move DF_DATETIME        to ColumnType[i].iDataFlexType
82616>>>>>>>>>//            Move "DateTime"         to ColumnType[i].sDataFlexType
82616>>>>>>>>>//            Move "23.6"             to ColumnType[i].sPrecision
82616>>>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
82616>>>>>>>>>//            Increment i
82616>>>>>>>>>
82616>>>>>>>>>        End
82616>>>>>>>>>>
82616>>>>>>>>>
82616>>>>>>>>>        Function_Return aColumnType
82617>>>>>>>>>    End_Function
82618>>>>>>>>>
82618>>>>>>>>>    // MySQL Data Types
82618>>>>>>>>>    Function _UtilEnumerateMySQLTypes Returns tColumnType[]
82620>>>>>>>>>        tColumnType[] aColumnType
82620>>>>>>>>>        tColumnType[] aColumnType
82621>>>>>>>>>        Integer i
82621>>>>>>>>>
Including file: mdsmysql_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\mdsmysql_DriverDef.inc)
82621>>>>>>>>>>// Generated By The Database Update Framework
82621>>>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\mdsmysql_DriverDef.xml
82621>>>>>>>>>>// Driver COLUMN DATA TYPES
82621>>>>>>>>>>//
82621>>>>>>>>>>// Created: 2018-03-14 23:46:49.593
82621>>>>>>>>>>
82621>>>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
82622>>>>>>>>>>            Move 8                                       to aColumnType[i].iSQLType
82623>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82624>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82625>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82626>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82627>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82628>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82629>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82630>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82631>>>>>>>>>>            Increment i
82632>>>>>>>>>>
82632>>>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
82633>>>>>>>>>>            Move 16                                      to aColumnType[i].iSQLType
82634>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82635>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82636>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82637>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82638>>>>>>>>>>            Move 64                                      to aColumnType[i].nMaxSize
82639>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82640>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82641>>>>>>>>>>            Move 64                                      to aColumnType[i].sPrecision
82642>>>>>>>>>>            Increment i
82643>>>>>>>>>>
82643>>>>>>>>>>            Move "blob"                                  to aColumnType[i].sSQLType
82644>>>>>>>>>>            Move 252                                     to aColumnType[i].iSQLType
82645>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82646>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82647>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82648>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82649>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82650>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82651>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82652>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82653>>>>>>>>>>            Increment i
82654>>>>>>>>>>
82654>>>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
82655>>>>>>>>>>            Move 254                                     to aColumnType[i].iSQLType
82656>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82657>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82658>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82659>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82660>>>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
82661>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82662>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82663>>>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
82664>>>>>>>>>>            Increment i
82665>>>>>>>>>>
82665>>>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
82666>>>>>>>>>>            Move 10                                      to aColumnType[i].iSQLType
82667>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82668>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82669>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
82670>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82671>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82672>>>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
82673>>>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
82674>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
82675>>>>>>>>>>            Increment i
82676>>>>>>>>>>
82676>>>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
82677>>>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
82678>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82679>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82680>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
82681>>>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
82682>>>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
82683>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82684>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82685>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
82686>>>>>>>>>>            Increment i
82687>>>>>>>>>>
82687>>>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
82688>>>>>>>>>>            Move 246                                     to aColumnType[i].iSQLType
82689>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82690>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82691>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82692>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82693>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82694>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82695>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82696>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82697>>>>>>>>>>            Increment i
82698>>>>>>>>>>
82698>>>>>>>>>>            Move "decimal-MySQL4"                        to aColumnType[i].sSQLType
82699>>>>>>>>>>            Move 0                                       to aColumnType[i].iSQLType
82700>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82701>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82702>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82703>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82704>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82705>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82706>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82707>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82708>>>>>>>>>>            Increment i
82709>>>>>>>>>>
82709>>>>>>>>>>            Move "double"                                to aColumnType[i].sSQLType
82710>>>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
82711>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82712>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82713>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82714>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82715>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82716>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82717>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82718>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82719>>>>>>>>>>            Increment i
82720>>>>>>>>>>
82720>>>>>>>>>>            Move "enum"                                  to aColumnType[i].sSQLType
82721>>>>>>>>>>            Move 247                                     to aColumnType[i].iSQLType
82722>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82723>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82724>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82725>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82726>>>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
82727>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82728>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82729>>>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
82730>>>>>>>>>>            Increment i
82731>>>>>>>>>>
82731>>>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
82732>>>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
82733>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82734>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82735>>>>>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
82736>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82737>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82738>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82739>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82740>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82741>>>>>>>>>>            Increment i
82742>>>>>>>>>>
82742>>>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
82743>>>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
82744>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82745>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82746>>>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
82747>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82748>>>>>>>>>>            Move 11                                      to aColumnType[i].nMaxSize
82749>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82750>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82751>>>>>>>>>>            Move 11                                      to aColumnType[i].sPrecision
82752>>>>>>>>>>            Increment i
82753>>>>>>>>>>
82753>>>>>>>>>>            Move "longblob"                              to aColumnType[i].sSQLType
82754>>>>>>>>>>            Move 251                                     to aColumnType[i].iSQLType
82755>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82756>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82757>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82758>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82759>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82760>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82761>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82762>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82763>>>>>>>>>>            Increment i
82764>>>>>>>>>>
82764>>>>>>>>>>            Move "longtext"                              to aColumnType[i].sSQLType
82765>>>>>>>>>>            Move -251                                    to aColumnType[i].iSQLType
82766>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82767>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82768>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82769>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82770>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82771>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82772>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82773>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82774>>>>>>>>>>            Increment i
82775>>>>>>>>>>
82775>>>>>>>>>>            Move "mediumblob"                            to aColumnType[i].sSQLType
82776>>>>>>>>>>            Move 250                                     to aColumnType[i].iSQLType
82777>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82778>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82779>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82780>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82781>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82782>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82783>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82784>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82785>>>>>>>>>>            Increment i
82786>>>>>>>>>>
82786>>>>>>>>>>            Move "mediumint"                             to aColumnType[i].sSQLType
82787>>>>>>>>>>            Move 9                                       to aColumnType[i].iSQLType
82788>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82789>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82790>>>>>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
82791>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82792>>>>>>>>>>            Move 9                                       to aColumnType[i].nMaxSize
82793>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82794>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82795>>>>>>>>>>            Move 9                                       to aColumnType[i].sPrecision
82796>>>>>>>>>>            Increment i
82797>>>>>>>>>>
82797>>>>>>>>>>            Move "mediumtext"                            to aColumnType[i].sSQLType
82798>>>>>>>>>>            Move -250                                    to aColumnType[i].iSQLType
82799>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82800>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82801>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82802>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82803>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82804>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82805>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82806>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82807>>>>>>>>>>            Increment i
82808>>>>>>>>>>
82808>>>>>>>>>>            Move "set"                                   to aColumnType[i].sSQLType
82809>>>>>>>>>>            Move 248                                     to aColumnType[i].iSQLType
82810>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82811>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82812>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82813>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82814>>>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
82815>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82816>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82817>>>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
82818>>>>>>>>>>            Increment i
82819>>>>>>>>>>
82819>>>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
82820>>>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
82821>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82822>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82823>>>>>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
82824>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82825>>>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
82826>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82827>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82828>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
82829>>>>>>>>>>            Increment i
82830>>>>>>>>>>
82830>>>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
82831>>>>>>>>>>            Move -252                                    to aColumnType[i].iSQLType
82832>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82833>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82834>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82835>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82836>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82837>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82838>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82839>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82840>>>>>>>>>>            Increment i
82841>>>>>>>>>>
82841>>>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
82842>>>>>>>>>>            Move 11                                      to aColumnType[i].iSQLType
82843>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82844>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82845>>>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
82846>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82847>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82848>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82849>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82850>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82851>>>>>>>>>>            Increment i
82852>>>>>>>>>>
82852>>>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
82853>>>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
82854>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82855>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82856>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
82857>>>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
82858>>>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
82859>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82860>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82861>>>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
82862>>>>>>>>>>            Increment i
82863>>>>>>>>>>
82863>>>>>>>>>>            Move "tinyblob"                              to aColumnType[i].sSQLType
82864>>>>>>>>>>            Move 249                                     to aColumnType[i].iSQLType
82865>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82866>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82867>>>>>>>>>>            Move 255                                     to aColumnType[i].iDefaultSize
82868>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82869>>>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
82870>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82871>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82872>>>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
82873>>>>>>>>>>            Increment i
82874>>>>>>>>>>
82874>>>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
82875>>>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
82876>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82877>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82878>>>>>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
82879>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82880>>>>>>>>>>            Move 4                                       to aColumnType[i].nMaxSize
82881>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82882>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82883>>>>>>>>>>            Move 4                                       to aColumnType[i].sPrecision
82884>>>>>>>>>>            Increment i
82885>>>>>>>>>>
82885>>>>>>>>>>            Move "tinytext"                              to aColumnType[i].sSQLType
82886>>>>>>>>>>            Move -249                                    to aColumnType[i].iSQLType
82887>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82888>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82889>>>>>>>>>>            Move 255                                     to aColumnType[i].iDefaultSize
82890>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82891>>>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
82892>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82893>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82894>>>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
82895>>>>>>>>>>            Increment i
82896>>>>>>>>>>
82896>>>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
82897>>>>>>>>>>            Move 253                                     to aColumnType[i].iSQLType
82898>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82899>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82900>>>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
82901>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82902>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82903>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82904>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82905>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82906>>>>>>>>>>            Increment i
82907>>>>>>>>>>
82907>>>>>>>>>>            Move "year"                                  to aColumnType[i].sSQLType
82908>>>>>>>>>>            Move 13                                      to aColumnType[i].iSQLType
82909>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82910>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82911>>>>>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
82912>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82913>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82914>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82915>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82916>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82917>>>>>>>>>>            Increment i
82918>>>>>>>>>>
82918>>>>>>>>>>
82918>>>>>>>>>
82918>>>>>>>>>//        Move eMySQL_LONGLONG    to ColumnType[i].iSQLType
82918>>>>>>>>>//        Move "bigint"           to ColumnType[i].sSQLType
82918>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82918>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82918>>>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
82918>>>>>>>>>//        Increment i
82918>>>>>>>>>//
82918>>>>>>>>>//        Move eMySQL_BIT         to ColumnType[i].iSQLType
82918>>>>>>>>>//        Move "bit"              to ColumnType[i].sSQLType
82918>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82918>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82918>>>>>>>>>//        Move "4.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
82918>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82918>>>>>>>>>//        Increment i
82918>>>>>>>>>//
82918>>>>>>>>>//        Move eMySQL_BLOB        to ColumnType[i].iSQLType
82918>>>>>>>>>//        Move "blob"             to ColumnType[i].sSQLType
82918>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82918>>>>>>>>>//        Move "BINARY"           to ColumnType[i].sDataFlexType
82918>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82918>>>>>>>>>//        Increment i
82918>>>>>>>>>//
82918>>>>>>>>>//        Move eMySQL_STRING      to ColumnType[i].iSQLType
82918>>>>>>>>>//        Move "char"             to ColumnType[i].sSQLType
82918>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82918>>>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
82918>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
82918>>>>>>>>>//        Increment i
82918>>>>>>>>>//
82918>>>>>>>>>//        Move eMySQL_DATE        to ColumnType[i].iSQLType
82918>>>>>>>>>//        Move "date"             to ColumnType[i].sSQLType
82918>>>>>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
82918>>>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
82918>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
82918>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82918>>>>>>>>>//        Increment i
82918>>>>>>>>>//
82918>>>>>>>>>//        Move eMySQL_DATETIME    to ColumnType[i].iSQLType
82918>>>>>>>>>//        Move "datetime"         to ColumnType[i].sSQLType
82918>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
82918>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
82918>>>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
82918>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82918>>>>>>>>>//        Increment i
82918>>>>>>>>>//
82918>>>>>>>>>//        Move eMySQL_DECIMAL     to ColumnType[i].iSQLType
82918>>>>>>>>>//        Move "decimal"          to ColumnType[i].sSQLType
82918>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82918>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82918>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82918>>>>>>>>>//        Increment i
82918>>>>>>>>>//
82918>>>>>>>>>//        Move eMySQL_DOUBLE      to ColumnType[i].iSQLType
82918>>>>>>>>>//        Move "double"           to ColumnType[i].sSQLType
82918>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82918>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82918>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82918>>>>>>>>>//        Increment i
82918>>>>>>>>>//
82918>>>>>>>>>//        Move eMySQL_ENUM        to ColumnType[i].iSQLType
82918>>>>>>>>>//        Move "enum"             to ColumnType[i].sSQLType
82918>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82918>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82918>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
82918>>>>>>>>>//        Increment i
82918>>>>>>>>>//
82918>>>>>>>>>//        Move eMySQL_FLOAT       to ColumnType[i].iSQLType
82918>>>>>>>>>//        Move "float"            to ColumnType[i].sSQLType
82918>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82918>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82918>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
82918>>>>>>>>>//        Increment i
82918>>>>>>>>>//
82918>>>>>>>>>//        Move eMySQL_INT24       to ColumnType[i].iSQLType
82918>>>>>>>>>//        Move "int"              to ColumnType[i].sSQLType
82918>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82918>>>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
82918>>>>>>>>>//        Move "11.0"             to ColumnType[i].sPrecision
82918>>>>>>>>>//        Increment i
82918>>>>>>>>>//
82918>>>>>>>>>//        Move eMySQL_LONG_BLOB   to ColumnType[i].iSQLType
82918>>>>>>>>>//        Move "longblob"         to ColumnType[i].sSQLType
82918>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82918>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
82918>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82918>>>>>>>>>//        Increment i
82918>>>>>>>>>//
82918>>>>>>>>>//        Move eMySQL_LONG_TEXT   to ColumnType[i].iSQLType
82918>>>>>>>>>//        Move "longtext"         to ColumnType[i].sSQLType
82918>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82918>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82918>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82918>>>>>>>>>//        Increment i
82918>>>>>>>>>//
82918>>>>>>>>>//        Move eMySQL_MEDIUM_BLOB to ColumnType[i].iSQLType
82918>>>>>>>>>//        Move "mediumblob"       to ColumnType[i].sSQLType
82918>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82918>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
82918>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82918>>>>>>>>>//        Increment i
82918>>>>>>>>>//
82918>>>>>>>>>//        Move eMySQL_INT24       to ColumnType[i].iSQLType
82918>>>>>>>>>//        Move "mediumint"        to ColumnType[i].sSQLType
82918>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82918>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82918>>>>>>>>>//        Move "9.0"              to ColumnType[i].sPrecision
82918>>>>>>>>>//
82918>>>>>>>>>//        Move eMySQL_MEDIUM_TEXT to ColumnType[i].iSQLType
82918>>>>>>>>>//        Move "mediumtext"       to ColumnType[i].sSQLType
82918>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82918>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82918>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82918>>>>>>>>>//        Increment i
82918>>>>>>>>>//
82918>>>>>>>>>//        Move eMySQL_SET         to ColumnType[i].iSQLType
82918>>>>>>>>>//        Move "set"              to ColumnType[i].sSQLType
82918>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82918>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82918>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
82918>>>>>>>>>//        Increment i
82918>>>>>>>>>//
82918>>>>>>>>>//        Move eMySQL_SHORT       to ColumnType[i].iSQLType
82918>>>>>>>>>//        Move "smallint"         to ColumnType[i].sSQLType
82918>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82918>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82918>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
82918>>>>>>>>>//        Increment i
82918>>>>>>>>>//
82918>>>>>>>>>//        Move eMySQL_TEXT        to ColumnType[i].iSQLType
82918>>>>>>>>>//        Move "text"             to ColumnType[i].sSQLType
82918>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82918>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82918>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82918>>>>>>>>>//        Increment i
82918>>>>>>>>>//
82918>>>>>>>>>//        Move eMySQL_TIME        to ColumnType[i].iSQLType
82918>>>>>>>>>//        Move "time"             to ColumnType[i].sSQLType
82918>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
82918>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
82918>>>>>>>>>//        Move "10.0"             to ColumnType[i].sPrecision
82918>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82918>>>>>>>>>//        Increment i
82918>>>>>>>>>//
82918>>>>>>>>>//        Move eMySQL_TIMESTAMP   to ColumnType[i].iSQLType
82918>>>>>>>>>//        Move "timestamp"        to ColumnType[i].sSQLType
82918>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
82918>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
82918>>>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
82918>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82918>>>>>>>>>//        Increment i
82918>>>>>>>>>//
82918>>>>>>>>>//        Move eMySQL_TINY_BLOB   to ColumnType[i].iSQLType
82918>>>>>>>>>//        Move "tinyblob"         to ColumnType[i].sSQLType
82918>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
82918>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
82918>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
82918>>>>>>>>>//        Increment i
82918>>>>>>>>>//
82918>>>>>>>>>//        Move eMySQL_TINY        to ColumnType[i].iSQLType
82918>>>>>>>>>//        Move "tinyint"          to ColumnType[i].sSQLType
82918>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82918>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
82918>>>>>>>>>//        Move "4.0"              to ColumnType[i].sPrecision
82918>>>>>>>>>//        Increment i
82918>>>>>>>>>//
82918>>>>>>>>>//        Move eMySQL_TINY_TEXT   to ColumnType[i].iSQLType
82918>>>>>>>>>//        Move "tinytext"         to ColumnType[i].sSQLType
82918>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82918>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82918>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
82918>>>>>>>>>//        Increment i
82918>>>>>>>>>//
82918>>>>>>>>>//        Move eMySQL_VAR_STRING  to ColumnType[i].iSQLType
82918>>>>>>>>>//        Move "varchar"          to ColumnType[i].sSQLType
82918>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
82918>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
82918>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
82918>>>>>>>>>//        Increment i
82918>>>>>>>>>//
82918>>>>>>>>>//        Move eMySQL_YEAR        to ColumnType[i].iSQLType
82918>>>>>>>>>//        Move "year"             to ColumnType[i].sSQLType
82918>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
82918>>>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
82918>>>>>>>>>//        Move "4.0"              to ColumnType[i].sPrecision
82918>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
82918>>>>>>>>>//        Increment i
82918>>>>>>>>>
82918>>>>>>>>>        Function_Return aColumnType
82919>>>>>>>>>    End_Function
82920>>>>>>>>>
82920>>>>>>>>>    // Oracle Data Types
82920>>>>>>>>>    Function _UtilEnumerateOracleTypes Returns tColumnType[]
82922>>>>>>>>>        tColumnType[] aColumnType
82922>>>>>>>>>        tColumnType[] aColumnType
82923>>>>>>>>>        Integer i
82923>>>>>>>>>
Including file: ora_drv_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ora_drv_DriverDef.inc)
82923>>>>>>>>>>// Generated By The Database Update Framework
82923>>>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\ora_drv_DriverDef.xml
82923>>>>>>>>>>// Driver COLUMN DATA TYPES
82923>>>>>>>>>>//
82923>>>>>>>>>>// Created: 2018-03-14 23:47:34.82
82923>>>>>>>>>>
82923>>>>>>>>>>            Move "blob"                                  to aColumnType[i].sSQLType
82924>>>>>>>>>>            Move 113                                     to aColumnType[i].iSQLType
82925>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82926>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82927>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82928>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82929>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82930>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
82931>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
82932>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82933>>>>>>>>>>            Increment i
82934>>>>>>>>>>
82934>>>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
82935>>>>>>>>>>            Move 96                                      to aColumnType[i].iSQLType
82936>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82937>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82938>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82939>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82940>>>>>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
82941>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
82942>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
82943>>>>>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
82944>>>>>>>>>>            Increment i
82945>>>>>>>>>>
82945>>>>>>>>>>            Move "clob"                                  to aColumnType[i].sSQLType
82946>>>>>>>>>>            Move 112                                     to aColumnType[i].iSQLType
82947>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82948>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82949>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
82950>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82951>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
82952>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
82953>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
82954>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
82955>>>>>>>>>>            Increment i
82956>>>>>>>>>>
82956>>>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
82957>>>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
82958>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82959>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82960>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
82961>>>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
82962>>>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
82963>>>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
82964>>>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
82965>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
82966>>>>>>>>>>            Increment i
82967>>>>>>>>>>
82967>>>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
82968>>>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
82969>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82970>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82971>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
82972>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82973>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82974>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82975>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82976>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82977>>>>>>>>>>            Increment i
82978>>>>>>>>>>
82978>>>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
82979>>>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
82980>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
82981>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82982>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
82983>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
82984>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
82985>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
82986>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
82987>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
82988>>>>>>>>>>            Increment i
82989>>>>>>>>>>
82989>>>>>>>>>>            Move "intervalds"                            to aColumnType[i].sSQLType
82990>>>>>>>>>>            Move 190                                     to aColumnType[i].iSQLType
82991>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
82992>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
82993>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
82994>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
82995>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
82996>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
82997>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
82998>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
82999>>>>>>>>>>            Increment i
83000>>>>>>>>>>
83000>>>>>>>>>>            Move "intervalym"                            to aColumnType[i].sSQLType
83001>>>>>>>>>>            Move 189                                     to aColumnType[i].iSQLType
83002>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83003>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83004>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
83005>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83006>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83007>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
83008>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
83009>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83010>>>>>>>>>>            Increment i
83011>>>>>>>>>>
83011>>>>>>>>>>            Move "long"                                  to aColumnType[i].sSQLType
83012>>>>>>>>>>            Move 8                                       to aColumnType[i].iSQLType
83013>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83014>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83015>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
83016>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83017>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83018>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83019>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83020>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83021>>>>>>>>>>            Increment i
83022>>>>>>>>>>
83022>>>>>>>>>>            Move "longraw"                               to aColumnType[i].sSQLType
83023>>>>>>>>>>            Move 24                                      to aColumnType[i].iSQLType
83024>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83025>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83026>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
83027>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83028>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83029>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
83030>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
83031>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83032>>>>>>>>>>            Increment i
83033>>>>>>>>>>
83033>>>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
83034>>>>>>>>>>            Move 286                                     to aColumnType[i].iSQLType
83035>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83036>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83037>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83038>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83039>>>>>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
83040>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83041>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83042>>>>>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
83043>>>>>>>>>>            Increment i
83044>>>>>>>>>>
83044>>>>>>>>>>            Move "nclob"                                 to aColumnType[i].sSQLType
83045>>>>>>>>>>            Move 288                                     to aColumnType[i].iSQLType
83046>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83047>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83048>>>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
83049>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83050>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83051>>>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
83052>>>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
83053>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83054>>>>>>>>>>            Increment i
83055>>>>>>>>>>
83055>>>>>>>>>>            Move "number"                                to aColumnType[i].sSQLType
83056>>>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
83057>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83058>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83059>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83060>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83061>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
83062>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83063>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83064>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
83065>>>>>>>>>>            Increment i
83066>>>>>>>>>>
83066>>>>>>>>>>            Move "nvarchar2"                             to aColumnType[i].sSQLType
83067>>>>>>>>>>            Move 287                                     to aColumnType[i].iSQLType
83068>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83069>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83070>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83071>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83072>>>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
83073>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83074>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83075>>>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
83076>>>>>>>>>>            Increment i
83077>>>>>>>>>>
83077>>>>>>>>>>            Move "raw"                                   to aColumnType[i].sSQLType
83078>>>>>>>>>>            Move 23                                      to aColumnType[i].iSQLType
83079>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83080>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83081>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83082>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83083>>>>>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
83084>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
83085>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
83086>>>>>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
83087>>>>>>>>>>            Increment i
83088>>>>>>>>>>
83088>>>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
83089>>>>>>>>>>            Move 187                                     to aColumnType[i].iSQLType
83090>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83091>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83092>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
83093>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83094>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83095>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
83096>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
83097>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83098>>>>>>>>>>            Increment i
83099>>>>>>>>>>
83099>>>>>>>>>>            Move "timestampltz"                          to aColumnType[i].sSQLType
83100>>>>>>>>>>            Move 232                                     to aColumnType[i].iSQLType
83101>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83102>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83103>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
83104>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83105>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83106>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
83107>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
83108>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83109>>>>>>>>>>            Increment i
83110>>>>>>>>>>
83110>>>>>>>>>>            Move "timestamptz"                           to aColumnType[i].sSQLType
83111>>>>>>>>>>            Move 188                                     to aColumnType[i].iSQLType
83112>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83113>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83114>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
83115>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83116>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83117>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
83118>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
83119>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83120>>>>>>>>>>            Increment i
83121>>>>>>>>>>
83121>>>>>>>>>>            Move "varchar2"                              to aColumnType[i].sSQLType
83122>>>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
83123>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83124>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83125>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83126>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83127>>>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
83128>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83129>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83130>>>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
83131>>>>>>>>>>            Increment i
83132>>>>>>>>>>
83132>>>>>>>>>>
83132>>>>>>>>>
83132>>>>>>>>>//        Move eOracle_BLOB       to ColumnType[i].iSQLType
83132>>>>>>>>>//        Move "BLOB"             to ColumnType[i].sSQLType
83132>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83132>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83132>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83132>>>>>>>>>//        Increment i
83132>>>>>>>>>//
83132>>>>>>>>>//        Move eOracle_CHAR       to ColumnType[i].iSQLType
83132>>>>>>>>>//        Move "CHAR"             to ColumnType[i].sSQLType
83132>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83132>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83132>>>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
83132>>>>>>>>>//        Increment i
83132>>>>>>>>>//
83132>>>>>>>>>//        Move eOracle_CLOB       to ColumnType[i].iSQLType
83132>>>>>>>>>//        Move "CLOB"             to ColumnType[i].sSQLType
83132>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83132>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83132>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83132>>>>>>>>>//        Increment i
83132>>>>>>>>>//
83132>>>>>>>>>//        Move eOracle_DATE       to ColumnType[i].iSQLType
83132>>>>>>>>>//        Move "DATE"             to ColumnType[i].sSQLType
83132>>>>>>>>>//        Move DF_Date            to ColumnType[i].iDataFlexType
83132>>>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
83132>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
83132>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83132>>>>>>>>>//        Increment i
83132>>>>>>>>>//
83132>>>>>>>>>//        Move eOracle_FLOAT      to ColumnType[i].iSQLType
83132>>>>>>>>>//        Move "FLOAT"            to ColumnType[i].sSQLType
83132>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83132>>>>>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
83132>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
83132>>>>>>>>>//        Increment i
83132>>>>>>>>>//
83132>>>>>>>>>//        Move eOracle_INT        to ColumnType[i].iSQLType
83132>>>>>>>>>//        Move "INT"              to ColumnType[i].sSQLType
83132>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83132>>>>>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
83132>>>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
83132>>>>>>>>>//        Increment i
83132>>>>>>>>>//
83132>>>>>>>>>//        Move eOracle_INTERVALDS to ColumnType[i].iSQLType
83132>>>>>>>>>//        Move "INTERVALDAYTOSEC" to ColumnType[i].sSQLType
83132>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
83132>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
83132>>>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
83132>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83132>>>>>>>>>//        Increment i
83132>>>>>>>>>//
83132>>>>>>>>>//        Move eOracle_INTERVALYM  to ColumnType[i].iSQLType
83132>>>>>>>>>//        Move "INTERVALYEARTOMON" to ColumnType[i].sSQLType
83132>>>>>>>>>//        Move DF_DATETIME         to ColumnType[i].iDataFlexType
83132>>>>>>>>>//        Move "DateTime"          to ColumnType[i].sDataFlexType
83132>>>>>>>>>//        Move "23.0"              to ColumnType[i].sPrecision
83132>>>>>>>>>//        Move True                to ColumnType[i].bCanEditSize
83132>>>>>>>>>//        Increment i
83132>>>>>>>>>//
83132>>>>>>>>>//        Move eOracle_RAW        to ColumnType[i].iSQLType
83132>>>>>>>>>//        Move "LONG"             to ColumnType[i].sSQLType
83132>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83132>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83132>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83132>>>>>>>>>//        Increment i
83132>>>>>>>>>//
83132>>>>>>>>>//        Move eOracle_LONGRAW    to ColumnType[i].iSQLType
83132>>>>>>>>>//        Move "LONG RAW"         to ColumnType[i].sSQLType
83132>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83132>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83132>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83132>>>>>>>>>//        Increment i
83132>>>>>>>>>//
83132>>>>>>>>>//        Move eOracle_NCHAR      to ColumnType[i].iSQLType
83132>>>>>>>>>//        Move "NCHAR"            to ColumnType[i].sSQLType
83132>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83132>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83132>>>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
83132>>>>>>>>>//        Increment i
83132>>>>>>>>>//
83132>>>>>>>>>//        Move eOracle_NCLOB      to ColumnType[i].iSQLType
83132>>>>>>>>>//        Move "NCLOB"            to ColumnType[i].sSQLType
83132>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83132>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83132>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83132>>>>>>>>>//        Increment i
83132>>>>>>>>>//
83132>>>>>>>>>//        Move eOracle_NUMBER     to ColumnType[i].iSQLType
83132>>>>>>>>>//        Move "NUMBER"           to ColumnType[i].sSQLType
83132>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83132>>>>>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
83132>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
83132>>>>>>>>>//        Increment i
83132>>>>>>>>>//
83132>>>>>>>>>//        Move eOracle_NVARCHAR2  to ColumnType[i].iSQLType
83132>>>>>>>>>//        Move "NVARCHAR2"        to ColumnType[i].sSQLType
83132>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83132>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83132>>>>>>>>>//        Move "4000"             to ColumnType[i].sPrecision
83132>>>>>>>>>//        Increment i
83132>>>>>>>>>//
83132>>>>>>>>>//        Move eOracle_RAW        to ColumnType[i].iSQLType
83132>>>>>>>>>//        Move "RAW"              to ColumnType[i].sSQLType
83132>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83132>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83132>>>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
83132>>>>>>>>>//        Increment i
83132>>>>>>>>>//
83132>>>>>>>>>//        Move eOracle_ROWID      to ColumnType[i].iSQLType
83132>>>>>>>>>//        Move "ROWID"            to ColumnType[i].sSQLType
83132>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83132>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83132>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83132>>>>>>>>>//        Increment i
83132>>>>>>>>>//
83132>>>>>>>>>//        Move eOracle_TIMESTAMP  to ColumnType[i].iSQLType
83132>>>>>>>>>//        Move "TimeStamp"        to ColumnType[i].sSQLType
83132>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
83132>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
83132>>>>>>>>>//        Move "11.0"             to ColumnType[i].sPrecision
83132>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83132>>>>>>>>>//        Increment i
83132>>>>>>>>>//
83132>>>>>>>>>//        Move eOracle_TIMESTAMPLTZ   to ColumnType[i].iSQLType
83132>>>>>>>>>//        Move "TIMESTAMPLOCALTZ"     to ColumnType[i].sSQLType
83132>>>>>>>>>//        Move DF_DATETIME            to ColumnType[i].iDataFlexType
83132>>>>>>>>>//        Move "DateTime"             to ColumnType[i].sDataFlexType
83132>>>>>>>>>//        Move "13.0"                 to ColumnType[i].sPrecision
83132>>>>>>>>>//        Move True                   to ColumnType[i].bCanEditSize
83132>>>>>>>>>//        Increment i
83132>>>>>>>>>//
83132>>>>>>>>>//        Move eOracle_TIMESTAMPTZ    to ColumnType[i].iSQLType
83132>>>>>>>>>//        Move "TIMEZONETIMEZONE"     to ColumnType[i].sSQLType
83132>>>>>>>>>//        Move DF_DATETIME            to ColumnType[i].iDataFlexType
83132>>>>>>>>>//        Move "DateTime"             to ColumnType[i].sDataFlexType
83132>>>>>>>>>//        Move "11.0"                 to ColumnType[i].sPrecision
83132>>>>>>>>>//        Move True                   to ColumnType[i].bCanEditSize
83132>>>>>>>>>//        Increment i
83132>>>>>>>>>//
83132>>>>>>>>>//        Move eOracle_VARCHAR2   to ColumnType[i].iSQLType
83132>>>>>>>>>//        Move "VARCHAR"          to ColumnType[i].sSQLType
83132>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83132>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83132>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83132>>>>>>>>>
83132>>>>>>>>>        Function_Return aColumnType
83133>>>>>>>>>    End_Function
83134>>>>>>>>>
83134>>>>>>>>>    // PostgreSQL Data Types
83134>>>>>>>>>    Function _UtilEnumeratePostgreSQLTypes Returns tColumnType[]
83136>>>>>>>>>        tColumnType[] aColumnType
83136>>>>>>>>>        tColumnType[] aColumnType
83137>>>>>>>>>        Integer i
83137>>>>>>>>>
Including file: mdspgsql_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\mdspgsql_DriverDef.inc)
83137>>>>>>>>>>// Generated By The Database Update Framework
83137>>>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\mdspgsql_DriverDef.xml
83137>>>>>>>>>>// Driver COLUMN DATA TYPES
83137>>>>>>>>>>//
83137>>>>>>>>>>// Created: 2018-03-14 23:47:02.984
83137>>>>>>>>>>
83137>>>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
83138>>>>>>>>>>            Move 20                                      to aColumnType[i].iSQLType
83139>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83140>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83141>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
83142>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83143>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
83144>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83145>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83146>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
83147>>>>>>>>>>            Increment i
83148>>>>>>>>>>
83148>>>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
83149>>>>>>>>>>            Move 1560                                    to aColumnType[i].iSQLType
83150>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83151>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83152>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83153>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83154>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83155>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
83156>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
83157>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83158>>>>>>>>>>            Increment i
83159>>>>>>>>>>
83159>>>>>>>>>>            Move "boolean"                               to aColumnType[i].sSQLType
83160>>>>>>>>>>            Move 16                                      to aColumnType[i].iSQLType
83161>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83162>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83163>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83164>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83165>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83166>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83167>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83168>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83169>>>>>>>>>>            Increment i
83170>>>>>>>>>>
83170>>>>>>>>>>            Move "bytea"                                 to aColumnType[i].sSQLType
83171>>>>>>>>>>            Move 17                                      to aColumnType[i].iSQLType
83172>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83173>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83174>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83175>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83176>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83177>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
83178>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
83179>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83180>>>>>>>>>>            Increment i
83181>>>>>>>>>>
83181>>>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
83182>>>>>>>>>>            Move 18                                      to aColumnType[i].iSQLType
83183>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83184>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83185>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83186>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83187>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83188>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83189>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83190>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83191>>>>>>>>>>            Increment i
83192>>>>>>>>>>
83192>>>>>>>>>>            Move "citext"                                to aColumnType[i].sSQLType
83193>>>>>>>>>>            Move -25                                     to aColumnType[i].iSQLType
83194>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83195>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83196>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83197>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83198>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83199>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83200>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83201>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83202>>>>>>>>>>            Increment i
83203>>>>>>>>>>
83203>>>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
83204>>>>>>>>>>            Move 1082                                    to aColumnType[i].iSQLType
83205>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83206>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83207>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
83208>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83209>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83210>>>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
83211>>>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
83212>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
83213>>>>>>>>>>            Increment i
83214>>>>>>>>>>
83214>>>>>>>>>>            Move "double"                                to aColumnType[i].sSQLType
83215>>>>>>>>>>            Move 701                                     to aColumnType[i].iSQLType
83216>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83217>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83218>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
83219>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83220>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
83221>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83222>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83223>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
83224>>>>>>>>>>            Increment i
83225>>>>>>>>>>
83225>>>>>>>>>>            Move "integer"                               to aColumnType[i].sSQLType
83226>>>>>>>>>>            Move 23                                      to aColumnType[i].iSQLType
83227>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83228>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83229>>>>>>>>>>            Move 11                                      to aColumnType[i].iDefaultSize
83230>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83231>>>>>>>>>>            Move 11                                      to aColumnType[i].nMaxSize
83232>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83233>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83234>>>>>>>>>>            Move 11                                      to aColumnType[i].sPrecision
83235>>>>>>>>>>            Increment i
83236>>>>>>>>>>
83236>>>>>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
83237>>>>>>>>>>            Move 790                                     to aColumnType[i].iSQLType
83238>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83239>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83240>>>>>>>>>>            Move 30                                      to aColumnType[i].iDefaultSize
83241>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83242>>>>>>>>>>            Move 30                                      to aColumnType[i].nMaxSize
83243>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83244>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83245>>>>>>>>>>            Move 30                                      to aColumnType[i].sPrecision
83246>>>>>>>>>>            Increment i
83247>>>>>>>>>>
83247>>>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
83248>>>>>>>>>>            Move 1700                                    to aColumnType[i].iSQLType
83249>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83250>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83251>>>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
83252>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83253>>>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
83254>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83255>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83256>>>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
83257>>>>>>>>>>            Increment i
83258>>>>>>>>>>
83258>>>>>>>>>>            Move "oid"                                   to aColumnType[i].sSQLType
83259>>>>>>>>>>            Move 26                                      to aColumnType[i].iSQLType
83260>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83261>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83262>>>>>>>>>>            Move 20                                      to aColumnType[i].iDefaultSize
83263>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83264>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83265>>>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
83266>>>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
83267>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83268>>>>>>>>>>            Increment i
83269>>>>>>>>>>
83269>>>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
83270>>>>>>>>>>            Move 700                                     to aColumnType[i].iSQLType
83271>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83272>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83273>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
83274>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83275>>>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
83276>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83277>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83278>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
83279>>>>>>>>>>            Increment i
83280>>>>>>>>>>
83280>>>>>>>>>>            Move "regproc"                               to aColumnType[i].sSQLType
83281>>>>>>>>>>            Move 24                                      to aColumnType[i].iSQLType
83282>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83283>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83284>>>>>>>>>>            Move 64                                      to aColumnType[i].iDefaultSize
83285>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83286>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83287>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83288>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83289>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83290>>>>>>>>>>            Increment i
83291>>>>>>>>>>
83291>>>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
83292>>>>>>>>>>            Move 21                                      to aColumnType[i].iSQLType
83293>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83294>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83295>>>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
83296>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83297>>>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
83298>>>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
83299>>>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
83300>>>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
83301>>>>>>>>>>            Increment i
83302>>>>>>>>>>
83302>>>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
83303>>>>>>>>>>            Move 25                                      to aColumnType[i].iSQLType
83304>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83305>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83306>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83307>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83308>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83309>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83310>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83311>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83312>>>>>>>>>>            Increment i
83313>>>>>>>>>>
83313>>>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
83314>>>>>>>>>>            Move 1083                                    to aColumnType[i].iSQLType
83315>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83316>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83317>>>>>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
83318>>>>>>>>>>            Move 8                                       to aColumnType[i].iMinSize
83319>>>>>>>>>>            Move 15                                      to aColumnType[i].nMaxSize
83320>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83321>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83322>>>>>>>>>>            Move 15                                      to aColumnType[i].sPrecision
83323>>>>>>>>>>            Increment i
83324>>>>>>>>>>
83324>>>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
83325>>>>>>>>>>            Move 1114                                    to aColumnType[i].iSQLType
83326>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83327>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83328>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
83329>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83330>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83331>>>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
83332>>>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
83333>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83334>>>>>>>>>>            Increment i
83335>>>>>>>>>>
83335>>>>>>>>>>            Move "timestamptz"                           to aColumnType[i].sSQLType
83336>>>>>>>>>>            Move 1184                                    to aColumnType[i].iSQLType
83337>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83338>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83339>>>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
83340>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83341>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83342>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83343>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83344>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83345>>>>>>>>>>            Increment i
83346>>>>>>>>>>
83346>>>>>>>>>>            Move "uuid"                                  to aColumnType[i].sSQLType
83347>>>>>>>>>>            Move 2950                                    to aColumnType[i].iSQLType
83348>>>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
83349>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83350>>>>>>>>>>            Move 40                                      to aColumnType[i].iDefaultSize
83351>>>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
83352>>>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
83353>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83354>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83355>>>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
83356>>>>>>>>>>            Increment i
83357>>>>>>>>>>
83357>>>>>>>>>>            Move "varbit"                                to aColumnType[i].sSQLType
83358>>>>>>>>>>            Move 1562                                    to aColumnType[i].iSQLType
83359>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83360>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83361>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83362>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83363>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83364>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83365>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83366>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83367>>>>>>>>>>            Increment i
83368>>>>>>>>>>
83368>>>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
83369>>>>>>>>>>            Move 1043                                    to aColumnType[i].iSQLType
83370>>>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
83371>>>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
83372>>>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
83373>>>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
83374>>>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
83375>>>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
83376>>>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
83377>>>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
83378>>>>>>>>>>            Increment i
83379>>>>>>>>>>
83379>>>>>>>>>>
83379>>>>>>>>>
83379>>>>>>>>>//        Move ePgSQL_INT8        to ColumnType[i].iSQLType
83379>>>>>>>>>//        Move "bigint"           to ColumnType[i].sSQLType
83379>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83379>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
83379>>>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
83379>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83379>>>>>>>>>//        Increment i
83379>>>>>>>>>//
83379>>>>>>>>>//        Move ePgSQL_BIT         to ColumnType[i].iSQLType
83379>>>>>>>>>//        Move "bit"              to ColumnType[i].sSQLType
83379>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83379>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83379>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83379>>>>>>>>>//        Increment i
83379>>>>>>>>>//
83379>>>>>>>>>//        Move ePgSQL_BOOL        to ColumnType[i].iSQLType
83379>>>>>>>>>//        Move "boolean"          to ColumnType[i].sSQLType
83379>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83379>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83379>>>>>>>>>//        Move "1"                to ColumnType[i].sPrecision
83379>>>>>>>>>//        Increment i
83379>>>>>>>>>//
83379>>>>>>>>>//        Move ePgSQL_BYTEA       to ColumnType[i].iSQLType
83379>>>>>>>>>//        Move "bytea"            to ColumnType[i].sSQLType
83379>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83379>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83379>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83379>>>>>>>>>//        Increment i
83379>>>>>>>>>//
83379>>>>>>>>>//        Move ePgSQL_CHAR        to ColumnType[i].iSQLType
83379>>>>>>>>>//        Move "char"             to ColumnType[i].sSQLType
83379>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83379>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83379>>>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
83379>>>>>>>>>//        Increment i
83379>>>>>>>>>//
83379>>>>>>>>>//        Move ePgSQL_CITEXT      to ColumnType[i].iSQLType
83379>>>>>>>>>//        Move "citext"           to ColumnType[i].sSQLType
83379>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83379>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83379>>>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
83379>>>>>>>>>//        Increment i
83379>>>>>>>>>//
83379>>>>>>>>>//        Move ePgSQL_DATE        to ColumnType[i].iSQLType
83379>>>>>>>>>//        Move "date"             to ColumnType[i].sSQLType
83379>>>>>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
83379>>>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
83379>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
83379>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83379>>>>>>>>>//        Increment i
83379>>>>>>>>>//
83379>>>>>>>>>//        Move ePgSQL_FLOAT4      to ColumnType[i].iSQLType
83379>>>>>>>>>//        Move "decimal"          to ColumnType[i].sSQLType
83379>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83379>>>>>>>>>//        Move "Decimal"          to ColumnType[i].sDataFlexType
83379>>>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
83379>>>>>>>>>//        Increment i
83379>>>>>>>>>//
83379>>>>>>>>>//        Move ePgSQL_FLOAT8      to ColumnType[i].iSQLType
83379>>>>>>>>>//        Move "double"           to ColumnType[i].sSQLType
83379>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83379>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83379>>>>>>>>>//        Move "22"               to ColumnType[i].sPrecision
83379>>>>>>>>>//        Increment i
83379>>>>>>>>>//
83379>>>>>>>>>//        Move ePgSQL_INT4        to ColumnType[i].iSQLType
83379>>>>>>>>>//        Move "integer"          to ColumnType[i].sSQLType
83379>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83379>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
83379>>>>>>>>>//        Move "8.0"              to ColumnType[i].sPrecision
83379>>>>>>>>>//        Increment i
83379>>>>>>>>>//
83379>>>>>>>>>//        Move ePgSQL_MONEY       to ColumnType[i].iSQLType
83379>>>>>>>>>//        Move "money"            to ColumnType[i].sSQLType
83379>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83379>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
83379>>>>>>>>>//        Move "8.0"              to ColumnType[i].sPrecision
83379>>>>>>>>>//        Increment i
83379>>>>>>>>>//
83379>>>>>>>>>//        Move ePgSQL_OID         to ColumnType[i].iSQLType
83379>>>>>>>>>//        Move "oid"              to ColumnType[i].sSQLType
83379>>>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
83379>>>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
83379>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83379>>>>>>>>>//        Increment i
83379>>>>>>>>>//
83379>>>>>>>>>//        Move ePgSQL_FLOAT4      to ColumnType[i].iSQLType
83379>>>>>>>>>//        Move "real"             to ColumnType[i].sSQLType
83379>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83379>>>>>>>>>//        Move "Real"             to ColumnType[i].sDataFlexType
83379>>>>>>>>>//        Move "6.6"              to ColumnType[i].sPrecision
83379>>>>>>>>>//        Increment i
83379>>>>>>>>>//
83379>>>>>>>>>//        Move ePgSQL_REGPROC     to ColumnType[i].iSQLType
83379>>>>>>>>>//        Move "regproc"          to ColumnType[i].sSQLType
83379>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83379>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83379>>>>>>>>>//        Move "64"               to ColumnType[i].sPrecision
83379>>>>>>>>>//        Increment i
83379>>>>>>>>>//
83379>>>>>>>>>//        Move ePgSQL_INT2        to ColumnType[i].iSQLType
83379>>>>>>>>>//        Move "smallint"         to ColumnType[i].sSQLType
83379>>>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
83379>>>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
83379>>>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
83379>>>>>>>>>//        Increment i
83379>>>>>>>>>//
83379>>>>>>>>>//        Move ePgSQL_TEXT        to ColumnType[i].iSQLType
83379>>>>>>>>>//        Move "text"             to ColumnType[i].sSQLType
83379>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83379>>>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
83379>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83379>>>>>>>>>//        Increment i
83379>>>>>>>>>//
83379>>>>>>>>>//        Move ePgSQL_TIME        to ColumnType[i].iSQLType
83379>>>>>>>>>//        Move "time"             to ColumnType[i].sSQLType
83379>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83379>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
83379>>>>>>>>>//        Move "15.0"             to ColumnType[i].sPrecision
83379>>>>>>>>>//        Increment i
83379>>>>>>>>>//
83379>>>>>>>>>//        Move ePgSQL_TIMESTAMP   to ColumnType[i].iSQLType
83379>>>>>>>>>//        Move "timestamp"        to ColumnType[i].sSQLType
83379>>>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
83379>>>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
83379>>>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
83379>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83379>>>>>>>>>//        Increment i
83379>>>>>>>>>//
83379>>>>>>>>>//        Move ePgSQL_UUID        to ColumnType[i].iSQLType
83379>>>>>>>>>//        Move "uuid"             to ColumnType[i].sSQLType
83379>>>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
83379>>>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
83379>>>>>>>>>//        Move "40"               to ColumnType[i].sPrecision
83379>>>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
83379>>>>>>>>>//        Increment i
83379>>>>>>>>>//
83379>>>>>>>>>//        Move ePgSQL_VARCHAR     to ColumnType[i].iSQLType
83379>>>>>>>>>//        Move "varchar"          to ColumnType[i].sSQLType
83379>>>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
83379>>>>>>>>>//        Move "DF_TEXT"          to ColumnType[i].sDataFlexType
83379>>>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
83379>>>>>>>>>//        Increment i
83379>>>>>>>>>
83379>>>>>>>>>        Function_Return aColumnType
83380>>>>>>>>>    End_Function
83381>>>>>>>>>
83381>>>>>>>>>    // Internal usage. Use the UtilColumnTypeXXX functions instead.
83381>>>>>>>>>    Function _UtilColumnType String sDriverID Integer iDbType Integer iType String sType Boolean bIntegerInputType Returns tColumnType
83383>>>>>>>>>        Integer iValue iSize iCount iStart
83383>>>>>>>>>        tColumnType[] ColumnTypeArray
83383>>>>>>>>>        tColumnType[] ColumnTypeArray
83384>>>>>>>>>        tColumnType RetvalType
83384>>>>>>>>>        tColumnType RetvalType
83384>>>>>>>>>        String sValue
83384>>>>>>>>>        Boolean bFrameworkDataFlexType
83384>>>>>>>>>
83384>>>>>>>>>        Move "Undefined" to RetvalType.sSQLType
83385>>>>>>>>>        Move -1999       to RetvalType.iSQLType
83386>>>>>>>>>
83386>>>>>>>>>        Move 0 to iStart
83387>>>>>>>>>        Move (Uppercase(sType)) to sType
83388>>>>>>>>>        Move (iType <= -1490) to bFrameworkDataFlexType
83389>>>>>>>>>        If (bFrameworkDataFlexType = True) Begin
83391>>>>>>>>>            Get _UtilDUFDataTypeToSqlTypeMapping sDriverID iDbType iType to RetvalType
83392>>>>>>>>>            Function_Return RetvalType
83393>>>>>>>>>        End
83393>>>>>>>>>>
83393>>>>>>>>>
83393>>>>>>>>>        Get _UtilEnumerateColumnTypes sDriverID iDbType to ColumnTypeArray
83394>>>>>>>>>
83394>>>>>>>>>        Move (SizeOfArray(ColumnTypeArray)) to iSize
83395>>>>>>>>>        Decrement iSize
83396>>>>>>>>>
83396>>>>>>>>>        For iCount from iStart to iSize
83402>>>>>>>>>>
83402>>>>>>>>>            Move ColumnTypeArray[iCount].iSQLType to iValue
83403>>>>>>>>>            Move ColumnTypeArray[iCount].sSQLType to sValue
83404>>>>>>>>>            If (bIntegerInputType = True) Begin
83406>>>>>>>>>                If (iValue = iType) Begin
83408>>>>>>>>>                    Move ColumnTypeArray[iCount].sSQLType       to RetvalType.sSQLType
83409>>>>>>>>>                    Move iType                                  to RetvalType.iSQLType
83410>>>>>>>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
83411>>>>>>>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
83412>>>>>>>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
83413>>>>>>>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
83414>>>>>>>>>                    Move iSize to iCount // We're done!
83415>>>>>>>>>                End
83415>>>>>>>>>>
83415>>>>>>>>>            End
83415>>>>>>>>>>
83415>>>>>>>>>            Else Begin
83416>>>>>>>>>                Move (Uppercase(sValue)) to sValue
83417>>>>>>>>>                If (sValue = sType) Begin
83419>>>>>>>>>                    Move sType                                  to RetvalType.sSQLType
83420>>>>>>>>>                    Move ColumnTypeArray[iCount].iSQLType       to RetvalType.iSQLType
83421>>>>>>>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
83422>>>>>>>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
83423>>>>>>>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
83424>>>>>>>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
83425>>>>>>>>>                    Move iSize to iCount // We're done!
83426>>>>>>>>>                End
83426>>>>>>>>>>
83426>>>>>>>>>            End
83426>>>>>>>>>>
83426>>>>>>>>>        Loop
83427>>>>>>>>>>
83427>>>>>>>>>
83427>>>>>>>>>        // If no match was found it was probably because it was a DataFlex standard type that was passed.
83427>>>>>>>>>        // In which case we search for a match in DataFlex standard types:
83427>>>>>>>>>        If (RetvalType.sSQLType = "Undefined") Begin
83429>>>>>>>>>            Get _UtilEnumerateDataFlexTypes to ColumnTypeArray
83430>>>>>>>>>            Move (SizeOfArray(ColumnTypeArray)) to iSize
83431>>>>>>>>>            Decrement iSize
83432>>>>>>>>>
83432>>>>>>>>>            For iCount from iStart to iSize
83438>>>>>>>>>>
83438>>>>>>>>>                Move ColumnTypeArray[iCount].iSQLType to iValue
83439>>>>>>>>>                Move ColumnTypeArray[iCount].sSQLType to sValue
83440>>>>>>>>>                If (iValue = iType) Begin
83442>>>>>>>>>                    Move ColumnTypeArray[iCount].sSQLType       to RetvalType.sSQLType
83443>>>>>>>>>                    Move iType                                  to RetvalType.iSQLType
83444>>>>>>>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
83445>>>>>>>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
83446>>>>>>>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
83447>>>>>>>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
83448>>>>>>>>>                    Move iSize to iCount // We're done!
83449>>>>>>>>>                End
83449>>>>>>>>>>
83449>>>>>>>>>            Loop
83450>>>>>>>>>>
83450>>>>>>>>>        End
83450>>>>>>>>>>
83450>>>>>>>>>
83450>>>>>>>>>        Function_Return RetvalType
83451>>>>>>>>>    End_Function
83452>>>>>>>>>
83452>>>>>>>>>    // Returns a struct array with all data types for the passed driver & dbtype.
83452>>>>>>>>>    Function _UtilEnumerateColumnTypes String sDriverID Integer iDbType Returns tColumnType[]
83454>>>>>>>>>        tColumnType[] ColumnType
83454>>>>>>>>>        tColumnType[] ColumnType
83455>>>>>>>>>
83455>>>>>>>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
83455>>>>>>>>>        // the dbType.
83455>>>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
83457>>>>>>>>>            If (iDbType = EN_DbTypeMySQL) Begin
83459>>>>>>>>>                Move ODBC_DRV_ID to sDriverID
83460>>>>>>>>>            End
83460>>>>>>>>>>
83460>>>>>>>>>            If (iDbType = EN_DbTypeMSSQL) Begin
83462>>>>>>>>>                Move MSSQLDRV_ID to sDriverID
83463>>>>>>>>>            End
83463>>>>>>>>>>
83463>>>>>>>>>            If (iDbType = EN_DbTypeDB2) Begin
83465>>>>>>>>>                Move DB2_DRV_ID to sDriverID
83466>>>>>>>>>            End
83466>>>>>>>>>>
83466>>>>>>>>>            If (iDbType = EN_DbTypePostgre) Begin
83468>>>>>>>>>                Move ODBC_DRV_ID to sDriverID
83469>>>>>>>>>            End
83469>>>>>>>>>>
83469>>>>>>>>>        End
83469>>>>>>>>>>
83469>>>>>>>>>
83469>>>>>>>>>        Case Begin
83469>>>>>>>>>            Case (iDbType = EN_dbTypeDataFlex)
83471>>>>>>>>>                Get _UtilEnumerateDataFlexTypes to ColumnType
83472>>>>>>>>>                Case Break
83473>>>>>>>>>
83473>>>>>>>>>            Case (iDbType = EN_DbTypeDB2)
83476>>>>>>>>>                Get _UtilEnumerateDB2Types to ColumnType
83477>>>>>>>>>                Case Break
83478>>>>>>>>>
83478>>>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
83481>>>>>>>>>                Get _UtilEnumerateMSSQLTypes sDriverID to ColumnType
83482>>>>>>>>>                Case Break
83483>>>>>>>>>        Case End
83483>>>>>>>>>
83483>>>>>>>>>        Function_Return ColumnType
83484>>>>>>>>>    End_Function
83485>>>>>>>>>
83485>>>>>>>>>    // Returns a struct with the default column types for the SQL back-end and how they
83485>>>>>>>>>    // are mapped to a DUF data type.
83485>>>>>>>>>    Function _UtilDUFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
83487>>>>>>>>>        tColumnType ColumnType
83487>>>>>>>>>        tColumnType ColumnType
83487>>>>>>>>>        String sDataType
83487>>>>>>>>>        Integer iDriverID iCount
83487>>>>>>>>>
83487>>>>>>>>>        Move 0 to iCount
83488>>>>>>>>>        Get DriverIndex sDriverID to iDriverID
83489>>>>>>>>>
83489>>>>>>>>>        Case Begin
83489>>>>>>>>>            // DF_ASCII
83489>>>>>>>>>            Case (iType = DF_ASCII_DUF)
83491>>>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83493>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
83496>>>>>>>>>                End
83496>>>>>>>>>>
83496>>>>>>>>>                Else Begin
83497>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
83500>>>>>>>>>                End
83500>>>>>>>>>>
83500>>>>>>>>>                Move DF_ASCII    to ColumnType.iDataFlexType
83501>>>>>>>>>                Move "ASCII"     to ColumnType.sDataFlexType
83502>>>>>>>>>                Move sDataType   to ColumnType.sSQLType
83503>>>>>>>>>                Move DF_ASCII    to ColumnType.iSQLType
83504>>>>>>>>>                Move False       to ColumnType.bCanEditSize
83505>>>>>>>>>                Case Break
83506>>>>>>>>>
83506>>>>>>>>>            // DF_BINARY
83506>>>>>>>>>            Case (iType = DF_BINARY_DUF)
83509>>>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83511>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
83514>>>>>>>>>                End
83514>>>>>>>>>>
83514>>>>>>>>>                Else Begin
83515>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
83518>>>>>>>>>                End
83518>>>>>>>>>>
83518>>>>>>>>>                Move DF_BINARY   to ColumnType.iDataFlexType
83519>>>>>>>>>                Move "Binary"    to ColumnType.sDataFlexType
83520>>>>>>>>>                Move sDataType   to ColumnType.sSQLType
83521>>>>>>>>>                Move DF_BINARY   to ColumnType.iSQLType
83522>>>>>>>>>                Move False       to ColumnType.bCanEditSize
83523>>>>>>>>>                Case Break
83524>>>>>>>>>
83524>>>>>>>>>            // DF_DATE
83524>>>>>>>>>            Case (iType = DF_DATE_DUF)
83527>>>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83529>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
83532>>>>>>>>>                End
83532>>>>>>>>>>
83532>>>>>>>>>                Else Begin
83533>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
83536>>>>>>>>>                End
83536>>>>>>>>>>
83536>>>>>>>>>                Move DF_DATE     to ColumnType.iDataFlexType
83537>>>>>>>>>                Move "Date"      to ColumnType.sDataFlexType
83538>>>>>>>>>                Move sDataType   to ColumnType.sSQLType
83539>>>>>>>>>                Move DF_DATE     to ColumnType.iSQLType
83540>>>>>>>>>                Move True        to ColumnType.bCanEditSize
83541>>>>>>>>>                Case Break
83542>>>>>>>>>
83542>>>>>>>>>            // DF_DATETIME
83542>>>>>>>>>            Case (iType = DF_DATETIME_DUF)
83545>>>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83547>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
83550>>>>>>>>>                End
83550>>>>>>>>>>
83550>>>>>>>>>                Else Begin
83551>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
83554>>>>>>>>>                End
83554>>>>>>>>>>
83554>>>>>>>>>                Move DF_DATETIME to ColumnType.iDataFlexType
83555>>>>>>>>>                Move "DateTime"  to ColumnType.sDataFlexType
83556>>>>>>>>>                Move sDataType   to ColumnType.sSQLType
83557>>>>>>>>>                Move DF_DATETIME to ColumnType.iSQLType
83558>>>>>>>>>                Move True        to ColumnType.bCanEditSize
83559>>>>>>>>>                Case Break
83560>>>>>>>>>
83560>>>>>>>>>            // DF_NUMERIC
83560>>>>>>>>>            // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
83560>>>>>>>>>            // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
83560>>>>>>>>>            // we make them here all "Numeric"...
83560>>>>>>>>>            // If (sDriverID = ODBC_DRV_ID) Begin
83560>>>>>>>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
83560>>>>>>>>>            // End
83560>>>>>>>>>            // Else Begin
83560>>>>>>>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
83560>>>>>>>>>            // End
83560>>>>>>>>>            // ToDo: How should we find the best "Numeric" data type here?
83560>>>>>>>>>            Case (iType = DF_BCD_DUF)
83563>>>>>>>>>                Move DF_BCD      to ColumnType.iDataFlexType
83564>>>>>>>>>                Move "Numeric"   to ColumnType.sDataFlexType
83565>>>>>>>>>                Move "Numeric"   to ColumnType.sSQLType
83566>>>>>>>>>                Move SQL_NUMERIC to ColumnType.iSQLType
83567>>>>>>>>>                Move False       to ColumnType.bCanEditSize
83568>>>>>>>>>                Case Break
83569>>>>>>>>>
83569>>>>>>>>>            // DF_TEXT
83569>>>>>>>>>            Case (iType = DF_TEXT_DUF)
83572>>>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
83574>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
83577>>>>>>>>>                End
83577>>>>>>>>>>
83577>>>>>>>>>                Else Begin
83578>>>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
83581>>>>>>>>>                End
83581>>>>>>>>>>
83581>>>>>>>>>                Move DF_TEXT     to ColumnType.iDataFlexType
83582>>>>>>>>>                Move "Text"      to ColumnType.sDataFlexType
83583>>>>>>>>>                Move sDataType   to ColumnType.sSQLType
83584>>>>>>>>>                Move DF_TEXT     to ColumnType.iSQLType
83585>>>>>>>>>                Move False       to ColumnType.bCanEditSize
83586>>>>>>>>>                Case Break
83587>>>>>>>>>
83587>>>>>>>>>            Case Else
83587>>>>>>>>>                Move -1999       to ColumnType.iDataFlexType
83588>>>>>>>>>                Move "Undefined" to ColumnType.sDataFlexType
83589>>>>>>>>>                Move "Undefined" to ColumnType.sSQLType
83590>>>>>>>>>                Move -1999       to ColumnType.iSQLType
83591>>>>>>>>>                Move True        to ColumnType.bCanEditSize
83592>>>>>>>>>
83592>>>>>>>>>        Case End
83592>>>>>>>>>
83592>>>>>>>>>        Function_Return ColumnType
83593>>>>>>>>>    End_Function
83594>>>>>>>>>
83594>>>>>>>>>    Function _AllTablesToConvert Returns Integer[]
83596>>>>>>>>>        Integer[] aTableConvertExceptions iTablesArray
83598>>>>>>>>>        Handle hTable
83598>>>>>>>>>        Integer iIndex
83598>>>>>>>>>        String sTableName
83598>>>>>>>>>        Boolean bFlexErrs
83598>>>>>>>>>
83598>>>>>>>>>        // a) Get the exception table array the developer has specified
83598>>>>>>>>>        Get paTableConvertExceptions to aTableConvertExceptions
83599>>>>>>>>>
83599>>>>>>>>>        // b) Add CodeMast, CodeType & DbVersion to exceptions
83599>>>>>>>>>        Repeat
83599>>>>>>>>>>
83599>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
83602>>>>>>>>>            If (hTable <> 0) Begin
83604>>>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
83607>>>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
83608>>>>>>>>>                If (bFlexErrs = False) Begin
83610>>>>>>>>>                    If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE" or Uppercase(sTableName) = "DBVERSION") Begin
83612>>>>>>>>>                        Move (SearchArray(hTable, aTableConvertExceptions)) to iIndex
83613>>>>>>>>>                        If (iIndex = -1) Begin
83615>>>>>>>>>                            Move hTable to aTableConvertExceptions[SizeOfArray(aTableConvertExceptions)]
83616>>>>>>>>>                        End
83616>>>>>>>>>>
83616>>>>>>>>>                    End
83616>>>>>>>>>>
83616>>>>>>>>>                End
83616>>>>>>>>>>
83616>>>>>>>>>            End
83616>>>>>>>>>>
83616>>>>>>>>>        Until (hTable = 0)
83618>>>>>>>>>
83618>>>>>>>>>        Move 0 to hTable
83619>>>>>>>>>
83619>>>>>>>>>        // c) Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
83619>>>>>>>>>        Repeat
83619>>>>>>>>>>
83619>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
83622>>>>>>>>>            If (hTable > 0) Begin
83624>>>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
83627>>>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
83628>>>>>>>>>                If (bFlexErrs = False) Begin
83630>>>>>>>>>                    Move (SearchArray(hTable, aTableConvertExceptions)) to iIndex
83631>>>>>>>>>                    If (iIndex = -1) Begin
83633>>>>>>>>>                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
83634>>>>>>>>>                    End
83634>>>>>>>>>>
83634>>>>>>>>>                End
83634>>>>>>>>>>
83634>>>>>>>>>            End
83634>>>>>>>>>>
83634>>>>>>>>>        Until (hTable = 0)
83636>>>>>>>>>
83636>>>>>>>>>        Function_Return iTablesArray
83637>>>>>>>>>    End_Function
83638>>>>>>>>>
83638>>>>>>>>>    Function _AllTablesDateCorrections Returns Integer[]
83640>>>>>>>>>        Integer[] aTableDateCorrectionExceptions iTablesArray
83642>>>>>>>>>        Handle hTable
83642>>>>>>>>>        Integer iIndex
83642>>>>>>>>>        String sTableName
83642>>>>>>>>>        Boolean bFlexErrs
83642>>>>>>>>>
83642>>>>>>>>>        Get paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
83643>>>>>>>>>        Move 0 to hTable
83644>>>>>>>>>
83644>>>>>>>>>        // Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
83644>>>>>>>>>        Repeat
83644>>>>>>>>>>
83644>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
83647>>>>>>>>>            If (hTable > 0) Begin
83649>>>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
83652>>>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
83653>>>>>>>>>                If (bFlexErrs = False) Begin
83655>>>>>>>>>                    Move (SearchArray(hTable, aTableDateCorrectionExceptions)) to iIndex
83656>>>>>>>>>                    If (iIndex = -1) Begin
83658>>>>>>>>>                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
83659>>>>>>>>>                    End
83659>>>>>>>>>>
83659>>>>>>>>>                End
83659>>>>>>>>>>
83659>>>>>>>>>            End
83659>>>>>>>>>>
83659>>>>>>>>>        Until (hTable = 0)
83661>>>>>>>>>
83661>>>>>>>>>        Function_Return iTablesArray
83662>>>>>>>>>    End_Function
83663>>>>>>>>>
83663>>>>>>>>>    Function _AppendAPIColumn tAPIColumn[] aCurrent String sFieldName Integer iType Integer iLength Integer iPrecision Integer iOptions Returns tAPIColumn[]
83665>>>>>>>>>        tAPIColumn NewAPIColumn
83665>>>>>>>>>        tAPIColumn NewAPIColumn
83665>>>>>>>>>
83665>>>>>>>>>        Move sFieldName to NewAPIColumn.sFieldName
83666>>>>>>>>>        Move iType      to NewAPIColumn.iType
83667>>>>>>>>>        Move iLength    to NewAPIColumn.iLength
83668>>>>>>>>>        Move iPrecision to NewAPIColumn.iPrecision
83669>>>>>>>>>        Move iOptions   to NewAPIColumn.iOptions
83670>>>>>>>>>
83670>>>>>>>>>        Move NewAPIColumn to aCurrent[SizeOfArray(aCurrent)]
83671>>>>>>>>>
83671>>>>>>>>>        Function_Return aCurrent
83672>>>>>>>>>    End_Function
83673>>>>>>>>>
83673>>>>>>>>>    Function _UtilIndexAppendSegmentFieldNames tAPIIndexSegment[] APIIndexSegment Returns String
83675>>>>>>>>>        String sRetval sFieldName
83675>>>>>>>>>        Integer iCount iSize
83675>>>>>>>>>
83675>>>>>>>>>        Move (SizeOfArray(APIIndexSegment)) to iSize
83676>>>>>>>>>        Decrement iSize
83677>>>>>>>>>        For iCount from 0 to iSize
83683>>>>>>>>>>
83683>>>>>>>>>            Move APIIndexSegment[iCount].sFieldName to sFieldName
83684>>>>>>>>>            Move (sRetval * (String(sFieldName))) to sRetval
83685>>>>>>>>>        Loop
83686>>>>>>>>>>
83686>>>>>>>>>        Move (Trim(sRetval)) to sRetval
83687>>>>>>>>>
83687>>>>>>>>>        Function_Return sRetval
83688>>>>>>>>>    End_Function
83689>>>>>>>>>
83689>>>>>>>>>    // *** Miscellaneous other functions ***
83689>>>>>>>>>    // Some of which can be used by both "Sqlxxx" and "Apixxx" functions.
83689>>>>>>>>>    //
83689>>>>>>>>>
83689>>>>>>>>>    // Callback functionality used when e.g. calling driver functions directly.
83689>>>>>>>>>    Function Callback String sCallback_Text Integer iCallback_Type Returns Integer
83691>>>>>>>>>        Integer iPerc
83691>>>>>>>>>        Number nReady nTotal
83691>>>>>>>>>
83691>>>>>>>>>        Send DoAdvance of ghoProgressBar
83692>>>>>>>>>
83692>>>>>>>>>        If (sCallback_Text contains "Copy records") Begin
83694>>>>>>>>>            Move CS_DUF_CopyingData to sCallback_Text
83695>>>>>>>>>        End
83695>>>>>>>>>>
83695>>>>>>>>>        If (sCallback_Text contains "Dropping index" or sCallback_Text contains "Temporary delete of all indices of table") Begin
83697>>>>>>>>>            Move (Replace("Dropping index", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
83698>>>>>>>>>            Move (Replace("Temporary delete of all indices of table", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
83699>>>>>>>>>        End
83699>>>>>>>>>>
83699>>>>>>>>>        If (sCallback_Text contains "Creating index") Begin
83701>>>>>>>>>            Move (Replace("Creating index", sCallback_Text, CS_DUF_CreatingIndex)) to sCallback_Text
83702>>>>>>>>>        End
83702>>>>>>>>>>
83702>>>>>>>>>
83702>>>>>>>>>        Case Begin
83702>>>>>>>>>            Case (iCallback_Type = DF_Message_Text)
83704>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83705>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83706>>>>>>>>>                Case Break
83707>>>>>>>>>            Case (iCallback_Type = DF_Message_Heading_1)
83710>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83711>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83712>>>>>>>>>                Case Break
83713>>>>>>>>>            Case (iCallback_Type = DF_Message_Heading_2)
83716>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83717>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83718>>>>>>>>>                Case Break
83719>>>>>>>>>            Case (iCallback_Type = DF_Message_Heading_3)
83722>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83723>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83724>>>>>>>>>                Case Break
83725>>>>>>>>>            Case (iCallback_Type = DF_Message_Heading_4)
83728>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83729>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83730>>>>>>>>>                Case Break
83731>>>>>>>>>            Case (iCallback_Type = DF_Message_Heading_5)
83734>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83735>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83736>>>>>>>>>                Case Break
83737>>>>>>>>>            Case (iCallback_Type = DF_Message_Warning)
83740>>>>>>>>>                Send None
83741>>>>>>>>>                Case Break
83742>>>>>>>>>            Case (iCallback_Type = DF_Message_Progress_Title)
83745>>>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
83746>>>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
83747>>>>>>>>>                Case Break
83748>>>>>>>>>            Case (iCallback_Type = DF_Message_Progress_Value)
83751>>>>>>>>>                //*** Interpret numbers
83751>>>>>>>>>                Move (Left(sCallback_Text, (Pos(",", sCallback_Text) - 1)))                       to nReady
83752>>>>>>>>>                Move (Right(sCallback_Text, (Length(sCallback_Text) - Pos(",", sCallback_Text)))) to nTotal
83753>>>>>>>>>                Move ((nReady / nTotal) * 100)                                                    to iPerc
83754>>>>>>>>>                Set Action_Text of ghoStatusPanel to (String(iPerc) * String("% Done (Total Number of Records:") * String(nTotal) + ")")
83755>>>>>>>>>                Case Break
83756>>>>>>>>>            Case Else
83756>>>>>>>>>                Set Message_Text to ""
83757>>>>>>>>>                Set Action_Text  to ""
83758>>>>>>>>>        Case End
83758>>>>>>>>>
83758>>>>>>>>>        Send ProcessEvents of ghoStatusPanel
83759>>>>>>>>>        Function_Return False
83760>>>>>>>>>    End_Function
83761>>>>>>>>>
83761>>>>>>>>>    // * Dummy function for the Studio's Code Explorer *
83761>>>>>>>>>    Function PRIVATE_SUB_FUNCTIONS Returns Boolean
83763>>>>>>>>>        Function_Return False
83764>>>>>>>>>    End_Function
83765>>>>>>>>>
83765>>>>>>>>>    // *** Helper functions with compiled sql script code ***
83765>>>>>>>>>    //
83765>>>>>>>>>    // When dropping columns on some SQL back-ends they doesn't reclaim the space taken up by the columns dropped.
83765>>>>>>>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
83765>>>>>>>>>    // the new rows added after the alter statement. to get around this you need to create a clustered
83765>>>>>>>>>    // index on the table _or_ rebuild the clustered Index if it already has one. Rebuilding the index
83765>>>>>>>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
83765>>>>>>>>>    //   ALTER TABLE MyTable
83765>>>>>>>>>    //       REBUILD
83765>>>>>>>>>    Function _SqlUtilRemoveTableColumnMSSQL String sTableName String sColumnName Returns Boolean
83767>>>>>>>>>        Boolean bOK
83767>>>>>>>>>
83767>>>>>>>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
83769>>>>>>>>>            Function_Return False
83770>>>>>>>>>        End
83770>>>>>>>>>>
83770>>>>>>>>>
83770>>>>>>>>>        SQLIncludeScriptFile ..\Scripts\DropConstraintAndColumnNameMSSQL.sql as DropConstraintAndColumnNameMSSQL.sql
83770>>>>>>>>>        Get _SqlUtilRemoveTableColumnByScript "DropConstraintAndColumnNameMSSQL.sql" sTableName sColumnName to bOK
83771>>>>>>>>>
83771>>>>>>>>>        Function_Return (bOK = True)
83772>>>>>>>>>    End_Function
83773>>>>>>>>>
83773>>>>>>>>>    // When dropping columns SQL Sever does not reclaim the space taken up by the columns dropped.
83773>>>>>>>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
83773>>>>>>>>>    // the new rows added after the alter statement. To get around this you need to create a clustered
83773>>>>>>>>>    // index on the table or rebuild the clustered Index if it already has one. Rebuilding the index
83773>>>>>>>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
83773>>>>>>>>>    //   ALTER TABLE MyTable
83773>>>>>>>>>    //       REBUILD
83773>>>>>>>>>    Function _SqlUtilRemoveTableColumnByScript String sMemScriptFile String sTableName String sColumnName Returns Boolean
83775>>>>>>>>>        tSQLScriptArray SQLScriptArray
83775>>>>>>>>>        tSQLScriptArray SQLScriptArray
83775>>>>>>>>>        String sDriverID
83775>>>>>>>>>        Boolean bOK
83775>>>>>>>>>        Integer iSize iCount
83775>>>>>>>>>
83775>>>>>>>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
83777>>>>>>>>>            Function_Return False
83778>>>>>>>>>        End
83778>>>>>>>>>>
83778>>>>>>>>>
83778>>>>>>>>>        Get psDriverID to sDriverID
83779>>>>>>>>>        Get _SqlUtilReadResource sMemScriptFile to SQLScriptArray
83780>>>>>>>>>        If (SQLScriptArray.bError = True) Begin
83782>>>>>>>>>            Function_Return False
83783>>>>>>>>>        End
83783>>>>>>>>>>
83783>>>>>>>>>
83783>>>>>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
83784>>>>>>>>>        Decrement iSize
83785>>>>>>>>>
83785>>>>>>>>>        For iCount from 0 to iSize
83791>>>>>>>>>>
83791>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "TABLE_NAME_XXX") Begin
83793>>>>>>>>>                Move (Replaces("TABLE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sTableName))) to SQLScriptArray.sSQLScriptArray[iCount]
83794>>>>>>>>>            End
83794>>>>>>>>>>
83794>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLUMN_NAME_XXX") Begin
83796>>>>>>>>>                Move (Replaces("COLUMN_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sColumnName))) to SQLScriptArray.sSQLScriptArray[iCount]
83797>>>>>>>>>            End
83797>>>>>>>>>>
83797>>>>>>>>>        Loop
83798>>>>>>>>>>
83798>>>>>>>>>
83798>>>>>>>>>        Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
83799>>>>>>>>>
83799>>>>>>>>>        Function_Return (bOK = True)
83800>>>>>>>>>    End_Function
83801>>>>>>>>>
83801>>>>>>>>>    // Reads a SQL script file that has been compiled into the .exe program as a resource.
83801>>>>>>>>>    // Pass: The memory resource reference and a boolean True if you want to create the file on disk (in the Home folder).
83801>>>>>>>>>    // Returns: A tSQLScriptArray Struct with the Sql script as an uChar Array will be returned along with the a bError boolean.
83801>>>>>>>>>    Function _SqlUtilReadResource String sMemFileName Returns tSQLScriptArray
83803>>>>>>>>>        Integer iChannel iArgumentSize iCount
83803>>>>>>>>>        Number nByteCount
83803>>>>>>>>>        String sSQLScript
83803>>>>>>>>>        tSQLScriptArray SqlScriptArray
83803>>>>>>>>>        tSQLScriptArray SqlScriptArray
83803>>>>>>>>>        UChar[] uCharData
83804>>>>>>>>>
83804>>>>>>>>>        Move False to Err
83805>>>>>>>>>        Get Seq_New_Channel to iChannel
83806>>>>>>>>>        If (iChannel = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
83808>>>>>>>>>            Error DFERR_PROGRAM 'No channel available...'
83809>>>>>>>>>>
83809>>>>>>>>>            Move True to SqlScriptArray.bError
83810>>>>>>>>>            Function_Return SqlScriptArray
83811>>>>>>>>>        End
83811>>>>>>>>>>
83811>>>>>>>>>
83811>>>>>>>>>        // First decide the size of the script
83811>>>>>>>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
83813>>>>>>>>>        Read_Block channel iChannel uCharData -1 // -1 means that all data should be read.
83815>>>>>>>>>        Close_Input channel iChannel
83817>>>>>>>>>
83817>>>>>>>>>        Move (SizeOfArray(uCharData)) to nByteCount
83818>>>>>>>>>        If (nByteCount  < 1) Begin
83820>>>>>>>>>            Send Seq_Release_Channel iChannel
83821>>>>>>>>>            Move True to SqlScriptArray.bError
83822>>>>>>>>>            Function_Return SqlScriptArray
83823>>>>>>>>>        End
83823>>>>>>>>>>
83823>>>>>>>>>
83823>>>>>>>>>        // If necessary change the string argument_size
83823>>>>>>>>>        // Read the script file from memory line-by-line
83823>>>>>>>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
83825>>>>>>>>>            Move 0 to iCount
83826>>>>>>>>>            Repeat
83826>>>>>>>>>>
83826>>>>>>>>>                Readln channel iChannel sSQLScript
83828>>>>>>>>>                Move sSQLScript to SqlScriptArray.sSQLScriptArray[iCount]
83829>>>>>>>>>                Increment iCount
83830>>>>>>>>>            Until (SeqEof = True)
83832>>>>>>>>>        Close_Input channel iChannel
83834>>>>>>>>>        Send Seq_Release_Channel iChannel
83835>>>>>>>>>
83835>>>>>>>>>        // Finally "sanitize" the script by removing all comments.
83835>>>>>>>>>        Get _SqlUtilSanitizeScript SqlScriptArray to SqlScriptArray
83836>>>>>>>>>
83836>>>>>>>>>        Function_Return SqlScriptArray
83837>>>>>>>>>    End_Function
83838>>>>>>>>>
83838>>>>>>>>>    Function _SqlUtilExecuteEmbeddedScript tSQLScriptArray SQLScriptArray String sDriverID Boolean bCreateScriptFile String sMemFileName Boolean bShowProgr Returns Boolean
83840>>>>>>>>>        String sSQLVal sStmt sCR sGOKeyWord sNoCountKeyWord sMessage sExportFile
83840>>>>>>>>>        Handle hoSql hoSQLConnect hoStmt hoError
83840>>>>>>>>>        Integer i iMsgs iRows iRowType iCount iChunkCounter iChunkMax iOut iNextSet iMessage iPos
83840>>>>>>>>>        String[] sMsg aSQLQueryMessages
83842>>>>>>>>>        DateTime dtQueryExecStart dtQueryExecEnd
83842>>>>>>>>>        TimeSpan tsQuery
83842>>>>>>>>>        tSqlErrorArray aSqlErrorArray
83842>>>>>>>>>        tSqlErrorArray aSqlErrorArray
83842>>>>>>>>>        tSQLConnection SQLConnection
83842>>>>>>>>>        tSQLConnection SQLConnection
83842>>>>>>>>>        Boolean bShowProgress
83842>>>>>>>>>
83842>>>>>>>>>        If (num_arguments > 4) Begin
83844>>>>>>>>>            Move bShowProgr to bShowProgress
83845>>>>>>>>>        End
83845>>>>>>>>>>
83845>>>>>>>>>        Get phoSQLManager to hoSql
83846>>>>>>>>>
83846>>>>>>>>>        Get _SqlFindKeyWord CI_SQLGO to sGOKeyWord
83847>>>>>>>>>        // There seems to be a problem to pass strings when their value gets really big, aka
83847>>>>>>>>>        // above the argument_size level. It isn't clear when these problems starts but sooner
83847>>>>>>>>>        // or later SqlExecDirect stops working correctly with no error messages!
83847>>>>>>>>>        // To guard from this we set a max number of lines (iChunkMax) that can be processed
83847>>>>>>>>>        // at a time. Testing with the Create Chinook Database script; 500 seems like a number that works fine.
83847>>>>>>>>>        // A bonus of this is that it turns out that it is actually faster to run in chunks!
83847>>>>>>>>>        Get piChunkMax to iChunkMax
83848>>>>>>>>>        Move 0 to iChunkCounter
83849>>>>>>>>>        Move "" to sStmt
83850>>>>>>>>>
83850>>>>>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
83851>>>>>>>>>        Move (Character(13) + Character(10)) to sCR
83852>>>>>>>>>
83852>>>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
83853>>>>>>>>>
83853>>>>>>>>>        Get phoSQLManager  to hoSQL
83854>>>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
83856>>>>>>>>>            If (Uppercase(SQLConnection.sConnectionString) contains CS_SQLIniDSNKeyword) Begin
83858>>>>>>>>>                Move (Pos(";", SQLConnection.sConnectionString)) to iPos
83859>>>>>>>>>                If (iPos > 0) Begin
83861>>>>>>>>>                    Move (Left(SQLConnection.sConnectionString, (iPos - 1))) to SQLConnection.sConnectionString
83862>>>>>>>>>                    Move (Trim(SQLConnection.sConnectionString)) to SQLConnection.sConnectionString
83863>>>>>>>>>                End
83863>>>>>>>>>>
83863>>>>>>>>>            End
83863>>>>>>>>>>
83863>>>>>>>>>        End
83863>>>>>>>>>>
83863>>>>>>>>>        Send SqlSetConnect of hoSQL sDriverID SQLConnection.sConnectionString
83864>>>>>>>>>        Get SqlConnect     of hoSQL "" "" to hoSQLConnect
83865>>>>>>>>>
83865>>>>>>>>>        If (hoSQLConnect <> 0) Begin
83867>>>>>>>>>            Move False to Err
83868>>>>>>>>>            Get SqlOpen of hoSQLConnect to hoStmt
83869>>>>>>>>>            If (hoStmt <> 0) Begin
83871>>>>>>>>>
83871>>>>>>>>>                // If the embedded resource should be written as a script file to disk:
83871>>>>>>>>>                If (bCreateScriptFile = True) Begin
83873>>>>>>>>>                    Get psHome of (phoWorkspace(ghoApplication)) to sExportFile
83874>>>>>>>>>                    Get vFolderFormat sExportFile to sExportFile
83875>>>>>>>>>                    Move (sExportFile + sMemFileName) to sExportFile
83876>>>>>>>>>                    Get Seq_New_Channel to iOut
83877>>>>>>>>>                    If (iOut <> DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
83879>>>>>>>>>                        Direct_Output channel iOut sExportFile
83881>>>>>>>>>                    End
83881>>>>>>>>>>
83881>>>>>>>>>                End
83881>>>>>>>>>>
83881>>>>>>>>>
83881>>>>>>>>>                // Record starting date/time stamp
83881>>>>>>>>>                Move (CurrentDateTime()) to dtQueryExecStart
83882>>>>>>>>>                // Turn on error handling if enabled
83882>>>>>>>>>                If (pbHandleQueryErrors(Self)) Begin
83884>>>>>>>>>                    Set pbSqlError to False
83885>>>>>>>>>                    Set paSqlErrorArray to aSqlErrorArray
83886>>>>>>>>>                    Move Error_Object_Id to hoError
83887>>>>>>>>>                    Move Self to Error_Object_Id
83888>>>>>>>>>                End
83888>>>>>>>>>>
83888>>>>>>>>>
83888>>>>>>>>>                Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iRows
83889>>>>>>>>>                Decrement iRows
83890>>>>>>>>>                If (sDriverID = MSSQLDRV_ID) Begin
83892>>>>>>>>>                    Move (sNoCountKeyWord + sCR) to sStmt
83893>>>>>>>>>                End
83893>>>>>>>>>>
83893>>>>>>>>>
83893>>>>>>>>>                for iCount from 0 to iRows
83899>>>>>>>>>>
83899>>>>>>>>>                    Move (SQLScriptArray.sSQLScriptArray[iCount]) to sSQLVal
83900>>>>>>>>>
83900>>>>>>>>>                    If (Uppercase(sSQLVal) <> sGOKeyWord) Begin
83902>>>>>>>>>                        If (sSQLVal <> "") Begin
83904>>>>>>>>>                            Move (sSQLVal + sCR) to sSQLVal
83905>>>>>>>>>                        End
83905>>>>>>>>>>
83905>>>>>>>>>                        Move (Append(sStmt, (sSQLVal))) to sStmt
83906>>>>>>>>>                    End
83906>>>>>>>>>>
83906>>>>>>>>>
83906>>>>>>>>>                    // - Each time we encounter a "GO" statement we execute it,
83906>>>>>>>>>                    // or if at the very end of the script.
83906>>>>>>>>>                    If (Uppercase(sSQLVal) = sGOKeyWord or iChunkCounter >= iChunkMax or iCount = iRows) Begin
83908>>>>>>>>>
83908>>>>>>>>>                        // - It turns out it can be at least 10 times faster to execute SQL statements in chunks,
83908>>>>>>>>>                        // instead of all in one go.
83908>>>>>>>>>                        Send SqlExecDirect of hoStmt sStmt
83909>>>>>>>>>
83909>>>>>>>>>                        If (bCreateScriptFile = True) Begin
83911>>>>>>>>>                            Write channel iOut sStmt
83913>>>>>>>>>                        End
83913>>>>>>>>>>
83913>>>>>>>>>                        Move "" to sStmt
83914>>>>>>>>>                        Move 0 to iChunkCounter
83915>>>>>>>>>                    End
83915>>>>>>>>>>
83915>>>>>>>>>                    Increment iChunkCounter
83916>>>>>>>>>                Loop
83917>>>>>>>>>>
83917>>>>>>>>>
83917>>>>>>>>>                Repeat
83917>>>>>>>>>>
83917>>>>>>>>>                    If (pbHandleQueryErrors(Self)) Begin
83919>>>>>>>>>                        Move hoError to Error_Object_Id
83920>>>>>>>>>                    End
83920>>>>>>>>>>
83920>>>>>>>>>                    Move (CurrentDateTime()) to dtQueryExecEnd
83921>>>>>>>>>
83921>>>>>>>>>                    Send _SqlColumnInfo hoStmt
83922>>>>>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT to iRows
83923>>>>>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
83924>>>>>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_NUMMESSAGES to iMsgs
83925>>>>>>>>>                    Set piRows    to iRows
83926>>>>>>>>>                    Set piRowType to iRowType
83927>>>>>>>>>
83927>>>>>>>>>                    If (iMsgs <> 0) Begin
83929>>>>>>>>>                        If (ghoDbUpdateHandler > 0) Begin
83931>>>>>>>>>                            Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
83932>>>>>>>>>                        End
83932>>>>>>>>>>
83932>>>>>>>>>                        for i from 1 to iMsgs
83938>>>>>>>>>>
83938>>>>>>>>>                            Get SqlGetMessage of hoStmt i to sMessage
83939>>>>>>>>>                            Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
83940>>>>>>>>>                            If (bShowProgress = True) Begin
83942>>>>>>>>>                                If (Active_State(ghoStatusPanel)) Begin
83944>>>>>>>>>                                    Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
83945>>>>>>>>>                                End
83945>>>>>>>>>>
83945>>>>>>>>>                                Else Begin
83946>>>>>>>>>                                    Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
83948>>>>>>>>>                                End
83948>>>>>>>>>>
83948>>>>>>>>>                            End
83948>>>>>>>>>>
83948>>>>>>>>>                            Move sMessage to sMsg[SizeOfArray(sMsg)]
83949>>>>>>>>>                            Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
83950>>>>>>>>>                        Loop
83951>>>>>>>>>>
83951>>>>>>>>>
83951>>>>>>>>>
83951>>>>>>>>>                        If (ghoDbUpdateHandler > 0) Begin
83953>>>>>>>>>                            Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
83954>>>>>>>>>                        End
83954>>>>>>>>>>
83954>>>>>>>>>                        Set paQueryMessages to sMsg
83955>>>>>>>>>                    End
83955>>>>>>>>>>
83955>>>>>>>>>
83955>>>>>>>>>                    Get SQLNextResultSet of hoStmt to iNextSet
83956>>>>>>>>>                Until (iNextSet = 0)
83958>>>>>>>>>
83958>>>>>>>>>                Move (CurrentDateTime()) to dtQueryExecEnd
83959>>>>>>>>>            End
83959>>>>>>>>>>
83959>>>>>>>>>
83959>>>>>>>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
83960>>>>>>>>>            Set ptsQueryExec to tsQuery
83961>>>>>>>>>            Send SqlClose of hoStmt
83962>>>>>>>>>
83962>>>>>>>>>            If (bCreateScriptFile = True) Begin
83964>>>>>>>>>                Close_Output channel iOut
83966>>>>>>>>>                Send Seq_Release_Channel iOut
83967>>>>>>>>>            End
83967>>>>>>>>>>
83967>>>>>>>>>        End
83967>>>>>>>>>>
83967>>>>>>>>>        Send SqlDisconnect of hoSQLConnect
83968>>>>>>>>>
83968>>>>>>>>>        Function_Return (hoSQLConnect <> 0 and Err = False)
83969>>>>>>>>>    End_Function
83970>>>>>>>>>
83970>>>>>>>>>    Function _SqlUtilCreatePostGreSQLDatabaseByScript String sMemScriptFile String sDatabaseName Returns Boolean
83972>>>>>>>>>        tSQLScriptArray SQLScriptArray
83972>>>>>>>>>        tSQLScriptArray SQLScriptArray
83972>>>>>>>>>        String sDriverID sCollation
83972>>>>>>>>>        Boolean bOK
83972>>>>>>>>>        Integer iSize iCount
83972>>>>>>>>>
83972>>>>>>>>>        If (Trim(sDatabaseName) = "") Begin
83974>>>>>>>>>            Function_Return False
83975>>>>>>>>>        End
83975>>>>>>>>>>
83975>>>>>>>>>
83975>>>>>>>>>        Get psDriverID  to sDriverID
83976>>>>>>>>>        Get psCollation to sCollation
83977>>>>>>>>>        Get _SqlUtilReadResource sMemScriptFile to SQLScriptArray
83978>>>>>>>>>        If (SQLScriptArray.bError = True) Begin
83980>>>>>>>>>            Function_Return False
83981>>>>>>>>>        End
83981>>>>>>>>>>
83981>>>>>>>>>
83981>>>>>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
83982>>>>>>>>>        Decrement iSize
83983>>>>>>>>>
83983>>>>>>>>>        For iCount from 0 to iSize
83989>>>>>>>>>>
83989>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "DATABASE_NAME_XXX") Begin
83991>>>>>>>>>                Move (Replaces("DATABASE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sDatabaseName))) to SQLScriptArray.sSQLScriptArray[iCount]
83992>>>>>>>>>            End
83992>>>>>>>>>>
83992>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLLATION_NAME_XXX") Begin
83994>>>>>>>>>                Move (Replaces("COLLATION_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sCollation))) to SQLScriptArray.sSQLScriptArray[iCount]
83995>>>>>>>>>            End
83995>>>>>>>>>>
83995>>>>>>>>>        Loop
83996>>>>>>>>>>
83996>>>>>>>>>
83996>>>>>>>>>        Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
83997>>>>>>>>>
83997>>>>>>>>>        Function_Return (bOK = True)
83998>>>>>>>>>    End_Function
83999>>>>>>>>>
83999>>>>>>>>>    Function _SqlUtilCreateMySQLDatabaseByScript String sMemScriptFile String sDatabaseName Returns Boolean
84001>>>>>>>>>        tSQLScriptArray SQLScriptArray
84001>>>>>>>>>        tSQLScriptArray SQLScriptArray
84001>>>>>>>>>        String sDriverID sCollation
84001>>>>>>>>>        Boolean bOK
84001>>>>>>>>>        Integer iSize iCount
84001>>>>>>>>>
84001>>>>>>>>>        If (Trim(sDatabaseName) = "") Begin
84003>>>>>>>>>            Function_Return False
84004>>>>>>>>>        End
84004>>>>>>>>>>
84004>>>>>>>>>
84004>>>>>>>>>        Get psDriverID  to sDriverID
84005>>>>>>>>>        Get psCollation to sCollation
84006>>>>>>>>>        Get _SqlUtilReadResource sMemScriptFile to SQLScriptArray
84007>>>>>>>>>        If (SQLScriptArray.bError = True) Begin
84009>>>>>>>>>            Function_Return False
84010>>>>>>>>>        End
84010>>>>>>>>>>
84010>>>>>>>>>
84010>>>>>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
84011>>>>>>>>>        Decrement iSize
84012>>>>>>>>>
84012>>>>>>>>>        For iCount from 0 to iSize
84018>>>>>>>>>>
84018>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "DATABASE_NAME_XXX") Begin
84020>>>>>>>>>                Move (Replaces("DATABASE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sDatabaseName))) to SQLScriptArray.sSQLScriptArray[iCount]
84021>>>>>>>>>            End
84021>>>>>>>>>>
84021>>>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLLATION_NAME_XXX") Begin
84023>>>>>>>>>                Move (Replaces("COLLATION_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sCollation))) to SQLScriptArray.sSQLScriptArray[iCount]
84024>>>>>>>>>            End
84024>>>>>>>>>>
84024>>>>>>>>>        Loop
84025>>>>>>>>>>
84025>>>>>>>>>        // ToDo: THIS FAILS BUT THE SQL SCRIPT WORKS IN MYSQL!
84025>>>>>>>>>        Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
84026>>>>>>>>>
84026>>>>>>>>>        Function_Return (bOK = True)
84027>>>>>>>>>    End_Function
84028>>>>>>>>>
84028>>>>>>>>>    Function _StrToFieldNumber Integer iFile String sField Returns Integer
84030>>>>>>>>>        Integer iMax iPos
84030>>>>>>>>>        String sName
84030>>>>>>>>>
84030>>>>>>>>>        Move (Lowercase(sField)) to sField
84031>>>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iMax
84034>>>>>>>>>        For iPos from 0 to iMax
84040>>>>>>>>>>
84040>>>>>>>>>            Get_Attribute DF_FIELD_NAME of iFile iPos to sName
84043>>>>>>>>>            Move (Lowercase(sName)) to sName
84044>>>>>>>>>            If (sName = sField) Begin
84046>>>>>>>>>                Function_Return iPos
84047>>>>>>>>>            End
84047>>>>>>>>>>
84047>>>>>>>>>        Loop
84048>>>>>>>>>>
84048>>>>>>>>>        Function_Return -1
84049>>>>>>>>>    End_Function
84050>>>>>>>>>
84050>>>>>>>>>    // Checks if the passed connection id exists in the CLI interface.
84050>>>>>>>>>    // This might be needed by API-methods when a connection id is to be used and
84050>>>>>>>>>    // the connection id hasn't been established with the driver's CLI interface.
84050>>>>>>>>>    // NOTE: Only applicable for DAW drivers.
84050>>>>>>>>>    Function IsConnectionID String sConnectionID String sDriverID Returns Boolean
84052>>>>>>>>>        String sID sConnString
84052>>>>>>>>>        Integer iDriver iNumConn iCount
84052>>>>>>>>>        Handle hoCLI
84052>>>>>>>>>        Boolean bOK
84052>>>>>>>>>
84052>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
84053>>>>>>>>>        If (bOK = False) Begin
84055>>>>>>>>>            Error DFERR_PROGRAM "Connection ID's can only be used with DAW drivers."
84056>>>>>>>>>>
84056>>>>>>>>>            Function_Return False
84057>>>>>>>>>        End
84057>>>>>>>>>>
84057>>>>>>>>>
84057>>>>>>>>>        Move False to bOK
84058>>>>>>>>>        Get phoCLIHandler to hoCLI
84059>>>>>>>>>        If (hoCLI <> 0) Begin
84061>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
84062>>>>>>>>>            Get DriverIndex of hoCLI sDriverID to iDriver
84063>>>>>>>>>
84063>>>>>>>>>            // If driver not loaded; load it.
84063>>>>>>>>>            If (iDriver = 0) Begin
84065>>>>>>>>>                Load_Driver sDriverID
84066>>>>>>>>>                Get DriverIndex sDriverID to iDriver
84067>>>>>>>>>            End
84067>>>>>>>>>>
84067>>>>>>>>>            If (iDriver <> 0) Begin
84069>>>>>>>>>                Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
84072>>>>>>>>>                Decrement iNumConn
84073>>>>>>>>>                For iCount from 0 to iNumConn
84079>>>>>>>>>>
84079>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iCount to sConnString
84082>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iCount to sID
84085>>>>>>>>>                    If (sID = sConnectionID) Begin
84087>>>>>>>>>                        Move True to bOK
84088>>>>>>>>>                    End
84088>>>>>>>>>>
84088>>>>>>>>>                Loop
84089>>>>>>>>>>
84089>>>>>>>>>            End
84089>>>>>>>>>>
84089>>>>>>>>>        End
84089>>>>>>>>>>
84089>>>>>>>>>
84089>>>>>>>>>        Function_Return bOK
84090>>>>>>>>>    End_Function
84091>>>>>>>>>
84091>>>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
84093>>>>>>>>>        Boolean bOK
84093>>>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID or sDriverID = DFBTRDRV_ID) to bOK
84094>>>>>>>>>        Function_Return bOK
84095>>>>>>>>>    End_Function
84096>>>>>>>>>
84096>>>>>>>>>    Function IsMSSQLDriver Returns Boolean
84098>>>>>>>>>        Integer iDriverIndex
84098>>>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriverIndex
84099>>>>>>>>>        Function_Return (iDriverIndex <> 0)
84100>>>>>>>>>    End_Function
84101>>>>>>>>>
84101>>>>>>>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
84101>>>>>>>>>    // attempt to load the driver.
84101>>>>>>>>>    // Returns true if the passed driver is SQL based.
84101>>>>>>>>>    Function IsSQLDriver String sDriverID Returns Boolean
84103>>>>>>>>>        Boolean bOK
84103>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
84104>>>>>>>>>        Function_Return bOK
84105>>>>>>>>>    End_Function
84106>>>>>>>>>
84106>>>>>>>>>    // *** Error Handler ***
84106>>>>>>>>>    //
84106>>>>>>>>>    // Note: If the cDbUpdateHandler & cDbUpdateVersion classes are used this error handler is _not_
84106>>>>>>>>>    //       used. Instead the Error_Report in the cDbUpdateHandler i used.
84106>>>>>>>>>    Procedure Error_Report Integer iErrorNumber Integer iErrorLine String sErrorText
84108>>>>>>>>>        Integer iSize iErrorMode
84108>>>>>>>>>        tSqlErrorArray aSqlErrorArray
84108>>>>>>>>>        tSqlErrorArray aSqlErrorArray
84108>>>>>>>>>
84108>>>>>>>>>        If (pbProcessingError(Self)) Begin
84110>>>>>>>>>            Procedure_Return
84111>>>>>>>>>        End
84111>>>>>>>>>>
84111>>>>>>>>>
84111>>>>>>>>>        Get Error_Report_Mode to iErrorMode
84112>>>>>>>>>        If (iErrorMode = DUF_ERROR_NO_REPORT) Begin
84114>>>>>>>>>            Procedure_Return
84115>>>>>>>>>        End
84115>>>>>>>>>>
84115>>>>>>>>>
84115>>>>>>>>>        Set pbProcessingError to True
84116>>>>>>>>>        Set pbSqlError to True
84117>>>>>>>>>        Get paSqlErrorArray      to aSqlErrorArray
84118>>>>>>>>>        Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iSize
84119>>>>>>>>>        Move sErrorText          to aSqlErrorArray.sSqlErrorArray[iSize]
84120>>>>>>>>>        Get psSQLStatementString to aSqlErrorArray.sSqlStatementArray[iSize]
84121>>>>>>>>>        Move iErrorNumber        to aSqlErrorArray.iSqlErrorArray[iSize]
84122>>>>>>>>>        Set paSqlErrorArray      to aSqlErrorArray
84123>>>>>>>>>        Set pbProcessingError to False
84124>>>>>>>>>    End_Procedure
84125>>>>>>>>>
84125>>>>>>>>>    // *** Miscellanous Helper Functions ***
84125>>>>>>>>>    //
84125>>>>>>>>>    // Helper function. Takes a DF_FILE_XXXX_NAME value as parameter and
84125>>>>>>>>>    // returns the table name only; stripped of any path or filename extension.
84125>>>>>>>>>    Function _TableNameOnly String sName Returns String
84127>>>>>>>>>        String sPath sExt
84127>>>>>>>>>
84127>>>>>>>>>        Get ParseFolderName sName to sPath
84128>>>>>>>>>        If (sPath <> "") Begin
84130>>>>>>>>>            Move (Replace(sPath, sName, "")) to sName
84131>>>>>>>>>        End
84131>>>>>>>>>>
84131>>>>>>>>>        Get ParseFileExtension sName to sExt
84132>>>>>>>>>        If (sExt <> "") Begin
84134>>>>>>>>>            Move (Replace(("." + sExt), sName, "")) to sName
84135>>>>>>>>>        End
84135>>>>>>>>>>
84135>>>>>>>>>
84135>>>>>>>>>        Function_Return sName
84136>>>>>>>>>    End_Function
84137>>>>>>>>>
84137>>>>>>>>>    // Removes any prefix to a table name.
84137>>>>>>>>>    // Example mssqldrv:mytable returns mytable
84137>>>>>>>>>    //         dbo.mytable returns mytable
84137>>>>>>>>>    Function _TableNoPrefix String sName Returns String
84139>>>>>>>>>        Integer iPos
84139>>>>>>>>>
84139>>>>>>>>>        Move (Pos(":", sName)) to iPos
84140>>>>>>>>>        If (iPos <> 0) Begin
84142>>>>>>>>>            Move (Mid(sName, 999, (iPos + 1))) to sName
84143>>>>>>>>>        End
84143>>>>>>>>>>
84143>>>>>>>>>        Move (Pos(".", sName)) to iPos
84144>>>>>>>>>        If (iPos <> 0) Begin
84146>>>>>>>>>            Move (Mid(sName, 999, (iPos + 1))) to sName
84147>>>>>>>>>        End
84147>>>>>>>>>>
84147>>>>>>>>>
84147>>>>>>>>>        Function_Return sName
84148>>>>>>>>>    End_Function
84149>>>>>>>>>
84149>>>>>>>>>    // Returns the first datapath found in the psDataPath property.
84149>>>>>>>>>    // The returned path always ends with a "\"
84149>>>>>>>>>    Function psDataPathFirstPart Returns String
84151>>>>>>>>>        String sDataPath
84151>>>>>>>>>        Integer iCount
84151>>>>>>>>>
84151>>>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
84152>>>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
84153>>>>>>>>>        If (iCount > 1) Begin
84155>>>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
84156>>>>>>>>>        End
84156>>>>>>>>>>
84156>>>>>>>>>        If (sDataPath <> "") Begin
84158>>>>>>>>>            Get vFolderFormat sDataPath to sDataPath
84159>>>>>>>>>        End
84159>>>>>>>>>>
84159>>>>>>>>>
84159>>>>>>>>>        Function_Return sDataPath
84160>>>>>>>>>    End_Function
84161>>>>>>>>>
84161>>>>>>>>>    Function psLogTextFileWithPath Returns String
84163>>>>>>>>>        String sFileName
84163>>>>>>>>>        Handle hoLogFile
84163>>>>>>>>>        Get phoLogFile to hoLogFile
84164>>>>>>>>>        Get psLogTextFileWithPath of hoLogFile to sFileName
84165>>>>>>>>>        Function_Return sFileName
84166>>>>>>>>>    End_Function
84167>>>>>>>>>
84167>>>>>>>>>    Function phoLogFile Returns Handle
84169>>>>>>>>>        Handle hoLogFile   
84169>>>>>>>>>        Boolean bErr
84169>>>>>>>>>        
84169>>>>>>>>>        Move Err to bErr
84170>>>>>>>>>        Move 0 to hoLogFile
84171>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT  
84172>>>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
84173>>>>>>>>>        Delegate Get phoLogFile to hoLogFile
84175>>>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
84176>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
84177>>>>>>>>>        Move bErr to Err
84178>>>>>>>>>        
84178>>>>>>>>>        Function_Return hoLogFile
84179>>>>>>>>>    End_Function
84180>>>>>>>>>
84180>>>>>>>>>    Function pnCurrentVersionUpdate Returns Number
84182>>>>>>>>>        Number nCurrentVersionUpdate
84182>>>>>>>>>
84182>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
84183>>>>>>>>>        Delegate Get pnCurrentVersionUpdate to nCurrentVersionUpdate
84185>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
84186>>>>>>>>>
84186>>>>>>>>>        Function_Return nCurrentVersionUpdate
84187>>>>>>>>>    End_Function
84188>>>>>>>>>
84188>>>>>>>>>    Procedure LogError String sText Boolean bError
84190>>>>>>>>>        Handle hoLogFile
84190>>>>>>>>>        Number nCurrentVersionUpdate
84190>>>>>>>>>
84190>>>>>>>>>        Get phoLogFile to hoLogFile
84191>>>>>>>>>        If (hoLogFile = 0) Begin
84193>>>>>>>>>            Procedure_Return
84194>>>>>>>>>        End
84194>>>>>>>>>>
84194>>>>>>>>>        Get pnCurrentVersionUpdate to nCurrentVersionUpdate
84195>>>>>>>>>
84195>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
84196>>>>>>>>>        Send LogError of hoLogFile nCurrentVersionUpdate 0 sText 0 bError
84197>>>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
84198>>>>>>>>>    End_Procedure
84199>>>>>>>>>
84199>>>>>>>>>    Function pbContinueOnError Returns Boolean
84201>>>>>>>>>        Boolean bContinueOnError
84201>>>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
84203>>>>>>>>>            Get pbContinueOnError of ghoDbUpdateHandler to bContinueOnError
84204>>>>>>>>>        End
84204>>>>>>>>>>
84204>>>>>>>>>        Function_Return bContinueOnError
84205>>>>>>>>>    End_Function
84206>>>>>>>>>
84206>>>>>>>>>
84206>>>>>>>>>    Function _UtilUpdateTAGFile String sFullTAGFileName String sColumnName Returns Boolean
84208>>>>>>>>>        Integer iChIn iChOut // iCount
84208>>>>>>>>>        Boolean bExists
84208>>>>>>>>>        String sExistingColumn
84208>>>>>>>>>
84208>>>>>>>>>        Move False to bExists
84209>>>>>>>>>        Get Seq_New_Channel to iChIn
84210>>>>>>>>>        Get Seq_New_Channel to iChOut
84211>>>>>>>>>        If (iChIn = DF_SEQ_CHANNEL_NOT_AVAILABLE or iChOut = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
84213>>>>>>>>>            Function_Return True
84214>>>>>>>>>        End
84214>>>>>>>>>>
84214>>>>>>>>>
84214>>>>>>>>>        Move False to Err
84215>>>>>>>>>        // The following line should also use the channel attribute. (Thank you, Hans van de Laar)
84215>>>>>>>>>        Direct_Input channel iChIn ("'" + sFullTAGFileName + "'")
84217>>>>>>>>>        While (not(SeqEof))
84221>>>>>>>>>            Readln channel iChIn sExistingColumn
84223>>>>>>>>>            If (Uppercase(sExistingColumn) = Uppercase(sColumnName)) Begin
84225>>>>>>>>>                Move True to bExists
84226>>>>>>>>>            End
84226>>>>>>>>>>
84226>>>>>>>>>            If (Trim(sExistingColumn) = "") Begin
84228>>>>>>>>>                Move True to SeqEof
84229>>>>>>>>>            End
84229>>>>>>>>>>
84229>>>>>>>>>        Loop
84230>>>>>>>>>>
84230>>>>>>>>>        Close_Input channel iChIn
84232>>>>>>>>>        Send Seq_Release_Channel iChIn
84233>>>>>>>>>
84233>>>>>>>>>        If (bExists = False) Begin
84235>>>>>>>>>            Append_Output channel iChOut sFullTAGFileName
84237>>>>>>>>>            Writeln channel iChOut sColumnName
84240>>>>>>>>>            Close_Output channel iChOut
84242>>>>>>>>>            Send Seq_Release_Channel iChOut
84243>>>>>>>>>        End
84243>>>>>>>>>>
84243>>>>>>>>>
84243>>>>>>>>>        Function_Return (Err = False)
84244>>>>>>>>>    End_Function
84245>>>>>>>>>
84245>>>>>>>>>    // Changes source code files.
84245>>>>>>>>>    // Pass a file name with full path and a value to search for, together with the value
84245>>>>>>>>>    // to change to. Can e.g. be used for changing all .int files from using a fixed server name,
84245>>>>>>>>>    // to use a Connection ID.
84245>>>>>>>>>    // Sample: Get _UtilChangeSourceCodeLine "C:\DataFlex 18.2 Examples\Order Entry\Data\Order.int" "SERVER_NAME SERVER=(local)\SQLEXPRESS1" "SERVER_NAME DFCONNID=ChinookDb"
84245>>>>>>>>>    // Pass "True" for the bShowResult if you want to see the result while it works. Showln will then be used for output
84245>>>>>>>>>    // Returns True if no errors occured.
84245>>>>>>>>>    Function _UtilChangeSourceCodeLine String sFileName String sChangeFrom String sChangeTo Boolean bShowResult Returns Boolean
84247>>>>>>>>>        Integer iCh iRow iItems iCount
84247>>>>>>>>>        String sValue sRow
84247>>>>>>>>>        String[] sFileArray
84248>>>>>>>>>        Boolean bExists bIsActive
84248>>>>>>>>>
84248>>>>>>>>>        Move False to Err
84249>>>>>>>>>        Move 0 to iRow
84250>>>>>>>>>
84250>>>>>>>>>        If (ghoStatusPanel <> 0) Begin
84252>>>>>>>>>            Get Active_state of ghoStatusPanel to bIsActive
84253>>>>>>>>>        End
84253>>>>>>>>>>
84253>>>>>>>>>
84253>>>>>>>>>        Get vFilePathExists sFileName to bExists
84254>>>>>>>>>        If (bExists = False) Begin
84256>>>>>>>>>            If (bShowResult = True) Begin
84258>>>>>>>>>                If (bIsActive = True) Begin
84260>>>>>>>>>                    Send Update_StatusPanel of ghoStatusPanel ("File does not exist:" * String(sFileName))
84261>>>>>>>>>                End
84261>>>>>>>>>>
84261>>>>>>>>>                Else Begin
84262>>>>>>>>>                    Showln "File does not exist: " sFileName
84265>>>>>>>>>                End
84265>>>>>>>>>>
84265>>>>>>>>>            End
84265>>>>>>>>>>
84265>>>>>>>>>            Function_Return False
84266>>>>>>>>>        End
84266>>>>>>>>>>
84266>>>>>>>>>
84266>>>>>>>>>        Get Seq_Open_Input_Channel sFileName to iCh
84267>>>>>>>>>        If (iCh < 1) Begin
84269>>>>>>>>>            Function_Return False
84270>>>>>>>>>        End
84270>>>>>>>>>>
84270>>>>>>>>>
84270>>>>>>>>>        If (bShowResult = True) Begin
84272>>>>>>>>>            If (ghoStatusPanel <> 0) Begin
84274>>>>>>>>>                Get Active_state of ghoStatusPanel to bIsActive
84275>>>>>>>>>                If (bIsActive = True) Begin
84277>>>>>>>>>                    Set Message_Text of ghoStatusPanel to sFileName
84278>>>>>>>>>                    Send Update_StatusPanel of ghoStatusPanel ("sChangeFrom =" * String(sChangeFrom) * "sChangeTo =" * String(sChangeTo))
84279>>>>>>>>>                    Send DoAdvance of ghoProgressBar
84280>>>>>>>>>                End
84280>>>>>>>>>>
84280>>>>>>>>>            End
84280>>>>>>>>>>
84280>>>>>>>>>            Else Begin
84281>>>>>>>>>                Showln ""
84283>>>>>>>>>                Showln "sFileName = " sFileName
84286>>>>>>>>>                Showln "sChangeFrom = " sChangeFrom " sChangeTo = " sChangeTo
84291>>>>>>>>>            End
84291>>>>>>>>>>
84291>>>>>>>>>        End
84291>>>>>>>>>>
84291>>>>>>>>>
84291>>>>>>>>>        While (not(SeqEof))
84295>>>>>>>>>            Readln channel iCh sRow
84297>>>>>>>>>            If (Uppercase(sRow) contains Uppercase(sChangeFrom)) Begin
84299>>>>>>>>>//                If (bShowResult = True) Begin
84299>>>>>>>>>//                    If (bIsActive = True) Begin
84299>>>>>>>>>//                        Send Update_StatusPanel of ghoStatusPanel ("Changed from:" * String(sRow) * "to:" * String(sChangeTo))
84299>>>>>>>>>//                    End
84299>>>>>>>>>//                    Else Begin
84299>>>>>>>>>//                        Showln "Changed from: " sRow " to: " sChangeTo
84299>>>>>>>>>//                    End
84299>>>>>>>>>//                End
84299>>>>>>>>>                // Change the whole line to the new connection id:
84299>>>>>>>>>                Move sChangeTo to sRow
84300>>>>>>>>>                // Move (Replaces(sChangeFrom, sRow, sChangeTo)) to sValue
84300>>>>>>>>>            End
84300>>>>>>>>>>
84300>>>>>>>>>            Move sRow to sFileArray[iRow]
84301>>>>>>>>>            Increment iRow
84302>>>>>>>>>        Loop
84303>>>>>>>>>>
84303>>>>>>>>>        Send Seq_Close_Channel iCh
84304>>>>>>>>>
84304>>>>>>>>>        Sleep 1 // Wait for Windows to close the file
84305>>>>>>>>>
84305>>>>>>>>>        Get Seq_Open_Output_Channel sFileName to iCh
84306>>>>>>>>>        If (iCh < 1) Begin
84308>>>>>>>>>            Function_Return False
84309>>>>>>>>>        End
84309>>>>>>>>>>
84309>>>>>>>>>        Move (SizeOfArray(sFileArray)) to iItems
84310>>>>>>>>>        Decrement iItems
84311>>>>>>>>>
84311>>>>>>>>>        for iCount from 0 to iItems
84317>>>>>>>>>>
84317>>>>>>>>>            Move sFileArray[iCount] to sValue
84318>>>>>>>>>            Writeln channel iCh sValue
84321>>>>>>>>>        Loop
84322>>>>>>>>>>
84322>>>>>>>>>        Send Seq_Close_Channel iCh
84323>>>>>>>>>
84323>>>>>>>>>        Function_Return (Err = False)
84324>>>>>>>>>    End_Function
84325>>>>>>>>>
84325>>>>>>>>>    // This message creates an error log in the "Home" folder named "SQLErrorLog.txt",
84325>>>>>>>>>    // and opens it in "notepad.exe".
84325>>>>>>>>>    // Note: This is _not_ used by the cDbUpdateHandler & cDbUpdateVersion classes!
84325>>>>>>>>>    //       Instead the cDbUpdateLogFile's WriteErrorLog & ShowErrorLog are used.
84325>>>>>>>>>    Procedure _UtilShowErrorList
84327>>>>>>>>>        tSqlErrorArray aSqlErrorArray
84327>>>>>>>>>        tSqlErrorArray aSqlErrorArray
84327>>>>>>>>>        Integer iRows iCount iCh iErrorNum
84327>>>>>>>>>        String sPath sFileName sErrorTxt sStatement
84327>>>>>>>>>
84327>>>>>>>>>        Get psHome of (phoWorkspace(ghoApplication)) to sPath
84328>>>>>>>>>        Get vFolderFormat sPath to sPath
84329>>>>>>>>>        Move "SQLErrorLog.txt"  to sFileName
84330>>>>>>>>>        Get Seq_Open_Output_Channel (sPath + sFileName) to iCh
84331>>>>>>>>>            Get paSqlErrorArray to aSqlErrorArray
84332>>>>>>>>>            Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iRows
84333>>>>>>>>>            If (iRows > 0) Begin
84335>>>>>>>>>                Decrement iRows
84336>>>>>>>>>                for iCount from 0 to iRows
84342>>>>>>>>>>
84342>>>>>>>>>                    Move aSqlErrorArray.sSqlErrorArray[iCount]      to sErrorTxt
84343>>>>>>>>>                    Move aSqlErrorArray.sSqlStatementArray[iCount]  to sStatement
84344>>>>>>>>>                    Move aSqlErrorArray.iSqlErrorArray[iCount]      to iErrorNum
84345>>>>>>>>>                    Writeln channel iCh "Error No: " iErrorNum " Error Text: " sErrorTxt
84351>>>>>>>>>                    Writeln channel iCh "SQL Statement: " sStatement
84355>>>>>>>>>                Loop
84356>>>>>>>>>>
84356>>>>>>>>>            End
84356>>>>>>>>>>
84356>>>>>>>>>        Send Seq_Close_Channel iCh
84357>>>>>>>>>
84357>>>>>>>>>        If (iRows > 0) Begin
84359>>>>>>>>>            Runprogram Shell Background (sPath + sFileName)
84360>>>>>>>>>        End
84360>>>>>>>>>>
84360>>>>>>>>>    End_Procedure
84361>>>>>>>>>
84361>>>>>>>>>    // For this to be returning a True value, the table number needs to be in the Filelist.cfg,
84361>>>>>>>>>    // and the table needs to exist as an SQL table.
84361>>>>>>>>>    Function _UtilTableIsSql Handle hTable Returns Boolean
84363>>>>>>>>>        String sRootName sDriverID
84363>>>>>>>>>        Boolean bIsSQL
84363>>>>>>>>>
84363>>>>>>>>>        Move False to bIsSQL
84364>>>>>>>>>        If (hTable > 0) Begin
84366>>>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84369>>>>>>>>>            Get _UtilTableIsSqlByRootName sRootName to bIsSQL
84370>>>>>>>>>            If (bIsSQL = True) Begin
84372>>>>>>>>>                Get psDriverID to sDriverID
84373>>>>>>>>>                Get _TableNameOnly sRootName to sRootName
84374>>>>>>>>>                Get _SqlUtilCheckIfTableNameExists sRootName sDriverID to bIsSQL
84375>>>>>>>>>            End
84375>>>>>>>>>>
84375>>>>>>>>>        End
84375>>>>>>>>>>
84375>>>>>>>>>
84375>>>>>>>>>        Function_Return bIsSQL
84376>>>>>>>>>    End_Function
84377>>>>>>>>>
84377>>>>>>>>>    Function _UtilTableIsSqlByRootName String sRootName Returns Boolean
84379>>>>>>>>>        Boolean bIsSQL
84379>>>>>>>>>        Move (sRootName contains ":") to bIsSQL
84380>>>>>>>>>        Function_Return bIsSQL
84381>>>>>>>>>    End_Function
84382>>>>>>>>>
84382>>>>>>>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
84382>>>>>>>>>    Function _SqlUtilCheckIfTableNameExists String sTableName String sDriverID Returns Boolean
84384>>>>>>>>>        String sDatabase sSchema sVal
84384>>>>>>>>>        Boolean bExists
84384>>>>>>>>>        String[] sTablesArray
84385>>>>>>>>>        Integer iSize iCount
84385>>>>>>>>>
84385>>>>>>>>>        Move False to bExists
84386>>>>>>>>>        Get psDatabase to sDatabase
84387>>>>>>>>>        Get psSchema   to sSchema
84388>>>>>>>>>        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
84389>>>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
84390>>>>>>>>>        Decrement iSize
84391>>>>>>>>>        for iCount from 0 to iSize
84397>>>>>>>>>>
84397>>>>>>>>>            Move sTablesArray[iCount] to sVal
84398>>>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
84400>>>>>>>>>                Move True to bExists
84401>>>>>>>>>                Move iSize to iCount // We're done!
84402>>>>>>>>>            End
84402>>>>>>>>>>
84402>>>>>>>>>        Loop
84403>>>>>>>>>>
84403>>>>>>>>>
84403>>>>>>>>>        Function_Return bExists
84404>>>>>>>>>    End_Function
84405>>>>>>>>>
84405>>>>>>>>>    // Checks that the passed hTable number both exists in Filelist.cfg and
84405>>>>>>>>>    // that the embedded .dat file exists on disk.
84405>>>>>>>>>    Function _UtilTableIsEmbedded Handle hTable Returns Boolean
84407>>>>>>>>>        Boolean bExists bIsEmbedded
84407>>>>>>>>>        String sDataPath sRootName
84407>>>>>>>>>
84407>>>>>>>>>        Get _UtilTableNumberIsInUse hTable to bExists
84408>>>>>>>>>        If (bExists = False) Begin
84410>>>>>>>>>            Function_Return False
84411>>>>>>>>>        End
84411>>>>>>>>>>
84411>>>>>>>>>
84411>>>>>>>>>        Move False to bIsEmbedded
84412>>>>>>>>>        If (hTable > 0) Begin
84414>>>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84417>>>>>>>>>            Move (not(sRootName contains ":")) to bIsEmbedded
84418>>>>>>>>>        End
84418>>>>>>>>>>
84418>>>>>>>>>        If (bIsEmbedded = True) Begin
84420>>>>>>>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
84421>>>>>>>>>            Get vFolderFormat sDataPath to sDataPath
84422>>>>>>>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bIsEmbedded
84423>>>>>>>>>        End
84423>>>>>>>>>>
84423>>>>>>>>>
84423>>>>>>>>>        Function_Return bIsEmbedded
84424>>>>>>>>>    End_Function
84425>>>>>>>>>
84425>>>>>>>>>End_Class
84426>>>>>>>
84426>>>>>>>Class cDbUpdateFunctionLibrary is a cBaseDbUpdateFuncLib
84427>>>>>>>
84427>>>>>>>    Procedure Construct_Object
84429>>>>>>>        Forward Send Construct_Object
84431>>>>>>>        Move Self to ghoDbUpdateFunctionLibrary
84432>>>>>>>    End_Procedure
84433>>>>>>>
84433>>>>>>>    Procedure End_Construct_Object
84435>>>>>>>        Forward Send End_Construct_Object
84437>>>>>>>    End_Procedure
84438>>>>>>>
84438>>>>>>>    // *** SQL Messages for making changes to the SQL back-end ***
84438>>>>>>>    //
84438>>>>>>>    // * Dummy function for the Studio's Code Explorer *
84438>>>>>>>    Function SQL_DATABASE_FUNCTIONS Returns Boolean
84440>>>>>>>        Function_Return False
84441>>>>>>>    End_Function
84442>>>>>>>
84442>>>>>>>    // Function for creating a new *Database*.
84442>>>>>>>    // Note: This is for creating SQL DATABASES - not tables!
84442>>>>>>>    // Returns True if successful.
84442>>>>>>>    // ToDo: Currently only works for MS-SQL...
84442>>>>>>>    Function SqlDatabaseCreate String sDriverID String sDatabase Boolean bUpdateConnectionString Boolean bPermanantly Returns Boolean
84444>>>>>>>        String sSQL sSQL1 sConnectionID sConnectionString
84444>>>>>>>        String sCreateDatabaseKeyWord sSelectFromWhereName sCollation sCollateKeyWord
84444>>>>>>>        Handle hConnection hStmt hoSQLManager
84444>>>>>>>        Integer iFetchResult iDbType
84444>>>>>>>        Boolean bOK bExists
84444>>>>>>>
84444>>>>>>>        Get piDbType to iDbType
84445>>>>>>>        If (iDbType <> EN_DbTypeMSSQL and iDbType <> EN_DbTypeDB2 and iDbType <> EN_DbTypeMySQL and iDbType <> EN_DbTypePostgre) Begin
84447>>>>>>>            Error DFERR_PROGRAM "Sorry, the SqlDatabaseCreate function is currently only supported for MS-SQL, MySQL & PostGre and DB2 drivers"
84448>>>>>>>>
84448>>>>>>>            Function_Return False
84449>>>>>>>        End
84449>>>>>>>>
84449>>>>>>>
84449>>>>>>>        Get SqlUtilCheckIfDatabaseExists sDatabase to bExists
84450>>>>>>>        If (bExists = True) Begin
84452>>>>>>>            Function_Return True
84453>>>>>>>        End
84453>>>>>>>>
84453>>>>>>>
84453>>>>>>>        Get phoSQLManager to hoSQLManager
84454>>>>>>>
84454>>>>>>>        Get psConnectionID     to sConnectionID
84455>>>>>>>        Get psConnectionString to sConnectionString
84456>>>>>>>        Move 0 to LastErr
84457>>>>>>>
84457>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
84459>>>>>>>            // If an ODBC data source (DSN) we cannot pass the UID & PWD; so strip them from the connection string.
84459>>>>>>>            // ToDo: 2018-08-11 I think this is wrong and the uid & pw should be there.
84459>>>>>>>//            If (Uppercase(sConnectionString) contains CS_SQLIniDSNKeyword) Begin
84459>>>>>>>//                Move (Pos(";", sConnectionString)) to iPos
84459>>>>>>>//                If (iPos > 0) Begin
84459>>>>>>>//                    Move (Left(sConnectionString, (iPos - 1))) to sConnectionString
84459>>>>>>>//                    Move (Trim(sConnectionString)) to sConnectionString
84459>>>>>>>//                End
84459>>>>>>>//            End
84459>>>>>>>        End
84459>>>>>>>>
84459>>>>>>>
84459>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
84460>>>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
84461>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
84462>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
84464>>>>>>>            Error DFERR_PROGRAM (CS_DUF_LoginToDbServerFailed + "\n" + sConnectionString)
84465>>>>>>>>
84465>>>>>>>            Function_Return False
84466>>>>>>>        End
84466>>>>>>>>
84466>>>>>>>
84466>>>>>>>        Get SqlOpen of hConnection to hStmt
84467>>>>>>>
84467>>>>>>>        If (hStmt = 0) Begin
84469>>>>>>>            Send SqlDisconnect of hoSQLManager
84470>>>>>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
84471>>>>>>>>
84471>>>>>>>            Function_Return False
84472>>>>>>>        End
84472>>>>>>>>
84472>>>>>>>
84472>>>>>>>        Get psCollation to sCollation
84473>>>>>>>
84473>>>>>>>        Case Begin
84473>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
84475>>>>>>>                Get _SqlFindKeyWord CI_SQLCreateDatabase to sCreateDatabaseKeyWord
84476>>>>>>>                Get _SqlSelectFromWhereName to sSelectFromWhereName
84477>>>>>>>                Move (sSelectFromWhereName + "='" + sDatabase + "'") to sSQL
84478>>>>>>>
84478>>>>>>>                // Check if database exists
84478>>>>>>>                Send SqlExecDirect of hStmt sSQL
84479>>>>>>>                Get SqlFetch of hStmt to iFetchResult
84480>>>>>>>                Send SqlClose of hStmt
84481>>>>>>>                Send SqlDisconnect of hConnection
84482>>>>>>>                // If database already exists we're out of here!
84482>>>>>>>                // Note that we return True as this is not an error.
84482>>>>>>>                If (iFetchResult > 0) Begin
84484>>>>>>>                    Function_Return True
84485>>>>>>>                End
84485>>>>>>>>
84485>>>>>>>                // Database doesn't exist, create it.
84485>>>>>>>                If (iFetchResult = 0) Begin
84487>>>>>>>                    Move (sCreateDatabaseKeyWord + " [" + sDatabase + "]") to sSQL1
84488>>>>>>>                    Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84489>>>>>>>                    If (sCollation <> "") Begin
84491>>>>>>>                        Get _SqlFindKeyWord CI_SQLDatabaseCollation to sCollateKeyWord
84492>>>>>>>                        Move (sSQL1 * String(sCollateKeyWord) * String(sCollation)) to sSQL1
84493>>>>>>>                    End
84493>>>>>>>>
84493>>>>>>>                    Send SqlUtilExecuteQuery sSQL1 sDriverID
84494>>>>>>>                    Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84495>>>>>>>                    If (LastErr = CLIERR_GENERAL_ERROR) Begin
84497>>>>>>>                        Function_Return False
84498>>>>>>>                    End
84498>>>>>>>>
84498>>>>>>>                    // We need to wait a short time for Sql to finish, especially Windows to write the new file to disk.
84498>>>>>>>                    Sleep 1
84499>>>>>>>                    Send SqlUtilExecuteQuery sSQL sDriverID
84500>>>>>>>                End
84500>>>>>>>>
84500>>>>>>>                Case Break
84501>>>>>>>
84501>>>>>>>            Case (iDbType = EN_DbTypeMySQL and sDriverID = ODBC_DRV_ID)
84504>>>>>>>                // ToDo: How should this be set/checked?
84504>>>>>>>//                If (Lowercase(Left(sCollation, 3)) <> "utf") Begin
84504>>>>>>>//                    Set psCollation to "utf8"
84504>>>>>>>//                End
84504>>>>>>>                SQLIncludeScriptFile ..\Scripts\CreateMySQLDatabase.sql as CreateMySQLDatabase.sql
84504>>>>>>>                Get _SqlUtilCreateMySQLDatabaseByScript "CreateMySQLDatabase.sql" sDatabase to bOK
84505>>>>>>>                Case Break
84506>>>>>>>
84506>>>>>>>            Case Else
84506>>>>>>>                Error DFERR_PROGRAM "Unsupported database type"
84507>>>>>>>>
84507>>>>>>>        Case End
84507>>>>>>>
84507>>>>>>>        If (Err = False) Begin
84509>>>>>>>            Send LogError ("The Database:" * String(sDatabase) * "was created successfully for driver:" * String(sDriverID)) False
84510>>>>>>>        End
84510>>>>>>>>
84510>>>>>>>        // If used in e.g. the cDbUpdateHandler we want to change the login database name to
84510>>>>>>>        // the one we just created.
84510>>>>>>>        If (bUpdateConnectionString = True and Err = False) Begin
84512>>>>>>>            Set psDatabase to sDatabase
84513>>>>>>>            //...and perhaps also the SQLConnections.ini file setting.
84513>>>>>>>            If (bPermanantly = True) Begin
84515>>>>>>>                If (ghoSQLConnectionHandler <> 0) Begin
84517>>>>>>>                    Get SQLIniFileSetDefaultConnection of ghoSQLConnectionHandler sConnectionID to bOK
84518>>>>>>>                End
84518>>>>>>>>
84518>>>>>>>            End
84518>>>>>>>>
84518>>>>>>>        End
84518>>>>>>>>
84518>>>>>>>
84518>>>>>>>        Function_Return (Err = False)
84519>>>>>>>    End_Function
84520>>>>>>>
84520>>>>>>>    // Backs up an SQL database to a folder of choice. If no path is passed the SQL default backup folder
84520>>>>>>>    // will be used.
84520>>>>>>>    Function SqlDatabaseBackupToDisk String sDatabase String sBackupName String sPath Boolean bShowProg Returns Boolean
84522>>>>>>>        Boolean bOK bExists bShowProgress bErr
84522>>>>>>>        String sStatement sDriverID
84522>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
84522>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
84522>>>>>>>        Integer iDbType
84522>>>>>>>
84522>>>>>>>        If (sDatabase = "") Begin
84524>>>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
84525>>>>>>>>
84525>>>>>>>            Function_Return False
84526>>>>>>>        End
84526>>>>>>>>
84526>>>>>>>        If (sBackupName = "") Begin
84528>>>>>>>            Error DFERR_PROGRAM "The database backup name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
84529>>>>>>>>
84529>>>>>>>            Function_Return False
84530>>>>>>>        End
84530>>>>>>>>
84530>>>>>>>
84530>>>>>>>        // Create backup-folder if it doesn't exist
84530>>>>>>>        Get vFolderExists sPath to bExists
84531>>>>>>>        If (bExists = False) Begin
84533>>>>>>>            Get vCreateDirectory sPath to bErr
84534>>>>>>>            If (bErr = True) Begin
84536>>>>>>>                Error DFERR_PROGRAM ("Could not create database backup folder:" * sPath)
84537>>>>>>>>
84537>>>>>>>                Function_Return False
84538>>>>>>>            End
84538>>>>>>>>
84538>>>>>>>        End
84538>>>>>>>>
84538>>>>>>>        // Make sure the path ends with a back-slash
84538>>>>>>>        If (sPath <> "") Begin
84540>>>>>>>            Get vFolderFormat sPath to sPath
84541>>>>>>>        End
84541>>>>>>>>
84541>>>>>>>
84541>>>>>>>        Get psDriverID to sDriverID
84542>>>>>>>        Get piDbType   to iDbType
84543>>>>>>>        If (num_arguments > 3) Begin
84545>>>>>>>            Move bShowProg to bShowProgress
84546>>>>>>>        End
84546>>>>>>>>
84546>>>>>>>
84546>>>>>>>        Case Begin
84546>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
84548>>>>>>>                SQLIncludeScriptFile ..\Scripts\BackupMSSQLDatabase.sql as BackupMSSQLDatabase.sql
84548>>>>>>>                SQLIncludeScriptFile ..\Scripts\GetPercentageBackupCompletionMSSQL.sql as GetPercentageBackupCompletionMSSQL.sql
84548>>>>>>>                Get _SqlUtilReadResource  "BackupMSSQLDatabase.sql" sDriverID False to SQLScriptArray
84549>>>>>>>                Get _SqlUtilReadResource "GetPercentageBackupCompletionMSSQL.sql" sDriverID False to SQLScriptArrayPercentReady
84550>>>>>>>
84550>>>>>>>                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
84551>>>>>>>                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase))   to sStatement
84552>>>>>>>                Move (Replaces("BACKUP_PATH_XXX",   sStatement, sPath))       to sStatement
84553>>>>>>>                Move (Replaces("BACKUP_NAME_XXX",   sStatement, sBackupName)) to sStatement
84554>>>>>>>                Move sStatement to SQLScriptArray.sSQLScriptArray[0]
84555>>>>>>>                Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" bShowProgress to bOK
84556>>>>>>>                Case Break
84557>>>>>>>            Case Else
84557>>>>>>>                Send Info_Box ("The SqlUtilBackupDatabaseToDisk function is currently not implemented for the driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and add a little ESQL code snippet to make it work for that driver! Thanks for helping out.")
84558>>>>>>>        Case End
84558>>>>>>>
84558>>>>>>>        Function_Return bOK
84559>>>>>>>    End_Function
84560>>>>>>>
84560>>>>>>>    Function SqlDatabaseCollationQuery String sDatabase Boolean bSilent Returns String
84562>>>>>>>        String sStatement sDriverID sRetval //sPrevious
84562>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
84562>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
84562>>>>>>>        Integer iDbType iRows iFetchResult //iColumn
84562>>>>>>>        Handle hoSQLHandler hoSQLConnect hstmt
84562>>>>>>>        tSQLConnection SQLConnection
84562>>>>>>>        tSQLConnection SQLConnection
84562>>>>>>>
84562>>>>>>>        If (sDatabase = "") Begin
84564>>>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilDatabaseCollation' function"
84565>>>>>>>>
84565>>>>>>>            Function_Return ""
84566>>>>>>>        End
84566>>>>>>>>
84566>>>>>>>
84566>>>>>>>        Move "" to sRetval
84567>>>>>>>        Get psDriverID to sDriverID
84568>>>>>>>        Get piDbType   to iDbType
84569>>>>>>>
84569>>>>>>>        Case Begin
84569>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
84571>>>>>>>                SQLIncludeScriptFile ..\Scripts\QueryMSSQLCollation.sql as QueryMSSQLCollation.sql
84571>>>>>>>                Get _SqlUtilReadResource "QueryMSSQLCollation.sql" sDriverID False to SQLScriptArray
84572>>>>>>>
84572>>>>>>>                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
84573>>>>>>>                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase)) to sStatement
84574>>>>>>>                Get phoSQLManager to hoSQLHandler
84575>>>>>>>
84575>>>>>>>                If (hoSQLHandler <> 0) Begin
84577>>>>>>>                    Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
84578>>>>>>>                    Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
84579>>>>>>>
84579>>>>>>>                    If (hoSQLConnect <> 0) Begin
84581>>>>>>>                        Get SQLOpen of hoSQLConnect to hstmt
84582>>>>>>>                        If (hstmt <> 0) Begin
84584>>>>>>>                            Send SqlExecDirect of hstmt sStatement
84585>>>>>>>                            Get SqlStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
84586>>>>>>>                            Get SQLFetch of hstmt to iFetchResult
84587>>>>>>>                            If (iFetchResult <> 0) Begin
84589>>>>>>>                                Get SQLColumnValue of hstmt 2 to sRetval // Column 1 = Database Name, 2 = Collation Name.
84590>>>>>>>                            End
84590>>>>>>>>
84590>>>>>>>                            Send SQLClose of hstmt
84591>>>>>>>                        End
84591>>>>>>>>
84591>>>>>>>                        Send SQLDisconnect of hoSQLConnect
84592>>>>>>>                    End
84592>>>>>>>>
84592>>>>>>>                End
84592>>>>>>>>
84592>>>>>>>                Case Break
84593>>>>>>>            Case Else
84593>>>>>>>                If (bSilent = False) Begin
84595>>>>>>>                    Send Info_Box ("The SqlDatabaseCollationQuery function is currently not implemented for this driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and create a little SQL code snippet and send it to RDC Tools to make this routine work for this driver! Thanks for helping out.")
84596>>>>>>>                End
84596>>>>>>>>
84596>>>>>>>        Case End
84596>>>>>>>
84596>>>>>>>        Function_Return sRetval
84597>>>>>>>    End_Function
84598>>>>>>>
84598>>>>>>>    Function SqlDatabaseCollationChange String sDatabase String sSQLCollation Returns Boolean
84600>>>>>>>        String sDriverID sSQL sConnectionID sConnectionString sSet sWith // sSQL1 
84600>>>>>>>        String sAlterDatabaseKeyWord sCollateKeyWord sSQLCollationCheck sSingle_User sMulti_User sRollback sImmediate
84600>>>>>>>        Handle hConnection hStmt hoSQLManager
84600>>>>>>>        Integer iDbType // iFetchResult
84600>>>>>>>
84600>>>>>>>        If (sDatabase = "") Begin
84602>>>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
84603>>>>>>>>
84603>>>>>>>            Function_Return False
84604>>>>>>>        End
84604>>>>>>>>
84604>>>>>>>
84604>>>>>>>        If (sSQLCollation = "") Begin
84606>>>>>>>            Error DFERR_PROGRAM "The SQL Collation name was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
84607>>>>>>>>
84607>>>>>>>            Function_Return False
84608>>>>>>>        End
84608>>>>>>>>
84608>>>>>>>
84608>>>>>>>        Get psDriverID to sDriverID
84609>>>>>>>        Get piDbType   to iDbType
84610>>>>>>>
84610>>>>>>>        Get phoSQLManager to hoSQLManager
84611>>>>>>>        Get psConnectionID     to sConnectionID
84612>>>>>>>        Get psConnectionString to sConnectionString
84613>>>>>>>        Move 0 to LastErr
84614>>>>>>>
84614>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
84615>>>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
84616>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
84617>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
84619>>>>>>>            Error DFERR_PROGRAM ("Login failed to the database server. The following connect string was used:\n" + sConnectionString)
84620>>>>>>>>
84620>>>>>>>            Function_Return False
84621>>>>>>>        End
84621>>>>>>>>
84621>>>>>>>
84621>>>>>>>        Get SqlOpen of hConnection to hStmt
84622>>>>>>>
84622>>>>>>>        If (hStmt = 0) Begin
84624>>>>>>>            Send SqlDisconnect of hoSQLManager
84625>>>>>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
84626>>>>>>>>
84626>>>>>>>            Function_Return False
84627>>>>>>>        End
84627>>>>>>>>
84627>>>>>>>
84627>>>>>>>        // Check if collation already exists
84627>>>>>>>        Get SqlDatabaseCollationQuery sDatabase False to sSQLCollationCheck
84628>>>>>>>        // If the current collate is the same as the new; do nothing.
84628>>>>>>>        If (sSQLCollation = sSQLCollationCheck) Begin
84630>>>>>>>            Function_Return True
84631>>>>>>>        End
84631>>>>>>>>
84631>>>>>>>
84631>>>>>>>        Get _SqlFindKeyWord CI_SQLSet               to sSet
84632>>>>>>>        Get _SqlFindKeyWord CI_SQLWith              to sWith
84633>>>>>>>        Get _SqlFindKeyWord CI_SQLSingle_User       to sSingle_User
84634>>>>>>>        Get _SqlFindKeyWord CI_SQLMulti_User        to sMulti_User
84635>>>>>>>        Get _SqlFindKeyWord CI_SQLRollback          to sRollback
84636>>>>>>>        Get _SqlFindKeyWord CI_SQLIMMEDIATE         to sImmediate
84637>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterDatabase     to sAlterDatabaseKeyWord
84638>>>>>>>        Get _SqlFindKeyWord CI_SQLDatabaseCollation to sCollateKeyWord
84639>>>>>>>
84639>>>>>>>        // MS-SQL Syntax:
84639>>>>>>>        // ALTER DATABASE [database] SET SINGLE_USER WITH ROLLBACK IMMEDIATE;
84639>>>>>>>        // ALTER DATABASE [database] COLLATE SQL_1xCompat_CP850_CI_AS;
84639>>>>>>>        // ALTER DATABASE [database] SET MULTI_USER;
84639>>>>>>>        Move (              sAlterDatabaseKeyWord  * String(sDatabase) * String(sSet) * String(sSingle_User) * String(sWith) * String(sRollback) * String(sImmediate)) to sSQL
84640>>>>>>>        Move (sSQL * String(sAlterDatabaseKeyWord) * String(sDatabase) * String(sCollateKeyWord) * String(sSQLCollation)) to sSQL
84641>>>>>>>        Move (sSQL * String(sAlterDatabaseKeyWord) * String(sDatabase) * String(sSet) * String(sMulti_User)) to sSQL
84642>>>>>>>//        Move (sAlterDatabaseKeyWord * String(sDatabase) * String(sCollateKeyWord) * String(sSQLCollation)) to sSQL
84642>>>>>>>
84642>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84643>>>>>>>        Send SqlUtilExecuteQuery sSQL sDriverID False
84644>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
84645>>>>>>>        If (LastErr = CLIERR_GENERAL_ERROR) Begin
84647>>>>>>>           Function_Return False
84648>>>>>>>        End
84648>>>>>>>>
84648>>>>>>>
84648>>>>>>>        Function_Return (Err = False)
84649>>>>>>>    End_Function
84650>>>>>>>
84650>>>>>>>
84650>>>>>>>    // * Dummy function for the Studio's Code Explorer *
84650>>>>>>>    Function SQL_TABLE_FUNCTIONS Returns Boolean
84652>>>>>>>        Function_Return False
84653>>>>>>>    End_Function
84654>>>>>>>
84654>>>>>>>    // Converts from SQL to Embedded (DataFlex .dat files).
84654>>>>>>>    // To convert from SQL -> SQL (e.g. from Oracle - > MS SQL)
84654>>>>>>>    //   first use SQLTableConvertToEmbedded in one cDbUpdateVersion object,
84654>>>>>>>    //   and then use the ApiTableConvertToSQL method in a second cDbUpdateVersion object.
84654>>>>>>>    // Note: To convert an embedded table to SQL use ApiTableConvertToSQL.
84654>>>>>>>    Function SqlTableConvertToEmbedded Handle hTable Boolean bCpyDat Returns Boolean
84656>>>>>>>        Handle hToTable
84656>>>>>>>        Boolean bOK bExists bOpened bCopyData
84656>>>>>>>        String sDriverID sPhysicalName sRootName sDisplayName
84656>>>>>>>        tSQLConnection SQLConnection
84656>>>>>>>        tSQLConnection SQLConnection
84656>>>>>>>        Integer iPos iMaxRecords
84656>>>>>>>
84656>>>>>>>        Get psDriverID to sDriverID
84657>>>>>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
84658>>>>>>>        If (bExists = False) Begin
84660>>>>>>>            Function_Return False
84661>>>>>>>        End
84661>>>>>>>>
84661>>>>>>>
84661>>>>>>>        If (num_arguments > 1) Begin
84663>>>>>>>            Move bCpyDat to bCopyData
84664>>>>>>>        End
84664>>>>>>>>
84664>>>>>>>        Else Begin
84665>>>>>>>            Move False to bCopyData
84666>>>>>>>        End
84666>>>>>>>>
84666>>>>>>>
84666>>>>>>>        Open hTable
84668>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
84671>>>>>>>        If (bOpened = False) Begin
84673>>>>>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
84674>>>>>>>>
84674>>>>>>>            Function_Return False
84675>>>>>>>        End
84675>>>>>>>>
84675>>>>>>>        Move 0 to hToTable
84676>>>>>>>
84676>>>>>>>        Move 16711679 to iMaxRecords
84677>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
84680>>>>>>>        Move (Pos(".", sDisplayName)) to iPos
84681>>>>>>>        If (iPos > 0) Begin
84683>>>>>>>            Move (Mid(sDisplayName, 200, (iPos +1))) to sDisplayName
84684>>>>>>>        End
84684>>>>>>>>
84684>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
84687>>>>>>>        Get _TableNameOnly sRootName                 to sRootName
84688>>>>>>>        Move (sRootName + ".dat")                    to sPhysicalName
84689>>>>>>>
84689>>>>>>>        If (ghoProgressBar <> 0) Begin
84691>>>>>>>            Send DoAdvance of ghoProgressBar
84692>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Converting to Embedded - Table:" * String(sRootName) * "Number:" * String(hTable))
84693>>>>>>>        End
84693>>>>>>>>
84693>>>>>>>
84693>>>>>>>        Move False to Err
84694>>>>>>>
84694>>>>>>>        Structure_Start hToTable DATAFLEX_ID
84695>>>>>>>            Structure_Copy hTable to hToTable
84696>>>>>>>
84696>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
84699>>>>>>>            Set_Attribute DF_FILE_REUSE_DELETED of hToTable to DF_FILE_DELETED_REUSE
84702>>>>>>>            Set_Attribute DF_FILE_MULTIUSER     of hToTable to DF_FILE_USER_MULTI
84705>>>>>>>            Set_Attribute DF_FILE_TRANSACTION   of hToTable to DF_FILE_TRANSACTION_CLIENT_ATOMIC
84708>>>>>>>            Set_Attribute DF_FILE_MAX_RECORDS   of hToTable to iMaxRecords
84711>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
84712>>>>>>>
84712>>>>>>>        Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
84714>>>>>>>
84714>>>>>>>        Set Action_Text of ghoStatusPanel to ""
84715>>>>>>>        Move (not(Err)) to bOK
84716>>>>>>>        If (bOK = True and bCopyData = True) Begin
84718>>>>>>>            Get ApiTableCopyData hTable sPhysicalName sRootName DATAFLEX_ID to bOK
84719>>>>>>>        End
84719>>>>>>>>
84719>>>>>>>
84719>>>>>>>        // This must be after copying data...
84719>>>>>>>        If (Err = False) Begin
84721>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
84724>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
84727>>>>>>>        End
84727>>>>>>>>
84727>>>>>>>        Move (not(Err)) to bOK
84728>>>>>>>
84728>>>>>>>        Function_Return (bOK = True)
84729>>>>>>>    End_Function
84730>>>>>>>
84730>>>>>>>    // Creates an SQL Table at the SQL end by its filelist number;
84730>>>>>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
84730>>>>>>>    Function SqlTableCreate Integer hTable Returns Boolean
84732>>>>>>>        String sTableName sSQLString sPath sCreateTable sDriverID
84732>>>>>>>        Integer iDbType
84732>>>>>>>        Boolean bExists
84732>>>>>>>
84732>>>>>>>        Get psDriverID to sDriverID
84733>>>>>>>        Get UtilTableHandleToString hTable to sTableName
84734>>>>>>>        Get _SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
84735>>>>>>>        If (bExists = True) Begin
84737>>>>>>>            Function_Return False
84738>>>>>>>        End
84738>>>>>>>>
84738>>>>>>>
84738>>>>>>>        Get psDataPathFirstPart to sPath
84739>>>>>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
84740>>>>>>>
84740>>>>>>>        Get piDbType to iDbType
84741>>>>>>>        Get _SqlProperTableName sTableName to sTableName
84742>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
84743>>>>>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
84744>>>>>>>
84744>>>>>>>        Move False to Err
84745>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84746>>>>>>>
84746>>>>>>>        Function_Return (Err = False)
84747>>>>>>>    End_Function
84748>>>>>>>
84748>>>>>>>    // Same as SqlTableCreate but creates an SQL Table at the SQL end by a table name;
84748>>>>>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
84748>>>>>>>    Function SqlTableCreateByTableName String sTableName  Returns Boolean
84750>>>>>>>        String sSQLString sPath sCreateTable sDriverID
84750>>>>>>>        Integer iDbType
84750>>>>>>>        Boolean bExists
84750>>>>>>>
84750>>>>>>>        Get psDriverID to sDriverID
84751>>>>>>>        Get _SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
84752>>>>>>>        If (bExists = True) Begin
84754>>>>>>>            Function_Return False
84755>>>>>>>        End
84755>>>>>>>>
84755>>>>>>>
84755>>>>>>>        Get psDataPathFirstPart to sPath
84756>>>>>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
84757>>>>>>>        If (bExists = True) Begin
84759>>>>>>>            // ToDo: What should we do if an .int file already exists?
84759>>>>>>>        End
84759>>>>>>>>
84759>>>>>>>
84759>>>>>>>        Get piDbType to iDbType
84760>>>>>>>        Get _SqlProperTableName sTableName to sTableName
84761>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
84762>>>>>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
84763>>>>>>>
84763>>>>>>>        Move False to Err
84764>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84765>>>>>>>
84765>>>>>>>        Function_Return (Err = False)
84766>>>>>>>    End_Function
84767>>>>>>>    
84767>>>>>>>    // ToDo: 2019-09-23 This needs to be finilized 
84767>>>>>>>    // It resets SQL constraints after a Structure_End, if necessary.
84767>>>>>>>    Function SqlTableRecreateConstraints Handle hTable Returns Boolean
84769>>>>>>>        Boolean bOK                                                            
84769>>>>>>>        String sStatement
84769>>>>>>>        Move "ALTER TABLE [dbo].[THREADS] ADD  DEFAULT ((0)) FOR [SEGMENTS]" to sStatement
84770>>>>>>>        Function_Return bOK
84771>>>>>>>    End_Function
84772>>>>>>>    
84772>>>>>>>    // First deletes the data cache file and then drops the passed SQL table.
84772>>>>>>>    // Note: The table needs to exist in filelist.cfg, and it must be possible to open it,
84772>>>>>>>    //       else try using the SqlTableRemoveByTableName message.
84772>>>>>>>    Function SqlTableRemove Handle hTable Returns Boolean
84774>>>>>>>        String sSQLString sPath sDropTable sTableName sDriverID
84774>>>>>>>        Integer iRetval iDbType
84774>>>>>>>        Boolean bExists bOK
84774>>>>>>>
84774>>>>>>>        Get psDriverID to sDriverID
84775>>>>>>>        Get UtilTableHandleToString hTable to sTableName
84776>>>>>>>        Get _SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
84777>>>>>>>        If (bExists = False) Begin
84779>>>>>>>            Function_Return False
84780>>>>>>>        End
84780>>>>>>>>
84780>>>>>>>
84780>>>>>>>        Get psDataPathFirstPart to sPath
84781>>>>>>>        Get _UtilDeleteCacheFile sTableName to iRetval
84782>>>>>>>
84782>>>>>>>        Get piDbType to iDbType
84783>>>>>>>        Get _SqlProperTableName sTableName to sTableName
84784>>>>>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
84785>>>>>>>        Move (sDropTable * String(sTableName)) to sSQLString
84786>>>>>>>
84786>>>>>>>        Move False to Err
84787>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84788>>>>>>>
84788>>>>>>>        // We also need to remove the cache-file since the table has been changed
84788>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
84789>>>>>>>
84789>>>>>>>        Function_Return (Err = False)
84790>>>>>>>    End_Function
84791>>>>>>>
84791>>>>>>>    // First deletes the data cache file and then drops the passed data table.
84791>>>>>>>    Function SqlTableRemoveByTableName String sTableName Returns Boolean
84793>>>>>>>        String sSQLString sPath sDropTable sVal sSchema sDriverID
84793>>>>>>>        Integer iRetval iDbType
84793>>>>>>>        Boolean bOK
84793>>>>>>>
84793>>>>>>>        Get psDriverID to sDriverID
84794>>>>>>>        Get psDataPathFirstPart to sPath
84795>>>>>>>        Get _UtilDeleteCacheFile sTableName to iRetval
84796>>>>>>>
84796>>>>>>>        Get piDbType to iDbType
84797>>>>>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
84798>>>>>>>        Get psSchema to sSchema
84799>>>>>>>        If (sSchema = "") Begin
84801>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
84802>>>>>>>        End
84802>>>>>>>>
84802>>>>>>>        Move (Uppercase(sTableName)) to sVal
84803>>>>>>>        If (not(sVal contains (sSchema + "."))) Begin
84805>>>>>>>            Move (Lowercase(sSchema) + "." + sTableName) to sTableName
84806>>>>>>>        End
84806>>>>>>>>
84806>>>>>>>        Move (sDropTable * String(sTableName)) to sSQLString
84807>>>>>>>
84807>>>>>>>        Move False to Err
84808>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84809>>>>>>>
84809>>>>>>>        // We also need to remove the cache-file since the table has been changed
84809>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
84810>>>>>>>
84810>>>>>>>        Function_Return (Err = False)
84811>>>>>>>    End_Function
84812>>>>>>>
84812>>>>>>>    // *** Sql View Messages ***
84812>>>>>>>
84812>>>>>>>    // First deletes the data cache file and then drops the passed Sql data view.
84812>>>>>>>    Function SqlViewRemove String sDataView Returns Boolean
84814>>>>>>>        String sDriverID sSQLString sDropViewKeyWord
84814>>>>>>>        Integer iRetval
84814>>>>>>>        Boolean bOK
84814>>>>>>>
84814>>>>>>>        Get psDriverID to sDriverID
84815>>>>>>>        Get _UtilDeleteCacheFile sDataView to iRetval
84816>>>>>>>
84816>>>>>>>        Get _SqlFindKeyWord CI_SQLDropView to sDropViewKeyWord
84817>>>>>>>        Move (sDropViewKeyWord * String(sDataView)) to sSQLString
84818>>>>>>>        Set psSQLStatementString to sSQLString
84819>>>>>>>
84819>>>>>>>        // As we don't check if the view exist or not, it might happen
84819>>>>>>>        // that it doesn't and that would through an error, so guard for that eventuality (just ignore it).
84819>>>>>>>        Move False to Err
84820>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
84821>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84822>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
84823>>>>>>>        Move 0 to LastErr
84824>>>>>>>
84824>>>>>>>        // We also need to remove the cache-file since the table has been changed
84824>>>>>>>        Get _UtilDeleteCacheFile sDataView to bOK
84825>>>>>>>
84825>>>>>>>        Function_Return (Err = False)
84826>>>>>>>    End_Function
84827>>>>>>>
84827>>>>>>>    Function SqlTableRename Handle hTable String sCurrentTableName String sNewtTableName Returns Boolean
84829>>>>>>>        Boolean bOK
84829>>>>>>>        Integer iDbType
84829>>>>>>>        String sDriverID sAlterTable sRenameTable sSQLTo sSQLString
84829>>>>>>>
84829>>>>>>>        Get psDriverID to sDriverID
84830>>>>>>>        Get piDbType   to iDbType
84831>>>>>>>
84831>>>>>>>        Case Begin
84831>>>>>>>            Case (iDbType = EN_DbTypeDB2)
84833>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
84834>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
84835>>>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
84836>>>>>>>            Break
84837>>>>>>>
84837>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
84840>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
84841>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
84842>>>>>>>                Move (sRenameTable * "'" - sCurrentTableName - "', '" - String(sNewtTableName) - "'") to sSQLString
84843>>>>>>>            Break
84844>>>>>>>
84844>>>>>>>            Case (iDbType = EN_DbTypeOracle)
84847>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
84848>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
84849>>>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
84850>>>>>>>            Break
84851>>>>>>>
84851>>>>>>>            Case (iDbType = EN_DbTypePostgre)
84854>>>>>>>                Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
84855>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
84856>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
84857>>>>>>>                Move (sAlterTable * sCurrentTableName * sRenameTable * sSQLTo * String(sNewtTableName)) to sSQLString
84858>>>>>>>            Break
84859>>>>>>>
84859>>>>>>>            Case (iDbType = EN_DbTypeMySQL)
84862>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
84863>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
84864>>>>>>>                Move (Replaces("-", sNewtTableName, "_")) to sNewtTableName
84865>>>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
84866>>>>>>>            Break
84867>>>>>>>        Case End
84867>>>>>>>
84867>>>>>>>        Move False to Err
84868>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
84869>>>>>>>        Move (Err = False) to bOK
84870>>>>>>>
84870>>>>>>>        Function_Return bOK
84871>>>>>>>    End_Function
84872>>>>>>>
84872>>>>>>>    // * Dummy function for the Studio's Code Explorer *
84872>>>>>>>    Function SQL_COLUMN_FUNCTIONS Returns Boolean
84874>>>>>>>        Function_Return False
84875>>>>>>>    End_Function
84876>>>>>>>
84876>>>>>>>    // Sample: Get SqlColumnAdd MyTable.File_Number "NewColumnName" True "InitValue" DF_ASCII_DUF 35
84876>>>>>>>    Function SqlColumnAdd Integer hTable String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
84878>>>>>>>        Integer iLength iDecimals
84878>>>>>>>        String sColumnValue
84878>>>>>>>        String sTableName sDriverID
84878>>>>>>>        Boolean bOK bInitializeValue
84878>>>>>>>
84878>>>>>>>        Get psDriverID to sDriverID
84879>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84880>>>>>>>        If (bOK = False) Begin
84882>>>>>>>            Function_Return False
84883>>>>>>>        End
84883>>>>>>>>
84883>>>>>>>
84883>>>>>>>        Get UtilTableHandleToString hTable to sTableName
84884>>>>>>>        If (sTableName = "") Begin
84886>>>>>>>            Function_Return False
84887>>>>>>>        End
84887>>>>>>>>
84887>>>>>>>
84887>>>>>>>        If (num_arguments > 3) Begin
84889>>>>>>>            Move iLen     to iLength
84890>>>>>>>            Move iDec     to iDecimals
84891>>>>>>>            Move bInitVal to bInitializeValue
84892>>>>>>>            Move sColVal  to sColumnValue
84893>>>>>>>        End
84893>>>>>>>>
84893>>>>>>>
84893>>>>>>>        Get SqlColumnAddByTableName sTableName sColumnName iDataType iLen iDecimals bInitializeValue sColumnValue to bOK
84894>>>>>>>
84894>>>>>>>        Function_Return (bOK = True)
84895>>>>>>>    End_Function
84896>>>>>>>
84896>>>>>>>    // Sample: Get SqlColumnAddByTableName "MyTable" "NewColumnName" DF_ASCII_DUF 35 0 True "InitValue"
84896>>>>>>>    Function SqlColumnAddByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
84898>>>>>>>        Integer iDbType iLength iDecimals iDriver
84898>>>>>>>        String sStmt sAlterTable sAddColumn sVal sDataType sLengthAndDecimals sColumnValue
84898>>>>>>>        String sDriverID sNotNull
84898>>>>>>>        Boolean bOK bInitializeValue bRetval bFixed bDriverIgnoreErrorState
84898>>>>>>>        Handle hTable
84898>>>>>>>
84898>>>>>>>        Get psDriverID to sDriverID
84899>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84900>>>>>>>        If (bOK = False) Begin
84902>>>>>>>            Function_Return True
84903>>>>>>>        End
84903>>>>>>>>
84903>>>>>>>
84903>>>>>>>        Get UtilTableNameToHandle sTableName to hTable
84904>>>>>>>        If (hTable = 0) Begin
84906>>>>>>>            Get NextFreeFilelistSlot to hTable
84907>>>>>>>        End
84907>>>>>>>>
84907>>>>>>>
84907>>>>>>>        Get piDbType to iDbType
84908>>>>>>>        // If a field/column already exists; we just ignore the request to not add unneccesary errors to the log.
84908>>>>>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
84909>>>>>>>        If (Uppercase(sVal) = Uppercase(sColumnName)) Begin
84911>>>>>>>            Function_Return True
84912>>>>>>>        End
84912>>>>>>>>
84912>>>>>>>
84912>>>>>>>        Get DriverIndex sDriverID to iDriver
84913>>>>>>>        Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
84916>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
84919>>>>>>>
84919>>>>>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
84920>>>>>>>        If (num_arguments > 3) Begin
84922>>>>>>>            Move iLen     to iLength
84923>>>>>>>            Move iDec     to iDecimals
84924>>>>>>>            Move bInitVal to bInitializeValue
84925>>>>>>>            Move sColVal  to sColumnValue
84926>>>>>>>        End
84926>>>>>>>>
84926>>>>>>>
84926>>>>>>>        Get _SqlProperTableName sTableName   to sTableName
84927>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
84928>>>>>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
84929>>>>>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
84930>>>>>>>
84930>>>>>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
84931>>>>>>>        If (bFixed = False) Begin
84933>>>>>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
84934>>>>>>>        End
84934>>>>>>>>
84934>>>>>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
84935>>>>>>>
84935>>>>>>>        Move False to Err
84936>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
84937>>>>>>>
84937>>>>>>>        If (bInitializeValue = True and Err = False) Begin
84939>>>>>>>            Get SQLColumnUpdateValue hTable sColumnName sColumnValue to bRetval
84940>>>>>>>        End
84940>>>>>>>>
84940>>>>>>>
84940>>>>>>>        If (Err = False) Begin
84942>>>>>>>            Get SqlUtilAdjustAuxFiles hTable sTableName sColumnName to bOK
84943>>>>>>>        End
84943>>>>>>>>
84943>>>>>>>
84943>>>>>>>        Move (not(Err)) to bRetval
84944>>>>>>>
84944>>>>>>>        // We also need to remove the cache-file since the table has been changed
84944>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
84945>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
84948>>>>>>>
84948>>>>>>>        Function_Return bRetval
84949>>>>>>>    End_Function
84950>>>>>>>
84950>>>>>>>    // To update all current rows for a table column with a common value.
84950>>>>>>>    Function SqlColumnUpdateValue Handle hTable String sColumnName String sColumnValue Returns Boolean
84952>>>>>>>        String sDriverID sTableName sUpdate sSet sNoCountOn sSqlSafe_Updates sStmt
84952>>>>>>>        Boolean bRetval bSQLDriver
84952>>>>>>>        Integer iCurrErr iDbType
84952>>>>>>>
84952>>>>>>>        Move False to bRetval
84953>>>>>>>        Get piDbType to iDbType
84954>>>>>>>        Get psDriverID to sDriverID
84955>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
84956>>>>>>>        If (bSQLDriver = False) Begin
84958>>>>>>>            Function_Return bRetval
84959>>>>>>>        End
84959>>>>>>>>
84959>>>>>>>        Get UtilTableHandleToString hTable to sTableName
84960>>>>>>>
84960>>>>>>>        Move Err to iCurrErr
84961>>>>>>>        Move False to Err
84962>>>>>>>        Get _SqlFindKeyWord CI_SQLUpdate       to sUpdate
84963>>>>>>>        Get _SqlFindKeyWord CI_SQLSet          to sSet
84964>>>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountOn
84965>>>>>>>        // If MySQL and DAW's ODBC driver is used we need to do it slightly different.
84965>>>>>>>        If (iDbType = EN_DbTypeMySQL) Begin
84967>>>>>>>            Get _SqlFindKeyWord CI_SQL_SAFE_UPDATES to sSqlSafe_Updates
84968>>>>>>>            Move (sSet * sSqlSafe_Updates + "=0;" * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'") to sStmt
84969>>>>>>>        End
84969>>>>>>>>
84969>>>>>>>        Else Begin
84970>>>>>>>            Move (sNoCountOn * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'") to sStmt
84971>>>>>>>        End
84971>>>>>>>>
84971>>>>>>>
84971>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
84972>>>>>>>        Move (Err = False) to bRetval
84973>>>>>>>        Move iCurrErr to Err
84974>>>>>>>
84974>>>>>>>        Function_Return bRetval
84975>>>>>>>    End_Function
84976>>>>>>>
84976>>>>>>>    // The fourth & fifth arguments are optional, depending on the iDataType
84976>>>>>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
84976>>>>>>>    Function SqlColumnChange Handle hTable String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
84978>>>>>>>        String sDriverID sTableName
84978>>>>>>>        Boolean bOK
84978>>>>>>>
84978>>>>>>>        Get psDriverID to sDriverID
84979>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84980>>>>>>>        If (bOK = False) Begin
84982>>>>>>>            Function_Return False
84983>>>>>>>        End
84983>>>>>>>>
84983>>>>>>>
84983>>>>>>>        Get UtilTableHandleToString hTable to sTableName
84984>>>>>>>        Get SqlColumnChangeByTableName sTableName sColumnName iDataType iLen iDec to bOK
84985>>>>>>>
84985>>>>>>>        Function_Return (Err = False)
84986>>>>>>>    End_Function
84987>>>>>>>
84987>>>>>>>    // Same as SqlColumnChange but instead of passing a filelist number; pass the table name as a string.
84987>>>>>>>    // The fourth & fifth arguments are optional, depending on the iDataType
84987>>>>>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
84987>>>>>>>    Function SqlColumnChangeByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
84989>>>>>>>        Integer iDbType iLength iDecimals
84989>>>>>>>        String sDriverID sStmt sAlterTable sAlterColumn sDataType sLengthAndDecimals sNotNull
84989>>>>>>>        Boolean bExists bOK bFixed
84989>>>>>>>        Handle hTable
84989>>>>>>>
84989>>>>>>>        Get psDriverID to sDriverID
84990>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84991>>>>>>>        If (bOK = False) Begin
84993>>>>>>>            Function_Return False
84994>>>>>>>        End
84994>>>>>>>>
84994>>>>>>>
84994>>>>>>>        Get UtilTableNameToHandle sTableName to hTable
84995>>>>>>>        If (hTable = 0) Begin
84997>>>>>>>            Get NextFreeFilelistSlot to hTable
84998>>>>>>>        End
84998>>>>>>>>
84998>>>>>>>        Get SQLUtilColumnExists sTableName sColumnName to bExists
84999>>>>>>>        If (bExists = False) Begin
85001>>>>>>>            Function_Return False
85002>>>>>>>        End
85002>>>>>>>>
85002>>>>>>>
85002>>>>>>>        If (num_arguments > 3) Begin
85004>>>>>>>            Move iLen to iLength
85005>>>>>>>        End
85005>>>>>>>>
85005>>>>>>>        If (num_arguments > 4) Begin
85007>>>>>>>            Move iDec to iDecimals
85008>>>>>>>        End
85008>>>>>>>>
85008>>>>>>>
85008>>>>>>>        Get piDbType to iDbType
85009>>>>>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
85010>>>>>>>
85010>>>>>>>        Move False to Err
85011>>>>>>>        Get _SqlProperTableName sTableName    to sTableName
85012>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
85013>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterColumn to sAlterColumn
85014>>>>>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
85015>>>>>>>
85015>>>>>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
85016>>>>>>>        If (bFixed = False) Begin
85018>>>>>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
85019>>>>>>>        End
85019>>>>>>>>
85019>>>>>>>
85019>>>>>>>        Move (sAlterTable * sTableName * sAlterColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
85020>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
85021>>>>>>>
85021>>>>>>>        // We also need to remove the cache-file since the table has been changed
85021>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
85022>>>>>>>
85022>>>>>>>        Function_Return (Err = False)
85023>>>>>>>    End_Function
85024>>>>>>>
85024>>>>>>>    Function SqlColumnDefaultValue Handle hTable Integer iColumn String sValue Returns Boolean
85026>>>>>>>        Boolean bOK bErr bIsSQLDriver
85026>>>>>>>        String sDriverID
85026>>>>>>>        Integer iDataType
85026>>>>>>>
85026>>>>>>>        Get psDriverID to sDriverID
85027>>>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
85028>>>>>>>        If (bIsSQLDriver = False) Begin
85030>>>>>>>            Function_Return False
85031>>>>>>>        End
85031>>>>>>>>
85031>>>>>>>
85031>>>>>>>        Move Err to bErr
85032>>>>>>>        Move False to bErr
85033>>>>>>>
85033>>>>>>>        // There seems to be a problem with the ODBC_DRV driver that sometimes
85033>>>>>>>        // inserts randomly character(10) and spaces, so we correct from that here:
85033>>>>>>>        Move (Replaces(Character(10), Trim(sValue), "")) to sValue
85034>>>>>>>        Get_Attribute DF_FIELD_TYPE of hTable iColumn to iDataType
85037>>>>>>>        If (iDataType = DF_BCD and Left(sValue, 1 <> "[")) Begin
85039>>>>>>>            Move ("[" + String(sValue) + "]") to sValue
85040>>>>>>>        End
85040>>>>>>>>
85040>>>>>>>
85040>>>>>>>        Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sValue
85043>>>>>>>        Move (not(Err)) to bOK
85044>>>>>>>        Move bErr to Err
85045>>>>>>>
85045>>>>>>>        Function_Return bOK
85046>>>>>>>    End_Function
85047>>>>>>>
85047>>>>>>>    Function SqlColumnNullable Handle hTable Integer iColumn Boolean bNullable Returns Boolean
85049>>>>>>>        Boolean bOK bErr bCurrentState bOpen bIsSQLDriver
85049>>>>>>>        String sDriverID
85049>>>>>>>
85049>>>>>>>        Get psDriverID to sDriverID
85050>>>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
85051>>>>>>>        If (bIsSQLDriver = False) Begin
85053>>>>>>>            Function_Return False
85054>>>>>>>        End
85054>>>>>>>>
85054>>>>>>>
85054>>>>>>>        Move Err to bErr
85055>>>>>>>        Move False to bErr
85056>>>>>>>        Get_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bCurrentState
85059>>>>>>>        If (bNullable = bCurrentState) Begin
85061>>>>>>>            Function_Return True
85062>>>>>>>        End
85062>>>>>>>>
85062>>>>>>>
85062>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
85065>>>>>>>        If (bOpen = False) Begin
85067>>>>>>>            Get AutoConnectionIDLogin to bOK
85068>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
85069>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
85070>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
85071>>>>>>>            Open hTable
85073>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
85074>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
85075>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
85076>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
85079>>>>>>>        End
85079>>>>>>>>
85079>>>>>>>        If (bOpen = True) Begin
85081>>>>>>>            Structure_Start hTable sDriverID
85082>>>>>>>                Set_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bNullable
85085>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
85086>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
85088>>>>>>>            Set Action_Text of ghoStatusPanel to ""
85089>>>>>>>        End
85089>>>>>>>>
85089>>>>>>>
85089>>>>>>>        Move (not(Err)) to bOK
85090>>>>>>>        Move bErr to Err
85091>>>>>>>
85091>>>>>>>        Function_Return bOK
85092>>>>>>>    End_Function
85093>>>>>>>
85093>>>>>>>    // Drop column by its table handle
85093>>>>>>>    Function SqlColumnRemove Handle hTable String sColumnName Returns Boolean
85095>>>>>>>        String sDriverID sTableName
85095>>>>>>>        Boolean bOK
85095>>>>>>>
85095>>>>>>>        Get psDriverID to sDriverID
85096>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85097>>>>>>>        If (bOK = False) Begin
85099>>>>>>>            Function_Return False
85100>>>>>>>        End
85100>>>>>>>>
85100>>>>>>>
85100>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85101>>>>>>>        If (sTableName = "") Begin
85103>>>>>>>            Function_Return False
85104>>>>>>>        End
85104>>>>>>>>
85104>>>>>>>
85104>>>>>>>        Get SqlColumnRemoveByTableName sTableName sColumnName to bOK
85105>>>>>>>
85105>>>>>>>        Function_Return (bOK = True)
85106>>>>>>>    End_Function
85107>>>>>>>
85107>>>>>>>    // Drop column by its table name as a string.
85107>>>>>>>    Function SqlColumnRemoveByTableName String sTableName String sColumnName Returns Boolean
85109>>>>>>>        Integer iDbType iDriver
85109>>>>>>>        String sDriverID sStmt sAlterTable sDropColumn
85109>>>>>>>        Boolean bExists bOK bRetval bDriverIgnoreErrorState
85109>>>>>>>        Handle hTable
85109>>>>>>>
85109>>>>>>>        Get psDriverID to sDriverID
85110>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85111>>>>>>>        If (bOK = False) Begin
85113>>>>>>>            Function_Return False
85114>>>>>>>        End
85114>>>>>>>>
85114>>>>>>>
85114>>>>>>>        Get DriverIndex sDriverID to iDriver
85115>>>>>>>        Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
85118>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
85121>>>>>>>
85121>>>>>>>        Get UtilTableNameToHandle sTableName to hTable
85122>>>>>>>        If (hTable <> 0) Begin
85124>>>>>>>            Get SQLUtilColumnExists sTableName sColumnName to bExists
85125>>>>>>>            If (bExists = False) Begin
85127>>>>>>>                Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
85130>>>>>>>                Function_Return False
85131>>>>>>>            End
85131>>>>>>>>
85131>>>>>>>        End
85131>>>>>>>>
85131>>>>>>>
85131>>>>>>>        Get piDbType to iDbType
85132>>>>>>>        If (iDbType = EN_DbTypeMSSQL) Begin
85134>>>>>>>            Get _SqlUtilRemoveTableColumnMSSQL sTableName sColumnName to bOK
85135>>>>>>>            Get _UtilDeleteCacheFile sTableName to bOK
85136>>>>>>>            Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
85139>>>>>>>            Function_Return bOK
85140>>>>>>>        End
85140>>>>>>>>
85140>>>>>>>
85140>>>>>>>        Move False to Err
85141>>>>>>>        Get _SqlProperTableName sTableName    to sTableName
85142>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
85143>>>>>>>        Get _SqlFindKeyWord CI_SQLDropColumn  to sDropColumn
85144>>>>>>>
85144>>>>>>>        Move (sAlterTable * sTableName * sDropColumn * sColumnName) to sStmt
85145>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
85146>>>>>>>        Move (not(Err)) to bRetval
85147>>>>>>>
85147>>>>>>>        // We also need to remove the cache-file since the table has been changed
85147>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
85148>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
85151>>>>>>>
85151>>>>>>>        Function_Return bRetval
85152>>>>>>>    End_Function
85153>>>>>>>
85153>>>>>>>    // Rename a field/column by table handle (filelist number)
85153>>>>>>>    Function SqlColumnRename Integer hTable String sColumnName String sNewColumnName Returns Boolean
85155>>>>>>>        String sDriverID sTableName
85155>>>>>>>        Boolean bOK
85155>>>>>>>
85155>>>>>>>        Get psDriverID to sDriverID
85156>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85157>>>>>>>        If (bOK = False) Begin
85159>>>>>>>            Function_Return False
85160>>>>>>>        End
85160>>>>>>>>
85160>>>>>>>
85160>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85161>>>>>>>        Get SqlColumnRenameByTableName sTableName sColumnName sNewColumnName to bOK
85162>>>>>>>
85162>>>>>>>        Function_Return (Err = False)
85163>>>>>>>    End_Function
85164>>>>>>>
85164>>>>>>>    // Rename a field/column by table name.
85164>>>>>>>    Function SqlColumnRenameByTableName String sTableName String sColumnName String sNewColumnName Returns Boolean
85166>>>>>>>        Integer iDbType iDataType
85166>>>>>>>        String sDriverID sStmt sAlterTable sRenameColumn sVal sColumnKeyWord sOrgTableName sDatabase sDataType
85166>>>>>>>        Boolean bOK bRetval
85166>>>>>>>        Handle hTable
85166>>>>>>>
85166>>>>>>>        Move sTableName to sOrgTableName
85167>>>>>>>        Get psDriverID to sDriverID
85168>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85169>>>>>>>        If (bOK = False) Begin
85171>>>>>>>            Function_Return False
85172>>>>>>>        End
85172>>>>>>>>
85172>>>>>>>
85172>>>>>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
85173>>>>>>>        If (sVal = "") Begin
85175>>>>>>>            Function_Return False
85176>>>>>>>        End
85176>>>>>>>>
85176>>>>>>>
85176>>>>>>>        Get piDbType to iDbType
85177>>>>>>>        Get _SqlFindKeyWord CI_SQLColumn       to sColumnKeyWord
85178>>>>>>>        Get _SqlProperTableName sTableName     to sTableName
85179>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable   to sAlterTable
85180>>>>>>>        Get _SqlFindKeyWord CI_SQLRenameColumn to sRenameColumn
85181>>>>>>>
85181>>>>>>>        Case Begin
85181>>>>>>>            Case (iDbType = EN_dbTypeMSSQL)
85183>>>>>>>                Move (sRenameColumn * "'" + sTableName + "." + sColumnName + "'," * "'" + sNewColumnName + "'," * "'" + sColumnKeyWord + "'") to sStmt
85184>>>>>>>                Case Break
85185>>>>>>>            // Alter table "SYS"."Customer" rename column "Comments" to "NewColumnName"
85185>>>>>>>            Case (iDbType = EN_dbTypeOracle)
85188>>>>>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
85189>>>>>>>                Case Break
85190>>>>>>>            // ALTER TABLE Schema.TableName RENAME COLUMN "deptnumb" TO "deptnum"
85190>>>>>>>            Case (iDbType = EN_dbTypeDB2)
85193>>>>>>>                Move (sAlterTable *  sTableName * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
85194>>>>>>>                Case Break
85195>>>>>>>            // ALTER TABLE "Customer" RENAME COLUMN "Comments" TO "NewColumnName"
85195>>>>>>>            Case (iDbType = EN_dbTypePostgre)
85198>>>>>>>                Move sOrgTableName to sTableName
85199>>>>>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
85200>>>>>>>                Case Break
85201>>>>>>>            Case (iDbType = EN_dbTypeMySQL)
85204>>>>>>>                // ALTER TABLE orderentry.customer CHANGE Comments NewColumnName text // Note: The last token is the column type!
85204>>>>>>>                Move sOrgTableName to sTableName
85205>>>>>>>                Get psDatabase to sDatabase
85206>>>>>>>                Get UtilTableNameToHandle sTableName to hTable
85207>>>>>>>                If (hTable = 0) Begin
85209>>>>>>>                    Get UtilTableOpen hTable sTableName DF_SHARE to bOK
85210>>>>>>>                    If (bOK = False) Begin
85212>>>>>>>                        Function_Return False
85213>>>>>>>                    End
85213>>>>>>>>
85213>>>>>>>                    Get NextFreeFilelistSlot to hTable
85214>>>>>>>                End
85214>>>>>>>>
85214>>>>>>>                Else Begin
85215>>>>>>>                    Open hTable
85217>>>>>>>                End
85217>>>>>>>>
85217>>>>>>>                Get SQLColumnType sDriverID hTable sTableName sColumnName to iDataType
85218>>>>>>>                Get UtilColumnTypeToString sDriverID iDbType iDataType    to sDataType
85219>>>>>>>                Move (sAlterTable * sDatabase + "." + sTableName * sRenameColumn * sColumnName * sNewColumnName * sDataType) to sStmt
85220>>>>>>>                Case Break
85221>>>>>>>            Case Else
85221>>>>>>>                Move (sAlterTable * "'" + sTableName + "'" * sRenameColumn * "'" + sTableName + "." + sColumnName + "'" * "TO" * "'" + sNewColumnName + "'") to sStmt
85222>>>>>>>        Case End
85222>>>>>>>
85222>>>>>>>        Move False to Err
85223>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
85224>>>>>>>        Move (Err = False) to bRetval
85225>>>>>>>        // We also need to remove the cache-file since the table has been changed
85225>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
85226>>>>>>>
85226>>>>>>>        Function_Return bRetval
85227>>>>>>>    End_Function
85228>>>>>>>
85228>>>>>>>    Function SqlColumnType String sDriverID Handle hTable String sTableName String sColumnName Returns Integer
85230>>>>>>>        Handle hoSQLHandler hSQLConnect hStmt
85230>>>>>>>        Integer iNumCols iCount iDataType
85230>>>>>>>        String sValue
85230>>>>>>>
85230>>>>>>>        Get phoSQLManager to hoSQLHandler
85231>>>>>>>        Get SQLFileConnect of hoSQLHandler hTable to hSQLConnect
85232>>>>>>>        If (hSQLConnect <> 0) Begin
85234>>>>>>>            Get SQLOpen of hSQLConnect to hStmt
85235>>>>>>>            If (hStmt <> 0) Begin
85237>>>>>>>                Send SQLExecDirect of hStmt ("select * from" * sTableName)
85238>>>>>>>
85238>>>>>>>                Get SQLStmtAttribute of hStmt SQLSTMTATTRIB_COLUMNCOUNT to iNumCols
85239>>>>>>>                For iCount from 1 to iNumCols
85245>>>>>>>>
85245>>>>>>>                    Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_LABEL to sValue
85246>>>>>>>                    If (Lowercase(sValue) = Lowercase(sColumnName)) Begin
85248>>>>>>>                        Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_SQLTYPE to iDataType
85249>>>>>>>                        Move iNumCols to iCount // We're out of here
85250>>>>>>>                    End
85250>>>>>>>>
85250>>>>>>>                Loop
85251>>>>>>>>
85251>>>>>>>
85251>>>>>>>                Send SQLClose of hStmt
85252>>>>>>>            End
85252>>>>>>>>
85252>>>>>>>            Send SQLDisconnect of hSQLConnect
85253>>>>>>>        End
85253>>>>>>>>
85253>>>>>>>
85253>>>>>>>        Function_Return iDataType
85254>>>>>>>    End_Function
85255>>>>>>>
85255>>>>>>>    // * Dummy function for the Studio's Code Explorer *
85255>>>>>>>    Function SQL_EXECUTE_FUNCTIONS Returns Boolean
85257>>>>>>>        Function_Return False
85258>>>>>>>    End_Function
85259>>>>>>>
85259>>>>>>>    Procedure SqlUtilExecuteQuery String sStmt String sDriverID Boolean bShowProgr
85261>>>>>>>        String sMessage // sConnectionString
85261>>>>>>>        Handle hoSqlHandler hoSQLConnect hoStmt hoError
85261>>>>>>>        Integer i iMsgs iFetchResult iRowType iRows iErr iMessage iLastErr
85261>>>>>>>        String[] sMsg aSQLQueryMessages aSQLFetchResults
85264>>>>>>>        DateTime dtQueryExecStart dtQueryExecEnd dtFetchStart dtFetchEnd
85264>>>>>>>        TimeSpan tsQuery tsFetch
85264>>>>>>>        tSqlErrorArray aSqlErrorArray
85264>>>>>>>        tSqlErrorArray aSqlErrorArray
85264>>>>>>>        Boolean bOK bShowProgress
85264>>>>>>>        tSQLConnection SQLConnection
85264>>>>>>>        tSQLConnection SQLConnection
85264>>>>>>>
85264>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85265>>>>>>>        If (bOK = False) Begin
85267>>>>>>>            Procedure_Return
85268>>>>>>>        End
85268>>>>>>>>
85268>>>>>>>
85268>>>>>>>        If (num_arguments > 2) Begin
85270>>>>>>>            Move bShowProgr to bShowProgress
85271>>>>>>>        End
85271>>>>>>>>
85271>>>>>>>
85271>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
85272>>>>>>>        Get phoSQLManager to hoSqlHandler
85273>>>>>>>        Send SqlSetConnect of hoSqlHandler sDriverID SQLConnection.sConnectionString
85274>>>>>>>        Get SqlConnect     of hoSqlHandler "" "" to hoSQLConnect
85275>>>>>>>
85275>>>>>>>        If (hoSQLConnect <> 0) Begin
85277>>>>>>>            Get SqlOpen of hoSQLConnect to hoStmt
85278>>>>>>>            If (hoStmt <> 0) Begin
85280>>>>>>>                // record starting date/time stamp
85280>>>>>>>                Move (CurrentDateTime()) to dtQueryExecStart
85281>>>>>>>                // turn on error handling if enabled
85281>>>>>>>                If (pbHandleQueryErrors(Self)) Begin
85283>>>>>>>                    Set pbSqlError to False
85284>>>>>>>                    Set paSqlErrorArray to aSqlErrorArray
85285>>>>>>>                    Move Error_Object_Id to hoError
85286>>>>>>>                    If (ghoDbUpdateHandler <> 0) Begin
85288>>>>>>>                        Move ghoDbUpdateHandler to Error_Object_Id
85289>>>>>>>                    End
85289>>>>>>>>
85289>>>>>>>                    Else Begin
85290>>>>>>>                        Move Self to Error_Object_Id
85291>>>>>>>                    End
85291>>>>>>>>
85291>>>>>>>                End
85291>>>>>>>>
85291>>>>>>>
85291>>>>>>>                // Before we execute the statement; save it so we can display the faulty statement in the error log.
85291>>>>>>>                Set psSQLStatementString to sStmt
85292>>>>>>>                Send Cursor_Wait of Cursor_Control
85293>>>>>>>                Send SqlExecDirect of hoStmt sStmt
85294>>>>>>>                Send Cursor_Ready of Cursor_Control
85295>>>>>>>
85295>>>>>>>                If (pbHandleQueryErrors(Self)) Begin
85297>>>>>>>                    Move hoError to Error_Object_Id
85298>>>>>>>                End
85298>>>>>>>>
85298>>>>>>>
85298>>>>>>>                Move 0 to iMsgs
85299>>>>>>>                Move Err to iErr
85300>>>>>>>                Move LastErr to iLastErr
85301>>>>>>>                Get SqlStmtAttribute of hoStmt SQLSTMTATTRIB_NUMMESSAGES   to iMsgs
85302>>>>>>>                Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT      to iRows
85303>>>>>>>                Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
85304>>>>>>>                Send _SqlColumnInfo hoStmt
85305>>>>>>>                Send Ignore_Error of Error_Object_Id 12289
85306>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
85307>>>>>>>                Repeat
85307>>>>>>>>
85307>>>>>>>                    Get SqlFetch of hoStmt to iFetchResult
85308>>>>>>>                    If (iFetchResult <> 0) Begin
85310>>>>>>>                        Get SQLColumnValue of hoStmt 1 to aSQLFetchResults[SizeOfArray(aSQLFetchResults)]
85311>>>>>>>                    End
85311>>>>>>>>
85311>>>>>>>                Until (iFetchResult = 0)
85313>>>>>>>                Send Trap_Error of Error_Object_Id 12289
85314>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
85315>>>>>>>                Move iErr to Err
85316>>>>>>>                Move iLastErr to LastErr
85317>>>>>>>                Set paSQLFetchResults to aSQLFetchResults
85318>>>>>>>
85318>>>>>>>                Set piRows    to iRows
85319>>>>>>>                Set piRowType to iRowType
85320>>>>>>>                Move (CurrentDateTime()) to dtQueryExecEnd
85321>>>>>>>                Move (CurrentDateTime()) to dtFetchStart
85322>>>>>>>
85322>>>>>>>                If (iMsgs <> 0) Begin
85324>>>>>>>                    If (ghoDbUpdateHandler > 0) Begin
85326>>>>>>>                        Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
85327>>>>>>>                    End
85327>>>>>>>>
85327>>>>>>>                    For i from 1 to iMsgs
85333>>>>>>>>
85333>>>>>>>                        Get SqlGetMessage of hoStmt i to sMessage
85334>>>>>>>                        Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
85335>>>>>>>                        If (bShowProgress = True) Begin
85337>>>>>>>                            If (Active_State(ghoStatusPanel)) Begin
85339>>>>>>>                                Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
85340>>>>>>>                            End
85340>>>>>>>>
85340>>>>>>>                            Else Begin
85341>>>>>>>                                Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
85343>>>>>>>                            End
85343>>>>>>>>
85343>>>>>>>                        End
85343>>>>>>>>
85343>>>>>>>                        Move sMessage to sMsg[SizeOfArray(sMsg)]
85344>>>>>>>                        Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
85345>>>>>>>                    Loop
85346>>>>>>>>
85346>>>>>>>                    If (ghoDbUpdateHandler > 0) Begin
85348>>>>>>>                        Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
85349>>>>>>>                    End
85349>>>>>>>>
85349>>>>>>>                    Set paQueryMessages to sMsg
85350>>>>>>>                End
85350>>>>>>>>
85350>>>>>>>                Else Begin
85351>>>>>>>                    If (bShowProgress = True) Begin
85353>>>>>>>                        Get paSqlErrorArray to aSqlErrorArray
85354>>>>>>>                        If (SizeOfArray(aSqlErrorArray.iSqlErrorArray)) Begin
85356>>>>>>>                            Move (SizeOfArray(aSqlErrorArray.iSqlErrorArray)) to iMsgs
85357>>>>>>>                            Decrement iMsgs
85358>>>>>>>                            For i from 0 to iMsgs
85364>>>>>>>>
85364>>>>>>>                                Showln "Embedded SQL Statement: " aSqlErrorArray.sSqlStatementArray[i]
85367>>>>>>>                                Showln "SQL Error Message     : " aSqlErrorArray.sSqlErrorArray[i]
85370>>>>>>>                            Loop
85371>>>>>>>>
85371>>>>>>>                        End
85371>>>>>>>>
85371>>>>>>>                    End
85371>>>>>>>>
85371>>>>>>>                End
85371>>>>>>>>
85371>>>>>>>                Move (CurrentDateTime()) to dtFetchEnd
85372>>>>>>>            End
85372>>>>>>>>
85372>>>>>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
85373>>>>>>>            Move (dtFetchStart - dtFetchEnd) to tsFetch
85374>>>>>>>            Set ptsQueryExec to tsQuery
85375>>>>>>>            Set ptsFetchResults to tsFetch
85376>>>>>>>            Send SqlClose of hoStmt
85377>>>>>>>        End
85377>>>>>>>>
85377>>>>>>>
85377>>>>>>>        Send SqlDisconnect of hoSQLConnect
85378>>>>>>>    End_Procedure
85379>>>>>>>
85379>>>>>>>    // *** Main message for executing an SQL script that has been compiled into the program as a resource ***
85379>>>>>>>    // Use the SQLIncludeScriptFile command to include an SQL script into the program.
85379>>>>>>>    // Returns False if no error occured.
85379>>>>>>>    Function SqlUtilExecuteResource String sMemFileName String sDriverID Boolean bCreateScriptFile Boolean bShowProgr Returns Boolean
85381>>>>>>>        Boolean bOK bShowProgress
85381>>>>>>>        tSQLScriptArray SQLScriptArray
85381>>>>>>>        tSQLScriptArray SQLScriptArray
85381>>>>>>>        DateTime dtTotalQueryStart dtTotalQueryEnd
85381>>>>>>>        TimeSpan tsTotalTime
85381>>>>>>>
85381>>>>>>>        Move (CurrentDateTime()) to dtTotalQueryStart
85382>>>>>>>        Get _SqlUtilReadResource sMemFileName to SQLScriptArray
85383>>>>>>>        If (SQLScriptArray.bError = True) Begin
85385>>>>>>>            Function_Return False
85386>>>>>>>        End
85386>>>>>>>>
85386>>>>>>>
85386>>>>>>>        If (num_arguments > 3) Begin
85388>>>>>>>            Move bShowProgr to bShowProgress
85389>>>>>>>        End
85389>>>>>>>>
85389>>>>>>>
85389>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
85390>>>>>>>        Get _SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID bCreateScriptFile sMemFileName bShowProgress to bOK
85391>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
85392>>>>>>>
85392>>>>>>>        Move (CurrentDateTime()) to dtTotalQueryEnd
85393>>>>>>>        Move (dtTotalQueryEnd - dtTotalQueryStart) to tsTotalTime
85394>>>>>>>        Set ptsTotalQueryTime to tsTotalTime
85395>>>>>>>
85395>>>>>>>        Function_Return bOK
85396>>>>>>>    End_Function
85397>>>>>>>
85397>>>>>>>    // * Dummy function for the Studio's Code Explorer *
85397>>>>>>>    Function SQL_UTILITY_FUNCTIONS Returns Boolean
85399>>>>>>>        Function_Return False
85400>>>>>>>    End_Function
85401>>>>>>>
85401>>>>>>>    // Does three things with auxilirary files;
85401>>>>>>>    // 1) Deletes the cache file in the first Data folder of the psDataPath property as the table at the SQL end has been changed.
85401>>>>>>>    // 2) Adds the sColumnName to the TableName.tag file in the first Data folder of the psDataPath property
85401>>>>>>>    // 3) Creates a new TableName.fd file if the DdSrc folder is available (if this is a development environment)
85401>>>>>>>    Function SqlUtilAdjustAuxFiles Handle hTable String sTableName String sColumnName Returns Boolean
85403>>>>>>>        String sDataPath sDDSrcPath sDriverID
85403>>>>>>>        Boolean bOK bExists
85403>>>>>>>        Integer iCount iCh iPos
85403>>>>>>>
85403>>>>>>>        // If table name equals e.g. "dbo.MyTable" we need to remove the prefix.
85403>>>>>>>        If (sTableName contains ".") Begin
85405>>>>>>>            Move (Pos(".", sTableName)) to iPos
85406>>>>>>>            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
85407>>>>>>>        End
85407>>>>>>>>
85407>>>>>>>
85407>>>>>>>        Get psDriverID to sDriverID
85408>>>>>>>        Get psDataPathFirstPart to sDataPath
85409>>>>>>>        Get vFolderExists sDataPath to bOK
85410>>>>>>>        If (bOK = False) Begin
85412>>>>>>>            Error DFERR_PROGRAM "Function SqlUtilAdjustAuxFiles; psDataPath not found!"
85413>>>>>>>>
85413>>>>>>>            Function_Return False
85414>>>>>>>        End
85414>>>>>>>>
85414>>>>>>>
85414>>>>>>>        // First delete the cache file:
85414>>>>>>>        Get _UtilDeleteCacheFile sTableName to bOK
85415>>>>>>>
85415>>>>>>>        Get Seq_New_Channel to iCh
85416>>>>>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
85418>>>>>>>            Function_Return False
85419>>>>>>>        End
85419>>>>>>>>
85419>>>>>>>
85419>>>>>>>        Get vFilePathExists (sDataPath + sTableName + ".tag") to bExists
85420>>>>>>>        If (bExists = False) Begin
85422>>>>>>>            Function_Return False
85423>>>>>>>        End
85423>>>>>>>>
85423>>>>>>>
85423>>>>>>>        Get _SqlUtilUpdateIntFile hTable to bOK
85424>>>>>>>        // Add the new column name to the .tag filen (if it doesn't exist):
85424>>>>>>>        Get _UtilUpdateTAGFile (sDataPath + sTableName + ".tag") sColumnName to bOK
85425>>>>>>>
85425>>>>>>>        // If in development environment; output new .fd file:
85425>>>>>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
85426>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
85427>>>>>>>        If (iCount > 1) Begin
85429>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
85430>>>>>>>        End
85430>>>>>>>>
85430>>>>>>>        Get vFolderExists sDDSrcPath to bExists
85431>>>>>>>        If (bExists = True) Begin
85433>>>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
85434>>>>>>>            Move False to Err
85435>>>>>>>            Get AutoConnectionIDLogin to bOK
85436>>>>>>>            If (hTable <> 0) Begin
85438>>>>>>>                Open hTable
85440>>>>>>>            End
85440>>>>>>>>
85440>>>>>>>            Else Begin
85441>>>>>>>                Get UtilTableOpen hTable sTableName DF_SHARE to bOK
85442>>>>>>>            End
85442>>>>>>>>
85442>>>>>>>
85442>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOK
85445>>>>>>>            If (bOK = True) Begin
85447>>>>>>>                Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
85449>>>>>>>            End
85449>>>>>>>>
85449>>>>>>>            If (Err = True) Begin
85451>>>>>>>                Move False to bOK
85452>>>>>>>            End
85452>>>>>>>>
85452>>>>>>>        End
85452>>>>>>>>
85452>>>>>>>
85452>>>>>>>        Function_Return (bOK = True)
85453>>>>>>>    End_Function
85454>>>>>>>
85454>>>>>>>    // Message for changing .int files to use connection ID's
85454>>>>>>>    //
85454>>>>>>>    // Changes all ".int" files for the passed sDataPath to use a sConnectionID,
85454>>>>>>>    // OR changes an existing connection id to a new id.
85454>>>>>>>    // Pass the full path to the data folder and the name of the connection id (string value).
85454>>>>>>>    // Pass a True for the bShowResult parameter to show work in progress (showln's).
85454>>>>>>>    Procedure SqlUtilChangeIntFilesToConnectionIDs String sDataPath String sConnectionID Boolean bShowResult
85456>>>>>>>        String sFileName sDriverID sDriverFile sConnectionString
85456>>>>>>>        String[] sFilesData
85457>>>>>>>        Boolean bOK bCancel
85457>>>>>>>        Integer iSize iCount
85457>>>>>>>
85457>>>>>>>        Get SqlUtilEnumerateIntFiles sDataPath to sFilesData
85458>>>>>>>        Move (SizeOfArray(sFilesData))    to iSize
85459>>>>>>>        If (iSize = 0) Begin
85461>>>>>>>            If (ghoStatusPanel <> 0) Begin
85463>>>>>>>                If (Active_State(ghoStatusPanel)) Begin
85465>>>>>>>                    Send Stop_StatusPanel of ghoStatusPanel
85466>>>>>>>                End
85466>>>>>>>>
85466>>>>>>>            End
85466>>>>>>>>
85466>>>>>>>            Send Info_Box CS_DUF_NoIntFilesFound
85467>>>>>>>            Procedure_Return
85468>>>>>>>        End
85468>>>>>>>>
85468>>>>>>>
85468>>>>>>>        Move (Trim(sConnectionID)) to sConnectionID
85469>>>>>>>        Get vFolderFormat sDataPath to sDataPath
85470>>>>>>>        Decrement iSize
85471>>>>>>>        For iCount from 0 to iSize
85477>>>>>>>>
85477>>>>>>>            Move sFilesData[iCount] to sFileName
85478>>>>>>>            // This makes sure that we also can change an existing connection id to something new:
85478>>>>>>>            Get _UtilChangeSourceCodeLine (sDataPath + sFileName) CS_SERVER_NAME (CS_SERVER_NAME * CS_DFCONNID + "=" + sConnectionID) bShowResult to bOK
85479>>>>>>>            If (ghoStatusPanel <> 0) Begin
85481>>>>>>>                If (Active_State(ghoStatusPanel)) Begin
85483>>>>>>>                    Get Check_StatusPanel of ghoStatusPanel to bCancel
85484>>>>>>>                    If (bCancel = True) Begin
85486>>>>>>>                        Send Deactivate of ghoStatusPanel
85487>>>>>>>                        Procedure_Return
85488>>>>>>>                    End
85488>>>>>>>>
85488>>>>>>>                End
85488>>>>>>>>
85488>>>>>>>            End
85488>>>>>>>>
85488>>>>>>>        Loop
85489>>>>>>>>
85489>>>>>>>
85489>>>>>>>        Get psDriverID to sDriverID
85490>>>>>>>
85490>>>>>>>         // Finally also change the driver file e.g. MSSQLDRV.int file in the Data folder in case it has a "DFconnectionID xxxxID,SERVER..."
85490>>>>>>>        Move "" to sFileName
85491>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
85493>>>>>>>            Move "MSSQLDrv.int" to sFileName
85494>>>>>>>        End
85494>>>>>>>>
85494>>>>>>>        If (sDriverID = DB2_DRV_ID) Begin
85496>>>>>>>            Move "DB2_Drv.int" to sFileName
85497>>>>>>>        End
85497>>>>>>>>
85497>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
85499>>>>>>>            Move "ODBC_Drv.int" to sFileName
85500>>>>>>>        End
85500>>>>>>>>
85500>>>>>>>        If (sFileName <> "") Begin
85502>>>>>>>            Move "" to sDriverFile
85503>>>>>>>            Get_File_Path sFileName to sDriverFile
85504>>>>>>>            If (sDriverFile <> "") Begin
85506>>>>>>>                Get psConnectionString to sConnectionString
85507>>>>>>>                Get _UtilChangeSourceCodeLine sDriverFile CS_SQLConnectionIDText (CS_SQLConnectionIDText * String(sConnectionID) + "," * String(sConnectionString) * String(",0")) bShowResult to bOK
85508>>>>>>>            End
85508>>>>>>>>
85508>>>>>>>        End
85508>>>>>>>>
85508>>>>>>>    End_Procedure
85509>>>>>>>
85509>>>>>>>    // Checks if the database exists in SQL. Returns = True if it does.
85509>>>>>>>    Function SqlUtilCheckIfDatabaseExists String sDatabase Returns Boolean
85511>>>>>>>        String[] sDatabaseArray
85512>>>>>>>        String sVal sServer sDriverID
85512>>>>>>>        Integer iCount iSize iPos
85512>>>>>>>        Boolean bExists
85512>>>>>>>        tSQLConnection SQLConnection
85512>>>>>>>        tSQLConnection SQLConnection
85512>>>>>>>
85512>>>>>>>        Move False to bExists
85513>>>>>>>        Get psDriverID to sDriverID
85514>>>>>>>        // DB2 doesn't have a "Database" name, so we always return True.
85514>>>>>>>        If (sDriverID = DB2_DRV_ID) Begin
85516>>>>>>>            Function_Return bExists
85517>>>>>>>        End
85517>>>>>>>>
85517>>>>>>>
85517>>>>>>>        Get SqlUtilEnumerateDatabases sDriverID to sDatabaseArray
85518>>>>>>>        If (SizeOfArray(sDatabaseArray) = 0) Begin
85520>>>>>>>            Function_Return False
85521>>>>>>>        End
85521>>>>>>>>
85521>>>>>>>
85521>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
85522>>>>>>>        Move SQLConnection.sServer to sServer
85523>>>>>>>
85523>>>>>>>        // Special code to handle a FILEDSN that also can contain "/"
85523>>>>>>>        If (Uppercase(sServer) contains ("." + CS_SQLIniDSNKeyword)) Begin
85525>>>>>>>            Move sDatabaseArray[0] to sVal  // Dummy!
85526>>>>>>>        End
85526>>>>>>>>
85526>>>>>>>        Else If (sServer contains "/") Begin
85529>>>>>>>            Move (Pos("/", sServer)) to iPos
85530>>>>>>>            Move (Mid(sServer, 999, (iPos +1))) to sDatabase
85531>>>>>>>        End
85531>>>>>>>>
85531>>>>>>>
85531>>>>>>>        Move (SizeOfArray(sDatabaseArray)) to iSize
85532>>>>>>>        Decrement iSize
85533>>>>>>>        For iCount from 0 to iSize
85539>>>>>>>>
85539>>>>>>>            Move sDatabaseArray[iCount] to sVal
85540>>>>>>>            If (Uppercase(sVal) = Uppercase(sDatabase)) Begin
85542>>>>>>>                Move True to bExists
85543>>>>>>>                If (bExists = True) Begin
85545>>>>>>>                    Move iSize to iCount // We're done.
85546>>>>>>>                End
85546>>>>>>>>
85546>>>>>>>            End
85546>>>>>>>>
85546>>>>>>>        Loop
85547>>>>>>>>
85547>>>>>>>
85547>>>>>>>        Function_Return bExists
85548>>>>>>>    End_Function
85549>>>>>>>
85549>>>>>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
85549>>>>>>>    Function SqlUtilCheckIfTableHandleExists Handle hTable String sDriverID Returns Boolean
85551>>>>>>>        String sDatabase sSchema sTableName sVal
85551>>>>>>>        Boolean bExists
85551>>>>>>>        String[] sTablesArray
85552>>>>>>>        Integer iSize iCount
85552>>>>>>>
85552>>>>>>>        Move False to bExists
85553>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85554>>>>>>>        Get psDatabase to sDatabase
85555>>>>>>>        Get psSchema   to sSchema
85556>>>>>>>        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
85557>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
85558>>>>>>>        Decrement iSize
85559>>>>>>>        For iCount from 0 to iSize
85565>>>>>>>>
85565>>>>>>>            Move sTablesArray[iCount] to sVal
85566>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
85568>>>>>>>                Move True to bExists
85569>>>>>>>                Move iSize to iCount // We're done!
85570>>>>>>>            End
85570>>>>>>>>
85570>>>>>>>        Loop
85571>>>>>>>>
85571>>>>>>>
85571>>>>>>>        Function_Return bExists
85572>>>>>>>    End_Function
85573>>>>>>>
85573>>>>>>>    Function SqlUtilCheckIfTableNameSpelling String sDriverID String sDatabase String sTableName String sSchema Returns String
85575>>>>>>>        String sVal sTableSpelledCorrectly
85575>>>>>>>        Boolean bExists
85575>>>>>>>        String[] sTablesArray
85576>>>>>>>        Integer iSize iCount
85576>>>>>>>
85576>>>>>>>        Move False to bExists
85577>>>>>>>        Move sTableName to sTableSpelledCorrectly
85578>>>>>>>        Get _SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
85579>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
85580>>>>>>>        Decrement iSize
85581>>>>>>>        For iCount from 0 to iSize
85587>>>>>>>>
85587>>>>>>>            Move sTablesArray[iCount] to sVal
85588>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
85590>>>>>>>                Move sVal to sTableSpelledCorrectly
85591>>>>>>>                Move iSize to iCount // We're done!
85592>>>>>>>            End
85592>>>>>>>>
85592>>>>>>>        Loop
85593>>>>>>>>
85593>>>>>>>
85593>>>>>>>        Function_Return sTableSpelledCorrectly
85594>>>>>>>    End_Function
85595>>>>>>>
85595>>>>>>>    // ToDo: This index name function needs to be finished...
85595>>>>>>>    Function SqlUtilCheckIfIndexNameExists Handle hTable String sIndexName Returns Boolean
85597>>>>>>>        String sSchema sTableName sDriverID
85597>>>>>>>        Boolean bExists
85597>>>>>>>
85597>>>>>>>        Get psDriverID to sDriverID
85598>>>>>>>        Get psSchema to sSchema
85599>>>>>>>        Get UtilTableHandleToString hTable to sTableName
85600>>>>>>>
85600>>>>>>>        Function_Return bExists
85601>>>>>>>    End_Function
85602>>>>>>>
85602>>>>>>>    // Checks if a column/field name exists in a SQL table definition
85602>>>>>>>    // Returns True if it does
85602>>>>>>>    // Sample:
85602>>>>>>>    //   Get SQLUtilColumnExists "MySQLTable" "MyColumnName" to bExists
85602>>>>>>>    Function SqlUtilColumnExists String sTableName String sFieldName Returns Boolean
85604>>>>>>>        Integer iNumColumns iColumn
85604>>>>>>>        String sColumn sDriverID
85604>>>>>>>        String[] sColumnsArray
85605>>>>>>>        Boolean bExists bOK
85605>>>>>>>
85605>>>>>>>        Move False to bExists
85606>>>>>>>        Get AutoConnectionIDLogin to bOK
85607>>>>>>>        Get psDriverID to sDriverID
85608>>>>>>>
85608>>>>>>>        Get _SqlUtilEnumerateColumns sDriverID sTableName to sColumnsArray
85609>>>>>>>        Move (SizeOfArray(sColumnsArray)) to iNumColumns
85610>>>>>>>        Decrement iNumColumns
85611>>>>>>>        For iColumn from 0 to iNumColumns
85617>>>>>>>>
85617>>>>>>>            Move sColumnsArray[iColumn] to sColumn
85618>>>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
85620>>>>>>>                Move True to bExists
85621>>>>>>>                Move iNumColumns to iColumn // We're out of here
85622>>>>>>>            End
85622>>>>>>>>
85622>>>>>>>        Loop
85623>>>>>>>>
85623>>>>>>>
85623>>>>>>>        Function_Return bExists
85624>>>>>>>    End_Function
85625>>>>>>>
85625>>>>>>>    Function SqlUtilConvertColumnTypesToSQL2008 Handle hTable Returns Boolean
85627>>>>>>>        Integer iNumColumns iColumn iDFType iNativeType
85627>>>>>>>        Boolean bOpened bOK
85627>>>>>>>        String sColumnName sNativeTypeName
85627>>>>>>>
85627>>>>>>>        Get AutoConnectionIDLogin to bOK
85628>>>>>>>        Get OpenTableExclusive hTable to bOK
85629>>>>>>>        If (bOK = False) Begin
85631>>>>>>>            Function_Return False
85632>>>>>>>        End
85632>>>>>>>>
85632>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
85635>>>>>>>        If (bOpened = False) Begin
85637>>>>>>>            Error DFERR_PROGRAM ("Function SQLUtilConvertColumnTypesToSQL2008; Could not open table" * String(hTable))
85638>>>>>>>>
85638>>>>>>>            Function_Return False
85639>>>>>>>        End
85639>>>>>>>>
85639>>>>>>>
85639>>>>>>>        Move False to Err
85640>>>>>>>
85640>>>>>>>        Structure_Start hTable
85641>>>>>>>            Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
85644>>>>>>>
85644>>>>>>>            For iColumn from 1 to iNumColumns
85650>>>>>>>>
85650>>>>>>>                Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iDfType
85653>>>>>>>                Get_Attribute DF_FIELD_NAME             of hTable iColumn to sColumnName
85656>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iNativeType
85659>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE_Name of hTable iColumn to sNativeTypeName
85662>>>>>>>
85662>>>>>>>                Case Begin
85662>>>>>>>                    Case (iDFType = DF_DATE)
85664>>>>>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
85666>>>>>>>                            // Convert datetime to date
85666>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_DATE
85669>>>>>>>                        End
85669>>>>>>>>
85669>>>>>>>                        Case Break
85670>>>>>>>                    Case (iDFType = DF_DATETIME)
85673>>>>>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
85675>>>>>>>                            // Convert datetime to datetime2
85675>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_TIMESTAMP2
85678>>>>>>>                        End
85678>>>>>>>>
85678>>>>>>>                        Case Break
85679>>>>>>>                    Case (iDFType = DF_ASCII)
85682>>>>>>>                        If (iNativeType = SQL_CHAR) Begin
85684>>>>>>>                            // Convert char to varchar
85684>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
85687>>>>>>>                        End
85687>>>>>>>>
85687>>>>>>>                        Case Break
85688>>>>>>>                    Case (iDFType = DF_TEXT)
85691>>>>>>>                        If (iNativeType = SQL_LONGVARCHAR) Begin
85693>>>>>>>                            // Convert text to varchar(max)
85693>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
85696>>>>>>>                        End
85696>>>>>>>>
85696>>>>>>>                        Case Break
85697>>>>>>>                    Case (iDFType = DF_BINARY)
85700>>>>>>>                        If (iNativeType = SQL_LONGVARBINARY) Begin
85702>>>>>>>                            // Convert image to varbinary(max)
85702>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARBINARY
85705>>>>>>>                        End
85705>>>>>>>>
85705>>>>>>>                        Case Break
85706>>>>>>>                Case End
85706>>>>>>>            Loop
85707>>>>>>>>
85707>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
85708>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
85710>>>>>>>
85710>>>>>>>        Set Action_Text of ghoStatusPanel to ""
85711>>>>>>>        Function_Return (Err = False)
85712>>>>>>>    End_Function
85713>>>>>>>
85713>>>>>>>
85713>>>>>>>    // Will create an SQL table with the passed sTableName & sColumnName as Numeric 4.2 to keep
85713>>>>>>>    // the DbUpdateVersion database revision in.
85713>>>>>>>    // Also pass the file number of the current (embedded?) table number used in development.
85713>>>>>>>    // It will first create the SQL Table & column, then create the .int file and change Filelist.cfg
85713>>>>>>>    Function SqlUtilCreateDbVersionTable Handle hTable String sColumnName String sDriverID Returns Boolean
85715>>>>>>>        Boolean bOK bOpened
85715>>>>>>>        String sTableName sDataType sAlterTable sAddColumn sLengthAndDecimals sStmt
85715>>>>>>>
85715>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
85718>>>>>>>        Get _TableNameOnly sTableName to sTableName
85719>>>>>>>        If (sTableName = "") Begin
85721>>>>>>>            Function_Return False
85722>>>>>>>        End
85722>>>>>>>>
85722>>>>>>>
85722>>>>>>>        // This just creates the table and a "dummy" column.
85722>>>>>>>        Get SqlTableCreate hTable sDriverID to bOK
85723>>>>>>>        If (bOK = False) Begin
85725>>>>>>>            Function_Return False
85726>>>>>>>        End
85726>>>>>>>>
85726>>>>>>>
85726>>>>>>>        Close hTable
85727>>>>>>>        Move False to Err
85728>>>>>>>
85728>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
85729>>>>>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
85730>>>>>>>        Move "Decimal" to sDataType
85731>>>>>>>        Get _SqlFormatLengthAndDecimalAsString 4 2 to sLengthAndDecimals
85732>>>>>>>
85732>>>>>>>        // Adds the "sColumnName" passed to the function
85732>>>>>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals) to sStmt
85733>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
85734>>>>>>>
85734>>>>>>>        // Now we can delete the dummy column:
85734>>>>>>>        Get SqlColumnRemoveByTableName sTableName "Dummy" to bOK
85735>>>>>>>
85735>>>>>>>        // Finally, we attach to the newly created table.
85735>>>>>>>        If (Err = False) Begin
85737>>>>>>>            Get ApiTableAttachToSQL hTable True to bOK
85738>>>>>>>        End
85738>>>>>>>>
85738>>>>>>>        Open hTable
85740>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
85743>>>>>>>
85743>>>>>>>        Function_Return (Err = False and bOK = True and bOpened = True)
85744>>>>>>>    End_Function
85745>>>>>>>
85745>>>>>>>    // Returns a handle to the SQL server associated with the passed driver ID.
85745>>>>>>>    // Pass e.g. the psServer property to determine the current connection server.
85745>>>>>>>    // Returns a handle to the database connection, or a zero (0) if it fails.
85745>>>>>>>    // This handle can be used to obtain attributes about the server, such as default
85745>>>>>>>    // column types.
85745>>>>>>>    Function SqlUtilDatabaseHandle String sDriverID String sServer Returns Handle
85747>>>>>>>        Handle hDatabase
85747>>>>>>>        Integer iDriver iServers iCount
85747>>>>>>>        String sValue
85747>>>>>>>
85747>>>>>>>        If (sServer = "") Begin
85749>>>>>>>            Function_Return 0
85750>>>>>>>        End
85750>>>>>>>>
85750>>>>>>>
85750>>>>>>>        Get DriverIndex sDriverID to iDriver
85751>>>>>>>        If (iDriver = 0) Begin
85753>>>>>>>            Function_Return 0
85754>>>>>>>        End
85754>>>>>>>>
85754>>>>>>>
85754>>>>>>>        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iServers
85757>>>>>>>        For iCount from 1 to iServers
85763>>>>>>>>
85763>>>>>>>            Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
85766>>>>>>>            If (Uppercase(sValue) contains Uppercase(sServer)) Begin
85768>>>>>>>                Get_Attribute DF_DATABASE_ID of iDriver iCount to hDatabase
85771>>>>>>>            End
85771>>>>>>>>
85771>>>>>>>        Loop
85772>>>>>>>>
85772>>>>>>>
85772>>>>>>>        Function_Return hDatabase
85773>>>>>>>    End_Function
85774>>>>>>>
85774>>>>>>>//    Function UtilIsFilelistEntryDriverBased Integer hTable String sDriverID Returns Boolean
85774>>>>>>>//        String sRootName
85774>>>>>>>//        Boolean bOK
85774>>>>>>>//
85774>>>>>>>//        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
85774>>>>>>>//        Move (sRootName contains sDriverID) to bOK
85774>>>>>>>//
85774>>>>>>>//        Function_Return bOK
85774>>>>>>>//    End_Function
85774>>>>>>>
85774>>>>>>>//    Function UtilFilelistAddDriverInfo Integer hTable Returns Boolean
85774>>>>>>>//        String sDriverID sRootName sDisplayName sSchema sVal
85774>>>>>>>//        Integer iDbType
85774>>>>>>>//        Boolean bOK
85774>>>>>>>//
85774>>>>>>>//        Get UtilIsFilelistEntryDriverBased to bOK
85774>>>>>>>//        If (bOK = True) Begin
85774>>>>>>>//            Function_Return False
85774>>>>>>>//        End
85774>>>>>>>//
85774>>>>>>>//        Get psDriverID to sDriverID
85774>>>>>>>//        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
85774>>>>>>>//        Move (sDriverID + ":" + sRootName)           to sRootName
85774>>>>>>>//        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
85774>>>>>>>//
85774>>>>>>>//        Get psDriverID to sDriverID
85774>>>>>>>//        Get piDbType   to iDbType
85774>>>>>>>//        Get psSchema   to sSchema
85774>>>>>>>//        If (sSchema = "") Begin
85774>>>>>>>//            Get _SqlFindKeyWord CI_SQLDBO to sSchema
85774>>>>>>>//        End
85774>>>>>>>//
85774>>>>>>>//        Move (Uppercase(sDisplayName)) to sVal
85774>>>>>>>//        If (not(sVal contains (sSchema + "."))) Begin
85774>>>>>>>//            If (iDbType = EN_dbTypeDB2) Begin
85774>>>>>>>//                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
85774>>>>>>>//            End
85774>>>>>>>//            Else Begin
85774>>>>>>>//                Move (sSchema + "." + sDisplayName) to sDisplayName
85774>>>>>>>//            End
85774>>>>>>>//        End
85774>>>>>>>//
85774>>>>>>>//        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
85774>>>>>>>//        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
85774>>>>>>>//
85774>>>>>>>//        Function_Return True
85774>>>>>>>//    End_Function
85774>>>>>>>
85774>>>>>>>    // Removes all driver identifications (e.g. "MSSQLDRV:MyTable")
85774>>>>>>>    // from the passed filelist.
85774>>>>>>>    // Returns the number of tables affected.
85774>>>>>>>    Function SqlUtilFilelistRemoveDriverInfo String sFilelist Returns Integer
85776>>>>>>>        String sCurrentFileList sRootName sDisplayName sLogicalName sVal
85776>>>>>>>        Integer iRetval
85776>>>>>>>        Handle hTable
85776>>>>>>>
85776>>>>>>>        // We first save the current filelist as the passed filelist name
85776>>>>>>>        // may come from another workspace, to restore it when we're ready.
85776>>>>>>>        Get_Attribute DF_FILELIST_NAME to sCurrentFileList
85779>>>>>>>        Set_Attribute DF_FILELIST_NAME to sFilelist
85782>>>>>>>        Move 0 to hTable
85783>>>>>>>        Move 0 to iRetval
85784>>>>>>>
85784>>>>>>>        Repeat
85784>>>>>>>>
85784>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
85787>>>>>>>            If (hTable <> 0) Begin
85789>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
85792>>>>>>>                Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
85795>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
85798>>>>>>>                Move (Uppercase(sRootName)) to sVal
85799>>>>>>>                If (sVal contains MSSQLDRV_ID or sVal contains DB2_DRV_ID or sVal contains ODBC_DRV_ID) Begin
85801>>>>>>>                    // Prefixes:
85801>>>>>>>                    Move (Replace((MSSQLDRV_ID + ":"), sRootName, "")) to sRootName
85802>>>>>>>                    Move (Replace((DB2_DRV_ID  + ":"), sRootName, "")) to sRootName
85803>>>>>>>                    Move (Replace((ODBC_DRV_ID + ":"), sRootName, "")) to sRootName
85804>>>>>>>                    // Suffixes:
85804>>>>>>>                    Move (Replace(("." + MSSQLDRV_ID), sRootName, "")) to sRootName
85805>>>>>>>                    Move (Replace(("." + DB2_DRV_ID),  sRootName, "")) to sRootName
85806>>>>>>>                    Move (Replace(("." + ODBC_DRV_ID), sRootName, "")) to sRootName
85807>>>>>>>
85807>>>>>>>                    // Change Filelist entry:
85807>>>>>>>                    Set_Attribute DF_FILE_ROOT_NAME of hTable          to sRootName
85810>>>>>>>
85810>>>>>>>                    Move (Lowercase(sDisplayName)) to sVal
85811>>>>>>>                    If (sVal contains "dbo.") Begin
85813>>>>>>>                        Move (Replace("dbo.", sDisplayName, ""))       to sDisplayName
85814>>>>>>>
85814>>>>>>>                        // Change Filelist entry:
85814>>>>>>>                        Set_Attribute DF_FILE_DISPLAY_NAME of hTable   to sDisplayName
85817>>>>>>>                    End
85817>>>>>>>>
85817>>>>>>>                    Increment iRetval
85818>>>>>>>                End
85818>>>>>>>>
85818>>>>>>>            End
85818>>>>>>>>
85818>>>>>>>        Until (hTable = 0)
85820>>>>>>>
85820>>>>>>>        Set_Attribute DF_FILELIST_NAME to sCurrentFileList
85823>>>>>>>
85823>>>>>>>        Function_Return iRetval
85824>>>>>>>    End_Function
85825>>>>>>>
85825>>>>>>>    // To open all Sql based tables in Filelist.cfg
85825>>>>>>>    Procedure SqlUtilOpenAllTables
85827>>>>>>>        Handle hTable
85827>>>>>>>        String sRoot sDriverID
85827>>>>>>>        Boolean bOK
85827>>>>>>>
85827>>>>>>>        Move 0 to hTable
85828>>>>>>>        Move "" to sDriverID
85829>>>>>>>        Get AutoConnectionIDLogin to bOK
85830>>>>>>>
85830>>>>>>>        Repeat
85830>>>>>>>>
85830>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
85833>>>>>>>            If (hTable > 0) Begin
85835>>>>>>>                Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
85838>>>>>>>                If (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) Begin
85840>>>>>>>                    Get_Attribute DF_FILE_ROOT_NAME of hTable to sRoot
85843>>>>>>>                    If (Uppercase(sRoot) contains ".INT" or Uppercase(sRoot) contains MSSQLDRV_ID or Uppercase(sRoot) contains DB2_DRV_ID or Uppercase(sRoot) contains ODBC_DRV_ID) Begin
85845>>>>>>>                        Open hTable
85847>>>>>>>                    End
85847>>>>>>>>
85847>>>>>>>                End
85847>>>>>>>>
85847>>>>>>>            End
85847>>>>>>>>
85847>>>>>>>
85847>>>>>>>        Until (hTable = 0)
85849>>>>>>>    End_Procedure
85850>>>>>>>
85850>>>>>>>//    Function SqlUtilSchemaName Handle hTable Returns String
85850>>>>>>>//        String sRetval sDriverID
85850>>>>>>>//        String sTableName
85850>>>>>>>//        Integer iDbType iIndex
85850>>>>>>>//        Boolean bOK
85850>>>>>>>//
85850>>>>>>>//        Get psDriverID to sDriverID
85850>>>>>>>//        Get _SqlCheckCurrentDriver sDriverID to bOK
85850>>>>>>>//        If (hTable = 0 or bOK = False) Begin
85850>>>>>>>//            Function_Return ""
85850>>>>>>>//        End
85850>>>>>>>//
85850>>>>>>>//        Move False to Err
85850>>>>>>>//        Get UtilTableHandleToString hTable to sTableName
85850>>>>>>>//        Get piDbType to iDbType
85850>>>>>>>//        Get _SqlUtilEnumerateTableIndex sTableName sDriverID to iIndex
85850>>>>>>>//        If (iIndex = -1) Begin
85850>>>>>>>//            Function_Return ""
85850>>>>>>>//        End
85850>>>>>>>//
85850>>>>>>>//        Function_Return sRetval
85850>>>>>>>//    End_Function
85850>>>>>>>
85850>>>>>>>    // Checks if the passed Table;
85850>>>>>>>    // 1) Already has a Filelist entry that points to SQL and
85850>>>>>>>    // 2) It has an .int file.
85850>>>>>>>    // If both is True it should already be connected to SQL
85850>>>>>>>    Function SqlUtilTableIsAttached String sDriverID Handle hTable Returns Boolean
85852>>>>>>>        Boolean bExists bRootName
85852>>>>>>>        String sRootName sDataPath
85852>>>>>>>
85852>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
85855>>>>>>>        Move (sRootName contains sDriverID) to bRootName
85856>>>>>>>
85856>>>>>>>        Get psDataPathFirstPart to sDataPath
85857>>>>>>>        Get vFolderExists sDataPath to bExists
85858>>>>>>>        If (bExists = False) Begin
85860>>>>>>>            // If the path doesn't exist it cannot have an .int file and we're done, although it shouldn't happen.
85860>>>>>>>            Function_Return False
85861>>>>>>>        End
85861>>>>>>>>
85861>>>>>>>
85861>>>>>>>        Get vFolderFormat sDataPath to sDataPath
85862>>>>>>>        Get _TableNameOnly sRootName to sRootName
85863>>>>>>>        Get vFilePathExists (sDataPath + sRootName + ".int") to bExists
85864>>>>>>>
85864>>>>>>>        Function_Return (bRootName = True and bExists = True)
85865>>>>>>>    End_Function
85866>>>>>>>
85866>>>>>>>    Function SqlUtilTableIsViewType String sDriverID Handle hTable Returns Boolean
85868>>>>>>>        Boolean bViewTableType bOpen bOK
85868>>>>>>>        Integer iTableCount iNumTables
85868>>>>>>>        String sTableName sOwner sTableType sEnumTableName sEnumSchemaName
85868>>>>>>>        Handle hoCliHandler
85868>>>>>>>        tSQLConnection SQLConnection
85868>>>>>>>        tSQLConnection SQLConnection
85868>>>>>>>
85868>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
85871>>>>>>>        If (bOpen = False) Begin
85873>>>>>>>            Get AutoConnectionIDLogin to bOK
85874>>>>>>>            Open hTable
85876>>>>>>>        End
85876>>>>>>>>
85876>>>>>>>
85876>>>>>>>        Get pSQLConnection to SQLConnection
85877>>>>>>>        Get phoCLIHandler to hoCliHandler
85878>>>>>>>        Set psDriverID of hoCliHandler to sDriverID
85879>>>>>>>
85879>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
85882>>>>>>>        Get _TableNameOnly sTableName to sTableName
85883>>>>>>>        Get_Attribute DF_FILE_OWNER     of hTable to sOwner
85886>>>>>>>        Get EnumerateTables of hoCliHandler SQLConnection.sConnectionString to iNumTables
85887>>>>>>>
85887>>>>>>>        For iTableCount from 1 to iNumTables
85893>>>>>>>>
85893>>>>>>>            Get TableName  of hoCliHandler iTableCount to sEnumTableName
85894>>>>>>>            Get SchemaName of hoCliHandler iTableCount to sEnumSchemaName
85895>>>>>>>            If ((Uppercase(sEnumTableName)  = Uppercase(sTableName)) and (Uppercase(sEnumSchemaName) = Uppercase(sOwner))) Begin
85897>>>>>>>                Get TableType of hoCliHandler iTableCount to sTableType
85898>>>>>>>                Move iNumTables to iTableCount // We're done.
85899>>>>>>>            End
85899>>>>>>>>
85899>>>>>>>        Loop
85900>>>>>>>>
85900>>>>>>>
85900>>>>>>>        Move (sTableType = "VIEW") to bViewTableType
85901>>>>>>>        If (bOpen = False) Begin
85903>>>>>>>            Close hTable
85904>>>>>>>        End
85904>>>>>>>>
85904>>>>>>>
85904>>>>>>>        Function_Return bViewTableType
85905>>>>>>>    End_Function
85906>>>>>>>
85906>>>>>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
85906>>>>>>>    //
85906>>>>>>>    // SQL utility function that returns a database type (string) constant
85906>>>>>>>    // corresponding to the passed iDbType.
85906>>>>>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
85908>>>>>>>        String sRetval
85908>>>>>>>        Get SqlUtilDbTypeToString of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
85909>>>>>>>        Function_Return sRetval
85910>>>>>>>    End_Function
85911>>>>>>>
85911>>>>>>>    // SQL utility function that returns a database type constant (integer)
85911>>>>>>>    // corresponding to the passed sDbType string constant.
85911>>>>>>>    Function SqlUtilDbTypeToInteger String sDbType Returns Integer
85913>>>>>>>        Integer iRetval
85913>>>>>>>        Get SqlUtilDbTypeToInteger of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDbType to iRetval
85914>>>>>>>        Function_Return iRetval
85915>>>>>>>    End_Function
85916>>>>>>>
85916>>>>>>>    // Pass an integer DbType and function returns the database type integer as a string value.
85916>>>>>>>    // Used e.g. when reading a connection ini-file to display the database type in
85916>>>>>>>    // the SQL Connection program's grid.
85916>>>>>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
85918>>>>>>>        String sRetval
85918>>>>>>>        Get SqlUtilDbTypeIntegerToStringConstant of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
85919>>>>>>>        Function_Return sRetval
85920>>>>>>>    End_Function
85921>>>>>>>
85921>>>>>>>    // Pass a driver name as a string and the function will return
85921>>>>>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
85921>>>>>>>    // quite work and always returns "MS SQL Server"
85921>>>>>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
85923>>>>>>>        Integer iRetval
85923>>>>>>>        Get SqlUtilDbTypeFromDriver of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDriverID to iRetval
85924>>>>>>>        Function_Return iRetval
85925>>>>>>>    End_Function
85926>>>>>>>
85926>>>>>>>    // Returns a temp table name that consists of the RootName, an underscore and as much of a GUID
85926>>>>>>>    // that "fits" in the max allowed length for table names.
85926>>>>>>>    // Max number of characters allowed for table names;
85926>>>>>>>    // IBM DB2      = 128
85926>>>>>>>    // MS-SQL       = 128
85926>>>>>>>    // Oracle       = 128 (Version 12.2 and later. 30 characters for earlier versions)
85926>>>>>>>    // MySQL        = 64
85926>>>>>>>    // PostgreSQL   = 64
85926>>>>>>>    Function SqlUtilGUIDTempTableName String sRootName Returns String
85928>>>>>>>        String sGUIDName
85928>>>>>>>        Integer iDbType iLength
85928>>>>>>>
85928>>>>>>>        Get piDbType to iDbType
85929>>>>>>>        Move (RandomHexUUID()) to sGUIDName
85930>>>>>>>        Move (sRootName + "_" + sGUIDName) to sGUIDName
85931>>>>>>>        Move (Length(sGUIDName)) to iLength
85932>>>>>>>
85932>>>>>>>        Case Begin
85932>>>>>>>            Case (iDbType = EN_DbTypeDB2)
85934>>>>>>>            If (iLength > 128) Begin
85936>>>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
85937>>>>>>>            End
85937>>>>>>>>
85937>>>>>>>            Case Break
85938>>>>>>>
85938>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
85941>>>>>>>            If (iLength > 128) Begin
85943>>>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
85944>>>>>>>            End
85944>>>>>>>>
85944>>>>>>>            Case Break
85945>>>>>>>
85945>>>>>>>            Case (iDbType = EN_DbTypeOracle) // Note: We assume an Oracle version of 12.2 or later.
85948>>>>>>>            If (iLength > 128) Begin
85950>>>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
85951>>>>>>>            End
85951>>>>>>>>
85951>>>>>>>            Case Break
85952>>>>>>>
85952>>>>>>>            Case (iDbType = EN_DbTypeMySQL)
85955>>>>>>>            If (iLength > 64) Begin
85957>>>>>>>                Move (Left(sGUIDName, 64)) to sGUIDName
85958>>>>>>>            End
85958>>>>>>>>
85958>>>>>>>            Case Break
85959>>>>>>>
85959>>>>>>>            Case (iDbType = EN_DbTypePostgre)
85962>>>>>>>            If (iLength > 64) Begin
85964>>>>>>>                Move (Left(sGUIDName, 64)) to sGUIDName
85965>>>>>>>            End
85965>>>>>>>>
85965>>>>>>>        Case End
85965>>>>>>>
85965>>>>>>>        Function_Return sGUIDName
85966>>>>>>>    End_Function
85967>>>>>>>
85967>>>>>>>    // Reads a resource that has been embedded by the compiler and writes it to disk.
85967>>>>>>>    // Pass the memory resource file reference and the filename to be created,
85967>>>>>>>    // including full path.
85967>>>>>>>    Procedure SqlUtilCreateFileFromMemory String sMemFileName String sFileName
85969>>>>>>>        String sText
85969>>>>>>>        Integer iCh iSize iArgSize
85969>>>>>>>
85969>>>>>>>        Move ("Resource:" + sMemFileName) to sMemFileName
85970>>>>>>>        Get Seq_Open_Input_Channel sMemFileName to iCh
85971>>>>>>>        Get_Channel_Size iCh to iSize
85972>>>>>>>        Read_Block channel iCh sText iSize
85974>>>>>>>        Send Seq_Close_Channel iCh
85975>>>>>>>
85975>>>>>>>        Get Seq_Open_Output_Channel sFileName to iCh
85976>>>>>>>            Write channel iCh sText
85978>>>>>>>        Send Seq_Close_Channel iCh
85979>>>>>>>
85979>>>>>>>        // Wait for file to be written to disk.
85979>>>>>>>        Sleep 2
85980>>>>>>>    End_Procedure
85981>>>>>>>
85981>>>>>>>    Function SqlUtilDefaultNullValue String sDriverID Integer iDbType Integer iDataType Returns String
85983>>>>>>>        String sNotNull sRetval sDefaultValue
85983>>>>>>>        Boolean bOK
85983>>>>>>>
85983>>>>>>>        Get IsSQLDriver sDriverID to bOK
85984>>>>>>>        If (bOK = False) Begin
85986>>>>>>>            Function_Return ""
85987>>>>>>>        End
85987>>>>>>>>
85987>>>>>>>
85987>>>>>>>        Get UtilDataTypeDefaultValue sDriverID iDbType iDataType to sDefaultValue
85988>>>>>>>        Get _SqlFindKeyWord CI_SQLNotNull to sNotNull
85989>>>>>>>
85989>>>>>>>        Case Begin
85989>>>>>>>            Case (iDbType = EN_dbTypeMSSQL)
85991>>>>>>>                Move ("DEFAULT" * String(sDefaultValue) * String(sNotNull)) to sRetval
85992>>>>>>>                Case Break
85993>>>>>>>            Case (iDbType = EN_dbTypeMySQL)
85996>>>>>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
85997>>>>>>>                Case Break
85998>>>>>>>            Case (iDbType = EN_dbTypePostgre)
86001>>>>>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
86002>>>>>>>                Case Break
86003>>>>>>>            Case (iDbType = EN_dbTypeDB2)
86006>>>>>>>                Move (String(sNotNull))                                     to sRetval
86007>>>>>>>                Case Break
86008>>>>>>>
86008>>>>>>>            // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
86008>>>>>>>            // ToDo: We need to look deeper into how Oracle handles NULL
86008>>>>>>>            Case (iDbType = EN_dbTypeOracle)
86011>>>>>>>                Move  ""                                                    to sRetval
86012>>>>>>>                Case Break
86013>>>>>>>
86013>>>>>>>            Case Else
86013>>>>>>>                Move  ""                                                    to sRetval
86014>>>>>>>        Case End
86014>>>>>>>
86014>>>>>>>        Function_Return sRetval
86015>>>>>>>    End_Function
86016>>>>>>>
86016>>>>>>>    // * Dummy function for the Studio's Code Explorer *
86016>>>>>>>    Function SQL_ENUMERATION_FUNCTIONS Returns Boolean
86018>>>>>>>        Function_Return False
86019>>>>>>>    End_Function
86020>>>>>>>
86020>>>>>>>    // Enumerate SQL Servers.
86020>>>>>>>    // Pass a driver id. Returns a string array.
86020>>>>>>>    // The iDataSourceType (iDatSrcType) parameter is optional and is for the ODBC driver only.
86020>>>>>>>    // Note: Returns servers for MSSQLDRV; else data-sources on the machine.
86020>>>>>>>    Function SqlUtilEnumerateServers String sDriverID Integer iDatSrcType Returns String[]
86022>>>>>>>        String[] sReturnArray
86023>>>>>>>        Handle hoSQLHandler
86023>>>>>>>        String sServer
86023>>>>>>>        Integer iCount iNumItems iDataSourceType
86023>>>>>>>
86023>>>>>>>        If (num_arguments > 1) Begin
86025>>>>>>>            Move iDatSrcType to iDataSourceType
86026>>>>>>>        End
86026>>>>>>>>
86026>>>>>>>
86026>>>>>>>        Case Begin
86026>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
86028>>>>>>>                Get phoMSSQLHandler to hoSQLHandler
86029>>>>>>>                Get EnumerateServers of hoSQLHandler to iNumItems
86030>>>>>>>                For iCount from 0 to (iNumItems - 1)
86036>>>>>>>>
86036>>>>>>>                    Get String_Value of hoSQLHandler iCount to sServer
86037>>>>>>>                    Move (Trim(sServer)) to sReturnArray[iCount]
86038>>>>>>>                Loop
86039>>>>>>>>
86039>>>>>>>                Case Break
86040>>>>>>>
86040>>>>>>>            Case (sDriverID = DB2_DRV_ID)
86043>>>>>>>                Get phoDB2SQLHandler to hoSQLHandler
86044>>>>>>>                Send SeedDataSources of hoSQLHandler
86045>>>>>>>                Move 0 to iCount
86046>>>>>>>                Repeat
86046>>>>>>>>
86046>>>>>>>                    Get DataSources of hoSQLHandler to sServer
86047>>>>>>>                    If (sServer <> "") Begin
86049>>>>>>>                        Move (Replace(",", sServer, "")) to sServer
86050>>>>>>>                        Move sServer to sReturnArray[iCount]
86051>>>>>>>                    End
86051>>>>>>>>
86051>>>>>>>                    Increment iCount
86052>>>>>>>                Until (sServer = "")
86054>>>>>>>                Case Break
86055>>>>>>>
86055>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
86058>>>>>>>                Get phoODBCSQLHandler to hoSQLHandler
86059>>>>>>>                Set DataSourceType of hoSQLHandler to iDataSourceType
86060>>>>>>>                Move 0 to iCount
86061>>>>>>>                Repeat
86061>>>>>>>>
86061>>>>>>>                    Get DataSources of hoSQLHandler to sServer
86062>>>>>>>                    If (sServer <> "") Begin
86064>>>>>>>                        Move (Replace(",", sServer, ", ")) to sServer
86065>>>>>>>                        Move sServer to sReturnArray[iCount]
86066>>>>>>>                    End
86066>>>>>>>>
86066>>>>>>>                    Increment iCount
86067>>>>>>>                Until (sServer = "")
86069>>>>>>>                Case Break
86070>>>>>>>
86070>>>>>>>            Case Else
86070>>>>>>>                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateServers function"
86071>>>>>>>>
86071>>>>>>>        Case End
86071>>>>>>>
86071>>>>>>>        Function_Return sReturnArray
86072>>>>>>>    End_Function
86073>>>>>>>
86073>>>>>>>    // Returns all databases as a string array for the passed driver id.
86073>>>>>>>    Function SqlUtilEnumerateDatabases String sDriverID Returns String[]
86075>>>>>>>        String[] sReturnArray
86076>>>>>>>        String sServer sVal
86076>>>>>>>        tSQLIntTableInfo[] sReturnStructArray
86076>>>>>>>        tSQLIntTableInfo[] sReturnStructArray
86077>>>>>>>        tSQLConnection SQLConnection
86077>>>>>>>        tSQLConnection SQLConnection
86077>>>>>>>        Boolean bOK
86077>>>>>>>        Integer iCount iSize
86077>>>>>>>
86077>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
86078>>>>>>>        If (bOK = False) Begin
86080>>>>>>>            Function_Return sReturnArray
86081>>>>>>>        End
86081>>>>>>>>
86081>>>>>>>
86081>>>>>>>        Case Begin
86081>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
86083>>>>>>>                Get _SqlDatabasesArrayMSSQL to sReturnArray
86084>>>>>>>                Case Break
86085>>>>>>>            Case (sDriverID = DB2_DRV_ID)
86088>>>>>>>                Get _SqlDatabasesArrayDB2 to sReturnArray
86089>>>>>>>                Case Break
86090>>>>>>>
86090>>>>>>>            // This is needed to be able to check if a database exists or not.
86090>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
86093>>>>>>>                Get _SqlDatabasesArrayODBC to sReturnStructArray
86094>>>>>>>                If (SizeOfArray(sReturnStructArray)) Begin
86096>>>>>>>                    If (SizeOfArray(sReturnStructArray) = 1 and sReturnStructArray[0].sServerName = "") Begin
86098>>>>>>>                        // If a FILEDSN: (can only be one database name)
86098>>>>>>>                        Move sReturnStructArray[0].sDatabaseName to sReturnArray[0]
86099>>>>>>>                    End
86099>>>>>>>>
86099>>>>>>>                    Else Begin
86100>>>>>>>                        // Else the DSN's were read from the registry.
86100>>>>>>>                        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
86101>>>>>>>                        Move SQLConnection.sServer to sServer
86102>>>>>>>                        Move (SizeOfArray(sReturnStructArray)) to iSize
86103>>>>>>>                        Decrement iSize
86104>>>>>>>                        for iCount from 0 to iSize
86110>>>>>>>>
86110>>>>>>>                            Move (sReturnStructArray[iCount].sServerName) to sVal
86111>>>>>>>                            If (Uppercase(sServer) = Uppercase(sVal)) Begin
86113>>>>>>>                                Move sReturnStructArray[iCount].sDatabaseName to sReturnArray[0]
86114>>>>>>>                                Move iSize to iCount // We're done.
86115>>>>>>>                            End
86115>>>>>>>>
86115>>>>>>>                        Loop
86116>>>>>>>>
86116>>>>>>>                    End
86116>>>>>>>>
86116>>>>>>>                End
86116>>>>>>>>
86116>>>>>>>                Case Break
86117>>>>>>>
86117>>>>>>>            Case Else
86117>>>>>>>//                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateDatabases function"
86117>>>>>>>        Case End
86117>>>>>>>
86117>>>>>>>        Function_Return sReturnArray
86118>>>>>>>    End_Function
86119>>>>>>>
86119>>>>>>>    
86119>>>>>>>    // *** Database API Functions: ***
86119>>>>>>>    // Instead of using Sql Scripts (ESQL), we can opt to use the DataFlex Database API's to
86119>>>>>>>    // make changes/updates to the database.
86119>>>>>>>
86119>>>>>>>    // * Dummy function for the Studio's Code Explorer *
86119>>>>>>>    Function API_TABLE_FUNCTIONS Returns Boolean
86121>>>>>>>        Function_Return False
86122>>>>>>>    End_Function
86123>>>>>>>
86123>>>>>>>    // This might not do what you think - Here's what it does:
86123>>>>>>>    // It checks that the passed hTable TableName in filelist.cfg is exactly the same as at the SQL back-end.
86123>>>>>>>    // If that is True; it creates an .int file for it and changes Filelist.cfg to point
86123>>>>>>>    // to the SQL table.
86123>>>>>>>    // Typical usage for this function is when an entry exists in the Filelist for a table and the table
86123>>>>>>>    // already exists in SQL.
86123>>>>>>>    // This is a bit fiddly as the DF_FILE_PHYSICAL_NAME attribute can only be set inside a
86123>>>>>>>    // Structure_Start ... Structure_End operation when creating a NEW table. Thus it cannot be set when
86123>>>>>>>    // restructuring an existing table.
86123>>>>>>>    Function ApiTableAttachToSql Handle hTable Boolean bUseConnID Returns Boolean
86125>>>>>>>        Boolean bExists bOpened bOK bSystemFile bUseConnectionID bIsAlias
86125>>>>>>>        String sDriverID sConnectionID sConnectionString sDisplayName sRootName sLogicalName sPhysicalName sSchema
86125>>>>>>>        Handle hToTable
86125>>>>>>>
86125>>>>>>>        Move True to bUseConnectionID
86126>>>>>>>        If (num_arguments > 1) Begin
86128>>>>>>>            Move bUseConnID to bUseConnectionID
86129>>>>>>>        End
86129>>>>>>>>
86129>>>>>>>
86129>>>>>>>        Get psDriverID to sDriverID
86130>>>>>>>        // If the table doesn't exist on the SQL back-end we do nothing.
86130>>>>>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
86131>>>>>>>        If (bExists = False) Begin
86133>>>>>>>            Function_Return False
86134>>>>>>>        End
86134>>>>>>>>
86134>>>>>>>
86134>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias
86135>>>>>>>
86135>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
86136>>>>>>>        If (bOK = False) Begin
86138>>>>>>>            Function_Return False
86139>>>>>>>        End
86139>>>>>>>>
86139>>>>>>>
86139>>>>>>>        // Then we need to check that the function hasn't been called before; which in case
86139>>>>>>>        // we do nothing
86139>>>>>>>        Get SQLUtilTableIsAttached sDriverID hTable to bExists
86140>>>>>>>        If (bExists = True) Begin
86142>>>>>>>            Function_Return False
86143>>>>>>>        End
86143>>>>>>>>
86143>>>>>>>
86143>>>>>>>        Get psConnectionID     to sConnectionID
86144>>>>>>>        Get psConnectionString to sConnectionString
86145>>>>>>>        If (sConnectionID = "" or sConnectionString = "") Begin
86147>>>>>>>            Error DFERR_PROGRAM ("An SQL connection has NOT been setup correctly. Could not attach table:" * String(hTable) * "to SQL")
86148>>>>>>>>
86148>>>>>>>            Function_Return False
86149>>>>>>>        End
86149>>>>>>>>
86149>>>>>>>
86149>>>>>>>        Set Private.phCurrentTable to hTable
86150>>>>>>>        Get psSchema to sSchema
86151>>>>>>>        If (sSchema = "") Begin
86153>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
86154>>>>>>>        End
86154>>>>>>>>
86154>>>>>>>
86154>>>>>>>        // If we should use a connection id we need to check it exists;
86154>>>>>>>        // else we create it before attempting creating the table
86154>>>>>>>        If (bUseConnectionID = True) Begin
86156>>>>>>>            Get AutoConnectionIDLogin to bOK
86157>>>>>>>            If (bOk = False) Begin
86159>>>>>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
86160>>>>>>>>
86160>>>>>>>                Function_Return False
86161>>>>>>>            End
86161>>>>>>>>
86161>>>>>>>        End
86161>>>>>>>>
86161>>>>>>>
86161>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
86164>>>>>>>        Get _TableNameOnly sRootName to sRootName
86165>>>>>>>        If (sRootName = "") Begin
86167>>>>>>>            Function_Return False
86168>>>>>>>        End
86168>>>>>>>>
86168>>>>>>>        Move (sRootName + ".int")                    to sPhysicalName
86169>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
86172>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
86175>>>>>>>
86175>>>>>>>        // The Studio no longer adds the schema to the DISPLAY_NAME, so commented out.
86175>>>>>>>        //
86175>>>>>>>        // We don't want to change the display name if it starts with an ampersand ("@"),
86175>>>>>>>        // because then the table should not be visible to users.
86175>>>>>>>//        Move (Pos("@", sDisplayName)) to iPos
86175>>>>>>>//        If (iPos <> 1) Begin
86175>>>>>>>//            If (sDisplayName contains ".") Begin
86175>>>>>>>//                Move (Pos(".", sDisplayName)) to iPos
86175>>>>>>>//                Move (Mid(sDisplayName, 200 ,(iPos + 1))) to sDisplayName
86175>>>>>>>//                Move (sSchema + "." + sDisplayName)       to sDisplayName
86175>>>>>>>//            End
86175>>>>>>>//            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
86175>>>>>>>//                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
86175>>>>>>>//            End
86175>>>>>>>//        End
86175>>>>>>>
86175>>>>>>>        If (bIsAlias = False) Begin
86177>>>>>>>            Get OpenTableExclusive hTable to bOpened
86178>>>>>>>            If (bOpened = False) Begin
86180>>>>>>>                Error DFERR_PROGRAM ("Function ApiTableAttachToSQL - Could not open table number:" * String(hTable) * sLogicalName)
86181>>>>>>>>
86181>>>>>>>                Function_Return False
86182>>>>>>>            End
86182>>>>>>>>
86182>>>>>>>        End
86182>>>>>>>>
86182>>>>>>>
86182>>>>>>>        If (ghoProgressBar <> 0) Begin
86184>>>>>>>            Send DoAdvance of ghoProgressBar
86185>>>>>>>            Set Message_Text of ghoStatusPanel to ""
86186>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Attaching to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable) * "to SQL")
86187>>>>>>>        End
86187>>>>>>>>
86187>>>>>>>        // Note: The hToTable will get changed by the Structure_xxx command...
86187>>>>>>>        Move hTable to hToTable
86188>>>>>>>        Move False to Err
86189>>>>>>>
86189>>>>>>>        // We now create a stub .int file and after Structure_end and also change the Filelist.cfg,
86189>>>>>>>        // then we do a pseudo .int file change with the "_SqlUtilUpdateIntFile" function. After that we have
86189>>>>>>>        // a proper and updated .int file.
86189>>>>>>>        Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bSystemFile
86192>>>>>>>        Get _SqlUtilCreateIntFile hTable sDriverID sConnectionID True bSystemFile to bOK
86193>>>>>>>
86193>>>>>>>        If (bIsAlias = False) Begin
86195>>>>>>>            Structure_Start hToTable sDriverID
86196>>>>>>>                Set Private.phCurrentTable to hTable
86197>>>>>>>                If (bUseConnectionID = True) Begin
86199>>>>>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to (CS_DFCONNID + "=" + sConnectionID)
86202>>>>>>>                End
86202>>>>>>>>
86202>>>>>>>                Else Begin
86203>>>>>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to sConnectionString
86206>>>>>>>                End
86206>>>>>>>>
86206>>>>>>>                Set_Attribute DF_FILE_OWNER         of hToTable to (Lowercase(sSchema))
86209>>>>>>>                // For unknown reason the above sometimes triggers an error and it doesn't help to try to trap the error; so we cheat...
86209>>>>>>>                Move False to Err
86210>>>>>>>                Move 0 to LastErr
86211>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
86212>>>>>>>            Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86214>>>>>>>            Set Action_Text of ghoStatusPanel to ""
86215>>>>>>>        End
86215>>>>>>>>
86215>>>>>>>
86215>>>>>>>        Move (not(Err)) to bOK
86216>>>>>>>        If (bOK = True) Begin
86218>>>>>>>            // The attributes set above will always trigger an error
86218>>>>>>>            // We also adjust the Filelist entries
86218>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to (sDriverID + ":" + sRootName)
86221>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
86224>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
86227>>>>>>>
86227>>>>>>>            // This updates the .int file to make it up-to-date with the SQL back-end.
86227>>>>>>>            Get _SqlUtilUpdateIntFile hTable to bOK
86228>>>>>>>        End
86228>>>>>>>>
86228>>>>>>>
86228>>>>>>>        Function_Return (bOK = True)
86229>>>>>>>    End_Function
86230>>>>>>>
86230>>>>>>>    // Sample usage:
86230>>>>>>>    //    Get ApiTableChangeAttribute SysInfo.File_Number DF_FILE_IS_SYSTEM_FILE True to bOK
86230>>>>>>>    //    Get ApiTableChangeAttribute OrderHea.File_Number DF_FILE_REUSE_DELETED DF_FILE_DELETED_NOREUSE to bOK
86230>>>>>>>    Function ApiTableChangeAttribute Handle hTable Integer iAttribute Integer iValue Returns Boolean
86232>>>>>>>        Boolean bOK bIsSQLTable
86232>>>>>>>
86232>>>>>>>        Get AutoConnectionIDLogin to bOK
86233>>>>>>>        Move False to Err
86234>>>>>>>        Get OpenTableExclusive hTable to bOK
86235>>>>>>>        If (bOK = False) Begin
86237>>>>>>>            Function_Return False
86238>>>>>>>        End
86238>>>>>>>>
86238>>>>>>>
86238>>>>>>>        // ToDo: Add to all table change functions!
86238>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
86239>>>>>>>            If (bIsSQLTable = True) Begin
86241>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
86244>>>>>>>            End
86244>>>>>>>>
86244>>>>>>>
86244>>>>>>>        Set Private.phCurrentTable to hTable
86245>>>>>>>        Structure_Start hTable
86246>>>>>>>            Set_Attribute iAttribute of hTable to iValue
86249>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86250>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86252>>>>>>>
86252>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86253>>>>>>>        Function_Return (Err = False)
86254>>>>>>>    End_Function
86255>>>>>>>
86255>>>>>>>    Function ApiTableMoveFileListEntry String sRootName String sLogicalName String sDisplayName Handle hFromSlot Handle hToSlot String sDriverID Returns Boolean
86257>>>>>>>        Boolean bOK
86257>>>>>>>        
86257>>>>>>>        Get ApiTableChangeFileListSlot sRootName sLogicalName sDisplayName hToSlot sDriverID to bOK
86258>>>>>>>        If (bOK = True) Begin
86260>>>>>>>            Get ApiTableChangeFileListSlot "" "" "" hFromSlot sDriverID to bOK
86261>>>>>>>        End
86261>>>>>>>>
86261>>>>>>>        
86261>>>>>>>        Function_Return (bOK = True)
86262>>>>>>>    End_Function
86263>>>>>>>    
86263>>>>>>>    // To use a filelist slot for the passed FileName, TableName & DisplayName,
86263>>>>>>>    // or to change the filelist slot names.
86263>>>>>>>    Function ApiTableChangeFileListSlot String sRootName String sLogicalName String sDisplayName Handle hTable String sDriverID Returns Boolean
86265>>>>>>>        String sFileListName
86265>>>>>>>        
86265>>>>>>>        Move False to Err
86266>>>>>>>
86266>>>>>>>        If (ghoProgressBar <> 0) Begin
86268>>>>>>>            Send DoAdvance of ghoProgressBar
86269>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Changing Filelist slot for Table:" * String(sLogicalName) * "Number:" * String(hTable))
86270>>>>>>>        End
86270>>>>>>>>
86270>>>>>>>        // If all strings are empty it means that we should remove this entry from filelist.
86270>>>>>>>        If (sRootName = "" and sLogicalName = "" and sDisplayName = "") Begin
86272>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
86275>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
86278>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
86281>>>>>>>            Function_Return (Err = False) // And we're done.
86282>>>>>>>        End
86282>>>>>>>>
86282>>>>>>>
86282>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
86284>>>>>>>//            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
86284>>>>>>>            Move (sDriverID + ":" + sRootName) to sRootName
86285>>>>>>>        End
86285>>>>>>>>
86285>>>>>>>//        Else Begin
86285>>>>>>>//            Set_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
86285>>>>>>>//        End
86285>>>>>>>//
86285>>>>>>>//        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
86285>>>>>>>//        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
86285>>>>>>>
86285>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
86288>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
86291>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
86294>>>>>>>        
86294>>>>>>>        Function_Return (Err = False)
86295>>>>>>>    End_Function
86296>>>>>>>
86296>>>>>>>    Function ApiTableChangeRecordLength Handle hTable Integer iRecordLength Returns Boolean
86298>>>>>>>        Boolean bOK
86298>>>>>>>
86298>>>>>>>        Get AutoConnectionIDLogin to bOK
86299>>>>>>>        Move False to Err
86300>>>>>>>        Get OpenTableExclusive hTable to bOK
86301>>>>>>>        If (bOK = False) Begin
86303>>>>>>>            Function_Return False
86304>>>>>>>        End
86304>>>>>>>>
86304>>>>>>>
86304>>>>>>>        Set Private.phCurrentTable to hTable
86305>>>>>>>        Structure_Start hTable
86306>>>>>>>            Set_Attribute DF_FILE_RECORD_LENGTH of hTable to iRecordLength
86309>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86310>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86312>>>>>>>
86312>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86313>>>>>>>        Function_Return (Err = False)
86314>>>>>>>    End_Function
86315>>>>>>>
86315>>>>>>>    Function ApiTableChangeRelation Handle hTable Handle hToTable Integer iFromField Integer iToField Returns Boolean
86317>>>>>>>        Boolean bOK bIsSQLTable
86317>>>>>>>
86317>>>>>>>        Move False to Err
86318>>>>>>>        Get AutoConnectionIDLogin to bOK
86319>>>>>>>        Open hToTable
86321>>>>>>>        Get OpenTableExclusive hTable to bOK
86322>>>>>>>        If (bOK = False) Begin
86324>>>>>>>            Function_Return False
86325>>>>>>>        End
86325>>>>>>>>
86325>>>>>>>
86325>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
86326>>>>>>>            If (bIsSQLTable = True) Begin
86328>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
86331>>>>>>>            End
86331>>>>>>>>
86331>>>>>>>
86331>>>>>>>        Set Private.phCurrentTable to hTable
86332>>>>>>>        Structure_Start hTable
86333>>>>>>>            Set_Attribute DF_FIELD_RELATED_FILE  of hTable iFromField to hToTable
86336>>>>>>>            Set_Attribute DF_FIELD_RELATED_FIELD of hTable iFromField to iToField
86339>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86340>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86342>>>>>>>
86342>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86343>>>>>>>        Function_Return (Err = False)
86344>>>>>>>    End_Function
86345>>>>>>>
86345>>>>>>>    Procedure ApiTableConvertAllAddException Integer hTable
86347>>>>>>>        Integer[] aTableConvertExceptions
86348>>>>>>>        Get paTableConvertExceptions to aTableConvertExceptions
86349>>>>>>>        Move hTable to aTableConvertExceptions[SizeOfArray(aTableConvertExceptions)]
86350>>>>>>>        Set paTableConvertExceptions to aTableConvertExceptions
86351>>>>>>>    End_Procedure
86352>>>>>>>
86352>>>>>>>    Procedure ApiTableDateCorrectionAddException Integer hTable
86354>>>>>>>        Integer[] aTableDateCorrectionExceptions
86355>>>>>>>        Get paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
86356>>>>>>>        Move hTable to aTableDateCorrectionExceptions[SizeOfArray(aTableDateCorrectionExceptions)]
86357>>>>>>>        Set paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
86358>>>>>>>    End_Procedure
86359>>>>>>>
86359>>>>>>>    Procedure ApiTableConvertALLToSql
86361>>>>>>>        Integer[] iTablesArray
86362>>>>>>>        Integer iSize iCount
86362>>>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
86362>>>>>>>        String sDriverID
86362>>>>>>>
86362>>>>>>>        Get psDriverID to sDriverID
86363>>>>>>>        Get pbUseConnectionID to bUseConnectionID
86364>>>>>>>        Get pbToANSI          to bToANSI
86365>>>>>>>        Get pbRecnum          to bRecnum
86366>>>>>>>        Get pbCopyData        to bCopyData
86367>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
86369>>>>>>>            Get pbContinueOnError to bContinueOnError
86370>>>>>>>        End
86370>>>>>>>>
86370>>>>>>>
86370>>>>>>>        Get _AllTablesToConvert to iTablesArray
86371>>>>>>>        Move (SizeOfArray(iTablesArray)) to iSize
86372>>>>>>>        Set pbVisible   of ghoProgressBarOverall to True
86373>>>>>>>        Set piPosition  of ghoProgressBarOverall to 0
86374>>>>>>>        Set piAdvanceBy of ghoProgressBarOverall to 1
86375>>>>>>>        Set piMaximum   of ghoProgressBarOverall to iSize
86376>>>>>>>
86376>>>>>>>        Decrement iSize
86377>>>>>>>        For iCount from 0 to iSize
86383>>>>>>>>
86383>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount
86384>>>>>>>            Get ApiTableConvertToSQL_Ex iTablesArray[iCount] sDriverID bUseConnectionID bToANSI bRecnum bCopyData to bOK
86385>>>>>>>            // Probably the right logic here is to just continue trying to convert every table even
86385>>>>>>>            // if there was an error converting one table...
86385>>>>>>>            //If (bContinueOnError = False and bOK = False) Break
86385>>>>>>>        Loop
86386>>>>>>>>
86386>>>>>>>
86386>>>>>>>    End_Procedure
86387>>>>>>>
86387>>>>>>>    Procedure ApiTableAttachALLToSql
86389>>>>>>>        Integer[] iTablesArray
86390>>>>>>>        Integer iSize iCount
86390>>>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
86390>>>>>>>        String sDriverID
86390>>>>>>>
86390>>>>>>>        Get psDriverID to sDriverID
86391>>>>>>>        Get pbUseConnectionID to bUseConnectionID
86392>>>>>>>        Get pbToANSI          to bToANSI
86393>>>>>>>        Get pbRecnum          to bRecnum
86394>>>>>>>        Get pbCopyData        to bCopyData
86395>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
86397>>>>>>>            Get pbContinueOnError to bContinueOnError
86398>>>>>>>        End
86398>>>>>>>>
86398>>>>>>>
86398>>>>>>>        Get _AllTablesToConvert to iTablesArray
86399>>>>>>>        Move (SizeOfArray(iTablesArray)) to iSize
86400>>>>>>>        Decrement iSize
86401>>>>>>>        For iCount from 0 to iSize
86407>>>>>>>>
86407>>>>>>>            Get ApiTableAttachToSQL iTablesArray[iCount] bUseConnectionID to bOK
86408>>>>>>>        Loop
86409>>>>>>>>
86409>>>>>>>
86409>>>>>>>    End_Procedure
86410>>>>>>>
86410>>>>>>>    Function ApiTableConvertToSql_Ex Handle hTable String sDriverID Boolean bUseConnectionID Boolean bToAnsi Boolean bRecnum Boolean bCopyData Returns Boolean
86412>>>>>>>        Handle hToTable hoLogFile
86412>>>>>>>        Boolean bOK bExists bOpened bDAWDriver bContinueOnError bIsAlias
86412>>>>>>>        String sPhysicalName sRootName sLogicalName sDisplayName sConnectionID sConnectionString
86412>>>>>>>        String sANSI_OEM sSchema sBaseTableSpace sLongTableSpace sIndexTableSpace sDatabase sGUIDName sWarning
86412>>>>>>>        tSQLConnection SQLConnection
86412>>>>>>>        tSQLConnection SQLConnection
86412>>>>>>>
86412>>>>>>>        Get _UtilTableExists hTable to bExists
86413>>>>>>>        If (bExists = False) Begin
86415>>>>>>>            Set Private.phCurrentTable to hTable
86416>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end.(Or Filelist.cfg contains a driver but the table doesn't exists on the SQL back-end)"
86417>>>>>>>>
86417>>>>>>>            Function_Return False
86418>>>>>>>        End
86418>>>>>>>>
86418>>>>>>>
86418>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias
86419>>>>>>>        // If this is an Alias file there is nothing to convert to SQL.
86419>>>>>>>        // Instead we change the Filelist.cfg by adding the driver id to the rootname and create an .int file
86419>>>>>>>        If (bIsAlias = True) Begin
86421>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
86424>>>>>>>            If (sDriverID <> DATAFLEX_ID and not(sRootName contains ":")) Begin
86426>>>>>>>                Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
86429>>>>>>>                Get psConnectionID to sConnectionID
86430>>>>>>>                Get _SqlUtilCreateIntFile hTable sDriverID sConnectionID True False to bOK
86431>>>>>>>            End
86431>>>>>>>>
86431>>>>>>>            Function_Return True
86432>>>>>>>        End
86432>>>>>>>>
86432>>>>>>>
86432>>>>>>>        Set Private.phCurrentTable to hTable
86433>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
86436>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
86439>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
86442>>>>>>>
86442>>>>>>>        If (ghoProgressBar <> 0) Begin
86444>>>>>>>            Send DoAdvance of ghoProgressBar
86445>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * "Number:" * String(hTable) * String(sLogicalName))
86446>>>>>>>            Set Message_Text   of ghoStatusPanel to ""
86447>>>>>>>            Set Action_Text    of ghoStatusPanel to ""
86448>>>>>>>        End
86448>>>>>>>>
86448>>>>>>>
86448>>>>>>>        // Marco Kuipers suggestion;
86448>>>>>>>        // If Filelist.cfg points to an embedded .dat table and the table already exists as
86448>>>>>>>        // an SQL table; Instead of creating the table in SQL, attach it to the existing
86448>>>>>>>        // SQL table.
86448>>>>>>>        Get _UtilTableIsSql hTable to bOK
86449>>>>>>>        If (bOK = False) Begin
86451>>>>>>>            Get _SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
86452>>>>>>>            If (bExists = True) Begin
86454>>>>>>>//                Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
86454>>>>>>>//                Get SqlTableRename hTable sLogicalName sGUIDName to bOK
86454>>>>>>>                Get phoLogFile to hoLogFile
86455>>>>>>>                If (hoLogFile <> 0) Begin          
86457>>>>>>>                    Move ("WARNING! Function: ApiTableConvertToSQL_Ex. The table" * sLogicalName * "pointed to an embedded table in Filelist.cfg that already existed as an SQL table! The table was NOT converted to SQL but instead ATTACHED to the existing SQL table.") to sWarning
86458>>>>>>>//                    Move ("WARNING! Function: ApiTableConvertToSQL_Ex. The table" * sLogicalName * "pointed to an embedded table in Filelist.cfg that already existed as an SQL table! The existing SQL table was renamed to:" * String(sGUIDName) * "and then converted again.") to sWarning
86458>>>>>>>                    Send LogError sWarning False
86459>>>>>>>                End
86459>>>>>>>>
86459>>>>>>>                Else Begin
86460>>>>>>>                    Error DFERR_PROGRAM sWarning
86461>>>>>>>>
86461>>>>>>>                End                                                       
86461>>>>>>>>
86461>>>>>>>                Get ApiTableAttachToSql hTable bUseConnectionID to bOK
86462>>>>>>>                Function_Return bOK // We're done (We have attached to an existing SQL table instead of converting it.
86463>>>>>>>            End
86463>>>>>>>>
86463>>>>>>>        End
86463>>>>>>>>
86463>>>>>>>
86463>>>>>>>        // Does the rootname contain a driver?
86463>>>>>>>        If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
86465>>>>>>>            // Does the table already exist as an SQL table?
86465>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
86466>>>>>>>            // It can happen that the table is missing from Filelist.cfg but still
86466>>>>>>>            // exist on the SQL side, in case we want to search for the table by its name.
86466>>>>>>>            If (bExists = False) Begin
86468>>>>>>>                Get _SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
86469>>>>>>>            End
86469>>>>>>>>
86469>>>>>>>            If (bExists = True) Begin
86471>>>>>>>                Set TableName_Text of ghoStatusPanel to ""
86472>>>>>>>                Function_Return False
86473>>>>>>>            End
86473>>>>>>>>
86473>>>>>>>        End
86473>>>>>>>>
86473>>>>>>>        Move (If(bToAnsi = True, CS_ANSI_Txt, CS_OEM_Txt)) to sANSI_OEM
86474>>>>>>>
86474>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWDriver
86475>>>>>>>        If (bUseConnectionID = True) Begin
86477>>>>>>>            Move False to bUseConnectionID
86478>>>>>>>        End
86478>>>>>>>>
86478>>>>>>>
86478>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
86479>>>>>>>        Move SQLConnection.sSchema           to sSchema
86480>>>>>>>        If (sSchema = "") Begin
86482>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO    to sSchema
86483>>>>>>>            Move (Lowercase(sSchema))        to sSchema
86484>>>>>>>        End
86484>>>>>>>>
86484>>>>>>>
86484>>>>>>>        Move SQLConnection.sDatabase         to sDatabase
86485>>>>>>>        Move SQLConnection.sConnectionID     to sConnectionID
86486>>>>>>>        Move SQLConnection.sConnectionString to sConnectionString
86487>>>>>>>        If (sConnectionID = "" or sConnectionString = "") Begin
86489>>>>>>>            Error DFERR_PROGRAM ("The SQL connection info has NOT been setup. Could not convert table:" * String(hTable) * "to SQL")
86490>>>>>>>>
86490>>>>>>>            Function_Return False
86491>>>>>>>        End
86491>>>>>>>>
86491>>>>>>>
86491>>>>>>>        Get AutoConnectionIDLogin to bOK
86492>>>>>>>        Open hTable
86494>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
86497>>>>>>>        If (bOpened = False) Begin
86499>>>>>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
86500>>>>>>>>
86500>>>>>>>            Function_Return False
86501>>>>>>>        End
86501>>>>>>>>
86501>>>>>>>
86501>>>>>>>        If (ghoProgressBar <> 0) Begin
86503>>>>>>>            Send DoAdvance of ghoProgressBar
86504>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Converting to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable))
86505>>>>>>>        End
86505>>>>>>>>
86505>>>>>>>
86505>>>>>>>        Move 0 to hToTable
86506>>>>>>>        Get _TableNameOnly sRootName                 to sRootName
86507>>>>>>>        Move (sRootName + ".int")                    to sPhysicalName
86508>>>>>>>
86508>>>>>>>        Case Begin
86508>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
86510>>>>>>>                Case Break
86511>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
86514>>>>>>>                Case Break
86515>>>>>>>            Case (sDriverID = DB2_DRV_ID)
86518>>>>>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
86519>>>>>>>                Move SQLConnection.sLongTableSpace  to sLongTableSpace
86520>>>>>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
86521>>>>>>>                Case Break
86522>>>>>>>            Case (sDriverID = DATAFLEX_ID)
86525>>>>>>>                Case Break
86526>>>>>>>            Case Else
86526>>>>>>>                Error DFERR_PROGRAM "Wrong database driver passed to the 'ApiTableConvertToSQL_Ex' function."
86527>>>>>>>>
86527>>>>>>>                Case Break
86528>>>>>>>        Case End
86528>>>>>>>
86528>>>>>>>        Move False to Err
86529>>>>>>>
86529>>>>>>>        Structure_Start hToTable sDriverID
86530>>>>>>>            Structure_Copy hTable to hToTable
86531>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
86534>>>>>>>
86534>>>>>>>            If (sDriverID <> DATAFLEX_ID) Begin
86536>>>>>>>                If (bUseConnectionID = True) Begin
86538>>>>>>>                    Set_Attribute DF_FILE_LOGIN of hToTable to (CS_DFCONNID + "=" + sConnectionID)
86541>>>>>>>                End
86541>>>>>>>>
86541>>>>>>>                Else Begin
86542>>>>>>>                    Set_Attribute DF_FILE_LOGIN of hToTable to sConnectionString
86545>>>>>>>                End
86545>>>>>>>>
86545>>>>>>>
86545>>>>>>>                Set_Attribute DF_FILE_RECNUM_TABLE of hToTable to bRecnum
86548>>>>>>>
86548>>>>>>>                If (sSchema <> "") Begin
86550>>>>>>>                    Set_Attribute DF_FILE_OWNER of hToTable to sSchema
86553>>>>>>>                End
86553>>>>>>>>
86553>>>>>>>
86553>>>>>>>                If (sDriverID = DB2_DRV_ID) Begin
86555>>>>>>>                    If (sLongTableSpace <> "") Begin
86557>>>>>>>                        Set_Attribute DF_FILE_LONG_TABLESPACE  of hToTable to sLongTableSpace
86560>>>>>>>                    End
86560>>>>>>>>
86560>>>>>>>                    If (sBaseTableSpace <> "") Begin
86562>>>>>>>                        Set_Attribute DF_FILE_TABLE_TABLESPACE of hToTable to sBaseTableSpace
86565>>>>>>>                    End
86565>>>>>>>>
86565>>>>>>>                    If (sIndexTableSpace <> "") Begin
86567>>>>>>>                        Set_Attribute DF_FILE_INDEX_TABLESPACE of hToTable to sIndexTableSpace
86570>>>>>>>                    End
86570>>>>>>>>
86570>>>>>>>                End
86570>>>>>>>>
86570>>>>>>>            End
86570>>>>>>>>
86570>>>>>>>
86570>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86571>>>>>>>        Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86573>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86574>>>>>>>
86574>>>>>>>        Move (not(Err)) to bOK
86575>>>>>>>
86575>>>>>>>        If (bOK = True and bCopyData = True) Begin
86577>>>>>>>            Get ApiTableCopyData hTable sPhysicalName sRootName sDriverID to bOK
86578>>>>>>>
86578>>>>>>>            If (ghoDbUpdateHandler > 0) Begin
86580>>>>>>>                Get pbContinueOnError to bContinueOnError
86581>>>>>>>            End
86581>>>>>>>>
86581>>>>>>>            // If the data copy failed we will keep the newly created SQL table but
86581>>>>>>>            // rename it by adding a GUID to the end of the table name
86581>>>>>>>            // - or as much as "fit" because different SQL back-ends have
86581>>>>>>>            // different rules how long a table name can be.
86581>>>>>>>            // The new table will probably contain data but something went
86581>>>>>>>            // wrong while converting the data from embedded to SQL.
86581>>>>>>>            If (bOK = False and bContinueOnError = False) Begin
86583>>>>>>>                Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
86584>>>>>>>                Get SqlTableRename hTable sLogicalName sGUIDName to bOK
86585>>>>>>>                Error DFERR_PROGRAM ("Copying of" * sLogicalName * " data failed due to bad data. Either duplicate records and/or bad e.g Date/DateTime data. The SQL table was renamed to:" * String(sGUIDName) * "and its Filelist.cfg entry was NOT changed.")
86586>>>>>>>>
86586>>>>>>>            End
86586>>>>>>>>
86586>>>>>>>        End
86586>>>>>>>>
86586>>>>>>>
86586>>>>>>>        // This must be after copying data...
86586>>>>>>>        If (Err = False) Begin
86588>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
86591>>>>>>>            // It seems the Studio does not do this any more, so commented out.
86591>>>>>>>            // We also adjust the display name by prefixing it by the schema name;
86591>>>>>>>            //            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
86591>>>>>>>            //                // The max length for the display_name is 31 characters...
86591>>>>>>>            //                If (Length(sSchema + "." + sDisplayName) < 31) Begin
86591>>>>>>>            //                    Set_Attribute DF_FILE_DISPLAY_NAME of hTable to (Lowercase(sSchema) + "." + sDisplayName)
86591>>>>>>>            //                End
86591>>>>>>>            //            End
86591>>>>>>>        End
86591>>>>>>>>
86591>>>>>>>
86591>>>>>>>        Close hTable
86592>>>>>>>        Move (not(Err)) to bOK
86593>>>>>>>        Function_Return bOK
86594>>>>>>>    End_Function
86595>>>>>>>
86595>>>>>>>    // Calls a driver function directly to copy data from one table to another (table structures needs to be the same).
86595>>>>>>>    // It will first drop all indicies, copy the data and then recreate indicies.
86595>>>>>>>    // An error log file with the sRootname + ".err" will be created in the Data folder.
86595>>>>>>>    Function ApiTableCopyData Integer hFromTable String sPhysicalName String sRootName String sDriverID Returns Boolean
86597>>>>>>>        Boolean bOpened bOK
86597>>>>>>>        Integer hToTable iIndex iRetval iVoid iOrgFreq
86597>>>>>>>        String sErrorFile sEmpty sPath
86597>>>>>>>
86597>>>>>>>        Get_Attribute DF_FILE_NEXT_EMPTY of 0 to hToTable
86600>>>>>>>        Get AutoConnectionIDLogin to bOK
86601>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
86603>>>>>>>            Send IncreaseSortBufferSize
86604>>>>>>>//            Send SetAllIndexesToBatch hToTable
86604>>>>>>>        End
86604>>>>>>>>
86604>>>>>>>
86604>>>>>>>        Move False to Err
86605>>>>>>>        Open sPhysicalName as hToTable
86607>>>>>>>        Get_Attribute DF_FILE_OPENED of hToTable to bOpened
86610>>>>>>>        If (bOpened = False) Begin
86612>>>>>>>            Function_Return False
86613>>>>>>>        End
86613>>>>>>>>
86613>>>>>>>
86613>>>>>>>        If (ghoStatusPanel <> 0) Begin
86615>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Copying Data for Table:" * sRootName * "Number:" * String(hFromTable))
86616>>>>>>>            Set piMinimum of ghoProgressBar to 0
86617>>>>>>>            Set piMaximum of ghoProgressBar to 100 // 100%
86618>>>>>>>        End
86618>>>>>>>>
86618>>>>>>>
86618>>>>>>>        Move "" to sEmpty
86619>>>>>>>        Move False to Err
86620>>>>>>>        Move True to bOK
86621>>>>>>>        Set Private.phCurrentTable to hToTable
86622>>>>>>>
86622>>>>>>>        // No need to get the record identifier
86622>>>>>>>        Set_Attribute DF_FILE_GET_RID_AFTER_CREATE of hToTable to False
86625>>>>>>>        Get_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
86628>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
86630>>>>>>>            // Remove all indices to speed up copying of data:
86630>>>>>>>            Call_Driver hToTable sDriverID Function CLI_DROPINDICES Callback ghoDbUpdateHandler Passing sEmpty sEmpty iVoid Result iRetval
86635>>>>>>>            If (iRetval <> 0) Begin       
86637>>>>>>>                Error DFERR_PROGRAM ("Failed dropping indices for table Number:" * String(hToTable) * "Name:" * String(sRootName))
86638>>>>>>>>
86638>>>>>>>                Close hToTable
86639>>>>>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
86642>>>>>>>                Function_Return False
86643>>>>>>>            End
86643>>>>>>>>
86643>>>>>>>        End
86643>>>>>>>>
86643>>>>>>>
86643>>>>>>>        Move (sRootName + ".err") to sErrorFile
86644>>>>>>>        Move 0 to iIndex
86645>>>>>>>        Move False to Err
86646>>>>>>>
86646>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
86648>>>>>>>            Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to 10
86651>>>>>>>            Call_Driver hToTable sDriverID Function CLI_BCP CallBack ghoDbUpdateHandler Passing iIndex sEmpty hFromTable Result iRetval
86656>>>>>>>            If (iRetval <> 0) Begin
86658>>>>>>>                Error DFERR_PROGRAM ("Failed copying data for table Number:" * String(hToTable) * "Name:" * String(sRootName))
86659>>>>>>>>
86659>>>>>>>                Close hToTable
86660>>>>>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
86663>>>>>>>                Function_Return False
86664>>>>>>>            End
86664>>>>>>>>
86664>>>>>>>        End
86664>>>>>>>>
86664>>>>>>>        Else Begin
86665>>>>>>>            Copy_Records hFromTable to hToTable using 0 Callback ghoDbUpdateHandler
86668>>>>>>>        End
86668>>>>>>>>
86668>>>>>>>
86668>>>>>>>        If (Err = False) Begin
86670>>>>>>>            Get psHome of (phoWorkspace(ghoApplication)) to sPath
86671>>>>>>>            Get vDeleteFile (sPath + sErrorFile) to iRetval
86672>>>>>>>        End
86672>>>>>>>>
86672>>>>>>>
86672>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
86674>>>>>>>            // Recreate indices:
86674>>>>>>>            Call_Driver hToTable sDriverID Function CLI_CREATEINDICES Callback ghoDbUpdateHandler Passing sEmpty sEmpty iVoid Result iRetval
86679>>>>>>>            If (iRetval <> 0) Begin
86681>>>>>>>                Error DFERR_PROGRAM ("Failed creating indices for table Number:" * String(hToTable) * "Name:" * String(sRootName))
86682>>>>>>>>
86682>>>>>>>                Close hToTable
86683>>>>>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
86686>>>>>>>                Function_Return False
86687>>>>>>>            End
86687>>>>>>>>
86687>>>>>>>        End
86687>>>>>>>>
86687>>>>>>>
86687>>>>>>>        Close hToTable
86688>>>>>>>        Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
86691>>>>>>>
86691>>>>>>>        If (bOK = True) Begin
86693>>>>>>>            Move (not(Err)) to bOK
86694>>>>>>>        End
86694>>>>>>>>
86694>>>>>>>
86694>>>>>>>        If (ghoStatusPanel <> 0) Begin
86696>>>>>>>            Set TableName_Text of ghoStatusPanel to ""
86697>>>>>>>            Set Message_Text   of ghoStatusPanel to ""
86698>>>>>>>            Set Action_Text    of ghoStatusPanel to ""
86699>>>>>>>        End
86699>>>>>>>>
86699>>>>>>>
86699>>>>>>>        Function_Return (bOK = True)
86700>>>>>>>    End_Function
86701>>>>>>>
86701>>>>>>>    // The bANSI parameter's default value = True, meaning a table in ANSI format will be created.
86701>>>>>>>    // i.e. DF_FILE_TABLE_CHARACTER_FORMAT {"OEM"|"ANSI"}
86701>>>>>>>    Function ApiTableCreate Handle hTable String sRootName String sDisplayName String sLogicalName Boolean bUseConnectionID Boolean bANSI Boolean bRecnum tAPIColumn[] aColumnIn Returns Boolean
86703>>>>>>>        Handle hFile
86703>>>>>>>        String sConnectionID sPhysicalFile sANSI_OEM sVal sSchema sOriginalDriverID sDriverID sTableName
86703>>>>>>>        Integer iIdentityType iDataType iDbType iCount iSize
86703>>>>>>>        Boolean bOk bExists bSqlDriver bDeleteDummy bExistsInFilelist bSysFile
86703>>>>>>>        tSQLConnection SQLConnection
86703>>>>>>>        tSQLConnection SQLConnection
86703>>>>>>>        tAPIColumn[] aColumns
86703>>>>>>>        tAPIColumn[] aColumns
86704>>>>>>>        tColumnType ColumnType
86704>>>>>>>        tColumnType ColumnType
86704>>>>>>>
86704>>>>>>>        // First check if the passed filenumber already exists; in case we do nothing
86704>>>>>>>        Get _UtilTableExists hTable to bOk
86705>>>>>>>        If (bOk = True) Begin
86707>>>>>>>            Function_Return False
86708>>>>>>>        End
86708>>>>>>>>
86708>>>>>>>
86708>>>>>>>        Set Private.phCurrentTable to hTable
86709>>>>>>>        Move sLogicalName to sTableName
86710>>>>>>>        If (ghoProgressBar <> 0) Begin
86712>>>>>>>            Send DoAdvance of ghoProgressBar
86713>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Creating Table:" * String(sTableName) * "Number:" * String(hTable) * String(sLogicalName))
86714>>>>>>>        End
86714>>>>>>>>
86714>>>>>>>
86714>>>>>>>        Get UtilTableLogicalNameIsInUse sTableName to bExistsInFilelist
86715>>>>>>>        Get psDriverID to sDriverID
86716>>>>>>>        Get IsSQLDriver sDriverID to bSqlDriver
86717>>>>>>>        Get piDbType to iDbType
86718>>>>>>>
86718>>>>>>>        // If no columns passed in, we need to create a "dummy" column
86718>>>>>>>        Move False to bDeleteDummy
86719>>>>>>>        If (Num_Arguments = 8) Begin
86721>>>>>>>            Move aColumnIn to aColumns
86722>>>>>>>        End
86722>>>>>>>>
86722>>>>>>>        If ((SizeOfArray(aColumns)) = 0) Begin
86724>>>>>>>            Get UtilDFDataTypeToSqlTypeMapping sDriverID iDbType DF_BCD to ColumnType
86725>>>>>>>            Move ColumnType.iSQLType to iDataType
86726>>>>>>>            If (bRecnum = False) Begin
86728>>>>>>>                Move C_tAPIColumn_Identity to iIdentityType
86729>>>>>>>            End
86729>>>>>>>>
86729>>>>>>>            Else Begin
86730>>>>>>>                Move C_tAPIColumn_None     to iIdentityType
86731>>>>>>>            End
86731>>>>>>>>
86731>>>>>>>            Get _AppendAPIColumn aColumns "temp" iDataType 10 0 iIdentityType to aColumns
86732>>>>>>>            Move True to bDeleteDummy
86733>>>>>>>        End
86733>>>>>>>>
86733>>>>>>>
86733>>>>>>>        // If columns have been passed as an array we need to check if an identity column
86733>>>>>>>        // has been specified (aColumns[iCounter].iOptions = C_tAPIColumn_Identity), and
86733>>>>>>>        // if so auto-set the bRecnum to FALSE. This is because else there would be
86733>>>>>>>        // two identity columns and SQL doesn't like that and throws an error.
86733>>>>>>>        If (bRecnum = True and (SizeOfArray(aColumns)) <> 0) Begin
86735>>>>>>>            Move (SizeOfArray(aColumns)) to iSize
86736>>>>>>>            Decrement iSize
86737>>>>>>>            for iCount from 0 to iSize
86743>>>>>>>>
86743>>>>>>>                If (aColumns[iCount].iOptions = C_tAPIColumn_Identity) Begin
86745>>>>>>>                    Move False to bRecnum
86746>>>>>>>                    Move iSize to iCount
86747>>>>>>>                End
86747>>>>>>>>
86747>>>>>>>            Loop
86748>>>>>>>>
86748>>>>>>>        End
86748>>>>>>>>
86748>>>>>>>
86748>>>>>>>        // If this is a SQL based driver we also check if the table exists
86748>>>>>>>        // in the SQL back end; in case we do nothing.
86748>>>>>>>        If (bSqlDriver = True) Begin
86750>>>>>>>            // Get all connection properties
86750>>>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
86751>>>>>>>            Move SQLConnection.sSchema to sSchema
86752>>>>>>>            If (sSchema = "") Begin
86754>>>>>>>                Get _SqlFindKeyWord CI_SQLDBO to sSchema
86755>>>>>>>            End
86755>>>>>>>>
86755>>>>>>>
86755>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
86756>>>>>>>            // It can happen that the table is missing from Filelist.cfg but still
86756>>>>>>>            // exist on the SQL side, in case we want to search for the table by its name.
86756>>>>>>>            If (bExists = False) Begin
86758>>>>>>>                Get _SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
86759>>>>>>>            End
86759>>>>>>>>
86759>>>>>>>            // If the table exists on the SQL back-end but not in Filelist.cfg,
86759>>>>>>>            // we will just add it to Filelist.cfg
86759>>>>>>>            If (bExists = True) Begin
86761>>>>>>>                If (bExistsInFilelist = False) Begin
86763>>>>>>>                    If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
86765>>>>>>>                        Move (sDriverID + ":" + sRootName) to sRootName
86766>>>>>>>                    End
86766>>>>>>>>
86766>>>>>>>                    Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
86769>>>>>>>                    Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
86772>>>>>>>                    Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
86775>>>>>>>                    Move False to bSysFile
86776>>>>>>>                    Get _SqlUtilCreateIntFile hTable sDriverID SQLConnection.sConnectionID bANSI bSysFile to bOK
86777>>>>>>>                End
86777>>>>>>>>
86777>>>>>>>                Function_Return False
86778>>>>>>>            End
86778>>>>>>>>
86778>>>>>>>        End
86778>>>>>>>>
86778>>>>>>>
86778>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
86779>>>>>>>        If (num_arguments > 6) Begin
86781>>>>>>>            If (bANSI = False) Begin
86783>>>>>>>                Move CS_OEM_Txt to sANSI_OEM
86784>>>>>>>            End
86784>>>>>>>>
86784>>>>>>>        End
86784>>>>>>>>
86784>>>>>>>
86784>>>>>>>        Move False to Err
86785>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
86787>>>>>>>            Move sRootName to sPhysicalFile
86788>>>>>>>        End
86788>>>>>>>>
86788>>>>>>>
86788>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
86790>>>>>>>            Move SQLConnection.sConnectionID to sConnectionID
86791>>>>>>>
86791>>>>>>>            // If DAW driver and we should use a connection id we need to
86791>>>>>>>            // check if the connection ID exists; else we create it before attempting creating the table
86791>>>>>>>            If (bUseConnectionID = True) Begin
86793>>>>>>>                Get IsConnectionID sConnectionID sDriverID to bExists
86794>>>>>>>                If (bExists = False) Begin
86796>>>>>>>                    Get AutoSetConnectionID sConnectionID to bOk
86797>>>>>>>                    If (bOk = False) Begin
86799>>>>>>>                        Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
86800>>>>>>>>
86800>>>>>>>                        Function_Return False
86801>>>>>>>                    End
86801>>>>>>>>
86801>>>>>>>                End
86801>>>>>>>>
86801>>>>>>>            End
86801>>>>>>>>
86801>>>>>>>
86801>>>>>>>            If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
86803>>>>>>>                Move (sTableName + ".int") to sPhysicalFile
86804>>>>>>>            End
86804>>>>>>>>
86804>>>>>>>            Else Begin
86805>>>>>>>                Move (sRootName + ".int") to sPhysicalFile
86806>>>>>>>            End
86806>>>>>>>>
86806>>>>>>>            Move (Uppercase(sDisplayName)) to sVal
86807>>>>>>>//            If (not(sVal contains (sSchema + "."))) Begin
86807>>>>>>>//                Move (Lowercase(sSchema) + "." + sTableName) to sDisplayName
86807>>>>>>>//            End
86807>>>>>>>        End
86807>>>>>>>>
86807>>>>>>>        Move False to Err
86808>>>>>>>        Move 0 to hFile
86809>>>>>>>
86809>>>>>>>        Structure_Start hFile sDriverID
86810>>>>>>>            If (sDriverID <> DATAFLEX_ID) Begin
86812>>>>>>>                If (bUseConnectionID = True) Begin
86814>>>>>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to (CS_DFCONNID + "=" + sConnectionID)
86817>>>>>>>                End
86817>>>>>>>>
86817>>>>>>>                Else Begin
86818>>>>>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to SQLConnection.sConnectionString
86821>>>>>>>                End
86821>>>>>>>>
86821>>>>>>>                Set_Attribute DF_FILE_TABLE_NAME               of hFile to sTableName
86824>>>>>>>                Set_Attribute DF_FILE_USE_DUMMY_ZERO_DATE      of hFile to True
86827>>>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT   of hFile to sANSI_OEM
86830>>>>>>>                Set_Attribute DF_FILE_RECNUM_TABLE             of hFile to bRecnum
86833>>>>>>>
86833>>>>>>>                If (sSchema <> "") Begin
86835>>>>>>>                    Set_Attribute DF_FILE_OWNER                of hFile to sSchema
86838>>>>>>>                End
86838>>>>>>>>
86838>>>>>>>
86838>>>>>>>                If (sDriverID = DB2_DRV_ID) Begin
86840>>>>>>>                    If (SQLConnection.sLongTableSpace <> "") Begin
86842>>>>>>>                        Set_Attribute DF_FILE_LONG_TABLESPACE  of hFile to SQLConnection.sLongTableSpace
86845>>>>>>>                    End
86845>>>>>>>>
86845>>>>>>>                End
86845>>>>>>>>
86845>>>>>>>                If (sDriverID = DB2_DRV_ID) Begin
86847>>>>>>>                    If (SQLConnection.sBaseTableSpace <> "") Begin
86849>>>>>>>                        Set_Attribute DF_FILE_TABLE_TABLESPACE of hFile to SQLConnection.sBaseTableSpace
86852>>>>>>>                    End
86852>>>>>>>>
86852>>>>>>>                    If (SQLConnection.sIndexTableSpace <> "") Begin
86854>>>>>>>                        Set_Attribute DF_FILE_INDEX_TABLESPACE of hFile to SQLConnection.sIndexTableSpace
86857>>>>>>>                    End
86857>>>>>>>>
86857>>>>>>>                End
86857>>>>>>>>
86857>>>>>>>            End
86857>>>>>>>>
86857>>>>>>>
86857>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hFile to sPhysicalFile
86860>>>>>>>            Get ApiColumnsAddToTable hFile aColumns True to bOk
86861>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86862>>>>>>>        Structure_End hFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86864>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86865>>>>>>>
86865>>>>>>>        Move (not(Err)) to bOK
86866>>>>>>>        If (bOk = True) Begin
86868>>>>>>>            If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
86870>>>>>>>                Move (sDriverID + ":" + sRootName) to sRootName
86871>>>>>>>            End
86871>>>>>>>>
86871>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
86874>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
86877>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
86880>>>>>>>
86880>>>>>>>            // Lastly we remove the temporary column we created above, if all went well.
86880>>>>>>>            If (bDeleteDummy) Begin
86882>>>>>>>                Get ApiColumnRemove hTable "temp" to bOk
86883>>>>>>>            End
86883>>>>>>>>
86883>>>>>>>        End
86883>>>>>>>>
86883>>>>>>>
86883>>>>>>>        Set TableName_Text of ghoStatusPanel to ""
86884>>>>>>>        Close hTable
86885>>>>>>>        Function_Return (bOK = True)
86886>>>>>>>    End_Function
86887>>>>>>>
86887>>>>>>>    Function ApiTableCreateAlias String sFileName String sDisplayName String sAliasName Integer iFilelistSlot Returns Boolean
86889>>>>>>>        Move False to Err
86890>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of iFilelistSlot to sFileName
86893>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of iFilelistSlot to sDisplayName
86896>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of iFilelistSlot to sAliasName
86899>>>>>>>
86899>>>>>>>        Function_Return (Err = False)
86900>>>>>>>    End_Function
86901>>>>>>>
86901>>>>>>>    // ToDo: Needs to be revised
86901>>>>>>>    Procedure ApiTableCreateFromDEF String sPath String sFileName String sTableName String sDisplayName Integer iFilelistSlot
86903>>>>>>>        Handle hTable
86903>>>>>>>        String sDEFName sDataPath
86903>>>>>>>        Boolean bExists
86903>>>>>>>
86903>>>>>>>        // Do nothing if MSSQL Driver.
86903>>>>>>>//        Get IsMSSQLDriver to bExists
86903>>>>>>>//        If (bExists = True) Begin
86903>>>>>>>//            Procedure_Return
86903>>>>>>>//        End
86903>>>>>>>
86903>>>>>>>        Get psDataPathFirstPart to sDataPath
86904>>>>>>>        Get vFilePathExists (sDataPath + sFileName + ".dat") to bExists
86905>>>>>>>        If (bExists = True) Begin
86907>>>>>>>            // We also needs to check if it is an Alias file, in case the sFileName.dat exists, but it may
86907>>>>>>>            // still be missing from the filelist and needs to be added.
86907>>>>>>>            Get _UtilTableNumberIsInUse iFilelistSlot to bExists
86908>>>>>>>            If (bExists = True) Begin
86910>>>>>>>                Procedure_Return
86911>>>>>>>            End
86911>>>>>>>>
86911>>>>>>>            // Do _not_ use the DEF file if an alias, it will overwrite the base table data.
86911>>>>>>>            Else Begin
86912>>>>>>>                Set_Attribute DF_FILE_ROOT_NAME    of iFilelistSlot to sFileName
86915>>>>>>>                Set_Attribute DF_FILE_LOGICAL_NAME of iFilelistSlot to sTableName
86918>>>>>>>                Set_Attribute DF_FILE_DISPLAY_NAME of iFilelistSlot to sDisplayName
86921>>>>>>>                Procedure_Return
86922>>>>>>>            End
86922>>>>>>>>
86922>>>>>>>        End
86922>>>>>>>>
86922>>>>>>>
86922>>>>>>>        Move (sPath + sFileName + ".def") to sDEFName
86923>>>>>>>        Move 0 to hTable
86924>>>>>>>        Move False to Err
86925>>>>>>>
86925>>>>>>>        Structure_Start hTable DATAFLEX_ID
86926>>>>>>>            Load_Def sDEFName Onto hTable
86927>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hTable to sFileName
86930>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86931>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86933>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86934>>>>>>>
86934>>>>>>>        Move iFilelistSlot to hTable
86935>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sFileName
86938>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
86941>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
86944>>>>>>>
86944>>>>>>>    End_Procedure
86945>>>>>>>
86945>>>>>>>    Function ApiTableMoveToFileSlot Integer iFromFileSlot Integer iToFileSlot String sDriverID Returns Boolean
86947>>>>>>>        Boolean bTmp bErr bOK
86947>>>>>>>        String sTableName sDisplayName sFileName
86947>>>>>>>
86947>>>>>>>        // We preserve the value of the Err flag, by saving its current state and resetting it before end of function.
86947>>>>>>>        Move Err to bTmp
86948>>>>>>>        Move False to Err
86949>>>>>>>
86949>>>>>>>        Get AutoConnectionIDLogin to bOK
86950>>>>>>>        // First get the info for the current filelist slot:
86950>>>>>>>        Open iFromFileSlot
86952>>>>>>>        Get_Attribute DF_FILE_OPENED of iFromFileSlot to bOK
86955>>>>>>>        If (bOK = True) Begin
86957>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to sFileName
86960>>>>>>>            Get_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to sTableName
86963>>>>>>>            Get_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to sDisplayName
86966>>>>>>>
86966>>>>>>>            //...then move it.
86966>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of iToFileSlot to sFileName
86969>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iToFileSlot to sTableName
86972>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iToFileSlot to sDisplayName
86975>>>>>>>
86975>>>>>>>            //...and finally remove the old filelist values.
86975>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to ""
86978>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to ""
86981>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to ""
86984>>>>>>>        End
86984>>>>>>>>
86984>>>>>>>        Close iFromFileSlot
86985>>>>>>>
86985>>>>>>>        Move Err to bErr
86986>>>>>>>        Move bTmp to Err
86987>>>>>>>        Function_Return (bErr = False)
86988>>>>>>>    End_Function
86989>>>>>>>
86989>>>>>>>    Function ApiTableRelate Handle hTableFrom Handle hTableTo Integer iColumnFrom Integer iColumnTo Returns Boolean
86991>>>>>>>        Handle hTable
86991>>>>>>>        Boolean bOK
86991>>>>>>>        String sDriverID
86991>>>>>>>
86991>>>>>>>        Get _UtilTableExists hTableFrom to bOK
86992>>>>>>>        If (bOK = False) Begin
86994>>>>>>>            Set Private.phCurrentTable to hTableFrom
86995>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
86996>>>>>>>>
86996>>>>>>>            Function_Return False
86997>>>>>>>        End
86997>>>>>>>>
86997>>>>>>>
86997>>>>>>>        Get _UtilTableExists hTableTo to bOK
86998>>>>>>>        If (bOK = False) Begin
87000>>>>>>>            Set Private.phCurrentTable to hTableTo
87001>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
87002>>>>>>>>
87002>>>>>>>            Function_Return False
87003>>>>>>>        End
87003>>>>>>>>
87003>>>>>>>
87003>>>>>>>        Get AutoConnectionIDLogin to bOK
87004>>>>>>>        Get UtilTableOpen hTableFrom "" DF_EXCLUSIVE to bOK
87005>>>>>>>        If (bOK = False) Begin
87007>>>>>>>            Function_Return False
87008>>>>>>>        End
87008>>>>>>>>
87008>>>>>>>
87008>>>>>>>        Move False to Err
87009>>>>>>>        Open hTableTo
87011>>>>>>>
87011>>>>>>>        Move hTableFrom to hTable
87012>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
87015>>>>>>>        Set Private.phCurrentTable to hTable
87016>>>>>>>
87016>>>>>>>        Structure_Start hTable sDriverID
87017>>>>>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumnFrom to hTableTo
87020>>>>>>>            If (iColumnTo <> 0) Begin
87022>>>>>>>                Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumnFrom to iColumnTo
87025>>>>>>>            End
87025>>>>>>>>
87025>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87026>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87028>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87029>>>>>>>
87029>>>>>>>        If (hTableTo > 0) Begin
87031>>>>>>>            Close hTableTo
87032>>>>>>>        End
87032>>>>>>>>
87032>>>>>>>
87032>>>>>>>        Function_Return (Err = False)
87033>>>>>>>    End_Function
87034>>>>>>>
87034>>>>>>>    // Removes the passed table name completely from disk, filelist (& Sql Server if an Sql-driver)
87034>>>>>>>    Function ApiTableRemove Handle hTable Returns Boolean
87036>>>>>>>        String sTableName sDriverID
87036>>>>>>>        Boolean bOk
87036>>>>>>>        String sDataPath
87036>>>>>>>
87036>>>>>>>        Get AutoConnectionIDLogin to bOK
87037>>>>>>>        Move False to Err
87038>>>>>>>        Get psDriverID to sDriverID
87039>>>>>>>        Get UtilTableHandleToString hTable sDriverID to sTableName
87040>>>>>>>        If (sTableName = "") Begin
87042>>>>>>>            Function_Return False
87043>>>>>>>        End
87043>>>>>>>>
87043>>>>>>>
87043>>>>>>>        Set Private.phCurrentTable to hTable
87044>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
87045>>>>>>>        Delete_db sTableName
87046>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
87047>>>>>>>
87047>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
87049>>>>>>>//            Get SqlTableRemoveByTableName sTableName to bOk  // We don't have to do this because the database is already removed by 'delete_db' above
87049>>>>>>>            Get psDataPathFirstPart to sDataPath
87050>>>>>>>            Get vDeleteFile (sDataPath + sTableName + ".int") to bOk
87051>>>>>>>        End
87051>>>>>>>>
87051>>>>>>>        // Also remove table from filelist.cfg in case the physical file didn't exist.
87051>>>>>>>        If (hTable <> 0) Begin
87053>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
87056>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
87059>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
87062>>>>>>>        End
87062>>>>>>>>
87062>>>>>>>
87062>>>>>>>        Close hTable
87063>>>>>>>        Function_Return (hTable <> 0)
87064>>>>>>>    End_Function
87065>>>>>>>
87065>>>>>>>    Function ApiTableRemoveRelation Handle hTableFrom Integer iColumn Returns Boolean
87067>>>>>>>        Handle hTable
87067>>>>>>>        Boolean bOK
87067>>>>>>>
87067>>>>>>>        Get AutoConnectionIDLogin to bOK
87068>>>>>>>        Move False to Err
87069>>>>>>>        Open hTableFrom Mode DF_EXCLUSIVE
87071>>>>>>>        Move hTableFrom to hTable
87072>>>>>>>
87072>>>>>>>        Structure_Start hTable
87073>>>>>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to 0
87076>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87077>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87079>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87080>>>>>>>
87080>>>>>>>        Close hTableFrom
87081>>>>>>>        Function_Return (Err = False)
87082>>>>>>>    End_Function
87083>>>>>>>
87083>>>>>>>    Function ApiTableRename Handle hTable String sRootName String sDisplayName String sLogicalName Returns Boolean
87085>>>>>>>        String sPhysicalName sRootNameTo sLogicalNameTo sDataPath sDriverID sSchema sPhysicalNameTo
87085>>>>>>>        Boolean bOK bExists bOpened
87085>>>>>>>        tAPITableNameInfo APITableNameInfo
87085>>>>>>>        tAPITableNameInfo APITableNameInfo
87085>>>>>>>
87085>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
87088>>>>>>>        If (bOpened = False) Begin
87090>>>>>>>            Get OpenTableExclusive hTable to bOpened
87091>>>>>>>            If (bOpened = False) Begin
87093>>>>>>>                Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
87094>>>>>>>                Function_Return False
87095>>>>>>>            End
87095>>>>>>>>
87095>>>>>>>        End
87095>>>>>>>>
87095>>>>>>>
87095>>>>>>>        Set Private.phCurrentTable to hTable
87096>>>>>>>        Move hTable         to APITableNameInfo.iTableNumber
87097>>>>>>>        Move sRootName      to APITableNameInfo.sRootName
87098>>>>>>>        Move sLogicalName   to APITableNameInfo.sLogicalName
87099>>>>>>>        Move sDisplayName   to APITableNameInfo.sDisplayName
87100>>>>>>>        Get _ApiTableFilelistNamesCompare True APITableNameInfo to bExists
87101>>>>>>>        If (bExists = True) Begin
87103>>>>>>>            Function_Return True
87104>>>>>>>        End
87104>>>>>>>>
87104>>>>>>>
87104>>>>>>>        Set Private.phCurrentTable to hTable
87105>>>>>>>        Move False to Err
87106>>>>>>>        Get psDataPathFirstPart to sDataPath
87107>>>>>>>        Get_Attribute DF_FILE_PHYSICAL_NAME of hTable to sPhysicalName
87110>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo
87113>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo
87116>>>>>>>
87116>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
87119>>>>>>>        Close hTable
87120>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
87122>>>>>>>            Get vFilePathExists (sDataPath + sRootNameTo + ".dat") to bExists
87123>>>>>>>            If (bExists = True) Begin
87125>>>>>>>                If (Uppercase(sRootName) <> Uppercase(sRootNameTo)) Begin
87127>>>>>>>                    Copy_db (sDataPath + sRootNameTo) to (sDataPath + sRootName)
87130>>>>>>>                    // We need a short break here before attempting to delete the physical old files or Windows
87130>>>>>>>                    // might report "File in use..." and the deletion will fail.
87130>>>>>>>                    Sleep 2
87131>>>>>>>                    Get vDeleteFile (sDataPath + sRootNameTo + ".*") to bOK
87132>>>>>>>                End
87132>>>>>>>>
87132>>>>>>>            End
87132>>>>>>>>
87132>>>>>>>        End
87132>>>>>>>>
87132>>>>>>>
87132>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
87134>>>>>>>            If (not(sPhysicalName contains ".")) Begin
87136>>>>>>>                Move (sPhysicalName + String(".int")) to sPhysicalName
87137>>>>>>>            End
87137>>>>>>>>
87137>>>>>>>
87137>>>>>>>            // Change the table name in the .int file to the new table new:
87137>>>>>>>            Get _UtilChangeSourceCodeLine (sDataPath + sPhysicalName) (CS_DATABASE_NAME * String(sLogicalNameTo)) (CS_DATABASE_NAME * String(sLogicalName)) False to bOK
87138>>>>>>>            If (bOK = False) Begin
87140>>>>>>>                Function_Return False
87141>>>>>>>            End
87141>>>>>>>>
87141>>>>>>>
87141>>>>>>>            // Change table name at the SQL side:
87141>>>>>>>            Get psSchema to sSchema
87142>>>>>>>            Get SqlTableRename hTable sLogicalNameTo sLogicalName to bOK
87143>>>>>>>
87143>>>>>>>            Get _TableNameOnly sRootName to sPhysicalNameTo
87144>>>>>>>            // Remove cache file and Rename the physical file names:
87144>>>>>>>            Get vDeleteFile (sDataPath + sPhysicalNameTo + ".cch")                                  to bOK
87145>>>>>>>            Get vRenameFile (sDataPath + sPhysicalName)            (sDataPath + sRootName + ".int") to bOK
87146>>>>>>>            Get vRenameFile (sDataPath + sPhysicalNameTo + ".tag") (sDataPath + sRootName + ".tag") to bOK
87147>>>>>>>            Move (sDriverID + ":" + sRootName) to sRootName
87148>>>>>>>
87148>>>>>>>            // The Studio no longer adds the schema to the DISPLAY_NAME, so commented out.
87148>>>>>>>//            If (not(sDisplayName contains ".")) Begin
87148>>>>>>>//                Move (sSchema + "." + sDisplayName) to sDisplayName
87148>>>>>>>//            End
87148>>>>>>>        End
87148>>>>>>>>
87148>>>>>>>
87148>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
87151>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
87154>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
87157>>>>>>>
87157>>>>>>>        Function_Return (Err = False)
87158>>>>>>>    End_Function
87159>>>>>>>
87159>>>>>>>    Function ApiTableRenameAlias Integer hTable String sDisplayName String sLogicalName Returns Boolean
87161>>>>>>>        Move False to Err
87162>>>>>>>        Set Private.phCurrentTable to hTable
87163>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
87166>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
87169>>>>>>>
87169>>>>>>>        Function_Return (Err = False)
87170>>>>>>>    End_Function
87171>>>>>>>
87171>>>>>>>    // Note: This table update function does _not_ convert an embedded table to SQL. Use function ApiTableConvertToSQL first for that.
87171>>>>>>>    Function ApiTableUpdate tAPITableNameInfo APITableNameInfoFrom tAPIColumn[] aColumnsFrom tAPIIndex[] aIndexesFrom tAPIRelation[] aRelationsFrom Returns Boolean
87173>>>>>>>        Handle hTable
87173>>>>>>>        String sTableName
87173>>>>>>>        String sDriverIDFrom sDriverIDTo
87173>>>>>>>        Integer iDbType
87173>>>>>>>        Boolean bOk bOpened bApiTableUpdateAuto
87173>>>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase bTableExists
87173>>>>>>>        Boolean bIsSame bFilelistError bIsAliasFrom bIsSQLTableFrom bIsSQLTableTo
87173>>>>>>>        tSQLConnection SQLConnection
87173>>>>>>>        tSQLConnection SQLConnection
87173>>>>>>>        tAPITable      APITableFrom APITableTo
87173>>>>>>>        tAPITable      APITableFrom APITableTo
87173>>>>>>>        tColumnType    ColumnType
87173>>>>>>>        tColumnType    ColumnType
87173>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
87173>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
87174>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
87174>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
87175>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
87175>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
87176>>>>>>>
87176>>>>>>>        // We don't allow changes to the framework's DbVersion table.
87176>>>>>>>        If (Lowercase(sTableName) = "dbversion") Begin
87178>>>>>>>            Function_Return False
87179>>>>>>>        End
87179>>>>>>>>
87179>>>>>>>
87179>>>>>>>        Move APITableNameInfoFrom.sDriverID     to sDriverIDFrom
87180>>>>>>>        Get piDbType                            to iDbType
87181>>>>>>>        Get pbRecnum                            to bRecnum
87182>>>>>>>        Get pbToANSI                            to bToANSI
87183>>>>>>>        Get pbCopyData                          to bCopyData
87184>>>>>>>        Get pbApiTableUpdateAuto                to bApiTableUpdateAuto
87185>>>>>>>        Get pbCompareDate_DateTime              to bCompareDate_DateTime
87186>>>>>>>        Get pbCompareIndexAscending             to bCompareIndexAscending
87187>>>>>>>        Get pbCompareIndexUppercase             to bCompareIndexUppercase
87188>>>>>>>        Get pbUseConnectionID                   to bUseConnectionID
87189>>>>>>>
87189>>>>>>>        Move APITableNameInfoFrom.iTableNumber  to hTable
87190>>>>>>>        Set Private.phCurrentTable              to hTable
87191>>>>>>>        Get _UtilTableExists  hTable             to bTableExists
87192>>>>>>>
87192>>>>>>>        If (ghoProgressBar <> 0) Begin
87194>>>>>>>            Send DoAdvance of ghoProgressBar
87195>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * "Number:" * String(hTable) * String(APITableNameInfoFrom.sLogicalName))
87196>>>>>>>            Set Message_Text   of ghoStatusPanel to ""
87197>>>>>>>            Set Action_Text    of ghoStatusPanel to ""
87198>>>>>>>        End
87198>>>>>>>>
87198>>>>>>>
87198>>>>>>>        Move APITableNameInfoFrom.bIsAlias      to bIsAliasFrom
87199>>>>>>>        Move APITableNameInfoFrom.bIsSQL        to bIsSQLTableFrom
87200>>>>>>>        Get _UtilTableIsSql hTable               to bIsSQLTableTo
87201>>>>>>>        Get UtilDriverFromTableNumber hTable    to sDriverIDTo
87202>>>>>>>        Move True                               to APITableFrom.bFromTable
87203>>>>>>>        Move hTable                             to APITableFrom.hTable
87204>>>>>>>        Move APITableNameInfoFrom               to APITableFrom.ApiTableInfo
87205>>>>>>>        Move aColumnsFrom                       to APITableFrom.aApiColumns
87206>>>>>>>        Move aIndexesFrom                       to APITableFrom.aApiIndexes
87207>>>>>>>        Move aRelationsFrom                     to APITableFrom.aApiRelations
87208>>>>>>>
87208>>>>>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
87210>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverIDFrom to bOk
87211>>>>>>>            If (bOk = True) Begin
87213>>>>>>>                Get ApiTableAttachToSql hTable True to bOk
87214>>>>>>>                Function_Return bOk
87215>>>>>>>            End 
87215>>>>>>>>
87215>>>>>>>        End
87215>>>>>>>>
87215>>>>>>>
87215>>>>>>>        If (bTableExists = True) Begin
87217>>>>>>>            If (bIsSQLTableTo = True) Begin
87219>>>>>>>                Get _UtilDeleteCacheFile APITableFrom.ApiTableInfo.sLogicalName to bOk
87220>>>>>>>            End
87220>>>>>>>>
87220>>>>>>>
87220>>>>>>>            Get OpenTableExclusive hTable to bOpened
87221>>>>>>>            If (bOpened = False) Begin
87223>>>>>>>                Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
87224>>>>>>>                Function_Return False
87225>>>>>>>            End
87225>>>>>>>>
87225>>>>>>>            Get UtilTableStructFill hTable False                                                        to APITableTo
87226>>>>>>>            Get UtilColumnCombineFromAndToArrays   APITableFrom.aApiColumns   APITableTo.aApiColumns    to aAPIColumnCompare
87227>>>>>>>            Get UtilIndexCombineFromAndToArrays    APITableFrom.aApiIndexes   APITableTo.aApiIndexes    to aAPIIndexCompare
87228>>>>>>>            Get UtilRelationCombineFromAndToArrays APITableFrom.aApiRelations APITableTo.aApiRelations  to aAPIRelationCompare
87229>>>>>>>        End
87229>>>>>>>>
87229>>>>>>>
87229>>>>>>>        Move False to Err
87230>>>>>>>        Case Begin
87230>>>>>>>            // Alias table:
87230>>>>>>>            Case (bIsAliasFrom = True)
87232>>>>>>>                Get _UtilTableCheckChangeFilelistNames APITableNameInfoFrom to bOk
87233>>>>>>>                Case Break
87234>>>>>>>
87234>>>>>>>            // New Table:
87234>>>>>>>            Case (bTableExists = False)
87237>>>>>>>                Get ApiTableCreate      hTable APITableNameInfoFrom.sRootName APITableNameInfoFrom.sDisplayName APITableNameInfoFrom.sLogicalName bUseConnectionID bToANSI bRecnum aColumnsFrom to bOk
87238>>>>>>>                //LR 20191112 Begin: Make file a system file if bIsSystemFile = True
87238>>>>>>>                If (APITableNameInfoFrom.bIsSystemFile) Begin
87240>>>>>>>                    Get ApiTableChangeAttribute hTable DF_FILE_IS_SYSTEM_FILE True to bOK
87241>>>>>>>                End                                                                 
87241>>>>>>>>
87241>>>>>>>                Get UtilIndexesUpdate   hTable bIsSQLTableFrom bIsSQLTableTo APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
87242>>>>>>>                Get UtilRelationsUpdate hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
87243>>>>>>>                Case Break
87244>>>>>>>
87244>>>>>>>            // Update table:
87244>>>>>>>            Case (bTableExists = True)
87247>>>>>>>                Get UtilTableCompare APITableFrom APITableTo False (&bFilelistError) to bIsSame
87248>>>>>>>                If (bIsSame = True) Begin
87250>>>>>>>                    Case Break
87251>>>>>>>                End
87251>>>>>>>>
87251>>>>>>>                If (bFilelistError = True) Begin
87253>>>>>>>                    Get ApiTableRename hTable APITableNameInfoFrom.sRootName APITableNameInfoFrom.sDisplayName APITableNameInfoFrom.sLogicalName to bOk
87254>>>>>>>                    If (bOk = False) Begin
87256>>>>>>>                        Case Break
87257>>>>>>>                    End
87257>>>>>>>>
87257>>>>>>>                End
87257>>>>>>>>
87257>>>>>>>
87257>>>>>>>                If (ghoProgressBar <> 0) Begin
87259>>>>>>>                    Send DoAdvance of ghoProgressBar
87260>>>>>>>                    Set TableName_Text of ghoStatusPanel to ("Updating Table:" * "Number:" * String(hTable) * String(APITableNameInfoFrom.sLogicalName))
87261>>>>>>>                End
87261>>>>>>>>
87261>>>>>>>
87261>>>>>>>                // Columns:
87261>>>>>>>                Move True to bOk
87262>>>>>>>                Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom bIsSQLTableTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
87263>>>>>>>                If (bIsSame = False) Begin
87265>>>>>>>                    Get ApiColumnsUpdate sDriverIDFrom hTable bIsSQLTableFrom APITableFrom.aApiColumns APITableTo.aApiColumns bCompareDate_DateTime to bOk
87266>>>>>>>                End
87266>>>>>>>>
87266>>>>>>>                If (bOk = False) Begin
87268>>>>>>>                    Case Break
87269>>>>>>>                End
87269>>>>>>>>
87269>>>>>>>
87269>>>>>>>                // Indexes:
87269>>>>>>>                Get UtilIndexesCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare bCompareIndexUppercase bCompareIndexAscending to bIsSame
87270>>>>>>>                If (bIsSame = False) Begin
87272>>>>>>>                    Get UtilIndexesUpdate hTable bIsSQLTableFrom bIsSQLTableTo APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
87273>>>>>>>                End
87273>>>>>>>>
87273>>>>>>>
87273>>>>>>>                // Relations:
87273>>>>>>>                Get UtilRelationsCompare hTable aAPIRelationCompare to bIsSame
87274>>>>>>>                If (bIsSame = False) Begin
87276>>>>>>>                    Get UtilRelationsUpdate hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
87277>>>>>>>                    If (bOk = False) Begin
87279>>>>>>>                        Case Break
87280>>>>>>>                    End
87280>>>>>>>>
87280>>>>>>>                End
87280>>>>>>>>
87280>>>>>>>
87280>>>>>>>                Case Break
87281>>>>>>>
87281>>>>>>>            Case Else
87281>>>>>>>                Error DFERR_PROGRAM "Unknown Case structure exit in Function ApiTableUpdate"
87282>>>>>>>>
87282>>>>>>>                Move False to bOk
87283>>>>>>>        Case End
87283>>>>>>>        
87283>>>>>>>        // Note: If the from table was SQL; we should either connect to an existing SQL to table,
87283>>>>>>>        // or convert an embedded table to SQL
87283>>>>>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
87285>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverIDFrom to bOk
87286>>>>>>>            If (bOk = False) Begin
87288>>>>>>>                Get ApiTableConvertToSql_Ex hTable sDriverIDFrom bUseConnectionID bToANSI bRecnum bCopyData to bOK
87289>>>>>>>            End
87289>>>>>>>>
87289>>>>>>>        End
87289>>>>>>>>
87289>>>>>>>        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
87292>>>>>>>            Get SqlTableConvertToEmbedded hTable True to bOk
87293>>>>>>>        End
87293>>>>>>>>
87293>>>>>>>        
87293>>>>>>>        // Filelist Names:
87293>>>>>>>        Get _UtilTableCheckChangeFilelistNames APITableNameInfoFrom to bOk
87294>>>>>>>        Close hTable
87295>>>>>>>        Set TableName_Text of ghoStatusPanel to ""
87296>>>>>>>
87296>>>>>>>        Function_Return (bOK = True)
87297>>>>>>>    End_Function
87298>>>>>>>
87298>>>>>>>    // * Dummy function for the Studio's Code Explorer *
87298>>>>>>>    Function API_COLUMN_FUNCTIONS Returns Boolean
87300>>>>>>>        Function_Return False
87301>>>>>>>    End_Function
87302>>>>>>>
87302>>>>>>>    // Adds a column name to the passed table number.
87302>>>>>>>    Function ApiColumnAdd Handle hTable String sFieldName Integer iType Integer iLength Integer iPrec Boolean bInitVal String sColVal Returns Boolean
87304>>>>>>>        Integer iColumn iCount iFile iPrecision iLastErr
87304>>>>>>>        Boolean bExists bOK bInitializeValue bRetval
87304>>>>>>>        String sDataPath sDdSrcPath sTableName sColumnValue sDriverID
87304>>>>>>>
87304>>>>>>>        Get UtilColumnExists hTable sFieldName to bExists
87305>>>>>>>        If (bExists = True) Begin
87307>>>>>>>            Function_Return False
87308>>>>>>>        End
87308>>>>>>>>
87308>>>>>>>
87308>>>>>>>        Move False to Err
87309>>>>>>>        If (num_arguments > 4) Begin
87311>>>>>>>            Move iPrec to iPrecision
87312>>>>>>>        End
87312>>>>>>>>
87312>>>>>>>        If (num_arguments > 6) Begin
87314>>>>>>>            Move bInitVal to bInitializeValue
87315>>>>>>>            Move sColVal  to sColumnValue
87316>>>>>>>        End
87316>>>>>>>>
87316>>>>>>>        If (iType < -1490) Begin
87318>>>>>>>            Move (iType + 1500) to iType
87319>>>>>>>        End
87319>>>>>>>>
87319>>>>>>>
87319>>>>>>>        Move hTable to iFile
87320>>>>>>>        Get psDriverID to sDriverID
87321>>>>>>>        Get AutoConnectionIDLogin to bOK
87322>>>>>>>        Move False to Err
87323>>>>>>>        Move LastErr to iLastErr
87324>>>>>>>        Get OpenTableExclusive iFile to bOK
87325>>>>>>>        Set Private.phCurrentTable to hTable
87326>>>>>>>
87326>>>>>>>        Structure_Start iFile sDriverID
87327>>>>>>>            Move 0 to iColumn
87328>>>>>>>            Set Private.piCurrentField to iColumn
87329>>>>>>>            Create_Field hTable At iColumn
87330>>>>>>>            Set_Attribute DF_FIELD_NAME      of iFile iColumn to sFieldName
87333>>>>>>>            Set_Attribute DF_FIELD_TYPE      of iFile iColumn to iType
87336>>>>>>>            Set_Attribute DF_FIELD_LENGTH    of iFile iColumn to (iLength + iPrecision)
87339>>>>>>>            Set_Attribute DF_FIELD_PRECISION of iFile iColumn to iPrecision
87342>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87343>>>>>>>        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87345>>>>>>>
87345>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87346>>>>>>>
87346>>>>>>>        // If in development environment; create .fd file:
87346>>>>>>>        Open hTable
87348>>>>>>>        Get psDdSrcPath  of (phoWorkspace(ghoApplication)) to sDDSrcPath
87349>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
87350>>>>>>>        If (iCount > 1) Begin
87352>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
87353>>>>>>>        End
87353>>>>>>>>
87353>>>>>>>        Get vFolderExists sDDSrcPath to bExists
87354>>>>>>>        If (bExists = True) Begin
87356>>>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
87357>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
87360>>>>>>>            Get _TableNameOnly sTableName to sTableName
87361>>>>>>>            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
87363>>>>>>>        End
87363>>>>>>>>
87363>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin  // We only want a tag if DataFlex embedded db
87365>>>>>>>            Get psDataPath  of (phoWorkspace(ghoApplication)) to sDataPath
87366>>>>>>>            Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
87367>>>>>>>            If (iCount > 1) Begin
87369>>>>>>>                Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
87370>>>>>>>            End
87370>>>>>>>>
87370>>>>>>>            Get vFolderFormat sDataPath to sDataPath
87371>>>>>>>            // Add the new column name to the .tag filen (if it doesn't exist):
87371>>>>>>>            // The following line should not be necexxary for the DataFlex driver. (Thank you, Hans van de Laar)
87371>>>>>>>            //Get UtilUpdateTAGFile (sDataPath + sTableName + ".tag") sFieldName to bOK
87371>>>>>>>        End
87371>>>>>>>>
87371>>>>>>>        // Check for a default value
87371>>>>>>>        If (bInitializeValue = True and sColumnValue <> "" and Err = False) Begin
87373>>>>>>>            Get ApiColumnUpdateValue hTable sFieldName sColumnValue to bRetval
87374>>>>>>>        End
87374>>>>>>>>
87374>>>>>>>        Close hTable
87375>>>>>>>
87375>>>>>>>        Function_Return (Err = False)
87376>>>>>>>    End_Function
87377>>>>>>>
87377>>>>>>>    // Adds a column name to the passed table number.
87377>>>>>>>    Function ApiColumnInsert String sDriverIDFrom Handle hTable Integer iColumn String sFieldName Integer iType Integer iLength Integer iPrec Boolean bIsSQLType Returns Boolean
87379>>>>>>>        Integer iCount iFile iPrecision iNumberOfFields iDbType
87379>>>>>>>        Boolean bExists bOK bIsDateType bIsSQLTypeTo
87379>>>>>>>        String sDdSrcPath sTableName
87379>>>>>>>
87379>>>>>>>        Get UtilColumnExists hTable sFieldName to bExists
87380>>>>>>>        Move False to Err
87381>>>>>>>        If (bExists = True) Begin
87383>>>>>>>            Function_Return False
87384>>>>>>>        End
87384>>>>>>>>
87384>>>>>>>        If (num_arguments > 4) Begin
87386>>>>>>>            Move iPrec to iPrecision
87387>>>>>>>        End
87387>>>>>>>>
87387>>>>>>>        If (iType < -1490) Begin
87389>>>>>>>            Move (iType + 1500) to iType
87390>>>>>>>        End
87390>>>>>>>>
87390>>>>>>>
87390>>>>>>>        Get AutoConnectionIDLogin to bOK
87391>>>>>>>        Move False to Err
87392>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTypeTo
87393>>>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
87393>>>>>>>        // data types between Embedded and SQL, else we can't compare the data types. 
87393>>>>>>>        Get piDbType to iDbType
87394>>>>>>>        If (bIsSQLTypeTo = False) Begin
87396>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iType iLength to iType
87397>>>>>>>            If (iType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
87399>>>>>>>                Move DF_DATE to iType
87400>>>>>>>            End
87400>>>>>>>>
87400>>>>>>>        End
87400>>>>>>>>
87400>>>>>>>
87400>>>>>>>        // Structure_start will change the value of hTable...
87400>>>>>>>        Move hTable to iFile
87401>>>>>>>        Get OpenTableExclusive iFile to bOK
87402>>>>>>>        If (bOK = False) Begin
87404>>>>>>>            Function_Return False
87405>>>>>>>        End
87405>>>>>>>>
87405>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iNumberOfFields
87408>>>>>>>
87408>>>>>>>        // If the passed column number is higher than the current number of fields
87408>>>>>>>        // in the table, this means we should _not_ insert a field but rather add
87408>>>>>>>        // a new field to the end:
87408>>>>>>>        If (iColumn > iNumberOfFields) Begin
87410>>>>>>>            Move 0 to iColumn
87411>>>>>>>        End
87411>>>>>>>>
87411>>>>>>>
87411>>>>>>>        Set Private.phCurrentTable to hTable
87412>>>>>>>        Set Private.piCurrentField to iColumn
87413>>>>>>>
87413>>>>>>>        Structure_Start iFile
87414>>>>>>>            Create_Field iFile At iColumn
87415>>>>>>>            Set_Attribute DF_FIELD_NAME            of iFile iColumn to sFieldName
87418>>>>>>>            If (bIsSQLTypeTo = False) Begin
87420>>>>>>>                Set_Attribute DF_FIELD_TYPE        of iFile iColumn to iType
87423>>>>>>>            End
87423>>>>>>>>
87423>>>>>>>            Else Begin
87424>>>>>>>                Set_Attribute DF_FIELD_NATIVE_TYPE of iFile iColumn to iType
87427>>>>>>>            End
87427>>>>>>>>
87427>>>>>>>            Get UtilColumnIsDateType iType bIsSQLTypeTo to bIsDateType
87428>>>>>>>            If (bIsDateType = False) Begin
87430>>>>>>>                Set_Attribute DF_FIELD_LENGTH       of iFile iColumn to (iLength + iPrecision)
87433>>>>>>>                Set_Attribute DF_FIELD_PRECISION    of iFile iColumn to iPrecision
87436>>>>>>>            End
87436>>>>>>>>
87436>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87437>>>>>>>        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87439>>>>>>>
87439>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87440>>>>>>>        // If in development environment; create .fd file:
87440>>>>>>>        Open hTable
87442>>>>>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
87443>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
87444>>>>>>>        If (iCount > 1) Begin
87446>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
87447>>>>>>>        End
87447>>>>>>>>
87447>>>>>>>        Get vFolderExists sDDSrcPath to bExists
87448>>>>>>>        If (bExists = True) Begin
87450>>>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
87451>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
87454>>>>>>>            Get _TableNameOnly sTableName to sTableName
87455>>>>>>>            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
87457>>>>>>>        End
87457>>>>>>>>
87457>>>>>>>
87457>>>>>>>        // Check for a default value
87457>>>>>>>        Close hTable
87458>>>>>>>
87458>>>>>>>        Function_Return (Err = False)
87459>>>>>>>    End_Function
87460>>>>>>>
87460>>>>>>>    // To update all records for a table column with a fixed value.
87460>>>>>>>    Function ApiColumnUpdateValue Handle hTable String sFieldName String sColumnValue Returns Boolean
87462>>>>>>>        Integer iRecs iCurrErr iField iRecord
87462>>>>>>>        Boolean bRetval bOpen
87462>>>>>>>
87462>>>>>>>        Move 0 to iRecs
87463>>>>>>>        Move False to bRetval
87464>>>>>>>        Move Err to iCurrErr
87465>>>>>>>        Move False to Err
87466>>>>>>>
87466>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
87469>>>>>>>        If (bOpen = False) Begin
87471>>>>>>>            Open hTable
87473>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
87476>>>>>>>            If (bOpen = False) Begin
87478>>>>>>>                Function_Return bRetval
87479>>>>>>>            End
87479>>>>>>>>
87479>>>>>>>        End
87479>>>>>>>>
87479>>>>>>>
87479>>>>>>>        Field_Map hTable sFieldName to iField
87481>>>>>>>        If (iField <> 0) Begin
87483>>>>>>>            Set Private.phCurrentTable to hTable
87484>>>>>>>            Set Private.piCurrentField to iField
87485>>>>>>>            Clear hTable
87486>>>>>>>            Repeat
87486>>>>>>>>
87486>>>>>>>                Vfind hTable 0 GT
87488>>>>>>>                If (Found) Begin
87490>>>>>>>                    If (ghoStatusPanel <> 0) Begin
87492>>>>>>>                        Get_Field_Value hTable 0 to iRecord
87495>>>>>>>                        Send Update_StatusPanel of ghoStatusPanel (CS_DUF_UpdateVersion * String(iRecord))
87496>>>>>>>                    End
87496>>>>>>>>
87496>>>>>>>                    Reread hTable
87500>>>>>>>                        Set_Field_Value hTable iField to sColumnValue
87503>>>>>>>                        SaveRecord hTable
87504>>>>>>>                    Unlock
87505>>>>>>>>
87505>>>>>>>                End
87505>>>>>>>>
87505>>>>>>>           Until (not(Found))
87507>>>>>>>        End
87507>>>>>>>>
87507>>>>>>>
87507>>>>>>>        Move (Err = False) to bRetval
87508>>>>>>>        Move iCurrErr to Err
87509>>>>>>>
87509>>>>>>>        Function_Return bRetval
87510>>>>>>>    End_Function
87511>>>>>>>
87511>>>>>>>    // Note: This can only be used from within a Structure_Start/End construct.
87511>>>>>>>    Function ApiColumnsAddToTable Handle hTable tAPIColumn[] aColumns Boolean bCreating Returns Boolean
87513>>>>>>>        Integer iCount iSize iColumn iType iDataFlexType iIndex iDbType
87513>>>>>>>        Boolean bFieldExists bNativeType bIsSQLDriver bIsDAWSqlDriver bIsSqlTable bRecnumTable bIsOpen bIsDateType
87513>>>>>>>        String sFieldName sDriverID sTableName sDefaultValue
87513>>>>>>>
87513>>>>>>>        Get psDriverID to sDriverID
87514>>>>>>>        Get piDbType to iDbType
87515>>>>>>>        Get UtilTableHandleToString hTable to sTableName
87516>>>>>>>        Get IsSQLDriver    sDriverID to bIsSQLDriver
87517>>>>>>>        Get IsDAWSQLDriver sDriverID to bIsDAWSqlDriver
87518>>>>>>>        Get _UtilTableIsSql hTable to bIsSqlTable
87519>>>>>>>        If (bIsSqlTable = False and bCreating = True and bIsSQLDriver = True) Begin
87521>>>>>>>            Move True to bIsSqlTable
87522>>>>>>>        End
87522>>>>>>>>
87522>>>>>>>        Move False to bIsOpen
87523>>>>>>>        If (hTable > 0) Begin
87525>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
87528>>>>>>>        End
87528>>>>>>>>
87528>>>>>>>        If (bIsOpen = True) Begin
87530>>>>>>>            Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
87533>>>>>>>        End
87533>>>>>>>>
87533>>>>>>>        Else Begin
87534>>>>>>>            Get pbRecnum to bRecnumTable
87535>>>>>>>        End
87535>>>>>>>>
87535>>>>>>>
87535>>>>>>>        Move False to Err
87536>>>>>>>        Move (SizeOfArray(aColumns)) to iSize
87537>>>>>>>        Decrement iSize
87538>>>>>>>        for iCount from 0 to iSize
87544>>>>>>>>
87544>>>>>>>            Move aColumns[iCount].sFieldName to sFieldName
87545>>>>>>>            If (hTable > 0) Begin
87547>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87548>>>>>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87549>>>>>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn to sFieldName
87552>>>>>>>                Move (Trim(sFieldName) <> "") to bFieldExists
87553>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
87554>>>>>>>                Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87555>>>>>>>            End
87555>>>>>>>>
87555>>>>>>>            Else Begin
87556>>>>>>>                Move False to bFieldExists
87557>>>>>>>            End
87557>>>>>>>>
87557>>>>>>>
87557>>>>>>>            If (bFieldExists = False) Begin
87559>>>>>>>                Move 0 to iColumn
87560>>>>>>>                Create_Field hTable At iColumn
87561>>>>>>>            End
87561>>>>>>>>
87561>>>>>>>            Else Begin
87562>>>>>>>                Move iCount to iColumn
87563>>>>>>>            End
87563>>>>>>>>
87563>>>>>>>
87563>>>>>>>            Set Private.piCurrentField to iColumn
87564>>>>>>>
87564>>>>>>>            Move                                        iColumn to aColumns[iCount].iFieldNumber
87565>>>>>>>            Set_Attribute DF_FIELD_NAME       of hTable iColumn to aColumns[iCount].sFieldName
87568>>>>>>>
87568>>>>>>>            Move aColumns[iCount].iType to iType
87569>>>>>>>            Move (not(iType < -1490)) to bNativeType
87570>>>>>>>            If (iType < -1490) Begin
87572>>>>>>>                Move (iType + 1500) to iType
87573>>>>>>>            End
87573>>>>>>>>
87573>>>>>>>
87573>>>>>>>            If (bIsSqlTable = True) Begin
87575>>>>>>>                If (aColumns[iCount].bIsSQLType = True) Begin
87577>>>>>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iDataFlexType
87578>>>>>>>                    Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iDataFlexType
87581>>>>>>>                    Set_Attribute DF_FIELD_NATIVE_TYPE   of hTable iColumn to iType
87584>>>>>>>                    Set_Attribute DF_FIELD_NULL_ALLOWED  of hTable iColumn to aColumns[iCount].bAllowNULL
87587>>>>>>>
87587>>>>>>>                    Move aColumns[iCount].sDefaultValue                    to sDefaultValue
87588>>>>>>>                    If (iDataFlexType = DF_BCD and Left(String(sDefaultValue), 1) <> "[") Begin
87590>>>>>>>                        Move ("[" + String(sDefaultValue) + "]") to sDefaultValue
87591>>>>>>>                    End
87591>>>>>>>>
87591>>>>>>>                    Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sDefaultValue
87594>>>>>>>
87594>>>>>>>                End
87594>>>>>>>>
87594>>>>>>>                Else Begin
87595>>>>>>>                    Set_Attribute DF_FIELD_TYPE        of hTable iColumn to iType
87598>>>>>>>                End
87598>>>>>>>>
87598>>>>>>>            End
87598>>>>>>>>
87598>>>>>>>            Else Begin
87599>>>>>>>                If (bCreating = False) Begin
87601>>>>>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iType
87602>>>>>>>                    If (iType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
87604>>>>>>>                        Move DF_DATE to iType
87605>>>>>>>                    End
87605>>>>>>>>
87605>>>>>>>                End
87605>>>>>>>>
87605>>>>>>>                Set_Attribute DF_FIELD_TYPE of hTable iColumn to iType
87608>>>>>>>            End
87608>>>>>>>>
87608>>>>>>>
87608>>>>>>>            Get UtilColumnIsDateType iType bIsSqlTable to bIsDateType
87609>>>>>>>            If (bIsDateType = False) Begin
87611>>>>>>>                Set_Attribute DF_FIELD_LENGTH     of hTable iColumn to aColumns[iCount].iLength
87614>>>>>>>                Set_Attribute DF_FIELD_PRECISION  of hTable iColumn to aColumns[iCount].iPrecision
87617>>>>>>>            End
87617>>>>>>>>
87617>>>>>>>
87617>>>>>>>            If (aColumns[iCount].iOptions iand C_tAPIColumn_Identity) Begin
87619>>>>>>>                Move 0 to iIndex
87620>>>>>>>                Create_Index hTable at iIndex
87621>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to 1
87624>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD   of hTable iIndex 1 to iColumn
87627>>>>>>>                Set_Attribute DF_FILE_PRIMARY_INDEX    of hTable iIndex to 1
87630>>>>>>>
87630>>>>>>>                // If we have an identity table - we must create a primary_key table.
87630>>>>>>>                If (bIsSqlTable = True) Begin
87632>>>>>>>                        Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex to True
87635>>>>>>>                        Set_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to True
87638>>>>>>>                End
87638>>>>>>>>
87638>>>>>>>            End
87638>>>>>>>>
87638>>>>>>>        Loop
87639>>>>>>>>
87639>>>>>>>
87639>>>>>>>        Function_Return (Err = False)
87640>>>>>>>    End_Function
87641>>>>>>>
87641>>>>>>>    // Changes a field type, length and precision for the passed table number and field name
87641>>>>>>>    Function ApiColumnChange Handle hTable String sFieldNameFrom Integer iTypeFrom Integer iLengthFrom Integer iPrec Returns Boolean
87643>>>>>>>        Integer iColumn iPrecFrom iTypeTo iLengthTo iPrecTo
87643>>>>>>>        Boolean bOK bIsSqlTable
87643>>>>>>>        String sFieldNameTo
87643>>>>>>>
87643>>>>>>>        If (num_arguments > 4) Begin
87645>>>>>>>            Move iPrec to iPrecFrom
87646>>>>>>>        End
87646>>>>>>>>
87646>>>>>>>        If (iTypeFrom < -1490) Begin
87648>>>>>>>            Move (iTypeFrom + 1500) to iTypeFrom
87649>>>>>>>        End
87649>>>>>>>>
87649>>>>>>>
87649>>>>>>>        Get AutoConnectionIDLogin to bOK
87650>>>>>>>        Move False to Err
87651>>>>>>>        Get OpenTableExclusive hTable to bOK
87652>>>>>>>        If (bOK = False) Begin
87654>>>>>>>            Function_Return False
87655>>>>>>>        End
87655>>>>>>>>
87655>>>>>>>
87655>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87656>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87657>>>>>>>        Field_Map hTable sFieldNameFrom to iColumn
87659>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
87660>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87661>>>>>>>        If (Err = True) Begin
87663>>>>>>>            Function_Return False
87664>>>>>>>        End
87664>>>>>>>>
87664>>>>>>>
87664>>>>>>>        Get_Attribute DF_FIELD_NAME                  of hTable iColumn to sFieldNameTo
87667>>>>>>>        Get _UtilTableIsSql hTable to bIsSqlTable
87668>>>>>>>        If (bIsSqlTable = False) Begin
87670>>>>>>>            Get_Attribute DF_FIELD_TYPE              of hTable iColumn to iTypeTo
87673>>>>>>>        End
87673>>>>>>>>
87673>>>>>>>        Else Begin
87674>>>>>>>            Get_Attribute DF_FIELD_NATIVE_TYPE       of hTable iColumn to iTypeTo
87677>>>>>>>        End
87677>>>>>>>>
87677>>>>>>>        // Let the driver decide the other values;
87677>>>>>>>        Get_Attribute DF_FIELD_LENGTH                of hTable iColumn to iLengthTo
87680>>>>>>>        Get_Attribute DF_FIELD_PRECISION             of hTable iColumn to iPrecTo
87683>>>>>>>
87683>>>>>>>        If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo) Begin
87685>>>>>>>            Function_Return False
87686>>>>>>>        End
87686>>>>>>>>
87686>>>>>>>
87686>>>>>>>        Set Private.phCurrentTable to hTable
87687>>>>>>>        Set Private.piCurrentField to iColumn
87688>>>>>>>
87688>>>>>>>        Structure_Start hTable
87689>>>>>>>            Set_Attribute DF_FIELD_NAME              of hTable iColumn to sFieldNameFrom
87692>>>>>>>//            If (bIsSqlTable = False) Begin
87692>>>>>>>                Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iTypeFrom
87695>>>>>>>//            End
87695>>>>>>>//            Else Begin
87695>>>>>>>//                Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iTypeFrom
87695>>>>>>>//                Set_Attribute DF_FIELD_NATIVE_TYPE   of hTable iColumn to iTypeFrom
87695>>>>>>>//            End
87695>>>>>>>            Set_Attribute DF_FIELD_LENGTH            of hTable iColumn to (iLengthFrom + iPrecFrom)
87698>>>>>>>            Set_Attribute DF_FIELD_PRECISION         of hTable iColumn to iPrecFrom
87701>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87702>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87704>>>>>>>
87704>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87705>>>>>>>        Function_Return (Err = False)
87706>>>>>>>    End_Function
87707>>>>>>>
87707>>>>>>>    // Changes a field type, length and precision for the passed table number and field name
87707>>>>>>>    Function ApiColumnChangeByColumnNumber String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo String sFieldNameFrom Integer iColumn Integer iTypeFrom Integer iLengthFrom Integer iPrec Integer iOpt Returns Boolean
87709>>>>>>>        Integer iPrecFrom iTypeTo iLengthTo iPrecTo iDbType iOptionFrom iOptionTo iDataFlexType iIndex
87709>>>>>>>        Boolean bOK bCompareDate_DateTime bSkip bRecnumTable bIsSameDataType
87709>>>>>>>        String sFieldNameTo sDriverIDTo
87709>>>>>>>        tColumnType ColumnType
87709>>>>>>>        tColumnType ColumnType
87709>>>>>>>
87709>>>>>>>        Get pbCompareDate_DateTime to bCompareDate_DateTime
87710>>>>>>>        Get piDbType to iDbType
87711>>>>>>>        If (num_arguments > 4) Begin
87713>>>>>>>            Move iPrec to iPrecFrom
87714>>>>>>>            Move iOpt  to iOptionFrom
87715>>>>>>>        End
87715>>>>>>>>
87715>>>>>>>        If (iTypeFrom < -1490) Begin
87717>>>>>>>            Move (iTypeFrom + 1500) to iTypeFrom
87718>>>>>>>        End
87718>>>>>>>>
87718>>>>>>>
87718>>>>>>>        Get AutoConnectionIDLogin to bOK
87719>>>>>>>        Move False to Err
87720>>>>>>>        Close hTable
87721>>>>>>>        Get OpenTableExclusive hTable to bOK
87722>>>>>>>        If (bOK = False) Begin
87724>>>>>>>            Function_Return False
87725>>>>>>>        End
87725>>>>>>>>
87725>>>>>>>
87725>>>>>>>        Get_Attribute DF_FILE_DRIVER                of hTable         to sDriverIDTo
87728>>>>>>>        Get_Attribute DF_FILE_RECNUM_TABLE          of hTable         to bRecnumTable
87731>>>>>>>        Get UtilSQLColumnTypeToDataFlexType sDriverIDTo iDbType iTypeTo iLengthTo to iDataFlexType
87732>>>>>>>        If (iDataFlexType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
87734>>>>>>>            Move DF_DATE to iDataFlexType
87735>>>>>>>        End
87735>>>>>>>>
87735>>>>>>>        Get_Attribute DF_FIELD_NAME                 of hTable iColumn to sFieldNameTo
87738>>>>>>>
87738>>>>>>>        If (bIsSQLTableTo = True) Begin
87740>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE  of hTable iColumn to iTypeTo
87743>>>>>>>        End
87743>>>>>>>>
87743>>>>>>>        Else Begin
87744>>>>>>>            Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iTypeTo
87747>>>>>>>        End
87747>>>>>>>>
87747>>>>>>>
87747>>>>>>>        Get_Attribute DF_FIELD_LENGTH               of hTable iColumn to iLengthTo
87750>>>>>>>        Get_Attribute DF_FIELD_PRECISION            of hTable iColumn to iPrecTo
87753>>>>>>>            Get_Attribute DF_FIELD_IS_IDENTITY      of hTable iColumn to iOptionTo
87756>>>>>>>
87756>>>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
87756>>>>>>>        // data types between Embedded and SQL, else we can't compare the data types.
87756>>>>>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
87758>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iTypeTo
87759>>>>>>>            If (iTypeTo = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
87761>>>>>>>                Move DF_DATE to iTypeTo  
87762>>>>>>>            End
87762>>>>>>>>
87762>>>>>>>        End
87762>>>>>>>>
87762>>>>>>>        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
87765>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDTo   iDbType iTypeTo   iLengthTo   to iTypeFrom
87766>>>>>>>        End
87766>>>>>>>>
87766>>>>>>>        Move (iTypeFrom = iTypeTo) to bIsSameDataType
87767>>>>>>>
87767>>>>>>>        If (bCompareDate_DateTime = False) Begin
87769>>>>>>>            Move ((iTypeFrom = SQL_TYPE_DATE or iTypeFrom = SQL_TYPE_TIME or iTypeFrom = SQL_TYPE_TIMESTAMP) and (iTypeTo = SQL_TYPE_DATE or iTypeTo = SQL_TYPE_TIME or iTypeTo = SQL_TYPE_TIMESTAMP)) to bSkip
87770>>>>>>>            If (bSkip = True) Begin
87772>>>>>>>                If (sFieldNameFrom = sFieldNameTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
87774>>>>>>>                    Function_Return True
87775>>>>>>>                End
87775>>>>>>>>
87775>>>>>>>            End
87775>>>>>>>>
87775>>>>>>>        End
87775>>>>>>>>
87775>>>>>>>        Else If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
87778>>>>>>>            Function_Return True
87779>>>>>>>        End
87779>>>>>>>>
87779>>>>>>>
87779>>>>>>>        Set Private.phCurrentTable to hTable
87780>>>>>>>        Set Private.piCurrentField to iColumn
87781>>>>>>>
87781>>>>>>>        Structure_Start hTable
87782>>>>>>>            If (sFieldNameFrom <> sFieldNameTo) Begin
87784>>>>>>>                Set_Attribute DF_FIELD_NAME             of hTable iColumn to sFieldNameFrom
87787>>>>>>>            End
87787>>>>>>>>
87787>>>>>>>
87787>>>>>>>            If (bIsSameDataType = False) Begin
87789>>>>>>>                Set_Attribute DF_FIELD_TYPE             of hTable iColumn to iDataFlexType
87792>>>>>>>                If (bIsSQLTableTo = True) Begin
87794>>>>>>>                        Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to iTypeFrom
87797>>>>>>>                End
87797>>>>>>>>
87797>>>>>>>            End
87797>>>>>>>>
87797>>>>>>>
87797>>>>>>>            If (iLengthFrom <> iLengthTo) Begin
87799>>>>>>>                Set_Attribute DF_FIELD_LENGTH           of hTable iColumn to iLengthFrom
87802>>>>>>>            End
87802>>>>>>>>
87802>>>>>>>            If (iPrecFrom <> iPrecTo) Begin
87804>>>>>>>                Set_Attribute DF_FIELD_PRECISION        of hTable iColumn to iPrecFrom
87807>>>>>>>            End
87807>>>>>>>>
87807>>>>>>>
87807>>>>>>>            If (bIsSQLTableTo = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
87809>>>>>>>                // Can't set a recnum table to "DF_FIELD_IS_IDENTITY"
87809>>>>>>>                If (bRecnumTable = True) Begin
87811>>>>>>>                    Set_Attribute DF_FILE_RECNUM_TABLE  of hTable to False
87814>>>>>>>                End
87814>>>>>>>>
87814>>>>>>>
87814>>>>>>>                // We might need to create an index here.
87814>>>>>>>                // To be able to set the DF_FIELD_IS_IDENTITY the index must already exist, but it might not at this stage.
87814>>>>>>>                // This should probably fix that problem and if an adjustment is needed, it will get done with the normal
87814>>>>>>>                // index update checking logic.
87814>>>>>>>                Get_Attribute DF_FIELD_INDEX               of hTable iColumn to iIndex
87817>>>>>>>                If (iIndex = 0 and Uppercase(sFieldNameTo) <> "RECNUM") Begin
87819>>>>>>>                    Create_Index hTable At iIndex
87820>>>>>>>                    Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex   to 1
87823>>>>>>>                End
87823>>>>>>>>
87823>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD       of hTable iIndex 1 to iColumn
87826>>>>>>>                Set_Attribute DF_FILE_PRIMARY_INDEX        of hTable          to iIndex
87829>>>>>>>                    Set_Attribute DF_FIELD_IS_IDENTITY     of hTable iColumn  to True
87832>>>>>>>                If (bIsSQLTableTo = True) Begin
87834>>>>>>>                        Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex   to True
87837>>>>>>>                End
87837>>>>>>>>
87837>>>>>>>            End
87837>>>>>>>>
87837>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87838>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87840>>>>>>>
87840>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87841>>>>>>>        Function_Return (Err = False)
87842>>>>>>>    End_Function
87843>>>>>>>
87843>>>>>>>    Function ApiColumnChangeMainIndex Handle hTable Integer iIndex Integer iColumn Returns Boolean
87845>>>>>>>        Boolean bOK
87845>>>>>>>
87845>>>>>>>        Get AutoConnectionIDLogin to bOK
87846>>>>>>>        Move False to Err
87847>>>>>>>        Get OpenTableExclusive hTable to bOK
87848>>>>>>>        If (bOK = False) Begin
87850>>>>>>>            Function_Return False
87851>>>>>>>        End
87851>>>>>>>>
87851>>>>>>>
87851>>>>>>>        Structure_Start hTable
87852>>>>>>>            Set_Attribute DF_FIELD_INDEX of hTable iColumn to iIndex
87855>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87856>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87858>>>>>>>
87858>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87859>>>>>>>        Function_Return (Err = False)
87860>>>>>>>    End_Function
87861>>>>>>>
87861>>>>>>>    // To move an existing field to another position in a table.
87861>>>>>>>    Function ApiColumnMove Handle hTable Integer iOld Integer iNew Boolean bIsSQLType Integer iLength Integer iPrecision Returns Boolean
87863>>>>>>>        String sColumn sDriverID
87863>>>>>>>        Integer iType
87863>>>>>>>        Boolean bOK bIsDate
87863>>>>>>>
87863>>>>>>>        Close hTable
87864>>>>>>>        Get AutoConnectionIDLogin to bOK
87865>>>>>>>        Get OpenTableExclusive hTable to bOK
87866>>>>>>>        If (bOK = False) Begin
87868>>>>>>>            Function_Return False
87869>>>>>>>        End
87869>>>>>>>>
87869>>>>>>>
87869>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
87872>>>>>>>        If (sDriverID = DFBTRDRV_ID) Begin
87874>>>>>>>            Error DFERR_PROGRAM "Function 'ColumnMove' is not supported for the Pervasive database."
87875>>>>>>>>
87875>>>>>>>            Function_Return False
87876>>>>>>>        End
87876>>>>>>>>
87876>>>>>>>
87876>>>>>>>        Get_Attribute DF_FIELD_NAME of hTable iOld to sColumn
87879>>>>>>>        Get_Attribute DF_FIELD_TYPE of hTable iOld to iType
87882>>>>>>>        Get UtilColumnIsDateType iType bIsSQLType  to bIsDate
87883>>>>>>>
87883>>>>>>>        Set Private.phCurrentTable to hTable
87884>>>>>>>        Set Private.piCurrentField to iOld
87885>>>>>>>
87885>>>>>>>//        If (bIsDate = False) Begin
87885>>>>>>>//            Get_Attribute DF_FIELD_LENGTH    of hTable iOld to iLength
87885>>>>>>>//            Get_Attribute DF_FIELD_PRECISION of hTable iOld to iPrecision
87885>>>>>>>//        End
87885>>>>>>>//        Else Begin
87885>>>>>>>//            Move 6 to iLength
87885>>>>>>>//            Move 0 to iPrecision
87885>>>>>>>//        End
87885>>>>>>>
87885>>>>>>>        Move False to Err
87886>>>>>>>
87886>>>>>>>        Structure_Start hTable
87887>>>>>>>            Delete_Field hTable iOld
87888>>>>>>>            Create_Field hTable At iNew
87889>>>>>>>            Set_Attribute DF_FIELD_OLD_NUMBER of hTable iNew to iOld
87892>>>>>>>
87892>>>>>>>            Set_Attribute DF_FIELD_NAME of hTable iNew to sColumn
87895>>>>>>>            If (bIsSQLType = False) Begin
87897>>>>>>>                Set_Attribute DF_FIELD_TYPE of hTable iNew to iType
87900>>>>>>>            End
87900>>>>>>>>
87900>>>>>>>            Else Begin
87901>>>>>>>                Set_Attribute DF_FIELD_TYPE of hTable iNew to iType
87904>>>>>>>//                Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iNew to iSQLType
87904>>>>>>>            End
87904>>>>>>>>
87904>>>>>>>
87904>>>>>>>            If (bIsDate = False) Begin
87906>>>>>>>                Set_Attribute DF_FIELD_LENGTH    of hTable iNew to iLength
87909>>>>>>>                Set_Attribute DF_FIELD_PRECISION of hTable iNew to iPrecision
87912>>>>>>>            End
87912>>>>>>>>
87912>>>>>>>
87912>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87913>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87915>>>>>>>
87915>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87916>>>>>>>        Function_Return (Err = False)
87917>>>>>>>    End_Function
87918>>>>>>>
87918>>>>>>>    // Deletes a column name for the passed table number (and column number).
87918>>>>>>>    Function ApiColumnRemove Handle hTable String sFieldName Returns Boolean
87920>>>>>>>        Integer iColumn
87920>>>>>>>        Boolean bOK
87920>>>>>>>
87920>>>>>>>        Get AutoConnectionIDLogin to bOK
87921>>>>>>>        Move False to Err
87922>>>>>>>        Close hTable
87923>>>>>>>        Get OpenTableExclusive hTable to bOK
87924>>>>>>>        If (bOK = False) Begin
87926>>>>>>>            Function_Return False
87927>>>>>>>        End
87927>>>>>>>>
87927>>>>>>>
87927>>>>>>>        If (not(Err)) Begin
87929>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87930>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87931>>>>>>>            Field_Map hTable sFieldName to iColumn
87933>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
87934>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87935>>>>>>>            If (iColumn = 0) Begin
87937>>>>>>>                Move 0 to LastErr
87938>>>>>>>                Function_Return False
87939>>>>>>>            End
87939>>>>>>>>
87939>>>>>>>            Move False to Err
87940>>>>>>>
87940>>>>>>>            Set Private.phCurrentTable to hTable
87941>>>>>>>            Set Private.piCurrentField to iColumn
87942>>>>>>>
87942>>>>>>>            Structure_Start hTable
87943>>>>>>>                Delete_Field hTable iColumn
87944>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
87945>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87947>>>>>>>            Set Action_Text of ghoStatusPanel to ""
87948>>>>>>>        End
87948>>>>>>>>
87948>>>>>>>        Else Begin
87949>>>>>>>            Error DFERR_PROGRAM ("The table number:" * String(hTable) * "could not be opened exclusiv. This indicates the table is in use!")
87950>>>>>>>>
87950>>>>>>>        End
87950>>>>>>>>
87950>>>>>>>
87950>>>>>>>        Function_Return (Err = False)
87951>>>>>>>    End_Function
87952>>>>>>>
87952>>>>>>>    // Renames a field for the passed table number & old field name & new field name
87952>>>>>>>    // Returns True if no errors occured.
87952>>>>>>>    // Sample usage:
87952>>>>>>>    //   Get ColumnRename Quote.File_Number "ID#" "ID" to bOK
87952>>>>>>>    Function ApiColumnRename Integer hTable String sOldFieldName String sNewFieldName Returns Boolean
87954>>>>>>>        Integer iField
87954>>>>>>>        Boolean bOK bExists bIsOpen
87954>>>>>>>
87954>>>>>>>        Get UtilColumnExists hTable sNewFieldName to bExists
87955>>>>>>>        If (bExists = True) Begin
87957>>>>>>>            Function_Return False
87958>>>>>>>        End
87958>>>>>>>>
87958>>>>>>>
87958>>>>>>>        // Note: The Field_Map command does _not_ work if the table has been
87958>>>>>>>        //       opened exclusively, so we first open it in normal mode.
87958>>>>>>>        Close hTable
87959>>>>>>>        Open hTable
87961>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
87964>>>>>>>        If (bIsOpen = False) Begin
87966>>>>>>>            Function_Return False
87967>>>>>>>        End
87967>>>>>>>>
87967>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87968>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87969>>>>>>>        Field_Map hTable sOldFieldName to iField
87971>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87972>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
87973>>>>>>>
87973>>>>>>>        Get AutoConnectionIDLogin to bOK
87974>>>>>>>        Get OpenTableExclusive hTable to bOK
87975>>>>>>>        If (bOK = False) Begin
87977>>>>>>>            Function_Return False
87978>>>>>>>        End
87978>>>>>>>>
87978>>>>>>>
87978>>>>>>>        Move False to Err
87979>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
87980>>>>>>>        Set Private.phCurrentTable to hTable
87981>>>>>>>        Set Private.piCurrentField to iField
87982>>>>>>>
87982>>>>>>>        If (iField > 0) Begin
87984>>>>>>>            Structure_Start hTable
87985>>>>>>>                Set_Attribute DF_FIELD_NAME of hTable iField to sNewFieldName
87988>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
87989>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87991>>>>>>>        End
87991>>>>>>>>
87991>>>>>>>        Else Begin
87992>>>>>>>            Move 0 to LastErr
87993>>>>>>>            Move False to Err
87994>>>>>>>        End
87994>>>>>>>>
87994>>>>>>>
87994>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87995>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
87996>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
87997>>>>>>>
87997>>>>>>>        Function_Return (Err = False)
87998>>>>>>>    End_Function
87999>>>>>>>
87999>>>>>>>    Function UtilColumnsCheckForInserts Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
88001>>>>>>>        tAPIColumnCompare[] aAPIColumnsToInsert
88001>>>>>>>        tAPIColumnCompare[] aAPIColumnsToInsert
88002>>>>>>>        Integer iSize iCount iItem iFieldTo iNumberOfFieldsTo iColumnNumber
88002>>>>>>>        Boolean bRenameField
88002>>>>>>>
88002>>>>>>>        Open hTable
88004>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88005>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88006>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
88007>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumberOfFieldsTo
88010>>>>>>>        Move (iSize max iNumberOfFieldsTo) to iSize
88011>>>>>>>        Decrement iSize
88012>>>>>>>        for iCount from 0 to iSize
88018>>>>>>>>
88018>>>>>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
88020>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88021>>>>>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88022>>>>>>>
88022>>>>>>>                Field_Map hTable aAPIColumnCompare[iCount].sFieldNameFrom to iFieldTo
88024>>>>>>>                If (aAPIColumnCompare[iCount].bExistsFrom = True and iFieldTo = 0) Begin
88026>>>>>>>                    Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iColumnNumber
88027>>>>>>>                    Get UtilColumnShouldBeRenamed aAPIColumnCompare[iCount]      to bRenameField
88028>>>>>>>                    If (iColumnNumber = -1 and bRenameField = False) Begin
88030>>>>>>>                        Move aAPIColumnCompare[iCount].iFieldNumber     to aAPIColumnsToInsert[iItem].iFieldNumber
88031>>>>>>>                        Move aAPIColumnCompare[iCount].sFieldNameFrom   to aAPIColumnsToInsert[iItem].sFieldNameFrom
88032>>>>>>>                        Move aAPIColumnCompare[iCount].iTypeFrom        to aAPIColumnsToInsert[iItem].iTypeFrom
88033>>>>>>>                        Move aAPIColumnCompare[iCount].sTypeFrom        to aAPIColumnsToInsert[iItem].sTypeFrom
88034>>>>>>>                        Move aAPIColumnCompare[iCount].iLengthFrom      to aAPIColumnsToInsert[iItem].iLengthFrom
88035>>>>>>>                        Move aAPIColumnCompare[iCount].iPrecisionFrom   to aAPIColumnsToInsert[iItem].iPrecisionFrom
88036>>>>>>>                        Move aAPIColumnCompare[iCount].bIsSQLTypeFrom   to aAPIColumnsToInsert[iItem].bIsSQLTypeFrom
88037>>>>>>>                        Move aAPIColumnCompare[iCount].bIsSQLTypeTo     to aAPIColumnsToInsert[iItem].bIsSQLTypeTo
88038>>>>>>>                        Move True                                       to aAPIColumnsToInsert[iItem].bExistsFrom
88039>>>>>>>                        Move False                                      to aAPIColumnsToInsert[iItem].bExistsTo
88040>>>>>>>                        Increment iItem
88041>>>>>>>                    End
88041>>>>>>>>
88041>>>>>>>                End
88041>>>>>>>>
88041>>>>>>>            End
88041>>>>>>>>
88041>>>>>>>        Loop
88042>>>>>>>>
88042>>>>>>>
88042>>>>>>>        Move False to Err
88043>>>>>>>        Move 0 to LastErr
88044>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88045>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
88046>>>>>>>        Function_Return aAPIColumnsToInsert
88047>>>>>>>    End_Function
88048>>>>>>>
88048>>>>>>>    Function UtilColumnsInsert String sDriverIDFrom Handle hTable tAPIColumnCompare[] aAPIColumnsToInsert Returns Boolean
88050>>>>>>>        Integer iSize iCount
88050>>>>>>>        Boolean bOK
88050>>>>>>>        tAPIColumn[] aColumnsTo
88050>>>>>>>        tAPIColumn[] aColumnsTo
88051>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
88051>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
88052>>>>>>>
88052>>>>>>>        Move (SizeOfArray(aAPIColumnsToInsert)) to iSize
88053>>>>>>>        If (iSize = 0) Begin
88055>>>>>>>            Function_Return True
88056>>>>>>>        End
88056>>>>>>>>
88056>>>>>>>
88056>>>>>>>        Move False to Err
88057>>>>>>>        Decrement iSize
88058>>>>>>>        for iCount from 0 to iSize
88064>>>>>>>>
88064>>>>>>>            Get ApiColumnInsert sDriverIDFrom hTable aAPIColumnsToInsert[iCount].iFieldNumber aAPIColumnsToInsert[iCount].sFieldNameFrom aAPIColumnsToInsert[iCount].iTypeFrom aAPIColumnsToInsert[iCount].iLengthFrom aAPIColumnsToInsert[iCount].iPrecisionFrom aAPIColumnsToInsert[iCount].bIsSQLTypeFrom to bOK
88065>>>>>>>        Loop
88066>>>>>>>>
88066>>>>>>>
88066>>>>>>>        Function_Return bOK
88067>>>>>>>    End_Function
88068>>>>>>>
88068>>>>>>>    // Returns a struct array with fields that has the same names but different field numbers.
88068>>>>>>>    Function UtilColumnsCheckForMoves Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
88070>>>>>>>        tAPIColumnCompare[] aAPIColumnsToMove
88070>>>>>>>        tAPIColumnCompare[] aAPIColumnsToMove
88071>>>>>>>        Integer iSize iCount iItem iShouldMove
88071>>>>>>>
88071>>>>>>>        Move 0 to iItem
88072>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
88073>>>>>>>        Decrement iSize
88074>>>>>>>        for iCount from 0 to iSize
88080>>>>>>>>
88080>>>>>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
88082>>>>>>>                Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iShouldMove
88083>>>>>>>                If (iShouldMove <> -1) Begin
88085>>>>>>>                    Move aAPIColumnCompare[iCount] to aAPIColumnsToMove[iItem]
88086>>>>>>>                    Move iShouldMove               to aAPIColumnsToMove[iItem].iFieldNumberTo
88087>>>>>>>                    Move aAPIColumnCompare[iShouldMove - 1].sFieldNameTo to aAPIColumnsToMove[iItem].sFieldNameTo
88088>>>>>>>                    Increment iItem
88089>>>>>>>                End
88089>>>>>>>>
88089>>>>>>>            End
88089>>>>>>>>
88089>>>>>>>        Loop
88090>>>>>>>>
88090>>>>>>>
88090>>>>>>>        Move False to Err
88091>>>>>>>        Move 0 to LastErr
88092>>>>>>>        Function_Return aAPIColumnsToMove
88093>>>>>>>    End_Function
88094>>>>>>>
88094>>>>>>>    Function UtilColumnsMove Handle hTable tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo tAPIColumnCompare[] aAPIColumnsToMove Returns Boolean
88096>>>>>>>        Integer iSize iCount
88096>>>>>>>        Boolean bOK
88096>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
88096>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
88097>>>>>>>
88097>>>>>>>        Move (SizeOfArray(aAPIColumnsToMove)) to iSize
88098>>>>>>>        If (iSize = 0) Begin
88100>>>>>>>            Function_Return True
88101>>>>>>>        End
88101>>>>>>>>
88101>>>>>>>
88101>>>>>>>        Move False to Err
88102>>>>>>>        Decrement iSize
88103>>>>>>>        for iCount from 0 to iSize
88109>>>>>>>>
88109>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88110>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
88111>>>>>>>            If (aAPIColumnsToMove[iCount].bExistsFrom = True and aAPIColumnsToMove[iCount].bExistsTo = True) Begin
88113>>>>>>>                Get ApiColumnMove hTable aAPIColumnsToMove[iCount].iFieldNumberTo aAPIColumnsToMove[iCount].iFieldNumber aAPIColumnsToMove[iCount].bIsSQLTypeFrom aAPIColumnsToMove[iCount].iLengthFrom aAPIColumnsToMove[iCount].iPrecisionFrom to bOK
88114>>>>>>>                Get UtilColumnsStructFill hTable to aColumnsTo
88115>>>>>>>                Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88116>>>>>>>                Get UtilColumnsCheckForMoves hTable aAPIColumnCompare to aAPIColumnsToMove
88117>>>>>>>                If (SizeOfArray(aAPIColumnsToMove)) Begin
88119>>>>>>>                    Move (SizeOfArray(aAPIColumnsToMove)) to iSize
88120>>>>>>>                    Decrement iSize
88121>>>>>>>                    Move 0 to iCount
88122>>>>>>>                End
88122>>>>>>>>
88122>>>>>>>            End
88122>>>>>>>>
88122>>>>>>>        Loop
88123>>>>>>>>
88123>>>>>>>
88123>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88124>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
88125>>>>>>>        If (LastErr = DFERR_ARRAY_INDEX_OUT_OF_BOUNDS) Begin
88127>>>>>>>            Move 0 to LastErr
88128>>>>>>>        End
88128>>>>>>>>
88128>>>>>>>        Function_Return bOK
88129>>>>>>>    End_Function
88130>>>>>>>
88130>>>>>>>    // Takes a tAPIColumnCompare struct as parameter and returns True if;
88130>>>>>>>    // - Field Numbers, Data Types, Lengths and Precisions are all equal.
88130>>>>>>>    // - The "FROM" field name is <> "TO" field name
88130>>>>>>>//    // - The "FROM" field name also exists in the "TO" table; or the "TO" is part
88130>>>>>>>//    //   of the "FROM" field name. E.g. "FROM" = LATEST_REPL_COST_DATE, "TO" = Latest_Repl_Cos would results in a TRUE.
88130>>>>>>>    Function UtilColumnShouldBeRenamed tAPIColumnCompare aAPIColumnCompare Returns Boolean
88132>>>>>>>        Boolean bShouldRename
88132>>>>>>>        String sFieldNameFrom sFieldNameTo
88132>>>>>>>
88132>>>>>>>        Move (Uppercase(aAPIColumnCompare.sFieldNameFrom)) to sFieldNameFrom
88133>>>>>>>        Move (Uppercase(aAPIColumnCompare.sFieldNameTo))   to sFieldNameTo
88134>>>>>>>        If (sFieldNameFrom = sFieldNameTo) Begin
88136>>>>>>>            Function_Return False
88137>>>>>>>        End
88137>>>>>>>>
88137>>>>>>>
88137>>>>>>>        Move (aAPIColumnCompare.bExistsFrom    = aAPIColumnCompare.bExistsTo      and ;              aAPIColumnCompare.iFieldNumber   = aAPIColumnCompare.iFieldNumberTo and ;              aAPIColumnCompare.iTypeFrom      = aAPIColumnCompare.iTypeTo        and ;              aAPIColumnCompare.iLengthFrom    = aAPIColumnCompare.iLengthTo      and ;              aAPIColumnCompare.iPrecisionFrom = aAPIColumnCompare.iPrecisionTo   and ;              aAPIColumnCompare.iOptionsFrom   = aAPIColumnCompare.iOptionsTo) to bShouldRename
88138>>>>>>>//        If (bShouldRename = False) Begin
88138>>>>>>>//            Function_Return False
88138>>>>>>>//        End
88138>>>>>>>//
88138>>>>>>>//        If (sFieldNameFrom contains sFieldNameTo) Begin
88138>>>>>>>//            Function_Return True
88138>>>>>>>//        End
88138>>>>>>>
88138>>>>>>>        Function_Return bShouldRename
88139>>>>>>>    End_Function
88140>>>>>>>
88140>>>>>>>    // Returns -1 if the passed iColumn number doesn't exist with the same name in the aAPIColumnCompare struct array.
88140>>>>>>>    // Else it returns the column/field number of the field that exists in another position.
88140>>>>>>>    Function UtilColumnExistsWithOtherNumber tAPIColumnCompare[] aAPIColumnCompare Integer iColumn Returns Integer
88142>>>>>>>        Integer iCount iSize iRetval
88142>>>>>>>        String sFieldNameFrom
88142>>>>>>>
88142>>>>>>>        Move -1 to iRetval
88143>>>>>>>        If (aAPIColumnCompare[iColumn].bExistsFrom = False or aAPIColumnCompare[iColumn].bExistsTo = False) Begin
88145>>>>>>>            Function_Return iRetval
88146>>>>>>>        End
88146>>>>>>>>
88146>>>>>>>
88146>>>>>>>        Move (Uppercase(aAPIColumnCompare[iColumn].sFieldNameFrom)) to sFieldNameFrom
88147>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
88148>>>>>>>        Decrement iSize
88149>>>>>>>        for iCount from 0 to iSize
88155>>>>>>>>
88155>>>>>>>            // We're only interested in fields other than the passed field/column number:
88155>>>>>>>            If (iCount <> iColumn) Begin
88157>>>>>>>                If (Uppercase(aAPIColumnCompare[iCount].sFieldNameTo) = sFieldNameFrom) Begin
88159>>>>>>>                    Move (iCount + 1) to iRetval
88160>>>>>>>                End
88160>>>>>>>>
88160>>>>>>>            End
88160>>>>>>>>
88160>>>>>>>        Loop
88161>>>>>>>>
88161>>>>>>>
88161>>>>>>>        Move 0 to LastErr
88162>>>>>>>        Function_Return iRetval
88163>>>>>>>    End_Function
88164>>>>>>>
88164>>>>>>>    Function UtilColumnsCheckForRenames Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
88166>>>>>>>        tAPIColumnCompare[] aAPIColumnsToRename
88166>>>>>>>        tAPIColumnCompare[] aAPIColumnsToRename
88167>>>>>>>        Integer iSize iCount iItem iFieldTo iShouldMove
88167>>>>>>>        Boolean bRenameField
88167>>>>>>>
88167>>>>>>>        Open hTable
88169>>>>>>>        Move 0 to iItem
88170>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
88171>>>>>>>        Decrement iSize
88172>>>>>>>        for iCount from 0 to iSize
88178>>>>>>>>
88178>>>>>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
88180>>>>>>>                // Check if the field exists in another position (other field number)
88180>>>>>>>                Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iShouldMove
88181>>>>>>>                Get UtilColumnShouldBeRenamed aAPIColumnCompare[iCount] to bRenameField
88182>>>>>>>                If (aAPIColumnCompare[iCount].bExistsFrom = True and iShouldMove = -1 and bRenameField = True) Begin
88184>>>>>>>                    Move aAPIColumnCompare[iCount].iFieldNumber     to aAPIColumnsToRename[iItem].iFieldNumber
88185>>>>>>>                    Move iFieldTo                                   to aAPIColumnsToRename[iItem].iFieldNumberTo
88186>>>>>>>                    Move aAPIColumnCompare[iCount].sFieldNameFrom   to aAPIColumnsToRename[iItem].sFieldNameFrom
88187>>>>>>>                    Move aAPIColumnCompare[iCount].sFieldNameTo     to aAPIColumnsToRename[iItem].sFieldNameTo
88188>>>>>>>                    Increment iItem
88189>>>>>>>                End
88189>>>>>>>>
88189>>>>>>>            End
88189>>>>>>>>
88189>>>>>>>        Loop
88190>>>>>>>>
88190>>>>>>>
88190>>>>>>>        Move False to Err
88191>>>>>>>        Move 0 to LastErr
88192>>>>>>>        Function_Return aAPIColumnsToRename
88193>>>>>>>    End_Function
88194>>>>>>>
88194>>>>>>>    Function UtilColumnsRename Handle hTable tAPIColumnCompare[] aAPIColumnsToRename Returns Boolean
88196>>>>>>>        Integer iSize iCount
88196>>>>>>>        Boolean bOK
88196>>>>>>>        tAPIColumn[] aColumnsTo
88196>>>>>>>        tAPIColumn[] aColumnsTo
88197>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
88197>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
88198>>>>>>>
88198>>>>>>>        Move (SizeOfArray(aAPIColumnsToRename)) to iSize
88199>>>>>>>        If (iSize = 0) Begin
88201>>>>>>>            Function_Return True
88202>>>>>>>        End
88202>>>>>>>>
88202>>>>>>>
88202>>>>>>>        Move False to Err
88203>>>>>>>        Decrement iSize
88204>>>>>>>        For iCount from 0 to iSize
88210>>>>>>>>
88210>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88211>>>>>>>            Get ApiColumnRename hTable aAPIColumnsToRename[iCount].sFieldNameTo aAPIColumnsToRename[iCount].sFieldNameFrom to bOK
88212>>>>>>>        Loop
88213>>>>>>>>
88213>>>>>>>
88213>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88214>>>>>>>        Function_Return bOK
88215>>>>>>>    End_Function
88216>>>>>>>
88216>>>>>>>    Function UtilColumnIsDateType Integer iType Boolean bIsSQLTableTo Returns Boolean
88218>>>>>>>        Boolean bDateType
88218>>>>>>>
88218>>>>>>>        If (bIsSQLTableTo = True) Begin
88220>>>>>>>            Move (iType = SQL_TYPE_DATE or iType = SQL_TYPE_TIMESTAMP or iType = SQL_TYPE_TIMESTAMP2) to bDateType
88221>>>>>>>        End
88221>>>>>>>>
88221>>>>>>>        Else Begin
88222>>>>>>>            Move (iType = DF_DATE or iType = DF_DATETIME) to bDateType
88223>>>>>>>        End
88223>>>>>>>>
88223>>>>>>>
88223>>>>>>>        Function_Return bDateType
88224>>>>>>>    End_Function
88225>>>>>>>
88225>>>>>>>    Function ApiColumnsUpdate String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo Boolean bCompareDate_DateTime Returns Boolean
88227>>>>>>>        Integer iCount iColumns iColumn iTypeFrom iTypeTo iDataFlexType iIndex iLengthFrom iLengthTo iPrecisionFrom iPrecisionTo iOptionFrom iOptionTo iDbType
88227>>>>>>>        Integer iCount2 iColumn2
88227>>>>>>>        Handle hFile
88227>>>>>>>        Boolean bFieldExistsFrom bFieldExistsTo bIsSQLDriver bIsSame bOK bSkip
88227>>>>>>>        Boolean bRecnum bIsSQLTableTo bRecnumTable bIsOpen bSkipTypeChange bIsDateType
88227>>>>>>>        String sFieldNameFrom sFieldNameTo sDriverIDTo sDefaultValue
88227>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare aApiInsertColumns aAPIMoveColumns aAPIRenameColumns aAPIRemoveColumns
88227>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare aApiInsertColumns aAPIMoveColumns aAPIRenameColumns aAPIRemoveColumns
88232>>>>>>>        tColumnType ColumnType
88232>>>>>>>        tColumnType ColumnType
88232>>>>>>>
88232>>>>>>>        Move False to Err
88233>>>>>>>        Close hTable
88234>>>>>>>        Get OpenTableExclusive hTable to bIsOpen
88235>>>>>>>        If (bIsOpen = False) Begin
88237>>>>>>>            Error DFERR_PROGRAM ("Function 'ApiColumnsUpdate'. Can't open table number:" * String(hTable))
88238>>>>>>>>
88238>>>>>>>            Function_Return False
88239>>>>>>>        End 
88239>>>>>>>>
88239>>>>>>>        
88239>>>>>>>        Get piDbType to iDbType
88240>>>>>>>        Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
88243>>>>>>>        Move bIsSQLTableFrom to bIsSQLDriver
88244>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTableTo
88245>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverIDTo
88248>>>>>>>
88248>>>>>>>        Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88249>>>>>>>
88249>>>>>>>        // Before we start to change the table we need to do three things;
88249>>>>>>>        // 1) Insert any new fields
88249>>>>>>>        Get UtilColumnsCheckForInserts hTable aAPIColumnCompare to aApiInsertColumns
88250>>>>>>>        If (SizeOfArray(aApiInsertColumns)) Begin
88252>>>>>>>            Get UtilColumnsInsert sDriverIDFrom hTable aApiInsertColumns to bOK
88253>>>>>>>            If (bOK = False) Begin
88255>>>>>>>                Function_Return False
88256>>>>>>>            End
88256>>>>>>>>
88256>>>>>>>            // Update info with changes made.
88256>>>>>>>            Get UtilColumnsStructFill hTable to aColumnsTo
88257>>>>>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88258>>>>>>>        End
88258>>>>>>>>
88258>>>>>>>
88258>>>>>>>        // 2) Move fields with same names
88258>>>>>>>        Get UtilColumnsCheckForMoves hTable aAPIColumnCompare to aAPIMoveColumns
88259>>>>>>>        If (SizeOfArray(aAPIMoveColumns)) Begin
88261>>>>>>>            Get UtilColumnsMove hTable aColumnsFrom aColumnsTo aAPIMoveColumns to bOK
88262>>>>>>>            If (bOK = False) Begin
88264>>>>>>>                Function_Return False
88265>>>>>>>            End
88265>>>>>>>>
88265>>>>>>>            Get UtilColumnsStructFill hTable to aColumnsTo
88266>>>>>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88267>>>>>>>        End
88267>>>>>>>>
88267>>>>>>>        
88267>>>>>>>        // 3) Rename fields
88267>>>>>>>        Get UtilColumnsCheckForRenames hTable aAPIColumnCompare to aAPIRenameColumns
88268>>>>>>>        If (SizeOfArray(aAPIRenameColumns)) Begin
88270>>>>>>>            Get UtilColumnsRename hTable aAPIRenameColumns to bOK
88271>>>>>>>            If (bOK = False) Begin
88273>>>>>>>                Function_Return False
88274>>>>>>>            End
88274>>>>>>>>
88274>>>>>>>            Get UtilColumnsStructFill hTable to aColumnsTo
88275>>>>>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88276>>>>>>>        End
88276>>>>>>>>
88276>>>>>>>
88276>>>>>>>        // 4) Remove fields if more fields currently exists compared to the new table definition.
88276>>>>>>>//        Get utilColumnsCheckForRemoves hTable aAPIColumnCompare to aAPIRemoveColumns
88276>>>>>>>//        If (SizeOfArray(aAPIRemoveColumns)) Begin
88276>>>>>>>//            Get UtilColumnsRemove hTable aAPIRemoveColumns to bOK
88276>>>>>>>//            If (bOK = False) Begin
88276>>>>>>>//                Function_Return False
88276>>>>>>>//            End
88276>>>>>>>//            Get UtilColumnsStructFill hTable to aColumnsTo
88276>>>>>>>//            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88276>>>>>>>//        End
88276>>>>>>>
88276>>>>>>>        // If any of the fields were changed by "Insert", "Rename" or "Move", we need to compare the fields again:
88276>>>>>>>        If (SizeOfArray(aApiInsertColumns) or SizeOfArray(aAPIRenameColumns) or SizeOfArray(aAPIMoveColumns)) Begin
88278>>>>>>>            Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom bIsSQLTableTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
88279>>>>>>>            If (bIsSame = True) Begin
88281>>>>>>>                Function_Return True
88282>>>>>>>            End
88282>>>>>>>>
88282>>>>>>>        End
88282>>>>>>>>
88282>>>>>>>
88282>>>>>>>        // We can now continue to make standard field changes:
88282>>>>>>>        Get OpenTableExclusive hTable to bIsOpen
88283>>>>>>>        Set Private.phCurrentTable to hTable
88284>>>>>>>        Move hTable to hFile
88285>>>>>>>        Structure_Start hFile sDriverIDTo
88286>>>>>>>
88286>>>>>>>            Move (SizeOfArray(aAPIColumnCompare)) to iColumns
88287>>>>>>>            Decrement iColumns
88288>>>>>>>            for iCount from 0 to iColumns
88294>>>>>>>>
88294>>>>>>>                Send DoAdvance of ghoProgressBar
88295>>>>>>>
88295>>>>>>>                Move aAPIColumnCompare[iCount].iFieldNumber to iColumn
88296>>>>>>>                Set Private.piCurrentField                  to iColumn
88297>>>>>>>                Get UtilColumnCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom aAPIColumnCompare[iCount].bIsSQLTypeTo aAPIColumnCompare[iCount] bCompareDate_DateTime to bIsSame
88298>>>>>>>                If (bIsSame = False) Begin
88300>>>>>>>
88300>>>>>>>                    Move aAPIColumnCompare[iCount].bExistsFrom          to bFieldExistsFrom
88301>>>>>>>                    If (bFieldExistsFrom = True) Begin
88303>>>>>>>                        Move aAPIColumnCompare[iCount].bExistsTo        to bFieldExistsTo
88304>>>>>>>                        Move aAPIColumnCompare[iCount].sFieldNameFrom   to sFieldNameFrom
88305>>>>>>>                        Move aAPIColumnCompare[iCount].iLengthFrom      to iLengthFrom
88306>>>>>>>                        Move aAPIColumnCompare[iCount].iPrecisionFrom   to iPrecisionFrom
88307>>>>>>>                        Move aAPIColumnCompare[iCount].iOptionsFrom     to iOptionFrom
88308>>>>>>>
88308>>>>>>>                        Move aAPIColumnCompare[iCount].iTypeFrom        to iTypeFrom
88309>>>>>>>                        Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iDataFlexType
88310>>>>>>>                        If (iTypeFrom < -1490) Begin
88312>>>>>>>                            Move (iTypeFrom + 1500)                     to iTypeFrom
88313>>>>>>>                        End
88313>>>>>>>>
88313>>>>>>>
88313>>>>>>>                        // If one of the two tables are SQL and the other Embedded we need to "translate"
88313>>>>>>>                        // data types between Embedded and SQL, else we can't compare the data types.
88313>>>>>>>                        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
88315>>>>>>>                            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iTypeFrom
88316>>>>>>>                            If (iTypeFrom = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
88318>>>>>>>                                Move DF_DATE to iTypeFrom
88319>>>>>>>                            End
88319>>>>>>>>
88319>>>>>>>                        End
88319>>>>>>>>
88319>>>>>>>                        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
88322>>>>>>>                            Get UtilSqlColumnTypeToDataFlexType sDriverIDTo   iDbType iTypeTo   iLengthTo   to iTypeTo
88323>>>>>>>                        End
88323>>>>>>>>
88323>>>>>>>
88323>>>>>>>                        Move aAPIColumnCompare[iCount].sFieldNameTo to sFieldNameTo
88324>>>>>>>                        Move aAPIColumnCompare[iCount].iLengthTo    to iLengthTo
88325>>>>>>>                        Move aAPIColumnCompare[iCount].iPrecisionTo to iPrecisionTo
88326>>>>>>>                        Move aAPIColumnCompare[iCount].iOptionsTo   to iOptionTo
88327>>>>>>>                        Move aAPIColumnCompare[iCount].iTypeTo      to iTypeTo
88328>>>>>>>
88328>>>>>>>                        Move False to bSkipTypeChange
88329>>>>>>>                        If (bCompareDate_DateTime = False) Begin
88331>>>>>>>                            Move ((iTypeFrom = SQL_TYPE_DATE or iTypeFrom = SQL_TYPE_TIME or iTypeFrom = SQL_TYPE_TIMESTAMP) and (iTypeTo = SQL_TYPE_DATE or iTypeTo = SQL_TYPE_TIME or iTypeTo = SQL_TYPE_TIMESTAMP)) to bSkipTypeChange
88332>>>>>>>                        End
88332>>>>>>>>
88332>>>>>>>
88332>>>>>>>                        If (bFieldExistsTo = False) Begin
88334>>>>>>>                            Move 0 to iColumn
88335>>>>>>>                            Create_Field hFile At iColumn
88336>>>>>>>                            Set Private.piCurrentField to iColumn
88337>>>>>>>                        End
88337>>>>>>>>
88337>>>>>>>
88337>>>>>>>                        If (sFieldNameFrom <> sFieldNameTo) Begin
88339>>>>>>>                            Set_Attribute DF_FIELD_NAME of hFile iColumn to sFieldNameFrom
88342>>>>>>>                        End
88342>>>>>>>>
88342>>>>>>>
88342>>>>>>>                        If (bIsSQLTableFrom = True and bIsSQLTableTo = True and aAPIColumnCompare[iCount].iOptionsFrom <> C_tAPIColumn_Identity) Begin
88344>>>>>>>                            Set_Attribute DF_FIELD_NULL_ALLOWED  of hFile iColumn to aAPIColumnCompare[iCount].bAllowNULLFrom
88347>>>>>>>                            Move aAPIColumnCompare[iCount].sDefaultValueFrom to sDefaultValue
88348>>>>>>>                            If (iDataFlexType = DF_BCD and Left(String(sDefaultValue), 1) <> "[") Begin
88350>>>>>>>                                Move ("[" + String(sDefaultValue) + "]") to sDefaultValue
88351>>>>>>>                            End
88351>>>>>>>>
88351>>>>>>>                            Set_Attribute DF_FIELD_DEFAULT_VALUE of hFile iColumn to sDefaultValue
88354>>>>>>>                        End
88354>>>>>>>>
88354>>>>>>>
88354>>>>>>>                        If (bSkipTypeChange = False) Begin
88356>>>>>>>                            If (iTypeFrom <> iTypeTo) Begin
88358>>>>>>>                                If (bIsSQLTableTo = True) Begin
88360>>>>>>>                                    Set_Attribute DF_FIELD_NATIVE_TYPE of hFile iColumn to iTypeFrom
88363>>>>>>>                                End
88363>>>>>>>>
88363>>>>>>>                                Else Begin                                                   
88364>>>>>>>                                    If (iDataFlexType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
88366>>>>>>>                                        Move DF_DATE to iDataFlexType  // Date
88367>>>>>>>                                    End
88367>>>>>>>>
88367>>>>>>>                                    Set_Attribute DF_FIELD_TYPE of hFile iColumn to iDataFlexType
88370>>>>>>>                                End
88370>>>>>>>>
88370>>>>>>>                            End
88370>>>>>>>>
88370>>>>>>>                        End
88370>>>>>>>>
88370>>>>>>>
88370>>>>>>>                        Get UtilColumnIsDateType iTypeFrom bIsSQLTableTo to bIsDateType
88371>>>>>>>                        // We can't set the length or precision for Date type columns (they are fixed).
88371>>>>>>>                        If (bIsDateType = False) Begin
88373>>>>>>>                            If (iLengthFrom <> iLengthTo) Begin
88375>>>>>>>                                Set_Attribute DF_FIELD_LENGTH of hFile iColumn to iLengthFrom
88378>>>>>>>                            End
88378>>>>>>>>
88378>>>>>>>                            If (iPrecisionFrom <> iPrecisionTo) Begin
88380>>>>>>>                                Set_Attribute DF_FIELD_PRECISION of hFile iColumn to iPrecisionFrom
88383>>>>>>>                            End
88383>>>>>>>>
88383>>>>>>>                        End
88383>>>>>>>>
88383>>>>>>>
88383>>>>>>>                        If (bIsSQLTableTo = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
88385>>>>>>>                            // Can't set a recnum table to "DF_FIELD_IS_IDENTITY"
88385>>>>>>>                            If (bRecnumTable = True) Begin
88387>>>>>>>                                Set_Attribute DF_FILE_RECNUM_TABLE of hTable to False
88390>>>>>>>                            End
88390>>>>>>>>
88390>>>>>>>
88390>>>>>>>                            // We might need to create an index here.
88390>>>>>>>                            // To be able to set the DF_FIELD_IS_IDENTITY the index must already exist, but it might not at this stage.
88390>>>>>>>                            // This should probably fix that problem and if an adjustment is needed, it will get done with the normal
88390>>>>>>>                            // index update checking logic.
88390>>>>>>>                            Get_Attribute DF_FIELD_INDEX           of hFile iColumn to iIndex
88393>>>>>>>                            If (iIndex = 0 and Uppercase(sFieldNameTo) <> "RECNUM") Begin
88395>>>>>>>                                Create_Index hFile at iIndex
88396>>>>>>>                                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hFile iIndex to 1
88399>>>>>>>                            End
88399>>>>>>>>
88399>>>>>>>
88399>>>>>>>                            Set_Attribute DF_INDEX_SEGMENT_FIELD   of hFile iIndex 1 to iColumn
88402>>>>>>>                            Set_Attribute DF_FILE_PRIMARY_INDEX    of hFile          to iIndex
88405>>>>>>>                                // Note: The order here is crucial!
88405>>>>>>>                                Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hFile iIndex to True
88408>>>>>>>                                Set_Attribute DF_FIELD_IS_IDENTITY of hFile iColumn    to True
88411>>>>>>>                        End
88411>>>>>>>>
88411>>>>>>>                    End
88411>>>>>>>>
88411>>>>>>>                    Else Begin
88412>>>>>>>                        Delete_Field hFile iColumn
88413>>>>>>>                        Move (RemoveFromArray(aColumnsTo, iCount)) to aColumnsTo
88414>>>>>>>                        Move (SizeOfArray(aColumnsTo)) to iCount2
88415>>>>>>>                        Decrement iCount2
88416>>>>>>>                        // We need to adjust FieldNumbers in the array with one, as we just deleted a field,
88416>>>>>>>                        // starting with the array number we just deleted the field for.
88416>>>>>>>                        for iColumn2 from iCount to iCount2
88422>>>>>>>>
88422>>>>>>>                            Move (aColumnsTo[iColumn2].iFieldNumber - 1) to aColumnsTo[iColumn2].iFieldNumber
88423>>>>>>>                        Loop
88424>>>>>>>>
88424>>>>>>>                        Decrement iCount
88425>>>>>>>                        Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88426>>>>>>>                        Move (SizeOfArray(aAPIColumnCompare)) to iColumns
88427>>>>>>>                        If (SizeOfArray(aColumnsFrom) = SizeOfArray(aColumnsTo)) Begin
88429>>>>>>>                            Move iColumns to iCount 
88430>>>>>>>                        End
88430>>>>>>>>
88430>>>>>>>                    End
88430>>>>>>>>
88430>>>>>>>                End
88430>>>>>>>>
88430>>>>>>>            Loop
88431>>>>>>>>
88431>>>>>>>
88431>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88432>>>>>>>        Structure_End hFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88434>>>>>>>
88434>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88435>>>>>>>        Function_Return (Err = False)
88436>>>>>>>    End_Function
88437>>>>>>>
88437>>>>>>>    // * Dummy function for the Studio's Code Explorer *
88437>>>>>>>    Function API_INDEX_FUNCTIONS Returns Boolean
88439>>>>>>>        Function_Return False
88440>>>>>>>    End_Function
88441>>>>>>>
88441>>>>>>>    // Get ApiIndexCreate Customers.File_Number 1 2 0 1 -1 -1 -1 -1 -1 -1 -1 -1 to bOK
88441>>>>>>>    // Note: the "-1" can be left out as this function is overloaded to make it easier to call.
88441>>>>>>>    // Note: This doesn't set Descending attributes - Use function IndexChangeDirection to do that.
88441>>>>>>>    Function ApiIndexCreate Handle hTable Integer iIndex Integer iSegments Integer iSgmnt1 Integer iSgmnt2 Integer iSgmnt3 Integer iSgmnt4 Integer iSgmnt5 Integer iSgmnt6 Integer iSgmnt7 Integer iSgmnt8 Integer iSgmnt9 Integer iSgmnt10 Returns Boolean
88443>>>>>>>        Integer iTableNo iSegment1 iSegment2 iSegment3 iSegment4 iSegment5 iSegment6 iSegment7 iSegment8 iSegment9 iSegment10  iIndexSegments
88443>>>>>>>        String sDriverID
88443>>>>>>>        Boolean bOK bExists bIsSQLTable
88443>>>>>>>
88443>>>>>>>        Get AutoConnectionIDLogin to bOK
88444>>>>>>>        Get OpenTableExclusive hTable to bOK
88445>>>>>>>        If (bOK = False) Begin
88447>>>>>>>            Function_Return False
88448>>>>>>>        End
88448>>>>>>>>
88448>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88451>>>>>>>
88451>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
88452>>>>>>>            If (bIsSQLTable = True) Begin
88454>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88457>>>>>>>            End
88457>>>>>>>>
88457>>>>>>>
88457>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iIndexSegments
88460>>>>>>>        Move (iIndexSegments > 0) to bExists
88461>>>>>>>        If (bExists = True) Begin
88463>>>>>>>            Function_Return True
88464>>>>>>>        End
88464>>>>>>>>
88464>>>>>>>
88464>>>>>>>        Move -1 to iSegment1
88465>>>>>>>        Move -1 to iSegment2
88466>>>>>>>        Move -1 to iSegment3
88467>>>>>>>        Move -1 to iSegment4
88468>>>>>>>        Move -1 to iSegment5
88469>>>>>>>        Move -1 to iSegment6
88470>>>>>>>        Move -1 to iSegment7
88471>>>>>>>        Move -1 to iSegment8
88472>>>>>>>        Move -1 to iSegment9
88473>>>>>>>        Move -1 to iSegment10
88474>>>>>>>
88474>>>>>>>        If (num_arguments > 3) Begin
88476>>>>>>>            Move iSgmnt1 to iSegment1
88477>>>>>>>        End
88477>>>>>>>>
88477>>>>>>>        If (num_arguments > 4) Begin
88479>>>>>>>            Move iSgmnt2 to iSegment2
88480>>>>>>>        End
88480>>>>>>>>
88480>>>>>>>        If (num_arguments > 5) Begin
88482>>>>>>>            Move iSgmnt3 to iSegment3
88483>>>>>>>        End
88483>>>>>>>>
88483>>>>>>>        If (num_arguments > 6) Begin
88485>>>>>>>            Move iSgmnt4 to iSegment4
88486>>>>>>>        End
88486>>>>>>>>
88486>>>>>>>        If (num_arguments > 7) Begin
88488>>>>>>>            Move iSgmnt5 to iSegment5
88489>>>>>>>        End
88489>>>>>>>>
88489>>>>>>>        If (num_arguments > 8) Begin
88491>>>>>>>            Move iSgmnt6 to iSegment6
88492>>>>>>>        End
88492>>>>>>>>
88492>>>>>>>        If (num_arguments > 9) Begin
88494>>>>>>>            Move iSgmnt7 to iSegment7
88495>>>>>>>        End
88495>>>>>>>>
88495>>>>>>>        If (num_arguments > 10) Begin
88497>>>>>>>            Move iSgmnt8 to iSegment8
88498>>>>>>>        End
88498>>>>>>>>
88498>>>>>>>        If (num_arguments > 11) Begin
88500>>>>>>>            Move iSgmnt9 to iSegment9
88501>>>>>>>        End
88501>>>>>>>>
88501>>>>>>>        If (num_arguments > 12) Begin
88503>>>>>>>            Move iSgmnt10 to iSegment10
88504>>>>>>>        End
88504>>>>>>>>
88504>>>>>>>
88504>>>>>>>        Move False to Err
88505>>>>>>>        Move hTable to iTableNo
88506>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88507>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
88508>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_NON_FATAL_RESTRUCTURE_ERROR
88509>>>>>>>
88509>>>>>>>        // We start by deleting the index, if it exists.
88509>>>>>>>        If (bExists = True) Begin
88511>>>>>>>            Structure_Start hTable sDriverID
88512>>>>>>>                Delete_Index iTableNo iIndex
88513>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
88514>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88516>>>>>>>        End
88516>>>>>>>>
88516>>>>>>>
88516>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88517>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
88518>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_NON_FATAL_RESTRUCTURE_ERROR
88519>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88520>>>>>>>        Move False to Err
88521>>>>>>>        Move 0 to LastErr
88522>>>>>>>
88522>>>>>>>        // Need to re-open if index deleted.
88522>>>>>>>        Move iTableNo to hTable
88523>>>>>>>        Get OpenTableExclusive hTable to bOK
88524>>>>>>>        If (bOK = False) Begin
88526>>>>>>>            Function_Return False
88527>>>>>>>        End
88527>>>>>>>>
88527>>>>>>>
88527>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88528>>>>>>>        Structure_Start hTable sDriverID
88529>>>>>>>            Create_Index hTable At iIndex
88530>>>>>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iSegments
88533>>>>>>>
88533>>>>>>>            If (iSgmnt1 <> -1) Begin
88535>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 1 to iSegment1
88538>>>>>>>            End
88538>>>>>>>>
88538>>>>>>>            If (iSegment2 <> -1) Begin
88540>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 2 to iSegment2
88543>>>>>>>            End
88543>>>>>>>>
88543>>>>>>>            If (iSegment3 <> -1) Begin
88545>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 3 to iSegment3
88548>>>>>>>            End
88548>>>>>>>>
88548>>>>>>>            If (iSegment4 <> -1) Begin
88550>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 4 to iSegment4
88553>>>>>>>            End
88553>>>>>>>>
88553>>>>>>>            If (iSegment5 <> -1) Begin
88555>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 5 to iSegment5
88558>>>>>>>            End
88558>>>>>>>>
88558>>>>>>>            If (iSegment6 <> -1) Begin
88560>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 6 to iSegment6
88563>>>>>>>            End
88563>>>>>>>>
88563>>>>>>>            If (iSegment7 <> -1) Begin
88565>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 7 to iSegment7
88568>>>>>>>            End
88568>>>>>>>>
88568>>>>>>>            If (iSegment8 <> -1) Begin
88570>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 8 to iSegment8
88573>>>>>>>            End
88573>>>>>>>>
88573>>>>>>>            If (iSegment9 <> -1) Begin
88575>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 9 to iSegment9
88578>>>>>>>            End
88578>>>>>>>>
88578>>>>>>>            If (iSegment10 <> -1) Begin
88580>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 10 to iSegment10
88583>>>>>>>            End
88583>>>>>>>>
88583>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88584>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88586>>>>>>>
88586>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88587>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88588>>>>>>>
88588>>>>>>>        Function_Return (Err = False)
88589>>>>>>>    End_Function
88590>>>>>>>
88590>>>>>>>    // Example:
88590>>>>>>>    // Get ApiIndexCreateEx hTable 1 (StrSplitToArray("1,5,6,7,8,2,3,4,10,9,11", ",")) to bOk
88590>>>>>>>    // Note: The StrSplitToArray function was introduced with DataFlex 18.2
88590>>>>>>>    Function ApiIndexCreateEx Handle hTable Integer iIndex Integer[] iSgmnts Returns Boolean
88592>>>>>>>        Integer iTableNo iNumSgmnt iNumSgmnts
88592>>>>>>>        String sDriverID
88592>>>>>>>        Boolean bOK bIsSQLTable
88592>>>>>>>
88592>>>>>>>        Get AutoConnectionIDLogin to bOK
88593>>>>>>>
88593>>>>>>>        Move False to Err
88594>>>>>>>        Move hTable to iTableNo
88595>>>>>>>        Get OpenTableExclusive hTable to bOK
88596>>>>>>>        If (bOK = False) Begin
88598>>>>>>>            Function_Return False
88599>>>>>>>        End
88599>>>>>>>>
88599>>>>>>>
88599>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88602>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
88603>>>>>>>            If (bIsSQLTable = True) Begin
88605>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88608>>>>>>>            End
88608>>>>>>>>
88608>>>>>>>
88608>>>>>>>        // We start by deleting the index
88608>>>>>>>        Structure_Start hTable sDriverID
88609>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88610>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
88611>>>>>>>            Delete_Index iTableNo iIndex
88612>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
88613>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
88614>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
88616>>>>>>>
88616>>>>>>>        Move False to Err
88617>>>>>>>        Move iTableNo to hTable
88618>>>>>>>        Get OpenTableExclusive hTable to bOK
88619>>>>>>>        If (bOK = False) Begin
88621>>>>>>>            Function_Return False
88622>>>>>>>        End
88622>>>>>>>>
88622>>>>>>>
88622>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88623>>>>>>>        Structure_Start hTable sDriverID
88624>>>>>>>            Move (SizeOfArray(iSgmnts)) to iNumSgmnts
88625>>>>>>>
88625>>>>>>>            Create_Index hTable at iIndex
88626>>>>>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSgmnts
88629>>>>>>>
88629>>>>>>>            for iNumSgmnt from 0 to (iNumSgmnts - 1)
88635>>>>>>>>
88635>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex (iNumSgmnt + 1) to iSgmnts[iNumSgmnt]
88638>>>>>>>            Loop
88639>>>>>>>>
88639>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
88641>>>>>>>
88641>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88642>>>>>>>
88642>>>>>>>        Function_Return (Err = False)
88643>>>>>>>    End_Function
88644>>>>>>>
88644>>>>>>>    Function APIIndexCreateByFieldNames Handle hTable tAPIIndex APIIndex tAPIIndex[] APIIndexTo tAPIIndexSegment[] aIndexSegments Returns Boolean
88646>>>>>>>        Integer iCount iSegmentsFrom iFieldFrom iSegmentsTo iSQLIndexType iTableNo
88646>>>>>>>        String sDriverID sSQLIndexName
88646>>>>>>>        Boolean bOK bIsSQLTable bIsOpen bIsSQLPrimaryKey bIsSQLClustered bIsSQLTemporaryIndex bExists
88646>>>>>>>
88646>>>>>>>        Move (SizeOfArray(aIndexSegments)) to iSegmentsFrom
88647>>>>>>>        If (iSegmentsFrom = 0) Begin
88649>>>>>>>            Function_Return False
88650>>>>>>>        End
88650>>>>>>>>
88650>>>>>>>
88650>>>>>>>        Get AutoConnectionIDLogin to bOK
88651>>>>>>>        Move False to Err
88652>>>>>>>        Get OpenTableExclusive hTable to bIsOpen
88653>>>>>>>        If (bIsOpen = False) Begin
88655>>>>>>>            Function_Return False
88656>>>>>>>        End
88656>>>>>>>>
88656>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88659>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTable
88660>>>>>>>            If (bIsSQLTable = True) Begin
88662>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88665>>>>>>>            End
88665>>>>>>>>
88665>>>>>>>
88665>>>>>>>        Move 0     to iSegmentsTo
88666>>>>>>>        Move 0     to iSQLIndexType
88667>>>>>>>        Move ""    to sSQLIndexName
88668>>>>>>>        Move False to bIsSQLTemporaryIndex
88669>>>>>>>        Move False to bIsSQLPrimaryKey
88670>>>>>>>        Move False to bIsSQLClustered
88671>>>>>>>
88671>>>>>>>            Get UtilIndexTempRenameSQLName hTable APIIndex.sSQLIndexName sDriverID          to bOK
88672>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber              to iSegmentsTo
88675>>>>>>>        Move (iSegmentsTo > 0) to bExists
88676>>>>>>>        If (bExists = True) Begin
88678>>>>>>>            If (bIsSQLTable = True and iSegmentsTo > 0) Begin
88680>>>>>>>                Get_Attribute DF_INDEX_NAME of hTable APIIndex.iIndexNumber                 to sSQLIndexName
88683>>>>>>>                        Get_Attribute DF_INDEX_SQL_TYPE of hTable APIIndex.iIndexNumber         to iSQLIndexType
88686>>>>>>>                        Move (iSQLIndexType = DF_INDEX_TEMPORARY)                               to bIsSQLTemporaryIndex
88687>>>>>>>                    Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex.iIndexNumber  to bIsSQLPrimaryKey
88690>>>>>>>                    Get_Attribute DF_INDEX_CLUSTERED       of hTable APIIndex.iIndexNumber  to bIsSQLClustered
88693>>>>>>>            End
88693>>>>>>>>
88693>>>>>>>        End
88693>>>>>>>>
88693>>>>>>>
88693>>>>>>>        Move hTable to iTableNo
88694>>>>>>>        Move False to Err
88695>>>>>>>        Move 0 to LastErr
88696>>>>>>>
88696>>>>>>>        Structure_Start hTable sDriverID
88697>>>>>>>            If (bExists = True) Begin
88699>>>>>>>                Delete_Index iTableNo APIIndex.iIndexNumber
88700>>>>>>>            End
88700>>>>>>>>
88700>>>>>>>
88700>>>>>>>            Create_Index hTable At APIIndex.iIndexNumber
88701>>>>>>>
88701>>>>>>>                If (bIsSQLTable = True) Begin // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
88703>>>>>>>                    Set_Attribute DF_INDEX_SQL_TYPE        of hTable APIIndex.iIndexNumber to APIIndex.iSQLIndexType
88706>>>>>>>                    Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex.iIndexNumber to APIIndex.bIsSQLPrimaryKey
88709>>>>>>>                    Set_Attribute DF_INDEX_CLUSTERED       of hTable APIIndex.iIndexNumber to APIIndex.bIsSQLClustered
88712>>>>>>>                    Set_Attribute DF_INDEX_NAME            of hTable APIIndex.iIndexNumber to APIIndex.sSQLIndexName
88715>>>>>>>                End
88715>>>>>>>>
88715>>>>>>>
88715>>>>>>>                    Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber to iSegmentsFrom
88718>>>>>>>
88718>>>>>>>            for iCount from 0 to (iSegmentsFrom -1)
88724>>>>>>>>
88724>>>>>>>                Move aIndexSegments[iCount].iFieldNumber to iFieldFrom
88725>>>>>>>                If (iFieldFrom <> -1 ) Begin
88727>>>>>>>                        Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable APIIndex.iIndexNumber (iCount +1) to iFieldFrom
88730>>>>>>>                        Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable APIIndex.iIndexNumber (iCount +1) to aIndexSegments[iCount].bAscending
88733>>>>>>>                        Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable APIIndex.iIndexNumber (iCount +1) to aIndexSegments[iCount].bUppercase
88736>>>>>>>                End
88736>>>>>>>>
88736>>>>>>>            Loop
88737>>>>>>>>
88737>>>>>>>
88737>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88738>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88740>>>>>>>
88740>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88741>>>>>>>
88741>>>>>>>        Function_Return (Err = False)
88742>>>>>>>    End_Function
88743>>>>>>>
88743>>>>>>>    // If an SQL index is to be renamed we need to check that the name doesn't exist already, but
88743>>>>>>>    // with another index number. If we find one we temporarily renames it by adding "TMP" to the SQL name.
88743>>>>>>>    Function UtilIndexTempRenameSQLName Handle hTable String sSQLIndexName String sDriverID Returns Boolean
88745>>>>>>>        Integer iLastIndex iCount iTableNo iSegments
88745>>>>>>>        String sSQLIndexNameCompare sTmpIndexName
88745>>>>>>>        Boolean bIsOpen bExists bIsSQLDriver 
88745>>>>>>>
88745>>>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
88746>>>>>>>        
88746>>>>>>>        If (bIsSQLDriver = False) Begin
88748>>>>>>>            Function_Return False
88749>>>>>>>        End
88749>>>>>>>>
88749>>>>>>>
88749>>>>>>>        Move False to Err
88750>>>>>>>        Move hTable to iTableNo
88751>>>>>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
88754>>>>>>>        for iCount from 0 to iLastIndex
88760>>>>>>>>
88760>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iCount to iSegments
88763>>>>>>>            Move (iSegments > 0) to bExists
88764>>>>>>>            If (bExists = True) Begin
88766>>>>>>>                Get_Attribute DF_INDEX_NAME of hTable iCount to sSQLIndexNameCompare
88769>>>>>>>                If (Lowercase(sSQLIndexName) = Lowercase(sSQLIndexNameCompare)) Begin
88771>>>>>>>                    Move (sSQLIndexNameCompare + String("_TMP")) to sTmpIndexName
88772>>>>>>>                    Structure_Start iTableNo sDriverID
88773>>>>>>>                        Set_Attribute DF_INDEX_NAME of iTableNo iCount to sTmpIndexName
88776>>>>>>>                    Structure_End iTableNo DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88778>>>>>>>                    Open hTable
88780>>>>>>>                End
88780>>>>>>>>
88780>>>>>>>            End
88780>>>>>>>>
88780>>>>>>>        Loop
88781>>>>>>>>
88781>>>>>>>
88781>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
88784>>>>>>>        If (bIsOpen = False) Begin
88786>>>>>>>            Get OpenTableExclusive hTable to bIsOpen
88787>>>>>>>        End
88787>>>>>>>>
88787>>>>>>>        If (bIsOpen = False) Begin
88789>>>>>>>            Function_Return False
88790>>>>>>>        End
88790>>>>>>>>
88790>>>>>>>
88790>>>>>>>        Function_Return (Err = False)
88791>>>>>>>    End_Function
88792>>>>>>>
88792>>>>>>>    // Checks if an SQL Index name for the "FROM" database already exists in the TO database,
88792>>>>>>>    // but with another Index number. We can then not rename the SQL index name for the TO database table.
88792>>>>>>>    Function UtilIndexSQLIndexNameExists Handle hTable Integer iIndexNumberFrom String sSQLIndexNameFrom tAPIIndex[] APIIndexTo Returns Integer
88794>>>>>>>        Integer iSize iCount
88794>>>>>>>        Integer iRetVal
88794>>>>>>>
88794>>>>>>>        Move 0 to iRetVal
88795>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndexNumberFrom to iRetVal
88798>>>>>>>        If (iRetVal = 0) Begin
88800>>>>>>>            Function_Return 0
88801>>>>>>>        End
88801>>>>>>>>
88801>>>>>>>        Move (SizeOfArray(APIIndexTo)) to iSize
88802>>>>>>>        Decrement iSize
88803>>>>>>>        for iCount from 0 to iSize
88809>>>>>>>>
88809>>>>>>>            If (Uppercase(sSQLIndexNameFrom) = Uppercase(APIIndexTo[iCount].sSQLIndexName)) Begin
88811>>>>>>>                If (iIndexNumberFrom <> APIIndexTo[iCount].iIndexNumber) Begin
88813>>>>>>>                    Move APIIndexTo[iCount].iIndexNumber to iRetVal
88814>>>>>>>                End
88814>>>>>>>>
88814>>>>>>>            End
88814>>>>>>>>
88814>>>>>>>        Loop
88815>>>>>>>>
88815>>>>>>>
88815>>>>>>>        Function_Return iRetVal
88816>>>>>>>    End_Function
88817>>>>>>>
88817>>>>>>>    Function ApiIndexDeleteSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
88819>>>>>>>        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
88819>>>>>>>        Boolean bIsSQLTable
88819>>>>>>>        
88819>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
88820>>>>>>>            If (bIsSQLTable = True) Begin
88822>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88825>>>>>>>            End
88825>>>>>>>>
88825>>>>>>>
88825>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88828>>>>>>>        If (iSegment = iNumSegments) Begin
88830>>>>>>>//            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
88830>>>>>>>        End
88830>>>>>>>>
88830>>>>>>>
88830>>>>>>>        Else If (iSegment > 0 and iSegment < iNumSegments) Begin
88833>>>>>>>            for iCurSegment from iSegment to (iNumSegments - 1)
88839>>>>>>>>
88839>>>>>>>                //*** Move index segment attributes
88839>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
88842>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
88845>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
88848>>>>>>>
88848>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment to iSegmentCase
88851>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment to iSegmentDirection
88854>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment to iSegmentColumn
88857>>>>>>>            Loop
88858>>>>>>>>
88858>>>>>>>
88858>>>>>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
88861>>>>>>>        End
88861>>>>>>>>
88861>>>>>>>
88861>>>>>>>        Function_Return (Err = False)
88862>>>>>>>    End_Function
88863>>>>>>>
88863>>>>>>>    Function APIIndexRemoveAllIndexes Handle hTable tAPIIndex[] APIIndex Returns Boolean
88865>>>>>>>        Integer iCount iSize iIndex
88865>>>>>>>        String sDriverID
88865>>>>>>>        Boolean bOK bIsSQLTable bIsOpen
88865>>>>>>>
88865>>>>>>>        Move (SizeOfArray(APIIndex)) to iSize
88866>>>>>>>        If (iSize = 0) Begin
88868>>>>>>>            Function_Return True
88869>>>>>>>        End
88869>>>>>>>>
88869>>>>>>>
88869>>>>>>>        Get AutoConnectionIDLogin to bOK
88870>>>>>>>        Move False to Err
88871>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
88874>>>>>>>        If (bIsOpen = False) Begin
88876>>>>>>>            Get OpenTableExclusive hTable to bIsOpen
88877>>>>>>>            If (bIsOpen = False) Begin
88879>>>>>>>                Function_Return False
88880>>>>>>>            End
88880>>>>>>>>
88880>>>>>>>        End
88880>>>>>>>>
88880>>>>>>>
88880>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88883>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTable
88884>>>>>>>            If (bIsSQLTable = True) Begin
88886>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88889>>>>>>>            End
88889>>>>>>>>
88889>>>>>>>
88889>>>>>>>        Move False to Err
88890>>>>>>>        Move 0 to LastErr
88891>>>>>>>        Decrement iSize
88892>>>>>>>
88892>>>>>>>        Structure_Start hTable sDriverID
88893>>>>>>>            for iCount from 0 to iSize
88899>>>>>>>>
88899>>>>>>>//                Move False to bIsSQLPrimaryKey
88899>>>>>>>//                #IF (!@ > 180)   // DF 18.1 and up
88899>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88899>>>>>>>//                    Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex[iCount].iIndexNumber to bIsSQLPrimaryKey
88899>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
88899>>>>>>>//                #ENDIF
88899>>>>>>>                // We can't delete if this is a primary key index:
88899>>>>>>>//                If (bIsSQLPrimaryKey = False) Begin
88899>>>>>>>                    Move APIIndex[iCount].iIndexNumber to iIndex
88900>>>>>>>                    Delete_Index hTable iIndex
88901>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
88901>>>>>>>//                End
88901>>>>>>>            Loop
88902>>>>>>>>
88902>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88903>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88905>>>>>>>//        Move False to Err
88905>>>>>>>        Move 0 to LastErr
88906>>>>>>>
88906>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88907>>>>>>>        Function_Return (Err = False)
88908>>>>>>>    End_Function
88909>>>>>>>
88909>>>>>>>    Function ApiIndexChangeDirection Handle hTable Integer iIndex Integer iSegment Integer iDirection Returns Boolean
88911>>>>>>>        Boolean bOK
88911>>>>>>>
88911>>>>>>>        Get AutoConnectionIDLogin to bOK
88912>>>>>>>        Move False to Err
88913>>>>>>>        Get OpenTableExclusive hTable to bOK
88914>>>>>>>        If (bOK = False) Begin
88916>>>>>>>            Function_Return False
88917>>>>>>>        End
88917>>>>>>>>
88917>>>>>>>        Structure_Start hTable
88918>>>>>>>            Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to iDirection
88921>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88922>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88924>>>>>>>
88924>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88925>>>>>>>        Function_Return (Err = False)
88926>>>>>>>    End_Function
88927>>>>>>>
88927>>>>>>>    Function ApiIndexChangeUppercase Handle hTable Integer iIndex Integer iSegment Boolean bUppercase Returns Boolean
88929>>>>>>>        Integer iCase
88929>>>>>>>        Boolean bOK
88929>>>>>>>
88929>>>>>>>        If (bUppercase = True) Begin
88931>>>>>>>            Move DF_CASE_IGNORED to iCase
88932>>>>>>>        End
88932>>>>>>>>
88932>>>>>>>        Else Begin
88933>>>>>>>            Move DF_CASE_USED to iCase
88934>>>>>>>        End
88934>>>>>>>>
88934>>>>>>>
88934>>>>>>>        Get AutoConnectionIDLogin to bOK
88935>>>>>>>        Move False to Err
88936>>>>>>>        Get OpenTableExclusive hTable to bOK
88937>>>>>>>        If (bOK = False) Begin
88939>>>>>>>            Function_Return False
88940>>>>>>>        End
88940>>>>>>>>
88940>>>>>>>        Structure_Start hTable
88941>>>>>>>            Set_Attribute DF_INDEX_SEGMENT_CASE of hTable iIndex iSegment to iCase
88944>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88945>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88947>>>>>>>
88947>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88948>>>>>>>        Function_Return (Err = False)
88949>>>>>>>    End_Function
88950>>>>>>>
88950>>>>>>>    // To delete an index
88950>>>>>>>    Function ApiIndexRemove Handle hTable Integer iIndex Returns Boolean
88952>>>>>>>        Integer iTableNo iNumSegments
88952>>>>>>>        String sDriverID
88952>>>>>>>        Boolean bOK bIsSQLTable
88952>>>>>>>
88952>>>>>>>        Get AutoConnectionIDLogin to bOK
88953>>>>>>>        Move False to Err
88954>>>>>>>        Move hTable to iTableNo
88955>>>>>>>        Get OpenTableExclusive hTable to bOK
88956>>>>>>>        If (bOK = False) Begin
88958>>>>>>>            Function_Return False
88959>>>>>>>        End
88959>>>>>>>>
88959>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88962>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
88963>>>>>>>            If (bIsSQLTable = True) Begin
88965>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88968>>>>>>>            End
88968>>>>>>>>
88968>>>>>>>
88968>>>>>>>        // Check to see if the index exists or not...
88968>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88971>>>>>>>        If (iNumSegments = 0) Begin
88973>>>>>>>            Function_Return True // Then nothing to do.
88974>>>>>>>        End
88974>>>>>>>>
88974>>>>>>>
88974>>>>>>>        Structure_Start hTable sDriverID
88975>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
88976>>>>>>>            Delete_Index iTableNo iIndex
88977>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
88978>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88979>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88981>>>>>>>
88981>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88982>>>>>>>        Function_Return (Err = False)
88983>>>>>>>    End_Function
88984>>>>>>>
88984>>>>>>>    // Delete an Index Segment
88984>>>>>>>    Function ApiIndexRemoveSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
88986>>>>>>>        Boolean bOK bSQLDriver bIndexTemporary bIsSQLTable
88986>>>>>>>        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
88986>>>>>>>        Integer iIndexType
88986>>>>>>>        String sDriverID
88986>>>>>>>
88986>>>>>>>        Get AutoConnectionIDLogin to bOK
88987>>>>>>>        Move False to Err
88988>>>>>>>
88988>>>>>>>        Get OpenTableExclusive hTable to bOK
88989>>>>>>>        If (bOK = False) Begin
88991>>>>>>>            Function_Return False
88992>>>>>>>        End
88992>>>>>>>>
88992>>>>>>>
88992>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
88993>>>>>>>            If (bIsSQLTable = True) Begin
88995>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88998>>>>>>>            End
88998>>>>>>>>
88998>>>>>>>
88998>>>>>>>        // Check to see if the index exists or not...
88998>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89001>>>>>>>        If (iNumSegments = 0) Begin
89003>>>>>>>            Function_Return False
89004>>>>>>>        End
89004>>>>>>>>
89004>>>>>>>
89004>>>>>>>        Move False to bIndexTemporary
89005>>>>>>>        Get psDriverID to sDriverID
89006>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
89007>>>>>>>        If (bSQLDriver) Begin
89009>>>>>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
89012>>>>>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
89015>>>>>>>                Move True to bIndexTemporary
89016>>>>>>>        End
89016>>>>>>>>
89016>>>>>>>
89016>>>>>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
89016>>>>>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
89018>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89021>>>>>>>            If (iSegment = iNumSegments) Begin
89023>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
89026>>>>>>>            End
89026>>>>>>>>
89026>>>>>>>            Else If (iSegment > 0 and iSegment < iNumSegments) Begin
89029>>>>>>>                For iCurSegment from iSegment to (iNumSegments - 1)
89035>>>>>>>>
89035>>>>>>>                    //*** Move index segment attributes
89035>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
89038>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
89041>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
89044>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
89047>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
89050>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
89053>>>>>>>                Loop
89054>>>>>>>>
89054>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
89057>>>>>>>            End
89057>>>>>>>>
89057>>>>>>>        End
89057>>>>>>>>
89057>>>>>>>
89057>>>>>>>        Else Begin
89058>>>>>>>           Structure_Start hTable
89059>>>>>>>               Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89062>>>>>>>               If (iSegment = iNumSegments) Begin
89064>>>>>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
89067>>>>>>>               End
89067>>>>>>>>
89067>>>>>>>               Else If (iSegment > 0 and iSegment < iNumSegments) Begin
89070>>>>>>>                   for iCurSegment from iSegment to (iNumSegments - 1)
89076>>>>>>>>
89076>>>>>>>                       //*** Move index segment attributes
89076>>>>>>>                       Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
89079>>>>>>>                       Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
89082>>>>>>>                       Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
89085>>>>>>>                       Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
89088>>>>>>>                       Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
89091>>>>>>>                       Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
89094>>>>>>>                   Loop
89095>>>>>>>>
89095>>>>>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
89098>>>>>>>               End
89098>>>>>>>>
89098>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
89099>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89101>>>>>>>            Set Action_Text of ghoStatusPanel to ""
89102>>>>>>>        End
89102>>>>>>>>
89102>>>>>>>
89102>>>>>>>        Function_Return (Err = False)
89103>>>>>>>    End_Function
89104>>>>>>>
89104>>>>>>>    // Add/Insert an Index Segment
89104>>>>>>>    Function ApiIndexInsertSegment Handle hTable Integer iIndex Integer iSegment Integer iSegmentColumn Integer iSegmentCase Integer iSegmentDirection Returns Boolean
89106>>>>>>>        Boolean bOK bSQLDriver bIndexTemporary bIsSQLTable
89106>>>>>>>        Integer iNumSegments iCurSegment iCurSegmentColumn iCurSegmentCase iCurSegmentDirection
89106>>>>>>>        Integer iIndexType
89106>>>>>>>        String sDriverId
89106>>>>>>>
89106>>>>>>>        Get AutoConnectionIDLogin to bOK
89107>>>>>>>        Move False to Err
89108>>>>>>>
89108>>>>>>>        Get OpenTableExclusive hTable to bOK
89109>>>>>>>        If (bOK = False) Begin
89111>>>>>>>            Function_Return False
89112>>>>>>>        End
89112>>>>>>>>
89112>>>>>>>
89112>>>>>>>            Get _UtilTableIsSql hTable to bIsSQLTable
89113>>>>>>>            If (bIsSQLTable = True) Begin
89115>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
89118>>>>>>>            End
89118>>>>>>>>
89118>>>>>>>
89118>>>>>>>        Move False to bIndexTemporary
89119>>>>>>>        // Check to see if the index exists or not...
89119>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89122>>>>>>>        If (iNumSegments = 0) Begin
89124>>>>>>>            Function_Return False
89125>>>>>>>        End
89125>>>>>>>>
89125>>>>>>>
89125>>>>>>>        Get psDriverID to sDriverID
89126>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
89127>>>>>>>        If (bSQLDriver) Begin
89129>>>>>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
89132>>>>>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
89135>>>>>>>                Move True to bIndexTemporary
89136>>>>>>>        End
89136>>>>>>>>
89136>>>>>>>
89136>>>>>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
89136>>>>>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
89138>>>>>>>           Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89141>>>>>>>
89141>>>>>>>           If (iSegment > iNumSegments) Begin
89143>>>>>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
89146>>>>>>>               Move (iNumSegments + 1) to iCurSegment
89147>>>>>>>           End
89147>>>>>>>>
89147>>>>>>>           Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
89150>>>>>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
89153>>>>>>>               Move iNumSegments to iCurSegment
89154>>>>>>>
89154>>>>>>>               While (iCurSegment > iSegment)
89158>>>>>>>                   //*** Move index segment attributes
89158>>>>>>>                   Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iCurSegmentCase
89161>>>>>>>                   Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iCurSegmentDirection
89164>>>>>>>                   Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
89167>>>>>>>                   Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iCurSegmentCase
89170>>>>>>>                   Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iCurSegmentDirection
89173>>>>>>>                   Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iCurSegmentColumn
89176>>>>>>>                   Decrement iCurSegment
89177>>>>>>>               Loop
89178>>>>>>>>
89178>>>>>>>
89178>>>>>>>               //*** Now set new segment attributes
89178>>>>>>>               Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
89181>>>>>>>               Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
89184>>>>>>>               Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
89187>>>>>>>           End
89187>>>>>>>>
89187>>>>>>>        End
89187>>>>>>>>
89187>>>>>>>
89187>>>>>>>        Else Begin
89188>>>>>>>        Structure_Start hTable
89189>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89192>>>>>>>
89192>>>>>>>            If (iSegment > iNumSegments) Begin
89194>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
89197>>>>>>>                Move (iNumSegments + 1) to iCurSegment
89198>>>>>>>            End
89198>>>>>>>>
89198>>>>>>>            Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
89201>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
89204>>>>>>>                Move iNumSegments to iCurSegment
89205>>>>>>>
89205>>>>>>>                While (iCurSegment > iSegment)
89209>>>>>>>                    //*** Move index segment attributes
89209>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iSegmentCase
89212>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iSegmentDirection
89215>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
89218>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
89221>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
89224>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
89227>>>>>>>                    Decrement iCurSegment
89228>>>>>>>                Loop
89229>>>>>>>>
89229>>>>>>>
89229>>>>>>>                //*** Now set new segment attributes
89229>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
89232>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
89235>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
89238>>>>>>>            End
89238>>>>>>>>
89238>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
89239>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89241>>>>>>>            Set Action_Text of ghoStatusPanel to ""
89242>>>>>>>        End
89242>>>>>>>>
89242>>>>>>>
89242>>>>>>>        Function_Return (Err = False)
89243>>>>>>>    End_Function
89244>>>>>>>
89244>>>>>>>    // * Dummy function for the Studio's Code Explorer *
89244>>>>>>>    Function TABLE_UTILITY_FUNCTIONS Returns Boolean
89246>>>>>>>        Function_Return False
89247>>>>>>>    End_Function  
89248>>>>>>>    
89248>>>>>>>    // Preparation message before an SQL onversion. It will check and wash all embedded data tables and prepare them
89248>>>>>>>    // for an SQL conversion.
89248>>>>>>>    Function UtilPrepareDataFolderForSQLConversion Boolean bMoveMiscFilesToBackup Boolean bFixALLBogusFilelistEntries Boolean bConvertTo30Format Boolean bRepairAndReindex Boolean bFixBogusDates Returns Boolean
89250>>>>>>>        Boolean bConvertTo30FormatbOK bRepairAndReindexOK bFixBogusDatesOK bMoveMiscFilesToBackupOK
89250>>>>>>>        
89250>>>>>>>        Move True to bConvertTo30FormatbOK
89251>>>>>>>        Move True to bRepairAndReindexOK
89252>>>>>>>        Move True to bFixBogusDatesOK
89253>>>>>>>        Move True to bMoveMiscFilesToBackupOK
89254>>>>>>>        
89254>>>>>>>        If (bMoveMiscFilesToBackup = True) Begin   
89256>>>>>>>            Set Message_Text of ghoStatusPanel to "Moving misc. files to backup..."
89257>>>>>>>            Get UtilMoveMiscFilesToBackupFolder to bMoveMiscFilesToBackupOK
89258>>>>>>>        End                                                                                
89258>>>>>>>>
89258>>>>>>>        If (bFixALLBogusFilelistEntries = True) Begin
89260>>>>>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus Filelist.cfg entries..."
89261>>>>>>>            Get UtilTableFixALLBogusFilelistEntries to bFixALLBogusFilelistEntries
89262>>>>>>>        End
89262>>>>>>>>
89262>>>>>>>        If (bConvertTo30Format = True) Begin
89264>>>>>>>            Set Message_Text of ghoStatusPanel to "Converting .dat files from 2.3->..."
89265>>>>>>>            Get UtilTableConvertALLTablesFrom23Format to bConvertTo30FormatbOK
89266>>>>>>>        End                                                 
89266>>>>>>>>
89266>>>>>>>        If (bRepairAndReindex = True) Begin
89268>>>>>>>            Set Message_Text of ghoStatusPanel to "Repairing and reindexing..."
89269>>>>>>>            Get UtilTableRepairAndReindexALL to bRepairAndReindexOK
89270>>>>>>>        End  
89270>>>>>>>>
89270>>>>>>>        If (bFixBogusDates = True) Begin
89272>>>>>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus date values..."
89273>>>>>>>            Get UtilTablesFixAllDateBogusValues True False to bFixBogusDatesOK
89274>>>>>>>        End                                    
89274>>>>>>>>
89274>>>>>>>        
89274>>>>>>>        Function_Return (bConvertTo30FormatbOK = True and bFixALLBogusFilelistEntries = True and bRepairAndReindexOK = True and bFixBogusDatesOK = True and bMoveMiscFilesToBackupOK = True)
89275>>>>>>>    End_Function
89276>>>>>>>
89276>>>>>>>    Function UtilTableConvertALLTablesFrom23Format Returns Boolean
89278>>>>>>>        Boolean bOK bFlexErrs bTemp
89278>>>>>>>        Handle hTable
89278>>>>>>>        String sTableName
89278>>>>>>>        Integer iCount iSize
89278>>>>>>>        
89278>>>>>>>        Move True to bOK
89279>>>>>>>        Move 0 to hTable    
89280>>>>>>>
89280>>>>>>>        Get UtilFilelistNoOfTables to iSize
89281>>>>>>>        Set pbVisible    of ghoProgressBarOverall to True
89282>>>>>>>        Set piPosition   of ghoProgressBarOverall to 0
89283>>>>>>>        Set piMaximum    of ghoProgressBarOverall to iSize
89284>>>>>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
89285>>>>>>>
89285>>>>>>>        Repeat
89285>>>>>>>>
89285>>>>>>>            Set Action_Text of ghoStatusPanel to "Checking if table is in 2.3 format..."
89286>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount  
89287>>>>>>>            Increment iCount
89288>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89291>>>>>>>            If (hTable > 0) Begin
89293>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
89296>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
89297>>>>>>>                If (bFlexErrs = False) Begin
89299>>>>>>>                    Get UtilTableConvertFrom23Format hTable to bTemp
89300>>>>>>>                    If (bTemp = False) Begin
89302>>>>>>>                        Move False to bOK
89303>>>>>>>                    End
89303>>>>>>>>
89303>>>>>>>                End
89303>>>>>>>>
89303>>>>>>>            End
89303>>>>>>>>
89303>>>>>>>        Until (hTable = 0)
89305>>>>>>>        
89305>>>>>>>        Set Action_Text of ghoStatusPanel to ""
89306>>>>>>>        Function_Return bOK
89307>>>>>>>    End_Function
89308>>>>>>>    
89308>>>>>>>    // Converts an embedded table from 2.3 -> 3.0.
89308>>>>>>>    // Returns: FALSE only if the table can't be opened or the conversion fails.
89308>>>>>>>    // It will return a TRUE if successful or the table is an SQL table.
89308>>>>>>>    Function UtilTableConvertFrom23Format Handle hTable Returns Boolean
89310>>>>>>>        Boolean bOK bIsEmbedded bIsAlias
89310>>>>>>>        String sRevision
89310>>>>>>>        
89310>>>>>>>        Get AutoConnectionIDLogin to bOK
89311>>>>>>>        If (bOK = False) Begin
89313>>>>>>>            Function_Return True
89314>>>>>>>        End
89314>>>>>>>>
89314>>>>>>>        Get OpenTableExclusive hTable to bOK
89315>>>>>>>        If (bOK = False) Begin
89317>>>>>>>            Function_Return True
89318>>>>>>>        End
89318>>>>>>>>
89318>>>>>>>        Get _UtilTableIsEmbedded hTable to bIsEmbedded
89319>>>>>>>        If (bIsEmbedded = False) Begin
89321>>>>>>>            Function_Return True
89322>>>>>>>        End                             
89322>>>>>>>>
89322>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias
89323>>>>>>>        If (bIsAlias = True) Begin
89325>>>>>>>            Function_Return True
89326>>>>>>>        End                     
89326>>>>>>>>
89326>>>>>>>        
89326>>>>>>>        Move False to Err
89327>>>>>>>        Get_Attribute DF_FILE_REVISION of hTable to sRevision
89330>>>>>>>        If (sRevision contains "2.3") Begin
89332>>>>>>>            Move False to Err
89333>>>>>>>            Set Private.phCurrentTable to hTable
89334>>>>>>>            Structure_Start hTable    
89335>>>>>>>                Set_Attribute DF_FILE_INTEGRITY_CHECK of hTable to True
89338>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table to 3.0/4.0"
89339>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_FORCE "." ghoDbUpdateHandler
89341>>>>>>>            Set Action_Text of ghoStatusPanel to ""
89342>>>>>>>        End
89342>>>>>>>>
89342>>>>>>>        
89342>>>>>>>        Function_Return (Err = False)
89343>>>>>>>    End_Function
89344>>>>>>>
89344>>>>>>>    Function UtilTableFixALLBogusFilelistEntries Returns Boolean
89346>>>>>>>        Boolean bIgnore bExists bOK bResponse
89346>>>>>>>        Handle hTable   
89346>>>>>>>        String sTableName
89346>>>>>>>        
89346>>>>>>>        Move False to Err 
89347>>>>>>>        Move True to bOK
89348>>>>>>>        Move 0 to hTable
89349>>>>>>>        Repeat
89349>>>>>>>>
89349>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89352>>>>>>>            If (hTable > 0) Begin
89354>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
89357>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS" or Uppercase(sTableName) = "CODETYPE" or Uppercase(sTableName) = "CODEMAST")  to bIgnore
89358>>>>>>>                If (bIgnore = False) Begin
89360>>>>>>>                    Get _UtilTableExists hTable to bExists
89361>>>>>>>                    If (bExists = False) Begin
89363>>>>>>>                        Get ApiTableChangeFileListSlot "" "" "" hTable DATAFLEX_ID to bResponse
89364>>>>>>>                        If (bResponse = False) Begin
89366>>>>>>>                            Move False to bOK
89367>>>>>>>                        End
89367>>>>>>>>
89367>>>>>>>                        
89367>>>>>>>                    End
89367>>>>>>>>
89367>>>>>>>                End
89367>>>>>>>>
89367>>>>>>>            End
89367>>>>>>>>
89367>>>>>>>        Until (hTable = 0)                     
89369>>>>>>>        
89369>>>>>>>        Set Action_Text of ghoStatusPanel to "" 
89370>>>>>>>        Function_Return bOK
89371>>>>>>>    End_Function
89372>>>>>>>    
89372>>>>>>>    // Replaces all date values with CS_DUFLowestAllowedDateValue for all tables in Filelist.cfg,
89372>>>>>>>    // _except_ those tables that has been excluded with the "ApiTableDateCorrectionAddException" message.
89372>>>>>>>    // If the passed bAllowZeroDates = True, date columns that are = 0 will not be changed.
89372>>>>>>>    // This is for prepairing embedded tables (*.dat) before an SQL conversion.
89372>>>>>>>    //
89372>>>>>>>    // The root of the problem is the following:
89372>>>>>>>    // The data type Date in SQL has a range of accepted values from 01-01-0001 through 12-31-9999
89372>>>>>>>    // while the data type DateTime has a range of accepted values from 01-01-1753 through 12-31-9999
89372>>>>>>>    // So if you happen to have a Date from before 1753, or an empty / NULL value - this will be outside
89372>>>>>>>    // the range that DateTime can handle and if you then try to change a Date column to a DateTime,
89372>>>>>>>    // an SQL error will be thrown;
89372>>>>>>>    // "The conversion of a date data type to a datetime data type resulted in an out-of-range value".
89372>>>>>>>    Function UtilTablesFixAllDateBogusValues Boolean bFixZeroDates Boolean bResetIndexesToOnLine Returns Boolean
89374>>>>>>>        Boolean bOK bIsAlias bIsSQL
89374>>>>>>>        Integer iCount iSize iDateSize
89374>>>>>>>        Handle hTable
89374>>>>>>>        String sLogicalName
89374>>>>>>>        Integer[] aTablesToCheck aDateFields
89376>>>>>>>
89376>>>>>>>        Get _AllTablesDateCorrections to aTablesToCheck
89377>>>>>>>        Move (SizeOfArray(aTablesToCheck)) to iSize
89378>>>>>>>        Set pbVisible    of ghoProgressBarOverall to True
89379>>>>>>>        Set piPosition   of ghoProgressBarOverall to 0
89380>>>>>>>        Set piMaximum    of ghoProgressBarOverall to iSize
89381>>>>>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
89382>>>>>>>
89382>>>>>>>        Move True to bOK
89383>>>>>>>        Decrement iSize
89384>>>>>>>        for iCount from 0 to iSize
89390>>>>>>>>
89390>>>>>>>            Move aTablesToCheck[iCount] to hTable
89391>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount
89392>>>>>>>            Get UtilTableIsAlias hTable to bIsAlias
89393>>>>>>>            Get _UtilTableIsSql   hTable to bIsSQL
89394>>>>>>>
89394>>>>>>>            Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
89397>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Processing Table Number:" * String(hTable) * "Name:" * String(sLogicalName))
89398>>>>>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus date values..."
89399>>>>>>>
89399>>>>>>>            If (bIsAlias = False and bIsSQL = False) Begin
89401>>>>>>>                Get UtilCheckForDateFields hTable to aDateFields
89402>>>>>>>                Move (SizeOfArray(aDateFields)) to iDateSize
89403>>>>>>>                If (iDateSize > 0) Begin
89405>>>>>>>                    Get UtilTableCorrectBogusDateValues hTable aDateFields bFixZeroDates bResetIndexesToOnLine to bOK
89406>>>>>>>                    Close hTable
89407>>>>>>>                End
89407>>>>>>>>
89407>>>>>>>            End
89407>>>>>>>>
89407>>>>>>>        Loop
89408>>>>>>>>
89408>>>>>>>
89408>>>>>>>        Close DF_ALL
89409>>>>>>>        Function_Return bOK
89410>>>>>>>    End_Function
89411>>>>>>>
89411>>>>>>>    // Returns all fields of type Date or DateTime in an integer array with the field numbers.
89411>>>>>>>    Function UtilCheckForDateFields Handle hTable Returns Integer[]
89413>>>>>>>        Integer[] aDateFields aDateFieldsEmpty
89415>>>>>>>        Integer iSize iCount iType
89415>>>>>>>        Boolean bOpen bOK
89415>>>>>>>        
89415>>>>>>>        Get _UtilTableExists hTable to bOK
89416>>>>>>>        If (bOK = False) Begin
89418>>>>>>>            Set Private.phCurrentTable to hTable
89419>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
89420>>>>>>>>
89420>>>>>>>            Function_Return aDateFieldsEmpty
89421>>>>>>>        End
89421>>>>>>>>
89421>>>>>>>        Set Private.phCurrentTable to hTable
89422>>>>>>>        Set Private.piCurrentField to 0
89423>>>>>>>
89423>>>>>>>//        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89423>>>>>>>        Open hTable
89425>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
89428>>>>>>>//        Set Error_Report_Mode to DUF_ERROR_REPORT
89428>>>>>>>        If (bOpen = False) Begin
89430>>>>>>>//            Error DFERR_PROGRAM ("Table could not be opened." * String(hTable))
89430>>>>>>>            Function_Return aDateFieldsEmpty
89431>>>>>>>        End
89431>>>>>>>>
89431>>>>>>>
89431>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iSize
89434>>>>>>>        For iCount from 1 to iSize
89440>>>>>>>>
89440>>>>>>>            Get_Attribute DF_FIELD_TYPE of hTable iCount to iType
89443>>>>>>>            If (iType = DF_DATE or iType = DF_DATETIME) Begin
89445>>>>>>>                Move iCount to aDateFields[SizeOfArray(aDateFields)]
89446>>>>>>>            End
89446>>>>>>>>
89446>>>>>>>        Loop
89447>>>>>>>>
89447>>>>>>>
89447>>>>>>>        Function_Return aDateFields
89448>>>>>>>    End_Function
89449>>>>>>>
89449>>>>>>>    // Loops through all records for the passed hTable, and checks that all Date values
89449>>>>>>>    // for the passed aDateFields array are OK. Else the Data value is set to CS_DUFLowestAllowedDateValue
89449>>>>>>>    // and the record is saved
89449>>>>>>>    // If the passed bAllowZeroDates = True, date columns that are = 0 will not be changed.
89449>>>>>>>    // Note: It first sets all indexes to BATCH and reset them at the end.
89449>>>>>>>    Function UtilTableCorrectBogusDateValues Handle hTable Integer[] aDateFields Boolean bFixZeroDates Boolean bResetIndexesToOnLine Returns Boolean
89451>>>>>>>        Integer iSize iCount iField iRecord iTotalRecords iDateFormat iDriverIndex
89451>>>>>>>        String sDriverID sDateMin
89451>>>>>>>        Boolean bCancel bFound bOK bChange bOpened bSaveChanges 
89451>>>>>>>        Date dDate dDateMin
89451>>>>>>>        Integer[] iaChangeField
89452>>>>>>>
89452>>>>>>>        Get _UtilTableExists hTable to bOK
89453>>>>>>>        // I believe we should just skip files not found and not report an error.
89453>>>>>>>        // This is because a filelist may have entries but no files/tables on disk, but
89453>>>>>>>        // this may be adjusted by other calls to DUF in a later update package. 
89453>>>>>>>        // Especially considering that this call is probably done at the very
89453>>>>>>>        // beginning of a DUF update.
89453>>>>>>>        If (bOK = False) Begin
89455>>>>>>>//            Set Private.phCurrentTable to hTable
89455>>>>>>>//            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
89455>>>>>>>//            Function_Return False
89455>>>>>>>            Function_Return True
89456>>>>>>>        End
89456>>>>>>>>
89456>>>>>>>
89456>>>>>>>        // The CS_DUFLowestAllowedDateValue is defined as "01/01/1753", so we first set the
89456>>>>>>>        // date format to "USA" = "MM/DD/YYYY"
89456>>>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
89459>>>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_USA
89462>>>>>>>
89462>>>>>>>//        Send SetAllIndexesToBatch hTable True
89462>>>>>>>        Open hTable
89464>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
89467>>>>>>>        If (bOpened = False) Begin
89469>>>>>>>            Function_Return False
89470>>>>>>>        End
89470>>>>>>>>
89470>>>>>>>        
89470>>>>>>>        Set Private.phCurrentTable to hTable
89471>>>>>>>        Move 0 to iRecord
89472>>>>>>>        Move (SizeOfArray(aDateFields)) to iSize
89473>>>>>>>        Decrement iSize
89474>>>>>>>
89474>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
89477>>>>>>>        Get DriverIndex sDriverID to iDriverIndex
89478>>>>>>>        If (iDriverIndex <> 0) Begin
89480>>>>>>>            Get_Attribute DF_DRIVER_DUMMY_ZERO_DATE_VALUE of iDriverIndex to sDateMin
89483>>>>>>>            If (sDateMin = "") Begin
89485>>>>>>>                Move CS_DUFLowestAllowedDateValue to dDateMin
89486>>>>>>>            End
89486>>>>>>>>
89486>>>>>>>            Else Begin
89487>>>>>>>                If (IsDate(sDateMin)) Begin
89489>>>>>>>                    Move sDateMin to dDateMin
89490>>>>>>>                End
89490>>>>>>>>
89490>>>>>>>                Else Begin
89491>>>>>>>                    Move CS_DUFLowestAllowedDateValue to dDateMin
89492>>>>>>>                End
89492>>>>>>>>
89492>>>>>>>            End
89492>>>>>>>>
89492>>>>>>>        End
89492>>>>>>>>
89492>>>>>>>        Else Begin
89493>>>>>>>            Move CS_DUFLowestAllowedDateValue to dDateMin
89494>>>>>>>        End
89494>>>>>>>>
89494>>>>>>>
89494>>>>>>>        Get_Attribute DF_FILE_RECORDS_USED of hTable to iTotalRecords
89497>>>>>>>        Set piPosition   of ghoProgressBar to 0
89498>>>>>>>        Set piAdvanceBy  of ghoProgressBar to 100
89499>>>>>>>        Set piMaximum    of ghoProgressBar to iTotalRecords
89500>>>>>>>        Move False to Err
89501>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89502>>>>>>>
89502>>>>>>>        Clear hTable
89503>>>>>>>        Repeat
89503>>>>>>>>
89503>>>>>>>            Vfind hTable 0 GT
89505>>>>>>>            Move Found to bFound
89506>>>>>>>            If (bFound = True) Begin
89508>>>>>>>                Move False to bSaveChanges
89509>>>>>>>                Move (ResizeArray(iaChangeField, 0)) to iaChangeField
89510>>>>>>>                Move (SizeOfArray(aDateFields)) to iSize
89511>>>>>>>                Decrement iSize
89512>>>>>>>                For iCount from 0 to iSize
89518>>>>>>>>
89518>>>>>>>                    Move aDateFields[iCount] to iField
89519>>>>>>>                    Get_Field_Value hTable iField to dDate
89522>>>>>>>                    If (bFixZeroDates = True) Begin
89524>>>>>>>                        Move (dDate = 0 or dDate < dDateMin) to bChange
89525>>>>>>>                    End
89525>>>>>>>>
89525>>>>>>>                    Else Begin
89526>>>>>>>                        Move (dDate <> 0 and dDate < dDateMin) to bChange
89527>>>>>>>                    End
89527>>>>>>>>
89527>>>>>>>                    If (bChange = True) Begin
89529>>>>>>>                        Move iField to iaChangeField[SizeOfArray(iaChangeField)]
89530>>>>>>>                    End
89530>>>>>>>>
89530>>>>>>>                Loop
89531>>>>>>>>
89531>>>>>>>
89531>>>>>>>                // Only change Date fields that needs to be changed.
89531>>>>>>>                If (SizeOfArray(iaChangeField)) Begin
89533>>>>>>>                    Reread hTable
89537>>>>>>>                        Move (SizeOfArray(iaChangeField)) to iSize
89538>>>>>>>                        Decrement iSize
89539>>>>>>>                        For iCount from 0 to iSize
89545>>>>>>>>
89545>>>>>>>                            Move iaChangeField[iCount] to iField
89546>>>>>>>                            Set Private.piCurrentField to iField
89547>>>>>>>                            Set_Field_Value hTable iField to dDateMin
89550>>>>>>>                        Loop
89551>>>>>>>>
89551>>>>>>>                        Move False to Err
89552>>>>>>>                        SaveRecord hTable
89553>>>>>>>                    Unlock
89554>>>>>>>>
89554>>>>>>>                End
89554>>>>>>>>
89554>>>>>>>
89554>>>>>>>                Increment iRecord
89555>>>>>>>                // Increment the StatusPanel counter and check the
89555>>>>>>>                // cancel status every 100 records rather than every
89555>>>>>>>                // record, it's way faster.
89555>>>>>>>                If (Mod(iRecord, 100) = 0) Begin
89557>>>>>>>                    Send DoAdvance of ghoProgressBar
89558>>>>>>>                    Set Action_Text of ghoStatusPanel to ("Record:" * String(iRecord))
89559>>>>>>>                    Get Check_StatusPanel of ghoStatusPanel to bCancel
89560>>>>>>>                End
89560>>>>>>>>
89560>>>>>>>            End
89560>>>>>>>>
89560>>>>>>>        Until (bFound = False)
89562>>>>>>>
89562>>>>>>>        Set_Attribute DF_DATE_FORMAT to iDateFormat
89565>>>>>>>        If (bResetIndexesToOnLine = True) Begin
89567>>>>>>>            Send SetAllIndexesToBatch hTable False
89568>>>>>>>        End
89568>>>>>>>>
89568>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
89569>>>>>>>
89569>>>>>>>        Function_Return (Err = False)
89570>>>>>>>    End_Function
89571>>>>>>>
89571>>>>>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
89571>>>>>>>    // Note that it first removes any driver prefixes in the rootname.
89571>>>>>>>    Function UtilTableInfoCompare Boolean bCompareFilelistUppercase tAPITableNameInfoCompare APITableInfoCompare Returns Boolean
89573>>>>>>>        Boolean bIsSame
89573>>>>>>>        String sRootNameFrom sRootNameTo sLogicalNameFrom sLogicalNameTo sDisplayNameFrom sDisplayNameTo
89573>>>>>>>
89573>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sRootNameFrom    to sRootNameFrom
89574>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sRootNameTo      to sRootNameTo
89575>>>>>>>        Move APITableInfoCompare.sLogicalNameFrom               to sLogicalNameFrom
89576>>>>>>>        Move APITableInfoCompare.sLogicalNameTo                 to sLogicalNameTo
89577>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sDisplayNameFrom to sDisplayNameFrom
89578>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sDisplayNameTo   to sDisplayNameTo
89579>>>>>>>
89579>>>>>>>        If (bCompareFilelistUppercase = True) Begin
89581>>>>>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(sLogicalNameFrom) = Uppercase(sLogicalNameTo)) to bIsSame
89582>>>>>>>        End
89582>>>>>>>>
89582>>>>>>>        Else Begin
89583>>>>>>>            Move (sRootNameFrom = sRootNameTo and sLogicalNameFrom = sLogicalNameTo and sDisplayNameFrom = sDisplayNameTo) to bIsSame
89584>>>>>>>        End
89584>>>>>>>>
89584>>>>>>>        If (bIsSame = False) Begin
89586>>>>>>>            Function_Return False
89587>>>>>>>        End
89587>>>>>>>>
89587>>>>>>>
89587>>>>>>>        Move (APITableInfoCompare.bIsAliasFrom = APITableInfoCompare.bIsAliasTo) to bIsSame
89588>>>>>>>        If (bIsSame = False) Begin
89590>>>>>>>            Function_Return False
89591>>>>>>>        End
89591>>>>>>>>
89591>>>>>>>
89591>>>>>>>        Move (APITableInfoCompare.bIsSQLFrom = APITableInfoCompare.bIsSQLTo) to bIsSame
89592>>>>>>>        If (bIsSame = False) Begin
89594>>>>>>>            Function_Return False
89595>>>>>>>        End
89595>>>>>>>>
89595>>>>>>>
89595>>>>>>>        Move (APITableInfoCompare.bIsSystemFileFrom = APITableInfoCompare.bIsSystemFileTo) to bIsSame
89596>>>>>>>        If (bIsSame = False) Begin
89598>>>>>>>            Function_Return False
89599>>>>>>>        End
89599>>>>>>>>
89599>>>>>>>
89599>>>>>>>        Function_Return bIsSame
89600>>>>>>>    End_Function
89601>>>>>>>
89601>>>>>>>    Function UtilTableCompare tAPITable APITableFrom tAPITable APITableTo Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
89603>>>>>>>        Handle hTableFrom hTableTo
89603>>>>>>>        Boolean bIsSame bIsSQLFrom bIsSQLTo
89603>>>>>>>        Boolean bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase
89603>>>>>>>        String sRootName sDriverIDFrom sDriverIDTo
89603>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
89603>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
89604>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
89604>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
89605>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
89605>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
89606>>>>>>>
89606>>>>>>>        Move (IsSameStruct(APITableFrom, APITableTo)) to bIsSame
89607>>>>>>>        If (bIsSame = True) Begin
89609>>>>>>>            Function_Return True
89610>>>>>>>        End
89610>>>>>>>>
89610>>>>>>>
89610>>>>>>>        Move False to bFilelistError
89611>>>>>>>        Move True to bIsSame
89612>>>>>>>        Get pbCompareDate_DateTime  to bCompareDate_DateTime
89613>>>>>>>        Get pbCompareIndexAscending to bCompareIndexAscending
89614>>>>>>>        Get pbCompareIndexUppercase to bCompareIndexUppercase
89615>>>>>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
89616>>>>>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo
89617>>>>>>>
89617>>>>>>>        Move APITableFrom.ApiTableInfo.sRootName to sRootName
89618>>>>>>>        Get _TableNameOnly sRootName             to sRootName
89619>>>>>>>        Move sRootName to APITableTo.ApiTableInfo.sRootName
89620>>>>>>>
89620>>>>>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg is the same).
89620>>>>>>>        // bCodeGenerateMode = True = Code Generation mode.
89620>>>>>>>        If (bCodeGenerateMode = True) Begin
89622>>>>>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
89622>>>>>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
89624>>>>>>>                Function_Return False
89625>>>>>>>            End
89625>>>>>>>>
89625>>>>>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
89626>>>>>>>            If (bIsSame = False) Begin
89628>>>>>>>                Send UserError ("Yikes! There is a serious problem with the Filelist.cfg slot number:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * ".\nThis needs to be fixed before you can generate code for this table number.")
89629>>>>>>>                Move True to bFilelistError
89630>>>>>>>                Function_Return False
89631>>>>>>>            End
89631>>>>>>>>
89631>>>>>>>        End
89631>>>>>>>>
89631>>>>>>>
89631>>>>>>>        If (bCodeGenerateMode = False) Begin
89633>>>>>>>            // Then we want to create this table
89633>>>>>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
89635>>>>>>>                Function_Return False
89636>>>>>>>            End
89636>>>>>>>>
89636>>>>>>>
89636>>>>>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
89637>>>>>>>            If (bIsSame = False) Begin
89639>>>>>>>                Error DFERR_PROGRAM ("'UtilTableCompare function' problem in Filelist.cfg! Table No:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * "No changes was made for this entry.")
89640>>>>>>>>
89640>>>>>>>                Move True to bFilelistError
89641>>>>>>>                Function_Return False
89642>>>>>>>            End
89642>>>>>>>>
89642>>>>>>>        End
89642>>>>>>>>
89642>>>>>>>
89642>>>>>>>        // Check columns:
89642>>>>>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
89643>>>>>>>        Move APITableFrom.ApiTableInfo.bIsSQL       to bIsSQLFrom
89644>>>>>>>        Move APITableFrom.ApiTableInfo.sDriverID    to sDriverIDFrom
89645>>>>>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo
89646>>>>>>>        Move APITableTo.ApiTableInfo.bIsSQL         to bIsSQLTo
89647>>>>>>>        Move APITableTo.ApiTableInfo.sDriverID      to sDriverIDTo
89648>>>>>>>        Get UtilColumnsStructFill hTableTo          to APITableTo.aApiColumns
89649>>>>>>>        Get UtilColumnCombineFromAndToArrays APITableFrom.aApiColumns APITableTo.aApiColumns to aAPIColumnCompare
89650>>>>>>>        Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
89651>>>>>>>        If (bIsSame = False) Begin
89653>>>>>>>            Function_Return False
89654>>>>>>>        End
89654>>>>>>>>
89654>>>>>>>
89654>>>>>>>        // ...then check indexes:
89654>>>>>>>        Get UtilIndexesStructFill hTableFrom to APITableTo.aApiIndexes
89655>>>>>>>        Get UtilIndexCombineFromAndToArrays APITableFrom.aApiIndexes APITableTo.aApiIndexes to aAPIIndexCompare
89656>>>>>>>        Get UtilIndexesCompare bIsSQLFrom bIsSQLTo aAPIIndexCompare bCompareIndexUppercase bCompareIndexAscending to bIsSame
89657>>>>>>>        If (bIsSame = False) Begin
89659>>>>>>>            Function_Return False
89660>>>>>>>        End
89660>>>>>>>>
89660>>>>>>>
89660>>>>>>>        // ...and finally relationships:
89660>>>>>>>        Get UtilRelationsStructFill hTableFrom to APITableTo.aApiRelations
89661>>>>>>>        Get UtilRelationCombineFromAndToArrays APITableFrom.aApiRelations APITableTo.aApiRelations to aAPIRelationCompare
89662>>>>>>>        Move (IsSameArray(APITableFrom.aApiRelations, APITableTo.aApiRelations)) to bIsSame
89663>>>>>>>        Get UtilRelationsCompare hTableFrom aAPIRelationCompare to bIsSame
89664>>>>>>>
89664>>>>>>>        Function_Return (bIsSame = True)
89665>>>>>>>    End_Function
89666>>>>>>>
89666>>>>>>>    // Similar to UtilTableCompare, but takes a tAPITableCompare struct array and a tAPITableBooleans struct as params.
89666>>>>>>>    Function UtilTableCompare_Ex tAPITableCompare APITableCompare tAPITableBooleans CompareTableBooleans Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
89668>>>>>>>        Handle hTable
89668>>>>>>>        Boolean bIsSame bIsSQLFrom bIsSQLTo
89668>>>>>>>        String sRootName sDriverIDFrom sDriverIDTo
89668>>>>>>>
89668>>>>>>>        If (APITableCompare.APITableNameInfoCompare.bExistsFrom = False and APITableCompare.APITableNameInfoCompare.bExistsTo = False) Begin
89670>>>>>>>            Move True to bFilelistError
89671>>>>>>>            Function_Return False
89672>>>>>>>        End
89672>>>>>>>>
89672>>>>>>>
89672>>>>>>>        Move APITableCompare.hTable to hTable
89673>>>>>>>        Move True  to bIsSame
89674>>>>>>>        Move False to bFilelistError
89675>>>>>>>
89675>>>>>>>        If (APITableCompare.bExistsFrom = True) Begin
89677>>>>>>>            Move APITableCompare.APITableNameInfoCompare.sRootNameFrom to sRootName
89678>>>>>>>        End
89678>>>>>>>>
89678>>>>>>>        Else Begin
89679>>>>>>>            Move APITableCompare.APITableNameInfoCompare.sRootNameTo   to sRootName
89680>>>>>>>        End
89680>>>>>>>>
89680>>>>>>>        Get _TableNameOnly sRootName                                   to sRootName
89681>>>>>>>
89681>>>>>>>        Move APITableCompare.APITableNameInfoCompare.sDriverIDFrom     to sDriverIDFrom
89682>>>>>>>        Move APITableCompare.APITableNameInfoCompare.sDriverIDTo       to sDriverIDTo
89683>>>>>>>        Move APITableCompare.APITableNameInfoCompare.bIsSQLFrom        to bIsSQLFrom
89684>>>>>>>        Move APITableCompare.APITableNameInfoCompare.bIsSQLTo          to bIsSQLTo
89685>>>>>>>
89685>>>>>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg are the same).
89685>>>>>>>        // bCodeGenerateMode = True = Code Generation mode.
89685>>>>>>>        If (bCodeGenerateMode = True) Begin
89687>>>>>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
89687>>>>>>>            If (APITableCompare.bExistsTo = False) Begin
89689>>>>>>>                Function_Return False
89690>>>>>>>            End
89690>>>>>>>>
89690>>>>>>>            Move (Uppercase(APITableCompare.APITableNameInfoCompare.sLogicalNameFrom) = Uppercase(APITableCompare.APITableNameInfoCompare.sLogicalNameTo)) to bIsSame
89691>>>>>>>            If (bIsSame = False) Begin
89693>>>>>>>                Send UserError ("Yikes! There is a problem with the Filelist.cfg slot number:" * String(hTable) + ;                    ".\nThe FROM table logical name is:" * String(APITableCompare.APITableNameInfoCompare.sLogicalNameFrom) * "\nwhile the TO table logical name is:" * ;                    String(APITableCompare.APITableNameInfoCompare.sLogicalNameTo) * ".\nThis needs to be fixed before you can generate code for this table number.")
89694>>>>>>>                Move True to bFilelistError
89695>>>>>>>                Function_Return False
89696>>>>>>>            End
89696>>>>>>>>
89696>>>>>>>        End
89696>>>>>>>>
89696>>>>>>>
89696>>>>>>>        If (bCodeGenerateMode = False) Begin
89698>>>>>>>            If (APITableCompare.bExistsTo = False) Begin
89700>>>>>>>                // Then we might want to create this table
89700>>>>>>>                Function_Return False
89701>>>>>>>            End
89701>>>>>>>>
89701>>>>>>>
89701>>>>>>>            Move (APITableCompare.APITableNameInfoCompare.bIsAliasFrom = APITableCompare.APITableNameInfoCompare.bIsAliasTo) to bIsSame
89702>>>>>>>            If (bIsSame = False) Begin
89704>>>>>>>                Function_Return False
89705>>>>>>>            End
89705>>>>>>>>
89705>>>>>>>
89705>>>>>>>            Move (APITableCompare.APITableNameInfoCompare.bIsSQLFrom = APITableCompare.APITableNameInfoCompare.bIsSQLTo) to bIsSame
89706>>>>>>>            If (bIsSame = False) Begin
89708>>>>>>>                Function_Return False
89709>>>>>>>            End
89709>>>>>>>>
89709>>>>>>>
89709>>>>>>>            Move (APITableCompare.APITableNameInfoCompare.bIsSystemFileFrom = APITableCompare.APITableNameInfoCompare.bIsSystemFileTo) to bIsSame
89710>>>>>>>            If (bIsSame = False) Begin
89712>>>>>>>                Function_Return False
89713>>>>>>>            End
89713>>>>>>>>
89713>>>>>>>
89713>>>>>>>            // Check table names et al.
89713>>>>>>>            Get UtilTableInfoCompare CompareTableBooleans.bCompareFilelistUppercase APITableCompare.APITableNameInfoCompare to bIsSame
89714>>>>>>>            If (bIsSame = False) Begin
89716>>>>>>>                Function_Return False
89717>>>>>>>            End
89717>>>>>>>>
89717>>>>>>>        End
89717>>>>>>>>
89717>>>>>>>
89717>>>>>>>        // Check Columns:
89717>>>>>>>        Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo APITableCompare.aAPIColumnsCompare CompareTableBooleans.bCompareDate_DateTime to bIsSame
89718>>>>>>>        If (bIsSame = False) Begin
89720>>>>>>>            Function_Return False
89721>>>>>>>        End
89721>>>>>>>>
89721>>>>>>>
89721>>>>>>>        // ...then check Indexes:
89721>>>>>>>        Get UtilIndexesCompare bIsSQLFrom bIsSQLTo APITableCompare.aAPIIndexesCompare CompareTableBooleans.bCompareIndexUppercase CompareTableBooleans.bCompareIndexAscending to bIsSame
89722>>>>>>>        If (bIsSame = False) Begin
89724>>>>>>>            Function_Return False
89725>>>>>>>        End
89725>>>>>>>>
89725>>>>>>>
89725>>>>>>>        // ...and finally Relationships:
89725>>>>>>>        Get UtilRelationsCompare hTable APITableCompare.aAPIRelationsCompare to bIsSame
89726>>>>>>>
89726>>>>>>>        Function_Return (bIsSame = True)
89727>>>>>>>    End_Function
89728>>>>>>>
89728>>>>>>>    // To fill a complete Table array structure (tAPITable[]) with data.
89728>>>>>>>    // The data + filelist.cfg path, login et al must have been setup properly first.
89728>>>>>>>    // Pass a True as first parameter if the ghoStatusPanel is active and progress info should be shown.
89728>>>>>>>    // Pass a second True if this is a comparison and the text should either reflect "FROM" or "TO" database.
89728>>>>>>>    Function UtilTablesStructArrayFill Boolean bStatusPanel Boolean bCompareUtil Boolean bFromTables Returns tAPITable[]
89730>>>>>>>        tAPITableNameInfo ApiTableNameInfo
89730>>>>>>>        tAPITableNameInfo ApiTableNameInfo
89730>>>>>>>        tAPITable[]     aApiTables aApiTablesEmpty
89730>>>>>>>        tAPITable[]     aApiTables aApiTablesEmpty
89732>>>>>>>        tAPIColumn[]    aApiColumns
89732>>>>>>>        tAPIColumn[]    aApiColumns
89733>>>>>>>        tAPIIndex[]     aApiIndexes
89733>>>>>>>        tAPIIndex[]     aApiIndexes
89734>>>>>>>        tAPIRelation[]  aApiRelations
89734>>>>>>>        tAPIRelation[]  aApiRelations
89735>>>>>>>        Handle hTable
89735>>>>>>>        Integer iCount
89735>>>>>>>        Boolean bUserCancel bOK
89735>>>>>>>        String sLogicalName sMessageText
89735>>>>>>>
89735>>>>>>>        Get AutoConnectionIDLogin to bOK
89736>>>>>>>        Move 0 to hTable
89737>>>>>>>        If (bFromTables = True) Begin
89739>>>>>>>            Move "Reading 'FROM' Table Structure:" to sMessageText
89740>>>>>>>            If (bCompareUtil = True) Begin
89742>>>>>>>                Move (sMessageText * "(1 of 3)") to sMessageText
89743>>>>>>>            End
89743>>>>>>>>
89743>>>>>>>        End
89743>>>>>>>>
89743>>>>>>>        Else Begin
89744>>>>>>>            Move "Reading 'TO' Table Structure:" to sMessageText
89745>>>>>>>            If (bCompareUtil = True) Begin
89747>>>>>>>                Move (sMessageText * "(2 of 3)") to sMessageText
89748>>>>>>>            End
89748>>>>>>>>
89748>>>>>>>        End
89748>>>>>>>>
89748>>>>>>>        Set Message_Text of ghoStatusPanel to sMessageText
89749>>>>>>>
89749>>>>>>>        Get UtilFilelistNoOfTables to iCount
89750>>>>>>>        Set piMaximum of ghoProgressBar to iCount
89751>>>>>>>        Move 0 to iCount
89752>>>>>>>
89752>>>>>>>        Repeat
89752>>>>>>>>
89752>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89755>>>>>>>            If (hTable > 0 and hTable <> 50) Begin
89757>>>>>>>
89757>>>>>>>                Open hTable
89759>>>>>>>                // ToDo: Needs to be revised
89759>>>>>>>                // For some reason tables may be reported as "unopened", while in
89759>>>>>>>                // fact the open was successful (!)
89759>>>>>>>//                Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89759>>>>>>>//                If (bIsOpen = False) Begin
89759>>>>>>>//                    Move True to aApiTablesEmpty[0].bError
89759>>>>>>>//                    Move hTable to aApiTablesEmpty[0].ApiTableInfo.iTableNumber
89759>>>>>>>//                    Function_Return aApiTablesEmpty
89759>>>>>>>//                End
89759>>>>>>>
89759>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
89762>>>>>>>                Set piPosition of ghoProgressBar to iCount
89763>>>>>>>                Send DoAdvance of ghoProgressBarOverall
89764>>>>>>>                Set Action_Text of ghoStatusPanel to ("Number:" * String(hTable) * String(sLogicalName))
89765>>>>>>>
89765>>>>>>>                Get UtilTableStructFill hTable bFromTables to aApiTables[iCount]
89766>>>>>>>//                Close hTable DF_PERMANENT
89766>>>>>>>                Increment iCount
89767>>>>>>>            End
89767>>>>>>>>
89767>>>>>>>
89767>>>>>>>            If (bStatusPanel = True) Begin
89769>>>>>>>                Get Check_StatusPanel of ghoStatusPanel to bUserCancel
89770>>>>>>>                If (bUserCancel = True) Begin
89772>>>>>>>                    Move True to aApiTablesEmpty[0].bCancel
89773>>>>>>>                    Function_Return aApiTablesEmpty
89774>>>>>>>                End
89774>>>>>>>>
89774>>>>>>>            End
89774>>>>>>>>
89774>>>>>>>
89774>>>>>>>        Until (hTable = 0)
89776>>>>>>>
89776>>>>>>>        Function_Return aApiTables
89777>>>>>>>    End_Function
89778>>>>>>>
89778>>>>>>>    // Returns a 'single' table APITable struct.
89778>>>>>>>    Function UtilTableStructFill Handle hTable Boolean bFromTables Returns tAPITable
89780>>>>>>>        tAPITableNameInfo ApiTableNameInfo
89780>>>>>>>        tAPITableNameInfo ApiTableNameInfo
89780>>>>>>>        tAPITable         ApiTable ApiTableEmpty
89780>>>>>>>        tAPITable         ApiTable ApiTableEmpty
89780>>>>>>>        tAPIColumn[]     aApiColumns
89780>>>>>>>        tAPIColumn[]     aApiColumns
89781>>>>>>>        tAPIIndex[]      aApiIndexes
89781>>>>>>>        tAPIIndex[]      aApiIndexes
89782>>>>>>>        tAPIRelation[]   aApiRelations
89782>>>>>>>        tAPIRelation[]   aApiRelations
89783>>>>>>>        Boolean bIsOpen
89783>>>>>>>
89783>>>>>>>        Open hTable
89785>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89788>>>>>>>        If (bIsOpen = False) Begin
89790>>>>>>>            Move True to ApiTableEmpty.bError
89791>>>>>>>            Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
89792>>>>>>>            Function_Return ApiTableEmpty
89793>>>>>>>        End
89793>>>>>>>>
89793>>>>>>>
89793>>>>>>>        // Fill Table Name Info
89793>>>>>>>        Get UtilTableNameInfoStructFill hTable to ApiTableNameInfo
89794>>>>>>>
89794>>>>>>>        // Fill columns
89794>>>>>>>        Get UtilColumnsStructFill hTable to aApiColumns
89795>>>>>>>        If (SizeOfArray(aApiColumns)) Begin
89797>>>>>>>            If (aApiColumns[0].bCancel = True) Begin
89799>>>>>>>                Move True to ApiTableEmpty.bError
89800>>>>>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
89801>>>>>>>                Function_Return ApiTableEmpty
89802>>>>>>>            End
89802>>>>>>>>
89802>>>>>>>        End
89802>>>>>>>>
89802>>>>>>>
89802>>>>>>>        // Fill indexes
89802>>>>>>>        Get UtilIndexesStructFill hTable to aApiIndexes
89803>>>>>>>        If (SizeOfArray(aApiIndexes)) Begin
89805>>>>>>>            If (aApiIndexes[0].bCancel = True) Begin
89807>>>>>>>                Move True to ApiTableEmpty.bError
89808>>>>>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
89809>>>>>>>                Function_Return ApiTableEmpty
89810>>>>>>>            End
89810>>>>>>>>
89810>>>>>>>        End
89810>>>>>>>>
89810>>>>>>>
89810>>>>>>>        // Fill relationships
89810>>>>>>>        Get UtilRelationsStructFill hTable to aApiRelations
89811>>>>>>>        If (SizeOfArray(aApiRelations)) Begin
89813>>>>>>>            If (aApiRelations[0].bCancel = True) Begin
89815>>>>>>>                Move True to ApiTableEmpty.bError
89816>>>>>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
89817>>>>>>>                Function_Return ApiTableEmpty
89818>>>>>>>            End
89818>>>>>>>>
89818>>>>>>>        End
89818>>>>>>>>
89818>>>>>>>
89818>>>>>>>        Move hTable             to ApiTable.hTable
89819>>>>>>>        Move bFromTables        to ApiTable.bFromTable
89820>>>>>>>        Move (not(bFromTables)) to ApiTable.bToTable
89821>>>>>>>
89821>>>>>>>        Move ApiTableNameInfo   to ApiTable.ApiTableInfo
89822>>>>>>>        Move aApiColumns        to ApiTable.aApiColumns
89823>>>>>>>        Move aApiIndexes        to ApiTable.aApiIndexes
89824>>>>>>>        Move aApiRelations      to ApiTable.aApiRelations
89825>>>>>>>
89825>>>>>>>        Function_Return ApiTable
89826>>>>>>>    End_Function
89827>>>>>>>
89827>>>>>>>    Function UtilTableNameInfoStructFill Handle hTable Returns tAPITableNameInfo
89829>>>>>>>        tAPITableNameInfo APITableNameInfo APITableNameInfoEmpty
89829>>>>>>>        tAPITableNameInfo APITableNameInfo APITableNameInfoEmpty
89829>>>>>>>        Boolean bIsOpen
89829>>>>>>>
89829>>>>>>>        Open hTable
89831>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89834>>>>>>>        If (bIsOpen = False) Begin
89836>>>>>>>            Move True   to APITableNameInfoEmpty.bError
89837>>>>>>>            Move hTable to APITableNameInfoEmpty.iTableNumber
89838>>>>>>>            Function_Return APITableNameInfoEmpty
89839>>>>>>>        End
89839>>>>>>>>
89839>>>>>>>
89839>>>>>>>        Move hTable                                  to APITableNameInfo.iTableNumber
89840>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to APITableNameInfo.sRootName
89843>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to APITableNameInfo.sLogicalName
89846>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to APITableNameInfo.sDisplayName
89849>>>>>>>        Get_Attribute DF_FILE_DRIVER       of hTable to APITableNameInfo.sDriverID
89852>>>>>>>
89852>>>>>>>        Get UtilTableIsAlias                  hTable to APITableNameInfo.bIsAlias
89853>>>>>>>        Get _UtilTableIsSql                    hTable to APITableNameInfo.bIsSQL
89854>>>>>>>
89854>>>>>>>        Function_Return APITableNameInfo
89855>>>>>>>    End_Function
89856>>>>>>>
89856>>>>>>>    Function UtilFindTableArrayItem tAPITable[] ByRef aTableStructure String sLogicalTableName Returns Integer
89858>>>>>>>        Integer iSize iCount iItem
89858>>>>>>>        tAPITableNameInfo ApiTableNameInfo
89858>>>>>>>        tAPITableNameInfo ApiTableNameInfo
89858>>>>>>>
89858>>>>>>>        Move -1 to iItem
89859>>>>>>>        Move (SizeOfArray(aTableStructure)) to iSize
89860>>>>>>>        Decrement iSize
89861>>>>>>>        for iCount from 0 to iSize
89867>>>>>>>>
89867>>>>>>>            Move aTableStructure[iCount].ApiTableInfo to ApiTableNameInfo
89868>>>>>>>            If (Uppercase(ApiTableNameInfo.sLogicalName) = Uppercase(sLogicalTableName)) Begin
89870>>>>>>>                Move iCount to iItem
89871>>>>>>>                Move iSize  to iCount // We're done.
89872>>>>>>>            End
89872>>>>>>>>
89872>>>>>>>        Loop
89873>>>>>>>>
89873>>>>>>>
89873>>>>>>>        Function_Return iItem
89874>>>>>>>    End_Function
89875>>>>>>>
89875>>>>>>>    Function UtilTableArrayCompare tAPITable APITableFrom tAPITable APITableTo Returns Integer
89877>>>>>>>        If (APITableFrom.hTable  > APITableTo.hTable) ;            Function_Return (GT)
89880>>>>>>>        If (APITableFrom.hTable  < APITableTo.hTable) ;            Function_Return (LT)
89883>>>>>>>
89883>>>>>>>        If (APITableFrom.bFromTable = True)  ;            Function_Return (LT)
89886>>>>>>>        If (APITableFrom.bFromTable = False) ;            Function_Return (GT)
89889>>>>>>>
89889>>>>>>>        Function_Return (EQ)
89890>>>>>>>    End_Function
89891>>>>>>>
89891>>>>>>>    Function UtilTableCombineFromAndToArrays tAPITable[] aAPITableFrom tAPITable[] aAPITableTo Returns tAPITableCompare[]
89893>>>>>>>        Integer iCount iSize iSizeFrom iSizeTo iItemFrom iItemTo iItem
89893>>>>>>>        Handle hTable
89893>>>>>>>        tAPITable[] aAPITableFromAndTo
89893>>>>>>>        tAPITable[] aAPITableFromAndTo
89894>>>>>>>        tAPITable   APITableFrom APITableTo APITableEmpty
89894>>>>>>>        tAPITable   APITableFrom APITableTo APITableEmpty
89894>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
89894>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
89894>>>>>>>        tAPITableCompare[]    aAPITableCompare // This is the result set for this function
89894>>>>>>>        tAPITableCompare[]    aAPITableCompare // This is the result set for this function
89895>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
89895>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
89896>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
89896>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
89897>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
89897>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
89898>>>>>>>        tAPITableNameInfo ApiTableInfoEmpty ApiTableInfoFrom ApiTableInfoTo
89898>>>>>>>        tAPITableNameInfo ApiTableInfoEmpty ApiTableInfoFrom ApiTableInfoTo
89898>>>>>>>        tAPIColumn[]   aApiColumnsEmpty aApiColumnsFrom aApiColumnsTo
89898>>>>>>>        tAPIColumn[]   aApiColumnsEmpty aApiColumnsFrom aApiColumnsTo
89901>>>>>>>        tAPIIndex[]    aApiIndexEmpty aApiIndexFrom aApiIndexTo
89901>>>>>>>        tAPIIndex[]    aApiIndexEmpty aApiIndexFrom aApiIndexTo
89904>>>>>>>        tAPIRelation[] aApiRelationEmpty aApiRelationFrom aApiRelationTo
89904>>>>>>>        tAPIRelation[] aApiRelationEmpty aApiRelationFrom aApiRelationTo
89907>>>>>>>
89907>>>>>>>        Move (SizeOfArray(aAPITableFrom)) to iSizeFrom
89908>>>>>>>        Move (SizeOfArray(aAPITableTo))   to iSizeTo
89909>>>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
89911>>>>>>>            Function_Return aAPITableCompare
89912>>>>>>>        End
89912>>>>>>>>
89912>>>>>>>
89912>>>>>>>        Move (AppendArray(aAPITableFrom, aAPITableTo)) to aAPITableFromAndTo
89913>>>>>>>        Move (SortArray(aAPITableFromAndTo, Self, RefFunc(UtilTableArrayCompare))) to aAPITableFromAndTo
89914>>>>>>>
89914>>>>>>>        Move 0 to iItem
89915>>>>>>>        Move (SizeOfArray(aAPITableFromAndTo)) to iSize
89916>>>>>>>        Decrement iSize
89917>>>>>>>        for iCount from 0 to iSize
89923>>>>>>>>
89923>>>>>>>
89923>>>>>>>            Move iCount to iItemFrom
89924>>>>>>>            Move iCount to iItemTo
89925>>>>>>>            Move APITableEmpty to APITableFrom
89926>>>>>>>            Move APITableEmpty to APITableTo
89927>>>>>>>
89927>>>>>>>            If (aAPITableFromAndTo[iCount].bFromTable = True) Begin
89929>>>>>>>                Move aAPITableFromAndTo[iCount]     to APITableFrom
89930>>>>>>>            End
89930>>>>>>>>
89930>>>>>>>            If (aAPITableFromAndTo[iCount].bToTable = True) Begin
89932>>>>>>>                Move aAPITableFromAndTo[iCount]     to APITableTo
89933>>>>>>>            End
89933>>>>>>>>
89933>>>>>>>            If (aAPITableFromAndTo[iCount].hTable = aAPITableFromAndTo[iCount + 1].hTable) Begin
89935>>>>>>>                Move aAPITableFromAndTo[iCount]     to APITableFrom
89936>>>>>>>                Move (iCount + 1) to iItemTo
89937>>>>>>>                Move aAPITableFromAndTo[iItemTo]    to APITableTo
89938>>>>>>>            End
89938>>>>>>>>
89938>>>>>>>            If (APITableFrom.hTable > APITableTo.hTable) Begin
89940>>>>>>>                Get FindTableNumber aAPITableTo APITableFrom.hTable to iItemTo
89941>>>>>>>                If (iItemTo <> -1) Begin
89943>>>>>>>                    Move aAPITableTo[iItemTo] to APITableTo
89944>>>>>>>                End
89944>>>>>>>>
89944>>>>>>>                Else Begin
89945>>>>>>>                    Move APITableEmpty to APITableTo
89946>>>>>>>                End
89946>>>>>>>>
89946>>>>>>>            End
89946>>>>>>>>
89946>>>>>>>
89946>>>>>>>            Move APITableFrom.ApiTableInfo  to ApiTableInfoFrom
89947>>>>>>>            Move APITableFrom.aApiColumns   to aApiColumnsFrom
89948>>>>>>>            Move APITableFrom.aApiIndexes   to aApiIndexFrom
89949>>>>>>>            Move APITableFrom.aApiRelations to aApiRelationFrom
89950>>>>>>>
89950>>>>>>>            Move APITableTo.ApiTableInfo    to ApiTableInfoTo
89951>>>>>>>            Move APITableTo.aApiColumns     to aApiColumnsTo
89952>>>>>>>            Move APITableTo.aApiIndexes     to aApiIndexTo
89953>>>>>>>            Move APITableTo.aApiRelations   to aApiRelationTo
89954>>>>>>>
89954>>>>>>>            Move aAPITableFromAndTo[iCount].hTable to hTable
89955>>>>>>>
89955>>>>>>>            If (hTable > 0) Begin
89957>>>>>>>
89957>>>>>>>                // Table info:
89957>>>>>>>                Get UtilTableINFOCombineFromAndToArrays ApiTableInfoFrom ApiTableInfoTo to APITableNameInfoCompare
89958>>>>>>>                Move APITableNameInfoCompare.iTableNumber                               to aAPITableCompare[iItem].hTable
89959>>>>>>>                Move APITableNameInfoCompare.bExistsFrom                                to aAPITableCompare[iItem].bExistsFrom
89960>>>>>>>                Move APITableNameInfoCompare.bExistsTo                                  to aAPITableCompare[iItem].bExistsTo
89961>>>>>>>                Move APITableNameInfoCompare                                            to aAPITableCompare[iItem].APITableNameInfoCompare
89962>>>>>>>
89962>>>>>>>                // Column info:
89962>>>>>>>                Get UtilColumnCombineFromAndToArrays aApiColumnsFrom aApiColumnsTo      to aAPIColumnCompare
89963>>>>>>>                Move aAPIColumnCompare                                                  to aAPITableCompare[iItem].aAPIColumnsCompare
89964>>>>>>>
89964>>>>>>>                // Index info:
89964>>>>>>>                Get UtilIndexCombineFromAndToArrays aApiIndexFrom aApiIndexTo           to aAPIIndexCompare
89965>>>>>>>                Move aAPIIndexCompare                                                   to aAPITableCompare[iItem].aAPIIndexesCompare
89966>>>>>>>
89966>>>>>>>                // Relation info:
89966>>>>>>>                Get UtilRelationCombineFromAndToArrays aApiRelationFrom aApiRelationTo  to aAPIRelationCompare
89967>>>>>>>                Move aAPIRelationCompare                                                to aAPITableCompare[iItem].aAPIRelationsCompare
89968>>>>>>>
89968>>>>>>>                Move False                                                              to aAPITableCompare[iItem].bShouldChange
89969>>>>>>>                Move False                                                              to aAPITableCompare[iItem].bCancel
89970>>>>>>>                Move False                                                              to aAPITableCompare[iItem].bError
89971>>>>>>>                If (iItemTo > iItemFrom) Begin
89973>>>>>>>                    Increment iCount
89974>>>>>>>                End
89974>>>>>>>>
89974>>>>>>>                Increment iItem
89975>>>>>>>            End
89975>>>>>>>>
89975>>>>>>>
89975>>>>>>>        Loop
89976>>>>>>>>
89976>>>>>>>
89976>>>>>>>        Function_Return aAPITableCompare
89977>>>>>>>    End_Function
89978>>>>>>>
89978>>>>>>>    Function FindTableNumber tAPITable[] ByRef aTableStructure Handle hTable Returns Integer
89980>>>>>>>        Integer iSize iCount iItem
89980>>>>>>>        tAPITableNameInfo ApiTableNameInfo
89980>>>>>>>        tAPITableNameInfo ApiTableNameInfo
89980>>>>>>>
89980>>>>>>>        Move -1 to iItem
89981>>>>>>>        Move (SizeOfArray(aTableStructure)) to iSize
89982>>>>>>>        Decrement iSize
89983>>>>>>>        For iCount from 0 to iSize
89989>>>>>>>>
89989>>>>>>>            Move aTableStructure[iCount].ApiTableInfo to ApiTableNameInfo
89990>>>>>>>            If (ApiTableNameInfo.iTableNumber = hTable) Begin
89992>>>>>>>                Move iCount to iItem
89993>>>>>>>                Move iSize  to iCount // We're done.
89994>>>>>>>            End
89994>>>>>>>>
89994>>>>>>>        Loop
89995>>>>>>>>
89995>>>>>>>
89995>>>>>>>        Function_Return iItem
89996>>>>>>>    End_Function
89997>>>>>>>
89997>>>>>>>    Function UtilTableInfoCombineFromAndToArrays tAPITableNameInfo APITableNameInfoFrom tAPITableNameInfo APITableNameInfoTo Returns tAPITableNameInfoCompare
89999>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
89999>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
89999>>>>>>>
89999>>>>>>>        If (APITableNameInfoFrom.iTableNumber = 0 and APITableNameInfoTo.iTableNumber = 0) Begin
90001>>>>>>>            Function_Return APITableNameInfoCompare
90002>>>>>>>        End
90002>>>>>>>>
90002>>>>>>>
90002>>>>>>>        // FROM database info:
90002>>>>>>>        If (APITableNameInfoFrom.iTableNumber > 0) Begin
90004>>>>>>>            Move APITableNameInfoFrom.iTableNumber  to APITableNameInfoCompare.iTableNumber
90005>>>>>>>            Move APITableNameInfoFrom.sRootName     to APITableNameInfoCompare.sRootNameFrom
90006>>>>>>>            Move APITableNameInfoFrom.sLogicalName  to APITableNameInfoCompare.sLogicalNameFrom
90007>>>>>>>            Move APITableNameInfoFrom.sDisplayName  to APITableNameInfoCompare.sDisplayNameFrom
90008>>>>>>>            Move APITableNameInfoFrom.sDriverID     to APITableNameInfoCompare.sDriverIDFrom
90009>>>>>>>            Move APITableNameInfoFrom.bIsAlias      to APITableNameInfoCompare.bIsAliasFrom
90010>>>>>>>            Move APITableNameInfoFrom.bIsSQL        to APITableNameInfoCompare.bIsSQLFrom
90011>>>>>>>            Move True                               to APITableNameInfoCompare.bExistsFrom
90012>>>>>>>        End
90012>>>>>>>>
90012>>>>>>>
90012>>>>>>>        // TO database info:
90012>>>>>>>        If (APITableNameInfoTo.iTableNumber > 0) Begin
90014>>>>>>>            Move APITableNameInfoTo.iTableNumber    to APITableNameInfoCompare.iTableNumber
90015>>>>>>>            Move APITableNameInfoTo.sRootName       to APITableNameInfoCompare.sRootNameTo
90016>>>>>>>            Move APITableNameInfoTo.sLogicalName    to APITableNameInfoCompare.sLogicalNameTo
90017>>>>>>>            Move APITableNameInfoTo.sDisplayName    to APITableNameInfoCompare.sDisplayNameTo
90018>>>>>>>            Move APITableNameInfoTo.sDriverID       to APITableNameInfoCompare.sDriverIDTo
90019>>>>>>>            Move APITableNameInfoTo.bIsAlias        to APITableNameInfoCompare.bIsAliasTo
90020>>>>>>>            Move APITableNameInfoTo.bIsSQL          to APITableNameInfoCompare.bIsSQLTo
90021>>>>>>>            Move True                               to APITableNameInfoCompare.bExistsTo
90022>>>>>>>        End
90022>>>>>>>>
90022>>>>>>>
90022>>>>>>>        Function_Return APITableNameInfoCompare
90023>>>>>>>    End_Function
90024>>>>>>>
90024>>>>>>>    // Note:
90024>>>>>>>    // The DF_FILE_TABLE_NAME attribute holds the name of the table at the back end. Depending on the back end, table
90024>>>>>>>    // names may be case sensitive, contain spaces or other special characters. This attribute is used to determine a table's
90024>>>>>>>    // back end name when using Embedded SQL. Since Embedded SQL works on the back end directly, the back end's name must be used.
90024>>>>>>>    // In most cases the back end name will be the same as the table name used in DataFlex.
90024>>>>>>>    // To do the opposite; To get the file handle from a table name string use the UtilTableNameToHandle function.
90024>>>>>>>    Function UtilTableHandleToString Handle hTable Returns String
90026>>>>>>>        String sTableName
90026>>>>>>>        Boolean bOpen bExists bOK
90026>>>>>>>
90026>>>>>>>        Get _UtilTableNumberIsInUse hTable to bExists
90027>>>>>>>        If (bExists = False) Begin
90029>>>>>>>            Function_Return ""
90030>>>>>>>        End
90030>>>>>>>>
90030>>>>>>>
90030>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90031>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
90034>>>>>>>        If (bOpen = False) Begin
90036>>>>>>>            Get AutoConnectionIDLogin to bOK
90037>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90038>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
90039>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
90040>>>>>>>            Open hTable
90042>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90043>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
90044>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
90045>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
90048>>>>>>>        End
90048>>>>>>>>
90048>>>>>>>        If (bOpen = True) Begin
90050>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
90051>>>>>>>            Get_Attribute DF_FILE_TABLE_NAME of hTable to sTableName
90054>>>>>>>            // If blank it is an embedded table:
90054>>>>>>>            If (sTableName = "") Begin
90056>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
90059>>>>>>>                Move 0 to LastErr
90060>>>>>>>                Move False to Err
90061>>>>>>>            End
90061>>>>>>>>
90061>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
90062>>>>>>>        End
90062>>>>>>>>
90062>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90063>>>>>>>        Move 0 to LastErr
90064>>>>>>>
90064>>>>>>>        Function_Return sTableName
90065>>>>>>>    End_Function
90066>>>>>>>
90066>>>>>>>    // Returns the filenumber for the passed Table name from Filelist.cfg.
90066>>>>>>>    // Returns 0 if unsuccessful.
90066>>>>>>>    // To do the opposite; To get the string value from a table handle string use the UtilTableHandleToString function.
90066>>>>>>>    Function UtilTableNameToHandle String sTableName Returns Integer
90068>>>>>>>        String sValue sPrefixTableName sDriverID
90068>>>>>>>        Handle hTable hRetval
90068>>>>>>>
90068>>>>>>>        Get psDriverID to sDriverID
90069>>>>>>>        If (sDriverID <> DATAFLEX_ID and not(sTableName contains ":")) Begin
90071>>>>>>>            Move (sDriverID + ":" + sTableName) to sPrefixTableName
90072>>>>>>>        End
90072>>>>>>>>
90072>>>>>>>        Move 0 to hTable
90073>>>>>>>        Move 0 to hRetval
90074>>>>>>>        Repeat
90074>>>>>>>>
90074>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
90077>>>>>>>            If (hTable <> 0) Begin
90079>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sValue
90082>>>>>>>                If (Uppercase(sValue) = Uppercase(sTableName) or Uppercase(sValue) = Uppercase(sPrefixTableName)) Begin
90084>>>>>>>                    Move hTable to hRetval
90085>>>>>>>                    Move 0 to hTable
90086>>>>>>>                End
90086>>>>>>>>
90086>>>>>>>            End
90086>>>>>>>>
90086>>>>>>>        Until (hTable = 0)
90088>>>>>>>
90088>>>>>>>        Function_Return hRetval
90089>>>>>>>    End_Function
90090>>>>>>>
90090>>>>>>>    // Use function to move all *.dat, *.k?? & *.hdr files to a "Data\Backup" folder
90090>>>>>>>    // _after_ all tables have successfully been converted to SQL (.int files)
90090>>>>>>>    Function UtilMoveAllEmbeddedToBackupFolder Returns Boolean
90092>>>>>>>        Boolean bOK bExists
90092>>>>>>>        String sDataPath sBackupFolder
90092>>>>>>>
90092>>>>>>>        Close DF_ALL DF_PERMANENT
90093>>>>>>>        Send DoAdvance of ghoProgressBar
90094>>>>>>>
90094>>>>>>>        Set Message_Text of ghoStatusPanel to "Moving Embedded (*.dat) files to Backup folder."
90095>>>>>>>        Move CS_DUFBackupDataFolder to sBackupFolder
90096>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
90097>>>>>>>        Get vFolderFormat sDataPath to sDataPath
90098>>>>>>>
90098>>>>>>>        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
90099>>>>>>>        If (bExists = False) Begin
90101>>>>>>>            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
90102>>>>>>>            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
90103>>>>>>>            If (bExists = False) Begin
90105>>>>>>>                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all *.dat and *.k?? files to. You need to move them somewhere manually.")
90106>>>>>>>>
90106>>>>>>>                Function_Return False
90107>>>>>>>            End
90107>>>>>>>>
90107>>>>>>>        End
90107>>>>>>>>
90107>>>>>>>
90107>>>>>>>        Get vMoveFile (sDataPath + "*.dat") (sDataPath + sBackupFolder) to bOK
90108>>>>>>>        Get vMoveFile (sDataPath + "*.hdr") (sDataPath + sBackupFolder) to bOK
90109>>>>>>>        Get vMoveFile (sDataPath + "*.k??") (sDataPath + sBackupFolder) to bOK
90110>>>>>>>        Get vMoveFile (sDataPath + "*.vld") (sDataPath + sBackupFolder) to bOK
90111>>>>>>>        // We need to wait for Windows before we can copy files back
90111>>>>>>>        Sleep 2  
90112>>>>>>>        
90112>>>>>>>        //...except for these files that needs to be copied back to the Data folder:
90112>>>>>>>        Get vCopyFile (sBackupFolder + "\CodeMast.*")  sDataPath to bOK 
90113>>>>>>>        Get vCopyFile (sBackupFolder + "\CodeType.*")  sDataPath to bOK                                 
90114>>>>>>>        Get vCopyFile (sBackupFolder + "\Flexerrs.*")  sDataPath to bOK                                 
90115>>>>>>>        Get vCopyFile (sBackupFolder + "\DFErr001.*")  sDataPath to bOK                                 
90116>>>>>>>        Get vCopyFile (sBackupFolder + "\DFErr002.*")  sDataPath to bOK                                 
90117>>>>>>>        Get vCopyFile (sBackupFolder + "\DFErr003.*")  sDataPath to bOK                                 
90118>>>>>>>//            Get vCopyFile (sBackupFolder + "\DbVersion.*") sDataPath to bOK  
90118>>>>>>>        
90118>>>>>>>
90118>>>>>>>        Set Message_Text of ghoStatusPanel to ""
90119>>>>>>>        Function_Return True
90120>>>>>>>    End_Function
90121>>>>>>>    
90121>>>>>>>    Function UtilTableRepairAndReindexALL Returns Boolean
90123>>>>>>>        Boolean bOK bRetval
90123>>>>>>>        Handle hTable
90123>>>>>>>        Integer iSize iCount
90123>>>>>>>        
90123>>>>>>>        Move True to bOK
90124>>>>>>>        Get UtilFilelistNoOfTables to iSize
90125>>>>>>>        Set pbVisible    of ghoProgressBarOverall to True
90126>>>>>>>        Set piPosition   of ghoProgressBarOverall to 0
90127>>>>>>>        Set piMaximum    of ghoProgressBarOverall to iSize
90128>>>>>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
90129>>>>>>>
90129>>>>>>>        Repeat
90129>>>>>>>>
90129>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount
90130>>>>>>>            Increment iCount
90131>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
90134>>>>>>>            If (hTable <> 0 and hTable <> 50) Begin // 50 = Flexerrs.
90136>>>>>>>                Get UtilTableRepairAndReindex hTable to bRetval
90137>>>>>>>                If (bRetval = False) Begin
90139>>>>>>>                    Move False to bOK
90140>>>>>>>                End
90140>>>>>>>>
90140>>>>>>>            End
90140>>>>>>>>
90140>>>>>>>        Until (hTable = 0)
90142>>>>>>>                
90142>>>>>>>        Function_Return bOK
90143>>>>>>>    End_Function           
90144>>>>>>>    
90144>>>>>>>    // Checks if an Embedded (DataFlex) data-file needs to be repaired.
90144>>>>>>>    // After the header has been repaired - also makes a re-index.  
90144>>>>>>>    // Returns TRUE if successful OR the table was an an ALIAS or SQL table in case we do nothing.
90144>>>>>>>    Function UtilTableRepairAndReindex Handle hTable Returns Boolean
90146>>>>>>>        Boolean bOK bIsAlias bIsEmbedded bIsOpen bBadExists
90146>>>>>>>        Integer iRetval
90146>>>>>>>        String sRootName sFileName sDataPath
90146>>>>>>>        
90146>>>>>>>        Move False to Err
90147>>>>>>>        Move 0 to LastErr 
90148>>>>>>>        Move True to bOK
90149>>>>>>>        
90149>>>>>>>        Get _UtilTableIsEmbedded hTable to bIsEmbedded
90150>>>>>>>        If (bIsEmbedded = False or hTable = 50) Begin // 50 = Flexerrs
90152>>>>>>>            Function_Return True
90153>>>>>>>        End
90153>>>>>>>>
90153>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias 
90154>>>>>>>        If (bIsAlias = True) Begin
90156>>>>>>>            Function_Return True
90157>>>>>>>        End
90157>>>>>>>>
90157>>>>>>>        
90157>>>>>>>        // Check for bad file and remove if exists
90157>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
90160>>>>>>>        Set private.phCurrentTable to hTable  
90161>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT  
90162>>>>>>>        
90162>>>>>>>        // This is important! Else it can happen that the table can't be opened,
90162>>>>>>>        // with a "4077 - File in use" error.
90162>>>>>>>        Close DF_ALL DF_PERMANENT    
90163>>>>>>>        Open hTable
90165>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90168>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90169>>>>>>>        If (bIsOpen = False) Begin
90171>>>>>>>            Error DFERR_PROGRAM ("Could not open table to be repaired and reindexed:" * String(sRootName))
90172>>>>>>>>
90172>>>>>>>            Function_Return False        
90173>>>>>>>        End
90173>>>>>>>>
90173>>>>>>>
90173>>>>>>>        Get vFilePathExists (sRootName + ".BAD")  to bBadExists
90174>>>>>>>        If (bBadExists = True) Begin
90176>>>>>>>            Get_File_Path (sRootName + ".BAD") to sFileName
90177>>>>>>>            Get vDeleteFile sFileName to iRetval
90178>>>>>>>        End
90178>>>>>>>>
90178>>>>>>>        
90178>>>>>>>        Set TableName_Text of ghoStatusPanel to ("Repairing and reindex Table Name:" * sRootName * "Number:" * String(hTable))
90179>>>>>>>        
90179>>>>>>>        Move False to Err
90180>>>>>>>        // **** Repair and reindex the table. ****
90180>>>>>>>        Get UtilTableRepairEmbedded hTable sRootName to bOK
90181>>>>>>>
90181>>>>>>>        // Check for bad file: if it exists, something went wrong
90181>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
90182>>>>>>>        Get vFolderFormat sDataPath to sDataPath
90183>>>>>>>        Get vFilePathExists (sDataPath + sRootName + ".BAD") to bBadExists
90184>>>>>>>        If (bBadExists = True) Begin
90186>>>>>>>            Error DFERR_PROGRAM ("Error while sorting data. .BAD file created:"  * String(sRootName) + ".BAD")
90187>>>>>>>>
90187>>>>>>>            Move False to bOK
90188>>>>>>>        End
90188>>>>>>>>
90188>>>>>>>        Close hTable
90189>>>>>>>
90189>>>>>>>        Function_Return bOK
90190>>>>>>>    End_Function
90191>>>>>>>
90191>>>>>>>    // Repair and reindex the named DataFlex data-table.
90191>>>>>>>    // No checks are done if the passed table name is an embedded or SQL,
90191>>>>>>>    // so use with care (make sure you only pass embedded table names).
90191>>>>>>>    Function UtilTableRepairEmbedded Handle hTable String sTableName Returns Boolean
90193>>>>>>>        String sMode
90193>>>>>>>        Integer iVoid
90193>>>>>>>
90193>>>>>>>        Set Message_Text of ghoStatusPanel to "Repair/Reindex in progress..."
90194>>>>>>>        Move "0" to sMode   // 0=Reindex after repair!    
90195>>>>>>>        Close hTable        // The table needs to be closed, else error 4177 "Table in use".
90196>>>>>>>        Call_Driver 0 DATAFLEX_ID Function FLEX_REPAIR_FILE Callback ghoDbUpdateHandler Passing sTableName sMode 0 Result iVoid 
90201>>>>>>>        Set Message_Text of ghoStatusPanel to ""
90202>>>>>>>        Function_Return (iVoid = 0)
90203>>>>>>>    End_Function
90204>>>>>>>
90204>>>>>>>    // Returns _two_ arrays.
90204>>>>>>>    // Returns all files that are Master files in array ByRef iaFileIsMaster
90204>>>>>>>    // Also returns all files that are Alias files in a second array.
90204>>>>>>>    // IMPORTANT: All master & alias files _must_ have been included into
90204>>>>>>>    //            the DoSetAllMasterAndAlias message.
90204>>>>>>>    Function UtilTableAllMasterAndAliasFiles Integer[] ByRef iaFileIsMaster Returns Integer[]
90206>>>>>>>        Integer[] iaFileIsAlias
90207>>>>>>>        Integer hTable iFileAlias iSize
90207>>>>>>>        Boolean bOpen
90207>>>>>>>
90207>>>>>>>        Move 0 to hTable
90208>>>>>>>        Repeat
90208>>>>>>>>
90208>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
90211>>>>>>>            If (hTable <> 0) Begin
90213>>>>>>>                Open hTable
90215>>>>>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
90218>>>>>>>                If (bOpen = True) Begin
90220>>>>>>>                    Get_Attribute DF_FILE_ALIAS of hTable to iFileAlias
90223>>>>>>>                    If (iFileAlias = DF_FILE_IS_MASTER) Begin
90225>>>>>>>                        Move (SizeOfArray(iaFileIsMaster)) to iSize
90226>>>>>>>                        Move hTable to iaFileIsMaster[iSize]
90227>>>>>>>                    End
90227>>>>>>>>
90227>>>>>>>                    Else If (iFileAlias = DF_FILE_IS_ALIAS) Begin
90230>>>>>>>                        Move (SizeOfArray(iaFileIsAlias)) to iSize
90231>>>>>>>                        Move hTable to iaFileIsAlias[iSize]
90232>>>>>>>                    End
90232>>>>>>>>
90232>>>>>>>                End
90232>>>>>>>>
90232>>>>>>>            End
90232>>>>>>>>
90232>>>>>>>        Until (hTable = 0)
90234>>>>>>>
90234>>>>>>>        Function_Return iaFileIsAlias
90235>>>>>>>    End_Function  
90236>>>>>>>    
90236>>>>>>>    // Is a repair of the data-header necessary? (Embedded tables only)
90236>>>>>>>    Function UtilTableRepairIsNeeded Handle hTable String sTableName Returns Integer
90238>>>>>>>        String sMode
90238>>>>>>>        Integer iRepairNeeded bIsOpen
90238>>>>>>>
90238>>>>>>>        Move "0" to sMode
90239>>>>>>>        Set private.phCurrentTable to hTable 
90240>>>>>>>        Close hTable
90241>>>>>>>        Open hTable
90243>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90246>>>>>>>        Call_Driver hTable DATAFLEX_ID Function FLEX_GET_REPAIRS_NEEDED Callback 0 Passing sTableName sMode 0 Result iRepairNeeded
90251>>>>>>>
90251>>>>>>>        Function_Return iRepairNeeded
90252>>>>>>>    End_Function
90253>>>>>>>
90253>>>>>>>    // Helper function
90253>>>>>>>    // Takes two params:
90253>>>>>>>    //   1. An array with all master table numbers  (Function UtilTableAllMasterAndAliasFiles)
90253>>>>>>>    //   2. An array with all alias table numbers   (Function UtilTableAllMasterAndAliasFiles)
90253>>>>>>>    // Returns:
90253>>>>>>>    //  DF_FILE_ALIAS_DEFAULT if no master or alias
90253>>>>>>>    //  DF_FILE_IS_MASTER if master
90253>>>>>>>    //  DF_FILE_IS_ALIAS if alias
90253>>>>>>>    Function UtilTableIsMasterAlias Handle hTable Integer[] iaFileIsMaster Integer[] iaFileIsAlias Returns Integer
90255>>>>>>>        Integer i iSize
90255>>>>>>>
90255>>>>>>>        Move (SizeOfArray(iaFileIsMaster)) to iSize
90256>>>>>>>        Decrement iSize
90257>>>>>>>        for i from 0 to iSize
90263>>>>>>>>
90263>>>>>>>            If (hTable = iaFileIsMaster[i]) Begin
90265>>>>>>>                Function_Return DF_FILE_IS_MASTER
90266>>>>>>>            End
90266>>>>>>>>
90266>>>>>>>        Loop
90267>>>>>>>>
90267>>>>>>>
90267>>>>>>>        Move (SizeOfArray(iaFileIsAlias)) to iSize
90268>>>>>>>        Decrement iSize
90269>>>>>>>        for i from 0 to iSize
90275>>>>>>>>
90275>>>>>>>            If (hTable = iaFileIsAlias[i]) Begin
90277>>>>>>>                Function_Return DF_FILE_IS_ALIAS
90278>>>>>>>            End
90278>>>>>>>>
90278>>>>>>>        Loop
90279>>>>>>>>
90279>>>>>>>
90279>>>>>>>        Function_Return DF_FILE_ALIAS_DEFAULT
90280>>>>>>>    End_Function
90281>>>>>>>
90281>>>>>>>    // Determine the available indexes of a table.
90281>>>>>>>    //
90281>>>>>>>    // Arguments:
90281>>>>>>>    //   Handle hTable - The number of the table
90281>>>>>>>    //
90281>>>>>>>    // Returns:
90281>>>>>>>    //   String - A string to be used with the sort command
90281>>>>>>>    //   to re-index all indexes of a table.
90281>>>>>>>    Function UtilTableIndexString Handle hTable Returns String
90283>>>>>>>        String  sSortString
90283>>>>>>>        Integer iLastIndex iNumSegments iCount
90283>>>>>>>
90283>>>>>>>        Move "" to sSortString
90284>>>>>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
90287>>>>>>>
90287>>>>>>>        for iCount from 1 to iLastIndex
90293>>>>>>>>
90293>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iCount to iNumSegments
90296>>>>>>>            If iNumSegments Begin
90298>>>>>>>                If (Length(sSortString)) ;                    Move (Append(sSortString, " ")) to sSortString
90301>>>>>>>                Move (Append(sSortString, iCount)) to sSortString
90302>>>>>>>            End
90302>>>>>>>>
90302>>>>>>>        Loop
90303>>>>>>>>
90303>>>>>>>
90303>>>>>>>        Function_Return sSortString
90304>>>>>>>    End_Function
90305>>>>>>>
90305>>>>>>>    
90305>>>>>>>    // * Dummy function for the Studio's Code Explorer *
90305>>>>>>>    Function API_COLUMN_UTILITY_FUNCTIONS Returns Boolean
90307>>>>>>>        Function_Return False
90308>>>>>>>    End_Function
90309>>>>>>>
90309>>>>>>>    // Compare multiple columns. (For 'FROM' & 'TO' tables)
90309>>>>>>>    Function UtilColumnsCompare String sDriverIDFrom String sDriverIDTo Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare[] aAPIColumnCompare Boolean bCompareDate_DataTime Returns Boolean
90311>>>>>>>        Boolean bIsSame
90311>>>>>>>        Integer iCount iColumns iColumn
90311>>>>>>>
90311>>>>>>>        Move True to bIsSame
90312>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iColumns
90313>>>>>>>        Set piMaximum of ghoProgressBar  to iColumns
90314>>>>>>>        Decrement iColumns
90315>>>>>>>
90315>>>>>>>        for iCount from 0 to iColumns
90321>>>>>>>>
90321>>>>>>>            Set piPosition of ghoProgressBar to iCount
90322>>>>>>>            Get UtilColumnCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare[iCount] bCompareDate_DataTime to bIsSame
90323>>>>>>>            If (bIsSame = False) Begin
90325>>>>>>>                Function_Return False
90326>>>>>>>            End
90326>>>>>>>>
90326>>>>>>>        Loop
90327>>>>>>>>
90327>>>>>>>
90327>>>>>>>        Function_Return (bIsSame = True)
90328>>>>>>>    End_Function
90329>>>>>>>
90329>>>>>>>    // Compares a single column (For 'FROM' & 'TO' tables)
90329>>>>>>>    Function UtilColumnCompare String sDriverIDFrom String sDriverIDTo Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare APIColumnCompare Boolean bCompareDate_DataTime Returns Boolean
90331>>>>>>>        Integer iFromType iToType iDbType
90331>>>>>>>        tColumnType ColumnType
90331>>>>>>>        tColumnType ColumnType
90331>>>>>>>        Boolean bIsDateTypeFrom bIsDateTypeTo
90331>>>>>>>
90331>>>>>>>        If (APIColumnCompare.bCancelFrom = True or APIColumnCompare.bCancelTo = True) Begin
90333>>>>>>>            Function_Return False
90334>>>>>>>        End
90334>>>>>>>>
90334>>>>>>>        If (APIColumnCompare.bExistsFrom = False or APIColumnCompare.bExistsTo = False) Begin
90336>>>>>>>            Function_Return False
90337>>>>>>>        End
90337>>>>>>>>
90337>>>>>>>        If (Uppercase(APIColumnCompare.sFieldNameFrom) <> Uppercase(APIColumnCompare.sFieldNameTo)) Begin
90339>>>>>>>            Function_Return False
90340>>>>>>>        End                                                                
90340>>>>>>>>
90340>>>>>>>
90340>>>>>>>        If (bIsSQLFrom = True and bIsSQLTo = True) Begin
90342>>>>>>>            If (APIColumnCompare.bAllowNULLFrom <> APIColumnCompare.bAllowNULLTo) Begin
90344>>>>>>>                Function_Return False
90345>>>>>>>            End
90345>>>>>>>>
90345>>>>>>>            If (APIColumnCompare.sDefaultValueFrom <> APIColumnCompare.sDefaultValueTo) Begin
90347>>>>>>>                If ((APIColumnCompare.sDefaultValueFrom = ""   and APIColumnCompare.sDefaultValueTo = "''") or ;                    (APIColumnCompare.sDefaultValueFrom = "''" and APIColumnCompare.sDefaultValueTo = "")) Begin
90349>>>>>>>                    End
90349>>>>>>>>
90349>>>>>>>                Else Begin
90350>>>>>>>                    Function_Return False
90351>>>>>>>                End
90351>>>>>>>>
90351>>>>>>>            End
90351>>>>>>>>
90351>>>>>>>        End
90351>>>>>>>>
90351>>>>>>>
90351>>>>>>>        Get piDbType                       to iDbType
90352>>>>>>>        Move APIColumnCompare.iTypeFrom    to iFromType
90353>>>>>>>        Move APIColumnCompare.iTypeTo      to iToType
90354>>>>>>>
90354>>>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
90354>>>>>>>        // data types between Embedded and SQL.
90354>>>>>>>        If (bIsSQLFrom = True and bIsSQLTo = False) Begin
90356>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iFromType APIColumnCompare.iLengthFrom to iFromType
90357>>>>>>>        End
90357>>>>>>>>
90357>>>>>>>        If (bIsSQLFrom = False and bIsSQLTo = True) Begin
90359>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDTo iDbType iToType APIColumnCompare.iLengthTo to iToType
90360>>>>>>>        End
90360>>>>>>>>
90360>>>>>>>
90360>>>>>>>        Get UtilColumnIsDateType iFromType bIsSQLFrom to bIsDateTypeFrom
90361>>>>>>>        Get UtilColumnIsDateType iToType   bIsSQLTo   to bIsDateTypeTo
90362>>>>>>>
90362>>>>>>>        // Make Date and DateTime comparison?
90362>>>>>>>        If (bCompareDate_DataTime = True) Begin
90364>>>>>>>            If (iFromType <> iToType) Begin
90366>>>>>>>                Function_Return False
90367>>>>>>>            End
90367>>>>>>>>
90367>>>>>>>        End
90367>>>>>>>>
90367>>>>>>>
90367>>>>>>>        // This is when not checking for Date/DateTime differences but all other other field types...
90367>>>>>>>        If (bCompareDate_DataTime = False and bIsDateTypeFrom = False) Begin
90369>>>>>>>            If (iFromType <> iToType) Begin
90371>>>>>>>                Function_Return False
90372>>>>>>>            End
90372>>>>>>>>
90372>>>>>>>        End
90372>>>>>>>>
90372>>>>>>>
90372>>>>>>>        // Only if the field is not a Date type (any of them) we compare length & precision.
90372>>>>>>>        If (bIsDateTypeFrom = False) Begin
90374>>>>>>>            If (APIColumnCompare.iLengthFrom <> APIColumnCompare.iLengthTo) Begin
90376>>>>>>>                Function_Return False
90377>>>>>>>            End
90377>>>>>>>>
90377>>>>>>>            If (APIColumnCompare.iPrecisionFrom <> APIColumnCompare.iPrecisionTo) Begin
90379>>>>>>>                Function_Return False
90380>>>>>>>            End
90380>>>>>>>>
90380>>>>>>>        End
90380>>>>>>>>
90380>>>>>>>
90380>>>>>>>        If (APIColumnCompare.iOptionsFrom <> APIColumnCompare.iOptionsTo) Begin
90382>>>>>>>            Function_Return False
90383>>>>>>>        End
90383>>>>>>>>
90383>>>>>>>
90383>>>>>>>        Function_Return True
90384>>>>>>>    End_Function
90385>>>>>>>
90385>>>>>>>    Function UtilColumnsStructFill Handle hTable Returns tAPIColumn[]
90387>>>>>>>        Integer iNumColumns iColumn iCount iOptions iDbType iType iCheckFieldNumber
90387>>>>>>>        Boolean bIdentityKey bDawSqlDriver bSqlDriver bIsOpen bExists bIsSqlTable bUserCancel
90387>>>>>>>        tAPIColumn[] APIColumns APIColumnsEmpty
90387>>>>>>>        tAPIColumn[] APIColumns APIColumnsEmpty
90389>>>>>>>        String sDriverID sRootName sLogicalName
90389>>>>>>>
90389>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90390>>>>>>>        Get piDbType to iDbType
90391>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
90394>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
90397>>>>>>>
90397>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90400>>>>>>>        If (bIsOpen = False) Begin
90402>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90403>>>>>>>            Open hTable
90405>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90406>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90409>>>>>>>            If (bIsOpen = False) Begin
90411>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
90412>>>>>>>                Move True to APIColumnsEmpty[0].bError
90413>>>>>>>                Function_Return APIColumnsEmpty
90414>>>>>>>            End
90414>>>>>>>>
90414>>>>>>>        End
90414>>>>>>>>
90414>>>>>>>
90414>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
90417>>>>>>>        Get IsSQLDriver    sDriverID to bSqlDriver
90418>>>>>>>        Get IsDAWSQLDriver sDriverID to bDawSqlDriver
90419>>>>>>>
90419>>>>>>>        Get _UtilTableIsSqlByRootName sRootName to bIsSqlTable
90420>>>>>>>        If (bIsSqlTable = True) Begin
90422>>>>>>>            Get _UtilTableExists hTable to bExists
90423>>>>>>>            If (bExists = False) Begin
90425>>>>>>>                Move True to APIColumnsEmpty[0].bError
90426>>>>>>>                Function_Return APIColumnsEmpty
90427>>>>>>>            End
90427>>>>>>>>
90427>>>>>>>        End
90427>>>>>>>>
90427>>>>>>>
90427>>>>>>>        Move 0 to iCount
90428>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
90431>>>>>>>        Set piMaximum of ghoProgressBar to iNumColumns
90432>>>>>>>
90432>>>>>>>        for iColumn from 1 to iNumColumns
90438>>>>>>>>
90438>>>>>>>            Move 0 to iOptions
90439>>>>>>>            Move False to bIdentityKey
90440>>>>>>>            Move False to Err
90441>>>>>>>            Move 0     to LastErr
90442>>>>>>>            Move bIsSqlTable to APIColumns[iCount].bIsSQLType
90443>>>>>>>            Set piPosition of ghoProgressBar to iColumn
90444>>>>>>>            If (bDawSqlDriver = True) Begin
90446>>>>>>>                Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
90447>>>>>>>                If (bIsSqlTable = True) Begin
90449>>>>>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iType
90452>>>>>>>                    Move iType                                                to APIColumns[iCount].iType
90453>>>>>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE_NAME of hTable iColumn to APIColumns[iCount].sType
90456>>>>>>>                    Get_Attribute DF_FIELD_NULL_ALLOWED     of hTable iColumn to APIColumns[iCount].bAllowNULL
90459>>>>>>>                    Get_Attribute DF_FIELD_DEFAULT_VALUE    of hTable iColumn to APIColumns[iCount].sDefaultValue
90462>>>>>>>                End
90462>>>>>>>>
90462>>>>>>>                Else Begin
90463>>>>>>>                    Get_Attribute DF_FIELD_TYPE             of hTable iColumn to APIColumns[iCount].iType
90466>>>>>>>                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
90467>>>>>>>                End
90467>>>>>>>>
90467>>>>>>>
90467>>>>>>>                // If the array value is out of bounce it means that this column doesn't exist on the backend.
90467>>>>>>>                Get_Attribute DF_Field_Number of hTable iColumn to iCheckFieldNumber
90470>>>>>>>                Move (iCheckFieldNumber >= 0) to bExists
90471>>>>>>>                If (bExists = False) Begin
90473>>>>>>>                    Move 0 to APIColumns[iCount].iType
90474>>>>>>>                End
90474>>>>>>>>
90474>>>>>>>                If (bExists = True) Begin
90476>>>>>>>                        Get_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to bIdentityKey
90479>>>>>>>                End
90479>>>>>>>>
90479>>>>>>>                Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
90480>>>>>>>                If (bIdentityKey = True) Begin
90482>>>>>>>                    Move C_tAPIColumn_Identity to APIColumns[iCount].iOptions
90483>>>>>>>                End
90483>>>>>>>>
90483>>>>>>>            End
90483>>>>>>>>
90483>>>>>>>            Else Begin
90484>>>>>>>                Move False to Err
90485>>>>>>>                Move 0     to LastErr
90486>>>>>>>                If (bIsSqlTable = True) Begin
90488>>>>>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to APIColumns[iCount].iType
90491>>>>>>>                End
90491>>>>>>>>
90491>>>>>>>                Else Begin
90492>>>>>>>                    Get_Attribute DF_FIELD_TYPE        of hTable iColumn to APIColumns[iCount].iType
90495>>>>>>>                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
90496>>>>>>>                End
90496>>>>>>>>
90496>>>>>>>                // If the array value is out of bounce it means that this column doesn't exist on the backend.
90496>>>>>>>                Move (LastErr <> DFERR_ARRAY_INDEX_OUT_OF_BOUNDS) to bExists
90497>>>>>>>                If (bExists = False) Begin
90499>>>>>>>                    Move 0 to APIColumns[iCount].iType
90500>>>>>>>                End
90500>>>>>>>>
90500>>>>>>>            End
90500>>>>>>>>
90500>>>>>>>
90500>>>>>>>            If (bExists = True) Begin
90502>>>>>>>                Move iColumn to APIColumns[iCount].iFieldNumber
90503>>>>>>>                Get_Attribute DF_FIELD_NAME        of hTable iColumn to APIColumns[iCount].sFieldName
90506>>>>>>>                // ToDo: Can't use native_size as it can get way to big and causes "out of memory" problems.
90506>>>>>>>//                If (bIsSqlTable = True) Begin
90506>>>>>>>//                    Get_Attribute DF_FIELD_NATIVE_SIZE of hTable iColumn to APIColumns[iCount].iLength
90506>>>>>>>//                    Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
90506>>>>>>>//                End
90506>>>>>>>                Get_Attribute DF_FIELD_LENGTH      of hTable iColumn to APIColumns[iCount].iLength
90509>>>>>>>                Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
90512>>>>>>>
90512>>>>>>>                // If the length was zero we might have an Overlap(!) field.
90512>>>>>>>                // We then need check the DF_FIELD_TYPE if it really is and reset data for this array item.
90512>>>>>>>                If (APIColumns[iCount].iLength = 0) Begin
90514>>>>>>>                    Get_Attribute DF_FIELD_TYPE    of hTable iColumn to iType
90517>>>>>>>                    If (iType = DF_OVERLAP) Begin
90519>>>>>>>                        Move 0 to APIColumns[iCount].iFieldNumber
90520>>>>>>>                        Move 0 to APIColumns[iCount].iLength
90521>>>>>>>                        Move 0 to APIColumns[iCount].iOptions
90522>>>>>>>                        Move 0 to APIColumns[iCount].iPrecision
90523>>>>>>>                        Move DF_OVERLAP to APIColumns[iCount].iType
90524>>>>>>>                        Move "" to APIColumns[iCount].sFieldName
90525>>>>>>>                        Decrement iCount
90526>>>>>>>                    End
90526>>>>>>>>
90526>>>>>>>                End
90526>>>>>>>>
90526>>>>>>>            End
90526>>>>>>>>
90526>>>>>>>            Get Check_StatusPanel of ghoStatusPanel to bUserCancel
90527>>>>>>>            If (bUserCancel = True) Begin
90529>>>>>>>                Move True to APIColumnsEmpty[0].bCancel
90530>>>>>>>                Function_Return APIColumnsEmpty
90531>>>>>>>            End
90531>>>>>>>>
90531>>>>>>>            Increment iCount
90532>>>>>>>        Loop
90533>>>>>>>>
90533>>>>>>>
90533>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90534>>>>>>>        Function_Return APIColumns
90535>>>>>>>    End_Function
90536>>>>>>>
90536>>>>>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
90536>>>>>>>    // The combined data will be sorted on the first struct member: iIndexNumber
90536>>>>>>>    // This is needed because index numbers can start at any number. The range for a particular table might also
90536>>>>>>>    // have "holes" in the series of index numbers.
90536>>>>>>>    Function UtilColumnCombineFromAndToArrays tAPIColumn[] APIColumnFrom tAPIColumn[] APIColumnTo Returns tAPIIndexCompare[]
90538>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
90538>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
90539>>>>>>>        tAPIColumnCompare   APIColumnCompare
90539>>>>>>>        tAPIColumnCompare   APIColumnCompare
90539>>>>>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
90539>>>>>>>
90539>>>>>>>        Move (SizeOfArray(APIColumnFrom)) to iSizeFrom
90540>>>>>>>        Decrement iSizeFrom
90541>>>>>>>        for iCount from 0 to iSizeFrom
90547>>>>>>>>
90547>>>>>>>            Move APIColumnFrom[iCount].iFieldNumber     to aAPIColumnCompare[iCount].iFieldNumber
90548>>>>>>>            Move APIColumnFrom[iCount].sFieldName       to aAPIColumnCompare[iCount].sFieldNameFrom
90549>>>>>>>            Move APIColumnFrom[iCount].iType            to aAPIColumnCompare[iCount].iTypeFrom
90550>>>>>>>            Move APIColumnFrom[iCount].sType            to aAPIColumnCompare[iCount].sTypeFrom
90551>>>>>>>            Move APIColumnFrom[iCount].iLength          to aAPIColumnCompare[iCount].iLengthFrom
90552>>>>>>>            Move APIColumnFrom[iCount].iPrecision       to aAPIColumnCompare[iCount].iPrecisionFrom
90553>>>>>>>            Move APIColumnFrom[iCount].iOptions         to aAPIColumnCompare[iCount].iOptionsFrom
90554>>>>>>>            Move APIColumnFrom[iCount].bIsSQLType       to aAPIColumnCompare[iCount].bIsSQLTypeFrom
90555>>>>>>>            Move APIColumnFrom[iCount].bAllowNULL       to aAPIColumnCompare[iCount].bAllowNULLFrom
90556>>>>>>>            Move APIColumnFrom[iCount].sDefaultValue    to aAPIColumnCompare[iCount].sDefaultValueFrom
90557>>>>>>>            Move APIColumnFrom[iCount].bShouldChange    to aAPIColumnCompare[iCount].bShouldChangeFrom
90558>>>>>>>            Move APIColumnFrom[iCount].bCancel          to aAPIColumnCompare[iCount].bCancelFrom
90559>>>>>>>            Move APIColumnFrom[iCount].bError           to aAPIColumnCompare[iCount].bErrorFrom
90560>>>>>>>            Move True                                   to aAPIColumnCompare[iCount].bExistsFrom
90561>>>>>>>        Loop
90562>>>>>>>>
90562>>>>>>>
90562>>>>>>>        Move (SizeOfArray(APIColumnTo)) to iSizeTo
90563>>>>>>>        Decrement iSizeTo
90564>>>>>>>        for iCount from 0 to iSizeTo
90570>>>>>>>>
90570>>>>>>>            Move APIColumnTo[iCount].iFieldNumber       to APIColumnCompare.iFieldNumber
90571>>>>>>>            // Search if the field number already exists in the array; else add it.
90571>>>>>>>            Move (SearchArray(APIColumnCompare, aAPIColumnCompare)) to iItem
90572>>>>>>>            If (iItem = -1) Begin
90574>>>>>>>                Move (SizeOfArray(aAPIColumnCompare))   to iItem
90575>>>>>>>            End
90575>>>>>>>>
90575>>>>>>>
90575>>>>>>>            Move APIColumnCompare.iFieldNumber          to aAPIColumnCompare[iItem].iFieldNumber
90576>>>>>>>            Move APIColumnTo[iCount].iFieldNumber       to aAPIColumnCompare[iItem].iFieldNumberTo
90577>>>>>>>            Move APIColumnTo[iCount].sFieldName         to aAPIColumnCompare[iItem].sFieldNameTo
90578>>>>>>>            Move APIColumnTo[iCount].iType              to aAPIColumnCompare[iItem].iTypeTo
90579>>>>>>>            Move APIColumnTo[iCount].sType              to aAPIColumnCompare[iItem].sTypeTo
90580>>>>>>>            Move APIColumnTo[iCount].iLength            to aAPIColumnCompare[iItem].iLengthTo
90581>>>>>>>            Move APIColumnTo[iCount].iPrecision         to aAPIColumnCompare[iItem].iPrecisionTo
90582>>>>>>>            Move APIColumnTo[iCount].iOptions           to aAPIColumnCompare[iItem].iOptionsTo
90583>>>>>>>            Move APIColumnTo[iCount].bIsSQLType         to aAPIColumnCompare[iItem].bIsSQLTypeTo
90584>>>>>>>            Move APIColumnTo[iCount].bAllowNULL         to aAPIColumnCompare[iItem].bAllowNULLTo
90585>>>>>>>            Move APIColumnTo[iCount].sDefaultValue      to aAPIColumnCompare[iItem].sDefaultValueTo
90586>>>>>>>            Move APIColumnTo[iCount].bShouldChange      to aAPIColumnCompare[iItem].bShouldChangeTo
90587>>>>>>>            Move APIColumnTo[iCount].bCancel            to aAPIColumnCompare[iItem].bCancelTo
90588>>>>>>>            Move APIColumnTo[iCount].bError             to aAPIColumnCompare[iItem].bErrorTo
90589>>>>>>>            Move True                                   to aAPIColumnCompare[iItem].bExistsTo
90590>>>>>>>        Loop
90591>>>>>>>>
90591>>>>>>>
90591>>>>>>>        Move (SortArray(aAPIColumnCompare)) to aAPIColumnCompare
90592>>>>>>>
90592>>>>>>>        Function_Return aAPIColumnCompare
90593>>>>>>>    End_Function
90594>>>>>>>
90594>>>>>>>    // Checks if a field name exists in a table definition
90594>>>>>>>    // Returns True if it does
90594>>>>>>>    // Sample:
90594>>>>>>>    //   Get UtilColumnExists MyTable.File_Number "MyColumnName" to iExists
90594>>>>>>>    Function UtilColumnExists Handle hTable String sFieldName Returns Boolean
90596>>>>>>>        Integer iNumColumns iColumn
90596>>>>>>>        String sColumn
90596>>>>>>>        Boolean bExists bOK bOpen
90596>>>>>>>
90596>>>>>>>        Get AutoConnectionIDLogin to bOK
90597>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90598>>>>>>>        Open hTable
90600>>>>>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90601>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
90604>>>>>>>        If (bOpen = False) Begin
90606>>>>>>>            Function_Return False
90607>>>>>>>        End
90607>>>>>>>>
90607>>>>>>>
90607>>>>>>>        Move False to bExists
90608>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
90611>>>>>>>        for iColumn from 1 to iNumColumns
90617>>>>>>>>
90617>>>>>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
90620>>>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
90622>>>>>>>                Move iNumColumns to iColumn
90623>>>>>>>                Move True to bExists
90624>>>>>>>            End
90624>>>>>>>>
90624>>>>>>>        Loop
90625>>>>>>>>
90625>>>>>>>        Close hTable
90626>>>>>>>
90626>>>>>>>        Function_Return bExists
90627>>>>>>>    End_Function
90628>>>>>>>
90628>>>>>>>    // Returns the field/column number for the passed FieldName as an integer.
90628>>>>>>>    Function UtilColumnNameToColumnNumber Handle hTable String sFieldName Returns Integer
90630>>>>>>>        Integer iNumColumns iColumn iRetval
90630>>>>>>>        String sColumn
90630>>>>>>>        Boolean bOK bOpen
90630>>>>>>>
90630>>>>>>>        Get AutoConnectionIDLogin to bOK
90631>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90632>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90633>>>>>>>        Open hTable
90635>>>>>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90636>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
90639>>>>>>>        If (bOpen = False) Begin
90641>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
90642>>>>>>>            Function_Return False
90643>>>>>>>        End
90643>>>>>>>>
90643>>>>>>>
90643>>>>>>>        Move 0 to iColumn
90644>>>>>>>        Move 0 to iRetval
90645>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
90648>>>>>>>        for iColumn from 1 to iNumColumns
90654>>>>>>>>
90654>>>>>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
90657>>>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
90659>>>>>>>                Move iColumn to iRetval
90660>>>>>>>                Move iNumColumns to iColumn
90661>>>>>>>            End
90661>>>>>>>>
90661>>>>>>>        Loop
90662>>>>>>>>
90662>>>>>>>        Close hTable
90663>>>>>>>
90663>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90664>>>>>>>        Function_Return iRetval
90665>>>>>>>    End_Function
90666>>>>>>>
90666>>>>>>>    // To convert between a data type string name and its integer constant declaration. E.g."VarChar" -> SQL_VarChar
90666>>>>>>>    // The reciprocal function is UtilColumnTypeToInteger.
90666>>>>>>>    Function UtilColumnTypeToInteger String sDriverID Integer iDbType String sDataType Returns Integer
90668>>>>>>>        tColumnType RetvalType
90668>>>>>>>        tColumnType RetvalType
90668>>>>>>>
90668>>>>>>>        Get _UtilColumnType sDriverID iDbType 0 sDataType False to RetvalType
90669>>>>>>>        Function_Return RetvalType.iSQLType
90670>>>>>>>    End_Function
90671>>>>>>>
90671>>>>>>>    // To convert between an integer data type constant and its string value. E.g. SQL_VarChar -> "VarChar".
90671>>>>>>>    // The reciprocal function is UtilColumnTypeToString.
90671>>>>>>>    Function UtilColumnTypeToString String sDriverID Integer iDbType Integer iDataType Returns String
90673>>>>>>>        tColumnType RetvalType
90673>>>>>>>        tColumnType RetvalType
90673>>>>>>>
90673>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90674>>>>>>>        Function_Return RetvalType.sSQLType
90675>>>>>>>    End_Function
90676>>>>>>>
90676>>>>>>>    Function UtilColumnTypePrecision String sDriverID Integer iDbType Integer iDataType Returns String
90678>>>>>>>        tColumnType RetvalType
90678>>>>>>>        tColumnType RetvalType
90678>>>>>>>
90678>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90679>>>>>>>        Function_Return RetvalType.sPrecision
90680>>>>>>>    End_Function
90681>>>>>>>
90681>>>>>>>    Function UtilColumnTypeFixed String sDriverID Integer iDbType Integer iDataType Returns Boolean
90683>>>>>>>        tColumnType RetvalType
90683>>>>>>>        tColumnType RetvalType
90683>>>>>>>
90683>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90684>>>>>>>        // Nils 2019-02-15. This return value seems to have been wrong. The function should return False
90684>>>>>>>        // if the column type length is _not_ fixed.
90684>>>>>>>        Function_Return (RetvalType.bCanEditSize = False)
90685>>>>>>>    End_Function
90686>>>>>>>
90686>>>>>>>    Function UtilColumnTypePrecisionSize String sDriverID Integer iDbType Integer iDataType Returns Integer
90688>>>>>>>        tColumnType RetvalType
90688>>>>>>>        tColumnType RetvalType
90688>>>>>>>        String sValue
90688>>>>>>>        Integer iRetval iPos
90688>>>>>>>
90688>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90689>>>>>>>        Move RetvalType.sPrecision to sValue
90690>>>>>>>        Move (Pos(".", sValue)) to iPos
90691>>>>>>>        If (iPos <> 0) Begin
90693>>>>>>>            Move (Left(sValue, (iPos -1))) to iRetval
90694>>>>>>>        End
90694>>>>>>>>
90694>>>>>>>        Else Begin
90695>>>>>>>            Move sValue to iRetval
90696>>>>>>>        End
90696>>>>>>>>
90696>>>>>>>        Function_Return iRetval
90697>>>>>>>    End_Function
90698>>>>>>>
90698>>>>>>>    Function UtilColumnTypePrecisionDec String sDriverID Integer iDbType Integer iDataType Returns Integer
90700>>>>>>>        tColumnType RetvalType
90700>>>>>>>        tColumnType RetvalType
90700>>>>>>>        String sValue
90700>>>>>>>        Integer iRetval iPos
90700>>>>>>>
90700>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90701>>>>>>>        Move RetvalType.sPrecision to sValue
90702>>>>>>>        Move (Pos(".", sValue)) to iPos
90703>>>>>>>        If (iPos = 0) Begin
90705>>>>>>>            Function_Return 0
90706>>>>>>>        End
90706>>>>>>>>
90706>>>>>>>        Move (Mid(sValue, 99, (iPos + 1))) to iRetval
90707>>>>>>>
90707>>>>>>>        Function_Return iRetval
90708>>>>>>>    End_Function
90709>>>>>>>
90709>>>>>>>    // * Dummy function for the Studio's Code Explorer *
90709>>>>>>>    Function API_INDEX_UTILITY_FUNCTIONS Returns Boolean
90711>>>>>>>        Function_Return False
90712>>>>>>>    End_Function
90713>>>>>>>
90713>>>>>>>    // Compares multiple indexes for a 'FROM' and a 'TO' table.
90713>>>>>>>    Function UtilIndexesCompare Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndexCompare[] aAPIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
90715>>>>>>>        Boolean bIsSame
90715>>>>>>>        Integer iCount iSize
90715>>>>>>>
90715>>>>>>>        Move True to bIsSame
90716>>>>>>>        Move (SizeOfArray(aAPIIndexCompare)) to iSize
90717>>>>>>>        Decrement iSize
90718>>>>>>>        For iCount from 0 to iSize
90724>>>>>>>>
90724>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90725>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
90726>>>>>>>            Get UtilIndexCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
90727>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
90728>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
90729>>>>>>>            If (bIsSame = False) Begin
90731>>>>>>>                Function_Return False
90732>>>>>>>            End
90732>>>>>>>>
90732>>>>>>>        Loop
90733>>>>>>>>
90733>>>>>>>
90733>>>>>>>        Function_Return bIsSame
90734>>>>>>>    End_Function
90735>>>>>>>
90735>>>>>>>    // Compares a single index for a 'FROM' and a 'TO' table.
90735>>>>>>>    Function UtilIndexCompare Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndexCompare APIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
90737>>>>>>>        Boolean bIsSame
90737>>>>>>>        Integer iSegment
90737>>>>>>>
90737>>>>>>>        Move (APIIndexCompare.bExistsFrom = APIIndexCompare.bExistsTo) to bIsSame
90738>>>>>>>        If (bIsSame = False) Begin
90740>>>>>>>            Function_Return False
90741>>>>>>>        End
90741>>>>>>>>
90741>>>>>>>        Move (APIIndexCompare.iPrimaryIndexFrom = APIIndexCompare.iPrimaryIndexTo) to bIsSame
90742>>>>>>>        If (bIsSame = False) Begin
90744>>>>>>>            Function_Return False
90745>>>>>>>        End
90745>>>>>>>>
90745>>>>>>>
90745>>>>>>>        If (bIsSqlTableFrom = True and bIsSqlTableTo = True) Begin
90747>>>>>>>            // * We should probably not compare SQL index names?
90747>>>>>>>            // Move (Uppercase(aIndexFrom.sSQLIndexName) = Uppercase(aIndexTo.sSQLIndexName)) to bIsSame
90747>>>>>>>            // If (bIsSame = False) Begin   DF_INDEX_SERVER_ONLY
90747>>>>>>>            //     Function_Return False
90747>>>>>>>            // End
90747>>>>>>>            Move (APIIndexCompare.bIsSQLPrimaryKeyFrom = APIIndexCompare.bIsSQLPrimaryKeyTo) to bIsSame
90748>>>>>>>            If (bIsSame = False) Begin
90750>>>>>>>                Function_Return False
90751>>>>>>>            End
90751>>>>>>>>
90751>>>>>>>            Move (APIIndexCompare.bIsSQLClusteredFrom = APIIndexCompare.bIsSQLClusteredTo) to bIsSame
90752>>>>>>>            If (bIsSame = False) Begin
90754>>>>>>>                Function_Return False
90755>>>>>>>            End
90755>>>>>>>>
90755>>>>>>>            Move (APIIndexCompare.iSQLIndexTypeFrom = APIIndexCompare.iSQLIndexTypeTo) to bIsSame
90756>>>>>>>            If (bIsSame = False) Begin
90758>>>>>>>                Function_Return False
90759>>>>>>>            End
90759>>>>>>>>
90759>>>>>>>            Move (Uppercase(APIIndexCompare.sSQLIndexNameFrom) = Uppercase(APIIndexCompare.sSQLIndexNameTo)) to bIsSame
90760>>>>>>>            If (bIsSame = False) Begin
90762>>>>>>>                Function_Return False
90763>>>>>>>            End
90763>>>>>>>>
90763>>>>>>>        End
90763>>>>>>>>
90763>>>>>>>
90763>>>>>>>        Get UtilIndexSegmentsCompare APIIndexCompare.IndexSegmentArrayFrom APIIndexCompare.IndexSegmentArrayTo bCompareIndexUppercase bCompareIndexAscending to iSegment
90764>>>>>>>        Move (iSegment = -1) to bIsSame
90765>>>>>>>
90765>>>>>>>        Function_Return (bIsSame = True)
90766>>>>>>>    End_Function
90767>>>>>>>
90767>>>>>>>    // Compares each segment for the passed index.
90767>>>>>>>    // Returns -1 if same; else returns the index segment that differs.
90767>>>>>>>    Function UtilIndexSegmentsCompare tAPIIndexSegment[] aIndexSegmentFrom tAPIIndexSegment[] aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
90769>>>>>>>        Integer iNumSegmentsFrom iNumSegmentsTo iNumSegments iSegment
90769>>>>>>>        Boolean bIsSame
90769>>>>>>>
90769>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
90770>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90771>>>>>>>        Move (SizeOfArray(aIndexSegmentFrom))      to iNumSegmentsFrom
90772>>>>>>>        Move (SizeOfArray(aIndexSegmentTo))        to iNumSegmentsTo
90773>>>>>>>        Move (iNumSegmentsFrom max iNumSegmentsTo) to iNumSegments
90774>>>>>>>
90774>>>>>>>        Decrement iNumSegments
90775>>>>>>>        for iSegment from 0 to iNumSegments
90781>>>>>>>>
90781>>>>>>>            Move False to bIsSame
90782>>>>>>>            If (iSegment < iNumSegmentsFrom and iSegment < iNumSegmentsTo) Begin
90784>>>>>>>                Get UtilIndexSegmentCompare aIndexSegmentFrom[iSegment] aIndexSegmentTo[iSegment] bCompareIndexUppercase bCompareIndexAscending to bIsSame
90785>>>>>>>            End
90785>>>>>>>>
90785>>>>>>>            If (bIsSame = False) Begin
90787>>>>>>>                Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
90788>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
90789>>>>>>>                Function_Return iSegment
90790>>>>>>>            End
90790>>>>>>>>
90790>>>>>>>        Loop
90791>>>>>>>>
90791>>>>>>>
90791>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90792>>>>>>>        Function_Return -1 // This means bIsSame = True
90793>>>>>>>    End_Function
90794>>>>>>>
90794>>>>>>>    Function UtilIndexSegmentCompare tAPIIndexSegment aIndexSegmentFrom tAPIIndexSegment aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
90796>>>>>>>        Boolean bIsSame
90796>>>>>>>
90796>>>>>>>        Move (aIndexSegmentFrom.iFieldNumber = aIndexSegmentTo.iFieldNumber) to bIsSame
90797>>>>>>>        If (bIsSame = False) Begin
90799>>>>>>>            Function_Return False
90800>>>>>>>        End
90800>>>>>>>>
90800>>>>>>>        If (bCompareIndexUppercase = True) Begin
90802>>>>>>>            Move (aIndexSegmentFrom.bUppercase = aIndexSegmentTo.bUppercase) to bIsSame
90803>>>>>>>            If (bIsSame = False) Begin
90805>>>>>>>                Function_Return False
90806>>>>>>>            End
90806>>>>>>>>
90806>>>>>>>        End
90806>>>>>>>>
90806>>>>>>>        If (bCompareIndexAscending = True) Begin
90808>>>>>>>            Move (aIndexSegmentFrom.bAscending = aIndexSegmentTo.bAscending) to bIsSame
90809>>>>>>>            If (bIsSame = False) Begin
90811>>>>>>>                Function_Return False
90812>>>>>>>            End
90812>>>>>>>>
90812>>>>>>>        End
90812>>>>>>>>
90812>>>>>>>
90812>>>>>>>        Function_Return True
90813>>>>>>>    End_Function
90814>>>>>>>
90814>>>>>>>    Function UtilIndexesUpdate Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndex[] aIndexesFrom tAPIIndex[] aIndexesTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
90816>>>>>>>        Boolean bIsSame bOK
90816>>>>>>>        Integer iSize iSizeTo iCount
90816>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
90816>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
90817>>>>>>>
90817>>>>>>>        Move (SizeOfArray(aIndexesFrom)) to iSize
90818>>>>>>>        If (iSize = 0) Begin
90820>>>>>>>            Function_Return True
90821>>>>>>>        End
90821>>>>>>>>
90821>>>>>>>        Move (SizeOfArray(aIndexesTo)) to iSizeTo
90822>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTableTo
90823>>>>>>>        Get UtilIndexCombineFromAndToArrays aIndexesFrom aIndexesTo to aAPIIndexCompare
90824>>>>>>>
90824>>>>>>>        for iCount from 0 to (iSize - 1)
90830>>>>>>>>
90830>>>>>>>            Get UtilIndexCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
90831>>>>>>>            If (bIsSame = False) Begin
90833>>>>>>>                Get APIIndexCreateByFieldNames hTable aIndexesFrom[iCount] aIndexesTo aIndexesFrom[iCount].IndexSegmentArray to bOK
90834>>>>>>>            End
90834>>>>>>>>
90834>>>>>>>        Loop
90835>>>>>>>>
90835>>>>>>>
90835>>>>>>>        // We probably should delete other indexes if they exists.
90835>>>>>>>        for iCount from (iSize +1) to iSizeTo
90841>>>>>>>>
90841>>>>>>>            Get ApiIndexRemove hTable iCount to bOK
90842>>>>>>>        Loop
90843>>>>>>>>
90843>>>>>>>
90843>>>>>>>        Function_Return bOK
90844>>>>>>>    End_Function
90845>>>>>>>
90845>>>>>>>    Function UtilIndexesStructFill Handle hTable Returns tAPIIndex[]
90847>>>>>>>        tAPIIndex[] APIIndexes
90847>>>>>>>        tAPIIndex[] APIIndexes
90848>>>>>>>        Integer iCount iIndex iIndexes iSegment iSegmentCount iNumSegments iColumn
90848>>>>>>>        String sDriverID
90848>>>>>>>        Boolean bDAWSQLDriver bIsOpen bIsSQLTable
90848>>>>>>>
90848>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90849>>>>>>>        Get psDriverID to sDriverID
90850>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
90851>>>>>>>        Get _UtilTableIsSql hTable to bIsSQLTable
90852>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90855>>>>>>>        If (bIsOpen = False) Begin
90857>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90858>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90859>>>>>>>            Open hTable
90861>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
90862>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90863>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90866>>>>>>>            If (bIsOpen = False) Begin
90868>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
90869>>>>>>>                Move True to APIIndexes[0].bError
90870>>>>>>>                Function_Return APIIndexes
90871>>>>>>>            End
90871>>>>>>>>
90871>>>>>>>        End
90871>>>>>>>>
90871>>>>>>>
90871>>>>>>>        Move 0 to iCount
90872>>>>>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iIndexes
90875>>>>>>>        for iIndex from 1 to iIndexes
90881>>>>>>>>
90881>>>>>>>            // This is a test that the index exists as there might be "holes" aka the index
90881>>>>>>>            // numbers doesn't not need to be consequitive:
90881>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
90884>>>>>>>            If (iNumSegments > 0) Begin
90886>>>>>>>
90886>>>>>>>                Move iIndex                                                     to APIIndexes[iCount].iIndexNumber
90887>>>>>>>                Get_Attribute DF_FILE_PRIMARY_INDEX of hTable                   to APIIndexes[iCount].iPrimaryIndex
90890>>>>>>>                If (bIsSQLTable = True) Begin
90892>>>>>>>                    Get_Attribute DF_INDEX_NAME         of hTable iIndex        to APIIndexes[iCount].sSQLIndexName
90895>>>>>>>                        Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex to APIIndexes[iCount].bIsSQLPrimaryKey
90898>>>>>>>                        Get_Attribute DF_INDEX_CLUSTERED of hTable iIndex       to APIIndexes[iCount].bIsSQLClustered
90901>>>>>>>                        Get_Attribute DF_INDEX_SQL_TYPE of hTable iIndex        to APIIndexes[iCount].iSQLIndexType // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
90904>>>>>>>                End
90904>>>>>>>>
90904>>>>>>>
90904>>>>>>>                Move 0 to iSegmentCount
90905>>>>>>>                Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
90908>>>>>>>                For iSegment from 1 to iNumSegments
90914>>>>>>>>
90914>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iSegment to iColumn
90917>>>>>>>                    Move iColumn                                                       to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].iFieldNumber
90918>>>>>>>                    Get_Attribute DF_FIELD_NAME              of hTable iColumn         to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].sFieldName
90921>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bUppercase
90924>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bAscending
90927>>>>>>>                    Increment iSegmentCount
90928>>>>>>>                Loop
90929>>>>>>>>
90929>>>>>>>                Increment iCount
90930>>>>>>>            End
90930>>>>>>>>
90930>>>>>>>        Loop
90931>>>>>>>>
90931>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90932>>>>>>>
90932>>>>>>>        Function_Return APIIndexes
90933>>>>>>>    End_Function
90934>>>>>>>
90934>>>>>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
90934>>>>>>>    // The combined data will be sorted on the first struct member: iIndexNumber
90934>>>>>>>    // This is needed because index numbers can start at any number. The range for a particular table might also
90934>>>>>>>    // have "holes" in the series of index numbers.
90934>>>>>>>    Function UtilIndexCombineFromAndToArrays tAPIIndex[] APIIndexFrom tAPIIndex[] APIIndexTo Returns tAPIIndexCompare[]
90936>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
90936>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
90937>>>>>>>        tAPIIndexCompare   APIIndexCompare
90937>>>>>>>        tAPIIndexCompare   APIIndexCompare
90937>>>>>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
90937>>>>>>>
90937>>>>>>>        Move (SizeOfArray(APIIndexFrom)) to iSizeFrom
90938>>>>>>>        Move (SizeOfArray(APIIndexTo)) to iSizeTo
90939>>>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
90941>>>>>>>            Function_Return aAPIIndexCompare
90942>>>>>>>        End
90942>>>>>>>>
90942>>>>>>>
90942>>>>>>>        Decrement iSizeFrom
90943>>>>>>>        for iCount from 0 to iSizeFrom
90949>>>>>>>>
90949>>>>>>>            Move APIIndexFrom[iCount].iIndexNumber      to aAPIIndexCompare[iCount].iIndexNumber
90950>>>>>>>            Move APIIndexFrom[iCount].iPrimaryIndex     to aAPIIndexCompare[iCount].iPrimaryIndexFrom
90951>>>>>>>            Move APIIndexFrom[iCount].sSQLIndexName     to aAPIIndexCompare[iCount].sSQLIndexNameFrom
90952>>>>>>>            Move APIIndexFrom[iCount].iSQLIndexType     to aAPIIndexCompare[iCount].iSQLIndexTypeFrom
90953>>>>>>>            Move APIIndexFrom[iCount].bIsSQLClustered   to aAPIIndexCompare[iCount].bIsSQLClusteredFrom
90954>>>>>>>            Move APIIndexFrom[iCount].bIsSQLPrimaryKey  to aAPIIndexCompare[iCount].bIsSQLPrimaryKeyFrom
90955>>>>>>>            Move APIIndexFrom[iCount].IndexSegmentArray to aAPIIndexCompare[iCount].IndexSegmentArrayFrom
90956>>>>>>>            Move APIIndexFrom[iCount].bShouldChange     to aAPIIndexCompare[iCount].bShouldChangeFrom
90957>>>>>>>            Move APIIndexFrom[iCount].bCancel           to aAPIIndexCompare[iCount].bCancelFrom
90958>>>>>>>            Move APIIndexFrom[iCount].bError            to aAPIIndexCompare[iCount].bErrorFrom
90959>>>>>>>            Move True                                   to aAPIIndexCompare[iCount].bExistsFrom
90960>>>>>>>        Loop
90961>>>>>>>>
90961>>>>>>>
90961>>>>>>>        Decrement iSizeTo
90962>>>>>>>        for iCount from 0 to iSizeTo
90968>>>>>>>>
90968>>>>>>>            Move APIIndexTo[iCount].iIndexNumber        to APIIndexCompare.iIndexNumber
90969>>>>>>>            // Search if the Index number already exists in the array; else add it.
90969>>>>>>>            Move (SearchArray(APIIndexCompare, aAPIIndexCompare)) to iItem
90970>>>>>>>            If (iItem = -1) Begin
90972>>>>>>>                Move (SizeOfArray(aAPIIndexCompare))    to iItem
90973>>>>>>>            End
90973>>>>>>>>
90973>>>>>>>
90973>>>>>>>            Move APIIndexCompare.iIndexNumber           to aAPIIndexCompare[iItem].iIndexNumber
90974>>>>>>>            Move APIIndexTo[iCount].iPrimaryIndex       to aAPIIndexCompare[iItem].iPrimaryIndexTo
90975>>>>>>>            Move APIIndexTo[iCount].sSQLIndexName       to aAPIIndexCompare[iItem].sSQLIndexNameTo
90976>>>>>>>            Move APIIndexTo[iCount].iSQLIndexType       to aAPIIndexCompare[iItem].iSQLIndexTypeTo
90977>>>>>>>            Move APIIndexTo[iCount].bIsSQLClustered     to aAPIIndexCompare[iItem].bIsSQLClusteredTo
90978>>>>>>>            Move APIIndexTo[iCount].bIsSQLPrimaryKey    to aAPIIndexCompare[iItem].bIsSQLPrimaryKeyTo
90979>>>>>>>            Move APIIndexTo[iCount].IndexSegmentArray   to aAPIIndexCompare[iItem].IndexSegmentArrayTo
90980>>>>>>>            Move APIIndexTo[iCount].bShouldChange       to aAPIIndexCompare[iItem].bShouldChangeTo
90981>>>>>>>            Move APIIndexTo[iCount].bCancel             to aAPIIndexCompare[iItem].bCancelTo
90982>>>>>>>            Move APIIndexTo[iCount].bError              to aAPIIndexCompare[iItem].bErrorTo
90983>>>>>>>            Move True                                   to aAPIIndexCompare[iItem].bExistsTo
90984>>>>>>>        Loop
90985>>>>>>>>
90985>>>>>>>
90985>>>>>>>        Move (SortArray(aAPIIndexCompare)) to aAPIIndexCompare
90986>>>>>>>
90986>>>>>>>        Function_Return aAPIIndexCompare
90987>>>>>>>    End_Function
90988>>>>>>>
90988>>>>>>>    // This is the same as the UtilIndexCompare function but it takes tAPIIndex structs as params.
90988>>>>>>>    Function UtilIndexTypeNumberCompare Handle hTable tAPIIndex aIndexFrom tAPIIndex aIndexTo Returns Boolean
90990>>>>>>>        Boolean bIsSame bDAWSQLDriver bIsSqlTable
90990>>>>>>>        String sDriverID
90990>>>>>>>
90990>>>>>>>        Get psDriverID to sDriverID
90991>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
90992>>>>>>>        Get IsSQLDriver sDriverID to bIsSqlTable
90993>>>>>>>        If (bIsSqlTable = True) Begin
90995>>>>>>>            Get _UtilTableIsSql hTable to bIsSqlTable
90996>>>>>>>        End
90996>>>>>>>>
90996>>>>>>>
90996>>>>>>>        Move (aIndexFrom.iIndexNumber = aIndexTo.iIndexNumber) to bIsSame
90997>>>>>>>        If (bIsSame = False) Begin
90999>>>>>>>            Function_Return False
91000>>>>>>>        End
91000>>>>>>>>
91000>>>>>>>
91000>>>>>>>        If (bDAWSQLDriver = True and bIsSqlTable = True) Begin
91002>>>>>>>            // Don't think we should do this. Or should we?
91002>>>>>>>            // Move (aIndexesFrom[iCount].sSQLIndexName = aIndexesTo[iCount].sSQLIndexName) to bIsSame
91002>>>>>>>
91002>>>>>>>            Move (aIndexFrom.iSQLIndexType = aIndexTo.iSQLIndexType) to bIsSame
91003>>>>>>>            If (bIsSame = False) Begin
91005>>>>>>>                Function_Return False
91006>>>>>>>            End
91006>>>>>>>>
91006>>>>>>>            Move (aIndexFrom.iPrimaryIndex = aIndexTo.iPrimaryIndex) to bIsSame
91007>>>>>>>            If (bIsSame = False) Begin
91009>>>>>>>                Function_Return False
91010>>>>>>>            End
91010>>>>>>>>
91010>>>>>>>            Move (aIndexFrom.bIsSQLPrimaryKey = aIndexTo.bIsSQLPrimaryKey) to bIsSame
91011>>>>>>>            If (bIsSame = False) Begin
91013>>>>>>>                Function_Return False
91014>>>>>>>            End
91014>>>>>>>>
91014>>>>>>>            Move (aIndexFrom.bIsSQLClustered = aIndexTo.bIsSQLClustered) to bIsSame
91015>>>>>>>            If (bIsSame = False) Begin
91017>>>>>>>                Function_Return False
91018>>>>>>>            End
91018>>>>>>>>
91018>>>>>>>        End
91018>>>>>>>>
91018>>>>>>>
91018>>>>>>>        Function_Return bIsSame
91019>>>>>>>    End_Function
91020>>>>>>>
91020>>>>>>>    // DF_INDEX_SQL_TYPE values
91020>>>>>>>    // Pass one of the DF_INDEX_XXX integer constants and the function
91020>>>>>>>    // returns a string with the name.
91020>>>>>>>    Function UtilIndexTypeToString Integer iIndexType Returns String
91022>>>>>>>        String sRetval
91022>>>>>>>            Case Begin
91022>>>>>>>                Case (iIndexType = DF_INDEX_CLIENT)
91024>>>>>>>                    Move "DF_INDEX_CLIENT" to sRetval
91025>>>>>>>                    Case Break
91026>>>>>>>                Case (iIndexType = DF_INDEX_SERVER)
91029>>>>>>>                    Move "DF_INDEX_SERVER" to sRetval
91030>>>>>>>                    Case Break
91031>>>>>>>                Case (iIndexType = DF_INDEX_SERVER_ONLY)
91034>>>>>>>                    Move "DF_INDEX_SERVER_ONLY" to sRetval
91035>>>>>>>                    Case Break
91036>>>>>>>                Case (iIndexType = DF_INDEX_TEMPORARY)
91039>>>>>>>                    Move "DF_INDEX_TEMPORARY" to sRetval
91040>>>>>>>                    Case Break
91041>>>>>>>                Case Else
91041>>>>>>>                    Move "UNKNOWN INDEX TYPE" to sRetval
91042>>>>>>>            Case End
91042>>>>>>>        Function_Return sRetval
91043>>>>>>>    End_Function
91044>>>>>>>
91044>>>>>>>    // * Dummy function for the Studio's Code Explorer *
91044>>>>>>>    Function API_RELATION_UTILITY_FUNCTIONS Returns Boolean
91046>>>>>>>        Function_Return False
91047>>>>>>>    End_Function
91048>>>>>>>
91048>>>>>>>    // Compares multiple relationships for a 'FROM' and a 'TO' databases
91048>>>>>>>    Function UtilRelationsCompare Handle hTable tAPIRelationCompare[] aAPIRelationCompare Returns Boolean
91050>>>>>>>        Boolean bIsSame
91050>>>>>>>        Integer iSize iCount
91050>>>>>>>
91050>>>>>>>        Move True to bIsSame
91051>>>>>>>        Move (SizeOfArray(aAPIRelationCompare)) to iSize
91052>>>>>>>        Decrement iSize
91053>>>>>>>        For iCount from 0 to iSize
91059>>>>>>>>
91059>>>>>>>            Get UtilRelationCompare hTable aAPIRelationCompare[iCount] to bIsSame
91060>>>>>>>            If (bIsSame = False) Begin
91062>>>>>>>                Function_Return False
91063>>>>>>>            End
91063>>>>>>>>
91063>>>>>>>        Loop
91064>>>>>>>>
91064>>>>>>>
91064>>>>>>>        Function_Return bIsSame
91065>>>>>>>    End_Function
91066>>>>>>>
91066>>>>>>>    // Compares a single relationship for a 'FROM' and a 'TO' table
91066>>>>>>>    Function UtilRelationCompare Handle hTable tAPIRelationCompare APIRelationCompare Returns Boolean
91068>>>>>>>        Boolean bIsSame
91068>>>>>>>
91068>>>>>>>        Move True to bIsSame
91069>>>>>>>        If (APIRelationCompare.bExistsFrom <> APIRelationCompare.bExistsTo) Begin
91071>>>>>>>            Function_Return False
91072>>>>>>>        End
91072>>>>>>>>
91072>>>>>>>        If (APIRelationCompare.hTableFrom = 0 or APIRelationCompare.hTableTo = 0) Begin
91074>>>>>>>            Function_Return False
91075>>>>>>>        End
91075>>>>>>>>
91075>>>>>>>
91075>>>>>>>        // We could also compare field names, but I don't think that is necessary...
91075>>>>>>>
91075>>>>>>>        Function_Return bIsSame
91076>>>>>>>    End_Function
91077>>>>>>>
91077>>>>>>>    // This message is different from ApiTableCreate in that it will not do a function_return if the table
91077>>>>>>>    // already exists.
91077>>>>>>>    Function UtilRelationsUpdate Handle hTable tAPIRelation[] aRelationsFrom tAPIRelation[] aRelationsTo Returns Boolean
91079>>>>>>>        Boolean bOK
91079>>>>>>>        Integer iSizeTo iSize iCount iColumn
91079>>>>>>>        String sDriverID
91079>>>>>>>
91079>>>>>>>        Move True to bOK
91080>>>>>>>        Move (SizeOfArray(aRelationsTo))   to iSizeTo
91081>>>>>>>        If (iSizeTo > 0) Begin
91083>>>>>>>            Get AutoConnectionIDLogin to bOK
91084>>>>>>>            Move False to Err
91085>>>>>>>            Open hTable Mode DF_EXCLUSIVE
91087>>>>>>>            Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
91090>>>>>>>            Decrement iSizeTo
91091>>>>>>>
91091>>>>>>>            // We should probably not make any comparison between "FROM" and "TO" database; instead just create all "FROM" relations
91091>>>>>>>            // for the "TO" database. But start by deleting all current "TO" relations:
91091>>>>>>>            Structure_Start hTable sDriverID
91092>>>>>>>                for iCount from 0 to iSizeTo
91098>>>>>>>>
91098>>>>>>>                    Move aRelationsTo[iCount].iColumnFrom to iColumn
91099>>>>>>>                    Set_Attribute DF_FIELD_RELATED_FILE  of hTable iColumn to 0
91102>>>>>>>                    Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn to 0
91105>>>>>>>                Loop
91106>>>>>>>>
91106>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
91107>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
91109>>>>>>>            Set Action_Text of ghoStatusPanel to ""
91110>>>>>>>        End
91110>>>>>>>>
91110>>>>>>>
91110>>>>>>>        Move (SizeOfArray(aRelationsFrom)) to iSize
91111>>>>>>>        Decrement iSize
91112>>>>>>>        for iCount from 0 to iSize
91118>>>>>>>>
91118>>>>>>>            Get ApiTableRelate aRelationsFrom[iCount].hTableFrom aRelationsFrom[iCount].hTableTo aRelationsFrom[iCount].iColumnFrom aRelationsFrom[iCount].iColumnTo aRelationsTo to bOK
91119>>>>>>>        Loop
91120>>>>>>>>
91120>>>>>>>
91120>>>>>>>        Function_Return bOK
91121>>>>>>>    End_Function
91122>>>>>>>
91122>>>>>>>    Function UtilRelationsStructFill Handle hTable Returns tAPIRelation[]
91124>>>>>>>        tAPIRelation[] APIRelations
91124>>>>>>>        tAPIRelation[] APIRelations
91125>>>>>>>        Integer iColumn iColumnTo iNumColumns iCount
91125>>>>>>>        Handle hParent
91125>>>>>>>        Boolean bIsOpen
91125>>>>>>>
91125>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
91126>>>>>>>        Move 0 to iCount
91127>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
91130>>>>>>>        If (bIsOpen = False) Begin
91132>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91133>>>>>>>            Open hTable
91135>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91136>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
91139>>>>>>>            If (bIsOpen = False) Begin
91141>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
91142>>>>>>>                Move True to APIRelations[0].bError
91143>>>>>>>                Function_Return APIRelations
91144>>>>>>>            End
91144>>>>>>>>
91144>>>>>>>        End
91144>>>>>>>>
91144>>>>>>>
91144>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
91147>>>>>>>        For iColumn from 1 to iNumColumns
91153>>>>>>>>
91153>>>>>>>            Get_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to hParent
91156>>>>>>>            If (hParent <> 0) Begin
91158>>>>>>>                Open hParent
91160>>>>>>>                Move hTable                                             to APIRelations[iCount].hTableFrom
91161>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable            to APIRelations[iCount].sLogicalNameFrom
91164>>>>>>>                Move iColumn                                            to APIRelations[iCount].iColumnFrom
91165>>>>>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn           to APIRelations[iCount].sFieldNameFrom
91168>>>>>>>
91168>>>>>>>                Move hParent                                            to APIRelations[iCount].hTableTo
91169>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hParent           to APIRelations[iCount].sLogicalNameTo
91172>>>>>>>                Get_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn  to iColumnTo
91175>>>>>>>                Move iColumnTo                                          to APIRelations[iCount].iColumnTo
91176>>>>>>>                Get_Attribute DF_FIELD_NAME of hParent iColumnTo        to APIRelations[iCount].sFieldNameTo
91179>>>>>>>                Move False                                              to APIRelations[iCount].bShouldChange
91180>>>>>>>                Move False                                              to APIRelations[iCount].bCancel
91181>>>>>>>                Move False                                              to APIRelations[iCount].bError
91182>>>>>>>                Close hParent
91183>>>>>>>                Increment iCount
91184>>>>>>>            End
91184>>>>>>>>
91184>>>>>>>        Loop
91185>>>>>>>>
91185>>>>>>>
91185>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
91186>>>>>>>        Function_Return APIRelations
91187>>>>>>>    End_Function
91188>>>>>>>
91188>>>>>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
91188>>>>>>>    // The combined data will be sorted on the first 4 struct members: hTableFrom, iColumnFrom, hTableTo and iColumnTo
91188>>>>>>>    Function UtilRelationCombineFromAndToArrays tAPIRelation[] aAPIRelationFrom tAPIRelation[] aAPIRelationTo Returns tAPIIndexCompare[]
91190>>>>>>>        tAPIRelation[] aAPIRelationFromAndTo
91190>>>>>>>        tAPIRelation[] aAPIRelationFromAndTo
91191>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
91191>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
91192>>>>>>>        tAPIRelationCompare   APIRelationCompare
91192>>>>>>>        tAPIRelationCompare   APIRelationCompare
91192>>>>>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
91192>>>>>>>
91192>>>>>>>        Move (SizeOfArray(aAPIRelationFrom)) to iSizeFrom
91193>>>>>>>        Move (SizeOfArray(aAPIRelationTo))   to iSizeTo
91194>>>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
91196>>>>>>>            Function_Return aAPIRelationCompare
91197>>>>>>>        End
91197>>>>>>>>
91197>>>>>>>
91197>>>>>>>        Move (AppendArray(aAPIRelationFrom, aAPIRelationTo)) to aAPIRelationFromAndTo
91198>>>>>>>        Move (SortArray(aAPIRelationFromAndTo, Self, RefFunc(__UtilRelationArrayCompare))) to aAPIRelationFromAndTo
91199>>>>>>>
91199>>>>>>>        Decrement iSizeFrom
91200>>>>>>>        for iCount from 0 to iSizeFrom
91206>>>>>>>>
91206>>>>>>>            Move aAPIRelationFrom[iCount].hTableFrom        to aAPIRelationCompare[iCount].hTableFrom
91207>>>>>>>            Move aAPIRelationFrom[iCount].iColumnFrom       to aAPIRelationCompare[iCount].iColumnFrom
91208>>>>>>>            Move aAPIRelationFrom[iCount].hTableTo          to aAPIRelationCompare[iCount].hTableTo
91209>>>>>>>            Move aAPIRelationFrom[iCount].iColumnTo         to aAPIRelationCompare[iCount].iColumnTo
91210>>>>>>>            Move aAPIRelationFrom[iCount].sLogicalNameFrom  to aAPIRelationCompare[iCount].sLogicalNameFrom_From
91211>>>>>>>            Move aAPIRelationFrom[iCount].sLogicalNameTo    to aAPIRelationCompare[iCount].sLogicalNameTo_From
91212>>>>>>>            Move aAPIRelationFrom[iCount].sFieldNameFrom    to aAPIRelationCompare[iCount].sFieldNameFrom_From
91213>>>>>>>            Move aAPIRelationFrom[iCount].sFieldNameTo      to aAPIRelationCompare[iCount].sFieldNameTo_From
91214>>>>>>>            Move aAPIRelationFrom[iCount].bShouldChange     to aAPIRelationCompare[iCount].bShouldChange_From
91215>>>>>>>            Move aAPIRelationFrom[iCount].bCancel           to aAPIRelationCompare[iCount].bCancel_From
91216>>>>>>>            Move aAPIRelationFrom[iCount].bError            to aAPIRelationCompare[iCount].bError_From
91217>>>>>>>            Move True                                       to aAPIRelationCompare[iCount].bExistsFrom
91218>>>>>>>        Loop
91219>>>>>>>>
91219>>>>>>>
91219>>>>>>>        Decrement iSizeTo
91220>>>>>>>        for iCount from 0 to iSizeTo
91226>>>>>>>>
91226>>>>>>>            Move aAPIRelationTo[iCount].hTableFrom          to APIRelationCompare.hTableFrom
91227>>>>>>>            Move aAPIRelationTo[iCount].iColumnFrom         to APIRelationCompare.iColumnFrom
91228>>>>>>>            Move aAPIRelationTo[iCount].hTableTo            to APIRelationCompare.hTableTo
91229>>>>>>>            Move aAPIRelationTo[iCount].iColumnTo           to APIRelationCompare.iColumnTo
91230>>>>>>>
91230>>>>>>>            // Search if the relation already exists in the array; else add it.
91230>>>>>>>            Move (SearchArray(APIRelationCompare, aAPIRelationCompare, Self, RefFunc(__SearchRelationCompare))) to iItem
91231>>>>>>>            If (iItem = -1) Begin
91233>>>>>>>                Move (SizeOfArray(aAPIRelationCompare))     to iItem
91234>>>>>>>            End
91234>>>>>>>>
91234>>>>>>>
91234>>>>>>>            Move APIRelationCompare.hTableFrom              to aAPIRelationCompare[iItem].hTableFrom
91235>>>>>>>            Move APIRelationCompare.iColumnFrom             to aAPIRelationCompare[iItem].iColumnFrom
91236>>>>>>>            Move APIRelationCompare.hTableTo                to aAPIRelationCompare[iItem].hTableTo
91237>>>>>>>            Move APIRelationCompare.iColumnTo               to aAPIRelationCompare[iItem].iColumnTo
91238>>>>>>>            Move aAPIRelationTo[iCount].sLogicalNameFrom    to aAPIRelationCompare[iItem].sLogicalNameFrom_To
91239>>>>>>>            Move aAPIRelationTo[iCount].sLogicalNameTo      to aAPIRelationCompare[iItem].sLogicalNameTo_To
91240>>>>>>>            Move aAPIRelationTo[iCount].sFieldNameFrom      to aAPIRelationCompare[iItem].sFieldNameFrom_To
91241>>>>>>>            Move aAPIRelationTo[iCount].sFieldNameTo        to aAPIRelationCompare[iItem].sFieldNameTo_To
91242>>>>>>>            Move aAPIRelationTo[iCount].bShouldChange       to aAPIRelationCompare[iItem].bShouldChange_To
91243>>>>>>>            Move aAPIRelationTo[iCount].bCancel             to aAPIRelationCompare[iItem].bCancel_To
91244>>>>>>>            Move aAPIRelationTo[iCount].bError              to aAPIRelationCompare[iItem].bError_To
91245>>>>>>>            Move True                                       to aAPIRelationCompare[iItem].bExistsTo
91246>>>>>>>        Loop
91247>>>>>>>>
91247>>>>>>>
91247>>>>>>>        Move (SortArray(aAPIRelationCompare, Self, RefFunc(__SearchRelationCompare))) to aAPIRelationCompare
91248>>>>>>>
91248>>>>>>>        Function_Return aAPIRelationCompare
91249>>>>>>>    End_Function
91250>>>>>>>
91250>>>>>>>    // * Dummy function for the Studio's Code Explorer *
91250>>>>>>>    Function CODEMAST_UTILITY_FUNCTIONS Returns Boolean
91252>>>>>>>        Function_Return False
91253>>>>>>>    End_Function
91254>>>>>>>
91254>>>>>>>    // To add a value to the CodeMast & CodeType tables. Pass; a) bCodeType if it is CodeType that should be updated.
91254>>>>>>>    // Else it is CodeMast. b) sTypeValue; either to be added If bCodeType = True, or it will be used to find the correct
91254>>>>>>>    // CodeType record. c) sValue1 and d) sValue2 is the CodeType Description & Comment, or CodeMast Type and Code values.
91254>>>>>>>    Function UtilCodeMasterAddValue Boolean bCodeType String sTypeValue String sValue2 String sValue3 Returns Boolean
91256>>>>>>>        Boolean bFound
91256>>>>>>>
91256>>>>>>>        Move False to Err
91257>>>>>>>        Open CodeMast
91259>>>>>>>        Open CodeType
91261>>>>>>>
91261>>>>>>>        If (bCodeType = True) Begin
91263>>>>>>>            Set Private.phCurrentTable to CODETYPE.File_Number
91264>>>>>>>            Clear CodeType
91265>>>>>>>            Move sTypeValue to CODETYPE.Type
91266>>>>>>>            Find eq CODETYPE by 1
91267>>>>>>>>
91267>>>>>>>            Move Found to bFound
91268>>>>>>>            If (bFound = True) Begin
91270>>>>>>>                Reread CodeType
91274>>>>>>>            End
91274>>>>>>>>
91274>>>>>>>            Else Begin
91275>>>>>>>                Clear CodeType
91276>>>>>>>            End
91276>>>>>>>>
91276>>>>>>>
91276>>>>>>>            Move sTypeValue to CODETYPE.Type
91277>>>>>>>            Move sValue2    to CODETYPE.Description
91278>>>>>>>            Move sValue3    to CODETYPE.Comment
91279>>>>>>>            SaveRecord CODETYPE
91280>>>>>>>
91280>>>>>>>            If (bFound = True) Begin
91282>>>>>>>                Unlock
91283>>>>>>>>
91283>>>>>>>            End
91283>>>>>>>>
91283>>>>>>>        End
91283>>>>>>>>
91283>>>>>>>
91283>>>>>>>        If (bCodeType = False) Begin
91285>>>>>>>            Set Private.phCurrentTable to CODEMAST.File_Number
91286>>>>>>>            Clear CODEMAST
91287>>>>>>>            Move sTypeValue to CODEMAST.Type
91288>>>>>>>            Move sValue2    to CODEMAST.Code
91289>>>>>>>            Find eq CODEMAST by 1
91290>>>>>>>>
91290>>>>>>>            Move Found to bFound
91291>>>>>>>            If (bFound = True) Begin
91293>>>>>>>                Reread CODEMAST
91297>>>>>>>            End
91297>>>>>>>>
91297>>>>>>>            Else Begin
91298>>>>>>>                Clear CODEMAST
91299>>>>>>>            End
91299>>>>>>>>
91299>>>>>>>
91299>>>>>>>            Move sTypeValue to CODEMAST.Type
91300>>>>>>>            Move sValue2    to CODEMAST.Code
91301>>>>>>>            Move sValue3    to CODEMAST.Description
91302>>>>>>>            SaveRecord CODEMAST
91303>>>>>>>
91303>>>>>>>            If (bFound = True) Begin
91305>>>>>>>                Unlock
91306>>>>>>>>
91306>>>>>>>            End
91306>>>>>>>>
91306>>>>>>>        End
91306>>>>>>>>
91306>>>>>>>
91306>>>>>>>        Close CodeMast
91307>>>>>>>        Close CodeType
91308>>>>>>>
91308>>>>>>>        Function_Return (Err = False)
91309>>>>>>>    End_Function
91310>>>>>>>
91310>>>>>>>    // Changes values in CodeType & CodeMast - From type value To type value. It first changes the type value in
91310>>>>>>>    // CodeType and then spins through all CodeMast records to change all related records.
91310>>>>>>>    Function UtilCodeMasterChangeValue String sFromValue String sToValue Returns Boolean
91312>>>>>>>        Boolean bFound
91312>>>>>>>
91312>>>>>>>        Move False to Err
91313>>>>>>>        Open CodeMast
91315>>>>>>>        Open CodeType
91317>>>>>>>
91317>>>>>>>        Clear CodeType
91318>>>>>>>        Move sFromValue to CODETYPE.Type
91319>>>>>>>        Find eq CODETYPE.Type
91320>>>>>>>>
91320>>>>>>>        If (Found = True) Begin
91322>>>>>>>            Reread CODETYPE
91326>>>>>>>                Move sToValue to CODETYPE.Type
91327>>>>>>>                SaveRecord CODETYPE
91328>>>>>>>            Unlock
91329>>>>>>>>
91329>>>>>>>        End
91329>>>>>>>>
91329>>>>>>>
91329>>>>>>>        Clear CODEMAST
91330>>>>>>>        Find gt CODEMAST by Recnum
91331>>>>>>>>
91331>>>>>>>        While (Found = True)
91335>>>>>>>            Move (Trim(Uppercase(CODEMAST.Type) = Trim(Uppercase(sFromValue)))) to bFound
91336>>>>>>>            If (bFound = True) Begin
91338>>>>>>>                Reread CODEMAST
91342>>>>>>>                    Move sToValue to CODEMAST.Type
91343>>>>>>>                    SaveRecord CODEMAST
91344>>>>>>>                Unlock
91345>>>>>>>>
91345>>>>>>>            End
91345>>>>>>>>
91345>>>>>>>            Find gt CODEMAST by Recnum
91346>>>>>>>>
91346>>>>>>>        Loop
91347>>>>>>>>
91347>>>>>>>
91347>>>>>>>        Close CodeMast
91348>>>>>>>        Close CodeType
91349>>>>>>>
91349>>>>>>>        Function_Return (Err = False)
91350>>>>>>>    End_Function
91351>>>>>>>
91351>>>>>>>    // Removes a value from CodeMast. Pass the sTypeValue and the sValue2 to remove.
91351>>>>>>>    Function UtilCodeMasterRemoveValue String sTypeValue String sValue2 Returns Boolean
91353>>>>>>>        Boolean bFound
91353>>>>>>>
91353>>>>>>>        Move False to Err
91354>>>>>>>        Open CodeMast
91356>>>>>>>
91356>>>>>>>        Clear CODEMAST
91357>>>>>>>        Move sTypeValue to CODEMAST.Type
91358>>>>>>>        Move sValue2    to CODEMAST.Code
91359>>>>>>>        Find eq CODEMAST.Code
91360>>>>>>>>
91360>>>>>>>        Move Found to bFound
91361>>>>>>>        If (bFound = True) Begin
91363>>>>>>>            Delete CODEMAST
91364>>>>>>>        End
91364>>>>>>>>
91364>>>>>>>
91364>>>>>>>        Close CodeMast
91365>>>>>>>
91365>>>>>>>        Function_Return (Err = False)
91366>>>>>>>    End_Function
91367>>>>>>>
91367>>>>>>>    Function UtilTableCreateCodeMastCodeTypeIntFiles String sDataPath Returns Boolean
91369>>>>>>>        Boolean bRecnum bToAnsi
91369>>>>>>>        Integer iCh
91369>>>>>>>        String sFileName sDriverID sConnectionID sSchemaName sANSI_OEM
91369>>>>>>>
91369>>>>>>>        If (Trim(sDataPath) = "") Begin
91371>>>>>>>            Function_Return False
91372>>>>>>>        End
91372>>>>>>>>
91372>>>>>>>
91372>>>>>>>        Move False to Err
91373>>>>>>>        Get psDriverID     to sDriverID
91374>>>>>>>        Get psConnectionID to sConnectionID
91375>>>>>>>        Get psSchema       to sSchemaName
91376>>>>>>>        Get True           to bRecnum
91377>>>>>>>        Get pbToANSI       to bToAnsi
91378>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
91379>>>>>>>        If (bToAnsi = False) Begin
91381>>>>>>>            Move CS_OEM_Txt to sANSI_OEM
91382>>>>>>>        End
91382>>>>>>>>
91382>>>>>>>
91382>>>>>>>        Get vFolderFormat sDataPath to sDataPath
91383>>>>>>>        Move "CodeMast.int"         to sFileName
91384>>>>>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
91385>>>>>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
91388>>>>>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
91391>>>>>>>            Writeln channel iCh ("DATABASE_NAME CODEMAST")
91394>>>>>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
91397>>>>>>>            Writeln channel iCh ("")
91400>>>>>>>            Writeln channel iCh ("RECNUM_TABLE YES")
91403>>>>>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
91406>>>>>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
91409>>>>>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
91412>>>>>>>            Writeln channel iCh ("")
91415>>>>>>>            Writeln channel iCh ("INDEX_NUMBER 1")
91418>>>>>>>            Writeln channel iCh ("INDEX_NAME CODEMAST001_PK")
91421>>>>>>>            Writeln channel iCh ("")
91424>>>>>>>        Send Seq_Close_Channel iCh
91425>>>>>>>
91425>>>>>>>        Get vFolderFormat sDataPath to sDataPath
91426>>>>>>>        Move "CodeType.int"         to sFileName
91427>>>>>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
91428>>>>>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
91431>>>>>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
91434>>>>>>>            Writeln channel iCh ("DATABASE_NAME CODETYPE")
91437>>>>>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
91440>>>>>>>            Writeln channel iCh ("")
91443>>>>>>>            Writeln channel iCh ("RECNUM_TABLE YES")
91446>>>>>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
91449>>>>>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
91452>>>>>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
91455>>>>>>>            Writeln channel iCh ("")
91458>>>>>>>            Writeln channel iCh ("INDEX_NUMBER 0")
91461>>>>>>>            Writeln channel iCh ("INDEX_NAME CODETYPE000")
91464>>>>>>>            Writeln channel iCh ("")
91467>>>>>>>            Writeln channel iCh ("INDEX_NUMBER 1")
91470>>>>>>>            Writeln channel iCh ("INDEX_NAME CODETYPE001_PK")
91473>>>>>>>            Writeln channel iCh ("")
91476>>>>>>>        Send Seq_Close_Channel iCh
91477>>>>>>>
91477>>>>>>>        Function_Return (Err = False)
91478>>>>>>>    End_Function
91479>>>>>>>
91479>>>>>>>    // * Dummy function for the Studio's Code Explorer *
91479>>>>>>>    Function OTHER_UTILITY_FUNCTIONS Returns Boolean
91481>>>>>>>        Function_Return False
91482>>>>>>>    End_Function
91483>>>>>>>
91483>>>>>>>    // Use function to move *.fd, termlist.*, collate.*, dfcollate.* files to a "Data\Backup" folder,
91483>>>>>>>    // and to remove all *.cch files (DAW SQL driver cache files. They will get recreated when needed.)
91483>>>>>>>    Function UtilMoveMiscFilesToBackupFolder Returns Boolean
91485>>>>>>>        Boolean bOK bExists
91485>>>>>>>        String sDataPath sBackupFolder
91485>>>>>>>
91485>>>>>>>        Set Message_Text of ghoStatusPanel to "Moving misc. files to Backup folder."
91486>>>>>>>        Move CS_DUFBackupDataFolder to sBackupFolder
91487>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
91488>>>>>>>        Get vFolderFormat sDataPath to sDataPath
91489>>>>>>>
91489>>>>>>>        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
91490>>>>>>>        If (bExists = False) Begin
91492>>>>>>>            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
91493>>>>>>>            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
91494>>>>>>>            If (bExists = False) Begin
91496>>>>>>>                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all misc. files to. You need to move them somewhere manually.")
91497>>>>>>>>
91497>>>>>>>                Function_Return False
91498>>>>>>>            End
91498>>>>>>>>
91498>>>>>>>            Get vMoveFile (sDataPath + "*.fd")         (sDataPath + sBackupFolder) to bOK  
91499>>>>>>>            Get vMoveFile (sDataPath + "*.bad")        (sDataPath + sBackupFolder) to bOK  
91500>>>>>>>            Get vMoveFile (sDataPath + "*.err")        (sDataPath + sBackupFolder) to bOK  
91501>>>>>>>            Get vMoveFile (sDataPath + "*.bak")        (sDataPath + sBackupFolder) to bOK
91502>>>>>>>            Get vMoveFile (sDataPath + "*.def")        (sDataPath + sBackupFolder) to bOK
91503>>>>>>>            Get vMoveFile (sDataPath + "*.fil")        (sDataPath + sBackupFolder) to bOK
91504>>>>>>>            Get vMoveFile (sDataPath + "*.hlp")        (sDataPath + sBackupFolder) to bOK
91505>>>>>>>            Get vMoveFile (sDataPath + "*.old")        (sDataPath + sBackupFolder) to bOK           
91506>>>>>>>            Get vMoveFile (sDataPath + "*.prn")        (sDataPath + sBackupFolder) to bOK           
91507>>>>>>>            Get vMoveFile (sDataPath + "*.sts")        (sDataPath + sBackupFolder) to bOK           
91508>>>>>>>            Get vMoveFile (sDataPath + "*.td")         (sDataPath + sBackupFolder) to bOK           
91509>>>>>>>            Get vMoveFile (sDataPath + "*.log")        (sDataPath + sBackupFolder) to bOK           
91510>>>>>>>            Get vMoveFile (sDataPath + "*.bat")        (sDataPath + sBackupFolder) to bOK           
91511>>>>>>>            Get vMoveFile (sDataPath + "*.cmd")        (sDataPath + sBackupFolder) to bOK           
91512>>>>>>>            Get vMoveFile (sDataPath + "*.zip")        (sDataPath + sBackupFolder) to bOK           
91513>>>>>>>            Get vMoveFile (sDataPath + "*.abs")        (sDataPath + sBackupFolder) to bOK           
91514>>>>>>>            Get vMoveFile (sDataPath + "termlist.*")   (sDataPath + sBackupFolder) to bOK
91515>>>>>>>            Get vMoveFile (sDataPath + "*.dfr")        (sDataPath + sBackupFolder) to bOK
91516>>>>>>>            Get vMoveFile (sDataPath + "vsutil.cfg")   (sDataPath + sBackupFolder) to bOK
91517>>>>>>>            Get vMoveFile (sDataPath + "collate.*")    (sDataPath + sBackupFolder) to bOK
91518>>>>>>>            Get vMoveFile (sDataPath + "df_collate.*") (sDataPath + sBackupFolder) to bOK
91519>>>>>>>            Get vDeleteFile (sDataPath + "*.cch")                                  to bOK
91520>>>>>>>        End
91520>>>>>>>>
91520>>>>>>>
91520>>>>>>>        Set Message_Text of ghoStatusPanel to ""
91521>>>>>>>        Function_Return True
91522>>>>>>>    End_Function
91523>>>>>>>    
91523>>>>>>>    // Check if the file exists in the Data folder,
91523>>>>>>>    // else creates it from memory as it has been compiled into the program as a resource:
91523>>>>>>>    Function UtilCheckCreateIfFileExists String sFileName String sResourceName Boolean bDataFile Returns Boolean
91525>>>>>>>        String sPath
91525>>>>>>>        Boolean bExists
91525>>>>>>>
91525>>>>>>>        Get psDataPathFirstPart to sPath
91526>>>>>>>        Move (sPath + sFileName) to sFileName
91527>>>>>>>        Get vFilePathExists sFileName to bExists
91528>>>>>>>
91528>>>>>>>        If (bExists = False) Begin
91530>>>>>>>            // Read from memory & create file on disk.
91530>>>>>>>            Send SqlUtilCreateFileFromMemory sResourceName sFileName
91531>>>>>>>            Get vFilePathExists sFileName to bExists
91532>>>>>>>        End
91532>>>>>>>>
91532>>>>>>>        Function_Return bExists
91533>>>>>>>    End_Function
91534>>>>>>>
91534>>>>>>>    Function UtilSqlColumnTypeToDataFlexType String sDriverID Integer iDbType Integer iDataType Integer iLength Returns Integer
91536>>>>>>>        tColumnType RetvalType
91536>>>>>>>        tColumnType RetvalType
91536>>>>>>>        Integer iRetval
91536>>>>>>>
91536>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
91537>>>>>>>        Move RetvalType.iDataFlexType to iRetval
91538>>>>>>>        If (RetvalType.iDataFlexType = DF_TEXT) Begin
91540>>>>>>>            If (iLength <= 255) Begin
91542>>>>>>>                Move DF_ASCII to iRetval
91543>>>>>>>            End
91543>>>>>>>>
91543>>>>>>>        End
91543>>>>>>>>
91543>>>>>>>        Function_Return iRetval
91544>>>>>>>    End_Function
91545>>>>>>>
91545>>>>>>>    Function UtilDataFlexDataTypeToString Integer iDataType Returns String
91547>>>>>>>        String sRetval
91547>>>>>>>
91547>>>>>>>        Case Begin
91547>>>>>>>            Case (iDataType = DF_ASCII)
91549>>>>>>>                Move "DF_ASCII" to sRetval
91550>>>>>>>                Case Break
91551>>>>>>>            Case (iDataType = DF_BCD)
91554>>>>>>>                Move "DF_BCD" to sRetval
91555>>>>>>>                Case Break
91556>>>>>>>            Case (iDataType = DF_BINARY)
91559>>>>>>>                Move "DF_BINARY" to sRetval
91560>>>>>>>                Case Break
91561>>>>>>>            Case (iDataType = DF_DATE)
91564>>>>>>>                Move "DF_DATE" to sRetval
91565>>>>>>>                Case Break
91566>>>>>>>            Case (iDataType = DF_DATETIME)
91569>>>>>>>                Move "DF_DATETIME" to sRetval
91570>>>>>>>                Case Break
91571>>>>>>>            Case (iDataType = DF_TEXT)
91574>>>>>>>                Move "DF_TEXT" to sRetval
91575>>>>>>>                Case Break
91576>>>>>>>            Case Else
91576>>>>>>>                Move "" to sRetval
91577>>>>>>>        Case End
91577>>>>>>>
91577>>>>>>>        Function_Return sRetval
91578>>>>>>>    End_Function
91579>>>>>>>
91579>>>>>>>    // The default value used for a datatype as specified in the driver int file.
91579>>>>>>>    Function UtilDataTypeDefaultValue String sDriverID Integer iDbType Integer iDataType Returns String
91581>>>>>>>        String sRetval sServer
91581>>>>>>>        tColumnType RetvalType
91581>>>>>>>        tColumnType RetvalType
91581>>>>>>>        Integer iDriver iDataFlexType
91581>>>>>>>        Handle hDatabase
91581>>>>>>>
91581>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
91582>>>>>>>        Move RetvalType.iDataFlexType to iDataFlexType
91583>>>>>>>        Get DriverIndex sDriverID to iDriver
91584>>>>>>>        Get psServer to sServer
91585>>>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
91586>>>>>>>        If (hDatabase = 0) Begin
91588>>>>>>>            Function_Return ""
91589>>>>>>>        End
91589>>>>>>>>
91589>>>>>>>
91589>>>>>>>        Case Begin
91589>>>>>>>            Case (iDataFlexType = DF_ASCII)
91591>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_ASCII     of iDriver hDatabase to sRetval
91594>>>>>>>                Case Break
91595>>>>>>>            Case (iDataFlexType = DF_BCD)
91598>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_NUMERIC   of iDriver hDatabase to sRetval
91601>>>>>>>                Case Break
91602>>>>>>>            Case (iDataFlexType = DF_BINARY)
91605>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_BINARY    of iDriver hDatabase to sRetval
91608>>>>>>>                Case Break
91609>>>>>>>            Case (iDataFlexType = DF_DATE)
91612>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE      of iDriver hDatabase to sRetval
91615>>>>>>>                Case Break
91616>>>>>>>            Case (iDataFlexType = DF_DATETIME)
91619>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME  of iDriver hDatabase to sRetval
91622>>>>>>>                Case Break
91623>>>>>>>            Case (iDataFlexType = DF_TEXT)
91626>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_TEXT      of iDriver hDatabase to sRetval
91629>>>>>>>                Case Break
91630>>>>>>>            Case Else
91630>>>>>>>                Move "" to sRetval
91631>>>>>>>        Case End
91631>>>>>>>
91631>>>>>>>        Function_Return sRetval
91632>>>>>>>    End_Function
91633>>>>>>>
91633>>>>>>>    Procedure Set Df_Database_Default_Default_Date_DUF String sDateValue
91635>>>>>>>        String sDriverID sServer
91635>>>>>>>        tColumnType RetvalType
91635>>>>>>>        tColumnType RetvalType
91635>>>>>>>        Integer iDbType iDriver
91635>>>>>>>        Handle hDatabase
91635>>>>>>>
91635>>>>>>>        Get psDriverID to sDriverID
91636>>>>>>>        Get piDbType   to iDbType
91637>>>>>>>        Get DriverIndex sDriverID to iDriver
91638>>>>>>>        Get psServer to sServer
91639>>>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
91640>>>>>>>        If (hDatabase = 0) Begin
91642>>>>>>>            Error DFERR_PROGRAM "Could not change the Default Date Value. Could not get a handle to the database. (Check that at least one connection is 'Enabled')"
91643>>>>>>>>
91643>>>>>>>            Procedure_Return
91644>>>>>>>        End
91644>>>>>>>>
91644>>>>>>>
91644>>>>>>>        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE of iDriver hDatabase to sDateValue
91647>>>>>>>
91647>>>>>>>    End_Procedure
91648>>>>>>>
91648>>>>>>>    Procedure Set Df_Database_Default_Default_Datetime_DUF String sDateValue
91650>>>>>>>        String sDriverID sServer
91650>>>>>>>        tColumnType RetvalType
91650>>>>>>>        tColumnType RetvalType
91650>>>>>>>        Integer iDbType iDriver
91650>>>>>>>        Handle hDatabase
91650>>>>>>>
91650>>>>>>>        Get psDriverID to sDriverID
91651>>>>>>>        Get piDbType   to iDbType
91652>>>>>>>        Get DriverIndex sDriverID to iDriver
91653>>>>>>>        Get psServer to sServer
91654>>>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
91655>>>>>>>        If (hDatabase = 0) Begin
91657>>>>>>>            Error DFERR_PROGRAM "Could not change the Default DateTime Value. Could not get a handle to the database."
91658>>>>>>>>
91658>>>>>>>            Procedure_Return
91659>>>>>>>        End
91659>>>>>>>>
91659>>>>>>>
91659>>>>>>>        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME of iDriver hDatabase to sDateValue
91662>>>>>>>
91662>>>>>>>    End_Procedure
91663>>>>>>>
91663>>>>>>>    // Returns a struct array with the default column types for the SQL back-end and how they
91663>>>>>>>    // are mapped to the standard DataFlex data types.
91663>>>>>>>    // The DataFlex data types are: "ASCII", "BINARY", "DATE", "DATETIME", "NUMERIC" and "TEXT".
91663>>>>>>>    Function UtilDefaultSqlTypeMappings String sDriverID Integer iDbType Returns tColumnType[]
91665>>>>>>>        tColumnType[] ColumnTypeArray EmptyArray
91665>>>>>>>        tColumnType[] ColumnTypeArray EmptyArray
91667>>>>>>>        String sDataType
91667>>>>>>>        Integer iDataType iDriverID iCount
91667>>>>>>>        Boolean bSQLDriver
91667>>>>>>>
91667>>>>>>>        Move 0 to iCount
91668>>>>>>>        Get DriverIndex sDriverID to iDriverID
91669>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
91670>>>>>>>        If (bSQLDriver = False) Begin
91672>>>>>>>            Function_Return EmptyArray
91673>>>>>>>        End
91673>>>>>>>>
91673>>>>>>>
91673>>>>>>>        // DF_ASCII
91673>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
91675>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
91678>>>>>>>        End
91678>>>>>>>>
91678>>>>>>>        Else Begin
91679>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
91682>>>>>>>        End
91682>>>>>>>>
91682>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
91683>>>>>>>        Move DF_ASCII    to ColumnTypeArray[iCount].iDataFlexType
91684>>>>>>>        Move "ASCII"     to ColumnTypeArray[iCount].sDataFlexType
91685>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
91686>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
91687>>>>>>>        Increment iCount
91688>>>>>>>
91688>>>>>>>        // DF_BINARY
91688>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
91690>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
91693>>>>>>>        End
91693>>>>>>>>
91693>>>>>>>        Else Begin
91694>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
91697>>>>>>>        End
91697>>>>>>>>
91697>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
91698>>>>>>>        Move DF_BINARY   to ColumnTypeArray[iCount].iDataFlexType
91699>>>>>>>        Move "Binary"    to ColumnTypeArray[iCount].sDataFlexType
91700>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
91701>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
91702>>>>>>>        Increment iCount
91703>>>>>>>
91703>>>>>>>        // DF_DATE
91703>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
91705>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
91708>>>>>>>        End
91708>>>>>>>>
91708>>>>>>>        Else Begin
91709>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
91712>>>>>>>        End
91712>>>>>>>>
91712>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
91713>>>>>>>        Move DF_DATE     to ColumnTypeArray[iCount].iDataFlexType
91714>>>>>>>        Move "Date"      to ColumnTypeArray[iCount].sDataFlexType
91715>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
91716>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
91717>>>>>>>        Increment iCount
91718>>>>>>>
91718>>>>>>>        // DF_DATETIME
91718>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
91720>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
91723>>>>>>>        End
91723>>>>>>>>
91723>>>>>>>        Else Begin
91724>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
91727>>>>>>>        End
91727>>>>>>>>
91727>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
91728>>>>>>>        Move DF_DATETIME to ColumnTypeArray[iCount].iDataFlexType
91729>>>>>>>        Move "DateTime"  to ColumnTypeArray[iCount].sDataFlexType
91730>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
91731>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
91732>>>>>>>        Increment iCount
91733>>>>>>>
91733>>>>>>>        // DF_NUMERIC
91733>>>>>>>        // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
91733>>>>>>>        // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
91733>>>>>>>        // we make them here all "Numeric"...
91733>>>>>>>        Case Begin
91733>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
91735>>>>>>>                Move SQL_NUMERIC to iDataType
91736>>>>>>>                Move "numeric"   to sDataType
91737>>>>>>>                Case Break
91738>>>>>>>            Case (sDriverID = DB2_DRV_ID)
91741>>>>>>>                Move SQL_NUMERIC to iDataType
91742>>>>>>>                Move "NUMERIC"   to sDataType
91743>>>>>>>                Case Break
91744>>>>>>>            Case Else
91744>>>>>>>                Move DF_BCD      to iDataType
91745>>>>>>>                Move "Numeric"   to sDataType
91746>>>>>>>        Case End
91746>>>>>>>        Move DF_BCD      to ColumnTypeArray[iCount].iDataFlexType
91747>>>>>>>        Move "Numeric"   to ColumnTypeArray[iCount].sDataFlexType
91748>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
91749>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
91750>>>>>>>        Increment iCount
91751>>>>>>>
91751>>>>>>>        // DF_TEXT
91751>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
91753>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
91756>>>>>>>        End
91756>>>>>>>>
91756>>>>>>>        Else Begin
91757>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
91760>>>>>>>        End
91760>>>>>>>>
91760>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
91761>>>>>>>        Move DF_TEXT     to ColumnTypeArray[iCount].iDataFlexType
91762>>>>>>>        Move "Text"      to ColumnTypeArray[iCount].sDataFlexType
91763>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
91764>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
91765>>>>>>>
91765>>>>>>>        Function_Return ColumnTypeArray
91766>>>>>>>    End_Function
91767>>>>>>>
91767>>>>>>>    Function UtilDFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
91769>>>>>>>        tColumnType[] ColumnTypeArray
91769>>>>>>>        tColumnType[] ColumnTypeArray
91770>>>>>>>        tColumnType   ColumnType
91770>>>>>>>        tColumnType   ColumnType
91770>>>>>>>        Integer iCount iSize
91770>>>>>>>
91770>>>>>>>        Get UtilDefaultSqlTypeMappings sDriverID iDbType iType to ColumnTypeArray
91771>>>>>>>        Move (SizeOfArray(ColumnTypeArray)) to iSize
91772>>>>>>>        Decrement iSize
91773>>>>>>>
91773>>>>>>>        for iCount from 0 to iSize
91779>>>>>>>>
91779>>>>>>>            If (iType = ColumnTypeArray[iCount].iDataFlexType) Begin
91781>>>>>>>                Move ColumnTypeArray[iCount].bCanEditSize   to ColumnType.bCanEditSize
91782>>>>>>>                Move ColumnTypeArray[iCount].iDataFlexType  to ColumnType.iDataFlexType
91783>>>>>>>                Move ColumnTypeArray[iCount].iSQLType       to ColumnType.iSQLType
91784>>>>>>>                Move ColumnTypeArray[iCount].sDataFlexType  to ColumnType.sDataFlexType
91785>>>>>>>                Move ColumnTypeArray[iCount].sPrecision     to ColumnType.sPrecision
91786>>>>>>>                Move ColumnTypeArray[iCount].sSQLType       to ColumnType.sSQLType
91787>>>>>>>                Move iSize to iCount
91788>>>>>>>            End
91788>>>>>>>>
91788>>>>>>>        Loop
91789>>>>>>>>
91789>>>>>>>
91789>>>>>>>        Function_Return ColumnType
91790>>>>>>>    End_Function
91791>>>>>>>
91791>>>>>>>    // Returns True if the passed hTable (filelist slot number) is an Alias table.
91791>>>>>>>    // An Alias file/table is a filelist number that share the same Physical filename
91791>>>>>>>    // but the Logical name is different.
91791>>>>>>>    // Note: If the table cannot be opened; the table is not considered to be an Alias.
91791>>>>>>>    Function UtilTableIsAlias Handle hTable Returns Boolean
91793>>>>>>>        String sRootName sRootNameCompare sLogicalName sLogicalNameCompare
91793>>>>>>>        Handle hInTable hMasterTable 
91793>>>>>>>        Boolean bIsAlias
91793>>>>>>>        
91793>>>>>>>        Move hTable to hInTable
91794>>>>>>>        Move False to bIsAlias
91795>>>>>>>        Move 0 to hMasterTable
91796>>>>>>>        
91796>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
91799>>>>>>>        // Remove any prefix with a driver name.
91799>>>>>>>        Get _TableNameOnly sRootName to sRootName     
91800>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
91803>>>>>>>        Get _TableNameOnly sLogicalName to sLogicalName     
91804>>>>>>>        
91804>>>>>>>        // If the table has the same root and logical name it can't be an alias,
91804>>>>>>>        // so we can safely return a "False".
91804>>>>>>>        If (Uppercase(sRootName) = Uppercase(sLogicalName)) Begin
91806>>>>>>>            Function_Return False
91807>>>>>>>        End
91807>>>>>>>>
91807>>>>>>>        
91807>>>>>>>        // Now we need to find a master table with the same root name (sRootName above),
91807>>>>>>>        // as the passed hTable root name.
91807>>>>>>>        // A master table always has the same root and logical name.
91807>>>>>>>        Move 0 to hTable
91808>>>>>>>        Repeat
91808>>>>>>>>
91808>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
91811>>>>>>>            If (hTable > 0 and hTable <> 50) Begin
91813>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootNameCompare
91816>>>>>>>                Get _TableNameOnly sRootNameCompare to sRootNameCompare
91817>>>>>>>                // If we found another table with the same root and logical name
91817>>>>>>>                // we have found a master table.
91817>>>>>>>                If (Uppercase(sRootName) = Uppercase(sRootNameCompare)) Begin
91819>>>>>>>                    Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalNameCompare
91822>>>>>>>                    Get _TableNameOnly sLogicalNameCompare to sLogicalNameCompare     
91823>>>>>>>                    If (Uppercase(sRootNameCompare) = Uppercase(sLogicalNameCompare)) Begin
91825>>>>>>>                        Move hTable to hMasterTable   
91826>>>>>>>                        Move 0 to hTable // To end the loop.
91827>>>>>>>                    End
91827>>>>>>>>
91827>>>>>>>                End
91827>>>>>>>>
91827>>>>>>>            End
91827>>>>>>>>
91827>>>>>>>        Until (hTable = 0)
91829>>>>>>>        
91829>>>>>>>        If (hMasterTable <> 0 and hMasterTable <> hInTable) Begin
91831>>>>>>>            Move True to bIsAlias
91832>>>>>>>        End
91832>>>>>>>>
91832>>>>>>>        
91832>>>>>>>        Function_Return bIsAlias
91833>>>>>>>    End_Function
91834>>>>>>>
91834>>>>>>>    // To Open a table with any driver.
91834>>>>>>>    // Note: If the driver is <> DATAFLEX_ID  - login credentials are used; it is then assumed
91834>>>>>>>    //       that the proper login properties has been setup properly with the cSQLConnections object.
91834>>>>>>>    //
91834>>>>>>>    // If the open command fails the Err flag will be reset to false, at the end of the function!
91834>>>>>>>    // The found flag is still used to indicate if the open was successful or not. The function
91834>>>>>>>    // returns a True if successful (table could be opened).
91834>>>>>>>    //
91834>>>>>>>    // Using the "Open As" syntax with drivers means that we don't need to rely on .int file settings.
91834>>>>>>>    // This is good because with DFConnectionID's those credentials doesn't need to be available in
91834>>>>>>>    // the .int file (and probably aren't). As long as the login properties of this object have been
91834>>>>>>>    // set properly we can open the table.
91834>>>>>>>    //
91834>>>>>>>    // DAW Driver Syntax:
91834>>>>>>>    //  <CKId>:<Schema>#<Table>@<ConnectString>|<Filename>.int
91834>>>>>>>    //  Now the @<ConnectString> can be followed by a pipe character '|' followed by the name of the INT file.
91834>>>>>>>    //  Doing so, the driver will apply the information from the .INT file to the passed direct Open String.
91834>>>>>>>    //  Note that when an INT file has been passed, it will skip the keyword DRIVER_NAME, SERVER_NAME,
91834>>>>>>>    //  DATABASE_NAME and SCHEMA_NAME from the INT file because those are supposed to be supplied in the String already.
91834>>>>>>>    //  Open mode; iMode = DF_SHARE or DF_EXCLUSIVE.
91834>>>>>>>    //
91834>>>>>>>    // DAW Driver Sample:
91834>>>>>>>    //   Open "MSSQLDRV:dbo#MyFile@SERVER=(local)\SQLEXPRESS;Trusted_Connection=yes;DATABASE=OrderEntry|options|intfile=MyFile.int"
91834>>>>>>>    //
91834>>>>>>>    Function UtilTableOpen Integer hTable String sTableName Integer iMode Returns Boolean
91836>>>>>>>        String sTableNameOrg
91836>>>>>>>        Boolean bOpen bOK
91836>>>>>>>        tSQLConnection SQLConnection
91836>>>>>>>        tSQLConnection SQLConnection
91836>>>>>>>        
91836>>>>>>>        Move False to bOpen
91837>>>>>>>        Move sTableName to sTableNameOrg
91838>>>>>>>        If (hTable > 0) Begin
91840>>>>>>>            Send Ignore_Error of Error_Object_Id 20529
91841>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91842>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
91843>>>>>>>            Send Ignore_Error of Error_Object_Id 10
91844>>>>>>>            Open hTable Mode iMode
91846>>>>>>>            Send Trap_Error of Error_Object_Id 20529
91847>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
91848>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
91849>>>>>>>            Send Trap_Error of Error_Object_Id 10
91850>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
91853>>>>>>>            If (bOpen = True) Begin
91855>>>>>>>                Function_Return True
91856>>>>>>>            End
91856>>>>>>>>
91856>>>>>>>        End
91856>>>>>>>>
91856>>>>>>>
91856>>>>>>>        Get UtilTableOpenAsIntFile hTable sTableName iMode to bOK 
91857>>>>>>>        If (hTable > 0) Begin
91859>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
91862>>>>>>>        End
91862>>>>>>>>
91862>>>>>>>
91862>>>>>>>        Function_Return bOpen
91863>>>>>>>    End_Function
91864>>>>>>>
91864>>>>>>>    Function UtilTableOpenAsIntFile Integer hTable String sTableName Integer iMode Returns Boolean
91866>>>>>>>        String sDriverID sConnection sSchema sExt sTableNameShort sTableNameOrg
91866>>>>>>>        Boolean bOpen bOK
91866>>>>>>>        tSQLConnection SQLConnection
91866>>>>>>>        tSQLConnection SQLConnection
91866>>>>>>>
91866>>>>>>>        If (hTable < 1) Begin
91868>>>>>>>            Function_Return False
91869>>>>>>>        End
91869>>>>>>>>
91869>>>>>>>
91869>>>>>>>        Move sTableName to sTableNameOrg
91870>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
91871>>>>>>>        Move SQLConnection.sDriverID to sDriverID
91872>>>>>>>        Move SQLConnection.sConnectionString to sConnection
91873>>>>>>>        Move SQLConnection.sSchema to sSchema
91874>>>>>>>        If (sSchema = "") Begin
91876>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
91877>>>>>>>        End
91877>>>>>>>>
91877>>>>>>>
91877>>>>>>>        // We need to remove the ".int" part of the table name because
91877>>>>>>>        // the table name after the "#" in the connection syntax below wants the
91877>>>>>>>        // "bare" table name without any extension.
91877>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
91879>>>>>>>            If (Lowercase(sTableName) contains ".int") Begin
91881>>>>>>>                Get ParseFileExtension sTableName to sExt
91882>>>>>>>                Move (Replace(("." + sExt), sTableName, "")) to sTableNameShort
91883>>>>>>>            End
91883>>>>>>>>
91883>>>>>>>            Else Begin
91884>>>>>>>                Move sTableName to sTableNameShort
91885>>>>>>>                Move (Append(sTableName, ".int")) to sTableName
91886>>>>>>>            End
91886>>>>>>>>
91886>>>>>>>            Move (sDriverID + ":" + sSchema + "#" + sTableNameShort + "@" + sConnection + "|options|intfile=" + sTableName) to sConnection
91887>>>>>>>            Move sConnection to sTableName
91888>>>>>>>        End
91888>>>>>>>>
91888>>>>>>>
91888>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
91889>>>>>>>        Send Ignore_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
91890>>>>>>>        If (hTable = 0) Begin
91892>>>>>>>            Get NextFreeFilelistSlot to hTable
91893>>>>>>>        End
91893>>>>>>>>
91893>>>>>>>
91893>>>>>>>        Case Begin
91893>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
91895>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
91895>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
91897>>>>>>>                    Close hTable
91898>>>>>>>                    Open sTableName as hTable
91900>>>>>>>                End
91900>>>>>>>>
91900>>>>>>>                Else Begin
91901>>>>>>>                    Get OpenTableExclusive hTable to bOK
91902>>>>>>>                    If (bOK = False) Begin
91904>>>>>>>                        Function_Return False
91905>>>>>>>                    End
91905>>>>>>>>
91905>>>>>>>                End
91905>>>>>>>>
91905>>>>>>>                Case Break
91906>>>>>>>
91906>>>>>>>            Case (sDriverID = DB2_DRV_ID)
91909>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
91909>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
91911>>>>>>>                    Close hTable
91912>>>>>>>                    Open sTableName as hTable
91914>>>>>>>                End
91914>>>>>>>>
91914>>>>>>>                Else Begin
91915>>>>>>>                    Get OpenTableExclusive hTable to bOK
91916>>>>>>>                    If (bOK = False) Begin
91918>>>>>>>                        Function_Return False
91919>>>>>>>                    End
91919>>>>>>>>
91919>>>>>>>                End
91919>>>>>>>>
91919>>>>>>>                Case Break
91920>>>>>>>
91920>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
91923>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
91923>>>>>>>                If (iMode = DF_SHARE) Begin
91925>>>>>>>                    Close hTable
91926>>>>>>>                    Open sTableName as hTable
91928>>>>>>>                End
91928>>>>>>>>
91928>>>>>>>                Else Begin
91929>>>>>>>                    Get OpenTableExclusive hTable to bOK
91930>>>>>>>                    If (bOK = False) Begin
91932>>>>>>>                        Function_Return False
91933>>>>>>>                    End
91933>>>>>>>>
91933>>>>>>>                End
91933>>>>>>>>
91933>>>>>>>                Case Break
91934>>>>>>>
91934>>>>>>>            Case (sDriverID = DATAFLEX_ID)
91937>>>>>>>                If (sTableName <> "" and iMode <> DF_EXCLUSIVE) Begin
91939>>>>>>>                    Close hTable
91940>>>>>>>                    Open sTableName as hTable
91942>>>>>>>                End
91942>>>>>>>>
91942>>>>>>>                Else If (iMode = DF_EXCLUSIVE) Begin
91945>>>>>>>                    Get OpenTableExclusive hTable to bOK
91946>>>>>>>                    If (bOK = False) Begin
91948>>>>>>>                        Function_Return False
91949>>>>>>>                    End
91949>>>>>>>>
91949>>>>>>>                End
91949>>>>>>>>
91949>>>>>>>                Else Begin
91950>>>>>>>                    Open hTable
91952>>>>>>>                End
91952>>>>>>>>
91952>>>>>>>                Case Break
91953>>>>>>>
91953>>>>>>>            Case Else
91953>>>>>>>                Error DFERR_PROGRAM ("Invalid driver:" * sDriverID)
91954>>>>>>>>
91954>>>>>>>        Case End
91954>>>>>>>
91954>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
91955>>>>>>>        Send Trap_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
91956>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
91958>>>>>>>            Move False to Found
91959>>>>>>>        End
91959>>>>>>>>
91959>>>>>>>        // If open failed, the Err is set to true,
91959>>>>>>>        // but we don't want that because it could end our loop.
91959>>>>>>>        Move False to Err
91960>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
91963>>>>>>>
91963>>>>>>>        Function_Return bOpen
91964>>>>>>>    End_Function
91965>>>>>>>
91965>>>>>>>    // Pass a table's logical name
91965>>>>>>>    // Returns True if the table exists in filelist.cfg.
91965>>>>>>>    Function UtilTableLogicalNameIsInUse String sCheckTable Returns Boolean
91967>>>>>>>        Handle hTable
91967>>>>>>>        Boolean bFound
91967>>>>>>>        String sCompareTable
91967>>>>>>>
91967>>>>>>>        Move False to bFound
91968>>>>>>>        Move 0 to hTable
91969>>>>>>>        Repeat
91969>>>>>>>>
91969>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
91972>>>>>>>            If (hTable > 0) Begin
91974>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sCompareTable
91977>>>>>>>                If (Uppercase(sCompareTable) = Uppercase(sCheckTable)) Begin
91979>>>>>>>                    Move True to bFound
91980>>>>>>>                End
91980>>>>>>>>
91980>>>>>>>            End
91980>>>>>>>>
91980>>>>>>>            If (bFound = True) ;                Break
91983>>>>>>>        Until (hTable = 0)
91985>>>>>>>
91985>>>>>>>        Function_Return (bFound = True)
91986>>>>>>>    End_Function
91987>>>>>>>
91987>>>>>>>    // Function will report the default driver "DATAFLEX" if table can't be opened
91987>>>>>>>    Function UtilDriverFromTableNumber Handle hTable Returns String
91989>>>>>>>        Boolean bOK bExists
91989>>>>>>>        String sDriverID
91989>>>>>>>
91989>>>>>>>        Get _UtilTableExists hTable to bExists
91990>>>>>>>        If (bExists = False) Begin
91992>>>>>>>            Function_Return DATAFLEX_ID
91993>>>>>>>        End
91993>>>>>>>>
91993>>>>>>>        Get OpenTableExclusive hTable to bOK
91994>>>>>>>        If (bOK = False) Begin
91996>>>>>>>            Function_Return DATAFLEX_ID
91997>>>>>>>        End
91997>>>>>>>>
91997>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
92000>>>>>>>        Function_Return sDriverID
92001>>>>>>>    End_Function
92002>>>>>>>
92002>>>>>>>    // Number of tables in Filelist.cfg. Returns integger
92002>>>>>>>    Function UtilFilelistNoOfTables Returns Integer
92004>>>>>>>        Handle hTable
92004>>>>>>>        Integer iRetval
92004>>>>>>>
92004>>>>>>>        Move 0 to hTable
92005>>>>>>>        Move 0 to iRetval
92006>>>>>>>
92006>>>>>>>        Repeat
92006>>>>>>>>
92006>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92009>>>>>>>            If (hTable > 0) Begin
92011>>>>>>>                Increment iRetval
92012>>>>>>>            End
92012>>>>>>>>
92012>>>>>>>        Until (hTable = 0)
92014>>>>>>>
92014>>>>>>>        Function_Return iRetval
92015>>>>>>>    End_Function
92016>>>>>>>
92016>>>>>>>    // Checks if any of the tables in Filelist.cfg is an SQL driver and returns the first Driver ID.
92016>>>>>>>    Function UtilIsAnyFilelistEntrySQLtable Returns String
92018>>>>>>>        Handle hTable
92018>>>>>>>        String sRoot sDriverID
92018>>>>>>>        Boolean bIsSQLTable
92018>>>>>>>        Integer iPos
92018>>>>>>>
92018>>>>>>>        Move 0 to hTable
92019>>>>>>>        Move "" to sDriverID
92020>>>>>>>        Move False to bIsSQLTable
92021>>>>>>>
92021>>>>>>>        Repeat
92021>>>>>>>>
92021>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92024>>>>>>>            If (hTable > 0) Begin
92026>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRoot
92029>>>>>>>                If (sRoot contains ":") Begin
92031>>>>>>>                    Move (Pos(":", sRoot)) to iPos
92032>>>>>>>                    Move (Left(sRoot, (iPos -1))) to sDriverID
92033>>>>>>>                End
92033>>>>>>>>
92033>>>>>>>                Get IsSQLDriver sDriverID to bIsSQLTable
92034>>>>>>>            End
92034>>>>>>>>
92034>>>>>>>
92034>>>>>>>        Until (hTable = 0 or bIsSQLTable = True)
92036>>>>>>>
92036>>>>>>>        Function_Return sDriverID
92037>>>>>>>    End_Function
92038>>>>>>>
92038>>>>>>>    Function UtilIsAllFilelistEntriesDataFlexTables Returns Boolean
92040>>>>>>>        String sRootName
92040>>>>>>>        Boolean bIsSQL
92040>>>>>>>        Handle hTable
92040>>>>>>>
92040>>>>>>>        Move False to bIsSQL
92041>>>>>>>        Move 0 to hTable
92042>>>>>>>        Repeat
92042>>>>>>>>
92042>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92045>>>>>>>            If (hTable > 0) Begin
92047>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
92050>>>>>>>                Get _UtilTableIsSqlByRootName sRootName to bIsSQL
92051>>>>>>>                If (bIsSQL = True) Begin
92053>>>>>>>                    Move 0 to hTable
92054>>>>>>>                End
92054>>>>>>>>
92054>>>>>>>            End
92054>>>>>>>>
92054>>>>>>>        Until (hTable = 0)
92056>>>>>>>
92056>>>>>>>        Function_Return (bIsSQL = False)
92057>>>>>>>    End_Function
92058>>>>>>>
92058>>>>>>>    // * Dummy function for the Studio's Code Explorer *
92058>>>>>>>    Function UTIL_ENUMERATION_FUNCTIONS Returns Boolean
92060>>>>>>>        Function_Return False
92061>>>>>>>    End_Function
92062>>>>>>>
92062>>>>>>>    Function UtilEnumerateOverlapFields Integer hTable Integer iField Returns String[]
92064>>>>>>>        String  sRetval
92064>>>>>>>        String[] sOverlapFieldsArray
92065>>>>>>>        Integer iType iColumn iColumns
92065>>>>>>>        Boolean bOpen bOverlap
92065>>>>>>>
92065>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
92068>>>>>>>        If (bOpen = False) Begin
92070>>>>>>>            Open hTable
92072>>>>>>>        End
92072>>>>>>>>
92072>>>>>>>
92072>>>>>>>        Move "" to sRetval
92073>>>>>>>
92073>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iColumns
92076>>>>>>>
92076>>>>>>>        for iColumn from 0 to iColumns
92082>>>>>>>>
92082>>>>>>>            Get_Attribute DF_FIELD_TYPE of hTable iColumn to iType
92085>>>>>>>            If (iField <> iColumn and iType <> DF_OVERLAP) Begin
92087>>>>>>>                Get_Attribute DF_FIELD_OVERLAP of hTable iField iColumn to bOverlap
92090>>>>>>>                If (bOverlap) Begin
92092>>>>>>>                    If (sRetval <> "") Begin
92094>>>>>>>                        Append sRetval ","
92095>>>>>>>                    End
92095>>>>>>>>
92095>>>>>>>                    Append sRetval iColumn
92096>>>>>>>                End
92096>>>>>>>>
92096>>>>>>>            End
92096>>>>>>>>
92096>>>>>>>        Loop
92097>>>>>>>>
92097>>>>>>>
92097>>>>>>>        If (bOpen = False) Begin
92099>>>>>>>            Close hTable
92100>>>>>>>        End
92100>>>>>>>>
92100>>>>>>>
92100>>>>>>>        Get StrSplitToArray sRetval "," to sOverlapFieldsArray
92101>>>>>>>
92101>>>>>>>        Function_Return sOverlapFieldsArray
92102>>>>>>>    End_Function
92103>>>>>>>
92103>>>>>>>    Function UtilEnumerateODBCDrivers Returns String
92105>>>>>>>        Handle hoRegistry hoODBCDriverNames
92105>>>>>>>        Boolean bExists bKeyOpened
92105>>>>>>>        String sKey
92105>>>>>>>        String[] sDrivers
92106>>>>>>>        Integer iDriverNames iDriverName
92106>>>>>>>
92106>>>>>>>        Get Create (RefClass (cRegistry)) to hoRegistry
92107>>>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
92108>>>>>>>        Set pfAccessRights of hoRegistry to Key_Read
92109>>>>>>>        Move "SOFTWARE\ODBC\ODBCINST.INI\ODBC Drivers" to sKey
92110>>>>>>>        Get KeyExists of hoRegistry sKey to bExists
92111>>>>>>>        If (bExists) Begin
92113>>>>>>>            Get OpenKey of hoRegistry sKey to bKeyOpened
92114>>>>>>>            If (bKeyOpened) Begin
92116>>>>>>>                Get Create (RefClass (Array)) to hoODBCDriverNames
92117>>>>>>>                Get GetValues of hoRegistry hoODBCDriverNames to iDriverNames
92118>>>>>>>                If (iDriverNames > 0) Begin
92120>>>>>>>                    Move (ResizeArray (sDrivers, iDriverNames)) to sDrivers
92121>>>>>>>                    Decrement iDriverNames
92122>>>>>>>                    for iDriverName from 0 to iDriverNames
92128>>>>>>>>
92128>>>>>>>                        Get Value of hoODBCDriverNames iDriverName to sDrivers[iDriverName]
92129>>>>>>>                    Loop
92130>>>>>>>>
92130>>>>>>>                End
92130>>>>>>>>
92130>>>>>>>                Send CloseKey of hoRegistry
92131>>>>>>>            End
92131>>>>>>>>
92131>>>>>>>        End
92131>>>>>>>>
92131>>>>>>>        Send Destroy of hoRegistry
92132>>>>>>>
92132>>>>>>>        Function_Return sDrivers
92133>>>>>>>    End_Function
92134>>>>>>>
92134>>>>>>>    Procedure IncreaseSortBufferSize
92136>>>>>>>        String sNull
92136>>>>>>>        Integer iSortBufferSize
92136>>>>>>>        Boolean bBufferSet
92136>>>>>>>
92136>>>>>>>        Move "" to sNull
92137>>>>>>>        Move (1024 * 128) to iSortBufferSize
92138>>>>>>>        Call_Driver 0 DATAFLEX_ID Function FLEX_SET_MAX_SORT_BUFFER Callback ghoDbUpdateHandler Passing sNull sNull iSortBufferSize Result bBufferSet
92143>>>>>>>
92143>>>>>>>    End_Procedure
92144>>>>>>>
92144>>>>>>>    Procedure SetAllIndexesToBatch Handle hTable Boolean bSetToBatch
92146>>>>>>>        Integer iLastIndex iIndex iNumSegments
92146>>>>>>>        Boolean bOK
92146>>>>>>>        String sDriverID
92146>>>>>>>
92146>>>>>>>        If (hTable > 0) Begin
92148>>>>>>>            Get UtilDriverFromTableNumber hTable to sDriverID
92149>>>>>>>            Close hTable
92150>>>>>>>            Get OpenTableExclusive hTable to bOK
92151>>>>>>>            If (bOK = False) Begin
92153>>>>>>>                Procedure_Return
92154>>>>>>>            End
92154>>>>>>>>
92154>>>>>>>            Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
92157>>>>>>>            Structure_Start hTable sDriverID
92158>>>>>>>                for iIndex from 1 to iLastIndex
92164>>>>>>>>
92164>>>>>>>                    Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
92167>>>>>>>                    If (iNumSegments > 0) Begin
92169>>>>>>>                        If (bSetToBatch = True) Begin
92171>>>>>>>                            Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_BATCH
92174>>>>>>>                        End
92174>>>>>>>>
92174>>>>>>>                        Else Begin
92175>>>>>>>                            Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_ONLINE
92178>>>>>>>                        End
92178>>>>>>>>
92178>>>>>>>                    End
92178>>>>>>>>
92178>>>>>>>                Loop
92179>>>>>>>>
92179>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
92181>>>>>>>        End
92181>>>>>>>>
92181>>>>>>>    End_Procedure
92182>>>>>>>
92182>>>>>>>    Function NextFreeFilelistSlot Returns Handle
92184>>>>>>>        Handle hTable
92184>>>>>>>
92184>>>>>>>        Move 0 to hTable
92185>>>>>>>        Get_Attribute DF_FILE_NEXT_EMPTY of hTable to hTable
92188>>>>>>>
92188>>>>>>>        Function_Return hTable
92189>>>>>>>    End_Function
92190>>>>>>>
92190>>>>>>>    // For debugging purposes. To print Sql statements as they are build...
92190>>>>>>>    Procedure DebugPrint String sStmt String sFileName
92192>>>>>>>        Integer iCh
92192>>>>>>>        Get Seq_Append_Output_Channel sFileName to iCh
92193>>>>>>>            Write channel iCh sStmt
92195>>>>>>>        Send Seq_Close_Channel iCh
92196>>>>>>>    End_Procedure
92197>>>>>>>
92197>>>>>>>    // Returns the integer number for the passed Driver ID that is
92197>>>>>>>    // needed by some database API calls.
92197>>>>>>>    Function DriverIndex String sDriverID Returns Integer
92199>>>>>>>        String  sCurrentDriver
92199>>>>>>>        Integer iNumberOfDrivers iDriver iCount
92199>>>>>>>
92199>>>>>>>        Move 0 to iDriver
92200>>>>>>>
92200>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
92203>>>>>>>        for iCount from 1 to iNumberOfDrivers
92209>>>>>>>>
92209>>>>>>>
92209>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
92212>>>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
92214>>>>>>>                Move iCount to iDriver
92215>>>>>>>            End
92215>>>>>>>>
92215>>>>>>>        Loop
92216>>>>>>>>
92216>>>>>>>
92216>>>>>>>        // In case it was not found, it wasn't loaded so we do that now.
92216>>>>>>>        If (iDriver = 0) Begin
92218>>>>>>>            Move False to Err
92219>>>>>>>            Load_Driver sDriverID
92220>>>>>>>            If (Err = False) Begin
92222>>>>>>>                Get_Attribute DF_NUMBER_DRIVERS to iDriver
92225>>>>>>>            End
92225>>>>>>>>
92225>>>>>>>        End
92225>>>>>>>>
92225>>>>>>>
92225>>>>>>>        Function_Return iDriver
92226>>>>>>>    End_Function
92227>>>>>>>
92227>>>>>>>
92227>>>>>>>    Function SqlServerClientVersionName for cMSSQLHandler Integer iClientVersion  Returns String
92229>>>>>>>        String  sSqlServerClientVersionName
92229>>>>>>>        
92229>>>>>>>        Case Begin
92229>>>>>>>            Case (iClientVersion = SQLSERVER2019CLIENT)
92231>>>>>>>                Move SQLSERVER2019DRVRSTR to sSqlServerClientVersionName
92232>>>>>>>                Case Break
92233>>>>>>>
92233>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
92236>>>>>>>                Move SQLSERVER2017CLIENTNAME to sSqlServerClientVersionName
92237>>>>>>>                Case Break
92238>>>>>>>                
92238>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
92241>>>>>>>                Move SQLSERVER2016CLIENTNAME to sSqlServerClientVersionName
92242>>>>>>>                Case Break
92243>>>>>>>            
92243>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
92246>>>>>>>                Move SQLSERVER2014CLIENTNAME to sSqlServerClientVersionName
92247>>>>>>>                Case Break
92248>>>>>>>            
92248>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
92251>>>>>>>                Move SQLSERVER2012CLIENTNAME to sSqlServerClientVersionName
92252>>>>>>>                Case Break
92253>>>>>>>            
92253>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
92256>>>>>>>                Move SQLSERVER2008CLIENTNAME to sSqlServerClientVersionName
92257>>>>>>>                Case Break
92258>>>>>>>            
92258>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
92261>>>>>>>                Move SQLSERVER2005CLIENTNAME to sSqlServerClientVersionName
92262>>>>>>>                Case Break
92263>>>>>>>            
92263>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
92266>>>>>>>                Move SQLSERVER2000CLIENTNAME to sSqlServerClientVersionName
92267>>>>>>>                Case Break
92268>>>>>>>            
92268>>>>>>>            Case Else
92268>>>>>>>                Move SQLSERVERUNKNOWNCLIENTNAME to sSqlServerClientVersionName
92269>>>>>>>        Case End
92269>>>>>>>        
92269>>>>>>>        Function_Return sSqlServerClientVersionName
92270>>>>>>>    End_Function
92271>>>>>>>
92271>>>>>>>    Function SqlServerClientDriverName for cMSSQLHandler Integer iClientVersion  Returns String
92273>>>>>>>        String  sSqlServerClientDriverName
92273>>>>>>>        
92273>>>>>>>        Case Begin
92273>>>>>>>            Case (iClientVersion = SQLSERVER2019CLIENT)
92275>>>>>>>                Move SQLSERVER2019DRVRSTR to sSqlServerClientDriverName
92276>>>>>>>                Case Break
92277>>>>>>>
92277>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
92280>>>>>>>                Move SQLSERVER2017DRVRSTR to sSqlServerClientDriverName
92281>>>>>>>                Case Break
92282>>>>>>>                
92282>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
92285>>>>>>>                Move SQLSERVER2016DRVRSTR to sSqlServerClientDriverName
92286>>>>>>>                Case Break
92287>>>>>>>            
92287>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
92290>>>>>>>                Move SQLSERVER2014DRVRSTR to sSqlServerClientDriverName
92291>>>>>>>                Case Break
92292>>>>>>>            
92292>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
92295>>>>>>>                Move SQLSERVER2012DRVRSTR to sSqlServerClientDriverName
92296>>>>>>>                Case Break
92297>>>>>>>            
92297>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
92300>>>>>>>                Move SQLSERVER2008DRVRSTR to sSqlServerClientDriverName
92301>>>>>>>                Case Break
92302>>>>>>>            
92302>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
92305>>>>>>>                Move SQLSERVER2005DRVRSTR to sSqlServerClientDriverName
92306>>>>>>>                Case Break
92307>>>>>>>            
92307>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
92310>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
92311>>>>>>>                Case Break
92312>>>>>>>            
92312>>>>>>>            Case Else
92312>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
92313>>>>>>>        Case End
92313>>>>>>>        
92313>>>>>>>        Function_Return sSqlServerClientDriverName
92314>>>>>>>    End_Function
92315>>>>>>>    
92315>>>>>>>    Function MinMSSQLDRV_And_ClientVersion String sMSSQLDRVVersion Integer iClientVersion Boolean bShowErrorDialog Boolean bExitProgram Returns String
92317>>>>>>>        String sDriverID sVersion sClient sClientLowest sRetval
92317>>>>>>>        Integer iNumberOfDrivers iDriver iClient
92317>>>>>>>        Handle hoCLIHandler hoMSSQLHandler   
92317>>>>>>>        Boolean bOK
92317>>>>>>>        
92317>>>>>>>        Move "" to sRetval
92318>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLIHandler
92319>>>>>>>        Get Create (RefClass(cMSSQLHandler)) to hoMSSQLHandler
92320>>>>>>>        Load_Driver MSSQLDRV_ID
92321>>>>>>>
92321>>>>>>>        // Loop through all loaded drivers.
92321>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
92324>>>>>>>        For iDriver from 1 to iNumberOfDrivers
92330>>>>>>>>
92330>>>>>>>            Get_Attribute DF_DRIVER_NAME of iDriver to sDriverID
92333>>>>>>>            If (sDriverID = MSSQLDRV_ID) Begin
92335>>>>>>>                Set psDriverID of hoCLIHandler to sDriverID
92336>>>>>>>                Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClient   
92339>>>>>>>                Get SqlServerClientVersionName of hoMSSQLHandler iClientVersion to sClientLowest 
92340>>>>>>>                Get SqlServerClientVersionName of hoMSSQLHandler iClient to sClient 
92341>>>>>>>                Get CKRevision of hoCLIHandler to sVersion
92342>>>>>>>                Move (SFormat (String(C_$DatabaseDriver), (sDriverID * "-" * (String(C_$Version) + ": " + String(sVersion))))) to sRetval
92343>>>>>>>                If (sClient <> "" and sRetval <> "") Begin
92345>>>>>>>                    Move (String(sRetval) + "\n" + String(C_$SQL_Client_Text) + "\n" + Trim(sClient)) to sRetval
92346>>>>>>>                End                                
92346>>>>>>>>
92346>>>>>>>                Else Begin
92347>>>>>>>                    Move (String(C_$SQL_Client_Text) + "\n" + Trim(sClient) * "(" + String(iClient) + ")") to sRetval
92348>>>>>>>                End
92348>>>>>>>>
92348>>>>>>>            End
92348>>>>>>>>
92348>>>>>>>        Loop
92349>>>>>>>>
92349>>>>>>>        Send Destroy of hoCLIHandler  
92350>>>>>>>        Send Destroy of hoMSSQLHandler  
92351>>>>>>>        If (bShowErrorDialog = True) Begin
92353>>>>>>>            Get IsFirstStringGreaterThanSecond sVersion sMSSQLDRVVersion to bOK
92354>>>>>>>            If (bOK = False or (iClient < iClientVersion)) Begin
92356>>>>>>>                Move (MSSQLDRV_ID + ".dll" * String(C_$SQL_Driver_Version_Min_Text) *  String(sMSSQLDRVVersion) + String("\n") + String(C_$SQL_Client_Version_Min_Text) + "\n" + String(sClientLowest) + String("\n\n") + String(C_$SQL_Versions_Are_Text) + String("\n") + String(sRetval)) to sRetval
92357>>>>>>>                If (bExitProgram = True) Begin
92359>>>>>>>                    Move (String(sRetval) + String("\n\n") + String(C_$PleaseAdjustTxt) * String(C_$ProgramWillExit_Text)) to sRetval
92360>>>>>>>                End
92360>>>>>>>>
92360>>>>>>>                Send Stop_Box sRetval  
92361>>>>>>>                If (bExitProgram = True) Begin
92363>>>>>>>                    Send Exit_Application
92364>>>>>>>                End
92364>>>>>>>>
92364>>>>>>>            End
92364>>>>>>>>
92364>>>>>>>        End
92364>>>>>>>>
92364>>>>>>>        
92364>>>>>>>        Function_Return sRetval
92365>>>>>>>    End_Function  
92366>>>>>>>    
92366>>>>>>>    // Returns True if first "." separated string is greater than the second.
92366>>>>>>>    // It checks from left to right, one part of the string at a time.
92366>>>>>>>    // E.g. if sVersion="20.1.31.10 and sSQLVersion="6.3.0.13" the function would return TRUE.
92366>>>>>>>    Function IsFirstStringGreaterThanSecond Global String sVersion String sSQLVersion Returns Boolean
92368>>>>>>>        String[] asVersion asSQLVersion          
92370>>>>>>>        Integer iSize iCount iVersion iSQLVersion
92370>>>>>>>        
92370>>>>>>>        Move (StrSplitToArray(sVersion, "."))    to asVersion
92371>>>>>>>        Move (StrSplitToArray(sSQLVersion, ".")) to asSQLVersion
92372>>>>>>>        Move (SizeOfArray(asVersion)) to iSize
92373>>>>>>>        // Make sure the two arrays are of the same size:
92373>>>>>>>        If (SizeOfArray(asSQLVersion) < iSize) Begin
92375>>>>>>>            Move (ResizeArray(asSQLVersion, iSize, 0)) to asSQLVersion
92376>>>>>>>        End
92376>>>>>>>>
92376>>>>>>>        Decrement iSize
92377>>>>>>>        for iCount from 0 to iSize
92383>>>>>>>>
92383>>>>>>>            Move asVersion[iCount]    to iVersion
92384>>>>>>>            Move asSQLVersion[iCount] to iSQLVersion
92385>>>>>>>            CompilerWarnings Off
92385>>>>>>>            If (iVersion > iSQLVersion) Break
92388>>>>>>>            CompilerWarnings On
92388>>>>>>>        Loop
92389>>>>>>>>
92389>>>>>>>        
92389>>>>>>>        Function_Return (iVersion > iSQLVersion)
92390>>>>>>>    End_Function
92391>>>>>>>
92391>>>>>>>    // Returns TRUE if table is opened exclusive, otherwise FALSE
92391>>>>>>>    // Note: If run from the Studio, CodeMast & CodeType _is_ open by the Studio,
92391>>>>>>>    //       so in that case we "cheat" and report those tables were opened OK.
92391>>>>>>>    Function OpenTableExclusive Handle hTable Returns Boolean
92393>>>>>>>        Integer iMode iErrorObject
92393>>>>>>>        Boolean bOpened
92393>>>>>>>        String sTableName 
92393>>>>>>>        Handle hoCurrentErrorHandler
92393>>>>>>>
92393>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
92394>>>>>>>        // Can't open a table properly if run through the Debugger/Studio,
92394>>>>>>>        // so we generate an error here:
92394>>>>>>>        If (IsDebuggerPresent()) Begin
92396>>>>>>>            Move Error_Object_Id to hoCurrentErrorHandler
92397>>>>>>>            Get piOrgErrorHandlerID to iErrorObject
92398>>>>>>>            If (iErrorObject <> 0) Begin
92400>>>>>>>                Move iErrorObject to Error_Object_Id
92401>>>>>>>            End
92401>>>>>>>>
92401>>>>>>>            Error DFERR_OPERATOR "It is not possible to make structural changes to the database when running through the Debugger/Studio! You need to run this program from outside of the Studio."
92402>>>>>>>>
92402>>>>>>>            Move hoCurrentErrorHandler to Error_Object_Id
92403>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
92404>>>>>>>            Function_Return False
92405>>>>>>>        End
92405>>>>>>>>
92405>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
92408>>>>>>>        If (bOpened) Begin
92410>>>>>>>//            If (IsDebuggerPresent()) Begin
92410>>>>>>>//                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
92410>>>>>>>//                If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE") Begin
92410>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
92410>>>>>>>//                    Function_Return True
92410>>>>>>>//                End
92410>>>>>>>//            End
92410>>>>>>>            Get_Attribute DF_FILE_OPEN_MODE of hTable to iMode
92413>>>>>>>            If (iMode=DF_EXCLUSIVE) Begin
92415>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
92416>>>>>>>                Function_Return True
92417>>>>>>>            End
92417>>>>>>>>
92417>>>>>>>            Close hTable
92418>>>>>>>        End
92418>>>>>>>>
92418>>>>>>>        Else Begin
92419>>>>>>>            Open hTable
92421>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpened
92424>>>>>>>            If (bOpened and IsDebuggerPresent()) Begin
92426>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
92429>>>>>>>                If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE") Begin
92431>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
92432>>>>>>>                    Function_Return True
92433>>>>>>>                End
92433>>>>>>>>
92433>>>>>>>            End
92433>>>>>>>>
92433>>>>>>>
92433>>>>>>>        End
92433>>>>>>>>
92433>>>>>>>
92433>>>>>>>        Close hTable
92434>>>>>>>        Open hTable Mode DF_EXCLUSIVE
92436>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
92439>>>>>>>
92439>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
92440>>>>>>>        Function_Return bOpened
92441>>>>>>>    End_Function
92442>>>>>>>
92442>>>>>>>    Function AutoConnectionIDLogin Returns Boolean
92444>>>>>>>        String sConnectionID sConnectionString sDriverID
92444>>>>>>>        Boolean bExists bOK bSQLDriver
92444>>>>>>>        Handle hoCLI hoDriver
92444>>>>>>>        Integer iRetval
92444>>>>>>>        tSQLConnection SQLConnection
92444>>>>>>>        tSQLConnection SQLConnection
92444>>>>>>>
92444>>>>>>>        Get psDriverID to sDriverID
92445>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
92446>>>>>>>        If (bSQLDriver = False) Begin
92448>>>>>>>            Function_Return True
92449>>>>>>>        End
92449>>>>>>>>
92449>>>>>>>
92449>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
92450>>>>>>>        Move SQLConnection.sDriverID                  to sDriverID
92451>>>>>>>        Move SQLConnection.sConnectionString          to sConnectionString
92452>>>>>>>        Move SQLConnection.sConnectionID to sConnectionID
92453>>>>>>>
92453>>>>>>>        Get IsConnectionID sConnectionID sDriverID to bExists
92454>>>>>>>        If (bExists = False) Begin
92456>>>>>>>            // We always start by deleting the current connection - if any - because the
92456>>>>>>>            // login details my have changed.
92456>>>>>>>            Get phoCLIHandler to hoCLI
92457>>>>>>>            Set psDriverID    of hoCLI to sDriverID
92458>>>>>>>            Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
92459>>>>>>>            Get AutoSetConnectionID sConnectionID to bOk
92460>>>>>>>            If (bOk = False) Begin
92462>>>>>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be changed.")
92463>>>>>>>>
92463>>>>>>>                Function_Return False
92464>>>>>>>            End
92464>>>>>>>>
92464>>>>>>>            Move bOK to bExists
92465>>>>>>>        End
92465>>>>>>>>
92465>>>>>>>
92465>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
92466>>>>>>>        Set Name of hoDriver to "oDbUpdateDatabaseDriver"
92467>>>>>>>        Set psDriverID of hoDriver to SQLConnection.sDriverID
92468>>>>>>>        Get DbLogin of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
92469>>>>>>>        Send Destroy of hoDriver
92470>>>>>>>
92470>>>>>>>        Function_Return (bExists = True)
92471>>>>>>>    End_Function
92472>>>>>>>
92472>>>>>>>    // Scans to see if all tables can be opened exclusivly. I.e. that nobody else is running the application.
92472>>>>>>>    // Returns: False if nobody else is running
92472>>>>>>>    //          True if at least one table is open by another process (e.g. another user is running the application)
92472>>>>>>>    // N.B! Only works for Embedded DataFlex Tables! It will _not_ work for Sql tables because; these
92472>>>>>>>    //      tables are not locked as DataFlex tables are.
92472>>>>>>>    Function IsDatabaseInUse Returns Boolean
92474>>>>>>>        Handle  hTable
92474>>>>>>>        String  sRootName
92474>>>>>>>        Boolean bOpen bErr bAlias bOK bIsSQLTable bFlexErrs bExists
92474>>>>>>>        Integer iCount iTables
92474>>>>>>>
92474>>>>>>>        Move 0 to iTables
92475>>>>>>>        Set Action_Text of ghoStatusPanel to "Database in use check..."
92476>>>>>>>        Get AutoConnectionIDLogin to bOK
92477>>>>>>>        Get UtilFilelistNoOfTables to iTables
92478>>>>>>>        Set piPosition   of ghoProgressBar to 0
92479>>>>>>>        Set piAdvanceBy  of ghoProgressBar to 1
92480>>>>>>>        Set piMaximum    of ghoProgressBar to iTables
92481>>>>>>>        Close DF_ALL
92482>>>>>>>        Move 0 to hTable
92483>>>>>>>        Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92486>>>>>>>        Move False to bErr
92487>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
92488>>>>>>>
92488>>>>>>>        Repeat
92488>>>>>>>>
92488>>>>>>>            Set piPosition of ghoProgressBar to iCount
92489>>>>>>>            Increment iCount
92490>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
92493>>>>>>>            Move (Uppercase(sRootName) = "FLEXERRS")  to bFlexErrs
92494>>>>>>>
92494>>>>>>>            // This test is only applicable for DataFlex embedded tables; so skip test if driver based table.
92494>>>>>>>            Get _UtilTableIsSqlByRootName sRootName to bIsSQLTable
92495>>>>>>>            Move False to bOpen
92496>>>>>>>            Get _UtilTableExists hTable to bExists
92497>>>>>>>            // Don't bother about CodeType (253, CodeMast (254) or) FlexErrs (Normally table 50)
92497>>>>>>>            If (bIsSQLTable = False and bExists = True and hTable <> 0 and hTable <> 253 and hTable <> 254 and bFlexErrs = False) Begin
92499>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
92500>>>>>>>                Open hTable
92502>>>>>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
92505>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
92506>>>>>>>                If (bOpen = True) Begin
92508>>>>>>>                    // We cannot open an Alias file exclusive as it will generate an error (4177 - "File in use")
92508>>>>>>>                    Get UtilTableIsAlias hTable to bAlias
92509>>>>>>>                    If (bAlias = False) Begin
92511>>>>>>>                        Close hTable
92512>>>>>>>                        Get OpenTableExclusive hTable to bOpen
92513>>>>>>>                        If (bOpen = False) Begin
92515>>>>>>>                            Move True to bErr
92516>>>>>>>                        End
92516>>>>>>>>
92516>>>>>>>                    End
92516>>>>>>>>
92516>>>>>>>                End
92516>>>>>>>>
92516>>>>>>>                Close hTable
92517>>>>>>>            End
92517>>>>>>>>
92517>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92520>>>>>>>            If (bErr = True ) ;                Break
92523>>>>>>>        Until (not(hTable))
92525>>>>>>>
92525>>>>>>>        Set Action_Text of ghoStatusPanel to ""
92526>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
92527>>>>>>>        Move False to Err
92528>>>>>>>
92528>>>>>>>        Function_Return bErr
92529>>>>>>>    End_Function
92530>>>>>>>
92530>>>>>>>End_Class
92531>>>>>Use for_all.pkg // Handy to have available in the OnUpdate event.
Including file: for_all.pkg    (C:\Program Files\DataFlex 24.0\Pkg\for_all.pkg)
92531>>>>>>>// This module contains the command definitions for the FOR_ALL construct.
92531>>>>>>>//
92531>>>>>>>// FOR_ALL is used to select and process a set of records in a database file;
92531>>>>>>>// FOR_ALL constructs may be nested. FOR_ALL is intended to work in
92531>>>>>>>// conjunction with constraint-clauses.
92531>>>>>>>//
92531>>>>>>>// SYNTAX:
92531>>>>>>>//
92531>>>>>>>//  For_All <File> BY|DOWN <Index> {AS QUE|QUEUE} {DO}
92531>>>>>>>//    <Constraints...>
92531>>>>>>>//    {DO}
92531>>>>>>>//      <loop body>
92531>>>>>>>//  End_For_All
92531>>>>>>>//
92531>>>>>>>// This set of macros implements a constraint-oriented file enumeration
92531>>>>>>>// syntax.  For example, to list all Customers by name in reverse order:
92531>>>>>>>//
92531>>>>>>>//   For_All Customer DOWN Customer.Customer_Name DO
92531>>>>>>>//     showln "Customer: " Customer.RecNum "  " Customer.Customer_Name
92531>>>>>>>//   End_For_All
92531>>>>>>>//
92531>>>>>>>// To list only Customers with a Balance greater than their credit limit:
92531>>>>>>>//
92531>>>>>>>//   For_All Customer BY Index.1
92531>>>>>>>//     CONSTRAIN Customer.Balance GT Customer.Credit_Limit
92531>>>>>>>//     DO
92531>>>>>>>//       showln "Customer: " Customer.RecNum "  " Customer.Customer_Name
92531>>>>>>>//   End_For_All
92531>>>>>>>//
92531>>>>>>>// Constraint clauses are:
92531>>>>>>>//
92531>>>>>>>//   CONSTRAIN <File> RELATES TO <File> ...
92531>>>>>>>//   CONSTRAIN <File> AS <Expression>
92531>>>>>>>//   CONSTRAIN <File.Field> AS <Expression>
92531>>>>>>>//   CONSTRAIN <File.Field> BETWEEN <lowBound> AND <highBound>
92531>>>>>>>//
92531>>>>>>>// For example, to list all customers with a bad status whose names start
92531>>>>>>>// with "A" and which have not made a payment in thirty days:
92531>>>>>>>//
92531>>>>>>>//    For_All Customer BY Index.2       //Index.2 = <Status>+<Name>
92531>>>>>>>//      CONSTRAIN Customer.Status EQ BAD
92531>>>>>>>//      CONSTRAIN Customer.Customer_Name GE "A"
92531>>>>>>>//      CONSTRAIN Customer.Customer_Name LT "B"
92531>>>>>>>//      CONSTRAIN Customer.Last_Pymt_Date LE (Today - 30)
92531>>>>>>>//      DO
92531>>>>>>>//        showln "Customer: " Customer.RecNum "  " Customer.Customer_Name
92531>>>>>>>//    End_For_All
92531>>>>>>>//
92531>>>>>>>
92531>>>>>>>
92531>>>>>>>//This command starts the loop process body when constraints are used;
92531>>>>>>>//If no constraints are required, DO should be specified on the FOR_ALL
92531>>>>>>>//command line, and not on a line by itself
92531>>>>>>>//
92531>>>>>>>
92531>>>>>>>//Ends a For_All loop
92531>>>>>>>//
92531>>>>>>>
92531>>>>>>>
92531>>>>>
92531>>>>>
92531>>>>>Class cDbUpdateVersion is a cObject
92532>>>>>
92532>>>>>    Procedure Construct_Object    
92534>>>>>        Boolean bOnCreateExecuted bUseCustomDbVersion
92534>>>>>        String[] aSQLQueryMessages
92535>>>>>        
92535>>>>>        Forward Send Construct_Object
92537>>>>>
92537>>>>>        // cDbUpdateHandler object event.
92537>>>>>        Delegate Get Private.pbOnCreateExecuted to bOnCreateExecuted
92539>>>>>        If (bOnCreateExecuted = False) Begin    
92541>>>>>            Delegate Get pbUseCustomDbVersion to bUseCustomDbVersion
92543>>>>>            If (bUseCustomDbVersion = False) Begin
92545>>>>>                Delegate Send CheckAutoCreateDbVersionTable 
92547>>>>>            End
92547>>>>>>
92547>>>>>            Delegate Send CheckIntFilesIntegrity
92549>>>>>            Delegate Send OnCreate
92551>>>>>            Delegate Set Private.pbOnCreateExecuted to True
92553>>>>>        End
92553>>>>>>
92553>>>>>
92553>>>>>        // Don't touch! It is used by class logic to indicate if the OnUpdate
92553>>>>>        // event was triggered, thus an actual change of the database was made.
92553>>>>>        Property Boolean pbVersionUpdate False
92554>>>>>
92554>>>>>        // This property must be manually set within each cDbUpdateVersion object
92554>>>>>        // by the programmer, to a consecutive number.
92554>>>>>        Property Number pnVersionNumber
92555>>>>>
92555>>>>>        Property Boolean pbUseConnectionID True
92556>>>>>        Property Boolean private.pbToANSI   True
92557>>>>>        Property Boolean private.pbRecnum   True
92558>>>>>        Property Boolean private.pbCopyData True
92559>>>>>        Property Boolean private.pbApiTableUpdateAuto False
92560>>>>>        Property Boolean private.pbCompareDate_DateTime False
92561>>>>>        Property Boolean private.pbCompareIndexAscending False
92562>>>>>        Property Boolean private.pbCompareIndexUppercase False
92563>>>>>        Property String private.psSchema
92564>>>>>        Property String private.psBaseTableSpace
92565>>>>>        Property String private.psLongTableSpace
92566>>>>>        Property String private.psIndexTableSpace
92567>>>>>
92567>>>>>        // Driver default value settings:
92567>>>>>        Property String private.psDriverDefaultValueASCII    ""
92568>>>>>        Property String private.psDriverDefaultValueBinary   ""
92569>>>>>        Property String private.psDriverDefaultValueDate     ""
92570>>>>>        Property String private.psDriverDefaultValueDateTime ""
92571>>>>>        Property String private.psDriverDefaultValueNumeric  ""
92572>>>>>        Property String private.psDriverDefaultValueText     ""
92573>>>>>
92573>>>>>        // Driver "nullability" settings:
92573>>>>>        Property Boolean private.pbDriverDefaultNullableASCII    False
92574>>>>>        Property Boolean private.pbDriverDefaultNullableBinary   False
92575>>>>>        Property Boolean private.pbDriverDefaultNullableDate     False
92576>>>>>        Property Boolean private.pbDriverDefaultNullableDateTime False
92577>>>>>        Property Boolean private.pbDriverDefaultNullableNumeric  False
92578>>>>>        Property Boolean private.pbDriverDefaultNullableText     False
92579>>>>>
92579>>>>>        // paSQLQueryMessages is a property of the container class cDbUpdateHandler.
92579>>>>>        // It is being used to gather ESQL message replies, and is output to the log file
92579>>>>>        // if pbVerboseState = True in the cDbUpdateHandler object.
92579>>>>>        // (See: Procedure Set pbDatabaseWasUpdated in the cDbUpdateHandler class)
92579>>>>>        // We reset it here for each cDbUpdateVersion object
92579>>>>>        Delegate Set paSQLQueryMessages to aSQLQueryMessages
92581>>>>>    End_Procedure
92582>>>>>
92582>>>>>    // *** Main hook event message ***
92582>>>>>    // Place your database update logic here!
92582>>>>>    Procedure OnUpdate
92584>>>>>    End_Procedure
92585>>>>>
92585>>>>>    // These properties also exists in the cDbUpdateFunctionLibray that is
92585>>>>>    // imported to the cDbUpdateHandler container class which should be a
92585>>>>>    // parent object to this object. To have the Studio's Property Panel
92585>>>>>    // "behave" aka show these properties we need to duplicate them in this
92585>>>>>    // class and "relay" them to the parent object.
92585>>>>>    Procedure Set pbToANSI Boolean bState
92587>>>>>        Set private.pbToANSI  to bState
92588>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92589>>>>>        Delegate Set pbToANSI to bState
92591>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92592>>>>>    End_Procedure
92593>>>>>
92593>>>>>    Function pbToANSI Returns Boolean
92595>>>>>        Function_Return (private.pbToAnsi(Self))
92596>>>>>    End_Function
92597>>>>>
92597>>>>>    Procedure Set pbRecnum Boolean bState
92599>>>>>        Set private.pbRecnum  to bState
92600>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92601>>>>>        Delegate Set pbRecnum to bState
92603>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92604>>>>>    End_Procedure
92605>>>>>
92605>>>>>    Function pbRecnum Returns Boolean
92607>>>>>        Function_Return (private.pbRecnum(Self))
92608>>>>>    End_Function
92609>>>>>
92609>>>>>    Procedure Set pbCopyData Boolean bState
92611>>>>>        Set private.pbCopyData  to bState
92612>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92613>>>>>        Delegate Set pbCopyData to bState
92615>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92616>>>>>    End_Procedure
92617>>>>>
92617>>>>>    Function pbCopyData Returns Boolean
92619>>>>>        Function_Return (private.pbCopyData(Self))
92620>>>>>    End_Function
92621>>>>>
92621>>>>>    // ToDo: Should we put these four properties under another "Property Panel" section?
92621>>>>>    Procedure Set pbApiTableUpdateAuto Boolean bState
92623>>>>>        Set private.pbApiTableUpdateAuto  to bState
92624>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92625>>>>>        Set pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
92626>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92627>>>>>    End_Procedure
92628>>>>>
92628>>>>>    Function pbApiTableUpdateAuto Returns Boolean
92630>>>>>        Function_Return (private.pbApiTableUpdateAuto(Self))
92631>>>>>    End_Function
92632>>>>>
92632>>>>>    Procedure Set pbCompareDate_DateTime Boolean bState
92634>>>>>        Set private.pbCompareDate_DateTime  to bState
92635>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92636>>>>>        Set pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
92637>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92638>>>>>    End_Procedure
92639>>>>>
92639>>>>>    Function pbCompareDate_DateTime Returns Boolean
92641>>>>>        Function_Return (private.pbCompareDate_DateTime(Self))
92642>>>>>    End_Function
92643>>>>>
92643>>>>>    Procedure Set pbCompareIndexAscending Boolean bState
92645>>>>>        Set private.pbCompareIndexAscending  to bState
92646>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92647>>>>>        Set pbCompareIndexAscending of ghoSQLConnectionHandler to bState
92648>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92649>>>>>    End_Procedure
92650>>>>>
92650>>>>>    Function pbCompareIndexAscending Returns Boolean
92652>>>>>        Function_Return (private.pbCompareIndexAscending(Self))
92653>>>>>    End_Function
92654>>>>>
92654>>>>>    Procedure Set pbCompareIndexUppercase Boolean bState
92656>>>>>        Set private.pbCompareIndexUppercase  to bState
92657>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92658>>>>>        Set pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
92659>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92660>>>>>    End_Procedure
92661>>>>>
92661>>>>>    Function pbCompareIndexUppercase Returns Boolean
92663>>>>>        Function_Return (private.pbCompareIndexUppercase(Self))
92664>>>>>    End_Function
92665>>>>>
92665>>>>>    Procedure Set psSchema String sValue
92667>>>>>        Set private.psSchema  to sValue
92668>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92669>>>>>        Delegate Set psSchema to sValue
92671>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92672>>>>>    End_Procedure
92673>>>>>
92673>>>>>    // First retrieve the private value that might have been set in the object.
92673>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
92673>>>>>    // it might have been specified in the SQLConnections.ini file.
92673>>>>>    Function psSchema Returns String
92675>>>>>        String sValue
92675>>>>>        Get private.psSchema to sValue
92676>>>>>        If (sValue = "") Begin
92678>>>>>            Get psSchema of ghoSQLConnectionHandler to sValue
92679>>>>>        End
92679>>>>>>
92679>>>>>        Function_Return sValue
92680>>>>>    End_Function
92681>>>>>
92681>>>>>    Procedure Set psBaseTableSpace String sValue
92683>>>>>        Set private.psBaseTableSpace  to sValue
92684>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92685>>>>>        Delegate Set psBaseTableSpace to sValue
92687>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92688>>>>>    End_Procedure
92689>>>>>
92689>>>>>    // First retrieve the private value that might have been set in the object.
92689>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
92689>>>>>    // it might have been specified in the SQLConnections.ini file.
92689>>>>>    Function psBaseTableSpace Returns String
92691>>>>>        String sValue
92691>>>>>        Get private.psBaseTableSpace to sValue
92692>>>>>        If (sValue = "") Begin
92694>>>>>            Get psBaseTableSpace of ghoSQLConnectionHandler to sValue
92695>>>>>        End
92695>>>>>>
92695>>>>>        Function_Return sValue
92696>>>>>    End_Function
92697>>>>>
92697>>>>>    Procedure Set psLongTableSpace String sValue
92699>>>>>        Set private.psLongTableSpace  to sValue
92700>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92701>>>>>        Delegate Set psLongTableSpace to sValue
92703>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92704>>>>>    End_Procedure
92705>>>>>
92705>>>>>    // First retrieve the private value that might have been set in the object.
92705>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
92705>>>>>    // it might have been specified in the SQLConnections.ini file.
92705>>>>>    Function psLongTableSpace Returns String
92707>>>>>        String sValue
92707>>>>>        Get private.psLongTableSpace to sValue
92708>>>>>        If (sValue = "") Begin
92710>>>>>            Get psLongTableSpace of ghoSQLConnectionHandler to sValue
92711>>>>>        End
92711>>>>>>
92711>>>>>        Function_Return sValue
92712>>>>>    End_Function
92713>>>>>
92713>>>>>    Procedure Set psIndexTableSpace String sValue
92715>>>>>        Set private.psIndexTableSpace  to sValue
92716>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92717>>>>>        Delegate Set psIndexTableSpace to sValue
92719>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92720>>>>>    End_Procedure
92721>>>>>
92721>>>>>    // First retrieve the private value that might have been set in the object.
92721>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
92721>>>>>    // it might have been specified in the SQLConnections.ini file.
92721>>>>>    Function psIndexTableSpace Returns String
92723>>>>>        String sValue
92723>>>>>        Get private.psIndexTableSpace to sValue
92724>>>>>        If (sValue = "") Begin
92726>>>>>            Get psIndexTableSpace of ghoSQLConnectionHandler to sValue
92727>>>>>        End
92727>>>>>>
92727>>>>>        Function_Return sValue
92728>>>>>    End_Function
92729>>>>>
92729>>>>>    Procedure Set psDriverDefaultValueASCII String sValue
92731>>>>>        Set private.psDriverDefaultValueASCII  to sValue
92732>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92733>>>>>        Delegate Set psDriverDefaultValueASCII to sValue
92735>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92736>>>>>    End_Procedure
92737>>>>>
92737>>>>>    // First retrieve the private value that might have been set in the object.
92737>>>>>    // If blank; get it from the parent object
92737>>>>>    Function psDriverDefaultValueASCII Returns String
92739>>>>>        String sValue
92739>>>>>        Get private.psDriverDefaultValueASCII to sValue
92740>>>>>        If (sValue = "") Begin
92742>>>>>            Delegate Get psDriverDefaultValueASCII to sValue
92744>>>>>        End
92744>>>>>>
92744>>>>>        Function_Return sValue
92745>>>>>    End_Function
92746>>>>>
92746>>>>>    Procedure Set psDriverDefaultValueBinary String sValue
92748>>>>>        Set private.psDriverDefaultValueBinary  to sValue
92749>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92750>>>>>        Delegate Set psDriverDefaultValueBinary to sValue
92752>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92753>>>>>    End_Procedure
92754>>>>>
92754>>>>>    // First retrieve the private value that might have been set in the object.
92754>>>>>    // If blank; get it from the parent object
92754>>>>>    Function psDriverDefaultValueBinary Returns String
92756>>>>>        String sValue
92756>>>>>        Get private.psDriverDefaultValueBinary to sValue
92757>>>>>        If (sValue = "") Begin
92759>>>>>            Delegate Get psDriverDefaultValueBinary to sValue
92761>>>>>        End
92761>>>>>>
92761>>>>>        Function_Return sValue
92762>>>>>    End_Function
92763>>>>>
92763>>>>>    Procedure Set psDriverDefaultValueDate String sValue
92765>>>>>        Set private.psDriverDefaultValueDate  to sValue
92766>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92767>>>>>        Delegate Set psDriverDefaultValueDate to sValue
92769>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92770>>>>>    End_Procedure
92771>>>>>
92771>>>>>    // First retrieve the private value that might have been set in the object.
92771>>>>>    // If blank; get it from the parent object
92771>>>>>    Function psDriverDefaultValueDate Returns String
92773>>>>>        String sValue
92773>>>>>        Get private.psDriverDefaultValueDate to sValue
92774>>>>>        If (sValue = "") Begin
92776>>>>>            Delegate Get psDriverDefaultValueDate to sValue
92778>>>>>        End
92778>>>>>>
92778>>>>>        Function_Return sValue
92779>>>>>    End_Function
92780>>>>>
92780>>>>>    Procedure Set psDriverDefaultValueDateTime String sValue
92782>>>>>        Set private.psDriverDefaultValueDateTime  to sValue
92783>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92784>>>>>        Delegate Set psDriverDefaultValueDateTime to sValue
92786>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92787>>>>>    End_Procedure
92788>>>>>
92788>>>>>    // First retrieve the private value that might have been set in the object.
92788>>>>>    // If blank; get it from the parent object
92788>>>>>    Function psDriverDefaultValueDateTime Returns String
92790>>>>>        String sValue
92790>>>>>        Get private.psDriverDefaultValueDateTime to sValue
92791>>>>>        If (sValue = "") Begin
92793>>>>>            Delegate Get psDriverDefaultValueDateTime to sValue
92795>>>>>        End
92795>>>>>>
92795>>>>>        Function_Return sValue
92796>>>>>    End_Function
92797>>>>>
92797>>>>>    Procedure Set psDriverDefaultValueNumeric String sValue
92799>>>>>        Set private.psDriverDefaultValueNumeric  to sValue
92800>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92801>>>>>        Delegate Set psDriverDefaultValueNumeric to sValue
92803>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92804>>>>>    End_Procedure
92805>>>>>
92805>>>>>    // First retrieve the private value that might have been set in the object.
92805>>>>>    // If blank; get it from the parent object
92805>>>>>    Function psDriverDefaultValueNumeric Returns String
92807>>>>>        String sValue
92807>>>>>        Get private.psDriverDefaultValueNumeric to sValue
92808>>>>>        If (sValue = "") Begin
92810>>>>>            Delegate Get psDriverDefaultValueNumeric to sValue
92812>>>>>        End
92812>>>>>>
92812>>>>>        Function_Return sValue
92813>>>>>    End_Function
92814>>>>>
92814>>>>>    Procedure Set psDriverDefaultValueText String sValue
92816>>>>>        Set private.psDriverDefaultValueText  to sValue
92817>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92818>>>>>        Delegate Set psDriverDefaultValueText to sValue
92820>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92821>>>>>    End_Procedure
92822>>>>>
92822>>>>>    // First retrieve the private value that might have been set in the object.
92822>>>>>    // If blank; get it from the parent object
92822>>>>>    Function psDriverDefaultValueText Returns String
92824>>>>>        String sValue
92824>>>>>        Get private.psDriverDefaultValueText to sValue
92825>>>>>        If (sValue = "") Begin
92827>>>>>            Delegate Get psDriverDefaultValueText to sValue
92829>>>>>        End
92829>>>>>>
92829>>>>>        Function_Return sValue
92830>>>>>    End_Function
92831>>>>>
92831>>>>>    Procedure Set pbDriverDefaultNullableASCII Boolean bState
92833>>>>>        Set private.pbDriverDefaultNullableASCII  to bState
92834>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92835>>>>>        Delegate Set pbDriverDefaultNullableASCII to bState
92837>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92838>>>>>    End_Procedure
92839>>>>>
92839>>>>>    // First retrieve the private value that might have been set in the object.
92839>>>>>    // If blank; get it from the parent object
92839>>>>>    Function pbDriverDefaultNullableASCII Returns Boolean
92841>>>>>        Boolean bState
92841>>>>>        Get private.pbDriverDefaultNullableASCII to bState
92842>>>>>        If (bState = False) Begin
92844>>>>>            Delegate Get pbDriverDefaultNullableASCII to bState
92846>>>>>        End
92846>>>>>>
92846>>>>>        Function_Return bState
92847>>>>>    End_Function
92848>>>>>
92848>>>>>    Procedure Set pbDriverDefaultNullableBinary Boolean bState
92850>>>>>        Set private.pbDriverDefaultNullableBinary  to bState
92851>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92852>>>>>        Delegate Set pbDriverDefaultNullableBinary to bState
92854>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92855>>>>>    End_Procedure
92856>>>>>
92856>>>>>    // First retrieve the private value that might have been set in the object.
92856>>>>>    // If blank; get it from the parent object
92856>>>>>    Function pbDriverDefaultNullableBinary Returns Boolean
92858>>>>>        Boolean bState
92858>>>>>        Get private.pbDriverDefaultNullableBinary to bState
92859>>>>>        If (bState = False) Begin
92861>>>>>            Delegate Get pbDriverDefaultNullableBinary to bState
92863>>>>>        End
92863>>>>>>
92863>>>>>        Function_Return bState
92864>>>>>    End_Function
92865>>>>>
92865>>>>>    Procedure Set pbDriverDefaultNullableDate Boolean bState
92867>>>>>        Set private.pbDriverDefaultNullableDate  to bState
92868>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92869>>>>>        Delegate Set pbDriverDefaultNullableDate to bState
92871>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92872>>>>>    End_Procedure
92873>>>>>
92873>>>>>    // First retrieve the private value that might have been set in the object.
92873>>>>>    // If blank; get it from the parent object
92873>>>>>    Function pbDriverDefaultNullableDate Returns Boolean
92875>>>>>        Boolean bState
92875>>>>>        Get private.pbDriverDefaultNullableDate to bState
92876>>>>>        If (bState = False) Begin
92878>>>>>            Delegate Get pbDriverDefaultNullableDate to bState
92880>>>>>        End
92880>>>>>>
92880>>>>>        Function_Return bState
92881>>>>>    End_Function
92882>>>>>
92882>>>>>    Procedure Set pbDriverDefaultNullableDateTime Boolean bState
92884>>>>>        Set private.pbDriverDefaultNullableDateTime  to bState
92885>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92886>>>>>        Delegate Set pbDriverDefaultNullableDateTime to bState
92888>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92889>>>>>    End_Procedure
92890>>>>>
92890>>>>>    // First retrieve the private value that might have been set in the object.
92890>>>>>    // If blank; get it from the parent object
92890>>>>>    Function pbDriverDefaultNullableDateTime Returns Boolean
92892>>>>>        Boolean bState
92892>>>>>        Get private.pbDriverDefaultNullableDateTime to bState
92893>>>>>        If (bState = False) Begin
92895>>>>>            Delegate Get pbDriverDefaultNullableDateTime to bState
92897>>>>>        End
92897>>>>>>
92897>>>>>        Function_Return bState
92898>>>>>    End_Function
92899>>>>>
92899>>>>>    Procedure Set pbDriverDefaultNullableNumeric Boolean bState
92901>>>>>        Set private.pbDriverDefaultNullableNumeric  to bState
92902>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92903>>>>>        Delegate Set pbDriverDefaultNullableNumeric to bState
92905>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92906>>>>>    End_Procedure
92907>>>>>
92907>>>>>    // First retrieve the private value that might have been set in the object.
92907>>>>>    // If blank; get it from the parent object
92907>>>>>    Function pbDriverDefaultNullableNumeric Returns Boolean
92909>>>>>        Boolean bState
92909>>>>>        Get private.pbDriverDefaultNullableNumeric to bState
92910>>>>>        If (bState = False) Begin
92912>>>>>            Delegate Get pbDriverDefaultNullableNumeric to bState
92914>>>>>        End
92914>>>>>>
92914>>>>>        Function_Return bState
92915>>>>>    End_Function
92916>>>>>
92916>>>>>    Procedure Set pbDriverDefaultNullableText Boolean bState
92918>>>>>        Set private.pbDriverDefaultNullableText  to bState
92919>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92920>>>>>        Delegate Set pbDriverDefaultNullableText to bState
92922>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92923>>>>>    End_Procedure
92924>>>>>
92924>>>>>    // First retrieve the private value that might have been set in the object.
92924>>>>>    // If blank; get it from the parent object
92924>>>>>    Function pbDriverDefaultNullableText Returns Boolean
92926>>>>>        Boolean bState
92926>>>>>        Get private.pbDriverDefaultNullableText to bState
92927>>>>>        If (bState = False) Begin
92929>>>>>            Delegate Get pbDriverDefaultNullableText to bState
92931>>>>>        End
92931>>>>>>
92931>>>>>        Function_Return bState
92932>>>>>    End_Function
92933>>>>>
92933>>>>>    Function ApiTableConvertToSQL Handle hTable Returns Boolean
92935>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK
92935>>>>>        String sDriverID sSchema sBaseTableSpace sLongTableSpace sIndexTableSpace
92935>>>>>
92935>>>>>        Get psDriverID to sDriverID
92936>>>>>        Get psSchema to sSchema
92937>>>>>
92937>>>>>        Get psBaseTableSpace to sBaseTableSpace
92938>>>>>        If (sBaseTableSpace <> "") Begin
92940>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92941>>>>>            Delegate Set psBaseTableSpace to sBaseTableSpace
92943>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92944>>>>>        End
92944>>>>>>
92944>>>>>
92944>>>>>        Get psLongTableSpace to sLongTableSpace
92945>>>>>        If (sLongTableSpace <> "") Begin
92947>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92948>>>>>            Delegate Set psLongTableSpace to sLongTableSpace
92950>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92951>>>>>        End
92951>>>>>>
92951>>>>>
92951>>>>>        Get psIndexTableSpace to sIndexTableSpace
92952>>>>>        If (sIndexTableSpace <> "") Begin
92954>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
92955>>>>>            Delegate Set psIndexTableSpace to sIndexTableSpace
92957>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
92958>>>>>        End
92958>>>>>>
92958>>>>>
92958>>>>>        Get pbUseConnectionID to bUseConnectionID
92959>>>>>        Get pbToANSI          to bToANSI
92960>>>>>        Get pbRecnum          to bRecnum
92961>>>>>        Get pbCopyData        to bCopyData
92962>>>>>
92962>>>>>        Get ApiTableConvertToSQL_Ex hTable sDriverID bUseConnectionID bToANSI bRecnum bCopyData to bOK
92963>>>>>
92963>>>>>        Function_Return bOK
92964>>>>>    End_Function
92965>>>>>
92965>>>>>//    Function ApiTableMoveAllToBackupFolder Returns Boolean
92965>>>>>//        Boolean bOK bExists
92965>>>>>//        String sDataPath sBackupFolder
92965>>>>>//        
92965>>>>>//        Set Message_Text of ghoStatusPanel to "Moving Embedded (*.dat) files to Backup folder."
92965>>>>>//        Move CS_DUFBackupDataFolder to sBackupFolder
92965>>>>>//        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
92965>>>>>//        Get vFolderFormat sDataPath to sDataPath
92965>>>>>//        
92965>>>>>//        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
92965>>>>>//        If (bExists = False) Begin
92965>>>>>//            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
92965>>>>>//            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
92965>>>>>//            If (bExists = False) Begin
92965>>>>>//                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all *.dat and *.k?? files to. You need to move them somewhere manually.")
92965>>>>>//                Function_Return False
92965>>>>>//            End                                                                                                                                            
92965>>>>>//            Get vMoveFile (sDataPath + "*.dat") (sDataPath + sBackupFolder) to bOK
92965>>>>>//            Get vMoveFile (sDataPath + "*.hdr") (sDataPath + sBackupFolder) to bOK
92965>>>>>//            Get vMoveFile (sDataPath + "*.k??") (sDataPath + sBackupFolder) to bOK
92965>>>>>//            Get vMoveFile (sDataPath + "*.vld") (sDataPath + sBackupFolder) to bOK
92965>>>>>//        End
92965>>>>>//        
92965>>>>>//        Set Message_Text of ghoStatusPanel to ""
92965>>>>>//        Function_Return bOK
92965>>>>>//    End_Function
92965>>>>>//
92965>>>>>    // This is automatically called after the OnUpdate
92965>>>>>    // event has been executed. It will automatically update the
92965>>>>>    // version database field/column with the "pnVersionNumber"
92965>>>>>    // value of the parent cDbUpdateHandler class - if it has been changed.
92965>>>>>    Procedure UpdateVersionColumnValue
92967>>>>>        Number nVersion nCurrentValue
92967>>>>>        Integer hTable iColumn
92967>>>>>        Boolean bVersionUpdate bDbUpdateErrorHasOccured bUseCustomDbVersion
92967>>>>>
92967>>>>>        // This is a property of the container class; cDbUpdateHandler that gets set when
92967>>>>>        // an error occurres when processing ESQL or database API messages of the cDbUpdateFunctionLibrary.
92967>>>>>        Delegate Get pbDbUpdateErrorHasOccured to bDbUpdateErrorHasOccured
92969>>>>>        Get pbVersionUpdate to bVersionUpdate
92970>>>>>
92970>>>>>        If (bVersionUpdate = True and bDbUpdateErrorHasOccured = False) Begin
92972>>>>>            Get pnVersionNumber to nVersion
92973>>>>>            Delegate Get piDbVersionFileNumber  to hTable
92975>>>>>            Delegate Get piDbVersionFieldNumber to iColumn
92977>>>>>            // NB! We need to permanently close tables as they e.g. now might no longer be embedded
92977>>>>>            // but instead SQL tables. If we don't the "old" embedded table will be opened instead.
92977>>>>>            Close DF_ALL DF_PERMANENT
92978>>>>>
92978>>>>>            Open hTable
92980>>>>>
92980>>>>>            // It is then the developer responsibility to take care of finding
92980>>>>>            // the correct record that is to be updated (The DbVersion table is not used). 
92980>>>>>            Delegate Get pbUseCustomDbVersion to bUseCustomDbVersion
92982>>>>>            If (bUseCustomDbVersion = True) Begin
92984>>>>>                Delegate Send OnFindVersionRecord   // cDbUpdateHandler object event (Programmer's hook!).
92986>>>>>            End
92986>>>>>>
92986>>>>>
92986>>>>>            Get_Field_Value hTable iColumn to nCurrentValue
92989>>>>>            If (nCurrentValue < nVersion) Begin
92991>>>>>                Lock
92992>>>>>>
92992>>>>>                    If (bUseCustomDbVersion = False) Begin
92994>>>>>                        Vfind hTable Recnum GE                            
92996>>>>>                    End
92996>>>>>>
92996>>>>>                    Set_Field_Value hTable iColumn to nVersion
92999>>>>>                    SaveRecord hTable
93000>>>>>                Unlock
93001>>>>>>
93001>>>>>            End
93001>>>>>>
93001>>>>>            Close hTable
93002>>>>>        End
93002>>>>>>
93002>>>>>    End_Procedure
93003>>>>>
93003>>>>>// Property of the container object (cDbUpdateHandler)
93003>>>>>Register_Function piCurrentErrorHandlerID Returns Integer
93003>>>>>
93003>>>>>    Procedure End_Construct_Object
93005>>>>>        Forward Send End_Construct_Object
93007>>>>>        Send ProcessUpdate True
93008>>>>>    End_Procedure
93009>>>>>    
93009>>>>>    Procedure ProcessUpdate Boolean bShouldTestForDuplicateVersionNumbers
93011>>>>>        Number nVersion nCurrentValue
93011>>>>>        Integer hTable iColumn iSize iDbVersionFileNumber iStatus
93011>>>>>        Boolean bStopOnFirstError bDbUpdateErrorHasOccured bContinueOnError bOpened bSystemTable bUseCustomDbVersion bTableExists bOnPreUpdateExecuted
93011>>>>>        String sObjectName
93011>>>>>        tDbVersionInfo[] dbVersionInfoArray
93011>>>>>        tDbVersionInfo[] dbVersionInfoArray
93012>>>>>
93012>>>>>        Delegate Set Private.pbUpdateVersionObjectError to False
93014>>>>>
93014>>>>>        // If the programmer forgot to set the version number we do not allow for the application
93014>>>>>        // to continue to run, as this potentially could endanger the integrity of the database. E.g. if
93014>>>>>        // one database update is depended on an earlier update and that earlier version
93014>>>>>        // update was never executed it could lead to disastrous results.
93014>>>>>        // This is a programmer error and should be discovered before any customer sees it. Thus no point in translating...
93014>>>>>        Get pnVersionNumber to nVersion
93015>>>>>        If (nVersion = 0) Begin
93017>>>>>            Get piCurrentErrorHandlerID to Error_Object_Id
93018>>>>>            Move (Name(Self)) to sObjectName
93019>>>>>            Error DFERR_PROGRAM ("The pnVersionNumber property was not set properly by the programmer for the following object; Program will now exit!\n\n" + sObjectName)
93020>>>>>>
93020>>>>>            Send Exit_Application
93021>>>>>        End
93021>>>>>>
93021>>>>>
93021>>>>>        // These are send to the parent container object (cDbUpdateHandler). The order is very sensitive!
93021>>>>>        // Hook event for the developer to e.g. create a database before the update events starts.
93021>>>>>        Delegate Get Private.pbOnPreUpdateExecuted to bOnPreUpdateExecuted
93023>>>>>        If (bOnPreUpdateExecuted = False) Begin
93025>>>>>            Delegate Send OnPreUpdate
93027>>>>>            Delegate Set Private.pbOnPreUpdateExecuted to True
93029>>>>>        End
93029>>>>>>
93029>>>>>        
93029>>>>>        Delegate Get piDbVersionFileNumber to iDbVersionFileNumber
93031>>>>>        
93031>>>>>        Delegate Get pbUseCustomDbVersion to bUseCustomDbVersion
93033>>>>>        If (bUseCustomDbVersion = False) Begin
93035>>>>>//            Delegate Send CheckAutoCreateDbVersionTable // cDbUpdateHandler object event.
93035>>>>>        End
93035>>>>>>
93035>>>>>        Else Begin
93036>>>>>            Get _UtilTableExists of ghoDbUpdateFunctionLibrary iDbVersionFileNumber to bTableExists
93037>>>>>            If (bTableExists = False) Begin
93039>>>>>                Delegate Send OnCreateCustomDbVersionTable
93041>>>>>            End
93041>>>>>>
93041>>>>>        End
93041>>>>>>
93041>>>>>        
93041>>>>>        // We now check that two or more cDbVersion objects does not have the same pnVersionNumber.
93041>>>>>        // Note that the paDbVersionInfoArray is a property of the container object (cDbUpdateHandler)
93041>>>>>        If (bShouldTestForDuplicateVersionNumbers = True) Begin
93043>>>>>            Delegate Get paDbVersionInfoArray to dbVersionInfoArray
93045>>>>>            Move (SizeOfArray(dbVersionInfoArray)) to iSize
93046>>>>>            Move nVersion to dbVersionInfoArray[iSize].nVersionNumber
93047>>>>>            Move (Self)   to dbVersionInfoArray[iSize].hObject
93048>>>>>            Delegate Set paDbVersionInfoArray to dbVersionInfoArray
93050>>>>>            Delegate Send CheckForDuplicates nVersion   // cDbUpdateHandler object event.
93052>>>>>        End
93052>>>>>>
93052>>>>>
93052>>>>>        Delegate Get piDbVersionFileNumber  to hTable
93054>>>>>        Delegate Get piDbVersionFieldNumber to iColumn
93056>>>>>
93056>>>>>        Open hTable
93058>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
93061>>>>>        If (bOpened = False) Begin
93063>>>>>            Send Stop_Box CS_DUF_DbUpdateTableMissing
93064>>>>>            Send Exit_Application
93065>>>>>        End
93065>>>>>>
93065>>>>>        
93065>>>>>        // It can happen that the table isn't initialized with a record even though it is a system table,
93065>>>>>        // in case we take care of it here.
93065>>>>>        Get_Attribute DF_FILE_STATUS of hTable to iStatus
93068>>>>>        If (iStatus = DF_FILE_INACTIVE) Begin
93070>>>>>            Vfind hTable 0 GT
93072>>>>>        End
93072>>>>>>
93072>>>>>        Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bSystemTable
93075>>>>>        If (bSystemTable = True) Begin
93077>>>>>            Get_Field_Value hTable iColumn to nCurrentValue
93080>>>>>        End
93080>>>>>>
93080>>>>>        Else Begin
93081>>>>>            If (bUseCustomDbVersion = True) Begin
93083>>>>>                Send OnFindVersionRecord
93084>>>>>                Get_Field_Value hTable iColumn to nCurrentValue
93087>>>>>            End
93087>>>>>>
93087>>>>>        End
93087>>>>>>
93087>>>>>
93087>>>>>        Close hTable
93088>>>>>
93088>>>>>        // We also guard from missing 'DatabaseVersionInfoTable' and column properties settings.
93088>>>>>        // If not set we do nothing.
93088>>>>>        If (nCurrentValue < nVersion) Begin
93090>>>>>
93090>>>>>            // If pbStopOnFirstError is True in the parent, the idea is that we do _no_ further
93090>>>>>            // execution of database update code. So if true _and_ one error
93090>>>>>            // has already occured; we're out of here.
93090>>>>>            Delegate Get pbStopOnFirstError        to bStopOnFirstError
93092>>>>>            Delegate Get pbDbUpdateErrorHasOccured to bDbUpdateErrorHasOccured
93094>>>>>            If (bStopOnFirstError = True) Begin
93096>>>>>                If (bDbUpdateErrorHasOccured = True) Begin
93098>>>>>                    Procedure_Return
93099>>>>>                End
93099>>>>>>
93099>>>>>            End
93099>>>>>>
93099>>>>>
93099>>>>>            // This is send to the parent container object (cDbUpdateHandler)
93099>>>>>            Delegate Send InitDatabaseUpdate (Self)    // cDbUpdateHandler object event.
93101>>>>>
93101>>>>>            // If the parent property pbContinueOnError = False, an update
93101>>>>>            // of a following cDbUpdateVersion object should not take place and we're out of here.
93101>>>>>            Delegate Get pbContinueOnError to bContinueOnError
93103>>>>>            If (bContinueOnError = False and bDbUpdateErrorHasOccured = True) Begin
93105>>>>>                Procedure_Return
93106>>>>>            End
93106>>>>>>
93106>>>>>
93106>>>>>            Delegate Set pnCurrentVersionUpdate to nVersion
93108>>>>>
93108>>>>>            Set Title_Text of ghoStatusPanel to (CS_DUF_UpdateVersion * CS_DUF_UpdateFromVersion * String(nCurrentValue) * CS_DUF_UpdateToVersion * String(nVersion))
93109>>>>>
93109>>>>>            // *** Programmer's main hook event for database update functions:
93109>>>>>            Send OnUpdate
93110>>>>>
93110>>>>>            Set pbVersionUpdate to True
93111>>>>>            Send UpdateVersionColumnValue
93112>>>>>            Delegate Set pbDatabaseWasUpdated to True   // cDbUpdateHandler property.
93114>>>>>        End
93114>>>>>>
93114>>>>>
93114>>>>>    End_Procedure
93115>>>>>
93115>>>>>End_Class
93116>>>Use cDbUpdateUserCount.pkg
Including file: cDbUpdateUserCount.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateUserCount.pkg)
93116>>>>>//****************************************************************************
93116>>>>>// $Module type: Class
93116>>>>>// $Module name: cDbUpdateUserCount.pkg
93116>>>>>// $Author     : Emil Stojanov Quantaris B.V.
93116>>>>>//
93116>>>>>//               Collected from DAW's newsgroups.
93116>>>>>//
93116>>>>>// Description : It uses the windows API to lock bytes in a file.
93116>>>>>//               If the application or PC craches it will release the lock
93116>>>>>//               automatically.
93116>>>>>//
93116>>>>>// Note 1      : It will count the number of running app's, so if a
93116>>>>>//               user starts the app twice on one machine it will count as two users.
93116>>>>>// Note 2      : The class was originally named cUserCount by Emil Stojanov.
93116>>>>>//               However, to not conflict with any other usage of this class it was
93116>>>>>//               renamed to "fit" into the "Database Update Framework" (cDbUpdateHandler
93116>>>>>//               and cDbUpdateVersion classes)
93116>>>>>//
93116>>>>>// $Rev History:
93116>>>>>//    2008-10-17  Module header created (Militaty data format)
93116>>>>>//    2008-10-17  Minor changes by Nils G Svedmyr. Created UI text constants
93116>>>>>//                for easy translation to other languages.
93116>>>>>//                Added the tUserCount struct for easier passing of parameters.
93116>>>>>//                Added the ApplicationPath message.
93116>>>>>//****************************************************************************
93116>>>>>Use LanguageText.pkg
93116>>>>>Use cDbUpdateUserCount.inc
Including file: cDbUpdateUserCount.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateUserCount.inc)
93116>>>>>>>Use GlobalFunctionsProcedures.pkg
93116>>>>>>>// Sample:
93116>>>>>>>// Get DoSetDefaultPrinter "HP LaserJet 4" to bVoid
93116>>>>>>>
93116>>>>>>>
93116>>>>>>>// Symbols used by UserCounting
93116>>>>>>>    Define GENERIC_READ         for |CI$80000000
93116>>>>>>>    Define GENERIC_WRITE        for |CI$40000000
93116>>>>>>>    Define GENERIC_EXECUTE      for |CI$20000000
93116>>>>>>>    Define GENERIC_ALL          for |CI$10000000
93116>>>>>>>    Define CREATE_NEW           for 1
93116>>>>>>>    Define CREATE_ALWAYS        for 2
93116>>>>>>>    Define OPEN_EXISTING        for 3
93116>>>>>>>    Define OPEN_ALWAYS          for 4
93116>>>>>>>    Define TRUNCATE_EXISTING    for 5
93116>>>>>>>    Define FILE_BEGIN           for 0
93116>>>>>>>    Define FILE_CURRENT         for 1
93116>>>>>>>    Define FILE_END             for 2
93116>>>>>>>    Define FILE_SHARE_READ      for |CI$00000001
93116>>>>>>>    Define FILE_SHARE_WRITE     for |CI$00000002
93116>>>>>>>    Define FILE_SHARE_DELETE    for |CI$00000004
93116>>>>>>>    Define FILE_FLAG_WRITE_THROUGH            for |CI$80000000
93116>>>>>>>    Define _MAX_PATH  for 260
93116>>>>>>>    Define _MAX_DRIVE for 3
93116>>>>>>>    Define _MAX_DIR   for 256
93116>>>>>>>    Define _MAX_FNAME for 256
93116>>>>>>>    Define _MAX_EXT   for 256
93116>>>>>>>
93116>>>>>>>External_Function Win32_CreateFile "CreateFileA" KERNEL32.DLL ;    Pointer lpFileName ;              // file name    DWord dwDesiredAccess ;           // access mode    DWord dwShareMode ;               // share mode    Pointer lpSecurityAttributes ;    // SD    DWord dwCreationDisposition ;     // how to create    DWord dwFlagsAndAttributes ;      // file attributes    Handle hTemplateFile ;            // handle to template file    Returns Handle
93117>>>>>>>
93117>>>>>>>External_Function Win32_ReadFile "ReadFile" KERNEL32.DLL ;    Handle hFile ;                  // handle to file    Pointer lpBuffer ;              // pointer to the buffer that receives the data    dWord nNumberOfBytesToRead ;    // number of bytes to read    Pointer lpNumberOfBytesRead ;   // number of bytes read    Pointer lpOverlapped ;          // pointer to an overlapped structure    Returns Integer
93118>>>>>>>
93118>>>>>>>External_Function Win32_WriteFile "WriteFile" KERNEL32.DLL ;    Handle hFile ;                      // handle to file    Pointer lpBuffer ;                  // pointer to buffer containing data to write    dWord nNumberOfBytesToWrite ;       // number of bytes to write    Pointer lpNumberOfBytesWritten ;    // number of bytes written    Pointer lpOverlapped ;              // pointer to an overlapped structure    Returns Integer
93119>>>>>>>
93119>>>>>>>External_Function Win32_LockFile "LockFile" KERNEL32.DLL ;    Handle hFile ;                      // handle to file    dWord dwFileOffsetLow ;             // low-order word of startposition    dWord dwFileOffsetHigh ;            // high-order word of startposition    dWord nNumberOfBytesToLockLow ;     // low-order word of length    dWord nNumberOfBytesToLockHigh ;    // high-order word of length    Returns Integer
93120>>>>>>>
93120>>>>>>>External_Function Win32_UnlockFile "UnlockFile" KERNEL32.DLL ;    Handle hFile ;                      // handle to file    dWord dwFileOffsetLow ;             // low-order word of startposition    dWord dwFileOffsetHigh ;            // high-order word of startposition    dWord nNumberOfBytesToUnLockLow ;   // low-order word of length    dWord nNumberOfBytesToUnLockHigh ;  // high-order word of length    Returns Integer
93121>>>>>>>
93121>>>>>>>External_Function Win32_SetFilePointer "SetFilePointer" KERNEL32.DLL ;    Handle hFile ;                  // handle to file    Integer lDistanceToMove ;       // bytes to move pointer (low-order 32-bits)    Pointer lpDistanceToMoveHigh ;  // bytes to move pointer (high-order 32-bits)    dWord dwMoveMethod ;            // starting point    Returns dWord
93122>>>>>>>
93122>>>>>>>External_Function Win32_CloseHandle "CloseHandle" KERNEL32.DLL ;    Handle hObject ;    // handle to object    Returns Integer
93123>>>>>>>
93123>>>>>>>External_Function SetDefaultPrinterEf "SetDefaultPrinterA" winspool.drv Pointer lpPrinter Returns Boolean
93124>>>>>>>// Sample:
93124>>>>>>>// Get DoSetDefaultPrinter "HP LaserJet 4" to bVoid
93124>>>>>>>Function DoSetDefaultPrinter String sPrinter Returns Boolean
93126>>>>>>>    Boolean bReturn
93126>>>>>>>    Move (Utf8ToAnsi(sPrinter)) to sPrinter
93127>>>>>>>    Move (sPrinter + (Character(0))) to sPrinter
93128>>>>>>>    Move (SetDefaultPrinterEf(AddressOf(sPrinter))) to bReturn
93129>>>>>>>    Function_Return bReturn
93130>>>>>>>End_Function
93131>>>>>Use vWin32fh.pkg
93131>>>>>Use seq_chnl.pkg
93131>>>>>
93131>>>>>// User interface constant strings:
93131>>>>>    Define CS_UserCountError            for "User count error:"
93131>>>>>    Define CS_UnableToInitUserCountSys  for "Unable to initialize user counting system!"
93131>>>>>    Define CS_UnableResetUserCountSys   for "Error resetting usercounting system!"
93131>>>>>    Define CS_ErrorAdvancingPointer     for "Error advancing file pointer!"
93131>>>>>    Define CS_MaxNoOfUserExceeded       for "Maximum number of users exceeded!"
93131>>>>>
93131>>>>>
93131>>>>>
93131>>>>>
93131>>>>>
93131>>>>>
93131>>>>>
93131>>>>>
93131>>>>>
93131>>>>>
93131>>>>>
93131>>>>>
93131>>>>>
93131>>>>>    Struct tUserCount
93131>>>>>        Integer iUserCount
93131>>>>>        Integer iError
93131>>>>>        String  sErrorTxt
93131>>>>>    End_Struct
93131>>>>>
93131>>>>>    Define CI_UserCountMaxUsers for 9999
93131>>>>>
93131>>>>>Class cDbUpdateUserCount is a cObject
93132>>>>>    Procedure Construct_Object
93134>>>>>        Forward Send Construct_Object
93136>>>>>
93136>>>>>        Property String  psLockFileName
93137>>>>>        Property Integer piMaxUsers
93138>>>>>        Property Boolean pbCheckDataFlexUserCount True
93139>>>>>
93139>>>>>        Property Handle  phUserCountFile
93140>>>>>        Property Integer pdwLockPosition
93141>>>>>    End_Procedure
93142>>>>>
93142>>>>>    Function IsProgramRunning Returns Boolean
93144>>>>>        tUserCount UserCount
93144>>>>>        tUserCount UserCount
93144>>>>>
93144>>>>>        Get CheckUserCount to UserCount
93145>>>>>
93145>>>>>        Function_Return (UserCount.iUserCount > 1)
93146>>>>>    End_Function
93147>>>>>
93147>>>>>    // Returns the full path of the Application (no trailing "\")
93147>>>>>    Function ApplicationPath Returns String
93149>>>>>        String sApplicationFileName sPath
93149>>>>>        Integer iNumChars iRetval
93149>>>>>
93149>>>>>        Move (Repeat(Character(0), 1024))    to sApplicationFileName
93150>>>>>        Move (GetModuleFileName(0, AddressOf(sApplicationFileName), 1024)) to iNumChars
93151>>>>>        Move (CString(sApplicationFileName)) to sApplicationFileName
93152>>>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to iRetval
93153>>>>>        Move (CString(sApplicationFileName)) to sPath
93154>>>>>
93154>>>>>        Function_Return sPath
93155>>>>>    End_Function
93156>>>>>
93156>>>>>    Function OpenUserCountFile String sFileName Returns Handle
93158>>>>>        Handle  hFile
93158>>>>>        Pointer pFileName
93158>>>>>        String sPath sFile
93158>>>>>        Integer iCh
93158>>>>>
93158>>>>>        Move (Addressof(sFileName)) to pFileName
93159>>>>>        Move (Win32_CreateFile(pFileName, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, (FILE_ATTRIBUTE_NORMAL ior FILE_FLAG_WRITE_THROUGH), 0)) to hFile
93160>>>>>
93160>>>>>        // If lock file doesn't exist, create it.
93160>>>>>        If (hFile = INVALID_HANDLE_VALUE) Begin
93162>>>>>            Get ApplicationPath to sPath
93163>>>>>            Get vFolderFormat sPath to sPath
93164>>>>>            Move (sPath + psLockFileName(Self)) to sFile
93165>>>>>            Get Seq_Open_Output_Channel sFile to iCh
93166>>>>>            If (iCh = DF_SEQ_CHANNEL_ERROR) Begin
93168>>>>>                Function_Return 0
93169>>>>>            End
93169>>>>>>
93169>>>>>            Direct_Output channel iCh sFile
93171>>>>>                Write channel iCh ""
93173>>>>>            Send Seq_Close_Channel iCh
93174>>>>>            Move (Win32_CreateFile(pFileName, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, (FILE_ATTRIBUTE_NORMAL ior FILE_FLAG_WRITE_THROUGH), 0)) to hFile
93175>>>>>        End
93175>>>>>>
93175>>>>>
93175>>>>>        Function_Return hFile
93176>>>>>    End_Function
93177>>>>>
93177>>>>>    Function CloseUserCountFile Handle hFile Returns Integer
93179>>>>>        Integer iReturnValue 
93179>>>>>        Boolean bOK
93179>>>>>
93179>>>>>        Move (Win32_CloseHandle(hFile)) to iReturnValue
93180>>>>>        If (iReturnValue = 0) Begin
93182>>>>>            Move False to bOK
93183>>>>>        End
93183>>>>>>
93183>>>>>        Else Begin
93184>>>>>            Move True to bOK
93185>>>>>        End
93185>>>>>>
93185>>>>>        Function_Return bOK
93186>>>>>    End_Function
93187>>>>>
93187>>>>>    Function UnlockUserCountFile Handle hFile dWord dwLockPos Returns Integer
93189>>>>>        Integer iReturnValue
93189>>>>>        Boolean bOK
93189>>>>>
93189>>>>>        Move (Win32_UnLockFile(hFile, dwLockPos, 0, 1, 0)) to iReturnValue
93190>>>>>        If (iReturnValue = 0) Begin
93192>>>>>            Move False to bOK
93193>>>>>        End
93193>>>>>>
93193>>>>>        Else Begin
93194>>>>>            Move True to bOK
93195>>>>>        End           
93195>>>>>>
93195>>>>>        Function_Return bOK
93196>>>>>    End_Function
93197>>>>>
93197>>>>>    Function ReSetUserCountPointer Handle hFile Returns dWord
93199>>>>>        dWord dwCurrPos
93199>>>>>
93199>>>>>        Move (Win32_SetFilePointer(hFile, 0, 0, FILE_BEGIN)) to dwCurrPos
93200>>>>>        Function_Return dwCurrPos
93201>>>>>    End_Function
93202>>>>>
93202>>>>>    Function SetUserCountPointer Handle hFile Integer iAdvance Returns dWord
93204>>>>>        DWord dwCurrPos
93204>>>>>
93204>>>>>        Move (Win32_SetFilePointer(hFile, iAdvance, 0, FILE_CURRENT)) to dwCurrPos
93205>>>>>        Function_Return dwCurrPos
93206>>>>>    End_Function
93207>>>>>
93207>>>>>    Function ReadUserCountFile Handle hFile Returns Boolean
93209>>>>>        Integer iReturnValue                               
93209>>>>>        Boolean bOK
93209>>>>>        String  sBuffer
93209>>>>>        Pointer pBuffer
93209>>>>>        String  sSize
93209>>>>>        Pointer pSize
93209>>>>>
93209>>>>>        Move (Repeat((Character(0)),5)) to sBuffer
93210>>>>>        Move (AddressOf(sBuffer)) to pBuffer
93211>>>>>
93211>>>>>        Move (Repeat((Character(0)),4)) to sSize
93212>>>>>        Move (AddressOf(sSize)) to pSize
93213>>>>>
93213>>>>>        Move (Win32_ReadFile(hFile, pBuffer, 1, pSize, 0)) to iReturnValue
93214>>>>>        If (iReturnValue = 0) Begin
93216>>>>>            Move False to bOK
93217>>>>>        End
93217>>>>>>
93217>>>>>        Else Begin
93218>>>>>            Move True to bOK
93219>>>>>        End                 
93219>>>>>>
93219>>>>>        Function_Return bOK
93220>>>>>    End_Function
93221>>>>>
93221>>>>>    Function LockUserCountFile Handle hFile dWord dwFilePos Returns Integer
93223>>>>>        Integer iReturnValue
93223>>>>>
93223>>>>>        Move (Win32_LockFile(hFile, dwFilePos, 0, 1, 0)) to iReturnValue
93224>>>>>        Function_Return iReturnValue
93225>>>>>    End_Function
93226>>>>>
93226>>>>>    Procedure DoCheckUserCount
93228>>>>>        tUserCount UserCount
93228>>>>>        tUserCount UserCount
93228>>>>>
93228>>>>>        Get CheckUserCount to UserCount
93229>>>>>        // If all is fine, we're done.
93229>>>>>        If (UserCount.iError = 0) Begin
93231>>>>>            Procedure_Return
93232>>>>>        End
93232>>>>>>
93232>>>>>
93232>>>>>        Send UserError (CS_UserCountError * String(UserCount.iError) + "\n" + UserCount.sErrorTxt)
93233>>>>>
93233>>>>>        If (UserCount.iUserCount = CI_UserCountMaxUsers) Begin
93235>>>>>            Abort
93236>>>>>>
93236>>>>>        End
93236>>>>>>
93236>>>>>    End_Procedure
93237>>>>>
93237>>>>>    Function CheckUserCount Returns tUserCount
93239>>>>>        Handle  hFile
93239>>>>>        String  sPath sFile
93239>>>>>        Integer iResult
93239>>>>>        DWord   dwFilePos
93239>>>>>        Integer bLocked
93239>>>>>        Integer iMaxUsers
93239>>>>>        Integer iCurUser
93239>>>>>        tUserCount UserCount
93239>>>>>        tUserCount UserCount
93239>>>>>
93239>>>>>        Move 0 to UserCount.iError
93240>>>>>
93240>>>>>        Get phUserCountFile to hFile
93241>>>>>        If (not(hFile)) Begin
93243>>>>>            Get ApplicationPath to sPath
93244>>>>>            Get vFolderFormat sPath to sPath
93245>>>>>            Move (sPath + psLockFileName(Self)) to sFile
93246>>>>>            Get OpenUserCountFile sFile to hFile
93247>>>>>            If (hFile = INVALID_HANDLE_VALUE) Begin
93249>>>>>                Move 1 to UserCount.iUserCount
93250>>>>>                Move 1 to UserCount.iError
93251>>>>>                Move CS_UnableToInitUserCountSys to UserCount.sErrorTxt
93252>>>>>                Function_Return UserCount
93253>>>>>            End
93253>>>>>>
93253>>>>>            Else Begin
93254>>>>>                Move False to bLocked
93255>>>>>                Set phUserCountFile to hFile
93256>>>>>                Get piMaxUsers to iMaxUsers
93257>>>>>
93257>>>>>                // Set Filepointer to beginning of the file
93257>>>>>                Get ResetUserCountPointer hFile to dwFilePos
93258>>>>>                If (dwFilePos = -1) Begin
93260>>>>>                    Move 1 to UserCount.iUserCount
93261>>>>>                    Move 2 to UserCount.iError
93262>>>>>                    Move CS_UnableResetUserCountSys to UserCount.sErrorTxt
93263>>>>>                    Function_Return UserCount
93264>>>>>                End
93264>>>>>>
93264>>>>>                For iCurUser from 1 to iMaxUsers
93270>>>>>>
93270>>>>>                    Get LockUserCountFile hFile dwFilePos to iResult
93271>>>>>                    If (not(iResult)) Begin  // byte is locked
93273>>>>>                        Get SetUserCountPointer hFile 10 to dwFilePos
93274>>>>>                        If (dwFilePos = -1) Begin
93276>>>>>                            Move 1 to UserCount.iUserCount
93277>>>>>                            Move 3 to UserCount.iError
93278>>>>>                            Move CS_ErrorAdvancingPointer to UserCount.sErrorTxt
93279>>>>>                            Function_Return UserCount
93280>>>>>                        End
93280>>>>>>
93280>>>>>                    End
93280>>>>>>
93280>>>>>                    Else Begin  // byte is not locked
93281>>>>>                        Set pdwLockPosition to dwFilePos
93282>>>>>                        Move True to bLocked
93283>>>>>                        Move iMaxUsers to iCurUser
93284>>>>>                    End
93284>>>>>>
93284>>>>>                Loop
93285>>>>>>
93285>>>>>                If (not(bLocked)) Begin
93287>>>>>                    Move CI_UserCountMaxUsers to UserCount.iUserCount
93288>>>>>                    Move 4 to UserCount.iError
93289>>>>>                    Move CS_MaxNoOfUserExceeded to UserCount.sErrorTxt
93290>>>>>                    Function_Return UserCount
93291>>>>>                End
93291>>>>>>
93291>>>>>            End
93291>>>>>>
93291>>>>>        End
93291>>>>>>
93291>>>>>
93291>>>>>        Function_Return UserCount
93292>>>>>    End_Function
93293>>>>>
93293>>>>>
93293>>>>>    Procedure DoReleaseUserCount
93295>>>>>        Integer iResult
93295>>>>>        Handle  hFile
93295>>>>>        DWord   dwLockPos
93295>>>>>
93295>>>>>        Get phUserCountFile to hFile
93296>>>>>        Get pdwLockPosition to dwLockPos
93297>>>>>        If (hFile) Begin
93299>>>>>            If (dwLockPos) Begin
93301>>>>>                Get UnlockUserCountFile hFile dwLockPos to iResult
93302>>>>>            End
93302>>>>>>
93302>>>>>            Get CloseUserCountFile hFile to iResult
93303>>>>>        End
93303>>>>>>
93303>>>>>    End_Procedure
93304>>>>>
93304>>>>>    Function CurrentNumberOfUsers Returns Integer
93306>>>>>        Handle  hFile
93306>>>>>        Integer iMaxUsers
93306>>>>>        DWord   dwFilePos
93306>>>>>        Integer iCurUser
93306>>>>>        Integer iResult
93306>>>>>        Integer iNumberOfLocks
93306>>>>>        String  sPath sFile
93306>>>>>
93306>>>>>        Move 0 to iNumberOfLocks
93307>>>>>
93307>>>>>        Get ApplicationPath to sPath
93308>>>>>        Get vFolderFormat sPath to sPath
93309>>>>>        Move (sPath + psLockFileName(Self)) to sFile
93310>>>>>        Get OpenUserCountFile sFile to hFile
93311>>>>>        If (hFile = INVALID_HANDLE_VALUE) Begin
93313>>>>>            Send UserError CS_UnableToInitUserCountSys
93314>>>>>            Abort
93315>>>>>>
93315>>>>>        End
93315>>>>>>
93315>>>>>
93315>>>>>        If (hFile > 0) Begin
93317>>>>>            Get piMaxUsers To iMaxUsers
93318>>>>>
93318>>>>>            // Set Filepointer to beginning of the file
93318>>>>>            Get ResetUserCountPointer hFile to dwFilePos
93319>>>>>            If (dwFilePos = -1) Begin
93321>>>>>                Send UserError CS_UnableResetUserCountSys
93322>>>>>                Abort
93323>>>>>>
93323>>>>>            End
93323>>>>>>
93323>>>>>            For iCurUser from 1 to iMaxUsers
93329>>>>>>
93329>>>>>                Get LockUserCountFile hFile dwFilePos to iResult
93330>>>>>                If (Not(iResult)) Begin  // byte is locked
93332>>>>>                    Increment iNumberOfLocks
93333>>>>>                End
93333>>>>>>
93333>>>>>                Else Begin  // byte is not locked
93334>>>>>                    Get UnlockUserCountFile hFile dwFilePos to iResult
93335>>>>>                End
93335>>>>>>
93335>>>>>                Get SetUserCountPointer hFile 10 to dwFilePos
93336>>>>>                If (dwFilePos = -1) Begin
93338>>>>>                    Send UserError CS_ErrorAdvancingPointer
93339>>>>>                    Abort
93340>>>>>>
93340>>>>>                End
93340>>>>>>
93340>>>>>            Loop
93341>>>>>>
93341>>>>>        End
93341>>>>>>
93341>>>>>        Get CloseUserCountFile hFile to iResult
93342>>>>>        Function_Return iNumberOfLocks
93343>>>>>    End_Function
93344>>>>>
93344>>>>>End_Class
93345>>>Use cDbUpdateFunctionLibrary.pkg
93345>>>
93345>>>//{ DataBindable=True }
93345>>>    // Note: We import all functionality of the DatabaseFunctionLibrary into the class:
93345>>>Class cDbUpdateHandler is a cDbUpdateFunctionLibrary // cObject
93346>>>//    Import_Class_Protocol cDbUpdateFunctionLibrary
93346>>>//    Import_Class_Protocol cDbUpdateFunctionLibrary_Mixin
93346>>>
93346>>>    Procedure Construct_Object
93348>>>        tUserCount UserCount
93348>>>        tUserCount UserCount
93348>>>        Integer iUserCount
93348>>>        Handle ho                     
93348>>>
93348>>>        Forward Send Construct_Object
93350>>>        Move Self to ghoDbUpdateHandler  
93351>>>        
93351>>>        // Latin1_General_CI_AS = General Insensitive collation
93351>>>        // Latin1_General_CS_AS = General Case Sensitive collation, AS= Accent Sensitive.   
93351>>>        // For MS-SQL See: https://docs.microsoft.com/en-us/sql/t-sql/statements/windows-collation-name-transact-sql?view=sql-server-2017
93351>>>        // Good read about which collation to select:
93351>>>        // https://social.msdn.microsoft.com/Forums/sqlserver/en-US/bfdc32d3-3d36-4d63-8d87-6ee972fd8130/on-sqllatin1generalcp1cias-sql-server-2008-default-collation?forum=transactsql
93351>>>        Property String psCollation "Latin1_General_CS_AS" //"SQL_Latin1_General_Cp1_CS_AS"
93352>>>
93352>>>        // Struct array that will contain pnVersionNumbers & object id's of
93352>>>        // all child cDbVersion objects.
93352>>>        Property tDbVersionInfo[] paDbVersionInfoArray
93353>>>
93353>>>        Property Integer Error_Processing_State False  // internal usage
93354>>>        
93354>>>        Property Boolean Private.pbDbVersionCheckDone False
93355>>>
93355>>>        Property Boolean pbUseCustomDbVersion False  
93356>>>        
93356>>>        // If this property = True _and_ no DbVersion table exists 
93356>>>        // when the framework is started, a DbVersion table will be created automatically.
93356>>>        Property Boolean pbAutoCreateDbVersionTable True
93357>>>
93357>>>        // Connected to the pbAutoCreateDbVersionTable property. If it is true,
93357>>>        // the Filelist.cfg slot number indicated by this property will be used
93357>>>        // if a DbVersion table is to be created. If this value = -1 at runtime
93357>>>        // an Unhandled Exception Error will be genereted and the program halted. So
93357>>>        // this property _must_ be set in the cDbUpdateHandler object if pbAutoCreateDbVersionTable = True,
93357>>>        // to a value that corresponds to a free Filelist.cfg slot number.
93357>>>        Property Integer Private.piDbVersionFileNumber -1
93358>>>        Property Integer Private.piDbVersionFieldNumber 1
93359>>>
93359>>>        // This is a message of the cDbUpdateFunctionLibrary_Mixin class
93359>>>        // that creates all library properties
93359>>>        Send CreateDbUpdateLibraryProperties
93360>>>
93360>>>        Property tDbUpdateHandlerMasterAlias[] paDbUpdateHandlerMasterAlias
93361>>>
93361>>>        // Error handling:
93361>>>        Property Boolean Private.pbOnCreateExecuted False
93362>>>        Property Boolean Private.pbOnPreUpdateExecuted False
93363>>>        Property Boolean Private.pbProcessingError False
93364>>>        Property Boolean pbDbUpdateErrorHasOccured False
93365>>>        // Don't touch. It is being used by the cDbUpdateVersion
93365>>>        // subclass to tell if that particular update went OK or not.
93365>>>        Property Boolean Private.pbUpdateVersionObjectError False
93366>>>        Property String[] paSQLQueryMessages
93367>>>
93367>>>        Property Integer piOrgErrorHandlerID Error_Object_Id
93368>>>        Move Self to Error_Object_Id
93369>>>        // Error handling:
93369>>>        // Temporarily redirect all errors to this object so we can silently
93369>>>        // log all errors that might appear while updating the database.
93369>>>        // We temporarily redirect all errors to this object so we can
93369>>>        // log and write errors to the log file. It will be reset after
93369>>>        // the database updates have been finished.
93369>>>        Property Integer piCurrentErrorHandlerID Error_Object_Id
93370>>>
93370>>>        Property Handle phoLogFile (Create(Self,RefClass(cDbUpdateLogFile)))
93371>>>
93371>>>        // Error Reporting Related
93371>>>        // If DUF_ERROR_NO_REPORT errors are supressed (only ERR gets set)
93371>>>        Property Integer Error_Report_Mode DUF_ERROR_REPORT
93372>>>
93372>>>        // If the pbContinueOnError = False, an update
93372>>>        // of another cDbUpdateVersion object will _not_ be
93372>>>        // performed if an error occured in a previous
93372>>>        // cDbUpdateVersion object.
93372>>>        Property Boolean pbContinueOnError False
93373>>>        // Stops execution in other cDbUpdateVersion objecs,
93373>>>        // if errors occurred in one cDbUpdateVersion object.
93373>>>        Property Boolean pbStopOnFirstError False
93374>>>        // If True errors that occured while updating the database
93374>>>        // will be shown in the default app for .txt files when done.
93374>>>        // Note: The log file will _always_ be created in the Data folder.
93374>>>        Property Boolean pbShowErrorLogPostRun True
93375>>>
93375>>>        // Be _very_ careful to set this property to true!
93375>>>        // If = True, no question will be asked if the update
93375>>>        // should begin. Also, even if the pbShowErrorLogPostRun=True,
93375>>>        // the error log won't be shown. The logfile itself will still be created though.
93375>>>        // You have to know what you're doing!
93375>>>        Property Boolean pbSilentMode False
93376>>>        
93376>>>        Property Boolean pbEnableCancelButton False
93377>>>
93377>>>        // Don't touch! Very private. The value is used by the error log to write for which
93377>>>        // cDbUpdateVersion object an error occured.
93377>>>        Property Number pnCurrentVersionUpdate 0
93378>>>
93378>>>        // The user counting logic is used to safe-guard agains anybody else is
93378>>>        // using the application when a database update is to be performed.
93378>>>        // (Garters & suspenders!)
93378>>>        Property Handle phoUserCountSystem (Create(Self,RefClass(cDbUpdateUserCount)))
93379>>>        Set psLockFileName of (phoUserCountSystem(Self)) to "DbUpdateUserCount.ucf"
93380>>>        Set piMaxUsers     of (phoUserCountSystem(Self)) to (CI_UserCountMaxUsers -1) // Large number!
93381>>>
93381>>>        // This lock file is used to guard against somebody else tries to start the
93381>>>        // application while updates are in progress.
93381>>>        Property Handle phoDatabaseUpdateLock (Create(Self,RefClass(cDbUpdateUserCount)))
93382>>>        Set psLockFileName of (phoDatabaseUpdateLock(Self)) to "DbUpdateLock.ucf"
93383>>>        Set piMaxUsers     of (phoDatabaseUpdateLock(Self)) to 1
93384>>>                                                                                      // Only the current user allowed.
93384>>>        // Properties for the table & column of a system file field/column where
93384>>>        // the database version update number gets saved.
93384>>>        Property Integer Private.Data_File  0
93385>>>        Property Integer Private.Data_Field 0
93386>>>
93386>>>        // Property that is used to indicate that we have already
93386>>>        // started the database update.
93386>>>        Property Boolean Private.pbDatabaseUpdateStarted False
93387>>>
93387>>>        // Don't touch! It is used by the child class cDbUpdateVersion logic to indicate that
93387>>>        // at least one OnUpdate child event has been triggered. Thus at least one active
93387>>>        // change of the database has been made.
93387>>>        Property Boolean Private.pbDatabaseWasUpdated False
93388>>>
93388>>>        // We need to trigger the user counting system so that a bit in the
93388>>>        // user counting file is locked. This is to guard that not more than one user
93388>>>        // is currently runnning the program.
93388>>>        Get CheckUserCount of (phoUserCountSystem(Self)) to UserCount
93389>>>
93389>>>        Get CurrentNumberOfUsers of (phoDatabaseUpdateLock(Self)) to iUserCount
93390>>>        If (iUserCount > 0) Begin
93392>>>            Send Stop_Box CS_DUF_UpdateInProgressTxt
93393>>>            Send Exit_Application
93394>>>        End
93394>>>>
93394>>>
93394>>>        Set pbHandleQueryErrors to False
93395>>>            
93395>>>        Property Handle phoSQLConnectionHandler 0
93396>>>        // If no ghoSQLConnectionHandler object has been created prior to this object,
93396>>>        // we will create one as it is used for all ConnectionID, ConnectionString
93396>>>        // etc information.
93396>>>        If (ghoSQLConnectionHandler = 0) Begin
93398>>>            Get Create (RefClass(cSQLConnectionHandler)) to ho
93399>>>            Set phoSQLConnectionHandler to ho
93400>>>        End             
93400>>>>
93400>>>        
93400>>>        Property Boolean pbCheckIntFiles False   
93401>>>        Property Handle  phIntFilesTable 2048
93402>>>        Property Boolean Private.pbIntFilesTablesCheckDone False
93403>>>        
93403>>>        Set Icon to "Default.ico"
93404>>>    End_Procedure
93405>>>
93405>>>    Procedure End_Construct_Object
93407>>>        Boolean bCheckIntFiles
93407>>>        
93407>>>        Forward Send End_Construct_Object
93409>>>        If (Private.pbOnCreateExecuted(Self) = False) Begin  
93411>>>            Send OnCreate
93412>>>            Set Private.pbOnCreateExecuted to True
93413>>>        End
93413>>>>
93413>>>        Send Cleanup
93414>>>    End_Procedure
93415>>>    
93415>>>    // Programmers hook event.
93415>>>    Procedure OnCreate
93417>>>    End_Procedure        
93418>>>                                 
93418>>>    // *** MAIN .Int file (and Filelist.cfg) Integrity Check Message ***
93418>>>    //                                                
93418>>>    // The logic is activated by setting the property "pbCheckIntFiles = True" in the
93418>>>    // cDbUpdateHandler object.
93418>>>    //
93418>>>    // Checks that all .int files are intact, or else writes new copies to disk. 
93418>>>    // Also checks that there is a Filelist.cfg, and if missing writes a new copy to disk.
93418>>>    //
93418>>>    // If not done previously the phIntFilesTable will be created and filled with data
93418>>>    // from the current set of .int files - iif (if-and-only-if) this is a development
93418>>>    // machine. Which is decided by checking if the DdSrc folder exists. And a copy
93418>>>    // of Filelist.cfg is made for backup purposes.
93418>>>    //
93418>>>    // Note: If an error occurrs the application will exit, as it means that at least one
93418>>>    // .int file is in error or the Filelist.cfg was missing and couldn't be recreated.
93418>>>    Procedure CheckIntFilesIntegrity
93420>>>        Boolean bCheckIntFiles bExists bOK bSaved bIsSQL bFileListExist bResult bDevelop bZipExists bIntFilesTablesCheckDone
93420>>>        String sPaths sDataPath sIntFileName sRootFileNname sFileListName sDDSrcPath sCurrentFolder
93420>>>        String sFileListZipFile sParam sProgram sFile 
93420>>>        Integer iDataPaths iCount
93420>>>        Handle hTable hIntFilesTable                    
93420>>>        UChar[] asFileListArray 
93421>>>        String[] asSavedIntFile
93422>>>        tDUFIntFile[] DUFIntFiles
93422>>>        tDUFIntFile[] DUFIntFiles
93423>>>        
93423>>>        Get pbCheckIntFiles to bCheckIntFiles
93424>>>        If (bCheckIntFiles = False) Begin
93426>>>            Procedure_Return
93427>>>        End
93427>>>>
93427>>>        
93427>>>        Move True to bResult        
93428>>>        
93428>>>        // Note: Include_Resource is a compiler directive!
93428>>>        // It will embedd the Filelist.cfg from the developers machine
93428>>>        // into the executable. Thus the file _must_ be named "Filelist.cfg", or you
93428>>>        // need to change the next code line.         
93428>>>        //
93428>>>        // There is a pickle with the Filelist.cfg as it is "busy" as it is open in the Studio,
93428>>>        // when we get here and then the compiler can't embedd it!        
93428>>>        // ToDo: Change compiler directives in Project properties (?)
93428>>>//        Include_Resource Filelist2.cfg as res_EmbeddedFilelistCfg type DF_RESOURCE_TYPE_BINARY
93428>>>//        Get ReadFileListResource "res_EmbeddedFilelistCfg" to asFileListArray
93428>>>        
93428>>>        Get psFileList of (phoWorkspace(ghoApplication)) to sFileListName
93429>>>        Get vFilePathExists sFileListName to bExists 
93430>>>        If (bExists = True) Begin
93432>>>            Get ParseFolderName sFileListName to sDataPath    
93433>>>            Get vFolderFormat sDataPath to sDataPath                              
93434>>>            Get ParseFileName sFileListName to sFile
93435>>>            // We need to create a backup copy of Filelist.cfg.
93435>>>            Get vCopyFile sFileListName (sDataPath + CS_FilelistBackupFile) to bOK
93436>>>            Get vFilePathExists (sDataPath + CS_FilelistBackupFile) to bOK
93437>>>            If (bOK = False) Begin
93439>>>                Move False to bResult
93440>>>                Error DFERR_PROGRAM ("Could not create a copy of Filelist.cfg for backup purposed! ***Please investigte the reason why this happened ***")
93441>>>>
93441>>>            End
93441>>>>
93441>>>        End
93441>>>>
93441>>>        // If the Filelist.cfg is missing - create it from a previous backup copy.
93441>>>        Else Begin
93442>>>            Get vCopyFile (sDataPath + CS_FilelistBackupFile) sFileListName to bOK
93443>>>//            Get WriteFileListResource asFileListArray sFileListName to bOK  
93443>>>            If (bOK = False) Begin   
93445>>>                Move False to bResult
93446>>>                Error DFERR_PROGRAM ("Filelist.cfg file is missing and couldn't be created!" * String(sFileListName))
93447>>>>
93447>>>            End
93447>>>>
93447>>>        End
93447>>>>
93447>>>        
93447>>>        Get phIntFilesTable to hIntFilesTable
93448>>>        Get_Attribute DF_FILE_ROOT_NAME of hIntFilesTable to sRootFileNname
93451>>>        Get _TableNoPrefix sRootFileNname to sRootFileNname
93452>>>        // This will automatically create the phIntFilesTable if not exists.
93452>>>        // It is used to save data from the current set of .int files.
93452>>>        If (sRootFileNname <> CS_IntFilesTableRootName) Begin
93454>>>            Send AutoCreateIntFilesTable
93455>>>            Get Private.pbIntFilesTablesCheckDone to bIntFilesTablesCheckDone
93456>>>            If (bIntFilesTablesCheckDone = False) Begin
93458>>>                Send Info_Box CS_DUF_DbUpdatedErrorText
93459>>>                Send Exit_Application of ghoApplication
93460>>>            End
93460>>>>
93460>>>        End                                                       
93460>>>>
93460>>>        
93460>>>        // Check if this is a development machine. *Only* then we will attempt to read .int files to the internal table. 
93460>>>        // ToDo: Or should this always be attempted? Else the 
93460>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
93461>>>        Move (IsDebuggerPresent()) to bDevelop
93462>>>        If (bDevelop = False) Begin
93464>>>            Get vFolderExists sDDSrcPath to bDevelop
93465>>>        End
93465>>>>
93465>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sPaths
93466>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sPaths to iDataPaths
93467>>>        For iCount from 1 to iDataPaths
93473>>>>
93473>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sPaths iCount to sDataPath   
93474>>>            Get vFolderFormat sDataPath to sDataPath 
93475>>>            Get vFolderExists sDataPath to bExists
93476>>>            If (bExists = True) Begin                  
93478>>>                Move 0 to hTable
93479>>>                Repeat
93479>>>>
93479>>>                    Get_Attribute DF_FILE_NEXT_USED of hTable to hTable    
93482>>>                    If (hTable <> 0) Begin
93484>>>                        Get_Attribute DF_FILE_ROOT_NAME of hTable to sIntFileName 
93487>>>                        Get _UtilTableIsSqlByRootName sIntFileName to bIsSQL
93488>>>                        If (bIsSQL = True) Begin     
93490>>>                            Get _TableNameOnly sIntFileName to sIntFileName
93491>>>                            Move (sIntFileName + ".int")    to sIntFileName
93492>>>                            Get IsIntFileSaved sIntFileName to bSaved  
93493>>>                            Move True to bOK            
93494>>>                            
93494>>>                            // Save .int file to database if not done previously.
93494>>>                            // We only attempt to read .int files on a development machine.
93494>>>                            If (bDevelop = True) Begin
93496>>>                                If (bSaved = False) Begin
93498>>>                                    Get SaveIntFileData sDataPath sIntFileName to bOK
93499>>>                                    If (bOK = False) Begin
93501>>>                                        Move False to bResult    
93502>>>                                    End
93502>>>>
93502>>>                                End         
93502>>>>
93502>>>                                If (bOK = True) Begin
93504>>>                                    Get HasIntFileChanged sDataPath sIntFileName to asSavedIntFile
93505>>>                                    If (SizeOfArray(asSavedIntFile)) Begin
93507>>>                                        Get UpdateIntFileData sDataPath sIntFileName asSavedIntFile to bOK
93508>>>                                        If (bOK = False) Begin
93510>>>                                            Move False to bResult
93511>>>                                            Error DFERR_PROGRAM ("Could not update .int file data to the internal database table:" * String(sIntFileName))
93512>>>>
93512>>>                                        End
93512>>>>
93512>>>                                    End
93512>>>>
93512>>>                                End
93512>>>>
93512>>>                            End
93512>>>>
93512>>>                            
93512>>>                            Get vFilePathExists (sDataPath + sIntFileName) to bExists
93513>>>                            If (bExists = False) Begin                           
93515>>>                                // If the .int file is missing on disk; create it from database.
93515>>>                                Get CreateIntFileFromSavedData hIntFilesTable sIntFileName sDataPath to bOK
93516>>>                                If (bOK = False) Begin         
93518>>>                                    Move False to bResult
93519>>>                                    Error DFERR_PROGRAM ("Could not create .int file:" * String(sIntFileName))
93520>>>>
93520>>>                                End
93520>>>>
93520>>>                            End
93520>>>>
93520>>>                        End
93520>>>>
93520>>>                    End
93520>>>>
93520>>>                Until (hTable = 0)
93522>>>            End
93522>>>>
93522>>>        Loop       
93523>>>>
93523>>>        
93523>>>        // If an error occured we need to exit the application.
93523>>>        If (bResult = False) Begin  
93525>>>            Send Info_Box CS_DUF_DbUpdatedErrorText 
93526>>>            Send Exit_Application
93527>>>        End
93527>>>>
93527>>>        
93527>>>    End_Procedure               
93528>>>
93528>>>    // To update currently saved IntFile data to the database.
93528>>>    // Because it is much easier, we first delete all current records and
93528>>>    // then saves the changed .int file to the database.
93528>>>    Function UpdateIntFileData String sDataPath String sIntFileName String[] asSavedIntFile Returns Boolean
93530>>>        Boolean bOK
93530>>>        
93530>>>        Move False to bOK
93531>>>
93531>>>        Get DeleteIntFileData sDataPath sIntFileName to bOK
93532>>>        If (bOK = True) Begin
93534>>>            Get SaveIntFileData sDataPath sIntFileName to bOK
93535>>>        End
93535>>>>
93535>>>        
93535>>>        Function_Return bOK
93536>>>    End_Function
93537>>>    
93537>>>    Function IsIntFileSaved String sIntFileName Returns Boolean
93539>>>        Handle hTable
93539>>>        Boolean bOK
93539>>>        Integer iColumn iIndex   
93539>>>        String sFileName
93539>>>        
93539>>>        Move False to bOK
93540>>>        Get phIntFilesTable to hTable
93541>>>        Move 2              to iColumn // This is the "InfFileName" field no.
93542>>>        Move 2              to iIndex  // This is the IntFileName + ID index.
93543>>>
93543>>>        Open hTable
93545>>>        Set_Field_Value hTable iColumn to sIntFileName
93548>>>        Vfind hTable iIndex GE
93550>>>        Get_Field_Value hTable iColumn to sFileName
93553>>>        If (Trim(sIntFileName) = Trim(sFileName)) Begin
93555>>>            Move True to bOK    
93556>>>        End
93556>>>>
93556>>>        Close hTable
93557>>>        
93557>>>        Function_Return bOK       
93558>>>    End_Function   
93559>>>    
93559>>>    // Checks that the passed .int file is the same as what is saved in the database.
93559>>>    // If not same, the return string array will contain the read .int file,
93559>>>    // else the returned array will be empty.
93559>>>    Function HasIntFileChanged String sDataPath String sIntFileName Returns String[]
93561>>>        String[] asIntFileOrg asIntFile asSavedIntFile asReturnIntFile
93565>>>        Boolean bIsSame
93565>>>        
93565>>>        Get ReadIntFileData    sDataPath sIntFileName to asIntFileOrg   
93566>>>        Get CurrentIntFileData sDataPath sIntFileName to asSavedIntFile
93567>>>        Get RemoveBlankLines asIntFileOrg   to asIntFile
93568>>>        Get RemoveBlankLines asSavedIntFile to asSavedIntFile
93569>>>        
93569>>>        Move (IsSameArray(asIntFile, asSavedIntFile)) to bIsSame
93570>>>        If (bIsSame = False) Begin
93572>>>            Move asIntFileOrg to asReturnIntFile    
93573>>>        End
93573>>>>
93573>>>        
93573>>>        Function_Return asReturnIntFile    
93574>>>    End_Function                                   
93575>>>    
93575>>>    // Takes a string array as parameter and returns a new
93575>>>    // string array without any empty rows and all rows trimmed.
93575>>>    // This is e.g. used by the HasIntFileChanged message to compare
93575>>>    // two .int file arrays. 
93575>>>    Function RemoveBlankLines String[] asIntFile Returns String[]
93577>>>        Integer iSize iCount iRow
93577>>>        String sVal        
93577>>>        String[] asRetValArray
93578>>>        
93578>>>        Move (SizeOfArray(asIntFile)) to iSize
93579>>>        If (iSize = 0) Begin
93581>>>            Function_Return asRetValArray
93582>>>        End                          
93582>>>>
93582>>>        Decrement iSize         
93583>>>        Move 0 to iRow
93584>>>        
93584>>>        For iCount from 0  to iSize
93590>>>>
93590>>>            Move asIntFile[iCount] to sVal
93591>>>            Move (Trim(sVal)) to sVal
93592>>>            If (sVal <> "") Begin
93594>>>                Move sVal to asRetValArray[iRow]
93595>>>                Increment iRow        
93596>>>            End
93596>>>>
93596>>>        Loop
93597>>>>
93597>>>        
93597>>>        Function_Return asRetValArray
93598>>>    End_Function
93599>>>    
93599>>>    Function SaveIntFileData String sPath String sIntFileName Returns Boolean
93601>>>        Handle hTable
93601>>>        Boolean bOK bErr
93601>>>        Integer iIDCol iFileCol iTextCol iIndex iIDIdx iSize iCount 
93601>>>        Number iID
93601>>>        String sFileName
93601>>>        String[] asIntFile
93602>>>        
93602>>>        Move Err to bErr
93603>>>        Move False to Err
93604>>>        Move False to bOK
93605>>>        Get phIntFilesTable to hTable  
93606>>>        Move 1              to iIDCol
93607>>>        Move 2              to iFileCol
93608>>>        Move 3              to iTextCol // This is the "InfFileName" field no.
93609>>>        Move 1              to iIDIdx   // Main ID index.
93610>>>        Move 2              to iIndex   // This is the IntFileName + ID index.
93611>>>
93611>>>        Get ReadIntFileData sPath sIntFileName to asIntFile
93612>>>        Move (SizeOfArray(asIntFile)) to iSize
93613>>>        If (iSize = 0) Begin
93615>>>            Function_Return False
93616>>>        End
93616>>>>
93616>>>        Decrement iSize
93617>>>        Open hTable  
93619>>>                  
93619>>>        // Find the last used ID no:
93619>>>        Fill_Field hTable iIDCol with DF_HIGH
93621>>>        Vfind hTable iIDIdx LE
93623>>>        Get_Field_Value hTable iIDCol to iID 
93626>>>        // This only happens the very first time we save a record.
93626>>>        If (iID = 999999999999) Begin
93628>>>            Move 0 to iID
93629>>>        End
93629>>>>
93629>>>        Increment iID        
93630>>>        
93630>>>        Lock
93631>>>>
93631>>>            For iCount from 0 to iSize
93637>>>>
93637>>>                Clear hTable
93638>>>                Set_Field_Value hTable iIDCol   to iID     
93641>>>                Set_Field_Value hTable iFileCol to sIntFileName
93644>>>                Set_Field_Value hTable iTextCol to asIntFile[iCount]
93647>>>                SaveRecord hTable
93648>>>                Increment iID
93649>>>            Loop
93650>>>>
93650>>>        Unlock
93651>>>>
93651>>>        Close hTable
93652>>>        
93652>>>        Move (not(Err)) to bOK
93653>>>        Move bErr to Err
93654>>>        
93654>>>        Function_Return bOK
93655>>>    End_Function
93656>>>    
93656>>>    // Deletes all records for the passed sIntFileName value,
93656>>>    // from the phIntFilesTable.
93656>>>    // Returns True if no errors occured.
93656>>>    Function DeleteIntFileData String sPath String sIntFileName Returns Boolean
93658>>>        Handle hTable
93658>>>        Boolean bOK bErr bFound
93658>>>        Integer iFileCol iIndex
93658>>>        String sVal
93658>>>        String[] asIntFile
93659>>>        
93659>>>        Move Err to bErr
93660>>>        Move False to Err
93661>>>        Move False to bOK
93662>>>        Move 2              to iFileCol
93663>>>        Move 2              to iIndex  // This is the IntFileName + ID index.
93664>>>        Get phIntFilesTable to hTable  
93665>>>        Open hTable  
93667>>>                  
93667>>>        // Find the first record
93667>>>        Set_Field_Value hTable iFileCol to sIntFileName
93670>>>        Vfind hTable iIndex GE
93672>>>        Get_Field_Value hTable iFileCol to sVal
93675>>>        Move (Found and Trim(sVal) = Trim(sIntFileName)) to bFound
93676>>>        While (bFound = True)
93680>>>            Delete hTable
93681>>>            Vfind hTable iIndex GT
93683>>>            Get_Field_Value hTable iFileCol to sVal
93686>>>            Move (Found and Trim(sVal) = Trim(sIntFileName)) to bFound
93687>>>        Loop
93688>>>>
93688>>>        Unlock
93689>>>>
93689>>>        Close hTable
93690>>>        
93690>>>        Move (not(Err)) to bOK
93691>>>        Move bErr to Err
93692>>>        
93692>>>        Function_Return bOK
93693>>>    End_Function
93694>>>
93694>>>    // Returns all saved phIntFilesTable records for the passed 
93694>>>    // sIntFileName value as a string array.
93694>>>    Function CurrentIntFileData String sPath String sIntFileName Returns String[]
93696>>>        Handle hTable
93696>>>        Boolean bOK bErr bFound
93696>>>        Integer iFileCol iTextCol iIndex
93696>>>        String sVal sFileName
93696>>>        String[] asIntFile asEmptyArray
93698>>>        
93698>>>        Move Err to bErr
93699>>>        Move False to Err
93700>>>        Move False to bOK
93701>>>        Move 2              to iFileCol
93702>>>        Move 3              to iTextCol // This is the "InfFileName" field no.
93703>>>        Move 2              to iIndex  // This is the IntFileName + ID index.
93704>>>        Get phIntFilesTable to hTable  
93705>>>        Open hTable  
93707>>>
93707>>>        // Find the first record
93707>>>        Set_Field_Value hTable iFileCol to sIntFileName
93710>>>        Vfind hTable iIndex GE
93712>>>        Get_Field_Value hTable iFileCol to sFileName
93715>>>        Move (Found and Trim(sFileName) = Trim(sIntFileName)) to bFound
93716>>>        While (bFound = True)
93720>>>            Get_Field_Value hTable iFileCol to sFileName
93723>>>            Move (Found and Trim(sFileName) = Trim(sIntFileName)) to bFound
93724>>>            If (bFound = True) Begin
93726>>>                Get_Field_Value hTable iTextCol to sVal
93729>>>                Move (Trim(sVal)) to asIntFile[SizeOfArray(asIntFile)]
93730>>>            End
93730>>>>
93730>>>            Vfind hTable iIndex GT
93732>>>        Loop
93733>>>>
93733>>>        
93733>>>        Close hTable
93734>>>        Move (not(Err)) to bOK
93735>>>        If (bOK = False) Begin
93737>>>            Move asEmptyArray to asIntFile
93738>>>        End
93738>>>>
93738>>>        Move bErr to Err               
93739>>>        
93739>>>        Function_Return asIntFile
93740>>>    End_Function
93741>>>
93741>>>    // Reads the passed sIntFileName from disk and returns its value
93741>>>    // as a string array.
93741>>>    Function ReadIntFileData String sPath String sIntFileName Returns String[]
93743>>>        String[] asIntFile       
93744>>>        String sFileName sLine
93744>>>        Integer iCh iSize iCount
93744>>>        
93744>>>        Get vFolderFormat sPath to sPath
93745>>>        If (not(sIntFileName contains ".")) Begin
93747>>>            Move (sIntFileName + ".int") to sIntFileName
93748>>>        End
93748>>>>
93748>>>        Move (sPath + sIntFileName) to sFileName
93749>>>        Get Seq_Open_input_Channel sFileName to iCh
93750>>>        If (iCh < 0) Begin
93752>>>            Function_Return asIntFile
93753>>>        End                                 
93753>>>>
93753>>>        
93753>>>        Repeat
93753>>>>
93753>>>            Readln channel iCh sLine
93755>>>            If (SeqEof = False) Begin
93757>>>                Move sLine to asIntFile[SizeOfArray(asIntFile)]
93758>>>            End
93758>>>>
93758>>>        Until (SeqEof = True)
93760>>>        Send Seq_Close_Channel iCh    
93761>>>        
93761>>>        Function_Return asIntFile
93762>>>    End_Function
93763>>>    
93763>>>    // Reads the Filelist.cfg from memeory as a resource.
93763>>>    // The Filelist.cfg has been compiled into the program.
93763>>>    Function ReadFileListResource String sMemFileName Returns UChar[]
93765>>>        Integer iCh iCount
93765>>>        Number nByteCount
93765>>>        String[] asFileListArray sEmptyArray
93767>>>        String sLine
93767>>>        UChar[] uCharData
93768>>>        
93768>>>        Move False to Err
93769>>>        Get Seq_New_Channel to iCh
93770>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
93772>>>            Error DFERR_PROGRAM 'No channel available...'
93773>>>>
93773>>>            Function_Return sEmptyArray
93774>>>        End
93774>>>>
93774>>>
93774>>>        // First decide the size of the script
93774>>>        Direct_Input channel iCh ("Resource: " + sMemFileName)
93776>>>        Read_Block channel iCh uCharData -1 // -1 means that all data should be read.
93778>>>        Close_Input channel iCh
93780>>>        Send Seq_Release_Channel iCh
93781>>>
93781>>>        Function_Return uCharData
93782>>>    End_Function    
93783>>>    
93783>>>    // Writes a copy of the workspace Filelist.cfg to disk.
93783>>>    // It does so by reading from a memory resource, as the file has
93783>>>    // been compiled into the program.
93783>>>    Function WriteFileListResource UChar[] asFileListArray String sFileListName Returns Boolean
93785>>>        Boolean bOK bErr
93785>>>        Integer iSize iCh
93785>>>        
93785>>>        Move Err to bErr
93786>>>        Move False to Err
93787>>>        Move False to bOK
93788>>>        Move (SizeOfArray(asFileListArray)) to iSize
93789>>>        If (iSize = 0) Begin
93791>>>            Function_Return False
93792>>>        End
93792>>>>
93792>>>
93792>>>        Get Seq_New_Channel to iCh
93793>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
93795>>>            Error DFERR_PROGRAM 'No channel available...'
93796>>>>
93796>>>            Function_Return False
93797>>>        End                      
93797>>>>
93797>>>        
93797>>>        Direct_Output channel iCh sFileListName
93799>>>        Writeln channel iCh asFileListArray
93802>>>                
93802>>>        Close_Input channel iCh
93804>>>        Send Seq_Release_Channel iCh
93805>>>        Move (not(Err)) to bOK
93806>>>        Move bErr to Err
93807>>>        
93807>>>        Function_Return bOK
93808>>>    End_Function
93809>>>
93809>>>    // Writes an .int for the passed sIntFileName file to disk by reading data from the phIntFilesTable data table.
93809>>>    // It first deletes the .cch file (if any).
93809>>>    Function CreateIntFileFromSavedData Handle hTable String sIntFileName String sDataPath Returns Boolean
93811>>>        Boolean bOK bFound bExists bErr
93811>>>        Integer iCh iSize iCount
93811>>>        String sFileName sCCHFileName sVal
93811>>>        String[] asIntFile
93812>>>        
93812>>>        Move Err to bErr   
93813>>>        Move False to Err
93814>>>        Move False to bOK
93815>>>
93815>>>        Get CurrentIntFileData sDataPath sIntFileName to asIntFile
93816>>>        Move (SizeOfArray(asIntFile)) to iSize
93817>>>        If (iSize = 0) Begin
93819>>>            Function_Return False        
93820>>>        End                      
93820>>>>
93820>>>        Decrement iSize
93821>>>        
93821>>>        Get Seq_New_Channel to iCh
93822>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
93824>>>            Function_Return False
93825>>>        End   
93825>>>>
93825>>>        
93825>>>        // Before we start to actually create the new .int file, make sure we delete
93825>>>        // the .cch file first.                                     
93825>>>        Move (Uppercase(sIntFileName)) to sCCHFileName
93826>>>        Move (Replace(".INT", sCCHFileName, ".CCH")) to sCCHFileName
93827>>>        Get vFilePathExists (sDataPath + sCCHFileName) to bExists
93828>>>        If (bExists = True) Begin
93830>>>            Get vDeleteFile (sDataPath + sCCHFileName) to bOK
93831>>>            If (bOK = False) Begin
93833>>>                Function_Return False
93834>>>            End
93834>>>>
93834>>>        End
93834>>>>
93834>>>        
93834>>>        Direct_Output channel iCh (sDataPath + sIntFileName)
93836>>>        For iCount from 0 to iSize
93842>>>>
93842>>>            Writeln channel iCh asIntFile[iCount]
93845>>>        Loop
93846>>>>
93846>>>        
93846>>>        Close_Input channel iCh
93848>>>        Send Seq_Release_Channel iCh
93849>>>        Move (not(Err)) to bOK
93850>>>        Move bErr to Err
93851>>>        
93851>>>        Function_Return bOK
93852>>>    End_Function   
93853>>>              
93853>>>    // Automatically writes .int files to disk that is missing.
93853>>>    // We only need to make this test this once, but because the message is called
93853>>>    // from each child cDbUpdateVersion object (and it needs to be called from there),
93853>>>    // we use property Private.pbIntFilesTablesCheckDone to ensure it is only run once.
93853>>>    Procedure AutoCreateIntFilesTable 
93855>>>        Integer hTable 
93855>>>        Boolean bIntFilesTablesCheckDone bTableExists
93855>>>        String sInfoTxt 
93855>>>        
93855>>>        Get phIntFilesTable to hTable  
93856>>>        Get Private.pbIntFilesTablesCheckDone to bIntFilesTablesCheckDone
93857>>>        If (bIntFilesTablesCheckDone = True) Begin
93859>>>            Procedure_Return
93860>>>        End
93860>>>>
93860>>>
93860>>>        If (hTable < 1) Begin
93862>>>            Set Private.pbIntFilesTablesCheckDone to False
93863>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
93864>>>            Error DFERR_PROGRAM "The phIntFilesTable has been set to 0 (!). The default value is 2048 and if changed MUST be set to a free Filelist.cfg slot in the cDbUpdateHandler object.\nProgram will now exit!"
93865>>>>
93865>>>            Procedure_Return
93866>>>        End
93866>>>>
93866>>>
93866>>>        Get _UtilTableExists of ghoDbUpdateFunctionLibrary hTable to bTableExists
93867>>>        If (bTableExists = True) Begin
93869>>>            Set Private.pbIntFilesTablesCheckDone to True
93870>>>            Procedure_Return
93871>>>        End
93871>>>>
93871>>>
93871>>>        Send CreateIntFilesTable hTable
93872>>>        Get Private.pbIntFilesTablesCheckDone to bIntFilesTablesCheckDone
93873>>>        Set Private.pbIntFilesTablesCheckDone to bIntFilesTablesCheckDone
93874>>>    End_Function
93875>>>                
93875>>>    Procedure CreateIntFilesTable Handle hTable
93877>>>        String sTableName sColumnName sInfoTxt sDriverID sDataPath
93877>>>        Boolean bTableExists bOK bUseConnectionID bExists
93877>>>        tAPIColumn[] APIColumn
93877>>>        tAPIColumn[] APIColumn
93878>>>
93878>>>        Get _UtilTableNumberIsInUse of ghoDbUpdateFunctionLibrary hTable to bTableExists
93879>>>        If (bTableExists = True) Begin
93881>>>            Procedure_Return
93882>>>        End
93882>>>>
93882>>>
93882>>>        Move False to Err
93883>>>        Get psDriverID to sDriverID
93884>>>        Get IsSQLDriver of ghoDbUpdateFunctionLibrary sDriverID to bUseConnectionID
93885>>>
93885>>>        Move CS_IntFilesTableRootName to sTableName
93886>>>
93886>>>        Move 1                  to APIColumn[0].iFieldNumber
93887>>>        Move "ID"               to APIColumn[0].sFieldName
93888>>>        Move DF_BCD             to APIColumn[0].iType
93889>>>        Move False              to APIColumn[0].bIsSQLType
93890>>>        Move 12                 to APIColumn[0].iLength
93891>>>        Move 0                  to APIColumn[0].iPrecision
93892>>>
93892>>>        Move 2                  to APIColumn[1].iFieldNumber
93893>>>        Move "IntFileName"      to APIColumn[1].sFieldName
93894>>>        Move DF_ASCII           to APIColumn[1].iType
93895>>>        Move False              to APIColumn[1].bIsSQLType
93896>>>        Move 50                 to APIColumn[1].iLength
93897>>>        Move 0                  to APIColumn[1].iPrecision
93898>>>
93898>>>        Move 3                  to APIColumn[2].iFieldNumber
93899>>>        Move "IntLineText"      to APIColumn[2].sFieldName
93900>>>        Move DF_ASCII           to APIColumn[2].iType
93901>>>        Move False              to APIColumn[2].bIsSQLType
93902>>>        Move 100                to APIColumn[2].iLength
93903>>>        Move 0                  to APIColumn[2].iPrecision
93904>>>
93904>>>        Get ApiTableCreate of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True APIColumn to bOk
93905>>>        
93905>>>        If (bOK = True and Err = False) Begin
93907>>>            Move ("Int Files Table:" + sTableName * "was successfully created" * "at filelist slot:" * String(hTable)) to sInfoTxt
93908>>>        End
93908>>>>
93908>>>        Else Begin
93909>>>            Set Private.pbIntFilesTablesCheckDone to False
93910>>>            Move ("ERROR" * "Int Files Table:" + sTableName * "could NOT be created" * "at filelist slot:" * String(hTable) * "\Program will now exit.") to sInfoTxt
93911>>>            Error DFERR_PROGRAM sInfoTxt
93912>>>>
93912>>>            Procedure_Return
93913>>>        End
93913>>>>
93913>>>        Send LogError of (phoLogFile(Self)) 0 0 sInfoTxt 0 False
93914>>>        
93914>>>        Open hTable
93916>>>        Get ApiIndexCreate hTable 1 1 1   to bOK     // Index 1 = ID
93917>>>        If (bOK = True) Begin
93919>>>            Get ApiIndexCreate hTable 2 2 2 1 to bOK // Index 2 = InteFileName, ID.
93920>>>        End
93920>>>>
93920>>>        If (bOK = False) Begin
93922>>>            Set Private.pbIntFilesTablesCheckDone to False
93923>>>            Move ("ERROR" * "Indexes for Int Files Table:" + sTableName * "could NOT be created" * "at filelist slot:" * String(hTable) * "\Program will now exit.") to sInfoTxt
93924>>>            Error DFERR_PROGRAM sInfoTxt
93925>>>>
93925>>>            Procedure_Return
93926>>>        End                    
93926>>>>
93926>>>        
93926>>>        // Check if the new .int file was created. If so and a .dat file exists - delete it.
93926>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
93927>>>        Get vFolderFormat sDataPath to sDataPath
93928>>>        Move (CS_IntFilesTableRootName + ".int") to sTableName
93929>>>        Get vFilePathExists (sDataPath + sTableName) to bExists
93930>>>        If (bExists = True) Begin
93932>>>            Move CS_IntFilesTableRootName to sTableName
93933>>>            Get vFilePathExists (sDataPath + sTableName + ".dat") to bExists
93934>>>            If (bExists = True) Begin
93936>>>                Get vDeleteFile (sDataPath + sTableName + ".dat") to bOK
93937>>>                Get vDeleteFile (sDataPath + sTableName + ".hdr") to bOK
93938>>>                Get vDeleteFile (sDataPath + sTableName + ".k??") to bOK
93939>>>            End
93939>>>>
93939>>>        End
93939>>>>
93939>>>        
93939>>>        Set Private.pbIntFilesTablesCheckDone to True
93940>>>    End_Procedure
93941>>>
93941>>>    Procedure CheckAutoCreateDbVersionTable
93943>>>        Boolean bDbVersionCheckDone bUseCustomDbVersion bAutoCreateDbVersionTable bTableExists
93943>>>        Integer iDbVersionFileNumber
93943>>>
93943>>>        Get Private.pbDbVersionCheckDone to bDbVersionCheckDone
93944>>>        If (bDbVersionCheckDone = True) Begin
93946>>>            Procedure_Return
93947>>>        End
93947>>>>
93947>>>        Get pbUseCustomDbVersion to bUseCustomDbVersion
93948>>>        If (bUseCustomDbVersion = True) Begin
93950>>>            Procedure_Return
93951>>>        End
93951>>>>
93951>>>
93951>>>        Get pbAutoCreateDbVersionTable to bAutoCreateDbVersionTable
93952>>>        If (bAutoCreateDbVersionTable = True and iDbVersionFileNumber = -1) Begin
93954>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
93955>>>            Error DFERR_PROGRAM "The iDbVersionFileSlotNumber = -1. It MUST be set to a free Filelist.cfg slot in the cDbUpdateHandler object. Could not auto-create the DbVersion table.\nProgram will now exit!"
93956>>>>
93956>>>            Send Exit_Application
93957>>>        End
93957>>>>
93957>>>
93957>>>        Get piDbVersionFileNumber to iDbVersionFileNumber
93958>>>        Get _UtilTableExists of ghoDbUpdateFunctionLibrary iDbVersionFileNumber to bTableExists
93959>>>        If (bTableExists = True) Begin
93961>>>            Set Private.pbDbVersionCheckDone to True
93962>>>            Procedure_Return
93963>>>        End
93963>>>>
93963>>>
93963>>>        Send CreateDbVersionTable iDbVersionFileNumber
93964>>>
93964>>>        // We only need to these DbVersion checks once, but because this message is called
93964>>>        // from each child cDbUpdateVersion object (and it needs to be called from there),
93964>>>        // we use a property to only run these tests once.
93964>>>        Set Private.pbDbVersionCheckDone to True
93965>>>    End_Procedure
93966>>>
93966>>>    Procedure CreateDbVersionTable Handle hTable
93968>>>        String sTableName sColumnName sInfoTxt sDriverID 
93968>>>        Boolean bTableExists bOK bUseConnectionID
93968>>>        tAPIColumn[] APIColumn
93968>>>        tAPIColumn[] APIColumn
93969>>>
93969>>>        Get _UtilTableNumberIsInUse of ghoDbUpdateFunctionLibrary hTable to bTableExists
93970>>>        If (bTableExists = True) Begin
93972>>>            Procedure_Return
93973>>>        End
93973>>>>
93973>>>
93973>>>        Get psDriverID to sDriverID
93974>>>        Get IsSQLDriver of ghoDbUpdateFunctionLibrary sDriverID to bUseConnectionID
93975>>>
93975>>>        Move "DbVersion"        to sTableName
93976>>>        Move 1                  to APIColumn[0].iFieldNumber
93977>>>        Move "DatabaseVersion"  to APIColumn[0].sFieldName
93978>>>        Move DF_BCD             to APIColumn[0].iType
93979>>>        Move False              to APIColumn[0].bIsSQLType
93980>>>        Move 4                  to APIColumn[0].iLength
93981>>>        Move 2                  to APIColumn[0].iPrecision
93982>>>
93982>>>        Move False to Err                                
93983>>>        
93983>>>        // Note: We always create an embedded DbVersion table. To do this we temporarily need to set the psDriverID to "DATAFLEX".
93983>>>        // To convert the DbVersion table to SQL, use the 'ApiTableConvertToSQL' function.
93983>>>        Set psDriverID to DATAFLEX_ID
93984>>>        Get ApiTableCreate of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True APIColumn to bOk
93985>>>        Get ApiTableChangeAttribute of ghoDbUpdateFunctionLibrary hTable DF_FILE_IS_SYSTEM_FILE True to bOK
93986>>>        Set psDriverID to sDriverID
93987>>>        
93987>>>        If (bOK = True and Err = False) Begin
93989>>>//            Move ("Column '" + APIColumn[0].sFieldName + "'" * "NUMERIC" * String(APIColumn[0].iLength) + ", was successfully added to '" + sTableName + "'" * "(at filelist slot:" * String(hTable) + ")") to sInfoTxt
93989>>>            Move ("DbVersion table:" + sTableName * "was successfully created" * "at filelist slot:" * String(hTable)) to sInfoTxt
93990>>>        End
93990>>>>
93990>>>        Else Begin
93991>>>            Move ("The column could NOT be added. Either column" * sColumnName * "already exists or the Table name is incorrect?") to sInfoTxt
93992>>>        End
93992>>>>
93992>>>
93992>>>        Send LogError of (phoLogFile(Self)) 0 0 sInfoTxt 0 False
93993>>>    End_Procedure
93994>>>
93994>>>    Procedure Set pbVerboseState Boolean bVerboseState
93996>>>        Handle ho
93996>>>        Get phoLogFile to ho
93997>>>        Set pbVerboseState of ho to bVerboseState
93998>>>    End_Procedure
93999>>>
93999>>>    Function pbVerboseState Returns Boolean
94001>>>        Boolean bVerboseState
94001>>>        Handle ho
94001>>>        Get phoLogFile to ho
94002>>>        Get pbVerboseState of ho to bVerboseState
94003>>>        Function_Return bVerboseState
94004>>>    End_Function
94005>>>
94005>>>    // Callback functionality used when e.g. calling driver functions directly.
94005>>>    // Note that this overrules the callback function of the cDbUpdateFunctionLibrary class.
94005>>>    Function Callback String sCallback_Text Integer iCallback_Type Returns Integer
94007>>>        Integer iPerc
94007>>>        Number nReady nTotal nVersion
94007>>>        Boolean bVerboseState
94007>>>        Handle hoLogFile
94007>>>
94007>>>        Get pbVerboseState to bVerboseState
94008>>>        Get pnCurrentVersionUpdate to nVersion
94009>>>        Get phoLogFile     to hoLogFile
94010>>>        Send DoAdvance of ghoProgressBar
94011>>>
94011>>>        If (sCallback_Text contains "Dropping index" or sCallback_Text contains "Temporary delete of all indices of table") Begin
94013>>>            Move (Replace("Dropping index", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
94014>>>            Move (Replace("Temporary delete of all indices of table", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
94015>>>        End
94015>>>>
94015>>>        If (sCallback_Text contains "Creating index") Begin
94017>>>            Move (Replace("Creating index", sCallback_Text, CS_DUF_CreatingIndex)) to sCallback_Text
94018>>>        End
94018>>>>
94018>>>
94018>>>        Case Begin
94018>>>            Case (iCallback_Type = DF_Message_Text)
94020>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
94021>>>                Set Action_Text  of ghoStatusPanel to ""
94022>>>                If (bVerboseState = True) Begin
94024>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
94025>>>                End
94025>>>>
94025>>>                Case Break
94026>>>            Case (iCallback_Type = DF_Message_Heading_1)
94029>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
94030>>>                If (bVerboseState = True) Begin
94032>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
94033>>>                End
94033>>>>
94033>>>                Case Break
94034>>>            Case (iCallback_Type = DF_Message_Heading_2)
94037>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
94038>>>                Set Action_Text  of ghoStatusPanel to ""
94039>>>                If (bVerboseState = True) Begin
94041>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
94042>>>                End
94042>>>>
94042>>>                Case Break
94043>>>            Case (iCallback_Type = DF_Message_Heading_3)
94046>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
94047>>>                Set Action_Text  of ghoStatusPanel to ""
94048>>>                If (bVerboseState = True) Begin
94050>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
94051>>>                End
94051>>>>
94051>>>                Case Break
94052>>>            Case (iCallback_Type = DF_Message_Heading_4)
94055>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
94056>>>                Set Action_Text  of ghoStatusPanel to ""
94057>>>                If (bVerboseState = True) Begin
94059>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
94060>>>                End
94060>>>>
94060>>>                Case Break
94061>>>            Case (iCallback_Type = DF_Message_Heading_5)
94064>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
94065>>>                Set Action_Text  of ghoStatusPanel to ""
94066>>>                If (bVerboseState = True) Begin
94068>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
94069>>>                End
94069>>>>
94069>>>                Case Break
94070>>>            Case (iCallback_Type = DF_Message_Warning)
94073>>>                If (bVerboseState = True) Begin
94075>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
94076>>>                End
94076>>>>
94076>>>                Case Break
94077>>>            Case (iCallback_Type = DF_Message_Progress_Title)
94080>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
94081>>>                Set Action_Text  of ghoStatusPanel to ""
94082>>>                If (bVerboseState = True) Begin
94084>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
94085>>>                End
94085>>>>
94085>>>                Case Break
94086>>>            Case (iCallback_Type = DF_Message_Progress_Value)
94089>>>                //*** Interpret numbers
94089>>>                Move (Left(sCallback_Text, (Pos(",", sCallback_Text) - 1)))                       to nReady
94090>>>                Move (Right(sCallback_Text, (Length(sCallback_Text) - Pos(",", sCallback_Text)))) to nTotal
94091>>>                Move ((nReady/nTotal) * 100)                                                      to iPerc
94092>>>                Set Action_Text of ghoStatusPanel to (String(iPerc) * String("% (Total:") * String(nTotal) + ")")
94093>>>                Set piPosition of ghoProgressBar to iPerc
94094>>>                Case Break
94095>>>            Case Else
94095>>>                Set Message_Text to ""
94096>>>                Set Action_Text  to ""
94097>>>        Case End
94097>>>
94097>>>        Send ProcessEvents of ghoStatusPanel
94098>>>        Function_Return False
94099>>>    End_Function
94100>>>
94100>>>    // This was made to be a procedure/function pair so we
94100>>>    // at the same time can set the property of the cDbUpdateFunctionLibrary
94100>>>
94100>>>    Procedure Set piDbType Integer iDbType
94102>>>        If (ghoSQLConnectionHandler = 0) Begin
94104>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94105>>>>
94105>>>            Procedure_Return
94106>>>        End
94106>>>>
94106>>>        Set piDbType of ghoSQLConnectionHandler to iDbType
94107>>>    End_Procedure
94108>>>
94108>>>    Function piDbType Returns Integer
94110>>>        Integer iDbType
94110>>>        If (ghoSQLConnectionHandler = 0) Begin
94112>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94113>>>>
94113>>>            Function_Return ""
94114>>>        End
94114>>>>
94114>>>        Get piDbType of ghoSQLConnectionHandler to iDbType
94115>>>        Function_Return iDbType
94116>>>    End_Function
94117>>>
94117>>>    Procedure Set psDriverID String sDriverID
94119>>>        If (ghoSQLConnectionHandler = 0) Begin
94121>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94122>>>>
94122>>>            Procedure_Return
94123>>>        End
94123>>>>
94123>>>        Set psDriverID of ghoSQLConnectionHandler to sDriverID
94124>>>    End_Procedure
94125>>>
94125>>>    Function psDriverID Returns String
94127>>>        String sValue
94127>>>        If (ghoSQLConnectionHandler = 0) Begin
94129>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94130>>>>
94130>>>            Function_Return ""
94131>>>        End
94131>>>>
94131>>>        Get psDriverID of ghoSQLConnectionHandler to sValue
94132>>>        Function_Return sValue
94133>>>    End_Function
94134>>>
94134>>>    Procedure CreateSQLConnection String sDriverID String sConnectionID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Boolean bSilent
94136>>>        If (ghoSQLConnectionHandler = 0) Begin
94138>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94139>>>>
94139>>>            Procedure_Return
94140>>>        End
94140>>>>
94140>>>        Send CreateSQLConnection of ghoSQLConnectionHandler sDriverID sConnectionID sServer sDatabase bTrusted sUserID sPassword bSilent
94141>>>    End_Procedure
94142>>>
94142>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
94144>>>        Integer iRetval
94144>>>        If (ghoSQLConnectionHandler = 0) Begin
94146>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94147>>>>
94147>>>            Function_Return 2
94148>>>        End
94148>>>>
94148>>>
94148>>>        Get RedirectConnection of ghoSQLConnectionHandler to iRetval
94149>>>        Function_Return iRetval
94150>>>    End_Function
94151>>>
94151>>>    Procedure Set psConnectionID String sValue
94153>>>        If (ghoSQLConnectionHandler = 0) Begin
94155>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94156>>>>
94156>>>            Procedure_Return
94157>>>        End
94157>>>>
94157>>>        Set psConnectionID of ghoSQLConnectionHandler to sValue
94158>>>    End_Procedure
94159>>>
94159>>>    Function psConnectionID Returns String
94161>>>        String sValue
94161>>>        If (ghoSQLConnectionHandler = 0) Begin
94163>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94164>>>>
94164>>>            Function_Return ""
94165>>>        End
94165>>>>
94165>>>        Get psConnectionID of ghoSQLConnectionHandler to sValue
94166>>>
94166>>>        Function_Return sValue
94167>>>    End_Function
94168>>>
94168>>>    // These "properties" are settings of the cCLIHandler class, but are being
94168>>>    // relayed to the ghoSQLConnectionHandler object
94168>>>    // simply by changing one of its parameters.
94168>>>    Procedure Set psServer String sValue
94170>>>        If (ghoSQLConnectionHandler = 0) Begin
94172>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94173>>>>
94173>>>            Procedure_Return
94174>>>        End
94174>>>>
94174>>>        Set psServer of ghoSQLConnectionHandler to sValue
94175>>>    End_Procedure
94176>>>
94176>>>    Function psServer Returns String
94178>>>        String sValue
94178>>>        If (ghoSQLConnectionHandler = 0) Begin
94180>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94181>>>>
94181>>>            Function_Return ""
94182>>>        End
94182>>>>
94182>>>        Get psServer of ghoSQLConnectionHandler to sValue
94183>>>
94183>>>        Function_Return sValue
94184>>>    End_Function
94185>>>
94185>>>    Procedure Set psDatabase String sValue
94187>>>        If (ghoSQLConnectionHandler = 0) Begin
94189>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94190>>>>
94190>>>            Procedure_Return
94191>>>        End
94191>>>>
94191>>>        Set psDatabase of ghoSQLConnectionHandler to sValue
94192>>>    End_Procedure
94193>>>
94193>>>    Function psDatabase Returns String
94195>>>        String sValue
94195>>>        If (ghoSQLConnectionHandler = 0) Begin
94197>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94198>>>>
94198>>>            Function_Return ""
94199>>>        End
94199>>>>
94199>>>        Get psDatabase of ghoSQLConnectionHandler to sValue
94200>>>
94200>>>        Function_Return sValue
94201>>>    End_Function
94202>>>
94202>>>    Procedure Set psUserID String sValue
94204>>>        If (ghoSQLConnectionHandler = 0) Begin
94206>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94207>>>>
94207>>>            Procedure_Return
94208>>>        End
94208>>>>
94208>>>        Set psUserID of ghoSQLConnectionHandler to sValue
94209>>>    End_Procedure
94210>>>
94210>>>    Function psUserID Returns String
94212>>>        String sValue
94212>>>        If (ghoSQLConnectionHandler = 0) Begin
94214>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94215>>>>
94215>>>            Function_Return ""
94216>>>        End
94216>>>>
94216>>>        Get psUserID of ghoSQLConnectionHandler to sValue
94217>>>
94217>>>        Function_Return sValue
94218>>>    End_Function
94219>>>
94219>>>    Procedure Set psPassword String sValue
94221>>>        If (ghoSQLConnectionHandler = 0) Begin
94223>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94224>>>>
94224>>>            Procedure_Return
94225>>>        End
94225>>>>
94225>>>        Set psPassword of ghoSQLConnectionHandler to sValue
94226>>>    End_Procedure
94227>>>
94227>>>    Function psPassword Returns String
94229>>>        String sValue
94229>>>        If (ghoSQLConnectionHandler = 0) Begin
94231>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94232>>>>
94232>>>            Function_Return ""
94233>>>        End
94233>>>>
94233>>>        Get psPassword of ghoSQLConnectionHandler to sValue
94234>>>
94234>>>        Function_Return sValue
94235>>>    End_Function
94236>>>
94236>>>    Procedure Set pbTrusted Boolean bValue
94238>>>        If (ghoSQLConnectionHandler = 0) Begin
94240>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94241>>>>
94241>>>            Procedure_Return
94242>>>        End
94242>>>>
94242>>>        Set pbTrusted of ghoSQLConnectionHandler to bValue
94243>>>    End_Procedure
94244>>>
94244>>>    Function pbTrusted Returns Boolean
94246>>>        Boolean bValue
94246>>>        If (ghoSQLConnectionHandler = 0) Begin
94248>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94249>>>>
94249>>>            Function_Return False
94250>>>        End
94250>>>>
94250>>>        Get pbTrusted of ghoSQLConnectionHandler to bValue
94251>>>
94251>>>        Function_Return bValue
94252>>>    End_Function
94253>>>
94253>>>    Procedure Set psConnectionString String sValue
94255>>>        If (ghoSQLConnectionHandler = 0) Begin
94257>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94258>>>>
94258>>>            Procedure_Return
94259>>>        End
94259>>>>
94259>>>        Set psConnectionString of ghoSQLConnectionHandler to sValue
94260>>>    End_Procedure
94261>>>
94261>>>    Function psConnectionString Returns String
94263>>>        String sValue
94263>>>        If (ghoSQLConnectionHandler = 0) Begin
94265>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94266>>>>
94266>>>            Function_Return ""
94267>>>        End
94267>>>>
94267>>>        Get psConnectionString of ghoSQLConnectionHandler to sValue
94268>>>
94268>>>        Function_Return sValue
94269>>>    End_Function
94270>>>
94270>>>    Function piConnectionOptions Returns Integer
94272>>>        Integer iValue
94272>>>        If (ghoSQLConnectionHandler = 0) Begin
94274>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
94275>>>>
94275>>>            Function_Return 0
94276>>>        End
94276>>>>
94276>>>        Get piConnectionOptions of ghoSQLConnectionHandler to iValue
94277>>>
94277>>>        Function_Return iValue
94278>>>    End_Function
94279>>>
94279>>>
94279>>>    Procedure Set pbCheckDataFlexUserCount Boolean bState
94281>>>        Set pbCheckDataFlexUserCount of (phoUserCountSystem(Self)) to bState
94282>>>    End_Procedure
94283>>>
94283>>>    Function pbCheckDataFlexUserCount Returns Boolean
94285>>>        Boolean bState
94285>>>        Get pbCheckDataFlexUserCount of (phoUserCountSystem(Self)) to bState
94286>>>        Function_Return bState
94287>>>    End_Function
94288>>>
94288>>>    Procedure Set psLogTextFile String sValue
94290>>>        Set psLogTextFile of (phoLogFile(Self)) to sValue
94291>>>    End_Procedure
94292>>>
94292>>>    Function psLogTextFile Returns String
94294>>>        String sValue
94294>>>        Get psLogTextFile of (phoLogFile(Self)) to sValue
94295>>>        Function_Return sValue
94296>>>    End_Function
94297>>>
94297>>>    Procedure Set psEditorProgram String sValue
94299>>>        Set psEditorProgram of (phoLogFile(Self)) to sValue
94300>>>    End_Procedure
94301>>>
94301>>>    Function psEditorProgram Returns String
94303>>>        String sValue
94303>>>        Get psEditorProgram of (phoLogFile(Self)) to sValue
94304>>>        Function_Return sValue
94305>>>    End_Function
94306>>>
94306>>>    Procedure Set pbUseDataTableLog Boolean bState
94308>>>        Set pbUseDataTableLog of (phoLogFile(Self)) to bState
94309>>>    End_Procedure
94310>>>
94310>>>    Function pbUseDataTableLog Returns Boolean
94312>>>        Boolean bState
94312>>>        Get pbUseDataTableLog of (phoLogFile(Self)) to bState
94313>>>        Function_Return bState
94314>>>    End_Function
94315>>>
94315>>>    Procedure Set pbQuickWrite Boolean bState
94317>>>        Set pbQuickWrite of (phoLogFile(Self)) to bState
94318>>>    End_Procedure
94319>>>
94319>>>    Function pbQuickWrite Returns Boolean
94321>>>        Boolean bState
94321>>>        Get pbQuickWrite of (phoLogFile(Self)) to bState
94322>>>        Function_Return bState
94323>>>    End_Function
94324>>>
94324>>>    Procedure Set pbDatabaseWasUpdated Boolean bState
94326>>>        Boolean bUpdateVersionObjectError bVerboseState
94326>>>        Integer iSize iCount
94326>>>        Number nVersion
94326>>>        String[] aSQLQueryMessages
94327>>>
94327>>>        Get Private.pbUpdateVersionObjectError to bUpdateVersionObjectError
94328>>>        Set Private.pbDatabaseWasUpdated to bState
94329>>>        // If no errors occurred in the current cDbUpdateVersion object - write
94329>>>        // to the log that it was OK.
94329>>>        If (bUpdateVersionObjectError = False) Begin
94331>>>            Get pnCurrentVersionUpdate to nVersion
94332>>>            Send LogError of (phoLogFile(Self)) nVersion 0 CS_SuccessfulUpdate 0 False
94333>>>        End
94333>>>>
94333>>>
94333>>>        Get pbVerboseState to bVerboseState
94334>>>        If (bVerboseState = True) Begin
94336>>>            Get paSQLQueryMessages to aSQLQueryMessages
94337>>>            Move (SizeOfArray(aSQLQueryMessages)) to iSize
94338>>>            Decrement iSize
94339>>>            For iCount from 0 to iSize
94345>>>>
94345>>>                Send LogError of (phoLogFile(Self)) nVersion 0 aSQLQueryMessages[iCount] 0 False
94346>>>            Loop
94347>>>>
94347>>>        End
94347>>>>
94347>>>
94347>>>    End_Procedure 
94348>>>    
94348>>>    Procedure Set piDbVersionFileNumber Integer iFileNumber
94350>>>        Set Private.piDbVersionFileNumber to iFileNumber
94351>>>    End_Procedure                                         
94352>>>    
94352>>>    Function piDbVersionFileNumber Returns Integer
94354>>>        Function_Return (Private.piDbVersionFileNumber(Self))
94355>>>    End_Function
94356>>>
94356>>>    Procedure Set piDbVersionFieldNumber Integer iFieldNumber
94358>>>        Set Private.piDbVersionFieldNumber to iFieldNumber
94359>>>    End_Procedure                                         
94360>>>    
94360>>>    Function piDbVersionFieldNumber Returns Integer
94362>>>        Function_Return (Private.piDbVersionFieldNumber(Self))
94363>>>    End_Function
94364>>>
94364>>>    Function pbDatabaseWasUpdated Returns Boolean
94366>>>        Function_Return (Private.pbDatabaseWasUpdated(Self))
94367>>>    End_Function
94368>>>    
94368>>>    //
94368>>>    Procedure ReinitializeFramework  
94370>>>        tDbVersionInfo[] aDbVersionInfoArray
94370>>>        tDbVersionInfo[] aDbVersionInfoArray
94371>>>        Handle hoDbVersionObject
94371>>>        Integer iSize iCount
94371>>>        
94371>>>        Set Private.pbDatabaseUpdateStarted to False
94372>>>        Get paDbVersionInfoArray to aDbVersionInfoArray
94373>>>        Move (SizeOfArray(aDbVersionInfoArray)) to iSize
94374>>>        Decrement iSize
94375>>>        
94375>>>        For iCount from 0 to iSize
94381>>>>
94381>>>            Move aDbVersionInfoArray[0].hObject to hoDbVersionObject
94382>>>            Send ProcessUpdate                  of hoDbVersionObject False
94383>>>        Loop
94384>>>>
94384>>>        Send Cleanup
94385>>>    End_Procedure
94386>>>    
94386>>>    // This event is triggered by the cDbUpdateVersion child class when
94386>>>    // a database change is to be started, and is considered private.
94386>>>    // It is only executed once for the first cDbUpateVersion object!
94386>>>    Procedure InitDatabaseUpdate Handle hDbUpdateVersionObject
94388>>>        Boolean bDatabaseUpdateStarted bInUse bExists bCheckDataFlexUserCount
94388>>>        Integer iRetval iDataFlexUsers iUserCount
94388>>>        Handle hoUserCountSystem
94388>>>        tUserCount UserCount
94388>>>        tUserCount UserCount
94388>>>        DateTime dtUpdateStarted
94388>>>        tSQLConnection SQLConnection
94388>>>        tSQLConnection SQLConnection
94388>>>
94388>>>        // *Important:* If we already started the update; we do no further checking.
94388>>>        Get Private.pbDatabaseUpdateStarted to bDatabaseUpdateStarted
94389>>>        If (bDatabaseUpdateStarted = True) Begin
94391>>>            Procedure_Return
94392>>>        End
94392>>>>
94392>>>
94392>>>        // If not silent mode; Ask user if OK to start database update.
94392>>>        If (pbSilentMode(Self) = False) Begin
94394>>>            Get YesNo_Box CS_DUF_DatabaseNeedsUpdate CS_DUF_HeaderUpdateText to iRetval
94395>>>            If (iRetval <> MBR_Yes) Begin
94397>>>                Send Exit_Application
94398>>>            End
94398>>>>
94398>>>        End
94398>>>>
94398>>>        
94398>>>        Send EnableCancelButton     of ghoStatusPanel (pbEnableCancelButton(Self))
94399>>>        Send Initialize_StatusPanel of ghoStatusPanel ("   " + CS_DUF_WorkingUpdateText) CS_DUF_WorkingHeaderText ""
94400>>>        Send Start_StatusPanel      of ghoStatusPanel
94401>>>
94401>>>        // This will save the status of all open tables including Master/Alias settings,
94401>>>        // so we can restore them later;
94401>>>        Send SaveOpenTables
94402>>>
94402>>>        Move 0 to iDataFlexUsers
94403>>>        // Make various tests to check that the database is not in use.
94403>>>        Get IsDatabaseInUse of hDbUpdateVersionObject to bInUse
94404>>>        // We also use our own user counting mechanism to guard against the
94404>>>        // database isn't opened already as we need exclusive access to the tables.:
94404>>>        Get phoUserCountSystem to hoUserCountSystem
94405>>>        Get CheckUserCount of hoUserCountSystem to UserCount
94406>>>        Get CurrentNumberOfUsers of hoUserCountSystem to iUserCount
94407>>>
94407>>>        Get pbCheckDataFlexUserCount of hoUserCountSystem to bCheckDataFlexUserCount
94408>>>        // Check DataFlex user count to see if anybody else is using the DataFlex license...
94408>>>        If (bCheckDataFlexUserCount = True) Begin
94410>>>            Get_Current_User_Count to iDataFlexUsers
94411>>>            // For some reason DataFlex - in some cases - might think that 2 users
94411>>>            // are in use while debugging from the Studio.
94411>>>            If (IsDebuggerPresent() and iDataFlexUsers = 2) Begin
94413>>>                Decrement iDataFlexUsers
94414>>>            End
94414>>>>
94414>>>        End 
94414>>>>
94414>>>        Else Begin
94415>>>            Move 1 to iDataFlexUsers 
94416>>>            Move 1 to iUserCount
94417>>>            Move False to bInUse
94418>>>        End
94418>>>>
94418>>>
94418>>>        If (pbSilentMode(Self) = False and iDataFlexUsers > 1) Begin
94420>>>            Get YesNo_Box CS_DUF_DatabaseInUseShort to iRetval
94421>>>            If (iRetval <> MBR_Yes) Begin
94423>>>                Send Exit_Application
94424>>>            End
94424>>>>
94424>>>        End
94424>>>>
94424>>>
94424>>>        If (bInUse = True or (UserCount.iError <> 0) or (iUserCount > 1)) Begin
94426>>>            Send Stop_Box CS_DUF_DatabaseInUseText
94427>>>            Send Exit_Application
94428>>>        End
94428>>>>
94428>>>
94428>>>        // This will put a look on the DbUpdateLock.ucf file.
94428>>>        // It is released when the update process is finished
94428>>>        Get CheckUserCount of (phoDatabaseUpdateLock(Self)) to UserCount
94429>>>
94429>>>        Move (CurrentDateTime()) to dtUpdateStarted
94430>>>        Set pdtUpdateStart of (phoLogFile(Self)) to dtUpdateStarted
94431>>>        Set Private.pbDatabaseUpdateStarted to True
94432>>>
94432>>>        // We need to close all tables before starting to make changes.
94432>>>        Close DF_ALL DF_PERMANENT
94433>>>
94433>>>        // If these properties has not exclicitly been set in the object, set them
94433>>>        // to settings from the SQLConnections.ini file;
94433>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
94434>>>        If (psSchema(Self) = "") Begin
94436>>>            Set psSchema            to SQLConnection.sSchema
94437>>>        End
94437>>>>
94437>>>        If (psBaseTableSpace(Self) = "") Begin
94439>>>            Set psBaseTableSpace    to SQLConnection.sBaseTableSpace
94440>>>        End
94440>>>>
94440>>>        If (psLongTableSpace(Self) = "") Begin
94442>>>            Set psLongTableSpace    to SQLConnection.sLongTableSpace
94443>>>        End
94443>>>>
94443>>>        If (psIndexTableSpace(Self) = "") Begin
94445>>>            Set psIndexTableSpace   to SQLConnection.sIndexTableSpace
94446>>>        End
94446>>>>
94446>>>        If (SQLConnection.sDriverID = "" or SQLConnection.sDriverID = DATAFLEX_ID) Begin
94448>>>            Procedure_Return
94449>>>        End
94449>>>>
94449>>>
94449>>>        Get SQLUtilCheckIfDatabaseExists of hDbUpdateVersionObject SQLConnection.sDatabase to bExists
94450>>>        If (SQLConnection.sDatabase <> "" and bExists = False) Begin
94452>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
94453>>>            Send Stop_StatusPanel of ghoStatusPanel
94454>>>            // ToDo: NS 2019-09-23 I think we should always show an error message to the user if this occur (!)
94454>>>            Send Stop_Box (CS_DUF_DatabaseConnStringSpec + SQLConnection.sDatabase + CS_DUF_DatabaseDoesntExist )
94455>>>//            Error DFERR_PROGRAM ("The database specified in the connection string: '" + SQLConnection.sDatabase + "' doesn't exist!\n\nYou need to create it with a database management software or by using the 'SqlDatabaseCreate' function, which can be used in the 'OnPreUpdate' event of the cDbUpdateHandler object.\n\nThe program will now exit.")
94455>>>            Send Exit_Application
94456>>>        End
94456>>>>
94456>>>    End_Procedure
94457>>>
94457>>>    // *** Hook message for pre-processing ***
94457>>>    // Event to be used to auto-create a version table when "DUF_Use_Custom_DbVersion" is used.
94457>>>    // Aka, when another table than the standard "DbVersion" is used.
94457>>>    Procedure OnCreateCustomDbVersionTable
94459>>>    End_Procedure
94460>>>    
94460>>>    // *** Hook message for pre-processing ***
94460>>>    // The programmer can use this event for putting code that
94460>>>    // needs to be executed _before_ code in any of the cDbUpdateVersion
94460>>>    // child objects are executed.
94460>>>    Procedure OnPreUpdate
94462>>>    End_Procedure
94463>>>
94463>>>    // *** Hook message for post-processing ***
94463>>>    // The programmer should use this event for putting code that
94463>>>    // needs to be executed _after_ all database updates have finished.
94463>>>    Procedure OnPostUpdate
94465>>>    End_Procedure
94466>>>
94466>>>    // *** Hook message for custom DbVersion record find ***
94466>>>    // The programmer can use this event for putting code that
94466>>>    // needs to be executed to find a *custom* DbVersion table record.
94466>>>    // By default the DbVersion table is used but this can be
94466>>>    // customized by adding this line to the code;
94466>>>    // "Define DUF_Use_Custom_DbVersion" before the line "Use cDbUpdateHandler.pkg"
94466>>>    // Note: You do _not_ need to use this event if the DbVersion table is used
94466>>>    //       to save the current database version to. Only if you use your own
94466>>>    //       table _and_ it is not a system table (contains only one record).
94466>>>    Procedure OnFindVersionRecord
94468>>>        // Open MyTable
94468>>>        // Move xx to MyTable.Field1
94468>>>        // Move yy to MyTable.Field2
94468>>>        // Find le MyTable by Index.x
94468>>>    End_Procedure
94469>>>
94469>>>    // Hook event for writing header error text (pre-update) to
94469>>>    // a datatable. Only called if the pbUseDataTableLog property = True.
94469>>>    // Don't forget to Open the table first (!) as all
94469>>>    // tables have been closed at this stage.
94469>>>    // The start date & time is passed.
94469>>>    Procedure OnErrorWriteHeader_DataTable DateTime dtUpdateStart
94471>>>    End_Procedure
94472>>>
94472>>>    // Hook event to log errors to a database table.
94472>>>    // Only called if the pbUseDataTableLog = True.
94472>>>    // Don't forget to Open the table first (!) as all
94472>>>    // tables have been closed at this stage.
94472>>>    // If pbQuickWrite = True the DbUpdateErrorArray
94472>>>    // will contain just one row, as it is called for each error
94472>>>    // that occurred. Else it is called once at the end after all updates
94472>>>    // have run and contains all errors.
94472>>>    Procedure OnErrorWriteRow_DataTable tDbUpdateError[] DbUpdateErrorArray
94474>>>    End_Procedure
94475>>>
94475>>>    // Automatically send after all processing is done, but before the OnPostUpdate event.
94475>>>    Procedure Cleanup
94477>>>        Boolean bDatabaseWasUpdated bError
94477>>>
94477>>>        Send CheckAutoCreateDbVersionTable
94478>>>        Send RestoreOpenTables
94479>>>
94479>>>        // The function library have two purposes; one is to use it in the
94479>>>        // Database Update Framework, but it can also be used on its own.
94479>>>        // If that is the case it has its own error handling system, which
94479>>>        // we temporarily disbled when running updates because we have
94479>>>        // error handling/logging here too... We now restore its setting.
94479>>>        If (ghoDbUpdateFunctionLibrary > 0) Begin
94481>>>            Set pbHandleQueryErrors of ghoDbUpdateFunctionLibrary to True
94482>>>        End
94482>>>>
94482>>>        Set pbHandleQueryErrors to True
94483>>>
94483>>>        Get pbDatabaseWasUpdated to bDatabaseWasUpdated
94484>>>        Get pbDbUpdateErrorHasOccured to bError
94485>>>        If (bDatabaseWasUpdated = True or bError = True) Begin
94487>>>
94487>>>            // We should always create the log as it also contains info about
94487>>>            // the update being successful.
94487>>>            Send WriteErrorLog of (phoLogFile(Self))
94488>>>
94488>>>            // This is a programmer's hook message:
94488>>>            Send OnPostUpdate
94489>>>
94489>>>            Send Stop_StatusPanel of ghoStatusPanel
94490>>>
94490>>>            If (pbSilentMode(Self) = False) Begin
94492>>>                If (bError = True) Begin
94494>>>                    If (pbShowErrorLogPostRun(Self) = True) Begin
94496>>>                        Send ShowErrorLog of (phoLogFile(Self))
94497>>>                    End
94497>>>>
94497>>>                    Send Info_Box CS_DUF_DbUpdatedErrorText
94498>>>                    Send Exit_Application
94499>>>                End
94499>>>>
94499>>>                Else Begin
94500>>>                    If (Private.pbDatabaseWasUpdated(Self) = True) Begin
94502>>>                        Send Info_Box CS_DUF_DatabaseUpdatedText
94503>>>                    End
94503>>>>
94503>>>                    Else Begin
94504>>>                        Send Info_Box CS_DUF_DatabaseCheckedText
94505>>>                    End
94505>>>>
94505>>>
94505>>>                End
94505>>>>
94505>>>            End
94505>>>>
94505>>>        End
94505>>>>
94505>>>
94505>>>        // Restore the standard error handler:
94505>>>        Get piOrgErrorHandlerID to Error_Object_Id
94506>>>    End_Procedure
94507>>>
94507>>>    // We do this _before_ we close the database to make changes, and save
94507>>>    // all 'Master' & 'Alias' tables settings so we can restore when
94507>>>    // we reopen the database.
94507>>>    Procedure SaveOpenTables
94509>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
94509>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
94510>>>        Get _MasterAndAliasFiles to aDbUpdateHandlerMasterAlias
94511>>>        Set paDbUpdateHandlerMasterAlias to aDbUpdateHandlerMasterAlias
94512>>>    End_Procedure
94513>>>
94513>>>    // Returns a struct array with all currently open tables and a "state" that indicates if the table
94513>>>    // was opened DF_FILE_ALIAS_DEFAULT, DF_FILE_IS_MASTER or DF_FILE_IS_ALIAS
94513>>>    Function _MasterAndAliasFiles Returns tDbUpdateHandlerMasterAlias[]
94515>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
94515>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
94516>>>        Integer hTable iMasterAliasType iSize
94516>>>        Boolean bOpen
94516>>>
94516>>>        Move 0 to hTable
94517>>>        Repeat
94517>>>>
94517>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
94520>>>            If (hTable <> 0) Begin
94522>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
94525>>>                If (bOpen = True) Begin
94527>>>                    Get_Attribute DF_FILE_ALIAS of hTable to iMasterAliasType
94530>>>                    Move (SizeOfArray(aDbUpdateHandlerMasterAlias)) to iSize
94531>>>                    Move hTable to aDbUpdateHandlerMasterAlias[iSize].hTable
94532>>>                    Move iMasterAliasType to aDbUpdateHandlerMasterAlias[iSize].iMode
94533>>>                End
94533>>>>
94533>>>            End
94533>>>>
94533>>>        Until (hTable = 0)
94535>>>
94535>>>        Function_Return aDbUpdateHandlerMasterAlias
94536>>>    End_Function
94537>>>
94537>>>    // Message that re-opens all files in the filelist.cfg and restores any master & alias attributes.
94537>>>    // Takes one parameter:
94537>>>    //   A struct array with all master & alias
94537>>>    Procedure RestoreOpenTables
94539>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
94539>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
94540>>>        Integer hTable iFileAlias iSize iCount
94540>>>        Boolean bOpen
94540>>>        String sRootName
94540>>>
94540>>>        Move 0 to hTable
94541>>>        Get paDbUpdateHandlerMasterAlias to aDbUpdateHandlerMasterAlias
94542>>>        Move (SizeOfArray(aDbUpdateHandlerMasterAlias)) to iSize
94543>>>        Decrement iSize
94544>>>        For iCount from 0 to iSize
94550>>>>
94550>>>            Move aDbUpdateHandlerMasterAlias[iCount].hTable to hTable
94551>>>            // We also need to check that the table hasn't been removed...
94551>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
94554>>>            If (hTable <> 0 and sRootName <> "") Begin
94556>>>                Open hTable
94558>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
94561>>>                If (bOpen = True) Begin
94563>>>                    Move aDbUpdateHandlerMasterAlias[iCount].iMode to iFileAlias
94564>>>                    If (iFileAlias = DF_FILE_IS_MASTER) Begin
94566>>>                        Set_Attribute DF_FILE_ALIAS of hTable to DF_FILE_IS_MASTER
94569>>>                    End
94569>>>>
94569>>>                    Else If (iFileAlias = DF_FILE_IS_ALIAS) Begin
94572>>>                        Set_Attribute DF_FILE_ALIAS of hTable to DF_FILE_IS_ALIAS
94575>>>                    End
94575>>>>
94575>>>                End
94575>>>>
94575>>>            End
94575>>>>
94575>>>        Loop
94576>>>>
94576>>>    End_Procedure
94577>>>
94577>>>    // This checks for both duplicate pnVersionNumbers _and_ that
94577>>>    // the cDbVersion object pnVersionNumber's all are consecutive (higher than the previous).
94577>>>    Procedure CheckForDuplicates Number nVersion
94579>>>        tDbVersionInfo[] DbVersionInfoArray
94579>>>        tDbVersionInfo[] DbVersionInfoArray
94580>>>        Integer iCount iSize iHits iDuplicateIndex
94580>>>        Number nCompare
94580>>>        Handle hObject1 hObject2
94580>>>        String sObjectName1 sObjectName2
94580>>>        Boolean bObjectOrderError
94580>>>
94580>>>        Get paDbVersionInfoArray to DbVersionInfoArray
94581>>>        Move (SizeOfArray(DbVersionInfoArray)) to iSize
94582>>>        Decrement iSize
94583>>>        Move 0 to iHits
94584>>>        Move 0 to nCompare
94585>>>        Move False to bObjectOrderError
94586>>>        For iCount from 0 to iSize
94592>>>>
94592>>>            If (nVersion = DbVersionInfoArray[iCount].nVersionNumber) Begin
94594>>>                Increment iHits
94595>>>                If (iHits > 1) Begin
94597>>>                    Move iCount to iDuplicateIndex
94598>>>                    If (nCompare <> 0) Begin
94600>>>                        Move (nCompare >= DbVersionInfoArray[iCount].nVersionNumber) to bObjectOrderError
94601>>>                    End
94601>>>>
94601>>>                End
94601>>>>
94601>>>            End
94601>>>>
94601>>>            Move DbVersionInfoArray[iCount].nVersionNumber to nCompare
94602>>>        Loop
94603>>>>
94603>>>        If (iHits > 1) Begin
94605>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
94606>>>            Move DbVersionInfoArray[(iDuplicateIndex   )].hObject to hObject1
94607>>>            Move DbVersionInfoArray[(iDuplicateIndex -1)].hObject to hObject2
94608>>>            Move (Name(hObject1)) to sObjectName1
94609>>>            Move (Name(hObject2)) to sObjectName2
94610>>>            Error DFERR_PROGRAM ("Duplicate version numbers! The SAME pnVersionNumber value was set for the following two objects; Program will now exit!\n\n" + sObjectName1 + "\n" + sObjectName2)
94611>>>>
94611>>>            Send Exit_Application
94612>>>        End
94612>>>>
94612>>>        Else If (bObjectOrderError = True) Begin
94615>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
94616>>>            Error DFERR_PROGRAM ("cDbVersion objects out of order! One or more of the cDbVersion objects has been placed out of order. This means that at least one pnVersionNumber is HIGHER than the following object's pnVersionNumber.\nProgram will now exit!")
94617>>>>
94617>>>            Send Exit_Application
94618>>>        End
94618>>>>
94618>>>    End_Procedure
94619>>>
94619>>>    // We take care of all errors in the Error_Report below and
94619>>>    // collect them all to an array property. So just ignore any
94619>>>    // "Ignore_Error" & "Trap_Error" messages that might be send/used
94619>>>    // in some other package.
94619>>>    Procedure Ignore_Error Integer iError
94621>>>    End_Procedure
94622>>>
94622>>>    Procedure Trap_Error Integer iError
94624>>>    End_Procedure
94625>>>
94625>>>    // Build complete error description from Flexerrs and user error message.
94625>>>    Function Error_Description Integer Error# String ErrMsg Returns String
94627>>>        String Full_Error_Text
94627>>>        
94627>>>        Move (Trim(ErrMsg)) to ErrMsg
94628>>>        Move (Trim(Error_Text(DESKTOP, Error#))) to Full_Error_Text
94629>>>        
94629>>>        If (ErrMsg <> "") Begin
94631>>>            
94631>>>            If ((Full_Error_Text<>"" ) and ;                Error_Text_Available( DESKTOP, Error# ) ) Begin
94633>>>                // Make sure last character of error text is a separating symbol.
94633>>>                // if not, add a "." So we have format of "error-text. error-detail"
94633>>>                If (Pos(Right(Full_Error_Text,1),".,:;") =0) ;                    Move (Full_Error_Text - ".") to Full_Error_Text
94636>>>                Move (Full_Error_Text * ErrMsg)  to Full_Error_Text
94637>>>            End
94637>>>>
94637>>>            Else ;                Move ErrMsg to Full_Error_Text
94639>>>            
94639>>>        End
94639>>>>
94639>>>        
94639>>>        Function_Return Full_Error_Text
94640>>>    End_Function
94641>>>
94641>>>    // While we update the database we collect all errors in
94641>>>    // the struct array paDbUpdateErrorArray.
94641>>>    Procedure Error_Report Integer iErrorNumber Integer iErrorLine String sErrorText
94643>>>        Number nVersion
94643>>>        Handle hoLogFile 
94643>>>//        String sErrExtraText
94643>>>        
94643>>>        If (Private.pbProcessingError(Self)) Begin
94645>>>            Procedure_Return
94646>>>        End
94646>>>>
94646>>>
94646>>>        // The UtilTableNameFromHandleToString function does a:
94646>>>        // "Get_Attribute DF_FILE_TABLE_NAME of hTable to sTableName" call
94646>>>        // and it generates an error if the table is of the embedded type.
94646>>>        // As we don't want to trigger an error in that very specific case,
94646>>>        // we just ignore it here.
94646>>>        //
94646>>>        // If no report mode, just set the err indicator to true.
94646>>>        If (Error_Report_Mode(Self) = DUF_ERROR_NO_REPORT) Begin
94648>>>            Move False to Err
94649>>>            Procedure_Return
94650>>>        End
94650>>>>
94650>>>
94650>>>        If (iErrorNumber = DFERR_UNSUPPORTED_ATTRIBUTE) Begin
94652>>>            Procedure_Return
94653>>>        End
94653>>>>
94653>>>
94653>>>        Set Private.pbProcessingError to True
94654>>>        Set Private.pbUpdateVersionObjectError to True
94655>>>
94655>>>        Set pbDbUpdateErrorHasOccured to True
94656>>>        Get pnCurrentVersionUpdate to nVersion
94657>>>        Get phoLogFile to hoLogFile
94658>>>        Send LogError of hoLogFile nVersion iErrorNumber sErrorText iErrorLine True
94659>>>
94659>>>        Set Private.pbProcessingError to False
94660>>>    End_Procedure
94661>>>
94661>>>End_Class
94662>Use vWin32fh.pkg
94662>Use cDbUpdateVersion.pkg
94662>
94662>Object oHtmlHelp is a cHtmlHelp
94664>    Set pbAlwaysOnTop to False
94665>End_Object
94666>
94666>Define CS_PropertiesKeyWord     for "Properties"
94666>Define CS_ThemeKeyWord          for "Theme"
94666>
94666>
94666>Object oApplication is a cApplication
94668>    Set psCompany to "RDC Tools International"
94669>    Set psProduct to "DUF - Code Generator"
94670>    Set peHelpType to htHtmlHelp
94671>    // Note: The help file settings gets changed by the Help toolbar button(s).
94671>    Set psHelpFile to "Developer5.chm"
94672>
94672>    Property Handle phoDbUpdateHandler 0
94674>    Property Handle phoTableDUFCodeGenerator_vw 0
94676>    Property String private.psFilelistFromOrg ""
94678>    Property String psFilelistFrom ""
94680>    Property Integer[] piaDifferences
94682>    Property String psOrgOpenPath ""
94684>
94684>    Property String psCompileDateAndTime
94686>    // This is used by the About object to display the compile date & time:
94686>    Include_Resource CompileHeader.h as res_CompileHeader type DF_RESOURCE_TYPE_LINE
94686>    
94686>    Function psWorkspaceHomePath Returns String
94689>        String sPath 
94689>        Get psHome of (phoWorkspace(Self)) to sPath
94690>        Function_Return sPath
94691>    End_Function
94692>
94692>    // Set psOrgOpenPath at startup
94692>    Procedure Save_DF_OPEN_PATH
94695>        String sOrgOpenPath sDataPath sFileListPath
94695>        
94695>        Get psFileList of (phoWorkspace(ghoApplication)) to sFileListPath
94696>        Set private.psFilelistFromOrg to sFileListPath
94697>        Get_Attribute DF_OPEN_PATH to sOrgOpenPath
94700>        // First remove the current Data folder path
94700>        Get PathAtIndex of (phoWorkspace(Self)) sOrgOpenPath 1 to sDataPath
94701>        Move (Replace(sDataPath, sOrgOpenPath, "")) to sOrgOpenPath
94702>        If (Left(sOrgOpenPath, 2) = "\;") Begin
94704>            Move (Replace("\;", sOrgOpenPath, "")) to sOrgOpenPath
94705>        End
94705>        Set psOrgOpenPath to sOrgOpenPath
94706>    End_Procedure
94707>
94707>    Procedure OnWorkspaceOpened
94710>        Forward Send OnWorkspaceOpened
94712>        Send Save_DF_OPEN_PATH
94713>    End_Procedure
94714>
94714>    Procedure Restore_DF_OPEN_PATH
94717>        String sOrgOpenpath
94717>        Get psOrgOpenPath to sOrgOpenpath
94718>        Set_Attribute DF_OPEN_PATH to sOrgOpenPath
94721>    End_Procedure
94722>
94722>    Procedure ResetFilelistPathing
94725>        String sDriverID sServer sFileList sDataPath
94725>        Send Restore_DF_OPEN_PATH
94726>        Close DF_ALL DF_PERMANENT
94727>        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
94728>        Get psServer   of ghoDbUpdateFunctionLibrary to sServer  
94729>        If (sDriverID <> "") Begin
94731>            Logout sDriverID sServer
94732>        End
94732>        Set psDriverID of ghoDbUpdateFunctionLibrary to DATAFLEX_ID
94733>        Set psServer   of ghoDbUpdateFunctionLibrary to ""
94734>        Get private.psFilelistFromOrg to sFileList
94735>        Get ParseFolderName sFileList                      to sDataPath
94736>        If (Right(sDataPath, 1) = "\") Begin
94738>            Move (Left(sDataPath, (Length(sDataPath) -1))) to sDataPath
94739>        End
94739>        Set psDataPath of (phoWorkspace(Self))  to sDataPath
94740>        Set psFileList of (phoWorkspace(Self))  to sFileList
94741>        Set_Attribute DF_FILELIST_NAME          to sFileList
94744>    End_Procedure
94745>
94745>    Function ChangeFilelistPathing String sFileList Returns Boolean
94748>        String sPath sSQLConnectionsIniName sDataPath sDriverID sServer sOrgOpenPath
94748>        Boolean bExists bEmbedded bIsSQLDriver bErr
94748>        Handle hoDbUpdateHandler hoSQLConnectionHandler hoSQLConnectionIniFile
94748>        tSQLConnection SQLConnection
94748>        tSQLConnection SQLConnection
94748>        Integer iRetval iDriverID
94748>
94748>        Move False to Err
94749>        Move (Trim(sFileList)) to sFileList
94750>        Get vFilePathExists sFileList to bExists
94751>        If (bExists = False) Begin
94753>            Send Info_Box "Can't find Filelist.cfg"
94754>            Function_Return False
94755>        End
94755>
94755>        Send Cursor_Wait of Cursor_Control
94756>        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
94757>        Get psServer   of ghoDbUpdateFunctionLibrary to sServer
94758>        Send Restore_DF_OPEN_PATH
94759>        Close DF_ALL DF_PERMANENT
94760>        Logout sDriverID sServer
94761>
94761>        Get ParseFolderName sFileList                      to sDataPath
94762>        If (Right(sDataPath, 1) = "\") Begin
94764>            Move (Left(sDataPath, (Length(sDataPath) -1))) to sDataPath
94765>        End
94765>        Set psDataPath of (phoWorkspace(Self))  to sDataPath
94766>        Set psFileList of (phoWorkspace(Self))  to sFileList
94767>
94767>        // Temporarily "redirect" the Open path to the current Data folder
94767>        Get psOrgOpenPath to sOrgOpenPath
94768>        Set_Attribute DF_OPEN_PATH to (sDataPath + ";" + sOrgOpenPath)
94771>        Set_Attribute DF_FILELIST_NAME to sFileList
94774>        Get UtilIsAnyFilelistEntrySQLtable of ghoDbUpdateFunctionLibrary to sDriverID
94775>        Get IsSQLDriver of ghoDbUpdateFunctionLibrary sDriverID to bIsSQLDriver
94776>        
94776>        // If none of the tables in the Filelist.cfg are SQL, we're done. Let's get out of here!
94776>        If (bIsSQLDriver = False) Begin
94778>            Send Cursor_Ready of Cursor_Control
94779>            Function_Return True
94780>        End
94780>
94780>        // Note: We delete all cache files (*.cch) before attempting to open any
94780>        // tables as a precausion, in case a table has been changed at the SQL back-end,
94780>        // because then the .cch file is out-of-sync with the SQL table.
94780>        Get DriverIndex of ghoDbUpdateFunctionLibrary sDriverID to iDriverID
94781>        Move Err to bErr 
94782>        Send Ignore_Error of Error_Object_Id DFERR_OPERATION_NOT_ALLOWED
94783>        Get_Attribute DF_DRIVER_CACHE_PATH of iDriverID to sPath
94786>        If (sPath = "") Begin 
94788>            If (LastErr = DFERR_OPERATION_NOT_ALLOWED and bErr = False) Begin
94790>                Move False to Err
94791>            End
94791>            Move sDataPath to sPath
94792>        End
94792>        Get vFolderFormat sPath to sPath
94793>        Get vDeleteFile (sPath + "*.cch") to iRetval
94794>
94794>        // Try to make a database connection by reading the SQLConnections.ini file:
94794>        Get vFolderFormat sDataPath to sPath
94795>        Get vParentPath sDataPath   to sPath
94796>        Get vFolderFormat sPath     to sPath
94797>        Move (sPath + "Programs")   to sPath
94798>        Get vFolderFormat sPath     to sPath
94799>        Move CS_SQLIniFileName to sSQLConnectionsIniName
94800>        Get vFilePathExists (sPath + sSQLConnectionsIniName) to bExists
94801>        If (bExists = False) Begin
94803>            Get UtilIsAllFilelistEntriesDataFlexTables of ghoDbUpdateFunctionLibrary to bEmbedded
94804>            If (bEmbedded = False) Begin
94806>                Send Cursor_Ready of Cursor_Control
94807>                Get YesNo_Box ("Couldn't find the DUF SQLConnections.ini file in the workspace Programs folder. Is there a DataFlex DFConnId.ini file in the Data folder that you want to open instead?") to iRetval
94808>                If (iRetval = MBR_Yes) Begin
94810>                    Send Cursor_Wait of Cursor_Control
94811>                    Move "DFConnId.ini" to sSQLConnectionsIniName
94812>                        Send UnRegisterAllConnections of ghoConnection
94813>                        Get AddAllConnections of ghoConnection to bExists
94814>                        Set psIniFileName of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) to sSQLConnectionsIniName
94815>                        Set psIniFilePath of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) to sPath
94816>                        Get SetupSQLConnection of ghoSQLConnectionHandler True False to SQLConnection
94817>                End
94817>            End
94817>        End
94817>        Else Begin
94818>            Get phoDbUpdateHandler to hoDbUpdateHandler
94819>            Get phoSQLConnectionHandler of hoDbUpdateHandler to hoSQLConnectionHandler
94820>            Get phoSQLConnectionIniFile of hoSQLConnectionHandler to hoSQLConnectionIniFile
94821>            Set psIniFilePath of hoSQLConnectionIniFile to sPath
94822>            Set psIniFileName of hoSQLConnectionIniFile to sSQLConnectionsIniName
94823>
94823>            Get SetupSQLConnection of hoSQLConnectionHandler True True to SQLConnection
94824>            Set pSQLConnection     of hoSQLConnectionHandler to SQLConnection
94825>        End
94825>
94825>        Send Cursor_Ready of Cursor_Control
94826>        Function_Return (Err = False)
94827>    End_Function
94828>
94828>    Object oConnection is a cConnection
94830>        Use LoginEncryption.pkg
Including file: LoginEncryption.pkg    (C:\Program Files\DataFlex 24.0\Pkg\LoginEncryption.pkg)
94830>>>Use cLoginEncryption.pkg
94830>>>
94830>>>Object oLoginEncryption is a cLoginEncryption
94832>>>
94832>>>    // this must be created in your appsrc directory and must contain an encryption
94832>>>    // key that is set to psEncryptPassword. It will look something like this
94832>>>    //
94832>>>    // Set psEncryptPassword to "JchUAo7W@r.b{<Yk~OONi0nq=sMi[*Rn[A-`Vo)q"
94832>>>    //  
Including file: LoginEncryptionKey.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\LoginEncryptionKey.inc)
94832>>>>// Studio generated login encryption key
94832>>>>Set psEncryptPassword to "%sLm*XHVF>f0yB.:.PHrBx6L)8x70i7zAN{q._WC"
94833>>>>
94833>>>    
94833>>>    // use this to register this object to your cConnection Object. This object
94833>>>    // must be created after the cConnection object
94833>>>    Move Self to ghoLoginEncryption
94834>>>End_Object
94835>        Use DatabaseLoginDialog.dg
Including file: DatabaseLoginDialog.dg    (C:\Program Files\DataFlex 24.0\Pkg\DatabaseLoginDialog.dg)
94835>>>
94835>>>Use Windows.pkg
94835>>>Use cConnection.pkg
94835>>>Use dfLine.pkg
94835>>>
94835>>>Object oDatabaseLoginDialog is a ModalPanel
94837>>>    Set Label to "Database Login"
94838>>>    Set Location to 2 2
94839>>>    Set Size to 110 211
94840>>>    
94840>>>    Property String psId
94842>>>    Property Boolean pbOk False
94844>>>    Property Boolean pbChanged False
94846>>>    Property Boolean pbAllowRemember True
94848>>>    
94848>>>    // this registers this object with the cConnection object.
94848>>>    Move Self to ghoLoginConnectDialog
94849>>>    
94849>>>    Object oUserIDForm is a Form
94851>>>        Set Label to "User Name"
94852>>>        Set Size to 12 85
94853>>>        Set Location to 34 79
94854>>>        Set Label_Col_Offset to 64
94855>>>        Set peAnchors to anTopLeftRight
94856>>>    End_Object
94857>>>    
94857>>>    Object oPwdForm is a Form
94859>>>        Set Size to 12 85
94860>>>        Set Location to 49 79
94861>>>        Set Label_Col_Offset to 64
94862>>>        Set Password_State to True
94863>>>        Set peAnchors to anTopLeftRight
94864>>>        Set Label to "Password"
94865>>>    End_Object
94866>>>    
94866>>>    Object oTrustedConnection is a CheckBox
94868>>>        Set Size to 10 50
94869>>>        Set Location to 65 79
94870>>>        Set Label to "Trusted Connection"
94871>>>    End_Object
94872>>>    
94872>>>    Object oRemember is a CheckBox
94874>>>        Set Size to 10 50
94875>>>        Set Location to 79 14
94876>>>        Set Label to "Remember and don't ask again"
94877>>>        Set Checked_State to True
94878>>>    End_Object
94879>>>    
94879>>>    Object oLogin_btn is a Button
94881>>>        Set Label to "&Login"
94882>>>        Set Location to 92 102
94883>>>        Set peAnchors to anBottomRight
94884>>>        Set Default_State to True
94885>>>        
94885>>>        Procedure OnClick
94888>>>            Boolean bTrust
94888>>>            String sUser sPwd sConn sErr sId
94888>>>            Integer iError
94888>>>            Get psId to sId
94889>>>            Get Value of oUserIDForm to sUser
94890>>>            Get Value of oPwdForm to sPwd
94891>>>            Get Checked_State of oTrustedConnection to bTrust
94892>>>            
94892>>>            Get LoginConnectIdNewCredentials of ghoConnection sId sUser sPwd bTrust to iError
94893>>>            If (iError=0) Begin
94895>>>                Set pbOk to True
94896>>>                Set pbChanged to True
94897>>>                Send Close_Panel
94898>>>            End
94898>>>>
94898>>>            Else Begin
94899>>>                Get psErrorText of ghoConnection to sErr
94900>>>                Send UserError sErr "Login Error"
94901>>>            End
94901>>>>
94901>>>        End_Procedure
94902>>>    End_Object
94903>>>    
94903>>>    Object oCancel_btn is a Button
94905>>>        Set Label to "&Cancel"
94906>>>        Set Location to 92 157
94907>>>        Set peAnchors to anBottomRight
94908>>>        
94908>>>        Procedure OnClick
94911>>>            Send Close_Panel
94912>>>        End_Procedure
94913>>>    End_Object
94914>>>    
94914>>>    Object oConnectionIdInfo is a TextBox
94916>>>        Set Size to 10 50
94917>>>        Set Location to 4 14
94918>>>        Set Label to 'Connection Id='
94919>>>    End_Object
94920>>>    
94920>>>    Object oConnectionServerInfo is a TextBox
94922>>>        Set Size to 10 50
94923>>>        Set Location to 16 14
94924>>>        Set Label to 'Server'
94925>>>    End_Object
94926>>>    
94926>>>    Object oLineControl1 is a LineControl
94928>>>        Set Size to 2 202
94929>>>        Set Location to 29 5
94930>>>    End_Object
94931>>>    
94931>>>    Function LoginConnectIdDialog String sId Returns Boolean
94934>>>        Boolean bOk bChanged bTrusted bAllowRemember bRemember
94934>>>        String sUser sPwd sDescription
94934>>>        tConnection Connect
94934>>>        tConnection Connect
94934>>>        
94934>>>        Get pbAllowRemember to bAllowRemember
94935>>>        
94935>>>        
94935>>>        If not bAllowRemember Begin
94937>>>            Set Enabled_State of oRemember to bRemember
94938>>>            Set Visible_State of oRemember to bRemember
94939>>>        End
94939>>>>
94939>>>        
94939>>>        Get ConnectionIdInfo of ghoConnection sId to Connect
94940>>>        Set Value of oConnectionIdInfo to ("Connection ID="+Connect.sId)
94941>>>        Set Value of oConnectionServerInfo to Connect.sString
94942>>>        
94942>>>        Set psId to sId
94943>>>        Set pbOk to False
94944>>>        Set pbChanged to False
94945>>>        Set Value of oUserIDForm to Connect.sUID
94946>>>        Set Value of oPwdForm to ""
94947>>>        
94947>>>        Send Popup
94948>>>        
94948>>>        Get pbOk to bOk
94949>>>        Get pbChanged to bChanged
94950>>>        If (bChanged and bOk) Begin
94952>>>            If bAllowRemember Begin
94954>>>                Get Checked_State of oRemember to bRemember
94955>>>                If bRemember Begin
94957>>>                    Get Checked_State of oTrustedConnection to bTrusted
94958>>>                    If not (bTrusted) Begin
94960>>>                        Get Value of oUserIDForm to sUser
94961>>>                        Get Value of oPwdForm to sPwd
94962>>>                    End
94962>>>>
94962>>>                    Get StoreConnectionIdCredentials of ghoConnection sId sUser sPwd bTrusted to bOk
94963>>>                End
94963>>>>
94963>>>            End
94963>>>>
94963>>>        End
94963>>>>
94963>>>        Function_Return bOk
94964>>>    End_Function
94965>>>    
94965>>>    
94965>>>    On_Key Key_Alt+Key_O Send KeyAction of oLogin_btn
94966>>>    On_Key Key_Alt+Key_L Send KeyAction of oCancel_btn
94967>>>End_Object
94968>>>
94968>    End_Object
94969>
94969>    Procedure End_Construct_Object
94972>        String sCompileTime  
94972>        Integer iPos
94972>        
94972>        Forward Send End_Construct_Object
94974>        Direct_Input "resource: res_CompileHeader"
94975>        Readln sCompileTime
94976>        Move (Pos('"', sCompileTime)) to iPos
94977>        If (iPos <> 0) Begin
94979>            Move (Mid(sCompileTime, Length(sCompileTime), (iPos + 1))) to sCompileTime
94980>            Move (Replaces('"', sCompileTime, '')) to sCompileTime
94981>            Set psCompileDateAndTime to sCompileTime
94982>        End
94982>        Close_Input
94983>    End_Procedure
94984>
94984>End_Object
94985>
94985>Object oDbUpdateHandler is a cDbUpdateHandler
94987>    Set piDbVersionFileNumber  to 1
94988>    Set piDbVersionFieldNumber to 1
94989>    Set phoDbUpdateHandler of ghoApplication to Self
94990>
94990>    Procedure OnPreUpdate
94993>        String sVersionInfo                     // DF 18.2 MSSQLDRV
94993>//        Get MinMSSQLDRV_And_ClientVersion "6.1.0.32"  SQLSERVER2012CLIENT True True to sVersionInfo
94993>                                                // DF 19.1 MSSQLDRV
94993>        Get MinMSSQLDRV_And_ClientVersion "6.3.0.13" SQLSERVER2016CLIENT True True to sVersionInfo
94994>    End_Procedure  
94995>
94995>    Object oDbUpdateVersion1_0 is a cDbUpdateVersion
94997>        Set pnVersionNumber to 1.0
94998>//        Procedure OnUpdate
94998>//            Boolean bOK 
94998>//        End_Procedure
94998>    End_Object
94999>
94999>End_Object
95000>
95000>Object oToolTipController is a cToolTipController
95002>    Move Self to ghoToolTipController
95003>    Set pbBalloonStyle to False
95004>    Set piIcon to TTI_INFO
95005>    Set psTitle to "Information"
95006>    Set piMaxWidth to 400
95007>    Set piDurationPopup to 14000    // 14 seconds, needed for long tooltips.
95008>End_Object
95009>
95009>Use oEditContextMenu.pkg
Including file: oEditContextMenu.pkg    (C:\Program Files\DataFlex 24.0\Pkg\oEditContextMenu.pkg)
95009>>>Use cCJStandardMenuItemClasses.pkg
95009>>>
95009>>>Object oEditContextMenu is a cCJContextMenu
95011>>>    
95011>>>    Move Self to Default_Form_Floating_Menu_ID
95012>>>    
95012>>>    Object oUndoMenuItem is a cCJUndoMenuItem
95014>>>    End_Object
95015>>>    
95015>>>    Object oCutMenuItem is a cCJCutMenuItem
95017>>>        Set pbControlBeginGroup to True
95018>>>    End_Object
95019>>>    
95019>>>    Object oCopyMenuItem is a cCJCopyMenuItem
95021>>>    End_Object
95022>>>
95022>>>    Object oPasteMenuItem is a cCJPasteMenuItem
95024>>>    End_Object
95025>>>
95025>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
95027>>>    End_Object
95028>>>
95028>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
95030>>>        Set pbControlBeginGroup to True
95031>>>    End_Object
95032>>>
95032>>>End_Object
95033>>>
95033>Use oDEOEditContextMenu17.pkg
Including file: oDEOEditContextMenu17.pkg    (C:\Program Files\DataFlex 24.0\Pkg\oDEOEditContextMenu17.pkg)
95033>>>Use Windows.pkg
95033>>>Use cCJStandardMenuItemClasses.pkg
95033>>>Use cCJDeoMenuItemClasses.pkg
95033>>>
95033>>>
95033>>>Object oDEOEditContextMenu17 is a cCJContextMenu
95035>>>    
95035>>>    Move Self to Default_dbFloating_Menu_ID
95036>>>    
95036>>>    Object oUndoMenuItem is a cCJUndoMenuItem
95038>>>    End_Object
95039>>>    
95039>>>    Object oCutMenuItem is a cCJCutMenuItem
95041>>>        Set pbControlBeginGroup to True
95042>>>    End_Object
95043>>>    
95043>>>    Object oCopyMenuItem is a cCJCopyMenuItem
95045>>>    End_Object
95046>>>
95046>>>    Object oPasteMenuItem is a cCJPasteMenuItem
95048>>>    End_Object
95049>>>
95049>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
95051>>>    End_Object
95052>>>
95052>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
95054>>>        Set pbControlBeginGroup to True
95055>>>    End_Object
95056>>>
95056>>>    Object oPromptMenuItem is a cCJPromptMenuItem
95058>>>        Set pbControlBeginGroup to True
95059>>>    End_Object
95060>>>
95060>>>    Object oFindNextMenu is a cCJFindNextMenuItem
95062>>>        Set pbControlBeginGroup to True
95063>>>    End_Object
95064>>>
95064>>>    Object oFindPreviousMenu is a cCJFindPreviousMenuItem
95066>>>    End_Object
95067>>>
95067>>>    Object oClearMenuItem is a cCJClearMenuItem
95069>>>        Set pbControlBeginGroup to True
95070>>>    End_Object
95071>>>
95071>>>    Object oClearAllMenu is a cCJClearAllMenuItem
95073>>>    End_Object
95074>>>
95074>>>    Object oSaveMenu is a cCJSaveMenuItem
95076>>>    End_Object
95077>>>    
95077>>>    Object oDeleteMenu is a cCJDeleteMenuItem
95079>>>    End_Object
95080>>>
95080>>>    Object oRememberitem is a cCJRememberFieldMenuItem
95082>>>        Set pbControlBeginGroup to True
95083>>>    End_Object
95084>>>
95084>>>    Object oRetainItem is a cCJRememberLastFieldMenuItem
95086>>>    End_Object
95087>>>
95087>>>    Object oUnRememberitem is a cCJUnRememberFieldMenuItem
95089>>>    End_Object
95090>>>
95090>>>    Object oCJClearAllDynamicDefaults is a cCJUnRememberFieldAllMenuItem
95092>>>    End_Object
95093>>>
95093>>>End_Object
95094>Use CaptureWindow.pkg
Including file: CaptureWindow.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\CaptureWindow.pkg)
95094>>>Use CaptureWindow.h
Including file: CaptureWindow.h    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\CaptureWindow.h)
95094>>>>>Define C_CaptureFolderKey  for "CaptureFolder"
95094>>>>>Define C_CaptureFolderName for "Capture"
95094>>>>>Define SRCCOPY           for |CI$00CC0020
95094>>>>>Define CF_BITMAP         for |CI2
95094>>>>>
95094>>>>>Enum_List   //Enum DEVCAP_INDEX As Integer  
95094>>>>>    Define DRIVERVERSION for 0 
95094>>>>>    Define TECHNOLOGY for 2 
95094>>>>>    Define HORZSIZE for 4 
95094>>>>>    Define VERTSIZE for 6 
95094>>>>>    Define HORZRES for 8 
95094>>>>>    Define VERTRES for 10 
95094>>>>>    Define BITSPIXEL for 12 
95094>>>>>    Define PLANES for 14 
95094>>>>>    Define NUMBRUSHES for 16 
95094>>>>>    Define NUMPENS for 18 
95094>>>>>    Define NUMMARKERS for 20 
95094>>>>>    Define NUMFONTS for 22 
95094>>>>>    Define NUMCOLORS for 24 
95094>>>>>    Define PDEVICESIZE for 26 
95094>>>>>    Define CURVECAPS for 28 
95094>>>>>    Define LINECAPS for 30 
95094>>>>>    Define POLYGONALCAPS for 32 
95094>>>>>    Define TEXTCAPS for 34 
95094>>>>>    Define CLIPCAPS for 36 
95094>>>>>    Define RASTERCAPS for 38 
95094>>>>>    Define ASPECTX for 40 
95094>>>>>    Define ASPECTY for 42 
95094>>>>>    Define ASPECTXY for 44 
95094>>>>>    Define SHADEBLENDCAPS for 45 
95094>>>>>    Define SIZEPALETTE for 104 
95094>>>>>    Define NUMRESERVED for 106 
95094>>>>>    Define COLORRES for 108 
95094>>>>>    Define PHYSICALWIDTH for 110 
95094>>>>>    Define PHYSICALHEIGHT for 111 
95094>>>>>    Define PHYSICALOFFSETX for 112 
95094>>>>>    Define PHYSICALOFFSETY for 113 
95094>>>>>    Define SCALINGFACTORX for 114 
95094>>>>>    Define SCALINGFACTORY for 115 
95094>>>>>    Define VREFRESH for 116 
95094>>>>>    Define DESKTOPVERTRES for 117 
95094>>>>>    Define DESKTOPHORZRES for 118 
95094>>>>>    Define BLTALIGNMENT for 119 
95094>>>>>End_Enum_List  
95094>>>>>
95094>>>>>Enum_List   //Enum compression
95094>>>>>    Define bi_rgb for 0       //- none (also identified by bi_rgb)
95094>>>>>    Define bi_rle4 for 1      //- rle 8-bit / pixel (also identified by bi_rle4)
95094>>>>>    Define bi_rle8 for 2      //- rle 4-bit / pixel (also identified by bi_rle8)
95094>>>>>    Define bi_bitfields for 3 //- bitfields (also identified by bi_bitfields)
95094>>>>>End_Enum_List  
95094>>>>>
95094>>>>>
95094>>>>>
95094>>>>>Define DIB_PAL_COLORS for 1
95094>>>>>Define DIB_RGB_COLORS for 0
95094>>>>>
95094>>>>>Struct RECT_TYPE
95094>>>>>   Integer ileft
95094>>>>>   Integer itop
95094>>>>>   Integer iright
95094>>>>>   Integer ibottom
95094>>>>>End_Struct
95094>>>>>
95094>>>>>Struct BITMAPINFOHEADER
95094>>>>>    DWord biSize                    // DWORD=integer
95094>>>>>    Integer biWidth                    // LONG =integer
95094>>>>>    Integer biHeight                   // LONG 
95094>>>>>    Short biPlanes                   // WORD =short
95094>>>>>    Short biBitCount                 // WORD 
95094>>>>>    DWord biCompression             // DWORD
95094>>>>>    DWord biSizeImage               // DWORD
95094>>>>>    Integer biXPelsPerMeter            // LONG 
95094>>>>>    Integer biYPelsPerMeter            // LONG 
95094>>>>>    DWord biClrUsed                 // DWORD
95094>>>>>    DWord biClrImportant            // DWORD
95094>>>>>End_Struct
95094>>>>>
95094>>>>>Struct RGBQUAD
95094>>>>>  CHAR rgbBlue            //BYTE=CHAR
95094>>>>>  CHAR rgbGreen
95094>>>>>  CHAR rgbRed
95094>>>>>  CHAR rgbReserved
95094>>>>>End_Struct
95094>>>>>
95094>>>>>Struct BITMAPINFO 
95094>>>>>    BITMAPINFOHEADER bmiHeader 
95094>>>>>    BITMAPINFOHEADER bmiHeader 
95094>>>>>    RGBQUAD[] bmiColors
95094>>>>>    RGBQUAD[] bmiColors
95094>>>>>End_Struct
95094>>>>>
95094>>>>>Struct BITMAPFILEHEADER
95094>>>>>    Short bfType         //WORD  //BM (0x4D42)
95094>>>>>    DWord bfSize        //DWORD
95094>>>>>    Short bfReserved1    //WORD 
95094>>>>>    Short bfReserved2    //WORD 
95094>>>>>    DWord bfOffBits     //DWORD
95094>>>>>End_Struct
95094>>>>>
95094>>>>>Struct BITMAP 
95094>>>>>    Integer   bmType
95094>>>>>    Integer   bmWidth
95094>>>>>    Integer   bmHeight
95094>>>>>    Integer   bmWidthBytes
95094>>>>>    Short   bmPlanes
95094>>>>>    Short   bmBitsPixel
95094>>>>>    Pointer bmBits
95094>>>>>end_struct
95094>>>>>
95094>>>>>Struct DIBSECTION 
95094>>>>>    BITMAP           dsBm
95094>>>>>    BITMAP           dsBm
95094>>>>>    BITMAPINFOHEADER dsBmih
95094>>>>>    BITMAPINFOHEADER dsBmih
95094>>>>>    DWord[3]         dsBitfields
95094>>>>>  Handle           dshSection
95094>>>>>  DWord            dsOffset
95094>>>>>End_Struct
95094>>>Use vWin32fh.pkg
95094>>>Use cApplication.pkg
95094>>>Use cIniFile.pkg
95094>>>
95094>>>Define CS_CaptureSection for "Capture"
95094>>>Define CS_CaptureFolder  for "Capture Folder"
95094>>>
95094>>>//   Declare Function GetActiveWindow% Lib "User" ()
95094>>>External_Function GetActiveWindow "GetActiveWindow" User32.dll ;    Returns Handle
95095>>>
95095>>>//   Declare Function GetDesktopWindow% Lib "User" ()
95095>>>
95095>>>//   Declare Sub GetWindowRect Lib "User" (ByVal Hwnd%, lpRect As RECT_Type)
95095>>>
95095>>>//   Declare Function GetDC% Lib "User" (ByVal Hwnd%)
95095>>>
95095>>>//   Declare Function CreateCompatibleDC% Lib "GDI" (ByVal hdc%)
95095>>>
95095>>>//   Declare Function CreateCompatibleBitmap% Lib "GDI" (ByVal hdc%, ByVal nWidth%, ByVal nHeight%)
95095>>>
95095>>>//   Declare Function SelectObject% Lib "GDI" (ByVal hdc%, ByVal hObject%)
95095>>>
95095>>>//   Declare Function BitBlt% Lib "GDI" (ByVal hDestDC%, ByVal X%, ByVal Y%, ByVal nWidth%, ;
95095>>>//                     ByVal nHeight%, ByVal hSrcDC%, ByVal XSrc%, ByVal YSrc%, ByVal dwRop&)
95095>>>
95095>>>//   Declare Function OpenClipboard% Lib "User" (ByVal Hwnd%)
95095>>>External_Function OpenClipboard "OpenClipboard" User32.dll  ;    Handle hWnd  Returns Integer
95096>>>
95096>>>//   Declare Function EmptyClipboard% Lib "User" ()
95096>>>External_Function EmptyClipboard "EmptyClipboard" User32.dll ;    Returns Integer
95097>>>
95097>>>//   Declare Function SetClipboardData% Lib "User" (ByVal wFormat%, ByVal hMem%)
95097>>>External_Function SetClipboardData "SetClipboardData" User32.dll ;    Integer wFormat Handle hMem Returns Integer
95098>>>
95098>>>//   Declare Function CloseClipboard% Lib "User" ()
95098>>>External_Function CloseClipboard "CloseClipboard" User32.dll ;    Returns Integer
95099>>>
95099>>>//   Declare Function ReleaseDC% Lib "User" (ByVal Hwnd%, ByVal hdc%)
95099>>>
95099>>>//   Declare Function DeleteDC% Lib "GDI" (ByVal hdc%)
95099>>>
95099>>>    External_Function CreateDIBSection "CreateDIBSection" Gdi32.dll ;        Handle hdc ;     // Handle to the device context        pointer pbmi ; //puntero a BITMAPINFO        UInteger iUsage ;        Pointer ppvBits ;        Handle hSection ;        DWord dwOffset ;        Returns Handle // HBITMAP
95100>>>
95100>>>    External_Function GetDIBits "GetDIBits" Gdi32.dll ;        handle hdc ;        handle hbmp ;        Uinteger uStartScan ;        uinteger cScanLines ;        pointer lpvBits ;        pointer lpbi ;  // LPBITMAPINFO        uinteger uUsage ;        Returns Integer
95101>>>
95101>>>External_Function Createfile "CreateFileA" kernel32.dll ;    Pointer lpFile ;      //filename    DWord dwDesAccess ;   // access mode    DWord dwShare ;       // share mode    Pointer lpSecAtt ;    // SD    DWord dwCrDisp ;      // how to create    DWord dwFlags ;       // file attributes    Handle hTempFile ;   // handle to template fil    Returns Integer      //Returns handle that can be used to access the object
95102>>>
95102>>>    External_Function WriteFile "WriteFile" Kernel32.dll ;        Handle hFile ;     // Handle to the file        Pointer lpBuffer ;  // data buffer        DWord nNumberOfBytesToWrite ;        Pointer lpNumberOfBytesWritten ;        Pointer lpOverlapped ;        Returns Boolean
95103>>>
95103>>>External_Function CloseHandle "CloseHandle" kernel32.dll ;    Handle hObject ;        // handle to object    Returns Integer
95104>>>
95104>>>
95104>>>     External_Function GetDIBColorTable "GetDIBColorTable" Gdi32.dll ;        handle hdc ;        uinteger uStartIndex ;        uinteger cEntries ;        pointer pColors ;        Returns Integer
95105>>>
95105>>>     External_Function GetObject "GetObjectA" Gdi32.dll ;        handle hgdiobj ;        integer cbBuffer ;        pointer lpvObject ;        Returns Integer
95106>>>
95106>>>
95106>>>// Check if focus is what you search or a child of it
95106>>>Function Find_Parent Global Handle hofocus Handle hofind Returns Boolean
95108>>>    If (hoFocus = hoFind) Begin
95110>>>        Function_Return True
95111>>>    End
95111>>>>
95111>>>   While (hofocus>Desktop)
95115>>>        If (Parent(hoFocus) = hoFind) Begin
95117>>>            Function_Return True
95118>>>        End
95118>>>>
95118>>>      Move (Parent(hofocus)) to hofocus
95119>>>   Loop
95120>>>>
95120>>>   Function_Return False
95121>>>End_Function
95122>>>
95122>>>// Returns the view object (outmost container) of the currently focused object.
95122>>>Function Current_View Global Returns Integer
95124>>>    Integer Obj#
95124>>>
95124>>>    Move (Focus(Self)) to Obj#
95125>>>    Repeat
95125>>>>
95125>>>        Move (Parent(Obj#)) to Obj#
95126>>>    Until (Scope_State(Obj#) = True)
95128>>>
95128>>>    Function_Return Obj#
95129>>>End_Function
95130>>>
95130>>>// Helper function. See also main message TakeSnapshot.
95130>>>// Capture an bitmap image of the current object and saves it to disk.
95130>>>Function CaptureImage Global Handle hVent String sFile Returns Integer
95132>>>    Handle hwnd deskhwnd hfile hnulo
95132>>>    Handle hdcScreen
95132>>>    Handle hdcWindow
95132>>>    Handle hdcMemDC
95132>>>    Handle hbmScreen
95132>>>    BITMAP bmpScreen
95132>>>    BITMAP bmpScreen
95132>>>    BITMAPFILEHEADER   bmfHeader
95132>>>    BITMAPFILEHEADER   bmfHeader
95132>>>    BITMAPINFOHEADER   bi
95132>>>    BITMAPINFOHEADER   bi
95132>>>    RECT_Type rcClient
95132>>>    RECT_Type rcClient
95132>>>    Integer junk fwidth fheight iret
95132>>>    DWord dwSizeofDIB dwBytesWritten dwBmpSize
95132>>>    Boolean baux
95132>>>    Pointer lpbitmap pnulo
95132>>>
95132>>>    //---------------------------------------------------
95132>>>    // Get window handle to Windows and our View
95132>>>    //---------------------------------------------------
95132>>>    Move (GetDesktopWindow()) to DeskHwnd
95133>>>    Get Window_Handle of hVent to hwnd
95134>>>
95134>>>    // Retrieve the handle to a display device context for the client
95134>>>    // area of the window.
95134>>>    Move (GetDC(hwnd)) to hdcScreen //what you want to paint (getdc(null)=full screen)
95135>>>    Move (GetDC(deskhwnd)) to hdcWindow //context = GetDC(hWnd);
95136>>>
95136>>>    // Create a compatible DC which is used in a BitBlt from the window DC
95136>>>    Move (CreateCompatibleDC(hdcWindow)) to hdcMemDC
95137>>>    Move 0 to iret
95138>>>    If (hdcMemDC) Begin
95140>>>       // Get the client area for size calculation
95140>>>       Move (GetWindowRect(hwnd,AddressOf(rcClient))) to junk
95141>>>       Move (rcClient.iright-rcClient.ileft) to fwidth
95142>>>       Move (rcClient.ibottom-rcClient.itop) to fheight
95143>>>
95143>>>       // Create a compatible bitmap from the Window DC
95143>>>       Move (CreateCompatibleBitmap(hdcWindow, fwidth, fheight)) to hbmScreen
95144>>>
95144>>>       If hbmScreen Begin
95146>>>          // Select the compatible bitmap into the compatible memory DC.
95146>>>          Move (SelectObject(hdcMemDC,hbmScreen)) to junk
95147>>>
95147>>>          // Bit block transfer into our compatible memory DC.
95147>>>          If (BitBlt(hdcMemDC,0,0, fwidth, fheight,hdcWindow, rcClient.ileft,rcClient.itop,SRCCOPY)) Begin
95149>>>             // Get the BITMAP from the HBITMAP
95149>>>             Move (GetObject(hbmScreen,SizeOfType(BITMAP),AddressOf(bmpScreen))) to junk
95150>>>             Move (SizeOfType(BITMAPINFOHEADER)) to bi.biSize
95151>>>             Move bmpScreen.bmWidth to bi.biWidth
95152>>>             Move bmpScreen.bmHeight to bi.biHeight
95153>>>             Move 1 to bi.biPlanes
95154>>>             Move 32 to bi.biBitCount
95155>>>             Move bi_rgb to bi.biCompression
95156>>>             Move 0 to bi.biSizeImage
95157>>>             Move 0 to bi.biXPelsPerMeter
95158>>>             Move 0 to bi.biYPelsPerMeter
95159>>>             Move 0 to bi.biClrUsed
95160>>>             Move 0 to bi.biClrImportant
95161>>>
95161>>>             Move (((bmpScreen.bmWidth * bi.biBitCount + 31) / 32) * 4 * bmpScreen.bmHeight ) to dwBmpSize
95162>>>             Move (Alloc(dwBmpSize+100)) to lpbitmap
95163>>>
95163>>>             // Gets the "bits" from the bitmap and copies them into a buffer
95163>>>             // which is pointed to by lpbitmap.
95163>>>             Move (GetDIBits(hdcWindow, hbmScreen, 0,bmpScreen.bmHeight, ;                 lpbitmap,AddressOf(bi), DIB_RGB_COLORS) ) to junk
95164>>>
95164>>>             // A file is created, this is where we will save the screen capture.
95164>>>             Move (CreateFile(AddressOf(sFile),GENERIC_WRITE, 0, ;                 hnulo,CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL, hnulo)) to hfile
95165>>>
95165>>>             // Add the size of the headers to the size of the bitmap to get the total file size
95165>>>             Move (dwBmpSize + SizeOfType(BITMAPFILEHEADER) + SizeOfType(BITMAPINFOHEADER)) to dwSizeofDIB
95166>>>
95166>>>             // Offset to where the actual bitmap bits start.
95166>>>             Move (SizeOfType(BITMAPFILEHEADER) + SizeOfType(BITMAPINFOHEADER)) to bmfHeader.bfOffBits
95167>>>
95167>>>             // Size of the file
95167>>>             Move dwSizeofDIB to bmfHeader.bfSize
95168>>>
95168>>>             // bfType must always be BM for Bitmaps
95168>>>             Move 19778 to bmfHeader.bfType //= 0x4D42; //BM   19778
95169>>>
95169>>>             Move 0 to dwBytesWritten
95170>>>             Move (WriteFile(hFile, AddressOf(bmfHeader), SizeOfType(BITMAPFILEHEADER), AddressOf(dwBytesWritten), pnulo)) to baux
95171>>>             Move (WriteFile(hFile, AddressOf(bi), SizeOfType(BITMAPINFOHEADER), AddressOf(dwBytesWritten), pnulo)) to baux
95172>>>             Move (WriteFile(hFile, lpbitmap, dwBmpSize, AddressOf(dwBytesWritten), pnulo))  to baux
95173>>>
95173>>>             //Close the handle for the file that was created
95173>>>             Move (CloseHandle(hFile)) to junk
95174>>>
95174>>>             // Write image from clipboard
95174>>>             Move (OpenClipboard(DeskHwnd)) to junk
95175>>>             Move (EmptyClipboard()) to junk
95176>>>             Move (SetClipboardData(CF_BITMAP,hbmScreen)) to junk
95177>>>             Move (CloseClipboard()) to junk
95178>>>
95178>>>             Move (DeleteObject(hbmScreen)) to baux
95179>>>             Move (Free(lpbitmap)) to baux
95180>>>             Move 1 to iret
95181>>>          End
95181>>>>
95181>>>       End
95181>>>>
95181>>>    End
95181>>>>
95181>>>    Move (ReleaseDC(hWnd, hdcMemDC)) to junk
95182>>>    Move (ReleaseDC(hwnd,hdcScreen)) to junk
95183>>>    Move (ReleaseDC(deskhwnd,hdcWindow)) to junk
95184>>>
95184>>>    Function_Return iret
95185>>>End_Function
95186>>>
95186>>>// *** MAIN MESSAGE ***
95186>>>// Takes a snapshot of the currently active view and saves it as a bitmap file,
95186>>>// in the current workspace's Capture folder. If that folder doesn't exist,
95186>>>// it will be created.
95186>>>// Pass False to take snapshot of the currently active view, or pass True
95186>>>// to take snapshot of the entire application. 
95186>>>// Pass True for the second boolean parameter (bShowSnapShotImage) to
95186>>>// show the file in the containing folder with Windows Explorer.
95186>>>Procedure TakeSnapshot Global Boolean bApplicationShot Boolean bSelectInExplorer
95188>>>    Integer iRetval
95188>>>    String sPath sToday sFileName
95188>>>    Handle hObjTo
95188>>>
95188>>>    Sysdate sToday
95189>>>    Move (Replace("/", sToday, "-")) to sToday
95190>>>
95190>>>    // Select the view to capture
95190>>>    If (bApplicationShot = False) Begin
95192>>>        Get Current_View to hObjTo
95193>>>    End
95193>>>>
95193>>>    Else Begin
95194>>>        Move (Parent(ghoCommandBars)) to hObjTo
95195>>>    End
95195>>>>
95195>>>
95195>>>    Get SnapShotFolder to sPath
95196>>>    Get vFolderFormat sPath to sPath
95197>>>
95197>>>    Move (sPath + (Object_Label(hObjTo)) + sToday + ".bmp") to sFileName
95198>>>    Get CaptureImage hObjTo sFileName to iRetval
95199>>>    If (iRetval <> 0 and bSelectInExplorer = True) Begin
95201>>>        Move ("/select, " + sFileName) to sFileName
95202>>>        Send vShellExecute "open" "explorer.exe" sFileName ""
95203>>>    End
95203>>>>
95203>>>End_Procedure
95204>>>
95204>>>// Function to get the folder where snapshots are saved.
95204>>>// Returns the full folder path. If the folder doesn't exist
95204>>>// it will be created.
95204>>>// Returns: The full snapshot folder path.
95204>>>Function SnapShotFolder Global Returns String
95206>>>    String sHome sPath sWorkSpaceFile
95206>>>    Boolean bExist
95206>>>    Integer iRetval
95206>>>    Handle hoIniFile
95206>>>
95206>>>    Get psWorkspaceWSFile of (phoWorkspace(ghoApplication)) to sWorkSpaceFile
95207>>>    Get psHome of (phoWorkspace(ghoApplication)) to sHome
95208>>>    Get vFolderFormat sHome to sHome
95209>>>
95209>>>    Get Create (RefClass(cIniFile)) to hoIniFile
95210>>>    Set psFileName of hoIniFile to sWorkSpaceFile
95211>>>    Get ReadString of hoIniFile CS_CaptureSection CS_CaptureFolder CS_CaptureSection to sPath
95212>>>    Send Destroy of hoIniFile
95213>>>
95213>>>    If (Pos("..\", sPath)) Begin
95215>>>        Move (Replace("..\", sPath, "")) to sPath
95216>>>        Move (sHome + sPath) to sPath
95217>>>    End
95217>>>>
95217>>>    Else If (Pos(".\", sPath)) Begin
95220>>>        Move (Replace(".\", sPath, "")) to sPath
95221>>>        Move (sHome + sPath) to sPath
95222>>>    End
95222>>>>
95222>>>    Else Begin
95223>>>        Move (sHome + sPath) to sPath
95224>>>    End
95224>>>>
95224>>>
95224>>>    Get vFolderExists sPath to bExist
95225>>>    If (bExist = False) Begin
95227>>>        If (sPath = "") Begin
95229>>>            Get vSHGetFolderPath vCSIDL_MYPICTURES to sPath  // E.g. "C:\Documents and Settings\username\My Documents\My Pictures"
95230>>>        End
95230>>>>
95230>>>        Else Begin
95231>>>            Get vCreateDirectory sPath to iRetval
95232>>>            If (iRetval <> 0) Begin
95234>>>                Send Info_Box ("Could not create the 'Capture' folder for saving shapshots to." * sPath)
95235>>>                Function_Return ""
95236>>>            End
95236>>>>
95236>>>        End
95236>>>>
95236>>>    End
95236>>>>
95236>>>
95236>>>    Function_Return sPath
95237>>>End_Function
95238>
95238>Object oMain is a Panel
95240>    Set Label to (psProduct(ghoApplication))
95241>    Set Location to 4 3
95242>    Set Size to 350 602
95243>    Set piMinSize to 400 515
95244>    Set Icon to "DUFUpdateCodeGenerator1.ico"
95245>
95245>    Object oCommandBarSystem is a cCJCommandBarSystem
95247>        Set pbTimerUpdate to True
95248>            Set pbAutoResizeIcons to True
95249>            Set pbTabbedWorkspaces to True
95250>            Set peVisualTheme to xtpThemeOffice2013Publisher
95251>            Set pbLargeIcons to True
95252>
95252>        Procedure OnCreateCommandBars
95255>            Integer eTheme
95255>            Forward Send OnCreateCommandBars
95257>
95257>            Get ReadDword of ghoApplication CS_PropertiesKeyWord CS_ThemeKeyWord xtpThemeOffice2013Publisher to eTheme
95258>            Send SetTheTheme eTheme
95259>            Send DisplayTabWorkspace
95260>        End_Procedure
95261>
95261>        Procedure DisplayTabWorkspace
95264>            Variant vTab vPaintManager
95264>            Handle hoTab hoPaintManager hoOptions
95264>            Integer iSize
95264>
95264>            If (not(IsComObjectCreated(Self))) Begin
95266>                Procedure_Return
95267>            End
95267>
95267>            Get OptionsObject to hoOptions
95268>
95268>            // Create the tab workspace object. It will get created for the Client_Area so
95268>            // each view will be displayd on a separate tab-page (instead of the standard VDF MDI-interface)
95268>            Get Create (RefClass(cCJTabWorkspace)) to hoTab
95269>            Get ComShowTabWorkspace True to vTab
95270>            // Connect the CodeJock side to the DataFlex proxy object.
95270>            Set pvComObject  of hoTab to vTab
95271>
95271>            // We don't allow to close tabs as we have no menu system.
95271>            Set ComFlags of hoTab to xtpWorkspaceHideAll //xtpWorkspaceHideClose //xtpWorkspaceShowCloseTab
95272>            Send ComEnableGroups of hoTab
95273>
95273>            // Create a paint manager object that is needed to set some
95273>            // of the tab-workspace properties.
95273>            Get Create (RefClass(cCJTabPaintManager)) to hoPaintManager
95274>            Get ComPaintManager of hoTab          to vPaintManager
95275>            Set pvComObject     of hoPaintManager to vPaintManager
95276>
95276>            // Sets the tab-pages to display on the left side, instead of at the top:
95276>            Set ComPosition     of hoPaintManager to xtpTabPositionLeft
95277>
95277>            // This will truncate the middle part of long items
95277>            Set ComDrawTextPathEllipsis of hoPaintManager to True
95278>            Set ComLayout               of hoPaintManager to xtpTabLayoutMultiRow
95279>
95279>            Move 32 to iSize
95280>            Send ComSetIconSize     of hoOptions False iSize iSize  // Set icon size for Toolbar buttons.
95281>            Get Create (RefClass(cCJPaintManager)) to hoPaintManager
95282>            Get ComPaintManager of hoPaintManager  to vPaintManager
95283>            Set pvComObject     of hoPaintManager  to vPaintManager
95284>            Set ComAutoResizeIcons of hoPaintManager to True
95285>            Send Destroy of hoPaintManager
95286>            Send ComRecalcLayout
95287>            Send Destroy of hoTab
95288>        End_Procedure
95289>
95289>            Procedure OnCreateTabbedWorkspace Handle hoTabWorkspace Handle hoTabPaintManager
95292>                // This will truncate the middle part of long text items
95292>                Set ComDrawTextPathEllipsis of hoTabPaintManager to True
95293>                Set ComFlags of hoTabWorkspace to xtpWorkspaceHideAll //xtpWorkspaceHideClose //xtpWorkspaceShowCloseTab
95294>            End_Procedure
95295>
95295>        Procedure SetTheTheme Integer eTheme
95298>            Integer iColor
95298>            Set peVisualTheme of ghoCommandBars to eTheme
95299>            Send ComRecalcLayout of ghoCommandBars
95300>            Get ComGetSpecialColor of ghoCommandBars XPCOLOR_TOOLBAR_FACE to iColor
95301>            Broadcast Recursive Set Color of (Client_Id(phoMainPanel(ghoApplication))) to iColor
95303>        End_Procedure
95304>
95304>        Object oActions_Toolbar is a cCJToolbar
95306>            Set pbCloseable to False
95307>            Set pbCustomizable to False
95308>            Set pbShowExpandButton to False
95309>            Set psTitle to "Actions"
95310>
95310>            Object oCodeGenerator_MenuItem is a cCJMenuItem
95312>                Set psCaption to "Code &Generator"
95313>                Set psImage to "SqlScript1.ico"
95314>                Set peControlStyle to xtpButtonIconAndCaption
95315>                Procedure OnExecute Variant vCommandBarControl
95318>                    Forward Send OnExecute vCommandBarControl
95320>                    Set pbChecked to True
95321>                    Set pbChecked of (oCompareDatabases_MenuItem(ghoCommandBars)) to False
95322>                    Send Activate_oTableDUFCodeGenerator of (Client_Id(phoMainPanel(ghoApplication)))
95323>                End_Procedure
95324>            End_Object
95325>
95325>            Object oCompareDatabases_MenuItem is a cCJMenuItem
95327>                Set psCaption to "Compare &Databases"
95328>                Set psImage to "DbCompare1.ico"
95329>                Set peControlStyle to xtpButtonIconAndCaption
95330>                Set pbChecked to True
95331>
95331>                Procedure OnExecute Variant vCommandBarControl  
95334>                    Forward Send OnExecute vCommandBarControl
95336>                    Set pbChecked to True
95337>                    Set pbChecked of (oCodeGenerator_MenuItem(ghoCommandBars)) to False
95338>                    Send Activate_oCompareDatabases_vw of (Client_Id(phoMainPanel(ghoApplication)))
95339>                End_Procedure
95340>            End_Object
95341>
95341>        End_Object
95342>
95342>        // This is needed to get the "Key_Shift+Key_Tab" key combination to activate
95342>        // the previous tab workspace view.
95342>
95342>        Object oEditToolBar is a cCJToolbar
95344>            Set psTitle to "Edit Toolbar"
95345>            Set pbCloseable to False
95346>            Set pbCustomizable to False
95347>            Set pbShowExpandButton to False
95348>
95348>            Object oCutToolbarItem is a cCJCutMenuItem
95350>                Set psImage to "ActionCut1.ico"
95351>            End_Object
95352>
95352>            Object oCopyToolbarItem is a cCJCopyMenuItem
95354>                Set psImage to "ActionCopy1.ico"
95355>
95355>            End_Object
95356>
95356>            Object oPasteToolbarItem is a cCJPasteMenuItem
95358>                Set psImage to "ActionPaste1.ico"
95359>            End_Object
95360>
95360>//            Object oDeleteEditToolbarItem is a cCJDeleteEditMenuItem
95360>//                Set psImage to "ActionDelete1.ico"
95360>//                Set pbControlBeginGroup to True
95360>//            End_Object
95360>
95360>            Object oPromptToolItem is a cCJPromptMenuItem
95362>                Set psImage to "ActionPrompt1.ico"
95363>                Set pbControlBeginGroup to True
95364>            End_Object
95365>
95365>            Object oClearToolItem is a cCJClearMenuItem
95367>                Set peControlStyle to xtpButtonIconAndCaption
95368>                Set psCaption      to "Clear/Add"
95369>                Set pbControlBeginGroup to True
95370>                Set psImage to "ActionClear1.ico"  
95371>                
95371>                Function IsEnabled Returns Boolean
95374>                    Function_Return True
95375>                End_Function
95376>
95376>            End_Object
95377>
95377>            Object oOpenContainingFolder_MenuItem is a cCJMenuItem
95379>                Set psImage to "ActionOpenContainingFolder1.ico"
95380>                Set psCaption to "Containing Folder"
95381>                Set psToolTip to "Open containing folder"
95382>                Set psDescription to "Open Containing Folder"
95383>                Set pbActiveUpdate to True
95384>                Set pbControlBeginGroup to True
95385>
95385>                Procedure OnExecute Variant vCommandBarControl
95388>                    String sPath sFile       
95388>                    Boolean bExists
95388>
95388>                    Forward Send OnExecute vCommandBarControl
95390>                    Get psFilelistFrom of ghoApplication to sFile
95391>                    Get ParseFolderName sFile to sPath
95392>                    Get vFilePathExists sFile to bExists
95393>                    // We want to have that file to be selected in Windows Explorer;
95393>                    If (bExists = True) Begin
95395>                        Move ("/select, " + sFile) to sPath
95396>                    End
95396>                    Send vShellExecute "open" "explorer.exe" sPath ""
95397>                End_Procedure
95398>
95398>                Function IsEnabled Returns Boolean
95401>                    String sFile
95401>                    Boolean bExists
95401>                    Get psFilelistFrom of ghoApplication to sFile
95402>                    Get vFilePathExists sFile to bExists
95403>                    Function_Return (bExists = True)
95404>                End_Function
95405>
95405>            End_Object
95406>
95406>            Object oCompareToolItem is a cCJMenuItem
95408>//                Set peControlStyle to xtpButtonIconAndCaption
95408>//                Set psCaption to "&Connection" 
95408>                Set psToolTip to "Show SQL Settings dialog"
95409>                Set psImage to "SQLSettings1.ico"
95410>                Set piShortCutKey to xtpKey_Alt VK_S
95411>                Set pbControlBeginGroup to True
95412>                Set pbActiveUpdate to True
95413>
95413>                Procedure OnExecute Variant vCommandBarControl
95416>                    tSQLConnection Connection
95416>                    tSQLConnection Connection
95416>                    String sFileListFrom sCurrentFilelist
95416>                    Handle hoFocus
95416>                    Boolean bExists bOK
95416>
95416>                    Move (Focus(Desktop)) to hoFocus
95417>
95417>                    // First change the "current" filelist depending on which
95417>                    // Filelist form is active.
95417>                    Get Value of hoFocus to sCurrentFilelist
95418>                    Get vFilePathExists sCurrentFilelist to bExists
95419>                    Get psFilelistFrom of ghoApplication to sFileListFrom
95420>                    If (sFileListFrom = "") Begin 
95422>                        Send Info_Box "You need to select a Filelist.cfg file with SQL tables first."
95423>                        Procedure_Return
95424>                    End
95424>                    If (bExists = True and sCurrentFilelist <> "") Begin
95426>                        Get ChangeFilelistPathing of ghoApplication sCurrentFilelist to bOK
95427>                        Get psFilelistFrom of ghoApplication to sFileListFrom
95428>                    End
95428>
95428>                    If (sFileListFrom <> "") Begin
95430>                        Get pSQLConnection of ghoSQLConnectionHandler to Connection
95431>                    End
95431>
95431>                    Send Activate_ReadOnlySQLMaintainConnections_dg of (Client_Id(ghoCommandBars)) Connection
95432>                End_Procedure  
95433>                
95433>                Function IsEnabled Returns Boolean
95436>                    tSQLConnection Connection
95436>                    tSQLConnection Connection
95436>                    Get pSQLConnection of ghoSQLConnectionHandler to Connection
95437>                    Function_Return (Connection.sDriverID <> DATAFLEX_ID and Connection.sDriverID <> "")
95438>                End_Function
95439>
95439>            End_Object
95440>
95440>            Object oAddToStudio_MenuItem is a cCJMenuItem
95442>                Set psCaption to "Add to Studio"
95443>                Set psDescription to "Add to Studio"
95444>                Set psToolTip to "Add this tool to the DataFlex Studio's 'Tools' menu"
95445>                Set psImage to "ActionAddStudio1.ico"
95446>                Set pbControlBeginGroup to True   
95447>                
95447>                Procedure OnExecute Variant vCommandBarControl
95450>                    Forward Send OnExecute vCommandBarControl
95452>                    Send Popup of (oAddToStudio_dg(Client_Id(phoMainPanel(ghoApplication))))
95453>                End_Procedure
95454>                
95454>            End_Object
95455>
95455>//            Object oCaptureViewMenuItem is a cCJMenuItem
95455>//                Set psCaption to "E&ditor Settings"
95455>//                Set psToolTip to "Editor"
95455>//                Set psDescription to "Editor Settings (Alt+D)"
95455>//
95455>//                Set psCaption to "Take shapshot"
95455>//                Set psToolTip to "Take shapshot"
95455>//                Set psDescription to "Take a snapshot image of the current view/panel. (F10)"
95455>//                Set psImage to "Camera1.ico"
95455>//                
95455>//                Procedure OnExecute Variant vCommandBarControl
95455>//                    Send TakeSnapshot False
95455>//                End_Procedure
95455>//
95455>//                Function IsEnabled Returns Boolean
95455>//                    Function_Return
95455>//                End_Function   
95455>//            End_Object
95455>
95455>//            #IF (!@ > 182)
95455>//
95455>//            Use DatabaseSelection.pkg
95455>//    
95455>//            Object oThemeItem is a cCJMenuItem
95455>//                Set peControlType to xtpControlComboBox
95455>//                Set psToolTip to "Theme"
95455>//                Set psCaption to "Theme:"
95455>//                Set psDescription to "Select a theme from the drop down list"
95455>//                Set pbControlBeginGroup to True
95455>//                Set pbVisible to False
95455>//
95455>//                Procedure OnCreateControl Handle hoObj
95455>//                    Integer iItem eTheme
95455>//                    Set ComWidth of hoObj to 250
95455>//                    Send FillComboList hoObj
95455>//                    Get peVisualTheme to eTheme
95455>//                    Get FindDataItem hoObj eTheme to iItem
95455>//                    Set ComListIndex of hoObj to (If(iItem, iItem, 1))
95455>//                End_Procedure
95455>//
95455>//                Function FindDataItem Handle hoCombo Integer eVal Returns Integer
95455>//                    Integer iCount i eTheme
95455>//                    Get ComListCount of hoCombo to iCount
95455>//                    For i from 1 to iCount
95455>//                        Get ComItemData of hoCombo i to eTheme
95455>//                        If (eTheme = eVal) Begin
95455>//                            Send SetTheTheme eTheme
95455>//                            Function_Return i
95455>//                        End
95455>//                    Loop
95455>//                    Function_Return 0
95455>//                End_Function
95455>//
95455>//                Procedure AddTheme Handle hoCombo String sText Integer eTheme
95455>//                    Integer iCount
95455>//                    Get ComListCount of hoCombo to iCount
95455>//                    Increment iCount
95455>//                    Send ComAddItem  of hoCombo sText iCount
95455>//                    Set ComItemData  of hoCombo iCount to  eTheme
95455>//                End_Procedure
95455>//
95455>//                Procedure FillComboList Handle hoCombo
95455>//                    Send ComClear     of hoCombo
95455>//
95455>//                    #IF (!@ > 190)
95455>//                    Send AddTheme hoCombo "xtpThemeOffice2016Access" xtpThemeOffice2016Access
95455>//                    Send AddTheme hoCombo "xtpThemeOffice2016Excel" xtpThemeOffice2016Excel
95455>//                    Send AddTheme hoCombo "xtpThemeOffice2016OneNote" xtpThemeOffice2016OneNote
95455>//                    Send AddTheme hoCombo "xtpThemeOffice2016Outlook" xtpThemeOffice2016Outlook
95455>//                    Send AddTheme hoCombo "xtpThemeOffice2016PowerPoint" xtpThemeOffice2016PowerPoint
95455>//                    Send AddTheme hoCombo "xtpThemeOffice2016Publisher" xtpThemeOffice2016OneNote
95455>//                    Send AddTheme hoCombo "xtpThemeOffice2016Word" xtpThemeOffice2016Word
95455>//                    #ENDIF
95455>//
95455>//                    Send AddTheme hoCombo "xtpThemeOffice2013Word" xtpThemeOffice2013Word
95455>//                    Send AddTheme hoCombo "xtpThemeOffice2013Outlook" xtpThemeOffice2013Outlook
95455>//                    Send AddTheme hoCombo "xtpThemeOffice2013Excel" xtpThemeOffice2013Excel
95455>//                    Send AddTheme hoCombo "xtpThemeOffice2013PowerPoint" xtpThemeOffice2013PowerPoint
95455>//                    Send AddTheme hoCombo "xtpThemeOffice2013Publisher" xtpThemeOffice2013Publisher
95455>//                    Send AddTheme hoCombo "xtpThemeOffice2013OneNote" xtpThemeOffice2013OneNote
95455>//                    Send AddTheme hoCombo "xtpThemeOffice2013Access" xtpThemeOffice2013Access
95455>//                    Send AddTheme hoCombo "xtpThemeOffice2003" xtpThemeOffice2003
95455>//                    Send AddTheme hoCombo "xtpThemeOffice2000" xtpThemeOffice2000
95455>//                    Send AddTheme hoCombo "xtpThemeOfficeXP" xtpThemeOfficeXP
95455>//
95455>//                    Send AddTheme hoCombo "xtpThemeOffice2010Blue" xtpThemeOffice2010Blue
95455>//                    Send AddTheme hoCombo "xtpThemeOffice2010Black" xtpThemeOffice2010Black
95455>//                    Send AddTheme hoCombo "xtpThemeOffice2010Silver" xtpThemeOffice2010Silver
95455>//
95455>//                    Send AddTheme hoCombo "xtpThemeOffice2007Aqua" xtpThemeOffice2007Aqua
95455>//                    Send AddTheme hoCombo "xtpThemeOffice2007Black" xtpThemeOffice2007Black
95455>//                    Send AddTheme hoCombo "xtpThemeOffice2007Blue" xtpThemeOffice2007Blue
95455>//                    Send AddTheme hoCombo "xtpThemeOffice2007Silver" xtpThemeOffice2007Silver
95455>//
95455>//                    Send AddTheme hoCombo "xtpThemeVisualStudio2015Blue" xtpThemeVisualStudio2015Blue
95455>//                    Send AddTheme hoCombo "xtpThemeVisualStudio2015Light" xtpThemeVisualStudio2015Light
95455>//                    Send AddTheme hoCombo "xtpThemeVisualStudio2015Dark" xtpThemeVisualStudio2015Dark
95455>//
95455>//                    Send AddTheme hoCombo "xtpThemeVisualStudio2012Light" xtpThemeVisualStudio2012Light
95455>//                    Send AddTheme hoCombo "xtpThemeVisualStudio2012Dark" xtpThemeVisualStudio2012Dark
95455>//
95455>//                    Send AddTheme hoCombo "xtpThemeVisualStudio2008" xtpThemeVisualStudio2008
95455>//                    Send AddTheme hoCombo "xtpThemeVisualStudio6" xtpThemeVisualStudio6
95455>//
95455>//                    Send AddTheme hoCombo "xtpThemeWindows7" xtpThemeWindows7
95455>//
95455>//                    Send AddTheme hoCombo "xtpThemeWhidbey" xtpThemeWhidbey
95455>//
95455>//                    Send AddTheme hoCombo "xtpThemeNativeWinXP" xtpThemeNativeWinXP
95455>//                End_Procedure
95455>//
95455>//                Function CurrentTheme Handle vCommandBarControl Returns Integer
95455>//                    Handle hMessage hoCombo
95455>//                    Integer iIndex
95455>//                    // create and bind  proxy control
95455>//                    Get CreateProxyControl vCommandBarControl to hoCombo
95455>//                    // get the current selection
95455>//                    Get ComListIndex of hoCombo to iIndex
95455>//                    // note the index selections are 1 based
95455>//                    If (iIndex > 0) Begin
95455>//                        // get the ItemData for the selected item and send that message
95455>//                        Get ComItemData of hoCombo iIndex to hMessage
95455>//                        Function_Return hMessage
95455>//                    End
95455>//                    // dispose of the proxy control
95455>//                    Send Destroy of hoCombo 
95455>//                    Function_Return 0
95455>//                End_Function
95455>//
95455>//                Procedure OnExecute Variant vCommandBarControl
95455>//                    Integer eTheme
95455>//                    Integer iColor
95455>//                    Get CurrentTheme vCommandBarControl to eTheme
95455>//                    Set peVisualTheme of ghoCommandBars to eTheme
95455>//                    Send ComRecalcLayout of ghoCommandBars
95455>//                    Send WriteDword of ghoApplication CS_PropertiesKeyWord CS_ThemeKeyWord eTheme
95455>//                    Get ComGetSpecialColor of ghoCommandBars XPCOLOR_TOOLBAR_FACE to iColor
95455>//                    Broadcast Recursive Set Color of (Client_Id(phoMainPanel(ghoApplication))) to iColor
95455>//                End_Procedure
95455>//
95455>//                Procedure SetTheTheme Integer eTheme
95455>//                    Integer iColor
95455>//                    Set peVisualTheme of ghoCommandBars to eTheme
95455>//                    Send ComRecalcLayout of ghoCommandBars
95455>//                    Get ComGetSpecialColor of ghoCommandBars XPCOLOR_TOOLBAR_FACE to iColor
95455>//                    Broadcast Recursive Set Color of (Client_Id(phoMainPanel(ghoApplication))) to iColor
95455>//                End_Procedure
95455>//
95455>//                Function ConvertSystemColor Integer iColor Returns Integer
95455>//                    Integer iSysColor
95455>//                    If (iColor = clDefault or iColor = clNone) Begin    // If default color then use -1
95455>//                        Move clNone to iColor
95455>//                    End
95455>//                    Else If (iColor < 0) Begin    // If it is a system color (<0) then convert this into an RGB value
95455>//                        Move (iColor iand |CI$7FFFFFFF) to iSysColor    // extract the system color constant
95455>//                        Move (GetSysColor(iSysColor)) to iColor
95455>//                    End
95455>//                    Function_Return iColor
95455>//                End_Function
95455>//
95455>//                Procedure OnCreateAction
95455>//                    Integer eTheme
95455>//                    Forward Send OnCreateAction
95455>//                    Get peVisualTheme of ghoCommandBars to eTheme
95455>//                    Get ReadDword of ghoApplication CS_PropertiesKeyWord CS_ThemeKeyWord eTheme to eTheme
95455>//                    Set peVisualTheme to eTheme
95455>//                End_Procedure
95455>//
95455>//            End_Object
95455>//            #ENDIF
95455>
95455>//            Object oColorSelection_TextItem is a cCJMenuItem
95455>//                Set peControlType to xtpControlLabel
95455>//                Set pbControlBeginGroup to True
95455>//                Set psCaption to "Hotspot Color:"
95455>//            End_Object
95455>//
95455>//            Object oColorSelection_Item is a cCJMenuItem
95455>//                Set psImage to "ColorSelectorBlack1.ico"
95455>//
95455>//                Object oColorDialog is a ColorDialog
95455>//                    Function SelectColor Returns Integer
95455>//                        Integer iRgbColor
95455>//                        Boolean bColorSelected
95455>//
95455>//                        Move -1 to iRgbColor
95455>//                        Get Show_Dialog to bColorSelected
95455>//                        If (bColorSelected) Begin
95455>//                            Get SelectedColor to iRgbColor
95455>//                        End
95455>//
95455>//                        Function_Return iRgbColor
95455>//                    End_Function
95455>//                End_Object
95455>//
95455>//                Procedure OnExecute Variant vCommandBarControl
95455>//                    Integer iColor
95455>//                    Forward Send OnExecute vCommandBarControl
95455>//                    Get SelectColor of oColorDialog to iColor
95455>//                    If (iColor <> -1) Begin
95455>//                        Broadcast Recursive Set piHeaderHotspotColor of (Client_Id(phoMainPanel(ghoApplication))) to iColor
95455>//                    End
95455>//                End_Procedure
95455>//
95455>//            End_Object
95455>
95455>            Object oAbout_MenuItem is a cCJMenuItem
95457>                Set psCaption to "About"
95458>                Set psToolTip to "About Info"
95459>                Set psDescription to "About the program"
95460>                Set psImage to "ActionAbout1.ico"
95461>                Set pbControlBeginGroup to True
95462>                Procedure OnExecute Variant vCommandBarControl
95465>                    Forward Send OnExecute vCommandBarControl
95467>                    Send Activate_About of (Client_Id(ghoCommandBars))
95468>                End_Procedure
95469>            End_Object
95470>
95470>            Object oHelpMenuItem is a cCJHelpMenuItem
95472>                Set peControlType to xtpControlSplitButtonPopup
95473>                Set psImage to "ActionHelp1.ico"
95474>
95474>                Procedure OnExecute Variant vCommandBarControl
95477>                    Send ShowProgramHelp
95478>                End_Procedure
95479>
95479>                Object oHelpMenuItemLocal is a cCJMenuItem
95481>                    Set psCaption to "Local HTML Help"
95482>                    Set psImage to "ActionHelp1.ico"
95483>                    Procedure OnExecute Variant vCommandBarControl
95486>                        Send ShowProgramHelp
95487>                    End_Procedure
95488>                End_Object
95489>
95489>                Object oHelpMenuItemInternetBrowser is a cCJMenuItem
95491>                    Set psCaption to "Online HTML Help"
95492>                    Set psImage to "ActionHelpInternet1.ico"
95493>                    Procedure OnExecute Variant vCommandBarControl
95496>                        Runprogram Shell Background "http://www.rdctools.com/HTMLHelpDUF/Developer5.htm"
95497>                    End_Procedure
95498>
95498>                End_Object
95499>
95499>                Object oCheckforUpdatesMenuItem is a cCJMenuItem
95501>                    Set psCaption to "Check for Updates"
95502>                    Set psDescription to "Check for Updates..."
95503>                    Set psImage to "InternetUpdate1.ico"
95504>                    Set pbControlBeginGroup to True
95505>                    
95505>                    Procedure OnExecute Variant vCommandBarControl
95508>                        String sPath sUpdateProgram sParam
95508>                        Get psProgramPath of (phoWorkspace(ghoApplication)) to sPath
95509>                        Get vFolderFormat sPath to sPath
95510>                        Move "updater.exe" to sUpdateProgram
95511>                        Move "/checknow"   to sParam
95512>                        Runprogram Shell Wait ('"' + sPath + sUpdateProgram + '"') sParam
95513>                    End_Procedure
95514>                
95514>                End_Object
95515>                
95515>            End_Object
95516>
95516>            Object oExitMenuItem is a cCJExitMenuItem
95518>                Set psToolTip to "Exit application"
95519>                Set psDescription to "Exit the program (Alt+F4)"
95520>                Set psImage to "ActionExit1.ico"
95521>                Set pbControlBeginGroup to True
95522>            End_Object
95523>
95523>        End_Object
95524>
95524>        Object oPreviousTabAction is a cCJAction
95526>            Set piShortCutKey to (xtpKey_Shift + xtpKey_Ctrl) VK_TAB
95527>            Procedure OnExecute Variant vCommandBarControl
95530>                Handle hoCommandBars hoClientArea
95530>                Forward Send OnExecute vCommandBarControl
95532>                Get CommandBarSystemObject to hoCommandBars
95533>                Get ClientAreaObject of hoCommandBars to hoClientArea
95534>                If hoClientArea Begin
95536>                    Send Switch_Next_View of hoClientArea
95537>                End
95537>            End_Procedure
95538>        End_Object
95539>
95539>        Object oStatusBar is a cCJStatusBar
95541>
95541>            Object oStatusPane1 is a cCJStatusBarPane
95543>                Set piID to sbpIDIdlePane
95544>                Set pbStyleStretch to True
95545>            End_Object
95546>
95546>            Object oStatusPane2 is a cCJStatusBarPane
95548>                Set phoViewPane to Self
95549>                Set pbStyleStretch to True
95550>            End_Object
95551>
95551>        End_Object
95552>
95552>    End_Object
95553>
95553>    Object oClientArea is a ClientArea
95555>        Use ManageSQLConnections.dg
Including file: ManageSQLConnections.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ManageSQLConnections.dg)
95555>>>Use Windows.pkg
95555>>>Use Cursor.pkg
95555>>>Use cCJCommandBarSystem.pkg
95555>>>Use cRDCButtonDPI.pkg
Including file: cRDCButtonDPI.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cRDCButtonDPI.pkg)
95555>>>>>//****************************************************************************
95555>>>>>// $Module type: Package
95555>>>>>// $Module name: cRDCButtonDPI.pkg
95555>>>>>//
95555>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
95555>>>>>// Copyright (c) 2013 RDC Tools International
95555>>>>>// E-mail      : support@rdctools.com
95555>>>>>// Web-site    : http://www.rdctools.com
95555>>>>>//
95555>>>>>// Created     : 2013-01-05 @ 19:04 (Military date format - Year-Month-Day)
95555>>>>>//
95555>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
95555>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
95555>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
95555>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
95555>>>>>// in the help folder for more details.
95555>>>>>//
95555>>>>>//****************************************************************************
95555>>>>>Use cRDCButton.pkg
Including file: cRDCButton.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cRDCButton.pkg)
95555>>>>>>>//****************************************************************************
95555>>>>>>>// $Module type: Package
95555>>>>>>>// $Module name: cRDCButton.pkg
95555>>>>>>>//
95555>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
95555>>>>>>>// Copyright (c) 2013 RDC Tools International
95555>>>>>>>// E-mail      : support@rdctools.com
95555>>>>>>>// Web-site    : http://www.rdctools.com
95555>>>>>>>//
95555>>>>>>>// Created     : 2013-01-05 @ 19:04 (Military date format - Year-Month-Day)
95555>>>>>>>//
95555>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
95555>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
95555>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
95555>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
95555>>>>>>>// in the help folder for more details.
95555>>>>>>>//
95555>>>>>>>//****************************************************************************
95555>>>>>>>Use Windows.pkg
95555>>>>>>>Use Enclient.pkg
95555>>>>>>>Use errornum.inc
95555>>>>>>>
95555>>>>>>>Class cButtonIdleHandler is a cIdleHandler
95556>>>>>>>    Procedure Construct_Object
95558>>>>>>>        Forward Send Construct_Object
95560>>>>>>>
95560>>>>>>>    End_Procedure
95561>>>>>>>
95561>>>>>>>    Procedure OnIdle
95563>>>>>>>        Delegate Send DoUpdate
95565>>>>>>>    End_Procedure
95566>>>>>>>
95566>>>>>>>End_Class
95567>>>>>>>
95567>>>>>>>Class cRDCButton is a Button
95568>>>>>>>
95568>>>>>>>    Procedure Construct_Object
95570>>>>>>>        Forward Send Construct_Object
95572>>>>>>>
95572>>>>>>>        Property Boolean pbAutoEnable True
95573>>>>>>>
95573>>>>>>>        Property Boolean pbEnabled True
95574>>>>>>>
95574>>>>>>>        Property Handle phoIdleHandler (Create(Self, RefClass(cButtonIdleHandler)))
95575>>>>>>>
95575>>>>>>>        On_Key kCancel Send CancelIfPopupObject
95576>>>>>>>    End_Procedure
95577>>>>>>>
95577>>>>>>>    Procedure CancelIfPopupObject
95579>>>>>>>        Boolean bIsInPopupObject
95579>>>>>>>        Delegate Get Popup_State to bIsInPopupObject
95581>>>>>>>        If (bIsInPopupObject = True) Begin
95583>>>>>>>            Send Close_Panel
95584>>>>>>>        End
95584>>>>>>>>
95584>>>>>>>    End_Procedure
95585>>>>>>>
95585>>>>>>>    Procedure End_Construct_Object
95587>>>>>>>        String sTooltip sStatus_Help
95587>>>>>>>
95587>>>>>>>        Forward Send End_Construct_Object
95589>>>>>>>
95589>>>>>>>        Get psToolTip   to sTooltip
95590>>>>>>>        Get Status_Help to sStatus_Help
95591>>>>>>>        If (sTooltip = "" and sStatus_Help <> "") Begin
95593>>>>>>>            Set psToolTip to sStatus_Help
95594>>>>>>>        End
95594>>>>>>>>
95594>>>>>>>        If (sTooltip <> "" and sStatus_Help = "") Begin
95596>>>>>>>            Set Status_Help to sToolTip
95597>>>>>>>        End
95597>>>>>>>>
95597>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to (pbAutoEnable(Self))
95598>>>>>>>    End_Procedure
95599>>>>>>>
95599>>>>>>>    Procedure DoUpdate
95601>>>>>>>        If (pbAutoEnable(Self) = False) Begin
95603>>>>>>>            Procedure_Return
95604>>>>>>>        End
95604>>>>>>>>
95604>>>>>>>        Set Enabled_State to (IsEnabled(Self))
95605>>>>>>>    End_Procedure
95606>>>>>>>
95606>>>>>>>    Function IsEnabled Returns Boolean
95608>>>>>>>        Boolean bEnabled
95608>>>>>>>        Get pbEnabled to bEnabled
95609>>>>>>>        Function_Return bEnabled
95610>>>>>>>    End_Function
95611>>>>>>>
95611>>>>>>>    // Enable the idle handler timer when the button is activated
95611>>>>>>>    Procedure Activating
95613>>>>>>>        Forward Send Activating
95615>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to True
95616>>>>>>>    End_Procedure
95617>>>>>>>
95617>>>>>>>    // Disable the idle handler when the button is deactivated
95617>>>>>>>    Procedure Deactivating
95619>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to False
95620>>>>>>>        Forward Send Deactivating
95622>>>>>>>    End_Procedure
95623>>>>>>>
95623>>>>>>>End_Class
95624>>>>>
95624>>>>>// Button class that automatically shows the correct icon size for the current DPI-setting:
95624>>>>>Class cRDCButtonDPI is a cRDCButton
95625>>>>>    Procedure Construct_Object
95627>>>>>        Integer iIconSize
95627>>>>>        Forward Send Construct_Object
95629>>>>>        Set piImageMarginLeft to 10
95630>>>>>    End_Procedure
95631>>>>>
95631>>>>>    // Returns: DPI setting as an integer.
95631>>>>>    //  Normal DPI setting: iDPI=96  is "Normal setting" 100%
95631>>>>>    //                      iDPI=120 is "Medium setting" 125%
95631>>>>>    //                      iDPI= 144 is "Large setting" 150%
95631>>>>>    Function GetCurrentDPI Returns Integer
95633>>>>>        Handle hDC
95633>>>>>        Integer iPixelsX
95633>>>>>        Move (GetDC(0)) to hDC
95634>>>>>        Move (GetDeviceCaps(hDC, LOGPIXELSX)) to iPixelsX
95635>>>>>        Move (ReleaseDC(0, hDC)) to hDC
95636>>>>>        Function_Return iPixelsX
95637>>>>>    End_Function
95638>>>>>
95638>>>>>    Function GetCorrectIconSize Returns Integer
95640>>>>>        Integer iPixelsX iIndex iSize
95640>>>>>        Integer[] iaSizes
95641>>>>>
95641>>>>>        Move 16 to iaSizes[0]
95642>>>>>        Move 24 to iaSizes[1]
95643>>>>>        Move 32 to iaSizes[2]
95644>>>>>        Move 48 to iaSizes[3]
95645>>>>>        Move 64 to iaSizes[4]
95646>>>>>
95646>>>>>        Get piImageSize to iSize  // the "100%" size
95647>>>>>        Move (SearchArray(iSize,iaSizes)) to iIndex
95648>>>>>        Move (0 max iIndex) to iIndex
95649>>>>>        Get GetCurrentDPI to iPixelsX
95650>>>>>        // Use a Case Statement here. Wherever we jump in we will continue onwards, regardless of whether
95650>>>>>        // we match the remaining Case statements or not. So list our Cases in reverse order, meaning we
95650>>>>>        // will increment iIndex as many times as we need here.
95650>>>>>        Case Begin
95650>>>>>            Case (iPixelsX > 144)
95652>>>>>                Increment iIndex
95653>>>>>            Case (iPixelsX = 144)
95656>>>>>                Increment iIndex
95657>>>>>            Case (iPixelsX = 120)
95660>>>>>                Increment iIndex
95661>>>>>        Case End
95661>>>>>        Move (iIndex min 4) to iIndex
95662>>>>>        Function_Return iaSizes[iIndex]
95663>>>>>    End_Function
95664>>>>>
95664>>>>>    Procedure Set psToolTip String sToolTip
95666>>>>>        String sStatusHelp
95666>>>>>
95666>>>>>        Get Status_Help to sStatusHelp
95667>>>>>        If (sStatusHelp = "") Begin
95669>>>>>            Set Status_Help to sToolTip
95670>>>>>        End
95670>>>>>>
95670>>>>>
95670>>>>>        Forward Set psToolTip to sToolTip
95672>>>>>    End_Procedure
95673>>>>>
95673>>>>>End_Class
95674>>>Use cSQLCheckBox.pkg
Including file: cSQLCheckBox.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLCheckBox.pkg)
95674>>>>>Use Windows.pkg
95674>>>>>
95674>>>>>// Used by the "Page" message below to show
95674>>>>>// a rectangle around ComboForm and Checkbox objects.
95674>>>>>    Define WM_CHANGEUISTATE for |CI$0127
95674>>>>>    Define WM_UPDATEUISTATE for |CI$0128
95674>>>>>    Define WM_QUERYUISTATE  for |CI$0129
95674>>>>>    Define UIS_SET          for 1
95674>>>>>    Define UIS_CLEAR        for 2
95674>>>>>    Define UIS_INITIALIZE   for 3
95674>>>>>    Define UISF_HIDEFOCUS   for |CI$1
95674>>>>>    Define UISF_HIDEACCEL   for |CI$2
95674>>>>>    Define UISF_ACTIVE      for |CI$4
95674>>>>>
95674>>>>>// Note: Can't use cRDCCheckbox as then the OnChange event isn't called (Don't know why)
95674>>>>>Class cSQLCheckBox is a CheckBox
95675>>>>>    Procedure Construct_Object
95677>>>>>        Forward Send Construct_Object
95679>>>>>        // The piItem should be set to the object's corresponding tSQLConnection member (One based)
95679>>>>>        Property Integer piItem
95680>>>>>    End_Procedure
95681>>>>>
95681>>>>>    Procedure DbTypeUpdate Integer iDbType String sDriverID
95683>>>>>    End_Procedure
95684>>>>>
95684>>>>>    Procedure ReadConnectionData String[] sConnectionData
95686>>>>>        Integer iItem
95686>>>>>        Get piItem to iItem
95687>>>>>        Set Checked_State to (sConnectionData[iItem] = "1")
95688>>>>>    End_Procedure
95689>>>>>
95689>>>>>    Procedure WriteConnectionData String[] ByRef sConnectionData
95691>>>>>        Boolean bState
95691>>>>>        Integer iItem
95691>>>>>        Get piItem to iItem
95692>>>>>        Get Checked_State to bState
95693>>>>>        Move bState to sConnectionData[iItem]
95694>>>>>    End_Procedure
95695>>>>>
95695>>>>>    Procedure Set psToolTip String sToolTip
95697>>>>>        String sStatusHelp
95697>>>>>
95697>>>>>        Get Status_Help to sStatusHelp
95698>>>>>        If (sStatusHelp = "") Begin
95700>>>>>            Set Status_Help to sToolTip
95701>>>>>        End
95701>>>>>>
95701>>>>>
95701>>>>>        Forward Set psToolTip to sToolTip
95703>>>>>    End_Procedure
95704>>>>>
95704>>>>>    // Fix for a bug when using manifest files & running Vista and above.
95704>>>>>    // The bug being that the focus rectangle doesn't show.
95704>>>>>    Procedure Page Integer iPageObject
95706>>>>>        Handle hWnd
95706>>>>>        Integer iRet iState
95706>>>>>
95706>>>>>        Forward Send Page iPageObject
95708>>>>>
95708>>>>>        If (iPageObject) Begin
95710>>>>>            Get Window_Handle to hWnd
95711>>>>>            If (hWnd) Begin
95713>>>>>                Move (SendMessage(hWnd, WM_QUERYUISTATE, 0, 0)) to iRet
95714>>>>>                If (iRet iand UISF_HIDEFOCUS) Begin
95716>>>>>                    Move (UIS_CLEAR + (UISF_HIDEFOCUS * 65536)) to iState
95717>>>>>                    Move (SendMessage(hWnd, WM_UPDATEUISTATE, iState, 0)) to iRet
95718>>>>>                End
95718>>>>>>
95718>>>>>            End
95718>>>>>>
95718>>>>>        End
95718>>>>>>
95718>>>>>    End_Procedure
95719>>>>>
95719>>>>>End_Class
95720>>>Use cSQLComboForm.pkg
Including file: cSQLComboForm.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLComboForm.pkg)
95720>>>>>Use Windows.pkg
95720>>>>>Use cRDCComboForm.pkg
Including file: cRDCComboForm.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cRDCComboForm.pkg)
95720>>>>>>>//****************************************************************************
95720>>>>>>>// $Module type: Package
95720>>>>>>>// $Module name: cRDCComboform.pkg
95720>>>>>>>//
95720>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
95720>>>>>>>// Copyright (c) 2014 RDC Tools International
95720>>>>>>>// E-mail      : support@rdctools.com
95720>>>>>>>// Web-site    : http://www.rdctools.com
95720>>>>>>>//
95720>>>>>>>// Created     : 2014-03-17 @ 12:35 (Military date format - Year-Month-Day)
95720>>>>>>>//
95720>>>>>>>// Portions by : Raveen Sundram, Excellent Software Ltd
95720>>>>>>>//               The auto-size combo width logic was developed by Raveen.
95720>>>>>>>//
95720>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
95720>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
95720>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
95720>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
95720>>>>>>>// in the help folder for more details.
95720>>>>>>>//
95720>>>>>>>//****************************************************************************
95720>>>>>>>Use Windows.pkg
95720>>>>>>>
95720>>>>>>>// Used by the "Page" message below to show
95720>>>>>>>// a focus rectangle around ComboForm and Checkbox objects.
95720>>>>>>>
95720>>>>>>>Class cComboFormIdleHandler is a cIdleHandler
95721>>>>>>>    Procedure Construct_Object
95723>>>>>>>        Forward Send Construct_Object
95725>>>>>>>
95725>>>>>>>        Set Label_Row_Offset to 0
95726>>>>>>>        Set Label_Col_Offset to 2
95727>>>>>>>        Set Label_Justification_Mode to jMode_Right
95728>>>>>>>        Set Combo_Sort_State to False
95729>>>>>>>        Set Entry_State to False
95730>>>>>>>
95730>>>>>>>    End_Procedure
95731>>>>>>>
95731>>>>>>>    Procedure OnIdle
95733>>>>>>>        Delegate Send DoUpdate
95735>>>>>>>    End_Procedure
95736>>>>>>>
95736>>>>>>>End_Class
95737>>>>>>>
95737>>>>>>>Class cRDCComboForm is a ComboForm
95738>>>>>>>    Procedure Construct_Object
95740>>>>>>>        Forward Send Construct_Object
95742>>>>>>>
95742>>>>>>>        Property Boolean pbAutoListWidth True
95743>>>>>>>
95743>>>>>>>        Property Boolean pbAutoShadowLabelObject True
95744>>>>>>>
95744>>>>>>>        Property Boolean pbAutoEnable False
95745>>>>>>>        Set Label_Col_Offset to 2
95746>>>>>>>        Property Boolean pbEnabled True
95747>>>>>>>        Set Label_Justification_Mode to JMode_Right
95748>>>>>>>        Property Handle phoIdleHandler (Create(Self, RefClass(cComboFormIdleHandler)))
95749>>>>>>>
95749>>>>>>>    End_Procedure
95750>>>>>>>
95750>>>>>>>    Procedure End_Construct_Object
95752>>>>>>>        Boolean bAutoShadowLabelObject
95752>>>>>>>        String sTooltip sStatus_Help
95752>>>>>>>
95752>>>>>>>        Get pbAutoShadowLabelObject to bAutoShadowLabelObject
95753>>>>>>>        If (bAutoShadowLabelObject = True) Begin
95755>>>>>>>            Set Private.Label_Shadow_Display_Mode to TBSHADOW_ON_LOCAL
95756>>>>>>>        End
95756>>>>>>>>
95756>>>>>>>
95756>>>>>>>        Forward Send End_Construct_Object
95758>>>>>>>
95758>>>>>>>        Get psToolTip   to sTooltip
95759>>>>>>>        Get Status_Help to sStatus_Help
95760>>>>>>>        If (sTooltip = "" and sStatus_Help <> "") Begin
95762>>>>>>>            Set psToolTip to sStatus_Help
95763>>>>>>>        End
95763>>>>>>>>
95763>>>>>>>        Else If (sTooltip <> "" and sStatus_Help = "") Begin
95766>>>>>>>            Set Status_Help to sTooltip
95767>>>>>>>        End
95767>>>>>>>>
95767>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to (pbAutoEnable(Self))
95768>>>>>>>
95768>>>>>>>    End_Procedure
95769>>>>>>>
95769>>>>>>>    Procedure DoUpdate
95771>>>>>>>        If (pbAutoEnable(Self) = False) Begin
95773>>>>>>>            Procedure_Return
95774>>>>>>>        End
95774>>>>>>>>
95774>>>>>>>        Set Enabled_State to (IsEnabled(Self))
95775>>>>>>>    End_Procedure
95776>>>>>>>
95776>>>>>>>    Function IsEnabled Returns Boolean
95778>>>>>>>        Boolean bEnabled
95778>>>>>>>        Get pbEnabled to bEnabled
95779>>>>>>>        Function_Return bEnabled
95780>>>>>>>    End_Function
95781>>>>>>>
95781>>>>>>>    // Enable the idle handler timer when the object is activated
95781>>>>>>>    Procedure Activating
95783>>>>>>>        Forward Send Activating
95785>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to True
95786>>>>>>>    End_Procedure
95787>>>>>>>
95787>>>>>>>    // Disable the idle handler when the object is deactivated
95787>>>>>>>    Procedure Deactivating
95789>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to False
95790>>>>>>>        Forward Send Deactivating
95792>>>>>>>    End_Procedure
95793>>>>>>>
95793>>>>>>>    // To "un-select" the text in the comboform on startup
95793>>>>>>>    Procedure DoApplyAnchors Integer Arg1 Integer Arg2
95795>>>>>>>        Integer iStart iEnd
95795>>>>>>>
95795>>>>>>>        If (Focus(Desktop)=Self) Begin
95797>>>>>>>            Get SelStart to iStart
95798>>>>>>>            Get SelEnd   to iEnd
95799>>>>>>>        End
95799>>>>>>>>
95799>>>>>>>        Forward Send DoApplyAnchors Arg1 Arg2
95801>>>>>>>        Send SetSel iStart iEnd
95802>>>>>>>    End_Procedure
95803>>>>>>>
95803>>>>>>>    // Message that will drop down the list without the user clicking it,
95803>>>>>>>    // so you can send "DropDownList" to the combo to show the list.
95803>>>>>>>    Procedure DropDownList
95805>>>>>>>        Send Windows_Message CB_SHOWDROPDOWN 1 0
95806>>>>>>>    End_Procedure
95807>>>>>>>
95807>>>>>>>    Procedure SizeComboWidth
95809>>>>>>>        Integer iCount iItem iTextExt iRows iWd iNewWd iVertAdj
95809>>>>>>>        String sVal
95809>>>>>>>
95809>>>>>>>        // Initialise Width
95809>>>>>>>        Set ListWidth to 0
95810>>>>>>>        Send DoSetListWidth
95811>>>>>>>
95811>>>>>>>        Get ListRowCount     to iRows
95812>>>>>>>        Get Combo_Item_Count to iCount
95813>>>>>>>
95813>>>>>>>        // Vertical scroll-bar adjustment is needed
95813>>>>>>>        Move (iRows > 0 and iCount > iRows) to iVertAdj
95814>>>>>>>        If (iVertAdj) Begin
95816>>>>>>>            Move (GetSystemMetrics(SM_CXVSCROLL)+GetSystemMetrics(SM_CXEDGE)) to iVertAdj
95817>>>>>>>        End
95817>>>>>>>>
95817>>>>>>>        Else Begin
95818>>>>>>>            Move (GetSystemMetrics(SM_CXEDGE)) to iVertAdj
95819>>>>>>>        End
95819>>>>>>>>
95819>>>>>>>
95819>>>>>>>        // Calculate New Width
95819>>>>>>>        Decrement iCount
95820>>>>>>>        For iItem from 0 to iCount
95826>>>>>>>>
95826>>>>>>>            Get Combo_Value iItem to sVal
95827>>>>>>>            If (sVal <> "") Begin
95829>>>>>>>                Get Text_Extent sVal to iTextExt
95830>>>>>>>                Move (Low(iTextExt) + iVertAdj) to iWd
95831>>>>>>>                If (iWd > iNewWd) Begin
95833>>>>>>>                    Move (iWd + GetSystemMetrics(SM_CXFIXEDFRAME) + GetSystemMetrics(SM_CXEDGE)) to iNewWd
95834>>>>>>>                End
95834>>>>>>>>
95834>>>>>>>            End
95834>>>>>>>>
95834>>>>>>>        Loop
95835>>>>>>>>
95835>>>>>>>
95835>>>>>>>        // Set New Width
95835>>>>>>>        Set ListWidth to iNewWd
95836>>>>>>>        Send DoSetListWidth
95837>>>>>>>    End_Procedure
95838>>>>>>>
95838>>>>>>>    Procedure Combo_Add_Item String sValue
95840>>>>>>>        Forward Send Combo_Add_Item sValue
95842>>>>>>>        If (pbAutoListWidth(Self)) Begin
95844>>>>>>>            Send SizeComboWidth
95845>>>>>>>        End
95845>>>>>>>>
95845>>>>>>>    End_Procedure
95846>>>>>>>
95846>>>>>>>    Procedure Combo_Fill_List
95848>>>>>>>        Forward Send Combo_Fill_List
95850>>>>>>>        If (pbAutoListWidth(Self)) Begin
95852>>>>>>>            Send SizeComboWidth
95853>>>>>>>        End
95853>>>>>>>>
95853>>>>>>>    End_Procedure
95854>>>>>>>
95854>>>>>>>    // Fix for a bug when using manifest files & running Vista and above.
95854>>>>>>>    // The bug being that the focus rectangle doesn't show.
95854>>>>>>>    Procedure Page Integer iPageObject
95856>>>>>>>        Handle hWnd
95856>>>>>>>        Integer iRet iState
95856>>>>>>>
95856>>>>>>>        Forward Send Page iPageObject
95858>>>>>>>
95858>>>>>>>        If (iPageObject) Begin
95860>>>>>>>            Get Window_Handle to hWnd
95861>>>>>>>            If (hWnd) Begin
95863>>>>>>>                Move (SendMessage(hWnd, WM_QUERYUISTATE, 0, 0)) to iRet
95864>>>>>>>                If (iRet iand UISF_HIDEFOCUS) Begin
95866>>>>>>>                    Move (UIS_CLEAR + (UISF_HIDEFOCUS * 65536)) to iState
95867>>>>>>>                    Move (SendMessage(hWnd, WM_UPDATEUISTATE, iState, 0)) to iRet
95868>>>>>>>                End
95868>>>>>>>>
95868>>>>>>>            End
95868>>>>>>>>
95868>>>>>>>        End
95868>>>>>>>>
95868>>>>>>>
95868>>>>>>>        // To "un-select" the text in the comboform
95868>>>>>>>        If (iPageObject = 1 and Focus(Desktop) <> Self) Begin
95870>>>>>>>            Send SetSel 0 0
95871>>>>>>>        End
95871>>>>>>>>
95871>>>>>>>    End_Procedure
95872>>>>>>>
95872>>>>>>>End_Class
95873>>>>>
95873>>>>>// Used by the "Page" message below to show
95873>>>>>// a rectangle around ComboForm and Checkbox objects.
95873>>>>>//#IFNDEF WM_CHANGEUISTATE
95873>>>>>//    Define WM_CHANGEUISTATE for |CI$0127
95873>>>>>//    Define WM_UPDATEUISTATE for |CI$0128
95873>>>>>//    Define WM_QUERYUISTATE  for |CI$0129
95873>>>>>//    Define UIS_SET          for 1
95873>>>>>//    Define UIS_CLEAR        for 2
95873>>>>>//    Define UIS_INITIALIZE   for 3
95873>>>>>//    Define UISF_HIDEFOCUS   for |CI$1
95873>>>>>//    Define UISF_HIDEACCEL   for |CI$2
95873>>>>>//    Define UISF_ACTIVE      for |CI$4
95873>>>>>//#ENDIF
95873>>>>>
95873>>>>>Class cSQLComboForm is a cRDCComboForm
95874>>>>>    Procedure Construct_Object
95876>>>>>        Forward Send Construct_Object
95878>>>>>
95878>>>>>        // This will shadow the label if the form itself has its Enabled_State=False
95878>>>>>//        Property Boolean pbAutoShadowLabelObject True
95878>>>>>
95878>>>>>        // The piItem should be set to the object's corresponding tSQLConnection member (One based)
95878>>>>>        Property Integer piItem
95879>>>>>
95879>>>>>//        Set Label_Col_Offset to 2
95879>>>>>//        Set Label_Justification_Mode to JMode_Right
95879>>>>>    End_Procedure
95880>>>>>
95880>>>>>    Procedure End_Construct_Object
95882>>>>>//        Boolean bAutoShadowLabelObject
95882>>>>>//        Get pbAutoShadowLabelObject to bAutoShadowLabelObject
95882>>>>>//        If (bAutoShadowLabelObject = True) Begin
95882>>>>>//            Set Private.Label_Shadow_Display_Mode to TBSHADOW_ON_LOCAL
95882>>>>>//        End
95882>>>>>        Forward Send End_Construct_Object
95884>>>>>    End_Procedure
95885>>>>>
95885>>>>>    Procedure DbTypeUpdate Integer iDbType String sDriverID
95887>>>>>    End_Procedure
95888>>>>>
95888>>>>>    Procedure ReadConnectionData String[] sConnectionData
95890>>>>>        Integer iItem
95890>>>>>        Get piItem to iItem
95891>>>>>        Set Value to sConnectionData[iItem]
95892>>>>>    End_Procedure
95893>>>>>
95893>>>>>    Procedure WriteConnectionData String[] ByRef sConnectionData
95895>>>>>        String sValue
95895>>>>>        Integer iItem
95895>>>>>        Get piItem to iItem
95896>>>>>        Get Value to sValue
95897>>>>>        Move sValue to sConnectionData[iItem]
95898>>>>>    End_Procedure
95899>>>>>
95899>>>>>//    Procedure Set psToolTip String sToolTip
95899>>>>>//        String sStatusHelp
95899>>>>>//
95899>>>>>//        Get Status_Help to sStatusHelp
95899>>>>>//        If (sStatusHelp = "") Begin
95899>>>>>//            Set Status_Help to sToolTip
95899>>>>>//        End
95899>>>>>//
95899>>>>>//        Forward Set psToolTip to sToolTip
95899>>>>>//    End_Procedure
95899>>>>>//
95899>>>>>//    // Fix for a bug when using manifest files & running Vista and above.
95899>>>>>//    // The bug being that the focus rectangle doesn't show.
95899>>>>>//    Procedure Page Integer iPageObject
95899>>>>>//        Handle hWnd
95899>>>>>//        Integer iRet iState
95899>>>>>//
95899>>>>>//        Forward Send Page iPageObject
95899>>>>>//
95899>>>>>//        If (iPageObject) Begin
95899>>>>>//            Get Window_Handle to hWnd
95899>>>>>//            If (hWnd) Begin
95899>>>>>//                Move (SendMessage(hWnd, WM_QUERYUISTATE, 0, 0)) to iRet
95899>>>>>//                If (iRet iand UISF_HIDEFOCUS) Begin
95899>>>>>//                    Move (UIS_CLEAR + (UISF_HIDEFOCUS * 65536)) to iState
95899>>>>>//                    Move (SendMessage(hWnd, WM_UPDATEUISTATE, iState, 0)) to iRet
95899>>>>>//                End
95899>>>>>//            End
95899>>>>>//        End
95899>>>>>//    End_Procedure
95899>>>>>
95899>>>>>End_Class
95900>>>Use cSQLForm.pkg
Including file: cSQLForm.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLForm.pkg)
95900>>>>>Use Windows.pkg
95900>>>>>
95900>>>>>Class cSQLForm is a Form
95901>>>>>    Procedure Construct_Object
95903>>>>>        Forward Send Construct_Object
95905>>>>>
95905>>>>>        // This will shadow the label if the form itself has its Enabled_State=False
95905>>>>>        Property Boolean pbAutoShadowLabelObject True
95906>>>>>
95906>>>>>        // The piItem should be set to the object's corresponding tSQLConnection member (One based)
95906>>>>>        Property Integer piItem
95907>>>>>
95907>>>>>        Set Label_Justification_Mode to JMode_Right
95908>>>>>        Set Label_Col_Offset to 2
95909>>>>>    End_Procedure
95910>>>>>
95910>>>>>    Procedure End_Construct_Object
95912>>>>>        Boolean bAutoShadowLabelObject
95912>>>>>        Get pbAutoShadowLabelObject to bAutoShadowLabelObject
95913>>>>>        If (bAutoShadowLabelObject = True) Begin
95915>>>>>            Set Private.Label_Shadow_Display_Mode to TBSHADOW_ON_LOCAL
95916>>>>>        End
95916>>>>>>
95916>>>>>        Forward Send End_Construct_Object
95918>>>>>    End_Procedure
95919>>>>>
95919>>>>>    Procedure DbTypeUpdate Integer iDbType String sDriverID
95921>>>>>    End_Procedure
95922>>>>>
95922>>>>>    Procedure ReadConnectionData String[] sConnectionData
95924>>>>>        Integer iItem
95924>>>>>        Get piItem to iItem
95925>>>>>        Set Value to sConnectionData[iItem]
95926>>>>>    End_Procedure
95927>>>>>
95927>>>>>    Procedure WriteConnectionData String[] ByRef sConnectionData
95929>>>>>        String sValue
95929>>>>>        Integer iItem
95929>>>>>        Get piItem to iItem
95930>>>>>        Get Value to sValue
95931>>>>>        Move sValue to sConnectionData[iItem]
95932>>>>>    End_Procedure
95933>>>>>
95933>>>>>    Procedure Set psToolTip String sToolTip
95935>>>>>        String sStatusHelp
95935>>>>>
95935>>>>>        Get Status_Help to sStatusHelp
95936>>>>>        If (sStatusHelp = "") Begin
95938>>>>>            Set Status_Help to sToolTip
95939>>>>>        End
95939>>>>>>
95939>>>>>
95939>>>>>        Forward Set psToolTip to sToolTip
95941>>>>>    End_Procedure
95942>>>>>
95942>>>>>End_Class
95943>>>Use cSQLConnectionHandler.pkg
95943>>>Use cDbUpdateFunctionLibrary.pkg
95943>>>Use cDbUpdateDatabaseDriver.pkg
95943>>>Use DatabaseSelection.dg
Including file: DatabaseSelection.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DatabaseSelection.dg)
95943>>>>>Use Windows.pkg
95943>>>>>Use cCJGridPromptList.pkg
Including file: cCJGridPromptList.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCJGridPromptList.pkg)
95943>>>>>>>Use Windows.pkg
95943>>>>>>>Use cCJGrid.pkg
95943>>>>>>>Use umPromptRelational.pkg
95943>>>>>>>
95943>>>>>>>Class cCJGridPromptList is a cCJGrid
95944>>>>>>>    
95944>>>>>>>    Procedure Construct_Object
95946>>>>>>>        Forward Send Construct_Object
95948>>>>>>>        
95948>>>>>>>        Property Boolean pbAutoSeed True     // if we should seed list from invoking data
95949>>>>>>>        Property Boolean Private_pbAutoOrdering True
95950>>>>>>>        Property Boolean pbAutoSearch True  // pops up search window
95951>>>>>>>        Property Integer peUpdateMode umPromptValue
95952>>>>>>>        Property Integer piUpdateColumn 0
95953>>>>>>>        Property Integer piInitialColumn -1
95954>>>>>>>        Property String  psSeedValue ''
95955>>>>>>>        Property Handle phmPromptUpdateCallback 0
95956>>>>>>>        Property Integer phoInvokingObject
95957>>>>>>>        
95957>>>>>>>        Property Boolean pbStoredAutoSeed
95958>>>>>>>        Property Boolean pbStoredAutoOrdering
95959>>>>>>>        Property Boolean pbStoredAutoSearch
95960>>>>>>>        Property Integer peStoredUpdateMode
95961>>>>>>>        Property Integer piStoredUpdateColumn
95962>>>>>>>        Property Integer piStoredInitialColumn
95963>>>>>>>        Property Handle  phmStoredPromptUpdateCallback
95964>>>>>>>        Property Boolean pbStoredSelectionEnable
95965>>>>>>>        Property Boolean pbStoredMultipleSelection
95966>>>>>>>        
95966>>>>>>>        // internally set by list
95966>>>>>>>        // these must be set upon closing the list and can be used for manual list updates
95966>>>>>>>        Property Boolean pbCanceled
95967>>>>>>>        Property Integer[] pSelectedRows
95968>>>>>>>        
95968>>>>>>>        Property Boolean pbNeedsNewOrdering
95969>>>>>>>        Property Boolean pbRequestSearch
95970>>>>>>>        Property tGridKeyPair[] pSearchKeys
95971>>>>>>>        
95971>>>>>>>        // these properties makes a prompt list a prompt list
95971>>>>>>>        // and should not be changed.
95971>>>>>>>        Set pbEditOnKeyNavigation to False
95972>>>>>>>        Set pbEditOnClick to False
95973>>>>>>>        Set pbReadOnly to True
95974>>>>>>>        Set pbFocusSubItems to True
95975>>>>>>>        
95975>>>>>>>        // these could maybe be changed
95975>>>>>>>        Set pbShadeSortColumn to True
95976>>>>>>>        Set pbHeaderReorders to True
95977>>>>>>>        Set pbHeaderTogglesDirection to True
95978>>>>>>>        Set pbHeaderSelectsColumn to True
95979>>>>>>>        Set peHorizontalGridStyle to xtpGridNoLines
95980>>>>>>>        Set piFocusCellBackColor to clNone
95981>>>>>>>        Set piFocusCellForeColor to clNone
95982>>>>>>>        Set piFocusCellRectangleColor to clBlack
95983>>>>>>>        Set pbUseFocusCellRectangle to False
95984>>>>>>>        Set pbSelectionEnable to True
95985>>>>>>>        
95985>>>>>>>        On_Key kEnter Send Ok
95986>>>>>>>        On_Key kCancel Send Cancel
95987>>>>>>>        
95987>>>>>>>    End_Procedure
95988>>>>>>>    
95988>>>>>>>    // reorder list automatically on column change
95988>>>>>>>    // this also set pbFocusSubItems which is required to make the two states work
95988>>>>>>>    Procedure Set pbAutoOrdering Boolean bAutoOrder
95990>>>>>>>        Set Private_pbAutoOrdering to bAutoOrder
95991>>>>>>>        Set pbFocusSubItems to bAutoOrder
95992>>>>>>>    End_Procedure
95993>>>>>>>    
95993>>>>>>>    Function pbAutoOrdering Returns Boolean
95995>>>>>>>        Boolean bAutoOrder
95995>>>>>>>        Get Private_pbAutoOrdering to bAutoOrder
95996>>>>>>>        Function_Return bAutoOrder
95997>>>>>>>    End_Function
95998>>>>>>>    
95998>>>>>>>    // augmented to handle auto-ordering and invoking the search popup list
95998>>>>>>>    Procedure OnIdle
96000>>>>>>>        Boolean bNeedsReorder bSearch bOldToggle
96000>>>>>>>        Handle hoCol
96000>>>>>>>        Integer iKy1 iKy2 iCol
96000>>>>>>>        
96000>>>>>>>        Get pbNeedsNewOrdering to bNeedsReorder
96001>>>>>>>        If bNeedsReorder Begin
96003>>>>>>>            Get SelectedColumn to iCol
96004>>>>>>>            If (iCol<>-1) Begin
96006>>>>>>>                
96006>>>>>>>                Get pbHeaderTogglesDirection to bOldToggle
96007>>>>>>>                Set pbHeaderTogglesDirection to False
96008>>>>>>>                Send HeaderReorder iCol
96009>>>>>>>                Set pbHeaderTogglesDirection to bOldToggle
96010>>>>>>>                
96010>>>>>>>                Set pbNeedsNewOrdering to False
96011>>>>>>>            End
96011>>>>>>>>
96011>>>>>>>        End
96011>>>>>>>>
96011>>>>>>>        
96011>>>>>>>        Get pbRequestSearch to bSearch
96012>>>>>>>        If bSearch Begin
96014>>>>>>>            Send Request_SearchEx // will use the keys pSearchKeys as eed
96015>>>>>>>        End
96015>>>>>>>>
96015>>>>>>>        
96015>>>>>>>        Forward Send OnIdle
96017>>>>>>>    End_Procedure
96018>>>>>>>    
96018>>>>>>>    Procedure OnStoreDefaults
96020>>>>>>>        Integer iVal
96020>>>>>>>        Boolean bVal
96020>>>>>>>        
96020>>>>>>>        Get pbAutoSeed to bVal
96021>>>>>>>        Set pbStoredAutoSeed to bVal
96022>>>>>>>        
96022>>>>>>>        Get pbAutoOrdering to bVal
96023>>>>>>>        Set pbStoredAutoOrdering to bVal
96024>>>>>>>        
96024>>>>>>>        Get pbAutoSearch to bVal
96025>>>>>>>        Set pbStoredAutoSearch to bVal
96026>>>>>>>        
96026>>>>>>>        Get peUpdateMode to iVal
96027>>>>>>>        Set peStoredUpdateMode to iVal
96028>>>>>>>        
96028>>>>>>>        Get piUpdateColumn to iVal
96029>>>>>>>        Set piStoredUpdateColumn to iVal
96030>>>>>>>        
96030>>>>>>>        Get piInitialColumn to iVal
96031>>>>>>>        Set piStoredInitialColumn to iVal
96032>>>>>>>        
96032>>>>>>>        Get phmPromptUpdateCallback to iVal
96033>>>>>>>        Set phmStoredPromptUpdateCallback to iVal
96034>>>>>>>        
96034>>>>>>>        Get pbSelectionEnable to bVal
96035>>>>>>>        Set pbStoredSelectionEnable to bVal
96036>>>>>>>        
96036>>>>>>>        Get pbMultipleSelection to bVal
96037>>>>>>>        Set pbStoredMultipleSelection to bVal
96038>>>>>>>        
96038>>>>>>>    End_Procedure
96039>>>>>>>    
96039>>>>>>>    Procedure OnRestoreDefaults
96041>>>>>>>        Integer iVal
96041>>>>>>>        Boolean bVal
96041>>>>>>>        
96041>>>>>>>        Get pbStoredAutoSeed to bVal
96042>>>>>>>        Set pbAutoSeed to bVal
96043>>>>>>>        
96043>>>>>>>        Get pbStoredAutoOrdering to bVal
96044>>>>>>>        Set pbAutoOrdering to bVal
96045>>>>>>>        
96045>>>>>>>        Get pbStoredAutoSearch to bVal
96046>>>>>>>        Set pbAutoSearch to bVal
96047>>>>>>>        
96047>>>>>>>        Get peStoredUpdateMode to iVal
96048>>>>>>>        Set peUpdateMode to iVal
96049>>>>>>>        
96049>>>>>>>        Get piStoredUpdateColumn to iVal
96050>>>>>>>        Set piUpdateColumn to iVal
96051>>>>>>>        
96051>>>>>>>        Get piStoredInitialColumn to iVal
96052>>>>>>>        Set piInitialColumn to iVal
96053>>>>>>>        
96053>>>>>>>        Get phmStoredPromptUpdateCallback to iVal
96054>>>>>>>        Set phmPromptUpdateCallback to iVal
96055>>>>>>>        
96055>>>>>>>        Get pbStoredSelectionEnable to bVal
96056>>>>>>>        Set pbSelectionEnable to bVal
96057>>>>>>>        
96057>>>>>>>        Get pbStoredMultipleSelection to bVal
96058>>>>>>>        Set pbMultipleSelection to bVal
96059>>>>>>>        
96059>>>>>>>    End_Procedure
96060>>>>>>>    
96060>>>>>>>    // finds the target seed value in the updatecolumn. If we autoseed and there is a
96060>>>>>>>    // seed value (psSeedValue), attempt to find GE that value, else move to first row
96060>>>>>>>    // Suitable for augmentation
96060>>>>>>>    Procedure OnSeedData
96062>>>>>>>        Integer iUpdateColumn iSortColumn
96062>>>>>>>        Boolean bSeed bAuto
96062>>>>>>>        String sValue
96062>>>>>>>        Handle hoCol
96062>>>>>>>        
96062>>>>>>>        Get piUpdateColumn to iUpdateColumn
96063>>>>>>>        Get psSeedValue to sValue
96064>>>>>>>        Get pbAutoSeed to bSeed
96065>>>>>>>        Get piSortColumn to iSortColumn
96066>>>>>>>        Get pbAutoOrdering to bAuto
96067>>>>>>>        // if not yet sorted and this is auto ordering we will
96067>>>>>>>        // sort the data for the search column. We do this to make the
96067>>>>>>>        // column search GE logic work properly.
96067>>>>>>>        If (bSeed and bAuto and iUpdateColumn<>-1 and iSortColumn<>iUpdateColumn) Begin
96069>>>>>>>            Get ColumnObject iUpdateColumn to hoCol
96070>>>>>>>            Send SortGridByColumn hoCol False
96071>>>>>>>        End
96071>>>>>>>>
96071>>>>>>>        
96071>>>>>>>        If (bSeed and sValue<>"" and iUpdateColumn<>-1) Begin
96073>>>>>>>            Send RequestFindColumnValue iUpdateColumn sValue True 0
96074>>>>>>>        End
96074>>>>>>>>
96074>>>>>>>        Else Begin
96075>>>>>>>            Send MovetoFirstRow
96076>>>>>>>        End
96076>>>>>>>>
96076>>>>>>>        
96076>>>>>>>    End_Procedure
96077>>>>>>>    
96077>>>>>>>    Procedure OnMoveValueOutByValue
96079>>>>>>>        String sValue
96079>>>>>>>        Handle hoInvokingObject hoCol  hoDataSource
96079>>>>>>>        Integer iRow iCol
96079>>>>>>>        Integer[] SelRowsIndexes
96080>>>>>>>        
96080>>>>>>>        Get phoInvokingObject to hoInvokingObject
96081>>>>>>>        Get pSelectedRows to SelRowsIndexes
96082>>>>>>>        If (SizeOfArray(SelRowsIndexes)>0) Begin
96084>>>>>>>            Get piUpdateColumn to iCol
96085>>>>>>>            Get ColumnObject iCol to hoCol
96086>>>>>>>            Get RowValue of hoCol SelRowsIndexes[0] to sValue
96087>>>>>>>            Set Value of hoInvokingObject to sValue
96088>>>>>>>            Set Item_Changed_State of hoInvokingObject to True
96089>>>>>>>        End
96089>>>>>>>>
96089>>>>>>>    End_Procedure
96090>>>>>>>    
96090>>>>>>>    Procedure OnMoveValueOutByCustom
96092>>>>>>>    End_Procedure
96093>>>>>>>    
96093>>>>>>>    // augment to popup a search window when allowed
96093>>>>>>>    Procedure OnComKeyDown Short ByRef llKeyCode Short llShift
96095>>>>>>>        Boolean bSubFocus bAutoSearch bChar
96095>>>>>>>        Integer iVal
96095>>>>>>>        
96095>>>>>>>        Get pbFocusSubItems to bSubFocus
96096>>>>>>>        Get pbAutoSearch to bAutoSearch
96097>>>>>>>        Forward Send OnComKeyDown llKeyCode llShift
96099>>>>>>>        If (bAutoSearch and not(bSubFocus)) Begin
96101>>>>>>>            If ((llShift iand 6)=0) Begin // skip alt and ctrl
96103>>>>>>>                Get GetVKeyToAnsi llKeyCode llShift to iVal
96104>>>>>>>                Move (iVal<>0) to bChar
96105>>>>>>>            End
96105>>>>>>>>
96105>>>>>>>            If bChar Begin
96107>>>>>>>                // this can get called multiple times before a search dialog pops up
96107>>>>>>>                Send AddToSearchKeys llKeyCode llShift
96108>>>>>>>            End
96108>>>>>>>>
96108>>>>>>>        End
96108>>>>>>>>
96108>>>>>>>    End_Procedure
96109>>>>>>>    
96109>>>>>>>    Procedure OnComRequestEdit Variant llRow Variant llColumn Variant llItem Boolean ByRef llCancel
96111>>>>>>>        Boolean bAutoSearch
96111>>>>>>>        Integer iKeyCode iShiftCode
96111>>>>>>>        Get pbAutoSearch to bAutoSearch
96112>>>>>>>        If bAutoSearch Begin
96114>>>>>>>            // this can get called multiple times before a search dialog pops up
96114>>>>>>>            Get piLastKey to iKeyCode
96115>>>>>>>            Get piLastKey2 to iShiftCode
96116>>>>>>>            Send AddToSearchKeys iKeyCode iShiftCode
96117>>>>>>>        End
96117>>>>>>>>
96117>>>>>>>        Move True to llCancel
96118>>>>>>>    End_Procedure
96119>>>>>>>    
96119>>>>>>>    Procedure OnComRowDblClick Variant llRow Variant llItem
96121>>>>>>>        Send ClearSearchRequest // kill any deferred search popup
96122>>>>>>>        Forward Send OnComRowDblClick llRow llItem
96124>>>>>>>    End_Procedure
96125>>>>>>>    
96125>>>>>>>    Procedure OnRowDoubleClick Integer iRow Integer iCol
96127>>>>>>>        Send Ok
96128>>>>>>>    End_Procedure
96129>>>>>>>    
96129>>>>>>>    
96129>>>>>>>    // we don't want a menu for prompt lists
96129>>>>>>>    Function CreateContextMenu Returns Handle
96131>>>>>>>        Function_Return 0
96132>>>>>>>    End_Function
96133>>>>>>>    
96133>>>>>>>    // if we use auto-ordering, change the order when the column changes
96133>>>>>>>    Procedure ColumnChanged Integer iOld Integer iNew
96135>>>>>>>        Boolean bAutoOrder
96135>>>>>>>        Forward Send ColumnChanged iOld iNew
96137>>>>>>>        Get pbAutoOrdering to bAutoOrder
96138>>>>>>>        If bAutoOrder Begin
96140>>>>>>>            // will be reordered in idle event
96140>>>>>>>            Set pbNeedsNewOrdering to True
96141>>>>>>>        End
96141>>>>>>>>
96141>>>>>>>    End_Procedure
96142>>>>>>>    
96142>>>>>>>    
96142>>>>>>>    Procedure Add_Focus Handle hoParent Returns Integer
96144>>>>>>>        Integer eMode
96144>>>>>>>        Integer[] SelRowsIndexes
96145>>>>>>>        Set pbCanceled to True // assume cancel unless changed
96146>>>>>>>        Set pSelectedRows to SelRowsIndexes // empty
96147>>>>>>>        Get peUpdateMode to eMode
96148>>>>>>>        If (eMode<>umPromptNonInvoking) Begin
96150>>>>>>>            Send OnStoreDefaults
96151>>>>>>>        End
96151>>>>>>>>
96151>>>>>>>        Send InitializePromptList
96152>>>>>>>        Forward Send Add_Focus hoParent
96154>>>>>>>        Send LoadData
96155>>>>>>>        Set psSeedValue to ""
96156>>>>>>>    End_Procedure
96157>>>>>>>    
96157>>>>>>>    // called before the list is activated.
96157>>>>>>>    Procedure InitializePromptList
96159>>>>>>>        Integer hoInvokingObject
96159>>>>>>>        Boolean bAutoColumn bAutoSeed
96159>>>>>>>        Integer i iOldMode eUpdateMode
96159>>>>>>>        String sValue
96159>>>>>>>        
96159>>>>>>>        Get peUpdateMode to eUpdateMode
96160>>>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
96162>>>>>>>            Get Focus of Desktop to hoInvokingObject
96163>>>>>>>            If (hoInvokingObject<=Desktop) Begin
96165>>>>>>>                Error DFERR_PROGRAM "Prompt list has no invoking object"
96166>>>>>>>>
96166>>>>>>>                Procedure_Return
96167>>>>>>>            End
96167>>>>>>>>
96167>>>>>>>            
96167>>>>>>>            Set phoInvokingObject to hoInvokingObject
96168>>>>>>>            
96168>>>>>>>            Send Prompt_Callback to hoInvokingObject Self
96169>>>>>>>            Get peUpdateMode to eUpdateMode
96170>>>>>>>        End
96170>>>>>>>>
96170>>>>>>>        
96170>>>>>>>        Send ClearSearchRequest // clear the search keys
96171>>>>>>>        Set pbNeedsNewOrdering to False
96172>>>>>>>        
96172>>>>>>>        Get pbAutoSeed to bAutoSeed
96173>>>>>>>        
96173>>>>>>>        If (eUpdateMode=umPromptValue) Begin // else not used here intentionally
96175>>>>>>>            Get Value of hoInvokingObject to sValue
96176>>>>>>>            Set psSeedValue to sValue
96177>>>>>>>        End
96177>>>>>>>>
96177>>>>>>>        
96177>>>>>>>    End_Procedure
96178>>>>>>>    
96178>>>>>>>    // called after list is created and active. Load Data, seed list, select start column, etc.
96178>>>>>>>    Procedure LoadData
96180>>>>>>>        Handle hoInvokingObject hoDataSource hoInitialColumn
96180>>>>>>>        Integer iUpdateColumn iRows iInitialColumn iInitialOrder
96180>>>>>>>        Integer eUpdateMode
96180>>>>>>>        Boolean bAutoSeed bAutoColumn bCancel bSubFocus bAutoOrder
96180>>>>>>>        
96180>>>>>>>        Get phoDataSource to hoDataSource
96181>>>>>>>        Get peUpdateMode to eUpdateMode
96182>>>>>>>        Get phoInvokingObject to hoInvokingObject
96183>>>>>>>        Get pbAutoSeed to bAutoSeed
96184>>>>>>>        Get piInitialColumn to iInitialColumn
96185>>>>>>>        Get piUpdateColumn to iUpdateColumn
96186>>>>>>>        Get RowCount of hoDataSource to iRows
96187>>>>>>>        
96187>>>>>>>        // We need an initial column. if you specified an initial column that will get used for the start column
96187>>>>>>>        // and the initial sort order. If you did not, which is typical, it will use the update column
96187>>>>>>>        If (iInitialColumn=-1) Begin
96189>>>>>>>            Move iUpdateColumn to iInitialColumn
96190>>>>>>>        End
96190>>>>>>>>
96190>>>>>>>        If (iInitialColumn>=0) Begin
96192>>>>>>>            Get ColumnObject iInitialColumn to hoInitialColumn
96193>>>>>>>            Set pbVisible of hoInitialColumn to True // initial column should be visible
96194>>>>>>>        End
96194>>>>>>>>
96194>>>>>>>        Send OnSeedData // find a good starting place for the row
96195>>>>>>>        Get pbFocusSubItems to bSubFocus
96196>>>>>>>        If bSubFocus Begin
96198>>>>>>>            // if column focus, which is normal, go to initialcolumn
96198>>>>>>>            If hoInitialColumn Begin
96200>>>>>>>                Get MoveToColumnObject hoInitialColumn to bCancel
96201>>>>>>>            End
96201>>>>>>>>
96201>>>>>>>            Else Begin
96202>>>>>>>                Send MoveToFirstEnterableColumn
96203>>>>>>>            End
96203>>>>>>>>
96203>>>>>>>        End
96203>>>>>>>>
96203>>>>>>>        
96203>>>>>>>    End_Procedure
96204>>>>>>>    
96204>>>>>>>    // This is only called in a successful close
96204>>>>>>>    Procedure ClosePromptList
96206>>>>>>>        Handle hoDataSource hoInvokingObject
96206>>>>>>>        Handle hmCallBack
96206>>>>>>>        Integer iRow eUpdateMode
96206>>>>>>>        Integer[] SelRowsIndexes
96207>>>>>>>        
96207>>>>>>>        Get phoDataSource to hoDataSource
96208>>>>>>>        Get phoInvokingObject to hoInvokingObject
96209>>>>>>>        
96209>>>>>>>        If (pbMultipleSelection(Self)) Begin
96211>>>>>>>            Get GetIndexesForSelectedRows to SelRowsIndexes
96212>>>>>>>        End
96212>>>>>>>>
96212>>>>>>>        Else Begin
96213>>>>>>>            Get SelectedRow of hoDataSource to iRow
96214>>>>>>>            If (iRow<>-1) Begin
96216>>>>>>>                Move iRow to SelRowsIndexes[0]
96217>>>>>>>            End
96217>>>>>>>>
96217>>>>>>>        End
96217>>>>>>>>
96217>>>>>>>        
96217>>>>>>>        Set pbCanceled to False
96218>>>>>>>        Set pSelectedRows to SelRowsIndexes
96219>>>>>>>        
96219>>>>>>>        Get peUpdateMode to eUpdateMode
96220>>>>>>>        // if non-invoking there is by definition, no move value out
96220>>>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
96222>>>>>>>            
96222>>>>>>>            If (eUpdateMode=umPromptValue) Begin
96224>>>>>>>                Send OnMoveValueOutByValue
96225>>>>>>>            End
96225>>>>>>>>
96225>>>>>>>            Else If (eUpdateMode=umPromptCustom) Begin
96228>>>>>>>                Send OnMoveValueOutByCustom
96229>>>>>>>            End
96229>>>>>>>>
96229>>>>>>>            Get phmPromptUpdateCallback to hmCallBack
96230>>>>>>>            If hmCallBack Begin
96232>>>>>>>                Send hmCallBack of hoInvokingObject Self
96233>>>>>>>            End
96233>>>>>>>>
96233>>>>>>>        End
96233>>>>>>>>
96233>>>>>>>        
96233>>>>>>>        Send Close_Panel
96234>>>>>>>    End_Procedure
96235>>>>>>>    
96235>>>>>>>    // augment to send OnRestoreDefaults.
96235>>>>>>>    Procedure Release_Focus
96237>>>>>>>        Integer eUpdateMode
96237>>>>>>>        Get peUpdateMode to eUpdateMode
96238>>>>>>>        Forward Send Release_Focus
96240>>>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
96242>>>>>>>            Send OnRestoreDefaults
96243>>>>>>>        End
96243>>>>>>>>
96243>>>>>>>    End_Procedure
96244>>>>>>>    
96244>>>>>>>    Function SelectedRowIds Returns RowID[]
96246>>>>>>>        RowID[] SelectedRowids
96247>>>>>>>        Integer[] SelectedRows
96248>>>>>>>        Integer i iRows
96248>>>>>>>        Handle hoDataSource
96248>>>>>>>        Get phoDataSource to hoDataSource
96249>>>>>>>        Get pSelectedRows to SelectedRows
96250>>>>>>>        Move (SizeOfArray(SelectedRows)) to iRows
96251>>>>>>>        For i from 0 to (iRows-1)
96257>>>>>>>>
96257>>>>>>>            Get RowTag of hoDataSource SelectedRows[i] to SelectedRowIds[i]
96258>>>>>>>        Loop
96259>>>>>>>>
96259>>>>>>>        Function_Return SelectedRowids
96260>>>>>>>    End_Function
96261>>>>>>>    
96261>>>>>>>    Function SelectedColumnValues Integer iCol Returns String[]
96263>>>>>>>        String[] SelectedValues
96264>>>>>>>        Integer[] SelectedRows
96265>>>>>>>        Integer i iRows
96265>>>>>>>        Handle hoCol
96265>>>>>>>        Get ColumnObject iCol to hoCol
96266>>>>>>>        Get pSelectedRows to SelectedRows
96267>>>>>>>        Move (SizeOfArray(SelectedRows)) to iRows
96268>>>>>>>        For i from 0 to (iRows-1)
96274>>>>>>>>
96274>>>>>>>            Get RowValue of hoCol SelectedRows[i] to SelectedValues[i]
96275>>>>>>>        Loop
96276>>>>>>>>
96276>>>>>>>        Function_Return SelectedValues
96277>>>>>>>    End_Function
96278>>>>>>>    
96278>>>>>>>    Procedure Ok Returns Integer
96280>>>>>>>        Send ClosePromptList
96281>>>>>>>    End_Procedure
96282>>>>>>>    
96282>>>>>>>    Procedure Cancel Returns Integer
96284>>>>>>>        Send Close_Panel
96285>>>>>>>    End_Procedure
96286>>>>>>>    
96286>>>>>>>    Procedure Search
96288>>>>>>>        Send Activate // give focus back to list so focus things are correct
96289>>>>>>>        Send Request_Search 0 0
96290>>>>>>>    End_Procedure
96291>>>>>>>    
96291>>>>>>>    // do a search using the current keys in the search key buffer for the sort column.
96291>>>>>>>    // Becaue this is called via an OnIdle it is possible to have multiple keys pressed before
96291>>>>>>>    // the OnIdle. These have been stored in pSearchKeys and will be passed to the popup dialog
96291>>>>>>>    Procedure Request_SearchEx
96293>>>>>>>        tGridKeyPair[] Keys
96293>>>>>>>        tGridKeyPair[] Keys
96294>>>>>>>        Integer iCol
96294>>>>>>>        Handle hoCol hoSearchDialog
96294>>>>>>>        Boolean bOk
96294>>>>>>>        String sValue
96294>>>>>>>        
96294>>>>>>>        Get piSortColumn to iCol
96295>>>>>>>        If (iCol<>-1) Begin
96297>>>>>>>            Get ColumnObject iCol to hoCol
96298>>>>>>>            Get pSearchKeys to Keys
96299>>>>>>>            Get CreateGridSearchDialogObject to hoSearchDialog
96300>>>>>>>            Get RequestGridSearchEx of hoSearchDialog Keys hoCol (&sValue) to bOk
96301>>>>>>>            If bOk Begin
96303>>>>>>>                Send RequestFindColumnValue iCol sValue True 0
96304>>>>>>>            End
96304>>>>>>>>
96304>>>>>>>            Send Destroy of hoSearchDialog
96305>>>>>>>        End
96305>>>>>>>>
96305>>>>>>>        Send ClearSearchRequest // clear the search keys
96306>>>>>>>    End_Procedure
96307>>>>>>>    
96307>>>>>>>    // set pbRequestSearch to true and add the keys to the search buffer.
96307>>>>>>>    Procedure AddToSearchKeys Integer iKeyCode Integer iShiftCode
96309>>>>>>>        tGridKeyPair[] Keys
96309>>>>>>>        tGridKeyPair[] Keys
96310>>>>>>>        tGridKeyPair KeyPair
96310>>>>>>>        tGridKeyPair KeyPair
96310>>>>>>>        Set pbRequestSearch to True
96311>>>>>>>        Move iKeyCode to KeyPair.KeyCode
96312>>>>>>>        Move iShiftCode to KeyPair.ShiftCode
96313>>>>>>>        Get pSearchKeys to Keys
96314>>>>>>>        Move KeyPair to Keys[SizeOfArray(Keys)]
96315>>>>>>>        Set pSearchKeys to Keys
96316>>>>>>>    End_Procedure
96317>>>>>>>    
96317>>>>>>>    Procedure ClearSearchRequest
96319>>>>>>>        tGridKeyPair[] SearchKeys
96319>>>>>>>        tGridKeyPair[] SearchKeys
96320>>>>>>>        Set pSearchKeys to SearchKeys
96321>>>>>>>        Set pbRequestSearch to False
96322>>>>>>>    End_Procedure
96323>>>>>>>    
96323>>>>>>>End_Class
96324>>>>>>>
96324>>>>>Use cDbUpdateFunctionLibrary.pkg
96324>>>>>Use MSSqldrv.pkg
96324>>>>>Use db2_drv.pkg
96324>>>>>Use odbc_drv.pkg
96324>>>>>Use cRDCModalPanel.pkg
Including file: cRDCModalPanel.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\DFAbout\cRDCModalPanel.pkg)
96324>>>>>>>//****************************************************************************
96324>>>>>>>// $Module type: Class
96324>>>>>>>// $Module name: cRDCModalPanel
96324>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International
96324>>>>>>>// Created     : 2014-03-17 @ 12:33
96324>>>>>>>//
96324>>>>>>>// Description :
96324>>>>>>>//
96324>>>>>>>// $Rev History:
96324>>>>>>>//    2014-03-17  Module header created
96324>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
96324>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
96324>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
96324>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
96324>>>>>>>// in the help folder for more details.
96324>>>>>>>//
96324>>>>>>>//****************************************************************************
96324>>>>>>>Use Windows.pkg
96324>>>>>>>Use cCJCommandBarSystem.pkg   
96324>>>>>>>Use cCJSkinFramework.pkg
96324>>>>>>>
96324>>>>>>>Class cRDCModalPanel is a ModalPanel
96325>>>>>>>
96325>>>>>>>    Procedure Construct_Object
96327>>>>>>>        Forward Send Construct_Object
96329>>>>>>>
96329>>>>>>>        Set Maximize_Icon to True
96330>>>>>>>        Set Minimize_Icon to False
96331>>>>>>>        Set Border_Style to Border_Thick
96332>>>>>>>        Set Locate_Mode to Center_On_Parent
96333>>>>>>>
96333>>>>>>>        Property String Private_Icon
96334>>>>>>>        Property Handle phoDialogCommandbar
96335>>>>>>>    End_Procedure
96336>>>>>>>
96336>>>>>>>    Procedure Set Icon String sIcon
96338>>>>>>>        Forward Set Icon to sIcon
96340>>>>>>>        Set Private_Icon to sIcon
96341>>>>>>>    End_Procedure
96342>>>>>>>
96342>>>>>>>    Function Icon Returns String
96344>>>>>>>        String sIcon
96344>>>>>>>        Get Private_Icon to sIcon
96345>>>>>>>        Function_Return sIcon
96346>>>>>>>    End_Function
96347>>>>>>>
96347>>>>>>>    Procedure Page Integer iPageObject
96349>>>>>>>        String sIcon
96349>>>>>>>        Integer hWnd
96349>>>>>>>        
96349>>>>>>>        Forward Send Page iPageObject
96351>>>>>>>        Get Private_Icon to sIcon
96352>>>>>>>        If (sIcon <> "") Begin
96354>>>>>>>            Set Icon to sIcon
96355>>>>>>>        End
96355>>>>>>>>
96355>>>>>>>
96355>>>>>>>        Get Window_Handle to hWnd
96356>>>>>>>
96356>>>>>>>        If ((ghoSkinFramework <> 0) and (hWnd <> 0)) Begin
96358>>>>>>>            Send ComRemoveWindow to ghoSkinFramework hWnd
96359>>>>>>>            Send ComApplyWindow  to ghoSkinFramework hWnd
96360>>>>>>>        End
96360>>>>>>>>
96360>>>>>>>    End_Procedure
96361>>>>>>>
96361>>>>>>>    // Put a status bar at the bottom of the panel, which makes
96361>>>>>>>    // status_help work and puts a gripper in the lower right corner.
96361>>>>>>>    Procedure End_Construct_Object
96363>>>>>>>        Integer iStyle iSize iOffset
96363>>>>>>>
96363>>>>>>>        Forward Send End_Construct_Object
96365>>>>>>>
96365>>>>>>>        Get Border_Style to iStyle
96366>>>>>>>        Move 8 to iOffset
96367>>>>>>>        If (iStyle = Border_Thick) Begin
96369>>>>>>>            Object oDialogCommandbar is a cCJCommandBarSystem
96371>>>>>>>                Object oStatusBar is a cCJStatusBar
96373>>>>>>>                    Set phoDialogCommandbar to Self
96374>>>>>>>                    Object oStatusIdle is a cCJStatusBarPane
96376>>>>>>>                        Set piId to sbpIDIdlePane
96377>>>>>>>                        Set pbStyleStretch to True
96378>>>>>>>                    End_Object
96379>>>>>>>                End_Object
96380>>>>>>>            End_Object
96381>>>>>>>            Get Size to iSize
96382>>>>>>>            Set Size to (Hi(iSize) + iOffset) (Low(iSize))
96383>>>>>>>            Set piMinSize to (Hi(iSize) + iOffset) (Low(iSize))
96384>>>>>>>        End
96384>>>>>>>>
96384>>>>>>>
96384>>>>>>>    End_Procedure
96385>>>>>>>
96385>>>>>>>    Procedure Popup
96387>>>>>>>        Set Statusbar_Id to (phoDialogCommandbar(Self))
96388>>>>>>>        Forward Send Popup
96390>>>>>>>    End_Procedure
96391>>>>>>>
96391>>>>>>>End_Class
96392>>>>>
96392>>>>>Object oDatabaseSelection_sl is a cRDCModalPanel
96394>>>>>    Set Label to "SQL Database Selection"
96395>>>>>    Set Size to 119 183
96396>>>>>    Set piMinSize to 89 170
96397>>>>>    Set Location to 2 2
96398>>>>>    Set Border_Style to Border_Thick
96399>>>>>    Set Icon to "DatabaseLookup1.ico"
96400>>>>>
96400>>>>>    Property String[] psTheData
96402>>>>>
96402>>>>>    If (ghoDbUpdateFunctionLibrary = 0) Begin
96404>>>>>        Object oDbUpateFunctionLibrary is a cDbUpdateFunctionLibrary
96406>>>>>        End_Object
96407>>>>>    End
96407>>>>>>
96407>>>>>
96407>>>>>    Object oSelList is a cCJGridPromptList
96409>>>>>        Set Size to 89 167
96410>>>>>        Set Location to 6 6
96411>>>>>        Set peAnchors to anAll
96412>>>>>        Set pbAllowColumnRemove to False
96413>>>>>        Set pbUseAlternateRowBackgroundColor to True
96414>>>>>        Set pbGrayIfDisable to False
96415>>>>>        Set pbHeaderReorders to False
96416>>>>>        Set pbHeaderSelectsColumn to False
96417>>>>>        Set pbHeaderTogglesDirection to False
96418>>>>>        Set pbShadeSortColumn to False
96419>>>>>        Set piFocusCellBackColor to clDkGray
96420>>>>>
96420>>>>>        Object oName is a cCJGridColumn
96422>>>>>            Set piWidth to 334
96423>>>>>            Set psCaption to "Database Name"
96424>>>>>        End_Object
96425>>>>>
96425>>>>>        Procedure Activating
96428>>>>>            tDataSourceRow[] MyData
96428>>>>>            tDataSourceRow[] MyData
96429>>>>>            Handle hoDataSource
96429>>>>>            String[] sTheData
96430>>>>>            Integer iCount iSize
96430>>>>>
96430>>>>>            Send Cursor_Wait of Cursor_Control
96431>>>>>            Forward Send Activating
96433>>>>>
96433>>>>>            Get psTheData to sTheData
96434>>>>>            Move (SizeOfArray(sTheData)) to iSize
96435>>>>>            Decrement iSize
96436>>>>>            For iCount from 0 to iSize
96442>>>>>>
96442>>>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
96443>>>>>            Loop
96444>>>>>>
96444>>>>>
96444>>>>>            Get phoDataSource to hoDataSource
96445>>>>>            Send InitializeData of hoDataSource MyData
96446>>>>>            Send Cursor_Ready of Cursor_Control
96447>>>>>        End_Procedure
96448>>>>>
96448>>>>>    End_Object
96449>>>>>
96449>>>>>    Object oOK_Btn is a Button
96451>>>>>        Set Size to 14 50
96452>>>>>        Set Label    to "&OK"
96453>>>>>        Set Location to 98 68
96454>>>>>        Set peAnchors To anBottomRight
96455>>>>>
96455>>>>>        Procedure OnClick
96458>>>>>            Send Ok of oSelList
96459>>>>>        End_Procedure
96460>>>>>
96460>>>>>    End_Object
96461>>>>>
96461>>>>>    Object oCancel_Btn is a Button
96463>>>>>        Set Size to 14 50
96464>>>>>        Set Label    to "&Cancel"
96465>>>>>        Set Location to 98 123
96466>>>>>        Set peAnchors to anBottomRight
96467>>>>>
96467>>>>>        Procedure OnClick
96470>>>>>            Send Close_Panel
96471>>>>>        End_Procedure
96472>>>>>
96472>>>>>    End_Object
96473>>>>>
96473>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
96474>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
96475>>>>>End_Object
96476>>>Use ServerSelection.dg
Including file: ServerSelection.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ServerSelection.dg)
96476>>>>>Use Windows.pkg
96476>>>>>Use cCJGridPromptList.pkg
96476>>>>>Use MSSqldrv.pkg
96476>>>>>Use db2_drv.pkg
96476>>>>>Use odbc_drv.pkg    
96476>>>>>Use cRDCModalPanel.pkg
96476>>>>>Use cDbUpdateFunctionLibrary.pkg
96476>>>>>
96476>>>>>Object oServerSelection_sl is a cRDCModalPanel
96478>>>>>    Set Size to 105 225
96479>>>>>    Set Label to "Database Server/DSN Selection"
96480>>>>>    Set piMinSize to 89 211
96481>>>>>    Set Location to 2 2
96482>>>>>    Set Icon to "ServerLookup1.ico"
96483>>>>>
96483>>>>>    Property String[] psTheData
96485>>>>>
96485>>>>>    Object oSelList is a cCJGridPromptList
96487>>>>>        Set Size to 72 215
96488>>>>>        Set Location to 6 6
96489>>>>>        Set peAnchors to anAll
96490>>>>>        Set pbAllowColumnRemove to False
96491>>>>>        Set pbUseAlternateRowBackgroundColor to True
96492>>>>>        Set pbGrayIfDisable to False
96493>>>>>        Set pbHeaderReorders to False
96494>>>>>        Set pbHeaderSelectsColumn to False
96495>>>>>        Set pbHeaderTogglesDirection to False
96496>>>>>        Set pbShadeSortColumn to False
96497>>>>>        Set piFocusCellBackColor to clDkGray
96498>>>>>
96498>>>>>        Object oName is a cCJGridColumn
96500>>>>>            Set piWidth to 358
96501>>>>>            Set psCaption to "Name"
96502>>>>>        End_Object
96503>>>>>
96503>>>>>        Procedure Activating
96506>>>>>            tDataSourceRow[] MyData
96506>>>>>            tDataSourceRow[] MyData
96507>>>>>            Handle hoDataSource
96507>>>>>            String[] sTheData
96508>>>>>            Integer iCount iSize
96508>>>>>
96508>>>>>            Send Cursor_Wait of Cursor_Control
96509>>>>>            Get psTheData to sTheData
96510>>>>>            Move (SizeOfArray(sTheData)) to iSize
96511>>>>>            Decrement iSize
96512>>>>>            For iCount from 0 to iSize
96518>>>>>>
96518>>>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
96519>>>>>            Loop
96520>>>>>>
96520>>>>>
96520>>>>>            Forward Send Activating
96522>>>>>
96522>>>>>            Get phoDataSource to hoDataSource
96523>>>>>            Send InitializeData of hoDataSource MyData
96524>>>>>            Send Cursor_Ready of Cursor_Control
96525>>>>>        End_Procedure
96526>>>>>
96526>>>>>    End_Object
96527>>>>>
96527>>>>>    Object oOK_Btn is a Button
96529>>>>>        Set Size to 14 50
96530>>>>>        Set Label    to "&OK"
96531>>>>>        Set Location to 85 116
96532>>>>>        Set peAnchors To anBottomRight
96533>>>>>
96533>>>>>        Procedure OnClick
96536>>>>>            Send Ok of oSelList
96537>>>>>        End_Procedure
96538>>>>>
96538>>>>>    End_Object
96539>>>>>
96539>>>>>    Object oCancel_Btn is a Button
96541>>>>>        Set Size to 14 50
96542>>>>>        Set Label    to "&Cancel"
96543>>>>>        Set Location to 85 171
96544>>>>>        Set peAnchors to anBottomRight
96545>>>>>
96545>>>>>        Procedure OnClick
96548>>>>>            Send Close_Panel
96549>>>>>        End_Procedure
96550>>>>>
96550>>>>>    End_Object
96551>>>>>
96551>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
96552>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
96553>>>>>End_Object
96554>>>Use TableSpaceSelection.dg
Including file: TableSpaceSelection.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\TableSpaceSelection.dg)
96554>>>>>Use Windows.pkg
96554>>>>>Use cCJGridPromptList.pkg     
96554>>>>>Use cRDCModalPanel.pkg
96554>>>>>Use cDbUpdateFunctionLibrary.pkg
96554>>>>>
96554>>>>>Object oTableSpaceSelection_sl is a cRDCModalPanel
96556>>>>>    Set Size to 118 177
96557>>>>>    Set Label to "SQL Tablespace Selection"
96558>>>>>    Set piMinSize to 89 177
96559>>>>>    Set Location to 2 2
96560>>>>>    Set Icon to "DatabaseLookup1.ico"
96561>>>>>
96561>>>>>    Property String[] psTheData
96563>>>>>
96563>>>>>//    If (ghoDbUpdateFunctionLibrary = 0) Begin
96563>>>>>//        Object oDbUpateFunctionLibrary is a cDbUpdateFunctionLibrary
96563>>>>>//        End_Object
96563>>>>>//    End
96563>>>>>
96563>>>>>    Object oSelList is a cCJGridPromptList
96565>>>>>        Set Size to 89 167
96566>>>>>        Set Location to 6 6
96567>>>>>        Set peAnchors to anAll
96568>>>>>        Set pbAllowColumnRemove to False
96569>>>>>        Set pbUseAlternateRowBackgroundColor to True
96570>>>>>        Set pbGrayIfDisable to False
96571>>>>>        Set pbHeaderReorders to False
96572>>>>>        Set pbHeaderSelectsColumn to False
96573>>>>>        Set pbHeaderTogglesDirection to False
96574>>>>>        Set pbShadeSortColumn to False
96575>>>>>        Set piFocusCellBackColor to clDkGray
96576>>>>>
96576>>>>>        Object oName is a cCJGridColumn
96578>>>>>            Set piWidth to 334
96579>>>>>            Set psCaption to "Table Space Name"
96580>>>>>        End_Object
96581>>>>>
96581>>>>>        Procedure Activating
96584>>>>>            tDataSourceRow[] MyData
96584>>>>>            tDataSourceRow[] MyData
96585>>>>>            Handle hoDataSource
96585>>>>>            String[] sTheData
96586>>>>>            Integer iCount iSize
96586>>>>>
96586>>>>>            Send Cursor_Wait of Cursor_Control
96587>>>>>            Forward Send Activating
96589>>>>>
96589>>>>>            Get psTheData to sTheData
96590>>>>>            Move (SizeOfArray(sTheData)) to iSize
96591>>>>>            Decrement iSize
96592>>>>>            For iCount from 0 to iSize
96598>>>>>>
96598>>>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
96599>>>>>            Loop
96600>>>>>>
96600>>>>>
96600>>>>>            Get phoDataSource to hoDataSource
96601>>>>>            Send InitializeData of hoDataSource MyData
96602>>>>>            Send Cursor_Ready of Cursor_Control
96603>>>>>        End_Procedure
96604>>>>>
96604>>>>>    End_Object
96605>>>>>
96605>>>>>    Object oOK_Btn is a Button
96607>>>>>        Set Size to 14 50
96608>>>>>        Set Label    to "&OK"
96609>>>>>        Set Location to 98 68
96610>>>>>        Set peAnchors To anBottomRight
96611>>>>>
96611>>>>>        Procedure OnClick
96614>>>>>            Send Ok of oSelList
96615>>>>>        End_Procedure
96616>>>>>
96616>>>>>    End_Object
96617>>>>>
96617>>>>>    Object oCancel_Btn is a Button
96619>>>>>        Set Size to 14 50
96620>>>>>        Set Label    to "&Cancel"
96621>>>>>        Set Location to 98 123
96622>>>>>        Set peAnchors to anBottomRight
96623>>>>>
96623>>>>>        Procedure OnClick
96626>>>>>            Send Close_Panel
96627>>>>>        End_Procedure
96628>>>>>
96628>>>>>    End_Object
96629>>>>>
96629>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
96630>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
96631>>>>>End_Object
96632>>>Use SchemasSelection.dg
Including file: SchemasSelection.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\SchemasSelection.dg)
96632>>>>>Use Windows.pkg
96632>>>>>Use cCJGridPromptList.pkg  
96632>>>>>Use cRDCModalPanel.pkg
96632>>>>>Use cDbUpdateFunctionLibrary.pkg
96632>>>>>
96632>>>>>Object oSchemasSelection_sl is a cRDCModalPanel
96634>>>>>    Set Size to 118 177
96635>>>>>    Set Label to "SQL Schemas Selection"
96636>>>>>    Set piMinSize to 89 177
96637>>>>>    Set Location to 2 2
96638>>>>>    Set Icon to "DatabaseLookup1.ico"
96639>>>>>
96639>>>>>    Property String[] psTheData
96641>>>>>
96641>>>>>    If (ghoDbUpdateFunctionLibrary = 0) Begin
96643>>>>>        Object oDbUpateFunctionLibrary is a cDbUpdateFunctionLibrary
96645>>>>>        End_Object
96646>>>>>    End
96646>>>>>>
96646>>>>>
96646>>>>>    Object oSelList is a cCJGridPromptList
96648>>>>>        Set Size to 89 167
96649>>>>>        Set Location to 6 6
96650>>>>>        Set peAnchors to anAll
96651>>>>>        Set pbAllowColumnRemove to False
96652>>>>>        Set pbUseAlternateRowBackgroundColor to True
96653>>>>>        Set pbGrayIfDisable to False
96654>>>>>        Set pbHeaderReorders to False
96655>>>>>        Set pbHeaderSelectsColumn to False
96656>>>>>        Set pbHeaderTogglesDirection to False
96657>>>>>        Set pbShadeSortColumn to False
96658>>>>>        Set piFocusCellBackColor to clDkGray
96659>>>>>
96659>>>>>        Object oName is a cCJGridColumn
96661>>>>>            Set piWidth to 334
96662>>>>>            Set psCaption to "Schema Name"
96663>>>>>        End_Object
96664>>>>>
96664>>>>>        Procedure Activating
96667>>>>>            tDataSourceRow[] MyData
96667>>>>>            tDataSourceRow[] MyData
96668>>>>>            Handle hoDataSource
96668>>>>>            String[] sTheData
96669>>>>>            Integer iCount iSize
96669>>>>>
96669>>>>>            Send Cursor_Wait of Cursor_Control
96670>>>>>            Forward Send Activating
96672>>>>>
96672>>>>>            Get psTheData to sTheData
96673>>>>>
96673>>>>>            Move (SizeOfArray(sTheData)) to iSize
96674>>>>>            Decrement iSize
96675>>>>>            For iCount from 0 to iSize
96681>>>>>>
96681>>>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
96682>>>>>            Loop
96683>>>>>>
96683>>>>>
96683>>>>>            Get phoDataSource to hoDataSource
96684>>>>>            Send InitializeData of hoDataSource MyData
96685>>>>>            Send Cursor_Ready of Cursor_Control
96686>>>>>        End_Procedure
96687>>>>>
96687>>>>>    End_Object
96688>>>>>
96688>>>>>    Object oOK_Btn is a Button
96690>>>>>        Set Size to 14 50
96691>>>>>        Set Label    to "&OK"
96692>>>>>        Set Location to 98 68
96693>>>>>        Set peAnchors To anBottomRight
96694>>>>>
96694>>>>>        Procedure OnClick
96697>>>>>            Send Ok of oSelList
96698>>>>>        End_Procedure
96699>>>>>
96699>>>>>    End_Object
96700>>>>>
96700>>>>>    Object oCancel_Btn is a Button
96702>>>>>        Set Size to 14 50
96703>>>>>        Set Label    to "&Cancel"
96704>>>>>        Set Location to 98 123
96705>>>>>        Set peAnchors to anBottomRight
96706>>>>>
96706>>>>>        Procedure OnClick
96709>>>>>            Send Close_Panel
96710>>>>>        End_Procedure
96711>>>>>
96711>>>>>    End_Object
96712>>>>>
96712>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
96713>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
96714>>>>>End_Object
96715>>>Use cRDCHeaderGroup.pkg  
Including file: cRDCHeaderGroup.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cRDCHeaderGroup.pkg)
96715>>>>>//****************************************************************************
96715>>>>>// $Module type: Package
96715>>>>>// $Module name: cRDCHeaderGroup.pkg
96715>>>>>//
96715>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
96715>>>>>// Copyright (c) 2017 RDC Tools International
96715>>>>>// E-mail      : support@rdctools.com
96715>>>>>// Web-site    : http://www.rdctools.com
96715>>>>>//
96715>>>>>// Created     : 2017-01-05 @ 19:04 (Military date format - Year-Month-Day)
96715>>>>>//
96715>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
96715>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
96715>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
96715>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
96715>>>>>// in the help folder for more details.
96715>>>>>//
96715>>>>>//****************************************************************************
96715>>>>>Use Windows.pkg
96715>>>>>Use cCommandLinkButton.pkg
Including file: cCommandLinkButton.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCommandLinkButton.pkg)
96715>>>>>>>// This requires version 6 of common controls (vista or windows server 2008). If used with
96715>>>>>>>// older versions you will just get a regular great big button.
96715>>>>>>>
96715>>>>>>>Use Windows.pkg
96715>>>>>>>Use CharTranslate.pkg
96715>>>>>>>
96715>>>>>>>Class cCommandLinkButton is a Button
96716>>>>>>>    
96716>>>>>>>    Procedure Construct_Object
96718>>>>>>>        Forward Send Construct_Object
96720>>>>>>>        Property String psPrivateNote
96721>>>>>>>    End_Procedure
96722>>>>>>>    
96722>>>>>>>    Procedure Set psNote String sNote
96724>>>>>>>        Boolean bSupported
96724>>>>>>>        Set psPrivateNote to sNote
96725>>>>>>>        Get IsExControlSupported to bSupported
96726>>>>>>>        If bSupported Begin
96728>>>>>>>            Send SetWinNote
96729>>>>>>>        End
96729>>>>>>>>
96729>>>>>>>    End_Procedure
96730>>>>>>>    
96730>>>>>>>    Procedure SetWinNote
96732>>>>>>>        WString wNote
96732>>>>>>>        Handle hWnd
96732>>>>>>>        Integer i
96732>>>>>>>        Pointer pVar
96732>>>>>>>        Get Form_Window_Handle 0 to hWnd
96733>>>>>>>        If hWnd Begin
96735>>>>>>>            Get psNote to wNote
96736>>>>>>>            Move (SendMessage(hwnd, BCM_SETNOTE, 0, AddressOf(wNote))) to i
96737>>>>>>>        End
96737>>>>>>>>
96737>>>>>>>    End_Procedure
96738>>>>>>>    
96738>>>>>>>    
96738>>>>>>>    Function psNote Returns String
96740>>>>>>>        Function_Return (psPrivateNote(Self))
96741>>>>>>>    End_Function
96742>>>>>>>    
96742>>>>>>>    
96742>>>>>>>    Procedure Page Integer iState
96744>>>>>>>        Integer i hWnd
96744>>>>>>>        Boolean bSupported
96744>>>>>>>        Get IsExControlSupported to bSupported
96745>>>>>>>        If (iState=1 and bSupported) Begin
96747>>>>>>>            Get form_style i to i
96748>>>>>>>            Set Form_Style 0 to (i ior (BS_COMMANDLINK + BS_FLAT))
96749>>>>>>>            Forward Send Page iState
96751>>>>>>>            Send SetWinNote
96752>>>>>>>        End
96752>>>>>>>>
96752>>>>>>>        Else Begin
96753>>>>>>>            Forward Send Page iState
96755>>>>>>>        End
96755>>>>>>>>
96755>>>>>>>    End_Procedure
96756>>>>>>>    
96756>>>>>>>End_Class
96757>>>>>
96757>>>>>Define clGreenGrey      for (RGB(64, 84, 93))
96757>>>>>Define clGreenGreyLight for (RGB(7, 117, 104))
96757>>>>>
96757>>>>>Class cRDCHeaderGroupImage is a cCommandLinkButton
96758>>>>>    Procedure Construct_Object
96760>>>>>        Forward Send Construct_Object
96762>>>>>
96762>>>>>        Set Size to 18 19
96763>>>>>        Set Focus_Mode to NonFocusable
96764>>>>>        Set peImageAlign to Button_ImageList_Align_Top
96765>>>>>        Set pbAutoResizeIcons to True
96766>>>>>    End_Procedure
96767>>>>>
96767>>>>>    Procedure OnClick
96769>>>>>        Broadcast Send Prompt of (Parent(Self))
96771>>>>>    End_Procedure
96772>>>>>
96772>>>>>    Procedure Set Bitmap String sBitmapName
96774>>>>>        Forward Set psImage to sBitmapName
96776>>>>>    End_Procedure
96777>>>>>
96777>>>>>    Procedure End_Construct_Object
96779>>>>>        Set pbShield to False
96780>>>>>        Forward Send End_Construct_Object
96782>>>>>    End_Procedure
96783>>>>>
96783>>>>>End_Class
96784>>>>>
96784>>>>>// Intermediate class - don't use.
96784>>>>>Class _cRDCHeaderGroup is a Container3d
96785>>>>>
96785>>>>>    Procedure Construct_Object
96787>>>>>        Forward Send Construct_Object
96789>>>>>
96789>>>>>        Property String private.psImage
96790>>>>>        Property String private.psLabel
96791>>>>>
96791>>>>>    End_Procedure
96792>>>>>
96792>>>>>    Procedure Set psImage String sImage
96794>>>>>        Set private.psImage to sImage
96795>>>>>    End_Procedure
96796>>>>>
96796>>>>>    Function psImage Returns String
96798>>>>>        Function_Return (private.psImage(Self))
96799>>>>>    End_Function
96800>>>>>
96800>>>>>    Procedure Set psLabel String sLabel
96802>>>>>        Set private.psLabel to sLabel
96803>>>>>    End_Procedure
96804>>>>>
96804>>>>>    Function psLabel Returns String
96806>>>>>        Function_Return (private.psLabel(Self))
96807>>>>>    End_Function
96808>>>>>
96808>>>>>    // Don't display but allow to use old "Label" syntax to set the value of the oInfo_tb object (header text)
96808>>>>>    Procedure Set Label String sLabel
96810>>>>>        Set psLabel to sLabel
96811>>>>>    End_Procedure
96812>>>>>
96812>>>>>    Function Label Returns String
96814>>>>>        Function_Return (private.psLabel(Self))
96815>>>>>    End_Function
96816>>>>>
96816>>>>>End_Class
96817>>>>>
96817>>>>>Register_Procedure NavigatePrevious
96817>>>>>Register_Procedure NavigateNext
96817>>>>>
96817>>>>>Class cRDCHeaderGroup is a _cRDCHeaderGroup
96818>>>>>
96818>>>>>    Procedure Construct_Object
96820>>>>>        Forward Send Construct_Object
96822>>>>>
96822>>>>>        Set peAnchors to anTopLeftRight
96823>>>>>        Set pbAcceptDropFiles to True
96824>>>>>        Set Border_Style to Border_Normal
96825>>>>>
96825>>>>>        Property Integer private.piColorOrg
96826>>>>>        Property Boolean private.pbIsHeaderGroup True // Don't touch!
96827>>>>>        Property String private.psToolTip ""
96828>>>>>
96828>>>>>        Property Integer piImageColOffset 4
96829>>>>>        Property Integer piImageRowOffset -1
96830>>>>>        Property String psNote ""
96831>>>>>        Property Boolean pbLargeImageSize True
96832>>>>>        Property Integer private.piLargeImageSize 24
96833>>>>>        Property Integer private.piSmallImageSize 16
96834>>>>>        Property Boolean pbUseHotspotColor False
96835>>>>>        Property Integer piHeaderHotspotColor clAqua
96836>>>>>        Property String private.psLabel ""
96837>>>>>        Property Integer piLabelColor clGreenGrey
96838>>>>>        Property Boolean pbLabelFontItalics False
96839>>>>>        Property Integer piLabelLargeFontHeight 12
96840>>>>>        Property Integer piLabelSmallFontHeight 10
96841>>>>>        Property Boolean pbUseLargeFontHeight False
96842>>>>>
96842>>>>>        Property Integer piLabelFontPointWeight fw_Bold
96843>>>>>        Property Integer piLabelColOffset 28
96844>>>>>        Property Integer piLabelRowOffset 4
96845>>>>>        Property Boolean pbCreateTooltipItem True
96846>>>>>
96846>>>>>        Set pbAcceptDropFiles to True
96847>>>>>
96847>>>>>        Send Define_ToolTip_Support_Mixin
96848>>>>>
96848>>>>>        // For the Studio to render the header image
96848>>>>>        Set Bitmap to "Default32x32.bmp"
96849>>>>>        // This doesn't work... I wonder if there's a way to "trick" the Studio
96849>>>>>        // to render some text in the header when in design mode?
96849>>>>>        Set Label to "HEADER TEXT"
96850>>>>>
96850>>>>>        On_Key kLeftArrow  Send NavigatePrevious
96851>>>>>        On_Key kUpArrow    Send NavigatePrevious
96852>>>>>        On_Key kRightArrow Send NavigateNext
96853>>>>>        On_Key kDownArrow  Send NavigateNext
96854>>>>>        On_Key kSwitch     Send Switch_Next_Area
96855>>>>>    End_Procedure
96856>>>>>
96856>>>>>    Import_Class_Protocol ToolTip_Support_Mixin
96857>>>>>
96857>>>>>    Procedure Set psImage String sImage
96859>>>>>        Set Bitmap to ""
96860>>>>>        Forward Set psImage to sImage
96862>>>>>    End_Procedure
96863>>>>>
96863>>>>>    Function psImage Returns String
96865>>>>>        Function_Return (psImage(Self))
96866>>>>>    End_Function
96867>>>>>
96867>>>>>    Procedure Set Label String sLabel
96869>>>>>        Forward Set psLabel to sLabel
96871>>>>>    End_Procedure
96872>>>>>
96872>>>>>    Procedure Set psToolTip String sToolTip
96874>>>>>        Set private.psToolTip to sToolTip
96875>>>>>    End_Procedure
96876>>>>>
96876>>>>>    Function psToolTip Returns String
96878>>>>>        Function_Return (private.psToolTip(Self))
96879>>>>>    End_Function
96880>>>>>
96880>>>>>    Procedure End_Construct_Object
96882>>>>>        String sNote sLabel
96882>>>>>        Boolean bUseLargeFontHeight bLargeImageSize bCreateTooltipItem
96882>>>>>        Integer iFontHeight iImageSize iLabelRowOffset iLabelColOffset iSize iTextOffset
96882>>>>>
96882>>>>>        Forward Send End_Construct_Object
96884>>>>>
96884>>>>>        Get piLabelColOffset to iLabelColOffset
96885>>>>>        Get pbUseLargeFontHeight to bUseLargeFontHeight
96886>>>>>        If (bUseLargeFontHeight = True) Begin
96888>>>>>            Get piLabelLargeFontHeight to iFontHeight
96889>>>>>            Move 8 to iLabelRowOffset
96890>>>>>        End
96890>>>>>>
96890>>>>>        Else Begin
96891>>>>>            Get piLabelSmallFontHeight to iFontHeight
96892>>>>>            Move 6 to iLabelRowOffset
96893>>>>>        End
96893>>>>>>
96893>>>>>
96893>>>>>        Get pbLargeImageSize to bLargeImageSize
96894>>>>>        If (bLargeImageSize = True) Begin
96896>>>>>            Get private.piLargeImageSize to iImageSize
96897>>>>>        End
96897>>>>>>
96897>>>>>        Else Begin
96898>>>>>            Get private.piSmallImageSize to iImageSize
96899>>>>>            Move (iLabelColOffset - 6) to iLabelColOffset
96900>>>>>        End
96900>>>>>>
96900>>>>>
96900>>>>>        Object oHeaderGroupImage is a cRDCHeaderGroupImage
96902>>>>>            Set piImageSize to iImageSize
96903>>>>>            Set Location to (piImageRowOffset(Self)) (piImageColOffset(Self))
96904>>>>>            Set psImage to (private.psImage(Self))
96905>>>>>            Set peImageAlign to Button_ImageList_Align_Center
96906>>>>>            Set psToolTip to (private.psToolTip(Self))
96907>>>>>        End_Object
96908>>>>>
96908>>>>>        Object oHeaderGroupInfo_tb is a TextBox
96910>>>>>            Set Size to 12 100
96911>>>>>            Set Location to (piLabelRowOffset(Self)) iLabelColOffset
96912>>>>>            Set FontWeight to (piLabelFontPointWeight(Self))
96913>>>>>            Set FontItalics to (pbLabelFontItalics(Self))
96914>>>>>            Set FontPointHeight to iFontHeight
96915>>>>>            Set Label to (private.psLabel(Self))
96916>>>>>            Set TextColor to (piLabelColor(Self))
96917>>>>>            Set psToolTip to (private.psToolTip(Self))
96918>>>>>            Get Size to iSize
96919>>>>>        End_Object
96920>>>>>
96920>>>>>        // ToDo: The positioning logic for placing the info image to the right of the header text is flawed.
96920>>>>>        // How can it be improved?
96920>>>>>        Get pbCreateTooltipItem to bCreateTooltipItem
96921>>>>>        If (bCreateTooltipItem = True and private.psToolTip(Self) <> "") Begin
96923>>>>>            Get private.psLabel to sLabel
96924>>>>>            Get Text_Extent sLabel to iTextOffset
96925>>>>>            Move (Low(iTextOffset) -0)  to iTextOffset
96926>>>>>            Object oHeaderGroupTooltip_tb is a TextBox
96928>>>>>                Set Size to 10 10
96929>>>>>                If (bUseLargeFontHeight = True) Begin
96931>>>>>                    //                    Set Location to (piLabelRowOffset(Self)) iTextOffset //(Low(iSize) + (iTextOffset))
96931>>>>>                    Set Location to (piLabelRowOffset(Self)) (Low(iSize) + (iLabelColOffset * 2) + 10)
96932>>>>>                End
96932>>>>>>
96932>>>>>                Else Begin
96933>>>>>                    //                    Set Location to (piLabelRowOffset(Self)) iTextOffset
96933>>>>>                    Set Location to (piLabelRowOffset(Self)) (Low(iSize) + iLabelColOffset + 25)
96934>>>>>                End
96934>>>>>>
96934>>>>>                Set psToolTip to (private.psToolTip(Self))
96935>>>>>                Set Bitmap to "ActionAbout.bmp"
96936>>>>>            End_Object
96937>>>>>        End
96937>>>>>>
96937>>>>>
96937>>>>>        Get psNote to sNote
96938>>>>>        If (Trim(sNote) <> "") Begin
96940>>>>>            Object oHeaderGroupNote_tb is a TextBox
96942>>>>>                Set Size to 12 100
96943>>>>>                Set Location to (Hi(iSize) + iLabelRowOffset) (iLabelColOffset + 8)
96944>>>>>                Set Label to ("-" * String(sNote))
96945>>>>>                Set TextColor to (piLabelColor(Self))
96946>>>>>                Set FontPointHeight to 9
96947>>>>>                Set psToolTip to (private.psToolTip(Self))
96948>>>>>            End_Object
96949>>>>>        End
96949>>>>>>
96949>>>>>
96949>>>>>    End_Procedure
96950>>>>>
96950>>>>>    Function Popup_State Returns Boolean
96952>>>>>        Boolean bIsPopup
96952>>>>>        Get Popup_State of (Parent(Self)) to bIsPopup
96953>>>>>        Function_Return bIsPopup
96954>>>>>    End_Function
96955>>>>>
96955>>>>>    Procedure OnEnterArea Handle hoFrom
96957>>>>>        Integer iColor
96957>>>>>        Forward Send OnEnterArea hoFrom
96959>>>>>        // Not ideal, but works most of the time.
96959>>>>>        //       When navigating to i.e a popup we don't want
96959>>>>>        //       the coloring to appear. Else there will be 2
96959>>>>>        //       cRDCHeaderGroup's with the highlight color...
96959>>>>>        // Is there a better way?
96959>>>>>        If (hoFrom <> Desktop and hoFrom < Parent(Self)) Begin
96961>>>>>            Procedure_Return
96962>>>>>        End
96962>>>>>>
96962>>>>>        If (pbUseHotspotColor(Self) = True) Begin
96964>>>>>            Get Color to iColor
96965>>>>>            Set private.piColorOrg to iColor
96966>>>>>            Get piHeaderHotspotColor to iColor
96967>>>>>            Set Color to iColor
96968>>>>>            Broadcast Recursive Set Color to iColor
96970>>>>>        End
96970>>>>>>
96970>>>>>    End_Procedure
96971>>>>>
96971>>>>>    Procedure OnExitArea Handle hoFrom
96973>>>>>        Integer iColor
96973>>>>>        Forward Send OnExitArea hoFrom
96975>>>>>        If (pbUseHotspotColor(Self) = True) Begin
96977>>>>>            Get private.piColorOrg to iColor
96978>>>>>            Set Color to iColor
96979>>>>>            Broadcast Recursive Set Color to iColor
96981>>>>>        End
96981>>>>>>
96981>>>>>    End_Procedure
96982>>>>>
96982>>>>>    // Public access message to change the group header text color at runtime.
96982>>>>>    Procedure Set Label_Color Integer iColor
96984>>>>>        Set TextColor of (oHeaderGroupInfo_tb(Self)) to iColor
96985>>>>>    End_Procedure
96986>>>>>
96986>>>>>    Procedure NavigatePrevious
96988>>>>>        Integer iMulti ivoid iLastErr
96988>>>>>        Handle hWnd
96988>>>>>        Boolean bErr
96988>>>>>
96988>>>>>        Move Err to bErr
96989>>>>>        Move LastErr to iLastErr
96990>>>>>
96990>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96991>>>>>        Get Select_Mode of (Focus(Self)) to iMulti
96992>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96993>>>>>        If (Err) Begin
96995>>>>>            Move bErr to Err
96996>>>>>            Move iLastErr to LastErr
96997>>>>>            Procedure_Return
96998>>>>>        End
96998>>>>>>
96998>>>>>
96998>>>>>        Move bErr to Err
96999>>>>>        Move iLastErr to LastErr
97000>>>>>        If (iMulti = Multi_Select) Begin
97002>>>>>            Send Previous
97003>>>>>        End
97003>>>>>>
97003>>>>>        Else Begin
97004>>>>>            Get Form_Window_Handle of (Focus(Self)) to hWnd
97005>>>>>            Move (Sendmessage(hWnd, WM_KEYDOWN, Ascii(VK_LEFT), 0)) to iVoid
97006>>>>>        End
97006>>>>>>
97006>>>>>    End_Procedure
97007>>>>>
97007>>>>>    Procedure NavigateNext
97009>>>>>        Integer iMulti iVoid iLastErr
97009>>>>>        Handle hWnd
97009>>>>>        Boolean bErr
97009>>>>>
97009>>>>>        Move Err to bErr
97010>>>>>        Move LastErr to iLastErr
97011>>>>>
97011>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
97012>>>>>        Get Select_Mode of (Focus(Self)) to iMulti
97013>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
97014>>>>>        If (Err) Begin
97016>>>>>            Move bErr to Err
97017>>>>>            Move iLastErr to LastErr
97018>>>>>            Procedure_Return
97019>>>>>        End
97019>>>>>>
97019>>>>>
97019>>>>>        Move bErr to Err
97020>>>>>        Move iLastErr to LastErr
97021>>>>>        If (iMulti = Multi_Select) Begin
97023>>>>>            Send Next
97024>>>>>        End
97024>>>>>>
97024>>>>>        Else Begin
97025>>>>>            Get Form_Window_Handle of (Focus(Self)) to hWnd
97026>>>>>            Move (Sendmessage(hWnd, WM_KEYDOWN, Ascii(VK_LEFT), 0)) to iVoid
97027>>>>>        End
97027>>>>>>
97027>>>>>
97027>>>>>    End_Procedure
97028>>>>>
97028>>>>>    Procedure Enable_Window Integer iState
97030>>>>>        Handle hWnd
97030>>>>>        Get Window_Handle to hWnd
97031>>>>>        If hWnd Begin
97033>>>>>            Move (EnableWindow(hWnd, iState)) to hWnd
97034>>>>>        End
97034>>>>>>
97034>>>>>    End_Procedure
97035>>>>>
97035>>>>>    Procedure Page_Object Integer iState
97037>>>>>        Handle hWnd
97037>>>>>        Get Window_Handle to hWnd
97038>>>>>        Forward Send Page_Object iState
97040>>>>>        If (hWnd = 0 and iState) Begin
97042>>>>>            Send Shadow_Display
97043>>>>>        End
97043>>>>>>
97043>>>>>    End_Procedure
97044>>>>>
97044>>>>>    Procedure Shadow_Display
97046>>>>>        Send Enable_Window (not(Object_Shadow_State(Self)))
97047>>>>>    End_Procedure
97048>>>>>
97048>>>>>    Function Explicit_Shadow_State Returns Boolean
97050>>>>>        Function_Return (Private.Explicit_Shadow_State(Self))
97051>>>>>    End_Function
97052>>>>>
97052>>>>>    // For some reason we need to augment this event to allow
97052>>>>>    // files to be dropped on a cRDCHeaderGroup object; else nothing will
97052>>>>>    // happen.
97052>>>>>    Procedure OnFileDropped String sFilename Boolean bLast
97054>>>>>        Delegate Send OnFileDropped sFilename bLast
97056>>>>>    End_Procedure
97057>>>>>
97057>>>>>End_Class
97058>>>>>
97058>>>>>// We don't want the broadcast of setting color to set the background
97058>>>>>// color for forms that are within a cRDCHeaderGroup object.
97058>>>>>// If the Form is not within a cRDCHeaderGroup the Form class should
97058>>>>>// behave as it always has. But if you don't like this; just comment
97058>>>>>// it out.
97058>>>>>//Procedure Set Color for Form Integer eColor
97058>>>>>//    Boolean bIsHeaderGroup bErr bEnabled_State
97058>>>>>//    Integer iLastErr
97058>>>>>//
97058>>>>>//    Move Err to bErr
97058>>>>>//    Move LastErr to iLastErr
97058>>>>>//
97058>>>>>//    Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
97058>>>>>//    Delegate Get private.pbIsHeaderGroup to bIsHeaderGroup
97058>>>>>//    Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
97058>>>>>//    Move bErr to Err
97058>>>>>//    Move iLastErr to LastErr
97058>>>>>//    If (bIsHeaderGroup = False) Begin
97058>>>>>//        Forward Set Color to eColor
97058>>>>>//    End
97058>>>>>//End_Procedure
97058>>>Use DriverSettings.dg
Including file: DriverSettings.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DriverSettings.dg)
97058>>>>>Use cApplication.pkg
97058>>>>>Use Dfline.pkg
97058>>>>>Use cRichEdit.pkg
97058>>>>>Use cScrollingContainer.pkg
Including file: cScrollingContainer.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cScrollingContainer.pkg)
97058>>>>>>>// Provides support for scrolling containers.
97058>>>>>>>// Scrolling containers is provided by creating two objects,
97058>>>>>>>// a host (cScrollingContainer) and a scrolling clientarea (cScrollingClientArea)
97058>>>>>>>// The host has no public interface, you just drop the object. It should have only one child object
97058>>>>>>>// and that should be a scrolling client-area. If it is not, it is an error. It is also considered
97058>>>>>>>// an error to place a scrolling client area in any object other than a scrolling container.
97058>>>>>>>
97058>>>>>>>Use Windows.pkg
97058>>>>>>>Use cScrollingContainerMixin.pkg
Including file: cScrollingContainerMixin.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cScrollingContainerMixin.pkg)
97058>>>>>>>>>// Mixin classes for scrolling container support:
97058>>>>>>>>>// cScrollingContainerMixin & cScrollingClientAreaMixin
97058>>>>>>>>>// These are used by cSrollingContainer / cScrollingClientArea and
97058>>>>>>>>>// dbScrollingContainer / dbScrollingClientArea.
97058>>>>>>>>>// The scrolling container has no public interface, you just drop the object. It should have only one child object
97058>>>>>>>>>// and that should be a scrolling client-area. If it is not, it is an error. It is also considered
97058>>>>>>>>>// an error to place a scrolling client area in any object other than a scrolling container.
97058>>>>>>>>>
97058>>>>>>>>>Use Windows.pkg
97058>>>>>>>>>Use Winuser.pkg
97058>>>>>>>>>Use tWinStructs.pkg
97058>>>>>>>>>
97058>>>>>>>>>Register_Function pbTabbedWorkspaces Returns Boolean
97058>>>>>>>>>Register_Function pbCenterTabbedViews Returns Boolean
97058>>>>>>>>>// support for the scrolling client area mixin object.
97058>>>>>>>>>
97058>>>>>>>>>Class cScrollingClientAreaMixin is a Mixin
97059>>>>>>>>>    
97059>>>>>>>>>    Procedure Define_cScrollingClientAreaMixin
97061>>>>>>>>>        
97061>>>>>>>>>        Set pbSizeToClientArea to False // should already be set to this, but just in case.
97062>>>>>>>>>        Set Border_Style to Border_None
97063>>>>>>>>>        
97063>>>>>>>>>        Property Boolean pbAutoScroll True
97064>>>>>>>>>        Property Boolean pbAutoScrollFocus True
97065>>>>>>>>>        Property Integer piAutoScrollMarginX 5
97066>>>>>>>>>        Property Integer piAutoScrollMarginY 5
97067>>>>>>>>>        Property Integer piAutoScrollMinX 0
97068>>>>>>>>>        Property Integer piAutoScrollMinY 0
97069>>>>>>>>>        Property Boolean pbShowDisabledScrollBar False
97070>>>>>>>>>        
97070>>>>>>>>>        
97070>>>>>>>>>        Property Integer piLineScrollUnit  5 // minimum scrolling unit for line up/down and mouse wheel
97071>>>>>>>>>        Property Integer piMinimumHeight 0 // the minimum height that doesn't need scrolling
97072>>>>>>>>>        Property Integer piMinimumWidth 0 //(the minimum width that doesn't need scrolling
97073>>>>>>>>>        // keeps track of scrolling
97073>>>>>>>>>        Property Integer piCurrentVertScrolled 0
97074>>>>>>>>>        Property Integer piCurrentHorzScrolled 0
97075>>>>>>>>>        Property Integer piWheelDelta 0               // internal, accumulates mouse wheel clicks
97076>>>>>>>>>        Delegate Set phoScrollingClientArea to Self
97078>>>>>>>>>        
97078>>>>>>>>>        // set this true to make this a tabbed workspace view (design time)
97078>>>>>>>>>        Property Boolean pbTabWorkspaceView False
97079>>>>>>>>>        // set this false to stop auto-determination of pbTabWorkspaceView (design time)
97079>>>>>>>>>        Property Boolean pbAutoSetTabWorkspaceView True
97080>>>>>>>>>    End_Procedure
97081>>>>>>>>>    
97081>>>>>>>>>    // low level event sent from windows.
97081>>>>>>>>>    Procedure OnWmMouseWheel Integer wParam Integer lParam
97083>>>>>>>>>        Integer iWheelDelta iKeys iDelta iClicks
97083>>>>>>>>>        Move (low(abs(wParam))) to iKeys           // any keys down when pressed
97084>>>>>>>>>        Move (hi(abs(wParam))) to iDelta           // number of click units
97085>>>>>>>>>        If (wParam<0) Begin
97087>>>>>>>>>            Move (-iDelta) to iDelta     // can be up or down
97088>>>>>>>>>        End
97088>>>>>>>>>>
97088>>>>>>>>>        Get  piWheelDelta to iWheelDelta           // Current accumulated micro clicks
97089>>>>>>>>>        Move (iWheelDelta+iDelta) to iWheelDelta
97090>>>>>>>>>        // C_WHEELDATA is 120 as defined by MS as the delta to react to. Once click is usually 120
97090>>>>>>>>>        Move (iWheelDelta/C_WHEELDELTA) to iClicks // Number of clicks to react to
97091>>>>>>>>>        Set  piWheelDelta to (mod(iWheelDelta,C_WHEELDELTA)) // remainder unused microclicks
97092>>>>>>>>>        // If we have enough Clicks send OnMouseWheel
97092>>>>>>>>>        If (iClicks<>0) Begin
97094>>>>>>>>>            Send OnMouseWheel iClicks iKeys
97095>>>>>>>>>        End
97095>>>>>>>>>>
97095>>>>>>>>>        // tell windows that we've handled the event.
97095>>>>>>>>>        Set Windows_Override_State to True
97096>>>>>>>>>    End_Procedure
97097>>>>>>>>>    
97097>>>>>>>>>    
97097>>>>>>>>>    // should be sent by DF message OnWMMouseWheel , which is sent by WM_MOUSEWHEEL
97097>>>>>>>>>    Procedure OnMouseWheel Integer iClicks Integer iKey
97099>>>>>>>>>        Integer iLineScrollUnit
97099>>>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
97100>>>>>>>>>        Send VScroll (-iClicks*iLineScrollUnit*2) // (If(iClicks>0,False,True)) (abs(iClicks))
97101>>>>>>>>>    End_Procedure
97102>>>>>>>>>    
97102>>>>>>>>>    // should be sent by WM_VSCROLL
97102>>>>>>>>>    Procedure SetVScrollbox Integer iType Integer iNewPos
97104>>>>>>>>>        Boolean bOk
97104>>>>>>>>>        tWinScrollInfo ScrollInfo
97104>>>>>>>>>        tWinScrollInfo ScrollInfo
97104>>>>>>>>>        Integer iLineScrollUnit
97104>>>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
97105>>>>>>>>>        Get GetScrollBarInfo True (&ScrollInfo) to bOk
97106>>>>>>>>>        If bOk Begin
97108>>>>>>>>>            
97108>>>>>>>>>            Case Begin
97108>>>>>>>>>                Case (iType=SB_PAGEDOWN)
97110>>>>>>>>>                    Send VScroll ScrollInfo.nPage
97111>>>>>>>>>                    Case Break
97112>>>>>>>>>                
97112>>>>>>>>>                Case (iType=SB_PAGEUP)
97115>>>>>>>>>                    Send VScroll (-Integer(ScrollInfo.nPage))
97116>>>>>>>>>                    Case Break
97117>>>>>>>>>                
97117>>>>>>>>>                Case (iType=SB_LINEDOWN)
97120>>>>>>>>>                    Send VScroll iLineScrollUnit
97121>>>>>>>>>                    Case Break
97122>>>>>>>>>                
97122>>>>>>>>>                Case (iType=SB_LINEUP)
97125>>>>>>>>>                    Send VScroll (-iLineScrollUnit)
97126>>>>>>>>>                    Case Break
97127>>>>>>>>>                
97127>>>>>>>>>                Case (iType=SB_BOTTOM)
97130>>>>>>>>>                    Send VScroll (ScrollInfo.nMax-ScrollInfo.nPos)
97131>>>>>>>>>                    Case Break
97132>>>>>>>>>                
97132>>>>>>>>>                Case (iType=SB_Top)
97135>>>>>>>>>                    Send VScroll (-ScrollInfo.nPos)
97136>>>>>>>>>                    Case Break
97137>>>>>>>>>                
97137>>>>>>>>>                Case (iType=SB_THUMBPOSITION)
97140>>>>>>>>>                    Case Break
97141>>>>>>>>>                
97141>>>>>>>>>                Case (iType=SB_THUMBTRACK)
97144>>>>>>>>>                    Send VScroll (ScrollInfo.nTrackPos-ScrollInfo.nPos)
97145>>>>>>>>>                    Case Break
97146>>>>>>>>>            Case End
97146>>>>>>>>>        End
97146>>>>>>>>>>
97146>>>>>>>>>    End_Procedure
97147>>>>>>>>>    
97147>>>>>>>>>    // should be sent by WM_HSCROLL
97147>>>>>>>>>    Procedure SetHScrollbox Integer iType Integer iNewPos
97149>>>>>>>>>        Boolean bOk
97149>>>>>>>>>        tWinScrollInfo ScrollInfo
97149>>>>>>>>>        tWinScrollInfo ScrollInfo
97149>>>>>>>>>        Integer iLineScrollUnit
97149>>>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
97150>>>>>>>>>        Get GetScrollBarInfo False (&ScrollInfo) to bOk
97151>>>>>>>>>        If bOk Begin
97153>>>>>>>>>            
97153>>>>>>>>>            Case Begin
97153>>>>>>>>>                Case (iType=SB_PAGEDOWN)
97155>>>>>>>>>                    Send hScroll ScrollInfo.nPage
97156>>>>>>>>>                    Case Break
97157>>>>>>>>>                
97157>>>>>>>>>                Case (iType=SB_PAGEUP)
97160>>>>>>>>>                    Send hScroll (-Integer(ScrollInfo.nPage))
97161>>>>>>>>>                    Case Break
97162>>>>>>>>>                
97162>>>>>>>>>                Case (iType=SB_LINEDOWN)
97165>>>>>>>>>                    Send hScroll iLineScrollUnit
97166>>>>>>>>>                    Case Break
97167>>>>>>>>>                
97167>>>>>>>>>                Case (iType=SB_LINEUP)
97170>>>>>>>>>                    Send hScroll (-iLineScrollUnit)
97171>>>>>>>>>                    Case Break
97172>>>>>>>>>                
97172>>>>>>>>>                Case (iType=SB_BOTTOM)
97175>>>>>>>>>                    Send hScroll (ScrollInfo.nMax-ScrollInfo.nPos)
97176>>>>>>>>>                    Case Break
97177>>>>>>>>>                
97177>>>>>>>>>                Case (iType=SB_Top)
97180>>>>>>>>>                    Send hScroll (-ScrollInfo.nPos)
97181>>>>>>>>>                    Case Break
97182>>>>>>>>>                
97182>>>>>>>>>                Case (iType=SB_THUMBPOSITION)
97185>>>>>>>>>                    Case Break
97186>>>>>>>>>                
97186>>>>>>>>>                Case (iType=SB_THUMBTRACK)
97189>>>>>>>>>                    Send hScroll (ScrollInfo.nTrackPos-ScrollInfo.nPos)
97190>>>>>>>>>                    Case Break
97191>>>>>>>>>            Case End
97191>>>>>>>>>        End
97191>>>>>>>>>>
97191>>>>>>>>>    End_Procedure
97192>>>>>>>>>    
97192>>>>>>>>>    
97192>>>>>>>>>    // this calls SetScrollInfo with proper info
97192>>>>>>>>>    Procedure SetScrollBarInfo Boolean bVert Integer iRangeMin Integer iRangeMax Integer iPageSize
97194>>>>>>>>>        tWinScrollInfo ScrollInfo
97194>>>>>>>>>        tWinScrollInfo ScrollInfo
97194>>>>>>>>>        Integer iVoid
97194>>>>>>>>>        Handle hWnd
97194>>>>>>>>>        Boolean bShow
97194>>>>>>>>>        
97194>>>>>>>>>        Delegate Get Window_Handle to hWnd
97196>>>>>>>>>        If (hWnd <> 0) Begin
97198>>>>>>>>>            Move (SizeOfType (tWinScrollInfo)) to ScrollInfo.cbSize
97199>>>>>>>>>            
97199>>>>>>>>>            Move (SIF_RANGE ior SIF_POS ior SIF_PAGE ) to ScrollInfo.fMask
97200>>>>>>>>>            Get pbShowDisabledScrollBar to bShow
97201>>>>>>>>>            If bShow Begin
97203>>>>>>>>>                Move (ScrollInfo.fMask ior SIF_DISABLENOSCROLL) to ScrollInfo.fMask
97204>>>>>>>>>            End
97204>>>>>>>>>>
97204>>>>>>>>>            Move iRangeMin to ScrollInfo.nMin
97205>>>>>>>>>            Move iRangeMax to ScrollInfo.nMax
97206>>>>>>>>>            Move iPageSize to ScrollInfo.nPage
97207>>>>>>>>>            Move 0 to ScrollInfo.nPos
97208>>>>>>>>>            Move (SetScrollInfo (hWnd, If(bVert,SB_VERT,SB_HORZ), AddressOf (ScrollInfo), True)) to iVoid
97209>>>>>>>>>            
97209>>>>>>>>>        End
97209>>>>>>>>>>
97209>>>>>>>>>    End_Procedure
97210>>>>>>>>>    
97210>>>>>>>>>    // this wraps GetScrollInfo
97210>>>>>>>>>    Function GetScrollBarInfo Boolean bVert tWinScrollInfo ByRef ScrollInfo Returns Boolean
97212>>>>>>>>>        Boolean bOk
97212>>>>>>>>>        Handle hWnd
97212>>>>>>>>>        
97212>>>>>>>>>        Delegate Get Window_Handle to hWnd
97214>>>>>>>>>        If (hWnd <> 0) Begin
97216>>>>>>>>>            Move (SizeOfType (tWinScrollInfo)) to ScrollInfo.cbSize
97217>>>>>>>>>            Move (SIF_ALL) to ScrollInfo.fMask
97218>>>>>>>>>            Move (GetScrollInfo (hWnd, If(bVert,SB_VERT,SB_HORZ), AddressOf (ScrollInfo))) to bOk
97219>>>>>>>>>        End
97219>>>>>>>>>>
97219>>>>>>>>>        Function_Return bOk
97220>>>>>>>>>    End_Function
97221>>>>>>>>>    
97221>>>>>>>>>    // this wraps SetScrollPos
97221>>>>>>>>>    Procedure SetScrollBarPosInfo Boolean bVert Integer iPos
97223>>>>>>>>>        Integer iVoid
97223>>>>>>>>>        Handle hWnd
97223>>>>>>>>>        
97223>>>>>>>>>        Delegate Get Window_Handle to hWnd
97225>>>>>>>>>        If (hWnd <> 0) Begin
97227>>>>>>>>>            Move (SetScrollPos(hWnd, If(bVert,SB_VERT,SB_HORZ), iPos, True)) to iVoid
97228>>>>>>>>>        End
97228>>>>>>>>>>
97228>>>>>>>>>    End_Procedure
97229>>>>>>>>>    
97229>>>>>>>>>    // scrolling containers don't do anhcors. However, this gets called every time the parent's
97229>>>>>>>>>    // guiSize changes. We can use that to scroll or resize the scrolling client as needed.
97229>>>>>>>>>    Procedure DoapplyAnchors Integer Arg1 Integer Arg2
97231>>>>>>>>>        Send ScrollClientArea
97232>>>>>>>>>    End_Procedure
97233>>>>>>>>>    
97233>>>>>>>>>    // augment to handle the scrolling area initialization.
97233>>>>>>>>>    Procedure Add_Focus Handle hoParent
97235>>>>>>>>>        Forward Send Add_Focus hoParent
97237>>>>>>>>>        // at this the scrolling container and client area should both be paged.
97237>>>>>>>>>        // child objects ae also paged with initial anchors applied
97237>>>>>>>>>        Send CalculateAutoScrollMinimums
97238>>>>>>>>>    End_Procedure
97239>>>>>>>>>    
97239>>>>>>>>>    Procedure Page Integer iPage
97241>>>>>>>>>        Forward Send Page iPage
97243>>>>>>>>>        If iPage Begin
97245>>>>>>>>>            // at this the scrolling container and client area should both be paged
97245>>>>>>>>>            // but the child controls are not paged. We don't want scrollbars when
97245>>>>>>>>>            // the child items are paged (else they may get anchored oddly)
97245>>>>>>>>>            // Prior to 19.0 these were set in Add_focus which meant that the child objects were
97245>>>>>>>>>            // already paged with scrollbars present. This would result in scrollbars appearing
97245>>>>>>>>>            // before they were really needed. This should be more accurate
97245>>>>>>>>>            Send SetScrollBarInfo True 0 0 0
97246>>>>>>>>>            Send SetScrollBarInfo False 0 0 0
97247>>>>>>>>>        End
97247>>>>>>>>>>
97247>>>>>>>>>    End_Procedure
97248>>>>>>>>>    
97248>>>>>>>>>    // determine scrolling minimums and set the client area as required.
97248>>>>>>>>>    
97248>>>>>>>>>    Procedure CalculateAutoScrollMinimums
97250>>>>>>>>>        Integer iMinX iMinY iSiz iLoc iMargin
97250>>>>>>>>>        Integer iAutoMinX iAutoMinY
97250>>>>>>>>>        Boolean bAutoScroll
97250>>>>>>>>>        Handle hoNext hoFirst
97250>>>>>>>>>        
97250>>>>>>>>>        Get pbAutoScroll to bAutoScroll
97251>>>>>>>>>        Get piAutoScrollMinX to iAutoMinX
97252>>>>>>>>>        Get piAutoScrollMinY to iAutoMinY
97253>>>>>>>>>        Get DialogToGui iAutoMinY iAutoMinX to iSiz
97254>>>>>>>>>        Move (Hi(iSiz)) to iAutoMinY
97255>>>>>>>>>        Move (Low(iSiz)) to iAutoMinX
97256>>>>>>>>>        Set piMinimumHeight to iAutoMinY
97257>>>>>>>>>        Set piMinimumWidth to iAutoMinX
97258>>>>>>>>>        
97258>>>>>>>>>        If (bAutoScroll and (iAutoMinX=0 or iAutoMinY=0)) Begin
97260>>>>>>>>>            
97260>>>>>>>>>            Get Next_Level to hoFirst
97261>>>>>>>>>            Move hoFirst to hoNext
97262>>>>>>>>>            If (hoFirst) Begin
97264>>>>>>>>>                Repeat
97264>>>>>>>>>>
97264>>>>>>>>>                    Get GuiWindowSize of hoNext to iSiz
97265>>>>>>>>>                    Get GuiLocation of hoNext to iLoc
97266>>>>>>>>>                    Move (Hi(iLoc)+Hi(iSiz) max iMinY) to iMinY
97267>>>>>>>>>                    Move (Low(iLoc)+Low(iSiz) max iMinX) to iMinx
97268>>>>>>>>>                    Get Next_Focus of hoNext to hoNext
97269>>>>>>>>>                Until (hoNext=0 or hoNext=hoFirst)
97271>>>>>>>>>                
97271>>>>>>>>>                If (iAutoMinY=0) Begin
97273>>>>>>>>>                    Get piAutoScrollMarginY to iMargin
97274>>>>>>>>>                    Set piMinimumHeight to (iMinY+iMargin)
97275>>>>>>>>>                End
97275>>>>>>>>>>
97275>>>>>>>>>                
97275>>>>>>>>>                If (iAutoMinX=0) Begin
97277>>>>>>>>>                    Get piAutoScrollMarginX to iMargin
97278>>>>>>>>>                    Set piMinimumWidth to (iMinX+iMargin)
97279>>>>>>>>>                    
97279>>>>>>>>>                End
97279>>>>>>>>>>
97279>>>>>>>>>            End
97279>>>>>>>>>>
97279>>>>>>>>>        End
97279>>>>>>>>>>
97279>>>>>>>>>        
97279>>>>>>>>>        // before setting the client area, unset all anchors so DoApplyAnchors will not do anything
97279>>>>>>>>>        Broadcast Set pbAnchorCreated to False
97281>>>>>>>>>        Send ScrollClientArea
97282>>>>>>>>>        // after the scroll set up, reinitialize all anchors.
97282>>>>>>>>>        Broadcast Send DoCreateAnchors
97284>>>>>>>>>    End_Procedure
97285>>>>>>>>>    
97285>>>>>>>>>    // Scroll the client area and adjust the client area size as needed. This does all the
97285>>>>>>>>>    // work of scrolling.
97285>>>>>>>>>    
97285>>>>>>>>>    Procedure ScrollClientArea
97287>>>>>>>>>        Integer iSiz
97287>>>>>>>>>        Integer iHeight iHCur iHCuriDelta iOrig iRange bOk
97287>>>>>>>>>        Integer iWidth iWCur iWDelta iWOrig
97287>>>>>>>>>        Integer iSzY iSzX iLocX iLocY
97287>>>>>>>>>        
97287>>>>>>>>>        Delegate Get GuiClientSize to iSiz
97289>>>>>>>>>        Move (Hi(iSiz)) to iHeight
97290>>>>>>>>>        Move (Low(iSiz)) to iWidth
97291>>>>>>>>>        
97291>>>>>>>>>        // Vertical scrolling
97291>>>>>>>>>        
97291>>>>>>>>>        Get piMinimumHeight to iOrig
97292>>>>>>>>>        Get piMinimumWidth to iWOrig
97293>>>>>>>>>        
97293>>>>>>>>>        If (iOrig<>0 or iWOrig<>0) Begin
97295>>>>>>>>>            
97295>>>>>>>>>            If (iOrig<>0) Begin
97297>>>>>>>>>                Get piCurrentVertScrolled to iHCur
97298>>>>>>>>>                // If the size got bigger and we've scrolled, we want to scroll up
97298>>>>>>>>>                If (iHCur<>0 and (iHCur+iHeight>iOrig)) Begin
97300>>>>>>>>>                    Move (iOrig-iHeight max 0) to iHCur
97301>>>>>>>>>                    Set piCurrentVertScrolled to iHCur
97302>>>>>>>>>                End
97302>>>>>>>>>>
97302>>>>>>>>>                If (iHCur<>0 or iOrig>iHeight) Begin
97304>>>>>>>>>                    Send SetScrollBarInfo True 0 iOrig (iHeight min iOrig)
97305>>>>>>>>>                    Send SetScrollBarPosInfo True iHCur
97306>>>>>>>>>                End
97306>>>>>>>>>>
97306>>>>>>>>>                Else Begin
97307>>>>>>>>>                    Send SetScrollBarInfo True 0 0 0 //iOrig (iHeight min iOrig)
97308>>>>>>>>>                End
97308>>>>>>>>>>
97308>>>>>>>>>            End
97308>>>>>>>>>>
97308>>>>>>>>>            
97308>>>>>>>>>            // Horiz scrolling
97308>>>>>>>>>            
97308>>>>>>>>>            Get piCurrentHorzScrolled to iWCur
97309>>>>>>>>>            // If the size got bigger and we've scrolled, we want to scroll left
97309>>>>>>>>>            If (iWCur<>0 and (iWCur+iWidth>iWOrig)) Begin
97311>>>>>>>>>                Move (iWOrig-iWidth max 0) to iWCur
97312>>>>>>>>>                Set piCurrentHorzScrolled to iWCur
97313>>>>>>>>>            End
97313>>>>>>>>>>
97313>>>>>>>>>            If (iWCur<>0 or iWOrig>iWidth) Begin
97315>>>>>>>>>                Send SetScrollBarInfo False 0 iWOrig (iWidth min iWOrig)
97316>>>>>>>>>                Send SetScrollBarPosInfo False iWCur
97317>>>>>>>>>            End
97317>>>>>>>>>>
97317>>>>>>>>>            Else Begin
97318>>>>>>>>>                Send SetScrollBarInfo False 0 0 0
97319>>>>>>>>>            End
97319>>>>>>>>>>
97319>>>>>>>>>        End
97319>>>>>>>>>>
97319>>>>>>>>>        
97319>>>>>>>>>        // this could change depending on scrollbars appearing or not
97319>>>>>>>>>        Delegate Get GuiClientSize to iSiz
97321>>>>>>>>>        
97321>>>>>>>>>        // size of container is the the minimum allowed size (if scrolling is needed)
97321>>>>>>>>>        // or it is the actual size of the container (if scrolling not needed and it is bigger)
97321>>>>>>>>>        // This is required to make anchors work sensibly
97321>>>>>>>>>        Move (hi(iSiz) max iOrig) to iSzY
97322>>>>>>>>>        Move (low(iSiz) max iWOrig) to iSzX
97323>>>>>>>>>        Move (-iHCur) to iLocY
97324>>>>>>>>>        Move (-iWCur) to iLocX
97325>>>>>>>>>        
97325>>>>>>>>>        // Allow chance to make modifications
97325>>>>>>>>>        Send AdjustSizesLocs (&iSzY) (&iSzX) (&iLocY) (&iLocX)
97326>>>>>>>>>        
97326>>>>>>>>>        Set GuiSize to iSzY iSzX
97327>>>>>>>>>        // if we've scrolled, we need to reposition the container
97327>>>>>>>>>        Set GuiLocation to iLocY iLocX
97328>>>>>>>>>    End_Procedure
97329>>>>>>>>>    
97329>>>>>>>>>    // note that scrolling never changes the size of the scrolling client.
97329>>>>>>>>>    // this way, it does not interfere with anchors.
97329>>>>>>>>>    
97329>>>>>>>>>    Procedure VScroll Integer iDelta
97331>>>>>>>>>        Integer iHeight iCur iOrig iSiz
97331>>>>>>>>>        Delegate Get GuiClientSize to iSiz
97333>>>>>>>>>        Move (hi(iSiz)) to iHeight
97334>>>>>>>>>        Get piCurrentVertScrolled to iCur
97335>>>>>>>>>        Get piMinimumHeight to iOrig
97336>>>>>>>>>        If (iOrig=0 or  Hi(iSiz)>=iOrig) Begin
97338>>>>>>>>>            Procedure_Return
97339>>>>>>>>>        End
97339>>>>>>>>>>
97339>>>>>>>>>        // make sure delta is within range
97339>>>>>>>>>        If (iDelta+iCur<0) Begin
97341>>>>>>>>>            Move (-iCur) to iDelta
97342>>>>>>>>>        End
97342>>>>>>>>>>
97342>>>>>>>>>        Else If (iDelta+iCur>iOrig - iHeight) Begin
97345>>>>>>>>>            Move (iOrig - iHeight - iCur) to iDelta
97346>>>>>>>>>        End
97346>>>>>>>>>>
97346>>>>>>>>>        If (iDelta=0) ;            Procedure_Return
97349>>>>>>>>>        
97349>>>>>>>>>        Move (iCur + iDelta) to iCur
97350>>>>>>>>>        Set piCurrentVertScrolled to iCur
97351>>>>>>>>>        Send SetScrollBarPosInfo True iCur
97352>>>>>>>>>        Get GuiLocation to iSiz
97353>>>>>>>>>        Set GuiLocation to (cast(hi(iSiz),Integer)-iDelta) (cast(low(iSiz),Integer))
97354>>>>>>>>>        Send ScrollClientArea
97355>>>>>>>>>    End_Procedure
97356>>>>>>>>>    
97356>>>>>>>>>    
97356>>>>>>>>>    Procedure HScroll Integer iDelta
97358>>>>>>>>>        Integer iHeight iCur iOrig iSiz
97358>>>>>>>>>        Delegate Get GuiClientSize to iSiz
97360>>>>>>>>>        Move (low(iSiz)) to iHeight
97361>>>>>>>>>        Get piCurrentHorzScrolled to iCur
97362>>>>>>>>>        Get piMinimumWidth to iOrig
97363>>>>>>>>>        If (iOrig=0 or  low(iSiz)>=iOrig) Begin
97365>>>>>>>>>            Procedure_Return
97366>>>>>>>>>        End
97366>>>>>>>>>>
97366>>>>>>>>>        If (iDelta+iCur<0) Begin
97368>>>>>>>>>            Move (-iCur) to iDelta
97369>>>>>>>>>        End
97369>>>>>>>>>>
97369>>>>>>>>>        Else If (iDelta+iCur>iOrig - iHeight) Begin
97372>>>>>>>>>            Move (iOrig - iHeight - iCur) to iDelta
97373>>>>>>>>>        End
97373>>>>>>>>>>
97373>>>>>>>>>        If (iDelta=0) ;            Procedure_Return
97376>>>>>>>>>        
97376>>>>>>>>>        Move (iCur + iDelta) to iCur
97377>>>>>>>>>        Set piCurrentHorzScrolled to iCur
97378>>>>>>>>>        Send SetScrollBarPosInfo False iCur
97379>>>>>>>>>        Get GuiLocation to iSiz
97380>>>>>>>>>        Set GuiLocation to (cast(hi(iSiz),Short)) (cast(low(iSiz),Short) -iDelta)
97381>>>>>>>>>        Send ScrollClientArea
97382>>>>>>>>>    End_Procedure
97383>>>>>>>>>    
97383>>>>>>>>>    // make sure client is a 0,0
97383>>>>>>>>>    Procedure ScrollHome
97385>>>>>>>>>        Send SetVScrollbox SB_TOP 0
97386>>>>>>>>>        Send SetHScrollbox SB_TOP 0
97387>>>>>>>>>    End_Procedure
97388>>>>>>>>>    
97388>>>>>>>>>    // get relative GUI location of this object to the parent one passed.
97388>>>>>>>>>    Procedure LocationRelativeTo Handle hoContainer Handle hoControl Integer ByRef iLocY Integer ByRef iLocX
97390>>>>>>>>>        Integer ivoid
97390>>>>>>>>>        tWinRect Rect0 Rect1
97390>>>>>>>>>        tWinRect Rect0 Rect1
97390>>>>>>>>>        Move (GetWindowRect(window_handle(hoContainer),addressof(Rect0))) to ivoid
97391>>>>>>>>>        Move (GetWindowRect(window_handle(hoControl),addressof(Rect1))) to ivoid
97392>>>>>>>>>        Move ((Rect1.top) - (Rect0.top)) to iLocY
97393>>>>>>>>>        Move ((rect1.left) - (rect0.left)) to iLocX
97394>>>>>>>>>    End_Procedure
97395>>>>>>>>>    
97395>>>>>>>>>    // This scrolls this object into visual range.
97395>>>>>>>>>    Procedure ScrollObjectInRange Handle hoControl
97397>>>>>>>>>        Handle hoScrollingContainer
97397>>>>>>>>>        Integer iCurrentVertScrolled iCurrentHorzScrolled
97397>>>>>>>>>        Integer iViewHeight iViewWidth
97397>>>>>>>>>        Integer iRelLocHeight iRelLocWidth
97397>>>>>>>>>        Integer iSize iControlHeight iControlWidth
97397>>>>>>>>>        Integer iScroll
97397>>>>>>>>>        Integer iMarginX iMarginY
97397>>>>>>>>>        Integer iScrollingContainerWindowSize iScrollingContainerClientSize
97397>>>>>>>>>        
97397>>>>>>>>>        Get piAutoScrollMarginX to iMarginX
97398>>>>>>>>>        Get piAutoScrollMarginY to iMarginY
97399>>>>>>>>>        
97399>>>>>>>>>        // the scrolling container
97399>>>>>>>>>        Move Self to hoScrollingContainer
97400>>>>>>>>>        // the amount the SC is currently scrolled
97400>>>>>>>>>        Get piCurrentVertScrolled of hoScrollingContainer to iCurrentVertScrolled
97401>>>>>>>>>        Get piCurrentHorzScrolled of hoScrollingContainer to iCurrentHorzScrolled
97402>>>>>>>>>        
97402>>>>>>>>>        // size of view's client area (this is the viewport area)
97402>>>>>>>>>        Get GuiClientSize of (Parent(hoScrollingContainer)) to iSize
97403>>>>>>>>>        Move (hi(iSize)) to iViewHeight
97404>>>>>>>>>        Move (low(iSize)) to iViewWidth
97405>>>>>>>>>        
97405>>>>>>>>>        // get this object's location relative to the scrolling container
97405>>>>>>>>>        Send LocationRelativeTo hoScrollingContainer hoControl (&iRelLocHeight) (&iRelLocWidth)
97406>>>>>>>>>        
97406>>>>>>>>>        // we expect that the client size is the window size but just in case
97406>>>>>>>>>        Get GuiWindowSize of hoScrollingContainer to iScrollingContainerWindowSize
97407>>>>>>>>>        Get GuiClientSize of hoScrollingContainer to iScrollingContainerClientSize
97408>>>>>>>>>        Move (iRelLocHeight - (Hi(iScrollingContainerWindowSize)-Hi(iScrollingContainerClientSize))) to iRelLocHeight
97409>>>>>>>>>        Move (iRelLocWidth - (Low(iScrollingContainerWindowSize)-Low(iScrollingContainerClientSize))) to iRelLocWidth
97410>>>>>>>>>        
97410>>>>>>>>>        // the outer size of the control object
97410>>>>>>>>>        Get GUIWindowSize of hoControl to iSize
97411>>>>>>>>>        Move (hi(iSize)) to iControlHeight
97412>>>>>>>>>        Move (low(iSize)) to iControlWidth
97413>>>>>>>>>        
97413>>>>>>>>>        // the general idea is to make the control fully visible but to scroll as little as possible.
97413>>>>>>>>>        
97413>>>>>>>>>        // Vertical Scroll
97413>>>>>>>>>        
97413>>>>>>>>>        // Vertical Scroll down
97413>>>>>>>>>        // if the bottom of the control plus a bottom margin does not fit make it fit at the bottom
97413>>>>>>>>>        If (iRelLocHeight + iControlHeight + iMarginY - iCurrentVertScrolled >iViewHeight) Begin
97415>>>>>>>>>            
97415>>>>>>>>>            // set scroll amount so that the bottom of the control is visible
97415>>>>>>>>>            Move (iRelLocHeight + iControlHeight + iMarginY - iCurrentVertScrolled - iViewHeight ) to iScroll
97416>>>>>>>>>            
97416>>>>>>>>>            // See if this amount, scrolls the top out of range. If so just scroll enough so that the
97416>>>>>>>>>            // top of the object appears at the bottom
97416>>>>>>>>>            If (iRelLocHeight - iCurrentVertScrolled < iScroll) Begin
97418>>>>>>>>>                Move (iRelLocHeight + iMarginY  - iCurrentVertScrolled - iViewHeight  ) to iScroll
97419>>>>>>>>>            End
97419>>>>>>>>>>
97419>>>>>>>>>            // if the scroll amnt is negative it's best to just keep it where it is.
97419>>>>>>>>>            If (iScroll>0) Begin
97421>>>>>>>>>                Send VScroll of hoScrollingContainer iScroll
97422>>>>>>>>>            End
97422>>>>>>>>>>
97422>>>>>>>>>        End
97422>>>>>>>>>>
97422>>>>>>>>>        // else vertical scroll up
97422>>>>>>>>>        // We scroll if the top of the object is not visible.
97422>>>>>>>>>        Else If (iRelLocHeight + iMarginY < iCurrentVertScrolled) Begin
97425>>>>>>>>>            // if we scroll we will scroll enough to see the top of the object.
97425>>>>>>>>>            Move (iRelLocHeight -iMarginY - iCurrentVertScrolled ) to iScroll
97426>>>>>>>>>            If (iScroll<0) Begin
97428>>>>>>>>>                Send VScroll of hoScrollingContainer (iScroll max (-iCurrentVertScrolled))
97429>>>>>>>>>            End
97429>>>>>>>>>>
97429>>>>>>>>>        End
97429>>>>>>>>>>
97429>>>>>>>>>        
97429>>>>>>>>>        // Horizonal Scroll
97429>>>>>>>>>        
97429>>>>>>>>>        // if the right side of the control does not fit, scroll it so it fits
97429>>>>>>>>>        If (iRelLocWidth + iControlWidth + iMarginX - iCurrentHorzScrolled >iViewWidth) Begin
97431>>>>>>>>>            Move (iRelLocWidth + iControlWidth + iMarginX - iCurrentHorzScrolled - iViewWidth ) to iScroll
97432>>>>>>>>>            If (iRelLocWidth - iCurrentHorzScrolled - iScroll<0) Begin
97434>>>>>>>>>                Move (iRelLocWidth  - iCurrentHorzScrolled - iMarginX ) to iScroll
97435>>>>>>>>>            End
97435>>>>>>>>>>
97435>>>>>>>>>            If (iScroll>0) Begin
97437>>>>>>>>>                Send HScroll of hoScrollingContainer iScroll
97438>>>>>>>>>            End
97438>>>>>>>>>>
97438>>>>>>>>>        End
97438>>>>>>>>>>
97438>>>>>>>>>        If (iRelLocWidth - iMarginX  - iCurrentHorzScrolled <0) Begin
97440>>>>>>>>>            // if this can fit by moving all the way to left, do so.
97440>>>>>>>>>            If (iRelLocWidth + iControlWidth + iMarginX <= iViewWidth) Begin
97442>>>>>>>>>                Move (-iCurrentHorzScrolled) to iScroll
97443>>>>>>>>>            End
97443>>>>>>>>>>
97443>>>>>>>>>            Else Begin
97444>>>>>>>>>                Move (iRelLocWidth - iCurrentHorzScrolled - iMarginX) to iScroll
97445>>>>>>>>>            End
97445>>>>>>>>>>
97445>>>>>>>>>            If (iScroll<0) Begin
97447>>>>>>>>>                Send HScroll of hoScrollingContainer (iScroll max (-iCurrentHorzScrolled))
97448>>>>>>>>>            End
97448>>>>>>>>>>
97448>>>>>>>>>        End
97448>>>>>>>>>>
97448>>>>>>>>>        
97448>>>>>>>>>        
97448>>>>>>>>>    End_Procedure
97449>>>>>>>>>    
97449>>>>>>>>>    // when we receive this message, we might need to scroll to bring the new focus in to view.
97449>>>>>>>>>    Procedure NotifyFocusSetInContainer Handle hoControl
97451>>>>>>>>>        Boolean bScrollOnFocus
97451>>>>>>>>>        Get pbAutoScrollFocus to bScrollOnFocus
97452>>>>>>>>>        If bScrollOnFocus Begin
97454>>>>>>>>>            Send ScrollObjectInRange hoControl
97455>>>>>>>>>        End
97455>>>>>>>>>>
97455>>>>>>>>>        Delegate Send NotifyFocusSetInContainer hoControl
97457>>>>>>>>>    End_Procedure
97458>>>>>>>>>    
97458>>>>>>>>>    
97458>>>>>>>>>    Function CenterTabWorkspaceView Returns Boolean
97460>>>>>>>>>        Boolean bCenter
97460>>>>>>>>>        Get pbCenterTabbedViews of ghoCommandBars to bCenter
97461>>>>>>>>>        Function_Return bCenter
97462>>>>>>>>>    End_Function
97463>>>>>>>>>    
97463>>>>>>>>>    Procedure AdjustSizesLocs Integer ByRef iHeight Integer ByRef iWidth Integer ByRef iLocY Integer ByRef iLocX
97465>>>>>>>>>        Boolean bTabWorkspaceView
97465>>>>>>>>>        Get pbTabWorkspaceView to bTabWorkspaceView
97466>>>>>>>>>        If bTabWorkspaceView Begin
97468>>>>>>>>>            Send AdjustTabWorkspaceView (&iHeight) (&iWidth) (&iLocY) (&iLocX)
97469>>>>>>>>>        End
97469>>>>>>>>>>
97469>>>>>>>>>    End_Procedure
97470>>>>>>>>>    
97470>>>>>>>>>    Function ParentView Returns Handle
97472>>>>>>>>>        Function_Return (Parent(Parent(Self)))
97473>>>>>>>>>    End_Function
97474>>>>>>>>>    
97474>>>>>>>>>    Procedure AdjustTabWorkspaceView Integer ByRef iHeight Integer ByRef iWidth Integer ByRef iLocY Integer ByRef iLocX
97476>>>>>>>>>        Integer iSize iMax iDiff
97476>>>>>>>>>        Handle hoView
97476>>>>>>>>>        Boolean bCenter bModal
97476>>>>>>>>>        Get ParentView to hoView
97477>>>>>>>>>        Get Block_Mouse_State of hoView to bModal
97478>>>>>>>>>        If not bModal Begin
97480>>>>>>>>>            Get CenterTabWorkspaceView to bCenter
97481>>>>>>>>>            Get GuiSize of hoView to iSize
97482>>>>>>>>>            Get piMaxSize of hoView to iMax
97483>>>>>>>>>            Get DialogToGui (Hi(iMax)) (Low(iMax)) to iMax
97484>>>>>>>>>            If (Low(iMax) and Low(iMax)<=Low(isize)) Begin
97486>>>>>>>>>                If bCenter Begin
97488>>>>>>>>>                    Move ((Low(iSize)-Low(iMax))/2) to iLocX
97489>>>>>>>>>                End
97489>>>>>>>>>>
97489>>>>>>>>>                Move (Low(iMax)) to iWidth
97490>>>>>>>>>            End
97490>>>>>>>>>>
97490>>>>>>>>>            If (Hi(iMax) and Hi(iMax)<=Hi(iSize)) Begin
97492>>>>>>>>>                If bCenter Begin
97494>>>>>>>>>                    Move ((Hi(iSize)-Hi(iMax))/2) to iLocY
97495>>>>>>>>>                    Move (iLocy min 25) to  iLocY
97496>>>>>>>>>                End
97496>>>>>>>>>>
97496>>>>>>>>>                Move (Hi(imax)) to iHeight
97497>>>>>>>>>            End
97497>>>>>>>>>>
97497>>>>>>>>>        End
97497>>>>>>>>>>
97497>>>>>>>>>    End_Procedure
97498>>>>>>>>>    
97498>>>>>>>>>    // Automatically determine if this is a scrolling tabbed workspace view
97498>>>>>>>>>    // If determines this by checking pbAutoSetTabWorkspaceView is set (it can be
97498>>>>>>>>>    // set to stop this), if we have a global commandbar object and we are using tabbed
97498>>>>>>>>>    // workspaces. We also make sure that the expected view object is a framework view class
97498>>>>>>>>>    // This should almost always yield the right answer.
97498>>>>>>>>>    // This is called by the scrolling container's end_constructor
97498>>>>>>>>>    Procedure AutoSetTabWorkspaceView
97500>>>>>>>>>        Boolean bTabView bIsView bAutoSetTabWorkspaceView
97500>>>>>>>>>        Handle hoParent
97500>>>>>>>>>        Integer iSize
97500>>>>>>>>>        Get pbAutoSetTabWorkspaceView to bAutoSetTabWorkspaceView
97501>>>>>>>>>        If (ghoCommandBars and bAutoSetTabWorkspaceView) Begin
97503>>>>>>>>>            Get pbTabbedWorkspaces of ghoCommandBars to bTabView
97504>>>>>>>>>            // not that pbTabbedWorkspaces is a designtime only property. You can not
97504>>>>>>>>>            // change this after the commandbar is paged.
97504>>>>>>>>>            If (bTabView) Begin
97506>>>>>>>>>                Get ParentView to hoParent
97507>>>>>>>>>                Get IsObjectOfClass of hoParent (RefClass(MdiDialog)) to bIsView
97508>>>>>>>>>                If (bIsView) Begin
97510>>>>>>>>>                    // set this as a tab workspace view
97510>>>>>>>>>                    Set pbTabWorkspaceView to True
97511>>>>>>>>>                    // when tab workspaces are enabled we always enable auto-scrolling
97511>>>>>>>>>                    // when tab workspaces are not enabled, pbScroll is whatever it is
97511>>>>>>>>>                    Set pbAutoScroll to True
97512>>>>>>>>>                    
97512>>>>>>>>>                End
97512>>>>>>>>>>
97512>>>>>>>>>            End
97512>>>>>>>>>>
97512>>>>>>>>>        End
97512>>>>>>>>>>
97512>>>>>>>>>    End_Procedure
97513>>>>>>>>>    
97513>>>>>>>>>End_Class
97514>>>>>>>>>
97514>>>>>>>>>// Container scrolling class support. Nothing in here is public
97514>>>>>>>>>Class cScrollingContainerMixin is a Mixin
97515>>>>>>>>>    
97515>>>>>>>>>    Procedure Define_cScrollingContainerMixin
97517>>>>>>>>>        Forward Set Border_Style to Border_None
97519>>>>>>>>>        Set pbSizeToClientArea to False // scrollbars and clientsize do not mix
97520>>>>>>>>>        Forward Set peAnchors to anAll
97522>>>>>>>>>        
97522>>>>>>>>>        // forcing scrollbars right away seems to make painting better
97522>>>>>>>>>        Set Window_Style WS_HSCROLL to True
97523>>>>>>>>>        Set Window_Style WS_VSCROLL to True
97524>>>>>>>>>        
97524>>>>>>>>>        Property Handle phoScrollingClientArea 0
97525>>>>>>>>>    End_Procedure
97526>>>>>>>>>    
97526>>>>>>>>>    // if anchors are changed, it will not work. We won't let that happen
97526>>>>>>>>>    Procedure Set peAnchors Integer eAnchors
97528>>>>>>>>>    End_Procedure
97529>>>>>>>>>    
97529>>>>>>>>>    // if a border style is set, it will not work. We won't let that happen
97529>>>>>>>>>    Procedure Set Border_Style Integer eStyle
97531>>>>>>>>>    End_Procedure
97532>>>>>>>>>    
97532>>>>>>>>>    // redirect scrollbar events and wheel events to the scrolling client area
97532>>>>>>>>>    Procedure OnWmMouseWheel Integer wParam Integer lParam
97534>>>>>>>>>        Handle hoClient
97534>>>>>>>>>        Get phoScrollingClientArea to hoClient
97535>>>>>>>>>        If hoClient Begin
97537>>>>>>>>>            Send OnMouseWheel of hoClient wParam lParam
97538>>>>>>>>>        End
97538>>>>>>>>>>
97538>>>>>>>>>    End_Procedure
97539>>>>>>>>>    
97539>>>>>>>>>    // should be sent by WM_VSCROLL
97539>>>>>>>>>    Procedure SetVScrollbox Integer iType Integer iNewPos
97541>>>>>>>>>        Handle hoClient
97541>>>>>>>>>        Get phoScrollingClientArea to hoClient
97542>>>>>>>>>        If hoClient Begin
97544>>>>>>>>>            Send SetVScrollbox of hoClient iType iNewPos
97545>>>>>>>>>        End
97545>>>>>>>>>>
97545>>>>>>>>>    End_Procedure
97546>>>>>>>>>    
97546>>>>>>>>>    // should be sent by WM_HSCROLL
97546>>>>>>>>>    Procedure SetHScrollbox Integer iType Integer iNewPos
97548>>>>>>>>>        Handle hoClient
97548>>>>>>>>>        Get phoScrollingClientArea to hoClient
97549>>>>>>>>>        If hoClient Begin
97551>>>>>>>>>            Send SetHScrollbox of hoClient iType iNewPos
97552>>>>>>>>>        End
97552>>>>>>>>>>
97552>>>>>>>>>    End_Procedure
97553>>>>>>>>>    
97553>>>>>>>>>    // augmented to adjust its size to the size of the parent client area.
97553>>>>>>>>>    // After this is set, anchors will handle any further resizing.
97553>>>>>>>>>    Procedure Page Integer iState
97555>>>>>>>>>        Integer iSiz iHeight iWidth
97555>>>>>>>>>        Integer iTop iBottom iLeft iRight iFontSize
97555>>>>>>>>>        Boolean bGroup
97555>>>>>>>>>        Handle hoClient
97555>>>>>>>>>        If (iState =1) Begin
97557>>>>>>>>>            Delegate Get Window_Style BS_GROUPBOX to bGroup
97559>>>>>>>>>            // We have special code to support groups because they
97559>>>>>>>>>            // draw a border inside of the client rectangle
97559>>>>>>>>>            If bGroup Begin
97561>>>>>>>>>                Get Physical_FontSize to iFontSize
97562>>>>>>>>>                Move (Hi(iFontSize)) to iTop
97563>>>>>>>>>                Move 2 to iLeft
97564>>>>>>>>>                Move 2 to iRight
97565>>>>>>>>>                Move 2 to iBottom
97566>>>>>>>>>            End
97566>>>>>>>>>>
97566>>>>>>>>>            // We use GetContainerClientSize instead of GuiClientSize because
97566>>>>>>>>>            // GetContainerClientSize has a special augmentation in tab pages that
97566>>>>>>>>>            // makes anchors work properly with unpaged tab-pages
97566>>>>>>>>>            Delegate Get GetContainerClientSize to iSiz
97568>>>>>>>>>            Set GuiSize to (Hi(iSiz)-(iTop+iBottom)) (Low(iSiz)-(iLeft+iRight))
97569>>>>>>>>>            Set GuiLocation to iTop iLeft
97570>>>>>>>>>            Send Adjust_Logicals
97571>>>>>>>>>        End
97571>>>>>>>>>>
97571>>>>>>>>>        Forward Send Page iState
97573>>>>>>>>>    End_Procedure
97574>>>>>>>>>    
97574>>>>>>>>>    Procedure End_Construct_Object
97576>>>>>>>>>        Handle hoClient
97576>>>>>>>>>        Forward Send End_Construct_Object
97578>>>>>>>>>        Get phoScrollingClientArea to hoClient
97579>>>>>>>>>        If (hoClient) Begin
97581>>>>>>>>>            Send AutoSetTabWorkspaceView of hoClient
97582>>>>>>>>>        End
97582>>>>>>>>>>
97582>>>>>>>>>    End_Procedure
97583>>>>>>>>>    
97583>>>>>>>>>End_Class
97584>>>>>>>
97584>>>>>>>Class cScrollingClientArea is a Container3d
97585>>>>>>>    Import_Class_Protocol cScrollingClientAreaMixin
97586>>>>>>>    Procedure Construct_Object
97588>>>>>>>        Forward Send Construct_Object
97590>>>>>>>        Send Define_cScrollingClientAreaMixin
97591>>>>>>>    End_Procedure
97592>>>>>>>End_Class
97593>>>>>>>
97593>>>>>>>
97593>>>>>>>
97593>>>>>>>Class cScrollingContainer is a Container3d
97594>>>>>>>    Import_Class_Protocol cScrollingContainerMixin
97595>>>>>>>    Procedure Construct_Object
97597>>>>>>>        Forward Send Construct_Object
97599>>>>>>>        Send Define_cScrollingContainerMixin
97600>>>>>>>    End_Procedure
97601>>>>>>>End_Class
97602>>>>>Use cRDCModalPanel.pkg
97602>>>>>Use cRDCForm.pkg
Including file: cRDCForm.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cRDCForm.pkg)
97602>>>>>>>//****************************************************************************
97602>>>>>>>// $Module type: Class
97602>>>>>>>// $Module name: cForm
97602>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International
97602>>>>>>>// Created     : 2014-03-17 @ 12:34
97602>>>>>>>//
97602>>>>>>>// Description :
97602>>>>>>>//
97602>>>>>>>// $Rev History:
97602>>>>>>>//    2014-03-17  Module header created
97602>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
97602>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
97602>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
97602>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
97602>>>>>>>// in the help folder for more details.
97602>>>>>>>//
97602>>>>>>>//****************************************************************************
97602>>>>>>>Use Windows.pkg
97602>>>>>>>
97602>>>>>>>Class cFormIdleHandler is a cIdleHandler
97603>>>>>>>    Procedure Construct_Object
97605>>>>>>>        Forward Send Construct_Object
97607>>>>>>>
97607>>>>>>>    End_Procedure
97608>>>>>>>
97608>>>>>>>    Procedure OnIdle
97610>>>>>>>        Delegate Send DoUpdate
97612>>>>>>>    End_Procedure
97613>>>>>>>
97613>>>>>>>End_Class
97614>>>>>>>
97614>>>>>>>Class cRDCForm is a Form
97615>>>>>>>
97615>>>>>>>    Procedure Construct_Object
97617>>>>>>>        Forward Send Construct_Object
97619>>>>>>>
97619>>>>>>>        Property Boolean pbAutoEnable False
97620>>>>>>>
97620>>>>>>>        Property Boolean pbEnabled True
97621>>>>>>>
97621>>>>>>>        Property Handle phoIdleHandler (Create(Self, RefClass(cFormIdleHandler)))
97622>>>>>>>
97622>>>>>>>        Set Label_Justification_mode to JMode_Right
97623>>>>>>>        Set Label_Col_Offset to 2
97624>>>>>>>        Set Label_Row_Offset to 0
97625>>>>>>>    End_Procedure
97626>>>>>>>
97626>>>>>>>    Procedure End_Construct_Object
97628>>>>>>>        String sTooltip sStatus_Help
97628>>>>>>>
97628>>>>>>>        Forward Send End_Construct_Object
97630>>>>>>>
97630>>>>>>>        Get psToolTip   to sTooltip
97631>>>>>>>        Get Status_Help to sStatus_Help
97632>>>>>>>        If (sTooltip = "" and sStatus_Help <> "") Begin
97634>>>>>>>            Set psToolTip to sStatus_Help
97635>>>>>>>        End
97635>>>>>>>>
97635>>>>>>>        Else If (sTooltip <> "" and sStatus_Help = "") Begin
97638>>>>>>>            Set Status_Help to sTooltip
97639>>>>>>>        End
97639>>>>>>>>
97639>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to (pbAutoEnable(Self))
97640>>>>>>>    End_Procedure
97641>>>>>>>
97641>>>>>>>    Procedure DoUpdate
97643>>>>>>>        If (pbAutoEnable(Self) = False) Begin
97645>>>>>>>            Procedure_Return
97646>>>>>>>        End
97646>>>>>>>>
97646>>>>>>>        Set Enabled_State to (IsEnabled(Self))
97647>>>>>>>    End_Procedure
97648>>>>>>>
97648>>>>>>>    Function IsEnabled Returns Boolean
97650>>>>>>>        Boolean bEnabled
97650>>>>>>>        Get pbEnabled to bEnabled
97651>>>>>>>        Function_Return bEnabled
97652>>>>>>>    End_Function
97653>>>>>>>
97653>>>>>>>    // Enable the idle handler timer when the object is activated
97653>>>>>>>    Procedure Activating
97655>>>>>>>        Forward Send Activating
97657>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to True
97658>>>>>>>    End_Procedure
97659>>>>>>>
97659>>>>>>>    // Disable the idle handler when the object is deactivated
97659>>>>>>>    Procedure Deactivating  
97661>>>>>>>        // When exiting the program it can happen that the idle handler
97661>>>>>>>        // already has been destroyed.      
97661>>>>>>>        If (Object_id(phoIdleHandler(Self)) <> 0) Begin
97663>>>>>>>            Set pbEnabled of (phoIdleHandler(Self)) to False
97664>>>>>>>        End
97664>>>>>>>>
97664>>>>>>>        Forward Send Deactivating
97666>>>>>>>    End_Procedure 
97667>>>>>>>    
97667>>>>>>>    // Toggles the password state, as it doesn't work changing the
97667>>>>>>>    // password_state at runtine because it is a design time property.
97667>>>>>>>    Procedure TogglePasswordState
97669>>>>>>>        Boolean bState    
97669>>>>>>>        Handle hoFocus hoParent
97669>>>>>>>        Integer iRetval
97669>>>>>>>        Get Password_State to bState
97670>>>>>>>        Set Password_State to (not(bState))
97671>>>>>>>        Get Focus of Desktop to hoFocus
97672>>>>>>>        Move (Parent(Self)) to hoParent
97673>>>>>>>        Send Page_Object False
97674>>>>>>>        Send Page_Object True   
97675>>>>>>>        Get msg_Add_Focus hoParent to iRetval
97676>>>>>>>        Set Focus_Mode of hoFocus to Focusable
97677>>>>>>>//        Send Page_Delete
97677>>>>>>>//        Send Page 1
97677>>>>>>>    End_Procedure
97678>>>>>>>
97678>>>>>>>End_Class
97679>>>>>Use cRDCComboForm.pkg
97679>>>>>Use cRDCButton.pkg
97679>>>>>Use cRDCHeaderGroup.pkg
97679>>>>>Use cDbDriverSettingsForm.pkg
Including file: cDbDriverSettingsForm.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbDriverSettingsForm.pkg)
97679>>>>>>>//****************************************************************************
97679>>>>>>>// $Module type: Class
97679>>>>>>>// $Module name: cDbDriverSettingsForm
97679>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International
97679>>>>>>>// Created     : 2014-03-17 @ 12:34
97679>>>>>>>//
97679>>>>>>>// Description :
97679>>>>>>>//
97679>>>>>>>// $Rev History:
97679>>>>>>>//    2014-03-17  Module header created
97679>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
97679>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
97679>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
97679>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
97679>>>>>>>// in the help folder for more details.
97679>>>>>>>//
97679>>>>>>>//****************************************************************************
97679>>>>>>>Use Windows.pkg
97679>>>>>>>Use seq_chnl.pkg
97679>>>>>>>
97679>>>>>>>Class cDbDriverSettingsForm is a Form
97680>>>>>>>
97680>>>>>>>    Procedure Construct_Object
97682>>>>>>>        Forward Send Construct_Object
97684>>>>>>>
97684>>>>>>>        Property Boolean private.pbDriverLoadingError False
97685>>>>>>>        
97685>>>>>>>        Set Label_Col_Offset to 2
97686>>>>>>>        Set Label_Justification_Mode to JMode_Right
97687>>>>>>>        Set Size to 11 125 
97688>>>>>>>        // We use these settings and not enabled_state to be able
97688>>>>>>>        // to show tooltips.
97688>>>>>>>        Set Color to clBtnFace
97689>>>>>>>        Set Focus_Mode to NonFocusable
97690>>>>>>>        Set peAnchors to anTopLeftRight
97691>>>>>>>
97691>>>>>>>        Property String psDriverIniFile ""
97692>>>>>>>    End_Procedure
97693>>>>>>>
97693>>>>>>>    Procedure Set psToolTip String sText
97695>>>>>>>        If (Trim(sText) = "") Begin
97697>>>>>>>            Move "No info available" to sText
97698>>>>>>>        End
97698>>>>>>>>
97698>>>>>>>        Forward Set psToolTip to sText
97700>>>>>>>    End_Procedure
97701>>>>>>>
97701>>>>>>>    Function psToolTip Returns String
97703>>>>>>>        String sTooltip sSearchValue
97703>>>>>>>
97703>>>>>>>        Get Label to sSearchValue
97704>>>>>>>        Get ExtractIniFileComment sSearchValue to sTooltip
97705>>>>>>>
97705>>>>>>>        Function_Return sTooltip
97706>>>>>>>    End_Function
97707>>>>>>>
97707>>>>>>>    Procedure SetValue String sDriver String sLabel Integer iAttribute
97709>>>>>>>        Integer iDriver
97709>>>>>>>        String sValue
97709>>>>>>>
97709>>>>>>>        // Sadly driver API attributes are only supported by the CLI-drivers,
97709>>>>>>>        // and the Pervasive driver is not amongst them. So do nothing if Pervasive.
97709>>>>>>>        If (sDriver <> DFBTRDRV_ID and sDriver <> DATAFLEX_ID) Begin
97711>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
97712>>>>>>>            Get DriverIndex of ghoSQLConnectionHandler sDriver to iDriver
97713>>>>>>>            Set private.pbDriverLoadingError to (iDriver = -1)
97714>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
97715>>>>>>>            If (iDriver <= 0) Begin
97717>>>>>>>                Procedure_Return
97718>>>>>>>            End
97718>>>>>>>>
97718>>>>>>>            // Set indicator to false prior asking for the driver attribute.
97718>>>>>>>            // This way we can decide to show the object or not, based on success/failure.
97718>>>>>>>            Move False to Err
97719>>>>>>>            Get_Attribute iAttribute of iDriver to sValue
97722>>>>>>>            If (sValue = "0") Begin
97724>>>>>>>                Move "0 (False)" to sValue
97725>>>>>>>            End
97725>>>>>>>>
97725>>>>>>>            If (sValue = "1") Begin
97727>>>>>>>                Move "1 (True)"  to sValue
97728>>>>>>>            End
97728>>>>>>>>
97728>>>>>>>            Set Value to sValue
97729>>>>>>>
97729>>>>>>>            Move (Replace("DF_DRIVER_", Uppercase(sLabel), "")) to sLabel
97730>>>>>>>            // Its a bit annoying reading all caps, so "proper" case
97730>>>>>>>            // all labels (DF_DRIVER_XXX values).
97730>>>>>>>            Get Propercase sLabel to sLabel
97731>>>>>>>            Set Label to sLabel
97732>>>>>>>
97732>>>>>>>            Get ExtractIniFileComment sLabel to sValue
97733>>>>>>>            Set Status_Help to sValue
97734>>>>>>>            Set psToolTip to sValue
97735>>>>>>>        End
97735>>>>>>>>
97735>>>>>>>    End_Procedure
97736>>>>>>>
97736>>>>>>>    // Pass a driver ini filename with path & a comment value to search for.
97736>>>>>>>    // Returns: The comments in the file as a string.
97736>>>>>>>    Function ExtractIniFileComment String sSearchValue Returns String
97738>>>>>>>        String sIniFile sValue sRetval sComment sCommentMarker
97738>>>>>>>        Boolean bCommentRow bStart
97738>>>>>>>        Integer iCh
97738>>>>>>>
97738>>>>>>>        Get psDriverIniFile to sIniFile
97739>>>>>>>        Move ";" to sCommentMarker
97740>>>>>>>        Get Seq_Open_Input_Channel sIniFile to iCh
97741>>>>>>>        While (SeqEof = False)
97745>>>>>>>            Readln channel iCh sValue
97747>>>>>>>            Move (Trim(sValue)) to sValue
97748>>>>>>>
97748>>>>>>>            // Check for a ";" at pos 1 & if the line contains the passed search value (driver attribute).
97748>>>>>>>            Move (Left(sValue, 1)) to sComment
97749>>>>>>>            If (bStart = False) Begin
97751>>>>>>>                Move (sComment = sCommentMarker and Lowercase(sValue) contains Lowercase(sSearchValue)) to bStart
97752>>>>>>>            End
97752>>>>>>>>
97752>>>>>>>            If (bStart = True) Begin
97754>>>>>>>                // Have we read past end of the comment for the driver attribute? If so, quit.
97754>>>>>>>                If (sComment <> sCommentMarker) Begin
97756>>>>>>>                    Move True to SeqEof
97757>>>>>>>                End
97757>>>>>>>>
97757>>>>>>>                Else Begin
97758>>>>>>>                    Move (sComment = sCommentMarker) to bCommentRow
97759>>>>>>>                    If (bCommentRow = True) Begin
97761>>>>>>>                        Move (Replace(sCommentMarker, sValue, "")) to sValue
97762>>>>>>>
97762>>>>>>>                        // Replace all double spaces with a single space character.
97762>>>>>>>                        Move (Replaces("  ", sValue, " ")) to sValue
97763>>>>>>>
97763>>>>>>>                        If (sRetval = "") Begin
97765>>>>>>>                            Move sValue to sRetval
97766>>>>>>>                        End
97766>>>>>>>>
97766>>>>>>>                        Else Begin
97767>>>>>>>                            Move (sRetval + " " + sValue) to sRetval
97768>>>>>>>                        End
97768>>>>>>>>
97768>>>>>>>                    End
97768>>>>>>>>
97768>>>>>>>                End
97768>>>>>>>>
97768>>>>>>>            End
97768>>>>>>>>
97768>>>>>>>        Loop
97769>>>>>>>>
97769>>>>>>>        Send Seq_Close_Channel iCh
97770>>>>>>>
97770>>>>>>>CompilerWarnings Off
97770>>>>>>>        // Replaces all double spaces with a single space character.
97770>>>>>>>        // The Replaces function doesn't quite work for this.
97770>>>>>>>        Repeat
97770>>>>>>>>
97770>>>>>>>            Replace "  " in sRetval with " "
97774>>>>>>>        Until (FindErr)
97776>>>>>>>        
97776>>>>>>>        Function_Return sRetval
97777>>>>>>>    End_Function
97778>>>>>>>CompilerWarnings On
97778>>>>>>>
97778>>>>>>>    Function Propercase String sText Returns String 
97780>>>>>>>        String[] sDelimiters
97781>>>>>>>        Integer iPos
97781>>>>>>>        
97781>>>>>>>        //Lowercase everything and we'll handle uppercase by exception
97781>>>>>>>        Move (Lowercase(sText)) to sText
97782>>>>>>>        
97782>>>>>>>        Move " " to sDelimiters[SizeOfArray(sDelimiters)]
97783>>>>>>>        Move "-" to sDelimiters[SizeOfArray(sDelimiters)]
97784>>>>>>>        Move "_" to sDelimiters[SizeOfArray(sDelimiters)]
97785>>>>>>>        
97785>>>>>>>        For iPos from 1 to (Length(sText)) // 1 based loop to match MID and OVERSTRIKE
97791>>>>>>>>
97791>>>>>>>            //If the previous character is a space, uppercase the current one (alway upper the first char)
97791>>>>>>>            If ((iPos = 1) or (SearchArray( Mid(sText, 1, (iPos - 1)), sDelimiters) <> -1)) ;                Move (Overstrike( Uppercase(Mid(sText, 1, iPos)), sText, iPos )) to sText
97794>>>>>>>        Loop
97795>>>>>>>>
97795>>>>>>>        
97795>>>>>>>        Function_Return sText
97796>>>>>>>    End_Function
97797>>>>>>>
97797>>>>>>>End_Class
97798>>>>>Use cDbUpdateFunctionLibrary.pkg
97798>>>>>
97798>>>>>Register_Procedure psOrgToolTip String sTooltip
97798>>>>>
97798>>>>>Object oDriverSettings_dg is a cRDCModalPanel
97800>>>>>    Set Size to 291 345
97801>>>>>    Set Label to "Driver Configuration File Info"
97802>>>>>    Set Location to 2 2
97803>>>>>    Set Maximize_Icon to False
97804>>>>>    Set Locate_Mode to CENTER_ON_PARENT
97805>>>>>    Set Icon to "DriverSettings1.ico"
97806>>>>>    
97806>>>>>    Property String psDriverID MSSQLDRV_ID
97808>>>>>    Property Boolean pbDriverLoadingError False
97810>>>>>    
97810>>>>>    Object oCancel_Btn is a cRDCButton
97812>>>>>        Set Label    to "&Close"
97813>>>>>        Set Location to 269 287
97814>>>>>        Set peAnchors to anBottomRight
97815>>>>>
97815>>>>>        Procedure OnClick
97818>>>>>            Send Close_Panel
97819>>>>>        End_Procedure
97820>>>>>
97820>>>>>    End_Object
97821>>>>>
97821>>>>>    Object oDriver_cf is a cRDCComboForm
97823>>>>>        Set Label to "Database Driver"
97824>>>>>        Set Size to 13 80
97825>>>>>        Set Location to 8 90
97826>>>>>        Set Form_Border to 0
97827>>>>>        Set Label_Col_Offset to 2
97828>>>>>        Set Label_Justification_Mode to JMode_Right
97829>>>>>        Set Status_Help to "Database driver."
97830>>>>>        Set Enabled_State to False
97831>>>>>        Set Skip_State to True
97832>>>>>
97832>>>>>        Procedure Combo_Fill_List
97835>>>>>            Send Combo_Add_Item DATAFLEX_ID
97836>>>>>            Send Combo_Add_Item DFBTRDRV_ID
97837>>>>>            Send Combo_Add_Item ODBC_DRV_ID
97838>>>>>            Send Combo_Add_Item MSSQLDRV_ID
97839>>>>>            Send Combo_Add_Item DB2_DRV_ID
97840>>>>>        End_Procedure
97841>>>>>
97841>>>>>    End_Object
97842>>>>>
97842>>>>>    Object oDriverFileName_cf is a cRDCForm
97844>>>>>        Set Label to "Database Driver File"
97845>>>>>        Set Size to 12 193
97846>>>>>        Set Location to 24 90
97847>>>>>        Set Label_Col_Offset to 2
97848>>>>>        Set Label_Justification_Mode to JMode_Right
97849>>>>>        Set Status_Help to "Database driver to be used when creating new tables."
97850>>>>>        Set Color to clBtnFace
97851>>>>>        Set Focus_Mode to NonFocusable
97852>>>>>        Set peAnchors to anTopLeftRight
97853>>>>>
97853>>>>>        Procedure OnChange
97856>>>>>            String sDriverID sValue sDriverIntFileName sTooltip sPath
97856>>>>>
97856>>>>>            Forward Send OnChange
97858>>>>>            Get Value to sValue
97859>>>>>            Set Status_Help to sValue
97860>>>>>
97860>>>>>            Get psDriverID to sDriverID
97861>>>>>            If (sDriverID <> DATAFLEX_ID) Begin
97863>>>>>                Get DatabaseDriverIniFilePath sDriverID to sPath
97864>>>>>                If (sPath <> "") Begin
97866>>>>>                    Move (sPath + sDriverID + ".int") to sDriverIntFileName
97867>>>>>                End
97867>>>>>>
97867>>>>>            End
97867>>>>>>
97867>>>>>            Else Begin
97868>>>>>                Move sDriverID to sDriverIntFileName
97869>>>>>            End
97869>>>>>>
97869>>>>>
97869>>>>>            Set Value of oDriverIniFile_fm to sDriverIntFileName
97870>>>>>            Get psOrgToolTip of oDriverIniFile_fm to sTooltip
97871>>>>>            Set Status_Help of oDriverIniFile_fm to (sTooltip * sDriverIntFileName)
97872>>>>>
97872>>>>>            // In case driver attribute objects already exists; destroy them
97872>>>>>            Broadcast Send Destroy    of oScrollingClientArea
97874>>>>>            // Then recreate them to show driver attributes
97874>>>>>            Send DoReadDriverSettings of oScrollingClientArea sDriverID
97875>>>>>        End_Procedure  
97876>>>>>        
97876>>>>>    End_Object
97877>>>>>
97877>>>>>    Object oDriverInfo_btn is a cRDCButton
97879>>>>>        Set Size to 13 50
97880>>>>>        Set Location to 24 287
97881>>>>>        Set Label to "Version Info"
97882>>>>>        Set Status_Help to "Shows a dialog with driver properties and SQL client software version(s), license info and more."
97883>>>>>        Set peAnchors to anTopRight
97884>>>>>
97884>>>>>        Procedure OnClick
97887>>>>>            Object oSysInfoDialog is a SysInfoDialog
97889>>>>>            End_Object
97890>>>>>
97890>>>>>            Send Popup of oSysInfoDialog
97891>>>>>        End_Procedure
97892>>>>>    End_Object
97893>>>>>
97893>>>>>    Object oDriverIniFile_fm is a cRDCForm
97895>>>>>        Set Size to 13 193
97896>>>>>        Set Location to 39 90
97897>>>>>        Set Label_Col_Offset to 2
97898>>>>>        Set Label_Justification_Mode to JMode_Right
97899>>>>>        Set Label to "Driver Configuration File"
97900>>>>>        Set peAnchors to anTopLeftRight
97901>>>>>        Set Color to clBtnFace
97902>>>>>        Set Focus_Mode to NonFocusable
97903>>>>>        Property String psOrgToolTip "The file is the first found in the DF_OPEN_PATH path string."
97905>>>>>        Set Status_Help to (psOrgToolTip(Self))
97906>>>>>    End_Object
97907>>>>>
97907>>>>>    Object oOpenDriverFile_Btn is a cRDCButton
97909>>>>>        Set Size to 13 50
97910>>>>>        Set Label to "Edit File"
97911>>>>>        Set Location to 39 287
97912>>>>>        Set Status_Help to "Opens the driver configuration file that contains configuration settings that are used when tables are restructured, in Notepad."
97913>>>>>        Set psImage to "ActionEdit1.ico"
97914>>>>>        Set peAnchors to anTopRight
97915>>>>>        Set pbAutoEnable to True
97916>>>>>
97916>>>>>        Procedure OnClick
97919>>>>>            String sFileName
97919>>>>>            Get Value of oDriverIniFile_fm to sFileName
97920>>>>>            If (sFileName <> DATAFLEX_ID) Begin
97922>>>>>                Runprogram Background "Notepad.exe" sFileName
97923>>>>>            End
97923>>>>>>
97923>>>>>            Else Begin
97924>>>>>                Send Info_Box "Sorry, there exist no driver ini file for the DataFlex database driver, so nothing to show here."
97925>>>>>            End
97925>>>>>>
97925>>>>>        End_Procedure   
97926>>>>>        
97926>>>>>        Function IsEnabled Returns Boolean
97929>>>>>            String sFileName
97929>>>>>            Get Value of oDriverFileName_cf to sFileName
97930>>>>>            Function_Return (sFileName <> "")
97931>>>>>        End_Function
97932>>>>>
97932>>>>>    End_Object
97933>>>>>
97933>>>>>    Object oDumpDriverData_Btn is a cRDCButton
97935>>>>>        Set Size to 13 50
97936>>>>>        Set Label to "Dump"
97937>>>>>        Set Location to 54 233
97938>>>>>        Set peAnchors to anTopRight
97939>>>>>        Set psToolTip to "Dumps the current status of the Connectivity Kit driver to an ASCII disk file."
97940>>>>>        Set psImage to "ActionExport1.ico"
97941>>>>>        Set pbAutoEnable to True
97942>>>>>        
97942>>>>>        Procedure OnClick
97945>>>>>            Handle hoCLI
97945>>>>>            String sDriver sPath sFileName
97945>>>>>            Integer iRetval
97945>>>>>
97945>>>>>            Get psDriverID to sDriver
97946>>>>>            Get Create (RefClass(cCLIHandler)) to hoCLI
97947>>>>>            Set psDriverID of hoCLI  to sDriver
97948>>>>>            If (sDriver = DATAFLEX_ID or sDriver = DFBTRDRV_ID) Begin
97950>>>>>                Send Destroy of hoCLI
97951>>>>>                Send Info_Box "Sorry, no attributes can be shown for the selected database driver."
97952>>>>>                Procedure_Return
97953>>>>>            End
97953>>>>>>
97953>>>>>
97953>>>>>            Get psHome of (phoWorkspace(ghoApplication)) to sPath
97954>>>>>            Get vFolderFormat sPath to sPath
97955>>>>>            Move (sDriver + "dump.txt") to sFileName
97956>>>>>            Send DumpStatus of hoCLI (sPath + sFileName)
97957>>>>>            Send Destroy of hoCLI
97958>>>>>
97958>>>>>            Send vShellExecute "open" sFileName "" sPath
97959>>>>>            Sleep 1
97960>>>>>            Get vDeleteFile (sPath + sFileName) to iRetval
97961>>>>>        End_Procedure
97962>>>>>
97962>>>>>        Function IsEnabled Returns Boolean
97965>>>>>            String sFileName
97965>>>>>            Boolean bDriverLoadingError 
97965>>>>>            Get pbDriverLoadingError to bDriverLoadingError
97966>>>>>            Get Value of oDriverFileName_cf to sFileName
97967>>>>>            Function_Return (sFileName <> "" and bDriverLoadingError = False)
97968>>>>>        End_Function
97969>>>>>
97969>>>>>    End_Object
97970>>>>>
97970>>>>>    Object oReset_Btn is a cRDCButton
97972>>>>>        Set Size to 13 50
97973>>>>>        Set Label to "Refresh"
97974>>>>>        Set Status_Help to "If you edit the driver configuration file, the display of attributes above needs to be refreshed. Click here to refresh."
97975>>>>>        Set Location to 54 287
97976>>>>>        Set psImage to "ActionRefresh1.ico"
97977>>>>>        Set peAnchors to anTopRight
97978>>>>>        Set pbAutoEnable to True
97979>>>>>
97979>>>>>        Procedure OnClick
97982>>>>>            String sDriver
97982>>>>>            Get psDriverID to sDriver
97983>>>>>            Unload_Driver sDriver
97984>>>>>            Load_Driver sDriver
97985>>>>>            Send Info_Box "This dialog needs to be re-opened to display the refreshed values. Dialog will now close and you need to re-open it manually."
97986>>>>>            Send Close_Panel
97987>>>>>        End_Procedure
97988>>>>>
97988>>>>>        Function IsEnabled Returns Boolean
97991>>>>>            String sFileName
97991>>>>>            Boolean bDriverLoadingError 
97991>>>>>            Get pbDriverLoadingError to bDriverLoadingError
97992>>>>>            Get Value of oDriverFileName_cf to sFileName
97993>>>>>            Function_Return (sFileName <> "" and bDriverLoadingError = False)
97994>>>>>        End_Function
97995>>>>>
97995>>>>>    End_Object
97996>>>>>
97996>>>>>    Object oDriverSetings_grp is a cRDCHeaderGroup
97998>>>>>        Set Size to 125 328
97999>>>>>        Set Location to 74 9
98000>>>>>        Set psImage to "DriverSettings1.ico"
98001>>>>>        Set Label to "Driver Configuration File Settings"   
98002>>>>>        Set psNote to "Hover the mouse over an attribute field to read information about it."
98003>>>>>        Set peAnchors to anAll
98004>>>>>
98004>>>>>        Object oInvisible_Container is a Container3d
98006>>>>>            Set Size to 100 327
98007>>>>>            Set Location to 24 0
98008>>>>>            Set Border_Style to Border_None
98009>>>>>            Set peAnchors to anAll
98010>>>>>    
98010>>>>>            Object oScrollingContainer is a cScrollingContainer
98012>>>>>               
98012>>>>>                Object oScrollingClientArea is a cScrollingClientArea
98014>>>>>
98014>>>>>                    // Just fill the array with all available driver attributes from Cli.pkg,
98014>>>>>                    // and one object will automatically be created for each attribute
98014>>>>>                    // for the current driver by the DoReadDriverSettings procedure.
98014>>>>>                    Function GeneralDriverAttributes Returns String[]
98017>>>>>                        String[] sAttributesArray
98018>>>>>    
98018>>>>>                        Move "DF_DRIVER_DEFAULT_DEFAULT_ASCII             |CI1101" to sAttributesArray[SizeOfArray(sAttributesArray)]
98019>>>>>                        Move "DF_DRIVER_DEFAULT_NULLABLE_ASCII            |CI1102" to sAttributesArray[SizeOfArray(sAttributesArray)]
98020>>>>>                        Move "DF_DRIVER_DEFAULT_DEFAULT_NUMERIC           |CI1103" to sAttributesArray[SizeOfArray(sAttributesArray)]
98021>>>>>                        Move "DF_DRIVER_DEFAULT_NULLABLE_NUMERIC          |CI1104" to sAttributesArray[SizeOfArray(sAttributesArray)]
98022>>>>>                        Move "DF_DRIVER_DEFAULT_DEFAULT_DATE              |CI1105" to sAttributesArray[SizeOfArray(sAttributesArray)]
98023>>>>>                        Move "DF_DRIVER_DEFAULT_NULLABLE_DATE             |CI1106" to sAttributesArray[SizeOfArray(sAttributesArray)]
98024>>>>>                        Move "DF_DRIVER_DEFAULT_DEFAULT_TEXT              |CI1107" to sAttributesArray[SizeOfArray(sAttributesArray)]
98025>>>>>                        Move "DF_DRIVER_DEFAULT_NULLABLE_TEXT             |CI1108" to sAttributesArray[SizeOfArray(sAttributesArray)]
98026>>>>>                        Move "DF_DRIVER_DEFAULT_DEFAULT_BINARY            |CI1109" to sAttributesArray[SizeOfArray(sAttributesArray)]
98027>>>>>                        Move "DF_DRIVER_DEFAULT_NULLABLE_BINARY           |CI1110" to sAttributesArray[SizeOfArray(sAttributesArray)]
98028>>>>>                        Move "DF_DRIVER_DUMMY_ZERO_DATE_VALUE             |CI1111" to sAttributesArray[SizeOfArray(sAttributesArray)]
98029>>>>>                        Move "DF_DRIVER_MAX_ACTIVE_STATEMENTS             |CI1112" to sAttributesArray[SizeOfArray(sAttributesArray)]
98030>>>>>                        Move "DF_DRIVER_CACHE_PATH                        |CI1113" to sAttributesArray[SizeOfArray(sAttributesArray)]
98031>>>>>                        Move "DF_DRIVER_DRIVER_DECIMAL_SEPARATOR          |CI1114" to sAttributesArray[SizeOfArray(sAttributesArray)]
98032>>>>>                        Move "DF_DRIVER_DEFAULT_TABLE_CHARACTER_FORMAT    |CI1115" to sAttributesArray[SizeOfArray(sAttributesArray)]
98033>>>>>                        Move "DF_DRIVER_DRIVER_THOUSANDS_SEPARATOR        |CI1116" to sAttributesArray[SizeOfArray(sAttributesArray)]
98034>>>>>                        Move "DF_DRIVER_APPLICATION_CHARACTER_FORMAT      |CI1117" to sAttributesArray[SizeOfArray(sAttributesArray)]
98035>>>>>                        Move "DF_DRIVER_DRIVER_DATE_FORMAT                |CI1118" to sAttributesArray[SizeOfArray(sAttributesArray)]
98036>>>>>                        Move "DF_DRIVER_LAST_ERROR_TEXT                   |CI1119" to sAttributesArray[SizeOfArray(sAttributesArray)]
98037>>>>>                        Move "DF_DRIVER_DRIVER_DATE_SEPARATOR             |CI1120" to sAttributesArray[SizeOfArray(sAttributesArray)]
98038>>>>>    
98038>>>>>                        // Exception to the rule!
98038>>>>>                        // Someone - in its infinite wisdome - decided that the keyword in the ini file should be "DFConnectionId",
98038>>>>>                        // and not "Connection_ID" that is the API attribute name. This brakes the cDriverSettingsForm tooltip logic.
98038>>>>>                        // We fix it by changing the attribute constant string here (removed the _ (underscore) before the "ID" part.
98038>>>>>                        Move "DF_DRIVER_CONNECTIONID                      |CI1121" to sAttributesArray[SizeOfArray(sAttributesArray)]
98039>>>>>                        Move "DF_DRIVER_IGNORE_UCASE_SUPPORT              |CI1122" to sAttributesArray[SizeOfArray(sAttributesArray)]
98040>>>>>                        Move "DF_DRIVER_CONNECTION_ID_STRING              |CI1123" to sAttributesArray[SizeOfArray(sAttributesArray)]
98041>>>>>    
98041>>>>>                        Move "DF_DRIVER_IGNORE_WARNINGS                   |CI1124" to sAttributesArray[SizeOfArray(sAttributesArray)]
98042>>>>>                        Move "DF_DRIVER_USE_DF_LOCKERROR                  |CI1126" to sAttributesArray[SizeOfArray(sAttributesArray)]
98043>>>>>                        Move "DF_DRIVER_FIND_CACHE_TIMEOUT                |CI1128" to sAttributesArray[SizeOfArray(sAttributesArray)]
98044>>>>>                        Move "DF_DRIVER_JIT_TRESHOLD                      |CI1130" to sAttributesArray[SizeOfArray(sAttributesArray)]
98045>>>>>                        Move "DF_DRIVER_TRUNCATE_BINARY_ZEROES            |CI1132" to sAttributesArray[SizeOfArray(sAttributesArray)]
98046>>>>>                        Move "DF_DRIVER_ERROR_DEBUG_MODE                  |CI1134" to sAttributesArray[SizeOfArray(sAttributesArray)]
98047>>>>>                        Move "DF_DRIVER_USE_CACHE                         |CI1136" to sAttributesArray[SizeOfArray(sAttributesArray)]
98048>>>>>                        Move "DF_DRIVER_REPORT_CACHE_ERRORS               |CI1138" to sAttributesArray[SizeOfArray(sAttributesArray)]
98049>>>>>                        Move "DF_DRIVER_USE_CACHE_EXPIRATION              |CI1140" to sAttributesArray[SizeOfArray(sAttributesArray)]
98050>>>>>                        Move "DF_DRIVER_DEFAULT_USE_DUMMY_ZERO_DATE       |CI1142" to sAttributesArray[SizeOfArray(sAttributesArray)]
98051>>>>>                        Move "DF_DRIVER_DEFAULT_RECORD_IDENTITY_HIDING    |CI1144" to sAttributesArray[SizeOfArray(sAttributesArray)]
98052>>>>>                        Move "DF_DRIVER_REPORT_ACTIVE_COLUMN_ERRORS       |CI1146" to sAttributesArray[SizeOfArray(sAttributesArray)]
98053>>>>>                        Move "DF_DRIVER_SILENT_LOGIN                      |CI1148" to sAttributesArray[SizeOfArray(sAttributesArray)]
98054>>>>>                        Move "DF_DRIVER_DEFAULT_MAP_TO_RECNUM             |CI1150" to sAttributesArray[SizeOfArray(sAttributesArray)]
98055>>>>>                        Move "DF_DRIVER_CONNECTION_ID_OPTIONS             |CI1152" to sAttributesArray[SizeOfArray(sAttributesArray)]
98056>>>>>                        Move "DF_DRIVER_NUMBER_CONNECTION_IDS             |CI1154" to sAttributesArray[SizeOfArray(sAttributesArray)]
98057>>>>>                        Move "DF_DRIVER_DEFAULT_DEFAULT_DATETIME          |CI1155" to sAttributesArray[SizeOfArray(sAttributesArray)]
98058>>>>>                        Move "DF_DRIVER_DEFAULT_NULLABLE_DATETIME         |CI1156" to sAttributesArray[SizeOfArray(sAttributesArray)]
98059>>>>>                        Move "DF_DRIVER_MATCH_CLIENT_SERVER_VERSION       |CI1158" to sAttributesArray[SizeOfArray(sAttributesArray)]
98060>>>>>                        Move "DF_DRIVER_SQLSERVER_CLIENT_VERSION          |CI1160" to sAttributesArray[SizeOfArray(sAttributesArray)]
98061>>>>>                        Move "DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE            |CI1168" to sAttributesArray[SizeOfArray(sAttributesArray)]
98062>>>>>                        Move "DF_DRIVER_MAP_DFDATE_TO_SQLTYPE             |CI1169" to sAttributesArray[SizeOfArray(sAttributesArray)]
98063>>>>>                        Move "DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE        |CI1170" to sAttributesArray[SizeOfArray(sAttributesArray)]
98064>>>>>                        Move "DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE         |CI1171" to sAttributesArray[SizeOfArray(sAttributesArray)]
98065>>>>>                        Move "DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE           |CI1172" to sAttributesArray[SizeOfArray(sAttributesArray)]
98066>>>>>                        Move "DF_DRIVER_MAP_DFASCII_TO_SQLTYPE            |CI1173" to sAttributesArray[SizeOfArray(sAttributesArray)]
98067>>>>>                        Move "DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE            |CI1174" to sAttributesArray[SizeOfArray(sAttributesArray)]
98068>>>>>                        Move "DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE             |CI1175" to sAttributesArray[SizeOfArray(sAttributesArray)]
98069>>>>>                        Move "DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE          |CI1176" to sAttributesArray[SizeOfArray(sAttributesArray)]
98070>>>>>                        Move "DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE           |CI1177" to sAttributesArray[SizeOfArray(sAttributesArray)]
98071>>>>>                        Move "DF_DRIVER_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA |CI1178" to sAttributesArray[SizeOfArray(sAttributesArray)]
98072>>>>>                        Move "DF_DRIVER_LOGIN_ON_OPEN                     |CI1180" to sAttributesArray[SizeOfArray(sAttributesArray)]
98073>>>>>                        Move "DF_DRIVER_MINIMUM_CLIENT_VERSION            |CI1182" to sAttributesArray[SizeOfArray(sAttributesArray)]
98074>>>>>    
98074>>>>>                        // Sort items alphabetically
98074>>>>>                        Move (SortArray(sAttributesArray)) to sAttributesArray
98075>>>>>                        Function_Return sAttributesArray
98076>>>>>                    End_Function
98077>>>>>    
98077>>>>>                    Function SplitValue String sValue Integer ByRef iAttribute Returns String
98080>>>>>                        String sAttribute sTmp
98080>>>>>                        Integer iPos
98080>>>>>    
98080>>>>>                        Move (Pos("|", sValue)) to iPos
98081>>>>>                        Move (Left(sValue, (iPos -1))) to sAttribute
98082>>>>>                        Move (Mid(sValue, Length(sValue), iPos)) to sTmp
98083>>>>>                        Move (Trim(sAttribute)) to sAttribute
98084>>>>>                        Move (Eval(sTmp)) to iAttribute
98085>>>>>    
98085>>>>>                        Function_Return sAttribute
98086>>>>>                    End_Function
98087>>>>>    
98087>>>>>                    // Note: Creates dynamic objects.
98087>>>>>                    // They are not being destroyed by this method.
98087>>>>>                    // It is the reponsibility of the calling method to do that,
98087>>>>>                    // prior calling this method.
98087>>>>>                    Procedure DoReadDriverSettings String sDriver
98090>>>>>                        Integer iLocW iLocH iHfactor iFirstLineOffset iCount iItems iAttribute
98090>>>>>                        Handle ho hoParent
98090>>>>>                        String[] sAttributesArray
98091>>>>>                        String sValue sAttribute sDriverIniFile 
98091>>>>>                        Boolean bDriverLoadingError
98091>>>>>    
98091>>>>>                        Move (Self) to hoParent
98092>>>>>                        Move 13  to iHfactor // Height offset between form
98093>>>>>                        Move 120 to iLocW
98094>>>>>                        Move 10  to iLocH                            
98095>>>>>                        Move  0  to iFirstLineOffset // Offset from the top for the very first object.
98096>>>>>    
98096>>>>>                        Get Value of oDriverIniFile_fm to sDriverIniFile
98097>>>>>                        If (Trim(sDriverIniFile) = "") Begin
98099>>>>>                            Get Create (RefClass(cDbDriverSettingsForm)) to ho
98100>>>>>                            Move (iFirstLineOffset + iLocH) to iLocH
98101>>>>>                            Set Location of ho to iLocH (iLocW + 30)
98102>>>>>                            Set Label of ho to "No Driver Configuration File found!"
98103>>>>>                            Set Value of ho to "No attributes to display..."   
98104>>>>>                            Procedure_Return
98105>>>>>                        End
98105>>>>>>
98105>>>>>                            
98105>>>>>                        // Driver attributes aren't supported by the Pervasive driver,
98105>>>>>                        // so notify and quite.
98105>>>>>                        If (sDriver = DFBTRDRV_ID or sDriver = DATAFLEX_ID) Begin
98107>>>>>                            Get Create (RefClass(cDbDriverSettingsForm)) to ho
98108>>>>>                            Move (iFirstLineOffset + iLocH) to iLocH
98109>>>>>                            Set Location of ho to iLocH (iLocW + 30)
98110>>>>>                            Set Label of ho to "Query of driver attributes unsupported!"
98111>>>>>                            Set Value of ho to "Sorry, no attributes to display"
98112>>>>>                            Procedure_Return
98113>>>>>                        End
98113>>>>>>
98113>>>>>    
98113>>>>>                        Get GeneralDriverAttributes to sAttributesArray
98114>>>>>                        Move (SizeOfArray(sAttributesArray)) to iItems
98115>>>>>                        Decrement iItems
98116>>>>>                        Send Ignore_Error of Error_Object_Id CLIERR_CONNECTIONIDOUTOFRANGE 
98117>>>>>                        Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE  // Invalid driver value
98118>>>>>    
98118>>>>>                        For iCount from 0 to iItems
98124>>>>>>
98124>>>>>                            Move sAttributesArray[iCount] to sValue
98125>>>>>                            Get SplitValue sValue (&iAttribute) to sAttribute
98126>>>>>    
98126>>>>>                            Get Create (RefClass(cDbDriverSettingsForm)) to ho 
98127>>>>>                            Set psDriverIniFile of ho to sDriverIniFile
98128>>>>>                            Send SetValue of ho sDriver sAttribute iAttribute
98129>>>>>                            Get private.pbDriverLoadingError of ho to bDriverLoadingError
98130>>>>>                            If (bDriverLoadingError = True) Begin
98132>>>>>                                Set Label of ho to "Driver could not be loaded!"   
98133>>>>>                                If (Trim(sDriverIniFile) = "") Begin
98135>>>>>                                    Set Value of ho to "Driver .dll file not found!"
98136>>>>>                                End
98136>>>>>>
98136>>>>>                                Else Begin
98137>>>>>                                    Set Value of ho to "No attributes to display..."   
98138>>>>>                                End
98138>>>>>>
98138>>>>>                                Set psToolTip of ho to "Check that the database engine for the selected driver is installed and is running correctly!"  
98139>>>>>                                Delegate Set pbDriverLoadingError to True
98141>>>>>                                Move iItems to iCount // We're out of here.   
98142>>>>>                                Move False to Err
98143>>>>>                            End
98143>>>>>>
98143>>>>>                            If (Err = True) Begin
98145>>>>>                                Send Destroy of ho
98146>>>>>                            End
98146>>>>>>
98146>>>>>                            Else Begin
98147>>>>>                                If (iCount = 0) Begin
98149>>>>>                                    Move (iFirstLineOffset + iLocH) to iLocH
98150>>>>>                                End
98150>>>>>>
98150>>>>>                                Set Location of ho to iLocH (iLocW + 30)
98151>>>>>                                Move (iLocH + iHfactor) to iLocH
98152>>>>>                            End
98152>>>>>>
98152>>>>>                        Loop
98153>>>>>>
98153>>>>>    
98153>>>>>                        Send Trap_Error of Error_Object_Id CLIERR_CONNECTIONIDOUTOFRANGE
98154>>>>>                        Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
98155>>>>>                    End_Procedure
98156>>>>>    
98156>>>>>                End_Object
98157>>>>>
98157>>>>>            End_Object
98158>>>>>    
98158>>>>>        End_Object
98159>>>>>
98159>>>>>    End_Object
98160>>>>>
98160>>>>>    Object oInfo_edt is a cRichEdit
98162>>>>>        Set Size to 49 328
98163>>>>>        Set Location to 213 9
98164>>>>>        Set Label to "General Connectivity Kit Information:"
98165>>>>>        Set Value to "It is possible to configure the behavior of a Connectivity Kit through configuration files. Configuration files can be located anywhere in DFPATH. In general, one configuration file per install is enough. There are situations where there is a need to have different configurations for different deploy environments on one machine/network. In that case the configuration file should be placed in the deployment environment rather than in the overall DataFlex environment."
98166>>>>>        Set Skip_State to True
98167>>>>>        Set Read_Only_State to True
98168>>>>>        Set pbItalics to True
98169>>>>>        Set peAnchors to anBottomLeftRight
98170>>>>>
98170>>>>>        Procedure DoIndent
98173>>>>>            Integer iTwipsPerInch iCurrentIndent
98173>>>>>        
98173>>>>>            // number of twips per inch
98173>>>>>            Move 1440 to iTwipsPerInch
98174>>>>>        
98174>>>>>            Set piSpacingBefore to (1440 * 0.05)
98175>>>>>            // indent 0.1 inches from current indentation
98175>>>>>            Get piParagraphIndent to iCurrentIndent
98176>>>>>            Set piParagraphIndent to (iCurrentIndent + (iTwipsPerInch * 0.1))
98177>>>>>        End_Procedure
98178>>>>>        Send DoIndent
98179>>>>>
98179>>>>>    End_Object
98180>>>>>
98180>>>>>    Procedure Activating
98183>>>>>        Forward Send Activating
98185>>>>>        Send Cursor_Ready of Cursor_Control
98186>>>>>    End_Procedure
98187>>>>>
98187>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
98188>>>>>    On_Key kCancel       Send KeyAction of oCancel_Btn
98189>>>>>End_Object
98190>>>>>
98190>>>>>// General purpose access method for the dialog above:
98190>>>>>Procedure PopupDriverSettings String sDriverID 
98193>>>>>    Handle ho
98193>>>>>    String sDriverFile sPath
98193>>>>>
98193>>>>>    Send Cursor_Wait of Cursor_Control
98194>>>>>    Move (oDriverSettings_dg(Self)) to ho
98195>>>>>    Set psDriverID of ho to sDriverID
98196>>>>>    Set pbDriverLoadingError of ho to False
98197>>>>>
98197>>>>>    Set Value of (oDriver_cf(ho)) to sDriverID
98198>>>>>    Get DatabaseDriverPath sDriverID to sPath
98199>>>>>    If (sPath <> "") Begin
98201>>>>>        Move (sDriverID + ".dll")  to sDriverFile
98202>>>>>    End
98202>>>>>>
98202>>>>>    Set Value of (oDriverFileName_cf(ho)) to (sPath + sDriverFile)
98203>>>>>    Send Cursor_Ready of Cursor_Control
98204>>>>>
98204>>>>>    Send Popup of ho
98205>>>>>End_Procedure
98206>>>>>
98206>>>>>Function DatabaseDriverPath String sDriverID Returns String
98209>>>>>    String sPath sDriverFileName
98209>>>>>
98209>>>>>    Move "" to sPath
98210>>>>>    If (sDriverID = DATAFLEX_ID) Begin
98212>>>>>        Function_Return sPath
98213>>>>>    End                   
98213>>>>>>
98213>>>>>    
98213>>>>>    Move (sDriverID + ".dll") to sDriverFileName
98214>>>>>    Get SearchLocallyThenGloballyForFile of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDriverFileName to sPath
98215>>>>>    
98215>>>>>    Function_Return sPath
98216>>>>>End_Function      
98217>>>>>
98217>>>>>Function DatabaseDriverIniFilePath String sDriverID Returns String
98220>>>>>    String sPath sDriverFileName
98220>>>>>
98220>>>>>    Move "" to sPath
98221>>>>>    If (sDriverID = DATAFLEX_ID) Begin
98223>>>>>        Function_Return sPath
98224>>>>>    End                   
98224>>>>>>
98224>>>>>    
98224>>>>>    Move (sDriverID + ".int") to sDriverFileName
98225>>>>>    Get SearchLocallyThenGloballyForFile of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDriverFileName to sPath
98226>>>>>    
98226>>>>>    Function_Return sPath
98227>>>>>End_Function      
98228>>>Use CreateDatabase.dg
Including file: CreateDatabase.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\CreateDatabase.dg)
98228>>>>>Use Windows.pkg
98228>>>>>Use cRDCModalPanel.pkg
98228>>>>>Use cRDCForm.pkg 
98228>>>>>Use cRDCComboForm.pkg
98228>>>>>Use cRDCSuggestionIniForm.pkg
Including file: cRDCSuggestionIniForm.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cRDCSuggestionIniForm.pkg)
98228>>>>>>>//****************************************************************************
98228>>>>>>>// $Module type: Class
98228>>>>>>>// $Module name: cRDCSuggestionIniForm
98228>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
98228>>>>>>>// Web-site    : http://www.rdctools.com
98228>>>>>>>// Created     : 2018-09-05 @ 09:50 (Military date format: YY-MM-DD)
98228>>>>>>>//
98228>>>>>>>// Description : The class consists of a variant of DataAccess Worldwide's cSuggestionFormList
98228>>>>>>>//               It has the added ability to save/retrieve values to the workspace .ws file.
98228>>>>>>>//
98228>>>>>>>// $Rev History:
98228>>>>>>>//    2018-09-05  Module header created
98228>>>>>>>//
98228>>>>>>>//****************************************************************************
98228>>>>>>>Use Windows.pkg
98228>>>>>>>Use Windows.pkg
98228>>>>>>>Use WinSuggestion.pkg
98228>>>>>>>Use cIniFile.pkg
98228>>>>>>>Use cRDCForm.pkg
98228>>>>>>>Use vWin32fh.pkg
98228>>>>>>>
98228>>>>>>>Define CS_cRDCSuggestionFormList       for "Suggestion Form List"  // [Section Name]
98228>>>>>>>Define CS_cRDCSuggestionSaveItem       for "Saved Item"            // Key=Value
98228>>>>>>>Define CS_cRDCSuggestionFormTooltip    for "This is a suggestion form - start typing what you're looking for. Previously entered values are saved automatically."
98228>>>>>>>
98228>>>>>>>Class cRDCSuggestionIniForm is a cRDCForm
98229>>>>>>>
98229>>>>>>>    Procedure Define_cRDCSuggestionControl_mixin
98231>>>>>>>
98231>>>>>>>        Property Integer piTimeOutTicks 0
98232>>>>>>>
98232>>>>>>>        On_Key kEnter            Send SelectSuggestion
98233>>>>>>>        On_Key Key_Escape        Send DeActivateSuggestionList
98234>>>>>>>        On_Key Key_Up_Arrow      Send Up
98235>>>>>>>        On_Key Key_Down_Arrow    Send Down
98236>>>>>>>
98236>>>>>>>        // Added 'Home' & 'End' navigation keys for the drop-down list and the form object (and Ctrl+Home & Ctrl+End).
98236>>>>>>>        On_Key Key_Home          Send Home
98237>>>>>>>        On_Key Key_Ctrl+Key_Home Send Home
98238>>>>>>>    On_Key Key_End           Send End
98239>>>>>>>On_Key Key_Ctrl+Key_End  Send End // Need this as well; else the Ctrl+Home/End keys generates a runtime error (always has).
98240>>>>>>>
98240>>>>>>>// Just can't seem to get the popup of the suggestion list with F4 to work.
98240>>>>>>>On_Key kPrompt           Send Prompt
98241>>>>>>>End_Procedure
98242>>>>>>>
98242>>>>>>>Import_Class_Protocol cSuggestionControl_mixin
98243>>>>>>>Import_Class_Protocol cSuggestion_mixin
98244>>>>>>>
98244>>>>>>>Procedure Construct_Object
98246>>>>>>>    Forward Send Construct_Object
98248>>>>>>>    Send Define_cRDCSuggestionControl_mixin
98249>>>>>>>    Send Define_cSuggestion_mixin
98250>>>>>>>
98250>>>>>>>    Set peSuggestionMode to smCustom
98251>>>>>>>    Set pbFullText to True
98252>>>>>>>    Set piStartAtChar to 1
98253>>>>>>>
98253>>>>>>>    Property String[] psSavedFormValues
98254>>>>>>>    Property String psIniFileSection
98255>>>>>>>    Property Integer piSuggestionListMaxItems 99 // Max no of values saved/read to ini file
98256>>>>>>>    Property Boolean pbUseWorkspaceIniFile True
98257>>>>>>>    Property Boolean pbAutoCheckValueExistsAsFile True
98258>>>>>>>    Property Boolean pbAskToRemoveMissingFile True
98259>>>>>>>    // Note: pbUseWorkspaceIniFile has presedence over the psIniFileName setting.
98259>>>>>>>    //       That means that if pbUseWorkspaceIniFile=True, psIniFilename will be set to the
98259>>>>>>>    //       worspace .ws file on program startup.
98259>>>>>>>    Property String psIniFileName "RDCSuggestionForm.ini"
98260>>>>>>>End_Procedure
98261>>>>>>>
98261>>>>>>>Procedure ShowSuggestions
98263>>>>>>>    tSuggestion[] aResults
98263>>>>>>>    tSuggestion[] aResults
98264>>>>>>>    Integer i iLines
98264>>>>>>>    String sSearch
98264>>>>>>>
98264>>>>>>>    Get pSearchResults to aResults
98265>>>>>>>    Get Value to sSearch
98266>>>>>>>
98266>>>>>>>    If (ghoSuggestionList <> 0) Begin
98268>>>>>>>        Send Delete_Data of ghoSuggestionList
98269>>>>>>>        Move (SizeOfArray(aResults)) to iLines
98270>>>>>>>        For i from 0 to (iLines-1)
98276>>>>>>>>
98276>>>>>>>            Send ShowSuggestion aResults[i] sSearch
98277>>>>>>>            If ((iLines-1)<>i) Begin
98279>>>>>>>                Send AppendTextLn of ghoSuggestionList ""
98280>>>>>>>            End
98280>>>>>>>>
98280>>>>>>>        Loop
98281>>>>>>>>
98281>>>>>>>        Send AdjustSuggestionListSize iLines
98282>>>>>>>    End
98282>>>>>>>>
98282>>>>>>>
98282>>>>>>>    Set Cursor of Cursor_Control to IDC_ARROW
98283>>>>>>>    Send Activate of (Self)
98284>>>>>>>    Send Release_Mouse_Capture
98285>>>>>>>End_Procedure
98286>>>>>>>
98286>>>>>>>Procedure Home
98288>>>>>>>    If (Focus(Desktop) = Self and ghoSuggestionList) Begin
98290>>>>>>>        Send ScrollHome
98291>>>>>>>    End
98291>>>>>>>>
98291>>>>>>>    Else Begin
98292>>>>>>>        Send Key VK_HOME
98293>>>>>>>    End
98293>>>>>>>>
98293>>>>>>>End_Procedure
98294>>>>>>>
98294>>>>>>>Procedure ScrollHome
98296>>>>>>>    Send SelectRow of ghoSuggestionList 0
98297>>>>>>>End_Procedure
98298>>>>>>>
98298>>>>>>>Procedure End
98300>>>>>>>If (Focus(Desktop) = Self and ghoSuggestionList) Begin
98302>>>>>>>    Send ScrollEnd
98303>>>>>>>End
98303>>>>>>>>
98303>>>>>>>Else Begin
98304>>>>>>>    Send Key VK_END
98305>>>>>>>End
98305>>>>>>>>
98305>>>>>>>End_Procedure
98306>>>>>>>
98306>>>>>>>Procedure ScrollEnd
98308>>>>>>>    Integer iLine iLines
98308>>>>>>>    Get Line_Count of ghoSuggestionList  to iLines
98309>>>>>>>    Get SelectedRow of ghoSuggestionList to iLine
98310>>>>>>>    // there can be an extra line at the end
98310>>>>>>>    If (iLine < iLines - 1) Begin
98312>>>>>>>        Send SelectRow of ghoSuggestionList (iLines - 1)
98313>>>>>>>    End
98313>>>>>>>>
98313>>>>>>>End_Procedure
98314>>>>>>>
98314>>>>>>>Procedure Activating
98316>>>>>>>    String[] sSavedFormValues
98317>>>>>>>    If (pbUseWorkspaceIniFile(Self) = True) Begin
98319>>>>>>>        Get ReadWorkspaceIniFile to sSavedFormValues
98320>>>>>>>        Set psSavedFormValues    to sSavedFormValues
98321>>>>>>>    End
98321>>>>>>>>
98321>>>>>>>End_Procedure
98322>>>>>>>
98322>>>>>>>Procedure Set psToolTip String sToolTip
98324>>>>>>>    String sStatusHelp
98324>>>>>>>
98324>>>>>>>    Get Status_Help to sStatusHelp
98325>>>>>>>    If (sStatusHelp = "") Begin
98327>>>>>>>        Set Status_Help to sToolTip
98328>>>>>>>    End
98328>>>>>>>>
98328>>>>>>>
98328>>>>>>>    Move (sToolTip + String(Character(10)) + String(CS_cRDCSuggestionFormTooltip)) to sToolTip
98329>>>>>>>    Forward Set psToolTip to sToolTip
98331>>>>>>>End_Procedure
98332>>>>>>>
98332>>>>>>>Function ReadWorkspaceIniFile Returns String[]
98334>>>>>>>    String sWorkspaceFile sObjectName sValue
98334>>>>>>>    String[] sSavedFormValues
98335>>>>>>>    Handle hoIniFile
98335>>>>>>>    Integer iItem iCount iSize
98335>>>>>>>    Boolean bExists
98335>>>>>>>
98335>>>>>>>    If (pbUseWorkspaceIniFile(Self) = False) Begin
98337>>>>>>>        Function_Return sSavedFormValues
98338>>>>>>>    End
98338>>>>>>>>
98338>>>>>>>
98338>>>>>>>    Move 0 to iItem
98339>>>>>>>    Get Object_Label to sObjectName
98340>>>>>>>    Move (psWorkspaceWSFile(phoWorkspace(ghoApplication))) to sWorkspaceFile
98341>>>>>>>    Set psIniFileName to sWorkspaceFile
98342>>>>>>>    Get Create (RefClass(cIniFile)) to hoIniFile
98343>>>>>>>    Set psFileName of hoIniFile to sWorkspaceFile
98344>>>>>>>    Get piSuggestionListMaxItems to iSize
98345>>>>>>>
98345>>>>>>>    For iCount from 0 to iSize
98351>>>>>>>>
98351>>>>>>>        Get KeyExists of hoIniFile (CS_cRDCSuggestionFormList * String(sObjectName)) (CS_cRDCSuggestionSaveItem + String(iCount)) to bExists
98352>>>>>>>        // We need to loop through all possible values because the list of items may not start at zero.
98352>>>>>>>        Get ReadString of hoIniFile (CS_cRDCSuggestionFormList * String(sObjectName)) (CS_cRDCSuggestionSaveItem + String(iCount)) "" to sValue
98353>>>>>>>        If (Trim(sValue) <> "") Begin
98355>>>>>>>            Move sValue to sSavedFormValues[iItem]
98356>>>>>>>            Increment iItem
98357>>>>>>>        End
98357>>>>>>>>
98357>>>>>>>    Loop
98358>>>>>>>>
98358>>>>>>>
98358>>>>>>>    Send Destroy of hoIniFile
98359>>>>>>>    Function_Return sSavedFormValues
98360>>>>>>>End_Function
98361>>>>>>>
98361>>>>>>>Procedure WriteWorkspaceIniFile
98363>>>>>>>    String sWorkspaceFile sObjectName sValue
98363>>>>>>>    String[] sSavedFormValues
98364>>>>>>>    Handle hoIniFile
98364>>>>>>>    Integer iSize iCount
98364>>>>>>>    Boolean bExists
98364>>>>>>>
98364>>>>>>>    If (pbUseWorkspaceIniFile(Self) = False) Begin
98366>>>>>>>        Procedure_Return
98367>>>>>>>    End
98367>>>>>>>>
98367>>>>>>>
98367>>>>>>>    Get Object_Label  to sObjectName
98368>>>>>>>    Get psIniFileName to sWorkspaceFile
98369>>>>>>>    Get Create (RefClass(cIniFile)) to hoIniFile
98370>>>>>>>    Set psFileName    of hoIniFile to sWorkspaceFile
98371>>>>>>>    Get SectionExists of hoIniFile (CS_cRDCSuggestionFormList * String(sObjectName)) to bExists
98372>>>>>>>    If (bExists = True) Begin
98374>>>>>>>        Send DeleteSection of hoIniFile (CS_cRDCSuggestionFormList * String(sObjectName))
98375>>>>>>>    End
98375>>>>>>>>
98375>>>>>>>
98375>>>>>>>    Get psSavedFormValues to sSavedFormValues
98376>>>>>>>    Move (SizeOfArray(sSavedFormValues)) to iSize
98377>>>>>>>    Decrement iSize
98378>>>>>>>
98378>>>>>>>    For iCount from 0 to iSize
98384>>>>>>>>
98384>>>>>>>        Move sSavedFormValues[iCount] to sValue
98385>>>>>>>        Move (Trim(sValue)) to sValue
98386>>>>>>>        Get vFilePathExists sValue to bExists
98387>>>>>>>        If (bExists = True) Begin
98389>>>>>>>            Send WriteString of hoIniFile (CS_cRDCSuggestionFormList * String(sObjectName)) (CS_cRDCSuggestionSaveItem + String(iCount)) sSavedFormValues[iCount]
98390>>>>>>>        End
98390>>>>>>>>
98390>>>>>>>    Loop
98391>>>>>>>>
98391>>>>>>>
98391>>>>>>>    Send Destroy of hoIniFile
98392>>>>>>>End_Procedure
98393>>>>>>>
98393>>>>>>>Procedure Prompt
98395>>>>>>>    If (ghoSuggestionTimer=0) Begin
98397>>>>>>>        Send CreateSuggestionTimer
98398>>>>>>>    End
98398>>>>>>>>
98398>>>>>>>    Send ActivateSuggestionList
98399>>>>>>>    Send FindSuggestions
98400>>>>>>>    Set Visible_State of ghoSuggestionList to True
98401>>>>>>>End_Procedure
98402>>>>>>>
98402>>>>>>>Procedure OnExitObject
98404>>>>>>>    String sValue
98404>>>>>>>    Boolean bExists
98404>>>>>>>    String[] sSavedFormValues
98405>>>>>>>    Integer iSize iIndex
98405>>>>>>>
98405>>>>>>>    Forward Send OnExitObject
98407>>>>>>>
98407>>>>>>>    If (pbUseWorkspaceIniFile(Self) = False) Begin
98409>>>>>>>        Procedure_Return
98410>>>>>>>    End
98410>>>>>>>>
98410>>>>>>>
98410>>>>>>>    Get Value to sValue
98411>>>>>>>    Move (Trim(sValue)) to sValue
98412>>>>>>>    Get psSavedFormValues to sSavedFormValues
98413>>>>>>>    Move (SearchArray(sValue, sSavedFormValues)) to iIndex
98414>>>>>>>    // Does it exist in the array already?
98414>>>>>>>    If (iIndex <> -1) Begin
98416>>>>>>>        Procedure_Return
98417>>>>>>>    End
98417>>>>>>>>
98417>>>>>>>    Get vFilePathExists sValue to bExists
98418>>>>>>>    If (bExists = False) Begin
98420>>>>>>>        Procedure_Return
98421>>>>>>>    End
98421>>>>>>>>
98421>>>>>>>    Move (SizeOfArray(sSavedFormValues)) to iSize
98422>>>>>>>    Move sValue to sSavedFormValues[iSize]
98423>>>>>>>    Set psSavedFormValues to sSavedFormValues
98424>>>>>>>    Send WriteWorkspaceIniFile
98425>>>>>>>End_Procedure
98426>>>>>>>
98426>>>>>>>// Custom code to find all matches for the search
98426>>>>>>>Procedure OnFindSuggestions String sSearch tSuggestion[] ByRef aSuggestions
98428>>>>>>>    String[] sSavedFormValues
98429>>>>>>>    Integer i iLen iSize iCount
98429>>>>>>>
98429>>>>>>>    Move (Lowercase(sSearch)) to sSearch
98430>>>>>>>    Move (Length(sSearch)) to iLen
98431>>>>>>>    Get psSavedFormValues to sSavedFormValues
98432>>>>>>>    Move (SizeOfArray(sSavedFormValues)) to iSize
98433>>>>>>>    Decrement iSize
98434>>>>>>>    For i from 0 to iSize
98440>>>>>>>>
98440>>>>>>>        If (Lowercase(sSavedFormValues[i]) contains sSearch) Begin
98442>>>>>>>            Move sSavedFormValues[i] to aSuggestions[iCount].sRowId
98443>>>>>>>            Move sSavedFormValues[i] to aSuggestions[iCount].aValues[0]
98444>>>>>>>            Increment iCount
98445>>>>>>>        End
98445>>>>>>>>
98445>>>>>>>    Loop
98446>>>>>>>>
98446>>>>>>>End_Procedure
98447>>>>>>>
98447>>>>>>>Procedure OnSelectSuggestion String sSearch tSuggestion Suggestion
98449>>>>>>>    Boolean bExists bAutoCheckValueExistsAsFile bAskToRemoveMissingFile
98449>>>>>>>    Integer iRetval iIndex
98449>>>>>>>    String[] sSavedFormValues
98450>>>>>>>    String sValue
98450>>>>>>>
98450>>>>>>>    //        Send Release_Mouse_Capture
98450>>>>>>>    Move Suggestion.sRowId to sValue
98451>>>>>>>    Move (Trim(sValue)) to sValue
98452>>>>>>>    Get pbAutoCheckValueExistsAsFile to bAutoCheckValueExistsAsFile
98453>>>>>>>
98453>>>>>>>    If (bAutoCheckValueExistsAsFile = True) Begin
98455>>>>>>>        Get pbAskToRemoveMissingFile to bAskToRemoveMissingFile
98456>>>>>>>        Get vFilePathExists sValue to bExists
98457>>>>>>>        If (bExists = False) Begin
98459>>>>>>>            If (bAskToRemoveMissingFile = True) Begin
98461>>>>>>>                Get YesNo_Box ("The file" * String(sValue) + "\nDoesn't exist. Do you want to remove it from the suggestion list?") to iRetval
98462>>>>>>>            End
98462>>>>>>>>
98462>>>>>>>            // This will happen if bAskToRemoveMissingFile = False, and bAutoCheckValueExistsAsFile = True.
98462>>>>>>>            // Then the missing file will just be removed from the saved list.
98462>>>>>>>            Else Begin
98463>>>>>>>                Move MBR_Yes to iRetval
98464>>>>>>>            End
98464>>>>>>>>
98464>>>>>>>
98464>>>>>>>            If (iRetval = MBR_Yes) Begin
98466>>>>>>>                Get psSavedFormValues to sSavedFormValues
98467>>>>>>>                Move (SearchArray(sValue, sSavedFormValues)) to iIndex
98468>>>>>>>                If (iIndex <> -1) Begin
98470>>>>>>>                    Move (RemoveFromArray(sSavedFormValues, iIndex)) to sSavedFormValues
98471>>>>>>>                    Set psSavedFormValues to sSavedFormValues
98472>>>>>>>                    Send WriteWorkspaceIniFile
98473>>>>>>>                    Set Value to ""
98474>>>>>>>                    Procedure_Return
98475>>>>>>>                End
98475>>>>>>>>
98475>>>>>>>            End
98475>>>>>>>>
98475>>>>>>>        End
98475>>>>>>>>
98475>>>>>>>    End
98475>>>>>>>>
98475>>>>>>>
98475>>>>>>>    Set Value to Suggestion.sRowId
98476>>>>>>>    Set Item_Changed_State to False
98477>>>>>>>End_Procedure
98478>>>>>>>
98478>>>>>>>//    { MethodType=Event  NoDoc=True }
98478>>>>>>>//    Procedure Mouse_Click Integer i1 Integer i2
98478>>>>>>>//        Send Release_Mouse_Capture
98478>>>>>>>//        Forward Send Mouse_click i1 i2
98478>>>>>>>//    End_Procedure
98478>>>>>>>
98478>>>>>>>End_Class
98479>>>>>>>
98479>>>>>>>//    Procedure Mouse_Up for cRDCSuggestionList Integer iWindowNumber Integer iPosition
98479>>>>>>>//        Handle hoObj
98479>>>>>>>//        Send Release_Mouse_Capture
98479>>>>>>>//        Get phoOwner to hoObj
98479>>>>>>>//        Send Activate of hoObj // move focus to owner, which will close the list
98479>>>>>>>//        Send SelectSuggestion of hoObj
98479>>>>>>>//    End_Procedure // Mouse_Up
98479>>>>>>>
98479>>>>>>>//    Function OnWindowsHook for cRDCSuggestionHookMouse Integer i1 Integer i2 Integer i3 Returns Integer
98479>>>>>>>//        tWinMouseHookStruct MouseHook
98479>>>>>>>//        Integer ivoid hObj
98479>>>>>>>//        Handle hoOwner hoParent
98479>>>>>>>//        If (i1=0 and (i2=WM_LBUTTONDOWN or i2=WM_RBUTTONDOWN or i2=WM_MBUTTONDOWN or ;
98479>>>>>>>//                      i2=WM_NCLBUTTONDOWN or i2=WM_NCRBUTTONDOWN or i2=WM_NCMBUTTONDOWN)) Begin
98479>>>>>>>//            Send Release_Mouse_Capture
98479>>>>>>>//            Move (CopyMemory(AddressOf(MouseHook), i3, SizeOfType(tWinMouseHookStruct))) to iVoid
98479>>>>>>>//            GET_OBJECT_FROM_WINDOW MouseHook.hwnd to hObj
98479>>>>>>>//            If (hObj = Cursor_Control) Begin
98479>>>>>>>//                Move (Focus(Desktop)) to hObj
98479>>>>>>>//            End
98479>>>>>>>//            Get Parent to hoParent
98479>>>>>>>//            Get phoOwner of hoParent to hoOwner
98479>>>>>>>//            If (not(hObj) or (hObj<>hoParent and hObj<>hoOwner)) Begin
98479>>>>>>>//                Send DisableWindowsHook
98479>>>>>>>//                Send DeActivateSuggestionList of hoOwner
98479>>>>>>>//            End
98479>>>>>>>//        End
98479>>>>>>>//    End_Function
98479>>>>>>>
98479>>>>>Use cDbUpdateFunctionLibrary.pkg
98479>>>>>Use cRDCHeaderGroup.pkg
98479>>>>>Use cCommandLinkButton.pkg
98479>>>>>
98479>>>>>Object oCreateDatabase_dg is a cRDCModalPanel
98481>>>>>    Set Size to 151 312
98482>>>>>    Set Label to "Create New Database"
98483>>>>>    Set piMinSize to 53 211
98484>>>>>    Set Location to 2 2
98485>>>>>    Set Icon to "ActionCreateDatabase1.ico"
98486>>>>>    
98486>>>>>    Property String psDriverID                   
98488>>>>>    Property String psCollation 
98490>>>>>    Property String psDatabaseName 
98492>>>>>
98492>>>>>//    Object oCollate_cf is a cRDCComboForm
98492>>>>>//        Set Size to 13 216
98492>>>>>//        Set Location to 42 63
98492>>>>>//        Set Label to "Use Collation:"  
98492>>>>>//        Set psToolTip to "Select/Enter the collation to use when creating the database. If none is specified the default SQL server collation above will be used. Note: Collations starting with 'SQL_' is obsolete and should not be used."
98492>>>>>//        // This must be set to False; else the filling takes for ever.
98492>>>>>//        Set pbAutoListWidth to False
98492>>>>>//        
98492>>>>>//        Procedure Combo_Fill_List
98492>>>>>//            String[] asCollations   
98492>>>>>//            Integer iCount iSize      
98492>>>>>//            String sDriverID sCollation
98492>>>>>//            
98492>>>>>//            Get psDriverID to sDriverID      
98492>>>>>//            
98492>>>>>//            // The _SqlEnumerateDatabaseCollations function is *at current* for MSSQLDRV_ID only.
98492>>>>>//            If (sDriverID = MSSQLDRV_ID) Begin
98492>>>>>//                Send Cursor_Wait of Cursor_Control
98492>>>>>//                Get _SqlEnumerateDatabaseCollations of ghoDbUpdateFunctionLibrary sDriverID to asCollations
98492>>>>>//                Move (SizeOfArray(asCollations)) to iSize
98492>>>>>//                Decrement iSize
98492>>>>>//                For iCount from 0 to iSize
98492>>>>>//                    Send Combo_Add_Item asCollations[iCount]
98492>>>>>//                Loop
98492>>>>>//                
98492>>>>>//                Get psCollation of ghoDbUpdateFunctionLibrary to sCollation
98492>>>>>//                Set Value to sCollation
98492>>>>>//                Send Cursor_Ready of Cursor_Control
98492>>>>>//            End
98492>>>>>//        End_Procedure
98492>>>>>//    
98492>>>>>//        Procedure OnChange
98492>>>>>//            String sValue
98492>>>>>//            Get Value to sValue
98492>>>>>//            Set psCollation to sValue
98492>>>>>//        End_Procedure
98492>>>>>//     
98492>>>>>//    End_Object
98492>>>>>
98492>>>>>    Object oInfo_tb is a TextBox
98494>>>>>        Set Auto_Size_State to False
98495>>>>>        Set Size to 8 50
98496>>>>>        Set Location to 133 120
98497>>>>>        Set TextColor to clGreen
98498>>>>>        Set Justification_Mode to JMode_Right
98499>>>>>        Set peAnchors to anBottomRight
98500>>>>>    End_Object
98501>>>>>
98501>>>>>    Object oMain_RDCHeaderGroup is a cRDCHeaderGroup
98503>>>>>        Set Size to 108 293
98504>>>>>        Set Location to 8 10
98505>>>>>        Set psImage to "ActionCreateDatabase1.ico"
98506>>>>>        Set Label to "Create Database"
98507>>>>>        Set psNote to "Enter collation and database name"
98508>>>>>        Set peAnchors to anTopBottom
98509>>>>>
98509>>>>>        Object oDriver_fm is a cRDCForm
98511>>>>>            Set Size to 13 100
98512>>>>>            Set Location to 34 63
98513>>>>>            Set Label to "Driver"
98514>>>>>            Set Enabled_State to False  
98515>>>>>        End_Object  
98516>>>>>        
98516>>>>>        Object oServerCurrentCollating_fm is a cRDCForm
98518>>>>>            Set Size to 13 216
98519>>>>>            Set Location to 49 63
98520>>>>>            Set Label to "Default Collation"
98521>>>>>            Set psToolTip to "The SQL server's default collation. It will be used when creating a new database, if nothing else is specified."
98522>>>>>            Set Enabled_State to False  
98523>>>>>            
98523>>>>>            Procedure InitializeCollation 
98526>>>>>                String sCollation
98526>>>>>                
98526>>>>>                Move False to Err
98527>>>>>                Send Ignore_All of Error_Object_Id
98528>>>>>                // Fetch the SQL server's default collation:
98528>>>>>                // It will be used when creating a new database, if nothing else is specified.
98528>>>>>                Get SqlDatabaseCollationQuery of ghoDbUpdateFunctionLibrary "master" False to sCollation
98529>>>>>                Send Trap_All of Error_Object_Id
98530>>>>>                If (Err = True) Begin
98532>>>>>                    Move "" to sCollation
98533>>>>>                End
98533>>>>>>
98533>>>>>                Set Value to sCollation
98534>>>>>            End_Procedure     
98535>>>>>    
98535>>>>>        End_Object  
98536>>>>>        
98536>>>>>        Object oCollate_fm is a cRDCSuggestionIniForm 
98538>>>>>            Set Size to 13 216
98539>>>>>            Set Location to 65 63
98540>>>>>            Set Label to "Collation"
98541>>>>>            Set psToolTip to "Suggestion list. Select/Enter the collation to use when creating the database. If none is specified the default SQL server collation above will be used. Note: Collations starting with 'SQL_' is obsolete and should not be used."
98542>>>>>            Set pbAskToRemoveMissingFile to False
98543>>>>>            Set pbAutoCheckValueExistsAsFile to False
98544>>>>>            Set pbUseWorkspaceIniFile to True
98545>>>>>            Set piStartAtChar to 3
98546>>>>>            Set Prompt_Button_Mode to PB_PromptOn
98547>>>>>            
98547>>>>>            Function ReadWorkspaceIniFile Returns String[]
98550>>>>>                String[] asCollations   
98551>>>>>                Integer iCount iSize      
98551>>>>>                String sDriverID sCollation
98551>>>>>                
98551>>>>>                Get psDriverID to sDriverID      
98552>>>>>                // The _SqlEnumerateDatabaseCollations function is at current for MSSQLDRV_ID only.
98552>>>>>                If (sDriverID <> MSSQLDRV_ID) Begin
98554>>>>>                    Function_Return asCollations
98555>>>>>                End                 
98555>>>>>>
98555>>>>>                
98555>>>>>                Send Cursor_Wait of Cursor_Control
98556>>>>>                Get _SqlEnumerateDatabaseCollations of ghoDbUpdateFunctionLibrary sDriverID to asCollations
98557>>>>>                Set psSavedFormValues to asCollations
98558>>>>>                    
98558>>>>>                If (sDriverID = MSSQLDRV_ID) Begin
98560>>>>>                    Get psCollation of ghoDbUpdateFunctionLibrary to sCollation
98561>>>>>                    Set Value to sCollation
98562>>>>>                End
98562>>>>>>
98562>>>>>                Send Cursor_Ready of Cursor_Control
98563>>>>>                Function_Return asCollations
98564>>>>>            End_Function
98565>>>>>    
98565>>>>>            Procedure OnChange
98568>>>>>                String sValue
98568>>>>>                Get Value to sValue
98569>>>>>                Set psCollation to sValue
98570>>>>>            End_Procedure
98571>>>>>         
98571>>>>>            Procedure WriteWorkspaceIniFile
98574>>>>>            End_Procedure             
98575>>>>>            
98575>>>>>//            Procedure Prompt      
98575>>>>>//                If (ghoSuggestionTimer=0) Begin
98575>>>>>//                    Send CreateSuggestionTimer
98575>>>>>//                End
98575>>>>>//                Send ActivateSuggestionList
98575>>>>>//                Send FindSuggestions
98575>>>>>//                Set Visible_State of ghoSuggestionList to True
98575>>>>>//            End_Procedure 
98575>>>>>            
98575>>>>>            Procedure OnEnterObject
98578>>>>>                Set pbUseWorkspaceIniFile to True
98579>>>>>                Forward Send OnEnterObject
98581>>>>>            End_Procedure
98582>>>>>
98582>>>>>            Procedure OnExitObject
98585>>>>>                Set pbUseWorkspaceIniFile to False
98586>>>>>                Forward Send OnExitObject
98588>>>>>            End_Procedure
98589>>>>>        
98589>>>>>            On_Key kCancel Send KeyAction of oCancel_Btn   
98590>>>>>//            On_Key kPrompt Send Prompt
98590>>>>>        End_Object   
98591>>>>>        
98591>>>>>        Object oDatabaseName_fm is a cRDCForm
98593>>>>>            Set Size to 13 216
98594>>>>>            Set Location to 81 63
98595>>>>>            Set Label_Col_Offset to 2
98596>>>>>            Set Label_Justification_Mode to JMode_Right
98597>>>>>            Set Label to "Database Name"
98598>>>>>            Set psToolTip to "Specify the name of the database to be created."
98599>>>>>        End_Object
98600>>>>>    
98600>>>>>    End_Object
98601>>>>>
98601>>>>>    Object oOK_Btn is a Button
98603>>>>>        Set Label    to "&OK"
98604>>>>>        Set Location to 130 198
98605>>>>>        Set peAnchors to anBottomRight   
98606>>>>>        
98606>>>>>        Property String psWorkingText "Working..."
98608>>>>>        Property String psIdleText    ""
98610>>>>>
98610>>>>>        Procedure OnClick
98613>>>>>            String sDatabase sDriverID sCollation
98613>>>>>            Boolean bOK bExists
98613>>>>>        
98613>>>>>            Get Value of oDatabaseName_fm to sDatabase    
98614>>>>>            Get psDriverID to sDriverID
98615>>>>>            Set psDatabaseName to ""
98616>>>>>
98616>>>>>            If (sDatabase <> "" and sDriverID <> "") Begin    
98618>>>>>                Set Value of oInfo_tb to (psWorkingText(Self))
98619>>>>>                If (sDriverID <> DATAFLEX_ID) Begin
98621>>>>>                    Get psCollation to sCollation
98622>>>>>                    Set psCollation of ghoDbUpdateFunctionLibrary to sCollation
98623>>>>>                End
98623>>>>>>
98623>>>>>
98623>>>>>                Get SqlUtilCheckIfDatabaseExists of ghoDbUpdateFunctionLibrary sDatabase to bExists
98624>>>>>                If (bExists = True) Begin
98626>>>>>                    Set Value of oInfo_tb to ""
98627>>>>>                    Send Info_Box "The database already exists. No changes made."
98628>>>>>                    Procedure_Return
98629>>>>>                End
98629>>>>>>
98629>>>>>                Send Cursor_Wait of Cursor_Control     
98630>>>>>                Get SqlDatabaseCreate of ghoDbUpdateFunctionLibrary sDriverID sDatabase False False to bOK
98631>>>>>                Send Cursor_Ready of Cursor_Control
98632>>>>>                Set Value of oInfo_tb to (psIdleText(Self))
98633>>>>>                If (bOK = False) Begin
98635>>>>>                    Send Info_Box ("Something went wrong and the database could NOT be created. Please check your database manager.")
98636>>>>>                    Procedure_Return
98637>>>>>                End 
98637>>>>>>
98637>>>>>                Set psDatabaseName to sDatabase
98638>>>>>                Send Close_Panel
98639>>>>>            End                                 
98639>>>>>>
98639>>>>>            Else If (sDatabase = "") Begin
98642>>>>>                Send Info_Box ("Please enter a database name and try again.")
98643>>>>>            End
98643>>>>>>
98643>>>>>        End_Procedure
98644>>>>>
98644>>>>>    End_Object
98645>>>>>
98645>>>>>    Object oCancel_Btn is a Button
98647>>>>>        Set Label    to "&Cancel"
98648>>>>>        Set Location to 130 253
98649>>>>>        Set peAnchors to anBottomRight
98650>>>>>
98650>>>>>        Procedure OnClick
98653>>>>>            Send Close_Panel
98654>>>>>        End_Procedure
98655>>>>>
98655>>>>>    End_Object
98656>>>>>
98656>>>>>    Object oHelp_btn is a Button
98658>>>>>        Set Location to 130 75
98659>>>>>        Set Label to "Help"
98660>>>>>        Set psImage to "ActionHelpInternet1.ico"
98661>>>>>        Set psToolTip to "Show a Full List of Collations Supported in SQL Server 2017"
98662>>>>>        Set peAnchors to anBottomLeft
98663>>>>>    
98663>>>>>        Procedure OnClick
98666>>>>>            Runprogram Shell Background "https://database.guide/full-list-of-collations-supported-in-sql-server-2017/"
98667>>>>>        End_Procedure
98668>>>>>    
98668>>>>>    End_Object
98669>>>>>    
98669>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
98670>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
98671>>>>>    On_Key kCancel       Send KeyAction of oCancel_Btn
98672>>>>>End_Object
98673>>>>>
98673>>>>>Function Create_DataBase_Dialog String sDriverID Returns String
98676>>>>>    String sDatabaseName         
98676>>>>>    Handle ho
98676>>>>>    
98676>>>>>    Move (oCreateDatabase_dg(Self)) to ho
98677>>>>>    Set psDriverID of ho to sDriverID
98678>>>>>    Set Value of (oDriver_fm(ho)) to sDriverID
98679>>>>>    Set Value of (oDatabaseName_fm(ho)) to ""
98680>>>>>    Send InitializeCollation of (oServerCurrentCollating_fm(ho))
98681>>>>>    Send Popup of ho
98682>>>>>    
98682>>>>>    Get psDatabaseName of ho to sDatabaseName
98683>>>>>    Function_Return sDatabaseName
98684>>>>>End_Function                         
98685>>>
98685>>>Define CS_LoadingServers        for "Enumerating servers..."
98685>>>Define CS_LoadingDatabases      for "Enumerating databases..."
98685>>>Define CS_LoadingTableSpaces    for "Enumerating table spaces..."
98685>>>Define CS_LoadingSchemas        for "Enumerating schemas..."
98685>>>Define CS_LoginAttempt          for "Connecting..."
98685>>>Define CS_LoginSuccessful       for "Login successful!"
98685>>>Define CS_LoginFailed           for "Login failed!"
98685>>>Define CS_DF_File_Schema        for "Schema"
98685>>>Define CS_DF_File_Owner         for "Owner"
98685>>>
98685>>>Object oSQLMaintainConnections_dg is a ModalPanel
98687>>>    Set Label to "Edit SQL Connection"
98688>>>    Set Size to 315 324 //309 324
98689>>>    Set Location to 4 6
98690>>>    Set piMaxSize to (Hi(Size(Self))) (Low(Size(Self)) + 300)
98691>>>    Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
98692>>>    Set Locate_Mode to CENTER_ON_PARENT
98693>>>    Set Border_Style to Border_Thick
98694>>>    
98694>>>    Property Boolean pbReadOnly  False
98696>>>    Property Boolean pbNew       False // First time for a workspace, which means the .ini-file is empty.
98698>>>    Property Integer piCurrentRow -1   // The current row of the grid that was passed to this dialog.
98700>>>    Property Boolean pbChanged   False // If any change was made to the data.
98702>>>    Property Handle phoDialogCommandbar
98704>>>    Property tSQLConnection pSQLConnectionData
98706>>>    Property tDataSourceRow[] pTheData
98708>>>    Property Boolean pbDFConnId  False // Is set to True if this is a DAW "DFConnId.ini" file; in which case we warn to not encrypt/decrypt password. (different algorithms and don't touch password)
98710>>>    Property String psUncryptedPw      // Used if  pbDFConnId = True to temporary save the un-encrypted password.
98712>>>
98712>>>    Object oSettings_grp is a cRDCHeaderGroup
98714>>>        Set Size to 202 303
98715>>>        Set Location to 77 11 //71 11
98716>>>        Set psImage to "Settings1.ico"
98717>>>        Set psLabel to "SQL Connection Settings"
98718>>>        Set peAnchors to anTopLeftRight
98719>>>        Set psToolTip to "Setup the SQL connection."
98720>>>
98720>>>        Object oConnectionID_fm is a cSQLForm
98722>>>            Set Size to 13 115
98723>>>            Set Location to 22 82
98724>>>            Set Label to "Connection ID"
98725>>>            Set psToolTip to "The DFConnectionID keyword to set a default connection id for the driver. This is the connection ID that appear in database table .int files with the format; 'SERVER_NAME DFCONNID=MyConnID'"
98726>>>            Set piItem to 2
98727>>>            Set peAnchors to anTopLeftRight
98728>>>        End_Object
98729>>>
98729>>>        Object oEnabled_cb is a cSQLCheckBox
98731>>>            Set Size to 10 36
98732>>>            Set Location to 25 210
98733>>>            Set Label to "Enabled"
98734>>>            Set psToolTip to "Check to indicate that this is the enabled connection. Note: There can only be one enabled connection at a time."
98735>>>            Set piItem to 1
98736>>>            Set peAnchors to anTopRight
98737>>>
98737>>>            Procedure OnChange
98740>>>                Boolean bChecked bNew
98740>>>                tSQLConnection SQLConnection
98740>>>                tSQLConnection SQLConnection
98740>>>
98740>>>                Get pbNew to bNew
98741>>>                Get Checked_State to bChecked
98742>>>                If (bNew = False and bChecked = True) Begin
98744>>>                    Get pSQLConnectionData to SQLConnection
98745>>>                    Move True to SQLConnection.bEnabled
98746>>>                End
98746>>>>
98746>>>
98746>>>            End_Procedure
98747>>>
98747>>>        End_Object
98748>>>
98748>>>        Object oODBC_rgp is a RadioGroup
98750>>>            Set Location to 38 24
98751>>>            Set Size to 32 173
98752>>>//            Set psToolTip to "Only available if the ODBC_DRV has been selected. Depending on the radio button that is selected the 'Server/DSN' selection list shows different values."
98752>>>            Set peAnchors to anTopLeftRight
98753>>>            Set Label to "ODBC Source Type"
98754>>>
98754>>>            Object oRadio0 is a Radio
98756>>>                Set Label to "User data"
98757>>>                Set Size to 10 44
98758>>>                Set Location to 12 5
98759>>>            End_Object
98760>>>
98760>>>            Object oRadio1 is a Radio
98762>>>                Set Label to "System data"
98763>>>                Set Size to 10 52
98764>>>                Set Location to 12 52
98765>>>            End_Object
98766>>>
98766>>>            Object oRadio2 is a Radio
98768>>>                Set Label to "Both"
98769>>>                Set Size to 10 26
98770>>>                Set Location to 13 109
98771>>>            End_Object
98772>>>
98772>>>            Object oRadio3 is a Radio
98774>>>                Set Label to "File"
98775>>>                Set Size to 10 25
98776>>>                Set Location to 13 141
98777>>>            End_Object
98778>>>
98778>>>            Procedure Notify_Select_State Integer iToItem Integer iFromItem
98781>>>                Forward Send Notify_Select_State iToItem iFromItem 
98783>>>                If (oFileDSN_btn(Self) <> 0) Begin
98785>>>                    Set Enabled_State of oFileDSN_btn to (iToItem = 3)
98786>>>                End
98786>>>>
98786>>>            End_Procedure
98787>>>
98787>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
98790>>>                Set Enabled_State to (sDriverID = ODBC_DRV_ID)
98791>>>                Set Enabled_State of oODBC_rgp to (sDriverID = ODBC_DRV_ID)
98792>>>            End_Procedure
98793>>>
98793>>>            Set Current_Radio to 2
98794>>>        End_Object
98795>>>
98795>>>        Object oFileDSN_btn is a cRDCButton
98797>>>            Set Size to 13 78
98798>>>            Set Location to 42 210
98799>>>            Set Label to "Select File DSN..."
98800>>>            Set pbAutoEnable to True
98801>>>            Set peAnchors to anTopRight
98802>>>
98802>>>            Procedure OnClick
98805>>>                String sFileName
98805>>>                Get vSelect_File ("Data Sources (*.dsn)|*.dsn|All Files (*.*)|*.*") "Select a file data source" "" to sFileName
98806>>>                If (sFileName <> "") Begin
98808>>>                    Set Value of oServer_fm to sFileName
98809>>>                End
98809>>>>
98809>>>            End_Procedure     
98810>>>            
98810>>>            Function IsEnabled Returns Boolean
98813>>>                String sDriverID
98813>>>                Integer iRadio
98813>>>                Get Value of oDriverID_cf to sDriverID
98814>>>                Get Current_Radio of oODBC_rgp to iRadio
98815>>>                Function_Return (sDriverID = ODBC_DRV_ID and iRadio = 3)
98816>>>            End_Function
98817>>>
98817>>>        End_Object
98818>>>
98818>>>        Object oODBCAdmin_btn is a cRDCButton
98820>>>            Set Size to 13 78
98821>>>            Set Location to 57 210
98822>>>            Set Label to "ODBC Admin" 
98823>>>            Set psImage to "ODBCAD32.ico"
98824>>>            Set pbAutoEnable to True
98825>>>            Set peAnchors to anTopRight
98826>>>            
98826>>>            Procedure OnClick
98829>>>                Handle hWnd
98829>>>                Get Window_Handle to hWnd
98830>>>                If (hWnd <> 0) Begin
98832>>>                    Call_Driver 0 ODBC_DRV_ID Function ODBC_MANAGE_DATA_SOURCES Callback 0 Passing CLI$StrDummy CLI$StrDummy !1 Result CLI$IntDummy
98837>>>                End
98837>>>>
98837>>>                Else Begin
98838>>>                    Send Stop_Box "Could not get a Windows handle.."
98839>>>                End
98839>>>>
98839>>>            End_Procedure
98840>>>
98840>>>            Function IsEnabled Returns Boolean
98843>>>                String sDriverID
98843>>>                Get Value of oDriverID_cf to sDriverID
98844>>>                Function_Return (sDriverID = ODBC_DRV_ID)
98845>>>            End_Function
98846>>>
98846>>>        End_Object
98847>>>
98847>>>        Object oServer_fm is a cSQLForm
98849>>>            Set Size to 13 114
98850>>>            Set Location to 74 82
98851>>>            Set Label to "Server"
98852>>>            Set psToolTip to "Server/DSN: Depending on the selected database type the label can either display as 'Server' or 'DSN'. Either enter the name - if you know it - or by using the selection list (F4). Tip: If you are using Microsoft SQL Server and you are testing on the same machine as the MS SQL Server instance is running and you are using SQLEXPRESS you can enter e.g. '.\SQLEXPRESS'. That will mean use the SQLEXPRESS instance of Microsoft SQL Server running on this machine. If you press [F4] and the selection list comes up empty for Microsoft SQL Server it probably is because the service hasn't been started. Type 'Services' in Windows menu system to start Windows Services app. Type 'SQL' to jump to the SQL Server services. Check that the 'SQL Server Browser' service is started and set to 'Automatic'."
98853>>>            Set piItem to 5
98854>>>            Set peAnchors to anTopLeftRight
98855>>>
98855>>>            Property Handle phoPromptObject (oServerSelection_sl(Self))
98857>>>
98857>>>            Procedure Prompt
98860>>>                String sDriverID sValue
98860>>>                String[] sTheData
98861>>>                Integer iDbType iODBCType iRadio iPos
98861>>>                Handle ho
98861>>>
98861>>>                Get Prompt_Object to ho
98862>>>                If (ho = 0) Begin
98864>>>                    Procedure_Return
98865>>>                End
98865>>>>
98865>>>
98865>>>                Set Label of oShowInfo_tb to CS_LoadingServers
98866>>>                Send Cursor_Wait of Cursor_Control
98867>>>                Get SelectedDbType of oDbType_cf to iDbType
98868>>>                Get Value of oDriverID_cf to sDriverID
98869>>>                Move (Trim(sDriverID)) to sDriverID
98870>>>                Get Current_Radio of oODBC_rgp to iRadio
98871>>>                If (iRadio = 0) Begin
98873>>>                    Move SQL_FETCH_USER   to iODBCType
98874>>>                End
98874>>>>
98874>>>                If (iRadio = 1) Begin
98876>>>                    Move SQL_FETCH_SYSTEM to iODBCType
98877>>>                End
98877>>>>
98877>>>                If (iRadio = 2) Begin
98879>>>                    Move SQL_FETCH_ALL    to iODBCType
98880>>>                End
98880>>>>
98880>>>
98880>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
98881>>>                Load_Driver sDriverID
98882>>>                Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
98883>>>                If (LastErr = DFERR_CANT_LOAD_DLL) Begin
98885>>>                    Send Cursor_Ready of Cursor_Control
98886>>>                    Send Info_Box ("Can't display any items because the database driver could not be loaded. (" + sDriverID + ")")
98887>>>                    Procedure_Return
98888>>>                End
98888>>>>
98888>>>
98888>>>                Get SqlUtilEnumerateServers of ghoDbUpdateFunctionLibrary sDriverID iODBCType to sTheData
98889>>>                Set psTheData  of ho to sTheData
98890>>>                Set Label of oShowInfo_tb to ""
98891>>>
98891>>>                Forward Send Prompt
98893>>>
98893>>>                // The selection list will show the ODBC DataSource name + a comma (,) + a description.
98893>>>                // We need to remove those parts from the comma and to the end of string.
98893>>>                If (sDriverID = ODBC_DRV_ID) Begin
98895>>>                    Get Value to sValue
98896>>>                    Move (Pos(",", sValue)) to iPos
98897>>>                    Move (Left(sValue, (iPos - 1))) to sValue
98898>>>                    Set Value to sValue
98899>>>                End
98899>>>>
98899>>>            End_Procedure
98900>>>
98900>>>            Procedure OnChange
98903>>>                tSQLIntTableInfo[] sReturnStructArray
98903>>>                tSQLIntTableInfo[] sReturnStructArray
98904>>>                String sServer sDatabaseName sVal sDriverID
98904>>>                Integer iSize iCount iPos 
98904>>>                Boolean bFileDSN
98904>>>                
98904>>>                Move False to bFileDSN
98905>>>                Get Value of oDriverID_cf to sDriverID
98906>>>                If (sDriverID = "") Begin
98908>>>                    Procedure_Return
98909>>>                End
98909>>>>
98909>>>                If (sDriverID = ODBC_DRV_ID) Begin
98911>>>                    Move "" to sDatabaseName
98912>>>                    Get Value to sServer 
98913>>>                    Move (Pos(",", sServer)) to iPos
98914>>>                    If (iPos <> 0) Begin
98916>>>                        Move (Left(sServer, (iPos -1))) to sServer
98917>>>                    End
98917>>>>
98917>>>                    If (sServer <> "") Begin
98919>>>                        Set psServer of ghoDbUpdateFunctionLibrary to sServer
98920>>>                    End
98920>>>>
98920>>>                    Get _SqlDatabasesArrayODBC of ghoDbUpdateFunctionLibrary to sReturnStructArray
98921>>>                    If (SizeOfArray(sReturnStructArray)) Begin
98923>>>                        If (SizeOfArray(sReturnStructArray) = 1 and sReturnStructArray[0].sServerName = "") Begin
98925>>>                            // If a FILEDSN: (can only be one database name)
98925>>>                            Move sReturnStructArray[0].sDatabaseName to sDatabaseName
98926>>>                            Move True to bFileDSN
98927>>>                        End
98927>>>>
98927>>>                        Else Begin
98928>>>                            // Else the DSN's were read from the registry.
98928>>>                            Move (SizeOfArray(sReturnStructArray)) to iSize
98929>>>                            Decrement iSize
98930>>>                            For iCount from 0 to iSize
98936>>>>
98936>>>                                Move (sReturnStructArray[iCount].sServerName) to sVal
98937>>>                                If (Uppercase(sServer) = Uppercase(sVal)) Begin
98939>>>                                    Move sReturnStructArray[iCount].sDatabaseName to sDatabaseName
98940>>>                                    Move iSize to iCount // We're done.
98941>>>                                End
98941>>>>
98941>>>                            Loop
98942>>>>
98942>>>                        End
98942>>>>
98942>>>                    End
98942>>>>
98942>>>                    Set Value of oDatabase_fm to sDatabaseName
98943>>>                    If (bFileDSN = True) Begin
98945>>>                        Set Current_Radio of oODBC_rgp to 3
98946>>>                    End    
98946>>>>
98946>>>                    Else Begin
98947>>>                        Set Current_Radio of oODBC_rgp to 2
98948>>>                    End
98948>>>>
98948>>>                End
98948>>>>
98948>>>            End_Procedure
98949>>>
98949>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
98952>>>                String sLabel
98952>>>                Handle ho
98952>>>
98952>>>                Get phoPromptObject to ho
98953>>>                Set Prompt_Button_Mode to PB_PromptOn
98954>>>                Case Begin
98954>>>                    Case (iDbType = EN_dbTypeDB2)
98956>>>                        Move "DSN" to sLabel
98957>>>                        Case Break
98958>>>                    Case (iDbType = EN_dbTypeMSSQL)
98961>>>                        If (sDriverID = ODBC_DRV_ID) Begin
98963>>>                            Move "ODBC Data Source" to sLabel
98964>>>                        End
98964>>>>
98964>>>                        Else Begin
98965>>>                            Move "Server" to sLabel
98966>>>                        End
98966>>>>
98966>>>                        Case Break
98967>>>                    Case (iDbType = EN_dbTypeMySQL)
98970>>>                        If (sDriverID = ODBC_DRV_ID) Begin
98972>>>                            Move "ODBC Data Source" to sLabel
98973>>>                        End
98973>>>>
98973>>>                        Else Begin
98974>>>                            Move "DSN" to sLabel
98975>>>                        End
98975>>>>
98975>>>                        Case Break
98976>>>                    Case (iDbType = EN_dbTypeOracle)
98979>>>                        If (sDriverID = ODBC_DRV_ID) Begin
98981>>>                            Move "ODBC Data Source" to sLabel
98982>>>                        End
98982>>>>
98982>>>                        Else Begin
98983>>>                            Move "Server" to sLabel
98984>>>                        End
98984>>>>
98984>>>                        Case Break
98985>>>                    Case (iDbType = EN_dbTypePostgre)
98988>>>                        If (sDriverID = ODBC_DRV_ID) Begin
98990>>>                            Move "ODBC Data Source" to sLabel
98991>>>                        End
98991>>>>
98991>>>                        Else Begin
98992>>>                            Move "Server" to sLabel
98993>>>                        End
98993>>>>
98993>>>                        Case Break
98994>>>                    Case Else
98994>>>                Case End
98994>>>
98994>>>                Set Prompt_Object to ho
98995>>>                Set Label to sLabel
98996>>>            End_Procedure
98997>>>
98997>>>        End_Object
98998>>>
98998>>>        Object oSilentLogin_fm is a cSQLCheckBox
99000>>>            Set Size to 10 48
99001>>>            Set Location to 76 210
99002>>>            Set Label to "Silent Login"
99003>>>            Set psToolTip to "Silent login to database is to not show error if login was unsuccessive."
99004>>>            Set peAnchors to anTopRight
99005>>>            Set piItem to 15
99006>>>        End_Object
99007>>>
99007>>>        Object oTrusted_cb is a cSQLCheckbox
99009>>>            Set Size to 12 85
99010>>>            Set Location to 92 82
99011>>>            Set Label to "Use Trusted Connection"
99012>>>            Set psToolTip to "(Windows Authentication) When selected, SQL Server uses integrated login (Windows login information) security to establish connections using this data source, regardless of the current login security mode at the server."
99013>>>            Set piItem to 8
99014>>>
99014>>>            Procedure OnChange
99017>>>                Boolean bChecked
99017>>>                Get Checked_State to bChecked
99018>>>                Set Enabled_State of oUserID_fm   to (bChecked = False)
99019>>>                Set Enabled_State of oPassword_fm to (bChecked = False)
99020>>>                Set Enabled_State of oViewPassword_btn to (bChecked = False)
99021>>>            End_Procedure
99022>>>
99022>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
99025>>>                Boolean bChecked
99025>>>
99025>>>                Get Checked_State to bChecked
99026>>>                If (iDbType <> EN_dbTypeMSSQL) Begin
99028>>>                    Set Enabled_State to (iDbType = EN_dbTypeMSSQL)
99029>>>                    If (bChecked = True) Begin
99031>>>                        Set Checked_State to False
99032>>>                    End
99032>>>>
99032>>>                End
99032>>>>
99032>>>                Else Begin
99033>>>                    Set Enabled_State to True
99034>>>                End
99034>>>>
99034>>>
99034>>>                Send OnChange
99035>>>            End_Procedure
99036>>>
99036>>>        End_Object
99037>>>
99037>>>        Object oConnOptions_fm is a cSQLForm
99039>>>            Set Size to 13 61
99040>>>            Set Location to 92 219
99041>>>            Set Label to "Options"
99042>>>            Set piItem to 10
99043>>>            Set Password_State to True
99044>>>            Set peAnchors to anTopRight
99045>>>            Set Label_Col_Offset to 0
99046>>>            Set Status_Help to "This text string value is added to the SQL connection string if needed. This is an addition to MS-SQL ODBC client software version 18 and up."
99047>>>
99047>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
99050>>>                Set Enabled_State to (sDriverID = MSSQLDRV_ID)
99051>>>            End_Procedure
99052>>>
99052>>>        End_Object
99053>>>
99053>>>        Object oUserID_fm is a cSQLForm
99055>>>            Set Size to 13 114
99056>>>            Set Location to 107 82
99057>>>            Set Label to "User ID"
99058>>>            Set psToolTip to "Enter the user name to use for authentication when you log on to the database."
99059>>>            Set piItem to 9
99060>>>            Set peAnchors to anTopLeftRight
99061>>>        End_Object
99062>>>
99062>>>        Object oPassword_fm is a cSQLForm
99064>>>            Set Size to 13 61
99065>>>            Set Location to 107 219
99066>>>            Set Label to "Pw"
99067>>>            Set psToolTip to "Enter the password for your user name. The password will automatically be encrypted & decrypted when writing/reading from the ini file. Of Special Note: If the cConnection class is used with DataFlex 19 or later and such an .ini file is edited with this program you will get a question if you would like the program to 'touch' the password or not. If you answer No, the ini-file will keep working with the DataFlex tools. You should probably never try to change the password with this program for a DFConnid.ini file as the two programs uses different encryption/decryption algorithms."
99068>>>            Set piItem to 10
99069>>>            Set Password_State to True
99070>>>            Set peAnchors to anTopRight
99071>>>            Set Label_Col_Offset to 0
99072>>>        End_Object
99073>>>
99073>>>        Object oShowInfo_tb is a TextBox
99075>>>            Set Auto_Size_State to False
99076>>>            Set Size to 10 112
99077>>>            Set Location to 122 82
99078>>>            Set TextColor to clGreen
99079>>>            Set Justification_Mode to JMode_Center
99080>>>            Set peAnchors to anTopRight
99081>>>        End_Object
99082>>>
99082>>>        Object oViewPassword_btn is a cRDCButton
99084>>>            Set Size to 13 15
99085>>>            Set Location to 107 283
99086>>>            Set psToolTip to "View/hide password"
99087>>>            Set psImage to "ViewPassword1.ico"
99088>>>            Set piImageMarginLeft to 2
99089>>>            Set peAnchors to anTopRight
99090>>>
99090>>>            Procedure OnClick
99093>>>                Handle ho
99093>>>                Boolean bState
99093>>>
99093>>>                Move (oPassword_fm(Self)) to ho
99094>>>                Get Password_State of ho 0 to bState
99095>>>                Send Deactivate of ho
99096>>>                Set Password_State of ho to (not(bState))
99097>>>                // Finally we need to re-add the object to the focus tree or it will be invisible.
99097>>>                Send Activate of ho (Parent(Self))
99098>>>            End_Procedure
99099>>>
99099>>>        End_Object
99100>>>
99100>>>        Object oCheckLogin_btn is a cRDCButton
99102>>>            Set Size to 13 78
99103>>>            Set Location to 123 210
99104>>>            Set Label to "Check &Login"
99105>>>            Set psImage to "ActionLogin1.ico"
99106>>>            Set psToolTip to "You should always use this button when adding a new SQL Connection to ensure that the entered credentials are correct. (Ctrl+L)"
99107>>>            Set piImageMarginLeft to 3
99108>>>            Set peAnchors to anTopRight
99109>>>
99109>>>            Procedure OnClick
99112>>>                String sConnectionString sDriverID sError
99112>>>                Boolean bLoginSuccessful 
99112>>>                Integer iDriverID
99112>>>                Handle hoErrorObj
99112>>>
99112>>>                Send Cursor_Wait of Cursor_Control // Note: The Cursor_Wait changes the Err flag!
99113>>>                Move Error_Object_Id to hoErrorObj
99114>>>                Move Self to Error_Object_Id
99115>>>                Move False to Err
99116>>>
99116>>>                Set Value of oLoginInfo_tb to CS_LoginAttempt
99117>>>                Send PumpMsgQueue
99118>>>                
99118>>>                Get Value of oDriverID_cf to sDriverID
99119>>>                Move "" to sError
99120>>>                Get LoginString (&sError) to sConnectionString
99121>>>                If (sError <> "") Begin
99123>>>                    Set Value of oLoginInfo_tb to CS_LoginFailed
99124>>>                    Send Info_Box sError
99125>>>                    Procedure_Return
99126>>>                End
99126>>>>
99126>>>                
99126>>>                Get DriverIndex of ghoSQLConnectionHandler sDriverID to iDriverID
99127>>>                If (iDriverID = 0) Begin
99129>>>                    Set TextColor of oLoginInfo_tb to clRed
99130>>>                    Set Value of oLoginInfo_tb to CS_LoginFailed
99131>>>                    Send Info_Box ("The driver" * sDriverID * "could not be loaded. Is the driver installed? And equally imporant; Is the corresponding database server or client software installed?")
99132>>>                    Procedure_Return
99133>>>                End
99133>>>>
99133>>>
99133>>>                Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriverID to True
99136>>>
99136>>>                Move False to Err
99137>>>                Send CreateConnParamsFromConnectionString of ghoSQLConnectionHandler sDriverID sConnectionString
99138>>>
99138>>>                Move (Err = False) to bLoginSuccessful
99139>>>                If bLoginSuccessful Begin
99141>>>                    Set TextColor of oLoginInfo_tb to clGreen
99142>>>                    Set Value of oLoginInfo_tb to CS_LoginSuccessful 
99143>>>                    Set psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
99144>>>                    Set psConnectionString of ghoDbUpdateFunctionLibrary to sConnectionString
99145>>>                End
99145>>>>
99145>>>                Else Begin
99146>>>                    Set TextColor of oLoginInfo_tb to clRed
99147>>>                    Set Value of oLoginInfo_tb to CS_LoginFailed
99148>>>                End
99148>>>>
99148>>>
99148>>>                Move hoErrorObj to Error_Object_Id
99149>>>                Send Cursor_Ready of Cursor_Control
99150>>>            End_Procedure
99151>>>
99151>>>            // This method is here simply to intercept any error that may occur while logging in
99151>>>            // it does not have to do anything with the error, but it suppresses the normal error display
99151>>>            Procedure Error_Report Integer iErrNum Integer iErrLine String sErrMsg
99154>>>                If (LastErr = 25000) Begin
99156>>>                    If (Trim(sErrMsg) <> "") Begin
99158>>>                        Send Info_Box sErrMsg
99159>>>                    End
99159>>>>
99159>>>                End  
99159>>>>
99159>>>            End_Procedure   
99160>>>            
99160>>>        End_Object
99161>>>
99161>>>        Object oIndexTableSpace_fm is a cSQLForm
99163>>>            Set Size to 13 114
99164>>>            Set Location to 133 82
99165>>>            Set Label to "Index Table Space"
99166>>>            Set piItem to 14
99167>>>            Set psToolTip to "To set the name of the table space where indexes will be stored. Only applicable for IBM DB2, Oracle and PostgreSQL databases."
99168>>>            Set Prompt_Button_Mode to PB_PromptOn
99169>>>            Set Prompt_Object to (oTableSpaceSelection_sl(Self))
99170>>>            Set peAnchors to anTopLeftRight
99171>>>
99171>>>            Procedure Prompt
99174>>>                String[] sTheData
99175>>>                Handle ho
99175>>>                tSQLConnection SQLConnection
99175>>>                tSQLConnection SQLConnection
99175>>>
99175>>>                Set Label of oShowInfo_tb to CS_LoadingTableSpaces
99176>>>                Get ReadCurrentSQLSettings to SQLConnection
99177>>>
99177>>>                Get _SqlUtilEnumerateTablespaces of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType SQLConnection.sConnectionString to sTheData
99178>>>
99178>>>                Get Prompt_Object to ho
99179>>>                Set psTheData     of ho to sTheData
99180>>>                Set Label of oShowInfo_tb to ""
99181>>>
99181>>>                Forward Send Prompt
99183>>>            End_Procedure
99184>>>
99184>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
99187>>>                Set Enabled_State to ((iDbType = EN_dbTypeDB2 or iDbType = EN_dbTypeOracle or iDbType = EN_dbTypePostgre) and sDriverID <> ODBC_DRV_ID)
99188>>>            End_Procedure
99189>>>
99189>>>        End_Object
99190>>>
99190>>>        Object oLoginInfo_tb is a TextBox
99192>>>            Set Auto_Size_State to False
99193>>>            Set Size to 9 78
99194>>>            Set Location to 140 210
99195>>>            Set TextColor to clGreen
99196>>>            Set peAnchors to anTopRight
99197>>>            Set Justification_Mode to JMode_Left
99198>>>        End_Object
99199>>>
99199>>>        Object oBaseTableSpace_fm is a cSQLForm
99201>>>            Set Size to 13 114
99202>>>            Set Location to 148 82
99203>>>            Set Label to "Table Space"
99204>>>            Set piItem to 12
99205>>>            Set psToolTip to "Sets the name of the table space where the data will be stored. Applicable for IBM DB2, Oracle and PostgreSQL databases. Table spaces allow you to assign a physical location to logical objects (tables). They can be used to improve performance or to increase the page size, thus increasing the maximum size of a record that can be stored in the table space. You can specify what table space must be used to store table, index or long data. The index and long data table space will only be set when the table tables pace is also set."
99206>>>            Set Prompt_Button_Mode to PB_PromptOn
99207>>>            Set Prompt_Object to (oTableSpaceSelection_sl(Self))
99208>>>            Set peAnchors to anTopLeftRight
99209>>>
99209>>>            Procedure Prompt
99212>>>                String[] sTheData
99213>>>                Handle ho
99213>>>                tSQLConnection SQLConnection
99213>>>                tSQLConnection SQLConnection
99213>>>
99213>>>                Set Label of oShowInfo_tb to CS_LoadingTableSpaces
99214>>>                Get ReadCurrentSQLSettings to SQLConnection
99215>>>                Get _SqlUtilEnumerateTablespaces of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType SQLConnection.sConnectionString to sTheData
99216>>>
99216>>>                Get Prompt_Object to ho
99217>>>                Set psTheData  of ho to sTheData
99218>>>                Set Label of oShowInfo_tb to ""
99219>>>
99219>>>                Forward Send Prompt
99221>>>            End_Procedure
99222>>>
99222>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
99225>>>                Set Enabled_State to ((iDbType = EN_dbTypeDB2 or iDbType = EN_dbTypeOracle or iDbType = EN_dbTypePostgre) and sDriverID <> ODBC_DRV_ID)
99226>>>            End_Procedure
99227>>>
99227>>>        End_Object
99228>>>
99228>>>        Object oLongTableSpace_fm is a cSQLForm
99230>>>            Set Size to 13 114
99231>>>            Set Location to 163 82
99232>>>            Set Label to "Long Table Space"
99233>>>            Set piItem to 13
99234>>>            Set psToolTip to "Only applicable for IBM DB2 databases. If you are unsure on what to enter your best bet is to use the same value as for the 'Table Space' above."
99235>>>            Set Prompt_Button_Mode to PB_PromptOn
99236>>>            Set Prompt_Object to (oTableSpaceSelection_sl(Self))
99237>>>            Set peAnchors to anTopLeftRight
99238>>>
99238>>>            Procedure Prompt
99241>>>                String[] sTheData
99242>>>                Handle ho
99242>>>                tSQLConnection SQLConnection
99242>>>                tSQLConnection SQLConnection
99242>>>
99242>>>                Set Label of oShowInfo_tb to CS_LoadingTableSpaces
99243>>>                Get ReadCurrentSQLSettings to SQLConnection
99244>>>
99244>>>                Get _SqlUtilEnumerateTablespaces of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType SQLConnection.sConnectionString to sTheData
99245>>>
99245>>>                Get Prompt_Object to ho
99246>>>                Set psTheData     of ho to sTheData
99247>>>                Set Label of oShowInfo_tb to ""
99248>>>
99248>>>                Forward Send Prompt
99250>>>            End_Procedure
99251>>>
99251>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
99254>>>                Set Enabled_State to (iDbType = EN_dbTypeDB2)
99255>>>            End_Procedure
99256>>>
99256>>>        End_Object
99257>>>
99257>>>        Object oSchema_fm is a cSQLForm
99259>>>            Set Size to 13 78
99260>>>            Set Location to 163 210
99261>>>            Set Label to "Schema"
99262>>>            Set psToolTip to "The name of the schema the table belongs to. A schema is a collection of names or objects. A schema can contain tables, views, and triggers. Schemas provide a logical classification of objects in the database. It can have a slightly different meaning depending on the selected database type. Please consult your database manager to ensure the correct value is selected. Applicable for IBM DB2, Oracle and PostgreSQL databases. For IBM DB2 not specifying a schema will result in the user name being used. Microsoft SQL Server has a completely different approach to security and privileges and uses owners instead."
99263>>>            Set piItem to 11
99264>>>            Set Enabled_State to False
99265>>>
99265>>>            Property String psSchemaToolTip "The name of the schema the table belongs to. A schema is a collection of names or objects. A schema can contain tables, views, and triggers. Schemas provide a logical classification of objects in the database. It can have a slightly different meaning depending on the selected database type. Please consult a database manager to ensure the correct value is selected. Applicable for IBM DB2, Oracle and PostgreSQL databases. For IBM DB2 not specifying a schema will result in the user name being used. Microsoft SQL Server has a completely different approach to security and privileges and uses owners instead."
99267>>>            Property String psOwnerTooltip  "The owner name to use within the database where the tables must be placed. If you want to specify an owner of the table that will be converted you can do so, not specifying an owner will result in the default owner being used. The suggested owner name to use is 'dbo'"
99269>>>
99269>>>            Set peAnchors to anTopRight
99270>>>            Set Label_Justification_Mode to JMode_Top
99271>>>            Set Label_Col_Offset to 0
99272>>>
99272>>>            Procedure Prompt
99275>>>                String[] sTheData
99276>>>                Handle ho
99276>>>                tSQLConnection SQLConnection
99276>>>                tSQLConnection SQLConnection
99276>>>
99276>>>                Set Label of oShowInfo_tb to CS_LoadingSchemas
99277>>>                Get ReadCurrentSQLSettings to SQLConnection
99278>>>
99278>>>                Get SqlUtilEnumerateSchemas of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType SQLConnection.sConnectionString to sTheData
99279>>>
99279>>>                Get Prompt_Object to ho
99280>>>                Set psTheData     of ho to sTheData
99281>>>                Set Label of oShowInfo_tb to ""
99282>>>
99282>>>                Forward Send Prompt
99284>>>            End_Procedure
99285>>>
99285>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
99288>>>                String sValue
99288>>>
99288>>>                Set Enabled_State to ((iDbType = EN_dbTypeMSSQL or iDbType = EN_dbTypeDB2 or iDbType = EN_dbTypeOracle or iDbType = EN_dbTypePostgre) and sDriverID <> ODBC_DRV_ID)
99289>>>                If (iDbType = EN_dbTypeMSSQL) Begin
99291>>>                    Set Label to CS_DF_File_Owner
99292>>>                    Set Prompt_Button_Mode to PB_PromptOff
99293>>>                    Set Prompt_Object to 0
99294>>>                    Set psToolTip to (psOwnerTooltip(Self))
99295>>>                    Get Value to sValue
99296>>>                    If (Trim(sValue) = "") Begin
99298>>>                        Set Value to "dbo"
99299>>>                    End
99299>>>>
99299>>>                End
99299>>>>
99299>>>                Else Begin
99300>>>                    Set Label to CS_DF_File_Schema
99301>>>                    Set Prompt_Button_Mode to PB_PromptOn
99302>>>                    Set Prompt_Object to (oSchemasSelection_sl(Self))
99303>>>                    Set psToolTip to (psSchemaToolTip(Self))
99304>>>                    If (Trim(sValue) = "dbo") Begin
99306>>>                        Set Value to ""
99307>>>                    End
99307>>>>
99307>>>                End
99307>>>>
99307>>>                If (Enabled_State(Self) = False) Begin
99309>>>                    Set Value to ""
99310>>>                End
99310>>>>
99310>>>            End_Procedure
99311>>>
99311>>>        End_Object
99312>>>
99312>>>        Object oDatabase_fm is a cSQLForm
99314>>>            Set Size to 13 114
99315>>>            Set Location to 177 82
99316>>>            Set Label to "Database"
99317>>>            Set peAnchors to anTopLeftRight
99318>>>            Set psToolTip to "Name of the SQL database. Note: If you are setting up your first connection for a workspace and your SQL database doesn't exist yet, leave the default 'Master' as it is always available. The 'SqlDatabaseCreate' function will take care of the rest when creating your new SQL database."
99319>>>            Set piItem to 6
99320>>>            Set Prompt_Button_Mode to PB_PromptOn
99321>>>            Set Prompt_Object to (oDatabaseSelection_sl(Self))
99322>>>
99322>>>            Property Handle phoPromptObject (oDatabaseSelection_sl(Self))
99324>>>
99324>>>            Procedure Prompt
99327>>>                String[] sTheData
99328>>>                Handle ho
99328>>>                tSQLConnection SQLConnection
99328>>>                tSQLConnection SQLConnection
99328>>>
99328>>>                Set Label of oShowInfo_tb to CS_LoadingDatabases
99329>>>                Get ReadCurrentSQLSettings to SQLConnection
99330>>>
99330>>>                Get SqlUtilEnumerateDatabases of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID to sTheData
99331>>>
99331>>>                Get Prompt_Object to ho
99332>>>                Set psTheData     of ho to sTheData
99333>>>                Set Label of oShowInfo_tb to ""
99334>>>
99334>>>                Forward Send Prompt
99336>>>            End_Procedure
99337>>>
99337>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
99340>>>                Boolean bAdd
99340>>>                String sValue
99340>>>                Handle ho
99340>>>                
99340>>>                If (sDriverID <> "") Begin
99342>>>                    Set Enabled_State to (sDriverID = MSSQLDRV_ID or (sDriverID = ODBC_DRV_ID and iDbType <> EN_DbTypeOracle))
99343>>>                    If (Enabled_State(Self) = True) Begin
99345>>>                        Move (piCurrentRow(Self) = -1) to bAdd
99346>>>                        Get Value to sValue
99347>>>                        If (bAdd = True and sValue = "" and iDbType = EN_dbTypeMSSQL) Begin
99349>>>                            Set Value to "master"
99350>>>                        End
99350>>>>
99350>>>                        Else Begin
99351>>>                            If (Value(Self) = "master") Begin
99353>>>                                Set Value to ""
99354>>>                            End
99354>>>>
99354>>>                        End
99354>>>>
99354>>>                    End
99354>>>>
99354>>>                    If (Enabled_State(Self) = False) Begin
99356>>>//                        Set Value to ""
99356>>>                    End
99356>>>>
99356>>>                End
99356>>>>
99356>>>            End_Procedure
99357>>>
99357>>>        End_Object
99358>>>
99358>>>        Object oCreateDatabase_btn is a cRDCButton
99360>>>            Set Size to 13 78
99361>>>            Set Location to 178 210
99362>>>            Set Label to "Create Database..."
99363>>>            Set psImage to "ActionCreateDatabase1.ico"
99364>>>            Set pbAutoEnable to True
99365>>>            Set peAnchors to anTopRight
99366>>>        
99366>>>            Procedure OnClick                                                              
99369>>>                String sConnectionString sError sDriverID sLoginText sDatabaseName
99369>>>                
99369>>>                Get LoginString (&sError) to sConnectionString
99370>>>                If (sError <> "") Begin
99372>>>                    Send Info_Box sError
99373>>>                    Procedure_Return
99374>>>                End                         
99374>>>>
99374>>>                
99374>>>                Get Value of oDriverID_cf to sDriverID
99375>>>                Get Create_DataBase_Dialog of (Client_Id(phoMainPanel(ghoApplication))) sDriverID to sDatabaseName
99376>>>                If (sDatabaseName <> "") Begin
99378>>>                    Set Value of oDatabase_fm to sDatabaseName
99379>>>                End
99379>>>>
99379>>>            End_Procedure                
99380>>>            
99380>>>            Function IsEnabled Returns Boolean
99383>>>                Integer iDbType    
99383>>>                Boolean bReadOnly
99383>>>                Get SelectedDbType of oDbType_cf to iDbType
99384>>>                Get pbReadOnly to bReadOnly
99385>>>                Function_Return (bReadOnly = False and (iDbType = EN_DbTypeMSSQL or iDbType = EN_DbTypeDB2 or iDbType = EN_DbTypeMySQL or iDbType = EN_DbTypePostgre))
99386>>>            End_Function
99387>>>        
99387>>>        End_Object
99388>>>
99388>>>        Procedure DbTypeUpdate Integer iDbType String sDriverID
99391>>>            String sDbType
99391>>>            Get SqlUtilDbTypeToString of ghoDbUpdateFunctionLibrary iDbType to sDbType
99392>>>            Set Label to (sDbType * "Connection Details")
99393>>>            Set Enabled_State to (iDbType <> EN_DbTypeDataFlex)
99394>>>        End_Procedure
99395>>>
99395>>>    End_Object
99396>>>
99396>>>    Object oOK_Btn is a cRDCButton
99398>>>        Set Label    to C_$OK
99399>>>        Set Location to 287 208 //281 208
99400>>>        Set peAnchors to anBottomRight
99401>>>
99401>>>        Procedure OnClick
99404>>>            String sLoginText
99404>>>            String[] sConnectionData
99405>>>            tSQLConnection SQLIniFileConnection
99405>>>            tSQLConnection SQLIniFileConnection
99405>>>            Boolean bNew bOK bShouldSave
99405>>>            Integer iRetval
99405>>>
99405>>>            Delegate Get Should_Save to bShouldSave
99407>>>            If (bShouldSave = False) Begin
99409>>>                Set pbChanged to False
99410>>>                Send Close_Panel
99411>>>                Procedure_Return
99412>>>            End
99412>>>>
99412>>>
99412>>>            Broadcast Recursive Send WriteConnectionData of (Parent(Self)) (&sConnectionData)
99414>>>
99414>>>            Get pbNew to bNew
99415>>>            Get MoveStringArrayToSQLConnection sConnectionData to SQLIniFileConnection
99416>>>            Case Begin
99416>>>                Case (SQLIniFileConnection.sDriverID = DB2_DRV_ID or SQLIniFileConnection.sDriverID = ODBC_DRV_ID)
99418>>>                    If (SQLIniFileConnection.sDriverID = DB2_DRV_ID) Begin
99420>>>                        Move "" to SQLIniFileConnection.sDatabase
99421>>>                    End
99421>>>>
99421>>>                    If (SQLIniFileConnection.bTrusted = True) Begin
99423>>>                        If (SQLIniFileConnection.bEnabled = True) Begin
99425>>>                        Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "") to bOK
99426>>>                        End
99426>>>>
99426>>>                        Else Begin
99427>>>                            Move (SQLIniFileConnection.sServer <> "") to bOK
99428>>>                        End
99428>>>>
99428>>>                    End
99428>>>>
99428>>>                    Else Begin
99429>>>                        // It should probably be allowed to use an UID but no password...
99429>>>                        If (SQLIniFileConnection.bEnabled = True) Begin
99431>>>                        Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sUserID <> "") to bOK
99432>>>                        End
99432>>>>
99432>>>                        Else Begin
99433>>>                            Move (SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sUserID <> "") to bOK
99434>>>                        End
99434>>>>
99434>>>                    End
99434>>>>
99434>>>                    Case Break
99435>>>                Case (SQLIniFileConnection.sDriverID = MSSQLDRV_ID)
99438>>>                    If (SQLIniFileConnection.bTrusted = True) Begin
99440>>>                        If (SQLIniFileConnection.bEnabled = True) Begin
99442>>>                        Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sDatabase <> "") to bOK
99443>>>                        End
99443>>>>
99443>>>                        Else Begin
99444>>>                            Move (SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sDatabase <> "") to bOK
99445>>>                        End
99445>>>>
99445>>>                    End
99445>>>>
99445>>>                    Else Begin
99446>>>                        // It should probably be allowed to use an UID but no password...
99446>>>                        If (SQLIniFileConnection.bEnabled = True) Begin
99448>>>                        Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sDatabase <> "" and SQLIniFileConnection.sUserID <> "") to bOK
99449>>>                        End
99449>>>>
99449>>>                        Else Begin
99450>>>                            Move (SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sDatabase <> "" and SQLIniFileConnection.sUserID <> "") to bOK
99451>>>                        End
99451>>>>
99451>>>                    End
99451>>>>
99451>>>                    Case Break
99452>>>            Case End
99452>>>
99452>>>            If (bOK = False) Begin
99454>>>                Send Info_Box "Please fill in all connection data."
99455>>>                Procedure_Return
99456>>>            End
99456>>>>
99456>>>
99456>>>            Move MBR_Yes to iRetval
99457>>>            Get Label of oLoginInfo_tb to sLoginText
99458>>>            If (sLoginText = CS_LoginFailed) Begin
99460>>>                Get YesNo_Box "The login failed. Are you sure you want to use these connection settings?" to iRetval
99461>>>            End
99461>>>>
99461>>>            Else If (sLoginText = "") Begin
99464>>>                Get YesNo_Box "The login has not been tested. Are you sure you want to use these connection settings?" to iRetval
99465>>>            End
99465>>>>
99465>>>            If (iRetval <> MBR_Yes) Begin
99467>>>                Procedure_Return
99468>>>            End
99468>>>>
99468>>>
99468>>>            Set pSQLConnectionData to SQLIniFileConnection
99469>>>            Set pbChanged to True
99470>>>            Send Close_Panel
99471>>>        End_Procedure
99472>>>
99472>>>    End_Object
99473>>>
99473>>>    Object oCancel_Btn is a cRDCButton
99475>>>        Set Label    to C_$Cancel
99476>>>        Set Location to 287 264 //281 264
99477>>>        Set peAnchors to anBottomRight
99478>>>
99478>>>        Procedure OnClick
99481>>>            Set pbChanged to False
99482>>>            Send Close_Panel
99483>>>        End_Procedure
99484>>>
99484>>>    End_Object
99485>>>
99485>>>    Object oHelp_Btn is a cRDCButton
99487>>>        Set Label to C_$Help
99488>>>        Set Location to 287 11 //281 11
99489>>>        Set peAnchors to anBottomLeft
99490>>>        Set psImage to "ActionHelp1.ico"
99491>>>
99491>>>        Procedure OnClick
99494>>>            Send DoDisplayKeyword of ghoHtmlHelp "SQLConnections Tool"
99495>>>        End_Procedure
99496>>>    End_Object
99497>>>
99497>>>    Object oConnectionType_grp is a cRDCHeaderGroup
99499>>>        Set Size to 60 303
99500>>>        Set Location to 8 11 //2 11
99501>>>        Set psImage to "SQLSettings1.ico"
99502>>>        Set psLabel to "Database Type Settings"
99503>>>
99503>>>        Object oDbType_cf is a cSQLComboForm
99505>>>            Set Size to 13 115
99506>>>            Set Location to 22 82
99507>>>            Set Label to "Database Type"
99508>>>            Set Entry_State to False
99509>>>            Set Combo_Sort_State to False
99510>>>            Set psToolTip to "Select a database type, then select a driver to use for the database"
99511>>>            Set piItem to 3
99512>>>            
99512>>>            Procedure Combo_Fill_List
99515>>>                Send Combo_Add_Item CS_DbTypeDataFlex
99516>>>                Send Combo_Add_Item CS_dbTypeMSSQL
99517>>>                Send Combo_Add_Item CS_dbTypeMySQL
99518>>>                Send Combo_Add_Item CS_dbTypeOracle
99519>>>                Send Combo_Add_Item CS_dbTypeDB2
99520>>>                Send Combo_Add_Item CS_dbTypePostgre
99521>>>                Set Value to CS_dbTypeMSSQL
99522>>>            End_Procedure
99523>>>
99523>>>            Procedure OnChange
99526>>>                Integer iDbType
99526>>>                String sDriverID
99526>>>    
99526>>>                Get SelectedDbType to iDbType
99527>>>                Send Refill_Comboform of oDriverID_cf iDbType
99528>>>                Get Value of oDriverID_cf to sDriverID 
99529>>>                If (sDriverID = "") Begin
99531>>>                    Move MSSQLDRV_ID to sDriverID
99532>>>                    Move EN_DbTypeMSSQL to iDbType
99533>>>                End
99533>>>>
99533>>>                Send DbTypeUpdate of oSettings_grp iDbType sDriverID
99534>>>            End_Procedure
99535>>>    
99535>>>            Function SelectedDbType Returns Integer
99538>>>                Integer iRetval
99538>>>                String sDbType
99538>>>    
99538>>>                Get Value to sDbType
99539>>>                Get SqlUtilDbTypeToInteger of ghoDbUpdateFunctionLibrary sDbType to iRetval
99540>>>    
99540>>>                Function_Return iRetval
99541>>>            End_Function
99542>>>
99542>>>        End_Object
99543>>>
99543>>>// This used to work, but it seems that the Ssms.exe is no longer part of Windows "global pathing (in DOS)".
99543>>>//        Object oStartSQLManager_btn is a cRDCButton
99543>>>//            Set Size to 13 78
99543>>>//            Set Location to 22 210
99543>>>//            Set Label to "SQL Manager"
99543>>>//            Set pbAutoEnable to True  
99543>>>//            Set psImage to "SSMS1.ico" 
99543>>>//            Set psToolTip to "Start Microsoft SQL Server Management Studio"
99543>>>//            Set peAnchors to anTopRight
99543>>>//        
99543>>>//            Procedure OnClick
99543>>>//                Runprogram Shell Background "Ssms.exe"    
99543>>>//            End_Procedure  
99543>>>//            
99543>>>//            Function IsEnabled Returns Boolean
99543>>>//                String sDbType
99543>>>//                Get Value of oDbType_cf to sDbType
99543>>>//                Function_Return (sDbType = CS_dbTypeMSSQL)
99543>>>//            End_Function
99543>>>//        
99543>>>//        End_Object
99543>>>
99543>>>        Object oDriverID_cf is a cSQLComboForm
99545>>>            Set Size to 13 115
99546>>>            Set Location to 37 82
99547>>>            Set Label to "Driver ID"
99548>>>            Set Entry_State to False
99549>>>            Set Combo_Sort_State to False
99550>>>            Set psToolTip to "Depending on the database type selected the comboform list will vary."
99551>>>            Set piItem to 4
99552>>>
99552>>>            Procedure Refill_Comboform Integer iDbType
99555>>>                String sValue
99555>>>
99555>>>                Send Combo_Delete_Data
99556>>>                Send Combo_Add_Item MSSQLDRV_ID
99557>>>                Send Combo_Add_Item DB2_DRV_ID
99558>>>                Send Combo_Add_Item ODBC_DRV_ID
99559>>>                Send Combo_Add_Item DATAFLEX_ID
99560>>>
99560>>>                Case Begin
99560>>>                    Case (iDbType = EN_dbTypeMSSQL)
99562>>>                        Move MSSQLDRV_ID to sValue
99563>>>                        Case Break
99564>>>                    Case (iDbType = EN_dbTypeMySQL)
99567>>>                        Move ODBC_DRV_ID to sValue
99568>>>                        Case Break
99569>>>                    Case (iDbType = EN_dbTypeOracle)
99572>>>                        Move ODBC_DRV_ID to sValue
99573>>>                        Case Break
99574>>>                    Case (iDbType = EN_dbTypeDB2)
99577>>>                        Move DB2_DRV_ID to sValue
99578>>>                        Case Break
99579>>>                    Case (iDbType = EN_dbTypePostgre)
99582>>>                        Move ODBC_DRV_ID to sValue
99583>>>                        Case Break
99584>>>                    Case Else
99584>>>                        Move DATAFLEX_ID to sValue
99585>>>                Case End
99585>>>                Set Value to sValue
99586>>>            End_Procedure
99587>>>
99587>>>            Procedure OnChange
99590>>>                String sDriverID
99590>>>                Integer iDbType
99590>>>
99590>>>                Get Value to sDriverID
99591>>>                If (sDriverID = "") Begin
99593>>>                    Procedure_Return
99594>>>                End
99594>>>>
99594>>>                Get SelectedDbType of oDbType_cf to iDbType
99595>>>                Broadcast Recursive Send DbTypeUpdate of oSettings_grp iDbType sDriverID
99597>>>            End_Procedure
99598>>>
99598>>>        End_Object
99599>>>
99599>>>        Object oShowDriverSettings_btn is a cRDCButton
99601>>>            Set Size to 13 78
99602>>>            Set Location to 37 210
99603>>>            Set Label to "Driver Settings"
99604>>>            Set Status_Help to "Shows settings for the selected driver."
99605>>>            Set psImage to "DriverSettings1.ico"
99606>>>            Set peAnchors to anTopRight
99607>>>
99607>>>            Procedure OnClick
99610>>>                String sDriver sPath 
99610>>>                
99610>>>                Get Value of oDriverID_cf to sDriver
99611>>>                Send PopupDriverSettings sDriver 
99612>>>            End_Procedure
99613>>>    
99613>>>        End_Object
99614>>>
99614>>>    End_Object
99615>>>
99615>>>    Function ReadCurrentSQLSettings Returns tSQLConnection
99618>>>        tSQLConnection SQLConnection
99618>>>        tSQLConnection SQLConnection
99618>>>
99618>>>        Get Value of oDriverID_cf        to SQLConnection.sDriverID
99619>>>        Get SelectedDbType of oDbType_cf to SQLConnection.iDbType
99620>>>
99620>>>        Get Checked_State of oTrusted_cb to SQLConnection.bTrusted
99621>>>        Get Value of oDriverID_cf        to SQLConnection.sDriverID
99622>>>        Get Value of oServer_fm          to SQLConnection.sServer
99623>>>        Get Value of oUserID_fm          to SQLConnection.sUserID
99624>>>        Get Value of oPassword_fm        to SQLConnection.sPassword     
99625>>>        Move False to Err
99626>>>        Get ConstructConnectionString of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) ;            SQLConnection.sDriverID SQLConnection.sServer "" SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
99627>>>        Set pSQLConnection of ghoSQLConnectionHandler to SQLConnection
99628>>>        Move Err to SQLConnection.bError
99629>>>        
99629>>>        Function_Return SQLConnection
99630>>>    End_Function
99631>>>
99631>>>    Function LoginString String ByRef sError Returns String
99634>>>        String sDriverID sServer sDatabase
99634>>>        tSQLConnection SQLConnection
99634>>>        tSQLConnection SQLConnection
99634>>>        
99634>>>        Get Value of oDriverID_cf to sDriverID
99635>>>        If (sDriverID = "") Begin
99637>>>            Move "Please select a driver first, then try again." to sError
99638>>>            Function_Return ""
99639>>>        End
99639>>>>
99639>>>
99639>>>        Get Value of oServer_fm   to sServer
99640>>>        If (sServer = "") Begin
99642>>>            Move "Please select a server first, then try again." to sError
99643>>>            Function_Return ""
99644>>>        End
99644>>>>
99644>>>
99644>>>        Get Value of oDatabase_fm to sDatabase
99645>>>        If (sDatabase = "" and sDriverID = MSSQLDRV_ID) Begin
99647>>>            Move "master" to sDatabase
99648>>>        End
99648>>>>
99648>>>
99648>>>        Get ReadCurrentSQLSettings to SQLConnection
99649>>>        If (SQLConnection.bError = True) Begin
99651>>>            Move "Login Error" to sError
99652>>>        End
99652>>>>
99652>>>
99652>>>        Function_Return SQLConnection.sConnectionString
99653>>>    End_Function
99654>>>
99654>>>    // Returns True if anything has changed.
99654>>>    Function Should_Save Returns Boolean
99657>>>        String[] sConnectionData sConnectionData2
99659>>>        tSQLConnection SQLConnectionData
99659>>>        tSQLConnection SQLConnectionData
99659>>>        Boolean bState
99659>>>
99659>>>        Broadcast Recursive Send WriteConnectionData (&sConnectionData)
99661>>>        Get pSQLConnectionData to SQLConnectionData
99662>>>        Get MoveSQLConnectionToStringArray SQLConnectionData to sConnectionData2
99663>>>        // We don't have a form here for the sConnectionString, so we "blank it out"
99663>>>        // to be able to compare properly.
99663>>>        Move "" to sConnectionData2[7]
99664>>>
99664>>>            Move (IsSameArray(sConnectionData, sConnectionData2)) to bState
99665>>>        Function_Return (bState = False)
99666>>>    End_Function
99667>>>
99667>>>    Function IsConnectionIDDuplicate tSQLConnection SQLConnection Returns Boolean
99670>>>        Integer iCount iSize iItems iCurrentRow
99670>>>        String sValue sConnectionID
99670>>>        Boolean bExists
99670>>>        tDataSourceRow[] TheData
99670>>>        tDataSourceRow[] TheData
99671>>>        tDataSourceRow TheRow
99671>>>        tDataSourceRow TheRow
99671>>>
99671>>>        Move 0 to iItems
99672>>>        Get piCurrentRow to iCurrentRow
99673>>>        Move SQLConnection.sConnectionID to sConnectionID
99674>>>        Get MoveSQLConnectionToGridRow SQLConnection to TheRow
99675>>>        Get pTheData to TheData
99676>>>        Move (SizeOfArray(TheData)) to iSize
99677>>>        If (iCurrentRow <> -1) Begin
99679>>>            // This is the sConnectionID:
99679>>>            Move TheRow.sValue[2] to TheData[iCurrentRow].sValue[2]
99680>>>        End
99680>>>>
99680>>>        Else Begin
99681>>>            Move TheRow to TheData[iSize]
99682>>>        End
99682>>>>
99682>>>        Move (SizeOfArray(TheData)) to iSize
99683>>>        Decrement iSize
99684>>>        For iCount from 0 to iSize
99690>>>>
99690>>>            Move TheData[iCount].sValue[2] to sValue
99691>>>            Move (sValue = sConnectionID) to bExists
99692>>>            If (bExists) Begin
99694>>>                Increment iItems
99695>>>            End
99695>>>>
99695>>>        Loop
99696>>>>
99696>>>
99696>>>        Function_Return (iItems > 1)
99697>>>    End_Function
99698>>>
99698>>>    // Transfers data between a tSQLConnection struct and a grid data row.
99698>>>    Function MoveSQLConnectionToGridRow tSQLConnection SQLConnection Returns tDataSourceRow
99701>>>        tDataSourceRow TheRow
99701>>>        tDataSourceRow TheRow
99701>>>        Integer iDbType
99701>>>        String sValue
99701>>>
99701>>>        Move 0                                  to TheRow.sValue[0]
99702>>>        Move SQLConnection.bEnabled             to TheRow.sValue[1]
99703>>>        Move SQLConnection.sConnectionID        to TheRow.sValue[2]
99704>>>        Move SQLConnection.sDriverID            to TheRow.sValue[3]
99705>>>
99705>>>        // We only show three asterisks ("***") instead of the password in the grid.
99705>>>        Move (Replace(SQLConnection.sPassword, SQLConnection.sConnectionString, "***")) to sValue
99706>>>        Move sValue                             to TheRow.sValue[4]
99707>>>
99707>>>        Move SQLConnection.iDbType to iDbType
99708>>>        Get SqlUtilDbTypeToString of ghoDbUpdateFunctionLibrary iDbType to sValue
99709>>>        Move sValue                             to TheRow.sValue[5]
99710>>>        Move SQLConnection.sServer              to TheRow.sValue[6]
99711>>>        Move SQLConnection.sDatabase            to TheRow.sValue[7]
99712>>>
99712>>>        // Hidden columns (to make Should_Save function work)
99712>>>        Move SQLConnection.sConnectionString    to TheRow.sValue[8] // "Untouched" connection string.
99713>>>        Move SQLConnection.bTrusted             to TheRow.sValue[9]
99714>>>        Move SQLConnection.sUserID              to TheRow.sValue[10]
99715>>>        Move SQLConnection.sPassword            to TheRow.sValue[11]
99716>>>        Move SQLConnection.sSchema              to TheRow.sValue[12]
99717>>>        Move SQLConnection.sBaseTableSpace      to TheRow.sValue[13]
99718>>>        Move SQLConnection.sLongTableSpace      to TheRow.sValue[14]
99719>>>        Move SQLConnection.sIndexTableSpace     to TheRow.sValue[15]
99720>>>        Move SQLConnection.bSilentLogin         to TheRow.sValue[16]
99721>>>//        Move SQLConnection.bDisabled            to TheRow.sValue[17]
99721>>>//        Move SQLConnection.iDriverIndex         to TheRow.sValue[18]
99721>>>
99721>>>        Function_Return TheRow
99722>>>    End_Function
99723>>>
99723>>>    Function MoveSQLConnectionToStringArray tSQLConnection SQLConnection Returns String[]
99726>>>        String[] sConnectionData
99727>>>        Integer iRetval
99727>>>
99727>>>        Move SQLConnection.bEnabled          to sConnectionData[1]
99728>>>        Move SQLConnection.sConnectionID     to sConnectionData[2]
99729>>>        Get SqlUtilDbTypeToString of ghoDbUpdateFunctionLibrary SQLConnection.iDbType to sConnectionData[3]
99730>>>        Move SQLConnection.sDriverID         to sConnectionData[4]
99731>>>        Move SQLConnection.sServer           to sConnectionData[5]
99732>>>        Move SQLConnection.sDatabase         to sConnectionData[6]
99733>>>        Move SQLConnection.sConnectionString to sConnectionData[7]
99734>>>        Move SQLConnection.bTrusted          to sConnectionData[8]
99735>>>        Move SQLConnection.sUserID           to sConnectionData[9]
99736>>>
99736>>>        If (SQLConnection.sPassword <> "") Begin
99738>>>            Move MBR_Yes to iRetval
99739>>>            If (pbDFConnId(Self) = True) Begin
99741>>>                Get YesNo_Box "You are working with a DAW 'DFConnId.ini' file. Although this program can both read/write to such a file, the password encryption/decryption algorithms are (obviously) different. Thus the password will not be touched. Continue?" to iRetval
99742>>>                If (iRetval = MBR_Yes) Begin
99744>>>                    Set psUncryptedPw to SQLConnection.sPassword
99745>>>                    Move "" to SQLConnection.sPassword 
99746>>>//                    Set Enabled_State of oCheckLogin_btn to False
99746>>>                End
99746>>>>
99746>>>                Else Begin
99747>>>                    Send Stop_UI
99748>>>                End
99748>>>>
99748>>>            End
99748>>>>
99748>>>            Else Begin
99749>>>                Move SQLConnection.sPassword to sConnectionData[10]
99750>>>            End
99750>>>>
99750>>>        End
99750>>>>
99750>>>
99750>>>        Move SQLConnection.sSchema           to sConnectionData[11]
99751>>>        Move SQLConnection.sBaseTableSpace   to sConnectionData[12]
99752>>>        Move SQLConnection.sLongTableSpace   to sConnectionData[13]
99753>>>        Move SQLConnection.sIndexTableSpace  to sConnectionData[14]
99754>>>        Move SQLConnection.bSilentLogin      to sConnectionData[15]
99755>>>
99755>>>        Function_Return sConnectionData
99756>>>    End_Function
99757>>>
99757>>>    Function MoveStringArrayToSQLConnection String[] sConnectionData Returns tSQLConnection
99760>>>        tSQLConnection SQLConnection
99760>>>        tSQLConnection SQLConnection
99760>>>
99760>>>        Move sConnectionData[1]  to SQLConnection.bEnabled
99761>>>        Move sConnectionData[2]  to SQLConnection.sConnectionID
99762>>>        Get SqlUtilDbTypeToInteger of ghoDbUpdateFunctionLibrary sConnectionData[3] to SQLConnection.iDbType
99763>>>        Move sConnectionData[4]  to SQLConnection.sDriverID
99764>>>        Move sConnectionData[5]  to SQLConnection.sServer
99765>>>        Move sConnectionData[6]  to SQLConnection.sDatabase
99766>>>
99766>>>        Move sConnectionData[8]  to SQLConnection.bTrusted
99767>>>        Move sConnectionData[9]  to SQLConnection.sUserID
99768>>>
99768>>>        If (sConnectionData[10] <> "" and pbDFConnId(Self) = False) Begin
99770>>>            Move sConnectionData[10] to SQLConnection.sPassword
99771>>>        End
99771>>>>
99771>>>        // In case of we're dealing with a DfConnID.ini file (DF 19+) we don't want to change the password
99771>>>        // as DAW's 'Managed Connections' program has a different password encryption/decryption algorithm.
99771>>>        If (pbDFConnId(Self) = True) Begin
99773>>>            Get psUncryptedPw to SQLConnection.sPassword
99774>>>        End
99774>>>>
99774>>>
99774>>>        Move sConnectionData[11] to SQLConnection.sSchema
99775>>>        Move sConnectionData[12] to SQLConnection.sBaseTableSpace
99776>>>        Move sConnectionData[13] to SQLConnection.sLongTableSpace
99777>>>        Move sConnectionData[14] to SQLConnection.sIndexTableSpace
99778>>>        Move sConnectionData[15] to SQLConnection.bSilentLogin
99779>>>
99779>>>        // Connection string:
99779>>>        Get ConstructConnectionString of ghoSQLConnectionHandler SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase ;                                                                 SQLConnection.bTrusted  SQLConnection.sUserID SQLConnection.sPassword ;                                      to SQLConnection.sConnectionString
99780>>>
99780>>>        Function_Return SQLConnection
99781>>>    End_Function
99782>>>
99782>>>    Procedure Popup
99785>>>        tSQLConnection SQLIniFileConnection
99785>>>        tSQLConnection SQLIniFileConnection
99785>>>        String[] sConnectionData
99786>>>        String sDriverID
99786>>>        Integer iDbType
99786>>>        Boolean bAdd
99786>>>
99786>>>        Move (piCurrentRow(Self) = -1) to bAdd
99787>>>        Get pSQLConnectionData to SQLIniFileConnection             
99788>>>        // we need these as the oConnectionType_grp has been moved to be the last object(s) in the dialog.
99788>>>        Set Value of oDbType_cf   to SQLIniFileConnection.iDbType
99789>>>        Set Value of oDriverID_cf to ""
99790>>>        If (SQLIniFileConnection.bEnabled = False and bAdd = True) Begin
99792>>>            Move True to SQLIniFileConnection.bEnabled
99793>>>        End
99793>>>>
99793>>>        Get MoveSQLConnectionToStringArray SQLIniFileConnection to sConnectionData
99794>>>
99794>>>        If (SQLIniFileConnection.sDriverID <> "") Begin
99796>>>            Set Value of oDriverID_cf to SQLIniFileConnection.sDriverID
99797>>>            Set Value of oDbType_cf   to SQLIniFileConnection.iDbType
99798>>>        End
99798>>>>
99798>>>        Broadcast Recursive Send ReadConnectionData sConnectionData
99800>>>
99800>>>        // We need this message to "auto-default" certain fields.
99800>>>        If (bAdd = True) Begin
99802>>>            Get SelectedDbType of oDbType_cf to iDbType
99803>>>            Get Value of oDriverID_cf to sDriverID
99804>>>            If (sDriverID = "") Begin
99806>>>                Move MSSQLDRV_ID to sDriverID
99807>>>            End
99807>>>>
99807>>>            Broadcast Recursive Send DbTypeUpdate of oSettings_grp iDbType sDriverID
99809>>>        End
99809>>>>
99809>>>
99809>>>        Set Password_State of oPassword_fm to True
99810>>>        Set Value of oLoginInfo_tb to ""
99811>>>        Set Statusbar_Id to (phoDialogCommandbar(Self))
99812>>>
99812>>>        Forward Send Popup
99814>>>    End_Procedure
99815>>>
99815>>>    Procedure Page Integer iPageObject
99818>>>        Boolean bNew bReadOnly
99818>>>        String sText
99818>>>        Handle hWnd
99818>>>
99818>>>        Send Cursor_Ready of Cursor_Control
99819>>>        Forward Send Page iPageObject
99821>>>        Set Icon to "SQLConnections1.ico"
99822>>>
99822>>>        Get pbNew to bNew
99823>>>        If (bNew = True) Begin   
99825>>>            Move ("The" * CS_SQLIniFileName * "file doesn't exist yet for this workspace and needs to be created. Here's what you need to do:\n\n") to sText
99826>>>            Move (sText * "1. Enter a Connection ID (the same that is being used by your workspace .int files) and other data that is used to login to the database.\n") to sText
99827>>>            Move (sText * "2. Press the 'Test Login' button to ensure entered details are correct.\n") to sText
99828>>>            Move (sText * "3. Press the 'OK' button and then save your changes.\n") to sText
99829>>>            Send Info_Box sText
99830>>>        End
99830>>>>
99830>>>
99830>>>        If (ghoSkinFramework <> 0 and hWnd <> 0) Begin
99832>>>            Send ComRemoveWindow to ghoSkinFramework hWnd
99833>>>            Send ComApplyWindow  to ghoSkinFramework hWnd
99834>>>        End
99834>>>>
99834>>>
99834>>>        Get pbReadOnly to bReadOnly
99835>>>        If (bReadOnly = True) Begin
99837>>>            Broadcast Recursive Set Enabled_State    to (not(bReadOnly))
99839>>>            Set Enabled_State of oConnectionType_grp to True
99840>>>            Set Enabled_State of oSettings_grp       to True
99841>>>            Set Enabled_State of oPassword_fm        to True
99842>>>            Set Enabled_State of oViewPassword_btn   to True
99843>>>            Set Enabled_State of oCheckLogin_btn     to True
99844>>>            Set Enabled_State of oCancel_Btn         to True
99845>>>            Set Enabled_State of oHelp_Btn           to True
99846>>>            Set Enabled_State of oShowDriverSettings_btn to True
99847>>>            Set Enabled_State of oCreateDatabase_btn to False
99848>>>            Send Activate of oCancel_Btn
99849>>>        End
99849>>>>
99849>>>    End_Procedure
99850>>>
99850>>>    Function IniFileName Returns String
99853>>>        String sRetval
99853>>>        Function_Return sRetval
99854>>>    End_Function
99855>>>
99855>>>    // Put a status bar at the bottom of the panel, which makes
99855>>>    // status_help work and puts a gripper in the lower right corner.
99855>>>    Procedure End_Construct_Object
99858>>>        Integer iStyle iSize iOffset
99858>>>
99858>>>        Forward Send End_Construct_Object
99860>>>
99860>>>        Get Border_Style to iStyle
99861>>>        Move 8 to iOffset
99862>>>        If (iStyle = Border_Thick) Begin
99864>>>            Object oDialogCommandbar is a cCJCommandBarSystem
99866>>>                Object oStatusBar is a cCJStatusBar
99868>>>                    Set phoDialogCommandbar to Self
99869>>>                    Object oStatusIdle is a cCJStatusBarPane
99871>>>                        Set piId to sbpIDIdlePane
99872>>>                        Set pbStyleStretch to True
99873>>>                    End_Object
99874>>>                End_Object
99875>>>            End_Object
99876>>>
99876>>>            Get Size to iSize
99877>>>            Set Size to (Hi(iSize) + iOffset) (Low(iSize))
99878>>>        End
99878>>>>
99878>>>    End_Procedure
99879>>>
99879>>>    Procedure ShowProgramHelp
99882>>>        Send DoDisplayKeyword of ghoHtmlHelp "SQLConnections Tool"
99883>>>    End_Procedure
99884>>>
99884>>>    On_Key Key_F1         Send ShowProgramHelp
99885>>>    On_Key Key_Ctrl+Key_L Send KeyAction of oCheckLogin_btn
99886>>>    On_Key kCancel        Send KeyAction of oCancel_Btn
99887>>>End_Object
99888>>>
99888>>>// General purpose access message                                                                                                           // If ini-file= "DFConnId.ini" (DAW file)
99888>>>Procedure Activate_SQLMaintainConnections_dg Boolean bNew Integer iCurrentRow tSQLConnection ByRef SQLConnectionData Boolean ByRef bChanged Boolean bDFConnId tDataSourceRow[] TheData
99891>>>    Handle ho
99891>>>    String sPath sSQLConnectionsFileName
99891>>>    Boolean bExists
99891>>>    
99891>>>    Send Cursor_Wait of Cursor_Control
99892>>>    Move (oSQLMaintainConnections_dg(Self)) to ho
99893>>>    Set pbReadOnly              of ho to False
99894>>>    Set pbNew                   of ho to bNew
99895>>>    Set piCurrentRow            of ho to iCurrentRow
99896>>>    Set pbDFConnId              of ho to bDFConnId
99897>>>    Set pSQLConnectionData      of ho to SQLConnectionData
99898>>>    Get psIniFilePath of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) to sPath
99899>>>    Get psIniFileName of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) to sSQLConnectionsFileName
99900>>>    File_Exist (sPath + sSQLConnectionsFileName) bExists
99901>>>    If (bExists = True) Begin
99903>>>        Set Label  of ho to ("Connection Properties" * "[" + String(sPath) + String(sSQLConnectionsFileName) + "]")
99904>>>    End
99904>>>>
99904>>>    Set pTheData                of ho to TheData
99905>>>
99905>>>    Send Popup                  of ho
99906>>>
99906>>>    Get pSQLConnectionData      of ho to SQLConnectionData
99907>>>    Get pbChanged               of ho to bChanged
99908>>>End_Procedure
99909>>>
99909>>>// Read-only access message
99909>>>Procedure Activate_ReadOnlySQLMaintainConnections_dg tSQLConnection SQLConnectionData
99912>>>    Handle ho
99912>>>    String sPath sSQLConnectionsFileName
99912>>>
99912>>>    Send Cursor_Wait of Cursor_Control
99913>>>    Move (oSQLMaintainConnections_dg(Self)) to ho
99914>>>    Set pbReadOnly              of ho to True
99915>>>
99915>>>    Set pSQLConnectionData      of ho to SQLConnectionData
99916>>>    Get psIniFilePath of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) to sPath
99917>>>    Get psIniFileName of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) to sSQLConnectionsFileName
99918>>>    Set Label  of ho to ("Connection Properties (Read-Only)" * "[" + String(sPath) + String(sSQLConnectionsFileName) + "]")
99919>>>
99919>>>    Send Popup of ho
99920>>>End_Procedure
99921>>>
99921>        Use AddToStudio.dg     
Including file: AddToStudio.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\AddToStudio.dg)
99921>>>Use Windows.pkg
99921>>>Use Dfspnfrm.pkg
99921>>>Use cRegistry.pkg
99921>>>Use vWin32fh.pkg
99921>>>
99921>>>Enum_List
99921>>>    Define cx_RegKeyAlreadyExist
99921>>>    Define cx_RegKeyCreated
99921>>>    Define cx_RegkeyFailed
99921>>>    Define cx_RegKeyVDFKeyDoesNotExist
99921>>>    Define CX_InstalledOkVdfUnder16
99921>>>End_Enum_List
99921>>>
99921>>>// Note: The "Visual" part will automatically be removed if
99921>>>// the current DataFlex version is above 17.
99921>>>Define CS_StudioPath        for "Software\Data Access Worldwide\Visual DataFlex Tools\"
99921>>>Define CS_StudioTools       for "\Studio\Tools"
99921>>>Define CS_RegApplication    for "<application>"
99921>>>Define CS_RegWorkspace      for "<workspace>"
99921>>>Define CS_CommandLine       for "CommandLine"
99921>>>Define CS_Name              for "Name"
99921>>>Define CS_Separator         for "Separator"
99921>>>Define CS_Command           for "Command"
99921>>>
99921>>>Object oAddToStudio_dg is a ModalPanel
99923>>>    Set Size to 79 330
99924>>>    Set Label to "Add Program To DataFlex Studio's Tools Menu"
99925>>>    Set piMinSize to 79 211
99926>>>    Set Location to 5 4
99927>>>    Set Locate_Mode to Center_On_Parent
99928>>>
99928>>>    Property String psTag CS_RegApplication
99930>>>
99930>>>    Object oStudioIntegration_grp is a Group
99932>>>        Set Size to 45 299
99933>>>        Set Location to 8 15
99934>>>        Set Label to "DataFlex Studio Integration"
99935>>>
99935>>>        Object oStudioMajorVersion_sf is a SpinForm
99937>>>            Set Size to 12 27
99938>>>            Set Location to 18 168
99939>>>            Set Maximum_Position to 30
99940>>>            Set Minimum_Position to 14
99941>>>            Set Label_Col_Offset to 2
99942>>>            Set Label_Justification_Mode to JMode_Right
99943>>>            Set Label to "Add to Studio's Tools Menu:     Major Version"
99944>>>            Set Status_Help to "DataFlex main version - e.g. '18'"
99945>>>            Set Value to FMAC_VERSION
99946>>>            Set peAnchors to anNone
99947>>>        End_Object
99948>>>
99948>>>        Object oStudioMinorVersion_sf is a SpinForm
99950>>>            Set Size to 12 27
99951>>>            Set Location to 18 254
99952>>>            Set Label_Col_Offset to 2
99953>>>            Set Label to "Minor Version"
99954>>>            Set Status_Help to "DataFlex minor version - e.g. '0'"
99955>>>            Set Maximum_Position to 9
99956>>>            Set Minimum_Position to 0
99957>>>            Set Value to FMAC_REVISION
99958>>>            Set Label_Justification_Mode to JMode_Right
99959>>>            Set peAnchors to anNone
99960>>>        End_Object
99961>>>
99961>>>    End_Object
99962>>>
99962>>>    Object oOK_btn is a Button
99964>>>        Set Location to 59 207
99965>>>        Set Label to "Add Now"
99966>>>        Set Status_Help to "Add to DataFlex Studio's Tools menu. The Studio version can be selected with the two spinforms. The program gets added to the Studios Tools menu."
99967>>>        Set peAnchors to anTopRight
99968>>>
99968>>>        Procedure OnClick
99971>>>            Integer iRetval iMajorVersion iMinorVersion
99971>>>            String sText sStudioVersion
99971>>>            Get Value of oStudioMajorVersion_sf to iMajorVersion
99972>>>            Get Value of oStudioMinorVersion_sf to iMinorVersion
99973>>>            Move (String(iMajorVersion) + "." + String(iMinorVersion)) to sStudioVersion
99974>>>            Get AddProgramToStudioToolsMenu sStudioVersion to iRetval
99975>>>            Case Begin
99975>>>                Case (iRetval = cx_RegKeyAlreadyExist)
99977>>>                    Move ("The program already exists in the" * sStudioVersion * "DataFlex Studios Tools menu.") to sText
99978>>>                    Break
99979>>>                Case (iRetval = cx_RegKeyCreated)
99982>>>                    Move ("Success. The tool was added to the" * sStudioVersion *  "DataFlex Studios Tools menu.") to sText
99983>>>                    Break
99984>>>                Case (iRetval = cx_RegkeyFailed)
99987>>>                    Move "Failed. Could not create the registry key for adding the program to the DataFlex Studio's Tools menu." to sText
99988>>>                    Break
99989>>>                Case (iRetval = cx_RegKeyVDFKeyDoesNotExist)
99992>>>                    Move ("Could not find the Studio registry key. Is DataFlex Studio version" * sStudioVersion * "really installed on this machine?") to sText
99993>>>                    Break
99994>>>                Case (iRetval = CX_InstalledOkVdfUnder16)
99997>>>                    Move ("The program was added to the" * sStudioVersion * "Studios Tools menu successfully, but because you installed for an earlier version of the Studio than 16.0 you need to compile the program under that same VDF version, else the Studio can't start the program properly. (Sorry, just a 'feature' of earlier versions of the Studio)") to sText
99998>>>                    Break
99999>>>            Case End
99999>>>
99999>>>            Send Info_Box sText
100000>>>        End_Procedure
100001>>>    End_Object
100002>>>
100002>>>    Object oCancel_Btn is a Button
100004>>>        Set Label to C_$Close
100005>>>        Set Location to 59 264
100006>>>        Set peAnchors to anBottomRight
100007>>>
100007>>>        Procedure OnClick
100010>>>            Send Close_Panel
100011>>>        End_Procedure
100012>>>
100012>>>    End_Object
100013>>>
100013>>>    Function AddProgramToStudioToolsMenu String sStudioVersion Returns Integer
100016>>>        Boolean bOk bExists bOpen
100016>>>        String sKey sValue sProgramPath sProgram sProduct sStudioPath
100016>>>        Handle hoReg hoArray
100016>>>        Integer i iItems iCreated iRetval
100016>>>
100016>>>        Move False to bOk
100017>>>        Move (CS_StudioPath + (Trim(sStudioVersion)))  to sStudioPath
100018>>>        If (sStudioVersion > "17.1") Begin
100020>>>            Move (Replace("Visual ", sStudioPath, "")) to sStudioPath
100021>>>        End
100021>>>>
100021>>>
100021>>>        Get psProgramPath of (phoWorkspace(ghoApplication)) to sProgramPath
100022>>>        Get PathAtIndex of (phoWorkspace(ghoApplication)) sProgramPath 1 to sProgramPath
100023>>>        Get vFolderFormat sProgramPath to sProgramPath
100024>>>        Get psProduct     of (phoWorkspace(ghoApplication)) to sProduct
100025>>>        Get Module_Name to sProgram
100026>>>        Get Create (RefClass(cRegistry)) to hoReg
100027>>>        Set phRootKey of hoReg to HKEY_CURRENT_USER
100028>>>
100028>>>        // First check if the VDF version is installed
100028>>>        Get KeyExists of hoReg sStudioPath to bExists
100029>>>        If (bExists = False) Begin
100031>>>            Send Destroy of hoReg
100032>>>            Function_Return cx_RegKeyVDFKeyDoesNotExist
100033>>>        End
100033>>>>
100033>>>
100033>>>        // Then check if any tools have been installed in the Tools Menu.
100033>>>        // If no tools created yet, create the Tools registry key.
100033>>>        Move (sStudioPath + CS_StudioTools) to sStudioPath
100034>>>        Get KeyExists of hoReg sStudioPath to bExists
100035>>>        If (bExists = False) Begin
100037>>>            Set pfAccessRights of hoReg to KEY_ALL_ACCESS
100038>>>            Get CreateKey of hoReg sStudioPath to iCreated
100039>>>            If (iCreated <> 0) Begin
100041>>>                Move cx_RegkeyFailed to iRetval
100042>>>            End
100042>>>>
100042>>>            Else Begin
100043>>>                Move True to bExists
100044>>>            End
100044>>>>
100044>>>        End
100044>>>>
100044>>>
100044>>>        If (bExists = True) Begin
100046>>>            Get OpenKey of hoReg sStudioPath to bOk
100047>>>            If (bOk = True) Begin
100049>>>                Get Create (RefClass(Array)) to hoArray
100050>>>                Get GetSubkeys of hoReg hoArray to iItems
100051>>>                Decrement iItems
100052>>>                Move False to bExists
100053>>>                Set pfAccessRights of hoReg to KEY_READ
100054>>>                // Check if the key already exists:
100054>>>                For i from 0 to iItems
100060>>>>
100060>>>                    Get Value of hoArray i to sKey
100061>>>                    Move (sStudioPath + "\" + sKey) to sKey
100062>>>                    Get OpenKey of hoReg sKey to bOpen
100063>>>                    If (bOpen = True) Begin
100065>>>                        Get ReadString of hoReg CS_Name to sValue
100066>>>                        If (sValue = sProduct) Begin
100068>>>                            Move True to bExists
100069>>>                        End
100069>>>>
100069>>>                    End
100069>>>>
100069>>>                Loop
100070>>>>
100070>>>                Send Destroy of hoArray
100071>>>                If (bExists = False) Begin
100073>>>                    Set pfAccessRights of hoReg to KEY_ALL_ACCESS
100074>>>                    // We need to create the next key number:
100074>>>                    // The studio expect tools menu items to be numbered 1,2,3...n
100074>>>                    Increment iItems
100075>>>                    Increment iItems
100076>>>                    Get CreateKey of hoReg (sStudioPath + "\" + String(iItems)) to iCreated
100077>>>                    If (iCreated = 0) Begin
100079>>>                        Send WriteString of hoReg CS_Name sProduct
100080>>>                        // From DataFlex 16 and up the params for the Studio's Tools menu changed slightly:
100080>>>                        If (sStudioVersion >= "16.0") Begin
100082>>>                            Send WriteString of hoReg CS_Command (sProgramPath + sProgram)
100083>>>                            Send WriteString of hoReg CS_CommandLine (psTag(Self))
100084>>>                        End
100084>>>>
100084>>>                        Else Begin
100085>>>                            Send WriteString of hoReg CS_CommandLine ('"' + sProgramPath + sProgram + ".exe" + '"' * psTag(Self))
100086>>>                            Move CX_InstalledOkVdfUnder16 to iRetval
100087>>>                        End
100087>>>>
100087>>>                        Send WriteDword  of hoReg CS_Separator 1
100088>>>                        Move cx_RegKeyCreated to iRetval
100089>>>                    End
100089>>>>
100089>>>                    Else Begin
100090>>>                        Move cx_RegkeyFailed to iRetval
100091>>>                    End
100091>>>>
100091>>>                End
100091>>>>
100091>>>                Else Begin
100092>>>                    Move cx_RegKeyAlreadyExist to iRetval
100093>>>                End
100093>>>>
100093>>>                Send CloseKey of hoReg
100094>>>            End
100094>>>>
100094>>>        End
100094>>>>
100094>>>
100094>>>        Send Destroy of hoReg
100095>>>        Function_Return iRetval
100096>>>    End_Function
100097>>>
100097>>>    Procedure Page Integer iPageObject
100100>>>        Forward Send Page iPageObject
100102>>>        Set Icon to "ActionAddStudio1.ico"
100103>>>    End_Procedure
100104>>>
100104>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
100105>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
100106>>>    On_Key kCancel       Send KeyAction of oCancel_Btn
100107>>>End_Object
100108>        Use ViewSourceCode.dg
Including file: ViewSourceCode.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ViewSourceCode.dg)
100108>>>Use Windows.pkg
100108>>>Use cRDCButtonDPI.pkg
100108>>>Use cRichEdit.pkg
100108>>>Use seq_chnl.pkg
100108>>>Use vWin32fh.pkg
100108>>>
100108>>>Object oSourceCodeDialog_dg is a ModalPanel
100110>>>    Set Size to 214 395
100111>>>    Set Label to "View Source Code Dialog"
100112>>>    Set piMinSize to 89 211
100113>>>    Set Location to 2 2
100114>>>    Set Border_Style To Border_Thick
100115>>>    Set Locate_Mode to Center_On_Parent
100116>>>
100116>>>    Property String psSourceCode ""
100118>>>    Property Integer piIndent
100120>>>
100120>>>    Object oSourceCode_edt is a cRichEdit
100122>>>        Set Size to 169 373
100123>>>        Set Location to 16 11
100124>>>        Set TextColor to clBlack
100125>>>        Set peAnchors to anAll
100126>>>        Set Label_Row_Offset to 3
100127>>>        Set Label_TextColor to clGreenGreyLight
100128>>>        Set Label_FontItalics to True
100129>>>        Set piFontSize to 200
100130>>>        Set psTypeFace to 'Consolas'
100131>>>
100131>>>        Delegate Set piIndent to (piParagraphIndent(Self))
100133>>>
100133>>>        Procedure DoSaveDocument
100136>>>            String sSourceCode
100136>>>            Boolean bOk bOkToSave bChanged
100136>>>
100136>>>            Move False to bOkToSave
100137>>>            Get pbCanUndo to bChanged
100138>>>            If (bChanged = False) Begin
100140>>>                Procedure_Return
100141>>>            End
100141>>>>
100141>>>
100141>>>            Get psSourceCode to sSourceCode
100142>>>            Send Write sSourceCode
100143>>>            // clear undo buffer on save
100143>>>            // we want undo buffer to only apply to the new document
100143>>>            Send ClearUndoBuffer
100144>>>            Send Info_Box "Changes saved."
100145>>>        End_Procedure
100146>>>
100146>>>        Procedure LoadData
100149>>>            String sSourceCode
100149>>>            Integer iTwips iIndent
100149>>>
100149>>>            Get psSourceCode to sSourceCode
100150>>>            Set Label to sSourceCode
100151>>>            Move 1440 to iTwips
100152>>>            Get piIndent to iIndent
100153>>>            Set piParagraphIndent to (iIndent + (iTwips * 0.2))
100154>>>
100154>>>            Send Read sSourceCode
100155>>>        End_Procedure
100156>>>
100156>>>        On_Key Key_Ctrl+Key_S Send DoSaveDocument
100157>>>        On_Key kCancel Send Cancel
100158>>>    End_Object
100159>>>
100159>>>    Object oCancel_Btn is a cRDCButtonDPI
100161>>>        Set Label    to "&Close"
100162>>>        Set Location to 193 334
100163>>>        Set peAnchors to anBottomRight
100164>>>
100164>>>        Procedure OnClick
100167>>>            Send Close_Panel
100168>>>        End_Procedure
100169>>>
100169>>>    End_Object
100170>>>
100170>>>
100170>>>    Object oFirstRun_btn is a cRDCButtonDPI
100172>>>        Set Location to 193 220
100173>>>        Set Label to "View &Top"
100174>>>        Set peAnchors to anBottomRight
100175>>>
100175>>>        Procedure OnClick
100178>>>            Send Beginning_of_Data to oSourceCode_edt
100179>>>        End_Procedure
100180>>>
100180>>>    End_Object
100181>>>
100181>>>    Object oLatestRun_btn is a cRDCButtonDPI
100183>>>        Set Location to 193 277
100184>>>        Set Label to "View &Bottom"
100185>>>        Set peAnchors to anBottomRight
100186>>>
100186>>>        Procedure OnClick
100189>>>            Send End_of_Data to oSourceCode_edt
100190>>>        End_Procedure
100191>>>
100191>>>    End_Object
100192>>>
100192>>>    // Automatically load data into the grid when activating.
100192>>>    Procedure Activating
100195>>>        Handle ho
100195>>>        Move (oSourceCode_edt(Self)) to ho
100196>>>        Send LoadData    of ho
100197>>>        Send Activate    of ho
100198>>>    End_Procedure
100199>>>
100199>>>    Procedure Page Integer iPageObject
100202>>>        Forward Send Page iPageObject
100204>>>        Set Icon to "ViewSourceCode1.ico"
100205>>>    End_Procedure
100206>>>
100206>>>    // Put a status bar at the bottom of the panel to add a gripper in the lower right corner.
100206>>>    Procedure End_Construct_Object
100209>>>        Integer iStyle iSize iOffset
100209>>>
100209>>>        Forward Send End_Construct_Object
100211>>>
100211>>>        Get Border_Style to iStyle
100212>>>        Move 8 to iOffset
100213>>>        If (iStyle = Border_Thick) Begin
100215>>>            Object oDialogCommandbar is a cCJCommandBarSystem
100217>>>                Object oStatusBar is a cCJStatusBar
100219>>>                    Object oStatusIdle is a cCJStatusBarPane
100221>>>                        Set piId to sbpIDIdlePane
100222>>>                        Set pbStyleStretch to True
100223>>>                    End_Object
100224>>>                End_Object
100225>>>            End_Object
100226>>>
100226>>>            Get Size to iSize
100227>>>            Set Size to (Hi(iSize) + iOffset) (Low(iSize))
100228>>>        End
100228>>>>
100228>>>    End_Procedure
100229>>>
100229>>>    On_Key Key_Alt+Key_T  Send KeyAction of oFirstRun_btn
100230>>>    On_Key Key_Ctrl+Key_T Send KeyAction of oFirstRun_btn
100231>>>    On_Key Key_Alt+Key_B  Send KeyAction of oLatestRun_btn
100232>>>    On_Key Key_Ctrl+Key_B Send KeyAction of oLatestRun_btn
100233>>>    On_Key Key_Alt+Key_C  Send KeyAction of oCancel_Btn
100234>>>End_Object
100235>>>
100235>>>Procedure ActivateSourceCodeDialog String sSourceCode
100238>>>    Handle ho
100238>>>    Boolean bExists
100238>>>
100238>>>    Get vFilePathExists sSourceCode to bExists
100239>>>    If (bExists = False) Begin
100241>>>        Send Info_Box "The file doesn't exist."
100242>>>        Procedure_Return
100243>>>    End
100243>>>>
100243>>>    Move (oSourceCodeDialog_dg(Self)) to ho
100244>>>    Set psSourceCode of ho to sSourceCode
100245>>>    Send Popup of ho
100246>>>End_Procedure
100247>        Use TableDUFCodeGenerator.vw   
Including file: TableDUFCodeGenerator.vw    (C:\Projects\DF20\DbUpdateFramework\AppSrc\TableDUFCodeGenerator.vw)
100247>>>Use Windows.pkg
100247>>>Use DFClient.pkg
100247>>>Use Cursor.pkg
100247>>>Use Batchdd.pkg
100247>>>Use cCJGrid.pkg
100247>>>Use cCJGridColumnRowIndicator.pkg
Including file: cCJGridColumnRowIndicator.pkg    (C:\Program Files\DataFlex 24.0\Pkg\cCJGridColumnRowIndicator.pkg)
100247>>>>>Use cCJGridColumn.pkg
100247>>>>>
100247>>>>>Class cCJGridColumnRowIndicator is a cCJGridColumn
100248>>>>>    
100248>>>>>    Procedure Construct_Object
100250>>>>>        Forward Send Construct_Object
100252>>>>>        
100252>>>>>        Property Integer piImage 0
100253>>>>>        
100253>>>>>        Set psCaption to ""
100254>>>>>        Set piWidth to 20
100255>>>>>        Set pbResizable to False
100256>>>>>        Set pbEditable to False
100257>>>>>        Set pbFocusable to False
100258>>>>>        Set pbAllowDrag to False
100259>>>>>        Set psToolTip to "Row Indicator"
100260>>>>>    End_Procedure
100261>>>>>    
100261>>>>>    Procedure OnCreateColumn
100263>>>>>        Integer iImage
100263>>>>>        Delegate Get AddImage "GridColumnRowIndicator.bmp" 0 to iImage
100265>>>>>        Set piImage to iImage
100266>>>>>    End_Procedure
100267>>>>>    
100267>>>>>    Procedure OnSetDisplayMetrics Handle hoGridItemMetrics Integer iRow String ByRef sValue
100269>>>>>        Integer iImage iFocusedRow
100269>>>>>        Handle hoDataSource
100269>>>>>        
100269>>>>>        Get phoDataSource to hoDataSource
100270>>>>>        Get SelectedRow of hoDataSource to iFocusedRow
100271>>>>>        Move -1 to iImage
100272>>>>>        If (iRow = iFocusedRow) Begin
100274>>>>>            Get piImage to iImage
100275>>>>>            Set ComItemIcon of hoGridItemMetrics to iImage
100276>>>>>        End
100276>>>>>>
100276>>>>>    End_Procedure
100277>>>>>    
100277>>>>>End_Class
100278>>>Use cCJGridColumn.pkg
100278>>>Use dfLine.pkg
100278>>>Use cRDCButton.pkg
100278>>>Use cDbUpdateFunctionLibrary.pkg
100278>>>Use DUFStatusPanel.pkg
100278>>>Use seq_chnl.pkg
100278>>>Use vWin32fh.pkg
100278>>>Use cRDCHeaderGroup.pkg
100278>>>Use cRDCSuggestionIniForm.pkg
100278>>>Use cSQLCheckBox.pkg
100278>>>Use WriteTestProgram.pkg
Including file: WriteTestProgram.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\WriteTestProgram.pkg)
100278>>>>>Use vWin32fh.pkg
100278>>>>>
100278>>>>>Define CS_DUFTestProgram for "DUFInternalUpdateProgram.src"
100278>>>>>
100278>>>>>Function WriteTestProgram String sSourcePackageName String sAppSrcPath Number nSourcePackageVersion Integer iDbVersionTable Integer iDbVersionField Returns Boolean
100281>>>>>    Integer iCh                                                               
100281>>>>>    
100281>>>>>    Get Seq_Open_Output_Channel sSourcePackageName to iCh
100282>>>>>    If (iCh = DF_SEQ_CHANNEL_ERROR) Begin
100284>>>>>        Send Info_Box "No free channel to write output to. Process interrupted" "Error"
100285>>>>>        Function_Return False
100286>>>>>    End  
100286>>>>>>
100286>>>>>    
100286>>>>>    Get vFolderFormat sAppSrcPath to sAppSrcPath
100287>>>>>    
100287>>>>>    Move False to Err
100288>>>>>    Direct_Output channel iCh (sAppSrcPath + CS_DUFTestProgram)
100290>>>>>        Send WriteProgramCode iCh sSourcePackageName nSourcePackageVersion iDbVersionTable iDbVersionField
100291>>>>>    Close_Output channel iCh
100293>>>>>    Send Seq_Release_Channel iCh    
100294>>>>>                                        
100294>>>>>    Function_Return (Err = False)
100295>>>>>End_Function                                   
100296>>>>>
100296>>>>>Procedure WriteProgramCode Integer iCh String sSourcePackageName Number nSourcePackageVersion Integer iDbVersionTable Integer iDbVersionField
100299>>>>>    Writeln channel iCh ("/" + "/ *** DUF Auto-Generated Program - For Internal Usage Only! ***")
100302>>>>>    Writeln channel iCh ("/" + "/ *** Use it to send to a collegue that is working on the same project, ***")
100305>>>>>    Writeln channel iCh ("/" + "/ *** to update his/her database with database changes you have made. ***")
100308>>>>>    Writeln channel iCh (SFormat("#IF (%1@ > 190)",Character(33)))
100311>>>>>    Writeln channel iCh "    CompilerLevelWarning All On"
100314>>>>>    Writeln channel iCh "#ENDIF"
100317>>>>>    Writeln channel iCh "Use cApplication.pkg"
100320>>>>>    Writeln channel iCh "Use cDbUpdateHandler.pkg"
100323>>>>>    Writeln channel iCh 
100325>>>>>    Writeln channel iCh "Object oApplication is a cApplication"
100328>>>>>    Writeln channel iCh "    Set psCompany to 'RDC Tools International'"
100331>>>>>    Writeln channel iCh "    Set psProduct to 'DUF Auto Update Program'"
100334>>>>>    Writeln channel iCh "    Set psProgram to 'Internal use/test of a DUF Update Package'"
100337>>>>>    Writeln channel iCh "    Set psVersion to '19.1'"
100340>>>>>    Writeln channel iCh "End_Object"
100343>>>>>    Writeln channel iCh 
100345>>>>>    Writeln channel iCh 'Get YesNo_Box ("This is a DUF test program written for INTERNAL usage only.\n\nUpdate your DEVELOPMENT DATABASE to version: ' (String(nSourcePackageVersion)) ' now?") to WindowIndex'
100350>>>>>    Writeln channel iCh "If (WindowIndex <> MBR_Yes) Begin"
100353>>>>>    Writeln channel iCh "    Send Exit_Application"
100356>>>>>    Writeln channel iCh "End"
100359>>>>>    Writeln channel iCh 
100361>>>>>    Writeln channel iCh "Object oDbUpdateHandler is a cDbUpdateHandler"
100364>>>>>    Writeln channel iCh "    Set piDbVersionFileNumber  to " iDbVersionTable
100368>>>>>    Writeln channel iCh "    Set piDbVersionFieldNumber to " iDbVersionField
100372>>>>>    Writeln channel iCh "    Set pbAutoCreateDbVersionTable to True"
100375>>>>>    Writeln channel iCh 
100377>>>>>    Writeln channel iCh "    Use " sSourcePackageName
100381>>>>>    Writeln channel iCh 
100383>>>>>    Writeln channel iCh "End_Object"
100386>>>>>    Writeln channel iCh 
100388>>>>>    Writeln channel ich "If (Private.pbDatabaseWasUpdated(ghoDbupdatehandler) = False) Begin"
100391>>>>>    Writeln channel ich "   Send Info_Box 'Nothing to update. (Version number has not changed)'"
100394>>>>>    Writeln channel ich "End"
100397>>>>>    Writeln channel iCh 
100399>>>>>    Writeln channel iCh "Send Exit_Application"
100402>>>>>    Writeln channel iCh ("/" + "/ *** End-Of-Program Code ***")
100405>>>>>
100405>>>>>//    Writeln channel iCh "Object oMainPanel is a BasicPanel"
100405>>>>>//    Writeln channel iCh "    Set Location to 59 173"
100405>>>>>//    Writeln channel iCh "    Set Size to 180 394"
100405>>>>>//    Writeln channel iCh "    Set piMinSize to 180 394"
100405>>>>>//    Writeln channel iCh "    Set Border_Style to Border_Thick"
100405>>>>>//    Writeln channel iCh "    Set Locate_Mode to Center_On_Screen"
100405>>>>>//    Writeln channel iCh "    Set Label to (psProduct(ghoApplication))"
100405>>>>>//    Writeln channel iCh "    Set Maximize_Icon to False"
100405>>>>>//    Writeln channel iCh "    Set peNeighborhood to nhPublic"
100405>>>>>//    Writeln channel iCh "End_Object"
100405>>>>>//    Writeln channel iCh "
100405>>>>>//    Writeln channel iCh "Start_UI oMainPanel
100405>>>>>End_Procedure
100406>>>Use cRDCCommandLinkButton.pkg
Including file: cRDCCommandLinkButton.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cRDCCommandLinkButton.pkg)
100406>>>>>//****************************************************************************
100406>>>>>// $Module type: Package
100406>>>>>// $Module name: cRDCCommandLinkButton.pkg
100406>>>>>//
100406>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
100406>>>>>// Copyright (c) 2018 RDC Tools International
100406>>>>>// E-mail      : support@rdctools.com
100406>>>>>// Web-site    : http://www.rdctools.com
100406>>>>>//
100406>>>>>// Created     : 2018-11-09 @ 17:04 (Military date format - Year-Month-Day)
100406>>>>>//
100406>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
100406>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
100406>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
100406>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
100406>>>>>// in the help folder for more details.
100406>>>>>//
100406>>>>>//****************************************************************************
100406>>>>>Use Windows.pkg
100406>>>>>Use cCommandLinkButton.pkg
100406>>>>>Use Enclient.pkg
100406>>>>>Use errornum.inc
100406>>>>>
100406>>>>>Class cRDCCommandLinkButtonIdleHandler is a cIdleHandler
100407>>>>>    Procedure Construct_Object
100409>>>>>        Forward Send Construct_Object
100411>>>>>
100411>>>>>    End_Procedure
100412>>>>>
100412>>>>>    Procedure OnIdle
100414>>>>>        Delegate Send DoUpdate
100416>>>>>    End_Procedure
100417>>>>>
100417>>>>>End_Class
100418>>>>>
100418>>>>>Class cRDCCommandLinkButton is a cCommandLinkButton
100419>>>>>
100419>>>>>    Procedure Construct_Object
100421>>>>>        Forward Send Construct_Object
100423>>>>>
100423>>>>>        Property Boolean pbAutoEnable True
100424>>>>>
100424>>>>>        Property Boolean pbEnabled True
100425>>>>>
100425>>>>>        Property Handle phoIdleHandler (Create(Self, RefClass(cRDCCommandLinkButtonIdleHandler)))
100426>>>>>
100426>>>>>        Set Border_Style to Border_Normal
100427>>>>>        Set piImageSize to 32
100428>>>>>        Set pbCenterToolTip to True
100429>>>>>
100429>>>>>    End_Procedure
100430>>>>>
100430>>>>>    Procedure End_Construct_Object
100432>>>>>        String sTooltip sStatus_Help
100432>>>>>
100432>>>>>        Forward Send End_Construct_Object
100434>>>>>
100434>>>>>        Get psToolTip   to sTooltip
100435>>>>>        Get Status_Help to sStatus_Help
100436>>>>>        If (sTooltip = "" and sStatus_Help <> "") Begin
100438>>>>>            Set psToolTip to sStatus_Help
100439>>>>>        End
100439>>>>>>
100439>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to (pbAutoEnable(Self))
100440>>>>>    End_Procedure
100441>>>>>
100441>>>>>    Procedure DoUpdate
100443>>>>>        If (pbAutoEnable(Self) = False) Begin
100445>>>>>            Procedure_Return
100446>>>>>        End
100446>>>>>>
100446>>>>>        Set Enabled_State to (IsEnabled(Self))
100447>>>>>    End_Procedure
100448>>>>>
100448>>>>>    Function IsEnabled Returns Boolean
100450>>>>>        Boolean bEnabled
100450>>>>>        Get pbEnabled to bEnabled
100451>>>>>        Function_Return bEnabled
100452>>>>>    End_Function
100453>>>>>
100453>>>>>    // Enable the idle handler timer when the button is activated
100453>>>>>    Procedure Activating
100455>>>>>        Forward Send Activating
100457>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to True
100458>>>>>    End_Procedure
100459>>>>>
100459>>>>>    // Disable the idle handler when the button is deactivated
100459>>>>>    Procedure Deactivating
100461>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to False
100462>>>>>        Forward Send Deactivating
100464>>>>>    End_Procedure
100465>>>>>
100465>>>>>    Procedure Set Color Integer eColor
100467>>>>>        Forward Set Color to clBtnFace
100469>>>>>    End_Procedure
100470>>>>>
100470>>>>>End_Class
100471>>>Use cRDCSlideButton.pkg                                 
Including file: cRDCSlideButton.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cRDCSlideButton.pkg)
100471>>>>>//****************************************************************************
100471>>>>>// $Module type: Package
100471>>>>>// $Module name: cRDCSlideButton.pkg
100471>>>>>//
100471>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
100471>>>>>// Copyright (c) 2018 RDC Tools International
100471>>>>>// E-mail      : support@rdctools.com
100471>>>>>// Web-site    : http://www.rdctools.com
100471>>>>>//
100471>>>>>// Created     : 2018-01-04 @ 16:47 (Military date format - Year-Month-Day)
100471>>>>>//
100471>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
100471>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
100471>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
100471>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
100471>>>>>// in the help folder for more details.
100471>>>>>//
100471>>>>>//****************************************************************************
100471>>>>>Use Windows.pkg
100471>>>>>Use cCommandLinkButton.pkg
100471>>>>>
100471>>>>>
100471>>>>>Enum_List
100471>>>>>    Define CI_RDCSlideButtonSmallImage  for 16
100471>>>>>    Define CI_RDCSlideButtonMediumImage for 24
100471>>>>>End_Enum_List
100471>>>>>
100471>>>>>// Used by the "Page" message below to show
100471>>>>>// a rectangle around ComboForm and Checkbox objects.
100471>>>>>
100471>>>>>Class cRDCSlideButtonImage is a cCommandLinkButton
100472>>>>>    Procedure Construct_Object
100474>>>>>        Forward Send Construct_Object
100476>>>>>
100476>>>>>        Property Handle private.phoParent 0
100477>>>>>
100477>>>>>    End_Procedure
100478>>>>>
100478>>>>>    Procedure Mouse_Up Integer iWindowNumber Integer iPosition
100480>>>>>        Forward Send Mouse_Up iWindowNumber iPosition
100482>>>>>        Send OnChange of (private.phoParent(Self))
100483>>>>>        Send Activate of (private.phoParent(Self))
100484>>>>>    End_Procedure
100485>>>>>
100485>>>>>    Procedure End_Construct_Object
100487>>>>>        Forward Send End_Construct_Object
100489>>>>>    End_Procedure
100490>>>>>
100490>>>>>End_Class
100491>>>>>
100491>>>>>Class cRDCSlideTextbox is a CheckBox
100492>>>>>
100492>>>>>    Procedure Construct_Object
100494>>>>>        Forward Send Construct_Object
100496>>>>>
100496>>>>>        Set Auto_Size_State to True
100497>>>>>    End_Procedure
100498>>>>>
100498>>>>>    Procedure End_Construct_Object
100500>>>>>        Forward Send End_Construct_Object
100502>>>>>    End_Procedure
100503>>>>>
100503>>>>>    Procedure OnChange
100505>>>>>        Delegate Send OnChange
100507>>>>>    End_Procedure
100508>>>>>
100508>>>>>    Procedure Page Integer iState
100510>>>>>        Integer iStyle iRet
100510>>>>>        Handle hWnd
100510>>>>>
100510>>>>>        If (iState = 1) Begin
100512>>>>>            Get Form_Style iStyle to iStyle
100513>>>>>            Set Form_Style 0 to (iStyle ior BS_USERBUTTON)
100514>>>>>            Forward Send Page iState
100516>>>>>            Get Window_Handle to hWnd
100517>>>>>            If (hWnd) Begin
100519>>>>>                Move (SendMessage(hWnd, WM_QUERYUISTATE, 0, 0)) to iRet
100520>>>>>                If (iRet iand UISF_HIDEFOCUS) Begin
100522>>>>>                    Move (UIS_CLEAR + (UISF_HIDEFOCUS * 65536)) to iState
100523>>>>>                    Move (SendMessage(hWnd, WM_UPDATEUISTATE, iState, 0)) to iRet
100524>>>>>                End
100524>>>>>>
100524>>>>>            End
100524>>>>>>
100524>>>>>        End
100524>>>>>>
100524>>>>>        Else Begin
100525>>>>>            Forward Send Page iState
100527>>>>>        End
100527>>>>>>
100527>>>>>    End_Procedure
100528>>>>>
100528>>>>>End_Class
100529>>>>>
100529>>>>>// Intermediate class - don't use.
100529>>>>>Class _cRDCSlideButtonContainer is a Container3d
100530>>>>>
100530>>>>>    Procedure Construct_Object
100532>>>>>        Forward Send Construct_Object
100534>>>>>
100534>>>>>        Property String private.psLabel
100535>>>>>        Property String private.psToolTip
100536>>>>>        Property String private.Status_Help
100537>>>>>        Property Handle private.Label_Object
100538>>>>>
100538>>>>>        Set Border_Style to Border_None
100539>>>>>    End_Procedure
100540>>>>>
100540>>>>>    Procedure End_Construct_Object
100542>>>>>        Forward Send End_Construct_Object
100544>>>>>
100544>>>>>    End_Procedure
100545>>>>>
100545>>>>>    // We support both the "Set Label" & "Set psLabel" interface.
100545>>>>>    Procedure Set psLabel String sLabel
100547>>>>>        Set private.psLabel to sLabel
100548>>>>>        If (private.Label_Object(Self) <> 0) Begin
100550>>>>>            Set Label of (private.Label_Object(Self)) to sLabel
100551>>>>>        End
100551>>>>>>
100551>>>>>    End_Procedure
100552>>>>>
100552>>>>>    Function psLabel Returns String
100554>>>>>        Function_Return (private.psLabel(Self))
100555>>>>>    End_Function
100556>>>>>
100556>>>>>    Procedure Set Label String sLabel
100558>>>>>        Set psLabel to sLabel
100559>>>>>    End_Procedure
100560>>>>>
100560>>>>>    Function Label Returns String
100562>>>>>        Function_Return (private.psLabel(Self))
100563>>>>>    End_Function
100564>>>>>
100564>>>>>    Procedure Set psToolTip String sToolTip
100566>>>>>        Set private.psToolTip to sToolTip
100567>>>>>    End_Procedure
100568>>>>>
100568>>>>>    Function psToolTip Returns String
100570>>>>>        Function_Return (private.psToolTip(Self))
100571>>>>>    End_Function
100572>>>>>
100572>>>>>    Procedure Set Status_Help String sStatusHelp
100574>>>>>        Set private.Status_Help to sStatusHelp
100575>>>>>    End_Procedure
100576>>>>>
100576>>>>>    Function Status_Help Returns String
100578>>>>>        Function_Return (private.Status_Help(Self))
100579>>>>>    End_Function
100580>>>>>
100580>>>>>End_Class
100581>>>>>
100581>>>>>Class cRDCSlideButton is a _cRDCSlideButtonContainer
100582>>>>>
100582>>>>>    Procedure Construct_Object
100584>>>>>        Forward Send Construct_Object
100586>>>>>
100586>>>>>        Property Handle private.phoButton 0
100587>>>>>        Property String private.psImage
100588>>>>>
100588>>>>>        Property Boolean private.Checked_State False
100589>>>>>        Property Boolean private.Auto_Size_State True
100590>>>>>        Property Integer private.piButtonHeight 15
100591>>>>>        Property Integer private.piButtonWidth  14
100592>>>>>        Property Integer private.piButtonLocationOffset -5
100593>>>>>        Property String psToggleOnImage  "ToggleOn.ico"
100594>>>>>        Property String psToggleOffImage "ToggleOff.ico"
100595>>>>>        Property Integer piImageSize CI_RDCSlideButtonMediumImage
100596>>>>>
100596>>>>>        On_Key kSwitch Send Switch_Next_Area
100597>>>>>    End_Procedure
100598>>>>>
100598>>>>>    // We support two syntaxes "Checked_State" and "pbChecked"
100598>>>>>    Procedure Set Checked_State Boolean bState
100600>>>>>        Set private.Checked_State to (not(bState))
100601>>>>>        Send OnChange
100602>>>>>    End_Procedure
100603>>>>>
100603>>>>>    Procedure Set pbChecked Boolean bState
100605>>>>>        Set private.Checked_State to bState
100606>>>>>        Send OnChange
100607>>>>>    End_Procedure
100608>>>>>
100608>>>>>    Function Checked_State Returns Boolean
100610>>>>>        Function_Return (private.Checked_State(Self))
100611>>>>>    End_Function
100612>>>>>
100612>>>>>    Function pbChecked Returns Boolean
100614>>>>>        Function_Return (private.Checked_State(Self))
100615>>>>>    End_Function
100616>>>>>
100616>>>>>    // This adjustment is so that the Studio layout is the same as when the
100616>>>>>    // program has been compiled and run.
100616>>>>>    Procedure Set Location Integer iRowPos Integer iColPos
100618>>>>>        If (iColPos > 4) Begin
100620>>>>>            Move (iColPos -4) to iColPos
100621>>>>>        End
100621>>>>>>
100621>>>>>
100621>>>>>        Forward Set Location to iRowPos iColPos
100623>>>>>    End_Procedure
100624>>>>>
100624>>>>>    // This slight adjustment is needed so the control doesn't
100624>>>>>    // "bump into" an object to the right of it that is located really close.
100624>>>>>    //    Procedure Set Size Integer iHeight Integer iWidth
100624>>>>>    //        If (iWidth > 5) Begin
100624>>>>>    //            Move (iWidth -5) to iWidth
100624>>>>>    //        End
100624>>>>>    //
100624>>>>>    //        Forward Set Size to iHeight iWidth
100624>>>>>    //    End_Procedure
100624>>>>>
100624>>>>>    Procedure OnChange
100626>>>>>        Handle hoButton
100626>>>>>        Boolean bChecked
100626>>>>>        String sImage
100626>>>>>
100626>>>>>        Get private.Checked_State to bChecked
100627>>>>>        Set private.Checked_State to (not(bChecked))
100628>>>>>        Get psCurrentImage to sImage
100629>>>>>        Get private.phoButton to hoButton
100630>>>>>        If (hoButton <> 0) Begin
100632>>>>>            Set psImage of hoButton to sImage
100633>>>>>            If (Desktop <> Self) Begin
100635>>>>>                Send OnChangeEvent
100636>>>>>            End
100636>>>>>>
100636>>>>>        End
100636>>>>>>
100636>>>>>    End_Procedure
100637>>>>>
100637>>>>>    Function psCurrentImage Returns String
100639>>>>>        Boolean bChecked
100639>>>>>        String sImage
100639>>>>>
100639>>>>>        Get private.Checked_State to bChecked
100640>>>>>        If (bChecked = True) Begin
100642>>>>>            Get psToggleOnImage to sImage
100643>>>>>        End
100643>>>>>>
100643>>>>>        Else Begin
100644>>>>>            Get psToggleOffImage to sImage
100645>>>>>        End
100645>>>>>>
100645>>>>>        Function_Return sImage
100646>>>>>    End_Function
100647>>>>>
100647>>>>>    Procedure OnClick
100649>>>>>        Send OnChange
100650>>>>>    End_Procedure
100651>>>>>
100651>>>>>    Procedure OnChangeEvent
100653>>>>>    End_Procedure
100654>>>>>
100654>>>>>    Procedure DoToggle
100656>>>>>        Boolean bChecked
100656>>>>>        Get Checked_State to bChecked
100657>>>>>        Set Checked_State to (not(bChecked))
100658>>>>>    End_Procedure
100659>>>>>
100659>>>>>    Procedure End_Construct_Object
100661>>>>>        Integer iSize iLoc iHeight iWidth iOffset iTextOffset iIconIndex iImageSize
100661>>>>>        Handle ho hoParent
100661>>>>>        String sImage sLabel
100661>>>>>
100661>>>>>        Forward Send End_Construct_Object
100663>>>>>
100663>>>>>        Get piImageSize to iImageSize
100664>>>>>        Case Begin
100664>>>>>            Case (iImageSize = CI_RDCSlideButtonSmallImage)
100666>>>>>                Set private.piButtonHeight         to 14
100667>>>>>                Set private.piButtonWidth          to 14
100668>>>>>                Set private.piButtonLocationOffset to -5
100669>>>>>                Case Break
100670>>>>>            Case (iImageSize = CI_RDCSlideButtonMediumImage)
100673>>>>>                Set private.piButtonHeight         to 16
100674>>>>>                Set private.piButtonWidth          to 20
100675>>>>>                Set private.piButtonLocationOffset to -6
100676>>>>>                Case Break
100677>>>>>        Case End
100677>>>>>
100677>>>>>        Move Self to hoParent
100678>>>>>        Get Label of hoParent to sLabel
100679>>>>>        Get Text_Extent sLabel to iTextOffset
100680>>>>>        Get Size     to iSize
100681>>>>>        Get Location to iLoc
100682>>>>>        Get psCurrentImage to sImage
100683>>>>>        Get private.piButtonHeight to iHeight
100684>>>>>        Get private.piButtonWidth  to iWidth
100685>>>>>        Set Size to (Hi(iSize)) (Low(iSize) + iWidth -7)
100686>>>>>        Get private.piButtonLocationOffset to iOffset
100687>>>>>        Get GetCorrectIconIndex  to iIconIndex
100688>>>>>        Move (iOffset + iIconIndex -1) to iOffset
100689>>>>>
100689>>>>>        Get CreateNamed (RefClass(cRDCSlideButtonImage)) "oRDCSlideButtonImage" to ho
100690>>>>>        Set Size                of ho to iHeight iWidth
100691>>>>>        Set Location            of ho to iOffset 0
100692>>>>>        Set psToolTip           of ho to (private.psToolTip(hoParent))
100693>>>>>        If (private.Status_Help(hoParent) = "") Begin
100695>>>>>            Set Status_Help     of ho to (private.psToolTip(hoParent))
100696>>>>>        End
100696>>>>>>
100696>>>>>        Else Begin
100697>>>>>            Set Status_Help     of ho to (private.Status_Help(hoParent))
100698>>>>>        End
100698>>>>>>
100698>>>>>        Set psImage             of ho to sImage
100699>>>>>        Set pbAutoResizeIcons   of ho to True
100700>>>>>        Set piImageSize         of ho to (piImageSize(Self))
100701>>>>>        //            Set Focus_Mode          of ho to NonFocusable
100701>>>>>        Set private.phoParent   of ho to hoParent
100702>>>>>        Set private.phoButton to ho
100703>>>>>
100703>>>>>        Get CreateNamed (RefClass(cRDCSlideTextbox)) "cRDCSlideTextbox" to ho
100704>>>>>        Set private.Label_Object to ho
100705>>>>>        Set Size                of ho to (Hi(iSize)) (Low(iSize) + iWidth)
100706>>>>>        Set Location            of ho to 2 iWidth
100707>>>>>        Set Label               of ho to sLabel
100708>>>>>        Set Focus_Mode          of ho to NonFocusable
100709>>>>>        Set psToolTip           of ho to (private.psToolTip(Parent(ho)))
100710>>>>>        If (private.Status_Help(hoParent) = "") Begin
100712>>>>>            Set Status_Help     of ho to (private.psToolTip(hoParent))
100713>>>>>        End
100713>>>>>>
100713>>>>>        Else Begin
100714>>>>>            Set Status_Help     of ho to (private.Status_Help(hoParent))
100715>>>>>        End
100715>>>>>>
100715>>>>>
100715>>>>>        //        Get psCurrentImage to sImage
100715>>>>>        //        Set Bitmap of ho to sImage
100715>>>>>        Send OnChangeEvent
100716>>>>>    End_Procedure
100717>>>>>
100717>>>>>    // Returns: DPI setting as an integer.
100717>>>>>    //  Normal DPI setting: iDPI=96  is "Normal setting" 100%
100717>>>>>    //                      iDPI=120 is "Medium setting" 125%
100717>>>>>    //                      iDPI= 144 is "Large setting" 150%
100717>>>>>    Function GetCurrentDPI Returns Integer
100719>>>>>        Handle hDC
100719>>>>>        Integer iPixelsX
100719>>>>>        Move (GetDC(0)) to hDC
100720>>>>>        Move (GetDeviceCaps(hDC, LOGPIXELSX)) to iPixelsX
100721>>>>>        Move (ReleaseDC(0, hDC)) to hDC
100722>>>>>        Function_Return iPixelsX
100723>>>>>    End_Function
100724>>>>>
100724>>>>>    Function GetCorrectIconSize Returns Integer
100726>>>>>        Integer iPixelsX iIndex iSize
100726>>>>>        Integer[] iaSizes
100727>>>>>
100727>>>>>        Move 16 to iaSizes[0]
100728>>>>>        Move 24 to iaSizes[1]
100729>>>>>        Move 32 to iaSizes[2]
100730>>>>>        Move 48 to iaSizes[3]
100731>>>>>        Move 64 to iaSizes[4]
100732>>>>>
100732>>>>>        Get piImageSize to iSize  // the "100%" size
100733>>>>>        Move (SearchArray(iSize,iaSizes)) to iIndex
100734>>>>>        Move (0 max iIndex) to iIndex
100735>>>>>        Get GetCurrentDPI to iPixelsX
100736>>>>>        // Use a Case Statement here. Wherever we jump in we will continue onwards, regardless of whether
100736>>>>>        // we match the remaining Case statements or not. So list our Cases in reverse order, meaning we
100736>>>>>        // will increment iIndex as many times as we need here.
100736>>>>>        Case Begin
100736>>>>>            Case (iPixelsX > 144)
100738>>>>>                Increment iIndex
100739>>>>>            Case (iPixelsX = 144)
100742>>>>>                Increment iIndex
100743>>>>>            Case (iPixelsX = 120)
100746>>>>>                Increment iIndex
100747>>>>>        Case End
100747>>>>>        Move (iIndex min 4) to iIndex
100748>>>>>        Function_Return iaSizes[iIndex]
100749>>>>>    End_Function
100750>>>>>
100750>>>>>    Function GetCorrectIconIndex Returns Integer
100752>>>>>        Integer iPixelsX iIndex iSize
100752>>>>>        Integer[] iaSizes
100753>>>>>
100753>>>>>        Move 16 to iaSizes[0]
100754>>>>>        Move 24 to iaSizes[1]
100755>>>>>        Move 32 to iaSizes[2]
100756>>>>>        Move 48 to iaSizes[3]
100757>>>>>        Move 64 to iaSizes[4]
100758>>>>>
100758>>>>>        Get piImageSize to iSize  // the "100%" size
100759>>>>>        Move (SearchArray(iSize,iaSizes)) to iIndex
100760>>>>>        Move (0 max iIndex) to iIndex
100761>>>>>        Get GetCurrentDPI to iPixelsX
100762>>>>>        // Use a Case Statement here. Wherever we jump in we will continue onwards, regardless of whether
100762>>>>>        // we match the remaining Case statements or not. So list our Cases in reverse order, meaning we
100762>>>>>        // will increment iIndex as many times as we need here.
100762>>>>>        Case Begin
100762>>>>>            Case (iPixelsX > 144)
100764>>>>>                Increment iIndex
100765>>>>>            Case (iPixelsX = 144)
100768>>>>>                Increment iIndex
100769>>>>>            Case (iPixelsX = 120)
100772>>>>>                Increment iIndex
100773>>>>>        Case End
100773>>>>>        Move (iIndex min 4) to iIndex
100774>>>>>        Function_Return iIndex
100775>>>>>    End_Function
100776>>>>>
100776>>>>>End_Class
100777>>>Use cRDCCJSelectionGrid.pkg
Including file: cRDCCJSelectionGrid.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cRDCCJSelectionGrid.pkg)
100777>>>>>//****************************************************************************
100777>>>>>// $Module type: Package
100777>>>>>// $Module name: cRDCCJSelectionGrid.pkg
100777>>>>>//
100777>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
100777>>>>>// Copyright (c) 2018 RDC Tools International
100777>>>>>// E-mail      : support@rdctools.com
100777>>>>>// Web-site    : http://www.rdctools.com
100777>>>>>//
100777>>>>>// Created     : 2018-12-17 @ 08:04 (Military date format - Year-Month-Day)
100777>>>>>//
100777>>>>>// Note        : Grid class that uses a checkbox column for selecting items.
100777>>>>>//
100777>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
100777>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
100777>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
100777>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
100777>>>>>// in the help folder for more details.
100777>>>>>//
100777>>>>>//****************************************************************************
100777>>>>>Use cCJGrid.pkg
100777>>>>>Use cCJGridColumn.pkg
100777>>>>>Use cCJGridColumnRowIndicator.pkg
100777>>>>>Use Cursor.pkg
100777>>>>>Use vWin32fh.pkg
100777>>>>>
100777>>>>>    Define CS_Settings                for "Settings"
100777>>>>>    Define CS_GridFontSize            for "GridFontSize"
100777>>>>>    Define CS_GridRowBackgroundColor  for "GridRowBackgroundColor"
100777>>>>>
100777>>>>>Struct tsSearchResult
100777>>>>>    String sFilename
100777>>>>>    String sAlternateFileName   // 8.3 format
100777>>>>>    DateTime dtCreationDateTime
100777>>>>>    DateTime dtLastAccessDateTime
100777>>>>>    DateTime dtLastWriteDateTime
100777>>>>>    BigInt biFileSize
100777>>>>>    Integer iFileAttributes
100777>>>>>End_Struct
100777>>>>>
100777>>>>>Enum_List
100777>>>>>    Define cx_Select_All
100777>>>>>    Define cx_Select_None
100777>>>>>    Define cx_Select_Invert
100777>>>>>End_Enum_List
100777>>>>>
100777>>>>>Struct tFolderData
100777>>>>>    String sFolderName
100777>>>>>    Boolean bSelected
100777>>>>>End_Struct
100777>>>>>
100777>>>>>// Classes used by the cRDCCJSelectionGrid
100777>>>>>Class cRDCCJToggleSelectMenuItem is a cCJMenuItem
100778>>>>>
100778>>>>>    Procedure Construct_Object
100780>>>>>        Forward Send Construct_Object
100782>>>>>        Set psCaption to "Toggle Current Item"
100783>>>>>        Set psImage to "ToggleOn.ico"
100784>>>>>        Set psShortcut to "Space-Bar"
100785>>>>>    End_Procedure
100786>>>>>
100786>>>>>    Procedure OnExecute Variant vCommandBarControl
100788>>>>>        Forward Send OnExecute vCommandBarControl
100790>>>>>        Send ToggleCurrentItem
100791>>>>>    End_Procedure
100792>>>>>
100792>>>>>End_Class
100793>>>>>
100793>>>>>Class cRDCCJSelectAllMenuItem is a cCJMenuItem
100794>>>>>
100794>>>>>    Procedure Construct_Object
100796>>>>>        Forward Send Construct_Object
100798>>>>>        Set pbControlBeginGroup to True
100799>>>>>        Set psCaption to "Select All"
100800>>>>>        Set psImage to "SelectAll.ico"
100801>>>>>        Set psShortcut to "Ctrl+A"
100802>>>>>    End_Procedure
100803>>>>>
100803>>>>>    Procedure OnExecute Variant vCommandBarControl
100805>>>>>        Forward Send OnExecute vCommandBarControl
100807>>>>>        Set SelectItems to cx_Select_All
100808>>>>>    End_Procedure
100809>>>>>
100809>>>>>End_Class
100810>>>>>
100810>>>>>Class cRDCCJDeSelectAllMenuItem is a cCJMenuItem
100811>>>>>
100811>>>>>    Procedure Construct_Object
100813>>>>>        Forward Send Construct_Object
100815>>>>>        Set psCaption to "Select None"
100816>>>>>        Set psImage to "SelectNone.ico"
100817>>>>>        Set psShortcut to "Ctrl+N"
100818>>>>>    End_Procedure
100819>>>>>
100819>>>>>    Procedure OnExecute Variant vCommandBarControl
100821>>>>>        Forward Send OnExecute vCommandBarControl
100823>>>>>        Set SelectItems to cx_Select_None
100824>>>>>    End_Procedure
100825>>>>>
100825>>>>>End_Class
100826>>>>>
100826>>>>>Class cRDCCJInvertSelectionsMenuItem is a cCJMenuItem
100827>>>>>
100827>>>>>    Procedure Construct_Object
100829>>>>>        Forward Send Construct_Object
100831>>>>>        Set psCaption to "Invert Selection"
100832>>>>>        Set psImage to "SelectInvert.ico"
100833>>>>>        Set psShortcut to "Ctrl+I"
100834>>>>>    End_Procedure
100835>>>>>
100835>>>>>    Procedure OnExecute Variant vCommandBarControl
100837>>>>>        Forward Send OnExecute vCommandBarControl
100839>>>>>        Set SelectItems to cx_Select_Invert
100840>>>>>    End_Procedure
100841>>>>>
100841>>>>>End_Class
100842>>>>>
100842>>>>>Class cRDCCJAddFolderMenuItem is a cCJMenuItem
100843>>>>>
100843>>>>>    Procedure Construct_Object
100845>>>>>        Forward Send Construct_Object
100847>>>>>        Set psCaption to "Add Folder"
100848>>>>>        Set psImage to "AddFolder.ico"
100849>>>>>        Set psShortcut to "Ins"
100850>>>>>    End_Procedure
100851>>>>>
100851>>>>>    Procedure OnExecute Variant vCommandBarControl
100853>>>>>        Forward Send OnExecute vCommandBarControl
100855>>>>>        Send BrowseForFolder
100856>>>>>    End_Procedure
100857>>>>>
100857>>>>>End_Class
100858>>>>>
100858>>>>>Class cRDCCJRemoveItemMenuItem is a cCJMenuItem
100859>>>>>
100859>>>>>    Procedure Construct_Object
100861>>>>>        Forward Send Construct_Object
100863>>>>>        Set psCaption to "Remove From Grid"
100864>>>>>        Set psImage to "ActionDelete.ico"
100865>>>>>        Set psShortcut to "Del"
100866>>>>>    End_Procedure
100867>>>>>
100867>>>>>    Procedure OnExecute Variant vCommandBarControl
100869>>>>>        Forward Send OnExecute vCommandBarControl
100871>>>>>        Send Request_Delete
100872>>>>>    End_Procedure
100873>>>>>
100873>>>>>End_Class
100874>>>>>
100874>>>>>Register_Function pbShowAddFolderMenuItem Returns Boolean
100874>>>>>Register_Function pbShowRemoveFolderMenuItem Returns Boolean
100874>>>>>Register_Function pbShowInvertSelectionsMenuItem Returns Boolean
100874>>>>>
100874>>>>>Class cGridContext_mnu is a cCJContextMenu
100875>>>>>    Procedure Construct_Object
100877>>>>>        Handle hoMenuItem
100877>>>>>        Forward Send Construct_Object
100879>>>>>
100879>>>>>        Get Create (RefClass(cRDCCJToggleSelectMenuItem))      to hoMenuItem
100880>>>>>        Get Create (RefClass(cRDCCJSelectAllMenuItem))         to hoMenuItem
100881>>>>>        Get Create (RefClass(cRDCCJDeSelectAllMenuItem))       to hoMenuItem
100882>>>>>        If (pbShowInvertSelectionsMenuItem(Self) = True) Begin
100884>>>>>            Get Create (RefClass(cRDCCJInvertSelectionsMenuItem))  to hoMenuItem
100885>>>>>        End
100885>>>>>>
100885>>>>>        If (pbShowAddFolderMenuItem(Self) = True) Begin
100887>>>>>            Get Create (RefClass(cRDCCJAddFolderMenuItem))  to hoMenuItem
100888>>>>>            Set pbControlBeginGroup of hoMenuItem to True
100889>>>>>        End
100889>>>>>>
100889>>>>>        If (pbShowRemoveFolderMenuItem(Self) = True) Begin
100891>>>>>            Get Create (RefClass(cRDCCJRemoveItemMenuItem))  to hoMenuItem
100892>>>>>            If (pbShowAddFolderMenuItem(Self) = False) Begin
100894>>>>>                Set pbControlBeginGroup of hoMenuItem to True
100895>>>>>            End
100895>>>>>>
100895>>>>>        End
100895>>>>>>
100895>>>>>    End_Procedure
100896>>>>>
100896>>>>>End_Class
100897>>>>>
100897>>>>>Class cRDCCJSelectionGrid is a cCJGrid
100898>>>>>
100898>>>>>    Procedure Construct_Object
100900>>>>>        Forward Send Construct_Object
100902>>>>>
100902>>>>>        // This must be set manually in the grid column object for the 'data' column (or one of them):
100902>>>>>        Property Handle phoData_Col 0
100903>>>>>        Property Handle phoCheckbox_Col 0
100904>>>>>
100904>>>>>        Property Boolean pbShowAddFolderMenuItem False
100905>>>>>        Property Boolean pbShowRemoveFolderMenuItem False   
100906>>>>>        Property Boolean pbShowInvertSelectionsMenuItem True
100907>>>>>        Property Boolean pbEnableMoveKeys False
100908>>>>>        Property Boolean pbAutoSaveSelections False
100909>>>>>
100909>>>>>        Set pbRestoreLayout to True
100910>>>>>        Set psLayoutSection to (Name(Self) + "_grid")
100911>>>>>        Set psNoItemsText to "No data found..."
100912>>>>>        Set pbHeaderReorders to True
100913>>>>>        Set pbHeaderPrompts to False
100914>>>>>        Set pbHeaderTogglesDirection to True
100915>>>>>        Set pbSelectionEnable to True
100916>>>>>        Set pbAllowInsertRow to False
100917>>>>>        Set pbAllowAppendRow to False
100918>>>>>        Set pbShowRowFocus to True
100919>>>>>        Set pbShowFooter to True
100920>>>>>        Set pbMultipleSelection to True
100921>>>>>        Set pbHotTracking to True
100922>>>>>        Set pbEditOnClick to True
100923>>>>>        Set piLayoutBuild to 4
100924>>>>>        Set Status_Help to "Select with the spacebar"
100925>>>>>        Set pbUseAlternateRowBackgroundColor to True
100926>>>>>        Set peAnchors to anAll
100927>>>>>        // This makes the ticked checkboxes to appear as bold.
100927>>>>>                Set peVisualTheme to xtpGridThemeVisualStudio2012Light
100928>>>>>
100928>>>>>        On_Key Key_Space      Send ToggleCurrentItem
100929>>>>>        On_Key Key_Delete     Send Request_Delete
100930>>>>>        On_Key Key_Insert     Send BrowseForFolder
100931>>>>>        On_Key Key_Ctrl+Key_A Send SelectAll
100932>>>>>        On_Key Key_Ctrl+Key_N Send SelectNone
100933>>>>>        On_Key Key_Ctrl+Key_I Send SelectInvert
100934>>>>>        On_Key kCancel        Send CancelIfPopupObject
100935>>>>>        On_Key Key_Alt+Key_Down_Arrow Send MoveDown
100936>>>>>        On_Key Key_Alt+Key_Up_Arrow   Send MoveUp
100937>>>>>    End_Procedure
100938>>>>>
100938>>>>>    Procedure MoveUp
100940>>>>>        tDataSourceRow[] TheData
100940>>>>>        tDataSourceRow[] TheData
100941>>>>>        tDataSourceRow TheRow
100941>>>>>        tDataSourceRow TheRow
100941>>>>>        Handle hDataSource
100941>>>>>        Integer iCurrentRow
100941>>>>>
100941>>>>>        If (pbEnableMoveKeys(Self) = False) Begin
100943>>>>>            Procedure_Return
100944>>>>>        End
100944>>>>>>
100944>>>>>        Get phoDataSource to hDataSource
100945>>>>>        Get DataSource of hDataSource to TheData
100946>>>>>        Get SelectedRow of hDataSource to iCurrentRow
100947>>>>>        If (iCurrentRow > 0) Begin
100949>>>>>            Move TheData[iCurrentRow - 1] to TheRow
100950>>>>>            Move TheData[iCurrentRow] to TheData[iCurrentRow - 1]
100951>>>>>            Move TheRow to TheData[iCurrentRow]
100952>>>>>            Send ReInitializeData TheData True
100953>>>>>            Send MoveToRow (iCurrentRow - 1)
100954>>>>>        End
100954>>>>>>
100954>>>>>    End_Procedure
100955>>>>>
100955>>>>>    Procedure MoveDown
100957>>>>>        tDataSourceRow[] TheData
100957>>>>>        tDataSourceRow[] TheData
100958>>>>>        tDataSourceRow TheRow
100958>>>>>        tDataSourceRow TheRow
100958>>>>>        Handle hDataSource
100958>>>>>        Integer iCurrentRow
100958>>>>>
100958>>>>>        If (pbEnableMoveKeys(Self) = False) Begin
100960>>>>>            Procedure_Return
100961>>>>>        End
100961>>>>>>
100961>>>>>        Get phoDataSource to hDataSource
100962>>>>>        Get DataSource of hDataSource to TheData
100963>>>>>        Get SelectedRow of hDataSource to iCurrentRow
100964>>>>>        If ((iCurrentRow + 1) < SizeOfArray(TheData)) Begin
100966>>>>>            Move TheData[iCurrentRow] to TheRow
100967>>>>>            Move TheData[iCurrentRow + 1] to TheData[iCurrentRow]
100968>>>>>            Move TheRow to TheData[iCurrentRow + 1]
100969>>>>>            Send ReInitializeData TheData True
100970>>>>>            Send MoveToRow (iCurrentRow + 1)
100971>>>>>        End
100971>>>>>>
100971>>>>>    End_Procedure
100972>>>>>
100972>>>>>    Procedure RefreshSelectionUpdate
100974>>>>>    End_Procedure                   
100975>>>>>    
100975>>>>>    Procedure CancelIfPopupObject
100977>>>>>        Boolean bIsInPopupObject
100977>>>>>        Delegate Get Popup_State to bIsInPopupObject
100979>>>>>        If (bIsInPopupObject = True) Begin
100981>>>>>            Send Close_Panel
100982>>>>>        End
100982>>>>>>
100982>>>>>    End_Procedure
100983>>>>>
100983>>>>>    Procedure End_Construct_Object
100985>>>>>        String sColor
100985>>>>>        Handle hoContextMenu
100985>>>>>        Forward Send End_Construct_Object
100987>>>>>
100987>>>>>        Object oCheckbox_col is a cCJGridColumn
100989>>>>>            Set phoCheckbox_Col to Self
100990>>>>>            Set piWidth to 60
100991>>>>>            Set pbResizable to False
100992>>>>>            Set psCaption to "Select"
100993>>>>>            Set psToolTip to "Select an item by using the space bar or click with the mouse."
100994>>>>>            Set pbCheckbox to True
100995>>>>>            Set peHeaderAlignment to xtpAlignmentCenter
100996>>>>>            Set peFooterAlignment to xtpAlignmentCenter
100997>>>>>            Set peDataType to Mask_Numeric_Window
100998>>>>>        End_Object
100999>>>>>
100999>>>>>        If (ghoApplication <> 0) Begin
101001>>>>>        Get ReadString of ghoApplication CS_Settings CS_GridRowBackgroundColor clGreenGreyLight to sColor
101002>>>>>        End
101002>>>>>>
101002>>>>>        If (sColor = "clBlueGreyLight") Begin
101004>>>>>            Move "clGreenGrey" to sColor
101005>>>>>        End
101005>>>>>>
101005>>>>>        Set piSelectedRowBackColor to sColor
101006>>>>>        Set piHighlightBackColor   to sColor
101007>>>>>
101007>>>>>        Get Create (RefClass(cGridContext_mnu)) to hoContextMenu
101008>>>>>        Set phoContextMenu to hoContextMenu
101009>>>>>    End_Procedure
101010>>>>>
101010>>>>>    Procedure OnCreateGridControl
101012>>>>>        Handle hoObject
101012>>>>>        Integer iToolTipStyle
101012>>>>>        Boolean bIsBalloonStyleSupported
101012>>>>>
101012>>>>>        Forward Send OnCreateGridControl
101014>>>>>
101014>>>>>        Get phoToolTipContext to hoObject
101015>>>>>        If (hoObject <> 0) Begin
101017>>>>>            Move xtpToolTipStandard to iToolTipStyle
101018>>>>>            // Baloon tooltip style requires IE 5.0 or later, so check if installed.
101018>>>>>            // The ComShowTitleAndDescription also requires IE 5.0.
101018>>>>>            Get ComIsBalloonStyleSupported of hoObject to bIsBalloonStyleSupported
101019>>>>>            If (bIsBalloonStyleSupported = True) Begin
101021>>>>>                Send ComShowTitleAndDescription of hoObject True xtpToolTipIconInfo
101022>>>>>            End
101022>>>>>>
101022>>>>>            Set ComStyle             of hoObject to iToolTipStyle
101023>>>>>            Set ComShowOfficeBorder  of hoObject to True
101024>>>>>            Set ComShowShadow        of hoObject to True
101025>>>>>            // Set the max width for a tooltip. 250 just seems to be a good
101025>>>>>            // compromise. After 250 pixels the text will wrap to the next line automatically.
101025>>>>>            Set ComMaxTipWidth       of hoObject to 250 // In pixels
101026>>>>>        End
101026>>>>>>
101026>>>>>        Send DoChangeFontSize
101027>>>>>    End_Procedure
101028>>>>>
101028>>>>>    Procedure AddItem String sDataValue
101030>>>>>        Handle hoDataSource
101030>>>>>        tDataSourceRow[] TheData
101030>>>>>        tDataSourceRow[] TheData
101031>>>>>        tsSearchResult[] asFolderArray
101031>>>>>        tsSearchResult[] asFolderArray
101032>>>>>        Integer iSize iData_Col iCheckbox_Col
101032>>>>>
101032>>>>>        If (not(IsComObjectCreated(Self))) Begin
101034>>>>>            Procedure_Return
101035>>>>>        End
101035>>>>>>
101035>>>>>
101035>>>>>        Get piColumnId of (phoData_Col(Self)) to iData_Col
101036>>>>>        Get piColumnId of (phoCheckbox_Col(Self)) to iCheckbox_Col
101037>>>>>        Get phoDataSource to hoDataSource
101038>>>>>        Get DataSource of hoDataSource to TheData
101039>>>>>        Move (SizeOfArray(TheData)) to iSize
101040>>>>>        Move sDataValue to TheData[iSize].sValue[iData_Col]
101041>>>>>        Move False      to TheData[iSize].sValue[iCheckbox_Col]
101042>>>>>
101042>>>>>        Send ReInitializeData TheData False
101043>>>>>        Send MoveToLastRow
101044>>>>>    End_Procedure
101045>>>>>
101045>>>>>    Procedure BrowseForFolder
101047>>>>>        String sFolderName
101047>>>>>        Get vSHBrowseForFolder "Select Folder to Add" to sFolderName
101048>>>>>        If (sFolderName <> "") Begin
101050>>>>>            Send AddItem sFolderName
101051>>>>>        End
101051>>>>>>
101051>>>>>    End_Procedure
101052>>>>>
101052>>>>>    // We don't want columns to be editable. But setting
101052>>>>>    // pbEditable = False or pbReadOnly makes it very hard to read,
101052>>>>>    // and makes it impossible to select the checkbox column with the mouse.
101052>>>>>    // So we disable those columns instead.
101052>>>>>    Function CanEditColumn Integer iCol Returns Boolean
101054>>>>>        Handle hoCol
101054>>>>>        Boolean bRetval
101054>>>>>
101054>>>>>        Forward Get CanEditColumn iCol to bRetval
101056>>>>>
101056>>>>>        Get piColumnId of (phoCheckbox_Col(Self)) to hoCol
101057>>>>>        If (iCol <> hoCol) Begin
101059>>>>>            Move False to bRetval
101060>>>>>        End
101060>>>>>>
101060>>>>>        Else Begin
101061>>>>>            Move True to bRetval
101062>>>>>        End
101062>>>>>>
101062>>>>>
101062>>>>>        Function_Return bRetval
101063>>>>>    End_Function
101064>>>>>
101064>>>>>    Procedure Request_Clear_All
101066>>>>>        tDataSourceRow[] EmptyData
101066>>>>>        tDataSourceRow[] EmptyData
101067>>>>>        Handle hoGrid hoDataSource
101067>>>>>
101067>>>>>        Move Self  to hoGrid
101068>>>>>        If (IsComObjectCreated(hoGrid)) Begin
101070>>>>>            Get phoDataSource of hoGrid to hoDataSource
101071>>>>>            Send InitializeData of hoGrid EmptyData
101072>>>>>            Send DoSetCheckboxFooterText
101073>>>>>        End
101073>>>>>>
101073>>>>>    End_Procedure
101074>>>>>
101074>>>>>    // Set checkboxes of the first column as selected.
101074>>>>>    // iState can be one of the following:
101074>>>>>    // cx_Select_All, cx_Select_None or cx_Select_Invert
101074>>>>>    Procedure Set SelectItems Integer iState
101076>>>>>        Integer iCount iSize iCheckbox_Col
101076>>>>>        Boolean bChecked
101076>>>>>        Handle hoDataSource hoCheckBox_Col
101076>>>>>        tDataSourceRow[] TheData
101076>>>>>        tDataSourceRow[] TheData
101077>>>>>        
101077>>>>>        Get phoCheckbox_Col to hoCheckBox_Col
101078>>>>>        If (hoCheckBox_Col = 0) Begin
101080>>>>>            Procedure_Return
101081>>>>>        End                 
101081>>>>>>
101081>>>>>        
101081>>>>>        Get piColumnId of (phoCheckbox_Col(Self)) to iCheckbox_Col
101082>>>>>        Get phoDataSource               to hoDataSource
101083>>>>>        Get DataSource of hoDataSource  to TheData
101084>>>>>        Move (SizeOfArray(TheData))     to iSize
101085>>>>>        Decrement iSize
101086>>>>>        For iCount from 0 to iSize
101092>>>>>>
101092>>>>>            Case Begin
101092>>>>>                Case (iState = cx_Select_All)
101094>>>>>                    Move True to TheData[iCount].sValue[iCheckbox_Col]
101095>>>>>                    Case Break
101096>>>>>                Case (iState = cx_Select_None)
101099>>>>>                    Move False to TheData[iCount].sValue[iCheckbox_Col]
101100>>>>>                    Case Break
101101>>>>>                Case (iState = cx_Select_Invert)
101104>>>>>                    Move TheData[iCount].sValue[iCheckbox_Col] to bChecked
101105>>>>>                    Move (not(bChecked)) to TheData[iCount].sValue[iCheckbox_Col]
101106>>>>>                    Case Break
101107>>>>>            Case End
101107>>>>>        Loop
101108>>>>>>
101108>>>>>
101108>>>>>        Send ReInitializeData TheData False
101109>>>>>        Send DoSetCheckboxFooterText
101110>>>>>    End_Procedure
101111>>>>>
101111>>>>>    // Returns a string array with selected values for the data column (phoData_Col).
101111>>>>>    Function SelectedItems Returns String[]
101113>>>>>        Integer iCount iSize iCheckbox_Col iData_Col
101113>>>>>        String[] asDataArray
101114>>>>>        Handle hoDataSource
101114>>>>>        tDataSourceRow[] TheData
101114>>>>>        tDataSourceRow[] TheData
101115>>>>>        Boolean bSelected
101115>>>>>
101115>>>>>        Get piColumnId of (phoData_Col(Self)) to iData_Col
101116>>>>>        Get piColumnId of oCheckbox_Col to iCheckbox_Col
101117>>>>>
101117>>>>>        Get phoDataSource to hoDataSource
101118>>>>>        Get DataSource of hoDataSource to TheData
101119>>>>>        Move (SizeOfArray(TheData)) to iSize
101120>>>>>        Decrement iSize
101121>>>>>
101121>>>>>        For iCount from 0 to iSize
101127>>>>>>
101127>>>>>            Move TheData[iCount].sValue[iCheckbox_Col] to bSelected
101128>>>>>            If (bSelected = True) Begin
101130>>>>>                Move TheData[iCount].sValue[iData_Col] to asDataArray[SizeOfArray(asDataArray)]
101131>>>>>            End
101131>>>>>>
101131>>>>>        Loop
101132>>>>>>
101132>>>>>
101132>>>>>        Function_Return asDataArray
101133>>>>>    End_Function
101134>>>>>
101134>>>>>    // Returns a string array with *all* values for the data column (phoData_Col).
101134>>>>>    Function AllItems Returns tFolderData[]
101136>>>>>        Integer iCount iSize iCheckbox_Col iData_Col iItem
101136>>>>>        tFolderData[] asDataArray
101136>>>>>        tFolderData[] asDataArray
101137>>>>>        Handle hoDataSource
101137>>>>>        tDataSourceRow[] TheData
101137>>>>>        tDataSourceRow[] TheData
101138>>>>>        Boolean bSelected
101138>>>>>
101138>>>>>        Get piColumnId of (phoData_Col(Self)) to iData_Col
101139>>>>>        Get piColumnId of oCheckbox_Col to iCheckbox_Col
101140>>>>>
101140>>>>>        Get phoDataSource to hoDataSource
101141>>>>>        Get DataSource of hoDataSource to TheData
101142>>>>>        Move (SizeOfArray(TheData)) to iSize
101143>>>>>        Decrement iSize
101144>>>>>
101144>>>>>        For iCount from 0 to iSize                                
101150>>>>>>
101150>>>>>            Move (SizeOfArray(asDataArray)) to iItem
101151>>>>>            Move TheData[iCount].sValue[iCheckbox_Col] to bSelected
101152>>>>>            Move bSelected                         to asDataArray[iItem].bSelected
101153>>>>>            Move TheData[iCount].sValue[iData_Col] to asDataArray[iItem].sFolderName
101154>>>>>        Loop
101155>>>>>>
101155>>>>>
101155>>>>>        Function_Return asDataArray
101156>>>>>    End_Function
101157>>>>>
101157>>>>>    Procedure SelectAll
101159>>>>>        Set SelectItems to cx_Select_All
101160>>>>>    End_Procedure
101161>>>>>
101161>>>>>    Procedure SelectNone
101163>>>>>        Set SelectItems to cx_Select_None
101164>>>>>    End_Procedure
101165>>>>>
101165>>>>>    Procedure SelectInvert
101167>>>>>        Set SelectItems to cx_Select_Invert
101168>>>>>    End_Procedure
101169>>>>>
101169>>>>>    // Returns number of items.
101169>>>>>    Function ItemCount Returns Integer
101171>>>>>        Integer iItems
101171>>>>>        Handle hoDataSource
101171>>>>>        tDataSourceRow[] TheData
101171>>>>>        tDataSourceRow[] TheData
101172>>>>>
101172>>>>>        Get phoDataSource to hoDataSource
101173>>>>>        Get DataSource of hoDataSource to TheData
101174>>>>>        Move (SizeOfArray(TheData)) to iItems
101175>>>>>
101175>>>>>        Function_Return iItems
101176>>>>>    End_Function
101177>>>>>
101177>>>>>    // Returns number of checked items.
101177>>>>>    Function CheckedItems Returns Integer
101179>>>>>        Integer iCount iItems iCheckbox_Col iRetval
101179>>>>>        Handle hoDataSource hoCheckbox_Col
101179>>>>>        tDataSourceRow[] TheData
101179>>>>>        tDataSourceRow[] TheData
101180>>>>>        Boolean bChecked
101180>>>>>
101180>>>>>        Get phoCheckbox_Col to hoCheckbox_Col
101181>>>>>        If (hoCheckbox_Col = 0) Begin
101183>>>>>            Procedure_Return
101184>>>>>        End
101184>>>>>>
101184>>>>>        Get piColumnId of hoCheckbox_Col to iCheckbox_Col
101185>>>>>        Get phoDataSource to hoDataSource
101186>>>>>        Get DataSource of hoDataSource to TheData
101187>>>>>        Move (SizeOfArray(TheData)) to iItems
101188>>>>>        Decrement iItems
101189>>>>>
101189>>>>>        For iCount from 0 to iItems
101195>>>>>>
101195>>>>>            Move TheData[iCount].sValue[iCheckbox_Col] to bChecked
101196>>>>>            If (bChecked = True) Begin
101198>>>>>                Increment iRetval
101199>>>>>            End
101199>>>>>>
101199>>>>>        Loop
101200>>>>>>
101200>>>>>
101200>>>>>        Function_Return iRetval
101201>>>>>    End_Function
101202>>>>>
101202>>>>>    // Toggles the current row on/off (the checkbox)
101202>>>>>    Procedure ToggleCurrentItem
101204>>>>>        Boolean bChecked
101204>>>>>        Integer iCol
101204>>>>>        Handle hoCol hoCheckbox_Col
101204>>>>>
101204>>>>>        Get phoCheckbox_Col to hoCheckbox_Col
101205>>>>>        If (hoCheckbox_Col = 0) Begin
101207>>>>>            Procedure_Return
101208>>>>>        End
101208>>>>>>
101208>>>>>        Get piColumnId of hoCheckbox_Col to iCol
101209>>>>>        Get ColumnObject iCol   to hoCol
101210>>>>>        Get SelectedRowValue    of hoCol to bChecked
101211>>>>>        Send UpdateCurrentValue of hoCol (not(bChecked))
101212>>>>>        Send Request_Save
101213>>>>>        Send DoSetCheckboxFooterText
101214>>>>>    End_Procedure
101215>>>>>
101215>>>>>    Procedure OnComMouseUp Short llButton Short llShift Integer llx Integer lly
101217>>>>>        Forward Send OnComMouseUp llButton llShift llx lly
101219>>>>>        Send Request_Save
101220>>>>>        Send DoSetCheckboxFooterText
101221>>>>>    End_Procedure
101222>>>>>
101222>>>>>    Procedure DoSetCheckboxFooterText
101224>>>>>        Integer iCol iSelected iItems
101224>>>>>        Handle hoCol hoCheckbox_Col
101224>>>>>
101224>>>>>        If ((phoData_Col(Self) = 0)) Begin
101226>>>>>            Move 1 to iCol
101227>>>>>        End
101227>>>>>>
101227>>>>>        Else Begin
101228>>>>>            Get piColumnId of (phoData_Col(Self)) to iCol
101229>>>>>        End
101229>>>>>>
101229>>>>>        Get ItemCount to iItems
101230>>>>>        Get ColumnObject iCol to hoCol
101231>>>>>        Get CheckedItems to iSelected
101232>>>>>        Set psFooterText of hoCol  to ("Selected:" * String(iSelected) * "of" * String(iItems))
101233>>>>>    End_Procedure
101234>>>>>
101234>>>>>    Procedure DoChangeFontSize
101236>>>>>        Handle hoFont hoPaintManager
101236>>>>>        Variant vFont
101236>>>>>        String sFont sFontSize
101236>>>>>        Boolean bCreated
101236>>>>>        Integer iVal
101236>>>>>
101236>>>>>        Get IsComObjectCreated to bCreated  // When program is started, grid object isn't created yet.
101237>>>>>        If (bCreated = False) Begin
101239>>>>>            Procedure_Return
101240>>>>>        End
101240>>>>>>
101240>>>>>
101240>>>>>        Get phoReportPaintManager to hoPaintManager
101241>>>>>        Get Create (RefClass(cComStdFont)) to hoFont  // Create a font object
101242>>>>>        Get ComTextFont of hoPaintManager to vFont    // Bind the font object to the Grid's text font
101243>>>>>        Set pvComObject of hoFont to vFont            // Connect DataFlex object with com object
101244>>>>>
101244>>>>>        Get ReadString of ghoApplication CS_Settings CS_GridFontSize 8 to iVal
101245>>>>>        Set ComSize of hoFont to iVal
101246>>>>>        Send ComRedraw
101247>>>>>        Send Destroy to hoFont                        // Destroy the font object (releases memory)
101248>>>>>    End_Procedure
101249>>>>>
101249>>>>>    // Augment to load data to the grid. Is called automatically
101249>>>>>    // from procedure Activating
101249>>>>>    Procedure LoadData
101251>>>>>    End_Procedure
101252>>>>>
101252>>>>>    // Automatically load data into the grid when activating.
101252>>>>>    Procedure Activating
101254>>>>>        Send Cursor_Wait of Cursor_Control
101255>>>>>        Send LoadData                       
101256>>>>>        Send DoChangeFontSize      
101257>>>>>        Send Cursor_Ready of Cursor_Control
101258>>>>>    End_Procedure
101259>>>>>
101259>>>>>    Procedure ScaleFont Integer iDirection    // from control + mouse wheel in container object
101261>>>>>        Integer iSize jSize kSize iSup iInf iDef
101261>>>>>        Handle hoPaintManager hoFont
101261>>>>>        Variant vFont
101261>>>>>        
101261>>>>>        Move 3 to iInf      //max size
101262>>>>>        Move 18 to iSup     //min size
101263>>>>>        Move 8 to iDef      //default
101264>>>>>        Boolean blimite
101264>>>>>        Get phoReportPaintManager to hoPaintManager
101265>>>>>        If (IsComObjectCreated (hoPaintManager) = False) Begin
101267>>>>>            Procedure_Return
101268>>>>>        End
101268>>>>>>
101268>>>>>        Get Create (RefClass(cComStdFont)) to hoFont
101269>>>>>        Get ComTextFont of hoPaintManager to vFont
101270>>>>>        Set pvComObject of hoFont to vFont
101271>>>>>        If (iDirection = 0) Begin
101273>>>>>            Set ComSize of hoFont to iDef
101274>>>>>        End
101274>>>>>>
101274>>>>>        Else Begin
101275>>>>>           Get ComSize of hoFont to iSize
101276>>>>>           Move iSize to jSize
101277>>>>>           Repeat
101277>>>>>>
101277>>>>>                Move (If(iDirection > 0, jSize + 1, jSize - 1)) to jSize
101278>>>>>                Move (If(iDirection > 0, If(jSize > iSup, True, False), If(jSize < iInf, True, False))) to blimite
101279>>>>>                If (not(blimite)) Begin       
101281>>>>>                   Set ComSize of hoFont to jSize
101282>>>>>                   Get ComSize of hoFont to kSize
101283>>>>>                End
101283>>>>>>
101283>>>>>            Until (iSize <> kSize or blimite)
101285>>>>>        End
101285>>>>>>
101285>>>>>        Send Destroy to hoFont 
101286>>>>>        Send ComRedraw  
101287>>>>>        Send WriteString of ghoApplication CS_Settings CS_GridFontSize iSize
101288>>>>>    End_Procedure 
101289>>>>>
101289>>>>>    Procedure Destroy
101291>>>>>        String sHomePath sFolderName sDefaultFolders
101291>>>>>        String[] asNoFolderList asStartFolder asFolderArray asDefaultFolders
101295>>>>>        Handle hoDataSource
101295>>>>>        tDataSourceRow[] TheData
101295>>>>>        tDataSourceRow[] TheData
101296>>>>>        Integer iSize iRow iCount iFolderCol iCheckBoxCol iDefaultFolders iFolder
101296>>>>>        Boolean bChecked bAutoSaveSelections
101296>>>>>
101296>>>>>        Get pbAutoSaveSelections to bAutoSaveSelections
101297>>>>>        If (not(IsComObjectCreated(Self))) Begin
101299>>>>>            Move False to bAutoSaveSelections // Can't save
101300>>>>>        End
101300>>>>>>
101300>>>>>        Get psWorkspaceHomePath of ghoApplication to sHomePath
101301>>>>>        If (sHomePath = "") Begin
101303>>>>>            Move False to bAutoSaveSelections // Can't save
101304>>>>>        End
101304>>>>>>
101304>>>>>            
101304>>>>>        If (bAutoSaveSelections = True) Begin
101306>>>>>            Send Cursor_Wait of Cursor_Control
101307>>>>>            Get phoDataSource to hoDataSource
101308>>>>>            Get DataSource of hoDataSource to TheData
101309>>>>>            Get piColumnId of (phoData_Col(Self))     to iFolderCol
101310>>>>>            Get piColumnId of (phoCheckbox_Col(Self)) to iCheckBoxCol
101311>>>>>            Move (SizeOfArray(TheData)) to iSize
101312>>>>>            Decrement iSize
101313>>>>>            Move 0 to iRow
101314>>>>>
101314>>>>>            For iCount from 0 to iSize
101320>>>>>>
101320>>>>>                Move TheData[iCount].sValue[iFolderCol]   to sFolderName
101321>>>>>                Move TheData[iCount].sValue[iCheckBoxCol] to bChecked
101322>>>>>                If (bChecked = True) Begin
101324>>>>>                    Move sFolderName to asFolderArray[iRow]
101325>>>>>                    Increment iRow
101326>>>>>                End
101326>>>>>>
101326>>>>>            Loop                  
101327>>>>>>
101327>>>>>            If (SizeOfArray(asFolderArray)) Begin
101329>>>>>                
101329>>>>>            End
101329>>>>>>
101329>>>>>            Send Cursor_Ready of Cursor_Control
101330>>>>>        End
101330>>>>>>
101330>>>>>            
101330>>>>>        Forward Send Destroy
101332>>>>>    End_Procedure
101333>>>>>    
101333>>>>>End_Class
101334>>>Use cRDCForm.pkg
101334>>>
101334>>>Enum_List
101334>>>    Define GenerateOK
101334>>>    Define GenerateUserCancel
101334>>>    Define GenerateError
101334>>>    Define GenerateChannelError
101334>>>    Define GenerateUserInputError
101334>>>    Define GenerateOpenTableError
101334>>>End_Enum_List
101334>>>
101334>>>Struct tGeneratorRow
101334>>>    Handle hTable
101334>>>    String sLogicalName
101334>>>    String sRootName
101334>>>    String sDisplayName
101334>>>    Boolean bIsAlias
101334>>>    Boolean bSelected
101334>>>End_Struct
101334>>>
101334>>>Activate_View Activate_oTableDUFCodeGenerator for oTableDUFCodeGenerator
101344>>>>
101344>>>Object oTableDUFCodeGenerator is a dbView
101346>>>    Set Size to 328 501
101347>>>    Set Label to "Generator"
101348>>>    Set Border_Style to Border_Thick
101349>>>    Set pbAcceptDropFiles to True
101350>>>    Set pbAutoActivate to True
101351>>>
101351>>>    Set phoTableDUFCodeGenerator_vw of ghoApplication to Self
101352>>>
101352>>>    Property String psOrgOpenPath
101354>>>    Property Handle phtable
101356>>>    Property String psTableName
101358>>>    Property Integer piDbVersionFileNumber  -1
101360>>>    Property Integer piDbVersionFieldNumber -1
101362>>>    Property Number pnSourcePackageVersion -1
101364>>>    
101364>>>    // Set psOrgOpenPath at startup
101364>>>    Procedure StartUp
101367>>>        String sOrgOpenPath sDataPath
101367>>>        Get_Attribute DF_OPEN_PATH to sOrgOpenPath
101370>>>        // First remove the current Data folder path
101370>>>        Get PathAtIndex of (phoWorkspace(ghoApplication)) sOrgOpenPath 1 to sDataPath
101371>>>        Move (Replace(sDataPath, sOrgOpenPath, "")) to sOrgOpenPath
101372>>>        If (Left(sOrgOpenPath, 2) = "\;") Begin
101374>>>            Move (Replace("\;", sOrgOpenPath, "")) to sOrgOpenPath
101375>>>        End
101375>>>>
101375>>>        Set psOrgOpenPath to sOrgOpenPath
101376>>>    End_Procedure
101377>>>    Send StartUp
101378>>>
101378>>>    Object oFromFilelist_grp is a cRDCHeaderGroup
101380>>>        Set Size to 50 473
101381>>>        Set Location to 8 15
101382>>>        Set pbAcceptDropFiles to True
101383>>>        Set psImage to "FolderLeft1.ico"
101384>>>        Set Label to "Select FROM Filelist.cfg"
101385>>>        Set psNote to "The development/latest version of the database"   
101386>>>        Set psToolTip to "Select the Filelist.cfg for your development database. This is a suggestion form. So if used before - start typing what you're looking for."
101387>>>
101387>>>        Object oFilelistPath_fm is a cRDCSuggestionIniForm
101389>>>            Set Size to 12 424
101390>>>            Set Location to 29 29
101391>>>            Set Label_Col_Offset to 0
101392>>>            Set Label_Row_Offset to 1
101393>>>            Set Label_Justification_Mode to JMode_Top
101394>>>            Set Prompt_Button_Mode to PB_PromptOn
101395>>>            Set peAnchors to anTopLeftRight
101396>>>            Set psToolTip to "Select the FROM database Filelist.cfg. This should be the development workspace Data folder's Filelist.cfg"
101397>>>            Set Prompt_Object to Self
101398>>>
101398>>>            Procedure Prompt
101401>>>                String sFileName sPath sFileMask sRetval
101401>>>
101401>>>                Get Value to sFileName
101402>>>                Get ParseFolderName sFileName to sPath
101403>>>                Move "Filelist.cfg files (*.cfg)|*.cfg" to sFileMask
101404>>>                Get vSelect_File sFileMask "Please select a Filelist.cfg file" sPath to sRetval
101405>>>                If (sRetval <> "") Begin
101407>>>                    Set Value to sRetval
101408>>>                End
101408>>>>
101408>>>            End_Procedure
101409>>>
101409>>>            Procedure OnChange
101412>>>                String sFileList
101412>>>                Boolean bOK bExists bCfgFile bHasRecords
101412>>>                Handle hTable
101412>>>                Number nVersionNumber
101412>>>
101412>>>                Move 0 to nVersionNumber
101413>>>                Get Value to sFileList
101414>>>                Get vFilePathExists sFileList to bExists
101415>>>                Move (Lowercase(sFileList) contains ".cfg") to bCfgFile
101416>>>                If (bExists = True and bCfgFile) Begin
101418>>>                    // A little trick to show the filelist.cfg in the form before we start filling the grid.
101418>>>                    Send PumpMsgQueue of Desktop
101419>>>                    Get ChangeFilelistPathing of ghoApplication sFileList to bOK
101420>>>
101420>>>                    If (bOK = True) Begin
101422>>>                        Set psFilelistFrom of ghoApplication to sFileList
101423>>>
101423>>>                        // *** LOAD DATA ***
101423>>>                        Send LoadData to oFilelist_grd
101424>>>
101424>>>                        // It just seem logical to activate the grid after populating it.
101424>>>                        // At this point there is little use of still having the oFilelist_fm active.
101424>>>                        Get HasRecords of oFilelist_grd to bHasRecords
101425>>>                        If (bHasRecords = True) Begin
101427>>>                            Send Activate of oFilelist_grd
101428>>>                        End
101428>>>>
101428>>>
101428>>>                        If (bExists = True) Begin
101430>>>                            Get phDbVersion of oFilelist_grd to hTable
101431>>>                            If (hTable <> 0) Begin
101433>>>                                Open hTable
101435>>>                                Get_Field_Value hTable 1   to nVersionNumber 
101438>>>                                // ToDo: How to handle this if not the standard "DbVersion" table is used?
101438>>>                                Set pnSourcePackageVersion to nVersionNumber
101439>>>                                Set piDbVersionFileNumber  to hTable
101440>>>                                Set piDbVersionFieldNumber to 1
101441>>>                                Close hTable
101442>>>                            End
101442>>>>
101442>>>                        End
101442>>>>
101442>>>                        If (nVersionNumber = 0) Begin
101444>>>                            Move 1.0 to nVersionNumber
101445>>>                        End   
101445>>>>
101445>>>                        Else Begin
101446>>>                            Move (nVersionNumber + .1) to nVersionNumber
101447>>>                        End
101447>>>>
101447>>>                        Set Value of oPnVersionNumber_fm to nVersionNumber
101448>>>                    End
101448>>>>
101448>>>                End
101448>>>>
101448>>>            End_Procedure
101449>>>
101449>>>            Function Window_Handle Returns Handle
101452>>>                Integer rVal
101452>>>                Get Window_Handle of (Parent(Self)) to rVal
101453>>>                Function_Return rVal
101454>>>            End_Function
101455>>>
101455>>>            Function Next_Object_Id Boolean bNoDescend Returns Integer
101458>>>                Function_Return (oFilelist_grd(Self))
101459>>>            End_Function
101460>>>
101460>>>            On_Key Key_Ctrl+Key_W Send None
101461>>>            On_Key Key_Ctrl+Key_Q Send None
101462>>>        End_Object
101463>>>
101463>>>    End_Object
101464>>>
101464>>>    Object oSelectTables_grp is a cRDCHeaderGroup
101466>>>        Set Size to 92 473
101467>>>        Set Location to 69 15
101468>>>        Set peAnchors to anAll
101469>>>        Set psImage to "SelectTables1.ico"
101470>>>        Set psLabel to "Select Tables"
101471>>>        Set psNote to "Right click grid for options"  
101472>>>        Set psToolTip to "Select one or more tables to generate 'DUF' database update code for. (Ctrl+A = 'Select All Tables'. Right-click grid for selection options."
101473>>>
101473>>>        Object oFilelist_grd is a cRDCCJSelectionGrid
101475>>>            Set Size to 56 423
101476>>>            Set Location to 27 29
101477>>>            Set piLayoutBuild to 6
101478>>>            Set Status_Help to "Select with the spacebar, or use the selection buttons above the grid"
101479>>>
101479>>>            Property Handle phDbVersion
101481>>>            Property Integer piCurrentRow -1
101483>>>
101483>>>            Object oCJGridColumnRowIndicator is a cCJGridColumnRowIndicator
101485>>>                Set piWidth to 26
101486>>>            End_Object
101487>>>                         
101487>>>            Object oFilelistNumber_col is a cCJGridColumn
101489>>>                Set piWidth to 74
101490>>>                Set psCaption to "Filelist No"
101491>>>                Set psToolTip to (psCaption(Self) * "(Read-Only)")
101492>>>                Set peDataType to Mask_Numeric_Window
101493>>>                Set pbEditable to False
101494>>>                Set peTextAlignment to xtpAlignmentCenter
101495>>>            End_Object
101496>>>
101496>>>            Object oLogicalName_col is a cCJGridColumn
101498>>>                Set piWidth to 121
101499>>>                Set psCaption to "Logical Name"
101500>>>                Set psToolTip to (psCaption(Self) * "(Read-Only)")
101501>>>                Set pbEditable to False
101502>>>                Set psFooterText to "No of Tables:"
101503>>>            End_Object
101504>>>
101504>>>            Object oRootName_col is a cCJGridColumn
101506>>>                // NOTE: This must be set at one of the columns!
101506>>>                Set phoData_Col to Self
101507>>>                Set piWidth to 191
101508>>>                Set psCaption to "Table Name (Rootname)"
101509>>>                Set psToolTip to (psCaption(Self) * "(Read-Only)")
101510>>>                Set pbEditable to False
101511>>>                Set psFooterText to "Selected:"
101512>>>            End_Object
101513>>>
101513>>>            Object oDisplayName_col is a cCJGridColumn
101515>>>                Set piWidth to 267
101516>>>                Set psCaption to "Display Name"
101517>>>                Set psToolTip to (psCaption(Self) * "(Read-Only)")
101518>>>                Set pbEditable to False
101519>>>            End_Object
101520>>>
101520>>>            Object oIsAlias_Col is a cCJGridColumn
101522>>>                Set piWidth to 85
101523>>>                Set psCaption to "Is Alias"
101524>>>                Set pbCheckbox to True
101525>>>                Set peHeaderAlignment to xtpAlignmentCenter
101526>>>                Set peFooterAlignment to xtpAlignmentCenter
101527>>>                Set pbVDFEditControl to False
101528>>>                Set psToolTip to "Is table an alias table? (Read-Only)"
101529>>>                Set psFooterText to "Alias:"
101530>>>            End_Object
101531>>>
101531>>>            Procedure LoadData
101534>>>                String sFileList sLogicalName
101534>>>                Handle hoDataSource hTable
101534>>>                tDataSourceRow[] TheData TheDataEmpty
101534>>>                tDataSourceRow[] TheData TheDataEmpty
101536>>>                Integer iRow iTableNo iRoot iLogical iDisplay iIsAlias iChecked iAliasCount iNoOfTables iCount
101536>>>                Boolean bExists bIsAlias bUserCancel
101536>>>
101536>>>                Get Value of oFilelistPath_fm to sFilelist
101537>>>                Get vFilePathExists sFileList to bExists
101538>>>                If (bExists = False) Begin
101540>>>                    Procedure_Return
101541>>>                End
101541>>>>
101541>>>
101541>>>                Send Initialize_StatusPanel of ghoStatusPanel "The Database Update Framework" "Loading Filelist.cfg data" "...and checking for Alias tables"
101542>>>                Send Start_StatusPanel of ghoStatusPanel
101543>>>                Get UtilFilelistNoOfTables of ghoDbUpdateFunctionLibrary to iNoOfTables
101544>>>                Set pbVisible of ghoProgressBar to True
101545>>>                Set pbVisible of ghoProgressBarOverall to False
101546>>>                Set piMaximum of ghoProgressBar to iNoOfTables
101547>>>                Move 0 to iCount
101548>>>                Get phoDataSource to hoDataSource
101549>>>                Get DataSource of hoDataSource to TheData
101550>>>                Move TheDataEmpty to TheData
101551>>>                Get piColumnId of oFilelistNumber_col to iTableNo
101552>>>                Get piColumnId of oRootName_col       to iRoot
101553>>>                Get piColumnid of oLogicalName_col    to iLogical
101554>>>                Get piColumnId of oDisplayName_col    to iDisplay
101555>>>                Get piColumnId of oIsAlias_Col        to iIsAlias
101556>>>                Get piColumnId of oCheckbox_Col       to iChecked
101557>>>
101557>>>                Move 0 to hTable
101558>>>                Move 0 to iRow
101559>>>                Repeat
101559>>>>
101559>>>                    Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
101562>>>                    Set piPosition of ghoProgressBar to iCount
101563>>>
101563>>>                    If (hTable > 0 and hTable <> 50) Begin
101565>>>                        Move hTable                                   to TheData[iRow].sValue[iTableNo]
101566>>>                        Get_Attribute DF_FILE_ROOT_NAME     of hTable to TheData[iRow].sValue[iRoot]
101569>>>                        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
101572>>>                        Move sLogicalName                             to TheData[iRow].sValue[iLogical]
101573>>>                        If (Uppercase(sLogicalName) = "DBVERSION") Begin
101575>>>                            Set phDbVersion to hTable
101576>>>                        End
101576>>>>
101576>>>                        Get_Attribute DF_FILE_DISPLAY_NAME  of hTable to TheData[iRow].sValue[iDisplay]
101579>>>                        Get UtilTableIsAlias of ghoDbUpdateFunctionLibrary hTable to bIsAlias
101580>>>                        Move bIsAlias                                 to TheData[iRow].sValue[iIsAlias]
101581>>>                        If (bIsAlias = True) Begin
101583>>>                            Increment iAliasCount
101584>>>                        End
101584>>>>
101584>>>                        Move False to TheData[iRow].sValue[iChecked]
101585>>>                        Increment iRow
101586>>>                    End
101586>>>>
101586>>>                    Increment iCount
101587>>>                    Get Check_StatusPanel of ghoStatusPanel to bUserCancel
101588>>>                    If (bUserCancel = True) Begin
101590>>>                        Move TheDataEmpty to TheData
101591>>>                        Move 0 to iRow
101592>>>                        Move 0 to iAliasCount
101593>>>                        Move 0 to hTable
101594>>>                    End
101594>>>>
101594>>>                Until (hTable = 0)
101596>>>                                    
101596>>>                Send InitializeData TheData
101597>>>                Set psFooterText of oLogicalName_col to ("No of Tables:" * String(iRow))
101598>>>                Set psFooterText of oIsAlias_Col     to ("Alias:" * String(iAliasCount))
101599>>>                Send Stop_StatusPanel of ghoStatusPanel
101600>>>            End_Procedure
101601>>>
101601>>>            Function SelectedTableNumber Returns Handle
101604>>>                Integer hTable iTableNo iRowNo
101604>>>                Handle hoDataSource
101604>>>                tDataSourceRow[] TheData
101604>>>                tDataSourceRow[] TheData
101605>>>
101605>>>                Get phoDataSource to hoDataSource
101606>>>                Get piColumnId of oFilelistNumber_col to iTableNo
101607>>>                Get DataSource of hoDataSource to TheData
101608>>>                Get SelectedRow of hoDataSource to iRowNo
101609>>>                Move TheData[iRowNo].sValue[iTableNo] to hTable
101610>>>
101610>>>                Function_Return hTable
101611>>>            End_Function
101612>>>
101612>>>            Function GenerateSourceFileName Returns String
101615>>>                String sRetval sPath sFileListName sTableName sVersionNumber
101615>>>                Boolean bExists
101615>>>                Integer iLogical iRowNo iSelected iPos
101615>>>                tDataSourceRow[] TheData
101615>>>                tDataSourceRow[] TheData
101616>>>                Handle hoDataSource
101616>>>                Number nVersionNumber
101616>>>
101616>>>                Get Value of oFilelistPath_fm to sFileListName
101617>>>                Get vFilePathExists sFileListName to bExists
101618>>>                If (bExists = False) Begin
101620>>>                    Function_Return ""
101621>>>                End
101621>>>>
101621>>>
101621>>>                Set_Attribute DF_DECIMAL_SEPARATOR to (Ascii('.'))
101624>>>                Get Value of oPnVersionNumber_fm to sVersionNumber
101625>>>//                Move nVersionNumber to sVersionNumber
101625>>>                Move (Pos(".", sVersionNumber)) to iPos
101626>>>                If (iPos = 0) Begin
101628>>>                    Move (sVersionNumber + String(".0")) to sVersionNumber
101629>>>                End
101629>>>>
101629>>>                Move (Replaces(".", sVersionNumber, "_")) to sVersionNumber
101630>>>                Move (Replaces(",", sVersionNumber, "_")) to sVersionNumber
101631>>>
101631>>>                Get ParseFolderName sFileListName to sPath
101632>>>                Get vParentPath sPath   to sPath
101633>>>                Get vFolderFormat sPath to sPath
101634>>>                Move (sPath + "AppSrc") to sPath
101635>>>                Get vFolderFormat sPath to sPath
101636>>>
101636>>>                Get phoDataSource to hoDataSource
101637>>>                Get piColumnid of oLogicalName_col to iLogical
101638>>>                Get DataSource of hoDataSource to TheData
101639>>>                Get CheckedItems to iSelected
101640>>>                If (iSelected > 1) Begin
101642>>>                    Move "MultipleTables" to sTableName
101643>>>                End
101643>>>>
101643>>>                Else Begin
101644>>>                    If (SizeOfArray(TheData) <> 0) Begin
101646>>>                        Get SelectedRow of hoDataSource to iRowNo
101647>>>                        Move TheData[iRowNo].sValue[iLogical] to sTableName
101648>>>                    End
101648>>>>
101648>>>                End
101648>>>>
101648>>>                Move ("DUF_" + sTableName + String(sVersionNumber) + ".pkg") to sTableName
101649>>>
101649>>>                Move (sPath + sTableName) to sRetval
101650>>>
101650>>>                Function_Return sRetval
101651>>>            End_Function
101652>>>
101652>>>            Function piCheckboxCol Returns Integer
101655>>>                Integer iIndex
101655>>>                Get piColumnId of oCheckbox_Col to iIndex
101656>>>                Function_Return iIndex
101657>>>            End_Function
101658>>>
101658>>>            // Returns a string array with the selected items.
101658>>>            Function SelectedItems Returns tGeneratorRow[]
101661>>>                Integer[] SelRows
101662>>>                Integer i iItems iSize iCheckbox_Col iFilelistNo_Col iLogical_Col iRoot_Col iDisplay_Col iIsAlias_Col
101662>>>                String sFileName
101662>>>                String[] sFilesArray
101663>>>                Handle hoDataSource
101663>>>                tDataSourceRow[] TheData
101663>>>                tDataSourceRow[] TheData
101664>>>                Boolean bChecked bIsAlias
101664>>>                tGeneratorRow[] GeneratorRowArray
101664>>>                tGeneratorRow[] GeneratorRowArray
101665>>>
101665>>>                Get piColumnId of oFilelistNumber_col to iFilelistNo_Col
101666>>>                Get piColumnId of oLogicalName_col    to iLogical_Col
101667>>>                Get piColumnId of oRootName_col       to iRoot_Col
101668>>>                Get piColumnId of oDisplayName_col    to iDisplay_Col
101669>>>                Get piColumnId of oIsAlias_Col        to iIsAlias_Col
101670>>>                Get piColumnId of oCheckbox_Col       to iCheckbox_Col
101671>>>
101671>>>                Get phoDataSource to hoDataSource
101672>>>                Get DataSource of hoDataSource to TheData
101673>>>                Move (SizeOfArray(TheData)) to iItems
101674>>>                Decrement iItems
101675>>>
101675>>>                For i from 0 to iItems
101681>>>>
101681>>>                    Move TheData[i].sValue[iCheckbox_Col] to bChecked
101682>>>                    If (bChecked = True) Begin
101684>>>                        Move (SizeOfArray(GeneratorRowArray)) to iSize
101685>>>                        Move TheData[i].sValue[iFilelistNo_Col] to GeneratorRowArray[iSize].hTable
101686>>>                        Move TheData[i].sValue[iLogical_Col]    to GeneratorRowArray[iSize].sLogicalName
101687>>>                        Move TheData[i].sValue[iRoot_Col]       to GeneratorRowArray[iSize].sRootName
101688>>>                        Move TheData[i].sValue[iDisplay_Col]    to GeneratorRowArray[iSize].sDisplayName
101689>>>                        Move TheData[i].sValue[iIsAlias_Col]    to GeneratorRowArray[iSize].bIsAlias
101690>>>                        Move TheData[i].sValue[iCheckbox_Col]   to GeneratorRowArray[iSize].bSelected
101691>>>                        Move sFileName to sFilesArray[iSize]
101692>>>                    End
101692>>>>
101692>>>                Loop
101693>>>>
101693>>>
101693>>>                Function_Return GeneratorRowArray
101694>>>            End_Function
101695>>>
101695>>>            Procedure Request_Clear
101698>>>                Delegate Send Request_Clear
101700>>>            End_Procedure   
101701>>>            
101701>>>            Function HasRecords Returns Boolean
101704>>>                Handle hoDataSource
101704>>>                tDataSourceRow[] TheData
101704>>>                tDataSourceRow[] TheData
101705>>>                Integer iItems
101705>>>
101705>>>                Get phoDataSource to hoDataSource
101706>>>                Get DataSource of hoDataSource to TheData
101707>>>                Move (SizeOfArray(TheData)) to iItems
101708>>>                Function_Return (iItems <> 0)
101709>>>            End_Function
101710>>>
101710>>>            Procedure Set SelectItems Integer iState
101713>>>                String sSourceFile
101713>>>
101713>>>                Forward Set SelectItems to iState
101715>>>                Get GenerateSourceFileName  to sSourceFile
101716>>>                Set Value of oSourceName_fm to sSourceFile
101717>>>            End_Procedure     
101718>>>            
101718>>>            Procedure ToggleCurrentItem 
101721>>>                String sSourceFile
101721>>>
101721>>>                Forward Send ToggleCurrentItem
101723>>>                Get GenerateSourceFileName  to sSourceFile
101724>>>                Set Value of oSourceName_fm to sSourceFile
101725>>>                
101725>>>            End_Procedure
101726>>>
101726>>>        End_Object
101727>>>
101727>>>        // Needed to not close the view when Esc is hit in the grid.
101727>>>        On_Key kCancel Send None
101728>>>    End_Object
101729>>>
101729>>>    Object oConfigureGeneration_grp is a cRDCHeaderGroup
101731>>>        Set Size to 48 473
101732>>>        Set Location to 172 15
101733>>>        Set peAnchors to anBottomLeftRight
101734>>>        Set psLabel to "Configure Code Generation"
101735>>>        Set psImage to "Settings1.ico"   
101736>>>        Set psToolTip to "Select how code is generated. If you are not sure what the flags does, leave the default settings."
101737>>>        
101737>>>        Object oUseConnectionID_cb is a cSQLCheckBox
101739>>>            Set Size to 9 78
101740>>>            Set Location to 19 30
101741>>>            Set Label to "Use Connection ID"
101742>>>            Set Checked_State to True
101743>>>            Set psToolTip to "If True (the default); uses the Connection ID of the connection string as defined by the SQLConnection.ini setting"
101744>>>        End_Object
101745>>>
101745>>>        Object oANSI_cb is a cSQLCheckBox
101747>>>            Set Size to 9 49
101748>>>            Set Location to 19 136
101749>>>            Set Label to "ANSI/OEM"
101750>>>            Set Checked_State to True  
101751>>>            Set psToolTip to "Set property 'pbToANSI' True/False. DataFlex data is stored in OEM format. Non-DataFlex back ends may expect the data to be stored in ANSI format. When defining the conversion options you can define the table character format to be used in the converted table."
101752>>>        End_Object
101753>>>
101753>>>        Object oCompareIndexAscending_cb is a cSQLCheckBox
101755>>>            Set Size to 9 93
101756>>>            Set Location to 19 200
101757>>>            Set Label to "Change Asc/Descending"
101758>>>            Set Checked_State to False
101759>>>            Set psToolTip to "Set property 'pbCompareIndexAscending' True/False. Check if Index is Ascending/Descending. (In SQL this setting is set for the whole database by selecting a 'Collation', so with SQL checking this per table doesn't make sense)"
101760>>>        End_Object
101761>>>
101761>>>        Object oApiTableUpdateAuto_cb is a cSQLCheckBox
101763>>>            Set Size to 9 137
101764>>>            Set Location to 19 316
101765>>>            Set Label to "Auto Update Table to SQL"
101766>>>            Set Checked_State to True
101767>>>            Set psToolTip to "Set property 'pbApiTableUpdateAuto' True/False. When set to True, 'TO' tables will get converted to the same database format as the 'FROM' tables. So if a 'FROM' table is an SQL table and the 'TO' table is in the embedded format (DataFlex table), it will be converted to SQL."
101768>>>        End_Object
101769>>>
101769>>>        Object oCompareDate_DataTime_cb is a cSQLCheckBox
101771>>>            Set Size to 9 91
101772>>>            Set Location to 32 30
101773>>>            Set Label to "Change Date/DataTime"
101774>>>            Set Checked_State to False
101775>>>            Set psToolTip to "Set property 'pbCompareDate_DateTime' True/False. Check if there are Date/DateTime column differences. Tick the box if the framework should create code to change e.g. a 'To' DateTime column to a Date column if the 'FROM' table column is defined as Date. Be careful as you might loose data!"
101776>>>        End_Object
101777>>>
101777>>>        Object oRecnum_cb is a cSQLCheckBox
101779>>>            Set Size to 9 57
101780>>>            Set Location to 32 136
101781>>>            Set Label to "Use Recnum"
101782>>>            Set Checked_State to True
101783>>>            Set psToolTip to "Set property 'pbRecnum' True/False. If the program that is using the source database uses the recnum programming style, the tables should be converted to recnum tables. If the program uses the RowId programming style, converting to standard tables is recommended."
101784>>>        End_Object
101785>>>
101785>>>        Object oCompareIndexUppercase_cb is a cSQLCheckBox
101787>>>            Set Size to 9 98
101788>>>            Set Location to 32 200
101789>>>            Set Label to "Change Upper/Lowercase"
101790>>>            Set Checked_State to False
101791>>>            Set psToolTip to "Set property 'pbCompareIndexUppercase' True/False. Check if Index is Uppercase/Lowercase. (In SQL this setting is set for the whole database by selecting a 'Collation', so then checking this per table doesn't make sense)"
101792>>>        End_Object
101793>>>
101793>>>        Object oIgnoreFilelistUppercase_cb is a cSQLCheckBox
101795>>>            Set Size to 9 142
101796>>>            Set Location to 32 316
101797>>>            Set Label to "Change Upper/Lowercase Table Names"
101798>>>            Set Checked_State to True
101799>>>            Set psToolTip to "Check Filelist.cfg RootName, LogicalName and DisplayName uppercase/lowercase differences"
101800>>>        End_Object
101801>>>
101801>>>        Procedure ToggleCurrentItem
101804>>>            Boolean bChecked
101804>>>            Handle hObject
101804>>>
101804>>>            Get Focus to hObject
101805>>>            Get Checked_State of hObject to bChecked
101806>>>            Set Checked_State of hObject to (not(bChecked))
101807>>>        End_Procedure
101808>>>
101808>>>    End_Object
101809>>>
101809>>>    Object oGenerateFilename_grp is a cRDCHeaderGroup
101811>>>        Set Size to 39 473
101812>>>        Set Location to 232 15
101813>>>        Set peAnchors to anBottomLeftRight
101814>>>        Set psImage to "ActionSaveCode1.ico"
101815>>>        Set psLabel to "Generated Package File Name"  
101816>>>        Set psToolTip to "A suggestion for the package file to be generated is shown. It can be changed if needed, but you are not encouraged to do so."
101817>>>
101817>>>        Object oPnVersionNumber_fm is a cRDCForm
101819>>>            Set Size to 12 22
101820>>>            Set Location to 17 108
101821>>>            Set Label to "Next pnVersionNumber"
101822>>>            Set psToolTip to "This value is the current DbVersion.DatabaseVersion value, with a value of 0.1 added to it."
101823>>>            Set peAnchors to anBottomLeft
101824>>>            Set Label_Justification_Mode to JMode_Right
101825>>>            Set Label_Col_Offset to 2
101826>>>            Set_Attribute DF_DECIMAL_SEPARATOR to (Ascii('.'))
101829>>>            Set Form_Datatype to 2
101830>>>            Set Value to 1.0
101831>>>
101831>>>            Procedure OnChange
101834>>>                String sSourceFile
101834>>>                Number nVersionNumber 
101834>>>                Integer iDecimalSeparator                     
101834>>>                
101834>>>                Set_Attribute DF_DECIMAL_SEPARATOR to (Ascii('.'))
101837>>>                Get Value to nVersionNumber
101838>>>//                If (nVersionNumber < 1) Begin
101838>>>//                    Move 1 to nVersionNumber   
101838>>>//                    Set Value to nVersionNumber     
101838>>>//                End
101838>>>                Set pnSourcePackageVersion to nVersionNumber
101839>>>                Get GenerateSourceFileName of oFilelist_grd  to sSourceFile
101840>>>                Set Value of oSourceName_fm to sSourceFile
101841>>>            End_Procedure
101842>>>
101842>>>        End_Object
101843>>>
101843>>>        Object oSourceName_fm is a cRDCForm
101845>>>            Set Size to 12 315
101846>>>            Set Location to 17 134
101847>>>            Set peAnchors to anBottomLeftRight
101848>>>            Set Label_Col_Offset to 0
101849>>>            Set Label_Justification_Mode to JMode_Top
101850>>>            Set Label_Row_Offset to 1
101851>>>            Set psToolTip to "The name of the output file to be generated. The suggested name can be changed if needed."
101852>>>        End_Object
101853>>>
101853>>>    End_Object
101854>>>
101854>>>    Object oBusinessProcess is a BusinessProcess
101856>>>        Set Status_Panel_Id to ghoStatusPanel
101857>>>        Set Allow_Cancel_State to True
101858>>>        Set Process_Caption to "The Database Update Framework"
101859>>>        Set Process_Title to "Generating Database Update Code..."
101860>>>        Set Process_Message to "For table:"
101861>>>
101861>>>        Procedure OnProcess
101864>>>            Send StartGenerateCode
101865>>>        End_Procedure
101866>>>
101866>>>        Procedure Ignore_Error Integer iError
101869>>>        End_Procedure
101870>>>        Procedure Trap_Error Integer iError
101873>>>        End_Procedure
101874>>>
101874>>>    End_Object
101875>>>
101875>>>    Object oGenerateCode_btn is a cRDCCommandLinkButton
101877>>>        Set Size to 36 166
101878>>>        Set Location to 281 63
101879>>>        Set Label to "Generate Code!"
101880>>>        Set psNote to "Create DUF update package for the selected tables."
101881>>>        Set psToolTip to "Start generating DUF code for all selected tables."
101882>>>        Set psImage to "SqlScript1.ico"    
101883>>>        Set Default_State to True
101884>>>        Set MultiLineState to True
101885>>>        Set piImageSize to 32 
101886>>>        Set pbAutoEnable to True
101887>>>        Set peAnchors to anBottomRight
101888>>>
101888>>>        Procedure OnClick
101891>>>            Boolean bExists
101891>>>            String sSourceFile sPath
101891>>>            Integer iSelected iRetval
101891>>>
101891>>>            Get Value of oSourceName_fm to sSourceFile
101892>>>            Get vFilePathExists sSourceFile to bExists
101893>>>            If (bExists = True) Begin
101895>>>                Get YesNo_Box ("Oops, the source file" * sSourceFile * "already exists!\n\nDo you want to overwrite it?") to iRetval
101896>>>                If (iRetval <> MBR_Yes) Begin
101898>>>                    Procedure_Return
101899>>>                End
101899>>>>
101899>>>            End                     
101899>>>>
101899>>>            
101899>>>            Get ExtractFilePath sSourceFile to sPath
101900>>>            Get vFilePathExists sPath       to bExists
101901>>>            If (bExists = False) Begin
101903>>>                Send Info_Box "Please check the source file path and try again. It doesn't exist!"
101904>>>                Procedure_Return
101905>>>            End
101905>>>>
101905>>>
101905>>>            Get CheckedItems  of oFilelist_grd to iSelected
101906>>>            If (iSelected = 0) Begin
101908>>>                Send Info_Box "No tables selected. Please adjust and try again."
101909>>>                Procedure_Return
101910>>>            End
101910>>>>
101910>>>
101910>>>            Send DoProcess of oBusinessProcess
101911>>>            Send Restore_DF_OPEN_PATH of ghoApplication
101912>>>        End_Procedure
101913>>>
101913>>>        Function IsEnabled Returns Boolean
101916>>>            Integer iSelected 
101916>>>            Get CheckedItems  of oFilelist_grd to iSelected
101917>>>            Function_Return (iSelected <> 0)
101918>>>        End_Function
101919>>>            
101919>>>    End_Object
101920>>>
101920>>>    Object oGenerateInternalUpdatetProgram_btn is a cRDCCommandLinkButton
101922>>>        Set Size to 36 77
101923>>>        Set Location to 281 239
101924>>>        Set Label to "Local"
101925>>>        Set psNote to "Create local helper program"
101926>>>        Set peAnchors to anBottomRight
101927>>>        Set psToolTip to "Generates a small basic program that Use's the generated package. To be be send to a fellow developer working on the same project, to make his/hers local database identical to the selected 'FROM' database."
101928>>>        Set psImage to "SqlScript1.ico"    
101929>>>        Set piImageSize to 16 // 24
101930>>>        Set pbAutoEnable to True
101931>>>        
101931>>>        Procedure OnClick
101934>>>            Integer iRetval
101934>>>            String sText
101934>>>        
101934>>>            Move "This generates a small basic program that Use's the generated package. To be be send to a fellow developer working on the same project, to make his/hers local database identical to the selected 'FROM' database. Continue?" to sText
101935>>>            Get YesNo_Box sText to iRetval
101936>>>            If (iRetval = MBR_Yes) Begin
101938>>>                Send GenerateInternalUpdateProgram
101939>>>            End
101939>>>>
101939>>>        End_Procedure
101940>>>        
101940>>>        Procedure GenerateInternalUpdateProgram
101943>>>            String sPath sSourcePackageName
101943>>>            Integer iDbVersionFileNumber iDbVersionFieldNumber
101943>>>            Number nSourcePackageVersion
101943>>>            Boolean bOK 
101943>>>            
101943>>>            Get piDbVersionFileNumber   to iDbVersionFileNumber
101944>>>            Get piDbVersionFieldNumber  to iDbVersionFieldNumber
101945>>>            Get pnSourcePackageVersion  to nSourcePackageVersion
101946>>>            
101946>>>            Get Value of oSourceName_fm to sSourcePackageName
101947>>>            Get ParseFolderName sSourcePackageName to sPath
101948>>>            Get ParseFileName sSourcePackageName to sSourcePackageName
101949>>>                        
101949>>>            Get WriteTestProgram sSourcePackageName sPath nSourcePackageVersion iDbVersionFileNumber iDbVersionFieldNumber to bOK
101950>>>            If (bOK = True) Begin
101952>>>                Send Info_Box ("Success! The source program" * CS_DUFTestProgram * "was created in:" * sPath)        
101953>>>            End 
101953>>>>
101953>>>            Else Begin
101954>>>                Send Info_Box "The creation of the source program failed..."
101955>>>            End
101955>>>>
101955>>>        End_Procedure
101956>>>        
101956>>>        Function IsEnabled Returns Boolean
101959>>>            String sPath sSourceName
101959>>>            Boolean bExists
101959>>>            Integer iSelected 
101959>>>
101959>>>            Get CheckedItems of oFilelist_grd to iSelected
101960>>>            Get Value of oSourceName_fm to sSourceName
101961>>>            Get ParseFolderName sSourceName to sPath
101962>>>            Get vFolderExists sPath to bExists
101963>>>            Function_Return (iSelected <> 0 and bExists = True)
101964>>>        End_Function
101965>>>
101965>>>    End_Object
101966>>>
101966>>>    Object oViewSoureCode_btn is a cRDCCommandLinkButton
101968>>>        Set Size to 36 76
101969>>>        Set Location to 281 326
101970>>>        Set Label to "View"
101971>>>        Set psNote to "View source code"
101972>>>        Set peAnchors to anBottomRight
101973>>>        Set psToolTip to "Open the source file in the editor"
101974>>>        Set MultiLineState to True
101975>>>        Set psImage to "ViewSourceCode1.ico" 
101976>>>        Set piImageSize to 16 
101977>>>        Set pbAutoEnable to True
101978>>>
101978>>>        Procedure OnClick
101981>>>            String sSourceName
101981>>>            
101981>>>            Get Value of oSourceName_fm to sSourceName
101982>>>            Send ActivateSourceCodeDialog sSourceName
101983>>>        End_Procedure
101984>>>
101984>>>        Function IsEnabled Returns Boolean
101987>>>            String sSourceName
101987>>>            Boolean bExists
101987>>>
101987>>>            Get Value of oSourceName_fm to sSourceName
101988>>>            Get vFilePathExists sSourceName to bExists
101989>>>            Function_Return (bExists = True)
101990>>>        End_Function
101991>>>
101991>>>    End_Object
101992>>>
101992>>>    Object oOpenAppSrcFolder_btn is a cRDCCommandLinkButton
101994>>>        Set Size to 36 76
101995>>>        Set Location to 281 413
101996>>>        Set Label to "F&older"
101997>>>        Set psNote to "Open containing folder"
101998>>>        Set peAnchors to anBottomRight
101999>>>        Set psToolTip to "Open the source location in Windows Explorer"
102000>>>        Set MultiLineState to True
102001>>>        Set psImage to "ActionOpenFolder1.ico" 
102002>>>        Set piImageSize to 16 // 24
102003>>>        Set pbAutoEnable to True
102004>>>
102004>>>        Procedure OnClick
102007>>>            String sPath sSourceName sFile  
102007>>>            Boolean bExists
102007>>>            
102007>>>            Get Value of oSourceName_fm to sSourceName
102008>>>            Get vFilePathExists sSourceName to bExists
102009>>>            Get ParseFolderName sSourceName to sPath
102010>>>            Get ParseFileName sSourceName to sFile
102011>>>            // We want to have that file to be selected in Windows Explorer when it opens
102011>>>            If (bExists = True) Begin
102013>>>                Move ("/select, " + '"' + sSourceName + '"') to sSourceName
102014>>>            End
102014>>>>
102014>>>            Runprogram Shell Background "Explorer.exe" sSourceName
102015>>>        End_Procedure
102016>>>
102016>>>        Function IsEnabled Returns Boolean
102019>>>            String sPath sSourceName
102019>>>            Boolean bExists
102019>>>
102019>>>            Get Value of oSourceName_fm to sSourceName
102020>>>            Get ParseFolderName sSourceName to sPath
102021>>>            Get vFolderExists sPath to bExists
102022>>>            Function_Return (bExists = True)
102023>>>        End_Function
102024>>>
102024>>>    End_Object
102025>>>
102025>>>    Procedure StartGenerateCode
102028>>>        String sSourceFile
102028>>>        Boolean bUseConnectionID bANSI bRecnum bCompareIndexUppercase bCompareIndexAscending
102028>>>        Handle hTable
102028>>>        Integer iErrors
102028>>>        Number nVersionNumber
102028>>>        tGeneratorRow[] TheData
102028>>>        tGeneratorRow[] TheData
102029>>>        tAPITableBooleans CompareTableBooleans
102029>>>        tAPITableBooleans CompareTableBooleans
102029>>>
102029>>>        Set_Attribute DF_DECIMAL_SEPARATOR to (Ascii('.'))
102032>>>        Get Value of oSourceName_fm                      to sSourceFile
102033>>>        Get Checked_State of oUseConnectionID_cb         to bUseConnectionID
102034>>>        Get Checked_State of oANSI_cb                    to bANSI
102035>>>        Get Checked_State of oRecnum_cb                  to bRecnum
102036>>>        Get Checked_State of oApiTableUpdateAuto_cb      to CompareTableBooleans.bApiTableUpdateAuto
102037>>>        Get Checked_State of oCompareDate_DataTime_cb    to CompareTableBooleans.bCompareDate_DateTime
102038>>>        Get Checked_State of oCompareIndexAscending_cb   to CompareTableBooleans.bCompareIndexAscending
102039>>>        Get Checked_State of oCompareIndexUppercase_cb   to CompareTableBooleans.bCompareIndexUppercase
102040>>>        Get Checked_State of oIgnoreFilelistUppercase_cb to CompareTableBooleans.bCompareFilelistUppercase
102041>>>
102041>>>        Get SelectedItems of oFilelist_grd to TheData
102042>>>        Get pnSourcePackageVersion to nVersionNumber
102043>>>        Get GenerateDUFSourceCode sSourceFile TheData nVersionNumber bUseConnectionID bANSI bRecnum CompareTableBooleans to iErrors
102044>>>
102044>>>        If (iErrors = GenerateChannelError) Begin
102046>>>            Send Info_Box "Sorry, couldn't retrieve a free channel number. Process halted."
102047>>>        End
102047>>>>
102047>>>        If (iErrors = GenerateUserInputError) Begin
102049>>>            Send Info_Box "Table number and pnVersionNumber both needs to be > 0. Please adjust and try again."
102050>>>        End
102050>>>>
102050>>>
102050>>>        Send Stop_StatusPanel of ghoStatusPanel
102051>>>        If (iErrors = GenerateOK) Begin
102053>>>            Send Info_Box "Ready!"
102054>>>        End
102054>>>>
102054>>>        If (iErrors = GenerateError) Begin
102056>>>            Send Info_Box ("Ready! But the code contains ERRORS because there were fields with length = 0! Search the generated code for the word 'ERROR!' to see those fields.")
102057>>>        End
102057>>>>
102057>>>        If (iErrors = GenerateOpenTableError) Begin
102059>>>            Send Info_Box ("Sorry, couldn't open the table! (Table No:" * String(phTable(Self)) * String(psFileName(Self)) + ") Process halted.")
102060>>>        End
102060>>>>
102060>>>        If (iErrors = GenerateUserCancel) Begin
102062>>>            Send Info_Box "Process cancelled by user."
102063>>>        End
102063>>>>
102063>>>    End_Procedure
102064>>>
102064>>>    Function GenerateDUFSourceCode String sSourceFile tGeneratorRow[] TheData Number nVersionNumber Boolean bUseConnectionID Boolean bANSI Boolean bRecnum tAPITableBooleans CompareTableBooleans Returns Integer
102067>>>        Boolean bApiTableUpdateAuto bCompare_DateTime bCompareIndexAscending bCompareIndexUppercase bCompareFilelistUppercase
102067>>>        Integer iCh iColumn iLength iPrecision iOptions iCount iSize iTable iTables
102067>>>        Integer iIndex iIndexes iSegment iNumSegments iType iErrors iStatus
102067>>>        Boolean bOpened bOK bDawSqlDriver bIsAlias bSqlDriver bSkipTable
102067>>>        String sRootName sLogicalName sDisplayName sTableName sFieldName sDataType sDriverID
102067>>>        Handle hTable
102067>>>        tAPITableNameInfo  APITableNameInfo
102067>>>        tAPITableNameInfo  APITableNameInfo
102067>>>        tAPIColumn[]   APIColumns
102067>>>        tAPIColumn[]   APIColumns
102068>>>        tAPIRelation[] APIRelations
102068>>>        tAPIRelation[] APIRelations
102069>>>        tAPIIndex[]    APIIndexes
102069>>>        tAPIIndex[]    APIIndexes
102070>>>        DateTime dtCreationTime
102070>>>
102070>>>        Move (CurrentDateTime()) to dtCreationTime
102071>>>        Move 0 to iErrors
102072>>>        Move (SizeOfArray(TheData)) to iTables
102073>>>        Decrement iTables
102074>>>        Move 0 to iTable
102075>>>        Move TheData[iTable].hTable to hTable
102076>>>
102076>>>        Get Seq_Open_Output_Channel sSourceFile to iCh
102077>>>        If (iCh = DF_SEQ_CHANNEL_ERROR) Begin
102079>>>            Function_Return GenerateChannelError
102080>>>        End
102080>>>>
102080>>>
102080>>>        If (hTable < 1 or nVersionNumber <= 0) Begin
102082>>>            Function_Return GenerateUserInputError
102083>>>        End
102083>>>>
102083>>>
102083>>>        Send Initialize_StatusPanel of ghoStatusPanel "The Database Update Framework" "Generating Update Code" ""
102084>>>        Send Start_StatusPanel of ghoStatusPanel
102085>>>        Set pbVisible of ghoProgressBar to True
102086>>>        Set pbVisible of ghoProgressBarOverall to True
102087>>>        Set piMaximum of ghoProgressBarOverall to iTables
102088>>>        
102088>>>        Move CompareTableBooleans.bApiTableUpdateAuto       to bApiTableUpdateAuto
102089>>>        Move CompareTableBooleans.bCompareDate_DateTime     to bCompare_DateTime
102090>>>        Move CompareTableBooleans.bCompareFilelistUppercase to bCompareFilelistUppercase
102091>>>        Move CompareTableBooleans.bCompareIndexAscending    to bCompareIndexAscending
102092>>>        Move CompareTableBooleans.bCompareIndexUppercase    to bCompareIndexUppercase
102093>>>
102093>>>        Get UtilTableOpen of ghoDbUpdateFunctionLibrary hTable "" DF_SHARE to bOpened
102094>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
102097>>>        If (bOpened = False) Begin
102099>>>            Send Seq_Close_Channel iCh
102100>>>            Set phTable to hTable
102101>>>            Set psFileName to TheData[iTable].sLogicalName
102102>>>            Function_Return GenerateOpenTableError
102103>>>        End
102103>>>>
102103>>>
102103>>>        Writeln channel iCh "/" "/ " CS_DatabaseUpdateFramework
102108>>>        Writeln channel iCh ("/" + "/ Created by: 'DUF Update Code Generator'. Created:" * String(dtCreationTime))
102111>>>        Writeln channel iCh ("Use cDbUpdateVersion.pkg")
102114>>>        Writeln channel iCh
102116>>>        Writeln channel iCh ("Object oDbUpdateVersion" + String(nVersionNumber) * "is a cDbUpdateVersion")
102119>>>        Writeln channel iCh ("    Set pnVersionNumber to" * String(nVersionNumber))
102122>>>        Writeln channel iCh ("    Procedure OnUpdate")
102125>>>        Writeln channel iCh ("        Boolean bOK")
102128>>>        Writeln channel iCh ("        tAPITableNameInfo APITableNameInfo")
102131>>>        Writeln channel iCh ("        tAPIColumn[]   APIColumns APIColumnEmpty")
102134>>>        Writeln channel iCh ("        tAPIIndex[]    APIIndexes APIIndexEmpty")
102137>>>        Writeln channel iCh ("        tAPIRelation[] APIRelations APIRelationEmpty")
102140>>>        Writeln channel iCh ("        Integer iCount iSegment")
102143>>>        Writeln channel iCh ("        Handle hTable")
102146>>>        Writeln channel iCh
102148>>>        Writeln channel iCh ("        Set pbUseConnectionID       to" * If(bUseConnectionID, "True", "False"))
102151>>>        Writeln channel iCh ("        Set pbToAnsi                to" * If(bANSI, "True", "False"))
102154>>>        Writeln channel iCh ("        Set pbRecnum                to" * If(bRecnum, "True", "False"))
102157>>>        Writeln channel iCh ("        Set pbApiTableUpdateAuto    to" * If(bApiTableUpdateAuto, "True", "False"))
102160>>>        Writeln channel iCh ("        Set pbCompareDate_DateTime  to" * If(bCompare_DateTime, "True", "False"))
102163>>>        Writeln channel iCh ("        Set pbCompareIndexAscending to" * If(bCompareIndexAscending, "True", "False"))
102166>>>        Writeln channel iCh ("        Set pbCompareIndexUppercase to" * If(bCompareIndexUppercase, "True", "False"))
102169>>>        Writeln channel iCh
102171>>>        Writeln channel iCh ("        Set Allow_Cancel_State of ghoStatusPanel  to False")
102174>>>        Writeln channel iCh ("        Set pbVisible    of ghoProgressBarOverall to True")
102177>>>        Writeln channel iCh ("        Set piPosition   of ghoProgressBarOverall to 0")
102180>>>        Writeln channel iCh ("        Set piMaximum    of ghoProgressBarOverall to" * String(iTables))
102183>>>        Writeln channel iCh ("        Set piAdvanceBy  of ghoProgressBarOverall to 1")
102186>>>        Writeln channel iCh ("        Send DoAdvance   of ghoProgressBarOverall")   
102189>>>        Writeln channel iCh ("        Move 0 to iCount")
102192>>>        Writeln channel iCh
102194>>>
102194>>>        // Create Definitions:
102194>>>        Move 0 to iTable
102195>>>        For iTable from 0 to iTables
102201>>>>
102201>>>            Set piPosition of ghoProgressBarOverall to iTable
102202>>>            Move TheData[iTable].hTable to hTable
102203>>>            Get UtilTableOpen of ghoDbUpdateFunctionLibrary hTable "" DF_SHARE to bOpened
102204>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpened
102207>>>            If (bOpened = False) Begin
102209>>>                Send Seq_Close_Channel iCh
102210>>>                Set phTable to hTable
102211>>>                Set psTableName to TheData[iTable].sLogicalName
102212>>>                Function_Return GenerateOpenTableError
102213>>>            End
102213>>>>
102213>>>            
102213>>>            Move (Uppercase(TheData[iTable].sLogicalName) = "DBVERSION") to bSkipTable
102214>>>
102214>>>            If (bSkipTable = False) Begin
102216>>>                Move TheData[iTable].sLogicalName to APITableNameInfo.sLogicalName
102217>>>                Set Action_Text of ghoStatusPanel to ("Number:" * String(APITableNameInfo.iTableNumber) * String(sLogicalName))
102218>>>
102218>>>                Move hTable                       to APITableNameInfo.iTableNumber
102219>>>                Move TheData[iTable].sRootName    to sRootName
102220>>>                Get _TableNameOnly of ghoDbUpdateFunctionLibrary sRootName to sTableName
102221>>>                Move sRootName                    to APITableNameInfo.sRootName
102222>>>
102222>>>                Move TheData[iTable].sDisplayName to APITableNameInfo.sDisplayName
102223>>>                Move TheData[iTable].bIsAlias     to bIsAlias
102224>>>                Move bIsAlias                     to APITableNameInfo.bIsAlias
102225>>>                Get _UtilTableIsSql of ghoDbUpdateFunctionLibrary hTable to APITableNameInfo.bIsSQL
102226>>>
102226>>>                // Get the Driver ID
102226>>>                Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
102229>>>                Get IsDAWSQLDriver of ghoDbUpdateFunctionLibrary sDriverID to bDawSqlDriver
102230>>>                Get IsSQLDriver    of ghoDbUpdateFunctionLibrary sDriverID to bSqlDriver
102231>>>
102231>>>                If (bIsAlias = False) Begin
102233>>>                    Set Action_Text of ghoStatusPanel to ("Number:" * String(APITableNameInfo.iTableNumber) * String(APITableNameInfo.sLogicalName))
102234>>>                    Get UtilColumnsStructFill of ghoDbUpdateFunctionLibrary hTable to APIColumns
102235>>>                    If (APIColumns[0].bError = True) Begin
102237>>>                        Function_Return GenerateError
102238>>>                    End
102238>>>>
102238>>>                    If (APIColumns[0].bCancel = True) Begin
102240>>>                        Function_Return GenerateUserCancel
102241>>>                    End
102241>>>>
102241>>>                    Move (SizeOfArray(APIColumns)) to iSize
102242>>>                    Decrement iSize
102243>>>                    If (iSize >= 0) Begin
102245>>>                        Writeln channel iCh ("        // Logical Table Name:" * '"' + APITableNameInfo.sLogicalName + '"' * "Filelist.cfg Number:" * String(APITableNameInfo.iTableNumber))
102248>>>                        Writeln channel iCh ("        Move" * String(APITableNameInfo.iTableNumber)                    * "to APITableNameInfo.iTableNumber")
102251>>>                        Writeln channel iCh ("        Move" * '"' + String(APITableNameInfo.sRootName)    + '"'        * "to APITableNameInfo.sRootName")
102254>>>                        Writeln channel iCh ("        Move" * '"' + String(APITableNameInfo.sLogicalName) + '"'        * "to APITableNameInfo.sLogicalName")
102257>>>                        Writeln channel iCh ("        Move" * '"' + String(APITableNameInfo.sDisplayName) + '"'        * "to APITableNameInfo.sDisplayName")
102260>>>                        Writeln channel iCh ("        Move" * '"' + String(sDriverID)                     + '"'        * "to APITableNameInfo.sDriverID")
102263>>>                        Writeln channel iCh ("        Move" * String(If(APITableNameInfo.bIsAlias,      "True", "False")) * "to APITableNameInfo.bIsAlias")
102266>>>                        Writeln channel iCh ("        Move" * String(If(APITableNameInfo.bIsSQL,        "True", "False")) * "to APITableNameInfo.bIsSQL")
102269>>>                        Writeln channel iCh ("        Move" * String(If(APITableNameInfo.bIsSystemFile, "True", "False")) * "to APITableNameInfo.bIsSystemFile")
102272>>>                        Writeln channel iCh
102274>>>                        Writeln channel iCh ("        // Table:" * '"' + APITableNameInfo.sLogicalName + '"' * "Column: 1")
102277>>>                    End
102277>>>>
102277>>>
102277>>>                    For iCount from 0 to iSize
102283>>>>
102283>>>                        Writeln channel iCh ("        Move" *       String(APIColumns[iCount].iFieldNumber)       * "to APIColumns[iCount].iFieldNumber")
102286>>>                        Writeln channel iCh ("        Move" * '"' + String(APIColumns[iCount].sFieldName)   + '"' * "to APIColumns[iCount].sFieldName")
102289>>>                        Writeln channel iCh ("        Move" *       String(APIColumns[iCount].iType)              * "to APIColumns[iCount].iType")
102292>>>                        Writeln channel iCh ("        Move" * String(If(APIColumns[iCount].bIsSQLType, "True", "False")) * "to APIColumns[iCount].bIsSQLType")
102295>>>                        Writeln channel iCh ("        Move" * String(If(APIColumns[iCount].bAllowNULL, "True", "False")) * "to APIColumns[iCount].bAllowNULL")
102298>>>                        Writeln channel iCh ("        Move" * '"' + String(APIColumns[iCount].sDefaultValue) + '"'       * "to APIColumns[iCount].sDefaultValue")
102301>>>                        If (APIColumns[iCount].iFieldNumber = 0 and APIColumns[iCount].iLength = 0) Begin
102303>>>                            Writeln channel iCh ("        ERROR! This field has a length = 0! It must be corrected before running this code")
102306>>>                            Increment iErrors
102307>>>                        End
102307>>>>
102307>>>                        Move APIColumns[iCount].sType to sDataType
102308>>>                        If (Lowercase(sDataType) contains "identity") Begin
102310>>>                            Move (Replace("identity",sDataType, "")) to sDataType
102311>>>                            Move (Trim(sDataType)) to sDataType
102312>>>                        End
102312>>>>
102312>>>                        Writeln channel iCh ("        Move" * '"' + sDataType                               + '"' * "to APIColumns[iCount].sType")
102315>>>                        Writeln channel iCh ("        Move" *       String(APIColumns[iCount].iLength)            * "to APIColumns[iCount].iLength")
102318>>>                        Writeln channel iCh ("        Move" *       String(APIColumns[iCount].iPrecision)         * "to APIColumns[iCount].iPrecision")
102321>>>                        Writeln channel iCh ("        Move" *       String(APIColumns[iCount].iOptions)           * "to APIColumns[iCount].iOptions")
102324>>>
102324>>>                        If (iCount < iSize) Begin
102326>>>                            Writeln channel iCh ("        Increment iCount")
102329>>>                            Writeln channel iCh
102331>>>                            Writeln channel iCh ("        // Table:" * '"' + APITableNameInfo.sLogicalName + '"' * "Column:" * String(iCount + 2))
102334>>>                        End
102334>>>>
102334>>>                    Loop
102335>>>>
102335>>>
102335>>>                    // Create Index Definitions:
102335>>>                    Get UtilIndexesStructFill of ghoDbUpdateFunctionLibrary hTable to APIIndexes
102336>>>                    If (APIIndexes[0].bError = True) Begin
102338>>>                        Function_Return GenerateError
102339>>>                    End
102339>>>>
102339>>>                    If (APIIndexes[0].bCancel = True) Begin
102341>>>                        Function_Return GenerateUserCancel
102342>>>                    End
102342>>>>
102342>>>                    Move (SizeOfArray(APIIndexes)) to iIndexes
102343>>>                    Decrement iIndexes
102344>>>                    If (iIndexes >= 0) Begin
102346>>>                        Writeln channel iCh
102348>>>                        Writeln channel iCh ("        // Table:" * '"' + APITableNameInfo.sLogicalName + '"' * "Index: 1")
102351>>>                        Writeln channel iCh ("        Move 0 to iCount")
102354>>>                        Writeln channel iCh ("        Move 0 to iSegment")
102357>>>                    End
102357>>>>
102357>>>                    For iIndex from 0 to iIndexes
102363>>>>
102363>>>                        Writeln channel     iCh ("        Move" *       String(APIIndexes[iIndex].iIndexNumber)        * "to APIIndexes[iCount].iIndexNumber")
102366>>>                        Writeln channel     iCh ("        Move" *       String(APIIndexes[iIndex].iPrimaryIndex)       * "to APIIndexes[iCount].iPrimaryIndex")
102369>>>                        Writeln channel     iCh ("        Move" *       String(APIIndexes[iIndex].iSQLIndexType)       * "to APIIndexes[iCount].iSQLIndexType")
102372>>>                        Writeln channel     iCh ("        Move" *       If((APIIndexes[iIndex].bIsSQLClustered),  "True", "False") * "to APIIndexes[iCount].bIsSQLClustered")
102375>>>                        Writeln channel     iCh ("        Move" *       If((APIIndexes[iIndex].bIsSQLPrimaryKey), "True", "False") * "to APIIndexes[iCount].bIsSQLPrimaryKey")
102378>>>                        If (APIIndexes[iIndex].sSQLIndexName <> "") Begin
102380>>>                            Writeln channel iCh ("        Move" * '"' + String(APIIndexes[iIndex].sSQLIndexName) + '"' * "to APIIndexes[iCount].sSQLIndexName")
102383>>>                        End
102383>>>>
102383>>>
102383>>>                        Move (SizeOfArray(APIIndexes[iIndex].IndexSegmentArray)) to iNumSegments
102384>>>                        Decrement iNumSegments
102385>>>                        For iSegment from 0 to iNumSegments
102391>>>>
102391>>>                            Writeln channel iCh ("        Move" *       String(APIIndexes[iIndex].IndexSegmentArray[iSegment].iFieldNumber)              * "to APIIndexes[iCount].IndexSegmentArray[iSegment].iFieldNumber")
102394>>>                            Writeln channel iCh ("        Move" * '"' + String(APIIndexes[iIndex].IndexSegmentArray[iSegment].sFieldName)          + '"' * "to APIIndexes[iCount].IndexSegmentArray[iSegment].sFieldName")
102397>>>                            Writeln channel iCh ("        Move" *       If((APIIndexes[iIndex].IndexSegmentArray[iSegment].bUppercase), "True", "False") * "to APIIndexes[iCount].IndexSegmentArray[iSegment].bUppercase")
102400>>>                            Writeln channel iCh ("        Move" *       If((APIIndexes[iIndex].IndexSegmentArray[iSegment].bAscending), "True", "False") * "to APIIndexes[iCount].IndexSegmentArray[iSegment].bAscending")
102403>>>                            If (iSegment < iNumSegments) Begin
102405>>>                                Writeln channel iCh ("        Increment iSegment")
102408>>>                            End
102408>>>>
102408>>>                        Loop
102409>>>>
102409>>>
102409>>>                        If (iIndex < iIndexes) Begin
102411>>>                            Writeln channel iCh ("        Increment iCount")
102414>>>                            Writeln channel iCh
102416>>>                            Writeln channel iCh ("        // Table:" * '"' + APITableNameInfo.sLogicalName + '"' * "Index:" * String(iIndex + 2))
102419>>>                            Writeln channel iCh ("        Move 0 to iSegment")
102422>>>                        End
102422>>>>
102422>>>                    Loop
102423>>>>
102423>>>
102423>>>                    // Create Relation Definitions:
102423>>>                    Get UtilRelationsStructFill of ghoDbUpdateFunctionLibrary hTable to APIRelations
102424>>>                    If (APIRelations[0].bError = True) Begin
102426>>>                        Function_Return GenerateError
102427>>>                    End
102427>>>>
102427>>>                    If (APIRelations[0].bCancel = True) Begin
102429>>>                        Function_Return GenerateUserCancel
102430>>>                    End
102430>>>>
102430>>>                    Move (SizeOfArray(APIRelations)) to iSize
102431>>>                    Decrement iSize
102432>>>                    If (iSize >= 0) Begin
102434>>>                        Writeln channel iCh
102436>>>                        Writeln channel iCh ("        // Table:" * '"' + APITableNameInfo.sLogicalName + '"' * "Relation: 1")
102439>>>                        Writeln channel iCh ("        Move 0 to iCount")
102442>>>                    End
102442>>>>
102442>>>                    For iCount from 0 to iSize
102448>>>>
102448>>>                        Writeln channel iCh ("        Move" * String(APIRelations[iCount].hTableFrom)  * "to APIRelations[iCount].hTableFrom")
102451>>>                        Writeln channel iCh ("        Move" * String(APIRelations[iCount].iColumnFrom) * "to APIRelations[iCount].iColumnFrom")
102454>>>                        Writeln channel iCh ("        Move" * String(APIRelations[iCount].hTableTo)    * "to APIRelations[iCount].hTableTo")
102457>>>                        Writeln channel iCh ("        Move" * String(APIRelations[iCount].iColumnTo)   * "to APIRelations[iCount].iColumnTo")
102460>>>                        If (iCount < iSize) Begin
102462>>>                            Writeln channel iCh ("        Increment iCount")
102465>>>                            Writeln channel iCh
102467>>>                            Writeln channel iCh ("        // Table:" * '"' + APITableNameInfo.sLogicalName + '"' * "Relation:" * String(iCount + 2))
102470>>>                        End
102470>>>>
102470>>>                    Loop
102471>>>>
102471>>>
102471>>>                    // Create Table Update Definition:
102471>>>                    Writeln channel iCh
102473>>>                    Writeln channel iCh ("        Get ApiTableUpdate APITableNameInfo APIColumns APIIndexes APIRelations to bOK")
102476>>>                    Writeln channel iCh
102478>>>
102478>>>                    Writeln channel iCh ("        Move APIColumnEmpty   to APIColumns")
102481>>>                    Writeln channel iCh ("        Move APIRelationEmpty to APIRelations")
102484>>>                    Writeln channel iCh ("        Move APIIndexEmpty    to APIIndexes")
102487>>>                    Writeln channel iCh ("        Move 0 to iCount")
102490>>>                    Writeln channel iCh ("        Send DoAdvance of ghoProgressBarOverall")
102493>>>                    Writeln channel iCh
102495>>>                End
102495>>>>
102495>>>
102495>>>                If (bIsAlias = True) Begin
102497>>>                    // Create Alias Table Definition:
102497>>>                    Writeln channel iCh ("        // Create Alias Table Definition:")
102500>>>                    Writeln channel iCh ("        Move" * String(hTable) * "to hTable")
102503>>>                    If (bSqlDriver = True and not(APITableNameInfo.sRootName contains sDriverID)) Begin
102505>>>                        Writeln channel iCh ("        Set_Attribute DF_FILE_ROOT_NAME    of hTable to" * '"' + sDriverID + ":" + APITableNameInfo.sRootName    + '"')
102508>>>                    End
102508>>>>
102508>>>                    Else Begin
102509>>>                        Writeln channel iCh ("        Set_Attribute DF_FILE_ROOT_NAME    of hTable to" * '"' + APITableNameInfo.sRootName    + '"')
102512>>>                    End
102512>>>>
102512>>>
102512>>>                    Writeln channel iCh ("        Set_Attribute DF_FILE_LOGICAL_NAME of hTable to" * '"' + APITableNameInfo.sLogicalName + '"')
102515>>>                    Writeln channel iCh ("        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to" * '"' + APITableNameInfo.sDisplayName + '"')
102518>>>                    Writeln channel iCh
102520>>>                End
102520>>>>
102520>>>            End
102520>>>>
102520>>>            Get Check_StatusPanel of ghoStatusPanel to iStatus
102521>>>            If (iStatus <> 0) Begin
102523>>>                Send Seq_Close_Channel iCh
102524>>>                Function_Return GenerateUserCancel
102525>>>            End         
102525>>>>
102525>>>            
102525>>>            Close hTable
102526>>>        Loop // Main TheData loop
102527>>>>
102527>>>
102527>>>        Writeln channel iCh ("    End_Procedure")
102530>>>        Writeln channel iCh ("End_Object")
102533>>>
102533>>>        Send Seq_Close_Channel iCh
102534>>>        Function_Return GenerateOK
102535>>>    End_Function
102536>>>
102536>>>    Function DFTypeToDUFType Integer iDataFlexDataType Returns String
102539>>>        String sRetval
102539>>>        Case Begin
102539>>>            Case (iDataFlexDataType = DF_ASCII)
102541>>>                Move DF_ASCII_DUF to sRetval
102542>>>                Case Break
102543>>>            Case (iDataFlexDataType = DF_BCD)
102546>>>                Move "DF_BCD_DUF" to sRetval
102547>>>                Case Break
102548>>>            Case (iDataFlexDataType = DF_BINARY)
102551>>>                Move "DF_BINARY_DUF" to sRetval
102552>>>                Case Break
102553>>>            Case (iDataFlexDataType = DF_DATE)
102556>>>                Move "DF_DATE_DUF" to sRetval
102557>>>                Case Break
102558>>>            Case (iDataFlexDataType = DF_DATETIME)
102561>>>                Move "DF_DATETIME_DUF" to sRetval
102562>>>                Case Break
102563>>>            Case (iDataFlexDataType = DF_TEXT)
102566>>>                Move "DF_TEXT_DUF" to sRetval
102567>>>                Case Break
102568>>>            Case Else
102568>>>                Move iDataFlexDataType to sRetval
102569>>>        Case End
102569>>>
102569>>>        Function_Return sRetval
102570>>>    End_Function
102571>>>
102571>>>    Procedure Request_Clear    
102574>>>        tSQLConnection Connection
102574>>>        tSQLConnection Connection
102574>>>        tDataSourceRow[] EmptyData
102574>>>        tDataSourceRow[] EmptyData
102575>>>        Handle hoGrid hoDataSource
102575>>>        Integer[] iDifferencesEmpty
102576>>>        
102576>>>        Move DATAFLEX_ID to Connection.sDriverID
102577>>>        Set pSQLConnection of ghoSQLConnectionHandler to Connection
102578>>>        Move (oFilelist_grd(Self))  to hoGrid
102579>>>        Get phoDataSource of hoGrid to hoDataSource
102580>>>        Send InitializeData of hoGrid EmptyData
102581>>>        Send ResetFilelistPathing of ghoApplication
102582>>>        Set Value of oFilelistPath_fm    to ""
102583>>>        Set Value of oPnVersionNumber_fm to 1.0
102584>>>        Set Value of oSourceName_fm      to ""
102585>>>        Set phDbVersion of oFilelist_grd to 0
102586>>>        Set psFilelistFrom of ghoApplication to ""
102587>>>        Set psFooterText of oLogicalName_col to "No of Tables:"
102588>>>        Set psFooterText of oRootName_col    to "Selected:"
102589>>>        Set psFooterText of oIsAlias_Col     to "Alias:"
102590>>>        Send Activate of oFilelistPath_fm    
102591>>>    End_Procedure
102592>>>
102592>>>    Procedure TagChangedTables String sFromFilelist Integer[] iaDifferences
102595>>>        Integer iSize iCount iItem iItems iTableNo iTableNo_Col iCheckbox_Col
102595>>>        Handle hoGrid hoDataSource
102595>>>        tDataSourceRow[] TheData
102595>>>        tDataSourceRow[] TheData
102596>>>
102596>>>        Set Value of oFilelistPath_fm to sFromFilelist
102597>>>        Move (oFilelist_grd(Self)) to hoGrid
102598>>>
102598>>>        Get piColumnId of (oFilelistNumber_col(hoGrid)) to iTableNo_Col
102599>>>        Get piColumnId of (oCheckbox_Col(hoGrid))       to iCheckbox_Col
102600>>>        Get phoDataSource of hoGrid to hoDataSource
102601>>>        Get DataSource of hoDataSource to TheData
102602>>>        Move (SizeOfArray(TheData)) to iItems
102603>>>        Decrement iItems
102604>>>
102604>>>        Move (SizeOfArray(iaDifferences)) to iSize
102605>>>        If (iSize = 0) Begin
102607>>>            Procedure_Return
102608>>>        End
102608>>>>
102608>>>        Decrement iSize
102609>>>        If (iSize > 0) Begin
102611>>>//            Send KeyAction of oDeSelectAll_btn  
102611>>>            Set SelectItems of oFilelist_grd to cx_Select_None
102612>>>        End
102612>>>>
102612>>>
102612>>>        For iCount from 0 to iSize
102618>>>>
102618>>>            Move iaDifferences[iCount] to iTableNo
102619>>>            If (iTableNo > 0) Begin
102621>>>                For iItem from 0 to iItems
102627>>>>
102627>>>                    If (TheData[iItem].sValue[iTableNo_Col] = iTableNo) Begin
102629>>>                        Move True to TheData[iItem].sValue[iCheckbox_Col]
102630>>>                        Move iItems to iItem // We found it and we're out of this loop.
102631>>>                    End
102631>>>>
102631>>>                Loop
102632>>>>
102632>>>            End
102632>>>>
102632>>>        Loop
102633>>>>
102633>>>
102633>>>        Send ReInitializeData of hoGrid TheData False
102634>>>        Send DoSetCheckboxFooterText of hoGrid
102635>>>    End_Procedure
102636>>>
102636>>>    Procedure OnSetFocus
102639>>>        If (SizeOfArray(phoActiveUpdates(ghoCommandBars)) <> 0) Begin
102641>>>            Send Execute of (oCodeGenerator_MenuItem(ghoCommandBars))
102642>>>        End
102642>>>>
102642>>>    End_Procedure
102643>>>    
102643>>>    Procedure OnFileDropped String sFilename Boolean bLast
102646>>>        String sTest
102646>>>        Forward Send OnFileDropped sFilename bLast
102648>>>        If (bLast = True) Begin
102650>>>            Get ParseFileName sFilename to sTest
102651>>>            If (Uppercase(sTest) <> "FILELIST.CFG") Begin
102653>>>                Send Info_Box "Sorry, only Filist.cfg files can be dropped here..."
102654>>>                Procedure_Return
102655>>>            End
102655>>>>
102655>>>            Set Value of oFilelistPath_fm to sFilename
102656>>>        End
102656>>>>
102656>>>    End_Procedure
102657>>>
102657>>>//    On_Key Key_Ctrl+Key_A  Send KeyAction of oSelectAll_btn
102657>>>//    On_Key Key_Ctrl+Key_N  Send KeyAction of oDeSelectAll_btn
102657>>>//    On_Key Key_Ctrl+Key_I  Send KeyAction of oInvertSelection_btn
102657>>>    On_Key Key_Ctrl+Key_G  Send KeyAction of oGenerateCode_btn
102658>>>    On_Key Key_Ctrl+Key_O  Send KeyAction of oOpenAppSrcFolder_btn
102659>>>    On_Key kClear          Send Request_Clear
102660>>>    On_Key kClear_All      Send Request_Clear
102661>>>    On_Key Key_Ctrl+Key_F4 Send None
102662>>>End_Object
102663>>>
102663>>>// General purpose access message to auto-fill grid with tables with
102663>>>// differences (after "Compare Databases" has been run).
102663>>>Procedure TagFileNamesForCodeGeneration
102666>>>    String sFileListFrom sCurrentFilelist
102666>>>    Integer[] iaDifferences
102667>>>    Handle ho
102667>>>
102667>>>    Send Activate_oTableDUFCodeGenerator
102668>>>    Move (oTableDUFCodeGenerator(Self)) to ho
102669>>>    Get Value of (oFilelistPath_fm(ho)) to sCurrentFilelist
102670>>>    If (sCurrentFilelist <> "") Begin
102672>>>        Send Request_Clear of ho
102673>>>    End
102673>>>>
102673>>>
102673>>>    Get psFilelistFrom of ghoApplication to sFileListFrom
102674>>>    Get piaDifferences of ghoApplication to iaDifferences
102675>>>    Send TagChangedTables of ho sFileListFrom iaDifferences
102676>>>    Send Info_Box ("Ready marking tables. Number of different tables:" * (String(SizeOfArray(iaDifferences))))
102677>>>End_Procedure
102678>        Use CompareDatabases.vw
Including file: CompareDatabases.vw    (C:\Projects\DF20\DbUpdateFramework\AppSrc\CompareDatabases.vw)
102678>>>Use Windows.pkg
102678>>>Use Dfclient.pkg
102678>>>Use Cursor.pkg
102678>>>Use Batchdd.pkg
102678>>>Use cRDCButton.pkg
102678>>>Use cDbUpdateFunctionLibrary.pkg
102678>>>Use DUFStatusPanel.pkg
102678>>>Use seq_chnl.pkg
102678>>>Use vWin32fh.pkg
102678>>>Use cRDCHeaderGroup.pkg
102678>>>Use cRDCSuggestionIniForm.pkg
102678>>>Use cSQLCheckBox.pkg
102678>>>Use cRDCCommandLinkButton.pkg
102678>>>Use LogFileDialog.dg
Including file: LogFileDialog.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\LogFileDialog.dg)
102678>>>>>Use Windows.pkg
102678>>>>>Use cRDCButtonDPI.pkg
102678>>>>>Use cRichEdit.pkg
102678>>>>>Use seq_chnl.pkg
102678>>>>>Use vWin32fh.pkg
102678>>>>>
102678>>>>>Object oLogFileDialog_dg is a ModalPanel
102680>>>>>    Set Size to 230 435
102681>>>>>    Set Label to "Log File Dialog"
102682>>>>>    Set piMinSize to 89 211
102683>>>>>    Set Location to 2 2
102684>>>>>    Set Border_Style To Border_Thick
102685>>>>>    Set Locate_Mode to Center_On_Parent
102686>>>>>    
102686>>>>>    Property String psLogFileName ""  
102688>>>>>    Property Integer piIndent 
102690>>>>>    
102690>>>>>    Object oLogFile_edt is a cRichEdit
102692>>>>>        Set Size to 185 413
102693>>>>>        Set Location to 16 11
102694>>>>>        Set TextColor to clBlack
102695>>>>>        Set peAnchors to anAll
102696>>>>>        Set Label_Row_Offset to 3
102697>>>>>        Set Label_TextColor to clGreenGreyLight
102698>>>>>        Set Label_FontItalics to True
102699>>>>>        Set piFontSize to 200
102700>>>>>        Set psTypeFace to 'Consolas'
102701>>>>>        
102701>>>>>        Delegate Set piIndent to (piParagraphIndent(Self))
102703>>>>>        
102703>>>>>        Procedure DoSaveDocument
102706>>>>>            String sLogFileName
102706>>>>>            Boolean bOk bOkToSave bChanged
102706>>>>>        
102706>>>>>            Move False to bOkToSave       
102707>>>>>            Get pbCanUndo to bChanged
102708>>>>>            If (bChanged = False) Begin
102710>>>>>                Procedure_Return
102711>>>>>            End
102711>>>>>>
102711>>>>>        
102711>>>>>            Get psLogFileName to sLogFileName
102712>>>>>            Send Write sLogFileName
102713>>>>>            // clear undo buffer on save
102713>>>>>            // we want undo buffer to only apply to the new document
102713>>>>>            Send ClearUndoBuffer
102714>>>>>            Send Info_Box "Changes saved."
102715>>>>>        End_Procedure 
102716>>>>>        
102716>>>>>        Procedure LoadData
102719>>>>>            String sLogFileName
102719>>>>>            Integer iTwips iIndent
102719>>>>>    
102719>>>>>            Get psLogFileName to sLogFileName
102720>>>>>            Set Label to sLogFileName
102721>>>>>            Move 1440 to iTwips
102722>>>>>            Get piIndent to iIndent
102723>>>>>            Set piParagraphIndent to (iIndent + (iTwips * 0.2))
102724>>>>>            
102724>>>>>            Send Read sLogFileName
102725>>>>>        End_Procedure
102726>>>>>    
102726>>>>>        On_Key Key_Ctrl+Key_S Send DoSaveDocument
102727>>>>>        On_Key kCancel Send Cancel
102728>>>>>    End_Object
102729>>>>>
102729>>>>>    Object oCancel_Btn is a cRDCButtonDPI
102731>>>>>        Set Label    to "&Close"
102732>>>>>        Set Location to 209 374
102733>>>>>        Set peAnchors to anBottomRight
102734>>>>>
102734>>>>>        Procedure OnClick
102737>>>>>            Send Close_Panel
102738>>>>>        End_Procedure
102739>>>>>
102739>>>>>    End_Object
102740>>>>>
102740>>>>>
102740>>>>>    Object oFirstRun_btn is a cRDCButtonDPI
102742>>>>>        Set Location to 209 260
102743>>>>>        Set Label to "Beginning"
102744>>>>>        Set peAnchors to anBottomRight
102745>>>>>    
102745>>>>>        Procedure OnClick
102748>>>>>            Send Beginning_of_Data to oLogFile_edt    
102749>>>>>        End_Procedure
102750>>>>>    
102750>>>>>    End_Object
102751>>>>>    Object oLatestRun_btn is a cRDCButtonDPI
102753>>>>>        Set Location to 209 317
102754>>>>>        Set Label to "End"
102755>>>>>        Set peAnchors to anBottomRight
102756>>>>>    
102756>>>>>        Procedure OnClick
102759>>>>>            Send End_of_Data to oLogFile_edt    
102760>>>>>        End_Procedure
102761>>>>>    
102761>>>>>    End_Object
102762>>>>>
102762>>>>>    // Automatically load data into the grid when activating.
102762>>>>>    Procedure Activating 
102765>>>>>        Handle ho
102765>>>>>        Move (oLogFile_edt(Self)) to ho
102766>>>>>        Send LoadData    of ho
102767>>>>>        // We need to active before we can send end_of_data.
102767>>>>>        Send Activate    of ho
102768>>>>>//        Send End_of_Data to ho
102768>>>>>    End_Procedure
102769>>>>>
102769>>>>>    Procedure Page Integer iPageObject
102772>>>>>        Forward Send Page iPageObject
102774>>>>>        Set Icon to "ViewReportBlack1.ico"
102775>>>>>    End_Procedure      
102776>>>>>    
102776>>>>>    // Put a status bar at the bottom of the panel to add a gripper in the lower right corner.
102776>>>>>    Procedure End_Construct_Object
102779>>>>>        Integer iStyle iSize iOffset
102779>>>>>
102779>>>>>        Forward Send End_Construct_Object
102781>>>>>
102781>>>>>        Get Border_Style to iStyle
102782>>>>>        Move 8 to iOffset
102783>>>>>        If (iStyle = Border_Thick) Begin
102785>>>>>            Object oDialogCommandbar is a cCJCommandBarSystem
102787>>>>>                Object oStatusBar is a cCJStatusBar
102789>>>>>                    Object oStatusIdle is a cCJStatusBarPane
102791>>>>>                        Set piId to sbpIDIdlePane
102792>>>>>                        Set pbStyleStretch to True
102793>>>>>                    End_Object
102794>>>>>                End_Object
102795>>>>>            End_Object
102796>>>>>
102796>>>>>            Get Size to iSize
102797>>>>>            Set Size to (Hi(iSize) + iOffset) (Low(iSize))
102798>>>>>        End
102798>>>>>>
102798>>>>>    End_Procedure
102799>>>>>
102799>>>>>    On_Key Key_Alt+Key_F  Send KeyAction of oFirstRun_btn
102800>>>>>    On_Key Key_Ctrl+Key_F Send KeyAction of oFirstRun_btn
102801>>>>>    On_Key Key_Alt+Key_L  Send KeyAction of oLatestRun_btn
102802>>>>>    On_Key Key_Ctrl+Key_L Send KeyAction of oLatestRun_btn
102803>>>>>    On_Key Key_Alt+Key_C  Send KeyAction of oCancel_Btn
102804>>>>>End_Object
102805>>>>>
102805>>>>>Procedure ActivateLogFileDialog String sLogFile
102808>>>>>    Handle ho       
102808>>>>>    Boolean bExists
102808>>>>>    
102808>>>>>    Get vFilePathExists sLogFile to bExists
102809>>>>>    If (bExists = False) Begin
102811>>>>>        Send Info_Box "The logfile doesn't exist."
102812>>>>>        Procedure_Return
102813>>>>>    End
102813>>>>>>
102813>>>>>    Move (oLogFileDialog_dg(Self)) to ho
102814>>>>>    Set psLogFileName of ho to sLogFile
102815>>>>>    Send Popup of ho
102816>>>>>End_Procedure           
102817>>>
102817>>>Define CS_ReportFileName                for "DUFCompareReport"
102817>>>Define CS_ReportFileNameExtenstion      for ".txt"
102817>>>Define CS_ReportDifferenceNote          for "(*)"
102817>>>Define CS_ReportTableNotFound           for "Table doesn't exist!"
102817>>>Define CS_ReportFieldNotFound           for "Field doesn't exist!"
102817>>>Define CS_ReportIndexNotFound           for "Index doesn't exist!"
102817>>>Define CS_ReportIndexSegmentNotFound    for "Index segment doesn't exist!"
102817>>>Define CS_ReportIndexNotApplicable      for "N/A"
102817>>>Define CS_ReportRelationNotFound        for "Relationship doesn't exist!"
102817>>>Define CS_ReportHeaderUnderWrite        for "===================================================================================="
102817>>>
102817>>>Define CI_ReportColumn1                 for 17
102817>>>Define CI_ReportColumn2                 for 65
102817>>>//Define CI_ReportColumn3                 for 75
102817>>>//Define CI_ReportColumn4                 for 90
102817>>>
102817>>>Struct tRelationDiffs
102817>>>    String sFromFieldsRight
102817>>>    String sFromFields
102817>>>    String sToFields
102817>>>    String sFrom
102817>>>    String sTo
102817>>>End_Struct
102817>>>
102817>>>Global_Variable Integer giDifferenceTables
102817>>>
102817>>>Activate_View Activate_oCompareDatabases_vw for oCompareDatabases_vw
102827>>>>
102827>>>Object oCompareDatabases_vw is a dbView
102829>>>    Set Size to 323 490
102830>>>    Set Label to "Compare"
102831>>>    Set piMinSize to 89 211
102832>>>    Set Border_Style To Border_Thick
102833>>>    Set pbAutoActivate to True
102834>>>    Set pbAcceptDropFiles to True
102835>>>
102835>>>    Object oFromFilelist_grp is a cRDCHeaderGroup
102837>>>        Set Size to 50 462
102838>>>        Set Location to 8 15
102839>>>        Set psImage to "FolderLeft1.ico"
102840>>>        Set Label to "Select FROM Filelist.cfg"
102841>>>        Set psNote to "The development/latest version of the database"  
102842>>>        Set psToolTip to "Select the Filelist.cfg file for the development database"
102843>>>
102843>>>        Object oFilelistPathFrom_fm is a cRDCSuggestionIniForm
102845>>>            Set Size to 12 413
102846>>>            Set Location to 29 29
102847>>>            Set Label_Col_Offset to 0
102848>>>            Set Label_Row_Offset to 1
102849>>>            Set Label_Justification_Mode to JMode_Top
102850>>>            Set Prompt_Button_Mode to PB_PromptOn
102851>>>            Set peAnchors to anTopLeftRight
102852>>>            Set psToolTip to "Select the FROM database Filelist.cfg. This should be the development workspace Data folder's Filelist.cfg"
102853>>>            // This is needed for the toolbar's prompt icon to be active
102853>>>            Set Prompt_Object to Self
102854>>>
102854>>>            Procedure Prompt
102857>>>                String sFileName sPath sFileMask sRetval
102857>>>
102857>>>                Get Value to sFileName
102858>>>                Get ParseFolderName sFileName to sPath
102859>>>                Move "Filelist.cfg files (*.cfg)|*.cfg" to sFileMask
102860>>>                Get vSelect_File sFileMask "Please select a Filelist.cfg file" sPath to sRetval
102861>>>                If (sRetval <> "") Begin
102863>>>                    Set Value to sRetval
102864>>>                End
102864>>>>
102864>>>            End_Procedure
102865>>>
102865>>>            Procedure OnChange
102868>>>                String sValue
102868>>>                Boolean bOK bCfgFile
102868>>>
102868>>>                Get Value to sValue
102869>>>                Get vFilePathExists sValue to bOK
102870>>>                Move (Lowercase(sValue) contains ".cfg") to bCfgFile
102871>>>                If (bOK = True and bCfgFile) Begin
102873>>>                    Get ChangeFilelistPathing of ghoApplication sValue to bOK
102874>>>                    If (bOK = True) Begin
102876>>>                        Set psFilelistFrom of ghoApplication to sValue
102877>>>                    End
102877>>>>
102877>>>                End
102877>>>>
102877>>>
102877>>>            End_Procedure
102878>>>
102878>>>            On_Key Key_Ctrl+Key_W Send None
102879>>>            On_Key Key_Ctrl+Key_Q Send None
102880>>>        End_Object
102881>>>
102881>>>    End_Object
102882>>>
102882>>>    Object oToFilelist_grp is a cRDCHeaderGroup
102884>>>        Set Size to 50 462
102885>>>        Set Location to 69 15
102886>>>        Set psImage to "FolderRight1.ico"
102887>>>        Set Label to "Select TO Filelist.cfg"
102888>>>        Set psNote to "The customer/current version of the database"   
102889>>>        Set psToolTip to "Select the Filelist.cfg file for the database that needs to be updated"
102890>>>
102890>>>        Object oFilelistPathTo_fm is a cRDCSuggestionIniForm
102892>>>            Set Size to 12 413
102893>>>            Set Location to 29 28
102894>>>            Set Label_Col_Offset to 0
102895>>>            Set Label_Row_Offset to 1
102896>>>            Set Label_Justification_Mode to JMode_Top
102897>>>            Set Prompt_Button_Mode to PB_PromptOn
102898>>>            Set peAnchors to anTopLeftRight
102899>>>            Set psToolTip to "Select the TO database Filelist.cfg"
102900>>>            Set Prompt_Object to Self
102901>>>
102901>>>            Procedure Prompt
102904>>>                String sFileName sPath sFileMask sRetval
102904>>>
102904>>>                Get Value to sFileName
102905>>>                Get ParseFolderName sFileName to sPath
102906>>>                Move "Filelist.cfg files (*.cfg)|*.cfg" to sFileMask
102907>>>                Get vSelect_File sFileMask "Please select a Filelist.cfg file" sPath to sRetval
102908>>>                If (sRetval <> "") Begin
102910>>>                    Set Value to sRetval
102911>>>                End
102911>>>>
102911>>>            End_Procedure
102912>>>
102912>>>            Procedure OnChange
102915>>>                String sValue sPath sReportName sToday
102915>>>                Date dToday
102915>>>                Boolean bOK bCfgFile
102915>>>
102915>>>                Get Value to sValue
102916>>>                Get vFilePathExists sValue to bOK
102917>>>                Move (Lowercase(sValue) contains ".cfg") to bCfgFile
102918>>>                If (bOK = False or bCfgFile = False) Begin
102920>>>                    Procedure_Return
102921>>>                End
102921>>>>
102921>>>
102921>>>                Set psFilelistFrom of ghoApplication to sValue
102922>>>                Sysdate dToday  
102923>>>                Move dToday to sToday
102924>>>                Move (Replaces("/", sToday, "-")) to sToday
102925>>>                Move (Replaces(".", sToday, "-")) to sToday
102926>>>                Get Value to sPath
102927>>>                Get ParseFolderName sPath to sPath
102928>>>                Get vFolderFormat   sPath to sPath
102929>>>                Move (sPath + CS_ReportFileName + String(sToday) + CS_ReportFileNameExtenstion) to sReportName
102930>>>                Set Value of oReportFileName_fm to sReportName
102931>>>            End_Procedure
102932>>>
102932>>>            On_Key Key_Ctrl+Key_W Send None
102933>>>            On_Key Key_Ctrl+Key_Q Send None
102934>>>        End_Object
102935>>>
102935>>>    End_Object
102936>>>
102936>>>    Object oCompareProperties_grp is a cRDCHeaderGroup
102938>>>        Set Size to 59 462
102939>>>        Set Location to 130 15
102940>>>        Set Label to "Configure Database Compare"
102941>>>        Set psNote to "Select checkboxes to configure the comparison"
102942>>>        Set psImage to "Settings1.ico" 
102943>>>        Set psToolTip to "Configure what will be compared"
102944>>>        
102944>>>        Object oCompareDate_DataTime_cb is a cSQLCheckBox
102946>>>            Set Size to 9 123
102947>>>            Set Location to 28 30
102948>>>            Set Label to "Check Date/DataTime difference"
102949>>>            Set psToolTip to "Check Date to DateTime column differences"
102950>>>            Set Checked_State to False
102951>>>        End_Object
102952>>>
102952>>>        Object oCompareIndexAscending_cb is a cSQLCheckBox
102954>>>            Set Size to 9 134
102955>>>            Set Location to 28 199
102956>>>            Set Label to "Check Index Ascending/Descending"
102957>>>            Set Checked_State to False
102958>>>            Set psToolTip to "Compare if Index is Ascending/Descending. (In SQL this setting is set for the whole database by selecting a 'Collation', so then checking this per table doesn't make sense)"
102959>>>        End_Object
102960>>>
102960>>>        Object oCompareIndexUppercase_cb is a cSQLCheckBox
102962>>>            Set Size to 9 117
102963>>>            Set Location to 41 30
102964>>>            Set Label to "Check Index Lower/Uppercase"
102965>>>            Set Checked_State to False
102966>>>            Set psToolTip to "Compare if Index is Uppercase/Lowercase. (In SQL this setting is set for the whole database by selecting a 'Collation', so then checking this per table doesn't make sense)"
102967>>>        End_Object
102968>>>
102968>>>        Object oIgnoreFilelistUppercase_cb is a cSQLCheckBox
102970>>>            Set Size to 9 156
102971>>>            Set Location to 41 199
102972>>>            Set Label to "Ignore Filelist Entries Uppercase/Lowercase"
102973>>>            Set Checked_State to True
102974>>>            Set psToolTip to "Check Filelist.cfg RootName, LogicalName and DisplayName uppercase/lowercase differences"
102975>>>        End_Object
102976>>>
102976>>>    End_Object
102977>>>
102977>>>    Object oReportFilename_grp is a cRDCHeaderGroup
102979>>>        Set Size to 51 462
102980>>>        Set Location to 200 15
102981>>>        Set psImage to "ActionPrintSave1.ico"
102982>>>        Set Label to "Report File Name"
102983>>>        Set psNote to "Output file name"    
102984>>>        Set psToolTip to "The name of the report file that contains the compare result"
102985>>>        
102985>>>        Object oReportFileName_fm is a Form
102987>>>            Set Size to 12 413
102988>>>            Set Location to 29 29
102989>>>            Set Label_Col_Offset to 0
102990>>>            Set Label_Row_Offset to 1
102991>>>            Set Label_Justification_Mode to JMode_Top
102992>>>            Set Prompt_Button_Mode to PB_PromptOn
102993>>>            Set peAnchors to anTopLeftRight
102994>>>            Set psToolTip to "The name of the output text file for database differences that will be generated"
102995>>>            Set Status_Help to "The name of the output text file for database differences that will be generated"
102996>>>            Set Prompt_Object to Self
102997>>>
102997>>>            Procedure Prompt
103000>>>                String sFileName sPath sFileMask sRetval
103000>>>
103000>>>                Get Value to sFileName
103001>>>                Get ParseFolderName sFileName to sPath
103002>>>                Move "Text files (*.txt)|*.txt" to sFileMask
103003>>>                Get vSelect_File sFileMask "Please select a text file for the report" sPath to sRetval
103004>>>                If (sRetval <> "") Begin
103006>>>                    Set Value to sRetval
103007>>>                End
103007>>>>
103007>>>            End_Procedure
103008>>>
103008>>>            On_Key Key_Ctrl+Key_W Send None
103009>>>            On_Key Key_Ctrl+Key_Q Send None
103010>>>        End_Object
103011>>>
103011>>>    End_Object
103012>>>
103012>>>    Procedure MainProcess
103015>>>        String sFilelistFrom sFilelistTo
103015>>>        Integer[] iaDifferences
103016>>>        Integer iSize iRetval hTable
103016>>>        Boolean bFromExists bToExists
103016>>>        tAPITableBooleans CompareCheckBoxes
103016>>>        tAPITableBooleans CompareCheckBoxes
103016>>>        DateTime dtExecStart dtExecEnd
103016>>>        TimeSpan tsTotalTime
103016>>>
103016>>>        Move (CurrentDateTime()) to dtExecStart
103017>>>        Get Value of oFilelistPathFrom_fm to sFilelistFrom
103018>>>        Get vFilePathExists sFilelistFrom to bFromExists
103019>>>        Get Value of oFilelistPathTo_fm   to sFilelistTo
103020>>>        Get vFilePathExists sFilelistTo   to bToExists
103021>>>
103021>>>        If (bFromExists = False or bToExists = False) Begin
103023>>>            Send Info_Box "You first need to select a 'FROM' and a 'TO' Filelist.cfg."
103024>>>            Procedure_Return
103025>>>        End
103025>>>>
103025>>>
103025>>>        Move 0 to giDifferenceTables
103026>>>        Get Checked_State of oCompareDate_DataTime_cb    to CompareCheckBoxes.bCompareDate_DateTime
103027>>>        Get Checked_State of oCompareIndexAscending_cb   to CompareCheckBoxes.bCompareIndexAscending
103028>>>        Get Checked_State of oCompareIndexUppercase_cb   to CompareCheckBoxes.bCompareIndexUppercase
103029>>>        Get Checked_State of oIgnoreFilelistUppercase_cb to CompareCheckBoxes.bCompareFilelistUppercase
103030>>>
103030>>>        Get CompareAndOutputDiffs sFilelistFrom sFilelistTo CompareCheckBoxes dtExecStart to iaDifferences
103031>>>        Set piaDifferences of ghoApplication to iaDifferences
103032>>>
103032>>>        Send Stop_StatusPanel of ghoStatusPanel
103033>>>        Move (CurrentDateTime()) to dtExecEnd
103034>>>        Move (dtExecEnd - dtExecStart) to tsTotalTime
103035>>>        Move (SizeOfArray(iaDifferences)) to iSize
103036>>>
103036>>>        Case Begin
103036>>>            Case (iSize = 0)
103038>>>                Send Info_Box "No differences found. The two databases should be identical."
103039>>>                Case Break
103040>>>            Case (iaDifferences[0] >= 1)
103043>>>                Get YesNo_Box ("Ready! (Time elapsed:" * String(tsTotalTime) + ")\n" + String(iSize) * "Differences found. View the report now?") to iRetval
103044>>>                If (iRetval = MBR_Yes) Begin
103046>>>                    Send DoShowReport of oViewReport_Btn
103047>>>                End
103047>>>>
103047>>>                Case Break
103048>>>            Case (iaDifferences[0] = -1)
103051>>>                Send Info_Box "Process interrupted."
103052>>>                Case Break
103053>>>            Case (iaDifferences[0] < -1)
103056>>>                Move iaDifferences[0]  to hTable
103057>>>                Move (999999 + hTable * -1) to hTable
103058>>>                Send Info_Box ("Process not complete. Couldn't open table number:" * String(hTable))
103059>>>                Send DoShowReport of oViewReport_Btn
103060>>>                Case Break
103061>>>            Case Else
103061>>>                Send Info_Box "An unknown error occured. Process interrupted."
103062>>>        Case End
103062>>>
103062>>>        Send Activate of oFilelistPathFrom_fm
103063>>>    End_Procedure
103064>>>
103064>>>    Function CompareAndOutputDiffs String sFilelistFrom String sFilelistTo tAPITableBooleans CompareCheckBoxes DateTime dtExecStart Returns Integer[]
103067>>>        Integer iSize iCount iNoOfTablesFrom iNoOfTablesTo iCh
103067>>>        Boolean bIsSame bFilelistError bUserCancel bOK bCollationDiff bIsEmbedded
103067>>>        Handle hTable
103067>>>        String sLogicalName sDatabaseCollationFrom sDatabaseCollationTo sDatabase
103067>>>        tAPITable[] aFromStructure aToStructure
103067>>>        tAPITable[] aFromStructure aToStructure
103069>>>        tAPITableCompare[] aAPITableCompare
103069>>>        tAPITableCompare[] aAPITableCompare
103070>>>        Integer[] iaDifferences iaDifferencesEmpty 
103072>>>
103072>>>        Set Message_Text of ghoStatusPanel to ""
103073>>>        // Set up the pathing correctly for the 'FROM' Filelist.cfg so we can open tables:
103073>>>        Get ChangeFilelistPathing of ghoApplication sFilelistFrom to bOK
103074>>>        If (bOK = False) Begin
103076>>>            Move -1 to iaDifferencesEmpty[0]
103077>>>            Function_Return iaDifferencesEmpty
103078>>>        End       
103078>>>>
103078>>>        Get UtilIsAllFilelistEntriesDataFlexTables of ghoDbUpdateFunctionLibrary to bIsEmbedded
103079>>>        If (bIsEmbedded = False) Begin
103081>>>            Get psDatabase of ghoDbUpdateFunctionLibrary to sDatabase
103082>>>            Get SqlDatabaseCollationQuery of ghoDbUpdateFunctionLibrary sDatabase True to sDatabaseCollationFrom
103083>>>        End 
103083>>>>
103083>>>        Else Begin
103084>>>            Move "Embedded Database (DataFlex)" to sDatabaseCollationFrom
103085>>>        End
103085>>>>
103085>>>
103085>>>        Get UtilFilelistNoOfTables of ghoDbUpdateFunctionLibrary to iNoOfTablesFrom
103086>>>        Set pbVisible   of ghoProgressBar        to True
103087>>>        Set piPosition  of ghoProgressBar        to 0
103088>>>        Set piAdvanceBy of ghoProgressBar        to 1
103089>>>        Set pbVisible   of ghoProgressBarOverall to True
103090>>>        Set piPosition  of ghoProgressBarOverall to 0
103091>>>        Set piAdvanceBy of ghoProgressBarOverall to 1
103092>>>        Set piMaximum   of ghoProgressBarOverall to iNoOfTablesFrom
103093>>>        
103093>>>        // *** Fill the 'FROM' structure with data: (1 of 3)
103093>>>        Get UtilTablesStructArrayFill of ghoDbUpdateFunctionLibrary True True True to aFromStructure
103094>>>        
103094>>>        // Process cancelled by user?
103094>>>        If (aFromStructure[0].bCancel = True) Begin
103096>>>            Move -1 to iaDifferencesEmpty[0]
103097>>>            Function_Return iaDifferencesEmpty
103098>>>        End
103098>>>>
103098>>>        
103098>>>        // Error while filling struct array (Table could not be opened)?
103098>>>        If (aFromStructure[0].bError = True) Begin
103100>>>            Move aFromStructure[0].ApiTableInfo.iTableNumber to hTable
103101>>>            Move (-999999 - hTable) to iaDifferencesEmpty[0]
103102>>>            Function_Return iaDifferencesEmpty
103103>>>        End
103103>>>>
103103>>>
103103>>>        // Set up the pathing correctly for the 'TO' Filelist.cfg so we can open tables from the other workspace:
103103>>>        Get ChangeFilelistPathing of ghoApplication sFilelistTo to bOK
103104>>>        If (bOK = False) Begin
103106>>>            Move -1 to iaDifferencesEmpty[0]
103107>>>            Function_Return iaDifferencesEmpty
103108>>>        End
103108>>>>
103108>>>
103108>>>        If (bIsEmbedded = False) Begin
103110>>>            Get psDatabase of ghoDbUpdateFunctionLibrary to sDatabase
103111>>>            Get SqlDatabaseCollationQuery of ghoDbUpdateFunctionLibrary sDatabase True to sDatabaseCollationTo
103112>>>        End 
103112>>>>
103112>>>        Else Begin
103113>>>            Move "Embedded Database (DataFlex)" to sDatabaseCollationTo
103114>>>        End
103114>>>>
103114>>>
103114>>>        Get UtilFilelistNoOfTables of ghoDbUpdateFunctionLibrary to iNoOfTablesTo
103115>>>        Set piMaximum of ghoProgressBarOverall to iNoOfTablesTo
103116>>>        Set piAdvanceBy of ghoProgressBarOverall to 1
103117>>>
103117>>>        // *** Fill the 'TO' structure with data: (2 of 3)
103117>>>        Get UtilTablesStructArrayFill of ghoDbUpdateFunctionLibrary True True False to aToStructure
103118>>>        // Process cancelled by user?
103118>>>        If (aToStructure[0].bCancel = True) Begin
103120>>>            Move -1 to iaDifferencesEmpty[0]
103121>>>            Function_Return iaDifferencesEmpty
103122>>>        End
103122>>>>
103122>>>        // Error while filling struct array (Table could not be opened)?
103122>>>        If (aToStructure[0].bError = True) Begin
103124>>>            Move aToStructure[0].ApiTableInfo.iTableNumber to hTable
103125>>>            Move (-999999 - hTable) to iaDifferencesEmpty[0]
103126>>>//            Function_Return iaDifferencesEmpty
103126>>>        End
103126>>>>
103126>>>
103126>>>        Set Message_Text of ghoStatusPanel to "Comparing and Writing Differences: (3 of 3)"
103127>>>        Move 0 to hTable
103128>>>        Move 0 to iCount
103129>>>        Get WriteReportHeader sDatabaseCollationFrom sDatabaseCollationTo to iCh
103130>>>
103130>>>        Get UtilTableCombineFromAndToArrays of ghoDbUpdateFunctionLibrary aFromStructure aToStructure to aAPITableCompare
103131>>>        Move (SizeOfArray(aAPITableCompare))   to iSize
103132>>>        Set piMaximum of ghoProgressBar        to iSize
103133>>>        Set piMaximum of ghoProgressBarOverall to iSize
103134>>>        Decrement iSize
103135>>>
103135>>>        For iCount from 0 to iSize
103141>>>>
103141>>>            Move True to bIsSame
103142>>>            Set piPosition of ghoProgressBarOverall to iCount
103143>>>            Move aAPITableCompare[iCount].hTable to hTable
103144>>>
103144>>>            If (aAPITableCompare[iCount].bExistsFrom = True) Begin
103146>>>                Move aAPITableCompare[iCount].APITableNameInfoCompare.sLogicalNameFrom to sLogicalName
103147>>>            End
103147>>>>
103147>>>            Else Begin
103148>>>                Move aAPITableCompare[iCount].APITableNameInfoCompare.sLogicalNameTo   to sLogicalName
103149>>>            End
103149>>>>
103149>>>            Set Action_Text of ghoStatusPanel to ("Name:" * sLogicalName * String("Number:") * String(hTable))
103150>>>
103150>>>            Get UtilTableCompare_Ex of ghoDbUpdateFunctionLibrary aAPITableCompare[iCount] CompareCheckBoxes False (&bFilelistError) to bIsSame
103151>>>
103151>>>            If (bIsSame = False) Begin
103153>>>                Send MainReport (&aAPITableCompare[iCount]) (&CompareCheckBoxes) iCh
103154>>>                Move hTable to iaDifferences[SizeOfArray(iaDifferences)]
103155>>>            End
103155>>>>
103155>>>
103155>>>            Get Check_StatusPanel of ghoStatusPanel to bUserCancel
103156>>>            If (bUserCancel = True) Begin
103158>>>                Move -1 to iaDifferencesEmpty[0]
103159>>>                Function_Return iaDifferencesEmpty
103160>>>            End
103160>>>>
103160>>>        Loop
103161>>>>
103161>>>        
103161>>>        Move False to bCollationDiff
103162>>>        If (Uppercase(sDatabaseCollationFrom) <> Uppercase(sDatabaseCollationTo)) Begin
103164>>>            Move True to bCollationDiff
103165>>>        End
103165>>>>
103165>>>        Send WriteReportFooter (SizeOfArray(iaDifferences)) bCollationDiff iCh dtExecStart
103166>>>        Close DF_ALL DF_PERMANENT
103167>>>
103167>>>        Function_Return iaDifferences
103168>>>    End_Function
103169>>>
103169>>>    Procedure MainReport tAPITableCompare ByRef aAPITableCompare tAPITableBooleans ByRef CompareCheckBoxes Integer iCh
103172>>>        String sDriverIDFrom sDriverIDTo sLogicalName sFrom sTo
103172>>>        Handle hTable
103172>>>        Boolean bCompareDate_DateTime bCompareIndexUppercase bCompareIndexAscending bCompareFilelistUppercase
103172>>>        Boolean bExistsFrom bExistsTo bIsSQLFrom bIsSQLTo
103172>>>
103172>>>        Move CompareCheckBoxes.bCompareDate_DateTime     to bCompareDate_DateTime
103173>>>        Move CompareCheckBoxes.bCompareIndexAscending    to bCompareIndexAscending
103174>>>        Move CompareCheckBoxes.bCompareIndexUppercase    to bCompareIndexUppercase
103175>>>        Move CompareCheckBoxes.bCompareFilelistUppercase to bCompareFilelistUppercase
103176>>>
103176>>>        Move aAPITableCompare.bExistsFrom                            to bExistsFrom
103177>>>        Move aAPITableCompare.bExistsTo                              to bExistsTo
103178>>>        Move aAPITableCompare.APITableNameInfoCompare.bIsSQLFrom     to bIsSQLFrom
103179>>>        Move aAPITableCompare.APITableNameInfoCompare.bIsSQLTo       to bIsSQLTo
103180>>>        Move aAPITableCompare.APITableNameInfoCompare.sDriverIDFrom  to sDriverIDFrom
103181>>>        Move aAPITableCompare.APITableNameInfoCompare.sDriverIDTo    to sDriverIDTo
103182>>>        Move aAPITableCompare.APITableNameInfoCompare.iTableNumber   to hTable
103183>>>
103183>>>        If (aAPITableCompare.bExistsFrom = True) Begin
103185>>>            Move aAPITableCompare.APITableNameInfoCompare.sLogicalNameFrom to sLogicalName
103186>>>        End
103186>>>>
103186>>>        Else Begin
103187>>>            Move (aAPITableCompare.APITableNameInfoCompare.sLogicalNameTo) to sLogicalName
103188>>>        End
103188>>>>
103188>>>
103188>>>        Send WriteTableInfoDiff aAPITableCompare.APITableNameInfoCompare bCompareFilelistUppercase iCh
103189>>>        If (aAPITableCompare.bExistsFrom = True and aAPITableCompare.bExistsTo = True) Begin
103191>>>            Send WriteColumnDiffs sDriverIDFrom sDriverIDTo hTable sLogicalName bIsSQLFrom bIsSQLTo aAPITableCompare.aAPIColumnsCompare bCompareDate_DateTime iCh
103192>>>            Send WriteIndexDiffs hTable bIsSQLFrom bIsSQLTo sLogicalName aAPITableCompare.aAPIIndexesCompare bCompareIndexUppercase bCompareIndexAscending iCh
103193>>>            Send WriteRelationDiffs hTable aAPITableCompare.aAPIRelationsCompare iCh
103194>>>        End
103194>>>>
103194>>>
103194>>>    End_Procedure
103195>>>
103195>>>    Function WriteReportHeader String sDatabaseCollationFrom String sDatabaseCollationTo Returns Integer
103198>>>        Integer iCh
103198>>>        String sFilelistFrom sFilelistTo sReportName //sDriverIDFrom sDriverIDTo sLogicalName sFrom sTo sRootName sTableName
103198>>>        DateTime dtCreationTime    
103198>>>
103198>>>        Get Value of oReportFileName_fm to sReportName
103199>>>        Get Seq_Open_Output_Channel sReportName to iCh
103200>>>        If (iCh = DF_SEQ_CHANNEL_ERROR) Begin
103202>>>            Send Stop_Box "Sorry, couldn't retrieve a free channel number."
103203>>>            Function_Return 0
103204>>>        End                   
103204>>>>
103204>>>        
103204>>>        If (Uppercase(sDatabaseCollationFrom) <> Uppercase(sDatabaseCollationTo)) Begin
103206>>>            Move (sDatabaseCollationTo * String("(*)")) to sDatabaseCollationTo
103207>>>        End
103207>>>>
103207>>>
103207>>>        Get Value of oFilelistPathFrom_fm to sFilelistFrom
103208>>>        Get Value of oFilelistPathTo_fm   to sFilelistTo
103209>>>        Move (CurrentDateTime()) to dtCreationTime
103210>>>
103210>>>        Writeln channel iCh CS_ReportHeaderUnderWrite
103213>>>        Writeln channel iCh CS_DatabaseUpdateFramework
103216>>>        Writeln channel iCh (" ***  DATABASE DIFFERENCES REPORT  ***")
103219>>>        Writeln channel iCh ""
103222>>>        Writeln channel iCh ("      Date & Time Printed       :" * String(dtCreationTime))
103225>>>        Writeln channel iCh ("      FROM Database Filelist.cfg:" * String(sFilelistFrom))
103228>>>        Writeln channel iCh ("      TO   Database Filelist.cfg:" * String(sFilelistTo))
103231>>>        Writeln channel iCh ("      FROM Database Collation   :" * String(sDatabaseCollationFrom))
103234>>>        Writeln channel iCh ("      TO   Database Collation   :" * String(sDatabaseCollationTo))
103237>>>        Writeln channel iCh ""
103240>>>        Writeln channel iCh ("      Note: An asterisk in parenthesis (*) denotes a difference!")
103243>>>        Writeln channel iCh CS_ReportHeaderUnderWrite
103246>>>        Writeln channel iCh
103248>>>
103248>>>        Function_Return iCh
103249>>>    End_Function
103250>>>
103250>>>    // Note: The rootname will be first be stripped if it contains any driver id prefix.
103250>>>    Procedure WriteTableInfoDiff tAPITableNameInfoCompare APITableNameInfoCompare Boolean bCompareFilelistUppercase Integer iCh
103253>>>        String sLogicalName  sFrom sTo
103253>>>        Boolean bExistsFrom bExistsTo bIsSame
103253>>>        Handle hTable
103253>>>
103253>>>        Get UtilTableInfoCompare of ghoDbUpdateFunctionLibrary bCompareFilelistUppercase APITableNameInfoCompare to bIsSame
103254>>>        If (bIsSame = True) Begin
103256>>>            Procedure_Return
103257>>>        End
103257>>>>
103257>>>
103257>>>        Move APITableNameInfoCompare.iTableNumber to hTable
103258>>>        Move APITableNameInfoCompare.bExistsFrom  to bExistsFrom
103259>>>        Move APITableNameInfoCompare.bExistsTo    to bExistsTo
103260>>>        If (bExistsFrom = True) Begin
103262>>>            Move APITableNameInfoCompare.sLogicalNameFrom to sLogicalName
103263>>>        End
103263>>>>
103263>>>        If (bExistsTo = True) Begin
103265>>>            Move APITableNameInfoCompare.sLogicalNameTo   to sLogicalName
103266>>>        End
103266>>>>
103266>>>
103266>>>        Writeln channel iCh
103268>>>        Writeln channel iCh "Table Name Difference(s) Table Number: " hTable " - " sLogicalName
103274>>>        Writeln channel iCh CS_ReportHeaderUnderWrite
103277>>>
103277>>>        Move "FROM Database:" to sFrom
103278>>>        Get MakeStringLength sFrom CI_ReportColumn2 to sFrom
103279>>>        Move (sFrom + "TO Database:") to sFrom
103280>>>        Writeln channel iCh sFrom
103283>>>        Move (Repeat("-", Length(sFrom))) to sFrom
103284>>>        Writeln channel iCh sFrom
103287>>>
103287>>>        Move "Logical Name:"                                                to sFrom
103288>>>        Get MakeStringLength sFrom CI_ReportColumn1                         to sFrom
103289>>>        If (bExistsFrom = True) Begin
103291>>>            Move (sFrom + String(APITableNameInfoCompare.sLogicalNameFrom)) to sFrom
103292>>>        End
103292>>>>
103292>>>        If (bExistsFrom = False) Begin
103294>>>            Move (sFrom + CS_ReportTableNotFound * String(CS_ReportDifferenceNote)) to sFrom
103295>>>        End
103295>>>>
103295>>>        Get MakeStringLength sFrom CI_ReportColumn2                         to sFrom
103296>>>        If (bExistsTo = True) Begin
103298>>>            Move APITableNameInfoCompare.sLogicalNameTo                     to sTo
103299>>>        End
103299>>>>
103299>>>        If (bExistsTo = False) Begin
103301>>>            Move ""                                                         to sTo
103302>>>            Move (CS_ReportTableNotFound * String(CS_ReportDifferenceNote)) to sTo
103303>>>        End
103303>>>>
103303>>>        Writeln channel iCh sFrom sTo
103307>>>
103307>>>        Move "Root Name:"                                                   to sFrom
103308>>>        Get MakeStringLength sFrom CI_ReportColumn1                         to sFrom
103309>>>        If (bExistsFrom = True) Begin
103311>>>            Move (sFrom + String(APITableNameInfoCompare.sRootNameFrom))    to sFrom
103312>>>        End
103312>>>>
103312>>>        If (bExistsFrom = False) Begin
103314>>>            Move (sFrom + CS_ReportTableNotFound * String(CS_ReportDifferenceNote)) to sFrom
103315>>>        End
103315>>>>
103315>>>        Get MakeStringLength sFrom CI_ReportColumn2                         to sFrom
103316>>>        If (bExistsTo = True) Begin
103318>>>            Move APITableNameInfoCompare.sRootNameTo                        to sTo
103319>>>        End
103319>>>>
103319>>>        If (bExistsTo = False) Begin
103321>>>            Move ""                                                         to sTo
103322>>>            Move (CS_ReportTableNotFound * String(CS_ReportDifferenceNote)) to sTo
103323>>>        End
103323>>>>
103323>>>        Writeln channel iCh sFrom sTo
103327>>>
103327>>>        Move "Display Name:"                                                to sFrom
103328>>>        Get MakeStringLength sFrom CI_ReportColumn1                         to sFrom
103329>>>        If (bExistsFrom = True) Begin
103331>>>            Move (sFrom + String(APITableNameInfoCompare.sDisplayNameFrom)) to sFrom
103332>>>        End
103332>>>>
103332>>>        If (bExistsFrom = False) Begin
103334>>>            Move (sFrom + CS_ReportTableNotFound * String(CS_ReportDifferenceNote)) to sFrom
103335>>>        End
103335>>>>
103335>>>        Get MakeStringLength sFrom CI_ReportColumn2                         to sFrom
103336>>>        If (bExistsTo = True) Begin
103338>>>            Move APITableNameInfoCompare.sDisplayNameTo                     to sTo
103339>>>        End
103339>>>>
103339>>>        If (bExistsTo = False) Begin
103341>>>            Move ""                                                         to sTo
103342>>>            Move (CS_ReportTableNotFound * String(CS_ReportDifferenceNote)) to sTo
103343>>>        End
103343>>>>
103343>>>        Writeln channel iCh sFrom sTo
103347>>>
103347>>>        If (bExistsFrom = False or bExistsTo = False) Begin
103349>>>            Writeln channel iCh
103351>>>        End
103351>>>>
103351>>>        Writeln channel iCh
103353>>>    End_Procedure
103354>>>
103354>>>    Procedure WriteColumnDiffs String sDriverIDFrom String sDriverIDTo Handle hTable String sLogicalTableName Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare[] aAPIColumnCompare Boolean bCompareDate_DateTime Integer iCh
103357>>>        Integer iSize iCount
103357>>>        Boolean bIsSame bHeader
103357>>>        String sFrom sTo sTypeFrom sTypeTo
103357>>>
103357>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
103358>>>        If (iSize = 0) Begin
103360>>>            Procedure_Return
103361>>>        End
103361>>>>
103361>>>
103361>>>        Decrement iSize
103362>>>        For iCount from 0 to iSize
103368>>>>
103368>>>            Get UtilColumnCompare of ghoDbUpdateFunctionLibrary sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare[iCount] bCompareDate_DateTime to bIsSame
103369>>>            If (bIsSame = False) Begin
103371>>>
103371>>>                If (bHeader = False) Begin
103373>>>                    Writeln channel iCh "Field Difference(s) for Table Number: " (String(hTable)) " - " sLogicalTableName
103379>>>                    Writeln channel iCh CS_ReportHeaderUnderWrite
103382>>>                    Move "FROM Database:" to sFrom
103383>>>                    Get MakeStringLength sFrom CI_ReportColumn2 to sFrom
103384>>>                    Move (sFrom + "TO Database:") to sFrom
103385>>>                    Writeln channel iCh sFrom
103388>>>                    Move (Repeat("-", Length(sFrom))) to sFrom
103389>>>                    Writeln channel iCh sFrom
103392>>>                    Move True to bHeader
103393>>>                End
103393>>>>
103393>>>
103393>>>                Get MakeFromString "Field Number:" aAPIColumnCompare[iCount].iFieldNumber (CS_ReportFieldNotFound * CS_ReportDifferenceNote) ;                                 aAPIColumnCompare[iCount].bExistsFrom to sFrom
103394>>>                Get MakeToString aAPIColumnCompare[iCount].iFieldNumber "" (CS_ReportFieldNotFound * CS_ReportDifferenceNote) ;                                 aAPIColumnCompare[iCount].bExistsTo to sTo
103395>>>                Writeln channel iCh sFrom sTo
103399>>>
103399>>>                Get MakeFromString "Field Name" aAPIColumnCompare[iCount].sFieldNameFrom CS_ReportDifferenceNote aAPIColumnCompare[iCount].bExistsTo to sFrom
103400>>>                Get MakeToString aAPIColumnCompare[iCount].sFieldNameTo "" CS_ReportDifferenceNote (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) = ;                                 Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) to sTo
103401>>>                Writeln channel iCh sFrom sTo
103405>>>
103405>>>                Get MakeFromString "Type:" aAPIColumnCompare[iCount].sTypeFrom CS_ReportDifferenceNote aAPIColumnCompare[iCount].bExistsFrom to sFrom
103406>>>                Get MakeToString aAPIColumnCompare[iCount].sTypeTo "" CS_ReportDifferenceNote (Uppercase(aAPIColumnCompare[iCount].sTypeFrom) = ;                                 Uppercase(aAPIColumnCompare[iCount].sTypeTo)) to sTo
103407>>>                Writeln channel iCh sFrom sTo
103411>>>
103411>>>                Get MakeFromString "Length:" aAPIColumnCompare[iCount].iLengthFrom CS_ReportDifferenceNote aAPIColumnCompare[iCount].bExistsFrom to sFrom
103412>>>                Get MakeToString aAPIColumnCompare[iCount].iLengthTo "" CS_ReportDifferenceNote (aAPIColumnCompare[iCount].iLengthFrom = ;                                 aAPIColumnCompare[iCount].iLengthTo) to sTo
103413>>>                Writeln channel iCh sFrom sTo
103417>>>
103417>>>                Get MakeFromString "Precision:" aAPIColumnCompare[iCount].iPrecisionFrom CS_ReportDifferenceNote aAPIColumnCompare[iCount].bExistsFrom to sFrom
103418>>>                Get MakeToString aAPIColumnCompare[iCount].iPrecisionTo "" CS_ReportDifferenceNote (aAPIColumnCompare[iCount].iPrecisionFrom = ;                                 aAPIColumnCompare[iCount].iPrecisionTo) to sTo
103419>>>                Writeln channel iCh sFrom sTo
103423>>>
103423>>>                Get MakeFromString "Default Value:" aAPIColumnCompare[iCount].sDefaultValueFrom CS_ReportDifferenceNote aAPIColumnCompare[iCount].bExistsFrom to sFrom
103424>>>                Get MakeToString aAPIColumnCompare[iCount].sDefaultValueTo "" CS_ReportDifferenceNote (aAPIColumnCompare[iCount].sDefaultValueFrom = ;                                 aAPIColumnCompare[iCount].sDefaultValueTo) to sTo
103425>>>                Writeln channel iCh sFrom sTo
103429>>>
103429>>>                Get MakeFromString "Allow NULL:" (If(aAPIColumnCompare[iCount].bAllowNULLFrom = True, "Yes", "No")) CS_ReportDifferenceNote ;                                 aAPIColumnCompare[iCount].bExistsTo to sFrom
103430>>>                Get MakeToString (If(aAPIColumnCompare[iCount].bAllowNULLTo = True, "Yes", "No")) "" CS_ReportDifferenceNote ;                                 aAPIColumnCompare[iCount].bExistsTo to sTo
103431>>>                Writeln channel iCh sFrom sTo
103435>>>
103435>>>                Get MakeFromString "Identity Field:" (If(aAPIColumnCompare[iCount].iOptionsFrom = C_tAPIColumn_Identity, "Yes", "No")) CS_ReportDifferenceNote ;                                 aAPIColumnCompare[iCount].bExistsTo to sFrom
103436>>>                Get MakeToString (If(aAPIColumnCompare[iCount].iOptionsTo = C_tAPIColumn_Identity, "Yes", "No")) "" CS_ReportDifferenceNote ;                                 aAPIColumnCompare[iCount].bExistsTo to sTo
103437>>>                Writeln channel iCh sFrom sTo
103441>>>                Writeln channel iCh
103443>>>            End
103443>>>>
103443>>>        Loop
103444>>>>
103444>>>
103444>>>        If (bHeader = True) Begin
103446>>>            Writeln channel iCh ""
103449>>>        End
103449>>>>
103449>>>    End_Procedure
103450>>>
103450>>>    Procedure WriteIndexDiffs Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo String sLogicalTableName tAPIIndexCompare[] aAPIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Integer iCh
103453>>>        Integer iSize iCount iSegmentSizeFrom iSegmentSizeTo iCount2 iSize2 iFieldNumberFrom iFieldNumberTo
103453>>>        Integer iIndexNumberFrom iIndexNumberTo iPrimaryIndexFrom iPrimaryIndexTo
103453>>>        tAPIIndexSegment[] aApiIndexSegmentsFrom aApiIndexSegmentsTo aApiIndexSegmentsEmpty
103453>>>        tAPIIndexSegment[] aApiIndexSegmentsFrom aApiIndexSegmentsTo aApiIndexSegmentsEmpty
103456>>>        String sFrom sTo sSQLIndexTypeFrom sSQLIndexTypeTo sSQLIndexNameFrom sSQLIndexNameTo sFieldNameFrom sFieldNameTo
103456>>>        Boolean bIsSame bIsSQLPrimaryFrom bIsSQLPrimaryTo bIsSQLClusteredFrom bIsSQLClusteredTo bHeader
103456>>>
103456>>>        Move (SizeOfArray(aAPIIndexCompare)) to iSize
103457>>>        Decrement iSize
103458>>>
103458>>>        For iCount from 0 to iSize
103464>>>>
103464>>>            Get UtilIndexCompare of ghoDbUpdateFunctionLibrary bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexAscending bCompareIndexUppercase to bIsSame
103465>>>            If (bIsSame = False) Begin
103467>>>                If (bHeader = False) Begin
103469>>>                    Writeln channel iCh "Index Difference(s) for Table Number: " (String(hTable)) " - " sLogicalTableName
103475>>>                    Writeln channel iCh CS_ReportHeaderUnderWrite
103478>>>                    Move "FROM Database:" to sFrom
103479>>>                    Get MakeStringLength sFrom CI_ReportColumn2 to sFrom
103480>>>                    Move (sFrom + "TO Database:") to sFrom
103481>>>                    Writeln channel iCh sFrom
103484>>>                    Move (Repeat("-", Length(sFrom))) to sFrom
103485>>>                    Writeln channel iCh sFrom
103488>>>                    Move True to bHeader
103489>>>                End
103489>>>>
103489>>>
103489>>>                // FROM Index:
103489>>>                If (aAPIIndexCompare[iCount].bExistsFrom = True) Begin
103491>>>                    Move aAPIIndexCompare[iCount].iIndexNumber              to iIndexNumberFrom
103492>>>                    Move aAPIIndexCompare[iCount].iPrimaryIndexFrom         to iPrimaryIndexFrom
103493>>>                    Move aAPIIndexCompare[iCount].sSQLIndexNameFrom         to sSQLIndexNameFrom
103494>>>                    Move aAPIIndexCompare[iCount].bIsSQLPrimaryKeyFrom      to bIsSQLPrimaryFrom
103495>>>                    Move aAPIIndexCompare[iCount].bIsSQLClusteredFrom       to bIsSQLClusteredFrom
103496>>>                    Get UtilIndexTypeToString of ghoDbUpdateFunctionLibrary ;                         aAPIIndexCompare[iCount].iSQLIndexTypeFrom         to sSQLIndexTypeFrom
103497>>>                    Move aAPIIndexCompare[iCount].IndexSegmentArrayFrom     to aApiIndexSegmentsFrom
103498>>>                End
103498>>>>
103498>>>                Else Begin
103499>>>                    Move -1                                                 to iIndexNumberFrom
103500>>>                    Move -1                                                 to iPrimaryIndexFrom
103501>>>                    Move (String(CS_ReportDifferenceNote))                  to sSQLIndexNameFrom
103502>>>                    Move False                                              to bIsSQLPrimaryFrom
103503>>>                    Move False                                              to bIsSQLClusteredFrom
103504>>>                    Move (String(CS_ReportDifferenceNote))                  to sSQLIndexTypeFrom
103505>>>                    Move aApiIndexSegmentsEmpty                             to aApiIndexSegmentsFrom
103506>>>                End
103506>>>>
103506>>>
103506>>>                If (aAPIIndexCompare[iCount].bExistsTo = True) Begin
103508>>>                    Move aAPIIndexCompare[iCount].iIndexNumber              to iIndexNumberTo
103509>>>                    Move aAPIIndexCompare[iCount].iPrimaryIndexTo           to iPrimaryIndexTo
103510>>>                    Move aAPIIndexCompare[iCount].sSQLIndexNameTo           to sSQLIndexNameTo
103511>>>                    Move aAPIIndexCompare[iCount].bIsSQLPrimaryKeyTo        to bIsSQLPrimaryTo
103512>>>                    Move aAPIIndexCompare[iCount].bIsSQLClusteredTo         to bIsSQLClusteredTo
103513>>>                    Get UtilIndexTypeToString of ghoDbUpdateFunctionLibrary ;                        aAPIIndexCompare[iCount].iSQLIndexTypeTo            to sSQLIndexTypeTo
103514>>>                    Move aAPIIndexCompare[iCount].IndexSegmentArrayTo       to aApiIndexSegmentsTo
103515>>>                End
103515>>>>
103515>>>                Else Begin
103516>>>                    Move -1                                                 to iIndexNumberTo
103517>>>                    Move -1                                                 to iPrimaryIndexTo
103518>>>                    Move (String(CS_ReportDifferenceNote))                  to sSQLIndexNameTo
103519>>>                    Move (String(CS_ReportDifferenceNote))                  to bIsSQLPrimaryTo
103520>>>                    Move (String(CS_ReportDifferenceNote))                  to bIsSQLClusteredTo
103521>>>                    Move (String(CS_ReportDifferenceNote))                  to sSQLIndexTypeTo
103522>>>                    Move (String(CS_ReportDifferenceNote))                  to bIsSQLPrimaryTo
103523>>>                    Move aApiIndexSegmentsEmpty                             to aApiIndexSegmentsTo
103524>>>                End
103524>>>>
103524>>>
103524>>>                Get MakeFromString "Index Number:" iIndexNumberFrom CS_ReportIndexNotFound (iIndexNumberFrom <> -1) to sFrom
103525>>>                Get MakeToString iIndexNumberTo "" (CS_ReportIndexNotFound * String(CS_ReportDifferenceNote)) (iIndexNumberTo <> -1) to sTo
103526>>>                Writeln channel iCh sFrom sTo
103530>>>
103530>>>                Get MakeFromString "Primary Idx #:" iPrimaryIndexFrom CS_ReportDifferenceNote (iPrimaryIndexFrom <> -1) to sFrom
103531>>>                Get MakeToString iPrimaryIndexTo "" CS_ReportDifferenceNote (iPrimaryIndexTo <> -1) to sTo
103532>>>                Writeln channel iCh sFrom sTo
103536>>>
103536>>>                // SQL Index info:
103536>>>                If (bIsSqlTableFrom = True and bIsSqlTableTo = True) Begin
103538>>>                    Get MakeFromString "SQL Name:" sSQLIndexNameFrom CS_ReportDifferenceNote (sSQLIndexNameFrom <> "") to sFrom
103539>>>                    Get MakeToString sSQLIndexNameTo "" CS_ReportDifferenceNote (iIndexNumberFrom <> -1 and Uppercase(sSQLIndexNameFrom) = Uppercase(sSQLIndexNameTo)) to sTo
103540>>>                    Writeln channel iCh sFrom sTo
103544>>>
103544>>>                    Get MakeFromString "SQL Primary:" (If(bIsSQLPrimaryFrom = True, "Yes", "No")) CS_ReportDifferenceNote aAPIIndexCompare[iCount].bExistsFrom to sFrom
103545>>>                    Get MakeToString (If(bIsSQLPrimaryTo = True, "Yes", "No")) "" CS_ReportDifferenceNote (iIndexNumberFrom <> -1 and bIsSQLPrimaryFrom = bIsSQLPrimaryTo) to sTo
103546>>>                    Writeln channel iCh sFrom sTo
103550>>>
103550>>>                    Get MakeFromString "SQL Clustered:" (If(bIsSQLClusteredFrom = True, "Yes", "No")) CS_ReportDifferenceNote aAPIIndexCompare[iCount].bExistsFrom to sFrom
103551>>>                    Get MakeToString (If(bIsSQLClusteredTo = True, "Yes", "No")) "" CS_ReportDifferenceNote (iIndexNumberFrom <> -1 and bIsSQLClusteredFrom = bIsSQLClusteredTo) to sTo
103552>>>                    Writeln channel iCh sFrom sTo
103556>>>
103556>>>                    Get MakeFromString "SQL Type:" sSQLIndexTypeFrom CS_ReportDifferenceNote True to sFrom
103557>>>                    Get MakeToString sSQLIndexTypeTo "" CS_ReportDifferenceNote True to sTo
103558>>>                    Writeln channel iCh sFrom sTo
103562>>>                End
103562>>>>
103562>>>
103562>>>                // Index Segments:
103562>>>                Move (SizeOfArray(aApiIndexSegmentsFrom)) to iSegmentSizeFrom
103563>>>                Move (SizeOfArray(aApiIndexSegmentsTo))   to iSegmentSizeTo
103564>>>
103564>>>                Move (iSegmentSizeFrom max iSegmentSizeTo)  to iSize2
103565>>>                Decrement iSize2
103566>>>                If (iSize2 > -1) Begin
103568>>>                    Writeln channel iCh
103570>>>                End
103570>>>>
103570>>>
103570>>>                For iCount2 from 0 to iSize2
103576>>>>
103576>>>                    Move "" to sFieldNameFrom
103577>>>                    Move "" to sFieldNameTo
103578>>>                    Get MakeStringLength "Field# & Name:" CI_ReportColumn1               to sFrom
103579>>>                    If (iCount2 < iSegmentSizeFrom) Begin
103581>>>                        Move aApiIndexSegmentsFrom[iCount2].iFieldNumber                 to iFieldNumberFrom
103582>>>                        Move (sFrom + String(iFieldNumberFrom))                          to sFrom
103583>>>                        Move (String(aApiIndexSegmentsFrom[iCount2].sFieldName))         to sFieldNameFrom
103584>>>                        Move (sFrom * String(sFieldNameFrom))                            to sFrom
103585>>>                    End
103585>>>>
103585>>>                    Else Begin
103586>>>                        Move 0                                                           to iFieldNumberFrom
103587>>>                        Move (sFrom + CS_ReportIndexSegmentNotFound)                     to sFrom
103588>>>                    End
103588>>>>
103588>>>                    Get MakeStringLength sFrom CI_ReportColumn2                          to sFrom
103589>>>
103589>>>                    Move ""                                                              to sTo
103590>>>                    If (iIndexNumberTo <> -1) Begin
103592>>>                        Move aApiIndexSegmentsTo[iCount2].iFieldNumber                   to iFieldNumberTo
103593>>>                        Move (String(iFieldNumberTo))                                    to sTo
103594>>>                        Move (String(aApiIndexSegmentsTo[iCount2].sFieldName))           to sFieldNameTo
103595>>>                        Move (sTo * String(sFieldNameTo))                                to sTo
103596>>>                    End
103596>>>>
103596>>>                    If (iFieldNumberFrom <> iFieldNumberTo or Uppercase(sFieldNameFrom) <> Uppercase(sFieldNameTo)) Begin
103598>>>                        Move (sTo + String(CS_ReportDifferenceNote))                     to sTo
103599>>>                    End
103599>>>>
103599>>>                    Writeln channel iCh sFrom sTo
103603>>>
103603>>>                    // Uppercase Index Segment:
103603>>>                    If (bCompareIndexUppercase = True) Begin
103605>>>                        Get MakeStringLength "Uppercase:" CI_ReportColumn1                                        to sFrom
103606>>>                        If (bIsSqlTableFrom = True) Begin
103608>>>                            Move (sFrom + CS_ReportIndexNotApplicable)                                            to sFrom
103609>>>                        End
103609>>>>
103609>>>                        Else If (iCount <= iSegmentSizeFrom) Begin
103612>>>                            Move (sFrom + String(If(aApiIndexSegmentsFrom[iCount2].bUppercase = 1, "Yes","No")))  to sFrom
103613>>>                        End
103613>>>>
103613>>>                        Get MakeStringLength sFrom CI_ReportColumn2                                               to sFrom
103614>>>                        Move "" to sTo
103615>>>                        If (bIsSqlTableFrom = True) Begin
103617>>>                            Move CS_ReportIndexNotApplicable                                                      to sTo
103618>>>                        End
103618>>>>
103618>>>                        Else If (iCount <= iSegmentSizeTo) Begin
103621>>>                            Move (String(If(aApiIndexSegmentsTo[iCount2].bUppercase = 1, "Yes", "No")))           to sTo
103622>>>                        End
103622>>>>
103622>>>                        Writeln channel iCh sFrom sTo
103626>>>                    End
103626>>>>
103626>>>
103626>>>                    // Ascending/Descending Index:
103626>>>                    If (bCompareIndexAscending = True) Begin
103628>>>                        Get MakeStringLength "Ascending:" CI_ReportColumn1                                        to sFrom
103629>>>                        If (bIsSqlTableFrom = True) Begin
103631>>>                            Move (sFrom + CS_ReportIndexNotApplicable)                                            to sFrom
103632>>>                        End
103632>>>>
103632>>>                        Else If (iCount <= iSegmentSizeFrom) Begin
103635>>>                            Move (sFrom + String(If(aApiIndexSegmentsFrom[iCount2].bAscending = 1, "Yes", "No"))) to sFrom
103636>>>                        End
103636>>>>
103636>>>                        Get MakeStringLength sFrom CI_ReportColumn2                                               to sFrom
103637>>>                        Move "" to sTo
103638>>>                        If (bIsSqlTableFrom = True) Begin
103640>>>                            Move CS_ReportIndexNotApplicable                                                      to sTo
103641>>>                        End
103641>>>>
103641>>>                        Else If (iCount <= iSegmentSizeTo) Begin
103644>>>                            Move (String(If(aApiIndexSegmentsTo[iCount2].bAscending = 1, "Yes", "No")))           to sTo
103645>>>                        End
103645>>>>
103645>>>                        Writeln channel iCh sFrom sTo
103649>>>                    End
103649>>>>
103649>>>                Loop
103650>>>>
103650>>>                Writeln channel iCh ""
103653>>>            End
103653>>>>
103653>>>        Loop
103654>>>>
103654>>>
103654>>>        If (bHeader = True) Begin
103656>>>            Writeln channel iCh ""
103659>>>        End
103659>>>>
103659>>>    End_Procedure
103660>>>
103660>>>    Procedure WriteRelationDiffs Handle hTable tAPIRelationCompare[] aAPIRelationCompare Integer iCh
103663>>>        Integer iSizeFrom iSize iCount iRow iItem
103663>>>        Boolean bExists bIsSame bHeader
103663>>>        String sFrom sTo sFromFieldsRight sFromFields sToFields sLogicalNameFrom
103663>>>        tRelationDiffs[] asRelationDiffs
103663>>>        tRelationDiffs[] asRelationDiffs
103664>>>
103664>>>
103664>>>        Move (SizeOfArray(aAPIRelationCompare)) to iSize
103665>>>        Decrement iSize
103666>>>        For iCount from 0 to iSize
103672>>>>
103672>>>            Get UtilRelationCompare of ghoDbUpdateFunctionLibrary hTable aAPIRelationCompare[iCount] to bIsSame
103673>>>            If (bIsSame = False) Begin
103675>>>                If (bHeader = False) Begin
103677>>>                    Move aAPIRelationCompare[iCount].sLogicalNameFrom_From   to sLogicalNameFrom
103678>>>                    If (sLogicalNameFrom = "") Begin
103680>>>                        Move aAPIRelationCompare[iCount].sLogicalNameFrom_To to sLogicalNameFrom
103681>>>                    End
103681>>>>
103681>>>                    Writeln channel iCh ""
103684>>>                    Writeln channel iCh "Relation Difference(s) for Table Number: " (String(hTable)) " - " sLogicalNameFrom
103690>>>                    Writeln channel iCh CS_ReportHeaderUnderWrite
103693>>>                    Move "FROM Database:" to sFrom
103694>>>                    Get MakeStringLength sFrom CI_ReportColumn2 to sFrom
103695>>>                    Move (sFrom + "TO Database:") to sFrom
103696>>>                    Writeln channel iCh sFrom
103699>>>                    Move (Repeat("-", Length(sFrom))) to sFrom
103700>>>                    Writeln channel iCh sFrom
103703>>>                    Move True to bHeader
103704>>>                End
103704>>>>
103704>>>
103704>>>                // FROM Relation:
103704>>>                Get MakeStringLength "Table.Field:" CI_ReportColumn1                            to sFrom
103705>>>                If (aAPIRelationCompare[iCount].bExistsFrom = True) Begin
103707>>>                    Move (sFrom + String(aAPIRelationCompare[iCount].hTableFrom)   + "." ;                                + String(aAPIRelationCompare[iCount].iColumnFrom)  * "->")      to sFrom
103708>>>                    Move (sFrom * String(aAPIRelationCompare[iCount].hTableTo)     + "." ;                                + String(aAPIRelationCompare[iCount].iColumnTo))                to sFrom
103709>>>                    Get MakeStringLength sFrom CI_ReportColumn2                                 to sFrom
103710>>>                    Move (String(aAPIRelationCompare[iCount].sLogicalNameFrom_From) + "." ;                        + String(aAPIRelationCompare[iCount].sFieldNameFrom_From)   * "->")     to sFromFields
103711>>>                    Move (String(aAPIRelationCompare[iCount].sLogicalNameTo_From)   + "." ;                        + String(aAPIRelationCompare[iCount].sFieldNameTo_From))                to sFromFieldsRight
103712>>>                End
103712>>>>
103712>>>                Else Begin
103713>>>                    Move (String(CS_ReportRelationNotFound) * String(CS_ReportDifferenceNote))  to sFrom
103714>>>                    Get MakeStringLength sFrom CI_ReportColumn2                                 to sFrom
103715>>>                    Move (String(CS_ReportDifferenceNote))                                      to sFromFields
103716>>>                    Move ""                                                                     to sFromFieldsRight
103717>>>                    Move iCount                                                                 to iItem
103718>>>                End
103718>>>>
103718>>>                Move (sFromFields * String(sFromFieldsRight))                                   to sFromFields
103719>>>                Get MakeStringLength sFromFields CI_ReportColumn2                               to sFromFields
103720>>>
103720>>>                // TO Relation:
103720>>>                If (aAPIRelationCompare[iCount].bExistsTo = True) Begin
103722>>>                    Move (String(aAPIRelationCompare[iCount].hTableFrom)           + "." ;                        + String(aAPIRelationCompare[iCount].iColumnFrom)          * "->")      to sTo
103723>>>                    Move (sTo * String(aAPIRelationCompare[iCount].hTableTo)       + "." ;                        + String(aAPIRelationCompare[iCount].iColumnTo))                        to sTo
103724>>>                    Move (String(aAPIRelationCompare[iCount].sLogicalNameFrom_To)  + "." ;                        + String(aAPIRelationCompare[iCount].sFieldNameFrom_To)    * "->")      to sToFields
103725>>>                    Move (sToFields * String(aAPIRelationCompare[iCount].sLogicalNameTo_To) + "." ;                        + String(aAPIRelationCompare[iCount].sFieldNameTo_To))                  to sToFields
103726>>>                End
103726>>>>
103726>>>                Else Begin
103727>>>                    Move (CS_ReportRelationNotFound * String(CS_ReportDifferenceNote))          to sTo
103728>>>                    Move (String(CS_ReportDifferenceNote))                                      to sToFields
103729>>>                End
103729>>>>
103729>>>
103729>>>                Move sFromFieldsRight to asRelationDiffs[iRow].sFromFieldsRight
103730>>>                Move sFrom to asRelationDiffs[iRow].sFrom
103731>>>                Move sTo   to asRelationDiffs[iRow].sTo
103732>>>                Move sFromFields to asRelationDiffs[iRow].sFromFields
103733>>>                Move sToFields   to asRelationDiffs[iRow].sToFields
103734>>>                If (iCount < iSize) Begin
103736>>>                    Increment iRow
103737>>>                    Move "" to asRelationDiffs[iRow].sFrom
103738>>>                    Move "" to asRelationDiffs[iRow].sTo
103739>>>                End
103739>>>>
103739>>>                Else Begin
103740>>>                    Increment iRow
103741>>>                End
103741>>>>
103741>>>            End
103741>>>>
103741>>>        Loop
103742>>>>
103742>>>
103742>>>        // We put all relations in an array struct so we can sort it alphatically.
103742>>>        // This is to show multiple field relations from one table to another next to each other, just as the Studio does.
103742>>>        Move (SortArray(asRelationDiffs))   to asRelationDiffs
103743>>>        Move (SizeOfArray(asRelationDiffs)) to iSizeFrom
103744>>>        Decrement iSizeFrom
103745>>>        For iCount from 0 to iSizeFrom
103751>>>>
103751>>>            Writeln channel iCh asRelationDiffs[iCount].sFrom       asRelationDiffs[iCount].sTo
103755>>>            Writeln channel iCh asRelationDiffs[iCount].sFromFields asRelationDiffs[iCount].sToFields
103759>>>            Writeln channel iCh
103761>>>        Loop
103762>>>>
103762>>>
103762>>>        If (bHeader = True) Begin
103764>>>            Writeln channel iCh ""
103767>>>        End
103767>>>>
103767>>>    End_Procedure
103768>>>
103768>>>    Procedure WriteReportFooter Integer iSize Boolean bCollationDiff Integer iCh DateTime dtExecStart
103771>>>        DateTime dtExecEnd
103771>>>        TimeSpan tsTotalTime
103771>>>
103771>>>        Move (CurrentDateTime()) to dtExecEnd
103772>>>        Move (dtExecEnd - dtExecStart) to tsTotalTime
103773>>>
103773>>>        Writeln channel iCh
103775>>>        Writeln channel iCh "SUMMARY:  [Total Elapsed Time: " tsTotalTime "]"
103780>>>        Writeln channel iCh CS_ReportHeaderUnderWrite               
103783>>>        If (bCollationDiff = False) Begin
103785>>>            Writeln channel iCh "Number of Tables with differences: " (String(iSize))
103789>>>        End 
103789>>>>
103789>>>        Else Begin
103790>>>            If (iSize <> 0) Begin
103792>>>                Writeln channel iCh "Number of Tables with differences: " (String(iSize))
103796>>>            End
103796>>>>
103796>>>            Writeln channel iCh "*** IMPORTANT: The SQL collation used for the 'FROM' and 'TO' database are different! ***"
103799>>>            Writeln channel iCh 
103801>>>        End
103801>>>>
103801>>>        
103801>>>        If (iSize = 0) Begin
103803>>>            Writeln channel iCh "*** No table differences found. All tables should be identical! ***"
103806>>>        End
103806>>>>
103806>>>
103806>>>        Send Seq_Close_Channel iCh
103807>>>    End_Procedure
103808>>>
103808>>>    Function MakeStringLength String sValue Integer iReportColumnPos Returns String
103811>>>        Move (Pad(sValue, (Length(sValue) + (iReportColumnPos - Length(sValue))))) to sValue
103812>>>
103812>>>        Function_Return sValue
103813>>>    End_Function
103814>>>
103814>>>    Function MakeFromString String sStartText String sText String sMissingText Boolean bExists Returns String
103817>>>        String sFrom
103817>>>
103817>>>        Get MakeStringLength sStartText CI_ReportColumn1 to sFrom
103818>>>        If (bExists = True) Begin
103820>>>            Move (sFrom + String(sText)) to sFrom
103821>>>        End
103821>>>>
103821>>>        Else Begin
103822>>>            Move (sFrom + String(sMissingText)) to sFrom
103823>>>        End
103823>>>>
103823>>>        Get MakeStringLength sFrom CI_ReportColumn2 to sFrom
103824>>>
103824>>>        Function_Return sFrom
103825>>>    End_Function
103826>>>
103826>>>    Function MakeToString String sStartText String sText String sMissingText Boolean bSame Returns String
103829>>>        String sTo
103829>>>
103829>>>        Move (String(sStartText) * String(sText)) to sTo
103830>>>        If (bSame = False) Begin
103832>>>            If (sTo <> "-1") Begin
103834>>>                Move (sTo * String(sMissingText)) to sTo
103835>>>            End
103835>>>>
103835>>>            Else Begin
103836>>>                Move (String(sMissingText)) to sTo
103837>>>            End
103837>>>>
103837>>>        End
103837>>>>
103837>>>
103837>>>        Function_Return sTo
103838>>>    End_Function
103839>>>
103839>>>    Function FindArrayItem tAPITable[] aFromStructure tAPITable[] aToStructure Integer iCount Handle ByRef hTable Integer ByRef iItemFrom Integer ByRef iItemTo Returns String
103842>>>        Integer iSizeFrom iSizeTo
103842>>>        Handle hTableFrom hTableTo
103842>>>        String sLogicalName
103842>>>
103842>>>        Move (SizeOfArray(aFromStructure)) to iSizeFrom
103843>>>        Move (SizeOfArray(aToStructure))   to iSizeTo
103844>>>
103844>>>        Move -1 to hTableFrom
103845>>>        Move -1 to hTableTo
103846>>>        Move iCount to iItemFrom
103847>>>        Move iCount to iItemTo
103848>>>
103848>>>        // The two struct arrays may be different in size (contain different number of items/tables).
103848>>>        //
103848>>>        // To avoid "Referenced Array Index Out of Bounds" error.
103848>>>        If (iCount < iSizeFrom) Begin
103850>>>            Move aFromStructure[iCount].ApiTableInfo.iTableNumber to hTableFrom
103851>>>        End
103851>>>>
103851>>>        If (iCount < iSizeTo) Begin
103853>>>            Move aToStructure[iCount].ApiTableInfo.iTableNumber   to hTableTo
103854>>>        End
103854>>>>
103854>>>        If (hTableFrom <> -1 and hTableTo <> -1) Begin
103856>>>            Move (hTableFrom min hTableTo)                to hTable
103857>>>        End
103857>>>>
103857>>>        Else Begin
103858>>>            Move (hTableFrom max hTableTo)                to hTable
103859>>>        End
103859>>>>
103859>>>
103859>>>        If (iCount < iSizeFrom and hTableFrom <= hTableTo) Begin
103861>>>            Move aFromStructure[iCount].ApiTableInfo.sLogicalName to sLogicalName
103862>>>            Get FindTableNumber (&aToStructure) hTable to iItemTo
103863>>>        End
103863>>>>
103863>>>
103863>>>        // If the 'TO' table number is lower than 'FROM'
103863>>>        Else If (iCount < iSizeTo) Begin
103866>>>            Move aToStructure[iCount].ApiTableInfo.sLogicalName to sLogicalName
103867>>>            Get FindTableNumber (&aFromStructure) hTable to iItemFrom
103868>>>        End
103868>>>>
103868>>>        Else If (iCount = iSizeTo) Begin
103871>>>            Get FindTableNumber (&aToStructure) hTable to iItemTo
103872>>>        End
103872>>>>
103872>>>
103872>>>        Function_Return sLogicalName
103873>>>    End_Function
103874>>>
103874>>>    Function FindTableNumber tAPITable[] ByRef aTableStructure Handle hTable Returns Integer
103877>>>        Integer iSize iCount iTable iItem
103877>>>        tAPITableNameInfo ApiTableNameInfo
103877>>>        tAPITableNameInfo ApiTableNameInfo
103877>>>
103877>>>        Move -1 to iItem
103878>>>        Move (SizeOfArray(aTableStructure)) to iSize
103879>>>        Decrement iSize
103880>>>        For iCount from 0 to iSize
103886>>>>
103886>>>            Move aTableStructure[iCount].ApiTableInfo to ApiTableNameInfo
103887>>>            If (ApiTableNameInfo.iTableNumber = hTable) Begin
103889>>>                Move iCount to iItem
103890>>>                Move iSize  to iCount // We're done.
103891>>>            End
103891>>>>
103891>>>        Loop
103892>>>>
103892>>>
103892>>>        Function_Return iItem
103893>>>    End_Function
103894>>>
103894>>>    // Pass one tAPIRelation for the FROM database and a struct array with relations for the TO database
103894>>>    // Returns the item number in the aAPIRelationsTO that equals the FROM relation struct data.
103894>>>    // If not found returns -1.
103894>>>//    Function FindEqualRelation tAPIRelation APIRelationFrom tAPIRelation[] aAPIRelationsTO Returns Integer
103894>>>//        Integer iRetval iSize iCount
103894>>>//
103894>>>//        Move -1 to iRetval
103894>>>//        Move (SizeOfArray(aAPIRelationsTO)) to iSize
103894>>>//        Decrement iSize
103894>>>//        For iCount from 0 to iSize
103894>>>//            If (APIRelationFrom.hTableFrom  = aAPIRelationsTO[iCount].hTableFrom  and ;
103894>>>//                APIRelationFrom.iColumnFrom = aAPIRelationsTO[iCount].iColumnFrom and ;
103894>>>//                APIRelationFrom.hTableTo    = aAPIRelationsTO[iCount].hTableTo    and ;
103894>>>//                APIRelationFrom.iColumnTo   = aAPIRelationsTO[iCount].iColumnTo) Begin
103894>>>//                    Move iCount to iRetval
103894>>>//                End
103894>>>//        Loop
103894>>>//
103894>>>//        Function_Return iRetval
103894>>>//    End_Function
103894>>>
103894>>>    // Returns a value <> -1 if the passed iIndex was found in the APIIndex struct array.
103894>>>    // The value returned is the item number, else a -1.
103894>>>//    Function FindIndexInArray Integer iIndex tAPIIndex[] APIIndex Returns Integer
103894>>>//        Integer iRetval iSize iCount iCompareIndex
103894>>>//
103894>>>//        Move -1 to iRetval
103894>>>//        Move (SizeOfArray(APIIndex)) to iSize
103894>>>//        Decrement iSize
103894>>>//        For iCount from 0 to iSize
103894>>>//            If (iIndex = APIIndex[iCount].iIndexNumber) Begin
103894>>>//                Move iCount to iRetval
103894>>>//            End
103894>>>//        Loop
103894>>>//        Function_Return iRetval
103894>>>//    End_Function
103894>>>
103894>>>    Procedure Request_Clear
103897>>>        tSQLConnection Connection
103897>>>        tSQLConnection Connection
103897>>>        Integer[] iDifferencesEmpty
103898>>>
103898>>>        Move DATAFLEX_ID to Connection.sDriverID
103899>>>        Set pSQLConnection of ghoSQLConnectionHandler to Connection
103900>>>        Set Value of oFilelistPathFrom_fm   to ""
103901>>>        Set Value of oFilelistPathTo_fm     to ""
103902>>>        Set Value of oReportFileName_fm     to ""
103903>>>        Set psFilelistFrom of ghoApplication to ""
103904>>>        Set piaDifferences of ghoApplication to iDifferencesEmpty
103905>>>
103905>>>        Send Activate of oFilelistPathFrom_fm
103906>>>    End_Procedure
103907>>>
103907>>>    Object oBusinessProcess is a BusinessProcess
103909>>>        Set Status_Panel_Id to ghoStatusPanel
103910>>>        Set Allow_Cancel_State to True
103911>>>        Set Process_Caption to "The Database Update Framework"
103912>>>        Set Process_Title to "Comparing Database Structures..."
103913>>>//        Set Display_Error_State to True // Temp!
103913>>>
103913>>>        Procedure OnProcess
103916>>>            Send MainProcess
103917>>>        End_Procedure
103918>>>
103918>>>        Procedure Ignore_Error Integer iError
103921>>>        End_Procedure
103922>>>        Procedure Trap_Error Integer iError
103925>>>        End_Procedure
103926>>>
103926>>>    End_Object
103927>>>
103927>>>    Object oCompare_btn is a cRDCCommandLinkButton
103929>>>        Set Size to 36 166
103930>>>        Set Location to 276 139
103931>>>        Set Label to "Co&mpare Databases!"
103932>>>        Set psNote to "Compare the two selected databases."
103933>>>        Set psImage to "DbCompare1.ico"
103934>>>        Set Default_State to True
103935>>>        Set psToolTip to "Start the compare process"
103936>>>        Set piImageSize to 32 // 48
103937>>>        Set peAnchors to anBottomRight
103938>>>
103938>>>        Procedure OnClick
103941>>>            String sFilelistFrom sFilelistTo
103941>>>            Integer[] iaDifferences
103942>>>            Boolean bFromExists bToExists
103942>>>
103942>>>            Get Value of oFilelistPathFrom_fm to sFilelistFrom
103943>>>            Get vFilePathExists sFilelistFrom to bFromExists
103944>>>            Get Value of oFilelistPathTo_fm   to sFilelistTo
103945>>>            Get vFilePathExists sFilelistTo   to bToExists
103946>>>            If (bFromExists = False or bToExists = False) Begin
103948>>>                Send Info_Box "You need to both select a FROM and a TO database Filelist.cfg. Please adjust and try again."
103949>>>                Procedure_Return
103950>>>            End
103950>>>>
103950>>>
103950>>>            Send DoProcess of oBusinessProcess
103951>>>            Send Restore_DF_OPEN_PATH of ghoApplication
103952>>>        End_Procedure
103953>>>
103953>>>        Function IsEnabled Returns Boolean
103956>>>            String sFileListFrom sFileListTo
103956>>>            Boolean bExists bState
103956>>>
103956>>>            Get Value of oFilelistPathFrom_fm to sFileListFrom
103957>>>            Get vFilePathExists sFileListFrom to bExists
103958>>>            If (bExists = False) Begin
103960>>>                Function_Return False
103961>>>            End
103961>>>>
103961>>>            Get Value of oFilelistPathTo_fm to sFileListTo
103962>>>            Get vFilePathExists sFileListTo to bExists
103963>>>            Get Enabled_State to bState
103964>>>            If (bState = False and bExists = False) Begin
103966>>>                Function_Return False
103967>>>            End
103967>>>>
103967>>>            Function_Return bExists
103968>>>        End_Function
103969>>>
103969>>>    End_Object
103970>>>
103970>>>    Object oViewReport_Btn is a cRDCCommandLinkButton
103972>>>        Set Size to 36 77
103973>>>        Set Location to 276 315
103974>>>        Set Label to "&Report"
103975>>>        Set psNote to "View report"
103976>>>        Set peAnchors to anBottomRight
103977>>>        Set psImage to "ViewReport1.ico"
103978>>>        Set psToolTip to "Open the folder where the report was generated. (Ctrl+R)"
103979>>>        Set piImageSize to 16 //24
103980>>>
103980>>>        Procedure OnClick
103983>>>            Send DoShowReport
103984>>>        End_Procedure
103985>>>        
103985>>>        Procedure DoShowReport
103988>>>            String sReportName
103988>>>            Get Value of oReportFileName_fm to sReportName
103989>>>            Send ActivateLogFileDialog of (Client_Id(ghoCommandBars)) sReportName
103990>>>//            Runprogram Shell Background sReportName
103990>>>        End_Procedure
103991>>>
103991>>>        Function IsEnabled Returns Boolean
103994>>>            String sReportName
103994>>>            Boolean bExists
103994>>>
103994>>>            Get Value of oReportFileName_fm to sReportName
103995>>>            Get vFilePathExists sReportName to bExists
103996>>>            Function_Return bExists
103997>>>        End_Function
103998>>>
103998>>>    End_Object
103999>>>
103999>>>    Object oTagFilelist_Btn is a cRDCCommandLinkButton
104001>>>        Set Size to 36 76
104002>>>        Set Location to 276 402
104003>>>        Set Label to "&Tag"
104004>>>        Set psNote to "Tag differences"
104005>>>        Set peAnchors to anBottomRight
104006>>>        Set MultiLineState to True
104007>>>        Set Border_Style to Border_Normal
104008>>>        Set peImageAlign to Button_ImageList_Align_Center
104009>>>        Set psImage to "SelectInvert1.ico"
104010>>>        Set psToolTip to "Tag Tables for the 'FROM' Filelist.cfg with differences - for code generation on the 'Code Generator' view page."
104011>>>        Set pbAutoEnable to True
104012>>>        Set piImageSize to 16 // 24
104013>>>
104013>>>        Procedure OnClick
104016>>>            String sFileListFrom
104016>>>            Get Value of oFilelistPathFrom_fm    to sFileListFrom
104017>>>            Set psFilelistFrom of ghoApplication to sFileListFrom
104018>>>            Send TagFileNamesForCodeGeneration
104019>>>        End_Procedure
104020>>>
104020>>>        Function IsEnabled Returns Boolean
104023>>>            Integer[] iaDifferences
104024>>>            Get piaDifferences of ghoApplication to iaDifferences
104025>>>            Function_Return (SizeOfArray(iaDifferences))
104026>>>        End_Function
104027>>>
104027>>>    End_Object
104028>>>
104028>>>    Procedure OnSetFocus
104031>>>        If (SizeOfArray(phoActiveUpdates(ghoCommandBars)) <> 0) Begin
104033>>>            Send Execute of (oCompareDatabases_MenuItem(ghoCommandBars))
104034>>>        End
104034>>>>
104034>>>    End_Procedure
104035>>>    
104035>>>    Procedure OnFileDropped String sFilename Boolean bLast
104038>>>        String sTest sFileListFrom sFileListTo
104038>>>
104038>>>        Forward Send OnFileDropped sFilename bLast
104040>>>        Get Value of oFilelistPathFrom_fm to sFileListFrom
104041>>>        Get Value of oFilelistPathTo_fm    to sFileListTo
104042>>>        If (bLast = True) Begin
104044>>>            Get ParseFileName sFilename to sTest
104045>>>            If (Uppercase(sTest) <> "FILELIST.CFG") Begin
104047>>>                Send Info_Box "Sorry, only Filist.cfg files can be dropped here..."
104048>>>                Procedure_Return
104049>>>            End                                           
104049>>>>
104049>>>            If (sFileListFrom = "") Begin
104051>>>                Set Value of oFilelistPathFrom_fm to sFilename
104052>>>            End 
104052>>>>
104052>>>            Else Begin
104053>>>                Set Value of oFilelistPathTo_fm to sFilename
104054>>>            End
104054>>>>
104054>>>                
104054>>>        End
104054>>>>
104054>>>    End_Procedure
104055>>>
104055>>>    On_Key Key_Ctrl+Key_M  Send KeyAction of oCompare_btn
104056>>>    On_Key Key_Ctrl+Key_R  Send KeyAction of oViewReport_Btn
104057>>>    On_Key Key_Ctrl+Key_T  Send KeyAction of oTagFilelist_Btn
104058>>>    On_Key kClear          Send Request_Clear
104059>>>    On_Key kClear_All      Send Request_Clear
104060>>>    On_Key Key_Ctrl+Key_F4 Send None
104061>>>End_Object
104062>
104062>        Use StdAbout.pkg
Including file: StdAbout.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\DFAbout\StdAbout.pkg)
104062>>>//************************************************************************
104062>>>// Confidential Trade Secret.
104062>>>// Copyright (c) 1997 Data Access Corporation, Miami Florida
104062>>>// as an unpublished work.  All rights reserved.
104062>>>// DataFlex is a registered trademark of Data Access Corporation.
104062>>>//
104062>>>//************************************************************************
104062>>>//************************************************************************
104062>>>//
104062>>>// $File name  : StdAbout.pkg
104062>>>// $File title : Standard about object package for VDF
104062>>>// Notice      :
104062>>>// $Author(s)  : John Tuohy
104062>>>//
104062>>>// $Rev History
104062>>>//
104062>>>// JT 06/27/97   File created
104062>>>//************************************************************************
104062>>>
104062>>>// This provides a quick and simple way to create an about package for a program.
104062>>>// You need to create a message inside you client area called Activate_About.
104062>>>// Within this message you should send the message DoAbout passing needed
104062>>>// string information.
104062>>>//
104062>>>//       Procedure Activate_About
104062>>>//           Send DoAbout sTitle sVersion sCopyright sAuthor sBitmap
104062>>>//       End_Procedure
104062>>>//    where: sTitle =     Name of application. If none provided, uses caption
104062>>>//                        bar title
104062>>>//           sVersion   = Version Line. If none provided, will be blank
104062>>>//           sCopyRight = Copyright Line. If none provided, will be blank
104062>>>//           sAuthor    = Author name, blank if none provided
104062>>>//           sBitMap    = Bitmap logo. If none provided, standard VDF bitmap
104062>>>//                        is used.
104062>>>// It is expected that you will place this in your own object package. For
104062>>>// example an order about package may look like this:
104062>>>//
104062>>>//   // OrderAbout.pkg
104062>>>//   Use StdAbout.pkg
104062>>>//   Procedure Activate_About
104062>>>//      String sTitle sCopyright sVersion sAuthor
104062>>>//      Move "My Order Entry System" to sTitle
104062>>>//      Move "Version 2.1" to sVersion
104062>>>//      Move "Copyright 1997, Super Software Inc." to sCopyright
104062>>>//      Move "John Smith"  to sAuthor
104062>>>//      Send DoAbout sTitle sVersion sCopyright sAuthor ""
104062>>>//   end_procedure
104062>>>//   // end of file.
104062>>>
104062>>>Use DfAbout.pkg
104062>>>
104062>>>// *************************************************************************
104062>>>//  Public message. This is the default message. It is expected that you will
104062>>>//   create your own message to override this
104062>>>// *************************************************************************
104062>>>
104062>>>Procedure Activate_About
104065>>>    Send DoAbout "" "" "" "" "" "" "" "" "" ""
104066>>>End_Procedure
104067>>>
104067>>>// *************************************************************************
104067>>>//  Public message. It is expected that you will send this message (most
104067>>>//  likely from Activate_About. This creates an about object, activates it
104067>>>//  and destroys it when done. It is not exepected that you will augment this.
104067>>>// *************************************************************************
104067>>>// Sample usage:
104067>>>//   The first two params will automatically be filled from the application settings if not provided.
104067>>>//   Send DoAbout "" "" ("Copyright: 2013" * psCompany(ghoApplication)) "Created by: Your Name" "YourAppBitmap.bmp" "Internet: http://www.YourWebAddress.com" "E-mail: mailto:support@YourEmailAddress.com" "Some other description of choice" "9th param" "and last param"
104067>>>
104067>>>Procedure DoAbout String sTitle String sVersion String sCopyRight String sAuthor String sBitmap ;    String sParam6 String sParam7 String sParam8 String sParam9 String sParam10
104070>>>    Integer hoObj hoMain iArgs
104070>>>    String sValue
104070>>>
104070>>>    // Create object
104070>>>    Object About is an AboutDialog
104072>>>    // Uncomment these two lines if you would like to have a resizable About object.
104072>>>    //            Set Border_Style to Border_Thick
104072>>>    //            Set peAnchors to anAll
104072>>>
104072>>>    // Add checking for the number of arguments passed to avoid runtime errors
104072>>>    // if one of them is not passed. This makes the interface
104072>>>    // more flexible.
104072>>>        Move num_arguments to iArgs
104073>>>
104073>>>        // If no title is passed use the label of the main panel (if a main panel exists).
104073>>>        If (iArgs > 0 and sTitle = "") Begin
104075>>>            Get Main_Window of Desktop to hoMain
104076>>>            If hoMain Begin
104078>>>                Get Label of hoMain to sValue
104079>>>            End
104079>>>>
104079>>>        End
104079>>>>
104079>>>        Else If (iArgs > 0 and sTitle <> "") Begin
104082>>>            Move sTitle to sValue
104083>>>        End
104083>>>>
104083>>>        Else If (iArgs = 0) Begin
104086>>>            Get Main_Window of Desktop to hoMain
104087>>>            If hoMain Begin
104089>>>                Get Label of hoMain to sValue
104090>>>            End
104090>>>>
104090>>>        End
104090>>>>
104090>>>
104090>>>        If (sValue <> "") Begin
104092>>>            Send Add_LineLn sValue
104093>>>        End
104093>>>>
104093>>>        Move "" to sValue
104094>>>
104094>>>        // If the passed sVersion value is blank, the info will be retrieved from the cApplication object.
104094>>>        // For this to work the Project Properties Version must have been set in the Studio.
104094>>>        If (iArgs < 2) Begin
104096>>>            Move "" to sValue
104097>>>        End
104097>>>>
104097>>>        Else Begin
104098>>>            Move sVersion to sValue
104099>>>        End
104099>>>>
104099>>>        Set Version to sValue
104100>>>
104100>>>        If (iArgs > 2 and sCopyRight <> "") Begin
104102>>>            Send Add_LineLn sCopyRight
104103>>>        End
104103>>>>
104103>>>
104103>>>        // If only the five "standard" params were passed we don't add an extra linefeed;
104103>>>        // else we do.
104103>>>        If (iArgs > 3 and iArgs < 6 and sAuthor <> "") Begin
104105>>>            Send Add_Line sAuthor
104106>>>        End
104106>>>>
104106>>>        Else If (iArgs > 5 and sAuthor <> "") Begin
104109>>>            Send Add_LineLn sAuthor
104110>>>        End
104110>>>>
104110>>>
104110>>>        // Square bitmaps of 80x80 works best
104110>>>        If (iArgs > 4 and sBitmap <> "") Begin
104112>>>            Set Logo to sBitMap
104113>>>        End
104113>>>>
104113>>>
104113>>>        // Here starts handling of the five optional params:
104113>>>        If (iArgs = 6 and sParam6  <> "") Begin
104115>>>            Send Add_Line sParam6
104116>>>        End
104116>>>>
104116>>>        Else If (iArgs > 6 and sParam6  <> "") Begin
104119>>>            Send Add_LineLn sParam6
104120>>>        End
104120>>>>
104120>>>
104120>>>        If (iArgs = 7 and sParam7  <> "") Begin
104122>>>            Send Add_Line sParam7
104123>>>        End
104123>>>>
104123>>>        Else If (iArgs > 7 and sParam7  <> "") Begin
104126>>>            Send Add_LineLn sParam7
104127>>>        End
104127>>>>
104127>>>
104127>>>        If (iArgs = 8 and sParam8  <> "") Begin
104129>>>            Send Add_Line sParam8
104130>>>        End
104130>>>>
104130>>>        Else If (iArgs > 8 and sParam8  <> "") Begin
104133>>>            Send Add_LineLn sParam8
104134>>>        End
104134>>>>
104134>>>
104134>>>        If (iArgs = 9 and sParam9  <> "") Begin
104136>>>            Send Add_Line sParam9
104137>>>        End
104137>>>>
104137>>>        Else If (iArgs > 9 and sParam9  <> "") Begin
104140>>>            Send Add_LineLn sParam9
104141>>>        End
104141>>>>
104141>>>
104141>>>        If (iArgs = 10 and sParam10 <> "") Begin
104143>>>            Send Add_Line sParam10
104144>>>        End
104144>>>>
104144>>>
104144>>>        Move Self to hoObj
104145>>>    End_Object
104146>>>
104146>>>    Send Popup   of hoObj // Popup the about object
104147>>>    Send Destroy of hoObj // When done, it will be destroyed
104148>>>End_Procedure
104149>        Use CompareDatabases.rv
Including file: CompareDatabases.rv    (C:\Projects\DF20\DbUpdateFramework\AppSrc\CompareDatabases.rv)
104149>>>Use Windows.pkg
104149>>>Use DFRptVw.pkg
104149>>>Use DFRpt.pkg
104149>>>Use File_Dlg.Pkg
104149>>>Use CompareDatabases.img
Including file: CompareDatabases.img    (C:\Projects\DF20\DbUpdateFramework\AppSrc\CompareDatabases.img)
104149>>>>>// CompareDatabases Basic Report
104149>>>>>// Since report images, such as the one used here, are not fully supported by
104149>>>>>// the Studio, the images for this report are placed in a separate package.
104149>>>>>//
/HEADER
Image 1, HEADER
 ***  The Database Update Framework (DUF) DATABASE DIFFERENCES REPORT  ***
     
      Date & Time Printed       : ____________________
      FROM Database Filelist.cfg: ________________________________________________________________________________________________________________________
      TO   Database Filelist.cfg: ________________________________________________________________________________________________________________________
/Top
Image 2, TOP
                                                                           Page:___.
/SubHeader
Image 3, SUBHEADER
________ Difference(s) for Table: ____ - ______________________________    
====================================================================================
FROM Database:                                              TO Database:
------------------------------------------------------------------------
/BodyFields
Image 4, BODYFIELDS
Field Number:  ____                                         ____
Name:          ____________________________________________ ____________________________________________
Type:          ____________________________________________ ____________________________________________
Length:        ____                                         ____
Precision:     ____                                         ____
Identity Field:___                                          ___   
/Footer
Image 5, FOOTER
SUMMARY:
====================================================================================
Number of Tables with differences: ____
/*
104149>>>
104149>>>Activate_View Activate_oCompareDatabases for oCompareDatabases
104159>>>>
104159>>>Object oCompareDatabases is a ReportView
104161>>>    Set Location to 6 6
104162>>>    Set Size to 84 181
104163>>>    Set Label to "Compare Databases"
104164>>>
104164>>>    Property String psFilelistFrom
104166>>>    Property String psFilelistTo
104168>>>    Property Integer piDifferences
104170>>>
104170>>>    Object oDestination is a RadioGroup
104172>>>        Set Size to 59 171
104173>>>        Set Location to 5 5
104174>>>        Set Label to "Output Device:"
104175>>>
104175>>>        Object oScreen is a Radio
104177>>>            Set Label to "Screen"
104178>>>            Set Size to 10 39
104179>>>            Set Location to 15 10
104180>>>            Set Status_Help to "Preview the report to screen"
104181>>>        End_Object
104182>>>
104182>>>        Object oPrinter is a Radio
104184>>>            Set Label to "Printer"
104185>>>            Set Size to 10 37
104186>>>            Set Location to 30 10
104187>>>            Set Status_Help to "Send the report to the default printer"
104188>>>        End_Object
104189>>>
104189>>>        Object oFile is a Radio
104191>>>            Set Label to "File"
104192>>>            Set Size to 10 27
104193>>>            Set Location to 42 10
104194>>>            Set Status_Help to "Send the report to a file"
104195>>>        End_Object
104196>>>
104196>>>        Object oFileNameForm is a Form
104198>>>            Set Label to "FileName:"
104199>>>            Set Size to 13 116
104200>>>            Set Location to 40 50
104201>>>            Set Label_Col_Offset to 0
104202>>>            Set Label_Justification_Mode to jMode_Top
104203>>>            Set Prompt_Button_Mode to pb_PromptOn
104204>>>
104204>>>            Procedure Prompt
104207>>>                Boolean bOk
104207>>>                String sFileName sFilePath sDataPath
104207>>>                Integer hoWorkspace
104207>>>
104207>>>                Get Value To sFileName
104208>>>                If (sFileName <> "") Begin
104210>>>                    Set File_Name Of oSaveAsDialog to sFileName
104211>>>                    Get ExtractFilePath sFileName to sFilePath
104212>>>                End
104212>>>>
104212>>>                If (sFilePath = "") Begin
104214>>>                    Get phoWorkspace Of ghoApplication to hoWorkspace
104215>>>                    Get psDataPath Of hoWorkspace to sDataPath
104216>>>                    Get PathAtIndex Of hoWorkspace sDataPath 1 to sFilePath
104217>>>                End
104217>>>>
104217>>>
104217>>>                Set Initial_Folder Of oSaveAsDialog to sFilePath
104218>>>
104218>>>                Get Show_Dialog Of oSaveAsDialog to bOk
104219>>>                If (bOk) Begin
104221>>>                    Get File_Name Of oSaveAsDialog to sFileName
104222>>>                    Set Value To sFileName
104223>>>                End
104223>>>>
104223>>>            End_Procedure
104224>>>
104224>>>        End_Object
104225>>>
104225>>>        Procedure Notify_Select_State Integer iNewItem Integer iOldItem
104228>>>            Forward Send Notify_Select_State iNewItem iOldItem
104230>>>
104230>>>            Case Begin
104230>>>                Case (iNewItem = 0)
104232>>>                    Set Output_Device_Mode to PRINT_TO_WINDOW
104233>>>                    Case Break
104234>>>                Case (iNewItem = 1)
104237>>>                    Set Output_Device_Mode to PRINT_TO_PRINTER
104238>>>                    Case Break
104239>>>                Case (iNewItem = 2)
104242>>>                    Set Output_Device_Mode to PRINT_TO_FILE
104243>>>                    Case Break
104244>>>            Case End
104244>>>
104244>>>            Set Enabled_State Of oFileNameForm to (iNewItem = 2)
104245>>>        End_Procedure
104246>>>
104246>>>    End_Object
104247>>>
104247>>>    Object oOkButton is a Button
104249>>>        Set Label to "&OK"
104250>>>        Set Location to 66 71
104251>>>        Set Default_State to TRUE
104252>>>
104252>>>        Procedure OnClick
104255>>>            Send StartReport
104256>>>        End_Procedure
104257>>>
104257>>>    End_Object
104258>>>
104258>>>    Object oCancelButton is a Button
104260>>>        Set Label to "&Cancel"
104261>>>        Set Location to 66 126
104262>>>
104262>>>        Procedure OnClick
104265>>>            Send Request_Cancel
104266>>>        End_Procedure
104267>>>
104267>>>    End_Object
104268>>>
104268>>>    Object oSaveAsDialog is a SaveAsDialog
104270>>>    End_Object
104271>>>
104271>>>    Procedure StartReport
104274>>>        Integer iOutputDevice
104274>>>        Handle hoWorkspace
104274>>>        String sFileName sCurrentDirectory sDataPath
104274>>>
104274>>>        Get Output_Device_Mode to iOutputDevice
104275>>>
104275>>>        Case Begin
104275>>>            Case (iOutputDevice = PRINT_TO_WINDOW)
104277>>>                Get_Current_Directory to sCurrentDirectory
104278>>>                Get phoWorkspace Of ghoApplication to hoWorkspace
104279>>>                Get psDataPath Of hoWorkspace to sDataPath
104280>>>                Get PathAtIndex Of hoWorkspace sDataPath 1 to sDataPath
104281>>>                Set_Directory sDataPath
104282>>>                Make_Temp_File "TXT" sFileName
104283>>>                Set_Directory sCurrentDirectory
104284>>>                If (Right(sDataPath, 1) <> Sysconf(SYSCONF_DIR_SEPARATOR)) Begin
104286>>>                    Move (sDataPath - Sysconf(SYSCONF_DIR_SEPARATOR)) To sDataPath
104287>>>                End
104287>>>>
104287>>>                Move (sDataPath - sFileName) to sFileName
104288>>>                Set Output_Device_Name to sFileName
104289>>>                Case Break
104290>>>            Case (iOutputDevice = PRINT_TO_PRINTER)
104293>>>                Set Output_Device_Name to "WinLST:"
104294>>>                Case Break
104295>>>            Case (iOutputDevice = PRINT_TO_FILE)
104298>>>                Get Value Of oFileNameForm to sFileName
104299>>>                Set Output_Device_Name to sFileName
104300>>>                Case Break
104301>>>        Case End
104301>>>
104301>>>        Send Run_Report
104302>>>
104302>>>        If (iOutputDevice = PRINT_TO_WINDOW) Begin
104304>>>            //Runprogram Background "NotePad" sFileName
104304>>>            Runprogram Shell Background sFileName
104305>>>            EraseFile sFileName
104306>>>>
104306>>>        End
104306>>>>
104306>>>    End_Procedure
104307>>>
104307>>>    Object oBasicReport is a BasicReport
104309>>>
104309>>>        Function Starting_Main_Report Returns Integer
104312>>>            Integer iRetval
104312>>>
104312>>>            Forward Get Starting_Main_Report to iRetval
104314>>>
104314>>>            Function_Return iRetval
104315>>>        End_Function
104316>>>
104316>>>        Procedure_Section Report_Header as Header
104321>>>            DateTime dtCreationTime
104321>>>            String sFilelistFrom sFilelistTo
104321>>>
104321>>>            Get psFilelistFrom to sFilelistFrom
104322>>>            Get psFilelistTo   to sFilelistTo
104323>>>            Move (CurrentDateTime()) to dtCreationTime
104324>>>
104324>>>            Print sFilelistFrom
104325>>>            Print sFilelistTo
104326>>>            Print dtCreationTime
104327>>>            Output_PageCheck Header
104328>>>        End_Procedure
104329>>>
104329>>>        Procedure_Section Page_Top as Top
104334>>>            Integer iPage
104334>>>
104334>>>            Get Page_Count to iPage
104335>>>            Print iPage
104336>>>            OutPut_PageCheck
104337>>>        End_Procedure
104338>>>
104338>>>        Procedure_Section SubHeaderFields as SubHeader
104343>>>            Print "Field"
104344>>>            Print "Table#"
104345>>>            Print "Table Name"
104346>>>        End_Procedure
104347>>>
104347>>>        Procedure_Section Body as BodyFields
104352>>>            Forward Send Body
104354>>>            // Print File.Field // Gets printed at BodySection.1
104354>>>            // Print Variable // Gets printed at BodySection.2
104354>>>            // Output_PageCheck // Without this nothing gets printed
104354>>>        End_Procedure
104355>>>
104355>>>//        Procedure_Section Page_Bottom as FooterSection
104355>>>//            Forward Send Page_Bottom
104355>>>//            // Output_PageCheck // Without this nothing gets printed
104355>>>//        End_Procedure
104355>>>
104355>>>        Procedure_Section Total as Footer
104360>>>            Integer iDifferences
104360>>>            Get piDifferences to iDifferences
104361>>>            Print iDifferences
104362>>>        End_Procedure
104363>>>
104363>>>    End_Object
104364>>>
104364>>>    On_Key Key_Alt+Key_O Send KeyAction of oOkButton
104365>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancelButton
104366>>>
104366>>>End_Object
104367>        Procedure Activate_About
104370>            Send DoAbout "" "" ("Copyright 2016-2024" * psCompany(ghoApplication)) "Author: Nils Svedmyr" "DUFUpdateCodeGenerator64x64.bmp" "E-mail: mailto:support@rdctools.com" "Web-site: www.rdctools.com" ("This tool was created with DataFlex" * String(C_DFVersion) * "from Data Access Worldwide. Please visit http://www.dataaccess.com for a free personal copy of DataFlex.")
104371>        End_Procedure
104372>
104372>        On_Key Key_Ctrl+Key_Tab           Send Switch_Next_View
104373>        On_Key Key_Ctrl+Key_Shift+Key_Tab Send Switch_Prior_View
104374>    End_Object
104375>
104375>    // Note that we have overriden the cHtmlHelp "GetHelpFile" function
104375>    // in the oHtmlHelp object, so we need to explitetly send the message
104375>    // to that object.
104375>    Procedure ShowProgramHelp
104378>        Set psHelpFile of ghoApplication to "Developer5.chm"
104379>        Send DoDisplayKeyword of oHtmlHelp "DUF Code Generator"
104380>    End_Procedure
104381>
104381>    Procedure ActivateCompareView
104384>        Send Execute of (oCompareDatabases_MenuItem(ghoCommandBars))
104385>    End_Procedure
104386>
104386>    Procedure ActivateGenerateView
104389>        Send Execute of (oCodeGenerator_MenuItem(ghoCommandBars))
104390>    End_Procedure
104391>
104391>    On_Key Key_Alt+Key_D   Send ActivateCompareView
104392>    On_Key Key_Ctrl+Key_D  Send ActivateCompareView
104393>    On_Key Key_Alt+Key_G   Send ActivateGenerateView
104394>    On_Key Key_Ctrl+Key_G  Send ActivateGenerateView    
104395>    On_Key Key_F1          Send ShowProgramHelp
104396>End_Object
104397>
104397>Send Execute of (oCodeGenerator_MenuItem(ghoCommandBars))
104398>Start_UI
104399>
Including Resources...
Summary
Memory Available: 2147483646
Total Warnings : 0
Total Errors   : 0
Total Symbols  : 54659
Total Resources: 6
Total Commands : 104398
Total Windows  : 20
Total Pages    : 5
Static Data    : 848769
Message area   : 668700
Total Blocks   : 37548
