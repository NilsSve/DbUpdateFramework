Compiling Program: C:\Projects\DF20\DbUpdateFramework\AppSrc\DUFCodeGenerator.src
Memory Available: 2147483646
1>    CompilerLevelWarning All On
1>Use DFAllEnt.pkg
Using pre-compiled package DFALLENT.PKG
Including file: dfallent.pkd    (C:\Program Files\DataFlex 20.1\Pkg\dfallent.pkd)
73081>Use cCJStandardCommandBarSystem.pkg
Including file: cCJStandardCommandBarSystem.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cCJStandardCommandBarSystem.pkg)
73081>>>// these are all the packages used in a standard MDI menubar/toolbar system
73081>>>
73081>>>Use cCJCommandBarSystem.pkg
73081>>>Use cCJStandardMenuItemClasses.pkg
Including file: cCJStandardMenuItemClasses.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cCJStandardMenuItemClasses.pkg)
73081>>>>>Use Dfpanel.pkg
73081>>>>>Use cCJCommandBarSystem.pkg
73081>>>>>Use LanguageText.pkg
73081>>>>>
73081>>>>>
73081>>>>>Class cCJUndoMenuItem is a cCJMenuItem
73082>>>>>    
73082>>>>>    Procedure Construct_Object
73084>>>>>        Forward Send Construct_Object
73086>>>>>        Set psCaption   to C_$CaptionUndo
73087>>>>>        Set psToolTip to C_$ToolTipUndo
73088>>>>>        Set psDescription to C_$DescUndo
73089>>>>>        Set psImage to "ActionUndo.ico"
73090>>>>>        Set pbActiveUpdate to True
73091>>>>>        Set psCategory to C_$CategoryEdit
73092>>>>>        Set psShortcut to C_$Key_Ctrl_Z
73093>>>>>    End_Procedure
73094>>>>>    
73094>>>>>    Procedure OnExecute Variant vCommandBarControl
73096>>>>>        Send Undo of (focus(Self))
73097>>>>>    End_Procedure
73098>>>>>    
73098>>>>>    Function IsEnabled Returns Boolean
73100>>>>>        Boolean bEnabled
73100>>>>>        Get CanUndo of (Focus(Self)) to bEnabled
73101>>>>>        Function_Return bEnabled
73102>>>>>    End_Function
73103>>>>>    
73103>>>>>End_Class
73104>>>>>
73104>>>>>
73104>>>>>Class cCJDeleteEditMenuItem is a cCJMenuItem
73105>>>>>    
73105>>>>>    Procedure Construct_Object
73107>>>>>        Forward Send Construct_Object
73109>>>>>        Set psCaption   to C_$CaptionDelete
73110>>>>>        Set psToolTip to C_$ToolTipDelete
73111>>>>>        Set psDescription to C_$DescDelete
73112>>>>>        Set psImage to "actionDelete.ico"
73113>>>>>        Set psShortcut to C_$Key_Delete
73114>>>>>        Set pbActiveUpdate to True
73115>>>>>        Set psCategory to C_$CategoryEdit
73116>>>>>    End_Procedure
73117>>>>>    
73117>>>>>    
73117>>>>>    Procedure OnExecute Variant vCommandBarControl
73119>>>>>        Send Delete of (focus(Self))
73120>>>>>    End_Procedure
73121>>>>>    
73121>>>>>    Function IsEnabled Returns Boolean
73123>>>>>        Boolean bEnabled
73123>>>>>        Get CanDelete of (Focus(Self)) to bEnabled
73124>>>>>        Function_Return bEnabled
73125>>>>>    End_Function
73126>>>>>    
73126>>>>>End_Class
73127>>>>>
73127>>>>>
73127>>>>>Class cCJCutMenuItem is a cCJMenuItem
73128>>>>>    
73128>>>>>    Procedure Construct_Object
73130>>>>>        Forward Send Construct_Object
73132>>>>>        Set psCaption   to C_$CaptionCut
73133>>>>>        Set psToolTip to C_$TooltipCut
73134>>>>>        Set psDescription to C_$DescCut
73135>>>>>        Set psImage to "actionCut.ico"
73136>>>>>        Set psShortcut to C_$Key_Ctrl_X
73137>>>>>        Set pbActiveUpdate to True
73138>>>>>        Set psCategory to C_$CategoryEdit
73139>>>>>    End_Procedure
73140>>>>>    
73140>>>>>    
73140>>>>>    Procedure OnExecute Variant vCommandBarControl
73142>>>>>        Send Cut of (focus(Self))
73143>>>>>    End_Procedure
73144>>>>>    
73144>>>>>    Function IsEnabled Returns Boolean
73146>>>>>        Boolean bEnabled
73146>>>>>        Get CanCut of (Focus(Self)) to bEnabled
73147>>>>>        Function_Return bEnabled
73148>>>>>    End_Function
73149>>>>>    
73149>>>>>End_Class
73150>>>>>
73150>>>>>
73150>>>>>Class cCJCopyMenuItem is a cCJMenuItem
73151>>>>>    
73151>>>>>    Procedure Construct_Object
73153>>>>>        Forward Send Construct_Object
73155>>>>>        Set psCaption   to C_$CaptionCopy
73156>>>>>        Set psToolTip to C_$ToolTipCopy
73157>>>>>        Set psDescription to C_$DescCopy
73158>>>>>        Set psImage to "actionCopy.ico"
73159>>>>>        Set psShortcut to C_$Key_Ctrl_C
73160>>>>>        Set pbActiveUpdate to True
73161>>>>>        Set psCategory to C_$CategoryEdit
73162>>>>>    End_Procedure
73163>>>>>    
73163>>>>>    
73163>>>>>    Procedure OnExecute Variant vCommandBarControl
73165>>>>>        Send Copy of (focus(Self))
73166>>>>>    End_Procedure
73167>>>>>    
73167>>>>>    Function IsEnabled Returns Boolean
73169>>>>>        Boolean bEnabled
73169>>>>>        Get CanCopy of (Focus(Self)) to bEnabled
73170>>>>>        Function_Return bEnabled
73171>>>>>    End_Function
73172>>>>>    
73172>>>>>End_Class
73173>>>>>
73173>>>>>
73173>>>>>Class cCJPasteMenuItem is a cCJMenuItem
73174>>>>>    
73174>>>>>    Procedure Construct_Object
73176>>>>>        Forward Send Construct_Object
73178>>>>>        Set psCaption   to C_$CaptionPaste
73179>>>>>        Set psToolTip to C_$ToolTipPaste
73180>>>>>        Set psDescription to C_$DescPaste
73181>>>>>        Set psImage to "actionPaste.ico"
73182>>>>>        Set pbActiveUpdate to True
73183>>>>>        Set psShortcut to C_$Key_Ctrl_V
73184>>>>>        Set psCategory to C_$CategoryEdit
73185>>>>>    End_Procedure
73186>>>>>    
73186>>>>>    
73186>>>>>    Procedure OnExecute Variant vCommandBarControl
73188>>>>>        Send Paste of (focus(Self))
73189>>>>>    End_Procedure
73190>>>>>    
73190>>>>>    Function IsEnabled Returns Boolean
73192>>>>>        Boolean bEnabled
73192>>>>>        Get CanPaste of (Focus(Self)) to bEnabled
73193>>>>>        Function_Return bEnabled
73194>>>>>    End_Function
73195>>>>>    
73195>>>>>End_Class
73196>>>>>
73196>>>>>Class cCJSelectAllMenuItem is a cCJMenuItem
73197>>>>>    
73197>>>>>    Procedure Construct_Object
73199>>>>>        Forward Send Construct_Object
73201>>>>>        Set psCaption   to C_$CaptionSelectAll
73202>>>>>        Set psToolTip to C_$ToolTipSelectAll
73203>>>>>        Set psDescription to C_$DescSelectAll
73204>>>>>        Set pbActiveUpdate to True
73205>>>>>        Set psShortcut to C_$Key_Ctrl_A
73206>>>>>        Set psCategory to C_$CategoryEdit
73207>>>>>    End_Procedure
73208>>>>>    
73208>>>>>    
73208>>>>>    Procedure OnExecute Variant vCommandBarControl
73210>>>>>        Send Select_All of (focus(Self))
73211>>>>>    End_Procedure
73212>>>>>    
73212>>>>>    Function IsEnabled Returns Boolean
73214>>>>>        Boolean bEnabled
73214>>>>>        Get CanSelect of (Focus(Self)) to bEnabled
73215>>>>>        Function_Return bEnabled
73216>>>>>    End_Function
73217>>>>>    
73217>>>>>End_Class
73218>>>>>
73218>>>>>
73218>>>>>Class cCJExitMenuItem is a cCJMenuItem
73219>>>>>    
73219>>>>>    Procedure Construct_Object
73221>>>>>        Forward Send Construct_Object
73223>>>>>        Set psCaption to C_$CaptionExit
73224>>>>>        Set psToolTip to C_$ToolTipExit
73225>>>>>        Set psDescription to C_$ToolTipExit
73226>>>>>        Set psShortcut to C_$Key_Alt_F4
73227>>>>>        Set psCategory to C_$CategoryFile
73228>>>>>    End_Procedure
73229>>>>>    
73229>>>>>    Procedure OnExecute Variant vCommandBarControl
73231>>>>>        Send Exit_Application of Desktop
73232>>>>>    End_Procedure
73233>>>>>    
73233>>>>>End_Class
73234>>>>>
73234>>>>>Class cCJHelpMenuItem is a cCJMenuItem
73235>>>>>    
73235>>>>>    Procedure Construct_Object
73237>>>>>        Forward Send Construct_Object
73239>>>>>        Set psCaption to C_$CaptionHelp
73240>>>>>        Set psDescription to C_$ToolTipHelp
73241>>>>>        Set psToolTip to C_$DescHelp
73242>>>>>        Set psImage to "ActionHelp.ico"
73243>>>>>        Set psShortcut to "F1"
73244>>>>>        Set psCategory to C_$CategoryHelp
73245>>>>>    End_Procedure
73246>>>>>    
73246>>>>>    Procedure OnExecute Variant vCommandBarControl
73248>>>>>        Send Help of (Focus(Self))
73249>>>>>    End_Procedure
73250>>>>>    
73250>>>>>End_Class
73251>>>>>
73251>>>>>Class cCJStatusbarMenuItem is a cCJMenuItem
73252>>>>>    
73252>>>>>    Procedure Construct_Object
73254>>>>>        Forward Send Construct_Object
73256>>>>>        Set psCaption to C_$CaptionAddStatusbar
73257>>>>>        Set psToolTip to C_$ToolTipAddStatusbar
73258>>>>>        Set psDescription to  C_$DescAddStatusbar
73259>>>>>        Set psCategory to C_$CategoryWindow
73260>>>>>    End_Procedure
73261>>>>>    
73261>>>>>    Procedure OnExecute Variant vCommandBarControl
73263>>>>>        Handle hoCommandBars hoClientArea
73263>>>>>        Get CommandBarSystemObject to hoCommandBars
73264>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73265>>>>>        If hoClientArea Begin
73267>>>>>            // the clientarea's parent panel has message
73267>>>>>            Send Toggle_StatusBar of (Parent(hoClientArea))
73268>>>>>        End
73268>>>>>>
73268>>>>>    End_Procedure
73269>>>>>    
73269>>>>>    Function IsChecked Returns Boolean
73271>>>>>        Boolean bOn
73271>>>>>        Handle hoCommandBars hoClientArea
73271>>>>>        Get CommandBarSystemObject to hoCommandBars
73272>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73273>>>>>        If hoClientArea Begin
73275>>>>>            // the clientarea's parent panel has message
73275>>>>>            Get StatusBar_State of (Parent(hoClientArea)) to bOn
73276>>>>>        End
73276>>>>>>
73276>>>>>        Function_Return bOn
73277>>>>>    End_Function
73278>>>>>End_Class
73279>>>>>
73279>>>>>Class cCJAutoArrangeIconsMenuItem is a cCJMenuItem
73280>>>>>    
73280>>>>>    Procedure Construct_Object
73282>>>>>        Forward Send Construct_Object
73284>>>>>        Set psCaption to C_$CaptionAutoArrangeIcons
73285>>>>>        Set psToolTip to C_$ToolTipAutoArrangeIcons
73286>>>>>        Set psDescription to C_$DescAutoArrangeIcons
73287>>>>>        Set psCategory to C_$CategoryWindow
73288>>>>>    End_Procedure
73289>>>>>    
73289>>>>>    Procedure OnExecute Variant vCommandBarControl
73291>>>>>        Handle hoCommandBars hoClientArea
73291>>>>>        Get CommandBarSystemObject to hoCommandBars
73292>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73293>>>>>        If hoClientArea Begin
73295>>>>>            // the clientarea's parent panel has message
73295>>>>>            Send Toggle_Auto_Arrange_Icons of (Parent(hoClientArea))
73296>>>>>        End
73296>>>>>>
73296>>>>>    End_Procedure
73297>>>>>    
73297>>>>>    Function IsChecked Returns Boolean
73299>>>>>        Boolean bOn
73299>>>>>        Handle hoCommandBars hoClientArea
73299>>>>>        Get CommandBarSystemObject to hoCommandBars
73300>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73301>>>>>        If hoClientArea Begin
73303>>>>>            // the clientarea's parent panel has message
73303>>>>>            Get Auto_Arrange_Icons_State of (Parent(hoClientArea)) to bOn
73304>>>>>        End
73304>>>>>>
73304>>>>>        Function_Return bOn
73305>>>>>    End_Function
73306>>>>>End_Class
73307>>>>>
73307>>>>>Class cCJRestoreMenusMenuItem is a cCJMenuItem
73308>>>>>    
73308>>>>>    Procedure Construct_Object
73310>>>>>        Forward Send Construct_Object
73312>>>>>        Set psCaption to C_$CaptionRestoreMenus
73313>>>>>        Set psToolTip to C_$ToolTipRestoreMenus
73314>>>>>        Set psDescription to C_$DescRestoreMenus
73315>>>>>        Set psCategory to C_$CategoryWindow
73316>>>>>    End_Procedure
73317>>>>>    
73317>>>>>    Procedure OnExecute Variant vCommandBarControl
73319>>>>>        Handle hoCommandBars
73319>>>>>        Get CommandBarSystemObject to hoCommandBars
73320>>>>>        Send RestoreLayout of hoCommandBars
73321>>>>>    End_Procedure
73322>>>>>    
73322>>>>>End_Class
73323>>>>>
73323>>>>>Class cCJCascadeMenuItem is a cCJMenuItem
73324>>>>>    
73324>>>>>    Procedure Construct_Object
73326>>>>>        Forward Send Construct_Object
73328>>>>>        Set psCaption to C_$CaptionCascade
73329>>>>>        Set psToolTip to C_$ToolTipCascade
73330>>>>>        Set psDescription to  C_$DescCascade
73331>>>>>        Set psImage to "ActionCascade.ico"
73332>>>>>        Set psCategory to C_$CategoryWindow
73333>>>>>    End_Procedure
73334>>>>>    
73334>>>>>    Procedure OnExecute Variant vCommandBarControl
73336>>>>>        Handle hoCommandBars hoClientArea
73336>>>>>        Get CommandBarSystemObject to hoCommandBars
73337>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73338>>>>>        If hoClientArea Begin
73340>>>>>            Send Cascade_Windows of hoClientArea
73341>>>>>        End
73341>>>>>>
73341>>>>>    End_Procedure
73342>>>>>End_Class
73343>>>>>
73343>>>>>Class cCJTileHorizontally is a cCJMenuItem
73344>>>>>    
73344>>>>>    Procedure Construct_Object
73346>>>>>        Forward Send Construct_Object
73348>>>>>        Set psCaption to C_$CaptionTileHorizontally
73349>>>>>        Set psToolTip to C_$ToolTipTileHorizontally
73350>>>>>        Set psDescription to  C_$DescTileHorizontally
73351>>>>>        Set psImage to "ActionTileHorizontally.ico"
73352>>>>>        Set psCategory to C_$CategoryWindow
73353>>>>>    End_Procedure
73354>>>>>    
73354>>>>>    Procedure OnExecute Variant vCommandBarControl
73356>>>>>        Handle hoCommandBars hoClientArea
73356>>>>>        Get CommandBarSystemObject to hoCommandBars
73357>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73358>>>>>        If hoClientArea Begin
73360>>>>>            Send Tile_Windows_Horizontal of hoClientArea
73361>>>>>        End
73361>>>>>>
73361>>>>>    End_Procedure
73362>>>>>End_Class
73363>>>>>
73363>>>>>Class cCJTileVertically is a cCJMenuItem
73364>>>>>    
73364>>>>>    Procedure Construct_Object
73366>>>>>        Forward Send Construct_Object
73368>>>>>        Set psCaption to C_$CaptionTileVertically
73369>>>>>        Set psToolTip to C_$ToolTipTileVertically
73370>>>>>        Set psDescription to  C_$DescTileVertically
73371>>>>>        Set psImage to "ActionTileVertically.ico"
73372>>>>>        Set psCategory to C_$CategoryWindow
73373>>>>>    End_Procedure
73374>>>>>    
73374>>>>>    Procedure OnExecute Variant vCommandBarControl
73376>>>>>        Handle hoCommandBars hoClientArea
73376>>>>>        Get CommandBarSystemObject to hoCommandBars
73377>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73378>>>>>        If hoClientArea Begin
73380>>>>>            Send Tile_Windows_Vertical of hoClientArea
73381>>>>>        End
73381>>>>>>
73381>>>>>    End_Procedure
73382>>>>>End_Class
73383>>>>>
73383>>>>>Class cCJMinimizeWindowsMenuItem is a cCJMenuItem
73384>>>>>    
73384>>>>>    Procedure Construct_Object
73386>>>>>        Forward Send Construct_Object
73388>>>>>        Set psCaption to C_$CaptionMinimizeWindows
73389>>>>>        Set psToolTip to C_$ToolTipMinimizeWindows
73390>>>>>        Set psDescription to  C_$DescMinimizeWindows
73391>>>>>        Set psCategory to C_$CategoryWindow
73392>>>>>    End_Procedure
73393>>>>>    
73393>>>>>    Procedure OnExecute Variant vCommandBarControl
73395>>>>>        Handle hoCommandBars hoClientArea
73395>>>>>        Get CommandBarSystemObject to hoCommandBars
73396>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73397>>>>>        If hoClientArea Begin
73399>>>>>            // the clientarea's parent panel has message
73399>>>>>            Send Minimize_all_Windows of (Parent(hoClientArea))
73400>>>>>        End
73400>>>>>>
73400>>>>>    End_Procedure
73401>>>>>End_Class
73402>>>>>
73402>>>>>
73402>>>>>Class cCJRestoreWindowsMenuItem is a cCJMenuItem
73403>>>>>    
73403>>>>>    Procedure Construct_Object
73405>>>>>        Forward Send Construct_Object
73407>>>>>        Set psCaption to C_$CaptionRestoreWindows
73408>>>>>        Set psToolTip to C_$ToolTipRestoreWindows
73409>>>>>        Set psDescription to  C_$DescRestoreWindows
73410>>>>>        Set psCategory to C_$CategoryWindow
73411>>>>>    End_Procedure
73412>>>>>    
73412>>>>>    Procedure OnExecute Variant vCommandBarControl
73414>>>>>        Handle hoCommandBars hoClientArea
73414>>>>>        Get CommandBarSystemObject to hoCommandBars
73415>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73416>>>>>        If hoClientArea Begin
73418>>>>>            // the clientarea's parent panel has message
73418>>>>>            Send Restore_all_Windows of (Parent(hoClientArea))
73419>>>>>        End
73419>>>>>>
73419>>>>>    End_Procedure
73420>>>>>End_Class
73421>>>>>
73421>>>>>Class cCJArrangeIconsMenuItem is a cCJMenuItem
73422>>>>>    
73422>>>>>    Procedure Construct_Object
73424>>>>>        Forward Send Construct_Object
73426>>>>>        Set psCaption to C_$CaptionArrangeIcons
73427>>>>>        Set psToolTip to C_$ToolTipArrangeIcons
73428>>>>>        Set psDescription to  C_$DescArrangeIcons
73429>>>>>        Set psCategory to C_$CategoryWindow
73430>>>>>    End_Procedure
73431>>>>>    
73431>>>>>    Procedure OnExecute Variant vCommandBarControl
73433>>>>>        Handle hoCommandBars hoClientArea
73433>>>>>        Get CommandBarSystemObject to hoCommandBars
73434>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73435>>>>>        If hoClientArea Begin
73437>>>>>            Send Arrange_Icons of hoClientArea
73438>>>>>        End
73438>>>>>>
73438>>>>>    End_Procedure
73439>>>>>    
73439>>>>>End_Class
73440>>>Use cCJAboutMenuItem.pkg
Including file: cCJAboutMenuItem.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cCJAboutMenuItem.pkg)
73440>>>>>Use cCJCommandBarSystem.pkg
73440>>>>>Use LanguageText.pkg
73440>>>>>
73440>>>>>// It is expected that if you use this class that you provide an about object that is
73440>>>>>// activated via activate_about such as DfAbout.pkg. We don't use this for you automatically
73440>>>>>// because you may wish to create your own custom about package.
73440>>>>>
73440>>>>>Class cCJAboutMenuItem is a cCJMenuItem    
73441>>>>>
73441>>>>>    Procedure Construct_Object
73443>>>>>        Forward Send Construct_Object
73445>>>>>        Set psCaption to C_$CaptionAbout
73446>>>>>        Set psDescription to C_$ToolTipAbout
73447>>>>>        Set psToolTip to C_$DescAbout
73448>>>>>        Set psImage to "ActionAbout.ico"
73449>>>>>        Set psCategory to C_$CategoryHelp
73450>>>>>    End_Procedure
73451>>>>>    
73451>>>>>    Procedure OnExecute Variant vCommandBarControl
73453>>>>>        Handle hoCommandBars hoClientArea
73453>>>>>        Get CommandBarSystemObject to hoCommandBars
73454>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73455>>>>>        If hoClientArea Begin
73457>>>>>            Send Activate_About of hoClientArea
73458>>>>>        End
73458>>>>>>
73458>>>>>    End_Procedure
73459>>>>>
73459>>>>>End_Class
73460>>>>>
73460>>>>>
73460>>>Use cCJDeoMenuItemClasses.pkg
73460>>>Use cCJMDIWindowsMenuItem.pkg
Including file: cCJMDIWindowsMenuItem.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cCJMDIWindowsMenuItem.pkg)
73460>>>>>Use cCJCommandBarSystem.pkg
73460>>>>>
73460>>>>>Register_Function Client_ID Returns Integer
73460>>>>>
73460>>>>>// only used by cCJMDIWIndowsMenuItem
73460>>>>>Class cCJMDIWindowItem is a cCJMenuItem
73461>>>>>    
73461>>>>>    Procedure Construct_Object
73463>>>>>        Forward Send Construct_Object
73465>>>>>        Property Handle phWindow 0 // object id of view
73466>>>>>        Set pbControlFlagNoMovable to True
73467>>>>>        Set pbActiveUpdate to True
73468>>>>>    End_Procedure
73469>>>>>    
73469>>>>>    Procedure OnExecute Variant vCommandBarControl
73471>>>>>        Handle hWindow
73471>>>>>        Get phWindow to hWindow
73472>>>>>        Send Activate_View of hWindow
73473>>>>>    End_Procedure
73474>>>>>    
73474>>>>>End_Class
73475>>>>>
73475>>>>>
73475>>>>>Class cCJMDIWindowsMenuItem is a cCJMenuItem
73476>>>>>    
73476>>>>>    Procedure Construct_Object
73478>>>>>        Forward Send Construct_Object
73480>>>>>        Property Handle[] phArrayOfWindows
73481>>>>>        Set peControlType to xtpControlPopup
73482>>>>>        Set psCategory to C_$CategoryWindow
73483>>>>>    End_Procedure
73484>>>>>    
73484>>>>>    // This adds MDI windows to the existing menu items.
73484>>>>>    // This removes any existing windows menus and always adds a new set to the end
73484>>>>>    
73484>>>>>    Procedure OnPopupInit Variant vCommandBarControl Handle hCommandBarControls
73486>>>>>        Handle  hClientArea hView
73486>>>>>        String  sLabel
73486>>>>>        Integer i iWindows
73486>>>>>        Handle[] hArrayOfWindows
73487>>>>>        Variant vItem
73487>>>>>        
73487>>>>>        // delete all windows actions and menu items. Assume we have an array of DF action objects for the windows
73487>>>>>        // also assume that destroying an action removes all menu instances of that action
73487>>>>>        Get phArrayOfWindows to hArrayOfWindows
73488>>>>>        Move (SizeOfArray(hArrayOfWindows)) to iWindows
73489>>>>>        For i from 0 to (iWindows-1)
73495>>>>>>
73495>>>>>            Send Destroy of hArrayOfWindows[i] // assume this removes all menu items of this action
73496>>>>>        Loop
73497>>>>>>
73497>>>>>        Move (ResizeArray(hArrayOfWindows,0)) to hArrayOfWindows
73498>>>>>        
73498>>>>>        // Add all views to this menu. Create the action and add the item
73498>>>>>        Move 0 to i
73499>>>>>        Get Client_Id to hClientArea // object id of client area
73500>>>>>        If (hClientArea > 0) Begin
73502>>>>>            Get Next_Mdi_Dialog of hClientArea True to hView // find first view
73503>>>>>            While (hView <> 0)
73507>>>>>                If (Active_State(hView)) Begin
73509>>>>>                    // create the action
73509>>>>>                    Get Create U_cCJMDIWindowItem to hArrayOfWindows[i]
73510>>>>>                    Get Label of hView to sLabel // caption bar (name) of view
73511>>>>>                    Set psCaption of hArrayOfWindows[i] to sLabel
73512>>>>>                    Set psDescription of hArrayOfWindows[i] to ("Make this view (" - trim(sLabel) - ") the active window.")
73513>>>>>                    If (current_scope(desktop)=hView and View_mode(hView)<>VIEWMODE_ICONIZE) Begin
73515>>>>>                        Set pbChecked of hArrayOfWindows[i] to True
73516>>>>>                    End
73516>>>>>>
73516>>>>>                    Set phWindow of hArrayOfWindows[i] to hView // used by custom OnExecute
73517>>>>>                    If (i=0) Begin
73519>>>>>                        Set pbControlBeginGroup of hArrayOfWindows[i] to True
73520>>>>>                    End
73520>>>>>>
73520>>>>>                    // Create a menu item for this action
73520>>>>>                    Get AddDynamicControl of hArrayOfWindows[i] hCommandBarControls to vItem
73521>>>>>                    Increment i
73522>>>>>                End
73522>>>>>>
73522>>>>>                Get Next_Mdi_Dialog of hClientArea False to hView // find next
73523>>>>>            Loop
73524>>>>>>
73524>>>>>        End
73524>>>>>>
73524>>>>>        
73524>>>>>        Set phArrayOfWindows to hArrayOfWindows
73525>>>>>        
73525>>>>>    End_Procedure
73526>>>>>    
73526>>>>>End_Class
73527>Use cCJCommandBarSystem.pkg
73527>Use Dferror.pkg
73527>Use Colr_dlg.pkg
Including file: Colr_dlg.pkg    (C:\Program Files\DataFlex 20.1\Pkg\Colr_dlg.pkg)
73527>>>Use VDFBase.pkg
73527>>>Use DLL.pkg
73527>>>Use RGB.pkg
73527>>>Use GlobalFunctionsProcedures.pkg
73527>>>
73527>>>Define CC_RGBINIT         for 1
73527>>>Define CC_FULLOPEN        for 2
73527>>>Define CC_PREVENTFULLOPEN for 4
73527>>>
73527>>>// When called directly, lpTemplateName of lpCC must refer to a WString type.
73527>>>External_Function ChooseColorW 'ChooseColorW' COMDLG32.dll Pointer lpCC Returns Integer
73528>>>
73528>>>// Wrapper Function ChooseColor
73528>>>Function ChooseColor Global ;    Pointer lpCC ;    Returns Integer
73530>>>    
73530>>>    // lpCC is a pointer to a ChooseColor struct, which contains a pointer to a string.
73530>>>    // The string must be converted to UTF-16 and afterwards back to UTF-8.
73530>>>    Integer iResult iVoid
73530>>>    Pointer pCC pOrigTemplateName
73530>>>    tWinChooseColor tCC
73530>>>    tWinChooseColor tCC
73530>>>    UWide uwTemplateName
73530>>>    UWide uwTemplateName
73530>>>
73530>>>    // Copy the struct to a local struct that can be modified to UTF-16.
73530>>>    Move (AddressOf(tCC)) to pCC
73531>>>    Move (CopyMemory(pCC, lpCC, SizeOfType(tWinChooseColor))) to iVoid
73532>>>
73532>>>    // Change lpTemplateName to UTF-16. This address is pointing to the original string.
73532>>>    Move tCC.lpTemplateName to pOrigTemplateName
73533>>>    Move (StringToWide(pOrigTemplateName, (&uwTemplateName))) to tCC.lpTemplateName
73534>>>
73534>>>    // Call the function using the local struct
73534>>>    Move (ChooseColorW(pCC)) to iResult
73535>>>    
73535>>>    // The struct is now filled with data. Revert strings back to UTF-8 and then copy the struct back to the original memory location.
73535>>>    
73535>>>    // Copy the string to the original location
73535>>>    Move pOrigTemplateName to tCC.lpTemplateName
73536>>>    Send WideToString (&uwTemplateName) tCC.lpTemplateName 
73537>>>    
73537>>>    // Copy the struct back to the incoming one
73537>>>    Move (CopyMemory(lpCC, pCC, SizeOfType(tWinChooseColor))) to iVoid
73538>>>    
73538>>>    Function_Return iResult
73539>>>End_Function
73540>>>
73540>>>
73540>>>Class ColorDialog is a cObject
73541>>>    Procedure Construct_Object
73543>>>        Integer iLoop
73543>>>        Handle hoCustomColors
73543>>>        
73543>>>        Forward Send Construct_Object
73545>>>        
73545>>>        Property Boolean FullOpen_State        True
73546>>>        Property Boolean PreventFullOpen_State False
73547>>>        Property Boolean SelectedColor_State   True
73548>>>        Property Integer SelectedColor         0
73549>>>        
73549>>>        Property Handle phoCustomColors (Create(Self, U_Array)) // create an array to hold the custom colors
73550>>>        
73550>>>        // Set all custom colors to white...
73550>>>        Get phoCustomColors to hoCustomColors
73551>>>        For iLoop from 0 to 15
73557>>>>
73557>>>            Set Value of hoCustomColors iLoop to clWhite
73558>>>        Loop
73559>>>>
73559>>>        
73559>>>    End_Procedure
73560>>>    
73560>>>    Procedure Set Custom_Color Integer iItem Integer rgbColor
73562>>>        Set Value of (phoCustomColors(Self)) iItem to rgbColor
73563>>>    End_Procedure
73564>>>    
73564>>>    Function Custom_Color Integer iItem Returns Integer
73566>>>        Function_Return (Integer_Value(phoCustomColors(Self), iItem))
73567>>>    End_Function
73568>>>    
73568>>>    Procedure AssignCustomColors Handle hoSourceColorDialog
73570>>>        // Copies the custom colors from another ColorDialog instance
73570>>>        Integer iColor
73570>>>        
73570>>>        For iColor from 0 to 15
73576>>>>
73576>>>            Set Custom_Color iColor to (Value(hoSourceColorDialog, iColor))
73577>>>        Loop
73578>>>>
73578>>>    End_Procedure
73579>>>    
73579>>>    Function Value Integer iItem Returns String
73581>>>        // Provides support for the AssignCustomColors procedure, which requires
73581>>>        // that a "Get Value" interface is supported
73581>>>        Function_Return (Custom_Color(Self, iItem))
73582>>>    End_Function
73583>>>    
73583>>>    Function OwnerHandle Returns Handle
73585>>>        Handle hWnd
73585>>>        Handle hoObj
73585>>>        Get Focus of desktop to hoObj // start with the focus
73586>>>        Move (gOwnerWindowHandle(hoObj)) to hWnd // global function finds the right handle for us
73587>>>        Function_Return hWnd
73588>>>    End_Function
73589>>>    
73589>>>    Function Show_Dialog Returns Boolean
73591>>>        //Shows the dialog. Returns True if the OK button was clicked.
73591>>>        Handle  hContainer hoCustomColors
73591>>>        Boolean bSelected bFullOpen bNoOpen bSelColor
73591>>>        Integer rgbColor iFlags iLoop
73591>>>        String sCC sColors
73591>>>        tWinChooseColor ChseColor
73591>>>        tWinChooseColor ChseColor
73591>>>        
73591>>>        Get OwnerHandle to hContainer
73592>>>        
73592>>>        Get phoCustomColors to hoCustomColors
73593>>>        
73593>>>        Move '' to sColors
73594>>>        For iLoop from 0 to 15
73600>>>>
73600>>>            Get Value of hoCustomColors iLoop to rgbColor
73601>>>            Move (sColors + DWORDToBytes(rgbColor)) to sColors
73602>>>        Loop
73603>>>>
73603>>>        
73603>>>        Get FullOpen_State        to bFullOpen
73604>>>        Get PreventFullOpen_State to bNoOpen
73605>>>        Get SelectedColor_State   to bSelColor
73606>>>        Get SelectedColor         to rgbColor
73607>>>        
73607>>>        Move 0 to iFlags
73608>>>        If bFullOpen ;            Move (iFlags +CC_FULLOPEN)        to iFlags
73611>>>        If bNoOpen ;            Move (iFlags +CC_PREVENTFULLOPEN) to iFlags
73614>>>        If bSelColor ;            Move (iFlags +CC_RGBINIT)         to iFlags
73617>>>        
73617>>>        Move (SizeOfType(tWinChooseColor))     to ChseColor.lStructSize
73618>>>        Move hContainer           to ChseColor.hWndOWner
73619>>>        Move rgbColor             to ChseColor.rgbResult
73620>>>        Move (AddressOf(sColors)) to ChseColor.lpCustColors
73621>>>        Move iFlags               to ChseColor.flags
73622>>>        
73622>>>        Move (ChooseColorW(AddressOf(ChseColor))) to bSelected
73623>>>        
73623>>>        If bSelected Begin
73625>>>            For iLoop from 0 to 15
73631>>>>
73631>>>                Move (DeRefDw(AddressOf(sColors), iLoop *4)) to rgbColor
73632>>>                Set Value of hoCustomColors iLoop to rgbColor
73633>>>            Loop
73634>>>>
73634>>>            Move ChseColor.rgbResult to rgbColor
73635>>>            Set SelectedColor to rgbColor
73636>>>        End
73636>>>>
73636>>>        Function_Return bSelected
73637>>>    End_Function
73638>>>    
73638>>>End_Class
73639>Use Cursor.pkg
73639>// Unmark this Define statement if using Mertech drivers!
73639>Define DUF_Use_Mertech_Drivers
73639>Use cDbUpdateHandler.pkg
Including file: cDbUpdateHandler.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateHandler.pkg)
73639>>>//****************************************************************************
73639>>>// $Module type: Class
73639>>>// $Module name: cDbUpdateHandler
73639>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
73639>>>// Web-site    : http://www.rdctools.com
73639>>>// Created     : 2016-09-27 @ 09:33 (Military date format: YY-MM-DD)
73639>>>//
73639>>>// Purpose     : A framework for doing automated code based updates of a database from within
73639>>>//               a program, when it is started.
73639>>>//
73639>>>// Description : Place _one_ object of this class right after the cApplication object.
73639>>>//               Then inside this object place a series of cDbUpdateVersion objects
73639>>>//               as childs. One child object for each new database update.
73639>>>//
73639>>>//               - OnPreUpdate is a pre-processing event called
73639>>>//               before any database changes are started.
73639>>>//               - OnPostUpdate is a post-processing event called after all
73639>>>//               database changes have taken place.
73639>>>//
73639>>>// Note        : If tables have been opened prior to an object of this class
73639>>>//               (e.g. in the cApplication object), those tables will be closed.
73639>>>//               In that case you need to use the OnPostUpdate hook event to re-open
73639>>>//               tables after the last update has finished.
73639>>>//
73639>>>// Security    : Before an update is attempted; three things are checked to ensure the
73639>>>//               database is not in use. Aka nobody else is running the application.
73639>>>//               - All tables are tested for "Open in Exclusive_Mode"
73639>>>//               - The DataFlex license User Count is checked - cannot be more than 1, unless the
73639>>>//                 pbCheckDataFlexUserCount is set to False (Default = True)
73639>>>//               - A special user count file ("DbUpdateUserCount.ucf") is created in the Programs
73639>>>//                 folder and a bit-lock is performed for each start of the application and this
73639>>>//                 user counter is checked before an update is attempted.
73639>>>//                 Important: Even if it seems like both garters & suspenders are used to guard
73639>>>//                            against the database being "in use", there is no such guarantee! The
73639>>>//                            database could e.g. be open in "Microsoft SQL Server Management Studio"
73639>>>//                            and there is no way of telling. SO BE CAUTIOUS before attempting an update!
73639>>>//                 A second "user count file" is also used - "DbUpdateLock.ucf". It is used to
73639>>>//                 lock everybody else out (with a Stop box) while the database is being updated. The lock will
73639>>>//                 automatically be released after the update is completed.
73639>>>//
73639>>>//
73639>>>// Usage       :  Use cDbUpdateHandler.pkg
73639>>>//                Object oDatabaseUpdateHandler is a cDbUpdateHandler
73639>>>//                    // Declare the table that contains a "database version" field.
73639>>>//                    Declare_Datafile Sys
73639>>>//                    // Either one of these syntaxes is fine:
73639>>>//                    Set Data_File_Field to File_Field Sys.DbUpdateVersion
73639>>>//                    Set Data_File_Field to (RefTable(Sys)) (RefTable(Sys.DbUpdateVersion))
73639>>>//
73639>>>//                    // Don't forget to increase the pnVersionNumber property for each
73639>>>//                    // cDbUpdateVersion object!
73639>>>//                    // The VersionTableColumn field/column specified above will be updated automatically
73639>>>//                    // with the value of pnVersionNumber after each update has been finished.
73639>>>//                    Object oVersionUpdate1.1 is a cDbUpdateVersion
73639>>>//                        Set pnVersionNumber to 1.1
73639>>>//                        Use VersionUpdate1_1.pkg
73639>>>//                    End_Object
73639>>>//
73639>>>//                    Object oVersionUpdate1.2 is a cDbUpdateVersion
73639>>>//                        Set pnVersionNumber to 1.2
73639>>>//                        Use VersionUpdate1_2.pkg
73639>>>//                    End_Object
73639>>>//
73639>>>//                End_Object
73639>>>//
73639>>>//
73639>>>// $Rev History:
73639>>>//    2016-09-27  Module header created
73639>>>//    2016-09-28  Removed the Master/Alias logic. All update code must
73639>>>//                take place before any tables have been opened, or errors
73639>>>//                could occur if the client database is out of sync with the
73639>>>//                compiled program.
73639>>>//                Added user counting checks + lockout while database is being
73639>>>//                updated.
73639>>>//    2016-10-03  Changed the class name from cDatabaseUpdateHandler to cDbUpdateHandler,
73639>>>//                as it is more in line with the child class cDbUpdateVersion name.
73639>>>//    2016-10-06  Moved constant declarations, structs etc. to separate cDbUpdateHandler.inc file
73639>>>//****************************************************************************
73639>>>Use VdfBase.pkg
73639>>>Use Dferror.pkg
73639>>>Use seq_chnl.pkg
73639>>>Use Datadict.pkg
73639>>>Use DUFLanguageConstants.inc
Including file: DUFLanguageConstants.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DUFLanguageConstants.inc)
73639>>>>>// *** The Database Update Framework Include file for Languages ***
73639>>>>>// Language constant declarations for all classes included in "DUF - The Database Update Framework"
73639>>>>>// They have all been placed in this central spot to make translations to various languages more convenient.
73639>>>>>//
73639>>>>>Use LanguageText.Pkg
73639>>>>>
73639>>>>>    // *** cSQLConnectionsIniFile.pkg Class Language Constants ***
73639>>>>>    Define CS_DUF_DuplicateConnectionIDPre  for "Cannot register connection ID"
73639>>>>>    Define CS_DUF_DuplicateConnectionIDPost for "This ID already exists."
73639>>>>>    // *** cSQLConnectionsHandler.pkg Class Language Constants ***
73639>>>>>    Define CS_DUF_SetupErrorcConnection     for "Cannot login to the database server as the cConnection hasn't been setup properly. Can't continue. Program will now exit."
73639>>>>>    Define CS_DUF_CannotLoginToServer       for "Could not login to the database server. Can't continue. Program will now exit."
73639>>>>>    Define CS_DUF_ErrorText                 for "\n\nError Text:"
73639>>>>>    // *** cDbUpdateFunctionLibrary.pkg Class Language Constants ***
73639>>>>>    Define CS_DUF_ConnectError              for "SQL error. Could not connect to the SQL database manager"
73639>>>>>    Define CS_DUF_AttachError               for "Could not attach to the database:"
73639>>>>>    Define CS_DUF_DeletingIndex             for "Deleting index"
73639>>>>>    Define CS_DUF_CopyingData               for "Copying data"
73639>>>>>    Define CS_DUF_CreatingIndex             for "Creating index"
73639>>>>>    Define CS_DUF_LoginToDbServerFailed     for  "Login failed to the database server. The following connect string was used:\n"
73639>>>>>    Define CS_DUF_DoYouWantToExit           for "Do you want to stop the database update and exit?"  
73639>>>>>    Define CS_DUF_NoIntFilesFound           for "No .int files found! Nothing was changed."
73639>>>>>    // *** cDbUpdateVersion.pkg Class Language Constants ***
73639>>>>>    Define CS_DUF_UpdateVersion             for "Updating database"
73639>>>>>    Define CS_DUF_UpdateFromVersion         for "from version"
73639>>>>>    Define CS_DUF_UpdateToVersion           for "to version:"
73639>>>>>    Define CS_DUF_DbUpdateTableMissing      for "Cannot open the 'DbVersion' table that is used when updating the database! Cannot continue!"
73639>>>>>    // *** cDbUpdateHandler.inc Language Constants ***
73639>>>>>    Define CS_DUF_DatabaseInUseShort        for "There are others using the application/database. Are you sure you still want to update the database?"
73639>>>>>    Define CS_DUF_DatabaseNeedsUpdate       for ("The database needs to be updated." + "\n\nATTENTION! The database may not be in use while this work is performed. Make sure that nobody else is using the application before clicking 'Yes' below.\n\n" + "Start update now?")
73639>>>>>    Define CS_DUF_HeaderUpdateText          for "Important!"
73639>>>>>    Define CS_DUF_DatabaseInUseText         for "There are others using the application/database or at least one table could NOT be opened exclusively. Please close all other applications using the database and try again. The Application will now close."
73639>>>>>    Define CS_DUF_WorkingHeaderText         for "Working!"
73639>>>>>    Define CS_DUF_WorkingUpdateText         for "The database is being updated. Please wait..."
73639>>>>>    Define CS_DUF_DatabaseUpdatedText       for "Ready! The database was updated."
73639>>>>>    Define CS_DUF_DatabaseCheckedText       for "Ready! The database was checked but no updates was needed."
73639>>>>>    Define CS_DUF_DbUpdatedErrorText        for "One or more errors occured while the database was updated. Please check the logfile.\n\nThe program will now close."
73639>>>>>    Define CS_DUF_UpdateInProgressTxt       for ("System locked!\n\nThe database is being updated. Please try again later...\n\n" * "The program will now close.")
73639>>>>>    // *** cDbUpdateHandler.pkg Class Language Constants ***
73639>>>>>    Define CS_DUF_DatabaseConnStringSpec    for "The database specified in the connection string: '"
73639>>>>>    Define CS_DUF_DatabaseDoesntExist       for "' doesn't exist!\n\nYou need to create it with a database management software or by using the 'SqlDatabaseCreate' function, which can be used in the 'OnPreUpdate' event of the cDbUpdateHandler object.\n\nThe program will now exit."
73639>>>>>    // *** cDbUpdateLogFile.pkg Class Language Constants ***   
73639>>>>>    Define CS_DUF_LogFileNotFound           for "Could not locate the log file:\n\n"
73639>>>>>
73639>>>>>
73639>>>>>
73639>>>>>
73639>>>>>
73639>>>>>
73639>>>>>
73639>>>>>
73639>>>>>
73639>>>>>
73639>>>>>
73639>>>>>
73639>>>Use DUFStatusPanel.pkg
Including file: DUFStatusPanel.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DUFStatusPanel.pkg)
73639>>>>>// StatPnl.pkg - creates the standard status_panel object.
73639>>>>>//
73639>>>>>//
73639>>>>>// This is the default Status Panel object used by any of the Visual DataFlex classes that
73639>>>>>// invoke the standard status panel. The standard has always been that the package name
73639>>>>>// is StatPnl.pkg and the name of the object is Status_Panel. As of 12.0, there are major
73639>>>>>// changes in the way the status panel operates The Sentinel based external status panel used in
73639>>>>>// prior revisions has been replace with status panel that is part of the application.
73639>>>>>// This should work much better and faster than the old sentinel based solution.
73639>>>>>// While the way this operates has changed, the interface has not and therefore this should work
73639>>>>>// with most applications.
73639>>>>>//
73639>>>>>// As of 12.0, we have added a global handle that contains the object ID of this status panel.
73639>>>>>// This variable ghoStatusPanel can be used in place of the object name Status_Panel. This provides
73639>>>>>// a cleaner more robust interface.
73639>>>>>//
73639>>>>>//
73639>>>>>// Compatibility Note:
73639>>>>>//
73639>>>>>// When used in the standard way, this change will require no changes. A developer will only need to
73639>>>>>// change their code if they've modified the sentinel program, which was a difficult thing to do.
73639>>>>>//
73639>>>>>// If for some reason you application will not work using this as a replacement for the old status
73639>>>>>// panel, you've probably done something special with the old status-panel. If you don't want to
73639>>>>>// figure out how to use the new one and you want to continue using the old one you are going to need
73639>>>>>// to add some code to include the old status panel in your application. Add the following to your project (your src).
73639>>>>>//
73639>>>>>// Use StatPnl.pkg    // Make sure you load the new status panel object first. this is not optional!
73639>>>>>// Use OldStatPnl.pkg // load the old status panel. Status_Panel is now this old object
73639>>>>>//
73639>>>>>// If you do this, you will lose access to the new status-panel via Status_Panel. However, you
73639>>>>>// can still access the new object via the ghoStatusPanel handle.
73639>>>>>//
73639>>>>>//
73639>>>>>// Creating your own Status Panel objects
73639>>>>>//
73639>>>>>// If a developer wishes to create a custom panel, they should use this package as their template.
73639>>>>>// This panel can be visually modeled and changed any way you wish. Just save your new custom panel
73639>>>>>// with a different file and object name and direct your status panel request to the new object.
73639>>>>>//
73639>>>>>// If the new panel changes the interface and updates objects that are not currently defined, you
73639>>>>>// want to make sure you send the message ProcessEvents after you've updated the object. This allows
73639>>>>>// the object to paint when inside of a tight loop. For example, if you wanted to add a progress
73639>>>>>// bar (cProgressBar) you would want to Send ProcessEvents after you update the progress bar.
73639>>>>>// e.g.
73639>>>>>//       Procedure UpdateStatusBar
73639>>>>>//           Send DoAdvance of oProgressBar
73639>>>>>//           Send ProcessEvents
73639>>>>>//       End_Procedure
73639>>>>>//
73639>>>>>// of course, if you use the standard interfaces in status bar and your forward send these
73639>>>>>// messages this will be done for you.
73639>>>>>//
73639>>>>>// the standard Interface for status panels are:
73639>>>>>//
73639>>>>>// Send Initialize_StatusPanel - initializes values for caption, title & message
73639>>>>>// Send Start_StatusPanel      - start the status panel
73639>>>>>// Send Stop_StatusPanel       - stop the status panel
73639>>>>>// Send Update_StatusPanel     - update the status panel's action area
73639>>>>>// Get  Check_StatusPanel      - check for cancel (if cancel or pbCancel is set, close the panel)
73639>>>>>//
73639>>>>>// Get/Set Caption_Text - updates the caption bar
73639>>>>>// Get/Set Title_Text   - updates the title area
73639>>>>>// Get/Set Message_Text - updates the Message area
73639>>>>>// Get/Set Action_Text  - updates the action area
73639>>>>>// Get/Set Button_Text  - updates the button area
73639>>>>>//
73639>>>>>// Get/Set Allow_cancel_state - determines if panel can be canceled
73639>>>>>// Send EnableCancelButton - code you should provide to enable/disable cancel button
73639>>>>>//
73639>>>>>// ghoStatusPanel - global handle that points to the standard status panel.
73639>>>>>Use cProcessStatusPanel.pkg
73639>>>>>Use cCJSkinFramework.pkg
Including file: cCJSkinFramework.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cCJSkinFramework.pkg)
73639>>>>>>>Use windows.pkg
73639>>>>>>>Use cCJComSkinFramework.pkg
Including file: cCJComSkinFramework.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cCJComSkinFramework.pkg)
73639>>>>>>>>>// DataFlex COM proxy classes generated from C:\Program Files (x86)\Codejock Software\ActiveX\Xtreme SuitePro ActiveX v20.0.0\Bin\Codejock.SkinFramework.Unicode.x64.v20.0.0.ocx
73639>>>>>>>>>Use FlexCom20.pkg
73639>>>>>>>>>
73639>>>>>>>>>// Changes to Imported package
73639>>>>>>>>>//     OLEXTPxx to XTPxx
73639>>>>>>>>>//     OLExtpxx to xtpxx
73639>>>>>>>>>//     OLESkinFramework to SkinFramework
73639>>>>>>>>>//     OLESTDxxx and OLEXPxxxx to STD/XP
73639>>>>>>>>>//     cCom classes to cCJ
73639>>>>>>>>>//     cCJAutomationObject back to cComAutomationObject
73639>>>>>>>>>//     cCJActiveXControl back to cComActiveXControl
73639>>>>>>>>>//     cCJSkinFramework to cCJComSkinFramework
73639>>>>>>>>>//     Use statements as noted below (classes moved to these files)
73639>>>>>>>>>//     Set classlibrary of all cComAutomation objects to Windows (for class doc)
73639>>>>>>>>>
73639>>>>>>>>>// These have been extracted from this class and moved into seperate packages
73639>>>>>>>>>// because other Codejock classes use these.
73639>>>>>>>>>Use cCJColorManager.pkg     // cCJColorManager
73639>>>>>>>>>
73639>>>>>>>>>
73639>>>>>>>>>Define SkinFrameworkApplyOptions for Integer
73639>>>>>>>>>    Define xtpSkinApplyMetrics for 1
73639>>>>>>>>>    Define xtpSkinApplyFrame for 2
73639>>>>>>>>>    Define xtpSkinApplyColors for 4
73639>>>>>>>>>    Define xtpSkinApplyMenus for 8
73639>>>>>>>>>
73639>>>>>>>>>// CLSID: {C0DE2000-28D7-4F2C-87A7-7266367B4655}
73639>>>>>>>>>// Dispatch interface for SkinFramework Control
73639>>>>>>>>>Class cCJ_DSkinFramework is a Mixin
73640>>>>>>>>>
73640>>>>>>>>>    Function ComApplyOptions Returns SkinFrameworkApplyOptions
73642>>>>>>>>>        SkinFrameworkApplyOptions retVal
73642>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to retVal
73643>>>>>>>>>        Function_Return retVal
73644>>>>>>>>>    End_Function
73645>>>>>>>>>
73645>>>>>>>>>    Procedure Set ComApplyOptions SkinFrameworkApplyOptions value
73647>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to value
73648>>>>>>>>>    End_Procedure
73649>>>>>>>>>
73649>>>>>>>>>    Function ComAutoApplyNewWindows Returns Boolean
73651>>>>>>>>>        Boolean retVal
73651>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to retVal
73652>>>>>>>>>        Function_Return retVal
73653>>>>>>>>>    End_Function
73654>>>>>>>>>
73654>>>>>>>>>    Procedure Set ComAutoApplyNewWindows Boolean value
73656>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to value
73657>>>>>>>>>    End_Procedure
73658>>>>>>>>>
73658>>>>>>>>>    Function ComAutoApplyNewThreads Returns Boolean
73660>>>>>>>>>        Boolean retVal
73660>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to retVal
73661>>>>>>>>>        Function_Return retVal
73662>>>>>>>>>    End_Function
73663>>>>>>>>>
73663>>>>>>>>>    Procedure Set ComAutoApplyNewThreads Boolean value
73665>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to value
73666>>>>>>>>>    End_Procedure
73667>>>>>>>>>
73667>>>>>>>>>    Function ComLoadSkin String llResourcePath String llIniFileName Returns Boolean
73669>>>>>>>>>        Handle hDispatchDriver
73669>>>>>>>>>        Boolean retVal
73669>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73670>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
73671>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
73672>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
73673>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_BOOL to retVal
73674>>>>>>>>>        Function_Return retVal
73675>>>>>>>>>    End_Function
73676>>>>>>>>>
73676>>>>>>>>>    Procedure ComApplyWindow OLE_HANDLE llhWnd
73678>>>>>>>>>        Handle hDispatchDriver
73678>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73679>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
73680>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
73681>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 3 OLE_VT_VOID
73682>>>>>>>>>    End_Procedure
73683>>>>>>>>>
73683>>>>>>>>>    Procedure ComEnableThemeDialogTexture OLE_HANDLE llhWnd Integer llFlags
73685>>>>>>>>>        Handle hDispatchDriver
73685>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73686>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
73687>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
73688>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llFlags
73689>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 4 OLE_VT_VOID
73690>>>>>>>>>    End_Procedure
73691>>>>>>>>>
73691>>>>>>>>>    Procedure ComRemoveWindow OLE_HANDLE llhWnd
73693>>>>>>>>>        Handle hDispatchDriver
73693>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73694>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
73695>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
73696>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 6 OLE_VT_VOID
73697>>>>>>>>>    End_Procedure
73698>>>>>>>>>
73698>>>>>>>>>    Procedure ComRemoveAllWindows
73700>>>>>>>>>        Handle hDispatchDriver
73700>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73701>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 7 OLE_VT_VOID
73702>>>>>>>>>    End_Procedure
73703>>>>>>>>>
73703>>>>>>>>>    Procedure ComAddWindowClass String llClassName String llBaseClassName
73705>>>>>>>>>        Handle hDispatchDriver
73705>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73706>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
73707>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
73708>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llBaseClassName
73709>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 8 OLE_VT_VOID
73710>>>>>>>>>    End_Procedure
73711>>>>>>>>>
73711>>>>>>>>>    Procedure ComRemoveWindowClass String llClassName
73713>>>>>>>>>        Handle hDispatchDriver
73713>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73714>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
73715>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
73716>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 9 OLE_VT_VOID
73717>>>>>>>>>    End_Procedure
73718>>>>>>>>>
73718>>>>>>>>>    Function ComEnumerateSkinDirectory String llPath Boolean llRecursive Returns Variant
73720>>>>>>>>>        Handle hDispatchDriver
73720>>>>>>>>>        Variant retVal
73720>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73721>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
73722>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
73723>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BOOL llRecursive
73724>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 11 OLE_VT_DISPATCH to retVal
73725>>>>>>>>>        Function_Return retVal
73726>>>>>>>>>    End_Function
73727>>>>>>>>>
73727>>>>>>>>>    Function ComEnumerateSkinFile String llPath Returns Variant
73729>>>>>>>>>        Handle hDispatchDriver
73729>>>>>>>>>        Variant retVal
73729>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73730>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
73731>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
73732>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 12 OLE_VT_DISPATCH to retVal
73733>>>>>>>>>        Function_Return retVal
73734>>>>>>>>>    End_Function
73735>>>>>>>>>
73735>>>>>>>>>    Function ComGetColor XTPColorManagerColor llIndex Returns OLE_COLOR
73737>>>>>>>>>        Handle hDispatchDriver
73737>>>>>>>>>        OLE_COLOR retVal
73737>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73738>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
73739>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
73740>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 14 OLE_VT_I4 to retVal
73741>>>>>>>>>        Function_Return retVal
73742>>>>>>>>>    End_Function
73743>>>>>>>>>
73743>>>>>>>>>    Procedure ComExcludeModule String llModuleName
73745>>>>>>>>>        Handle hDispatchDriver
73745>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73746>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
73747>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llModuleName
73748>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 15 OLE_VT_VOID
73749>>>>>>>>>    End_Procedure
73750>>>>>>>>>
73750>>>>>>>>>    Function ComCreateSchema String llResourcePath String llIniFileName Returns Variant
73752>>>>>>>>>        Handle hDispatchDriver
73752>>>>>>>>>        Variant retVal
73752>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73753>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
73754>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
73755>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
73756>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 16 OLE_VT_DISPATCH to retVal
73757>>>>>>>>>        Function_Return retVal
73758>>>>>>>>>    End_Function
73759>>>>>>>>>
73759>>>>>>>>>    Procedure ComSetWindowTheme OLE_HANDLE llhWnd Variant llSchema
73761>>>>>>>>>        Handle hDispatchDriver
73761>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73762>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
73763>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
73764>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llSchema
73765>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 17 OLE_VT_VOID
73766>>>>>>>>>    End_Procedure
73767>>>>>>>>>
73767>>>>>>>>>    Procedure ComAboutBox
73769>>>>>>>>>        Handle hDispatchDriver
73769>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73770>>>>>>>>>        Send InvokeComMethod to hDispatchDriver -552 OLE_VT_VOID
73771>>>>>>>>>    End_Procedure
73772>>>>>>>>>End_Class
73773>>>>>>>>>
73773>>>>>>>>>// CLSID: {C0DE2000-4463-4030-B324-AC6A8075FEC8}
73773>>>>>>>>>// Event interface for SkinFramework Control
73773>>>>>>>>>Class cCJ_DSkinFrameworkEvents is a Mixin
73774>>>>>>>>>
73774>>>>>>>>>    Procedure RegisterComEvents
73776>>>>>>>>>    End_Procedure
73777>>>>>>>>>End_Class
73778>>>>>>>>>
73778>>>>>>>>>// CoClass
73778>>>>>>>>>// ProgID: Codejock.SkinFramework.20.0.0
73778>>>>>>>>>// CLSID: {C0DE2000-2217-42EE-B1B0-82C890431F17}
73778>>>>>>>>>// SkinFramework Control
73778>>>>>>>>>Class cCJComSkinFramework is a cComActiveXControl
73779>>>>>>>>>    Import_Class_Protocol cCJ_DSkinFramework
73780>>>>>>>>>    Import_Class_Protocol cCJ_DSkinFrameworkEvents
73781>>>>>>>>>
73781>>>>>>>>>    Procedure Construct_Object
73783>>>>>>>>>        Forward Send Construct_Object
73785>>>>>>>>>        Set psProgID to "{C0DE2000-2217-42EE-B1B0-82C890431F17}"
73786>>>>>>>>>        Set psEventId to "{C0DE2000-4463-4030-B324-AC6A8075FEC8}"
73787>>>>>>>>>        Set psLicenseKey to ("Skin Framework Control Copyright (c) 1998-2021 Codejock Software"+ Character(13)+ Character(10)+;                             "PRODUCT-ID: Codejock.SkinFramework.ActiveX.v20.0"+ Character(13)+ Character(10)+;                             "VALIDATE-CODE: GGE-OLD-QQR-EJS")
73788>>>>>>>>>        Set peAutoCreate to acAutoCreate
73789>>>>>>>>>    End_Procedure
73790>>>>>>>>>End_Class
73791>>>>>>>>>
73791>>>>>>>>>// CLSID: {C0DE2000-CA9A-4AA9-8601-0AB7F551AA3D}
73791>>>>>>>>>// SkinFramework Global Settings
73791>>>>>>>>>Class cCJISkinFrameworkGlobalSettings is a Mixin
73792>>>>>>>>>
73792>>>>>>>>>    Function ComLicense Returns String
73794>>>>>>>>>        String retVal
73794>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to retVal
73795>>>>>>>>>        Function_Return retVal
73796>>>>>>>>>    End_Function
73797>>>>>>>>>
73797>>>>>>>>>    Procedure Set ComLicense String value
73799>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to value
73800>>>>>>>>>    End_Procedure
73801>>>>>>>>>
73801>>>>>>>>>    Function ComTitle Returns String
73803>>>>>>>>>        String retVal
73803>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to retVal
73804>>>>>>>>>        Function_Return retVal
73805>>>>>>>>>    End_Function
73806>>>>>>>>>
73806>>>>>>>>>    Procedure Set ComTitle String value
73808>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to value
73809>>>>>>>>>    End_Procedure
73810>>>>>>>>>
73810>>>>>>>>>    // Set this value to True to force using legacy SkinFramework core that has been in use up to version 19
73810>>>>>>>>>    Function ComUseLegacyCore Returns Boolean
73812>>>>>>>>>        Boolean retVal
73812>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 110 OLE_VT_BOOL to retVal
73813>>>>>>>>>        Function_Return retVal
73814>>>>>>>>>    End_Function
73815>>>>>>>>>
73815>>>>>>>>>    // Set this value to True to force using legacy SkinFramework core that has been in use up to version 19
73815>>>>>>>>>    Procedure Set ComUseLegacyCore Boolean value
73817>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 110 OLE_VT_BOOL to value
73818>>>>>>>>>    End_Procedure
73819>>>>>>>>>
73819>>>>>>>>>    Function ComVersion Returns String
73821>>>>>>>>>        Handle hDispatchDriver
73821>>>>>>>>>        String retVal
73821>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73822>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 104 OLE_VT_BSTR to retVal
73823>>>>>>>>>        Function_Return retVal
73824>>>>>>>>>    End_Function
73825>>>>>>>>>
73825>>>>>>>>>    Function ComUnicode Returns Boolean
73827>>>>>>>>>        Handle hDispatchDriver
73827>>>>>>>>>        Boolean retVal
73827>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73828>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 105 OLE_VT_BOOL to retVal
73829>>>>>>>>>        Function_Return retVal
73830>>>>>>>>>    End_Function
73831>>>>>>>>>
73831>>>>>>>>>    Function ComOcxPath Returns String
73833>>>>>>>>>        Handle hDispatchDriver
73833>>>>>>>>>        String retVal
73833>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73834>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 106 OLE_VT_BSTR to retVal
73835>>>>>>>>>        Function_Return retVal
73836>>>>>>>>>    End_Function
73837>>>>>>>>>End_Class
73838>>>>>>>>>
73838>>>>>>>>>// CoClass
73838>>>>>>>>>// ProgID: Codejock.SkinFrameworkGlobalSettings.20.0.0
73838>>>>>>>>>// CLSID: {C0DE2000-F744-4373-B38D-29CE83EF0EE5}
73838>>>>>>>>>// SkinFramework Global Settings
73838>>>>>>>>>Class cCJComSkinFrameworkGlobalSettings is a cComAutomationObject
73839>>>>>>>>>    Import_Class_Protocol cCJISkinFrameworkGlobalSettings
73840>>>>>>>>>
73840>>>>>>>>>    Procedure Construct_Object
73842>>>>>>>>>        Forward Send Construct_Object
73844>>>>>>>>>        Set psProgID to "{C0DE2000-F744-4373-B38D-29CE83EF0EE5}"
73845>>>>>>>>>        Set peAutoCreate to acNoAutoCreate
73846>>>>>>>>>    End_Procedure
73847>>>>>>>>>End_Class
73848>>>>>>>>>
73848>>>>>>>>>// CLSID: {C0DE2000-1038-498E-A936-361F08B4C4AA}
73848>>>>>>>>>Class cCJSkinIniFile is a cComAutomationObject
73849>>>>>>>>>
73849>>>>>>>>>    Function ComColorScheme Returns String
73851>>>>>>>>>        String retVal
73851>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
73852>>>>>>>>>        Function_Return retVal
73853>>>>>>>>>    End_Function
73854>>>>>>>>>
73854>>>>>>>>>    Procedure Set ComColorScheme String value
73856>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
73857>>>>>>>>>    End_Procedure
73858>>>>>>>>>
73858>>>>>>>>>    Function ComFontSize Returns String
73860>>>>>>>>>        String retVal
73860>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
73861>>>>>>>>>        Function_Return retVal
73862>>>>>>>>>    End_Function
73863>>>>>>>>>
73863>>>>>>>>>    Procedure Set ComFontSize String value
73865>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
73866>>>>>>>>>    End_Procedure
73867>>>>>>>>>
73867>>>>>>>>>    Function ComIniFileName Returns String
73869>>>>>>>>>        String retVal
73869>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to retVal
73870>>>>>>>>>        Function_Return retVal
73871>>>>>>>>>    End_Function
73872>>>>>>>>>
73872>>>>>>>>>    Procedure Set ComIniFileName String value
73874>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to value
73875>>>>>>>>>    End_Procedure
73876>>>>>>>>>End_Class
73877>>>>>>>>>
73877>>>>>>>>>// CLSID: {C0DE2000-4834-499E-95B4-30E0C3F43A10}
73877>>>>>>>>>Class cCJSkinDescription is a cComAutomationObject
73878>>>>>>>>>
73878>>>>>>>>>    Function ComName Returns String
73880>>>>>>>>>        String retVal
73880>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
73881>>>>>>>>>        Function_Return retVal
73882>>>>>>>>>    End_Function
73883>>>>>>>>>
73883>>>>>>>>>    Procedure Set ComName String value
73885>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
73886>>>>>>>>>    End_Procedure
73887>>>>>>>>>
73887>>>>>>>>>    Function ComPath Returns String
73889>>>>>>>>>        String retVal
73889>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
73890>>>>>>>>>        Function_Return retVal
73891>>>>>>>>>    End_Function
73892>>>>>>>>>
73892>>>>>>>>>    Procedure Set ComPath String value
73894>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
73895>>>>>>>>>    End_Procedure
73896>>>>>>>>>
73896>>>>>>>>>    Function ComCount Returns Integer
73898>>>>>>>>>        Handle hDispatchDriver
73898>>>>>>>>>        Integer retVal
73898>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73899>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
73900>>>>>>>>>        Function_Return retVal
73901>>>>>>>>>    End_Function
73902>>>>>>>>>
73902>>>>>>>>>    Function ComIniFile Integer llIndex Returns Variant
73904>>>>>>>>>        Handle hDispatchDriver
73904>>>>>>>>>        Variant retVal
73904>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73905>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
73906>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
73907>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
73908>>>>>>>>>        Function_Return retVal
73909>>>>>>>>>    End_Function
73910>>>>>>>>>
73910>>>>>>>>>    Function Com_NewEnum Returns Variant
73912>>>>>>>>>        Handle hDispatchDriver
73912>>>>>>>>>        Variant retVal
73912>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73913>>>>>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
73914>>>>>>>>>        Function_Return retVal
73915>>>>>>>>>    End_Function
73916>>>>>>>>>End_Class
73917>>>>>>>>>
73917>>>>>>>>>// CLSID: {C0DE2000-FB37-4B08-A2B9-F6F8B253D697}
73917>>>>>>>>>Class cCJSkinDescriptions is a cComAutomationObject
73918>>>>>>>>>
73918>>>>>>>>>    Function ComCount Returns Integer
73920>>>>>>>>>        Handle hDispatchDriver
73920>>>>>>>>>        Integer retVal
73920>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73921>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
73922>>>>>>>>>        Function_Return retVal
73923>>>>>>>>>    End_Function
73924>>>>>>>>>
73924>>>>>>>>>    Function ComSkin Integer llIndex Returns Variant
73926>>>>>>>>>        Handle hDispatchDriver
73926>>>>>>>>>        Variant retVal
73926>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73927>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
73928>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
73929>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
73930>>>>>>>>>        Function_Return retVal
73931>>>>>>>>>    End_Function
73932>>>>>>>>>
73932>>>>>>>>>    Function Com_NewEnum Returns Variant
73934>>>>>>>>>        Handle hDispatchDriver
73934>>>>>>>>>        Variant retVal
73934>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73935>>>>>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
73936>>>>>>>>>        Function_Return retVal
73937>>>>>>>>>    End_Function
73938>>>>>>>>>End_Class
73939>>>>>>>>>
73939>>>>>>>>>// CLSID: {C0DE2000-C56F-43C0-BCF1-8193B35FE4C4}
73939>>>>>>>>>Class cCJSkinSchema is a cComAutomationObject
73940>>>>>>>>>
73940>>>>>>>>>    Function ComGetColor XTPColorManagerColor llIndex Returns OLE_COLOR
73942>>>>>>>>>        Handle hDispatchDriver
73942>>>>>>>>>        OLE_COLOR retVal
73942>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
73943>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
73944>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
73945>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_I4 to retVal
73946>>>>>>>>>        Function_Return retVal
73947>>>>>>>>>    End_Function
73948>>>>>>>>>End_Class
73949>>>>>>>Use cApplication.pkg
73949>>>>>>>
73949>>>>>>>Struct tSkinInformation
73949>>>>>>>    String sName     // description of the skin
73949>>>>>>>    String sSkinfile // file path. Can be relative or full
73949>>>>>>>    String sSkinIni  // section name
73949>>>>>>>End_Struct
73949>>>>>>>
73949>>>>>>>
73949>>>>>>>Class cCJSkinFramework is a cCJComSkinFramework
73950>>>>>>>    
73950>>>>>>>    Procedure Construct_Object
73952>>>>>>>        Forward Send Construct_Object
73954>>>>>>>        
73954>>>>>>>        Property String psSkinFile ""
73955>>>>>>>        Property String psSkinIni ""
73956>>>>>>>        Property Boolean pbLoadPreference False
73957>>>>>>>        
73957>>>>>>>        Set peAutoCreate to acAutoCreate
73958>>>>>>>        
73958>>>>>>>        Move Self to ghoSkinFramework
73959>>>>>>>    End_Procedure
73960>>>>>>>    
73960>>>>>>>    // return the default skin path, which is the programs directory.
73960>>>>>>>    // This requires an application object.
73960>>>>>>>    // If you want to different skin path, override this.
73960>>>>>>>    Function SkinPath Returns String
73962>>>>>>>        String sPath sPaths
73962>>>>>>>        Handle hoWorkspace
73962>>>>>>>        If ghoApplication Begin
73964>>>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
73965>>>>>>>            Get psProgramPath of hoWorkspace to sPaths
73966>>>>>>>            Get PathAtIndex of hoWorkspace sPaths 1 to sPath
73967>>>>>>>        End
73967>>>>>>>>
73967>>>>>>>        Else Begin
73968>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
73969>>>>>>>>
73969>>>>>>>        End
73969>>>>>>>>
73969>>>>>>>        Function_Return sPath
73970>>>>>>>    End_Function
73971>>>>>>>    
73971>>>>>>>    // Returns the Qualified name of psSkinFile. If the file is already qualified it just
73971>>>>>>>    // returns itself. If it is not, it uses SkinPath to get the path.
73971>>>>>>>    Function SkinQFile Returns String
73973>>>>>>>        String sFile sPath sSep
73973>>>>>>>        Boolean bQualified
73973>>>>>>>        Get psSkinFile to sFile
73974>>>>>>>        If not (IsFileNameQualified(sFile)) Begin
73976>>>>>>>            Get SkinPath to sPath
73977>>>>>>>            Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
73978>>>>>>>            Move (sPath - sSep - sFile) to sFile
73979>>>>>>>        End
73979>>>>>>>>
73979>>>>>>>        Function_Return sFile
73980>>>>>>>    End_Function
73981>>>>>>>    
73981>>>>>>>    // defines the default VDF window class mapping.
73981>>>>>>>    Procedure OnAddVDFWindowClasses
73983>>>>>>>        Send ComAddWindowClass "DFlistbox"               "ListBox"
73984>>>>>>>        Send ComAddWindowClass "DFentry"                 "Edit"
73985>>>>>>>        Send ComAddWindowClass "DFtextbox"               "Edit"
73986>>>>>>>        Send ComAddWindowClass "DFRichEditCtrl"          "Edit"
73987>>>>>>>        Send ComAddWindowClass "DFcombobox"              "ComboBox"
73988>>>>>>>        Send ComAddWindowClass "DFformlist"              "Edit"
73989>>>>>>>        Send ComAddWindowClass "DFFormListHeader"        "SysHeader32"
73990>>>>>>>        Send ComAddWindowClass "DFbutton"                "Button"
73991>>>>>>>        Send ComAddWindowClass "HPromptBtn"              "Button"
73992>>>>>>>        Send ComAddWindowClass "Hspinbtn"                "msctls_updown32"
73993>>>>>>>        Send ComAddWindowClass "DFSysTabControl32"       "SysTabControl32"
73994>>>>>>>        Send ComAddWindowClass "DFMDIClient"             "MDIClient"
73995>>>>>>>        Send ComAddWindowClass "DFedit"                  "edit"
73996>>>>>>>        Send ComAddWindowClass "DFlistedit"              "edit"
73997>>>>>>>        Send ComAddWindowClass "DFscrollbar"             "scrollbar"
73998>>>>>>>        Send ComAddWindowClass "DFgroup"                 "Button"
73999>>>>>>>        Send ComAddWindowClass "DFComboGrid"             "ComboBox"
74000>>>>>>>        // External class
74000>>>>>>>        Send ComAddWindowClass "cVdfAnimation"           "SysAnimate32"
74001>>>>>>>        Send ComAddWindowClass "cVdfProgressBar"         "msctls_progress32"
74002>>>>>>>        Send ComAddWindowClass "cVdfStatusBar"           "msctls_statusbar32"
74003>>>>>>>        Send ComAddWindowClass "cVdfToolbar"             "ToolbarWindow32"
74004>>>>>>>        Send ComAddWindowClass "cObsoleteVdfProgressBar" "msctls_progress32"
74005>>>>>>>        Send ComAddWindowClass "cVdfTrackBar"            "msctls_trackbar32"
74006>>>>>>>        Send ComAddWindowClass "cObsoleteBasicStatusBar" "msctls_statusbar32"
74007>>>>>>>        Send ComAddWindowClass "cVdfTreeView"            "SysTreeView32"
74008>>>>>>>    End_Procedure
74009>>>>>>>    
74009>>>>>>>    // Used to support developer designed class mappings (e.g. COM controls)
74009>>>>>>>    Procedure OnAddCustomWindowClasses
74011>>>>>>>    End_Procedure
74012>>>>>>>    
74012>>>>>>>    // called when object is created during end_construct_object.
74012>>>>>>>    Procedure OnCreate
74014>>>>>>>        Integer iOpts
74014>>>>>>>        Boolean bUseWindowsFont
74014>>>>>>>        Forward Send OnCreate
74016>>>>>>>        
74016>>>>>>>        // if we are using the windows fonts we will disable the apply metrics which
74016>>>>>>>        // never really looked good anyway. This test only exists or legacy purposes
74016>>>>>>>        Get pbUseWindowsFont of Desktop to bUseWindowsFont
74017>>>>>>>        If bUseWindowsFont Begin
74019>>>>>>>            Get ComApplyOptions to iOpts
74020>>>>>>>            Set ComApplyOptions to (RemoveBitValue(xtpSkinApplyMetrics, iOpts))
74021>>>>>>>        End
74021>>>>>>>>
74021>>>>>>>        
74021>>>>>>>        // this works around a CJ issue where skins applied to other threads causes an exception upon close down.
74021>>>>>>>        // We saw this with our mssql driver but it could occur elsewhere. This has been reported in the CJ newsgroup
74021>>>>>>>        // and this was the suggested workaround.
74021>>>>>>>        Set ComAutoApplyNewThreads to False
74022>>>>>>>        
74022>>>>>>>        Send OnAddVDFWindowClasses
74023>>>>>>>        Send OnAddCustomWindowClasses
74024>>>>>>>        
74024>>>>>>>        // if preferences are used, it will set psSkinFile and psSkinIni
74024>>>>>>>        If (pbLoadPreference(Self)) Begin
74026>>>>>>>            Send LoadSkinPreference
74027>>>>>>>        End
74027>>>>>>>>
74027>>>>>>>        // if a skin file name exists, we apply the skin.
74027>>>>>>>        If (psSkinFile(Self)<>"") Begin
74029>>>>>>>            Send ApplySkin
74030>>>>>>>        End
74030>>>>>>>>
74030>>>>>>>    End_Procedure
74031>>>>>>>    
74031>>>>>>>    // called by framework as part of application exit.
74031>>>>>>>    Procedure Broadcast_Notify_Exit_Application
74033>>>>>>>        Send Notify_Exit_Application
74034>>>>>>>    End_Procedure
74035>>>>>>>    
74035>>>>>>>    Procedure Notify_Exit_Application
74037>>>>>>>        If (pbLoadPreference(Self)) Begin
74039>>>>>>>            Send SaveSkinPreference
74040>>>>>>>        End
74040>>>>>>>>
74040>>>>>>>    End_Procedure
74041>>>>>>>    
74041>>>>>>>    Procedure NotifyPreApplySkin
74043>>>>>>>        Broadcast Send OnPreApplySkin of Desktop True
74045>>>>>>>    End_Procedure
74046>>>>>>>    
74046>>>>>>>    Procedure NotifyPostApplySkin
74048>>>>>>>        Broadcast Send OnPostApplySkin of Desktop True
74050>>>>>>>    End_Procedure
74051>>>>>>>    
74051>>>>>>>    // returns an array of all skins in the path. If path is "", use the default path.
74051>>>>>>>    // If the default path is used, returns the file names as relative names, else use full path.
74051>>>>>>>    Function EnumerateSkins String sPath Boolean bRecursive Returns tSkinInformation[]
74053>>>>>>>        tSkinInformation[] Skins
74053>>>>>>>        tSkinInformation[] Skins
74054>>>>>>>        String sSkinName sSkinFile sDefaultPath sSep
74054>>>>>>>        Variant vSkinDescriptions vSkinDescription vSkinIniFile
74054>>>>>>>        Handle hSkinDescriptions hSkinDescription hSkinIniFile
74054>>>>>>>        Integer iSkinsCount iSkinFilesCount iNumSkins iNumSkinFiles iArrayItem
74054>>>>>>>        Integer iPos iDfltLen
74054>>>>>>>        Boolean bUseRelativePath
74054>>>>>>>        
74054>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
74055>>>>>>>        
74055>>>>>>>        Get SkinPath to sDefaultPath
74056>>>>>>>        If (sPath="") Begin
74058>>>>>>>            Move sDefaultPath to sPath
74059>>>>>>>        End
74059>>>>>>>>
74059>>>>>>>        Move (Uppercase(sDefaultPath)) to sDefaultPath
74060>>>>>>>        Move (Length(sDefaultPath)) to iDfltLen
74061>>>>>>>        Move (sDefaultPath=Uppercase(sPath)) to bUseRelativePath
74062>>>>>>>        
74062>>>>>>>        Get ComEnumerateSkinDirectory sPath bRecursive to vSkinDescriptions
74063>>>>>>>        If (not(IsNullComObject(vSkinDescriptions))) Begin
74065>>>>>>>            
74065>>>>>>>            Get Create U_cCJSkinDescriptions to hSkinDescriptions
74066>>>>>>>            Get Create U_cCJSkinDescription to hSkinDescription
74067>>>>>>>            Get Create U_cCJSkinIniFile to hSkinIniFile
74068>>>>>>>            
74068>>>>>>>            Set pvComObject of hSkinDescriptions to vSkinDescriptions
74069>>>>>>>            Get ComCount of hSkinDescriptions to iNumSkinFiles
74070>>>>>>>            
74070>>>>>>>            For iSkinFilesCount from 0 to (iNumSkinFiles-1)
74076>>>>>>>>
74076>>>>>>>                Get ComSkin of hSkinDescriptions iSkinFilesCount to vSkinDescription
74077>>>>>>>                Set pvComObject of hSkinDescription to vSkinDescription
74078>>>>>>>                
74078>>>>>>>                Get ComCount of hSkinDescription to iNumSkins
74079>>>>>>>                
74079>>>>>>>                For iSkinsCount from 0 to (iNumSkins-1)
74085>>>>>>>>
74085>>>>>>>                    Get ComIniFile of hSkinDescription iSkinsCount to vSkinIniFile
74086>>>>>>>                    Set pvComObject of hSkinIniFile to vSkinIniFile
74087>>>>>>>                    
74087>>>>>>>                    Get ComName of hSkinDescription to Skins[iArrayItem].sName
74088>>>>>>>                    Get ComPath of hSkinDescription to sSkinFile
74089>>>>>>>                    If bUseRelativePath Begin
74091>>>>>>>                        Move (pos(sDefaultPath,uppercase(sSkinFile))) to iPos
74092>>>>>>>                        If iPos Begin
74094>>>>>>>                            Move (Remove(sSkinFile,iPos,iDfltLen)) to sSkinFile
74095>>>>>>>                            While (Left(sSkinFile,1)=sSep)
74099>>>>>>>                                Move (Remove(sSkinFile,1,1)) to sSkinFile
74100>>>>>>>                            Loop
74101>>>>>>>>
74101>>>>>>>                        End
74101>>>>>>>>
74101>>>>>>>                    End
74101>>>>>>>>
74101>>>>>>>                    Move sSkinFile to Skins[iArrayItem].sSkinfile
74102>>>>>>>                    Get ComIniFileName of hSkinIniFile to Skins[iArrayItem].sSkinIni
74103>>>>>>>                    
74103>>>>>>>                    Increment iArrayItem
74104>>>>>>>                Loop
74105>>>>>>>>
74105>>>>>>>            Loop
74106>>>>>>>>
74106>>>>>>>            
74106>>>>>>>            Send Destroy of hSkinDescriptions
74107>>>>>>>            Send Destroy of hSkinDescription
74108>>>>>>>            Send Destroy of hSkinIniFile
74109>>>>>>>            
74109>>>>>>>        End
74109>>>>>>>>
74109>>>>>>>        Function_Return Skins
74110>>>>>>>    End_Function
74111>>>>>>>    
74111>>>>>>>    // Save the skin preference. This requires an application object.
74111>>>>>>>    // Only do this if the application object allows it.
74111>>>>>>>    // This is called during startup if pbLoadPreference is True
74111>>>>>>>    // Suitable for override
74111>>>>>>>    Procedure SaveSkinPreference
74113>>>>>>>        String sSkin sIni
74113>>>>>>>        If ghoApplication Begin
74115>>>>>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
74117>>>>>>>                Get psSkinFile to sSkin
74118>>>>>>>                Get psSkinIni to sIni
74119>>>>>>>                Send WriteString of ghoApplication "Preferences" "SkinFile" sSkin
74120>>>>>>>                Send WriteString of ghoApplication "Preferences" "SkinIni" sIni
74121>>>>>>>            End
74121>>>>>>>>
74121>>>>>>>        End
74121>>>>>>>>
74121>>>>>>>        Else Begin
74122>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
74123>>>>>>>>
74123>>>>>>>        End
74123>>>>>>>>
74123>>>>>>>    End_Procedure
74124>>>>>>>    
74124>>>>>>>    // Load the skin preference. This requires an application object.
74124>>>>>>>    // Only do this if the application object allows it.
74124>>>>>>>    // This is called during startup if pbLoadPreference is True
74124>>>>>>>    // Suitable for override
74124>>>>>>>    Procedure LoadSkinPreference
74126>>>>>>>        String sSkin sIni
74126>>>>>>>        Boolean bExists
74126>>>>>>>        If ghoApplication Begin
74128>>>>>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
74130>>>>>>>                Get ValueExists of ghoApplication "Preferences" "SkinFile" to bExists
74131>>>>>>>                If bExists Begin
74133>>>>>>>                    Get ReadString of ghoApplication "Preferences" "SkinFile" "" to sSkin
74134>>>>>>>                    Get ReadString of ghoApplication "Preferences" "SkinIni" "" to sIni
74135>>>>>>>                    Set psSkinFile to sSkin
74136>>>>>>>                    Set psSkinIni to sIni
74137>>>>>>>                End
74137>>>>>>>>
74137>>>>>>>            End
74137>>>>>>>>
74137>>>>>>>        End
74137>>>>>>>>
74137>>>>>>>        Else Begin
74138>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
74139>>>>>>>>
74139>>>>>>>        End
74139>>>>>>>>
74139>>>>>>>    End_Procedure
74140>>>>>>>    
74140>>>>>>>    // Can be called to apply the current skin.
74140>>>>>>>    Procedure ApplySkin
74142>>>>>>>        Boolean bOk
74142>>>>>>>        String sSkin sIni
74142>>>>>>>        If (IsComObjectCreated(Self)) Begin
74144>>>>>>>            Get SkinQFile to sSkin
74145>>>>>>>            Get psSkinIni to sIni
74146>>>>>>>            
74146>>>>>>>            Send NotifyPreApplySkin
74147>>>>>>>            // when skins are used we don't want to use built in Visual Styles
74147>>>>>>>            Send EnableVisualStyles of Desktop (sSkin="")
74148>>>>>>>            Get ComLoadSkin sSkin sIni to bOK
74149>>>>>>>            If (sSkin<>"" and not(bOk)) Begin
74151>>>>>>>                // if not ok, no skin was appied. Enable visual styles
74151>>>>>>>                Send EnableVisualStyles of Desktop True
74152>>>>>>>            End
74152>>>>>>>>
74152>>>>>>>            Send NotifyPostApplySkin
74153>>>>>>>        End
74153>>>>>>>>
74153>>>>>>>    End_Procedure
74154>>>>>>>    
74154>>>>>>>    
74154>>>>>>>End_Class
74155>>>>>Use cProgressBar.pkg
Including file: cProgressBar.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cProgressBar.pkg)
74155>>>>>>>Use Windows.pkg
74155>>>>>>>Use cWinControl.pkg
Including file: cWinControl.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cWinControl.pkg)
74155>>>>>>>>>Use Windows.pkg
74155>>>>>>>>>
74155>>>>>>>>>// Key State Masks for Mouse Messages
74155>>>>>>>>>
74155>>>>>>>>>Define MK_LBUTTON  for |CI$0001
74155>>>>>>>>>Define MK_RBUTTON  for |CI$0002
74155>>>>>>>>>Define MK_SHIFT    for |CI$0004
74155>>>>>>>>>Define MK_CONTROL  for |CI$0008
74155>>>>>>>>>Define MK_MBUTTON  for |CI$0010
74155>>>>>>>>>Define MK_XBUTTON1 for |CI$0020
74155>>>>>>>>>Define MK_XBUTTON2 for |CI$0040
74155>>>>>>>>>
74155>>>>>>>>>Enum_List // Mouse Key Flags
74155>>>>>>>>>    Define mkLeft    for MK_LBUTTON
74155>>>>>>>>>    Define mkMiddle  for MK_MBUTTON
74155>>>>>>>>>    Define mkRight   for MK_RBUTTON
74155>>>>>>>>>    Define mkX1      for MK_XBUTTON1
74155>>>>>>>>>    Define mkX2      for MK_XBUTTON2
74155>>>>>>>>>    Define mkShift   for MK_SHIFT
74155>>>>>>>>>    Define mkControl for MK_CONTROL
74155>>>>>>>>>End_Enum_List
74155>>>>>>>>>
74155>>>>>>>>>Enum_List // Mouse Buttons. Used in OnMouseXXX messages
74155>>>>>>>>>    Define mbLeft
74155>>>>>>>>>    Define mbMiddle
74155>>>>>>>>>    Define mbRight
74155>>>>>>>>>    Define mbX1
74155>>>>>>>>>    Define mbX2
74155>>>>>>>>>End_Enum_List
74155>>>>>>>>>
74155>>>>>>>>>Class cWinControl is a DfBaseControl
74156>>>>>>>>>    Procedure Construct_Object
74158>>>>>>>>>        Forward Send Construct_Object
74160>>>>>>>>>        Property Integer private_pbEnabled True
74161>>>>>>>>>        Property Integer private_pbVisible True
74162>>>>>>>>>    End_Procedure
74163>>>>>>>>>    
74163>>>>>>>>>    Procedure End_Construct_Object
74165>>>>>>>>>        Forward Send End_Construct_Object
74167>>>>>>>>>        
74167>>>>>>>>>        Set External_Message WM_LBUTTONDOWN   to msg_OnWmLButtonDown
74168>>>>>>>>>        Set External_Message WM_MBUTTONDOWN   to msg_OnWmMButtonDown
74169>>>>>>>>>        Set External_Message WM_RBUTTONDOWN   to msg_OnWmRButtonDown
74170>>>>>>>>>        Set External_Message WM_LBUTTONUP     to msg_OnWmLButtonUp
74171>>>>>>>>>        Set External_Message WM_MBUTTONUP     to msg_OnWmMButtonUp
74172>>>>>>>>>        Set External_Message WM_RBUTTONUP     to msg_OnWmRButtonUp
74173>>>>>>>>>        Set External_Message WM_LBUTTONDBLCLK to msg_OnWmLButtonDblClk
74174>>>>>>>>>        Set External_Message WM_MBUTTONDBLCLK to msg_OnWmMButtonDblClk
74175>>>>>>>>>        Set External_Message WM_RBUTTONDBLCLK to msg_OnWmRButtonDblClk
74176>>>>>>>>>        Set External_Message WM_MOUSEMOVE     to msg_OnWmMouseMove
74177>>>>>>>>>    End_Procedure
74178>>>>>>>>>    
74178>>>>>>>>>    Procedure Notify Longptr wParam Longptr lParam
74180>>>>>>>>>        //Intentionally cancelled
74180>>>>>>>>>    End_Procedure
74181>>>>>>>>>    
74181>>>>>>>>>    Procedure Command Longptr wParam Longptr lParam
74183>>>>>>>>>        //Intentionally cancelled
74183>>>>>>>>>    End_Procedure
74184>>>>>>>>>    
74184>>>>>>>>>    Procedure DoRecreateWindow
74186>>>>>>>>>        // Recreates the window
74186>>>>>>>>>        If (Window_Handle(Self)) Begin
74188>>>>>>>>>            // attempt to do this without disturbing the focus tree.
74188>>>>>>>>>            Send Page_delete // prior to 8.3 this was Send Page_Object 0
74189>>>>>>>>>            Send Page 1      //                       Send Page_Object 1
74190>>>>>>>>>        End
74190>>>>>>>>>>
74190>>>>>>>>>    End_Procedure
74191>>>>>>>>>    
74191>>>>>>>>>    Procedure DoUpdateWindow
74193>>>>>>>>>        // Forces windows to update the window by bypassing WM_PAINT
74193>>>>>>>>>        Handle hWnd
74193>>>>>>>>>        
74193>>>>>>>>>        Get Window_Handle to hWnd
74194>>>>>>>>>        If hWnd ;            Move (UpdateWindow(hWnd)) to hWnd
74197>>>>>>>>>    End_Procedure
74198>>>>>>>>>    
74198>>>>>>>>>    Procedure Page Integer iState
74200>>>>>>>>>        Set Window_Style to WS_DISABLED (private_pbEnabled(Self) =False)
74201>>>>>>>>>        Set Window_Style to WS_VISIBLE (private_pbVisible(Self))
74202>>>>>>>>>        Forward Send Page iState
74204>>>>>>>>>    End_Procedure
74205>>>>>>>>>    
74205>>>>>>>>>    Procedure OnWmLButtonUp Integer wParam Integer lParam
74207>>>>>>>>>        Integer x y eButton
74207>>>>>>>>>        
74207>>>>>>>>>        Move (Hi(lParam))  to y
74208>>>>>>>>>        Move (Low(lParam)) to x
74209>>>>>>>>>        
74209>>>>>>>>>        Send OnMouseUp mbLeft x y wParam
74210>>>>>>>>>    End_Procedure
74211>>>>>>>>>    
74211>>>>>>>>>    Procedure OnWmMButtonUp Integer wParam Integer lParam
74213>>>>>>>>>        Integer x y eButton
74213>>>>>>>>>        
74213>>>>>>>>>        Move (Hi(lParam))  to y
74214>>>>>>>>>        Move (Low(lParam)) to x
74215>>>>>>>>>        
74215>>>>>>>>>        Send OnMouseUp mbMiddle x y wParam
74216>>>>>>>>>    End_Procedure
74217>>>>>>>>>    
74217>>>>>>>>>    Procedure OnWmRButtonUp Integer wParam Integer lParam
74219>>>>>>>>>        Integer x y eButton
74219>>>>>>>>>        
74219>>>>>>>>>        Move (Hi(lParam))  to y
74220>>>>>>>>>        Move (Low(lParam)) to x
74221>>>>>>>>>        
74221>>>>>>>>>        Send OnMouseUp mbRight x y wParam
74222>>>>>>>>>    End_Procedure
74223>>>>>>>>>    
74223>>>>>>>>>    Procedure OnWmLButtonDown Integer wParam Integer lParam
74225>>>>>>>>>        Integer x y eButton fKeys
74225>>>>>>>>>        
74225>>>>>>>>>        Move (Hi(lParam))  to y
74226>>>>>>>>>        Move (Low(lParam)) to x
74227>>>>>>>>>        
74227>>>>>>>>>        Send OnMouseDown mbLeft x y wParam
74228>>>>>>>>>    End_Procedure
74229>>>>>>>>>    Procedure OnWmMButtonDown Integer wParam Integer lParam
74231>>>>>>>>>        Integer x y eButton
74231>>>>>>>>>        
74231>>>>>>>>>        Move (Hi(lParam))  to y
74232>>>>>>>>>        Move (Low(lParam)) to x
74233>>>>>>>>>        
74233>>>>>>>>>        Send OnMouseDown mbMiddle x y wParam
74234>>>>>>>>>    End_Procedure
74235>>>>>>>>>    Procedure OnWmRButtonDown Integer wParam Integer lParam
74237>>>>>>>>>        Integer x y eButton
74237>>>>>>>>>        
74237>>>>>>>>>        Move (Hi(lParam))  to y
74238>>>>>>>>>        Move (Low(lParam)) to x
74239>>>>>>>>>        
74239>>>>>>>>>        Send OnMouseDown mbRight x y wParam
74240>>>>>>>>>    End_Procedure
74241>>>>>>>>>    
74241>>>>>>>>>    Procedure OnWmLButtonDblClk Integer wParam Integer lParam
74243>>>>>>>>>        Integer x y eButton
74243>>>>>>>>>        
74243>>>>>>>>>        Move (Hi(lParam))  to y
74244>>>>>>>>>        Move (Low(lParam)) to x
74245>>>>>>>>>        
74245>>>>>>>>>        Send OnMouseDoubleClick mbLeft x y wParam
74246>>>>>>>>>    End_Procedure
74247>>>>>>>>>    Procedure OnWmMButtonDblClk Integer wParam Integer lParam
74249>>>>>>>>>        Integer x y eButton
74249>>>>>>>>>        
74249>>>>>>>>>        Move (Hi(lParam))  to y
74250>>>>>>>>>        Move (Low(lParam)) to x
74251>>>>>>>>>        
74251>>>>>>>>>        Send OnMouseDoubleClick mbMiddle x y wParam
74252>>>>>>>>>    End_Procedure
74253>>>>>>>>>    Procedure OnWmRButtonDblClk Integer wParam Integer lParam
74255>>>>>>>>>        Integer x y eButton
74255>>>>>>>>>        
74255>>>>>>>>>        Move (Hi(lParam))  to y
74256>>>>>>>>>        Move (Low(lParam)) to x
74257>>>>>>>>>        
74257>>>>>>>>>        Send OnMouseDoubleClick mbRight x y wParam
74258>>>>>>>>>    End_Procedure
74259>>>>>>>>>    
74259>>>>>>>>>    Procedure OnWmMouseMove Integer wParam Integer lParam
74261>>>>>>>>>        Integer x y eButton
74261>>>>>>>>>        
74261>>>>>>>>>        Move (Hi(lParam))  to y
74262>>>>>>>>>        Move (Low(lParam)) to x
74263>>>>>>>>>        
74263>>>>>>>>>        Send OnMouseMove x y wParam
74264>>>>>>>>>    End_Procedure
74265>>>>>>>>>    
74265>>>>>>>>>    Procedure OnMouseDown Integer eButton Integer x Integer y Integer fKeys
74267>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
74267>>>>>>>>>        //String sButton
74267>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
74267>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
74267>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
74267>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
74267>>>>>>>>>        
74267>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
74267>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
74267>>>>>>>>>        //Showln 'OnMouseDown ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
74267>>>>>>>>>    End_Procedure
74268>>>>>>>>>    
74268>>>>>>>>>    Procedure OnMouseUp Integer eButton Integer x Integer y Integer fKeys
74270>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
74270>>>>>>>>>        //String sButton
74270>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
74270>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
74270>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
74270>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
74270>>>>>>>>>        
74270>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
74270>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
74270>>>>>>>>>        //Showln 'OnMouseUp ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
74270>>>>>>>>>    End_Procedure
74271>>>>>>>>>    
74271>>>>>>>>>    Procedure OnMouseDoubleClick Integer eButton Integer x Integer y Integer fKeys
74273>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
74273>>>>>>>>>        //String sButton
74273>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
74273>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
74273>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
74273>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
74273>>>>>>>>>        
74273>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
74273>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
74273>>>>>>>>>        //Showln 'OnMouseDblClk ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
74273>>>>>>>>>    End_Procedure
74274>>>>>>>>>    
74274>>>>>>>>>    Procedure OnMouseMove Integer x Integer y Integer fKeys
74276>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
74276>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
74276>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
74276>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
74276>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
74276>>>>>>>>>        
74276>>>>>>>>>        //Showln 'OnMouseMove ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
74276>>>>>>>>>    End_Procedure
74277>>>>>>>>>    
74277>>>>>>>>>    Procedure Set pbEnabled Boolean bEnabled
74279>>>>>>>>>        Handle hWnd
74279>>>>>>>>>        
74279>>>>>>>>>        If (bEnabled <> private_pbEnabled(Self)) Begin
74281>>>>>>>>>            Set private_pbEnabled to bEnabled
74282>>>>>>>>>            Get Window_Handle to hWnd
74283>>>>>>>>>            If hWnd ;                Move (EnableWindow(hWnd, bEnabled)) to hWnd
74286>>>>>>>>>        End
74286>>>>>>>>>>
74286>>>>>>>>>    End_Procedure
74287>>>>>>>>>    Function pbEnabled Returns Boolean
74289>>>>>>>>>        Function_Return (private_pbEnabled(Self))
74290>>>>>>>>>    End_Function
74291>>>>>>>>>    
74291>>>>>>>>>    Procedure Set pbVisible Boolean bVisible
74293>>>>>>>>>        Handle  hWnd
74293>>>>>>>>>        Integer iVoid
74293>>>>>>>>>        
74293>>>>>>>>>        If (bVisible <> private_pbVisible(Self)) Begin
74295>>>>>>>>>            Set private_pbVisible to bVisible
74296>>>>>>>>>            Get Window_Handle to hWnd
74297>>>>>>>>>            If hWnd ;                Move (ShowWindow(hWnd, If (bVisible, SW_SHOWNA, SW_HIDE))) to iVoid
74300>>>>>>>>>        End
74300>>>>>>>>>>
74300>>>>>>>>>    End_Procedure
74301>>>>>>>>>    Function pbVisible Returns Boolean
74303>>>>>>>>>        Function_Return (private_pbVisible(Self))
74304>>>>>>>>>    End_Function
74305>>>>>>>>>    
74305>>>>>>>>>End_Class
74306>>>>>>>Use CommCtrl.pkg
74306>>>>>>>
74306>>>>>>>//{ OverrideProperty=pbEnabled DesignTime=False }
74306>>>>>>>Class cProgressBar is a cWinControl
74307>>>>>>>    
74307>>>>>>>    Procedure Construct_Object
74309>>>>>>>        Forward Send Construct_Object
74311>>>>>>>        Property Integer private_piMinimum
74312>>>>>>>        Property Integer private_piMaximum   100
74313>>>>>>>        Property Integer private_piAdvanceBy 10
74314>>>>>>>        Property Integer private_piPosition
74315>>>>>>>        Property Integer private_pbVertical  False
74316>>>>>>>        Property Integer private_pbSmooth    False
74317>>>>>>>        Property Integer private_piBackColor clDefault
74318>>>>>>>        Property Integer private_piBarColor  clDefault
74319>>>>>>>        
74319>>>>>>>        Send Define_ToolTip_Support_Mixin
74320>>>>>>>        
74320>>>>>>>        Set External_Class_Name 'cVdfProgressBar' to 'msctls_progress32'
74321>>>>>>>        Set Focus_Mode to NonFocusable
74322>>>>>>>        Set Skip_State to True
74323>>>>>>>        Set pbUseFormWindowHandle to False     // Must come after Define_ToolTip_Support_Mixin
74324>>>>>>>    End_Procedure
74325>>>>>>>    
74325>>>>>>>    Import_Class_Protocol ToolTip_Support_Mixin
74326>>>>>>>    
74326>>>>>>>    Procedure Set piMinimum Integer iMin
74328>>>>>>>        Integer iMax
74328>>>>>>>        
74328>>>>>>>        Set private_piMinimum to iMin
74329>>>>>>>        Get private_piMaximum to iMax
74330>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
74331>>>>>>>    End_Procedure
74332>>>>>>>    Function piMinimum Returns Integer
74334>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETRANGE, 1, 0))
74337>>>>>>>        Else;            Function_Return (private_piMinimum(Self))
74339>>>>>>>    End_Function
74340>>>>>>>    
74340>>>>>>>    Procedure Set piMaximum Integer iMax
74342>>>>>>>        Integer iMin
74342>>>>>>>        
74342>>>>>>>        Set private_piMaximum to iMax
74343>>>>>>>        Get private_piMinimum to iMin
74344>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
74345>>>>>>>    End_Procedure
74346>>>>>>>    Function piMaximum Returns Integer
74348>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETRANGE, 0, 0))
74351>>>>>>>        Else;            Function_Return (private_piMaximum(Self))
74353>>>>>>>    End_Function
74354>>>>>>>    
74354>>>>>>>    Procedure Set piAdvanceBy Integer iAdvanceBy
74356>>>>>>>        Set private_piAdvanceBy to iAdvanceBy
74357>>>>>>>        Send Windows_Message PBM_SETSTEP iAdvanceBy 0
74358>>>>>>>    End_Procedure
74359>>>>>>>    Function piAdvanceBy Returns Integer
74361>>>>>>>        Function_Return (private_piAdvanceBy(Self))
74362>>>>>>>    End_Function
74363>>>>>>>    
74363>>>>>>>    Procedure Set piPosition Integer iPos
74365>>>>>>>        Set private_piPosition to iPos
74366>>>>>>>        Send Windows_Message PBM_SETPOS iPos 0
74367>>>>>>>    End_Procedure
74368>>>>>>>    
74368>>>>>>>    Function piPosition Returns Integer
74370>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETPOS, 0, 0))
74373>>>>>>>        Else;            Function_Return (private_piPosition(Self))
74375>>>>>>>    End_Function
74376>>>>>>>    
74376>>>>>>>    Procedure Set pbVertical Boolean bVertical
74378>>>>>>>        If (private_pbVertical(Self) <> bVertical) Begin
74380>>>>>>>            Set private_pbVertical to bVertical
74381>>>>>>>            Send DoRecreateWindow
74382>>>>>>>        End
74382>>>>>>>>
74382>>>>>>>    End_Procedure
74383>>>>>>>    
74383>>>>>>>    Function pbVertical Returns Boolean
74385>>>>>>>        Function_Return (private_pbVertical(Self))
74386>>>>>>>    End_Function
74387>>>>>>>    
74387>>>>>>>    Procedure Set pbSmooth Boolean bSmooth
74389>>>>>>>        If (private_pbSmooth(Self) <> bSmooth) Begin
74391>>>>>>>            Set private_pbSmooth to bSmooth
74392>>>>>>>            Send DoRecreateWindow
74393>>>>>>>        End
74393>>>>>>>>
74393>>>>>>>    End_Procedure
74394>>>>>>>    Function pbSmooth Returns Boolean
74396>>>>>>>        Function_Return (private_pbSmooth(Self))
74397>>>>>>>    End_Function
74398>>>>>>>    
74398>>>>>>>    Procedure Set piBackColor Integer rgbColor
74400>>>>>>>        Set private_piBackColor to rgbColor
74401>>>>>>>        Send Windows_Message PBM_SETBKCOLOR 0 rgbColor
74402>>>>>>>    End_Procedure
74403>>>>>>>    Function piBackColor Returns Integer
74405>>>>>>>        Function_Return (private_piBackColor(Self))
74406>>>>>>>    End_Function
74407>>>>>>>    
74407>>>>>>>    Procedure Set piBarColor Integer rgbColor
74409>>>>>>>        Set private_piBarColor to rgbColor
74410>>>>>>>        Send Windows_Message PBM_SETBARCOLOR 0 rgbColor
74411>>>>>>>    End_Procedure
74412>>>>>>>    Function piBarColor Returns Integer
74414>>>>>>>        Function_Return (private_piBarColor(Self))
74415>>>>>>>    End_Function
74416>>>>>>>    
74416>>>>>>>    Procedure DoAdvance
74418>>>>>>>        Send Windows_Message PBM_STEPIT 0 0
74419>>>>>>>    End_Procedure
74420>>>>>>>    
74420>>>>>>>    Procedure DoAdvanceBy  Integer iAdvanceBy
74422>>>>>>>        Send Windows_Message PBM_DELTAPOS iAdvanceBy 0
74423>>>>>>>    End_Procedure
74424>>>>>>>    
74424>>>>>>>    Procedure private_DoInitWindow
74426>>>>>>>        Set piBarColor  to (private_piBarColor(Self))
74427>>>>>>>        Set piBackColor to (private_piBackColor(Self))
74428>>>>>>>        Set piAdvanceBy to (private_piAdvanceBy(Self))
74429>>>>>>>        Set piMinimum   to (private_piMinimum(Self))
74430>>>>>>>        Set piMaximum   to (private_piMaximum(Self))
74431>>>>>>>        Set piPosition  to (private_piPosition(Self))
74432>>>>>>>    End_Procedure
74433>>>>>>>    
74433>>>>>>>    Procedure Page_Object Integer iState
74435>>>>>>>        Handle hWnd
74435>>>>>>>        
74435>>>>>>>        Get Window_Handle to hWnd
74436>>>>>>>        If (hWnd=0 and iState) Begin
74438>>>>>>>            Set Window_Style to PBS_VERTICAL (private_pbVertical(Self))
74439>>>>>>>            Set Window_Style to PBS_SMOOTH   (private_pbSmooth(Self))
74440>>>>>>>            Forward Send Page_Object True
74442>>>>>>>        End
74442>>>>>>>>
74442>>>>>>>        Else ;            Forward Send Page_Object iState
74445>>>>>>>        
74445>>>>>>>        // Handle tooltip support....
74445>>>>>>>        If (iState = 0) Begin
74447>>>>>>>            Send RequestDeleteToolTip
74448>>>>>>>        End
74448>>>>>>>>
74448>>>>>>>        Else Begin
74449>>>>>>>            Send RequestAddToolTip
74450>>>>>>>        End
74450>>>>>>>>
74450>>>>>>>    End_Procedure
74451>>>>>>>    
74451>>>>>>>    Procedure Page Integer iState
74453>>>>>>>        Forward Send Page iState
74455>>>>>>>        If (iState =1);            Send private_DoInitWindow
74458>>>>>>>    End_Procedure
74459>>>>>>>    
74459>>>>>>>    // Called by Page_Object. Handles tooltip creation. We use a dedicated
74459>>>>>>>    // method to perform AddToolTip because it is often the case that Page_Object
74459>>>>>>>    // is implemented in a mixin class.
74459>>>>>>>    Procedure RequestAddToolTip
74461>>>>>>>        Send AddToolTip
74462>>>>>>>    End_Procedure
74463>>>>>>>    
74463>>>>>>>    
74463>>>>>>>    // Called by Page_Object. Handles tooltip removal.
74463>>>>>>>    Procedure RequestDeleteToolTip
74465>>>>>>>        Send DeleteToolTip
74466>>>>>>>    End_Procedure
74467>>>>>>>End_Class
74468>>>>>Use Windows.pkg
74468>>>>>Use DUFLanguageConstants.inc
74468>>>>>Use Statpnl.pkg
74468>>>>>
74468>>>>>
74468>>>>>    Global_Variable Handle ghoProgressBar // will contain the ID of the embedded progress bar.
74468>>>>>
74468>>>>>    Global_Variable Handle ghoProgressBarOverall // will contain the ID of the embedded progress bar with overall results
74468>>>>>
74468>>>>>Object Status_Panel is a cProcessStatusPanel
74470>>>>>    Set Size to 152 222
74471>>>>>    Set Border_Style to Border_Dialog
74472>>>>>    Set Icon to "Default.ico"
74473>>>>>    Move Self to ghoStatusPanel // this can be used throughout the applicaton to access this object
74474>>>>>
74474>>>>>    Property Boolean Cancel_Button_Visible_State True
74476>>>>>
74476>>>>>    Procedure Activate
74479>>>>>        Integer iSizeBefore
74479>>>>>        Get GuiSize to iSizeBefore
74480>>>>>        Forward Send Activate
74482>>>>>        Set GuiSize to (Hi(iSizeBefore)) (Low(iSizeBefore))
74483>>>>>    End_Procedure
74484>>>>>
74484>>>>>    Procedure End_Construct_Object
74487>>>>>        Forward Send End_Construct_Object
74489>>>>>        Set Label of oTitleTxt      to ""
74490>>>>>        Set Label of oTableNameTxt  to ""
74491>>>>>        Set Label of oMessageTxt    to ""
74492>>>>>        Set Label of oActionTxt     to ""
74493>>>>>    End_Procedure
74494>>>>>
74494>>>>>    Object oTitleTxt is a TextBox
74496>>>>>        Set Location to 5 21
74497>>>>>        Set Size to 8 179
74498>>>>>        Set Auto_Size_State to False
74499>>>>>        Set Justification_Mode  to jMode_Center
74500>>>>>        Set Label to "This is the Title Text"
74501>>>>>    End_Object
74502>>>>>
74502>>>>>    Object oTableNameTxt is a TextBox
74504>>>>>        Set Size to 19 204
74505>>>>>        Set Location to 18 9
74506>>>>>        Set Auto_Size_State to False
74507>>>>>        Set Justification_Mode to JMode_Left
74508>>>>>        Set Label to "This is the TableName Text"
74509>>>>>    End_Object
74510>>>>>
74510>>>>>    Object oMessageTxt is a TextBox
74512>>>>>        Set Location to 39 9
74513>>>>>        Set Size to 19 204
74514>>>>>        Set Auto_Size_State to False
74515>>>>>        Set Justification_Mode to JMode_Left
74516>>>>>        Set Label to "This is the Message text"
74517>>>>>    End_Object
74518>>>>>
74518>>>>>    Object oActionTxt is a TextBox
74520>>>>>        Set Size to 16 204
74521>>>>>        Set Location to 60 9
74522>>>>>        Set Auto_Size_State to False
74523>>>>>        Set Justification_Mode to JMode_Left
74524>>>>>        Set Label to "This is the Action Text"
74525>>>>>    End_Object
74526>>>>>
74526>>>>>    Object oStopButton is a Button
74528>>>>>        Set Location to 123 82
74529>>>>>        Set Label to C_$Cancel
74530>>>>>
74530>>>>>        Procedure OnClick 
74533>>>>>            Integer iRetval
74533>>>>>            Get YesNo_Box CS_DUF_DoYouWantToExit to iRetval
74534>>>>>            If (iRetval = MBR_Yes) Begin
74536>>>>>                Send Exit_Application
74537>>>>>            End
74537>>>>>>
74537>>>>>        End_Procedure
74538>>>>>
74538>>>>>    End_Object
74539>>>>>
74539>>>>>    Object oPercentage_tb is a TextBox
74541>>>>>        Set Location to 74 196
74542>>>>>        Set Size to 10 25
74543>>>>>//        Set Label to "% Done"
74543>>>>>    End_Object
74544>>>>>
74544>>>>>    Object oCopyRight is a TextBox
74546>>>>>        Set Location to 140 21
74547>>>>>        Set Size to 9 197
74548>>>>>        Set FontPointHeight to 8
74549>>>>>        Set Auto_Size_State to False
74550>>>>>        Set Justification_Mode  to jMode_Center
74551>>>>>        Set Label to "Copyright 2001-2020 RDC Tools International"
74552>>>>>    End_Object
74553>>>>>
74553>>>>>    Object oProgressBar is a cProgressBar
74555>>>>>        Set Size to 10 179
74556>>>>>        Set Location to 83 22
74557>>>>>        Set pbVisible to True // default
74558>>>>>        Move Self to ghoProgressBar // this can be used throughout your application to access the progress bar
74559>>>>>    End_Object
74560>>>>>
74560>>>>>    Procedure Set Progress_Bar_Visible_State Boolean bVisible
74563>>>>>        Set pbVisible of ghoProgressBar to bVisible
74564>>>>>    End_Procedure
74565>>>>>
74565>>>>>    Function Progress_Bar_Visible_State Returns Boolean
74568>>>>>        Boolean bVisible
74568>>>>>        Get pbVisible of ghoProgressBar to bVisible
74569>>>>>        Function_Return (bVisible)
74570>>>>>    End_Function
74571>>>>>
74571>>>>>    Object oProgressBarOverall is a cProgressBar
74573>>>>>        Set Size to 10 179
74574>>>>>        Set Location to 107 22
74575>>>>>        Set pbVisible to True // default
74576>>>>>        Move Self to ghoProgressBarOverall // this can be used throughout your application to access the progress bar
74577>>>>>    End_Object
74578>>>>>
74578>>>>>    Object oOverallProgress_tb is a TextBox
74580>>>>>        Set Size to 10 65
74581>>>>>        Set Location to 95 24
74582>>>>>        Set Label to "Overall Progress"
74583>>>>>    End_Object
74584>>>>>
74584>>>>>    Procedure Set Progress_Bar_Overall_Visible_State Boolean bVisible
74587>>>>>        Set pbVisible of ghoProgressBarOverall to bVisible
74588>>>>>    End_Procedure
74589>>>>>
74589>>>>>    Function Progress_Bar_Overall_Visible_State Returns Boolean
74592>>>>>        Boolean bVisible
74592>>>>>        Get pbVisible of ghoProgressBarOverall to bVisible
74593>>>>>        Function_Return (bVisible)
74594>>>>>    End_Function
74595>>>>>
74595>>>>>    // These messages bind the standard cProcessStatusPanel interface to the actual
74595>>>>>    // objects defined within this instance of the status panel.
74595>>>>>
74595>>>>>    // note: all of the messages that change text should be forwarded
74595>>>>>    // as the forwarded messages allows the panel to paint when in a tight loop
74595>>>>>
74595>>>>>    Procedure Set Message_Text String sText
74598>>>>>        Set Label of oMessageTxt to sText
74599>>>>>        Forward Set Message_Text to sText
74601>>>>>    End_Procedure
74602>>>>>
74602>>>>>    Function Message_Text Returns String
74605>>>>>        Function_Return (Label(oMessageTxt))
74606>>>>>    End_Function
74607>>>>>
74607>>>>>    Procedure Set Action_Text String sText
74610>>>>>        Set Label of oActionTxt to sText
74611>>>>>        Forward Set Action_Text to sText
74613>>>>>    End_Procedure
74614>>>>>
74614>>>>>    Function Action_Text Returns String
74617>>>>>        Function_Return (Label(oActionTxt))
74618>>>>>    End_Function
74619>>>>>
74619>>>>>    Procedure Set Button_Text String sText
74622>>>>>        Set Label of oStopButton to sText
74623>>>>>        Forward Set Button_Text to sText
74625>>>>>    End_Procedure
74626>>>>>
74626>>>>>    Function Button_Text Returns String
74629>>>>>        Function_Return (Label(oStopButton))
74630>>>>>    End_Function
74631>>>>>
74631>>>>>    Procedure Set Title_Text String sText
74634>>>>>        Set Label of oTitleTxt to sText
74635>>>>>        Forward Set Title_Text to sText
74637>>>>>    End_Procedure
74638>>>>>
74638>>>>>    Function Title_Text Returns String
74641>>>>>        Function_Return (Label(oTitleTxt))
74642>>>>>    End_Function
74643>>>>>
74643>>>>>    Procedure Set TableName_Text String sText
74646>>>>>        Set Label of oTableNameTxt to sText
74647>>>>>    End_Procedure
74648>>>>>
74648>>>>>    Function TableName_Text Returns String
74651>>>>>        Function_Return (Label(oTableNameTxt))
74652>>>>>    End_Function
74653>>>>>
74653>>>>>    Procedure Set License_Text String sText
74656>>>>>//        Set Label of oLicense_txt to sText
74656>>>>>    End_Procedure
74657>>>>>
74657>>>>>    // gets called when status panel is activated passing whether a button
74657>>>>>    // should appear
74657>>>>>    Procedure EnableCancelButton Boolean bEnable
74660>>>>>        Boolean bVisible
74660>>>>>        Get Cancel_Button_Visible_State to bVisible
74661>>>>>        If (bEnable = False) Begin
74663>>>>>            Set Visible_State of oStopButton to bVisible
74664>>>>>        End
74664>>>>>>
74664>>>>>        Set Enabled_State of oStopButton to bEnable
74665>>>>>    End_Procedure
74666>>>>>
74666>>>>>    Procedure Reset_StatusPanel
74669>>>>>        Set Allow_Cancel_State of ghoStatusPanel to True
74670>>>>>        Set Cancel_Button_Visible_State of ghoStatusPanel to True
74671>>>>>        Set Progress_Bar_Visible_State  of ghoStatusPanel to True
74672>>>>>        Set Progress_Bar_Overall_Visible_State of ghoProgressBarOverall to False
74673>>>>>    End_Procedure
74674>>>>>
74674>>>>>//    Object oProgressBar is a cProgressBar
74674>>>>>//        Move Self to ghoProgressBar
74674>>>>>//        Set Location to 1 25
74674>>>>>//        Set Size to 9 173
74674>>>>>//        Set piMinimum        to 0
74674>>>>>//        Set piMaximum        to 2000
74674>>>>>//        Set piAdvanceBy      to 100
74674>>>>>//        Set pbSmooth to True
74674>>>>>//
74674>>>>>//        // For some weird reason the application skin makes the coloring of the progressbar
74674>>>>>//        // to malfunction. By telling the CodeJock SkinFramework to skip this object, the
74674>>>>>//        // color will show correctly.
74674>>>>>//        Procedure Page Integer iPageObject
74674>>>>>//            Handle hWin
74674>>>>>//            Forward Send Page iPageObject
74674>>>>>//            If (ghoSkinFramework <> 0) Begin
74674>>>>>//                Get Window_Handle to hWin
74674>>>>>//                Send ComRemoveWindow of ghoSkinFramework hWin
74674>>>>>//            End
74674>>>>>//        End_Procedure
74674>>>>>//    End_Object
74674>>>>>
74674>>>>>End_Object
74675>>>>>
74675>>>Use cDbUpdateHandler.inc // Contains cDbUpdateHandler class constants, structs etc.
Including file: cDbUpdateHandler.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateHandler.inc)
74675>>>>>// Constant declarations, structs etc. for the cDbUdpateHandler class.
74675>>>>>//
74675>>>>>Use VdfBase.pkg
74675>>>>>Use cApplication.pkg
74675>>>>>Use seq_chnl.pkg
74675>>>>>Use vWin32fh.pkg
Including file: vWin32fh.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh\vWin32fh.pkg)
74675>>>>>>>// This code is part of VDF GUIdance
74675>>>>>>>// Visit us @ http://www.vdf-guidance.com
74675>>>>>>>// e-Mail us @ info@vdf-guidance.com
74675>>>>>>>// VDF GUIdance is a mutual project of
74675>>>>>>>// Frank Vandervelpen - Vandervelpen Systems and
74675>>>>>>>// Wil van Antwerpen  - Antwise Solutions
74675>>>>>>>// All software source code should be used <<AS IS>> without any warranty.
74675>>>>>>>//
74675>>>>>>>//
74675>>>>>>>// *** Windows 32bit file handling wrapper class ***
74675>>>>>>>//
74675>>>>>>>
74675>>>>>>>// 05-09-2000 **WvA: Changed namingconvention of all classes and methods to new standard
74675>>>>>>>//                   This may be painfull for some of you, but it was really needed as it was
74675>>>>>>>//                   getting messy. The "vs" -prefix we used before was confusing and could
74675>>>>>>>//                   unintentionally have been interpreted as "Vdf-GUIdance String".
74675>>>>>>>//
74675>>>>>>>// The used naming-convention is:
74675>>>>>>>//     - a prefix of "vWin32_" for every external function declaration
74675>>>>>>>//     - a prefix of the letter "v" for the full API name for the vdf-wrapper function.
74675>>>>>>>//
74675>>>>>>>// By using this we are guarding ourselves for conflicts with variable declarations
74675>>>>>>>// of DataAccess in the future.
74675>>>>>>>// Or at least almost as the letter "v" is now also synonym for variant (duh~!)
74675>>>>>>>//
74675>>>>>>>// mm-dd-yyyy Author Description
74675>>>>>>>//
74675>>>>>>>//                   vSHGetFolderPath added to retrieve the new shell folders
74675>>>>>>>//                   vGetWindowsDirectory
74675>>>>>>>//
74675>>>>>>>//                   vGetTempFileName
74675>>>>>>>//                   vGetTempPath
74675>>>>>>>// 11-17-2001 **WvA: Removed User Interface Error popups such as Error handling.
74675>>>>>>>//                   This is an absolute need for WebApp. We expect you to handle the
74675>>>>>>>//                   error in your application anyways. Changed this for:
74675>>>>>>>//                   vDeleteFile, vCopyFile, vMoveFile and vRenameFile
74675>>>>>>>// 03-02-2002 **WvA: vRemoveDirectory added
74675>>>>>>>// 03-11-2002 **WvA: The parameter lpdword in the external function declaration for
74675>>>>>>>//                   vWin32_SHBrowsForFolder can cause compiler errors.
74675>>>>>>>//                   It is renamed too avoid this.
74675>>>>>>>// 11-11-2002 **WvA: Codecleanup, vcSelectFile_Dialog is now cvSelectFile_Dialog, its
74675>>>>>>>//                   function vSelectedFileName is now just SelectedFileName
74675>>>>>>>//                   Removed the local keyword in the variable declarations
74675>>>>>>>// 10-17-2003 **WvA: Cleaned up function vSelect_File and added code to destroy the dynamically
74675>>>>>>>//                   created file-open dialog
74675>>>>>>>// 02-12-2004 **WvA: Allan Ankerstjeme pointed me into a bug for the vCreateTempFileInPath
74675>>>>>>>//                   in that it didn't exactly return the correct filename of the file created.
74675>>>>>>>//                   This has now been taken care of.
74675>>>>>>>// 02-19-2004 **WvA: Removed all API declarations from the package itself to improve readability
74675>>>>>>>//                   These declarations are now included from the vWin32fh header file.
74675>>>>>>>// 02-19-2004 **WvA: Changed the default way in which the standard file handling works
74675>>>>>>>//                   Before today one could always undo the operation, as of now you cannot as
74675>>>>>>>//                   the default was a silly one using unnecessary resources (mainly diskspace)
74675>>>>>>>//                   Since i don't really expect someone to use that feature it has been removed.
74675>>>>>>>//                   One can however restore to the old way of handling by simply calling the
74675>>>>>>>//                   vWin32fhCompatibilityMode procedure ONE time before accessing any of the
74675>>>>>>>//                   filehandling operations
74675>>>>>>>// 02-19-2004 **WvA: The functions ParseFolderName, ParseFileName and ParseFileExtenstion added
74675>>>>>>>//                   as well as the StringFromRightOfChar function.
74675>>>>>>>// 02-19-2004 **WvA: sfoFormatDisk function added which can use to format a floppydisk
74675>>>>>>>//                   DISABLED now as testing shows that it does not work as advertised...
74675>>>>>>>// 02-20-2004 **WvA: The function vDDE_Error_Handler didn't pass the errornumber on to the DDE_Error_To_String function
74675>>>>>>>//                   Moved the hardcoded strings from vDDE_Error_Handler to define declarations for easier translation later on.
74675>>>>>>>// 09-10-2004 **WvA: Added the ToAnsi function to the fileoperations method so that
74675>>>>>>>//                   extended characters are treated ok too.
74675>>>>>>>//                   Reported by Flemming from
74675>>>>>>>// 12-17-2004 **WvA: Changed vFilePathExists to be global, reported by Peter van Mil
74675>>>>>>>// 12-28-2004 **WvA: WebApp compatibility added by introducing compiler directives
74675>>>>>>>// 03-10-2006 **WvA: Added more CSIDL types to our header file for use with the vSHGetFolderPath function
74675>>>>>>>// 01-02-2007 **WvA: Set NoChangeDir_State on vSelect_File and vSelectSaveFile to True but changed it back due to side effects.
74675>>>>>>>//                   Added vSelectSavefile function to create a file save dialog
74675>>>>>>>//                   Fixed ParseFolderName which was horribly broken (thanks for the reports)
74675>>>>>>>//                   Added vParentPath function to retrieve the parent "node" of a path
74675>>>>>>>// 01-04-2008 **WvA: Fixed vCreateTempFileInPath as the function wasn't working
74675>>>>>>>// 10-04-2009 **WvA: Added vshCreateDirectoryEx from Micheal Mullan, moved filedialogs to cvFileDialogs.pkg
74675>>>>>>>// 01-11-2010 **WvA: Added vWin32_APIFilesize as supplied by Renato Villa, to get the filesize of the specified file. See http://support.dataaccess.com/forums/showthread.php?t=41982
74675>>>>>>>// 10-02-2011 **WvA: Added vCSIDL_SYSTEMX86, courtesy of Ola Eldoy for pointing this out and providing the define statement.
74675>>>>>>>// 20-12-2012 **WvA: Default behavior on copy/move is now to autocreate subfolders, tip by Frank Cheng
74675>>>>>>>// 29-09-2014 **WvA: Added function vFolderFileCount to count the number of files in a folder, add vCSIDL_PROGRAM_FILESx86
74675>>>>>>>// 04-10-2014 **WvA: Added extra checks on vFilePathExists and vFolderExists courtesy of Nils Svedmyr
74675>>>>>>>
74675>>>>>>>Use File_Dlg.pkg      // Contains OpenDialog class definition
74675>>>>>>>Use cvFileDialogs.pkg
Including file: cvFileDialogs.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh\cvFileDialogs.pkg)
74675>>>>>>>>>//***************************************************************************
74675>>>>>>>>>//*
74675>>>>>>>>>//* Class:        cvSaveAsDialog
74675>>>>>>>>>//* Package Name: cvFileDialogs.pkg
74675>>>>>>>>>//*
74675>>>>>>>>>//***************************************************************************
74675>>>>>>>>>
74675>>>>>>>>>Use File_dlg.pkg
74675>>>>>>>>>
74675>>>>>>>>>// *WvA: 13-01-1999 Created
74675>>>>>>>>>// The Class cSelectFile_Dialog is created to support the function Select_File
74675>>>>>>>>>// This function opens the Windows standard file open dialog and returns the selected
74675>>>>>>>>>// file_name.
74675>>>>>>>>>Class cvSelectFile_Dialog is an OpenDialog
74676>>>>>>>>>
74676>>>>>>>>>    Procedure Construct_Object Integer iImage_Id
74678>>>>>>>>>        Forward Send Construct_Object iImage_Id
74680>>>>>>>>>        Set HideReadOnly_State to True
74681>>>>>>>>>    End_Procedure
74682>>>>>>>>>
74682>>>>>>>>>    Function SelectedFileName Returns String
74684>>>>>>>>>        String sFileName
74684>>>>>>>>>        Move "" to sFileName
74685>>>>>>>>>        If (Show_Dialog(Self)) Begin
74687>>>>>>>>>            Move (RTrim(File_Name(Self))) to sFileName
74688>>>>>>>>>        End
74688>>>>>>>>>>
74688>>>>>>>>>        Function_Return sFileName
74689>>>>>>>>>    End_Function
74690>>>>>>>>>End_Class
74691>>>>>>>>>
74691>>>>>>>>>// *WvA: 13-01-1999 Created
74691>>>>>>>>>// This function opens the Windows standard file open dialog and returns the selected
74691>>>>>>>>>// file_name. Returns '' if the user didn't make a selection.
74691>>>>>>>>>// **WvA: 17-10-2003 Cleaned up and added code to destroy the dynamically created
74691>>>>>>>>>//                   file-open dialog
74691>>>>>>>>>Function vSelect_File Global String sSupportedFileTypes String sCaptionText String sInitialFolder Returns String
74693>>>>>>>>>    String sSelectedFile
74693>>>>>>>>>    Integer hoOpenFileDialog
74693>>>>>>>>>
74693>>>>>>>>>    Object oOpenFileDialog is a cvSelectFile_Dialog
74695>>>>>>>>>
74695>>>>>>>>>        Set Dialog_Caption    to sCaptionText
74696>>>>>>>>>        Set Filter_String     to sSupportedFileTypes
74697>>>>>>>>>        Set Initial_Folder    to sInitialFolder
74698>>>>>>>>>
74698>>>>>>>>>        Move Self       to hoOpenFileDialog
74699>>>>>>>>>    End_Object
74700>>>>>>>>>
74700>>>>>>>>>    Get SelectedFileName of hoOpenFileDialog to sSelectedFile
74701>>>>>>>>>    Send Destroy_Object to hoOpenFileDialog
74702>>>>>>>>>    Function_Return sSelectedFile
74703>>>>>>>>>End_Function
74704>>>>>>>>>
74704>>>>>>>>>Class cvSaveAsDialog is a SaveAsDialog
74705>>>>>>>>>
74705>>>>>>>>>    Procedure Construct_Object
74707>>>>>>>>>        Forward Send Construct_Object
74709>>>>>>>>>        Set HideReadOnly_State to True
74710>>>>>>>>>    End_Procedure
74711>>>>>>>>>
74711>>>>>>>>>    Function SelectedFileName Returns String
74713>>>>>>>>>        String sFileName
74713>>>>>>>>>        Move "" to sFileName
74714>>>>>>>>>        If (Show_Dialog(Self)) Begin
74716>>>>>>>>>            Move (RTrim(File_Name(Self))) to sFileName
74717>>>>>>>>>        End
74717>>>>>>>>>>
74717>>>>>>>>>        Function_Return sFileName
74718>>>>>>>>>    End_Function
74719>>>>>>>>>
74719>>>>>>>>>End_Class
74720>>>>>>>>>
74720>>>>>>>>>// Added optional default filename as suggested by Nils
74720>>>>>>>>>Function vSelectSaveFile Global String sSupportedFileTypes String sCaptionText String sInitialFolder String sDefaultFileName Returns String
74722>>>>>>>>>    String sSelectedFile
74722>>>>>>>>>    Integer hoDialog
74722>>>>>>>>>
74722>>>>>>>>>    Move "" to sSelectedFile
74723>>>>>>>>>    Get Create (RefClass(cvSaveAsDialog)) to hoDialog
74724>>>>>>>>>    If (hoDialog) Begin
74726>>>>>>>>>    //Set NoChangeDir_State Of hoDialog To True
74726>>>>>>>>>        Set Dialog_Caption    of hoDialog to sCaptionText
74727>>>>>>>>>        Set Filter_String     of hoDialog to sSupportedFileTypes
74728>>>>>>>>>        Set Initial_Folder    of hoDialog to sInitialFolder
74729>>>>>>>>>        If (Num_Arguments = 4) Begin
74731>>>>>>>>>            Set File_Title        of hoDialog to sDefaultFileName
74732>>>>>>>>>        End
74732>>>>>>>>>>
74732>>>>>>>>>        Get SelectedFileName  of hoDialog to sSelectedFile
74733>>>>>>>>>        Send Destroy of hoDialog
74734>>>>>>>>>    End
74734>>>>>>>>>>
74734>>>>>>>>>    Function_Return sSelectedFile
74735>>>>>>>>>End_Function
74736>>>>>>>Use Seq_chnl.pkg
74736>>>>>>>
74736>>>>>>>Use windows.pkg
74736>>>>>>>Use Dll.pkg
74736>>>>>>>Use vWin32fh.h       // Header file with WinAPI declarations
Including file: vwin32fh.h    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh\vwin32fh.h)
74736>>>>>>>>>//TH-Header
74736>>>>>>>>>//*****************************************************************************************
74736>>>>>>>>>// Copyright (c)  2004 KURANT Project
74736>>>>>>>>>// All rights reserved.
74736>>>>>>>>>//
74736>>>>>>>>>// $FileName    : G:\Projects\vWin32fh\vWin32fh.h
74736>>>>>>>>>// $ProjectName : Windows 32 bits file handling
74736>>>>>>>>>// $Authors     : Wil van Antwerpen
74736>>>>>>>>>// $Created     : 19.02.2004  19:25
74736>>>>>>>>>// $Type        : BSD (as in do with it whatever you like)
74736>>>>>>>>>//
74736>>>>>>>>>// Contents:
74736>>>>>>>>>//  This file contains the Windows API external function call definitions and
74736>>>>>>>>>//  constants as they are used in the vWin32fh package.
74736>>>>>>>>>//*****************************************************************************************
74736>>>>>>>>>//TH-RevisionStart
74736>>>>>>>>>//TH-RevisionEnd
74736>>>>>>>>>
74736>>>>>>>>>Define CS_DDE_ERR_FILE_NOT_FOUND  For "The specified file was not found.\n"
74736>>>>>>>>>Define CS_DDE_ERR_PATH_NOT_FOUND  For "The specified path was not found.\n"
74736>>>>>>>>>Define CS_DDE_ERR_BAD_FORMAT      For "The .EXE file is invalid.\n"
74736>>>>>>>>>Define CS_DDE_ERR_ACCESSDENIED    For "The operating system denied access to the specified file.\n"
74736>>>>>>>>>Define CS_DDE_ERR_ASSOCINCOMPLETE For "The filename association is incomplete or invalid.\n"
74736>>>>>>>>>Define CS_DDE_ERR_DDEBUSY         For "The DDE transaction could not be completed because other DDE\ntransactions were being processed.\n"
74736>>>>>>>>>Define CS_DDE_ERR_DDEFAIL         For "The DDE transaction failed.\n"
74736>>>>>>>>>Define CS_DDE_ERR_DDETIMEOUT      For "The DDE transaction could not be completed,\nbecause the request timed out.\n"
74736>>>>>>>>>Define CS_DDE_ERR_DLLNOTFOUND     For "The specified dynamic-link library was not found.\n"
74736>>>>>>>>>Define CS_DDE_ERR_NOASSOC         For "There is no application associated with the given filename extension.\n"
74736>>>>>>>>>Define CS_DDE_ERR_OOM             For "There is not enough free memory available to complete the operation.\n"
74736>>>>>>>>>Define CS_DDE_ERR_PNF             For "The specified path was not found.\n"
74736>>>>>>>>>Define CS_DDE_ERR_SHARE           For "A sharing violation occurred.\n"
74736>>>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE1   For "Unknown DDE-error occurred.\nErrornumber"
74736>>>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
74736>>>>>>>>>Define CS_DDE_ERR_HANDL_PAKTC     For "\nPress a key to continue...\n\n"
74736>>>>>>>>>Define CS_DDE_ERR_HANDL_CAPTION   For "a DDE-error occurred"
74736>>>>>>>>>
74736>>>>>>>>>
74736>>>>>>>>>Define vMax_Path     For |CI260
74736>>>>>>>>>Define vMinChar      For |CI$80
74736>>>>>>>>>Define vMaxChar      For |CI$7F
74736>>>>>>>>>Define vMinShort     For |CI$8000
74736>>>>>>>>>Define vMaxShort     For |CI$7FFF
74736>>>>>>>>>Define vMinLong      For |CI$80000000
74736>>>>>>>>>Define vMaxLong      For |CI$7FFFFFFF
74736>>>>>>>>>Define vMaxByte      For |CI$FF
74736>>>>>>>>>Define vMaxWord      For |CI$FFFF
74736>>>>>>>>>Define vMaxDword     For |CI$FFFFFFFF
74736>>>>>>>>>
74736>>>>>>>>>
74736>>>>>>>>>
74736>>>>>>>>>// For FindFirstFile
74736>>>>>>>>>Define vINVALID_HANDLE_VALUE   For |CI-1
74736>>>>>>>>>Define vINVALID_FILE_SIZE      For |CI$FFFFFFFF
74736>>>>>>>>>Define vERROR_NO_MORE_FILES    For |CI18
74736>>>>>>>>>
74736>>>>>>>>>// The defines below can be used to find out what kind of error has occurred if
74736>>>>>>>>>// the API-call ShellExecute is used.
74736>>>>>>>>>Define vERROR_FILE_NOT_FOUND   For |CI0002
74736>>>>>>>>>Define vERROR_PATH_NOT_FOUND   For |CI0003
74736>>>>>>>>>Define vERROR_BAD_FORMAT       For |CI0011
74736>>>>>>>>>Define vSE_ERR_ACCESSDENIED    For |CI0005
74736>>>>>>>>>Define vSE_ERR_ASSOCINCOMPLETE For |CI0027
74736>>>>>>>>>Define vSE_ERR_DDEBUSY         For |CI0030
74736>>>>>>>>>Define vSE_ERR_DDEFAIL         For |CI0029
74736>>>>>>>>>Define vSE_ERR_DDETIMEOUT      For |CI0028
74736>>>>>>>>>Define vSE_ERR_DLLNOTFOUND     For |CI0032
74736>>>>>>>>>Define vSE_ERR_FNF             For |CI0002
74736>>>>>>>>>Define vSE_ERR_NOASSOC         For |CI0031
74736>>>>>>>>>Define vSE_ERR_OOM             For |CI0008
74736>>>>>>>>>Define vSE_ERR_PNF             For |CI0003
74736>>>>>>>>>Define vSE_ERR_SHARE           For |CI0026
74736>>>>>>>>>
74736>>>>>>>>>
74736>>>>>>>>>// C-Structure
74736>>>>>>>>>//typedef struct _browseinfo {
74736>>>>>>>>>//    HWND hwndOwner;
74736>>>>>>>>>//    LPCITEMIDLIST pidlRoot;
74736>>>>>>>>>//    LPSTR pszDisplayName;
74736>>>>>>>>>//    LPCSTR lpszTitle;
74736>>>>>>>>>//    UINT ulFlags;
74736>>>>>>>>>//    BFFCALLBACK lpfn;
74736>>>>>>>>>//    LPARAM lParam;
74736>>>>>>>>>//    int iImage;
74736>>>>>>>>>//} BROWSEINFO, *PBROWSEINFO, *LPBROWSEINFO;
74736>>>>>>>>>
74736>>>>>>>>>//declare C structure struct_browseinfo
74736>>>>>>>>>//as documented in MSDN under Windows Shell API
74736>>>>>>>>>Struct tvBrowseInfo
74736>>>>>>>>>  Handle    hWndOwner
74736>>>>>>>>>  Pointer   pIDLRoot
74736>>>>>>>>>  Pointer   pszDisplayName
74736>>>>>>>>>  Pointer   lpszTitle
74736>>>>>>>>>  dWord     ulFlags
74736>>>>>>>>>  Pointer   lpfnCallback
74736>>>>>>>>>  dWord     lParam
74736>>>>>>>>>  DWord     iImage
74736>>>>>>>>>End_Struct // tvBrowseInfo
74736>>>>>>>>>
74736>>>>>>>>>// Browsing for directory.
74736>>>>>>>>>Define vBIF_RETURNONLYFSDIRS   For |CI$0001  // For finding a folder to start document searching
74736>>>>>>>>>Define vBIF_DONTGOBELOWDOMAIN  For |CI$0002  // For starting the Find Computer
74736>>>>>>>>>Define vBIF_STATUSTEXT         For |CI$0004  // Includes a status area in the dialog box.
74736>>>>>>>>>                                            // The callback function can set the status text by
74736>>>>>>>>>                                            // sending messages to the dialog box.
74736>>>>>>>>>Define vBIF_RETURNFSANCESTORS  For |CI$0008  // Only returns file system ancestors.
74736>>>>>>>>>
74736>>>>>>>>>Define vBIF_BROWSEFORCOMPUTER  For |CI$1000  // Browsing for Computers.
74736>>>>>>>>>Define vBIF_BROWSEFORPRINTER   For |CI$2000  // Browsing for Printers
74736>>>>>>>>>
74736>>>>>>>>>// message from browser
74736>>>>>>>>>//Define BFFM_INITIALIZED        1
74736>>>>>>>>>//Define BFFM_SELCHANGED         2
74736>>>>>>>>>
74736>>>>>>>>>// messages to browser
74736>>>>>>>>>//Define BFFM_SETSTATUSTEXT      (WM_USER + 100)
74736>>>>>>>>>//Define BFFM_ENABLEOK           (WM_USER + 101)
74736>>>>>>>>>//Define BFFM_SETSELECTION       (WM_USER + 102)
74736>>>>>>>>>
74736>>>>>>>>>
74736>>>>>>>>>External_function vWin32_SHBrowseForFolder "SHBrowseForFolder" shell32.dll ;  Pointer lpsBrowseInfo Returns dWord
74737>>>>>>>>>
74737>>>>>>>>>External_function vWin32_SHGetPathFromIDList "SHGetPathFromIDList" shell32.dll ;  Pointer pidList Pointer lpBuffer Returns dWord
74738>>>>>>>>>
74738>>>>>>>>>External_function vWin32_CoTaskMemFree "CoTaskMemFree" ole32.dll Pointer pV Returns Integer
74739>>>>>>>>>
74739>>>>>>>>>
74739>>>>>>>>>
74739>>>>>>>>>
74739>>>>>>>>>Struct tvSecurity_attributes
74739>>>>>>>>>  DWord   nLength
74739>>>>>>>>>  Pointer lpDescriptor
74739>>>>>>>>>  Integer bInheritHandle
74739>>>>>>>>>End_Struct // tvSecurity_attributes
74739>>>>>>>>>
74739>>>>>>>>>//nLength:
74739>>>>>>>>>// Specifies the size, in bytes, of this structure. Set this value to the size of the
74739>>>>>>>>>// SECURITY_ATTRIBUTES structure.
74739>>>>>>>>>// Windows NT: Some functions that use the SECURITY_ATTRIBUTES structure do not verify the
74739>>>>>>>>>// value of the nLength member. However, an application should still set it properly.
74739>>>>>>>>>// That ensures current, future, and cross-platform compatibility.
74739>>>>>>>>>//
74739>>>>>>>>>//lpSecurityDescriptor:
74739>>>>>>>>>// Points to a security descriptor for the object that controls the sharing of it.
74739>>>>>>>>>// If NULL is specified for this member, the object may be assigned the default security
74739>>>>>>>>>// descriptor of the calling process.
74739>>>>>>>>>//
74739>>>>>>>>>//bInheritHandle:
74739>>>>>>>>>// Specifies whether the returned handle is inherited when a new process is created.
74739>>>>>>>>>// If this member is TRUE, the new process inherits the handle.
74739>>>>>>>>>
74739>>>>>>>>>
74739>>>>>>>>>// BOOL CreateDirectory(
74739>>>>>>>>>//    LPCTSTR lpPathName,
74739>>>>>>>>>//    LPSECURITY_ATTRIBUTES lpSecurityAttributes  // pointer to a security descriptor
74739>>>>>>>>>//   );
74739>>>>>>>>>//
74739>>>>>>>>>// lpPathName
74739>>>>>>>>>//  Points to a null-terminated string that specifies the path of the directory
74739>>>>>>>>>//  to be created.
74739>>>>>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
74739>>>>>>>>>//  This limit is related to how the CreateDirectory function parses paths.
74739>>>>>>>>>// lpSecurityAttributes
74739>>>>>>>>>//  Pointer to a SECURITY_ATTRIBUTES structure als called a security descriptor that
74739>>>>>>>>>//  determines whether the returned handle can be inherited by child processes.
74739>>>>>>>>>//  If lpSecurityAttributes is NULL, the handle cannot be inherited.
74739>>>>>>>>>// Returns:
74739>>>>>>>>>//  If the function succeeds, the return value is nonzero.
74739>>>>>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
74739>>>>>>>>>External_function vWin32_CreateDirectory "CreateDirectoryA" kernel32.dll ;  Pointer lpPathName Pointer lpSecurity_Attributes Returns Integer
74740>>>>>>>>>
74740>>>>>>>>>
74740>>>>>>>>>// lpPathName
74740>>>>>>>>>//  Points to a null-terminated string that specifies the path of the directory
74740>>>>>>>>>//  to be removed.
74740>>>>>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
74740>>>>>>>>>// Returns:
74740>>>>>>>>>//  If the function succeeds, the return value is nonzero.
74740>>>>>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
74740>>>>>>>>>External_function vWin32_RemoveDirectory "RemoveDirectoryA" kernel32.dll ;  Pointer lpPathName Returns Integer
74741>>>>>>>>>
74741>>>>>>>>>
74741>>>>>>>>>
74741>>>>>>>>>// The ShellExecute function opens or prints a specified file. The file can be an
74741>>>>>>>>>// executable file or a document file.
74741>>>>>>>>>//
74741>>>>>>>>>// Operation can be one of the following:
74741>>>>>>>>>//    "OPEN"  The function opens the file specified by lpFile.
74741>>>>>>>>>//            The file can be an executable file or a document file.
74741>>>>>>>>>//            The file can be a folder to open.
74741>>>>>>>>>//    "PRINT" The function prints the file specified by lpFile.
74741>>>>>>>>>//            The file should be a document file. If the file is an executable file,
74741>>>>>>>>>//            the function opens the file, as if "open" had been specified.
74741>>>>>>>>>//  "EXPLORE" The function explores the folder specified by lpFile.
74741>>>>>>>>>//
74741>>>>>>>>>// Return Values:
74741>>>>>>>>>//
74741>>>>>>>>>// If the function succeeds, the return value is the instance handle of the application that
74741>>>>>>>>>// was run, or the handle of a dynamic data exchange (DDE) server application.
74741>>>>>>>>>// If the function fails, the return value is an error value that is less than or equal to 32.
74741>>>>>>>>>//
74741>>>>>>>>>// The following table lists these error values:
74741>>>>>>>>>// Public Const ERROR_FILE_NOT_FOUND = 2&
74741>>>>>>>>>// Public Const ERROR_PATH_NOT_FOUND = 3&
74741>>>>>>>>>// Public Const ERROR_BAD_FORMAT = 11&
74741>>>>>>>>>// Public Const SE_ERR_ACCESSDENIED = 5
74741>>>>>>>>>// Public Const SE_ERR_ASSOCINCOMPLETE = 27
74741>>>>>>>>>// Public Const SE_ERR_DDEBUSY = 30
74741>>>>>>>>>// Public Const SE_ERR_DDEFAIL = 29
74741>>>>>>>>>// Public Const SE_ERR_DDETIMEOUT = 28
74741>>>>>>>>>// Public Const SE_ERR_DLLNOTFOUND = 32
74741>>>>>>>>>// Public Const SE_ERR_FNF = 2
74741>>>>>>>>>// Public Const SE_ERR_NOASSOC = 31
74741>>>>>>>>>// Public Const SE_ERR_OOM = 8
74741>>>>>>>>>// Public Const SE_ERR_PNF = 3
74741>>>>>>>>>// Public Const SE_ERR_SHARE = 26
74741>>>>>>>>>
74741>>>>>>>>>
74741>>>>>>>>>
74741>>>>>>>>>// Code to open the program that is associated with the selected file.
74741>>>>>>>>>//
74741>>>>>>>>>// External function call used in Procedure DoStartDocument
74741>>>>>>>>>External_function vWin32_ShellExecute "ShellExecuteA" shell32.dll ;  Handle hWnd ;  Pointer lpOperation ;  Pointer lpFile ;  Pointer lpParameters ;  Pointer lpDirectory ;  Dword iShowCmd Returns Handle
74742>>>>>>>>>
74742>>>>>>>>>
74742>>>>>>>>>
74742>>>>>>>>>
74742>>>>>>>>>Define vFO_MOVE                For |CI$0001
74742>>>>>>>>>Define vFO_COPY                For |CI$0002
74742>>>>>>>>>Define vFO_DELETE              For |CI$0003
74742>>>>>>>>>Define vFO_RENAME              For |CI$0004
74742>>>>>>>>>
74742>>>>>>>>>Define vFOF_MULTIDESTFILES     For |CI$0001
74742>>>>>>>>>Define vFOF_CONFIRMMOUSE       For |CI$0002
74742>>>>>>>>>Define vFOF_SILENT             For |CI$0004  // don't create progress/report
74742>>>>>>>>>Define vFOF_RENAMEONCOLLISION  For |CI$0008
74742>>>>>>>>>Define vFOF_NOCONFIRMATION     For |CI$0010  // Don't prompt the user.
74742>>>>>>>>>Define vFOF_WANTMAPPINGHANDLE  For |CI$0020  // Fill in SHFILEOPSTRUCT.hNameMappings
74742>>>>>>>>>                                          // Must be freed using SHFreeNameMappings
74742>>>>>>>>>Define vFOF_ALLOWUNDO          For |CI$0040
74742>>>>>>>>>Define vFOF_FILESONLY          For |CI$0080  // on *.*, do only files
74742>>>>>>>>>Define vFOF_SIMPLEPROGRESS     For |CI$0100  // means don't show names of files
74742>>>>>>>>>Define vFOF_NOCONFIRMMKDIR     For |CI$0200  // don't confirm making any needed dirs
74742>>>>>>>>>
74742>>>>>>>>>Struct tvShFileOpStruct
74742>>>>>>>>>  Handle  hWnd
74742>>>>>>>>>  Integer wFunc
74742>>>>>>>>>  Pointer pFrom
74742>>>>>>>>>  Pointer pTo
74742>>>>>>>>>  Short   fFlags
74742>>>>>>>>>  Short   fAnyOperationsAborted
74742>>>>>>>>>  Pointer hNameMappings
74742>>>>>>>>>  Pointer lpszProgressTitle      // only used if FOF_SIMPLEPROGRESS
74742>>>>>>>>>End_Struct // tvShFileOpStruct
74742>>>>>>>>>
74742>>>>>>>>>// hwnd
74742>>>>>>>>>//   Handle of the dialog box to use to display information about the status of the operation.
74742>>>>>>>>>
74742>>>>>>>>>// wFunc
74742>>>>>>>>>//   Operation to perform. This member can be one of the following values:
74742>>>>>>>>>//     FO_COPY     Copies the files specified by pFrom to the location specified by pTo.
74742>>>>>>>>>//     FO_DELETE   Deletes the files specified by pFrom (pTo is ignored).
74742>>>>>>>>>//     FO_MOVE     Moves the files specified by pFrom to the location specified by pTo.
74742>>>>>>>>>//     FO_RENAME   Renames the files specified by pFrom.
74742>>>>>>>>>
74742>>>>>>>>>// pFrom
74742>>>>>>>>>//   Pointer to a buffer that specifies one or more source file names. Multiple names must
74742>>>>>>>>>//   be null-separated. The list of names must be double null-terminated.
74742>>>>>>>>>
74742>>>>>>>>>// pTo
74742>>>>>>>>>//   Pointer to a buffer that contains the name of the destination file or directory. The
74742>>>>>>>>>//   buffer can contain mutiple destination file names if the fFlags member specifies
74742>>>>>>>>>//   FOF_MULTIDESTFILES. Multiple names must be null-separated. The list of names must be
74742>>>>>>>>>//   double null-terminated.
74742>>>>>>>>>
74742>>>>>>>>>// fAnyOperationsAborted
74742>>>>>>>>>//   Value that receives TRUE if the user aborted any file operations before they
74742>>>>>>>>>//   were completed or FALSE otherwise.
74742>>>>>>>>>
74742>>>>>>>>>
74742>>>>>>>>>// Performs a copy, move, rename, or delete operation on a file system object.
74742>>>>>>>>>// This can be a file or a folder.
74742>>>>>>>>>// With thanks to Andrew S Kaplan
74742>>>>>>>>>External_function vWin32_SHFileOperation "SHFileOperationA" Shell32.dll ;        Pointer lpFileOp Returns Integer
74743>>>>>>>>>
74743>>>>>>>>>
74743>>>>>>>>>// Thanks To Oliver Nelson for posting this code on the newsgroups
74743>>>>>>>>>External_function vWin32_GetWindowsDirectory "GetWindowsDirectoryA" kernel32.dll ;                           Pointer lpBuffer Integer nSize Returns Integer
74744>>>>>>>>>
74744>>>>>>>>>
74744>>>>>>>>>
74744>>>>>>>>>// Courtesy Of Vincent Oorsprong
74744>>>>>>>>>//External_Function vWin32_GetTempFileName "GetTempFileNameA" Kernel32.Dll ;
74744>>>>>>>>>//   Pointer lpPathName ;
74744>>>>>>>>>//   Pointer lpPrefixString ;
74744>>>>>>>>>//   Integer uUnique ;
74744>>>>>>>>>//   Pointer lpTempFileName ;
74744>>>>>>>>>//   Returns Integer
74744>>>>>>>>>// **WvA: 28-04-2005 Changed string parameter type into pointers
74744>>>>>>>>>External_function vWin32_GetTempFileName "GetTempFileNameA" kernel32.dll Pointer lpsPath ;        Pointer lpsPrefix Integer iUnique Pointer pLoad Returns Integer
74745>>>>>>>>>
74745>>>>>>>>>External_function vWin32_GetTempPath "GetTempPathA" Kernel32.Dll ;   Dword nBufferLength ;   Pointer lpBuffer ;   Returns Integer
74746>>>>>>>>>
74746>>>>>>>>>External_function vWin32_DeleteFile "DeleteFileA" Kernel32.Dll ;   Pointer lpFileName ;   Returns Integer
74747>>>>>>>>>
74747>>>>>>>>>// from:
74747>>>>>>>>>// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/shellcc/platform/shell/reference/enums/csidl.asp
74747>>>>>>>>>//
74747>>>>>>>>>Define vCSIDL_FLAG_CREATE       For |CI$8000 // IE5+, use this to create a special folder
74747>>>>>>>>>Define vCSIDL_ADMIN_TOOLS       For |CI$0030 // IE5+, The file system directory that is used to store administrative tools for an individual user
74747>>>>>>>>>Define vCSIDL_ALT_STARTUP       For |CI$001D // The file system directory that corresponds to the user's nonlocalized Startup program group
74747>>>>>>>>>Define vCSIDL_APPDATA           For |CI$001A // Version 4.71. The file system directory that serves as a common repository for application-specific data. A typical path is C:\Documents and Settings\<username>\Application Data
74747>>>>>>>>>Define vCSIDL_BITBUCKET         For |CI$000A // The virtual folder containing the objects in the user's Recycle Bin
74747>>>>>>>>>Define vCSIDL_CDBURN_AREA       For |CI$003B // IE6+ The file system directory acting as a staging area for files waiting to be written to CD. A typical path is C:\Documents and Settings\<username>\Local Settings\Application Data\Microsoft\CD Burning
74747>>>>>>>>>Define vCSIDL_COMMON_ADMINTOOLS For |CI$002F // IE5+ The file system directory containing administrative tools for all users of the computer
74747>>>>>>>>>Define vCSIDL_COMMON_ALTSTARTUP For |CI$001E // The file system directory that corresponds to the nonlocalized Startup program group for all users
74747>>>>>>>>>Define vCSIDL_COMMON_APPDATA    For |CI$0023 // IE5+ The file system directory containing application data for all users. A typical path is C:\Documents and Settings\All Users\Application Data
74747>>>>>>>>>Define vCSIDL_COMMON_DESKTOPDIRECTORY for |CI$0019 // WinNT+ Only, The file system directory that contains files and folders that appear on the desktop for all users. A typical path is C:\Documents and Settings\All Users\Desktop
74747>>>>>>>>>Define vCSIDL_COMMON_DOCUMENTS  For |CI$002E // IE5+ The file system directory that contains documents that are common to all users. A typical paths is C:\Documents and Settings\All Users\Documents
74747>>>>>>>>>Define vCSIDL_COMMON_FAVORITES  For |CI$001F // The file system directory that serves as a common repository for favorite items common to all users
74747>>>>>>>>>Define vCSIDL_COMMON_MUSIC      For |CI$0035 // IE6+ The file system directory that serves as a repository for music files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Music
74747>>>>>>>>>Define vCSIDL_COMMON_PICTURES   For |CI$0036 // The file system directory that serves as a repository for image files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Pictures
74747>>>>>>>>>Define vCSIDL_COMMON_PROGRAMS   For |CI$0017 // WinNT+ The file system directory that contains the directories for the common program groups that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs
74747>>>>>>>>>Define vCSIDL_COMMON_STARTMENU  For |CI$0016 // WinNT+ The file system directory that contains the programs and folders that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu
74747>>>>>>>>>Define vCSIDL_COMMON_STARTUP    For |CI$0018 // WinNT+ The file system directory that contains the programs that appear in the Startup folder for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs\Startup
74747>>>>>>>>>Define vCSIDL_COMMON_TEMPLATES  For |CI$002D // WinNT+ The file system directory that contains the templates that are available to all users. A typical path is C:\Documents and Settings\All Users\Templates
74747>>>>>>>>>Define vCSIDL_COMMON_VIDEO      For |CI$0037 // IE6+ The file system directory that serves as a repository for video files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Videos
74747>>>>>>>>>Define vCSIDL_COMPUTERSNEARME   For |CI$003D // The folder representing other machines in your workgroup
74747>>>>>>>>>Define vCSIDL_CONNECTIONS       For |CI$0031 // The virtual folder representing Network Connections, containing network and dial-up connections
74747>>>>>>>>>Define vCSIDL_CONTROLS          For |CI$0003 // The virtual folder containing icons for the Control Panel applications
74747>>>>>>>>>Define vCSIDL_COOKIES           For |CI$0021 // The file system directory that serves as a common repository for Internet cookies. A typical path is C:\Documents and Settings\username\Cookies
74747>>>>>>>>>Define vCSIDL_DESKTOP           For |CI$0000 // The virtual folder representing the Windows desktop, the root of the namespace
74747>>>>>>>>>Define vCSIDL_DESKTOPDIRECTORY  For |CI$0010 // The file system directory used to physically store file objects on the desktop (not to be confused with the desktop folder itself). A typical path is C:\Documents and Settings\username\Desktop
74747>>>>>>>>>Define vCSIDL_DRIVES            For |CI$0011 // The virtual folder representing My Computer, containing everything on the local computer: storage devices, printers, and Control Panel. The folder may also contain mapped network drives
74747>>>>>>>>>Define vCSIDL_FAVORITES         For |CI$0006 // The file system directory that serves as a common repository for the user's favorite items. A typical path is C:\Documents and Settings\username\Favorites
74747>>>>>>>>>Define vCSIDL_FONTS             For |CI$0014 // A virtual folder containing fonts. A typical path is C:\Windows\Fonts
74747>>>>>>>>>Define vCSIDL_HISTORY           For |CI$0022 // The file system directory that serves as a common repository for Internet history items
74747>>>>>>>>>Define vCSIDL_INTERNET          For |CI$0001 // A virtual folder representing the Internet
74747>>>>>>>>>Define vCSIDL_INTERNET_CACHE    For |CI$0020 // Comctl4.72+, The file system directory that serves as a common repository for temporary Internet files. A typical path is C:\Documents and Settings\username\Local Settings\Temporary Internet Files
74747>>>>>>>>>Define vCSIDL_LOCAL_APPDATA     For |CI$001C // IE5+ The file system directory that serves as a data repository for local (nonroaming) applications. A typical path is C:\Documents and Settings\username\Local Settings\Application Data
74747>>>>>>>>>Define vCSIDL_MYDOCUMENTS       For |CI$000C // IE6+ The virtual folder representing the My Documents desktop item
74747>>>>>>>>>Define vCSIDL_MYMUSIC           For |CI$000D // The file system directory that serves as a common repository for music files. A typical path is C:\Documents and Settings\User\My Documents\My Music
74747>>>>>>>>>Define vCSIDL_MYPICTURES        For |CI$0027 // IE5+ The file system directory that serves as a common repository for image files. A typical path is C:\Documents and Settings\username\My Documents\My Pictures
74747>>>>>>>>>Define vCSIDL_MYVIDEO           For |CI$000E // IE6+ The file system directory that serves as a common repository for video files. A typical path is C:\Documents and Settings\username\My Documents\My Videos
74747>>>>>>>>>Define vCSIDL_NETHOOD           For |CI$0013 // A file system directory containing the link objects that may exist in the My Network Places virtual folder. It is not the same as CSIDL_NETWORK, which represents the network namespace root. A typical path is C:\Documents and Settings\username\NetHood
74747>>>>>>>>>Define vCSIDL_NETWORK           For |CI$0012 // A virtual folder representing Network Neighborhood, the root of the network namespace hierarchy
74747>>>>>>>>>Define vCSIDL_PERSONAL          For |CI$0005 // (Documents folder) IE6 The virtual folder representing the My Documents desktop item.
74747>>>>>>>>>                                             // This is equivalent to CSIDL_MYDOCUMENTS. Previous to Version 6.0. The file system directory used to physically store a user's common repository of documents. A typical path is C:\Documents and Settings\username\My Documents
74747>>>>>>>>>Define vCSIDL_PHOTOALBUMS       For |CI$0045 // Vista+ The virtual folder used to store photo albums, typically username\My Pictures\Photo Albums
74747>>>>>>>>>Define vCSIDL_PLAYLISTS         For |CI$003F // Vista+ The virtual folder used to store play albums, typically username\My Music\Playlists
74747>>>>>>>>>Define vCSIDL_PRINTERS          For |CI$0004 // The virtual folder containing installed printers
74747>>>>>>>>>Define vCSIDL_PRINTHOOD         For |CI$001B // The file system directory that contains the link objects that can exist in the Printers virtual folder. A typical path is C:\Documents and Settings\username\PrintHood
74747>>>>>>>>>Define vCSIDL_PROFILE           For |CI$0028 // IE5+ The user's profile folder. A typical path is C:\Documents and Settings\username
74747>>>>>>>>>Define vCSIDL_PROGRAM_FILES     For |CI$0026 // IE5+ The Program Files folder. A typical path is C:\Program Files
74747>>>>>>>>>Define vCSIDL_PROGRAM_FILESx86  for |CI$002A // The Program Files folder for x86 programs. A typical path is C:\Program Files (x86)
74747>>>>>>>>>Define vCSIDL_PROGRAM_FILES_COMMON For |CI$002B // IE5+, WinNT+ A folder for components that are shared across applications. A typical path is C:\Program Files\Common
74747>>>>>>>>>Define vCSIDL_PROGRAMS          For |CI$0002 // The file system directory that contains the user's program groups (which are themselves file system directories). A typical path is C:\Documents and Settings\username\Start Menu\Programs
74747>>>>>>>>>Define vCSIDL_RECENT            For |CI$0008 // The file system directory that contains shortcuts to the user's most recently used documents. A typical path is C:\Documents and Settings\username\My Recent Documents
74747>>>>>>>>>Define vCSIDL_RESOURCES         For |CI$0038 // undocumented
74747>>>>>>>>>Define vCSIDL_SAMPLE_MUSIC      For |CI$0040 // Vista+, The file system directory that contains sample music. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Music
74747>>>>>>>>>Define vCSIDL_SAMPLE_PLAYLISTS  For |CI$0041 // Vista+, The file system directory that contains sample playlists. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Playlists
74747>>>>>>>>>Define vCSIDL_SAMPLE_PICTURES   For |CI$0042 // Vista+, The file system directory that contains sample pictures. A typical path is C:\Documents and Settings\username\My Documents\My Pictures\Sample Pictures
74747>>>>>>>>>Define vCSIDL_SAMPLE_VIDEOS     For |CI$0043 // Vista+, The file system directory that contains sample videos. A typical path is C:\Documents and Settings\username\My Documents\My Videos\Sample Videos
74747>>>>>>>>>Define vCSIDL_SENDTO            For |CI$0009 // The file system directory that contains Send To menu items. A typical path is C:\Documents and Settings\username\SendTo
74747>>>>>>>>>Define vCSIDL_STARTMENU         For |CI$000B // The file system directory containing Start menu items. A typical path is C:\Documents and Settings\username\Start Menu
74747>>>>>>>>>Define vCSIDL_STARTUP           For |CI$0007 // The file system directory that corresponds to the user's Startup program group. The system starts these programs whenever any user logs onto Windows NT or starts Windows 95. A typical path is C:\Documents and Settings\username\Start Menu\Programs\Startup
74747>>>>>>>>>Define vCSIDL_SYSTEM            For |CI$0025 // The Windows System folder. A typical path is C:\Windows\System32
74747>>>>>>>>>Define vCSIDL_SYSTEMX86         For |CI$0029 //
74747>>>>>>>>>Define vCSIDL_TEMPLATES         For |CI$0015 // The file system directory that serves as a common repository for document templates. A typical path is C:\Documents and Settings\username\Templates
74747>>>>>>>>>Define vCSIDL_WINDOWS           For |CI$0024 // The Windows directory or SYSROOT. This corresponds to the %windir% or %SYSTEMROOT% environment variables. A typical path is C:\Windows
74747>>>>>>>>>
74747>>>>>>>>>
74747>>>>>>>>>//HRESULT SHGetFolderPath(
74747>>>>>>>>>//    HWND hwndOwner,
74747>>>>>>>>>//    int nFolder,
74747>>>>>>>>>//    HANDLE hToken,
74747>>>>>>>>>//    DWORD dwFlags,
74747>>>>>>>>>//    LPTSTR pszPath
74747>>>>>>>>>//);
74747>>>>>>>>>// This function is a superset of SHGetSpecialFolderPath, included with earlier versions of
74747>>>>>>>>>// the shell. It is implemented in a redistributable DLL, SHFolder.dll, that also simulates
74747>>>>>>>>>// many of the new shell folders on older platforms such as Windows 95, Windows 98, and
74747>>>>>>>>>// Windows NT 4.0. This DLL always calls the current platform's version of this function.
74747>>>>>>>>>// If that fails, it will try to simulate the appropriate behavior.
74747>>>>>>>>>//
74747>>>>>>>>>External_function vWin32_SHGetFolderPath "SHGetFolderPathA" SHFolder.Dll ;   Pointer hWnd ;   Integer nFolder ;   Pointer hToken ;   DWord   dwFlags ;   Pointer lpszPath ;   Returns Integer
74748>>>>>>>>>
74748>>>>>>>>>
74748>>>>>>>>>
74748>>>>>>>>>Struct tvWin32FindData
74748>>>>>>>>> Dword            dwFileAttributes
74748>>>>>>>>> Dword            ftCreationLowDateTime
74748>>>>>>>>> Dword            ftCreationHighDateTime
74748>>>>>>>>> dword            ftLastAccessLowDateTime
74748>>>>>>>>> Dword            ftLastAccessHighDateTime
74748>>>>>>>>> Dword            ftLastWriteLowDateTime
74748>>>>>>>>> Dword            ftLastWriteHighDateTime
74748>>>>>>>>> Dword            nFileSizeHigh
74748>>>>>>>>> Dword            nFileSizeLow
74748>>>>>>>>> Dword            dwReserved0
74748>>>>>>>>> Dword            dwReserved1
74748>>>>>>>>> UChar[vMax_Path] cFileName
74748>>>>>>>>> UChar[14]        cAlternateFileName
74748>>>>>>>>>End_Struct
74748>>>>>>>>>
74748>>>>>>>>>// Courtesy Of Vincent Oorsprong
74748>>>>>>>>>// lpFileName      : address of name of file to search for
74748>>>>>>>>>// lpFindFileData  : address of returned information
74748>>>>>>>>>External_function vWin32_FindFirstFile "FindFirstFileA"  Kernel32.dll Pointer lpFileName ;          Pointer lpFindFileData Returns Handle
74749>>>>>>>>>
74749>>>>>>>>>// Courtesy Of Vincent Oorsprong
74749>>>>>>>>>// hFindFile       : handle of search
74749>>>>>>>>>// lpFindFileData  : address of structure for data on found file
74749>>>>>>>>>External_function vWin32_FindNextFile "FindNextFileA" Kernel32.dll Handle hFindFile ;          Pointer lpFindFileData Returns Integer
74750>>>>>>>>>
74750>>>>>>>>>//
74750>>>>>>>>>// Unicode equivalents
74750>>>>>>>>>//
74750>>>>>>>>>// lpFileName      : address of name of file to search for
74750>>>>>>>>>// lpFindFileData  : address of returned information
74750>>>>>>>>>External_function vWin32W_FindFirstFile "FindFirstFileW"  Kernel32.dll Pointer lpFileName ;          Pointer lpFindFileData Returns Handle
74751>>>>>>>>>
74751>>>>>>>>>// hFindFile       : handle of search
74751>>>>>>>>>// lpFindFileData  : address of structure for data on found file
74751>>>>>>>>>External_function vWin32W_FindNextFile "FindNextFileW" Kernel32.dll Handle hFindFile ;          Pointer lpFindFileData Returns Integer
74752>>>>>>>>>
74752>>>>>>>>>
74752>>>>>>>>>// Courtesy Of Vincent Oorsprong
74752>>>>>>>>>//  hFindFile      : file search handle
74752>>>>>>>>>External_function vWin32_FindClose "FindClose" Kernel32.dll Handle hFindFile Returns Integer
74753>>>>>>>>>
74753>>>>>>>>>
74753>>>>>>>>>
74753>>>>>>>>>Struct tvFileTime
74753>>>>>>>>>  DWord dwLowDateTime
74753>>>>>>>>>  DWord dwHighDateTime
74753>>>>>>>>>End_Struct
74753>>>>>>>>>
74753>>>>>>>>>
74753>>>>>>>>>Struct tvSystemTime
74753>>>>>>>>>  UShort wYear
74753>>>>>>>>>  UShort wMonth
74753>>>>>>>>>  UShort wDayOfWeek
74753>>>>>>>>>  UShort wDay
74753>>>>>>>>>  UShort wHour
74753>>>>>>>>>  UShort wMinute
74753>>>>>>>>>  UShort wSecond
74753>>>>>>>>>  UShort wMilliSeconds
74753>>>>>>>>>End_Struct
74753>>>>>>>>>
74753>>>>>>>>>
74753>>>>>>>>>// Courtesy Of Vincent Oorsprong
74753>>>>>>>>>//  lpFileTime     : pointer to file time to convert
74753>>>>>>>>>//  lpSystemTime   : pointer to structure to receive system time
74753>>>>>>>>>External_function vWin32_FileTimeToSystemTime "FileTimeToSystemTime" Kernel32.Dll ;          Pointer lpFileTime Pointer lpsystemTime Returns Integer
74754>>>>>>>>>
74754>>>>>>>>>// Courtesy Of Vincent Oorsprong
74754>>>>>>>>>// This function formats the time in a picture-string passed
74754>>>>>>>>>//
74754>>>>>>>>>// Picture      Meaning
74754>>>>>>>>>//    h         Hours with no leading zero for single-digit hours; 12-hour clock
74754>>>>>>>>>//    hh        Hours with leading zero for single-digit hours; 12-hour clock
74754>>>>>>>>>//    H         Hours with no leading zero for single-digit hours; 24-hour clock
74754>>>>>>>>>//    HH        Hours with leading zero for single-digit hours; 24-hour clock
74754>>>>>>>>>//    m         Minutes with no leading zero for single-digit minutes
74754>>>>>>>>>//    mm        Minutes with leading zero for single-digit minutes
74754>>>>>>>>>//    s         Seconds with no leading zero for single-digit seconds
74754>>>>>>>>>//    ss        Seconds with leading zero for single-digit seconds
74754>>>>>>>>>//    t         One character time marker string, such as A or P
74754>>>>>>>>>//    tt        Multicharacter time marker string, such as AM or PM
74754>>>>>>>>>//
74754>>>>>>>>>// For example, to get the time string  "11:29:40 PM"
74754>>>>>>>>>//    use the following picture string: "hh" : "mm" : "ss tt"
74754>>>>>>>>>
74754>>>>>>>>>External_function vWin32_GetTimeFormat "GetTimeFormatA" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpTimeStr ;  Integer cchTime Returns Integer
74755>>>>>>>>>
74755>>>>>>>>>
74755>>>>>>>>>// Courtesy Of Vincent Oorsprong
74755>>>>>>>>>// This function formats the date in a picture-string passed
74755>>>>>>>>>//
74755>>>>>>>>>// Picture      Meaning
74755>>>>>>>>>//    d         Day of month as digits with no leading zero for single-digit days.
74755>>>>>>>>>//    dd        Day of month as digits with leading zero for single-digit days.
74755>>>>>>>>>//    ddd       Day of week as a three-letter abbreviation. The function uses the
74755>>>>>>>>>//              LOCALE_SABBREVOAYMAME value associated with the specified locale.
74755>>>>>>>>>//    dddd      Day of week as its full name. The function uses the LOCALE_SDAYNAME
74755>>>>>>>>>//              value associated with the specified locale.
74755>>>>>>>>>//    M         Month as digits with no leading zero for single-digit months.
74755>>>>>>>>>//    MM        Month as digits with leading zero for single-digit months.
74755>>>>>>>>>//    MMM       Month as a three-letter abbreviation. The function uses the
74755>>>>>>>>>//              LOCALE_SABBREVMONTHNAME value associated with the specified locale.
74755>>>>>>>>>//    MMMM      Month as its full name. The function uses the LOCALE_SMONTHNAME value
74755>>>>>>>>>//              associated with the specified locale.
74755>>>>>>>>>//    y         Year as last two digits, but with no leading zero for years less than 10.
74755>>>>>>>>>//    yy        Year as last two digits, but with leading zero for years less than 10.
74755>>>>>>>>>//    yyyy      Year represented hy full four digits.
74755>>>>>>>>>//    gg        Period/era string. The function uses the CAL_SERASTRING value associated
74755>>>>>>>>>//              with the specified locale. This element is ignored if the date to be formatted
74755>>>>>>>>>//              does not have an associated era or period string.
74755>>>>>>>>>// For example, to get the date string  "Wed, Aug 31 94"
74755>>>>>>>>>// use the following picture string:    "ddd","MMM dd yy"
74755>>>>>>>>>
74755>>>>>>>>>External_function vWin32_GetDateFormat "GetDateFormatA" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpDateStr ;  Integer cchDate Returns Integer
74756>>>>>>>>>
74756>>>>>>>>>Define LOCALE_NOUSEROVERRIDE    For |CI$80000000  //  do not use user overrides
74756>>>>>>>>>Define TIME_NOMIHUTESORSECONDS  For |CI$00000001  //  do not use minutes or seconds
74756>>>>>>>>>Define TIME_NOSECONDS           For |CI$00000002  //  do not use seconds
74756>>>>>>>>>Define TIME_NOTIMEMARKER        For |CI$00000004  //  do not use time marker
74756>>>>>>>>>Define TIME_FORCE24HOURFORMAT   For |CI$00000008  //  always use 24 hour format
74756>>>>>>>>>
74756>>>>>>>>>//  Date Flags for GetDateFormatW.
74756>>>>>>>>>//
74756>>>>>>>>>Define DATE_SHORTDATE           For |CI$00000001  //  use short date picture
74756>>>>>>>>>Define DATE_LONGDATE            For |CI$00000002  //  use long date picture
74756>>>>>>>>>Define DATE_USE_ALT_CALENDAR    For |CI$00000004  //  use alternate calendar (if any)
74756>>>>>>>>>
74756>>>>>>>>>
74756>>>>>>>>>External_function vWin32_SetLastError "SetLastError" Kernel32.Dll Dword dwLastError Returns Integer
74757>>>>>>>>>
74757>>>>>>>>>
74757>>>>>>>>>// **WvA: 20-02-2004
74757>>>>>>>>>// While i was testing the format capabilities i stumbled over a very
74757>>>>>>>>>// weird problem where it looks like that the integer value gets somehow translated
74757>>>>>>>>>// incorrectly into an unsigned integer.
74757>>>>>>>>>// I don't have the time to dive into this.. so added a workaround (and removed it again)
74757>>>>>>>>>// It does smell a bit fishy though
74757>>>>>>>>>// Tested it with the same results on both VDF7 and VDF9.1
74757>>>>>>>>>
74757>>>>>>>>>Define SHFMT_ID_DEFAULT        For |CI$0000FFFF // The default format ID
74757>>>>>>>>>Define SHFMT_OPT_DEFAULT       For |CI$00000000 // The default "Quick Format" option.
74757>>>>>>>>>Define SHFMT_OPT_FULL          For |CI$00000001 // Deselects the "Quick Format" option, providing a full format instead. This is useful when an unformatted disk is detected.
74757>>>>>>>>>Define SHFMT_OPT_SYSONLY       For |CI$00000002 // Selects the "Create an MS-DOS startup disk" option, creating a system boot disk.
74757>>>>>>>>>
74757>>>>>>>>>// Possible errors that can be returned by the shellformat function
74757>>>>>>>>>Define SHFMT_ERROR             For (|CI$FFFFFFFF+1) // An error occurred during the last format or no drive parameter passed. This does not indicate that the disk is unformatable.
74757>>>>>>>>>Define SHFMT_CANCEL            For (|CI$FFFFFFFE+1) // The last format was canceled.
74757>>>>>>>>>Define SHFMT_NOFORMAT          For (|CI$FFFFFFFD+1) // The drive cannot be formatted.
74757>>>>>>>>>
74757>>>>>>>>>
74757>>>>>>>>> // Courtesy Of Steve Walter,
74757>>>>>>>>> // USA Software, Inc
74757>>>>>>>>> // Format a disk
74757>>>>>>>>> // Called By:  Move (vWin32_ShFormatDrive(hWnd,0,$FFFF,1)) To dwReturn
74757>>>>>>>>>External_function vWin32_ShFormatDrive "SHFormatDrive" shell32.dll Handle hWnd ;         Integer iDrive Integer iFormatID Integer iOptions Returns DWORD
74758>>>>>>>>>
74758>>>>>>>>>// Michael Mullan.  I Wanted to create all the folders in one statement...
74758>>>>>>>>>
74758>>>>>>>>>// SHCreateDirectoryEx
74758>>>>>>>>>
74758>>>>>>>>>//    Note  This function is available through Microsoft Windows XP Service Pack 2 (SP2) and Windows Server 2003.
74758>>>>>>>>>//    It might be altered or unavailable in subsequent versions of Windows.
74758>>>>>>>>>//
74758>>>>>>>>>//    This function creates a file system folder whose fully qualified path is given by pszPath. If one or more
74758>>>>>>>>>//    of the intermediate folders do not exist, they are created as well. SHCreateDirectoryEx also verifies that
74758>>>>>>>>>//    the files are visible. If they are not visible, expect one of the following:
74758>>>>>>>>>//
74758>>>>>>>>>//        * If hwnd is set to a valid window handle, a message box is displayed warning the user that he or she
74758>>>>>>>>>//        might not be able to access the files. If the user chooses not to proceed, the function returns
74758>>>>>>>>>//        ERROR_CANCELLED.
74758>>>>>>>>>//        * If hwnd is set to NULL, no user interface is displayed and the function returns ERROR_CANCELLED.
74758>>>>>>>>>
74758>>>>>>>>>//        Returns ERROR_SUCCESS if successful. If the operation fails, other error codes can be returned,
74758>>>>>>>>>//        including those listed here. For values not specifically listed, see System Error Codes.
74758>>>>>>>>>//      161  ERROR_BAD_PATHNAME                The pszPath parameter was set to a relative path.
74758>>>>>>>>>//      206  ERROR_FILENAME_EXCED_RANGE     The path pointed to by pszPath is too long.
74758>>>>>>>>>//      3    ERROR_PATH_NOT_FOUND            The system cannot find the path pointed to by pszPath. The path may contain an invalid entry.
74758>>>>>>>>>//      80   ERROR_FILE_EXISTS                The directory exists.
74758>>>>>>>>>//      183  ERROR_ALREADY_EXISTS            The directory exists.
74758>>>>>>>>>//      1223 ERROR_CANCELLED                The user canceled the operation.
74758>>>>>>>>>
74758>>>>>>>>>//        int SHCreateDirectoryEx(
74758>>>>>>>>>//            HWND hwnd,
74758>>>>>>>>>//            LPCTSTR pszPath,
74758>>>>>>>>>//            const SECURITY_ATTRIBUTES *psa
74758>>>>>>>>>//        );
74758>>>>>>>>>
74758>>>>>>>>>External_function vWin32_SHCreateDirectoryEx "SHCreateDirectoryExA" shell32.dll Handle hWnd;                  pointer pszPath  Pointer lpSecurity_Attributes Returns Integer
74759>>>>>>>>>
74759>>>>>>>>> External_Function vWin32_PathIsDirectory "PathIsDirectoryA" SHLWAPI.DLL Pointer lpszPath Returns Integer
74760>>>>>>>
74760>>>>>>>
74760>>>>>>>//
74760>>>>>>>// Gets the string from the right of the last sStopChar in sFrom
74760>>>>>>>// If sStopChar has no occurences in the string an empty string is
74760>>>>>>>// returned.
74760>>>>>>>Function StringFromRightOfChar Global String sFrom String sStopChar Returns String
74762>>>>>>>    String  sRetVal
74762>>>>>>>    String  sChar
74762>>>>>>>    Integer iLength
74762>>>>>>>    Integer iPos
74762>>>>>>>    Boolean bStopChar
74762>>>>>>>    Move "" to sRetval
74763>>>>>>>    Move (Length(sFrom)) to iLength
74764>>>>>>>    If ((iLength>0) And (Pos(sStopChar,sFrom) <> 0)) Begin
74766>>>>>>>        Move iLength   to iPos
74767>>>>>>>        Move (False)   to bStopChar
74768>>>>>>>        While Not bStopChar
74772>>>>>>>            Move (Mid(sFrom,1,iPos)) to sChar
74773>>>>>>>            Decrement iPos
74774>>>>>>>            If ((sChar=sStopChar) Or (iPos<1)) Begin
74776>>>>>>>                Move (True) to bStopChar
74777>>>>>>>            End
74777>>>>>>>>
74777>>>>>>>            Else Begin
74778>>>>>>>                Move (sChar+sRetVal) to sRetVal
74779>>>>>>>            End
74779>>>>>>>>
74779>>>>>>>        Loop
74780>>>>>>>>
74780>>>>>>>    End
74780>>>>>>>>
74780>>>>>>>    Function_Return sRetVal
74781>>>>>>>End_Function
74782>>>>>>>
74782>>>>>>>// Pre:  sFileName contains the complete path of the file.
74782>>>>>>>// Post: returns the complete path of the file.
74782>>>>>>>// This function is inspired on function SEQ_ExtractPathFromFileName of Sture Andersen.
74782>>>>>>>Function ParseFolderName Global String sFileName Returns String
74784>>>>>>>    String sFile
74784>>>>>>>    String sFolderName
74784>>>>>>>    String sDirSep // this is "\" for windows, or "/" for unix
74784>>>>>>>
74784>>>>>>>    Move "" to sFolderName
74785>>>>>>>    Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
74786>>>>>>>    If sDirSep In sFileName Begin
74788>>>>>>>        Move (StringFromRightOfChar(sFileName,sDirSep)) to sFile
74789>>>>>>>        Move (Left(sFileName,Length(sFileName)-Length(sFile))) to sFolderName
74790>>>>>>>    End
74790>>>>>>>>
74790>>>>>>>    Else If ":" In sFileName Begin
74793>>>>>>>        Move (StringFromRightOfChar(sFileName,":")) to sFile
74794>>>>>>>        Move (Replace(sFile,sFileName,"")) to sFolderName
74795>>>>>>>    End
74795>>>>>>>>
74795>>>>>>>    Function_Return sFolderName
74796>>>>>>>End_Function
74797>>>>>>>
74797>>>>>>>// Pre:  sFileName contains the complete path of the file.
74797>>>>>>>// post: The returned filename has it's path removed, but will have a extension
74797>>>>>>>Function ParseFileName Global String sFileName Returns String
74799>>>>>>>    String sFolderName
74799>>>>>>>    String sDirSep // this is "\" for windows, or "/" for unix
74799>>>>>>>
74799>>>>>>>    Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep
74800>>>>>>>    Get ParseFolderName sFileName to sFolderName
74801>>>>>>>    If (sFolderName <> "") Begin
74803>>>>>>>        Move (Replace(sFolderName,sFileName,"")) to sFileName
74804>>>>>>>    End
74804>>>>>>>>
74804>>>>>>>    Move (Replace(sDirSep,sFileName,"")) to sFileName
74805>>>>>>>    Function_Return sFilename
74806>>>>>>>End_Function
74807>>>>>>>
74807>>>>>>>// Pre:  sFileName may contain the complete path of the file.
74807>>>>>>>//       or contain multiple dots in the filename, so temp.gif.bak will
74807>>>>>>>//       return "bak" as the extension and not "gif"
74807>>>>>>>// Post: returns the extension only, this extension can be a valid unixlike extension
74807>>>>>>>//       such as "html" or "java"
74807>>>>>>>Function ParseFileExtension Global String sFileName Returns String
74809>>>>>>>    String  sFileExtension
74809>>>>>>>    Get ParseFileName sFileName to sFileName // takes care of corner case with path containing a ".". eg. c:\frank.cheng\hello
74810>>>>>>>    Get StringFromRightOfChar sFileName "." to sFileExtension
74811>>>>>>>    Function_Return sFileExtension
74812>>>>>>>End_Function
74813>>>>>>>
74813>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
74813>>>>>>>
74813>>>>>>>Function DDE_Error_To_String Integer iErrorID Returns String
74815>>>>>>>    String sMessage
74815>>>>>>>    Case Begin
74815>>>>>>>        Case (iErrorID = vERROR_FILE_NOT_FOUND)
74817>>>>>>>            Move CS_DDE_ERR_FILE_NOT_FOUND to sMessage
74818>>>>>>>            Case Break
74819>>>>>>>        Case (iErrorID = vERROR_PATH_NOT_FOUND)
74822>>>>>>>            Move CS_DDE_ERR_PATH_NOT_FOUND to sMessage
74823>>>>>>>            Case Break
74824>>>>>>>        Case (iErrorID = vERROR_BAD_FORMAT)
74827>>>>>>>            Move CS_DDE_ERR_BAD_FORMAT to sMessage
74828>>>>>>>            Case Break
74829>>>>>>>        Case (iErrorID = vSE_ERR_ACCESSDENIED)
74832>>>>>>>            Move CS_DDE_ERR_ACCESSDENIED to sMessage
74833>>>>>>>            Case Break
74834>>>>>>>        Case (iErrorID = vSE_ERR_ASSOCINCOMPLETE)
74837>>>>>>>            Move CS_DDE_ERR_ASSOCINCOMPLETE to sMessage
74838>>>>>>>            Case Break
74839>>>>>>>        Case (iErrorID = vSE_ERR_DDEBUSY)
74842>>>>>>>            Move CS_DDE_ERR_DDEBUSY to sMessage
74843>>>>>>>            Case Break
74844>>>>>>>        Case (iErrorID = vSE_ERR_DDEFAIL)
74847>>>>>>>            Move CS_DDE_ERR_DDEFAIL to sMessage
74848>>>>>>>            Case Break
74849>>>>>>>        Case (iErrorID = vSE_ERR_DDETIMEOUT)
74852>>>>>>>            Move CS_DDE_ERR_DDETIMEOUT to sMessage
74853>>>>>>>            Case Break
74854>>>>>>>        Case (iErrorID = vSE_ERR_DLLNOTFOUND)
74857>>>>>>>            Move CS_DDE_ERR_DLLNOTFOUND to sMessage
74858>>>>>>>            Case Break
74859>>>>>>>        Case (iErrorID = vSE_ERR_NOASSOC)
74862>>>>>>>            Move CS_DDE_ERR_NOASSOC to sMessage
74863>>>>>>>            Case Break
74864>>>>>>>        Case ((iErrorID = vSE_ERR_OOM) Or (iErrorID = 0))
74867>>>>>>>            Move CS_DDE_ERR_OOM to sMessage
74868>>>>>>>            Case Break
74869>>>>>>>        Case (iErrorID = vSE_ERR_PNF)
74872>>>>>>>            Move CS_DDE_ERR_PNF to sMessage
74873>>>>>>>            Case Break
74874>>>>>>>        Case (iErrorID = vSE_ERR_SHARE)
74877>>>>>>>            Move CS_DDE_ERR_SHARE to sMessage
74878>>>>>>>            Case Break
74879>>>>>>>        Case Else
74879>>>>>>>            Move CS_DDE_ERR_UNKNOWN_LINE1 to sMessage
74880>>>>>>>            Move (sMessage*Trim(iErrorID)*CS_DDE_ERR_UNKNOWN_LINE2) to sMessage
74881>>>>>>>            Case Break
74882>>>>>>>    Case End
74882>>>>>>>    Function_Return sMessage
74883>>>>>>>End_Function
74884>>>>>>>
74884>>>>>>>Procedure vDDE_Error_Handler Integer iErrorID
74886>>>>>>>    String sMessage
74886>>>>>>>    Get DDE_Error_To_String iErrorID to sMessage
74887>>>>>>>    Append sMessage CS_DDE_ERR_HANDL_PAKTC //  "Press a key to continue..."
74888>>>>>>>    Send Stop_Box sMessage CS_DDE_ERR_HANDL_CAPTION
74889>>>>>>>End_Procedure
74890>>>>>>>
74890>>>>>>>// Does the directory exist? - No = false, Yes = True
74890>>>>>>>// This also works with UNC path encoding and wildcards
74890>>>>>>>Function vFolderExists Global String sFolderName Returns Boolean
74892>>>>>>>    Boolean bFolderExists
74892>>>>>>>    Boolean bStop
74892>>>>>>>    String  sFolder sTmp
74892>>>>>>>    Integer iCh
74892>>>>>>>
74892>>>>>>>    // 2013-09-29 NGS Check for empty folder name and convert to ANSI
74892>>>>>>>    Move (Utf8ToAnsi(Trim(sFolderName))) to sFolderName
74893>>>>>>>    If (sFolderName = "") Begin
74895>>>>>>>        Function_Return False
74896>>>>>>>    End
74896>>>>>>>>
74896>>>>>>>
74896>>>>>>>    Move True  to bFolderExists
74897>>>>>>>    Move False to bStop
74898>>>>>>>    Move "dir:" to sFolder
74899>>>>>>>    Append sFolder sFolderName
74900>>>>>>>    Get Seq_New_Channel to iCh  // get free channel for input
74901>>>>>>>    Direct_Input channel iCh sFolder
74903>>>>>>>    Repeat
74903>>>>>>>>
74903>>>>>>>        Readln channel iCh sTmp
74905>>>>>>>        Move (SeqEof) to bStop
74906>>>>>>>        If (Trim(sTmp)="") Begin
74908>>>>>>>            Move False to bFolderExists
74909>>>>>>>        End
74909>>>>>>>>
74909>>>>>>>        Else Begin
74910>>>>>>>            Move True to bFolderExists
74911>>>>>>>            Move True to bStop
74912>>>>>>>        End
74912>>>>>>>>
74912>>>>>>>    Until (bStop)
74914>>>>>>>    Close_Input channel iCh
74916>>>>>>>    Send Seq_Release_Channel iCh
74917>>>>>>>    Function_Return bFolderExists
74918>>>>>>>End_Function
74919>>>>>>>
74919>>>>>>>// returns folder name if a folder was selected, otherwise returns ""
74919>>>>>>>Function vSHBrowseForFolder Global String sDialogTitle Returns String
74921>>>>>>>    String sFolder sTitle sPath
74921>>>>>>>    Pointer lpItemIdList
74921>>>>>>>    Integer iFolderSelected iRetval
74921>>>>>>>    tvBrowseInfo BrowseInfo
74921>>>>>>>    tvBrowseInfo BrowseInfo
74921>>>>>>>
74921>>>>>>>    Move "" to sPath
74922>>>>>>>    If (sDialogTitle<>"") Begin
74924>>>>>>>        Move sDialogTitle to sTitle
74925>>>>>>>        // Torben Lund suggested converting the string with toansi. Doing it like that
74925>>>>>>>        // disables showing some commonly used ascii characters like ascii 137 ()
74925>>>>>>>        // These chars are correctly shown if no toansi is used.
74925>>>>>>>        // I can imagine that he wanted to path to be ANSI, but as long as it isa just
74925>>>>>>>        // selected it will always be valid.
74925>>>>>>>        Move (AddressOf(sTitle)) to BrowseInfo.lpszTitle
74926>>>>>>>    End
74926>>>>>>>>
74926>>>>>>>
74926>>>>>>>    Move vBIF_RETURNONLYFSDIRS to BrowseInfo.ulFlags
74927>>>>>>>
74927>>>>>>>    // Torben Lund added line below. Move handle of focus object to structure before
74927>>>>>>>    // calling function. Otherwise, the folderdialog will be started as a seperate task.
74927>>>>>>>    Move (window_handle(focus(desktop))) to BrowseInfo.hWndOwner
74928>>>>>>>
74928>>>>>>>    // null 128 chars into var (make space)
74928>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
74929>>>>>>>
74929>>>>>>>    // select folder
74929>>>>>>>    Move (vWin32_SHBrowseForFolder(AddressOf(BrowseInfo))) to lpItemIdList
74930>>>>>>>    // get selected folder name
74930>>>>>>>    Move (vWin32_SHGetPathFromIDList(lpItemIdList, AddressOf(sFolder))) to iFolderSelected
74931>>>>>>>
74931>>>>>>>    // release memory resources that are used by the ItemIdList
74931>>>>>>>    Move (vWin32_CoTaskMemFree(lpItemIdList)) to iRetval
74932>>>>>>>
74932>>>>>>>    If (iFolderSelected<>0) Begin
74934>>>>>>>        Move (CString(sFolder)) to sPath
74935>>>>>>>    End
74935>>>>>>>>
74935>>>>>>>    Function_Return  sPath
74936>>>>>>>End_Function
74937>>>>>>>
74937>>>>>>>// returns 0 if the folder is created.
74937>>>>>>>//         1 if the API-call returned an error.
74937>>>>>>>Function vCreateDirectory Global String sNewFolder Returns Integer
74939>>>>>>>    String  sFolder
74939>>>>>>>    Integer iRetval bFolderCreated
74939>>>>>>>    tvSecurity_attributes SA
74939>>>>>>>    tvSecurity_attributes SA
74939>>>>>>>
74939>>>>>>>    Move False to bFolderCreated
74940>>>>>>>
74940>>>>>>>    // null MAX_PATH chars into var (make space)
74940>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
74941>>>>>>>
74941>>>>>>>    If (sNewFolder <> "") Begin
74943>>>>>>>
74943>>>>>>>        Move (SizeOfType(tvSecurity_attributes)) to SA.nLength
74944>>>>>>>        Move  0  to SA.lpDescriptor
74945>>>>>>>        Move  1  to SA.bInheritHandle
74946>>>>>>>
74946>>>>>>>        //
74946>>>>>>>        Move (sNewFolder+"") to sFolder
74947>>>>>>>        Move (vWin32_CreateDirectory(AddressOf(sFolder), AddressOf(SA))) to bFolderCreated
74948>>>>>>>    End
74948>>>>>>>>
74948>>>>>>>
74948>>>>>>>    If (bFolderCreated=false) Begin
74950>>>>>>>        Move 1 to iRetVal
74951>>>>>>>    End
74951>>>>>>>>
74951>>>>>>>    Function_Return iRetVal
74952>>>>>>>End_Function
74953>>>>>>>
74953>>>>>>>// **WvA: 03-02-2002 Function created.
74953>>>>>>>// With this function one can remove a directory.
74953>>>>>>>// returns 0 if the folder is removed.
74953>>>>>>>//         1 if the API-call returned an error (Use GetLastError API to get the details)
74953>>>>>>>//         2 if the folder did not exist
74953>>>>>>>//         3 if the sFolder parameter passed is equal to ""
74953>>>>>>>Function vRemoveDirectory Global String sFolder Returns Integer
74955>>>>>>>    Boolean bRemoved
74955>>>>>>>    String  sPath
74955>>>>>>>    Integer iRetval
74955>>>>>>>
74955>>>>>>>    Move 0     to iRetVal
74956>>>>>>>    Move False to bRemoved
74957>>>>>>>    Move (Trim(sFolder)) to sFolder
74958>>>>>>>    If (sFolder="") Begin
74960>>>>>>>        Move 3 to iRetVal
74961>>>>>>>    End
74961>>>>>>>>
74961>>>>>>>    If (vFolderExists(sFolder)=False) Begin
74963>>>>>>>        Move 2 to iRetVal
74964>>>>>>>    End
74964>>>>>>>>
74964>>>>>>>    If (iRetVal=0) Begin
74966>>>>>>>    // null MAX_PATH chars into var (make space)
74966>>>>>>>        Move (Repeat(Character(0), vMAX_PATH)) to sPath
74967>>>>>>>        //
74967>>>>>>>        Move (Insert(sFolder,sPath,1)) to sPath
74968>>>>>>>        Move (vWin32_RemoveDirectory(AddressOf(sPath))) to bRemoved
74969>>>>>>>    End
74969>>>>>>>>
74969>>>>>>>
74969>>>>>>>    If (iRetVal=0 And bRemoved=False) Begin
74971>>>>>>>        Move 1 to iRetVal
74972>>>>>>>    End
74972>>>>>>>>
74972>>>>>>>    Function_Return iRetVal
74973>>>>>>>End_Function
74974>>>>>>>
74974>>>>>>>// This function informs the user that he entered a yet unknown folder and
74974>>>>>>>// asks if he/she wants to create the folder (Yes/No)
74974>>>>>>>// Choice: "Yes" - this creates the folder
74974>>>>>>>//                 if successful, the function returns false
74974>>>>>>>//                 else it will be true.
74974>>>>>>>// Choice: "No"  - returns TRUE, This allows the programmer to take action
74974>>>>>>>//                 For example: to stop a save
74974>>>>>>>// Precondition: A foldername must be entered. We do not check for empty paths
74974>>>>>>>// This function returns a non-zero value if the folder isn't created afterwards
74974>>>>>>>Function vVerifyNewFolder Global String sFolderName Returns Integer
74976>>>>>>>    Integer bIsNotValid
74976>>>>>>>    Integer iUsers_Choice
74976>>>>>>>    String  sMessage
74976>>>>>>>
74976>>>>>>>    If (vFolderExists(sFolderName) Eq 0) Begin
74978>>>>>>>        Move "The folder '" to sMessage
74979>>>>>>>        Append sMessage sFolderName
74980>>>>>>>        Append sMessage "' does not yet exist,\n"
74981>>>>>>>        Append sMessage "Do you want to create it now?"
74982>>>>>>>        Get YesNo_Box sMessage "Confirm" MB_DefButton1 to iUsers_Choice
74983>>>>>>>        Case Begin
74983>>>>>>>            Case (iUsers_Choice = MBR_Yes)
74985>>>>>>>                Move (vCreateDirectory(sFolderName)) to bIsNotValid
74986>>>>>>>                If bIsNotValid Begin
74988>>>>>>>                    Move "An error occurred while trying to create folder '" to sMessage
74989>>>>>>>                    Append sMessage sFolderName "'.\n\n"
74991>>>>>>>                    Send Info_Box sMessage "Info"
74992>>>>>>>                End
74992>>>>>>>>
74992>>>>>>>                Case Break
74993>>>>>>>            Case (iUsers_Choice = MBR_No)
74996>>>>>>>                Move dfTrue to bIsNotValid // Cancel the save
74997>>>>>>>                Case Break
74998>>>>>>>        Case End
74998>>>>>>>    End
74998>>>>>>>>
74998>>>>>>>    Function_Return bIsNotValid
74999>>>>>>>End_Function
75000>>>>>>>
75000>>>>>>>// This will perform an operation on a file (e.g. open) with the application
75000>>>>>>>// registered in the Windows Registry to open that type of file (via its extension)
75000>>>>>>>// sOperation would be "OPEN" (it could also be "PRINT" etc).
75000>>>>>>>Procedure vShellExecute Global String sOperation String sDocument String sParameters String sPath
75002>>>>>>>    Handle  hInstance hWnd
75002>>>>>>>    // remove any leading/trailing spaces in the string
75002>>>>>>>    Move (Trim(sDocument)) to sDocument
75003>>>>>>>    Move (Trim(sPath))     to sPath
75004>>>>>>>    // Make the strings readable for windows API, by converting them to null-terminated
75004>>>>>>>    Append sOperation   (Character(0))
75005>>>>>>>    Append sDocument    (Character(0))
75006>>>>>>>    Append sParameters  (Character(0))
75007>>>>>>>    Append sPath        (Character(0))
75008>>>>>>>
75008>>>>>>>    Get Window_Handle to hWnd
75009>>>>>>>    Move (vWin32_ShellExecute (hWnd, AddressOf(sOperation), AddressOf(sDocument), AddressOf(sParameters), AddressOf(sPath), 1)) to hInstance
75010>>>>>>>    If (hInstance <= 32) Begin
75012>>>>>>>        Send vDDE_Error_Handler hInstance
75013>>>>>>>    End
75013>>>>>>>>
75013>>>>>>>End_Procedure
75014>>>>>>>
75014>>>>>>>Class cShellFileOperations is a Array
75015>>>>>>>
75015>>>>>>>    Procedure Construct_Object
75017>>>>>>>        Forward Send Construct_Object
75019>>>>>>>        Property Integer piDeleteFlags        0
75020>>>>>>>        Property Integer piCopyFlags          0
75021>>>>>>>        Property Integer piMoveFlags          0
75022>>>>>>>        Property Integer piRenameFlags        0
75023>>>>>>>
75023>>>>>>>        Set piDeleteFlags to (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
75024>>>>>>>        Set piCopyFlags   to (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR Ior vFOF_NOCONFIRMATION)
75025>>>>>>>        Set piMoveFlags   to (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR iOr vFOF_NOCONFIRMATION)
75026>>>>>>>        Set piRenameFlags to (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
75027>>>>>>>    End_Procedure
75028>>>>>>>
75028>>>>>>>    // This function uses the shell API to perform a file operation on the
75028>>>>>>>    // files supplied.
75028>>>>>>>    //
75028>>>>>>>    Function FileOperation String sSource String sDestination Integer eOperation Integer iFlags Returns Integer
75030>>>>>>>        Integer  iRetVal
75030>>>>>>>        Integer  iUserAbort
75030>>>>>>>        tvShFileOpStruct FOS
75030>>>>>>>        tvShFileOpStruct FOS
75030>>>>>>>
75030>>>>>>>        Move (Utf8ToAnsi(sSource)+Character(0)+Character(0))      to sSource
75031>>>>>>>        Move (Utf8ToAnsi(sDestination)+Character(0)+Character(0)) to sDestination
75032>>>>>>>        If (eOperation <> vFO_DELETE) Begin
75034>>>>>>>            Move (AddressOf(sDestination)) to FOS.pTo
75035>>>>>>>        End
75035>>>>>>>>
75035>>>>>>>
75035>>>>>>>        Move eOperation           to FOS.wFunc
75036>>>>>>>        Move (AddressOf(sSource)) to FOS.pFrom
75037>>>>>>>        Move iFlags               to FOS.fFlags
75038>>>>>>>
75038>>>>>>>        Move (vWin32_SHFileOperation(AddressOf(FOS))) to iRetVal
75039>>>>>>>        Move FOS.fAnyOperationsAborted to iUserAbort
75040>>>>>>>        If (iUserAbort <> 0) Begin
75042>>>>>>>            Move 80 to iRetVal  // file Operation Aborted by USER
75043>>>>>>>        End
75043>>>>>>>>
75043>>>>>>>        Function_Return (iRetVal)
75044>>>>>>>    End_Function
75045>>>>>>>
75045>>>>>>>    Function sfoDeleteFile String sFileName Returns Integer
75047>>>>>>>        Integer  iRetVal
75047>>>>>>>        Integer  iFlags
75047>>>>>>>
75047>>>>>>>        Get piDeleteFlags to iFlags
75048>>>>>>>        Get FileOperation sFileName "" vFO_DELETE iFlags to iRetVal
75049>>>>>>>        Function_Return iRetVal
75050>>>>>>>    End_Function
75051>>>>>>>
75051>>>>>>>    Function sfoCopyFile String sSource String sDestination Returns Integer
75053>>>>>>>        Integer  iRetVal
75053>>>>>>>        Integer  iFlags
75053>>>>>>>
75053>>>>>>>        Get piCopyFlags to iFlags
75054>>>>>>>        Get FileOperation sSource sDestination vFO_COPY iFlags to iRetVal
75055>>>>>>>        Function_Return iRetVal
75056>>>>>>>    End_Function
75057>>>>>>>
75057>>>>>>>    Function sfoMoveFile String sSource String sDestination Returns Integer
75059>>>>>>>        Integer  iRetVal
75059>>>>>>>        Integer  iFlags
75059>>>>>>>
75059>>>>>>>        Get piMoveFlags to iFlags
75060>>>>>>>        Get FileOperation sSource sDestination vFO_MOVE iFlags to iRetVal
75061>>>>>>>        Function_Return iRetVal
75062>>>>>>>    End_Function
75063>>>>>>>
75063>>>>>>>    // Rename a file or folder
75063>>>>>>>    // Returns a nonzero value if the operation failed.
75063>>>>>>>    Function sfoRenameFile String sSource String sDestination Returns Integer
75065>>>>>>>        Integer  iRetVal
75065>>>>>>>        Integer  iFlags
75065>>>>>>>
75065>>>>>>>        Get piRenameFlags to iFlags
75066>>>>>>>        Get FileOperation sSource sDestination vFO_RENAME iFlags to iRetVal
75067>>>>>>>        Function_Return iRetVal
75068>>>>>>>    End_Function
75069>>>>>>>
75069>>>>>>>    // Courtesy Of Steve Walter
75069>>>>>>>    // Requires Windows 2000 and up according to msdn but it was
75069>>>>>>>    //  in fact available before that as an unpublished API call
75069>>>>>>>    //  a little google search shows that this was already available
75069>>>>>>>    //  in windows 95 and NT
75069>>>>>>>    //
75069>>>>>>>    // The format is controlled by the dialog interface.
75069>>>>>>>    // That is, the user must click the OK button To actually Begin the format
75069>>>>>>>    // the format cannot be started programmatically.
75069>>>>>>>    // An alternative to this functionality would be to use a controlpanel
75069>>>>>>>    //  http://www.vdf-guidance.com/ContribPage.asp?Page=PKGCLSDFCPLAPP&ContribRecId=93
75069>>>>>>>    //
75069>>>>>>>    // hWnd = The windows handle of the object from which the format Function
75069>>>>>>>    //        is called.
75069>>>>>>>    // To Get this,
75069>>>>>>>    //          use:  Get Window_Handle Of <object>
75069>>>>>>>    //          For instance, in this app, we're going to use the Report_Panel:
75069>>>>>>>    //                  Get Window_Handle Of (Report_Panel(Main(Self))) To hWind
75069>>>>>>>    //
75069>>>>>>>    // sDrive = The drive letter. At this moment only A and B are valid
75069>>>>>>>    //
75069>>>>>>>    // iOptions = Format options.
75069>>>>>>>    //  SHFMT_OPT_DEFAULT = Quick format
75069>>>>>>>    //  SHFMT_OPT_FULL    = Full Format
75069>>>>>>>    //  SHFMT_OPT_SYSONLY = System only
75069>>>>>>>    //  3                 = Full format with system. (unsupported)
75069>>>>>>>    //
75069>>>>>>>    // Return Values:
75069>>>>>>>    //  SHFMT_ERROR    = Error on format or no drive specified.
75069>>>>>>>    //  SHFMT_CANCEL   = Format cancelled by user.
75069>>>>>>>    //  SHFMT_NOFORMAT = Drive is not formatable.
75069>>>>>>>    //
75069>>>>>>>    //
75069>>>>>>>    // *** ATTENTION: This function has been disabled as it doesn't
75069>>>>>>>    //                seem to work, i must have made a silly mistake
75069>>>>>>>    //                somewhere.
75069>>>>>>>    //
75069>>>>>>>    Function sfoFormatDisk String sDrive Integer iOptions Returns DWord
75071>>>>>>>        Handle   hWnd
75071>>>>>>>        Integer  iObj
75071>>>>>>>        DWord    dwReturnVal
75071>>>>>>>        Integer iDrive
75071>>>>>>>
75071>>>>>>>        Function_Return 1 // STOP HERE
75072>>>>>>>
75072>>>>>>>        Move (Trim(sDrive)) to sDrive
75073>>>>>>>        If ( sDrive <> '' ) Begin
75075>>>>>>>            If ( sDrive Contains ':' ) Begin
75077>>>>>>>                Move (Replace(':',sDrive,'')) to sDrive
75078>>>>>>>            End
75078>>>>>>>>
75078>>>>>>>            If (Not( 'AB' Contains sDrive )) Begin
75080>>>>>>>                Function_Return (SHFMT_NOFORMAT)
75081>>>>>>>            End
75081>>>>>>>>
75081>>>>>>>            If ( sDrive = 'A' ) Begin
75083>>>>>>>                Move 0 to iDrive
75084>>>>>>>            End
75084>>>>>>>>
75084>>>>>>>            Else If ( sDrive = 'B' ) Begin
75087>>>>>>>                Move 1 to iDrive
75088>>>>>>>            End
75088>>>>>>>>
75088>>>>>>>            // Window_Handle Of Desktop equals to 0
75088>>>>>>>
75088>>>>>>>            Get focus of desktop to iObj
75089>>>>>>>            If (iObj>desktop) Begin
75091>>>>>>>                Get Container_Handle of iObj to hWnd
75092>>>>>>>            End
75092>>>>>>>>
75092>>>>>>>            While (hWnd=0 And iObj<>Desktop)
75096>>>>>>>                Get Parent of iObj to iObj
75097>>>>>>>                Get Container_Handle of iObj to hWnd
75098>>>>>>>            Loop
75099>>>>>>>>
75099>>>>>>>
75099>>>>>>>            //Showln "hWnd = " hWnd " iDrive " iDrive " iOptions " iOptions
75099>>>>>>>            Move (vWin32_ShFormatDrive(hWnd, iDrive, SHFMT_ID_DEFAULT, iOptions)) to dwReturnVal
75100>>>>>>>        End
75100>>>>>>>>
75100>>>>>>>        Else Begin
75101>>>>>>>            Move (SHFMT_ERROR) to dwReturnVal
75102>>>>>>>        End
75102>>>>>>>>
75102>>>>>>>        Function_Return dwReturnVal
75103>>>>>>>    End_Function
75104>>>>>>>
75104>>>>>>>    //Example:
75104>>>>>>>    // Get sfoFormatDisk 'A' 0 To dReturnVal    // Formats drive A in QuickFormat
75104>>>>>>>    //                                          mode.
75104>>>>>>>
75104>>>>>>>End_Class
75105>>>>>>>
75105>>>>>>>Object oShellFileOperations is a cShellFileOperations
75107>>>>>>>End_Object
75108>>>>>>>
75108>>>>>>>// Restore to the old way of working with the shell file operations.
75108>>>>>>>// or.. to put lay man terms, allow any of the operations vDeleteFile
75108>>>>>>>// vCopyFile/vMoveFile/vRenameFile to have an UNDO
75108>>>>>>>Procedure vWin32fhCompatibilityMode
75110>>>>>>>    Integer hoSFO
75110>>>>>>>    Integer iFlags
75110>>>>>>>
75110>>>>>>>    Move (vFOF_SILENT Ior vFOF_NOCONFIRMATION Ior vFOF_ALLOWUNDO) to iFlags
75111>>>>>>>    Move (oShellFileOperations(Self)) to hoSFO
75112>>>>>>>
75112>>>>>>>    Set piDeleteFlags of hoSFO to iFlags
75113>>>>>>>    Set piCopyFlags   of hoSFO to iFlags
75114>>>>>>>    Set piMoveFlags   of hoSFO to iFlags
75115>>>>>>>    Set piRenameFlags of hoSFO to iFlags
75116>>>>>>>End_Procedure
75117>>>>>>>
75117>>>>>>>// Delete a file or folder
75117>>>>>>>// Returns a nonzero value if the operation failed.
75117>>>>>>>Function vDeleteFile Global String sFileName Returns Integer
75119>>>>>>>    Integer  iRetVal
75119>>>>>>>
75119>>>>>>>    Get sfoDeleteFile of (oShellFileOperations(Self)) sFileName to iRetVal
75120>>>>>>>    Function_Return iRetVal
75121>>>>>>>End_Function
75122>>>>>>>
75122>>>>>>>// Copy a file or folder
75122>>>>>>>// Returns a nonzero value if the operation failed.
75122>>>>>>>Function vCopyFile Global String sSource String sDestination Returns Integer
75124>>>>>>>    Integer  iRetVal
75124>>>>>>>
75124>>>>>>>    Get sfoCopyFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
75125>>>>>>>    Function_Return iRetVal
75126>>>>>>>End_Function
75127>>>>>>>
75127>>>>>>>// Move a file or folder
75127>>>>>>>// Returns a nonzero value if the operation failed.
75127>>>>>>>Function vMoveFile Global String sSource String sDestination Returns Integer
75129>>>>>>>    Integer  iRetVal
75129>>>>>>>
75129>>>>>>>    Get sfoMoveFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
75130>>>>>>>    Function_Return iRetVal
75131>>>>>>>End_Function
75132>>>>>>>
75132>>>>>>>// Rename a file or folder
75132>>>>>>>// Returns a nonzero value if the operation failed.
75132>>>>>>>Function vRenameFile Global String sSource String sDestination Returns Integer
75134>>>>>>>    Integer  iRetVal
75134>>>>>>>
75134>>>>>>>    Get sfoRenameFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
75135>>>>>>>    Function_Return iRetVal
75136>>>>>>>End_Function
75137>>>>>>>
75137>>>>>>>Function vGetWindowsDirectory Returns String
75139>>>>>>>    String  sDirectory
75139>>>>>>>    Integer iVoid
75139>>>>>>>
75139>>>>>>>    Move (ZeroString(vMAX_PATH)) to sDirectory
75140>>>>>>>    Move (vWin32_GetWindowsDirectory(AddressOf(sDirectory), vMAX_PATH)) to iVoid
75141>>>>>>>    Function_Return (CString(sDirectory))
75142>>>>>>>End_Function
75143>>>>>>>
75143>>>>>>>Function vGetTempPath Returns String
75145>>>>>>>    Integer iRetval
75145>>>>>>>    String  sTempPath
75145>>>>>>>
75145>>>>>>>    Move (ZeroString(vMAX_PATH)) to sTempPath
75146>>>>>>>    Move (vWin32_GetTempPath (vMAX_PATH, AddressOf(sTempPath))) to iRetVal
75147>>>>>>>    Function_Return (Cstring(sTempPath))
75148>>>>>>>End_Function
75149>>>>>>>
75149>>>>>>>// Courtesy of Marco Kuipers
75149>>>>>>>Function vMakeTempFile Returns String
75151>>>>>>>    Integer iRetval
75151>>>>>>>    String  sTempPath
75151>>>>>>>    String  sTempFileName
75151>>>>>>>    String  sPrefixString
75151>>>>>>>
75151>>>>>>>    Get vGetTempPath to sTempPath
75152>>>>>>>    If (sTempPath = "") Begin
75154>>>>>>>        Get vGetWindowsDirectory to sTempPath  // first fallback
75155>>>>>>>        If (sTempPath<>"") Begin
75157>>>>>>>            Move (sTempPath+"\Temp\") to sTempPath
75158>>>>>>>        End
75158>>>>>>>>
75158>>>>>>>    End
75158>>>>>>>>
75158>>>>>>>
75158>>>>>>>    If (sTempPath = "") Begin
75160>>>>>>>    // second fallback we really do not want to get here as to be fair using current folder as temp
75160>>>>>>>    // makes little sense. Leaving this in as it was old behavior.
75160>>>>>>>        Get_Current_Directory to sTempPath
75161>>>>>>>    End
75161>>>>>>>>
75161>>>>>>>
75161>>>>>>>    Move (Trim(sTempPath)+Character(0)) to sTempPath
75162>>>>>>>    If (Length(sTempPath)>(vMax_Path-14)) Begin
75164>>>>>>>        Error DFERR_PROGRAM ("Temporary path"+sTempPath+"is too long, cannot create temporary files.")
75165>>>>>>>>
75165>>>>>>>    End
75165>>>>>>>>
75165>>>>>>>
75165>>>>>>>    Move (ZeroString(vMax_Path)) to sTempFileName
75166>>>>>>>    Move ("tmp"+Character(0)) to sPrefixString // **WvA: 28-04-2005 Added a null
75167>>>>>>>    Move (vWin32_GetTempFileName (AddressOf(sTempPath), AddressOf(sPrefixString), 0, AddressOf(sTempFileName))) to iRetval
75168>>>>>>>    If (iRetval = 0) Begin  // **WvA: 28-04-2005 Changed condition, the api call returns 0 if an error occurs
75170>>>>>>>    //Get ShowLastError to iRetval
75170>>>>>>>        Move "" to sTempFileName
75171>>>>>>>    End
75171>>>>>>>>
75171>>>>>>>
75171>>>>>>>    Function_Return (Cstring(sTempFileName)) // **WvA: 28-04-2005 Cstring added
75172>>>>>>>End_Function
75173>>>>>>>
75173>>>>>>>// This function creates a uniquely named temporary file in folder sPath
75173>>>>>>>// The file created will have a prefix based on the first 3 characters in sPrefix
75173>>>>>>>// Note that you will have to cleanup the tempfile yourself as the function
75173>>>>>>>// does not take care of that.
75173>>>>>>>Function vCreateTempFileInPath String sPath String sPrefix Returns String
75175>>>>>>>    Integer iRetVal
75175>>>>>>>    String sTempFileName
75175>>>>>>>
75175>>>>>>>    Move (Utf8ToAnsi(sPath)+Character(0))   to sPath
75176>>>>>>>    Move (Utf8ToAnsi(sPrefix)+Character(0)) to sPrefix
75177>>>>>>>    Move (Pad("", vMAX_PATH)) to sTempFileName
75178>>>>>>>
75178>>>>>>>    Move (vWin32_GetTempFileName(AddressOf(sPath), AddressOf(sPrefix), 0, AddressOf(sTempFileName))) to iRetVal
75179>>>>>>>    Move (Trim(Cstring(sTempFileName))) to sTempFileName
75180>>>>>>>    Function_Return sTempFileName
75181>>>>>>>End_Function
75182>>>>>>>
75182>>>>>>>//
75182>>>>>>>// Get a specific shell folder for example to get the desktop folder
75182>>>>>>>// simply call this function and pass it vCSIDL_DESKTOP
75182>>>>>>>//
75182>>>>>>>Function vSHGetFolderPath Integer eFolder Returns String
75184>>>>>>>    String  sFolder
75184>>>>>>>    Integer iVoid
75184>>>>>>>    Handle  hWnd
75184>>>>>>>
75184>>>>>>>    Move (Window_Handle(focus(desktop))) to hWnd
75185>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
75186>>>>>>>    Move (vWin32_SHGetFolderPath(hWnd,eFolder, 0, 0,AddressOf(sFolder))) to iVoid
75187>>>>>>>    Function_Return (CString(sFolder))
75188>>>>>>>End_Function
75189>>>>>>>
75189>>>>>>>// Courtesy Of Vincent Oorsprong
75189>>>>>>>Function vConvertFileDateTime Global DWord dwLowDateTime DWord dwHighDateTime Returns String
75191>>>>>>>    String  sFormattedTime sFormattedDate
75191>>>>>>>    String  sFileDateTime
75191>>>>>>>    Integer iSuccess iLenCcTime iDataLength iLenCcDate
75191>>>>>>>    tvFileTime   FileTime
75191>>>>>>>    tvFileTime   FileTime
75191>>>>>>>    tvSystemTime SystemTime
75191>>>>>>>    tvSystemTime SystemTime
75191>>>>>>>
75191>>>>>>>    Move "" to sFileDateTime
75192>>>>>>>    Move dwLowDateTime  to FileTime.dwLowDateTime
75193>>>>>>>    Move dwHighDateTime to FileTime.dwHighDateTime
75194>>>>>>>
75194>>>>>>>    Move 0 to SystemTime.wYear
75195>>>>>>>
75195>>>>>>>    Move (vWin32_FileTimeToSystemTime (AddressOf(FileTime), AddressOf(SystemTime))) to iSuccess
75196>>>>>>>    If (iSuccess = 1) Begin
75198>>>>>>>        Move (ZeroString(255))        to sFormattedTime
75199>>>>>>>        Move (Length(sFormattedTime)) to iLenCcTime
75200>>>>>>>        Move (vWin32_GetTimeFormat (LOCALE_USER_DEFAULT, 0, AddressOf(SystemTime), 0, AddressOf(sFormattedTime), iLenCcTime)) to iDataLength
75201>>>>>>>        Move (ZeroString(255))        to sFormattedDate
75202>>>>>>>        Move (Length(sFormattedDate)) to iLenCcDate
75203>>>>>>>        Move (vWin32_GetDateFormat (LOCALE_USER_DEFAULT, 0, AddressOf(SystemTime), 0, AddressOf(sFormattedDate), iLenCcDate)) to iDataLength
75204>>>>>>>        Move (Cstring (sFormattedDate)  * Cstring (sFormattedTime)) to sFileDateTime
75205>>>>>>>    End
75205>>>>>>>>
75205>>>>>>>    Function_Return sFileDateTime
75206>>>>>>>End_Function
75207>>>>>>>
75207>>>>>>>// **WvA:
75207>>>>>>>// A windows replacement for the standard function FileExists.
75207>>>>>>>// This version will also return (true) for a file when it is open by an application.
75207>>>>>>>// Note that you can apply normal windows mask-signs in the filename such as * and ?
75207>>>>>>>// Example: Get vFilePathExists "C:\config.sy?"
75207>>>>>>>// This will return true if you have a file matching these conditions. (aka config.sys)
75207>>>>>>>Function vFilePathExists Global String sFilePathMask Returns Integer
75209>>>>>>>    String  sDirSep
75209>>>>>>>    Handle  hFindFile
75209>>>>>>>    Integer iVoid
75209>>>>>>>    tvWin32FindData FindData
75209>>>>>>>    tvWin32FindData FindData
75209>>>>>>>
75209>>>>>>>    Move vINVALID_HANDLE_VALUE to hFindFile
75210>>>>>>>    Move (Utf8ToANSI(Trim(sFilePathMask))) to sFilePathMask
75211>>>>>>>    If (Length(sFilePathMask)>0) Begin
75213>>>>>>>    // 2014-09-29 NGS Remove any trailing dir separators, as they make the function fail.
75213>>>>>>>        Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep
75214>>>>>>>        While (Right(sFilePathMask, 1) = sDirSep)
75218>>>>>>>            Move (Left(sFilePathMask, Length(sFilePathMask) -1)) to sFilePathMask
75219>>>>>>>        Loop
75220>>>>>>>>
75220>>>>>>>
75220>>>>>>>        Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
75221>>>>>>>        Move (vWin32_FindFirstFile (AddressOf(sFilePathMask), AddressOf(FindData))) to hFindFile
75222>>>>>>>        Move (vWin32_FindClose (hFindFile)) to iVoid
75223>>>>>>>    End
75223>>>>>>>>
75223>>>>>>>    Function_Return (hFindFile <> vINVALID_HANDLE_VALUE)
75224>>>>>>>End_Function
75225>>>>>>>
75225>>>>>>>//
75225>>>>>>>// WideChar version of the function, do not use, it's an experiment
75225>>>>>>>//
75225>>>>>>>Function vWFilePathExists Global String sFilePathMask Returns Integer
75227>>>>>>>    Handle  hFindFile
75227>>>>>>>    Integer iVoid
75227>>>>>>>    tvWin32FindData FindData
75227>>>>>>>    tvWin32FindData FindData
75227>>>>>>>
75227>>>>>>>    Move vINVALID_HANDLE_VALUE to hFindFile
75228>>>>>>>
75228>>>>>>>    If (Length(sFilePathMask)>0) Begin
75230>>>>>>>
75230>>>>>>>        Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
75231>>>>>>>        Move (vWin32W_FindFirstFile (AddressOf(sFilePathMask), AddressOf(FindData))) to hFindFile
75232>>>>>>>        Move (vWin32_FindClose (hFindFile)) to iVoid
75233>>>>>>>    End
75233>>>>>>>>
75233>>>>>>>    Function_Return (hFindFile <> vINVALID_HANDLE_VALUE)
75234>>>>>>>End_Function
75235>>>>>>>
75235>>>>>>>// **WvA
75235>>>>>>>// Formats a foldername by first trimming it and after that by sticking a
75235>>>>>>>// directory separator (/\) to the end if it doesn't have one there already.
75235>>>>>>>// The folder may contain a drive letter or UNC encoding.
75235>>>>>>>Function vFolderFormat Global String sFolderName Returns String
75237>>>>>>>    String sDirSep
75237>>>>>>>    Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep  // normally \ (backslash)
75238>>>>>>>    Move (Trim(sFolderName)) to sFolderName
75239>>>>>>>    If (Right(sFolderName,1)<>sDirSep) Begin
75241>>>>>>>        Move (sFolderName+sDirSep) to sFolderName
75242>>>>>>>    End
75242>>>>>>>>
75242>>>>>>>    Function_Return sFolderName
75243>>>>>>>End_Function
75244>>>>>>>
75244>>>>>>>//
75244>>>>>>>// Returns the amount of files in the folder (if it exists)
75244>>>>>>>// Returns -1 if folder doesn't exist.
75244>>>>>>>// The files "." and ".." are not counted.
75244>>>>>>>//
75244>>>>>>>Function vFolderFileCount Global String sFolderName Returns Integer
75246>>>>>>>    Boolean bFound
75246>>>>>>>    Handle  hFindFile
75246>>>>>>>    Integer iCount  iVoid
75246>>>>>>>    Integer iSuccess
75246>>>>>>>    String  sFileName
75246>>>>>>>    tvWin32FindData FindData
75246>>>>>>>    tvWin32FindData FindData
75246>>>>>>>
75246>>>>>>>    Move -1 to iCount
75247>>>>>>>    Get vFolderFormat sFolderName to sFolderName
75248>>>>>>>    Move (sFolderName+"*") to sFolderName // match any filename in the folder
75249>>>>>>>    Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
75250>>>>>>>    Move (vWin32_FindFirstFile (AddressOf(sFolderName), AddressOf(FindData))) to hFindFile
75251>>>>>>>    Move (hFindFile<>vINVALID_HANDLE_VALUE) to bFound
75252>>>>>>>    If (bFound) Begin
75254>>>>>>>        Move 0 to iCount
75255>>>>>>>    End
75255>>>>>>>>
75255>>>>>>>    While (bFound)
75259>>>>>>>        Increment iCount
75260>>>>>>>        Move (UCharArrayToString(FindData.cFileName)) to sFileName
75261>>>>>>>        If (sFileName="." or sFileName="..") Begin
75263>>>>>>>            Decrement iCount
75264>>>>>>>        End
75264>>>>>>>>
75264>>>>>>>        Move (vWin32_FindNextFile(hFindFile, AddressOf(FindData))) to iSuccess
75265>>>>>>>        Move (iSuccess<>0) to bFound
75266>>>>>>>    Loop
75267>>>>>>>>
75267>>>>>>>    Move (vWin32_FindClose (hFindFile)) to iVoid
75268>>>>>>>    Function_Return iCount
75269>>>>>>>End_Function
75270>>>>>>>
75270>>>>>>>//
75270>>>>>>>// Gets the parent path of the currently supplied path
75270>>>>>>>// Returns "" when we are at the root folder.
75270>>>>>>>//
75270>>>>>>>Function vParentPath Global String sPath Returns String
75272>>>>>>>    String sStrip sDirSep
75272>>>>>>>
75272>>>>>>>    Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
75273>>>>>>>    Move (Trim(sPath)) to sPath
75274>>>>>>>    If (Right(sPath,1) = sDirSep) Begin
75276>>>>>>>        Move (Left(sPath,Length(sPath)-1)) to sPath
75277>>>>>>>    End
75277>>>>>>>>
75277>>>>>>>    If (Pos(sDirSep, sPath)) Begin
75279>>>>>>>        Move (StringFromRightOfChar(sPath, sDirSep)) to sStrip
75280>>>>>>>        Move (Left(sPath,Length(sPath)-Length(sStrip))) to sPath
75281>>>>>>>    End
75281>>>>>>>>
75281>>>>>>>    Else Begin
75282>>>>>>>        Move "" to sPath
75283>>>>>>>    End
75283>>>>>>>>
75283>>>>>>>    Function_Return sPath
75284>>>>>>>End_Function
75285>>>>>>>
75285>>>>>>>// Create the folder, including intermediate directories.
75285>>>>>>>// Don't panic if the folder already exists.
75285>>>>>>>// Michael Mullan June 2009.
75285>>>>>>>Function vshCreateDirectoryEX Global String sNewFolder Returns Integer
75287>>>>>>>    String  sFolder
75287>>>>>>>    Integer iRetval iFolderCreated
75287>>>>>>>    tvSecurity_attributes SA
75287>>>>>>>    tvSecurity_attributes SA
75287>>>>>>>
75287>>>>>>>    Move 0 to iFolderCreated
75288>>>>>>>
75288>>>>>>>    // null MAX_PATH chars into var (make space)
75288>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
75289>>>>>>>    If (sNewFolder <> "") Begin
75291>>>>>>>
75291>>>>>>>        Move (SizeOfType(tvSecurity_attributes)) to SA.nLength
75292>>>>>>>        Move  0  to SA.lpDescriptor
75293>>>>>>>        Move  1  to SA.bInheritHandle
75294>>>>>>>
75294>>>>>>>        //
75294>>>>>>>        Move (sNewFolder+"") to sFolder
75295>>>>>>>        Move (vWin32_SHCreateDirectoryEx(0,AddressOf(sFolder), AddressOf(SA))) to iFolderCreated
75296>>>>>>>    End
75296>>>>>>>>
75296>>>>>>>
75296>>>>>>>    If (iFolderCreated <> 0) Begin
75298>>>>>>>        Move 1 to iRetVal
75299>>>>>>>        Case Begin
75299>>>>>>>            Case (iFolderCreated = 161)
75301>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_BAD_PATHNAME)")
75302>>>>>>>>
75302>>>>>>>                Case Break
75303>>>>>>>            Case (iFolderCreated = 206)
75306>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_FILENAME_EXCED_RANGE)")
75307>>>>>>>>
75307>>>>>>>                Case Break
75308>>>>>>>            Case (iFolderCreated = 3)
75311>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_PATH_NOT_FOUND)")
75312>>>>>>>>
75312>>>>>>>                Case Break
75313>>>>>>>            Case (iFolderCreated = 80)
75316>>>>>>>                Move 0 to iRetval // "ERROR_FILE_EXISTS"     not really an error
75317>>>>>>>                Case Break
75318>>>>>>>            Case (iFolderCreated = 183)
75321>>>>>>>                Move 0 to iRetval //  "ERROR_ALREADY_EXISTS"     not really an error
75322>>>>>>>                Case Break
75323>>>>>>>            Case (iFolderCreated = 1223)
75326>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_CANCELLED)")
75327>>>>>>>>
75327>>>>>>>                Case Break
75328>>>>>>>            Case Else
75328>>>>>>>                Error DFERR_OPERATOR ("Folder Creation Error # " + String(ifoldercreated) + "\n" + sNewFolder + "(FILE_CREATION_ERROR)")
75329>>>>>>>>
75329>>>>>>>        Case End
75329>>>>>>>    End
75329>>>>>>>>
75329>>>>>>>    Function_Return iRetVal
75330>>>>>>>End_Function
75331>>>>>>>
75331>>>>>>>Function vWin32_APIFileSize Global String sFileName Returns Integer
75333>>>>>>>    DWord   dwFileSizeHigh dwFileSizeLow
75333>>>>>>>    Integer iFileSize iVoid
75333>>>>>>>    Handle  hFindFile
75333>>>>>>>    tvWin32FindData FindData
75333>>>>>>>    tvWin32FindData FindData
75333>>>>>>>
75333>>>>>>>    Move (sFileName+"") to sFileName
75334>>>>>>>    Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
75335>>>>>>>    Move (vWin32_FindFirstFile (AddressOf(sFileName), AddressOf(FindData))) to hFindFile
75336>>>>>>>    If (hFindFile<>vINVALID_HANDLE_VALUE) Begin
75338>>>>>>>        Move FindData.nFileSizeHigh to dwFileSizeHigh
75339>>>>>>>        Move FindData.nFileSizeLow  to dwFileSizeLow
75340>>>>>>>    End
75340>>>>>>>>
75340>>>>>>>    Move (vWin32_FindClose (hFindFile)) to iVoid
75341>>>>>>>    Move ((dwFileSizeHigh * vMaxDword) + dwFileSizeLow) to iFileSize
75342>>>>>>>
75342>>>>>>>    Function_Return iFileSize
75343>>>>>>>End_Function
75344>>>>>>>
75344>>>>>>>//
75344>>>>>>>// Based on code in Peter Crook's Browse folder workspace
75344>>>>>>>// http://support.dataaccess.com/Forums/showthread.php?54383-Browse-for-Folder-package&p=282249#post282249
75344>>>>>>>//
75344>>>>>>>//=============================================================================
75344>>>>>>>// Verifies that a path is a valid directory.
75344>>>>>>>//
75344>>>>>>>// Returns TRUE if the path is a valid directory, or FALSE otherwise.
75344>>>>>>>//
75344>>>>>>>// Parameters:
75344>>>>>>>//      sPath - Address of the path to verify.
75344>>>>>>>//=============================================================================
75344>>>>>>>Function vPathIsDirectory Global String sPath Returns Boolean
75346>>>>>>>    Integer iResult
75346>>>>>>>    Boolean bRetVal
75346>>>>>>>
75346>>>>>>>    Move false to bRetVal
75347>>>>>>>    Move (Utf8ToAnsi(sPath) - Character (0)) to sPath
75348>>>>>>>    Move (vWin32_PathIsDirectory (AddressOf (sPath))) to iResult
75349>>>>>>>    If (iResult<>0) Begin
75351>>>>>>>        Move True to bRetVal
75352>>>>>>>    End
75352>>>>>>>>
75352>>>>>>>
75352>>>>>>>    Function_Return bRetVal
75353>>>>>>>End_Function
75354>>>>>>>
75354>>>>>Use DUFLanguageConstants.inc
75354>>>>>
75354>>>>>Define CS_IntFilesTableRootName for "IntFilesTable"
75354>>>>>Define CS_FilelistZipFile       for "FilelistBackupFile.zip"
75354>>>>>Define CS_FilelistBackupFile    for "FilelistBackupFile.cfg"
75354>>>>>
75354>>>>>Struct tDUFIntFile
75354>>>>>    Integer iID
75354>>>>>    String sIntFileName
75354>>>>>    String sIntLineText
75354>>>>>End_Struct
75354>>>>>
75354>>>>>Struct tDbVersionInfo
75354>>>>>    Number nVersionNumber
75354>>>>>    Handle hObject
75354>>>>>End_Struct
75354>>>>>
75354>>>>>Struct tDbUpdateError
75354>>>>>    Number nUpdateVersion
75354>>>>>    Integer iError
75354>>>>>    String  sOrgErrorText
75354>>>>>    String  sErrorText
75354>>>>>    Integer iErrorLine
75354>>>>>    Boolean bError  
75354>>>>>    Handle  hTable 
75354>>>>>    String  sTableRootName
75354>>>>>    Integer iField
75354>>>>>    Boolean bShortFormat
75354>>>>>End_Struct
75354>>>>>
75354>>>>>//  DF_FILE_ALIAS_DEFAULT if no master or alias
75354>>>>>//  DF_FILE_IS_MASTER if master
75354>>>>>//  DF_FILE_IS_ALIAS if alias
75354>>>>>Struct tDbUpdateHandlerMasterAlias
75354>>>>>    Handle hTable
75354>>>>>    Integer iMode
75354>>>>>End_Struct
75354>>>>>
75354>>>>>// Used as a start for error handing. Used by Error_Report_Mode property
75354>>>>>Enumeration_List
75354>>>>>    Define DUF_ERROR_REPORT    // Report Error on screen
75354>>>>>    Define DUF_ERROR_NO_REPORT // Show no Error..
75354>>>>>End_Enumeration_List
75354>>>>>
75354>>>>>    Define DATAFLEX_ID for "DATAFLEX"
75354>>>>>
75354>>>>>// Global handle to a cDatabaseUpdateHandler object that can be used to
75354>>>>>// communicate with the object from anywhere in a program.
75354>>>>>    Global_Variable Handle ghoDbUpdateHandler
75354>>>>>    Move 0 to ghoDbUpdateHandler
75355>>>>>
75355>>>>>// NOTE: If the DbVersion table should _not_ be used and you
75355>>>>>// instead set the "Set Data_File_Field to (RefTable(MyTable)) (RefTable(MyTable.DbUpdateVersion))"
75355>>>>>// in the cDbUpdateHandler object; Add a "Define DUF_Use_DbVersion" to your code,
75355>>>>>// _before_ the "Use cDbUpdateHandler.pkg" line.
75355>>>>>//#IFNDEF DUF_Use_Custom_DbVersion
75355>>>>>//    Declare_Datafile DbVersion
75355>>>>>//#ENDIF
75355>>>Use cDbUpdateLogFile.pkg
Including file: cDbUpdateLogFile.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateLogFile.pkg)
75355>>>>>//****************************************************************************
75355>>>>>// $Module type: Class
75355>>>>>// $Module name: cDbUpdateLogFile
75355>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
75355>>>>>// Web-site    : http://www.rdctools.com
75355>>>>>// Created     : 2016-10-05 @ 18:58 (Military date format: YY-MM-DD)
75355>>>>>//
75355>>>>>// Description : This logic was moved from the cDbUpdateHandler class so that it would
75355>>>>>//               be easier to change to where errors/status messages are written/saved. As it is less likely
75355>>>>>//               that this class is to change; each developer can decide if the errors instead
75355>>>>>//               should be saved to a database table, or something entirely different.
75355>>>>>//               The default is to write the errors to a Ascii-file in the Data folder.
75355>>>>>//
75355>>>>>// $Rev History:
75355>>>>>//    2016-10-05  Module header created
75355>>>>>//****************************************************************************
75355>>>>>Use UI
75355>>>>>Use vWin32fh.pkg
75355>>>>>
75355>>>>>
75355>>>>>    Define CS_DatabaseUpdateFramework for " ***  The Database Update Framework (DUF) ***"
75355>>>>>
75355>>>>>Define CS_SuccessfulUpdate for "The database was updated successfully!"
75355>>>>>
75355>>>>>Class cDbUpdateLogFile is a cObject
75356>>>>>
75356>>>>>    Procedure Construct_Object
75358>>>>>        Forward Send Construct_Object
75360>>>>>
75360>>>>>        // Error handling:
75360>>>>>        Property tDbUpdateError[] paDbUpdateErrorArray
75361>>>>>        Property Integer piChannel -1
75362>>>>>
75362>>>>>        // This property is set by the cDbUpdateHandler object,
75362>>>>>        // when the update process starts.
75362>>>>>        Property DateTime pdtUpdateStart
75363>>>>>
75363>>>>>        // Gets set to False if the log contains data
75363>>>>>        Property Boolean pbEmptyLogFile True
75364>>>>>
75364>>>>>        // Gets set to True after the error log header text
75364>>>>>        // has been written.
75364>>>>>        Property Boolean pbHeaderWritten False
75365>>>>>
75365>>>>>        // If all activities should be logged- not just errors.
75365>>>>>        Property Boolean pbVerboseState False
75366>>>>>
75366>>>>>        // File name for the error log where all errors
75366>>>>>        // after a run is written to (appended).
75366>>>>>        // It is saved in the Data folder.
75366>>>>>        Property String psLogTextFile   "DUFUpdateLog.txt"
75367>>>>>        // If this property is set to "" in object code, the
75367>>>>>        // "shell" command parameter will be used to let Windows decide
75367>>>>>        // with which program to open the logfile.
75367>>>>>        Property String psEditorProgram ""
75368>>>>>
75368>>>>>        Property Boolean pbUseDataTableLog False
75369>>>>>
75369>>>>>        // If true an error will be written to file immediately when
75369>>>>>        // it occurs. This can be handy if a large update generates a lots
75369>>>>>        // of errors and the application crasches before finished, thus
75369>>>>>        // the errors will not be written.
75369>>>>>        Property Boolean pbQuickWrite True
75370>>>>>    End_Procedure
75371>>>>>
75371>>>>>    Procedure End_Construct_Object
75373>>>>>        Forward Send End_Construct_Object
75375>>>>>
75375>>>>>    End_Procedure
75376>>>>>
75376>>>>>    Procedure LogError Number nVersion Integer iError String sErrorText Integer iErrorLine Boolean bError Boolean bShortFormatIn
75378>>>>>        tDbUpdateError[] DbUpdateErrorArray DbUpdateErrorArrayEmpty
75378>>>>>        tDbUpdateError[] DbUpdateErrorArray DbUpdateErrorArrayEmpty
75380>>>>>        Boolean bShortFormat
75380>>>>>        Integer iSize
75380>>>>>        Handle hCurrentTable
75380>>>>>        Integer iCurrentField           
75380>>>>>        String sOrgErrorText sTableRootName
75380>>>>>        
75380>>>>>        Move False to bShortFormat
75381>>>>>        If (num_arguments > 5) Begin
75383>>>>>            Move bShortFormatIn to bShortFormat
75384>>>>>        End
75384>>>>>>
75384>>>>>        // Only do once.
75384>>>>>        If (pbHeaderWritten(Self) = False) Begin
75386>>>>>            Send WriteHeaderData
75387>>>>>            Set pbHeaderWritten to True
75388>>>>>        End
75388>>>>>>
75388>>>>>
75388>>>>>        Get Private.phCurrentTable to hCurrentTable  
75389>>>>>        Get Private.piCurrentField to iCurrentField  
75390>>>>>        If (iError > 0) Begin
75392>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hCurrentTable to sTableRootName
75395>>>>>            Get FetchErrorDescription iError to sOrgErrorText 
75396>>>>>        End
75396>>>>>>
75396>>>>>        Get paDbUpdateErrorArray to DbUpdateErrorArray
75397>>>>>        Move (SizeOfArray(DbUpdateErrorArray)) to iSize
75398>>>>>        Move nVersion       to DbUpdateErrorArray[iSize].nUpdateVersion
75399>>>>>        Move iError         to DbUpdateErrorArray[iSize].iError
75400>>>>>        Move iErrorLine     to DbUpdateErrorArray[iSize].iErrorLine
75401>>>>>        Move True           to DbUpdateErrorArray[iSize].bError  
75402>>>>>        Move sOrgErrorText  to DbUpdateErrorArray[iSize].sOrgErrorText
75403>>>>>        Move sErrorText     to DbUpdateErrorArray[iSize].sErrorText
75404>>>>>        Move hCurrentTable  to DbUpdateErrorArray[iSize].hTable            
75405>>>>>        Move sTableRootName to DbUpdateErrorArray[iSize].sTableRootName
75406>>>>>        Move iCurrentField  to DbUpdateErrorArray[iSize].iField  
75407>>>>>        Move bShortFormat   to DbUpdateErrorArray[iSize].bShortFormat
75408>>>>>
75408>>>>>        If (bError = False) Begin
75410>>>>>            Move False to DbUpdateErrorArray[iSize].bError
75411>>>>>        End
75411>>>>>>
75411>>>>>        Set paDbUpdateErrorArray to DbUpdateErrorArray
75412>>>>>
75412>>>>>        If (pbUseDataTableLog(Self) = True) Begin
75414>>>>>            If (pbQuickWrite(Self) = True) Begin
75416>>>>>                Send OnWriteRow_DataTable
75417>>>>>                // If we are writing error for error flush the
75417>>>>>                // error array when latest error has been written.
75417>>>>>                Set paDbUpdateErrorArray to DbUpdateErrorArrayEmpty
75418>>>>>            End
75418>>>>>>
75418>>>>>            Procedure_Return
75419>>>>>        End
75419>>>>>>
75419>>>>>        Else Begin
75420>>>>>            If (pbQuickWrite(Self) = True) Begin
75422>>>>>                Send WriteErrorLog
75423>>>>>                // Flush the error log array
75423>>>>>                Set paDbUpdateErrorArray to DbUpdateErrorArrayEmpty
75424>>>>>            End
75424>>>>>>
75424>>>>>        End
75424>>>>>>
75424>>>>>    End_Procedure   
75425>>>>>    
75425>>>>>    Function FetchErrorDescription Integer iError Returns String
75427>>>>>        String sErrorText         
75427>>>>>        Move "" to sErrorText
75428>>>>>        If (iError > 0) Begin
75430>>>>>            Move (Error_Text(Desktop, iError)) to sErrorText 
75431>>>>>        End
75431>>>>>>
75431>>>>>        Function_Return sErrorText
75432>>>>>    End_Function
75433>>>>>
75433>>>>>    // Hook procedure for writing header text prior starting the update work to
75433>>>>>    // a database table. This does nothing by default.
75433>>>>>    // Don't forget to Open your "error log table" first (!) as all
75433>>>>>    // tables have been closed at this stage. Put anything
75433>>>>>    // you want to indicate that the update process is just started.
75433>>>>>    Procedure OnWriteHeader_DataTable DateTime dtUpdateStart
75435>>>>>        Delegate Send OnErrorWriteHeader_DataTable dtUpdateStart
75437>>>>>    End_Procedure
75438>>>>>
75438>>>>>    Procedure OnWriteRow_DataTable
75440>>>>>        tDbUpdateError[] DbUpdateErrorArray
75440>>>>>        tDbUpdateError[] DbUpdateErrorArray
75441>>>>>        Get paDbUpdateErrorArray to DbUpdateErrorArray
75442>>>>>        If (SizeOfArray(DbUpdateErrorArray) > 0) Begin
75444>>>>>            Delegate Send OnErrorWriteRow_DataTable DbUpdateErrorArray
75446>>>>>        End
75446>>>>>>
75446>>>>>    End_Procedure
75447>>>>>
75447>>>>>    Function psLogTextFileWithPath Returns String
75449>>>>>        String sPath sFileName sFullFileName
75449>>>>>        
75449>>>>>        Get psDataPathFirstPart to sPath
75450>>>>>        Get psLogTextFile to sFileName
75451>>>>>        Move (sPath + sFileName) to sFullFileName
75452>>>>>        Function_Return sFullFileName
75453>>>>>    End_Function                     
75454>>>>>    
75454>>>>>    Procedure WriteHeaderData
75456>>>>>        String sFileName
75456>>>>>        Integer iCh iSize
75456>>>>>        Boolean bQuickWrite
75456>>>>>        DateTime dtUpdateStart
75456>>>>>
75456>>>>>        Move (CurrentDateTime()) to dtUpdateStart
75457>>>>>        If (pbUseDataTableLog(Self) = True) Begin
75459>>>>>            Send OnWriteHeader_DataTable dtUpdateStart
75460>>>>>            Procedure_Return
75461>>>>>        End
75461>>>>>>
75461>>>>>
75461>>>>>        Get piChannel to iCh
75462>>>>>        If (iCh < 0) Begin
75464>>>>>            Get Seq_New_Channel to iCh
75465>>>>>            If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
75467>>>>>                Error DFERR_PROGRAM "No free channel for writing output!"
75468>>>>>>
75468>>>>>                Procedure_Return
75469>>>>>            End
75469>>>>>>
75469>>>>>            Set piChannel to iCh
75470>>>>>        End
75470>>>>>>
75470>>>>>
75470>>>>>        Get psLogTextFileWithPath to sFileName
75471>>>>>        Get vWin32_APIFileSize sFileName to iSize
75472>>>>>        Get pbQuickWrite to bQuickWrite
75473>>>>>        
75473>>>>>        If (bQuickWrite = True) Begin
75475>>>>>            Append_Output channel iCh sFileName
75477>>>>>                If (bQuickWrite = True) Begin
75479>>>>>                    If (iSize = 0) Begin
75481>>>>>                        Writeln channel iCh CS_DatabaseUpdateFramework
75484>>>>>                        Set pbEmptyLogFile to False
75485>>>>>                    End
75485>>>>>>
75485>>>>>                    Writeln channel iCh
75487>>>>>                    Writeln channel iCh ("Database Update Started:      " + String(dtUpdateStart))
75490>>>>>                End
75490>>>>>>
75490>>>>>            Close_Output channel iCh
75492>>>>>        End
75492>>>>>>
75492>>>>>    End_Procedure
75493>>>>>
75493>>>>>    // Returns the first datapath found in the psDataPath property.
75493>>>>>    // The returned path always ends with a "\"
75493>>>>>    Function psDataPathFirstPart Returns String
75495>>>>>        String sDataPath
75495>>>>>        Integer iCount
75495>>>>>
75495>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
75496>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
75497>>>>>        If (iCount > 1) Begin
75499>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
75500>>>>>        End
75500>>>>>>
75500>>>>>        If (sDataPath <> "") Begin
75502>>>>>            Get vFolderFormat sDataPath to sDataPath
75503>>>>>        End
75503>>>>>>
75503>>>>>
75503>>>>>        Function_Return sDataPath
75504>>>>>    End_Function
75505>>>>>
75505>>>>>    // Called from the cDbUpdateHandler object after all updates have been done.
75505>>>>>    Procedure WriteErrorLog
75507>>>>>        tDbUpdateError[] aDbUpdateErrorArray
75507>>>>>        tDbUpdateError[] aDbUpdateErrorArray
75508>>>>>        String sFileName sErrorNo sVersion sErrorText sText sRootName sOrgErrorText
75508>>>>>        Integer iCount iSize iCh iError iErrorLine iField
75508>>>>>        Boolean bUseDataTable bQuickWrite
75508>>>>>        DateTime dtUpdateStart dtUpdateEnd
75508>>>>>        TimeSpan tsElapsed
75508>>>>>        Number nVersion                                  
75508>>>>>        Handle hTable
75508>>>>>
75508>>>>>        If (pbHeaderWritten(Self) = False) Begin
75510>>>>>            Send WriteHeaderData
75511>>>>>            Set pbHeaderWritten to True
75512>>>>>        End
75512>>>>>>
75512>>>>>
75512>>>>>        Get pbUseDataTableLog to bUseDataTable
75513>>>>>        If (bUseDataTable = True) Begin
75515>>>>>            Send OnWriteRow_DataTable
75516>>>>>            Procedure_Return
75517>>>>>        End
75517>>>>>>
75517>>>>>
75517>>>>>        Get piChannel to iCh
75518>>>>>        If (iCh < 0) Begin
75520>>>>>            Get Seq_New_Channel to iCh
75521>>>>>            If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
75523>>>>>                Error DFERR_PROGRAM "No free channel for writing output!"
75524>>>>>>
75524>>>>>                Procedure_Return
75525>>>>>            End
75525>>>>>>
75525>>>>>            Set piChannel to iCh
75526>>>>>        End
75526>>>>>>
75526>>>>>
75526>>>>>        Get psLogTextFileWithPath to sFileName
75527>>>>>
75527>>>>>        Get paDbUpdateErrorArray to aDbUpdateErrorArray
75528>>>>>        Move (SizeOfArray(aDbUpdateErrorArray)) to iSize
75529>>>>>        Decrement iSize
75530>>>>>
75530>>>>>        Get pdtUpdateStart to dtUpdateStart
75531>>>>>        If (IsNullDateTime(dtUpdateStart) = False) Begin
75533>>>>>            Move (CurrentDateTime()) to dtUpdateEnd
75534>>>>>            Move (dtUpdateEnd - dtUpdateStart) to tsElapsed
75535>>>>>        End
75535>>>>>>
75535>>>>>        Get pbQuickWrite to bQuickWrite
75536>>>>>
75536>>>>>        Append_Output channel iCh sFileName
75538>>>>>        If (bQuickWrite = True and iSize < 0) Begin
75540>>>>>            Writeln channel iCh ("Database Update Finished:  " + String(dtUpdateEnd) * "Time Elapsed:" * String(tsElapsed))
75543>>>>>        End
75543>>>>>>
75543>>>>>        Else If (bQuickWrite = False) Begin
75546>>>>>            Writeln channel iCh
75548>>>>>            Writeln channel iCh ("Database Update Started:" * String(dtUpdateStart) * "and finished at:" * String(dtUpdateEnd) * "Time Elapsed:" * String(tsElapsed))
75551>>>>>        End   
75551>>>>>>
75551>>>>>        If (iSize >= 0) Begin
75553>>>>>            If (aDbUpdateErrorArray[0].bShortFormat = False) Begin
75555>>>>>                Writeln channel iCh "[Err No:] [pnVersionNumber:] [Status Text:]"
75558>>>>>            End
75558>>>>>>
75558>>>>>        End
75558>>>>>>
75558>>>>>
75558>>>>>        For iCount from 0 to iSize  
75564>>>>>>
75564>>>>>            Move aDbUpdateErrorArray[iCount].iError         to iError
75565>>>>>            Move aDbUpdateErrorArray[iCount].nUpdateVersion to nVersion
75566>>>>>            Move aDbUpdateErrorArray[iCount].sErrorText     to sErrorText
75567>>>>>            Move aDbUpdateErrorArray[iCount].iErrorLine     to iErrorLine  
75568>>>>>            Move aDbUpdateErrorArray[iCount].hTable         to hTable
75569>>>>>            Move aDbUpdateErrorArray[iCount].sTableRootName to sRootName
75570>>>>>            Move aDbUpdateErrorArray[iCount].iField         to iField
75571>>>>>            
75571>>>>>            Get PadLeft (String(iError)) 8 to sErrorNo
75572>>>>>            If (aDbUpdateErrorArray[iCount].bError = True) Begin
75574>>>>>                Get PadLeft (String(nVersion)) (27 - Length(sErrorNo)) to sVersion
75575>>>>>                Move (sErrorNo + sVersion + "   " + sErrorText * "[ErrLine:" * String(iErrorLine) + "]" + "    (Table:" * sRootName * String(hTable) + "." + String(iField) + ")") to sText
75576>>>>>            End
75576>>>>>>
75576>>>>>            Else Begin
75577>>>>>                Get PadLeft (String(nVersion)) 27 to sVersion
75578>>>>>                Move (sVersion + "   " + sErrorText) to sText
75579>>>>>            End
75579>>>>>>
75579>>>>>            Writeln channel iCh sText
75582>>>>>            If (aDbUpdateErrorArray[iCount].sOrgErrorText <> "") Begin
75584>>>>>                Move ("   (" + aDbUpdateErrorArray[iCount].sOrgErrorText + ")") to sOrgErrorText
75585>>>>>                Move (Utf8ToAnsi(sOrgErrorText)) to sOrgErrorText       
75586>>>>>                Writeln channel iCh sOrgErrorText
75589>>>>>            End
75589>>>>>>
75589>>>>>            If (sText contains CS_SuccessfulUpdate) Begin
75591>>>>>                Writeln channel iCh
75593>>>>>            End
75593>>>>>>
75593>>>>>        Loop
75594>>>>>>
75594>>>>>        Close_Output channel iCh
75596>>>>>
75596>>>>>        Send Seq_Release_Channel iCh
75597>>>>>        Set piChannel to -1
75598>>>>>
75598>>>>>    End_Procedure
75599>>>>>
75599>>>>>    // The character to pad is optional. If nothing, spaces are used.
75599>>>>>    // Example:
75599>>>>>    // Move (PadLeft(45672,10,"0")) to sString -> "0000045672"
75599>>>>>    //  or:
75599>>>>>    // Move (PadLeft("Test",10)) to sString -> " Test"
75599>>>>>    // Courtesy of Pieter van Dieren. Collected from DAWs' Newsgroups.
75599>>>>>    Function PadLeft String sString Integer iLength String sOptChar Returns String
75601>>>>>        String sChar
75601>>>>>
75601>>>>>        If (Num_Arguments >= 3) Begin
75603>>>>>            Move sOptChar to sChar
75604>>>>>        End
75604>>>>>>
75604>>>>>        Else Begin
75605>>>>>            Move " " to sChar
75606>>>>>        End
75606>>>>>>
75606>>>>>
75606>>>>>        While (Length(sString) < iLength)
75610>>>>>            Move (sChar + sString) to sString
75611>>>>>        Loop
75612>>>>>>
75612>>>>>
75612>>>>>        Function_Return sString
75613>>>>>    End_Function
75614>>>>>
75614>>>>>    Procedure ShowErrorLog
75616>>>>>        String sPath sFileName sEditorProgram
75616>>>>>        Boolean bExists
75616>>>>>
75616>>>>>        Get psLogTextFileWithPath to sFileName
75617>>>>>        Get vFilePathExists sFileName to bExists
75618>>>>>        If (bExists = True) Begin
75620>>>>>            Get psEditorProgram to sEditorProgram
75621>>>>>            If (sEditorProgram <> "") Begin
75623>>>>>                Runprogram Background (psEditorProgram(Self)) (sPath + sFileName)
75624>>>>>            End
75624>>>>>>
75624>>>>>            Else Begin
75625>>>>>                Runprogram Shell Background sFileName
75626>>>>>            End
75626>>>>>>
75626>>>>>        End
75626>>>>>>
75626>>>>>        Else Begin
75627>>>>>            Send Info_Box (CS_DUF_LogFileNotFound + String(sFileName))
75628>>>>>        End
75628>>>>>>
75628>>>>>    End_Procedure
75629>>>>>
75629>>>>>End_Class
75630>>>Use cDbUpdateVersion.pkg
Including file: cDbUpdateVersion.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateVersion.pkg)
75630>>>>>//****************************************************************************
75630>>>>>// $Module type: Class
75630>>>>>// $Module name: cDbUpdateVersion
75630>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
75630>>>>>// Web-site    : http://www.rdctools.com
75630>>>>>// Created     : 2016-09-27 @ 09:33 (Military date format: YY-MM-DD)
75630>>>>>//
75630>>>>>// Description : Child class to cDbUpdateHandler.
75630>>>>>//               Put an object of this class inside the global ghoDbUpdateHandler object.
75630>>>>>//               Set the pnVersionNumber to a version number.
75630>>>>>//               Inside the cDbUpdateVersion object put a "Use MyNewDbUpdatePackage.pkg"
75630>>>>>//               Add one cVersion object for each update of the database to the ghoDbUpdateHandler object.
75630>>>>>//               Place your code in the "OnUpdate" event that alters the database.
75630>>>>>//
75630>>>>>// $Rev History:
75630>>>>>//    2016-09-27  Module header created
75630>>>>>//****************************************************************************
75630>>>>>Use UI
75630>>>>>Use DUFLanguageConstants.inc
75630>>>>>Use cDbUpdateFunctionLibrary.pkg
Including file: cDbUpdateFunctionLibrary.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary.pkg)
75630>>>>>>>
75630>>>>>>>//****************************************************************************
75630>>>>>>>// $Module type: Class
75630>>>>>>>// $Module name: cDbUpdateFunctionLibrary
75630>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
75630>>>>>>>// Web-site    : http://www.rdctools.com
75630>>>>>>>// Created     : 2014-09-05 @ 09:50 (Military date format: YY-MM-DD)
75630>>>>>>>//
75630>>>>>>>// Description : The class consists of a function library for database manipulations, aka make changes to a database.
75630>>>>>>>//               It has top level functions that uses the DataFlex db API, _but_ also specialized
75630>>>>>>>//               functions to make db changes to Sql databases with the DAW & Mertech drivers,
75630>>>>>>>//               with the help of Sql-scripts.
75630>>>>>>>//
75630>>>>>>>// $Rev History:
75630>>>>>>>//    2014-09-05  Module header created
75630>>>>>>>//
75630>>>>>>>//****************************************************************************
75630>>>>>>>Use cApplication.pkg
75630>>>>>>>Use seq_chnl.pkg
75630>>>>>>>Use GlobalFunctionsProcedures.pkg
75630>>>>>>>Use Datadict.pkg                        // Declaration of DF_FILE_SQL_TABLE_NAME
75630>>>>>>>Use Dfcursor.pkg
75630>>>>>>>Use DUFStatusPanel.pkg
75630>>>>>>>Use cDbUpdateFunctionLibrary_Mixin.pkg  // Properties used by the cDbUpdateFunctionLibrary class.
Including file: cDbUpdateFunctionLibrary_Mixin.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary_Mixin.pkg)
75630>>>>>>>>>// *** Mixin Class For the cDbUpdateFunctionLibrary Class ***
75630>>>>>>>>>//
75630>>>>>>>>>// We need to create a mixin class for the library.
75630>>>>>>>>>// Why? Because we import the library to the cDbUpdateVersion class; that imports
75630>>>>>>>>>// all messages (functions & procedures) but all Properties are "lost", aka not imported by
75630>>>>>>>>>// the Import_Class_Protocol command. So we need a way to create our properties somewhere else...
75630>>>>>>>>>// Note: This class should _not_ have a construct_object defined.
75630>>>>>>>>>//
75630>>>>>>>>>Use VdfBase.pkg
75630>>>>>>>>>Use WinUuid.pkg
Including file: WinUuid.pkg    (C:\Program Files\DataFlex 20.1\Pkg\WinUuid.pkg)
75630>>>>>>>>>>>Use Unicode.Pkg
75630>>>>>>>>>>>
75630>>>>>>>>>>>External_Function WinAPI_UuidCreate "UuidCreate" Rpcrt4.dll ;    Pointer Uuid ;    Returns Integer
75631>>>>>>>>>>>
75631>>>>>>>>>>>External_Function WinAPI_UuidToString  "UuidToStringW" Rpcrt4.dll ;    Pointer pUuid ;    Pointer lpUUIDString ;    Returns Integer
75632>>>>>>>>>>>
75632>>>>>>>>>>>External_Function WinAPI_UuidCreateSequential "UuidCreateSequential" Rpcrt4.dll ;    Pointer pUuid ;    Returns Integer
75633>>>>>>>>>>>
75633>>>>>>>>>>>External_Function WinAPI_RpcStringFree "RpcStringFreeW" Rpcrt4.dll ;    Pointer pStr ;    Returns Integer
75634>>>>>>>>>>>
75634>>>>>>>>>>>
75634>>>>>>>>>>>// Returns a 'random' Universally Unique Identifier string as a 32 digit hex number.
75634>>>>>>>>>>>Function RandomHexUUID Global Returns String
75636>>>>>>>>>>>    Pointer pUUID pUUIDStr
75636>>>>>>>>>>>    Integer iRetval iOffset iChar
75636>>>>>>>>>>>    String sUUID
75636>>>>>>>>>>>    
75636>>>>>>>>>>>    Move (Alloc(16)) to pUUID
75637>>>>>>>>>>>    
75637>>>>>>>>>>>    Move (WinAPI_UuidCreate (pUUID)) to iRetval
75638>>>>>>>>>>>    
75638>>>>>>>>>>>    If (iRetval = 0) Begin
75640>>>>>>>>>>>        Move 0 to pUUIDStr
75641>>>>>>>>>>>        
75641>>>>>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
75642>>>>>>>>>>>        If (iRetval = 0) Begin
75644>>>>>>>>>>>            Move (PointerToWString(pUUIDStr)) to sUUID
75645>>>>>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
75646>>>>>>>>>>>            
75646>>>>>>>>>>>            Move (Uppercase (sUUID)) to sUUID
75647>>>>>>>>>>>        End
75647>>>>>>>>>>>>
75647>>>>>>>>>>>    End
75647>>>>>>>>>>>>
75647>>>>>>>>>>>    
75647>>>>>>>>>>>    Move (Free(pUUID)) to iRetval
75648>>>>>>>>>>>    
75648>>>>>>>>>>>    Function_Return sUUID
75649>>>>>>>>>>>End_Function
75650>>>>>>>>>>>
75650>>>>>>>>>>>
75650>>>>>>>>>>>// Returns a sequential Universally Unique Identifier string as a 32 digit hex number.
75650>>>>>>>>>>>Function SeqHexUUID Global Returns String
75652>>>>>>>>>>>    Pointer pUUID pUUIDStr
75652>>>>>>>>>>>    Integer iRetval iOffset iChar
75652>>>>>>>>>>>    String sUUID
75652>>>>>>>>>>>    
75652>>>>>>>>>>>    Move (Alloc(16)) to pUUID
75653>>>>>>>>>>>    
75653>>>>>>>>>>>    Move (WinAPI_UuidCreateSequential (pUUID)) to iRetval
75654>>>>>>>>>>>    
75654>>>>>>>>>>>    If (iRetval = 0) Begin
75656>>>>>>>>>>>        Move 0 to pUUIDStr
75657>>>>>>>>>>>        
75657>>>>>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
75658>>>>>>>>>>>        If (iRetval = 0) Begin
75660>>>>>>>>>>>            Move (PointerToWString(pUUIDStr)) to sUUID
75661>>>>>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
75662>>>>>>>>>>>            
75662>>>>>>>>>>>            Move (Uppercase (sUUID)) to sUUID
75663>>>>>>>>>>>        End
75663>>>>>>>>>>>>
75663>>>>>>>>>>>    End
75663>>>>>>>>>>>>
75663>>>>>>>>>>>    
75663>>>>>>>>>>>    Move (Free(pUUID)) to iRetval
75664>>>>>>>>>>>    
75664>>>>>>>>>>>    Function_Return sUUID
75665>>>>>>>>>>>End_Function
75666>>>>>>>>>Use cli.pkg
75666>>>>>>>>>Use sql.pkg
75666>>>>>>>>>Use MSSqldrv.pkg
Including file: MSSqldrv.pkg    (C:\Program Files\DataFlex 20.1\Pkg\MSSqldrv.pkg)
75666>>>>>>>>>>>//     Package that declares MS SQL driver constants and functions.
75666>>>>>>>>>>>//     This package can be used by developers who want to add Data Access
75666>>>>>>>>>>>//     MS SQL Client specific code to a DataFlex application.
75666>>>>>>>>>>>
75666>>>>>>>>>>>Use Cli.pkg
75666>>>>>>>>>>>Use SQL.pkg
75666>>>>>>>>>>>
75666>>>>>>>>>>>//   Driver Indentification
75666>>>>>>>>>>>
75666>>>>>>>>>>>//   Error number constants
75666>>>>>>>>>>>
75666>>>>>>>>>>>
75666>>>>>>>>>>>//   Possible DF_DRIVER_SQLSERVER_CLIENT_VERSION values
75666>>>>>>>>>>>
75666>>>>>>>>>>>
75666>>>>>>>>>>>
75666>>>>>>>>>>>
75666>>>>>>>>>>>
75666>>>>>>>>>>>
75666>>>>>>>>>>>// SQL Server spcific types.
75666>>>>>>>>>>>Define SQL_SS_TIMESTAMPOFFSET   for   (-155) //SQL server datetimeoffset type */
75666>>>>>>>>>>>Define SQL_SS_TIME2             for   (-154) //SQL server time type */
75666>>>>>>>>>>>Define SQL_SS_XML               for   (-152) //SQL server xml type */
75666>>>>>>>>>>>Define SQL_SS_VARIANT           for   (-150) //SQL server variant type */
75666>>>>>>>>>>>
75666>>>>>>>>>>>// SQL Server spcific types.
75666>>>>>>>>>>>Define SQL_TYPE_TIMESTAMP2      for   (-200) //SQL server datetime2 type */
75666>>>>>>>>>>>Define SQL_VARCHARMAX           for   (-201) //SQL server varchar(max) type */
75666>>>>>>>>>>>Define SQL_WVARCHARMAX          for   (-202) //SQL server wvarchar(max) type */
75666>>>>>>>>>>>Define SQL_VARBINARYMAX         for   (-203) //SQL server varbinary(max) type */
75666>>>>>>>>>>>Define SQL_TYPE_MONEY           for   (-204) //SQL server money type */
75666>>>>>>>>>>>Define SQL_TYPE_SMALLMONEY      for   (-205) //SQL server smallmoney type */
75666>>>>>>>>>>>Define SQL_TYPE_SMALLDATETIME   for   (-206) //SQL server smalldatetype type */
75666>>>>>>>>>>>
75666>>>>>>>>>>>
75666>>>>>>>>>>>//   MSSQL_SetConstraint <FileNum> <ConstraintText>
75666>>>>>>>>>>>//
75666>>>>>>>>>>>//     Setup a constraint for a file.
75666>>>>>>>>>>>
75666>>>>>>>>>>>
75666>>>>>>>>>>>Class cMSSQLHandler is a cCLIHandler
75667>>>>>>>>>>>    
75667>>>>>>>>>>>    Procedure Construct_Object
75669>>>>>>>>>>>        Forward Send Construct_Object
75671>>>>>>>>>>>        
75671>>>>>>>>>>>        Set psDriverID to MSSQLDRV_ID
75672>>>>>>>>>>>    End_Procedure
75673>>>>>>>>>>>    
75673>>>>>>>>>>>    
75673>>>>>>>>>>>    
75673>>>>>>>>>>>    //   Extract the list from the out connect string.
75673>>>>>>>>>>>    Function ExtractList String sOutConnStr Integer hoStore Returns Integer
75675>>>>>>>>>>>        String  sItem
75675>>>>>>>>>>>        Integer iStart
75675>>>>>>>>>>>        Integer iEnd
75675>>>>>>>>>>>        
75675>>>>>>>>>>>        If (hoStore = 0) ;            Move Current_object to hoStore
75678>>>>>>>>>>>        
75678>>>>>>>>>>>        Send Delete_Data to hoStore
75679>>>>>>>>>>>        Move (Pos("{", sOutConnStr)) to iStart
75680>>>>>>>>>>>        While (iStart > 0)
75684>>>>>>>>>>>            Move (Right(sOutConnStr, Length(sOutConnStr) - iStart)) to sOutConnStr
75685>>>>>>>>>>>            If (Left(sOutConnStr, 1) = "}") ;                Move 0 to iStart
75688>>>>>>>>>>>            Else Begin
75689>>>>>>>>>>>                Move (Pos(",", sOutConnStr)) to iStart
75690>>>>>>>>>>>                Move (Pos("}", sOutConnStr)) to iEnd
75691>>>>>>>>>>>                If ((iStart = 0) or (iEnd < iStart)) ;                    Move iEnd to iStart
75694>>>>>>>>>>>                
75694>>>>>>>>>>>                If (iStart > 0) ;                    Set Value of hoStore  (Item_Count(Current_Object)) to (Left(sOutConnStr, iStart - 1))
75697>>>>>>>>>>>                
75697>>>>>>>>>>>                If (iStart = iEnd) ;                    Move 0 to iStart
75700>>>>>>>>>>>            End
75700>>>>>>>>>>>>
75700>>>>>>>>>>>        Loop
75701>>>>>>>>>>>>
75701>>>>>>>>>>>        
75701>>>>>>>>>>>        Function_Return (Item_Count(hoStore))
75702>>>>>>>>>>>    End_Procedure
75703>>>>>>>>>>>    
75703>>>>>>>>>>>    
75703>>>>>>>>>>>    
75703>>>>>>>>>>>    //   Call the driver's browse connect function
75703>>>>>>>>>>>    Function BrowseConnect String sInConnStr Returns String
75705>>>>>>>>>>>        String  sDriver
75705>>>>>>>>>>>        String  sOutConnStr
75705>>>>>>>>>>>        Integer iArg
75705>>>>>>>>>>>        Integer iRetval
75705>>>>>>>>>>>        
75705>>>>>>>>>>>        Get psDriverID to sDriver
75706>>>>>>>>>>>        If (sDriver <> "") Begin
75708>>>>>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
75709>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
75714>>>>>>>>>>>        End
75714>>>>>>>>>>>>
75714>>>>>>>>>>>        
75714>>>>>>>>>>>        Function_Return sOutConnStr
75715>>>>>>>>>>>    End_Function// BrowseConnect
75716>>>>>>>>>>>    
75716>>>>>>>>>>>    
75716>>>>>>>>>>>    Function BrowseConnectLocal String sInConnStr Returns String
75718>>>>>>>>>>>        String  sDriver
75718>>>>>>>>>>>        String  sOutConnStr
75718>>>>>>>>>>>        Integer iArg
75718>>>>>>>>>>>        Integer iRetval
75718>>>>>>>>>>>        
75718>>>>>>>>>>>        Move 1 to iArg // Browses only local
75719>>>>>>>>>>>        
75719>>>>>>>>>>>        Get psDriverID to sDriver
75720>>>>>>>>>>>        If (sDriver <> "") Begin
75722>>>>>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
75723>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
75728>>>>>>>>>>>        End
75728>>>>>>>>>>>>
75728>>>>>>>>>>>        
75728>>>>>>>>>>>        Function_Return sOutConnStr
75729>>>>>>>>>>>    End_Function// BrowseConnect
75730>>>>>>>>>>>    
75730>>>>>>>>>>>    
75730>>>>>>>>>>>    Function EnumerateServersNetworkOrLocal Integer iNetworkLocal  Returns Integer
75732>>>>>>>>>>>        
75732>>>>>>>>>>>        String  sServerList
75732>>>>>>>>>>>        Integer iNumServers
75732>>>>>>>>>>>        Integer iDriver
75732>>>>>>>>>>>        Integer iClientVersion
75732>>>>>>>>>>>        String  sDriver
75732>>>>>>>>>>>        
75732>>>>>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriver
75733>>>>>>>>>>>        
75733>>>>>>>>>>>        If (iDriver) Begin
75735>>>>>>>>>>>            
75735>>>>>>>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
75738>>>>>>>>>>>            
75738>>>>>>>>>>>            Get SqlServerClientDriverName iClientVersion to sDriver
75739>>>>>>>>>>>            
75739>>>>>>>>>>>            Move ("DRIVER={" + sDriver + "};") to sDriver
75740>>>>>>>>>>>            If (iNetworkLocal = 0) Begin
75742>>>>>>>>>>>                Get BrowseConnect sDriver to sServerList
75743>>>>>>>>>>>            End
75743>>>>>>>>>>>>
75743>>>>>>>>>>>            Else Begin
75744>>>>>>>>>>>                Get BrowseConnectLocal sDriver to sServerList
75745>>>>>>>>>>>            End
75745>>>>>>>>>>>>
75745>>>>>>>>>>>            Get ExtractList sServerList Current_object to iNumServers
75746>>>>>>>>>>>        End
75746>>>>>>>>>>>>
75746>>>>>>>>>>>        
75746>>>>>>>>>>>        Function_Return iNumServers
75747>>>>>>>>>>>        
75747>>>>>>>>>>>    End_Function
75748>>>>>>>>>>>    
75748>>>>>>>>>>>    //   Enumerate the available SQL Server database servers
75748>>>>>>>>>>>    //   This function will return all SQL Server instances on the network.
75748>>>>>>>>>>>    //   This may take a long time.
75748>>>>>>>>>>>    //   To enumerate only local SQL Server instances use EnumerateServersLocal
75748>>>>>>>>>>>    Function EnumerateServers Returns Integer
75750>>>>>>>>>>>        
75750>>>>>>>>>>>        Integer iNumServers
75750>>>>>>>>>>>        Integer iNetworkLocal
75750>>>>>>>>>>>        
75750>>>>>>>>>>>        Move 0 to iNetworkLocal // 0 = enumerate network servers
75751>>>>>>>>>>>        
75751>>>>>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
75752>>>>>>>>>>>        
75752>>>>>>>>>>>        Function_Return iNumServers
75753>>>>>>>>>>>        
75753>>>>>>>>>>>    End_Function
75754>>>>>>>>>>>    
75754>>>>>>>>>>>    
75754>>>>>>>>>>>    //   Enumerate the available SQL Server database servers
75754>>>>>>>>>>>    //   This function will return only return SQL Server instance on the local machine
75754>>>>>>>>>>>    //   To enumerate all SQL Server instances in a network use EnumerateServers
75754>>>>>>>>>>>    Function EnumerateServersLocal Returns Integer
75756>>>>>>>>>>>        
75756>>>>>>>>>>>        Integer iNumServers
75756>>>>>>>>>>>        Integer iNetworkLocal
75756>>>>>>>>>>>        
75756>>>>>>>>>>>        Move 1 to iNetworkLocal // 1 = enumerate local servers
75757>>>>>>>>>>>        
75757>>>>>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
75758>>>>>>>>>>>        
75758>>>>>>>>>>>        Function_Return iNumServers
75759>>>>>>>>>>>        
75759>>>>>>>>>>>    End_Function
75760>>>>>>>>>>>    
75760>>>>>>>>>>>    
75760>>>>>>>>>>>    
75760>>>>>>>>>>>    //   Enumerate database in a given server.
75760>>>>>>>>>>>    Function EnumerateDatabases String sServer String sUser String sPassWord Returns Integer
75762>>>>>>>>>>>        Integer hoSQL
75762>>>>>>>>>>>        String  sConnect
75762>>>>>>>>>>>        String  sDatabase
75762>>>>>>>>>>>        Integer hdbc
75762>>>>>>>>>>>        Integer hstmt
75762>>>>>>>>>>>        Integer iFetchResult
75762>>>>>>>>>>>        
75762>>>>>>>>>>>        If (Num_Arguments < 3) ;            Move "" to sPassWord
75765>>>>>>>>>>>        If (Num_Arguments < 2) ;            Move "" to sUser
75768>>>>>>>>>>>        
75768>>>>>>>>>>>        If (sUser <> "") ;            Move ("SERVER=" + Trim(sServer) + ";UID=" + Trim(sUser) + ";PWD=" + Trim(sPassword) + ";") to sConnect
75771>>>>>>>>>>>        Else ;            Move ("SERVER=" + Trim(sServer) + ";Trusted_Connection=yes") to sConnect
75773>>>>>>>>>>>        
75773>>>>>>>>>>>        Object oEnumDBSQLmanager is a cSQLHandleManager
75775>>>>>>>>>>>            Move Current_Object to hoSQL
75776>>>>>>>>>>>        End_Object
75777>>>>>>>>>>>        
75777>>>>>>>>>>>        If (hoSQL <> 0) Begin
75779>>>>>>>>>>>            Get SQLConnect of hoSQL "MSSQLDRV" sConnect to hdbc
75780>>>>>>>>>>>            If (hdbc <> 0) Begin
75782>>>>>>>>>>>                Get SQLOpen of hdbc to hstmt
75783>>>>>>>>>>>                If (hstmt <> 0) Begin
75785>>>>>>>>>>>                    //   We could do a direct select on the sysdatabases table but we use
75785>>>>>>>>>>>                    //   the stored procedure sp_database instead. SQL Server recommends this
75785>>>>>>>>>>>                    //   approach in case meta data might change, the stored procedure will
75785>>>>>>>>>>>                    //   stay the same.
75785>>>>>>>>>>>                    Send SQLSetProcedureName to hstmt "sp_databases"
75786>>>>>>>>>>>                    Send SQLCall to hstmt
75787>>>>>>>>>>>                    Repeat
75787>>>>>>>>>>>>
75787>>>>>>>>>>>                        Get SQLFetch of hstmt to iFetchResult
75788>>>>>>>>>>>                        If (iFetchResult <> 0) Begin
75790>>>>>>>>>>>                            Get SQLColumnValue of hstmt 1 to sDatabase
75791>>>>>>>>>>>                            Set Value  (Item_Count(Current_Object)) to sDatabase
75792>>>>>>>>>>>                        End
75792>>>>>>>>>>>>
75792>>>>>>>>>>>                    Until (iFetchResult = 0)
75794>>>>>>>>>>>                    
75794>>>>>>>>>>>                    Send SQLClose to hstmt
75795>>>>>>>>>>>                End
75795>>>>>>>>>>>>
75795>>>>>>>>>>>                Send SQLDisconnect to hdbc
75796>>>>>>>>>>>            End
75796>>>>>>>>>>>>
75796>>>>>>>>>>>        End
75796>>>>>>>>>>>>
75796>>>>>>>>>>>        Send Destroy_Object to hoSQL
75797>>>>>>>>>>>        
75797>>>>>>>>>>>        Function_Return (Item_Count(Current_Object))
75798>>>>>>>>>>>    End_Function
75799>>>>>>>>>>>    
75799>>>>>>>>>>>    
75799>>>>>>>>>>>    Function SqlServerClientVersionName Integer iClientVersion  Returns String
75801>>>>>>>>>>>        
75801>>>>>>>>>>>        String  sSqlServerClientVersionName
75801>>>>>>>>>>>        
75801>>>>>>>>>>>        
75801>>>>>>>>>>>        Case Begin
75801>>>>>>>>>>>            
75801>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
75803>>>>>>>>>>>                Move SQLSERVER2017CLIENTNAME to sSqlServerClientVersionName
75804>>>>>>>>>>>                Case Break
75805>>>>>>>>>>>                
75805>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
75808>>>>>>>>>>>                Move SQLSERVER2016CLIENTNAME to sSqlServerClientVersionName
75809>>>>>>>>>>>                Case Break
75810>>>>>>>>>>>            
75810>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
75813>>>>>>>>>>>                Move SQLSERVER2014CLIENTNAME to sSqlServerClientVersionName
75814>>>>>>>>>>>                Case Break
75815>>>>>>>>>>>            
75815>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
75818>>>>>>>>>>>                Move SQLSERVER2012CLIENTNAME to sSqlServerClientVersionName
75819>>>>>>>>>>>                Case Break
75820>>>>>>>>>>>            
75820>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
75823>>>>>>>>>>>                Move SQLSERVER2008CLIENTNAME to sSqlServerClientVersionName
75824>>>>>>>>>>>                Case Break
75825>>>>>>>>>>>            
75825>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
75828>>>>>>>>>>>                Move SQLSERVER2005CLIENTNAME to sSqlServerClientVersionName
75829>>>>>>>>>>>                Case Break
75830>>>>>>>>>>>            
75830>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
75833>>>>>>>>>>>                Move SQLSERVER2000CLIENTNAME to sSqlServerClientVersionName
75834>>>>>>>>>>>                Case Break
75835>>>>>>>>>>>            
75835>>>>>>>>>>>            Case Else
75835>>>>>>>>>>>                Move SQLSERVERUNKNOWNCLIENTNAME to sSqlServerClientVersionName
75836>>>>>>>>>>>                
75836>>>>>>>>>>>        Case End
75836>>>>>>>>>>>        
75836>>>>>>>>>>>        
75836>>>>>>>>>>>        Function_Return sSqlServerClientVersionName
75837>>>>>>>>>>>        
75837>>>>>>>>>>>    End_Function
75838>>>>>>>>>>>
75838>>>>>>>>>>>
75838>>>>>>>>>>>    Function SqlServerClientDriverName Integer iClientVersion  Returns String
75840>>>>>>>>>>>        
75840>>>>>>>>>>>        String  sSqlServerClientDriverName
75840>>>>>>>>>>>        
75840>>>>>>>>>>>        Case Begin
75840>>>>>>>>>>>            
75840>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
75842>>>>>>>>>>>                Move SQLSERVER2017DRVRSTR to sSqlServerClientDriverName
75843>>>>>>>>>>>                Case Break
75844>>>>>>>>>>>                
75844>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
75847>>>>>>>>>>>                Move SQLSERVER2016DRVRSTR to sSqlServerClientDriverName
75848>>>>>>>>>>>                Case Break
75849>>>>>>>>>>>            
75849>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
75852>>>>>>>>>>>                Move SQLSERVER2014DRVRSTR to sSqlServerClientDriverName
75853>>>>>>>>>>>                Case Break
75854>>>>>>>>>>>            
75854>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
75857>>>>>>>>>>>                Move SQLSERVER2012DRVRSTR to sSqlServerClientDriverName
75858>>>>>>>>>>>                Case Break
75859>>>>>>>>>>>            
75859>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
75862>>>>>>>>>>>                Move SQLSERVER2008DRVRSTR to sSqlServerClientDriverName
75863>>>>>>>>>>>                Case Break
75864>>>>>>>>>>>            
75864>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
75867>>>>>>>>>>>                Move SQLSERVER2005DRVRSTR to sSqlServerClientDriverName
75868>>>>>>>>>>>                Case Break
75869>>>>>>>>>>>            
75869>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
75872>>>>>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
75873>>>>>>>>>>>                Case Break
75874>>>>>>>>>>>            
75874>>>>>>>>>>>            Case Else
75874>>>>>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
75875>>>>>>>>>>>                
75875>>>>>>>>>>>        Case End
75875>>>>>>>>>>>        
75875>>>>>>>>>>>        
75875>>>>>>>>>>>        Function_Return sSqlServerClientDriverName
75876>>>>>>>>>>>        
75876>>>>>>>>>>>    End_Function
75877>>>>>>>>>>>    
75877>>>>>>>>>>>    
75877>>>>>>>>>>>End_Class
75878>>>>>>>>>>>
75878>>>>>>>>>>>
75878>>>>>>>>>Use db2_drv.pkg
Including file: db2_drv.pkg    (C:\Program Files\DataFlex 20.1\Pkg\db2_drv.pkg)
75878>>>>>>>>>>>// DB2_DRV.PKG                                                          
75878>>>>>>>>>>>//   Package that declares DB2 driver constants and functions.          
75878>>>>>>>>>>>//   This package can be used by developers who want to add DB2 driver  
75878>>>>>>>>>>>//   specific code to a DataFlex application.                           
75878>>>>>>>>>>>
75878>>>>>>>>>>>Use Cli.pkg
75878>>>>>>>>>>>
75878>>>>>>>>>>>// Driver attributes
75878>>>>>>>>>>>
75878>>>>>>>>>>>
75878>>>>>>>>>>>// Driver Indentification
75878>>>>>>>>>>>
75878>>>>>>>>>>>// Error number constants
75878>>>>>>>>>>>
75878>>>>>>>>>>>// Call driver function identifiers
75878>>>>>>>>>>>
75878>>>>>>>>>>>// DB2 specific data types
75878>>>>>>>>>>>Define SQL_CLOB           for   (-99)
75878>>>>>>>>>>>Define SQL_BLOB           for   (-98)
75878>>>>>>>>>>>Define SQL_XML            for   (-370)
75878>>>>>>>>>>>// DB2 Graphic types are Unicode types
75878>>>>>>>>>>>Define SQL_GRAPHIC        for   (-95)
75878>>>>>>>>>>>Define SQL_VARGRAPHIC     for   (-96)
75878>>>>>>>>>>>Define SQL_LONGVARGRAPHIC for   (-97)
75878>>>>>>>>>>>Define SQL_DBCLOB         for   (-350)
75878>>>>>>>>>>>
75878>>>>>>>>>>>
75878>>>>>>>>>>>// Extra DB2 commands
75878>>>>>>>>>>>
75878>>>>>>>>>>>
75878>>>>>>>>>>>// DB2_SetConstraint <FileNum> <ConstraintText>                         
75878>>>>>>>>>>>//   Setup a constraint for a file.                                     
75878>>>>>>>>>>>
75878>>>>>>>>>>>
75878>>>>>>>>>>>
75878>>>>>>>>>>>Class cDB2Handler is a cCLIHandler
75879>>>>>>>>>>>    
75879>>>>>>>>>>>    Procedure Construct_Object
75881>>>>>>>>>>>        Forward Send Construct_Object
75883>>>>>>>>>>>        
75883>>>>>>>>>>>        Set psDriverID to DB2_DRV_ID
75884>>>>>>>>>>>    End_Procedure
75885>>>>>>>>>>>    
75885>>>>>>>>>>>    
75885>>>>>>>>>>>    
75885>>>>>>>>>>>    // Reset the datasource list to the beginning
75885>>>>>>>>>>>    Procedure SeedDataSources
75887>>>>>>>>>>>        String  sDriver
75887>>>>>>>>>>>        String  sVoid
75887>>>>>>>>>>>        Integer iRetval
75887>>>>>>>>>>>        
75887>>>>>>>>>>>        Get psDriverID to sDriver
75888>>>>>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid SQL_FETCH_ALL Result iRetval
75895>>>>>>>>>>>    End_Procedure
75896>>>>>>>>>>>    
75896>>>>>>>>>>>    
75896>>>>>>>>>>>    
75896>>>>>>>>>>>    // Call the driver's data sources function
75896>>>>>>>>>>>    Function DataSources Returns String
75898>>>>>>>>>>>        String  sDriver
75898>>>>>>>>>>>        String  sDataSource
75898>>>>>>>>>>>        String  sDescription
75898>>>>>>>>>>>        Integer iLength
75898>>>>>>>>>>>        Integer iRetval
75898>>>>>>>>>>>        
75898>>>>>>>>>>>        Get psDriverID to sDriver
75899>>>>>>>>>>>        If (sDriver <> "") Begin
75901>>>>>>>>>>>            Move 8192 to iLength
75902>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDataSource
75903>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDescription
75904>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
75909>>>>>>>>>>>        End
75909>>>>>>>>>>>>
75909>>>>>>>>>>>        
75909>>>>>>>>>>>        If (sDataSource <> "" or sDescription <> "") ;            Function_Return (sDataSource - (If(sDescription <> "", "," *  sDescription, "")))
75912>>>>>>>>>>>        Else ;            Function_Return ""
75914>>>>>>>>>>>    End_Function
75915>>>>>>>>>>>    
75915>>>>>>>>>>>End_Class
75916>>>>>>>>>Use odbc_drv.pkg
Including file: odbc_drv.pkg    (C:\Program Files\DataFlex 20.1\Pkg\odbc_drv.pkg)
75916>>>>>>>>>>>//   Package that declares ODBC driver constants and functions.         
75916>>>>>>>>>>>//   This package can be used by developers who want to add Data Access 
75916>>>>>>>>>>>//   ODBC Client specific code to a DataFlex application.               
75916>>>>>>>>>>>
75916>>>>>>>>>>>Use Cli.pkg
75916>>>>>>>>>>>
75916>>>>>>>>>>>// Driver Indentification
75916>>>>>>>>>>>
75916>>>>>>>>>>>// Error number constants
75916>>>>>>>>>>>
75916>>>>>>>>>>>// Call driver function identifiers
75916>>>>>>>>>>>
75916>>>>>>>>>>>Class cODBCHandler is a cCLIHandler
75917>>>>>>>>>>>    
75917>>>>>>>>>>>    Procedure Construct_Object
75919>>>>>>>>>>>        Forward Send Construct_Object
75921>>>>>>>>>>>        
75921>>>>>>>>>>>        Set psDriverID to ODBC_DRV_ID
75922>>>>>>>>>>>    End_Procedure
75923>>>>>>>>>>>    
75923>>>>>>>>>>>    
75923>>>>>>>>>>>    
75923>>>>>>>>>>>    // Setup the type of data sources returned by the datasources function
75923>>>>>>>>>>>    Procedure Set DataSourceType Integer iNewType
75925>>>>>>>>>>>        String  sDriver
75925>>>>>>>>>>>        String  sVoid
75925>>>>>>>>>>>        Integer iRetval
75925>>>>>>>>>>>        
75925>>>>>>>>>>>        Get psDriverID to sDriver
75926>>>>>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid iNewType Result iRetval
75933>>>>>>>>>>>    End_Procedure
75934>>>>>>>>>>>    
75934>>>>>>>>>>>    
75934>>>>>>>>>>>    // Call the driver's data sources function
75934>>>>>>>>>>>    Function DataSources Returns String
75936>>>>>>>>>>>        String  sDriver
75936>>>>>>>>>>>        String  sDataSource
75936>>>>>>>>>>>        String  sDescription
75936>>>>>>>>>>>        Integer iLength
75936>>>>>>>>>>>        Integer iRetval
75936>>>>>>>>>>>        
75936>>>>>>>>>>>        Get psDriverID to sDriver
75937>>>>>>>>>>>        If (sDriver <> "") Begin
75939>>>>>>>>>>>            Move 8192 to iLength
75940>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDataSource
75941>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDescription
75942>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
75947>>>>>>>>>>>        End
75947>>>>>>>>>>>>
75947>>>>>>>>>>>        
75947>>>>>>>>>>>        If (sDataSource <> "" or sDescription <> "") ;            Function_Return (sDataSource - (If(sDescription <> "", "," * sDescription, "")))
75950>>>>>>>>>>>        Else ;            Function_Return ""
75952>>>>>>>>>>>    End_Function
75953>>>>>>>>>>>    
75953>>>>>>>>>>>End_Class
75954>>>>>>>>>>>
75954>>>>>>>>>Use DFBTRDRV.PKG
Including file: DFBTRDRV.PKG    (C:\Program Files\DataFlex 20.1\Pkg\DFBTRDRV.PKG)
75954>>>>>>>>>>>// $File title : Package for the DataFlex Connectivity Kit for Pervasive.SQL
75954>>>>>>>>>>>// Notice      : This package contains constants and commands, used to call
75954>>>>>>>>>>>//               specific functions in the DFBTRDRV.
75954>>>>>>>>>>>Use Ui
75954>>>>>>>>>>>//
75954>>>>>>>>>>>// Driver Indentification
75954>>>>>>>>>>>//
75954>>>>>>>>>>>
75954>>>>>>>>>>>// Driver attributes
75954>>>>>>>>>>>//
75954>>>>>>>>>>>// Call_Driver functions ID's
75954>>>>>>>>>>>//
75954>>>>>>>>>>>//
75954>>>>>>>>>>>// DFBTRFN_CONVERT_FILE options
75954>>>>>>>>>>>//
75954>>>>>>>>>>>
75954>>>>>>>>>>>//
75954>>>>>>>>>>>// DFBTRFN_SET_OWNER options
75954>>>>>>>>>>>//
75954>>>>>>>>>>>
75954>>>>>>>>>>>//
75954>>>>>>>>>>>// DFBTRFN_SET_TRANSACTION_TYPE options
75954>>>>>>>>>>>//
75954>>>>>>>>>>>
75954>>>>>>>>>>>
75954>>>>>>>>>>>//
75954>>>>>>>>>>>// Command to create all vars which may be needed
75954>>>>>>>>>>>// in other commands.
75954>>>>>>>>>>>//
75954>>>>>>>>>>>
75954>>>>>>>>>>>
75954>>>>>>>>>>>
75954>>>>>>>>>>>//
75954>>>>>>>>>>>// Command to set the owner of a Btrieve file.
75954>>>>>>>>>>>// File must have been opened.
75954>>>>>>>>>>>// Filenumber needs to be passed.
75954>>>>>>>>>>>// To clear set the owner to "".
75954>>>>>>>>>>>// Examples:
75954>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret"
75954>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY CALLBACK MyCallBack
75954>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" ENCRYPT
75954>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY ENCRYPT CALLBACK MyCallBack
75954>>>>>>>>>>>// To clear:
75954>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to ""
75954>>>>>>>>>>>//
75954>>>>>>>>>>>
75954>>>>>>>>>>>
75954>>>>>>>>>>>
75954>>>>>>>>>>>//
75954>>>>>>>>>>>// Command to parse DFBTR_SET_OWNVER
75954>>>>>>>>>>>// options.
75954>>>>>>>>>>>//
75954>>>>>>>>>>>
75954>>>>>>>>>>>
75954>>>>>>>>>>>
75954>>>>>>>>>>>//
75954>>>>>>>>>>>// Command to parse for Callback
75954>>>>>>>>>>>//
75954>>>>>>>>>>>
75954>>>>>>>>>>>
75954>>>>>>>>>>>
75954>>>>>>>>>>>//
75954>>>>>>>>>>>// Command to clear the owner of a Btrieve file.
75954>>>>>>>>>>>// File must have been opened.
75954>>>>>>>>>>>// Filenumber needs to be passed.
75954>>>>>>>>>>>// Examples:
75954>>>>>>>>>>>//      DFBTR_CLEAR_OWNER MyFileNumber
75954>>>>>>>>>>>//
75954>>>>>>>>>>>
75954>>>>>>>>>>>
75954>>>>>>>>>>>
75954>>>>>>>>>>>//
75954>>>>>>>>>>>// Command to add a owner name to the internal list of ownernames
75954>>>>>>>>>>>// which will be tries when opening files.
75954>>>>>>>>>>>//
75954>>>>>>>>>>>
75954>>>>>>>>>>>
75954>>>>>>>>>>>
75954>>>>>>>>>>>//
75954>>>>>>>>>>>// Command to remove all owners from the internal list of ownernames
75954>>>>>>>>>>>//
75954>>>>>>>>>>>
75954>>>>>>>>>>>
75954>>>>>>>>>>>//
75954>>>>>>>>>>>// Command to set the owner name to be used when opening the DDF files.
75954>>>>>>>>>>>// The DDF owner is required when Pervasive.SQL security is turned on.
75954>>>>>>>>>>>// The DDF owner is equal to the password of the Master user in Pervasive.SQL
75954>>>>>>>>>>>// This command overwrites the DDF_OWNER setting in DFBTRDRV.INT
75954>>>>>>>>>>>//
75954>>>>>>>>>>>
75954>>>>>>>>>>>//
75954>>>>>>>>>>>// Command to change the transaction type.
75954>>>>>>>>>>>// Valid types are:
75954>>>>>>>>>>>//     DFBTRTT_NONE
75954>>>>>>>>>>>//     DFBTRTT_EXCLUSIVE
75954>>>>>>>>>>>//     DFBTRTT_CONCURRENT
75954>>>>>>>>>>>//
75954>>>>>>>>>>>//
75954>>>>>>>>>>>
75954>>>>>>>>>>>
75954>>>>>>>>>>>
75954>>>>>>>>>>>//
75954>>>>>>>>>>>// Command to get the current transaction type.
75954>>>>>>>>>>>//
75954>>>>>>>>>>>
75954>>>>>>>>>>>//
75954>>>>>>>>>>>// Command to set explicit_locking
75954>>>>>>>>>>>//
75954>>>>>>>>>>>
75954>>>>>>>>>>>//
75954>>>>>>>>>>>// Command to get explicit locking
75954>>>>>>>>>>>//
75954>>>>>>>>>>>
75954>>>>>>>>>>>//
75954>>>>>>>>>>>// Command to set detection for incompatible positive signs in numeric fields
75954>>>>>>>>>>>//
75954>>>>>>>>>>>
75954>>>>>>>>>>>//
75954>>>>>>>>>>>// Command to get detection for incompatible positive signs in numeric fields
75954>>>>>>>>>>>//
75954>>>>>>>>>>>
75954>>>>>>>>>>>// Purpose: An instance of this class can be used as a broker object to
75954>>>>>>>>>>>//          call several Dfbtrdrv releated methods.
75954>>>>>>>>>>>
75954>>>>>>>>>>>Class cDFBtrDrvHandler is an Array
75955>>>>>>>>>>>    
75955>>>>>>>>>>>    Procedure Construct_Object Integer iImage
75957>>>>>>>>>>>        Forward Send Construct_object iImage
75959>>>>>>>>>>>        
75959>>>>>>>>>>>        Property String  psDriverID "DFBTRDRV"
75960>>>>>>>>>>>    End_Procedure
75961>>>>>>>>>>>    
75961>>>>>>>>>>>    //  The revsion of a Dfbtrdrv Connectivity Kit
75961>>>>>>>>>>>    //
75961>>>>>>>>>>>    
75961>>>>>>>>>>>    Function CKRevision Returns String
75963>>>>>>>>>>>        String  sDriverID
75963>>>>>>>>>>>        String  sRevision
75963>>>>>>>>>>>        String  sVoid
75963>>>>>>>>>>>        Integer iRetval
75963>>>>>>>>>>>        
75963>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
75963>>>>>>>>>>>        // This error would otherwise be raised when we have an older
75963>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
75963>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
75964>>>>>>>>>>>        Get psDriverID to sDriverID
75965>>>>>>>>>>>        Move (Repeat(" ", 255)) to sRevision
75966>>>>>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
75971>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
75972>>>>>>>>>>>        If (Trim(sRevision) = "") Begin
75974>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
75974>>>>>>>>>>>            Move "0.0.0.0" to sRevision
75975>>>>>>>>>>>        End
75975>>>>>>>>>>>>
75975>>>>>>>>>>>        Function_Return sRevision
75976>>>>>>>>>>>    End_Function
75977>>>>>>>>>>>    
75977>>>>>>>>>>>    Function CkUsesUri Returns Integer
75979>>>>>>>>>>>        String  sDriverID
75979>>>>>>>>>>>        String  sVoid1
75979>>>>>>>>>>>        String  sVoid2
75979>>>>>>>>>>>        Integer iRetval
75979>>>>>>>>>>>        
75979>>>>>>>>>>>        Get psDriverID to sDriverID
75980>>>>>>>>>>>        
75980>>>>>>>>>>>        Move 0 to iRetval
75981>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
75981>>>>>>>>>>>        // This error would otherwise be raised when we have an older
75981>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKUSESURI function
75981>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
75982>>>>>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKUSESURI Callback 0 Passing sVoid1 sVoid2 0 Result iRetval
75987>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
75988>>>>>>>>>>>        
75988>>>>>>>>>>>        Function_Return iRetval
75989>>>>>>>>>>>    End_Function
75990>>>>>>>>>>>    
75990>>>>>>>>>>>    
75990>>>>>>>>>>>    
75990>>>>>>>>>>>    // Extract the Nth part of a a.b.c.d revsion string.
75990>>>>>>>>>>>    //
75990>>>>>>>>>>>    // Returns : The part version number or -1 if there is no such part number.
75990>>>>>>>>>>>    //
75990>>>>>>>>>>>    
75990>>>>>>>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
75992>>>>>>>>>>>        Integer iPartRev
75992>>>>>>>>>>>        Integer iCurrentPart
75992>>>>>>>>>>>        Integer iSeparatorPos
75992>>>>>>>>>>>        
75992>>>>>>>>>>>        If (iPartNum > 4) ;            Function_Return -1
75995>>>>>>>>>>>        
75995>>>>>>>>>>>        Move 0 to iCurrentPart
75996>>>>>>>>>>>        Repeat
75996>>>>>>>>>>>>
75996>>>>>>>>>>>            Move (Pos(".", sRevision)) to iSeparatorPos
75997>>>>>>>>>>>            If (iSeparatorPos > 0) Begin
75999>>>>>>>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) to iPartRev
76000>>>>>>>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) to sRevision
76001>>>>>>>>>>>                Increment iCurrentPart
76002>>>>>>>>>>>            End
76002>>>>>>>>>>>>
76002>>>>>>>>>>>            Else If (sRevision <> "") Begin
76005>>>>>>>>>>>                Move sRevision to iPartRev
76006>>>>>>>>>>>                Move "" to sRevision
76007>>>>>>>>>>>                Increment iCurrentPart
76008>>>>>>>>>>>            End
76008>>>>>>>>>>>>
76008>>>>>>>>>>>            Else ;                Move -1 to iPartRev
76010>>>>>>>>>>>        Until (iCurrentPart >= iPartNum or iPartRev = -1)
76012>>>>>>>>>>>        
76012>>>>>>>>>>>        Function_Return iPartRev
76013>>>>>>>>>>>    End_Function
76014>>>>>>>>>>>    
76014>>>>>>>>>>>    
76014>>>>>>>>>>>    
76014>>>>>>>>>>>    //
76014>>>>>>>>>>>    //  Returns the major revision of the CK
76014>>>>>>>>>>>    //
76014>>>>>>>>>>>    
76014>>>>>>>>>>>    Function CKMajorRevision Returns Integer
76016>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 1, CKRevision(Current_Object)))
76017>>>>>>>>>>>    End_Function
76018>>>>>>>>>>>    
76018>>>>>>>>>>>    
76018>>>>>>>>>>>    
76018>>>>>>>>>>>    //  Returns the minor revision of the CK
76018>>>>>>>>>>>    //
76018>>>>>>>>>>>    
76018>>>>>>>>>>>    Function CKMinorRevision Returns Integer
76020>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 2, CKRevision(Current_Object)))
76021>>>>>>>>>>>    End_Function
76022>>>>>>>>>>>    
76022>>>>>>>>>>>    
76022>>>>>>>>>>>    //  Returns the release revision of the CK
76022>>>>>>>>>>>    //
76022>>>>>>>>>>>    
76022>>>>>>>>>>>    Function CKReleaseRevision Returns Integer
76024>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 3, CKRevision(Current_Object)))
76025>>>>>>>>>>>    End_Function
76026>>>>>>>>>>>    
76026>>>>>>>>>>>    
76026>>>>>>>>>>>    //  Returns the major revision of the CK
76026>>>>>>>>>>>    //
76026>>>>>>>>>>>    
76026>>>>>>>>>>>    Function CKBuildRevision Returns Integer
76028>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 4, CKRevision(Current_Object)))
76029>>>>>>>>>>>    End_Function
76030>>>>>>>>>>>    
76030>>>>>>>>>>>    
76030>>>>>>>>>>>    //  Determines if the CK conforms to a passed minimal revsion.
76030>>>>>>>>>>>    //
76030>>>>>>>>>>>    
76030>>>>>>>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
76032>>>>>>>>>>>        If (iMajor < CKMajorRevision(Current_object)) ;            Function_Return (True)
76035>>>>>>>>>>>        Else If (iMajor = CKMajorRevision(Current_object)) Begin
76038>>>>>>>>>>>            If (iMinor < CKMinorRevision(Current_object)) ;                Function_Return (True)
76041>>>>>>>>>>>            Else If (iMinor = CKMinorRevision(Current_object)) Begin
76044>>>>>>>>>>>                If (iRelease < CKReleaseRevision(Current_object)) ;                    Function_Return (True)
76047>>>>>>>>>>>                Else If (iRelease = CKReleaseRevision(Current_object) and iBuild <= CKBuildRevision(Current_object)) ;                    Function_Return (True)
76051>>>>>>>>>>>            End
76051>>>>>>>>>>>>
76051>>>>>>>>>>>        End
76051>>>>>>>>>>>>
76051>>>>>>>>>>>        
76051>>>>>>>>>>>        Function_Return (False)
76052>>>>>>>>>>>    End_Function
76053>>>>>>>>>>>    
76053>>>>>>>>>>>    //   Functions to query the Pervasive.SQL version:
76053>>>>>>>>>>>    //       PSQLRequesterVersionInfo    Integer iFileNum Returns String
76053>>>>>>>>>>>    //       PSQLLocalEngineVersionInfo  Integer iFileNum Returns String
76053>>>>>>>>>>>    //       PSQLServerEngineVersionInfo Integer iFileNum Returns String
76053>>>>>>>>>>>    //
76053>>>>>>>>>>>    //   All 3 functions return the version of a Pervasive.SQL component
76053>>>>>>>>>>>    //   in the following format:
76053>>>>>>>>>>>    //       <version>.<revision>.<type>
76053>>>>>>>>>>>    //   possible values for <type>:
76053>>>>>>>>>>>    //       9 for 32-bit Windows workstation/workgroup engine or Linux
76053>>>>>>>>>>>    //         server using Workgroup authentication mode
76053>>>>>>>>>>>    //       C for client cache engine
76053>>>>>>>>>>>    //       D for DOS workstation
76053>>>>>>>>>>>    //       N for client Requester
76053>>>>>>>>>>>    //       S for NetWare server
76053>>>>>>>>>>>    //       T for 32-bit Windows server engine
76053>>>>>>>>>>>    //       U for Linux server using PAM or BTPASSWD authentication
76053>>>>>>>>>>>    //
76053>>>>>>>>>>>    //   example:
76053>>>>>>>>>>>    //       8.50.T
76053>>>>>>>>>>>    //   will be returned for a Pervasive.SQL 8.5 Server Engine running on
76053>>>>>>>>>>>    //   32-bits Windows server.
76053>>>>>>>>>>>    //
76053>>>>>>>>>>>    //   The FileNumber parameter must specify an opened table or 0.
76053>>>>>>>>>>>    //   For PSQLServerEngineVersionInfo the FileNumber can not be 0.
76053>>>>>>>>>>>    //
76053>>>>>>>>>>>    //   If the version information is not available or can not be obtained
76053>>>>>>>>>>>    //   the functions will return "0.0.0"
76053>>>>>>>>>>>    
76053>>>>>>>>>>>    //  Returns the version information of the
76053>>>>>>>>>>>    //           Pervasive.SQL Client requester.
76053>>>>>>>>>>>    
76053>>>>>>>>>>>    Function PSQLRequesterVersionInfo Integer iFileNum Returns String
76055>>>>>>>>>>>        
76055>>>>>>>>>>>        String  sDriverID
76055>>>>>>>>>>>        String  sVersion
76055>>>>>>>>>>>        String  sVoid
76055>>>>>>>>>>>        Integer iRetval
76055>>>>>>>>>>>        
76055>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
76055>>>>>>>>>>>        // This error would otherwise be raised when we have an older
76055>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
76055>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
76056>>>>>>>>>>>        Get psDriverID to sDriverID
76057>>>>>>>>>>>        Move (Repeat(" ", 255)) to sVersion
76058>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLREQUESTERVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
76063>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
76064>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
76066>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
76066>>>>>>>>>>>            Move "0.0.0" to sVersion
76067>>>>>>>>>>>        End
76067>>>>>>>>>>>>
76067>>>>>>>>>>>        Function_Return sVersion
76068>>>>>>>>>>>    End_Function
76069>>>>>>>>>>>    
76069>>>>>>>>>>>    //           Pervasive.SQL Engine
76069>>>>>>>>>>>    
76069>>>>>>>>>>>    Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
76071>>>>>>>>>>>        
76071>>>>>>>>>>>        String  sDriverID
76071>>>>>>>>>>>        String  sVersion
76071>>>>>>>>>>>        String  sVoid
76071>>>>>>>>>>>        Integer iRetval
76071>>>>>>>>>>>        
76071>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
76071>>>>>>>>>>>        // This error would otherwise be raised when we have an older
76071>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
76071>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
76072>>>>>>>>>>>        Get psDriverID to sDriverID
76073>>>>>>>>>>>        Move (Repeat(" ", 255)) to sVersion
76074>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLLOCALENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
76079>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
76080>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
76082>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
76082>>>>>>>>>>>            Move "0.0.0" to sVersion
76083>>>>>>>>>>>        End
76083>>>>>>>>>>>>
76083>>>>>>>>>>>        Function_Return sVersion
76084>>>>>>>>>>>    End_Function
76085>>>>>>>>>>>    
76085>>>>>>>>>>>    //  Returns the version information of the
76085>>>>>>>>>>>    //           Pervasive.SQL Server Engine
76085>>>>>>>>>>>    
76085>>>>>>>>>>>    Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
76087>>>>>>>>>>>        
76087>>>>>>>>>>>        String  sDriverID
76087>>>>>>>>>>>        String  sVersion
76087>>>>>>>>>>>        String  sVoid
76087>>>>>>>>>>>        Integer iRetval
76087>>>>>>>>>>>        
76087>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
76087>>>>>>>>>>>        // This error would otherwise be raised when we have an older
76087>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
76087>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
76088>>>>>>>>>>>        Get psDriverID to sDriverID
76089>>>>>>>>>>>        Move (Repeat(" ", 255)) to sVersion
76090>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLSERVERENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
76095>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
76096>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
76098>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
76098>>>>>>>>>>>            Move "0.0.0" to sVersion
76099>>>>>>>>>>>        End
76099>>>>>>>>>>>>
76099>>>>>>>>>>>        Function_Return sVersion
76100>>>>>>>>>>>    End_Function
76101>>>>>>>>>>>    
76101>>>>>>>>>>>End_Class
76102>>>>>>>>>>>
76102>>>>>>>>>>>
76102>>>>>>>>>Use cSQLConnectionIniFile.inc
Including file: cSQLConnectionIniFile.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionIniFile.inc)
76102>>>>>>>>>>>//****************************************************************************
76102>>>>>>>>>>>// $Module type: Include file
76102>>>>>>>>>>>// $Module name: cSQLConnectionIniFile.inc
76102>>>>>>>>>>>//
76102>>>>>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International.
76102>>>>>>>>>>>// Copyright (c) 2012 RDC Tools International
76102>>>>>>>>>>>// E-mail      : support@rdctools.com
76102>>>>>>>>>>>// Web-site    : http://www.rdctools.com
76102>>>>>>>>>>>//
76102>>>>>>>>>>>// Created     : 2017-01-18 @ 13:04 (Military date format - Year-Month-Day)
76102>>>>>>>>>>>//
76102>>>>>>>>>>>// Note        : Header file with constant declarations for the cSQLConnectionIniFile class.
76102>>>>>>>>>>>//
76102>>>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
76102>>>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
76102>>>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
76102>>>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
76102>>>>>>>>>>>// in the help folder for more details.
76102>>>>>>>>>>>//
76102>>>>>>>>>>>Use Winkern.pkg
76102>>>>>>>>>>>Use cIniFile.pkg
76102>>>>>>>>>>>    Use cCryptographerEx.pkg
Including file: cCryptographerEx.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cCryptographerEx.pkg)
76102>>>>>>>>>>>>>Use VdfBase.pkg
76102>>>>>>>>>>>>>
76102>>>>>>>>>>>>>Use CryptographerConstants.pkg
Including file: CryptographerConstants.pkg    (C:\Program Files\DataFlex 20.1\Pkg\CryptographerConstants.pkg)
76102>>>>>>>>>>>>>>>//   Author  : Ulbe Stellema
76102>>>>>>>>>>>>>>>// Algorithm classes
76102>>>>>>>>>>>>>>>Define ALG_CLASS_ANY                    for |CI$00000000 // (0)
76102>>>>>>>>>>>>>>>Define ALG_CLASS_SIGNATURE              for |CI$00002000 // (1 << 13)
76102>>>>>>>>>>>>>>>Define ALG_CLASS_MSG_ENCRYPT            for |CI$00004000 // (2 << 13)
76102>>>>>>>>>>>>>>>Define ALG_CLASS_DATA_ENCRYPT           for |CI$00006000 // (3 << 13)
76102>>>>>>>>>>>>>>>Define ALG_CLASS_HASH                   for |CI$00008000 // (4 << 13)
76102>>>>>>>>>>>>>>>Define ALG_CLASS_KEY_EXCHANGE           for |CI$0000A000 // (5 << 13)
76102>>>>>>>>>>>>>>>Define ALG_CLASS_ALL                    for |CI$0000E000 // (7 << 13)
76102>>>>>>>>>>>>>>>
76102>>>>>>>>>>>>>>>// Algorithm types
76102>>>>>>>>>>>>>>>Define ALG_TYPE_ANY                     for |CI$00000000 // (0)
76102>>>>>>>>>>>>>>>Define ALG_TYPE_DSS                     for |CI$00000200 // (1 << 9)
76102>>>>>>>>>>>>>>>Define ALG_TYPE_RSA                     for |CI$00000400 // (2 << 9)
76102>>>>>>>>>>>>>>>Define ALG_TYPE_BLOCK                   for |CI$00000600 // (3 << 9)
76102>>>>>>>>>>>>>>>Define ALG_TYPE_STREAM                  for |CI$00000800 // (4 << 9)
76102>>>>>>>>>>>>>>>Define ALG_TYPE_DH                      for |CI$00000A00 // (5 << 9)
76102>>>>>>>>>>>>>>>Define ALG_TYPE_SECURECHANNEL           for |CI$00000C00 // (6 << 9)
76102>>>>>>>>>>>>>>>
76102>>>>>>>>>>>>>>>// Generic sub-ids
76102>>>>>>>>>>>>>>>Define ALG_SID_ANY                      for |CI$00000000 // (0)
76102>>>>>>>>>>>>>>>
76102>>>>>>>>>>>>>>>// RSA sub-ids
76102>>>>>>>>>>>>>>>Define ALG_SID_RSA_ANY                  for 0
76102>>>>>>>>>>>>>>>Define ALG_SID_RSA_PKCS                 for 1
76102>>>>>>>>>>>>>>>Define ALG_SID_RSA_MSATWORK             for 2
76102>>>>>>>>>>>>>>>Define ALG_SID_RSA_ENTRUST              for 3
76102>>>>>>>>>>>>>>>Define ALG_SID_RSA_PGP                  for 4
76102>>>>>>>>>>>>>>>
76102>>>>>>>>>>>>>>>// DSS sub-ids
76102>>>>>>>>>>>>>>>Define ALG_SID_DSS_ANY                  for 0
76102>>>>>>>>>>>>>>>Define ALG_SID_DSS_PKCS                 for 1
76102>>>>>>>>>>>>>>>Define ALG_SID_DSS_DMS                  for 2
76102>>>>>>>>>>>>>>>
76102>>>>>>>>>>>>>>>// DES sub_ids
76102>>>>>>>>>>>>>>>Define ALG_SID_DES                      for 1
76102>>>>>>>>>>>>>>>Define ALG_SID_3DES                     for 3
76102>>>>>>>>>>>>>>>Define ALG_SID_DESX                     for 4
76102>>>>>>>>>>>>>>>Define ALG_SID_IDEA                     for 5
76102>>>>>>>>>>>>>>>Define ALG_SID_CAST                     for 6
76102>>>>>>>>>>>>>>>Define ALG_SID_SAFERSK64                for 7
76102>>>>>>>>>>>>>>>Define ALG_SID_SAFERSK128               for 8
76102>>>>>>>>>>>>>>>Define ALG_SID_3DES_112                 for 9
76102>>>>>>>>>>>>>>>Define ALG_SID_CYLINK_MEK               for 12
76102>>>>>>>>>>>>>>>Define ALG_SID_RC5                      for 13
76102>>>>>>>>>>>>>>>Define ALG_SID_AES_128                  for 14
76102>>>>>>>>>>>>>>>Define ALG_SID_AES_192                  for 15
76102>>>>>>>>>>>>>>>Define ALG_SID_AES_256                  for 16
76102>>>>>>>>>>>>>>>Define ALG_SID_AES                      for 17
76102>>>>>>>>>>>>>>>
76102>>>>>>>>>>>>>>>// Fortezza sub-ids
76102>>>>>>>>>>>>>>>Define ALG_SID_SKIPJACK                 for 10
76102>>>>>>>>>>>>>>>Define ALG_SID_TEK                      for 11
76102>>>>>>>>>>>>>>>
76102>>>>>>>>>>>>>>>// RC2 sub-ids
76102>>>>>>>>>>>>>>>Define ALG_SID_RC2                      for 2
76102>>>>>>>>>>>>>>>
76102>>>>>>>>>>>>>>>// Stream cipher sub-ids
76102>>>>>>>>>>>>>>>Define ALG_SID_RC4                      for 1
76102>>>>>>>>>>>>>>>Define ALG_SID_SEAL                     for 2
76102>>>>>>>>>>>>>>>
76102>>>>>>>>>>>>>>>// Diffie-Hellman sub-ids
76102>>>>>>>>>>>>>>>Define ALG_SID_DH_SANDF                 for 1
76102>>>>>>>>>>>>>>>Define ALG_SID_DH_EPHEM                 for 2
76102>>>>>>>>>>>>>>>Define ALG_SID_AGREED_KEY_ANY           for 3
76102>>>>>>>>>>>>>>>Define ALG_SID_KEA                      for 4
76102>>>>>>>>>>>>>>>
76102>>>>>>>>>>>>>>>// Hash sub ids
76102>>>>>>>>>>>>>>>Define ALG_SID_MD2                      for 1
76102>>>>>>>>>>>>>>>Define ALG_SID_MD4                      for 2
76102>>>>>>>>>>>>>>>Define ALG_SID_MD5                      for 3
76102>>>>>>>>>>>>>>>Define ALG_SID_SHA                      for 4
76102>>>>>>>>>>>>>>>Define ALG_SID_SHA1                     for 4
76102>>>>>>>>>>>>>>>Define ALG_SID_MAC                      for 5
76102>>>>>>>>>>>>>>>Define ALG_SID_RIPEMD                   for 6
76102>>>>>>>>>>>>>>>Define ALG_SID_RIPEMD160                for 7
76102>>>>>>>>>>>>>>>Define ALG_SID_SSL3SHAMD5               for 8
76102>>>>>>>>>>>>>>>Define ALG_SID_HMAC                     for 9
76102>>>>>>>>>>>>>>>Define ALG_SID_TLS1PRF                  for 10
76102>>>>>>>>>>>>>>>Define ALG_SID_HASH_REPLACE_OWF         for 11
76102>>>>>>>>>>>>>>>Define ALG_SID_SHA_256                  for 12
76102>>>>>>>>>>>>>>>Define ALG_SID_SHA_384                  for 13
76102>>>>>>>>>>>>>>>Define ALG_SID_SHA_512                  for 14
76102>>>>>>>>>>>>>>>
76102>>>>>>>>>>>>>>>// secure channel sub ids
76102>>>>>>>>>>>>>>>Define ALG_SID_SSL3_MASTER              for 1
76102>>>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_MASTER_HASH     for 2
76102>>>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_MAC_KEY         for 3
76102>>>>>>>>>>>>>>>Define ALG_SID_PCT1_MASTER              for 4
76102>>>>>>>>>>>>>>>Define ALG_SID_SSL2_MASTER              for 5
76102>>>>>>>>>>>>>>>Define ALG_SID_TLS1_MASTER              for 6
76102>>>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_ENC_KEY         for 7
76102>>>>>>>>>>>>>>>
76102>>>>>>>>>>>>>>>// algorithm identifier definitions
76102>>>>>>>>>>>>>>>Define CALG_MD2                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD2)
76102>>>>>>>>>>>>>>>Define CALG_MD4                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD4)
76102>>>>>>>>>>>>>>>Define CALG_MD5                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD5)
76102>>>>>>>>>>>>>>>Define CALG_SHA                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA)
76102>>>>>>>>>>>>>>>Define CALG_SHA1                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA1)
76102>>>>>>>>>>>>>>>Define CALG_MAC                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MAC)
76102>>>>>>>>>>>>>>>Define CALG_RSA_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
76102>>>>>>>>>>>>>>>Define CALG_DSS_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_DSS ior ALG_SID_DSS_ANY)
76102>>>>>>>>>>>>>>>Define CALG_NO_SIGN                     for (ALG_CLASS_SIGNATURE ior ALG_TYPE_ANY ior ALG_SID_ANY)
76102>>>>>>>>>>>>>>>Define CALG_RSA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
76102>>>>>>>>>>>>>>>Define CALG_DES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DES)
76102>>>>>>>>>>>>>>>Define CALG_3DES_112                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES_112)
76102>>>>>>>>>>>>>>>Define CALG_3DES                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES)
76102>>>>>>>>>>>>>>>Define CALG_DESX                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DESX)
76102>>>>>>>>>>>>>>>Define CALG_RC2                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC2)
76102>>>>>>>>>>>>>>>Define CALG_RC4                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_RC4)
76102>>>>>>>>>>>>>>>Define CALG_SEAL                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_SEAL)
76102>>>>>>>>>>>>>>>Define CALG_DH_SF                       for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_SANDF)
76102>>>>>>>>>>>>>>>Define CALG_DH_EPHEM                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_EPHEM)
76102>>>>>>>>>>>>>>>Define CALG_AGREEDKEY_ANY               for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_AGREED_KEY_ANY)
76102>>>>>>>>>>>>>>>Define CALG_KEA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_KEA)
76102>>>>>>>>>>>>>>>Define CALG_HUGHES_MD5                  for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_ANY ior ALG_SID_MD5)
76102>>>>>>>>>>>>>>>Define CALG_SKIPJACK                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_SKIPJACK)
76102>>>>>>>>>>>>>>>Define CALG_TEK                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_TEK)
76102>>>>>>>>>>>>>>>Define CALG_CYLINK_MEK                  for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_CYLINK_MEK)
76102>>>>>>>>>>>>>>>Define CALG_SSL3_SHAMD5                 for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SSL3SHAMD5)
76102>>>>>>>>>>>>>>>Define CALG_SSL3_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL3_MASTER)
76102>>>>>>>>>>>>>>>Define CALG_SCHANNEL_MASTER_HASH        for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MASTER_HASH)
76102>>>>>>>>>>>>>>>Define CALG_SCHANNEL_MAC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MAC_KEY)
76102>>>>>>>>>>>>>>>Define CALG_SCHANNEL_ENC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_ENC_KEY)
76102>>>>>>>>>>>>>>>Define CALG_PCT1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_PCT1_MASTER)
76102>>>>>>>>>>>>>>>Define CALG_SSL2_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL2_MASTER)
76102>>>>>>>>>>>>>>>Define CALG_TLS1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_TLS1_MASTER)
76102>>>>>>>>>>>>>>>Define CALG_RC5                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC5)
76102>>>>>>>>>>>>>>>Define CALG_HMAC                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HMAC)
76102>>>>>>>>>>>>>>>Define CALG_TLS1PRF                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_TLS1PRF)
76102>>>>>>>>>>>>>>>Define CALG_HASH_REPLACE_OWF            for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HASH_REPLACE_OWF)
76102>>>>>>>>>>>>>>>Define CALG_AES_128                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_128)
76102>>>>>>>>>>>>>>>Define CALG_AES_192                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_192)
76102>>>>>>>>>>>>>>>Define CALG_AES_256                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_256)
76102>>>>>>>>>>>>>>>Define CALG_AES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES)
76102>>>>>>>>>>>>>>>Define CALG_SHA_256                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_256)
76102>>>>>>>>>>>>>>>Define CALG_SHA_384                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_384)
76102>>>>>>>>>>>>>>>Define CALG_SHA_512                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_512)
76102>>>>>>>>>>>>>>>
76102>>>>>>>>>>>>>>>// Providers
76102>>>>>>>>>>>>>>>Define MS_DEF_PROV                      for "Microsoft Base Cryptographic Provider v1.0"
76102>>>>>>>>>>>>>>>Define MS_ENHANCED_PROV                 for "Microsoft Enhanced Cryptographic Provider v1.0"
76102>>>>>>>>>>>>>>>Define MS_STRONG_PROV                   for "Microsoft Strong Cryptographic Provider"
76102>>>>>>>>>>>>>>>Define MS_DEF_RSA_SIG_PROV              for "Microsoft RSA Signature Cryptographic Provider"
76102>>>>>>>>>>>>>>>Define MS_DEF_RSA_SCHANNEL_PROV         for "Microsoft RSA SChannel Cryptographic Provider"
76102>>>>>>>>>>>>>>>Define MS_DEF_DSS_PROV                  for "Microsoft Base DSS Cryptographic Provider"
76102>>>>>>>>>>>>>>>Define MS_DEF_DSS_DH_PROV               for "Microsoft Base DSS and Diffie-Hellman Cryptographic Provider"
76102>>>>>>>>>>>>>>>Define MS_ENH_DSS_DH_PROV               for "Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider"
76102>>>>>>>>>>>>>>>Define MS_DEF_DH_SCHANNEL_PROV          for "Microsoft DH SChannel Cryptographic Provider"
76102>>>>>>>>>>>>>>>Define MS_SCARD_PROV                    for "Microsoft Base Smart Card Crypto Provider"
76102>>>>>>>>>>>>>>>Define MS_ENH_RSA_AES_PROV              for "Microsoft Enhanced RSA and AES Cryptographic Provider"
76102>>>>>>>>>>>>>>>
76102>>>>>>>>>>>>>>>// dwFlags definitions for CryptAcquireContext
76102>>>>>>>>>>>>>>>Define CRYPT_VERIFYCONTEXT              for |CI$F0000000
76102>>>>>>>>>>>>>>>Define CRYPT_NEWKEYSET                  for |CI$00000008
76102>>>>>>>>>>>>>>>Define CRYPT_DELETEKEYSET               for |CI$00000010
76102>>>>>>>>>>>>>>>Define CRYPT_MACHINE_KEYSET             for |CI$00000020
76102>>>>>>>>>>>>>>>Define CRYPT_SILENT                     for |CI$00000040
76102>>>>>>>>>>>>>>>
76102>>>>>>>>>>>>>>>// dwFlag definitions for CryptGenKey
76102>>>>>>>>>>>>>>>Define CRYPT_EXPORTABLE                 for |CI$00000001
76102>>>>>>>>>>>>>>>Define CRYPT_USER_PROTECTED             for |CI$00000002
76102>>>>>>>>>>>>>>>Define CRYPT_CREATE_SALT                for |CI$00000004
76102>>>>>>>>>>>>>>>Define CRYPT_UPDATE_KEY                 for |CI$00000008
76102>>>>>>>>>>>>>>>Define CRYPT_NO_SALT                    for |CI$00000010
76102>>>>>>>>>>>>>>>Define CRYPT_PREGEN                     for |CI$00000040
76102>>>>>>>>>>>>>>>Define CRYPT_RECIPIENT                  for |CI$00000010
76102>>>>>>>>>>>>>>>Define CRYPT_INITIATOR                  for |CI$00000040
76102>>>>>>>>>>>>>>>Define CRYPT_ONLINE                     for |CI$00000080
76102>>>>>>>>>>>>>>>Define CRYPT_SF                         for |CI$00000100
76102>>>>>>>>>>>>>>>Define CRYPT_CREATE_IV                  for |CI$00000200
76102>>>>>>>>>>>>>>>Define CRYPT_KEK                        for |CI$00000400
76102>>>>>>>>>>>>>>>Define CRYPT_DATA_KEY                   for |CI$00000800
76102>>>>>>>>>>>>>>>Define CRYPT_VOLATILE                   for |CI$00001000
76102>>>>>>>>>>>>>>>Define CRYPT_SGCKEY                     for |CI$00002000
76102>>>>>>>>>>>>>>>Define CRYPT_ARCHIVABLE                 for |CI$00004000
76102>>>>>>>>>>>>>>>
76102>>>>>>>>>>>>>>>// Provider types
76102>>>>>>>>>>>>>>>Define PROV_RSA_FULL                    for 1
76102>>>>>>>>>>>>>>>Define PROV_RSA_SIG                     for 2
76102>>>>>>>>>>>>>>>Define PROV_DSS                         for 3
76102>>>>>>>>>>>>>>>Define PROV_FORTEZZA                    for 4
76102>>>>>>>>>>>>>>>Define PROV_MS_EXCHANGE                 for 5
76102>>>>>>>>>>>>>>>Define PROV_SSL                         for 6
76102>>>>>>>>>>>>>>>Define PROV_RSA_SCHANNEL                for 12
76102>>>>>>>>>>>>>>>Define PROV_DSS_DH                      for 13
76102>>>>>>>>>>>>>>>Define PROV_EC_ECDSA_SIG                for 14
76102>>>>>>>>>>>>>>>Define PROV_EC_ECNRA_SIG                for 15
76102>>>>>>>>>>>>>>>Define PROV_EC_ECDSA_FULL               for 16
76102>>>>>>>>>>>>>>>Define PROV_EC_ECNRA_FULL               for 17
76102>>>>>>>>>>>>>>>Define PROV_DH_SCHANNEL                 for 18
76102>>>>>>>>>>>>>>>Define PROV_SPYRUS_LYNKS                for 20
76102>>>>>>>>>>>>>>>Define PROV_RNG                         for 21
76102>>>>>>>>>>>>>>>Define PROV_INTEL_SEC                   for 22
76102>>>>>>>>>>>>>>>Define PROV_REPLACE_OWF                 for 23
76102>>>>>>>>>>>>>>>Define PROV_RSA_AES                     for 24
76102>>>>>>>>>>>>>>>
76102>>>>>>>>>>>>>>>// KP_MODE
76102>>>>>>>>>>>>>>>// KP_MODE
76102>>>>>>>>>>>>>>>Define CRYPT_MODE_CBC                   for 1       // Cipher block chaining
76102>>>>>>>>>>>>>>>Define CRYPT_MODE_ECB                   for 2       // Electronic code book
76102>>>>>>>>>>>>>>>Define CRYPT_MODE_OFB                   for 3       // Output feedback mode
76102>>>>>>>>>>>>>>>Define CRYPT_MODE_CFB                   for 4       // Cipher feedback mode
76102>>>>>>>>>>>>>>>Define CRYPT_MODE_CTS                   for 5       // Ciphertext stealing mode
76102>>>>>>>>>>>>>>>Define CRYPT_MODE_CBCI                  for 6       // ANSI CBC Interleaved
76102>>>>>>>>>>>>>>>Define CRYPT_MODE_CFBP                  for 7       // ANSI CFB Pipelined
76102>>>>>>>>>>>>>>>Define CRYPT_MODE_OFBP                  for 8       // ANSI OFB Pipelined
76102>>>>>>>>>>>>>>>Define CRYPT_MODE_CBCOFM                for 9       // ANSI CBC + OF Masking
76102>>>>>>>>>>>>>>>Define CRYPT_MODE_CBCOFMI               for 10      // ANSI CBC + OFM Interleaved
76102>>>>>>>>>>>>>>>
76102>>>>>>>>>>>>>>>// dwParam definitions for CryptGetKeyParam
76102>>>>>>>>>>>>>>>Define KP_IV                            for 1       // Initialization vector
76102>>>>>>>>>>>>>>>Define KP_SALT                          for 2       // Salt value
76102>>>>>>>>>>>>>>>Define KP_PADDING                       for 3       // Padding values
76102>>>>>>>>>>>>>>>Define KP_MODE                          for 4       // Mode of the cipher
76102>>>>>>>>>>>>>>>Define KP_MODE_BITS                     for 5       // Number of bits to feedback
76102>>>>>>>>>>>>>>>Define KP_PERMISSIONS                   for 6       // Key permissions DWORD
76102>>>>>>>>>>>>>>>Define KP_ALGID                         for 7       // Key algorithm
76102>>>>>>>>>>>>>>>Define KP_BLOCKLEN                      for 8       // Block size of the cipher
76102>>>>>>>>>>>>>>>Define KP_KEYLEN                        for 9       // Length of key in bits
76102>>>>>>>>>>>>>>>Define KP_SALT_EX                       for 10      // Length of salt in bytes
76102>>>>>>>>>>>>>>>Define KP_P                             for 11      // DSS/Diffie-Hellman P value
76102>>>>>>>>>>>>>>>Define KP_G                             for 12      // DSS/Diffie-Hellman G value
76102>>>>>>>>>>>>>>>Define KP_Q                             for 13      // DSS Q value
76102>>>>>>>>>>>>>>>Define KP_X                             for 14      // Diffie-Hellman X value
76102>>>>>>>>>>>>>>>Define KP_Y                             for 15      // Y value
76102>>>>>>>>>>>>>>>Define KP_RA                            for 16      // Fortezza RA value
76102>>>>>>>>>>>>>>>Define KP_RB                            for 17      // Fortezza RB value
76102>>>>>>>>>>>>>>>Define KP_INFO                          for 18      // for putting information into an RSA envelope
76102>>>>>>>>>>>>>>>Define KP_EFFECTIVE_KEYLEN              for 19      // setting and getting RC2 effective key length
76102>>>>>>>>>>>>>>>Define KP_SCHANNEL_ALG                  for 20      // for setting the Secure Channel algorithms
76102>>>>>>>>>>>>>>>Define KP_CLIENT_RANDOM                 for 21      // for setting the Secure Channel client random data
76102>>>>>>>>>>>>>>>Define KP_SERVER_RANDOM                 for 22      // for setting the Secure Channel server random data
76102>>>>>>>>>>>>>>>Define KP_RP                            for 23
76102>>>>>>>>>>>>>>>Define KP_PRECOMP_MD5                   for 24
76102>>>>>>>>>>>>>>>Define KP_PRECOMP_SHA                   for 25
76102>>>>>>>>>>>>>>>Define KP_CERTIFICATE                   for 26      // for setting Secure Channel certificate data (PCT1)
76102>>>>>>>>>>>>>>>Define KP_CLEAR_KEY                     for 27      // for setting Secure Channel clear key data (PCT1)
76102>>>>>>>>>>>>>>>Define KP_PUB_EX_LEN                    for 28
76102>>>>>>>>>>>>>>>Define KP_PUB_EX_VAL                    for 29
76102>>>>>>>>>>>>>>>Define KP_KEYVAL                        for 30
76102>>>>>>>>>>>>>>>Define KP_ADMIN_PIN                     for 31
76102>>>>>>>>>>>>>>>Define KP_KEYEXCHANGE_PIN               for 32
76102>>>>>>>>>>>>>>>Define KP_SIGNATURE_PIN                 for 33
76102>>>>>>>>>>>>>>>Define KP_PREHASH                       for 34
76102>>>>>>>>>>>>>>>Define KP_ROUNDS                        for 35
76102>>>>>>>>>>>>>>>Define KP_OAEP_PARAMS                   for 36      // for setting OAEP params on RSA keys
76102>>>>>>>>>>>>>>>Define KP_CMS_KEY_INFO                  for 37
76102>>>>>>>>>>>>>>>Define KP_CMS_DH_KEY_INFO               for 38
76102>>>>>>>>>>>>>>>Define KP_PUB_PARAMS                    for 39      // for setting public parameters
76102>>>>>>>>>>>>>>>Define KP_VERIFY_PARAMS                 for 40      // for verifying DSA and DH parameters
76102>>>>>>>>>>>>>>>Define KP_HIGHEST_VERSION               for 41      // for TLS protocol version setting
76102>>>>>>>>>>>>>>>Define KP_GET_USE_COUNT                 for 42      // for use with PP_CRYPT_COUNT_KEY_USE contexts
76102>>>>>>>>>>>>>>>
76102>>>>>>>>>>>>>>>// dwParam definitions for CryptGetHashParam
76102>>>>>>>>>>>>>>>Define HP_ALGID                         for |CI$0001  // Hash algorithm
76102>>>>>>>>>>>>>>>Define HP_HASHVAL                       for |CI$0002  // Hash value
76102>>>>>>>>>>>>>>>Define HP_HASHSIZE                      for |CI$0004  // Hash value size
76102>>>>>>>>>>>>>>>Define HP_HMAC_INFO                     for |CI$0005  // information for creating an HMA
76102>>>>>>>>>>>>>>>
76102>>>>>>>>>>>>>>>// key BLOB types
76102>>>>>>>>>>>>>>>Define KEYSTATEBLOB                     for |CI$0C
76102>>>>>>>>>>>>>>>Define OPAQUEKEYBLOB                    for |CI$09
76102>>>>>>>>>>>>>>>Define PLAINTEXTKEYBLOB                 for |CI$08
76102>>>>>>>>>>>>>>>Define PRIVATEKEYBLOB                   for |CI$07
76102>>>>>>>>>>>>>>>Define PUBLICKEYBLOB                    for |CI$06
76102>>>>>>>>>>>>>>>Define PUBLICKEYBLOBEX                  for |CI$0A
76102>>>>>>>>>>>>>>>Define SIMPLEBLOB                       for |CI$01
76102>>>>>>>>>>>>>>>Define SYMMETRICWRAPKEYBLOB             for |CI$0B
76102>>>>>>>>>>>>>>>
76102>>>>>>>>>>>>>>>Define CUR_BLOB_VERSION                 for 2
76102>>>>>>>>>>>>>>>
76102>>>>>>>>>>>>>>>// KP_PADDING
76102>>>>>>>>>>>>>>>Define PKCS5_PADDING                    for 1       // PKCS 5 (sec 6.2) padding method
76102>>>>>>>>>>>>>>>Define RANDOM_PADDING                   for 2
76102>>>>>>>>>>>>>>>Define ZERO_PADDING                     for 3
76102>>>>>>>>>>>>>>>
76102>>>>>>>>>>>>>>>//  Structure cryptimportkey
76102>>>>>>>>>>>>>>>Struct PUBLICKEYSTRUC
76102>>>>>>>>>>>>>>>    UChar    bType
76102>>>>>>>>>>>>>>>    UChar    bVersion
76102>>>>>>>>>>>>>>>    UShort   reserved
76102>>>>>>>>>>>>>>>    UInteger aiKeyAlg
76102>>>>>>>>>>>>>>>End_Struct
76102>>>>>>>>>>>>>>>
76102>>>>>>>>>>>>>>>Struct tPLAINTEXTKEYBLOB
76102>>>>>>>>>>>>>>>    PUBLICKEYSTRUC hdr
76102>>>>>>>>>>>>>>>    PUBLICKEYSTRUC hdr
76102>>>>>>>>>>>>>>>    UInteger       dwKeySize
76102>>>>>>>>>>>>>>>//    UChar[]        rgbKeyData
76102>>>>>>>>>>>>>>>End_Struct
76102>>>>>>>>>>>>>>>
76102>>>>>>>>>>>>>>>
76102>>>>>>>>>>>>>>>
76102>>>>>>>>>>>>>>>//  Structure for specifying the inner and outer strings when calculating HMAC hash (use with CryptSetHashParam)
76102>>>>>>>>>>>>>>>Struct HMAC_INFO
76102>>>>>>>>>>>>>>>    UInteger HashAlgid
76102>>>>>>>>>>>>>>>    Pointer pbInnerString
76102>>>>>>>>>>>>>>>    DWord cbInnerString
76102>>>>>>>>>>>>>>>    Pointer pbOuterString
76102>>>>>>>>>>>>>>>    DWord cbOuterString
76102>>>>>>>>>>>>>>>End_Struct
76102>>>>>>>>>>>>>>>
76102>>>>>>>>>>>>>>>Struct BLOBHEADER
76102>>>>>>>>>>>>>>>    UChar   bType
76102>>>>>>>>>>>>>>>    UChar   bVersion
76102>>>>>>>>>>>>>>>    Short   reserved
76102>>>>>>>>>>>>>>>    Integer aiKeyAlg
76102>>>>>>>>>>>>>>>End_Struct
76102>>>>>>>>>>>>>>>
76102>>>>>>>>>>>>>>>Struct CryptoBlob
76102>>>>>>>>>>>>>>>    BLOBHEADER  header
76102>>>>>>>>>>>>>>>    BLOBHEADER  header
76102>>>>>>>>>>>>>>>    Integer     cbKeySize
76102>>>>>>>>>>>>>>>    UChar[32]   rgbKeyData
76102>>>>>>>>>>>>>>>End_Struct
76102>>>>>>>>>>>>>>>
76102>>>>>>>>>>>>>>>
76102>>>>>>>>>>>>>>>// Note: lpContainer and lpProvider refer to WString types.
76102>>>>>>>>>>>>>>>External_Function CryptAcquireContextW "CryptAcquireContextW" advapi32.dll ;    Pointer phProv ;    Pointer lpContainer ;    Pointer lpProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
76103>>>>>>>>>>>>>>>
76103>>>>>>>>>>>>>>>// Compatibilty wrapper Function CryptAcquireContext
76103>>>>>>>>>>>>>>>Function CryptAcquireContext Global ;    Pointer phProv ;    Pointer szContainer ;    Pointer szProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
76105>>>>>>>>>>>>>>>    
76105>>>>>>>>>>>>>>>    Boolean bResult
76105>>>>>>>>>>>>>>>    UWide   uwContainer uwProvider
76105>>>>>>>>>>>>>>>    UWide   uwContainer uwProvider
76105>>>>>>>>>>>>>>>
76105>>>>>>>>>>>>>>>    Send StringToWide szContainer (&uwContainer)
76106>>>>>>>>>>>>>>>    Send StringToWide szProvider (&uwProvider)
76107>>>>>>>>>>>>>>>    
76107>>>>>>>>>>>>>>>    Move (CryptAcquireContextW (phProv, uwContainer.lpUText, uwProvider.lpUText, dwProvType, dwFlags)) to bResult                   
76108>>>>>>>>>>>>>>>
76108>>>>>>>>>>>>>>>    Function_Return bResult
76109>>>>>>>>>>>>>>>End_Function
76110>>>>>>>>>>>>>>>
76110>>>>>>>>>>>>>>>External_Function CryptReleaseContext "CryptReleaseContext" advapi32.dll ;    Handle hProv ;    Integer dwFlags ;    Returns Boolean
76111>>>>>>>>>>>>>>>
76111>>>>>>>>>>>>>>>External_Function CryptCreateHash "CryptCreateHash" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hKey ;    Integer dwFlags ;    Pointer phHash ;    Returns Boolean
76112>>>>>>>>>>>>>>>
76112>>>>>>>>>>>>>>>External_Function CryptDestroyHash "CryptDestroyHash" advapi32.dll ;    Handle hHash ;    Returns Boolean
76113>>>>>>>>>>>>>>>
76113>>>>>>>>>>>>>>>External_Function CryptHashData "CryptHashData" advapi32.dll ;    Handle hHash ;    Pointer pbData ;    Integer dwDataLen ;    Integer dwFlags ;    Returns Boolean
76114>>>>>>>>>>>>>>>
76114>>>>>>>>>>>>>>>External_Function CryptDeriveKey "CryptDeriveKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hBaseData ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
76115>>>>>>>>>>>>>>>
76115>>>>>>>>>>>>>>>External_Function CryptGetHashParam "CryptGetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    DWord dwFlags ;    Returns Integer
76116>>>>>>>>>>>>>>>
76116>>>>>>>>>>>>>>>External_Function CryptDestroyKey "CryptDestroyKey" advapi32.dll ;    Handle hKey ;    Returns Boolean
76117>>>>>>>>>>>>>>>
76117>>>>>>>>>>>>>>>External_Function CryptImportKey "CryptImportKey" advapi32.dll ;    Handle hProv ;    Pointer pbData ;    Integer dwDataLen ;    Handle hPubKey ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
76118>>>>>>>>>>>>>>>
76118>>>>>>>>>>>>>>>External_Function CryptGetKeyParam "CryptGetKeyParam" advapi32.dll ;    Handle hKey ;    Integer dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwFlags ;    Returns Boolean
76119>>>>>>>>>>>>>>>    
76119>>>>>>>>>>>>>>>External_Function CryptSetKeyParam "CryptSetKeyParam" advapi32.dll ;    Handle   hKey ;    UInteger dwParam ;    Pointer  pbdata ;    UInteger dwFlags ;    Returns  Boolean
76120>>>>>>>>>>>>>>>
76120>>>>>>>>>>>>>>>External_Function CryptEncrypt "CryptEncrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwBufLen ;    Returns Boolean
76121>>>>>>>>>>>>>>>
76121>>>>>>>>>>>>>>>External_Function CryptDecrypt "CryptDecrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
76122>>>>>>>>>>>>>>>
76122>>>>>>>>>>>>>>>External_Function CryptGenRandom "CryptGenRandom" advapi32.dll ;    Handle hProv ;    DWord dwLen ;    Pointer pbBuffer ;    Returns Boolean
76123>>>>>>>>>>>>>>>    
76123>>>>>>>>>>>>>>>External_Function CryptSetHashParam "CryptSetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Integer dwFlags ;    Returns Boolean
76124>>>>>>>>>>>>>>>    
76124>>>>>>>>>>>>>>>External_Function CryptGenKey "CryptGenKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
76125>>>>>>>>>>>>>>>    
76125>>>>>>>>>>>>>>>External_Function CryptExportKey "CryptExportKey" advapi32.dll ;    Handle hKey ;    Handle hExpKey ;    Integer dwBlobType ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
76126>>>>>>>>>>>>>
76126>>>>>>>>>>>>>Class cCryptographerEx is a cObject
76127>>>>>>>>>>>>>    
76127>>>>>>>>>>>>>    Procedure Construct_Object
76129>>>>>>>>>>>>>        Forward Send Construct_Object
76131>>>>>>>>>>>>>        
76131>>>>>>>>>>>>>        Property String     psProvider  MS_ENHANCED_PROV
76132>>>>>>>>>>>>>        Property Integer    piProvider  PROV_RSA_FULL
76133>>>>>>>>>>>>>        Property Integer    piCipher    CALG_RC4
76134>>>>>>>>>>>>>        Property Integer    piHash      CALG_MD5
76135>>>>>>>>>>>>>        
76135>>>>>>>>>>>>>        // Private properties
76135>>>>>>>>>>>>>        Property Handle     Private_phProv
76136>>>>>>>>>>>>>        
76136>>>>>>>>>>>>>        // Block cipher properties
76136>>>>>>>>>>>>>        Property UChar[]    paKey
76137>>>>>>>>>>>>>        Property UChar[]    paIV
76138>>>>>>>>>>>>>        Property Integer    piKeyAlg        PLAINTEXTKEYBLOB
76139>>>>>>>>>>>>>        Property Integer    piKeyType       CALG_AES_256
76140>>>>>>>>>>>>>        Property Integer    piKeyPadding    PKCS5_PADDING
76141>>>>>>>>>>>>>        Property Integer    piKeyMode       CRYPT_MODE_CBC
76142>>>>>>>>>>>>>        Property Integer    piBlockSize     16
76143>>>>>>>>>>>>>    End_Procedure
76144>>>>>>>>>>>>>    
76144>>>>>>>>>>>>>    
76144>>>>>>>>>>>>>    // Acquire key container handle
76144>>>>>>>>>>>>>    Function AcquireContext Returns Handle
76146>>>>>>>>>>>>>        Integer iProvider
76146>>>>>>>>>>>>>        WString wProvider
76146>>>>>>>>>>>>>        Handle hProv
76146>>>>>>>>>>>>>        Boolean bOk
76146>>>>>>>>>>>>>        Pointer pProv
76146>>>>>>>>>>>>>        
76146>>>>>>>>>>>>>        Move 0 to hProv
76147>>>>>>>>>>>>>        Get piProvider to iProvider
76148>>>>>>>>>>>>>        Get psProvider to wProvider
76149>>>>>>>>>>>>>        
76149>>>>>>>>>>>>>        //  Determine address to be passed as provider
76149>>>>>>>>>>>>>        If (Trim(wProvider) <> "") Begin
76151>>>>>>>>>>>>>            Move (AddressOf(wProvider)) to pProv
76152>>>>>>>>>>>>>        End
76152>>>>>>>>>>>>>>
76152>>>>>>>>>>>>>        Else Begin
76153>>>>>>>>>>>>>            Move 0 to pProv
76154>>>>>>>>>>>>>        End
76154>>>>>>>>>>>>>>
76154>>>>>>>>>>>>>        
76154>>>>>>>>>>>>>        //  Acquire Crypto Context. Note: pProv is pointer to UTF16 string.
76154>>>>>>>>>>>>>        Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_VERIFYCONTEXT)) to bOk
76155>>>>>>>>>>>>>        If (not(bOk) or hProv = 0) Begin
76157>>>>>>>>>>>>>            Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_NEWKEYSET ior CRYPT_VERIFYCONTEXT)) to bOk
76158>>>>>>>>>>>>>        End
76158>>>>>>>>>>>>>>
76158>>>>>>>>>>>>>        
76158>>>>>>>>>>>>>        If (not(bOk) or hProv = 0) Begin
76160>>>>>>>>>>>>>            // Fallback to original
76160>>>>>>>>>>>>>            Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,0)) to bOk
76161>>>>>>>>>>>>>            
76161>>>>>>>>>>>>>            If (not(bOk) or hProv = 0) Begin
76163>>>>>>>>>>>>>                Move (CryptAcquireContextW(AddressOf(hProv),0,pProv,iProvider,CRYPT_NEWKEYSET)) to bOk
76164>>>>>>>>>>>>>            End
76164>>>>>>>>>>>>>>
76164>>>>>>>>>>>>>        End
76164>>>>>>>>>>>>>>
76164>>>>>>>>>>>>>        Set Private_phProv to hProv
76165>>>>>>>>>>>>>        
76165>>>>>>>>>>>>>        Function_Return hProv
76166>>>>>>>>>>>>>    End_Function
76167>>>>>>>>>>>>>    
76167>>>>>>>>>>>>>    // Releases key container handle
76167>>>>>>>>>>>>>    Function ReleaseContext Handle hProv Returns Boolean
76169>>>>>>>>>>>>>        Function_Return (CryptReleaseContext(hProv,0))
76170>>>>>>>>>>>>>    End_Function
76171>>>>>>>>>>>>>    
76171>>>>>>>>>>>>>    // Creates hash object
76171>>>>>>>>>>>>>    Function CreateHash Handle hProv Returns Handle
76173>>>>>>>>>>>>>        Integer iAlgorithm
76173>>>>>>>>>>>>>        Handle hHash
76173>>>>>>>>>>>>>        Boolean bOk
76173>>>>>>>>>>>>>        
76173>>>>>>>>>>>>>        Move 0 to hHash
76174>>>>>>>>>>>>>        Get piHash to iAlgorithm
76175>>>>>>>>>>>>>        Move (CryptCreateHash(hProv,iAlgorithm,0,0,AddressOf(hHash))) to bOk
76176>>>>>>>>>>>>>        
76176>>>>>>>>>>>>>        Function_Return hHash
76177>>>>>>>>>>>>>    End_Function
76178>>>>>>>>>>>>>    
76178>>>>>>>>>>>>>    // Destroys the hash object
76178>>>>>>>>>>>>>    Function DestroyHash Handle hHash Returns Boolean
76180>>>>>>>>>>>>>        Function_Return (CryptDestroyHash(hHash))
76181>>>>>>>>>>>>>    End_Function
76182>>>>>>>>>>>>>    
76182>>>>>>>>>>>>>    // Adds data to hash object
76182>>>>>>>>>>>>>    Function HashData Handle hHash UChar[] ucData Returns Boolean
76184>>>>>>>>>>>>>        Function_Return (CryptHashData(hHash,AddressOf(ucData), SizeOfArray(ucData),0))
76185>>>>>>>>>>>>>    End_Function
76186>>>>>>>>>>>>>    
76186>>>>>>>>>>>>>    // Generates session key
76186>>>>>>>>>>>>>    Function DeriveKey Handle hProv Handle hHash Returns Handle
76188>>>>>>>>>>>>>        Integer iAlgorithm
76188>>>>>>>>>>>>>        Handle hKey
76188>>>>>>>>>>>>>        Boolean bOk
76188>>>>>>>>>>>>>        
76188>>>>>>>>>>>>>        Move 0 to hKey
76189>>>>>>>>>>>>>        Get piCipher to iAlgorithm
76190>>>>>>>>>>>>>        Move (CryptDeriveKey(hProv,iAlgorithm,hHash,CRYPT_EXPORTABLE,AddressOf(hKey))) to bOk
76191>>>>>>>>>>>>>        
76191>>>>>>>>>>>>>        Function_Return hKey
76192>>>>>>>>>>>>>    End_Function
76193>>>>>>>>>>>>>    
76193>>>>>>>>>>>>>    // Imports a plain text key
76193>>>>>>>>>>>>>    Function ImportPlainTextKey Handle hProv UChar[] ucaKey Returns Handle
76195>>>>>>>>>>>>>        tPLAINTEXTKEYBLOB blobhead
76195>>>>>>>>>>>>>        tPLAINTEXTKEYBLOB blobhead
76195>>>>>>>>>>>>>        Boolean   bSuccess
76195>>>>>>>>>>>>>        Handle    hKey
76195>>>>>>>>>>>>>        Integer   iHeadSize iKeySize
76195>>>>>>>>>>>>>        UChar[]   ucaKeyblob
76196>>>>>>>>>>>>>        Integer iVoid
76196>>>>>>>>>>>>>        
76196>>>>>>>>>>>>>        Move (SizeOfType(tPLAINTEXTKEYBLOB)) to iHeadSize
76197>>>>>>>>>>>>>        Move (SizeOfArray(ucaKey)) to iKeySize
76198>>>>>>>>>>>>>        
76198>>>>>>>>>>>>>        Move PLAINTEXTKEYBLOB to blobhead.hdr.bType
76199>>>>>>>>>>>>>        Move CUR_BLOB_VERSION   to blobhead.hdr.bVersion
76200>>>>>>>>>>>>>        Get piCipher            to blobhead.hdr.aiKeyAlg
76201>>>>>>>>>>>>>        Move iKeySize           to blobhead.dwKeySize
76202>>>>>>>>>>>>>        
76202>>>>>>>>>>>>>        Move (ResizeArray(ucaKeyblob, iHeadSize)) to ucaKeyblob
76203>>>>>>>>>>>>>        Move (CopyMemory(AddressOf(ucaKeyblob), AddressOf(blobhead), iHeadSize)) to iVoid
76204>>>>>>>>>>>>>        Move (AppendArray(ucaKeyblob, ucaKey)) to ucaKeyblob
76205>>>>>>>>>>>>>        
76205>>>>>>>>>>>>>        Move 0 to hKey
76206>>>>>>>>>>>>>        Move (CryptImportKey(hProv, AddressOf(ucaKeyblob), SizeOfArray(ucaKeyblob), 0, 0, AddressOf(hKey))) to bSuccess
76207>>>>>>>>>>>>>        If (not(bSuccess)) Begin
76209>>>>>>>>>>>>>            Move (ShowLastError()) to iVoid
76210>>>>>>>>>>>>>        End
76210>>>>>>>>>>>>>>
76210>>>>>>>>>>>>>        
76210>>>>>>>>>>>>>        Function_Return hKey
76211>>>>>>>>>>>>>    End_Function
76212>>>>>>>>>>>>>    
76212>>>>>>>>>>>>>    // Destroys the key
76212>>>>>>>>>>>>>    Function DestroyKey Handle hKey Returns Boolean
76214>>>>>>>>>>>>>        Function_Return (CryptDestroyKey(hKey))
76215>>>>>>>>>>>>>    End_Function
76216>>>>>>>>>>>>>    
76216>>>>>>>>>>>>>    // Retrieves key data
76216>>>>>>>>>>>>>    Function KeyParameter Handle hKey Integer iQuery Returns Integer
76218>>>>>>>>>>>>>        Integer iBuffer iLen
76218>>>>>>>>>>>>>        Boolean bOk
76218>>>>>>>>>>>>>        
76218>>>>>>>>>>>>>        Move (SizeOfType(Integer)) to iLen
76219>>>>>>>>>>>>>        Move (CryptGetKeyParam(hKey,iQuery,AddressOf(iBuffer),AddressOf(iLen),0)) to bOk
76220>>>>>>>>>>>>>        Function_Return iBuffer
76221>>>>>>>>>>>>>    End_Function
76222>>>>>>>>>>>>>    
76222>>>>>>>>>>>>>    // Retrieves a hash value
76222>>>>>>>>>>>>>    Function HashValue Handle lhHash Returns UChar[]
76224>>>>>>>>>>>>>        UChar[] ucHash
76225>>>>>>>>>>>>>        Integer liResult
76225>>>>>>>>>>>>>        DWord   dwDataLen
76225>>>>>>>>>>>>>        
76225>>>>>>>>>>>>>        Move 0 to dwDataLen
76226>>>>>>>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,0,AddressOf(dwDataLen),0)) to liResult
76227>>>>>>>>>>>>>        If (liResult = 0) ;            Function_Return ""
76230>>>>>>>>>>>>>        
76230>>>>>>>>>>>>>        Move (ResizeArray(ucHash, dwDataLen, 0)) to ucHash
76231>>>>>>>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,AddressOf(ucHash),AddressOf(dwDataLen),0)) to liResult
76232>>>>>>>>>>>>>        If (liResult = 0) ;            Function_Return ""
76235>>>>>>>>>>>>>        
76235>>>>>>>>>>>>>        Function_Return ucHash
76236>>>>>>>>>>>>>    End_Function
76237>>>>>>>>>>>>>
76237>>>>>>>>>>>>>    // Encrypts data
76237>>>>>>>>>>>>>    Function Encrypt UChar[] ucPassword UChar[] ucData Returns UChar[]
76239>>>>>>>>>>>>>        Handle hProv hHash hKey
76239>>>>>>>>>>>>>        Integer iAlgorithm iDataLen iCipherLen iErr
76239>>>>>>>>>>>>>        Boolean bOk
76239>>>>>>>>>>>>>        
76239>>>>>>>>>>>>>        Get AcquireContext to hProv
76240>>>>>>>>>>>>>        If (hProv) Begin
76242>>>>>>>>>>>>>            Get CreateHash hProv to hHash
76243>>>>>>>>>>>>>            If (hHash) Begin
76245>>>>>>>>>>>>>                Get HashData hHash ucPassword to bOk
76246>>>>>>>>>>>>>                If (bOk) Begin
76248>>>>>>>>>>>>>                    Get piCipher to iAlgorithm
76249>>>>>>>>>>>>>                    Get DeriveKey hProv hHash to hKey
76250>>>>>>>>>>>>>                End
76250>>>>>>>>>>>>>>
76250>>>>>>>>>>>>>                Get DestroyHash hHash to bOk
76251>>>>>>>>>>>>>            End
76251>>>>>>>>>>>>>>
76251>>>>>>>>>>>>>            
76251>>>>>>>>>>>>>            If (hKey) Begin
76253>>>>>>>>>>>>>                //  First call to determine resulting data size
76253>>>>>>>>>>>>>                Move (SizeOfArray(ucData)) to iDataLen
76254>>>>>>>>>>>>>                Move (SizeOfArray(ucData)) to iCipherLen
76255>>>>>>>>>>>>>                Move (CryptEncrypt(hKey, 0, True, 0, 0, AddressOf(iCipherLen), iDataLen)) to bOk
76256>>>>>>>>>>>>>                
76256>>>>>>>>>>>>>                //  Reserve space in string
76256>>>>>>>>>>>>>                If (iDataLen < iCipherLen) Begin
76258>>>>>>>>>>>>>                    Move (ResizeArray(ucData, iCipherLen, 0)) to ucData
76259>>>>>>>>>>>>>                End
76259>>>>>>>>>>>>>>
76259>>>>>>>>>>>>>                
76259>>>>>>>>>>>>>                //  Call to really decrypt
76259>>>>>>>>>>>>>                Move (CryptEncrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iDataLen),SizeOfArray(ucData))) to bOk
76260>>>>>>>>>>>>>                //If (not(bOk)) Begin
76260>>>>>>>>>>>>>                //Move "" to sData
76260>>>>>>>>>>>>>                //Move (GetLastError()) to iErr
76260>>>>>>>>>>>>>                //End
76260>>>>>>>>>>>>>                
76260>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
76261>>>>>>>>>>>>>            End 
76261>>>>>>>>>>>>>>
76261>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
76262>>>>>>>>>>>>>        End 
76262>>>>>>>>>>>>>>
76262>>>>>>>>>>>>>        Function_Return ucData
76263>>>>>>>>>>>>>    End_Function
76264>>>>>>>>>>>>>    
76264>>>>>>>>>>>>>    // Decrypts data
76264>>>>>>>>>>>>>    Function Decrypt UChar[] ucPassword UChar[] ucData Returns UChar[]
76266>>>>>>>>>>>>>        Handle hProv hHash hKey
76266>>>>>>>>>>>>>        Integer iAlgorithm iDataLen
76266>>>>>>>>>>>>>        Boolean bOk
76266>>>>>>>>>>>>>        
76266>>>>>>>>>>>>>        Get AcquireContext to hProv
76267>>>>>>>>>>>>>        If (hProv) Begin
76269>>>>>>>>>>>>>            Get CreateHash hProv to hHash
76270>>>>>>>>>>>>>            If (hHash) Begin
76272>>>>>>>>>>>>>                Get HashData hHash ucPassword to bOk
76273>>>>>>>>>>>>>                If (bOk) Begin
76275>>>>>>>>>>>>>                    Get piCipher to iAlgorithm
76276>>>>>>>>>>>>>                    Get DeriveKey hProv hHash to hKey
76277>>>>>>>>>>>>>                End
76277>>>>>>>>>>>>>>
76277>>>>>>>>>>>>>                Get DestroyHash hHash to bOk
76278>>>>>>>>>>>>>            End
76278>>>>>>>>>>>>>>
76278>>>>>>>>>>>>>            
76278>>>>>>>>>>>>>            If (hKey) Begin
76280>>>>>>>>>>>>>                Move (SizeOfArray(ucData)) to iDataLen
76281>>>>>>>>>>>>>                Move (CryptDecrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iDataLen))) to bOk
76282>>>>>>>>>>>>>                //  Resulting data can be shorter as the input string, in that case we shorten the result string
76282>>>>>>>>>>>>>                If (SizeOfArray (ucData) > iDataLen) Begin
76284>>>>>>>>>>>>>                    Move (ResizeArray(ucData, iDataLen)) to ucData
76285>>>>>>>>>>>>>                End
76285>>>>>>>>>>>>>>
76285>>>>>>>>>>>>>                
76285>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
76286>>>>>>>>>>>>>            End
76286>>>>>>>>>>>>>>
76286>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
76287>>>>>>>>>>>>>        End
76287>>>>>>>>>>>>>>
76287>>>>>>>>>>>>>        Function_Return ucData
76288>>>>>>>>>>>>>    End_Function
76289>>>>>>>>>>>>>    
76289>>>>>>>>>>>>>    // Creates a key
76289>>>>>>>>>>>>>    Function CreateKey Handle hProv Returns Handle
76291>>>>>>>>>>>>>        Integer iAlg iType iByte iLength iSize
76291>>>>>>>>>>>>>        CryptoBlob keyBlob
76291>>>>>>>>>>>>>        CryptoBlob keyBlob
76291>>>>>>>>>>>>>        Boolean bOk
76291>>>>>>>>>>>>>        Handle hKey
76291>>>>>>>>>>>>>        UChar[] aKey
76292>>>>>>>>>>>>>
76292>>>>>>>>>>>>>        Get paKey to aKey
76293>>>>>>>>>>>>>        Get piKeyAlg to iAlg
76294>>>>>>>>>>>>>        Get piKeyType to iType
76295>>>>>>>>>>>>>        Move iAlg                   to keyBlob.header.bType
76296>>>>>>>>>>>>>        Move CUR_BLOB_VERSION       to keyBlob.header.bVersion
76297>>>>>>>>>>>>>        Move iType                  to keyBlob.header.aiKeyAlg
76298>>>>>>>>>>>>>        Move (SizeOfArray(aKey))    to keyBlob.cbKeySize
76299>>>>>>>>>>>>>        
76299>>>>>>>>>>>>>        Move (SizeOfArray(aKey)-1) to iLength
76300>>>>>>>>>>>>>        For iByte from 0 to iLength
76306>>>>>>>>>>>>>>
76306>>>>>>>>>>>>>            Move aKey[iByte] to keyBlob.rgbKeyData[iByte]
76307>>>>>>>>>>>>>        Loop
76308>>>>>>>>>>>>>>
76308>>>>>>>>>>>>>        
76308>>>>>>>>>>>>>        Move 0 to hKey
76309>>>>>>>>>>>>>        Move (CryptImportKey(hProv,AddressOf(keyBlob),SizeOfType(CryptoBlob),0,0,AddressOf(hKey))) to bOk
76310>>>>>>>>>>>>>        Function_Return hKey
76311>>>>>>>>>>>>>    End_Function
76312>>>>>>>>>>>>>    
76312>>>>>>>>>>>>>    // Sets the key parameters
76312>>>>>>>>>>>>>    Function SetKeyParameters Handle hKey Returns Boolean
76314>>>>>>>>>>>>>        Integer iPadding iMode
76314>>>>>>>>>>>>>        Boolean bOk
76314>>>>>>>>>>>>>        UChar[] aIV
76315>>>>>>>>>>>>>        
76315>>>>>>>>>>>>>        //Move (SizeOfArray(aIV)-1) to iLength
76315>>>>>>>>>>>>>        //For iByte from 0 to iLength
76315>>>>>>>>>>>>>        //    Move iByte to aIV[iByte]
76315>>>>>>>>>>>>>        //Loop
76315>>>>>>>>>>>>>
76315>>>>>>>>>>>>>        // Set initialization vector
76315>>>>>>>>>>>>>        Get paIV to aIV
76316>>>>>>>>>>>>>        Move (CryptSetKeyParam(hKey,KP_IV,AddressOf(aIV),0)) to bOk
76317>>>>>>>>>>>>>        If (bOk) Begin
76319>>>>>>>>>>>>>            // Set padding
76319>>>>>>>>>>>>>            Get piKeyPadding to iPadding
76320>>>>>>>>>>>>>            Move (CryptSetKeyParam(hKey,KP_PADDING,AddressOf(iPadding),0)) to bOk
76321>>>>>>>>>>>>>            If (bOk) Begin
76323>>>>>>>>>>>>>                // Set move
76323>>>>>>>>>>>>>                Get piKeyMode to iMode
76324>>>>>>>>>>>>>                Move (CryptSetKeyParam(hKey,KP_MODE,AddressOf(iMode),0)) to bOk
76325>>>>>>>>>>>>>            End
76325>>>>>>>>>>>>>>
76325>>>>>>>>>>>>>        End
76325>>>>>>>>>>>>>>
76325>>>>>>>>>>>>>        Function_Return bOk        
76326>>>>>>>>>>>>>    End_Function
76327>>>>>>>>>>>>>    
76327>>>>>>>>>>>>>    // Encrypts using block cipher
76327>>>>>>>>>>>>>    Function BlockEncrypt UChar[] ucData Returns UChar[]
76329>>>>>>>>>>>>>        Handle hProv hKey
76329>>>>>>>>>>>>>        Integer iLen iSize iBlocks
76329>>>>>>>>>>>>>        Boolean bOk
76329>>>>>>>>>>>>>        
76329>>>>>>>>>>>>>        Get AcquireContext to hProv
76330>>>>>>>>>>>>>        If (hProv) Begin
76332>>>>>>>>>>>>>            // Create key
76332>>>>>>>>>>>>>            Get CreateKey hProv to hKey
76333>>>>>>>>>>>>>            If (hKey) Begin
76335>>>>>>>>>>>>>                Get SetKeyParameters hKey to bOk
76336>>>>>>>>>>>>>                If (bOk) Begin
76338>>>>>>>>>>>>>                    // Buffer for block ciphers can be up to block length larger
76338>>>>>>>>>>>>>                    Get piBlockSize to iSize
76339>>>>>>>>>>>>>                    Move (SizeOfArray(ucData)) to iLen
76340>>>>>>>>>>>>>                    
76340>>>>>>>>>>>>>                    Move ((iLen/iSize)+1) to iBlocks
76341>>>>>>>>>>>>>                    Move (ResizeArray(ucData,iBlocks*iSize)) to ucData
76342>>>>>>>>>>>>>                    Move (CryptEncrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iLen),SizeOfArray(ucData))) to bOk
76343>>>>>>>>>>>>>                End
76343>>>>>>>>>>>>>>
76343>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
76344>>>>>>>>>>>>>            End
76344>>>>>>>>>>>>>>
76344>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
76345>>>>>>>>>>>>>        End
76345>>>>>>>>>>>>>>
76345>>>>>>>>>>>>>        Function_Return ucData
76346>>>>>>>>>>>>>    End_Function
76347>>>>>>>>>>>>>    
76347>>>>>>>>>>>>>    // Decrypts using block cipher
76347>>>>>>>>>>>>>    Function BlockDecrypt UChar[] ucData Returns UChar[]
76349>>>>>>>>>>>>>        Handle hProv hKey
76349>>>>>>>>>>>>>        Integer iLen
76349>>>>>>>>>>>>>        Boolean bOk
76349>>>>>>>>>>>>>        
76349>>>>>>>>>>>>>        Get AcquireContext to hProv
76350>>>>>>>>>>>>>        If (hProv) Begin
76352>>>>>>>>>>>>>            // Create key
76352>>>>>>>>>>>>>            Get CreateKey hProv to hKey
76353>>>>>>>>>>>>>            If (hKey) Begin
76355>>>>>>>>>>>>>                Get SetKeyParameters hKey to bOk
76356>>>>>>>>>>>>>                If (bOk) Begin
76358>>>>>>>>>>>>>                    Move (SizeOfArray(ucData)) to iLen
76359>>>>>>>>>>>>>                    Move (CryptDecrypt(hKey,0,True,0,AddressOf(ucData),AddressOf(iLen))) to bOk
76360>>>>>>>>>>>>>                    Move (ResizeArray(ucData,iLen)) to ucData
76361>>>>>>>>>>>>>                End
76361>>>>>>>>>>>>>>
76361>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
76362>>>>>>>>>>>>>            End
76362>>>>>>>>>>>>>>
76362>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
76363>>>>>>>>>>>>>        End
76363>>>>>>>>>>>>>>
76363>>>>>>>>>>>>>        Function_Return ucData
76364>>>>>>>>>>>>>    End_Function
76365>>>>>>>>>>>>>    
76365>>>>>>>>>>>>>    
76365>>>>>>>>>>>>>    //  Generates random data.
76365>>>>>>>>>>>>>    Function GenerateRandom Integer iBytes Returns UChar[]
76367>>>>>>>>>>>>>        Handle hProv
76367>>>>>>>>>>>>>        UChar[] uaResult
76368>>>>>>>>>>>>>        Boolean bRes
76368>>>>>>>>>>>>>        
76368>>>>>>>>>>>>>        Get AcquireContext to hProv
76369>>>>>>>>>>>>>        
76369>>>>>>>>>>>>>        Move (ResizeArray(uaResult, iBytes)) to uaResult
76370>>>>>>>>>>>>>        Move (CryptGenRandom(hProv, iBytes, AddressOf(uaResult))) to bRes
76371>>>>>>>>>>>>>        
76371>>>>>>>>>>>>>        Get ReleaseContext hProv to bRes
76372>>>>>>>>>>>>>        
76372>>>>>>>>>>>>>        Function_Return uaResult
76373>>>>>>>>>>>>>    End_Function
76374>>>>>>>>>>>>>    
76374>>>>>>>>>>>>>    //  Generates random data and does a base64 encoding to properly present it as a string.
76374>>>>>>>>>>>>>    Function GenerateRandomString Integer iLength Returns String
76376>>>>>>>>>>>>>        String sResult
76376>>>>>>>>>>>>>        UChar[] ucData
76377>>>>>>>>>>>>>        Pointer pBase64
76377>>>>>>>>>>>>>        Integer iVoid
76377>>>>>>>>>>>>>        
76377>>>>>>>>>>>>>        Get GenerateRandom iLength to ucData
76378>>>>>>>>>>>>>        
76378>>>>>>>>>>>>>        Move (Base64Encode(AddressOf(ucData), iLength)) to pBase64
76379>>>>>>>>>>>>>        Move (PointerToString(pBase64)) to sResult
76380>>>>>>>>>>>>>        Move (Free(pBase64)) to iVoid
76381>>>>>>>>>>>>>        
76381>>>>>>>>>>>>>        Function_Return (Left(sResult, iLength))
76382>>>>>>>>>>>>>    End_Function
76383>>>>>>>>>>>>>    
76383>>>>>>>>>>>>>End_Class
76384>>>>>>>>>>>Use Base64Functions.pkg
Including file: Base64Functions.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\Base64Functions.pkg)
76384>>>>>>>>>>>>>//> This package enables base64 encoding and decoding of strings:
76384>>>>>>>>>>>>>//>
76384>>>>>>>>>>>>>//>     Get EncodeString of oBase64Functions sValue to sValue
76384>>>>>>>>>>>>>//>     Get DecodeString of oBase64Functions sValue to sValue
76384>>>>>>>>>>>>>//>
76384>>>>>>>>>>>>>//> Remember to set the "max argument size" if dealing with very large
76384>>>>>>>>>>>>>//> strings.
76384>>>>>>>>>>>>>//>
76384>>>>>>>>>>>>>//> For 17.1 and later the functionality of this package is based on two functions (Base64Encode and
76384>>>>>>>>>>>>>//> Base64Decode) that are built into the runtime.
76384>>>>>>>>>>>>>//>
76384>>>>>>>>>>>>>//> But for versions up to and including 17.0 it's based on the vdfBase64.dll file that was obtained
76384>>>>>>>>>>>>>//> from DAE that have kindly allowed me to distribute it to other DF developers. Programs including
76384>>>>>>>>>>>>>//> this package will give off an error on start-up if vdfBase64.dll is not found in the /bin folder
76384>>>>>>>>>>>>>//> if the VDF runtime. You will find the DLL in the /programs folder of the StureApsPublicLib workspace
76384>>>>>>>>>>>>>
76384>>>>>>>>>>>>>Use VdfBase.pkg
76384>>>>>>>>>>>>>
76384>>>>>>>>>>>>>// Functions in vdfBase64.dll
76384>>>>>>>>>>>>>External_Function xxBase64Encode "vdfbase64Encode" vdfBase64.dll Pointer pBuffer Returns Integer
76385>>>>>>>>>>>>>External_Function xxBase64Decode "vdfbase64Decode" vdfBase64.dll Pointer pBuffer Returns Integer
76386>>>>>>>>>>>>>External_Function xxBase64Free   "vdfbase64Free"   vdfBase64.dll Pointer pBuffer Returns Integer
76387>>>>>>>>>>>>>
76387>>>>>>>>>>>>>// Structure
76387>>>>>>>>>>>>>Struct txxfBase64Buffer
76387>>>>>>>>>>>>>    Pointer pData
76387>>>>>>>>>>>>>    Integer iLength
76387>>>>>>>>>>>>>End_Struct 
76387>>>>>>>>>>>>>
76387>>>>>>>>>>>>>Global_Variable Integer oBase64Functions
76387>>>>>>>>>>>>>
76387>>>>>>>>>>>>>Object _oBase64Functions is a cObject
76389>>>>>>>>>>>>>    Move Self to oBase64Functions
76390>>>>>>>>>>>>>
76390>>>>>>>>>>>>>
76390>>>>>>>>>>>>>    Function EncodeString String sValue Returns String
76393>>>>>>>>>>>>>        Address pBase64
76393>>>>>>>>>>>>>        String sResult
76393>>>>>>>>>>>>>        Integer iVoid
76393>>>>>>>>>>>>>        Move (Base64Encode(AddressOf(sValue), Length(sValue))) to pBase64
76394>>>>>>>>>>>>>        Move (PointerToString(pBase64)) to sResult
76395>>>>>>>>>>>>>        Move (Free(pBase64)) to iVoid
76396>>>>>>>>>>>>>        Function_Return sResult
76397>>>>>>>>>>>>>    End_Function
76398>>>>>>>>>>>>>
76398>>>>>>>>>>>>>    Function DecodeString String sValue Returns String
76401>>>>>>>>>>>>>        Address pBinary
76401>>>>>>>>>>>>>        String sBinary
76401>>>>>>>>>>>>>        Integer iVoid iLen
76401>>>>>>>>>>>>>        Move (Base64Decode(AddressOf(sValue), &iLen)) to pBinary
76402>>>>>>>>>>>>>        Move (Repeat(Character(0), iLen)) to sBinary
76403>>>>>>>>>>>>>        Move (MemCopy(AddressOf(sBinary), pBinary, iLen)) to iVoid
76404>>>>>>>>>>>>>        Move (Free(pBinary)) to iVoid
76405>>>>>>>>>>>>>        Function_Return sBinary
76406>>>>>>>>>>>>>    End_Function
76407>>>>>>>>>>>>>
76407>>>>>>>>>>>>>End_Object
76408>>>>>>>>>>>Use MSSqldrv.pkg
76408>>>>>>>>>>>Use db2_drv.pkg
76408>>>>>>>>>>>Use odbc_drv.pkg
76408>>>>>>>>>>>Use DFBtrDrv.pkg
76408>>>>>>>>>>>Use vWin32fh.pkg
76408>>>>>>>>>>>
76408>>>>>>>>>>>Use DUFLanguageConstants.inc
76408>>>>>>>>>>>Use MertechDUF.pkg
Including file: MertechDUF.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\MertechDUF.pkg)
76408>>>>>>>>>>>>>//
76408>>>>>>>>>>>>>// Use of Mertech drivers:
76408>>>>>>>>>>>>>// Put the line "Define DUF_Use_Mertech_Drivers in YOUR code prior the "Use" statement for this package if using Mertech drivers!
76408>>>>>>>>>>>>>// And put the line right before the "Use cDbUpdateHandler.pkg" line.
76408>>>>>>>>>>>>>//Define DUF_Use_Mertech_Drivers
76408>>>>>>>>>>>>>//
#REM USE MERTECH.INC
76408>>>>>>>>>>>>>    Use Flex2SQLDUF.pkg
Including file: Flex2SQLDUF.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\Flex2SQLDUF.pkg)
76408>>>>>>>>>>>>>>>//*************************************************************************
76408>>>>>>>>>>>>>>>//*                                                                       *
76408>>>>>>>>>>>>>>>//*  Confidential Trade Secret.                                           *
76408>>>>>>>>>>>>>>>//*  Copyright (c) 1997-2014 Mertech Data Systems Inc, Miami Florida      *
76408>>>>>>>>>>>>>>>//*  All rights reserved.                                                 *
76408>>>>>>>>>>>>>>>//*  DataFlex is a registered trademark of Data Access Corporation.       *
76408>>>>>>>>>>>>>>>//*                                                                       *
76408>>>>>>>>>>>>>>>//*  NOTE: This version of Flex2SQL is specially adapted to be used with  *
76408>>>>>>>>>>>>>>>// * the Database Update Framework (DUF)                                  *
76408>>>>>>>>>>>>>>>// *                                                                      *
76408>>>>>>>>>>>>>>>//*************************************************************************
76408>>>>>>>>>>>>>>>Use mertech.inc
Including file: mertech.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\mertech.inc)
76408>>>>>>>>>>>>>>>>>//*************************************************************************
76408>>>>>>>>>>>>>>>>>//*                                                                       *
76408>>>>>>>>>>>>>>>>>//*  Confidential Trade Secret.                                           *
76408>>>>>>>>>>>>>>>>>//*  Copyright (c) 1997-2014 Mertech Data Systems Inc, Miami Florida      *
76408>>>>>>>>>>>>>>>>>//*  All rights reserved.                                                 *
76408>>>>>>>>>>>>>>>>>//*  DataFlex is a registered trademark of Data Access Corporation.       *
76408>>>>>>>>>>>>>>>>>//*                                                                       *
76408>>>>>>>>>>>>>>>>>//*************************************************************************
76408>>>>>>>>>>>>>>>>>Use UI
76408>>>>>>>>>>>>>>>>>Use SEQ_CHNL.PKG
76408>>>>>>>>>>>>>>>>>
#REM -----------------------------------------------
#REM MERTECH DATA SYSTEMS INC. - MERTECH.COM
#REM MERTECH.INC VERSION 3.3.1.5
#REM -----------------------------------------------
76408>>>>>>>>>>>>>>>>>
76408>>>>>>>>>>>>>>>>>Object oMertechInc_Work is an Array  
76410>>>>>>>>>>>>>>>>>    CompilerWarnings Off
76410>>>>>>>>>>>>>>>>>    Property String psWork Public (Repeat("                                ", 512))
76412>>>>>>>>>>>>>>>>>    CompilerWarnings On
76412>>>>>>>>>>>>>>>>>End_Object
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//=============================================================================
76413>>>>>>>>>>>>>>>>>// #DEFINE's
76413>>>>>>>>>>>>>>>>>//=============================================================================
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//Currently Unsupported Attribute
76413>>>>>>>>>>>>>>>>>Define DF_FILE_PRIMARY_KEY                          For (DF_FILE_RECORD_REREAD+1)
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>// TODO: This is probably deprecated. Investigate.
76413>>>>>>>>>>>>>>>>>Define DF_FILE_NUMBER_INVERSE_KEYS                  For (DF_FILE_RECORD_REREAD+3)
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//=============================================================================
76413>>>>>>>>>>>>>>>>>/// @Name        DF_FILE_SET_MODE
76413>>>>>>>>>>>>>>>>>/// @Description Allows switching between set-oriented and record oriented fetch modes.
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// If DF_FILE_SET_MODE is set to True, the driver will fetch a set of records
76413>>>>>>>>>>>>>>>>>/// for each find. If DF_FILE_SET_MODE is False, the driver will fetch only one
76413>>>>>>>>>>>>>>>>>/// record at a time. This attribute can also be specified in the .INT file during
76413>>>>>>>>>>>>>>>>>/// migration through Flex2SQL. This settings is normally used alongside
76413>>>>>>>>>>>>>>>>>/// DF_FILE_MAX_ROWS to set the number of rows to return and DF_FILE_CACHE_MODE
76413>>>>>>>>>>>>>>>>>/// to turn on local caching.
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Note: Turning off set-mode can have a detrimental impact on performance. Unless
76413>>>>>>>>>>>>>>>>>/// there is a specific reason to do otherwise, this option should be left on.
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Default value: True
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Assumptions
76413>>>>>>>>>>>>>>>>>/// @Status      Public
76413>>>>>>>>>>>>>>>>>/// @Drivers     All
76413>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-15 by Oliver Nelson
76413>>>>>>>>>>>>>>>>>/// @See DF_FILE_MAX_ROWS DF_FILE_CACHE_MODE
76413>>>>>>>>>>>>>>>>>/// @INTOPT OPTIMIZE {FOR_SET | ONE_ROW}
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_SET_MODE of {FileNumber} to {variable}
76413>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_SET_MODE of {FileNumber} to {variable}
76413>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
76413>>>>>>>>>>>>>>>>>/// @Param  variable              Mode for the FileNumber. True for set-mode, False for one-row mode.
76413>>>>>>>>>>>>>>>>>/// @Example
76413>>>>>>>>>>>>>>>>>/// Open Orderhea
76413>>>>>>>>>>>>>>>>>/// Set_Attribute DF_FILE_SET_MODE of Orderhea.File_Number to True
76413>>>>>>>>>>>>>>>>>/// Get_Attribute DF_FILE_SET_MODE of Orderhea.File_Number to boolVar
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>Define DF_FILE_SET_MODE                             For (DF_FILE_RECORD_REREAD+5)
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//=============================================================================
76413>>>>>>>>>>>>>>>>>/// @Name        DF_FILE_DATABASENAME
76413>>>>>>>>>>>>>>>>>/// @Description Returns a string containing the name of the database where the
76413>>>>>>>>>>>>>>>>>/// table referenced by the passed File Number resides. This is a READ ONLY
76413>>>>>>>>>>>>>>>>>/// attribute. Note that because Oracle doesn't support the concept of multiple
76413>>>>>>>>>>>>>>>>>/// databases on one server, this attribute is not valid for Oracle.
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Assumptions
76413>>>>>>>>>>>>>>>>>/// @Status      Public
76413>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex, MySQLFlex, PGFlex
76413>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-15 by Oliver Nelson
76413>>>>>>>>>>>>>>>>>/// @See
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_DATABASENAME of {FileNumber} to {variable}
76413>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
76413>>>>>>>>>>>>>>>>>/// @Param  variable              Name of the Database
76413>>>>>>>>>>>>>>>>>/// @Example
76413>>>>>>>>>>>>>>>>>/// Open Orderhea
76413>>>>>>>>>>>>>>>>>/// Get_Attribute DF_FILE_DATABASENAME of Orderhea.File_Number to strVal
76413>>>>>>>>>>>>>>>>>Define DF_FILE_DATABASENAME                         For (DF_FILE_RECORD_REREAD+6)
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//=============================================================================
76413>>>>>>>>>>>>>>>>>/// @Name        DF_FILE_MAX_ROWS
76413>>>>>>>>>>>>>>>>>/// @Description Controls the maximum number of rows retrieved by a Find GT/LT
76413>>>>>>>>>>>>>>>>>/// operation. The driver will automatically retrieve and cache this many rows
76413>>>>>>>>>>>>>>>>>/// for future find GT/LT operations. Setting this property to a very high
76413>>>>>>>>>>>>>>>>>/// value can be inefficient from a UI perspective but may be advisable for
76413>>>>>>>>>>>>>>>>>/// local processing of rows (such as in a batch process).
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Default value: 10
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Assumptions
76413>>>>>>>>>>>>>>>>>/// @Status      Public
76413>>>>>>>>>>>>>>>>>/// @Drivers     All
76413>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-15 by Oliver Nelson
76413>>>>>>>>>>>>>>>>>/// @See DF_FILE_SET_MODE DF_FILE_CACHE_MODE
76413>>>>>>>>>>>>>>>>>/// @INTOPT MAX_ROWS_TO_QUERY {integer}
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_DATABASENAME of {FileNumber} to {variable}
76413>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
76413>>>>>>>>>>>>>>>>>/// @Param  variable              Attribute Value
76413>>>>>>>>>>>>>>>>>/// @Example
76413>>>>>>>>>>>>>>>>>/// Open Orderhea
76413>>>>>>>>>>>>>>>>>/// Set_Attribute DF_FILE_MAX_ROWS of Orderhea.File_Number to 10
76413>>>>>>>>>>>>>>>>>/// Get_Attribute DF_FILE_MAX_ROWS of Orderhea.File_Number to intVal
76413>>>>>>>>>>>>>>>>>Define DF_FILE_MAX_ROWS                             For (DF_FILE_RECORD_REREAD+7)
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//=============================================================================
76413>>>>>>>>>>>>>>>>>/// @Name        DF_FILE_TABLE_NAME
76413>>>>>>>>>>>>>>>>>/// @Description Use this attribute to set or get the name of the SQL table
76413>>>>>>>>>>>>>>>>>/// corresponding to the specified file number. In a restructure operation
76413>>>>>>>>>>>>>>>>>/// this attribute may be used to permanently change the table that a filelist
76413>>>>>>>>>>>>>>>>>/// entry is pointing to.
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Assumptions
76413>>>>>>>>>>>>>>>>>/// @Status      Public
76413>>>>>>>>>>>>>>>>>/// @Drivers     All
76413>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-15 by Oliver Nelson
76413>>>>>>>>>>>>>>>>>/// @See
76413>>>>>>>>>>>>>>>>>/// @INTOPT DATABASE_NAME {string}
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_TABLE_NAME of {FileNumber} to {variable}
76413>>>>>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_TABLE_NAME of {FileNumber} to {variable}
76413>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
76413>>>>>>>>>>>>>>>>>/// @Param  variable              Name of the SQL Table.
76413>>>>>>>>>>>>>>>>>/// @Example
76413>>>>>>>>>>>>>>>>>/// Open Orderhea
76413>>>>>>>>>>>>>>>>>/// Get_Attribute DF_FILE_TABLE_NAME of Orderhea.File_Number to strVal
76413>>>>>>>>>>>>>>>>>Define DF_FILE_TABLE_NAME                           For (DF_FILE_RECORD_REREAD+8)
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//=============================================================================
76413>>>>>>>>>>>>>>>>>/// @Name        DF_FILE_CACHE_MODE
76413>>>>>>>>>>>>>>>>>/// @Description Activates or deactivates the local cache for set-oriented searches.
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Through the DF_FILE_CACHE_MODE attribute, we can activate or deactivate the
76413>>>>>>>>>>>>>>>>>/// local cache. When the cache is active in a set-oriented search, a fixed
76413>>>>>>>>>>>>>>>>>/// number of records are pre-fetched and kept in the local cache. If a record
76413>>>>>>>>>>>>>>>>>/// is not found in the local cache, a new set is fetched. The number of records
76413>>>>>>>>>>>>>>>>>/// fetched is controlled via the DF_FILE_MAX_ROWS attribute. Set-mode vs. one-row
76413>>>>>>>>>>>>>>>>>/// mode is controlled via the DF_FILE_SET_MODE attribute.
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Note: Turning off the cache can have significant detrimental effects on performance.
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Default value: True
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Assumptions
76413>>>>>>>>>>>>>>>>>/// @Status      Public
76413>>>>>>>>>>>>>>>>>/// @Drivers     All
76413>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-15 by Oliver Nelson
76413>>>>>>>>>>>>>>>>>/// @See         DF_FILE_MAX_ROWS DF_FILE_SET_MODE
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_CACHE_MODE of {FileNumber} to {variable}
76413>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_CACHE_MODE of {FileNumber} to {variable}
76413>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
76413>>>>>>>>>>>>>>>>>/// @Param  variable              Mode for FileNumber. True for active. False for inactive.
76413>>>>>>>>>>>>>>>>>/// @Example
76413>>>>>>>>>>>>>>>>>/// Open Orderhea
76413>>>>>>>>>>>>>>>>>/// Set_Attribute DF_FILE_CACHE_MODE of Orderhea.File_Number to True
76413>>>>>>>>>>>>>>>>>/// Get_Attribute DF_FILE_CACHE_MODE of Orderhea.File_Number to boolVal
76413>>>>>>>>>>>>>>>>>Define DF_FILE_CACHE_MODE                           For (DF_FILE_RECORD_REREAD+9)
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//Currently Unsupported Attribute
76413>>>>>>>>>>>>>>>>>Define DF_FILE_STORAGE_BASE                         For (DF_FILE_RECORD_REREAD+10)
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//=============================================================================
76413>>>>>>>>>>>>>>>>>/// @Name        DF_FILE_STATIC
76413>>>>>>>>>>>>>>>>>/// @Description Activates or deactivates a special table mode where all rows
76413>>>>>>>>>>>>>>>>>/// from the table are loaded into a local cache. When active, all searches are
76413>>>>>>>>>>>>>>>>>/// done in memory and the actual table is not accessed.  The driver does not allow
76413>>>>>>>>>>>>>>>>>/// editing of a table in static mode.  This is a very useful feature especially
76413>>>>>>>>>>>>>>>>>/// when a table contains configuration or static information used in
76413>>>>>>>>>>>>>>>>>/// calculations, (i.e., Tax Rate tables, etc.) By keeping this table locally
76413>>>>>>>>>>>>>>>>>/// in memory, network round trips are saved resulting in significant
76413>>>>>>>>>>>>>>>>>/// performance improvements. This attribute is also useful for batch
76413>>>>>>>>>>>>>>>>>/// processes that make extensive table IO requests for reading static information.
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Note: Because the entire table is loaded into memory, it is inadvisable to use
76413>>>>>>>>>>>>>>>>>/// this on very large tables.
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Default value: False
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Assumptions
76413>>>>>>>>>>>>>>>>>/// @Status      Public
76413>>>>>>>>>>>>>>>>>/// @Drivers     All
76413>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-15 by Oliver Nelson
76413>>>>>>>>>>>>>>>>>/// @See
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_STATIC of {FileNumber} to {variable}
76413>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
76413>>>>>>>>>>>>>>>>>/// @Param  variable              Static Mode for FileNumber. True for static. False for dynamic.
76413>>>>>>>>>>>>>>>>>/// @Example
76413>>>>>>>>>>>>>>>>>/// Open Orderhea
76413>>>>>>>>>>>>>>>>>/// Set_Attribute DF_FILE_STATIC of Orderhea.File_Number to True
76413>>>>>>>>>>>>>>>>>/// Get_Attribute DF_FILE_STATIC of Orderhea.File_Number to boolVal
76413>>>>>>>>>>>>>>>>>Define DF_FILE_STATIC                               For (DF_FILE_RECORD_REREAD+11)
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//=============================================================================
76413>>>>>>>>>>>>>>>>>/// @Name        DF_FILE_SERVER_NAME
76413>>>>>>>>>>>>>>>>>/// @Description Use this attribute to set or get the name of the database server
76413>>>>>>>>>>>>>>>>>/// corresponding to the specified file number. In a restructure operation
76413>>>>>>>>>>>>>>>>>/// this attribute may be used to permanently change the server that a filelist
76413>>>>>>>>>>>>>>>>>/// entry is pointing to.
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Assumptions
76413>>>>>>>>>>>>>>>>>/// @Status      Public
76413>>>>>>>>>>>>>>>>>/// @Drivers     All
76413>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-15 by Oliver Nelson
76413>>>>>>>>>>>>>>>>>/// @See
76413>>>>>>>>>>>>>>>>>/// @INTOPT SERVER_NAME {string}
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_SERVER_NAME of {FileNumber} to {variable}
76413>>>>>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_SERVER_NAME of {FileNumber} to {variable}
76413>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
76413>>>>>>>>>>>>>>>>>/// @Param  variable              Name of the database server.
76413>>>>>>>>>>>>>>>>>/// @Example
76413>>>>>>>>>>>>>>>>>/// Open Orderhea
76413>>>>>>>>>>>>>>>>>/// Set_Attribute DF_FILE_SERVER_NAME of Orderhea.File_Number to "(localdb)\v11.0"
76413>>>>>>>>>>>>>>>>>/// Get_Attribute DF_FILE_SERVER_NAME of Orderhea.File_Number to strVal
76413>>>>>>>>>>>>>>>>>Define DF_FILE_SERVER_NAME                          For (DF_FILE_RECORD_REREAD+12)
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//=============================================================================
76413>>>>>>>>>>>>>>>>>/// @Name        DF_FETCH_FIELD_COUNT
76413>>>>>>>>>>>>>>>>>/// @Description This attribute is used to get the number of fields or columns
76413>>>>>>>>>>>>>>>>>/// in the given table. Note that this is referring to the columns in the SQL
76413>>>>>>>>>>>>>>>>>/// backend and may not necessarily reflect the number of columns in DataFlex.
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// This is a readonly attribute.
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Assumptions
76413>>>>>>>>>>>>>>>>>/// @Status      Public
76413>>>>>>>>>>>>>>>>>/// @Drivers     MsSQLFlex MySQLFlex
76413>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-14 by Aaron Gulack
76413>>>>>>>>>>>>>>>>>/// @See
76413>>>>>>>>>>>>>>>>>/// @INTOPT
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FETCH_FIELD_COUNT of {FileNumber} to {variable}
76413>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
76413>>>>>>>>>>>>>>>>>/// @Param  variable              Name of the Tablespace.
76413>>>>>>>>>>>>>>>>>/// @Example
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>/// Get_Attribute DF_FETCH_FIELD_COUNT of hFile To "INDXS"
76413>>>>>>>>>>>>>>>>>Define DF_FETCH_FIELD_COUNT                         For (DF_FILE_RECORD_REREAD+13)
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//=============================================================================
76413>>>>>>>>>>>>>>>>>/// @Name        DF_FILE_TABLESPACE_NAME
76413>>>>>>>>>>>>>>>>>/// @Description A tablespace is a container of segments (objects that have an
76413>>>>>>>>>>>>>>>>>/// allotted amount of space), i.e. tables and indexes. This attribute is
76413>>>>>>>>>>>>>>>>>/// used to get or set the name of the tablespace being used for the data tables.
76413>>>>>>>>>>>>>>>>>/// To set or get the tablespace name for indexes, use the DF_FILE_INDEXTABLESPACE_NAME
76413>>>>>>>>>>>>>>>>>/// attribute. Setting the tablespace name can only be done during a Structure_Start
76413>>>>>>>>>>>>>>>>>/// (during table creation).  Getting the name, however can be done at
76413>>>>>>>>>>>>>>>>>/// anytime.  Note that when setting the tablespace name, it must be set to an
76413>>>>>>>>>>>>>>>>>/// already existing tablespace, this attribute does not create the tablespace itself.
76413>>>>>>>>>>>>>>>>>/// Even though MYSQL uses tablespaces, this this attribute is only supported
76413>>>>>>>>>>>>>>>>>/// in Oracle and PostgreSQL.
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Assumptions
76413>>>>>>>>>>>>>>>>>/// @Status      Public
76413>>>>>>>>>>>>>>>>>/// @Drivers     ORAFlex PGFlex
76413>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-25 by Aaron Gulack
76413>>>>>>>>>>>>>>>>>/// @See         DF_FILE_INDEXTABLESPACE_NAME
76413>>>>>>>>>>>>>>>>>/// @INTOPT
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_TABLESPACE_NAME of {FileNumber} to {variable}
76413>>>>>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_TABLESPACE_NAME of {FileNumber} to {variable}
76413>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
76413>>>>>>>>>>>>>>>>>/// @Param  variable              Name of the Tablespace.
76413>>>>>>>>>>>>>>>>>/// @Example
76413>>>>>>>>>>>>>>>>>/// Handle hFile
76413>>>>>>>>>>>>>>>>>/// move 0 to hFile
76413>>>>>>>>>>>>>>>>>/// Structure_Start hFile "ORA_DRV"
76413>>>>>>>>>>>>>>>>>///     Set_Attribute DF_FILE_TABLESPACE_NAME      of hFile To "USERS"
76413>>>>>>>>>>>>>>>>>///     Set_Attribute DF_FILE_INDEXTABLESPACE_NAME of hFile To "INDXS"
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>///             // More table creation here
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Structure_End hFile DF_STRUCTEND_OPT_NONE "." 0
76413>>>>>>>>>>>>>>>>>Define DF_FILE_TABLESPACE_NAME                      For (DF_FILE_RECORD_REREAD+14)
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>// TODO: This is probably deprecated. Investigate.
76413>>>>>>>>>>>>>>>>>Define DF_FETCH_FIELDNUMBER                         For (DF_FILE_RECORD_REREAD+15)
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//=============================================================================
76413>>>>>>>>>>>>>>>>>/// @Name        DF_FILE_INDEXTABLESPACE_NAME
76413>>>>>>>>>>>>>>>>>/// @Description This attribute is used to get or set the name of the tablespace
76413>>>>>>>>>>>>>>>>>/// being used for the index segment of a database. For a description of tablespaces,
76413>>>>>>>>>>>>>>>>>/// see the description above for DF_FILE_TABLESPACE_NAME. Similar to the Tablespace
76413>>>>>>>>>>>>>>>>>/// name attribute, setting the index tablespace name can only be done during creation
76413>>>>>>>>>>>>>>>>>/// and must use an already existing tablespace as the variable. This attribute is
76413>>>>>>>>>>>>>>>>>/// only available for Oracle and Postgre.
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Assumptions
76413>>>>>>>>>>>>>>>>>/// @Status      Public
76413>>>>>>>>>>>>>>>>>/// @Drivers     ORAFlex PGFlex
76413>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-25 by Aaron Gulack
76413>>>>>>>>>>>>>>>>>/// @See         DF_FILE_TABLESPACE_NAME
76413>>>>>>>>>>>>>>>>>/// @INTOPT
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_INDEXTABLESPACE_NAME of {File Number} to {variable}
76413>>>>>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_INDEXTABLESPACE_NAME of {File Number} to {variable}
76413>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
76413>>>>>>>>>>>>>>>>>/// @Param  variable              Name of the Tablespace
76413>>>>>>>>>>>>>>>>>/// @Example
76413>>>>>>>>>>>>>>>>>/// Handle hFile
76413>>>>>>>>>>>>>>>>>/// move 0 to hFile
76413>>>>>>>>>>>>>>>>>/// Structure_Start hFile "ORA_DRV"
76413>>>>>>>>>>>>>>>>>///     Set_Attribute DF_FILE_TABLESPACE_NAME      of hFile To "USERS"
76413>>>>>>>>>>>>>>>>>///     Set_Attribute DF_FILE_INDEXTABLESPACE_NAME of hFile To "INDXS"
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>///             // More table creation here
76413>>>>>>>>>>>>>>>>>///             //
76413>>>>>>>>>>>>>>>>>/// Structure_End hFile DF_STRUCTEND_OPT_NONE "." 0
76413>>>>>>>>>>>>>>>>>Define DF_FILE_INDEXTABLESPACE_NAME                 For (DF_FILE_RECORD_REREAD+16)
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//=============================================================================
76413>>>>>>>>>>>>>>>>>/// @Name        DF_FILE_RETRIEVE_RECNUM
76413>>>>>>>>>>>>>>>>>/// @Description When creating records on a table with RECNUM support, the
76413>>>>>>>>>>>>>>>>>/// record number is returned after creation. When this attribute is false, the newly
76413>>>>>>>>>>>>>>>>>/// created record's RECNUM is not returned from the server. This could result in a
76413>>>>>>>>>>>>>>>>>/// slight performance improvement when many records are being created in a loop.
76413>>>>>>>>>>>>>>>>>/// The optimization, however, is negligible.  Having this attribute set to false can
76413>>>>>>>>>>>>>>>>>/// have detrimental effects if used improperly; i.e. DD-based saves or UI-based
76413>>>>>>>>>>>>>>>>>/// operations. Thus, this should almost always be set to true unless there is a
76413>>>>>>>>>>>>>>>>>/// compelling reason to do otherwise.
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Default Value: True
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Assumptions
76413>>>>>>>>>>>>>>>>>/// @Status      Public
76413>>>>>>>>>>>>>>>>>/// @Drivers     All
76413>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-31 by Aaron Gulack
76413>>>>>>>>>>>>>>>>>/// @See
76413>>>>>>>>>>>>>>>>>/// @INTOPT
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_RETRIEVE_RECNUM of {FileNumber} to {variable}
76413>>>>>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_RETRIEVE_RECNUM of {FileNumber} to {variable}
76413>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
76413>>>>>>>>>>>>>>>>>/// @Param  variable              Boolean variable. false to not retrieve record number, true otherwise.
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>/// @Example
76413>>>>>>>>>>>>>>>>>/// open ORDERHEA
76413>>>>>>>>>>>>>>>>>/// Handle  hFile
76413>>>>>>>>>>>>>>>>>/// Boolean bRetrieve
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Set_Attribute DF_FILE_RETRIEVE_RECNUM of hFile to false
76413>>>>>>>>>>>>>>>>>/// Get_Attribute DF_FILE_RETRIEVE_RECNUM of hFile To bRetrieve
76413>>>>>>>>>>>>>>>>>Define DF_FILE_RETRIEVE_RECNUM                      For (DF_FILE_RECORD_REREAD+17)
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//=============================================================================
76413>>>>>>>>>>>>>>>>>/// @Name        DF_FILE_NAME_SPACE
76413>>>>>>>>>>>>>>>>>/// @Description In Postgres, schemas are objects where all the tables,views and indexes
76413>>>>>>>>>>>>>>>>>/// are stored. Separate schemas are used to specify relational data. This attribute is
76413>>>>>>>>>>>>>>>>>/// used to set the name of the schema where a table is created. Schema's do not account
76413>>>>>>>>>>>>>>>>>/// for any physical space but are merely used as theory to explain the order of a database.
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Assumptions
76413>>>>>>>>>>>>>>>>>/// @Status      Public
76413>>>>>>>>>>>>>>>>>/// @Drivers     PGFlex
76413>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-25 by Aaron Gulack
76413>>>>>>>>>>>>>>>>>/// @See
76413>>>>>>>>>>>>>>>>>/// @INTOPT
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_NAME_SPACE of {FileNumber} to {variable}
76413>>>>>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_NAME_SPACE of {FileNumber} to {variable}
76413>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
76413>>>>>>>>>>>>>>>>>/// @Param  variable              Name of the Schema
76413>>>>>>>>>>>>>>>>>/// @Example
76413>>>>>>>>>>>>>>>>>/// open ORDERHEA
76413>>>>>>>>>>>>>>>>>/// Handle hFile
76413>>>>>>>>>>>>>>>>>/// String sSchemaName
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Set_Attribute DF_FILE_NAME_SPACE of hFile to "ORDERHEA"
76413>>>>>>>>>>>>>>>>>/// Get_Attribute DF_FILE_NAME_SPACE of hFile To sSchemaName
76413>>>>>>>>>>>>>>>>>Define DF_FILE_NAME_SPACE                           For (DF_FILE_RECORD_REREAD+18)
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>// Currently does not serve any function. May be included in future versions.
76413>>>>>>>>>>>>>>>>>Define DF_FILE_STORAGE_PCTFREE                      For (DF_FILE_RECORD_REREAD+19)
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>// Currently does not serve any function. May be included in future versions.
76413>>>>>>>>>>>>>>>>>Define DF_FILE_STORAGE_PCTUSED                      For (DF_FILE_RECORD_REREAD+21)
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>// Currently does not serve any function. May be included in future versions.
76413>>>>>>>>>>>>>>>>>Define DF_FILE_STORAGE_INITIAL                      For (DF_FILE_RECORD_REREAD+23)
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>// Currently does not serve any function. May be included in future versions.
76413>>>>>>>>>>>>>>>>>Define DF_FILE_STORAGE_NEXT                         For (DF_FILE_RECORD_REREAD+25)
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>// Currently does not serve any function. May be included in future versions.
76413>>>>>>>>>>>>>>>>>Define DF_FILE_ALLOW_NULL                           For (DF_FILE_RECORD_REREAD+27)
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//=============================================================================
76413>>>>>>>>>>>>>>>>>/// @Name        DF_FILE_GET_SERVERNAME_FROM_LOGIN
76413>>>>>>>>>>>>>>>>>/// @Description Use this attribute to specify whether the SERVER_NAME option will
76413>>>>>>>>>>>>>>>>>/// be included in the INT file.  If set to True, the SERVER_NAME option will not
76413>>>>>>>>>>>>>>>>>/// be included in the INT file, if set to false, the SERVER_NAME option will be
76413>>>>>>>>>>>>>>>>>/// included in the INT file. This has two uses. The first is during a Structure_Start
76413>>>>>>>>>>>>>>>>>/// i.e. table creation/modification. The other is when using the OUTPUT_INT_FILE
76413>>>>>>>>>>>>>>>>>/// command. Set this attribute before the OUTPUT_INT_FILE to indicate how the INT
76413>>>>>>>>>>>>>>>>>/// file will be written. This name indicates a backwards logic so take note that
76413>>>>>>>>>>>>>>>>>/// setting it to true will NOT include the SERVER_NAME in the INT file.
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Default Value: False
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Assumptions
76413>>>>>>>>>>>>>>>>>/// @Status      Deprecated
76413>>>>>>>>>>>>>>>>>/// @Drivers     All
76413>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-01 by Aaron Gulack
76413>>>>>>>>>>>>>>>>>/// @See         DF_FILE_SUPPRESS_SERVERNAME_OUTPUT
76413>>>>>>>>>>>>>>>>>/// @INTOPT              SERVER_NAME
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_GET_SERVERNAME_FROM_LOGIN of {FileNumber} to {variable}
76413>>>>>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_GET_SERVERNAME_FROM_LOGIN of {FileNumber} to {variable}
76413>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
76413>>>>>>>>>>>>>>>>>/// @Param  variable              Boolean variable. True to not include, false to include in INT.
76413>>>>>>>>>>>>>>>>>/// @Example
76413>>>>>>>>>>>>>>>>>/// Open Customer
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>///     Set_Attribute DF_FILE_GET_SERVERNAME_FROM_LOGIN of Customer.File_Number to True
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>///     OUTPUT_INT_FILE for Customer.File_Number to "c:\temp\test.int"
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Close Customer
76413>>>>>>>>>>>>>>>>>Define DF_FILE_GET_SERVERNAME_FROM_LOGIN            For (DF_FILE_RECORD_REREAD+29)
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//=============================================================================
76413>>>>>>>>>>>>>>>>>/// @Name        DF_FILE_SUPPRESS_SERVERNAME_OUTPUT
76413>>>>>>>>>>>>>>>>>/// @Description Use this attribute to specify whether the SERVER_NAME option will be included
76413>>>>>>>>>>>>>>>>>/// in the INT file.  If set to True, the server name will not be included in the INT file,
76413>>>>>>>>>>>>>>>>>/// if set to false, the server name will be included in the INT file. This has two uses.
76413>>>>>>>>>>>>>>>>>/// The first is during a Structure_Start i.e. table creation/modification. The other is
76413>>>>>>>>>>>>>>>>>/// when using the OUTPUT_INT_FILE command. Set this attribute before the OUTPUT_INT_FILE
76413>>>>>>>>>>>>>>>>>/// to indicate how the INT file will be written.
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Default Value: False
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Assumptions
76413>>>>>>>>>>>>>>>>>/// @Status      Public
76413>>>>>>>>>>>>>>>>>/// @Drivers     All
76413>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-01 by Aaron Gulack
76413>>>>>>>>>>>>>>>>>/// @See         DF_FILE_SUPPRESS_DATABASENAME_OUTPUT DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT
76413>>>>>>>>>>>>>>>>>/// @INTOPT              SERVER_NAME
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_SUPPRESS_SERVERNAME_OUTPUT of {FileNumber} to {variable}
76413>>>>>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_SUPPRESS_SERVERNAME_OUTPUT of {FileNumber} to {variable}
76413>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
76413>>>>>>>>>>>>>>>>>/// @Param  variable              Boolean variable. True to not include, false to include in INT.
76413>>>>>>>>>>>>>>>>>/// @Example
76413>>>>>>>>>>>>>>>>>/// Open Customer
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>///   Set_Attribute DF_FILE_SUPPRESS_SERVERNAME_OUTPUT of Customer.File_Number to True
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>///   OUTPUT_INT_FILE for Customer.File_Number to "c:\temp\test.int"
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Close Customer
76413>>>>>>>>>>>>>>>>>Define DF_FILE_SUPPRESS_SERVERNAME_OUTPUT                       For DF_FILE_GET_SERVERNAME_FROM_LOGIN
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//=============================================================================
76413>>>>>>>>>>>>>>>>>/// @Name        DF_FILE_GET_DATABASENAME_FROM_LOGIN
76413>>>>>>>>>>>>>>>>>/// @Description Use this attribute to specify whether the DATABASE_NAME option will
76413>>>>>>>>>>>>>>>>>/// be included in the INT file.  If set to True, the DATABASE_NAME option will not
76413>>>>>>>>>>>>>>>>>/// be included in the INT file, if set to false, the DATABASE_NAME option will be
76413>>>>>>>>>>>>>>>>>/// included in the INT file. This has two uses. The first is during a Structure_Start
76413>>>>>>>>>>>>>>>>>/// i.e. table creation/modification. The other is when using the OUTPUT_INT_FILE
76413>>>>>>>>>>>>>>>>>/// command. Set this attribute before the OUTPUT_INT_FILE to indicate how the INT
76413>>>>>>>>>>>>>>>>>/// file will be written. This name indicates a backwards logic so take note that
76413>>>>>>>>>>>>>>>>>/// setting it to true will NOT include the DATABASE_NAME in the INT file.
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Default Value: False
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Assumptions
76413>>>>>>>>>>>>>>>>>/// @Status      Deprecated
76413>>>>>>>>>>>>>>>>>/// @Drivers     PGFlex SQLFlex MySQLFlex
76413>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-01 by Aaron Gulack
76413>>>>>>>>>>>>>>>>>/// @See         DF_FILE_SUPPRESS_DATABASENAME_OUTPUT
76413>>>>>>>>>>>>>>>>>/// @INTOPT              DATABASE_NAME
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_GET_DATABASENAME_FROM_LOGIN of {FileNumber} to {variable}
76413>>>>>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_GET_DATABASENAME_FROM_LOGIN of {FileNumber} to {variable}
76413>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
76413>>>>>>>>>>>>>>>>>/// @Param  variable              Boolean variable. True to not include, false to include in INT.
76413>>>>>>>>>>>>>>>>>/// @Example
76413>>>>>>>>>>>>>>>>>/// Open Customer
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>///     Set_Attribute DF_FILE_GET_DATABASENAME_FROM_LOGIN of Customer.File_Number to True
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>///     OUTPUT_INT_FILE for Customer.File_Number to "c:\temp\test.int"
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Close Customer
76413>>>>>>>>>>>>>>>>>Define DF_FILE_GET_DATABASENAME_FROM_LOGIN          For (DF_FILE_RECORD_REREAD+31)
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//=============================================================================
76413>>>>>>>>>>>>>>>>>/// @Name        DF_FILE_SUPPRESS_DATABASENAME_OUTPUT
76413>>>>>>>>>>>>>>>>>/// @Description Use this attribute to specify whether the DATABASE_NAME option will
76413>>>>>>>>>>>>>>>>>/// be included in the INT file.  If set to True, the DATABASE_NAME option will not
76413>>>>>>>>>>>>>>>>>/// be included in the INT file, if set to false, the DATABASE_NAME option will be
76413>>>>>>>>>>>>>>>>>/// included in the INT file. This has two uses. The first is during a Structure_Start
76413>>>>>>>>>>>>>>>>>/// i.e. table creation/modification. The other is when using the OUTPUT_INT_FILE
76413>>>>>>>>>>>>>>>>>/// command. Set this attribute before the OUTPUT_INT_FILE to indicate how the INT
76413>>>>>>>>>>>>>>>>>/// file will be written. This name indicates a backwards logic so take note that
76413>>>>>>>>>>>>>>>>>/// setting it to true will NOT include the DATABASE_NAME in the INT file.
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Default Value: False
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Assumptions
76413>>>>>>>>>>>>>>>>>/// @Status      Public
76413>>>>>>>>>>>>>>>>>/// @Drivers     PGFlex SQLFlex MySQLFlex
76413>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-01 by Aaron Gulack
76413>>>>>>>>>>>>>>>>>/// @See         DF_FILE_SUPPRESS_SERVERNAME_OUTPUT DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT
76413>>>>>>>>>>>>>>>>>/// @INTOPT              DATABASE_NAME
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_SUPPRESS_DATABASENAME_OUTPUT of {FileNumber} to {variable}
76413>>>>>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_SUPPRESS_DATABASENAME_OUTPUT of {FileNumber} to {variable}
76413>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
76413>>>>>>>>>>>>>>>>>/// @Param  variable              Boolean variable. True to not include, false to include in INT.
76413>>>>>>>>>>>>>>>>>/// @Example
76413>>>>>>>>>>>>>>>>>/// Open Customer
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>///     Set_Attribute DF_FILE_SUPPRESS_DATABASENAME_OUTPUT of Customer.File_Number to True
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>///     OUTPUT_INT_FILE for Customer.File_Number to "c:\temp\test.int"
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Close Customer
76413>>>>>>>>>>>>>>>>>Define DF_FILE_SUPPRESS_DATABASENAME_OUTPUT                     For DF_FILE_GET_DATABASENAME_FROM_LOGIN
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//=============================================================================
76413>>>>>>>>>>>>>>>>>/// @Name        DF_FILE_GET_SCHEMANAME_FROM_LOGIN
76413>>>>>>>>>>>>>>>>>/// @Description Use this attribute to specify whether the SCHEMA_NAME option will
76413>>>>>>>>>>>>>>>>>/// be included in the INT file.  If set to True, the SCHEMA_NAME option will not
76413>>>>>>>>>>>>>>>>>/// be included in the INT file, if set to false, the SCHEMA_NAME option will be
76413>>>>>>>>>>>>>>>>>/// included in the INT file. This has two uses. The first is during a Structure_Start
76413>>>>>>>>>>>>>>>>>/// i.e. table creation/modification. The other is when using the OUTPUT_INT_FILE
76413>>>>>>>>>>>>>>>>>/// command. Set this attribute before the OUTPUT_INT_FILE to indicate how the INT
76413>>>>>>>>>>>>>>>>>/// file will be written. This name indicates a backwards logic so take note that
76413>>>>>>>>>>>>>>>>>/// setting it to true will NOT include the SCHEMA_NAME in the INT file.
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Default Value: False
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Assumptions
76413>>>>>>>>>>>>>>>>>/// @Status      Deprecated
76413>>>>>>>>>>>>>>>>>/// @Drivers     All
76413>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-01 by Aaron Gulack
76413>>>>>>>>>>>>>>>>>/// @See         DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT
76413>>>>>>>>>>>>>>>>>/// @INTOPT              SCHEMA_NAME
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_GET_SCHEMANAME_FROM_LOGIN of {FileNumber} to {variable}
76413>>>>>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_GET_SCHEMANAME_FROM_LOGIN of {FileNumber} to {variable}
76413>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
76413>>>>>>>>>>>>>>>>>/// @Param  variable              Boolean variable. True to not include, false to include in INT.
76413>>>>>>>>>>>>>>>>>/// @Example
76413>>>>>>>>>>>>>>>>>/// Open Customer
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>///     Set_Attribute DF_FILE_GET_SCHEMANAME_FROM_LOGIN of Customer.File_Number to True
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>///     OUTPUT_INT_FILE for Customer.File_Number to "c:\temp\test.int"
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Close Customer
76413>>>>>>>>>>>>>>>>>Define DF_FILE_GET_SCHEMANAME_FROM_LOGIN            For (DF_FILE_RECORD_REREAD+33)
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//=============================================================================
76413>>>>>>>>>>>>>>>>>/// @Name        DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT
76413>>>>>>>>>>>>>>>>>/// @Description Use this attribute to specify whether the SCHEMA_NAME option will
76413>>>>>>>>>>>>>>>>>/// be included in the INT file.  If set to True, the SCHEMA_NAME option will not
76413>>>>>>>>>>>>>>>>>/// be included in the INT file, if set to false, the SCHEMA_NAME option will be
76413>>>>>>>>>>>>>>>>>/// included in the INT file. This has two uses. The first is during a Structure_Start
76413>>>>>>>>>>>>>>>>>/// i.e. table creation/modification. The other is when using the OUTPUT_INT_FILE
76413>>>>>>>>>>>>>>>>>/// command. Set this attribute before the OUTPUT_INT_FILE to indicate how the INT
76413>>>>>>>>>>>>>>>>>/// file will be written. This name indicates a backwards logic so take note that
76413>>>>>>>>>>>>>>>>>/// setting it to true will NOT include the SCHEMA_NAME in the INT file.
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Default Value: False
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Assumptions
76413>>>>>>>>>>>>>>>>>/// @Status      Public
76413>>>>>>>>>>>>>>>>>/// @Drivers     All
76413>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-01 by Aaron Gulack
76413>>>>>>>>>>>>>>>>>/// @See         DF_FILE_SUPPRESS_DATABASENAME_OUTPUT DF_FILE_SUPPRESS_SERVERNAME_OUTPUT
76413>>>>>>>>>>>>>>>>>/// @INTOPT              SCHEMA_NAME
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT of {FileNumber} to {variable}
76413>>>>>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT of {FileNumber} to {variable}
76413>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
76413>>>>>>>>>>>>>>>>>/// @Param  variable              Boolean variable. True to not include, false to include in INT.
76413>>>>>>>>>>>>>>>>>/// @Example
76413>>>>>>>>>>>>>>>>>/// Open Customer
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>///     Set_Attribute DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT of Customer.File_Number to True
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>///     OUTPUT_INT_FILE for Customer.File_Number to "c:\temp\test.int"
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Close Customer
76413>>>>>>>>>>>>>>>>>Define DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT           For DF_FILE_GET_SCHEMANAME_FROM_LOGIN
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//TODO
76413>>>>>>>>>>>>>>>>>Define DF_FILE_PRESERVE_RECNUM                      For 184
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>// Currently Unsupported Attribute
76413>>>>>>>>>>>>>>>>>Define DF_FILE_NATIVE_RECORD_LENGTH                 For 194
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//=============================================================================
76413>>>>>>>>>>>>>>>>>/// @Name        DF_FILE_OEM_TRANSLATION
76413>>>>>>>>>>>>>>>>>/// @Description There are two sets of code pages used in windows, ANSI and
76413>>>>>>>>>>>>>>>>>/// OEM. ANSI is what is commonly used now, but some data still uses the OEM
76413>>>>>>>>>>>>>>>>>/// code pages. When migrating data, this attribute is used to determine whether
76413>>>>>>>>>>>>>>>>>/// the OEM data will be translated to ANSI during the migration. For example,
76413>>>>>>>>>>>>>>>>>/// migrating passwords with special characters may call for different code pages.
76413>>>>>>>>>>>>>>>>>/// Setting this attribute to true will convert the OEM data to ANSI, setting it
76413>>>>>>>>>>>>>>>>>/// to false will not.
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Assumptions
76413>>>>>>>>>>>>>>>>>/// @Status      Public
76413>>>>>>>>>>>>>>>>>/// @Drivers     All
76413>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-15 by Aaron Gulack
76413>>>>>>>>>>>>>>>>>/// @See
76413>>>>>>>>>>>>>>>>>/// @INTOPT
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_OEM_TRANSLATION of {FileNumber} to {variable}
76413>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_OEM_TRANSLATION of {FileNumber} to {variable}
76413>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
76413>>>>>>>>>>>>>>>>>/// @Param  variable              Indicates if OEM data will be converted to ANSI. True converts it, false does not.
76413>>>>>>>>>>>>>>>>>/// @Example
76413>>>>>>>>>>>>>>>>>/// open Customer
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Handle hFile
76413>>>>>>>>>>>>>>>>>/// Boolean bTranslate
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Move Customer.File_Number to hFile
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Structure_Start hFile
76413>>>>>>>>>>>>>>>>>///     Set_Attribute DF_FILE_OEM_TRANSLATION of hFile to True
76413>>>>>>>>>>>>>>>>>///     Get_Attribute DF_FILE_OEM_TRANSLATION of hFile to bTranslate
76413>>>>>>>>>>>>>>>>>/// Structure_End hFile
76413>>>>>>>>>>>>>>>>>Define DF_FILE_OEM_TRANSLATION                      For (DF_FILE_RECORD_REREAD+51)
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//=============================================================================
76413>>>>>>>>>>>>>>>>>/// @Name        DF_FILE_EPOCH_YEAR
76413>>>>>>>>>>>>>>>>>/// @Description When dealing with two-digit years, an epoch year must be used
76413>>>>>>>>>>>>>>>>>/// to determine which century the date is referring to. For example if the
76413>>>>>>>>>>>>>>>>>/// epoch year is set to 30, then any two digit year greater than 30 will be
76413>>>>>>>>>>>>>>>>>/// considered in the 20th Century, anything less than or equal to 30 will be
76413>>>>>>>>>>>>>>>>>/// considered in the 21st Century.  This attribute is used to turn on or off
76413>>>>>>>>>>>>>>>>>/// this feature. To use this feature, set this attribute to whatever the epoch
76413>>>>>>>>>>>>>>>>>/// year is expected to be. To disable this feature, set this attribute to 0
76413>>>>>>>>>>>>>>>>>/// or false. Note that setting this attribute must be done at table creation
76413>>>>>>>>>>>>>>>>>/// or inside of a Structure_Start.
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Assumptions
76413>>>>>>>>>>>>>>>>>/// @Status      Public
76413>>>>>>>>>>>>>>>>>/// @Drivers     All
76413>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-15 by Aaron Gulack
76413>>>>>>>>>>>>>>>>>/// @See
76413>>>>>>>>>>>>>>>>>/// @INTOPT      EPOCH_YEAR
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_EPOCH_YEAR of {FileNumber} to {variable}
76413>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_EPOCH_YEAR of {FileNumber} to {variable}
76413>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
76413>>>>>>>>>>>>>>>>>/// @Param  variable              Indicates what the epoch year is. 0 to disable
76413>>>>>>>>>>>>>>>>>/// @Example
76413>>>>>>>>>>>>>>>>>/// open Customer
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Handle hFile
76413>>>>>>>>>>>>>>>>>/// Boolean bEpoch
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Move Customer.File_Number to hFile
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Structure_Start hFile
76413>>>>>>>>>>>>>>>>>///     Set_Attribute DF_FILE_EPOCH_YEAR of hFile to 30
76413>>>>>>>>>>>>>>>>>///     Get_Attribute DF_FILE_EPOCH_YEAR of hFile to bEpoch
76413>>>>>>>>>>>>>>>>>/// Structure_End hFile
76413>>>>>>>>>>>>>>>>>Define DF_FILE_EPOCH_YEAR                           For (DF_FILE_RECORD_REREAD+53)
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>Define DF_FILE_USE_ROWCOUNT_IN_TRANSACTIONS         For 628
76413>>>>>>>>>>>>>>>>>Define DF_FILE_ICF_STATUS                           For 630
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//=============================================================================
76413>>>>>>>>>>>>>>>>>/// @Name        DF_FILE_LOCK_RECORD_STATUS
76413>>>>>>>>>>>>>>>>>/// @Description Table locking is done during transactions to maintain atomicity.
76413>>>>>>>>>>>>>>>>>/// In DataFlex, this is usually done with the REREAD/UNLOCK commands. This
76413>>>>>>>>>>>>>>>>>/// attribute is used to get the status of a table lock. If a table is currently
76413>>>>>>>>>>>>>>>>>/// in a REREAD, or locked, then the attribute will return true. Otherwise, it
76413>>>>>>>>>>>>>>>>>/// returns false. It is a read-only attribute so no setting can be done.
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Assumptions
76413>>>>>>>>>>>>>>>>>/// @Status      Public
76413>>>>>>>>>>>>>>>>>/// @Drivers     All
76413>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-06 by Aaron Gulack
76413>>>>>>>>>>>>>>>>>/// @See
76413>>>>>>>>>>>>>>>>>/// @INTOPT
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_LOCK_RECORD_STATUS of {FileNumber} to {variable}
76413>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
76413>>>>>>>>>>>>>>>>>/// @Param  variable              Indicates the status of the file lock
76413>>>>>>>>>>>>>>>>>/// @Example
76413>>>>>>>>>>>>>>>>>/// open Customer
76413>>>>>>>>>>>>>>>>>/// Handle hFile
76413>>>>>>>>>>>>>>>>>/// Integer bLocked
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Move Customer.File_Number to hFile
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Get_Attribute DF_FILE_LOCK_RECORD_STATUS of hFile to bLocked
76413>>>>>>>>>>>>>>>>>Define DF_FILE_LOCK_RECORD_STATUS                   For 632
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//=============================================================================
76413>>>>>>>>>>>>>>>>>/// @Name        DF_FILE_CASING
76413>>>>>>>>>>>>>>>>>/// @Description Controls the filename and column name casing.
76413>>>>>>>>>>>>>>>>>/// You can set this to either keep the file case, force to lower case or force
76413>>>>>>>>>>>>>>>>>/// to uppercase.
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Assumptions
76413>>>>>>>>>>>>>>>>>/// @Status      Public
76413>>>>>>>>>>>>>>>>>/// @Drivers     All
76413>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2014-04-28 by Wil van Antwerpen
76413>>>>>>>>>>>>>>>>>/// @See
76413>>>>>>>>>>>>>>>>>/// @INTOPT
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_CASING of {FileNumber} to {FILE_CASING_KEEP|FILE_CASING_LOWER|FILE_CASING_UPPER}
76413>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_CASING of {FileNumber} to {variable}
76413>>>>>>>>>>>>>>>>>/// @Param  FileNumber          Number of the file
76413>>>>>>>>>>>>>>>>>/// @Param  variable              integer set to one of the above values.
76413>>>>>>>>>>>>>>>>>/// @Example
76413>>>>>>>>>>>>>>>>>/// open Customer
76413>>>>>>>>>>>>>>>>>/// Handle hFile
76413>>>>>>>>>>>>>>>>>/// Integer eCasing
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Move Customer.File_Number to hFile
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Structure_Start hFile "ORA_DRV"
76413>>>>>>>>>>>>>>>>>///    Set_Attribute DF_FILE_CASING of hFile to FILE_CASING_KEEP
76413>>>>>>>>>>>>>>>>>/// Structure_End hFile
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Get_Attribute DF_FILE_CASING of hFile to eCasing
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>Define DF_FILE_CASING                               For 634
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>Define DF_FIELD_INVERSE_KEY_NAME                    For (DF_FIELD_NATIVE_LENGTH+1)
76413>>>>>>>>>>>>>>>>>Define DF_FIELD_INVERSE_KEY_TYPE                    For (DF_FIELD_NATIVE_LENGTH+2)
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//TODO
76413>>>>>>>>>>>>>>>>>Define DF_FIELD_TEXT_SEGMENT_NAME                   For (DF_FIELD_NATIVE_LENGTH+3)
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//TODO
76413>>>>>>>>>>>>>>>>>Define DF_FIELD_TEXT_NUM_SEGMENTS                   For (DF_FIELD_NATIVE_LENGTH+4)
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//=============================================================================
76413>>>>>>>>>>>>>>>>>/// @Name        DF_FIELD_DEFAULT_VALUE
76413>>>>>>>>>>>>>>>>>/// @Description Use this attribute to get or set the default value for a given column.
76413>>>>>>>>>>>>>>>>>/// Setting the default value can only be done during a structure_start or during table
76413>>>>>>>>>>>>>>>>>/// creation. If this attribute is not set, it is defaulted to the driver default.
76413>>>>>>>>>>>>>>>>>/// See Mertech.cfg
76413>>>>>>>>>>>>>>>>>/// @Assumptions
76413>>>>>>>>>>>>>>>>>/// @Status      Public
76413>>>>>>>>>>>>>>>>>/// @Drivers     All
76413>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-06 by Aaron Gulack
76413>>>>>>>>>>>>>>>>>/// @See
76413>>>>>>>>>>>>>>>>>/// @INTOPT
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FIELD_DEFAULT_VALUE of {FileNumber} {FieldNumber} to {variable}
76413>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FIELD_DEFAULT_VALUE of {FileNumber} {FieldNumber} to {variable}
76413>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
76413>>>>>>>>>>>>>>>>>/// @Param  FieldNumber           Number of the field
76413>>>>>>>>>>>>>>>>>/// @Param  variable              Variable for the default value of the field
76413>>>>>>>>>>>>>>>>>/// @Example
76413>>>>>>>>>>>>>>>>>/// open Customer
76413>>>>>>>>>>>>>>>>>/// String sDefault
76413>>>>>>>>>>>>>>>>>/// Handle hFile
76413>>>>>>>>>>>>>>>>>/// Integer iColumn
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Move "California" to sDefault
76413>>>>>>>>>>>>>>>>>/// Move Customer.File_Number to hFile
76413>>>>>>>>>>>>>>>>>/// Move 3 to iColumn
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Structure_Start hFile "ORA_DRV"
76413>>>>>>>>>>>>>>>>>///    Set_Attribute DF_FIELD_DEFAULT_VALUE of hFile iColumn to sDefault
76413>>>>>>>>>>>>>>>>>/// Structure_End hFile
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Get_Attribute DF_FIELD_DEFAULT_VALUE of hFile iColumn to sDefault
76413>>>>>>>>>>>>>>>>>Define DF_FIELD_DEFAULT_VALUE                       For (DF_FIELD_NATIVE_LENGTH+5)
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>// Currently Unsupported Attribute
76413>>>>>>>>>>>>>>>>>Define DF_FIELD_TEXT_LENGTH_SEGMENT                 For (DF_FIELD_NATIVE_LENGTH+6)
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//TODO
76413>>>>>>>>>>>>>>>>>//=============================================================================
76413>>>>>>>>>>>>>>>>>/// @Name        DF_FIELD_TIME_ON
76413>>>>>>>>>>>>>>>>>/// @Description Assign a field to retrieve Time Stamp value from a DATETIME
76413>>>>>>>>>>>>>>>>>/// column in a table.
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// This option was implemented because some versions of DataFlex do not support
76413>>>>>>>>>>>>>>>>>/// DATETIME fields normally supported by SQL databases.
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// To use this: Change the type of a date field in your FD to string type,
76413>>>>>>>>>>>>>>>>>/// Set the attribute DF_FIELD_TIME_ON of this field to TRUE and
76413>>>>>>>>>>>>>>>>>/// recompile your program.
76413>>>>>>>>>>>>>>>>>/// @Assumptions
76413>>>>>>>>>>>>>>>>>/// @Status      Public
76413>>>>>>>>>>>>>>>>>/// @Drivers     All
76413>>>>>>>>>>>>>>>>>/// @VersionNote
76413>>>>>>>>>>>>>>>>>/// @See
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FIELD_TIME_ON of <FileNumber|FileName FieldNumber> to DFTRUE | DFFALSE
76413>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
76413>>>>>>>>>>>>>>>>>/// @Param  FileName              Name of the file
76413>>>>>>>>>>>>>>>>>/// @Param  FieldNumber           Number of the field
76413>>>>>>>>>>>>>>>>>/// @Example
76413>>>>>>>>>>>>>>>>>/// #INCLUDE MERTECH.INC
76413>>>>>>>>>>>>>>>>>/// string sDateTime sDatabaseName
76413>>>>>>>>>>>>>>>>>/// open ORDERHEA
76413>>>>>>>>>>>>>>>>>/// Set_Attribute DF_FIELD_TIME_ON of 30 3 to dfTrue
76413>>>>>>>>>>>>>>>>>/// find GE ORDERHEA by recnum
76413>>>>>>>>>>>>>>>>>/// move ORDERHEA.ORDER_DATE to sDateTime
76413>>>>>>>>>>>>>>>>>/// showln "sDateTime: " sDateTime
76413>>>>>>>>>>>>>>>>>Define DF_FIELD_TIME_ON                             For (DF_FIELD_NATIVE_LENGTH+8)
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//=============================================================================
76413>>>>>>>>>>>>>>>>>/// @Name        DF_FIELD_NATIVE_NAME
76413>>>>>>>>>>>>>>>>>/// @Description This attribute is used to get the name of the desired column
76413>>>>>>>>>>>>>>>>>/// on the SQL backend. Currently this attribute is ReadOnly and so setting
76413>>>>>>>>>>>>>>>>>/// or modifying a column name cannot be done using this attribute.  In most
76413>>>>>>>>>>>>>>>>>/// cases, the field name on the SQL backend will be the same as the Dataflex name.
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// This is a ReadOnly attribute.
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Assumptions
76413>>>>>>>>>>>>>>>>>/// @Status      Public
76413>>>>>>>>>>>>>>>>>/// @Drivers     All
76413>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-09 by Aaron Gulack
76413>>>>>>>>>>>>>>>>>/// @See
76413>>>>>>>>>>>>>>>>>/// @INTOPT
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FIELD_NATIVE_NAME of {FileNumber} {FieldNumber} to {variable}
76413>>>>>>>>>>>>>>>>>/// @Param  FileNumber          Number of the file
76413>>>>>>>>>>>>>>>>>/// @Param  FieldNumber                 Number of the Field
76413>>>>>>>>>>>>>>>>>/// @Param  variable                    String containing the name of the field
76413>>>>>>>>>>>>>>>>>/// @Example
76413>>>>>>>>>>>>>>>>>/// Open Customer
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// String sName
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Get_Attribute DF_FIELD_NATIVE_NAME of Customer.File_Number 3 to sName
76413>>>>>>>>>>>>>>>>>Define DF_FIELD_NATIVE_NAME                         For (DF_FIELD_NATIVE_LENGTH+9)
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//=============================================================================
76413>>>>>>>>>>>>>>>>>/// @Name        DF_FIELD_NULL
76413>>>>>>>>>>>>>>>>>/// @Description Use this attribute to get or set whether a column in a table will
76413>>>>>>>>>>>>>>>>>/// allow null values. When set to true, the column accepts null values. Setting
76413>>>>>>>>>>>>>>>>>/// this attribute to false will keep it from accepting null values. Although,
76413>>>>>>>>>>>>>>>>>/// getting the value of this attribute can be done at anytime, setting it must
76413>>>>>>>>>>>>>>>>>/// be done in a Structure_Start or during table creation.
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Assumptions
76413>>>>>>>>>>>>>>>>>/// @Status      Public
76413>>>>>>>>>>>>>>>>>/// @Drivers     All
76413>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-09 by Aaron Gulack
76413>>>>>>>>>>>>>>>>>/// @See
76413>>>>>>>>>>>>>>>>>/// @INTOPT
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FIELD_NULL of {FileNumber} {FieldNumber} to {variable}
76413>>>>>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FIELD_NULL of {FileNumber} {FieldNumber} to {variable}
76413>>>>>>>>>>>>>>>>>/// @Param  FileNumber          Number of the file
76413>>>>>>>>>>>>>>>>>/// @Param  FieldNumber                 Number of the Field
76413>>>>>>>>>>>>>>>>>/// @Param  variable                    Boolean variable
76413>>>>>>>>>>>>>>>>>/// @Example
76413>>>>>>>>>>>>>>>>>/// Open Customer
76413>>>>>>>>>>>>>>>>>/// Handle hFile
76413>>>>>>>>>>>>>>>>>/// Integer iColumn
76413>>>>>>>>>>>>>>>>>/// Boolean bAllowNull
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Move Customer.File_Number to hFile
76413>>>>>>>>>>>>>>>>>/// Move 3 to iColumn
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Structure_Start hFile "ORA_DRV"
76413>>>>>>>>>>>>>>>>>///    Set_Attribute DF_FIELD_NULL of hFile iColumn to True
76413>>>>>>>>>>>>>>>>>/// Structure_End hFile
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Get_Attribute DF_FIELD_NULL of hFile iColumn to bAllowNull
76413>>>>>>>>>>>>>>>>>Define DF_FIELD_NULL                                For (DF_FIELD_NATIVE_LENGTH+10)
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//=============================================================================
76413>>>>>>>>>>>>>>>>>/// @Name        DF_FIELD_NATIVE_TYPE
76413>>>>>>>>>>>>>>>>>/// @Description Use this attribute to get or set the Native type for a specific
76413>>>>>>>>>>>>>>>>>/// field in a table.  The native type refers to the data type of the field on the
76413>>>>>>>>>>>>>>>>>/// SQL backend. Setting this attribute can only be done during table creation or
76413>>>>>>>>>>>>>>>>>/// inside of a Structure_Start. When setting this attribute, it is good practice
76413>>>>>>>>>>>>>>>>>/// to use the constants mentioned below instead of the integers. For a list of
76413>>>>>>>>>>>>>>>>>/// these constants, refer to the sections: "Oracle Data Types", "MySQL Data Types",
76413>>>>>>>>>>>>>>>>>/// "PostgreSQL Data Types", and "SQL Server Data Types" included in this document.
76413>>>>>>>>>>>>>>>>>/// Note that when getting the value for this attribute, an integer will be returned
76413>>>>>>>>>>>>>>>>>/// so these lists of constants can again prove useful.
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Assumptions
76413>>>>>>>>>>>>>>>>>/// @Status      Public
76413>>>>>>>>>>>>>>>>>/// @Drivers     All
76413>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-09 by Aaron Gulack
76413>>>>>>>>>>>>>>>>>/// @See
76413>>>>>>>>>>>>>>>>>/// @INTOPT      FIELD_TYPE
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FIELD_NATIVE_TYPE of {FileNumber} {FieldNumber} to {variable}
76413>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FIELD_NATIVE_TYPE of {FileNumber} {FieldNumber} to {variable}
76413>>>>>>>>>>>>>>>>>/// @Param  FileNumber          Number of the file
76413>>>>>>>>>>>>>>>>>/// @Param  FieldNumber         Number of the field
76413>>>>>>>>>>>>>>>>>/// @Param  variable                    variable for the native data type
76413>>>>>>>>>>>>>>>>>/// @Example
76413>>>>>>>>>>>>>>>>>/// open Customer
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Integer iColumn iType
76413>>>>>>>>>>>>>>>>>/// Handle hFile
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Move Customer.File_Number to hFile
76413>>>>>>>>>>>>>>>>>/// Structure_Start hFile
76413>>>>>>>>>>>>>>>>>///     Set_Attribute DF_FIELD_NATIVE_TYPE of hFile iColumn to "eSQLServer_DATE"
76413>>>>>>>>>>>>>>>>>///     Get_Attribute DF_FIELD_NATIVE_TYPE of hFile iColumn to iType
76413>>>>>>>>>>>>>>>>>///     Structure_End hFile
76413>>>>>>>>>>>>>>>>>Define DF_FIELD_NATIVE_TYPE                         For (DF_FIELD_NATIVE_LENGTH+12)
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>// Currently Unsupported Attribute (readOnly used by DataFlex 18.0 Studio)
76413>>>>>>>>>>>>>>>>>Define DF_FIELD_NATIVE_TYPE_NAME                    For 711
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>// Currently Unsupported Attribute
76413>>>>>>>>>>>>>>>>>Define DF_FIELD_NATIVE_OFFSET                       For (DF_FIELD_NATIVE_LENGTH+14)
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//=============================================================================
76413>>>>>>>>>>>>>>>>>/// @Name        DF_FIELD_AUTO_INCREMENT
76413>>>>>>>>>>>>>>>>>/// @Description Auto incrementing is a technique used in Dataflex usually for
76413>>>>>>>>>>>>>>>>>/// fields that are set as the unique identifier. Instead of generating a value
76413>>>>>>>>>>>>>>>>>/// or manually inserting data into the column, when a field auto increments,
76413>>>>>>>>>>>>>>>>>/// the value of the field increases by one (usually) with each record.  This
76413>>>>>>>>>>>>>>>>>/// field is used to get or set whether the field uses this technique or not.
76413>>>>>>>>>>>>>>>>>/// The attribute, however, can only be set inside of a Structure_Start or during
76413>>>>>>>>>>>>>>>>>/// table creation. Getting the attribute's value can be done at anytime. The
76413>>>>>>>>>>>>>>>>>/// value is stored as a boolean, either true or false.
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Assumptions
76413>>>>>>>>>>>>>>>>>/// @Status      Public
76413>>>>>>>>>>>>>>>>>/// @Drivers     All
76413>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-12 by Aaron Gulack
76413>>>>>>>>>>>>>>>>>/// @See
76413>>>>>>>>>>>>>>>>>/// @INTOPT      FIELD_AUTOINCREMENT_TYPE
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FIELD_AUTO_INCREMENT of {FileNumber} {FieldNumber} to {variable}
76413>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FIELD_AUTO_INCREMENT of {FileNumber} {FieldNumber} to {variable}
76413>>>>>>>>>>>>>>>>>/// @Param  FileNumber          Number of the file
76413>>>>>>>>>>>>>>>>>/// @Param  FieldNumber         Number of the field
76413>>>>>>>>>>>>>>>>>/// @Param  variable                    Boolean variable indicating if the field auto increments.
76413>>>>>>>>>>>>>>>>>/// @Example
76413>>>>>>>>>>>>>>>>>/// open Customer
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Integer iColumn
76413>>>>>>>>>>>>>>>>>/// Boolean bIncrement
76413>>>>>>>>>>>>>>>>>/// Handle hFile
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Move Customer.File_Number to hFile
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Structure_Start hFile
76413>>>>>>>>>>>>>>>>>///     Set_Attribute DF_FIELD_AUTO_INCREMENT of hFile iColumn to True
76413>>>>>>>>>>>>>>>>>///     Get_Attribute DF_FIELD_AUTO_INCREMENT of hFile iColumn to bIncrement
76413>>>>>>>>>>>>>>>>>///     Structure_End hFile
76413>>>>>>>>>>>>>>>>>Define DF_FIELD_AUTO_INCREMENT                      For (DF_FIELD_NATIVE_LENGTH+16)
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//Currently Unsupported Attribute
76413>>>>>>>>>>>>>>>>>Define DF_FIELD_GENERATE_ALWAYS                     For (DF_FIELD_NATIVE_LENGTH+18)
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>// Currently Unsupported Attribute
76413>>>>>>>>>>>>>>>>>Define DF_FIELD_SEND_LONG_DATA                      For 702
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//=============================================================================
76413>>>>>>>>>>>>>>>>>/// @Name        DF_INDEX_NATIVE_CREATED
76413>>>>>>>>>>>>>>>>>/// @Description Use this attribute to verify if the index that maps to the DataFlex
76413>>>>>>>>>>>>>>>>>/// index was created correctly at the SQL backend
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// This is a ReadOnly attribute
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Assumptions
76413>>>>>>>>>>>>>>>>>/// @Status      Public
76413>>>>>>>>>>>>>>>>>/// @Drivers     All
76413>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2014-04-30 by Wil van Antwerpen
76413>>>>>>>>>>>>>>>>>/// @See
76413>>>>>>>>>>>>>>>>>/// @INTOPT
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_INDEX_NATIVE_CREATED of {FileNumber} {IndexNumber} to variable
76413>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
76413>>>>>>>>>>>>>>>>>/// @Param  IndexNumber           Number of the index
76413>>>>>>>>>>>>>>>>>/// @Param  variable              True if created, false if not
76413>>>>>>>>>>>>>>>>>/// @Example
76413>>>>>>>>>>>>>>>>>/// Open Customer
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Handle  hFile
76413>>>>>>>>>>>>>>>>>/// Integer iIndex
76413>>>>>>>>>>>>>>>>>/// Boolean bCreated
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Move Customer.File_Number to hFile
76413>>>>>>>>>>>>>>>>>/// Move 1 To iIndex
76413>>>>>>>>>>>>>>>>>/// Get_Attribute DF_INDEX_NATIVE_CREATED of hFile iIndex to bCreated
76413>>>>>>>>>>>>>>>>>Define DF_INDEX_NATIVE_CREATED                      For (DF_INDEX_KEY_LENGTH+1)
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//=============================================================================
76413>>>>>>>>>>>>>>>>>/// @Name        DF_INDEX_NAME
76413>>>>>>>>>>>>>>>>>/// @Description Use this attribute to get the name of the index on the SQL backend
76413>>>>>>>>>>>>>>>>>/// that maps to the numbered index in Dataflex.  This is because, unlike Dataflex,
76413>>>>>>>>>>>>>>>>>/// all indexes in SQL are stored as names, not numbers. Since this attribute is
76413>>>>>>>>>>>>>>>>>/// currently only a ReadOnly attribute, it can not be used to set or modify a named
76413>>>>>>>>>>>>>>>>>/// index.
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// This is a ReadOnly attribute
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Assumptions
76413>>>>>>>>>>>>>>>>>/// @Status      Public
76413>>>>>>>>>>>>>>>>>/// @Drivers     All
76413>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-09 by Aaron Gulack
76413>>>>>>>>>>>>>>>>>/// @See
76413>>>>>>>>>>>>>>>>>/// @INTOPT
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_INDEX_NAME of {FileNumber} {IndexNumber} to variable
76413>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
76413>>>>>>>>>>>>>>>>>/// @Param  IndexNumber           Number of the index
76413>>>>>>>>>>>>>>>>>/// @Param  variable              Name of the index
76413>>>>>>>>>>>>>>>>>/// @Example
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Integer iFile iIndex iIndexes
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Open Orderhea
76413>>>>>>>>>>>>>>>>>/// Move Orderhea.File_Number to iFile
76413>>>>>>>>>>>>>>>>>/// Get_Attribute DF_FILE_LAST_INDEX_NUMBER of iFile to iIndexes
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// For iIndex From 0 to iIndexes
76413>>>>>>>>>>>>>>>>>///     Get_Attribute DF_INDEX_NAME of iFile iIndex to sIndexName
76413>>>>>>>>>>>>>>>>>///     Showln "Orderhea.Index." iIndex " : " sIndexName
76413>>>>>>>>>>>>>>>>>/// Loop
76413>>>>>>>>>>>>>>>>>Define DF_INDEX_NAME                                For (DF_INDEX_KEY_LENGTH+2)
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//=============================================================================
76413>>>>>>>>>>>>>>>>>/// @Name        DF_PRIMARY_KEY
76413>>>>>>>>>>>>>>>>>/// @Description This attribute is used to get or set the index number
76413>>>>>>>>>>>>>>>>>/// being used for the primary key. Getting the index number can be
76413>>>>>>>>>>>>>>>>>/// done at any time, but setting the index must be during a
76413>>>>>>>>>>>>>>>>>/// Structure_Start or during table creation.
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Assumptions
76413>>>>>>>>>>>>>>>>>/// @Status      Deprecated
76413>>>>>>>>>>>>>>>>>/// @Drivers     All
76413>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-09 by Aaron Gulack
76413>>>>>>>>>>>>>>>>>/// @See                 DF_INDEX_PRIMARY_KEY
76413>>>>>>>>>>>>>>>>>/// @INTOPT
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_PRIMARY_KEY of {FileNumber} to {variable}
76413>>>>>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_PRIMARY_KEY of {FileNumber} to {variable}
76413>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
76413>>>>>>>>>>>>>>>>>/// @Param  variable              Index number being used with primary key
76413>>>>>>>>>>>>>>>>>/// @Example
76413>>>>>>>>>>>>>>>>>/// Open Customer
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Integer iKey
76413>>>>>>>>>>>>>>>>>/// Handle hFile
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Move Customer.File_Number to hFile
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Structure_Start hFile
76413>>>>>>>>>>>>>>>>>///     Set_Attribute DF_PRIMARY_KEY of hFile to 2
76413>>>>>>>>>>>>>>>>>///     Get_Attribute DF_PRIMARY_KEY of hFile to iKey
76413>>>>>>>>>>>>>>>>>/// Structure_End hFile
76413>>>>>>>>>>>>>>>>>Define DF_PRIMARY_KEY                               For (DF_INDEX_KEY_LENGTH+3)
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//=============================================================================
76413>>>>>>>>>>>>>>>>>/// @Name        DF_INDEX_PRIMARY_KEY
76413>>>>>>>>>>>>>>>>>/// @Description This attribute is used to get or set the index number
76413>>>>>>>>>>>>>>>>>/// being used for the primary key. Getting the index number can be
76413>>>>>>>>>>>>>>>>>/// done at any time, but setting the index must be during a
76413>>>>>>>>>>>>>>>>>/// Structure_Start or during table creation.
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Assumptions
76413>>>>>>>>>>>>>>>>>/// @Status      Public
76413>>>>>>>>>>>>>>>>>/// @Drivers     All
76413>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-09 by Aaron Gulack
76413>>>>>>>>>>>>>>>>>/// @See
76413>>>>>>>>>>>>>>>>>/// @INTOPT              PRIMARY_KEY
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_INDEX_PRIMARY_KEY of {FileNumber} to {variable}
76413>>>>>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_INDEX_PRIMARY_KEY of {FileNumber} to {variable}
76413>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
76413>>>>>>>>>>>>>>>>>/// @Param  variable              Index number being used with primary key
76413>>>>>>>>>>>>>>>>>/// @Example
76413>>>>>>>>>>>>>>>>>/// Open Customer
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Integer iKey
76413>>>>>>>>>>>>>>>>>/// Handle hFile
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Move Customer.File_Number to hFile
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Structure_Start hFile
76413>>>>>>>>>>>>>>>>>///     Set_Attribute DF_INDEX_PRIMARY_KEY of hFile to 2
76413>>>>>>>>>>>>>>>>>///     Get_Attribute DF_INDEX_PRIMARY_KEY of hFile to iKey
76413>>>>>>>>>>>>>>>>>/// Structure_End hFile
76413>>>>>>>>>>>>>>>>>Define DF_INDEX_PRIMARY_KEY                         For (DF_INDEX_KEY_LENGTH+3)
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//=============================================================================
76413>>>>>>>>>>>>>>>>>/// @Name        DF_INDEX_STATUS
76413>>>>>>>>>>>>>>>>>/// @Description Oracle has an attribute for indexes called "STATUS" which indicates
76413>>>>>>>>>>>>>>>>>/// whether or not an index is valid for use. This attribute can only be used to get
76413>>>>>>>>>>>>>>>>>/// the value of the "STATUS" property in Oracle. It currently does not support setting
76413>>>>>>>>>>>>>>>>>/// the attribute. The two values for this attribute are "VALID" or "UNUSABLE".
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// This is a ReadOnly attribute
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Assumptions
76413>>>>>>>>>>>>>>>>>/// @Status      Public
76413>>>>>>>>>>>>>>>>>/// @Drivers     ORAFlex
76413>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-09 by Aaron Gulack
76413>>>>>>>>>>>>>>>>>/// @See
76413>>>>>>>>>>>>>>>>>/// @INTOPT
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_INDEX_STATUS of {FileNumber} {IndexNumber} to {variable}
76413>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
76413>>>>>>>>>>>>>>>>>/// @Param  FieldNumber           Number of the index
76413>>>>>>>>>>>>>>>>>/// @Param  variable              String indicating validity
76413>>>>>>>>>>>>>>>>>/// @Example
76413>>>>>>>>>>>>>>>>>/// Open Customer
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// String sIndexStatus
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Get_Attribute DF_INDEX_STATUS of Customer.File_Number 1 to sIndexStatus
76413>>>>>>>>>>>>>>>>>Define DF_INDEX_STATUS                              For (DF_INDEX_KEY_LENGTH+4)
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//Currently Unsupported Attribute
76413>>>>>>>>>>>>>>>>>Define DF_INDEX_STORAGE_PCTFREE                     For (DF_INDEX_KEY_LENGTH+5)
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//=============================================================================
76413>>>>>>>>>>>>>>>>>/// @Name        DF_INDEX_UNIQUE
76413>>>>>>>>>>>>>>>>>/// @Description An index on a column that is unique is considered so if it
76413>>>>>>>>>>>>>>>>>/// does not have two equal values in that column in two different rows. This
76413>>>>>>>>>>>>>>>>>/// attribute is used to find out whether or not the specified index is unique.
76413>>>>>>>>>>>>>>>>>/// If it is, this attribute will return "U" indicating that it is indeed unique.
76413>>>>>>>>>>>>>>>>>/// This is important to note because when getting the value of this attribute,
76413>>>>>>>>>>>>>>>>>/// a string variable must be used. Since this is a ReadOnly attribute, setting
76413>>>>>>>>>>>>>>>>>/// an idex to unique cannot be done with this attribute.
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Assumptions
76413>>>>>>>>>>>>>>>>>/// @Status      Public
76413>>>>>>>>>>>>>>>>>/// @Drivers     All
76413>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-14 by Aaron Gulack
76413>>>>>>>>>>>>>>>>>/// @See
76413>>>>>>>>>>>>>>>>>/// @INTOPT
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_INDEX_UNIQUE of {FileNumber} {IndexNumber} to {variable}
76413>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
76413>>>>>>>>>>>>>>>>>/// @Param  FieldNumber           Number of the index
76413>>>>>>>>>>>>>>>>>/// @Param  variable              String indicating if unique
76413>>>>>>>>>>>>>>>>>/// @Example
76413>>>>>>>>>>>>>>>>>/// Open Customer
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// String sIndexUnique
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Get_Attribute DF_INDEX_UNIQUE of Customer.File_Number 1 to sIndexUnique
76413>>>>>>>>>>>>>>>>>Define DF_INDEX_UNIQUE                              For (DF_INDEX_KEY_LENGTH+6)
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//Currently Unsupported Attribute
76413>>>>>>>>>>>>>>>>>Define DF_INDEX_STORAGE_BASE                        For (DF_INDEX_KEY_LENGTH+7)
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//Currently Unsupported Attribute
76413>>>>>>>>>>>>>>>>>Define DF_INDEX_STORAGE_INITIAL                     For (DF_INDEX_KEY_LENGTH+8)
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//Currently Unsupported Attribute
76413>>>>>>>>>>>>>>>>>Define DF_INDEX_STORAGE_NEXT                        For (DF_INDEX_KEY_LENGTH+10)
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//Currently Unsupported Attribute
76413>>>>>>>>>>>>>>>>>Define DF_INDEX_NATIVE_TYPE                         For (DF_INDEX_KEY_LENGTH+13)
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//TODO
76413>>>>>>>>>>>>>>>>>Define DF_INDEX_TABLESPACE                          For (DF_INDEX_KEY_LENGTH+14)
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//TODO
76413>>>>>>>>>>>>>>>>>Define DF_FIELD_PROGRAMMATIC_DEFAULT                For 701
76413>>>>>>>>>>>>>>>>>Define DF_FIELD_TIME                                For 703
76413>>>>>>>>>>>>>>>>>Define DF_FIELD_IS_NULL                             For 704
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//=============================================================================
76413>>>>>>>>>>>>>>>>>/// @Name        DF_FIELD_IS_LOB
76413>>>>>>>>>>>>>>>>>/// @Description In databases a LOB data type is any type that is considered
76413>>>>>>>>>>>>>>>>>/// a "Large Object" i.e. XML types, Binary types etc.  This attribute is a
76413>>>>>>>>>>>>>>>>>/// ReadOnly attribute used to indicate whether the given field is considered
76413>>>>>>>>>>>>>>>>>/// a LOB data type. Since it is ReadOnly, this attribute cannot set a field
76413>>>>>>>>>>>>>>>>>/// to a LOB data type.
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Assumptions
76413>>>>>>>>>>>>>>>>>/// @Status      Public
76413>>>>>>>>>>>>>>>>>/// @Drivers     All
76413>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-13 by Aaron Gulack
76413>>>>>>>>>>>>>>>>>/// @See
76413>>>>>>>>>>>>>>>>>/// @INTOPT
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FIELD_IS_LOB of {FileNumber} {FieldNumber} to {variable}
76413>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
76413>>>>>>>>>>>>>>>>>/// @Param      FieldNumber                       Number of the field
76413>>>>>>>>>>>>>>>>>/// @Param  variable              Boolean variable indicating if LOB
76413>>>>>>>>>>>>>>>>>/// @Example
76413>>>>>>>>>>>>>>>>>/// Open Customer
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Boolean bIsLOB
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Get_Attribute DF_FIELD_IS_LOB of Customer.File_Number 6 to bIsLOB
76413>>>>>>>>>>>>>>>>>Define DF_FIELD_IS_LOB                              For 706
76413>>>>>>>>>>>>>>>>>Define DF_FIELD_DEFAULT_FUNCTION                    For 707
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//Currently Unsupported Attribute
76413>>>>>>>>>>>>>>>>>Define DF_FIELD_HANDLE_AS_LOB                       For 708
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//TODO
76413>>>>>>>>>>>>>>>>>Define DF_FIELD_PARTIAL_OVERLAP                     For 710
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//=============================================================================
76413>>>>>>>>>>>>>>>>>/// @Name        DF_FILE_NUMBER_SQL_RELATIONS
76413>>>>>>>>>>>>>>>>>/// @Description This attribute is used to get the number of foreign keys
76413>>>>>>>>>>>>>>>>>/// for a given table on the SQL backend. Foreign keys are used to specify
76413>>>>>>>>>>>>>>>>>/// relationships between tables. Since this attribute is ReadOnly, it cannot
76413>>>>>>>>>>>>>>>>>/// be used to set the number of foreign keys in a table.  Note that this
76413>>>>>>>>>>>>>>>>>/// attribute returns only the number of foreign keys, no other information
76413>>>>>>>>>>>>>>>>>/// is provided with this attribute.
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// This is a ReadOnly attribute
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Assumptions
76413>>>>>>>>>>>>>>>>>/// @Status      Public
76413>>>>>>>>>>>>>>>>>/// @Drivers     All
76413>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-13 by Aaron Gulack
76413>>>>>>>>>>>>>>>>>/// @See
76413>>>>>>>>>>>>>>>>>/// @INTOPT
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_NUMBER_SQL_RELATIONS of {FileNumber} to {variable}
76413>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
76413>>>>>>>>>>>>>>>>>/// @Param  variable              Integer variable showing number of relationships
76413>>>>>>>>>>>>>>>>>/// @Example
76413>>>>>>>>>>>>>>>>>/// Open Customer
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Integer iRelations
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Get_Attribute DF_FILE_NUMBER_SQL_RELATIONS of Customer.File_Number to iRelations
76413>>>>>>>>>>>>>>>>>Define DF_FILE_NUMBER_SQL_RELATIONS                 For 626
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//TODO
76413>>>>>>>>>>>>>>>>>Define DF_SQL_RELATION_COLUMN                       For 716
76413>>>>>>>>>>>>>>>>>Define DF_SQL_RELATION_RELATED_SCHEMA               For 717
76413>>>>>>>>>>>>>>>>>Define DF_SQL_RELATION_RELATED_TABLE                For 719
76413>>>>>>>>>>>>>>>>>Define DF_SQL_RELATION_RELATED_COLUMN               For 721
76413>>>>>>>>>>>>>>>>>Define DF_SQL_RELATION_NAME                         For 723
76413>>>>>>>>>>>>>>>>>Define DF_SQL_RELATION_STATUS                       For 724
76413>>>>>>>>>>>>>>>>>Define DF_SQL_RELATION_DELETE_REF_ACTION            For 726
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//Currently Unsupported Attribute
76413>>>>>>>>>>>>>>>>>Define DF_FIELD_OVERLAP_START                       For 728
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//Currently Unsupported Attribute
76413>>>>>>>>>>>>>>>>>Define DF_FIELD_OVERLAP_END                         For 730
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//Currently Unsupported Attribute
76413>>>>>>>>>>>>>>>>>Define DF_FIELD_OVERLAP_OFFSET_START                For 732
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//Currently Unsupported Attribute
76413>>>>>>>>>>>>>>>>>Define DF_FIELD_OVERLAP_OFFSET_END                  For 734
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//=============================================================================
76413>>>>>>>>>>>>>>>>>/// @Name        DF_FILE_RECNUM_TABLE
76413>>>>>>>>>>>>>>>>>/// @Description Dataflex's embedded database, by default, uses a Recnum column
76413>>>>>>>>>>>>>>>>>/// as the unique identifier for a table instead of a primary key. A table can
76413>>>>>>>>>>>>>>>>>/// easily be changed to use another column though and this attribute gets or
76413>>>>>>>>>>>>>>>>>/// sets whether the Recnum is being used for a table. Getting the value of this
76413>>>>>>>>>>>>>>>>>/// attribute can be done at any time for any driver. The setting of this attribute,
76413>>>>>>>>>>>>>>>>>/// however, can only be done in certain situations. Only if an alternative primary
76413>>>>>>>>>>>>>>>>>/// key is set up already can this attribute be set to false and only during a
76413>>>>>>>>>>>>>>>>>/// Structure_Start. Also, the attribute can only be turned off (set to false),
76413>>>>>>>>>>>>>>>>>/// it can not be turned back on (set to True).
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Note: In Postgres, this attribute is a ReadOnly attribute and can not be set.
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Assumptions
76413>>>>>>>>>>>>>>>>>/// @Status      Public (PGFlex ReadOnly)
76413>>>>>>>>>>>>>>>>>/// @Drivers     All
76413>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-12 by Aaron Gulack
76413>>>>>>>>>>>>>>>>>/// @See                 DF_FILE_RECNUM_NAME DF_FILE_PRIMARY_INDEX
76413>>>>>>>>>>>>>>>>>/// @INTOPT
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_RECNUM_TABLE of {FileNumber} to {variable}
76413>>>>>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_RECNUM_TABLE of {FileNumber} to {variable}
76413>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
76413>>>>>>>>>>>>>>>>>/// @Param  variable              Boolean variable indicating if recnum is used
76413>>>>>>>>>>>>>>>>>/// @Example
76413>>>>>>>>>>>>>>>>>/// Open Customer
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Boolean bRecnum
76413>>>>>>>>>>>>>>>>>/// Handle hFile
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Move Customer.File_Number to hFile
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Structure_Start hFile
76413>>>>>>>>>>>>>>>>>///     Set_Attribute DF_FILE_RECNUM_TABLE of Customer.File_Number to False
76413>>>>>>>>>>>>>>>>>///     Get_Attribute DF_FILE_RECNUM_TABLE of Customer.File_Number to bRecnum
76413>>>>>>>>>>>>>>>>>/// Structure_End hFile
76413>>>>>>>>>>>>>>>>>Define DF_FILE_RECNUM_TABLE                         For 1401
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//=============================================================================
76413>>>>>>>>>>>>>>>>>/// @Name        DF_FILE_PRIMARY_INDEX
76413>>>>>>>>>>>>>>>>>/// @Description This attribute gets or sets the index which is used as the
76413>>>>>>>>>>>>>>>>>/// primary key for a table. The variable used for this attribute is an integer
76413>>>>>>>>>>>>>>>>>/// containing the numbered index used. Getting the value of this attribute can
76413>>>>>>>>>>>>>>>>>/// be done at any time, whereas setting can only be done at table creation or
76413>>>>>>>>>>>>>>>>>/// during a Structure_Start. If a RECNUM is used as the unique identifier then
76413>>>>>>>>>>>>>>>>>/// 0 is returned.
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Note: In Postgres this attribute is ReadOnly, so it can only be used to get
76413>>>>>>>>>>>>>>>>>/// the index used as the primary key.
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Assumptions
76413>>>>>>>>>>>>>>>>>/// @Status      Public (PGFlex ReadOnly)
76413>>>>>>>>>>>>>>>>>/// @Drivers     All
76413>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-12 by Aaron Gulack
76413>>>>>>>>>>>>>>>>>/// @See                 DF_FILE_RECNUM_NAME
76413>>>>>>>>>>>>>>>>>/// @INTOPT
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_PRIMARY_INDEX of {FileNumber} to {variable}
76413>>>>>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_PRIMARY_INDEX of {FileNumber} to {variable}
76413>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
76413>>>>>>>>>>>>>>>>>/// @Param  variable              Boolean variable indicating if a primary key is used
76413>>>>>>>>>>>>>>>>>/// @Example
76413>>>>>>>>>>>>>>>>>/// Open Customer
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Boolean bPrimary
76413>>>>>>>>>>>>>>>>>/// Handle hFile
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Move Customer.File_Number to hFile
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Structure_Start hFile
76413>>>>>>>>>>>>>>>>>///     Set_Attribute DF_FILE_PRIMARY_INDEX of Customer.File_Number to False
76413>>>>>>>>>>>>>>>>>///     Get_Attribute DF_FILE_PRIMARY_INDEX of Customer.File_Number to bPrimary
76413>>>>>>>>>>>>>>>>>/// Structure_End hFile
76413>>>>>>>>>>>>>>>>>Define DF_FILE_PRIMARY_INDEX                        For 1402
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//=============================================================================
76413>>>>>>>>>>>>>>>>>/// @Name        DF_FILE_RECNUM_NAME
76413>>>>>>>>>>>>>>>>>/// @Description This attribute is used to get the name of the Recnum field
76413>>>>>>>>>>>>>>>>>/// in the table, if one exists. It is a ReadOnly attribute so it can only
76413>>>>>>>>>>>>>>>>>/// be used in getting the name of the recnum field to a string variable.
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Assumptions
76413>>>>>>>>>>>>>>>>>/// @Status      Public
76413>>>>>>>>>>>>>>>>>/// @Drivers     All
76413>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-12 by Aaron Gulack
76413>>>>>>>>>>>>>>>>>/// @See                 DF_FILE_RECNUM_TABLE
76413>>>>>>>>>>>>>>>>>/// @INTOPT
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_RECNUM_NAME of {FileNumber} to {variable}
76413>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
76413>>>>>>>>>>>>>>>>>/// @Param  variable              String name of recnum field
76413>>>>>>>>>>>>>>>>>/// @Example
76413>>>>>>>>>>>>>>>>>/// Open Customer
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// String sRecnum
76413>>>>>>>>>>>>>>>>>///
76413>>>>>>>>>>>>>>>>>/// Get_Attribute DF_FILE_RECNUM_NAME of Customer.File_Number to sRecnum
76413>>>>>>>>>>>>>>>>>Define DF_FILE_RECNUM_NAME                          For 1403
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>Define DF_FETCH_ALL                                 For -1
76413>>>>>>>>>>>>>>>>>Define DF_FETCH_TRUE                                For "TRUE"
76413>>>>>>>>>>>>>>>>>Define DF_FETCH_FALSE                               For "FALSE"
76413>>>>>>>>>>>>>>>>>Define DF_BIND_ALL_COLUMNS                          For -1
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>// SQLFlex Lock Type
76413>>>>>>>>>>>>>>>>>Define DF_LOCK_TYPE_PAGE                            For 3
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>// Extended Callback Types
76413>>>>>>>>>>>>>>>>>Define DF_MESSAGE_ERROR                             For 9
76413>>>>>>>>>>>>>>>>>Define DF_MESSAGE_PROGRESS_STATUS                   For 20
76413>>>>>>>>>>>>>>>>>Define DF_MESSAGE_PROGRESS_CONTINUE                 For 21
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//Drivers
76413>>>>>>>>>>>>>>>>>Define ORAFLEX                                      For "ORA_DRV"
76413>>>>>>>>>>>>>>>>>Define SQLFLEX                                      For "SQL_DRV"
76413>>>>>>>>>>>>>>>>>Define MDSDB2                                       For "MDS_DB2"
76413>>>>>>>>>>>>>>>>>Define MDSPgSQL                                     For "MDSPGSQL"
76413>>>>>>>>>>>>>>>>>Define PgFlex                                       For "MDSPGSQL"
76413>>>>>>>>>>>>>>>>>Define MDSMySQL                                     For "MDSMYSQL"
76413>>>>>>>>>>>>>>>>>Define MySQLFlex                                    For "MDSMYSQL"
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>// Delimiter for SQL ID objects
76413>>>>>>>>>>>>>>>>>Define DB2_ID_DELIM                                 For '"'
76413>>>>>>>>>>>>>>>>>Define MYSQL_ID_DELIM                               For "`"
76413>>>>>>>>>>>>>>>>>Define ORACLE_ID_DELIM                              For '"'
76413>>>>>>>>>>>>>>>>>Define PGSQL_ID_DELIM                               For '"'
76413>>>>>>>>>>>>>>>>>Define SQLSERVER_ID_DELIM                           For '"'
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>// dfStructureEnd Option bits
76413>>>>>>>>>>>>>>>>>Define DF_STRUCTEND_OPT_INDEX_ONLY                  For 16    // Internal Use Only
76413>>>>>>>>>>>>>>>>>Define DF_STRUCTEND_OPT_FORCE_INVK                  For 32
76413>>>>>>>>>>>>>>>>>Define DF_STRUCTEND_OPT_OLD_INVK_NAME               For 64
76413>>>>>>>>>>>>>>>>>Define DF_STRUCTEND_OPT_FORCE_NOT_NULL              For 128
76413>>>>>>>>>>>>>>>>>Define DF_STRUCTEND_OPT_CREATE_ROWID_TABLE          For 256
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//Additional Data Types
76413>>>>>>>>>>>>>>>>>Define DF_DATETIME                                  For 7
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//Call_Driver Functions
76413>>>>>>>>>>>>>>>>>Define CALLDRV_LICENSE_ENVIRONMENT_SET              For 0
76413>>>>>>>>>>>>>>>>>Define CALLDRV_ORA_CURRENT_SQL_SERVER               For 6
76413>>>>>>>>>>>>>>>>>Define CALLDRV_SQL_ERROR_MESSAGE                    For 14
76413>>>>>>>>>>>>>>>>>Define CALLDRV_CURRENT_SQL_SERVER                   for 19
76413>>>>>>>>>>>>>>>>>Define CALLDRV_SQL_NEXT_RESULTSET                   for ((22 * (2^16)) + 11)
76413>>>>>>>>>>>>>>>>>Define CALLDRV_BIND_PARAMETER                       for 23
76413>>>>>>>>>>>>>>>>>Define CALLDRV_SQL_MAX_CURSORS                      For 26
76413>>>>>>>>>>>>>>>>>Define CALLDRV_SQLLOADER_FIELDS_TERM                For 30
76413>>>>>>>>>>>>>>>>>Define CALLDRV_CREATE_TABLE_FROM_DAT                For 30
76413>>>>>>>>>>>>>>>>>Define CALLDRV_SQLLOADER_DECIMAL_SEP                For 31
76413>>>>>>>>>>>>>>>>>Define CALLDRV_CONVERT_DAT_FILE                     For 32
76413>>>>>>>>>>>>>>>>>Define CALLDRV_SQLFLEX_MAX_CURSORS                  For 37
76413>>>>>>>>>>>>>>>>>Define CALLDRV_NATIVE_OPTIMIZATION                  For 38
76413>>>>>>>>>>>>>>>>>Define CALLDRV_GET_RETURNED_COLUMNS                 For 39
76413>>>>>>>>>>>>>>>>>Define CALLDRV_GET_RETURNED_ROWS                    For 40
76413>>>>>>>>>>>>>>>>>Define CALLDRV_GET_COLUMN_ATTRIBUTE                 For 41
76413>>>>>>>>>>>>>>>>>Define CALLDRV_START_TXTGEN_AFTER_RECNUM            For 42
76413>>>>>>>>>>>>>>>>>Define CALLDRV_FINISH_TXTGEN_AFTER_RECNUM           For 43
76413>>>>>>>>>>>>>>>>>Define CALLDRV_SET_ISOLATION_LEVEL                  For 44
76413>>>>>>>>>>>>>>>>>Define CALLDRV_GET_SERVER_CFG                       For 45
76413>>>>>>>>>>>>>>>>>Define CALLDRV_SET_SQL_LOCK_TIMEOUT                 For 46
76413>>>>>>>>>>>>>>>>>Define CALLDRV_GET_SQL_LOCK_TIMEOUT                 For 47
76413>>>>>>>>>>>>>>>>>Define CALLDRV_GET_RESULTS                          For 48
76413>>>>>>>>>>>>>>>>>Define CALLDRV_GET_MORE_RESULTS                     For 49
76413>>>>>>>>>>>>>>>>>Define CALLDRV_GET_CURRENT_USER_NAME                For 50
76413>>>>>>>>>>>>>>>>>Define CALLDRV_OPEN_EMBEDDED_CURSOR                 For 51
76413>>>>>>>>>>>>>>>>>Define CALLDRV_CLOSE_EMBEDDED_CURSOR                For 52
76413>>>>>>>>>>>>>>>>>Define CALLDRV_SET_CURRENT_EMBEDDED_CURSOR          For 53
76413>>>>>>>>>>>>>>>>>Define CALLDRV_GET_CURRENT_EMBEDDED_CURSOR          For 54
76413>>>>>>>>>>>>>>>>>Define CALLDRV_SET_MAX_EMBEDDED_CURSOR              For 55
76413>>>>>>>>>>>>>>>>>Define CALLDRV_GET_MAX_EMBEDDED_CURSOR              For 56
76413>>>>>>>>>>>>>>>>>Define CALLDRV_SQL_TRANSACTION                      For 57
76413>>>>>>>>>>>>>>>>>Define CALLDRV_LOCAL_TD_PATH                        For 58
76413>>>>>>>>>>>>>>>>>Define CALLDRV_CREATE_DB                            For 59
76413>>>>>>>>>>>>>>>>>Define CALLDRV_ESCAPE_STRING                        For 60
76413>>>>>>>>>>>>>>>>>Define CALLDRV_SET_PROC_ATTRIBUTE_TYPE              For 61
76413>>>>>>>>>>>>>>>>>Define CALLDRV_SQL_REFRESH_CACHE                    For 62
76413>>>>>>>>>>>>>>>>>Define CALLDRV_GET_SQL_STMT                         For 63
76413>>>>>>>>>>>>>>>>>Define CALLDRV_DIRECT_PATH_LOAD                     For 64
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>Define CALLDRV_READ_LOB                             For 65
76413>>>>>>>>>>>>>>>>>Define CALLDRV_WRITE_LOB                            For 66
76413>>>>>>>>>>>>>>>>>Define CALLDRV_APPEND_LOB                           For 67
76413>>>>>>>>>>>>>>>>>Define CALLDRV_LENGTH_LOB                           For 68
76413>>>>>>>>>>>>>>>>>Define CALLDRV_LOADFROMFILE_LOB                     For 69
76413>>>>>>>>>>>>>>>>>Define CALLDRV_ERASE_LOB                            For 70
76413>>>>>>>>>>>>>>>>>Define CALLDRV_TRUNCATE_LOB                         For 71
76413>>>>>>>>>>>>>>>>>Define CALLDRV_INITIALIZE_SEQUENCE                  For 72
76413>>>>>>>>>>>>>>>>>Define CALLDRV_CLIENT_CFG                           For 73
76413>>>>>>>>>>>>>>>>>Define CALLDRV_END_SAVERECORD                       For 74
76413>>>>>>>>>>>>>>>>>Define CALLDRV_ENABLE_RECONNECT                     For 75
76413>>>>>>>>>>>>>>>>>Define CALLDRV_ENUMERATE_SERVER                     For 76
76413>>>>>>>>>>>>>>>>>Define CALLDRV_USE_ROWCOUNT_IN_TRANSACTIONS         For 77
76413>>>>>>>>>>>>>>>>>Define CALLDRV_USE_DFLEX_DATE_FORMAT                For 78
76413>>>>>>>>>>>>>>>>>Define CALLDRV_FORCE_FIELDS_NOT_NULL                For 79
76413>>>>>>>>>>>>>>>>>Define CALLDRV_ORA_CREATE_TABLE_FROM_DAT            For 80
76413>>>>>>>>>>>>>>>>>Define CALLDRV_MAX_DATA_SIZE                        For 81
76413>>>>>>>>>>>>>>>>>Define CALLDRV_CHUNK_SIZE                           For 82
76413>>>>>>>>>>>>>>>>>Define CALLDRV_GET_DATA_CHUNK                       For 83
76413>>>>>>>>>>>>>>>>>Define CALLDRV_MIRROR_SERVER                        For 84
76413>>>>>>>>>>>>>>>>>Define CALLDRV_COPY_DATA                            For 85
76413>>>>>>>>>>>>>>>>>Define CALLDRV_SET_SQL_CURSOR_TYPE                  For 86
76413>>>>>>>>>>>>>>>>>Define CALLDRV_ICF                                  For 87
76413>>>>>>>>>>>>>>>>>Define CALLDRV_CLEAR_INT_CACHE                      For 88
76413>>>>>>>>>>>>>>>>>Define CALLDRV_GET_CURRENT_USER_PASSWORD            For 89
76413>>>>>>>>>>>>>>>>>Define CALLDRV_FORCE_FIELDS_NULL                    For 90
76413>>>>>>>>>>>>>>>>>Define CALLDRV_TRANSACTIONS_ALLOWED                 For 91
76413>>>>>>>>>>>>>>>>>Define CALLDRV_SQL_ERROR_MESSAGE2                   For 92
76413>>>>>>>>>>>>>>>>>Define CALLDRV_PGSQL_NAME_SPACE                     For 93
76413>>>>>>>>>>>>>>>>>Define CALLDRV_EMBEDDED_SQL_TYPE                    For 94
76413>>>>>>>>>>>>>>>>>Define CALLDRV_CREATE_INVK_FUNCTIONS                For 95
76413>>>>>>>>>>>>>>>>>Define CALLDRV_DEFAULT_FILE_CASING                  For 96
76413>>>>>>>>>>>>>>>>>Define CALLDRV_GLOBAL_SETTING                       For 97
76413>>>>>>>>>>>>>>>>>Define CALLDRV_RESTRUCTURE_SCRIPT                   For 98
76413>>>>>>>>>>>>>>>>>Define CALLDRV_CURRENT_SQL_SERVER_CONNECTION        For 99
76413>>>>>>>>>>>>>>>>>Define CALLDRV_100                                  For 100
76413>>>>>>>>>>>>>>>>>Define CALLDRV_FILE_STRUCT_DYNAMIC_ONLINE           For 101
76413>>>>>>>>>>>>>>>>>Define CALLDRV_SET_FIXED_FILE_RECORDS_USED          For 102
76413>>>>>>>>>>>>>>>>>Define CALLDRV_GET_FIXED_FILE_RECORDS_USED          For 103
76413>>>>>>>>>>>>>>>>>Define CALLDRV_LOB_EX_WRITE                         For 104
76413>>>>>>>>>>>>>>>>>Define CALLDRV_LOB_EX_APPEND                        For 105
76413>>>>>>>>>>>>>>>>>Define CALLDRV_LOB_EX_READ                          For 106
76413>>>>>>>>>>>>>>>>>Define CALLDRV_LOB_EX_GET_LENGTH                    For 107
76413>>>>>>>>>>>>>>>>>Define CALLDRV_LOB_EX_SET_LENGTH                    For 108
76413>>>>>>>>>>>>>>>>>Define CALLDRV_LOB_EX_TEST                          For 109
76413>>>>>>>>>>>>>>>>>Define CALLDRV_LOB_EX_SET_NULL                      For 110
76413>>>>>>>>>>>>>>>>>Define CALLDRV_GET_DATA_CHUNK_EX                    for 111
76413>>>>>>>>>>>>>>>>>Define CALLDRV_PARAM_RETURN_TYPE                    For 112
76413>>>>>>>>>>>>>>>>>Define CALLDRV_CONNECTION_STRING                    for 113
76413>>>>>>>>>>>>>>>>>Define CALLDRV_GET_SQL_CURSOR_TYPE                  for 114
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>// License and environment settings
76413>>>>>>>>>>>>>>>>>Define CALLDRV_DRIVER_REVISION                      For 0
76413>>>>>>>>>>>>>>>>>Define CALLDRV_COMPANY_NAME                         For 1
76413>>>>>>>>>>>>>>>>>Define CALLDRV_SERIAL_NUMBER                        For 2
76413>>>>>>>>>>>>>>>>>Define CALLDRV_LICENSED_USERS                       For 3
76413>>>>>>>>>>>>>>>>>Define CALLDRV_MAJOR_REVISION                       For 4
76413>>>>>>>>>>>>>>>>>Define CALLDRV_VERSION_COMMENTS                     For 5
76413>>>>>>>>>>>>>>>>>Define CALLDRV_OLEDB_OEM_TRANSLATION                For 6
76413>>>>>>>>>>>>>>>>>Define CALLDRV_SET_DB_PORT                          For 7
76413>>>>>>>>>>>>>>>>>Define CALLDRV_GET_DB_PORT                          For 8
76413>>>>>>>>>>>>>>>>>Define CALLDRV_SET_DB_SOCKET                        For 9
76413>>>>>>>>>>>>>>>>>Define CALLDRV_GET_DB_SOCKET                        For 10
76413>>>>>>>>>>>>>>>>>Define CALLDRV_SET_AS_SYSDBA                        For 11
76413>>>>>>>>>>>>>>>>>Define CALLDRV_OEM_TRANSLATION_STATE                For 12
76413>>>>>>>>>>>>>>>>>Define CALLDRV_TIME_TO_LIC_EXPIRATION               For 13
76413>>>>>>>>>>>>>>>>>Define CALLDRV_LICENSE_EXPIRATION_WARN              For 14
76413>>>>>>>>>>>>>>>>>Define CALLDRV_LICENSE_PATH                         For 15
76413>>>>>>>>>>>>>>>>>Define CALLDRV_AUTO_NUMERIC_REMAPPING               For 16
76413>>>>>>>>>>>>>>>>>Define CALLDRV_FORCE_DATE_FORMAT_INIT               For 17
76413>>>>>>>>>>>>>>>>>Define CALLDRV_STATIC_TABLE_OPT                     For 18
76413>>>>>>>>>>>>>>>>>Define CALLDRV_MAX_OBJECT_NAME_LENGTH               For 19
76413>>>>>>>>>>>>>>>>>Define CALLDRV_USE_LAZY_OPEN_MODE                   For 20
76413>>>>>>>>>>>>>>>>>Define CALLDRV_SET_CUSTOM_OEM_TO_ANSI               For 21
76413>>>>>>>>>>>>>>>>>Define CALLDRV_GET_CUSTOM_OEM_TO_ANSI               For 22
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//CALLDRV_ENUMERATE_SERVER_OPTION
76413>>>>>>>>>>>>>>>>>Define CALLDRV_ENUMERATE_SERVER_COUNT               For 0
76413>>>>>>>>>>>>>>>>>Define CALLDRV_ENUMERATE_SERVER_SERVER              For 1
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//CALLDRV_DEFAULT_FILE_CASING
76413>>>>>>>>>>>>>>>>>Define FILE_CASING_UPPER                            For 0
76413>>>>>>>>>>>>>>>>>Define FILE_CASING_LOWER                            For 1
76413>>>>>>>>>>>>>>>>>Define FILE_CASING_KEEP                             For 2
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>// CALLDRV_GLOBAL_SETTING
76413>>>>>>>>>>>>>>>>>Define GLOBAL_SETTING_TABLESPACE_SET                For 0
76413>>>>>>>>>>>>>>>>>Define GLOBAL_SETTING_TABLESPACE_GET                For 1
76413>>>>>>>>>>>>>>>>>Define GLOBAL_SETTING_INDEX_TABLESPACE_SET          For 2
76413>>>>>>>>>>>>>>>>>Define GLOBAL_SETTING_INDEX_TABLESPACE_GET          For 3
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>// CALLDRV_RESTRUCTURE_SCRIPT
76413>>>>>>>>>>>>>>>>>Define CALLDRV_RESTRUCTURE_SCRIPT_ENABLE            For 0
76413>>>>>>>>>>>>>>>>>Define CALLDRV_RESTRUCTURE_SCRIPT_DISABLE           For 1
76413>>>>>>>>>>>>>>>>>Define CALLDRV_RESTRUCTURE_SCRIPT_GET_CHUNK_SQL     For 2
76413>>>>>>>>>>>>>>>>>Define CALLDRV_RESTRUCTURE_SCRIPT_GET_CHUNK_INT     For 3
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>// DF_SQL_RELATION_STATUS attributes
76413>>>>>>>>>>>>>>>>>Define FOREIGN_KEY_NONE                             For -1
76413>>>>>>>>>>>>>>>>>Define FOREIGN_KEY_CREATE                           For  0
76413>>>>>>>>>>>>>>>>>Define FOREIGN_KEY_ENABLE                           For  1
76413>>>>>>>>>>>>>>>>>Define FOREIGN_KEY_DISABLE                          For  2
76413>>>>>>>>>>>>>>>>>Define FOREIGN_KEY_DROP                             For  3
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>// DF_SQL_RELATION_DELETE_REF_ACTION attributes
76413>>>>>>>>>>>>>>>>>Define DELETE_REF_NONE                              For 0
76413>>>>>>>>>>>>>>>>>Define DELETE_REF_CASCADE                           For 1
76413>>>>>>>>>>>>>>>>>Define DELETE_REF_SET_NULL                          For 2
76413>>>>>>>>>>>>>>>>>Define DELETE_REF_SET_DEFAULT                       For 3
76413>>>>>>>>>>>>>>>>>Define DELETE_REF_RESTRICT                          For 4
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//Embedded SQL Cursor Types
76413>>>>>>>>>>>>>>>>>Define CALLDRV_ENUMERATE_CURSOR_TYPE_NONE           For 0
76413>>>>>>>>>>>>>>>>>Define CALLDRV_ENUMERATE_CURSOR_TYPE_CLIENT         For 1
76413>>>>>>>>>>>>>>>>>Define CALLDRV_ENUMERATE_CURSOR_TYPE_SERVER         For 2
76413>>>>>>>>>>>>>>>>>Define CALLDRV_ENUMERATE_CURSOR_TYPE_PARAMETERIZED  For 3
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//Driver Call Direction
76413>>>>>>>>>>>>>>>>>Define CALLDRV_VALUE_GET                            For 0
76413>>>>>>>>>>>>>>>>>Define CALLDRV_VALUE_SET                            For 1
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//Inverse Key types
76413>>>>>>>>>>>>>>>>>Define REGULAR_SEG                                  For -1
76413>>>>>>>>>>>>>>>>>Define INVK_CASE_SEG                                For 0
76413>>>>>>>>>>>>>>>>>Define INVK_DESC_SEG                                For 1
76413>>>>>>>>>>>>>>>>>Define INVK_DESC_AND_CASE_SEG                       For 2
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//DB2 Index Types
76413>>>>>>>>>>>>>>>>>Define REG_INDEX                                    For 0
76413>>>>>>>>>>>>>>>>>Define REV_INDEX                                    For 1
76413>>>>>>>>>>>>>>>>>Define CLUST_INDEX                                  For 2
76413>>>>>>>>>>>>>>>>>Define REV_CLUST_INDEX                              For 3
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//Oracle Procedure Arguments type
76413>>>>>>>>>>>>>>>>>Define IS_NONE                                      For 0
76413>>>>>>>>>>>>>>>>>Define IS_IN                                        For 1
76413>>>>>>>>>>>>>>>>>Define IS_OUT                                       For 2
76413>>>>>>>>>>>>>>>>>Define IS_IN_OUT                                    For 3
76413>>>>>>>>>>>>>>>>>Define IS_RSET                                      For 4
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>// SQL_GET_COL Attributes
76413>>>>>>>>>>>>>>>>>Define SQL_GET_COL_ATTRIB_SIZE                      For 1
76413>>>>>>>>>>>>>>>>>Define SQL_GET_COL_ATTRIB_DECIMALS                  For 2
76413>>>>>>>>>>>>>>>>>Define SQL_GET_COL_ATTRIB_LABEL                     For 3
76413>>>>>>>>>>>>>>>>>Define SQL_GET_COL_ATTRIB_COLUMN_NAME               For 4
76413>>>>>>>>>>>>>>>>>Define SQL_GET_COL_ATTRIB_TABLE_NAME                For 5
76413>>>>>>>>>>>>>>>>>Define SQL_GET_COL_ATTRIB_SQLTYPE                   For 6
76413>>>>>>>>>>>>>>>>>Define SQL_GET_COL_ATTRIB_NULLABLE                  For 7
76413>>>>>>>>>>>>>>>>>Define SQL_GET_COL_ATTRIB_DFTYPE                    For 8
76413>>>>>>>>>>>>>>>>>Define SQL_GET_COL_ATTRIB_DATA_LENGTH               For 9
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>// MySQL Data Types
76413>>>>>>>>>>>>>>>>>Define eMySQL_DECIMAL                               For 0
76413>>>>>>>>>>>>>>>>>Define eMySQL_TINY                                  For 1
76413>>>>>>>>>>>>>>>>>Define eMySQL_SHORT                                 For 2
76413>>>>>>>>>>>>>>>>>Define eMySQL_LONG                                  For 3
76413>>>>>>>>>>>>>>>>>Define eMySQL_FLOAT                                 For 4
76413>>>>>>>>>>>>>>>>>Define eMySQL_DOUBLE                                For 5
76413>>>>>>>>>>>>>>>>>Define eMySQL_NULL                                  For 6
76413>>>>>>>>>>>>>>>>>Define eMySQL_TIMESTAMP                             For 7
76413>>>>>>>>>>>>>>>>>Define eMySQL_LONGLONG                              For 8
76413>>>>>>>>>>>>>>>>>Define eMySQL_INT24                                 For 9
76413>>>>>>>>>>>>>>>>>Define eMySQL_DATE                                  For 10
76413>>>>>>>>>>>>>>>>>Define eMySQL_TIME                                  For 11
76413>>>>>>>>>>>>>>>>>Define eMySQL_DATETIME                              For 12
76413>>>>>>>>>>>>>>>>>Define eMySQL_YEAR                                  For 13
76413>>>>>>>>>>>>>>>>>Define eMySQL_NEWDATE                               For 14
76413>>>>>>>>>>>>>>>>>Define eMySQL_BIT                                   For 16
76413>>>>>>>>>>>>>>>>>Define eMySQL_NEWDECIMAL                            For 246
76413>>>>>>>>>>>>>>>>>Define eMySQL_ENUM                                  For 247
76413>>>>>>>>>>>>>>>>>Define eMySQL_SET                                   For 248
76413>>>>>>>>>>>>>>>>>Define eMySQL_TINY_BLOB                             For 249
76413>>>>>>>>>>>>>>>>>Define eMySQL_MEDIUM_BLOB                           For 250
76413>>>>>>>>>>>>>>>>>Define eMySQL_LONG_BLOB                             For 251
76413>>>>>>>>>>>>>>>>>Define eMySQL_BLOB                                  For 252
76413>>>>>>>>>>>>>>>>>Define eMySQL_VAR_STRING                            For 253
76413>>>>>>>>>>>>>>>>>Define eMySQL_STRING                                For 254
76413>>>>>>>>>>>>>>>>>Define eMySQL_TINY_TEXT                             For -249
76413>>>>>>>>>>>>>>>>>Define eMySQL_MEDIUM_TEXT                           For -250
76413>>>>>>>>>>>>>>>>>Define eMySQL_LONG_TEXT                             For -251
76413>>>>>>>>>>>>>>>>>Define eMySQL_TEXT                                  For -252
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>// Oracle Data Types
76413>>>>>>>>>>>>>>>>>Define eOracle_VARCHAR2                             For   1
76413>>>>>>>>>>>>>>>>>Define eOracle_NUMBER                               For   2
76413>>>>>>>>>>>>>>>>>Define eOracle_INT                                  For   3
76413>>>>>>>>>>>>>>>>>Define eOracle_FLOAT                                For   4
76413>>>>>>>>>>>>>>>>>Define eOracle_STRING                               For   5
76413>>>>>>>>>>>>>>>>>Define eOracle_LONG                                 For   8
76413>>>>>>>>>>>>>>>>>Define eOracle_ROWID                                For  11
76413>>>>>>>>>>>>>>>>>Define eOracle_DATE                                 For  12
76413>>>>>>>>>>>>>>>>>Define eOracle_RAW                                  For  23
76413>>>>>>>>>>>>>>>>>Define eOracle_LONGRAW                              For  24
76413>>>>>>>>>>>>>>>>>Define eOracle_CHAR                                 For  96
76413>>>>>>>>>>>>>>>>>Define eOracle_MSLABEL                              For 106
76413>>>>>>>>>>>>>>>>>Define eOracle_CLOB                                 For 112
76413>>>>>>>>>>>>>>>>>Define eOracle_BLOB                                 For 113
76413>>>>>>>>>>>>>>>>>Define eOracle_TIMESTAMP                            For 187
76413>>>>>>>>>>>>>>>>>Define eOracle_TIMESTAMPTZ                          For 188
76413>>>>>>>>>>>>>>>>>Define eOracle_INTERVALYM                           For 189
76413>>>>>>>>>>>>>>>>>Define eOracle_INTERVALDS                           For 190
76413>>>>>>>>>>>>>>>>>Define eOracle_TIMESTAMPLTZ                         For 232
76413>>>>>>>>>>>>>>>>>Define eOracle_NCHAR                                For 286
76413>>>>>>>>>>>>>>>>>Define eOracle_NVARCHAR2                            For 287
76413>>>>>>>>>>>>>>>>>Define eOracle_NCLOB                                For 288
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>// PostgreSQL Data Types
76413>>>>>>>>>>>>>>>>>Define ePgSQL_CIRCLE                                For  718
76413>>>>>>>>>>>>>>>>>Define ePgSQL_MONEY                                 For  790
76413>>>>>>>>>>>>>>>>>Define ePgSQL_BOOL                                  For   16
76413>>>>>>>>>>>>>>>>>Define ePgSQL_BYTEA                                 For   17
76413>>>>>>>>>>>>>>>>>Define ePgSQL_CHAR                                  For   18
76413>>>>>>>>>>>>>>>>>Define ePgSQL_INT2                                  For   21
76413>>>>>>>>>>>>>>>>>Define ePgSQL_INT4                                  For   23
76413>>>>>>>>>>>>>>>>>Define ePgSQL_REGPROC                               For   24
76413>>>>>>>>>>>>>>>>>Define ePgSQL_REGPROCEDURE                          For 2202
76413>>>>>>>>>>>>>>>>>Define ePgSQL_REGOPER                               For 2203
76413>>>>>>>>>>>>>>>>>Define ePgSQL_REGOPERATOR                           For 2204
76413>>>>>>>>>>>>>>>>>Define ePgSQL_REGCLASS                              For 2205
76413>>>>>>>>>>>>>>>>>Define ePgSQL_REGTYPE                               For 2206
76413>>>>>>>>>>>>>>>>>Define ePgSQL_TEXT                                  For   25
76413>>>>>>>>>>>>>>>>>Define ePgSQL_CITEXT                                For  -25
76413>>>>>>>>>>>>>>>>>Define ePgSQL_OID                                   For   26
76413>>>>>>>>>>>>>>>>>Define ePgSQL_TID                                   For   27
76413>>>>>>>>>>>>>>>>>Define ePgSQL_XID                                   For   28
76413>>>>>>>>>>>>>>>>>Define ePgSQL_CID                                   For   29
76413>>>>>>>>>>>>>>>>>Define ePgSQL_XML                                   For  142
76413>>>>>>>>>>>>>>>>>Define ePgSQL_BPCHAR                                For 1042
76413>>>>>>>>>>>>>>>>>Define ePgSQL_VARCHAR                               For 1043
76413>>>>>>>>>>>>>>>>>Define ePgSQL_INT8                                  For   20
76413>>>>>>>>>>>>>>>>>Define ePgSQL_PATH                                  For  602
76413>>>>>>>>>>>>>>>>>Define ePgSQL_FLOAT4                                For  700
76413>>>>>>>>>>>>>>>>>Define ePgSQL_FLOAT8                                For  701
76413>>>>>>>>>>>>>>>>>Define ePgSQL_ABSTIME                               For  702
76413>>>>>>>>>>>>>>>>>Define ePgSQL_RELTIME                               For  703
76413>>>>>>>>>>>>>>>>>Define ePgSQL_TINTERVAL                             For  704
76413>>>>>>>>>>>>>>>>>Define ePgSQL_POINT                                 For  600
76413>>>>>>>>>>>>>>>>>Define ePgSQL_LINE                                  For  628
76413>>>>>>>>>>>>>>>>>Define ePgSQL_LSEG                                  For  601
76413>>>>>>>>>>>>>>>>>Define ePgSQL_BOX                                   For  603
76413>>>>>>>>>>>>>>>>>Define ePgSQL_POLYGON                               For  604
76413>>>>>>>>>>>>>>>>>Define ePgSQL_ACLITEM                               For 1033
76413>>>>>>>>>>>>>>>>>Define ePgSQL_MACADDR                               For  829
76413>>>>>>>>>>>>>>>>>Define ePgSQL_INET                                  For  869
76413>>>>>>>>>>>>>>>>>Define ePgSQL_CIDR                                  For  650
76413>>>>>>>>>>>>>>>>>Define ePgSQL_TIMESTAMP                             For 1114
76413>>>>>>>>>>>>>>>>>Define ePgSQL_DATE                                  For 1082
76413>>>>>>>>>>>>>>>>>Define ePgSQL_TIME                                  For 1083
76413>>>>>>>>>>>>>>>>>Define ePgSQL_TIMESTAMPTZ                           For 1184
76413>>>>>>>>>>>>>>>>>Define ePgSQL_INTERVAL                              For 1186
76413>>>>>>>>>>>>>>>>>Define ePgSQL_NUMERIC                               For 1700
76413>>>>>>>>>>>>>>>>>Define ePgSQL_TIMETZ                                For 1266
76413>>>>>>>>>>>>>>>>>Define ePgSQL_BIT                                   For 1560
76413>>>>>>>>>>>>>>>>>Define ePgSQL_VARBIT                                For 1562
76413>>>>>>>>>>>>>>>>>Define ePgSQL_UUID                                  For 2950
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>// SQL Server Data Types
76413>>>>>>>>>>>>>>>>>Define eSQLServer_NA                                For    0
76413>>>>>>>>>>>>>>>>>Define eSQLServer_CHAR                              For    1
76413>>>>>>>>>>>>>>>>>Define eSQLServer_NUMERIC                           For    2
76413>>>>>>>>>>>>>>>>>Define eSQLServer_DECIMAL                           For    3
76413>>>>>>>>>>>>>>>>>Define eSQLServer_INT                               For    4
76413>>>>>>>>>>>>>>>>>Define eSQLServer_SMALLINT                          For    5
76413>>>>>>>>>>>>>>>>>Define eSQLServer_FLOAT                             For    6
76413>>>>>>>>>>>>>>>>>Define eSQLServer_REAL                              For    7
76413>>>>>>>>>>>>>>>>>Define eSQLServer_DOUBLE                            For    8
76413>>>>>>>>>>>>>>>>>Define eSQLServer_DATETIME                          For   11
76413>>>>>>>>>>>>>>>>>Define eSQLServer_VARCHAR                           For   12
76413>>>>>>>>>>>>>>>>>Define eSQLServer_DATE                              For   40
76413>>>>>>>>>>>>>>>>>Define eSQLServer_TIME                              For   41
76413>>>>>>>>>>>>>>>>>Define eSQLServer_DATETIME2                         For   42
76413>>>>>>>>>>>>>>>>>Define eSQLServer_DATETIMEOFFSET                    For   43
76413>>>>>>>>>>>>>>>>>Define eSQLServer_SMALLDATETIME                     For   58
76413>>>>>>>>>>>>>>>>>Define eSQLServer_TIMESTAMP                         For   93
76413>>>>>>>>>>>>>>>>>Define eSQLServer_HIERARCHYID                       For  128
76413>>>>>>>>>>>>>>>>>Define eSQLServer_GEOMETRY                          For  129
76413>>>>>>>>>>>>>>>>>Define eSQLServer_GEOGRAPHY                         For  130
76413>>>>>>>>>>>>>>>>>Define eSQLServer_TEXT                              For   -1
76413>>>>>>>>>>>>>>>>>Define eSQLServer_BINARY                            For   -2
76413>>>>>>>>>>>>>>>>>Define eSQLServer_VARBINARY                         For   -3
76413>>>>>>>>>>>>>>>>>Define eSQLServer_IMAGE                             For   -4
76413>>>>>>>>>>>>>>>>>Define eSQLServer_BIGINT                            For   -5
76413>>>>>>>>>>>>>>>>>Define eSQLServer_TINYINT                           For   -6
76413>>>>>>>>>>>>>>>>>Define eSQLServer_BIT                               For   -7
76413>>>>>>>>>>>>>>>>>Define eSQLServer_NCHAR                             For   -8
76413>>>>>>>>>>>>>>>>>Define eSQLServer_NVARCHAR                          For   -9
76413>>>>>>>>>>>>>>>>>Define eSQLServer_NTEXT                             For  -10
76413>>>>>>>>>>>>>>>>>Define eSQLServer_GUID                              For  -11
76413>>>>>>>>>>>>>>>>>Define eSQLServer_VARBINARYMAX                      For  -98
76413>>>>>>>>>>>>>>>>>Define eSQLServer_VARCHARMAX                        For  -99
76413>>>>>>>>>>>>>>>>>Define eSQLServer_NVARCHARMAX                       For -100
76413>>>>>>>>>>>>>>>>>Define eSQLServer_SQLVARIANT                        For -150
76413>>>>>>>>>>>>>>>>>Define eSQLServer_XML                               For -370
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//=============================================================================
76413>>>>>>>>>>>>>>>>>//Error Text
76413>>>>>>>>>>>>>>>>>//==========
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//=============================================================================
76413>>>>>>>>>>>>>>>>>//Define Self if needed
76413>>>>>>>>>>>>>>>>>//=====================
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>//=============================================================================
76413>>>>>>>>>>>>>>>>>//Define varibles we need
76413>>>>>>>>>>>>>>>>>//=======================
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>    Define MertechInc_Variables_Defined
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>    Indicator MertechInc_bThereIsBinding
76413>>>>>>>>>>>>>>>>>
76413>>>>>>>>>>>>>>>>>    Integer MertechInc_FileNumber      //Replaces _SAVEFILENUMBER# and FILENUMBER
76413>>>>>>>>>>>>>>>>>    Integer MertechInc_iArg            //Replaces _LLONG#
76413>>>>>>>>>>>>>>>>>    Integer MertechInc_iCallBack       //Replaces _CALLBACK#
76413>>>>>>>>>>>>>>>>>    Integer MertechInc_iCount          //General loop limit integer
76413>>>>>>>>>>>>>>>>>    Integer MertechInc_iDecSep         //Holds the decimal seperator
76413>>>>>>>>>>>>>>>>>    Integer MertechInc_iFunction       //Replaces _FID#    ??? check is this is need when tidy is complete
76413>>>>>>>>>>>>>>>>>    Integer MertechInc_iLoop           //General loop integer
76413>>>>>>>>>>>>>>>>>    Integer Mertech_iMySQLParam        //Replaces _ALL_PAR_POS#
76413>>>>>>>>>>>>>>>>>    Integer MertechInc_iParamCount     //Replaces _NPAR#
76413>>>>>>>>>>>>>>>>>    Integer MertechInc_iRet            //Replaces _RET#
76413>>>>>>>>>>>>>>>>>    Integer MertechInc_iSaveCount      //Replaces _NPOS#
76413>>>>>>>>>>>>>>>>>    Integer MertechInc_iWork           //General work integer
76413>>>>>>>>>>>>>>>>>    Integer MertechInc_iWork2
76413>>>>>>>>>>>>>>>>>    Integer MertechInc_iWork3
76413>>>>>>>>>>>>>>>>>    Integer MertechInc_SizeCheckDone
76413>>>>>>>>>>>>>>>>>    Integer MertechInc_LastCursorNum
76413>>>>>>>>>>>>>>>>>    Move -2 to MertechInc_LastCursorNum // -1 means default cursor, so we're using -2 no cursor yet
76414>>>>>>>>>>>>>>>>>    Integer MertechInc_DefaultCursorType
76414>>>>>>>>>>>>>>>>>
76414>>>>>>>>>>>>>>>>>    Move CALLDRV_ENUMERATE_CURSOR_TYPE_NONE to MertechInc_DefaultCursorType
76415>>>>>>>>>>>>>>>>>
76415>>>>>>>>>>>>>>>>>    String MertechInc_Blank            //Replaces _BLANK#
76415>>>>>>>>>>>>>>>>>    String MertechInc_DriverName       //Replaces _DRIVERNAME#
76415>>>>>>>>>>>>>>>>>    String MertechInc_sArg1 255        //Replaces _ARG1#
76415>>>>>>>>>>>>>>>>>    String MertechInc_sArg2 255        //Replaces _ARG2#
76415>>>>>>>>>>>>>>>>>    String MertechInc_sWork 255        //General work string
76415>>>>>>>>>>>>>>>>>
76415>>>>>>>>>>>>>>>>>    String MertechInc_CurrentDriver    //Keep the current driver name
76415>>>>>>>>>>>>>>>>>    //Global string are created pre-filled with spaces. We need an empty string
76415>>>>>>>>>>>>>>>>>    Move "" to MertechInc_Blank
76416>>>>>>>>>>>>>>>>>    Move "" to MertechInc_CurrentDriver
76417>>>>>>>>>>>>>>>>>
76417>>>>>>>>>>>>>>>>>
76417>>>>>>>>>>>>>>>>>//=============================================================================
76417>>>>>>>>>>>>>>>>>//Use Obsolete Code
76417>>>>>>>>>>>>>>>>>//=================
76417>>>>>>>>>>>>>>>>>
76417>>>>>>>>>>>>>>>>>
76417>>>>>>>>>>>>>>>>>
76417>>>>>>>>>>>>>>>>>//=============================================================================
76417>>>>>>>>>>>>>>>>>//Comment Block Template
76417>>>>>>>>>>>>>>>>>//======================
76417>>>>>>>>>>>>>>>>>
76417>>>>>>>>>>>>>>>>>/// @Name {Name of the command for indexing} (used for documentation)
76417>>>>>>>>>>>>>>>>>/// @Description {Short Command Description} (used for documentation)
76417>>>>>>>>>>>>>>>>>///     The description can be multiple lines, and contain HTML tags.
76417>>>>>>>>>>>>>>>>>///     The other tokens will have HTML encoded so we can show stuff
76417>>>>>>>>>>>>>>>>>///     like <param1> properly. A blank line will automatically be
76417>>>>>>>>>>>>>>>>>///         translated into a paragraph break in the documentation, so
76417>>>>>>>>>>>>>>>>>///     no need for <br> or <p> tags.
76417>>>>>>>>>>>>>>>>>///
76417>>>>>>>>>>>>>>>>>/// @Assumptions {Assumptions made in order for the command to work}
76417>>>>>>>>>>>>>>>>>/// @Status {Obsolete, Internal, or Public} (used for documentation)
76417>>>>>>>>>>>>>>>>>/// @Drivers {DB2Flex, MySQLFlex, ORAFlex, PgFlex, SQLFlex or All} (used for documentation)
76417>>>>>>>>>>>>>>>>>/// @VersionNote {Date and author of the last revision}
76417>>>>>>>>>>>>>>>>>/// @See {list of related commands}
76417>>>>>>>>>>>>>>>>>///
76417>>>>>>>>>>>>>>>>>/// @Syntax {Syntax of use} (used for documentation)
76417>>>>>>>>>>>>>>>>>/// @Param {Each parameter with a brief description} (used for documentation)
76417>>>>>>>>>>>>>>>>>/// @DBMS {List of supported databases}
76417>>>>>>>>>>>>>>>>>/// @DataFlex {List of supported DataFlex versions}
76417>>>>>>>>>>>>>>>>>/// @Usage {Different uses command can have multiple syntaxes} (used for documentation)
76417>>>>>>>>>>>>>>>>>///
76417>>>>>>>>>>>>>>>>>/// @Example {An example of the command being used} (used for documentation)
76417>>>>>>>>>>>>>>>>>
76417>>>>>>>>>>>>>>>>>//=============================================================================
76417>>>>>>>>>>>>>>>>>/// @Name        DO_GETFILENUMBER_DRIVERNAME
76417>>>>>>>>>>>>>>>>>/// @Description Retrieves the current driver name and or the file number
76417>>>>>>>>>>>>>>>>>/// that will be used by the macro commands.
76417>>>>>>>>>>>>>>>>>///
76417>>>>>>>>>>>>>>>>>/// @Assumptions
76417>>>>>>>>>>>>>>>>>/// @Status      Internal Use Only
76417>>>>>>>>>>>>>>>>>/// @Drivers     All
76417>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-07-14 By Ian Smith
76417>>>>>>>>>>>>>>>>>/// @See
76417>>>>>>>>>>>>>>>>>//Most commands Use DO_GETFILENUMBER_DRIVERNAME so this code was being duplicated
76417>>>>>>>>>>>>>>>>>//all the Time. It has been moved to this method to remove that duplication.
76417>>>>>>>>>>>>>>>>>Procedure MertechInc_Get_Driver_name Global
76419>>>>>>>>>>>>>>>>>    //If we have a file number get its driver, else find first loaded Mertech driver
76419>>>>>>>>>>>>>>>>>    If MertechInc_FileNumber GT 0 ;        Get_Attribute DF_FILE_DRIVER of MertechInc_FileNumber to MertechInc_DriverName
76424>>>>>>>>>>>>>>>>>    Else Begin
76425>>>>>>>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to MertechInc_iCount
76428>>>>>>>>>>>>>>>>>        For MertechInc_iLoop from 1 to MertechInc_iCount
76434>>>>>>>>>>>>>>>>>>
76434>>>>>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of MertechInc_iLoop to MertechInc_DriverName
76437>>>>>>>>>>>>>>>>>            Move (UPPERCASE(MertechInc_DriverName)) to MertechInc_DriverName
76438>>>>>>>>>>>>>>>>>            If (MertechInc_DriverName EQ ORAFLEX  or MertechInc_DriverName EQ SQLFLEX or MertechInc_DriverName EQ MDSDB2 or ;                MertechInc_DriverName EQ MDSPgSQL or MertechInc_DriverName EQ MDSMySQL) Move MertechInc_iCount to MertechInc_iLoop
76441>>>>>>>>>>>>>>>>>            Else Move "" to MertechInc_DriverName
76443>>>>>>>>>>>>>>>>>        Loop
76444>>>>>>>>>>>>>>>>>>
76444>>>>>>>>>>>>>>>>>    End
76444>>>>>>>>>>>>>>>>>>
76444>>>>>>>>>>>>>>>>>
76444>>>>>>>>>>>>>>>>>    //Ensure that we return a valid Mertech driver.
76444>>>>>>>>>>>>>>>>>    If (MertechInc_DriverName NE ORAFLEX  and MertechInc_DriverName NE SQLFLEX  and ;        MertechInc_DriverName NE MDSPgSQL and MertechInc_DriverName NE MDSMySQL) Begin
76446>>>>>>>>>>>>>>>>>
76446>>>>>>>>>>>>>>>>>        //Report invalid driver
76446>>>>>>>>>>>>>>>>>        Error 25100 ("Mertech.inc - Not a Mertech driver. File" * String(MertechInc_FileNumber) * "Driver" * Trim(MertechInc_DriverName) )
76447>>>>>>>>>>>>>>>>>>
76447>>>>>>>>>>>>>>>>>
76447>>>>>>>>>>>>>>>>>        //Set MertechInc_FileNumber to MertechInc_Invalid_Driver so that the commands can
76447>>>>>>>>>>>>>>>>>        //determine if the driver is valid. MertechInc_FileNumber is use instead of
76447>>>>>>>>>>>>>>>>>        //MertechInc_DriverName as integer conparisons are quicker than string conparisons
76447>>>>>>>>>>>>>>>>>        Move MertechInc_Invalid_Driver to MertechInc_FileNumber
76448>>>>>>>>>>>>>>>>>    End
76448>>>>>>>>>>>>>>>>>>
76448>>>>>>>>>>>>>>>>>End_Procedure
76449>>>>>>>>>>>>>>>>>
76449>>>>>>>>>>>>>>>>>
76449>>>>>>>>>>>>>>>>>//=============================================================================
76449>>>>>>>>>>>>>>>>>/// @Name        MertechInc_Pre_Size_String
76449>>>>>>>>>>>>>>>>>/// @Description Returns a string full of spaces.
76449>>>>>>>>>>>>>>>>>///
76449>>>>>>>>>>>>>>>>>/// @Assumptions
76449>>>>>>>>>>>>>>>>>/// @Status      Internal
76449>>>>>>>>>>>>>>>>>/// @Drivers     n/a
76449>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-12-02 By Gandalf Hernandez
76449>>>>>>>>>>>>>>>>>/// @See
76449>>>>>>>>>>>>>>>>>Function MertechInc_Pre_Size_String Global Integer iSize Returns String
76451>>>>>>>>>>>>>>>>>   String sWork
76451>>>>>>>>>>>>>>>>>   Integer iBlocks iRemainder
76451>>>>>>>>>>>>>>>>>
76451>>>>>>>>>>>>>>>>>   If (iSize <= 1) Begin
76453>>>>>>>>>>>>>>>>>      // marcelo 06/28/2000 implemented logic to avoid VDF 7 crashing problems
76453>>>>>>>>>>>>>>>>>          If FMAC_VERSION eq 7 Move 1000 to iSize
76456>>>>>>>>>>>>>>>>>          Else Move 16384 to iSize
76458>>>>>>>>>>>>>>>>>   End
76458>>>>>>>>>>>>>>>>>>
76458>>>>>>>>>>>>>>>>>
76458>>>>>>>>>>>>>>>>>   // Build the string in blocks of 32, to speed things up
76458>>>>>>>>>>>>>>>>>   // If the string is less than 32 bytes, just fill it up regularly
76458>>>>>>>>>>>>>>>>>   Move (iSize / 32) to iBlocks
76459>>>>>>>>>>>>>>>>>   Move (Mod(iSize, 32)) to iRemainder
76460>>>>>>>>>>>>>>>>>
76460>>>>>>>>>>>>>>>>>   If (iBlocks > 0) Begin
76462>>>>>>>>>>>>>>>>>      Move (Repeat("                                ", iBlocks)) to sWork
76463>>>>>>>>>>>>>>>>>      Move (Append (sWork, (Repeat(" ", iRemainder)))) to sWork
76464>>>>>>>>>>>>>>>>>   End
76464>>>>>>>>>>>>>>>>>>
76464>>>>>>>>>>>>>>>>>   Else Move (Repeat(" ", iSize)) to sWork
76466>>>>>>>>>>>>>>>>>
76466>>>>>>>>>>>>>>>>>   Function_Return sWork
76467>>>>>>>>>>>>>>>>>End_Function
76468>>>>>>>>>>>>>>>>>
76468>>>>>>>>>>>>>>>>>//=============================================================================
76468>>>>>>>>>>>>>>>>>/// @Name        MertechInc_Set_DecSep
76468>>>>>>>>>>>>>>>>>/// @Description Saves the current decimal separator and sets the decimal
76468>>>>>>>>>>>>>>>>>/// separator to '.'.
76468>>>>>>>>>>>>>>>>>///
76468>>>>>>>>>>>>>>>>>/// @Assumptions
76468>>>>>>>>>>>>>>>>>/// @Status      Internal
76468>>>>>>>>>>>>>>>>>/// @Drivers     n/a
76468>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-17 By Ian Smith
76468>>>>>>>>>>>>>>>>>Procedure MertechInc_Set_DecSep Global
76470>>>>>>>>>>>>>>>>>    Get_Attribute DF_DECIMAL_SEPARATOR to MertechInc_iDecSep
76473>>>>>>>>>>>>>>>>>    If MertechInc_iDecSep Ne 46 Set_Attribute DF_DECIMAL_SEPARATOR to 46 // (.) WILL BE DECIMAL SEPARATOR
76478>>>>>>>>>>>>>>>>>End_Procedure
76479>>>>>>>>>>>>>>>>>
76479>>>>>>>>>>>>>>>>>//=============================================================================
76479>>>>>>>>>>>>>>>>>/// @Name        MertechInc_Reset_DecSep
76479>>>>>>>>>>>>>>>>>/// @Description Sets the decimal separator to the saved value.
76479>>>>>>>>>>>>>>>>>///
76479>>>>>>>>>>>>>>>>>/// @Status      Internal
76479>>>>>>>>>>>>>>>>>/// @Drivers     n/a
76479>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-17 By Ian Smith
76479>>>>>>>>>>>>>>>>>///
76479>>>>>>>>>>>>>>>>>Procedure MertechInc_Reset_DecSep Global
76481>>>>>>>>>>>>>>>>>    If MertechInc_iDecSep Ne 46 Set_Attribute DF_DECIMAL_SEPARATOR to MertechInc_iDecSep
76486>>>>>>>>>>>>>>>>>End_Procedure
76487>>>>>>>>>>>>>>>>>
76487>>>>>>>>>>>>>>>>>//=============================================================================
76487>>>>>>>>>>>>>>>>>/// @Name        FETCH_FIELD
76487>>>>>>>>>>>>>>>>>/// @Description Selects or de-selects the fields to be fetched during the
76487>>>>>>>>>>>>>>>>>/// next FIND (query).
76487>>>>>>>>>>>>>>>>>///
76487>>>>>>>>>>>>>>>>>/// @Status      Internal
76487>>>>>>>>>>>>>>>>>/// @Drivers     All
76487>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-07-16 By Ian Smith
76487>>>>>>>>>>>>>>>>>///
76487>>>>>>>>>>>>>>>>>/// @Syntax FETCH_FIELD <FileNum> <FieldStart> THRU <FieldEnd> TO DF_FETCH_TRUE
76487>>>>>>>>>>>>>>>>>/// @Param  FileNum    is the File Number
76487>>>>>>>>>>>>>>>>>/// @Param  FieldStart is the Field Name or Number that will start the selection range
76487>>>>>>>>>>>>>>>>>/// @Param  FieldEnd   is the Field Name or Number that will finish the selection range
76487>>>>>>>>>>>>>>>>>///
76487>>>>>>>>>>>>>>>>>/// @Syntax FETCH_FIELD <FileNum> <Field1> TO DF_FETCH_TRUE
76487>>>>>>>>>>>>>>>>>/// @Param  FileNum  is the File Number
76487>>>>>>>>>>>>>>>>>/// @Param  Field1 Fields Name or Number to be selected
76487>>>>>>>>>>>>>>>>>///
76487>>>>>>>>>>>>>>>>>
76487>>>>>>>>>>>>>>>>>//=============================================================================
76487>>>>>>>>>>>>>>>>>/// @Name        SQL_TEXT_MESSAGE
76487>>>>>>>>>>>>>>>>>/// @Description Use this command to manually insert a string into a trace
76487>>>>>>>>>>>>>>>>>/// file. This can be useful for readability within the trace file to log
76487>>>>>>>>>>>>>>>>>/// what is actually happening at certain points.
76487>>>>>>>>>>>>>>>>>///
76487>>>>>>>>>>>>>>>>>/// @Assumptions The text string is less than 80 characters long.
76487>>>>>>>>>>>>>>>>>/// @Status      Public
76487>>>>>>>>>>>>>>>>>/// @Drivers     All
76487>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 20013-08-19 by Aaron Gulack
76487>>>>>>>>>>>>>>>>>/// @See         ENABLE_TRACE_ON DISABLE_TRACE_ON
76487>>>>>>>>>>>>>>>>>///
76487>>>>>>>>>>>>>>>>>/// @Syntax SQL_TEXT_MESSAGE {variable}
76487>>>>>>>>>>>>>>>>>/// @Param  {variable}          The string to insert into the trace file.
76487>>>>>>>>>>>>>>>>>///
76487>>>>>>>>>>>>>>>>>/// @Example
76487>>>>>>>>>>>>>>>>>/// Login "localhost" "mds" "mertech" "ora_drv"
76487>>>>>>>>>>>>>>>>>///
76487>>>>>>>>>>>>>>>>>/// ENABLE_TRACE_ON to "c:\trace.txt" DEBUG_LEVEL
76487>>>>>>>>>>>>>>>>>/// open Customer
76487>>>>>>>>>>>>>>>>>/// SQL_TEXT_MESSAGE "The table has been opened"
76487>>>>>>>>>>>>>>>>>
76487>>>>>>>>>>>>>>>>>//=============================================================================
76487>>>>>>>>>>>>>>>>>/// @Name       SELECT_COLUMNS_FIND
76487>>>>>>>>>>>>>>>>>/// @Description This command is used to fetch only a certain number of fields
76487>>>>>>>>>>>>>>>>>/// while doing a "find". When specifying the field number to start from and
76487>>>>>>>>>>>>>>>>>/// field number to end on, the find will only fetch the given fields from the
76487>>>>>>>>>>>>>>>>>/// record. It is important to always use this command after first deselecting
76487>>>>>>>>>>>>>>>>>/// all columns i.e. setting RESET_FETCH_FIELDS to DF_FETCH_FALSE. Also, after
76487>>>>>>>>>>>>>>>>>/// using this command, all columns need to be reselected i.e. setting
76487>>>>>>>>>>>>>>>>>/// RESET_FETCH_FIELDS to DF_FETCH_TRUE. Note that fields used as a part the
76487>>>>>>>>>>>>>>>>>/// index segment associated with the find will always be fetched regardless.
76487>>>>>>>>>>>>>>>>>///
76487>>>>>>>>>>>>>>>>>/// @Assumptions
76487>>>>>>>>>>>>>>>>>/// @Status      Public
76487>>>>>>>>>>>>>>>>>/// @Drivers     All
76487>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 20014-04-30 by Marcello Yo
76487>>>>>>>>>>>>>>>>>/// @See         RESET_FETCH_FIELDS DISABLE_SELECT_COLUMNS_ERRORS
76487>>>>>>>>>>>>>>>>>///
76487>>>>>>>>>>>>>>>>>/// @Syntax SELECT_COLUMNS_FIND {FileNumber} {fieldStart} THRU {fieldEnd}
76487>>>>>>>>>>>>>>>>>/// @Param  FileNumber          The number of the file
76487>>>>>>>>>>>>>>>>>/// @Param  fieldStart          The field number to start the fetch from
76487>>>>>>>>>>>>>>>>>/// @Param  FieldEnd            The field number to end the fetch at
76487>>>>>>>>>>>>>>>>>///
76487>>>>>>>>>>>>>>>>>/// @Example
76487>>>>>>>>>>>>>>>>>/// Open Customer
76487>>>>>>>>>>>>>>>>>/// RESET_FETCH_FIELDS  CUSTOMER DF_FETCH_FALSE
76487>>>>>>>>>>>>>>>>>/// SELECT_COLUMNS_FIND CUSTOMER CUSTOMER_NUMBER NAME
76487>>>>>>>>>>>>>>>>>/// DISABLE_SELECT_COLUMNS_ERRORS DISABLED
76487>>>>>>>>>>>>>>>>>///
76487>>>>>>>>>>>>>>>>>/// Clear Customer
76487>>>>>>>>>>>>>>>>>/// Repeat
76487>>>>>>>>>>>>>>>>>///    Find Gt Customer by Index.1
76487>>>>>>>>>>>>>>>>>///    If (Found) Showln Customer.Customer_Number '-' Customer.Name
76487>>>>>>>>>>>>>>>>>/// Until (Not(Found))
76487>>>>>>>>>>>>>>>>>///
76487>>>>>>>>>>>>>>>>>/// RESET_FETCH_FIELDS Customer DF_FETCH_TRUE
76487>>>>>>>>>>>>>>>>>
76487>>>>>>>>>>>>>>>>>
76487>>>>>>>>>>>>>>>>>//=============================================================================
76487>>>>>>>>>>>>>>>>>/// @Name        RESET_FETCH_FIELDS
76487>>>>>>>>>>>>>>>>>/// @Description This command is used to specify whether to retrieve all columns
76487>>>>>>>>>>>>>>>>>/// or no columns when performing a find. It is usually used with the command
76487>>>>>>>>>>>>>>>>>/// SELECT_COLUMNS_FIND to reset the column fetching. This command can either be
76487>>>>>>>>>>>>>>>>>/// set to DF_FETCH_TRUE, which will fetch all columns or set to DF_FETCH_FALSE,
76487>>>>>>>>>>>>>>>>>/// which will fetch no columns.
76487>>>>>>>>>>>>>>>>>/// @Assumptions
76487>>>>>>>>>>>>>>>>>/// @Status      Public
76487>>>>>>>>>>>>>>>>>/// @Drivers     All
76487>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2014-04-30 by Marcello Yo
76487>>>>>>>>>>>>>>>>>/// @See         SELECT_COLUMNS_FIND DISABLE_SELECT_COLUMNS_ERRORS
76487>>>>>>>>>>>>>>>>>///
76487>>>>>>>>>>>>>>>>>/// @Syntax RESET_FETCH_FIELDS {FileNumber} {DF_FETCH_TRUE/DF_FETCH_FALSE}
76487>>>>>>>>>>>>>>>>>/// @Param  FileNumber                  The number of the file
76487>>>>>>>>>>>>>>>>>/// @Param  DF_FETCH_TRUE               fetch all columns
76487>>>>>>>>>>>>>>>>>/// @Param  DF_FETCH_FALSE              fetch no columns
76487>>>>>>>>>>>>>>>>>///
76487>>>>>>>>>>>>>>>>>/// @Example
76487>>>>>>>>>>>>>>>>>/// Open Customer
76487>>>>>>>>>>>>>>>>>/// RESET_FETCH_FIELDS  CUSTOMER DF_FETCH_FALSE
76487>>>>>>>>>>>>>>>>>/// SELECT_COLUMNS_FIND CUSTOMER CUSTOMER_NUMBER NAME
76487>>>>>>>>>>>>>>>>>/// DISABLE_SELECT_COLUMNS_ERRORS DISABLED
76487>>>>>>>>>>>>>>>>>///
76487>>>>>>>>>>>>>>>>>/// Clear Customer
76487>>>>>>>>>>>>>>>>>/// Repeat
76487>>>>>>>>>>>>>>>>>///    Find Gt Customer by Index.1
76487>>>>>>>>>>>>>>>>>///    If (Found) Showln Customer.Customer_Number '-' Customer.Name
76487>>>>>>>>>>>>>>>>>/// Until (Not(Found))
76487>>>>>>>>>>>>>>>>>///
76487>>>>>>>>>>>>>>>>>/// RESET_FETCH_FIELDS Customer DF_FETCH_TRUE
76487>>>>>>>>>>>>>>>>>
76487>>>>>>>>>>>>>>>>>//=============================================================================
76487>>>>>>>>>>>>>>>>>/// @Name        SQL_FOR_ONEROW
76487>>>>>>>>>>>>>>>>>/// @Description This command will instruct the driver to fetch one row
76487>>>>>>>>>>>>>>>>>/// per query
76487>>>>>>>>>>>>>>>>>///
76487>>>>>>>>>>>>>>>>>/// @Assumptions
76487>>>>>>>>>>>>>>>>>/// @Status      Deprecated
76487>>>>>>>>>>>>>>>>>/// @Drivers     All
76487>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-19 by Aaron Gulack
76487>>>>>>>>>>>>>>>>>/// @See
76487>>>>>>>>>>>>>>>>>///
76487>>>>>>>>>>>>>>>>>/// @Syntax SQL_FOR_ONEROW {FileNumber}
76487>>>>>>>>>>>>>>>>>/// @Param  FileNumber          The number of the file
76487>>>>>>>>>>>>>>>>>/// @Example
76487>>>>>>>>>>>>>>>>>///     open Customer
76487>>>>>>>>>>>>>>>>>///     SQL_FOR_ONEROW Customer.File_Number
76487>>>>>>>>>>>>>>>>>///     Repeat
76487>>>>>>>>>>>>>>>>>///             find gt Customer by Recnum
76487>>>>>>>>>>>>>>>>>///         If (Found) Begin
76487>>>>>>>>>>>>>>>>>///             showln "Sales name is " Customer.FirstName
76487>>>>>>>>>>>>>>>>>///         end
76487>>>>>>>>>>>>>>>>>///     until (Customer.ID = 10)
76487>>>>>>>>>>>>>>>>>
76487>>>>>>>>>>>>>>>>>//=============================================================================
76487>>>>>>>>>>>>>>>>>/// @Name        SQL_REFRESH_CACHE
76487>>>>>>>>>>>>>>>>>/// @Description For optimization during record retrieval, a set number of
76487>>>>>>>>>>>>>>>>>/// records are stored in a local cache. This command forces a refresh, by
76487>>>>>>>>>>>>>>>>>/// making the next find retrieve the record from the database instead of
76487>>>>>>>>>>>>>>>>>/// the cache.
76487>>>>>>>>>>>>>>>>>///
76487>>>>>>>>>>>>>>>>>/// @Assumptions
76487>>>>>>>>>>>>>>>>>/// @Status      Public
76487>>>>>>>>>>>>>>>>>/// @Drivers     All
76487>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-19 by Aaron Gulack
76487>>>>>>>>>>>>>>>>>/// @See
76487>>>>>>>>>>>>>>>>>///
76487>>>>>>>>>>>>>>>>>/// @Syntax SQL_REFRESH_CACHE OF {FileNumber}
76487>>>>>>>>>>>>>>>>>/// @Param  FileNumber          The number of the file
76487>>>>>>>>>>>>>>>>>/// @Example
76487>>>>>>>>>>>>>>>>>/// Open Customer
76487>>>>>>>>>>>>>>>>>///
76487>>>>>>>>>>>>>>>>>/// Find gt Customer by Index.1
76487>>>>>>>>>>>>>>>>>/// While (Found) Begin
76487>>>>>>>>>>>>>>>>>///     showln "Customer name is " CUSTOMER.CUSTOMER
76487>>>>>>>>>>>>>>>>>/// Loop
76487>>>>>>>>>>>>>>>>>///
76487>>>>>>>>>>>>>>>>>/// SQL_REFRESH_CACHE of CUSTOMER
76487>>>>>>>>>>>>>>>>>
76487>>>>>>>>>>>>>>>>>//=============================================================================
76487>>>>>>>>>>>>>>>>>/// @Name        SQL_FOR_SET
76487>>>>>>>>>>>>>>>>>/// @Description Use this command during LT or GT finds to only fetch a set
76487>>>>>>>>>>>>>>>>>/// number of rows. An option is also available for this command to disable
76487>>>>>>>>>>>>>>>>>/// the local cash by passing NOCACHE at the end of the command call. Note
76487>>>>>>>>>>>>>>>>>/// that if the rowcount is set low, too many round-trips to the server may
76487>>>>>>>>>>>>>>>>>/// result, effecting performance significantly. Also, if the rowcount is set
76487>>>>>>>>>>>>>>>>>/// too high a large number of records can be pre-fetched and end up not being
76487>>>>>>>>>>>>>>>>>/// used by the application. Because of this, the default of 10 rows and a cache
76487>>>>>>>>>>>>>>>>>/// will be adequate for most situations.
76487>>>>>>>>>>>>>>>>>///
76487>>>>>>>>>>>>>>>>>/// @Assumptions
76487>>>>>>>>>>>>>>>>>/// @Status      Public
76487>>>>>>>>>>>>>>>>>/// @Drivers     All
76487>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
76487>>>>>>>>>>>>>>>>>/// @See
76487>>>>>>>>>>>>>>>>>///
76487>>>>>>>>>>>>>>>>>/// @Syntax SQL_FOR_SET {FileNumber} MAXROWS {variable} {CACHE/NOCACHE}
76487>>>>>>>>>>>>>>>>>/// @Param  FileNumber          The number of the file
76487>>>>>>>>>>>>>>>>>/// @Param  variable            The maximum number of rows to retrieve
76487>>>>>>>>>>>>>>>>>/// @Param  CACHE               fetched rows will be kept at the local cache
76487>>>>>>>>>>>>>>>>>/// @Param  NOCACHE             fetched rows will not be kept at the local cache
76487>>>>>>>>>>>>>>>>>/// @Example
76487>>>>>>>>>>>>>>>>>/// Open Customer
76487>>>>>>>>>>>>>>>>>///
76487>>>>>>>>>>>>>>>>>/// SQL_FOR_SET Customer MAXROWS 15 CACHE
76487>>>>>>>>>>>>>>>>>/// find gt Customer by Index.1
76487>>>>>>>>>>>>>>>>>
76487>>>>>>>>>>>>>>>>>//=============================================================================
76487>>>>>>>>>>>>>>>>>/// @Name        SQL_SET
76487>>>>>>>>>>>>>>>>>/// @Description Initializes and sets an initial statement for embedded
76487>>>>>>>>>>>>>>>>>/// sql execution.
76487>>>>>>>>>>>>>>>>>///
76487>>>>>>>>>>>>>>>>>/// @Assumptions Parameter may be more than 255 characters long so redirect to method.
76487>>>>>>>>>>>>>>>>>/// @Status      Deprecated
76487>>>>>>>>>>>>>>>>>/// @Drivers     All
76487>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
76487>>>>>>>>>>>>>>>>>/// @See         SQL_SET_STMT
76487>>>>>>>>>>>>>>>>>///
76487>>>>>>>>>>>>>>>>>/// @Syntax SQL_SET {FileNumber}
76487>>>>>>>>>>>>>>>>>/// @Param  FileNumber          The number of the file
76487>>>>>>>>>>>>>>>>>
76487>>>>>>>>>>>>>>>>>Procedure MertechInc_SQL_SET Global String sStatement
76489>>>>>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function 1 CALLBACK 0 PASSING MertechInc_Blank sStatement 0 RESULT MertechInc_iRet
76494>>>>>>>>>>>>>>>>>End_Procedure
76495>>>>>>>>>>>>>>>>>
76495>>>>>>>>>>>>>>>>>//=============================================================================
76495>>>>>>>>>>>>>>>>>/// @Name        SQL_APPEND
76495>>>>>>>>>>>>>>>>>/// @Description Appends a string value to the current embedded sql statement
76495>>>>>>>>>>>>>>>>>/// already set.
76495>>>>>>>>>>>>>>>>>///
76495>>>>>>>>>>>>>>>>>/// @Assumptions Parameter may be more than 255 characters long so redirect to method.
76495>>>>>>>>>>>>>>>>>/// @Status      Deprecated
76495>>>>>>>>>>>>>>>>>/// @Drivers     All
76495>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
76495>>>>>>>>>>>>>>>>>/// @See                 SQL_APPEND_STMT
76495>>>>>>>>>>>>>>>>>
76495>>>>>>>>>>>>>>>>>Procedure MertechInc_SQL_APPEND Global String sStatement
76497>>>>>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function 2 CALLBACK 0 PASSING MertechInc_Blank sStatement 0 RESULT MertechInc_iRet
76502>>>>>>>>>>>>>>>>>End_Procedure
76503>>>>>>>>>>>>>>>>>
76503>>>>>>>>>>>>>>>>>//=============================================================================
76503>>>>>>>>>>>>>>>>>/// @Name        SQL_EXECUTE
76503>>>>>>>>>>>>>>>>>/// @Description Executes the current embedded SQL statement set and commits
76503>>>>>>>>>>>>>>>>>/// finishing any pending transaction.
76503>>>>>>>>>>>>>>>>>///
76503>>>>>>>>>>>>>>>>>/// @Assumptions
76503>>>>>>>>>>>>>>>>>/// @Status      Deprecated
76503>>>>>>>>>>>>>>>>>/// @Drivers     All
76503>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
76503>>>>>>>>>>>>>>>>>/// @See                 SQL_EXECUTE_STMT
76503>>>>>>>>>>>>>>>>>
76503>>>>>>>>>>>>>>>>>//=============================================================================
76503>>>>>>>>>>>>>>>>>/// @Name        LOCK_TABLE
76503>>>>>>>>>>>>>>>>>/// @Description Locks a table. This is equivalent to locking a DAT file.
76503>>>>>>>>>>>>>>>>>///
76503>>>>>>>>>>>>>>>>>/// @Assumptions
76503>>>>>>>>>>>>>>>>>/// @Status      Deprecated
76503>>>>>>>>>>>>>>>>>/// @Drivers     DB2Flex, and ORAFlex 3.x
76503>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
76503>>>>>>>>>>>>>>>>>/// @See
76503>>>>>>>>>>>>>>>>>///
76503>>>>>>>>>>>>>>>>>/// @Syntax LOCK_TABLE {FileName} {FileName1} {FileName2} {FileName3}...
76503>>>>>>>>>>>>>>>>>/// @Param  FileName            The name of file to be locked. Can be more than one
76503>>>>>>>>>>>>>>>>>
76503>>>>>>>>>>>>>>>>>//=============================================================================
76503>>>>>>>>>>>>>>>>>/// @Name        SQL_CHECK_TABLE
76503>>>>>>>>>>>>>>>>>/// @Description Use this command to verify that a given table exists on the
76503>>>>>>>>>>>>>>>>>/// SQL backend. This command takes three arguments, a string containing the
76503>>>>>>>>>>>>>>>>>/// name of the database, a string containing the name of the user and finally
76503>>>>>>>>>>>>>>>>>/// a string containing the name of the table being checked. If the table exists,
76503>>>>>>>>>>>>>>>>>/// the program proceeds normally. If the table does not exist then the flag
76503>>>>>>>>>>>>>>>>>/// "finderr" is set to true. Note that in order to handle the error a check must
76503>>>>>>>>>>>>>>>>>/// be done on the "finderr" variable.
76503>>>>>>>>>>>>>>>>>///
76503>>>>>>>>>>>>>>>>>/// @Assumptions All three parameters are less than 256 characters long.
76503>>>>>>>>>>>>>>>>>/// @Status      Public
76503>>>>>>>>>>>>>>>>>/// @Drivers     All
76503>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
76503>>>>>>>>>>>>>>>>>/// @See
76503>>>>>>>>>>>>>>>>>///
76503>>>>>>>>>>>>>>>>>/// @Syntax SQL_CHECK_TABLE {database} {username} {table}
76503>>>>>>>>>>>>>>>>>/// @Param  database            Name of the database
76503>>>>>>>>>>>>>>>>>/// @Param  username            Name of the user
76503>>>>>>>>>>>>>>>>>/// @Param  table                       Name of the table being checked
76503>>>>>>>>>>>>>>>>>///
76503>>>>>>>>>>>>>>>>>/// @Example
76503>>>>>>>>>>>>>>>>>/// SQL_CHECK_TABLE "testDB" "user" "Customer"
76503>>>>>>>>>>>>>>>>>/// If (finderr) Begin
76503>>>>>>>>>>>>>>>>>///     Showln "This table does not exist"
76503>>>>>>>>>>>>>>>>>/// End
76503>>>>>>>>>>>>>>>>>
76503>>>>>>>>>>>>>>>>>//=============================================================================
76503>>>>>>>>>>>>>>>>>/// @Name        SET_SQL_CONSTRAINT
76503>>>>>>>>>>>>>>>>>/// @Description This command allows you to put an additional constraint on
76503>>>>>>>>>>>>>>>>>/// your finds, moving filtering to the SQL backend. Using this command can
76503>>>>>>>>>>>>>>>>>/// result in significantly improved performance, since the server network traffic
76503>>>>>>>>>>>>>>>>>/// reduced. Note that the SQL statement passed for this command is added onto
76503>>>>>>>>>>>>>>>>>/// the predefined Database SQL statement so treat it as such. Because of this,
76503>>>>>>>>>>>>>>>>>/// it will almost always begin with "AND" followed by the desired constraint.
76503>>>>>>>>>>>>>>>>>///
76503>>>>>>>>>>>>>>>>>/// @Assumptions Parameter may be more than 255 characters long so redirect to method.
76503>>>>>>>>>>>>>>>>>/// @Status      Public
76503>>>>>>>>>>>>>>>>>/// @Drivers     All
76503>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
76503>>>>>>>>>>>>>>>>>/// @See         SQL_CONSTRAINT GET_SQL_CONSTRAINT DF_FIELD_PROGRAMMATIC_DEFAULT
76503>>>>>>>>>>>>>>>>>///
76503>>>>>>>>>>>>>>>>>/// @Syntax SET_SQL_CONSTRAINT of {file} to {variable}
76503>>>>>>>>>>>>>>>>>/// @Param  file                        Name or Number of the file.
76503>>>>>>>>>>>>>>>>>/// @Param  variable            A SQL expression that constrains the data
76503>>>>>>>>>>>>>>>>>///
76503>>>>>>>>>>>>>>>>>/// @Example
76503>>>>>>>>>>>>>>>>>/// Open Customer
76503>>>>>>>>>>>>>>>>>///
76503>>>>>>>>>>>>>>>>>/// SET_SQL_CONSTRAINT of 1 to (SFormat('AND "%1"."%2" = ' + "'%3'", "Customer", "Status", "Active"))
76503>>>>>>>>>>>>>>>>>///
76503>>>>>>>>>>>>>>>>>/// For_All Customer by Index.1 do
76503>>>>>>>>>>>>>>>>>///     Showln Customer.FirstName
76503>>>>>>>>>>>>>>>>>/// End_For_All
76503>>>>>>>>>>>>>>>>>
76503>>>>>>>>>>>>>>>>>Procedure MertechInc_SET_SQL_CONSTRAINT Global Integer iFunction String sConstraint
76505>>>>>>>>>>>>>>>>>    Call_Driver MertechInc_FileNumber MertechInc_DriverName Function iFunction CALLBACK 0 PASSING sConstraint MertechInc_Blank 0 RESULT MertechInc_iRet
76510>>>>>>>>>>>>>>>>>End_Procedure
76511>>>>>>>>>>>>>>>>>
76511>>>>>>>>>>>>>>>>>Procedure MertechInc_SET_SQL_CONSTRAINT_PROGRAMMATIC Global Integer iFunction
76513>>>>>>>>>>>>>>>>>    Call_Driver MertechInc_FileNumber MertechInc_DriverName Function iFunction CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank 4 RESULT MertechInc_iRet
76518>>>>>>>>>>>>>>>>>End_Procedure
76519>>>>>>>>>>>>>>>>>
76519>>>>>>>>>>>>>>>>>//=============================================================================
76519>>>>>>>>>>>>>>>>>/// @Name        GET_SQL_CONSTRAINT
76519>>>>>>>>>>>>>>>>>/// @Description This command returns the current SQL constraint for the given
76519>>>>>>>>>>>>>>>>>/// table.  If there is no current constraint, then a blank string is returned.
76519>>>>>>>>>>>>>>>>>///
76519>>>>>>>>>>>>>>>>>/// @Assumptions Parameter may be more than 255 characters long so redirect to method.
76519>>>>>>>>>>>>>>>>>/// @Status      Public
76519>>>>>>>>>>>>>>>>>/// @Drivers     All
76519>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
76519>>>>>>>>>>>>>>>>>/// @See         SQL_CONSTRAINT SET_SQL_CONSTRAINT
76519>>>>>>>>>>>>>>>>>///
76519>>>>>>>>>>>>>>>>>/// @Syntax GET_SQL_CONSTRAINT of {File} to {variable}
76519>>>>>>>>>>>>>>>>>/// @Param  File                        Name or number of the file
76519>>>>>>>>>>>>>>>>>/// @Param  variable            The string containing the constraining SQL expression
76519>>>>>>>>>>>>>>>>>///
76519>>>>>>>>>>>>>>>>>/// @Example
76519>>>>>>>>>>>>>>>>>/// Open Customer
76519>>>>>>>>>>>>>>>>>///
76519>>>>>>>>>>>>>>>>>/// String sCon
76519>>>>>>>>>>>>>>>>>///
76519>>>>>>>>>>>>>>>>>/// SET_SQL_CONSTRAINT of Customer to (SFormat('AND "%1"."%2" = ' + "'%3'", "Customer", "Status", "Active"))
76519>>>>>>>>>>>>>>>>>/// GET_SQL_CONSTRAINT of Customer to sCon
76519>>>>>>>>>>>>>>>>>///
76519>>>>>>>>>>>>>>>>>/// For_All Customer by Index.1 do
76519>>>>>>>>>>>>>>>>>///     Showln Customer.FirstName
76519>>>>>>>>>>>>>>>>>///     Showln sCon
76519>>>>>>>>>>>>>>>>>/// End_For_All
76519>>>>>>>>>>>>>>>>>
76519>>>>>>>>>>>>>>>>>Function MertechInc_GET_SQL_CONSTRAINT Global Integer iFunction Returns String
76521>>>>>>>>>>>>>>>>>    String sConstraint
76521>>>>>>>>>>>>>>>>>    Get MertechInc_Pre_Size_String 0 to sConstraint
76522>>>>>>>>>>>>>>>>>
76522>>>>>>>>>>>>>>>>>    Call_Driver MertechInc_FileNumber MertechInc_DriverName Function iFunction CALLBACK 0 PASSING sConstraint MertechInc_Blank 3 RESULT MertechInc_iRet
76527>>>>>>>>>>>>>>>>>    Function_Return sConstraint
76528>>>>>>>>>>>>>>>>>End_Function
76529>>>>>>>>>>>>>>>>>
76529>>>>>>>>>>>>>>>>>//=============================================================================
76529>>>>>>>>>>>>>>>>>/// @Name        SQL_CONSTRAINT
76529>>>>>>>>>>>>>>>>>/// @Description This command is used to toggle on or off the current SQL
76529>>>>>>>>>>>>>>>>>/// constraint that is set for a table. To deactivate the current constraint,
76529>>>>>>>>>>>>>>>>>/// pass the constant DEACTIVATE to this command. to reactivate the constraint,
76529>>>>>>>>>>>>>>>>>/// pass ACTIVATE to this command.
76529>>>>>>>>>>>>>>>>>///
76529>>>>>>>>>>>>>>>>>/// @Status      Public
76529>>>>>>>>>>>>>>>>>/// @Drivers     All
76529>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
76529>>>>>>>>>>>>>>>>>/// @See         SET_SQL_CONSTRAINT GET_SQL_CONSTRAINT
76529>>>>>>>>>>>>>>>>>///
76529>>>>>>>>>>>>>>>>>/// @Syntax SQL_CONSTRAINT of {File} to {Activate|Deactivate}
76529>>>>>>>>>>>>>>>>>/// @Param  File                        Name or Number of the file
76529>>>>>>>>>>>>>>>>>/// @Param  Activate            Activates the constraint
76529>>>>>>>>>>>>>>>>>/// @Param  Deactivate          Deactivates the constraint
76529>>>>>>>>>>>>>>>>>///
76529>>>>>>>>>>>>>>>>>/// @Example
76529>>>>>>>>>>>>>>>>>/// Open Customer
76529>>>>>>>>>>>>>>>>>///
76529>>>>>>>>>>>>>>>>>/// SET_SQL_CONSTRAINT of Customer to (SFormat('AND "%1"."%2" = ' + "'%3'", "Customer", "FirstName", "Aaron"))
76529>>>>>>>>>>>>>>>>>/// SQL_CONSTRAINT of Customer to Deactivate
76529>>>>>>>>>>>>>>>>>///
76529>>>>>>>>>>>>>>>>>/// For_All Customer by Index.1 do
76529>>>>>>>>>>>>>>>>>///     Showln Customer.FirstName
76529>>>>>>>>>>>>>>>>>/// End_For_All
76529>>>>>>>>>>>>>>>>>
76529>>>>>>>>>>>>>>>>>//=============================================================================
76529>>>>>>>>>>>>>>>>>/// @Name        CREATE_TD_FILE
76529>>>>>>>>>>>>>>>>>/// @Description A .TD file is created when the attribute is set to True.
76529>>>>>>>>>>>>>>>>>///
76529>>>>>>>>>>>>>>>>>/// @Assumptions
76529>>>>>>>>>>>>>>>>>/// @Status      Deprecated
76529>>>>>>>>>>>>>>>>>/// @Drivers     All
76529>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
76529>>>>>>>>>>>>>>>>>/// @See
76529>>>>>>>>>>>>>>>>>///
76529>>>>>>>>>>>>>>>>>/// @Syntax CREATE_TD_FILE {variable}
76529>>>>>>>>>>>>>>>>>/// @Param  variable            True to create the .TD file, false doesn't create it.
76529>>>>>>>>>>>>>>>>>
76529>>>>>>>>>>>>>>>>>//=============================================================================
76529>>>>>>>>>>>>>>>>>/// @Name        OPEN_INT
76529>>>>>>>>>>>>>>>>>/// @Description This command is used to replace the OPEN command in DataFlex.
76529>>>>>>>>>>>>>>>>>/// It can be useful when accessing tables that are not in the current filelist.
76529>>>>>>>>>>>>>>>>>/// To access these tables, the INT and FD files must be in the directory. From
76529>>>>>>>>>>>>>>>>>/// there, all that is needed is to open the table using this command under an
76529>>>>>>>>>>>>>>>>>/// alias name. If the command is executed successfully then the table can be
76529>>>>>>>>>>>>>>>>>/// queried normally as if it were a standard table. Note that if the desired
76529>>>>>>>>>>>>>>>>>/// table is already in the filelist or doesn't have an INT file then this
76529>>>>>>>>>>>>>>>>>/// command will act as a normal open command.
76529>>>>>>>>>>>>>>>>>///
76529>>>>>>>>>>>>>>>>>/// @Assumptions
76529>>>>>>>>>>>>>>>>>/// @Status      Public
76529>>>>>>>>>>>>>>>>>/// @Drivers     All
76529>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-21 by Aaron Gulack
76529>>>>>>>>>>>>>>>>>/// @See
76529>>>>>>>>>>>>>>>>>///
76529>>>>>>>>>>>>>>>>>/// @Syntax OPEN_INT {variable} as {aliasName}
76529>>>>>>>>>>>>>>>>>/// @Param  variable            The name of the int file without the extension.
76529>>>>>>>>>>>>>>>>>/// @Param  aliasName           The alias name being used to query this table.
76529>>>>>>>>>>>>>>>>>/// @Example
76529>>>>>>>>>>>>>>>>>/// OPEN_INT "customer" as Customer
76529>>>>>>>>>>>>>>>>>///
76529>>>>>>>>>>>>>>>>>/// For_All Customer by Index.1 do
76529>>>>>>>>>>>>>>>>>///     Showln Customer.FirstName
76529>>>>>>>>>>>>>>>>>/// End_For_All
76529>>>>>>>>>>>>>>>>>
76529>>>>>>>>>>>>>>>>>//=============================================================================
76529>>>>>>>>>>>>>>>>>/// @Name        SET_OPEN_MODE
76529>>>>>>>>>>>>>>>>>/// @Description This command is used to enable an option known as "Lazy Open
76529>>>>>>>>>>>>>>>>>/// Mode". When turned on the table's metadata i.e. table, columns, index
76529>>>>>>>>>>>>>>>>>/// descriptions, is deferred until a field is accessed, even if a OPEN has
76529>>>>>>>>>>>>>>>>>/// already been done. This can significantly improve an application's initial
76529>>>>>>>>>>>>>>>>>/// performance, especially when a large number of files are opened when the
76529>>>>>>>>>>>>>>>>>/// program is launched. By default, tables are set to open normally, but by
76529>>>>>>>>>>>>>>>>>/// passing the constant LAZY_MODE to this command, it can be altered to use
76529>>>>>>>>>>>>>>>>>/// this mode. Note that when this mode is activated, it effects all tables
76529>>>>>>>>>>>>>>>>>/// that are opened. To deactivate this feature, pass the constant "DEFAULT"
76529>>>>>>>>>>>>>>>>>/// to this command at any time. This is the preferred method to activate or
76529>>>>>>>>>>>>>>>>>/// deactive this feature but it can also be set globally in the .INI file.
76529>>>>>>>>>>>>>>>>>///
76529>>>>>>>>>>>>>>>>>/// Default Value: DEFAULT (Off)
76529>>>>>>>>>>>>>>>>>///
76529>>>>>>>>>>>>>>>>>/// @Assumptions
76529>>>>>>>>>>>>>>>>>/// @Status      Public
76529>>>>>>>>>>>>>>>>>/// @Drivers     All
76529>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-21 by Aaron Gulack
76529>>>>>>>>>>>>>>>>>/// @See
76529>>>>>>>>>>>>>>>>>///
76529>>>>>>>>>>>>>>>>>/// @Syntax SET_OPEN_MODE to {DEFAULT/LAZY_MODE}
76529>>>>>>>>>>>>>>>>>/// @Param  DEFAULT                     Used to turn of the lazy mode feature.
76529>>>>>>>>>>>>>>>>>/// @Param  LAZY_MODE           Turns on the lazy mode feature
76529>>>>>>>>>>>>>>>>>///
76529>>>>>>>>>>>>>>>>>/// @Example
76529>>>>>>>>>>>>>>>>>/// SET_OPEN_MODE TO LAZY_MODE
76529>>>>>>>>>>>>>>>>>/// Open "customer.int" as Customer
76529>>>>>>>>>>>>>>>>>/// ...
76529>>>>>>>>>>>>>>>>>/// ...
76529>>>>>>>>>>>>>>>>>/// Find gt Customer by Index.1
76529>>>>>>>>>>>>>>>>>
76529>>>>>>>>>>>>>>>>>//=============================================================================
76529>>>>>>>>>>>>>>>>>/// @Name        SQL_SET_STMT
76529>>>>>>>>>>>>>>>>>/// @Description Use this command to set an SQL statement to be executed on the
76529>>>>>>>>>>>>>>>>>/// desired table. The string passed to this command must be a valid SQL
76529>>>>>>>>>>>>>>>>>/// expression and must be on a table that has already been opened. Note that
76529>>>>>>>>>>>>>>>>>/// when using this command, the SQL_PREPARE_STMT and SQL_EXECUTE_STMT must be
76529>>>>>>>>>>>>>>>>>/// used in addition to carry out the expression. The option to pass the file
76529>>>>>>>>>>>>>>>>>/// name as an extra parameter is used in cases where the data needs to be
76529>>>>>>>>>>>>>>>>>/// fetched directly into the record buffer of the specified file.
76529>>>>>>>>>>>>>>>>>///
76529>>>>>>>>>>>>>>>>>/// @Assumptions Parameter may be more than 255 characters long so redirect to method.
76529>>>>>>>>>>>>>>>>>/// @Status      Public
76529>>>>>>>>>>>>>>>>>/// @Drivers     All
76529>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-21 by Aaron Gulack
76529>>>>>>>>>>>>>>>>>/// @See                 SQL_APPEND_STMT SQL_PREPARE_STMT SQL_EXECUTE_STMT SQL_CANCEL_QUERY_STMT SQL_FETCH_NEXT_ROW SQL_BINDCOLUMNS_STMT
76529>>>>>>>>>>>>>>>>>///
76529>>>>>>>>>>>>>>>>>/// @Syntax SQL_SET_STMT [of {file}] to {variable}
76529>>>>>>>>>>>>>>>>>/// @Param file                         Name or number of the file (optional)
76529>>>>>>>>>>>>>>>>>/// @Param variable                     String containing the SQL statement
76529>>>>>>>>>>>>>>>>>///
76529>>>>>>>>>>>>>>>>>/// @Usage SQL_SET_STMT of Customer to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
76529>>>>>>>>>>>>>>>>>/// @Usage SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
76529>>>>>>>>>>>>>>>>>///
76529>>>>>>>>>>>>>>>>>/// @Example
76529>>>>>>>>>>>>>>>>>/// Open Customer
76529>>>>>>>>>>>>>>>>>///
76529>>>>>>>>>>>>>>>>>/// String sID sFirstName sLastName sDOB
76529>>>>>>>>>>>>>>>>>///
76529>>>>>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
76529>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT
76529>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
76529>>>>>>>>>>>>>>>>>/// While (Found)
76529>>>>>>>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sID sFirstName sLastName sDOB
76529>>>>>>>>>>>>>>>>>///     Showln sID
76529>>>>>>>>>>>>>>>>>///     Showln sFirstName
76529>>>>>>>>>>>>>>>>>///     Showln sLastName
76529>>>>>>>>>>>>>>>>>///     Showln sDOB
76529>>>>>>>>>>>>>>>>>/// Loop
76529>>>>>>>>>>>>>>>>>/// SQL_CANCEL_QUERY_STMT
76529>>>>>>>>>>>>>>>>>
76529>>>>>>>>>>>>>>>>>Procedure MertechInc_SQL_SET_STMT Global String sStatment
76531>>>>>>>>>>>>>>>>>    Call_Driver MertechInc_FileNumber MertechInc_DriverName Function 22 CALLBACK 0 PASSING MertechInc_Blank sStatment 0 RESULT MertechInc_iRet
76536>>>>>>>>>>>>>>>>>End_Procedure
76537>>>>>>>>>>>>>>>>>
76537>>>>>>>>>>>>>>>>>//=============================================================================
76537>>>>>>>>>>>>>>>>>/// @Name        SQL_APPEND_STMT
76537>>>>>>>>>>>>>>>>>/// @Description This command is used to append a command string to the
76537>>>>>>>>>>>>>>>>>/// command buffer initialized by SQL_SET_STMT. SQL_APPEND_STMT was added
76537>>>>>>>>>>>>>>>>>/// so that long SQL expressions could be broken into smaller strings and
76537>>>>>>>>>>>>>>>>>/// appended to a dynamic command buffer, which is then passed to the server.
76537>>>>>>>>>>>>>>>>>/// The SQL_APPEND_STMT will concatenate a string to the command buffer
76537>>>>>>>>>>>>>>>>>/// initialized by the SQL_SET_STMT command. SQL_APPEND_STMT can be called as
76537>>>>>>>>>>>>>>>>>/// many times as necessary to complete the SQL expression. Subsequently, the
76537>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT command executes the completed command.  The option to
76537>>>>>>>>>>>>>>>>>/// pass the file name as an extra parameter is used in cases where the data
76537>>>>>>>>>>>>>>>>>/// needs to be fetched directly into the record buffer of the specified file.
76537>>>>>>>>>>>>>>>>>///
76537>>>>>>>>>>>>>>>>>/// @Assumptions Parameter may be more than 255 characters long so redirect to method.
76537>>>>>>>>>>>>>>>>>/// @Status      Public
76537>>>>>>>>>>>>>>>>>/// @Drivers     All
76537>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-22 by Aaron Gulack
76537>>>>>>>>>>>>>>>>>/// @See                 SQL_SET_STMT SQL_PREPARE_STMT SQL_EXECUTE_STMT SQL_CANCEL_QUERY_STMT SQL_FETCH_NEXT_ROW SQL_BINDCOLUMNS_STMT
76537>>>>>>>>>>>>>>>>>///
76537>>>>>>>>>>>>>>>>>/// @Syntax SQL_APPEND_STMT [of {file}] to {variable}
76537>>>>>>>>>>>>>>>>>/// @Param file                         The name or number of the file (optional)
76537>>>>>>>>>>>>>>>>>/// @Param variable                     The string to be appended to the current SQL expression
76537>>>>>>>>>>>>>>>>>///
76537>>>>>>>>>>>>>>>>>/// @Usage SQL_APPEND_STMT to " CUSTOMER.PHONE_NUMBER, CUSTOMER.FAX_NUMBER"
76537>>>>>>>>>>>>>>>>>/// @Usage SQL_APPEND_STMT of Customer to " CUSTOMER.PHONE_NUMBER, CUSTOMER.FAX_NUMBER"
76537>>>>>>>>>>>>>>>>>///
76537>>>>>>>>>>>>>>>>>/// @Example
76537>>>>>>>>>>>>>>>>>/// Open Customer
76537>>>>>>>>>>>>>>>>>///
76537>>>>>>>>>>>>>>>>>/// String sID sFirstName sLastName sDOB
76537>>>>>>>>>>>>>>>>>///
76537>>>>>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
76537>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT
76537>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
76537>>>>>>>>>>>>>>>>>/// While (Found)
76537>>>>>>>>>>>>>>>>>///     SQL_FETCH_NEXT_ROW into sID sFirstName sLastName sDOB
76537>>>>>>>>>>>>>>>>>///     Showln sID
76537>>>>>>>>>>>>>>>>>///     Showln sFirstName
76537>>>>>>>>>>>>>>>>>///     Showln sLastName
76537>>>>>>>>>>>>>>>>>///     Showln sDOB
76537>>>>>>>>>>>>>>>>>/// Loop
76537>>>>>>>>>>>>>>>>>/// SQL_CANCEL_QUERY_STMT
76537>>>>>>>>>>>>>>>>>
76537>>>>>>>>>>>>>>>>>Procedure MertechInc_SQL_APPEND_STMT Global String sStatement
76539>>>>>>>>>>>>>>>>>    Call_Driver MertechInc_FileNumber MertechInc_DriverName Function 22 CALLBACK 0 PASSING MertechInc_Blank sStatement 1 RESULT MertechInc_iRet
76544>>>>>>>>>>>>>>>>>End_Procedure
76545>>>>>>>>>>>>>>>>>
76545>>>>>>>>>>>>>>>>>//=============================================================================
76545>>>>>>>>>>>>>>>>>/// @Name        APPEND_UPDATE_COLUMN
76545>>>>>>>>>>>>>>>>>/// @Description Append a given string to the existing SQL statement
76545>>>>>>>>>>>>>>>>>/// already set.
76545>>>>>>>>>>>>>>>>>///
76545>>>>>>>>>>>>>>>>>/// @Assumptions Parameter may be more than 255 characters long so redirect to method
76545>>>>>>>>>>>>>>>>>/// @Status      Internal
76545>>>>>>>>>>>>>>>>>/// @Drivers     All
76545>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-23 by Aaron Gulack
76545>>>>>>>>>>>>>>>>>/// @See
76545>>>>>>>>>>>>>>>>>///
76545>>>>>>>>>>>>>>>>>/// @Syntax APPEND_UPDCOL_STMT {variable} for {fileName}.{fieldName} {fields...}
76545>>>>>>>>>>>>>>>>>/// @Param variable                             SQL expression to be appended
76545>>>>>>>>>>>>>>>>>/// @Param fileName                             Name of the file
76545>>>>>>>>>>>>>>>>>/// @Param fieldName                    Name of the field
76545>>>>>>>>>>>>>>>>>/// @Param fields...                    Any additional fields, use the file.field format
76545>>>>>>>>>>>>>>>>>
76545>>>>>>>>>>>>>>>>>Procedure MertechInc_APPEND_UPDATE_COLUMN Global String sStatement
76547>>>>>>>>>>>>>>>>>    Call_Driver MertechInc_FileNumber MertechInc_DriverName Function 22 CALLBACK 0 PASSING MertechInc_Blank sStatement 1 RESULT MertechInc_iRet
76552>>>>>>>>>>>>>>>>>End_Procedure
76553>>>>>>>>>>>>>>>>>
76553>>>>>>>>>>>>>>>>>//=============================================================================
76553>>>>>>>>>>>>>>>>>/// @Name        SQL_APPEND_UPDCOL_STMT
76553>>>>>>>>>>>>>>>>>/// @Description Used to optimize the update process of columns being loaded
76553>>>>>>>>>>>>>>>>>/// with the same value.
76553>>>>>>>>>>>>>>>>>///
76553>>>>>>>>>>>>>>>>>/// @Assumptions
76553>>>>>>>>>>>>>>>>>/// @Status      Deprecated
76553>>>>>>>>>>>>>>>>>/// @Drivers     All
76553>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-23 by Aaron Gulack
76553>>>>>>>>>>>>>>>>>/// @See
76553>>>>>>>>>>>>>>>>>///
76553>>>>>>>>>>>>>>>>>/// @Syntax SQL_APPEND_UPDCOL_STMT [of {file}] Value {variable} for {fileName}.{fieldName} {fields...}
76553>>>>>>>>>>>>>>>>>/// @Param file                         The name or number of the file (optional)
76553>>>>>>>>>>>>>>>>>/// @Param variable                     The value being uploaded
76553>>>>>>>>>>>>>>>>>/// @Param fileName                     The name of the file
76553>>>>>>>>>>>>>>>>>/// @Param fieldName            The name of the field
76553>>>>>>>>>>>>>>>>>/// @Param fields...            Any additional fields, use the file.field format
76553>>>>>>>>>>>>>>>>>///
76553>>>>>>>>>>>>>>>>>/// @Example
76553>>>>>>>>>>>>>>>>>/// Open Customer
76553>>>>>>>>>>>>>>>>>///
76553>>>>>>>>>>>>>>>>>/// SQL_SET_STMT    of Customer to "UPDATE CUSTOMER SET"
76553>>>>>>>>>>>>>>>>>/// SQL_APPEND_STMT of Customer to " ASC11='x', ASC12='y', ASC13='z'"
76553>>>>>>>>>>>>>>>>>///
76553>>>>>>>>>>>>>>>>>/// SQL_APPEND_UPDCOL_STMT of Customer value 0 ;
76553>>>>>>>>>>>>>>>>>///     for Customer.ID Customer.Purchases Customer.Credit ;
76553>>>>>>>>>>>>>>>>>///
76553>>>>>>>>>>>>>>>>>/// SQL_APPEND_STMT of Customer to " WHERE RECNUM=1"
76553>>>>>>>>>>>>>>>>>///
76553>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT of Customer
76553>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT of Customer
76553>>>>>>>>>>>>>>>>>
76553>>>>>>>>>>>>>>>>>//=============================================================================
76553>>>>>>>>>>>>>>>>>/// @Name        SQL_SET_CURSOR_TYPE
76553>>>>>>>>>>>>>>>>>/// @Description Specify the SQL cursor type to be used during the next
76553>>>>>>>>>>>>>>>>>/// embedded SQL statement execution.
76553>>>>>>>>>>>>>>>>>///
76553>>>>>>>>>>>>>>>>>/// @Assumptions
76553>>>>>>>>>>>>>>>>>/// @Status      Internal
76553>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex
76553>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-23 by Aaron Gulack
76553>>>>>>>>>>>>>>>>>/// @See
76553>>>>>>>>>>>>>>>>>///
76553>>>>>>>>>>>>>>>>>/// @Syntax SQL_SET_CURSOR_TYPE to {TYPE_NONE/TYPE_CLIENT/TYPE_SERVER}
76553>>>>>>>>>>>>>>>>>/// @Param TYPE_NONE                    the default cursor type should be used
76553>>>>>>>>>>>>>>>>>/// @Param TYPE_CLIENT                  a client side cursor should be used
76553>>>>>>>>>>>>>>>>>/// @Param TYPE_SERVER                  a server side cursor should be used
76553>>>>>>>>>>>>>>>>>
76553>>>>>>>>>>>>>>>>>//=============================================================================
76553>>>>>>>>>>>>>>>>>/// @Name        CLEAR_INT_CACHE
76553>>>>>>>>>>>>>>>>>/// @Description Clears all memory-cached INT info. This is used in the
76553>>>>>>>>>>>>>>>>>/// test framework to force a "reload" of int info which the framework
76553>>>>>>>>>>>>>>>>>/// modifies for its tests. This is a different cache than the TD files
76553>>>>>>>>>>>>>>>>>/// which are a file based cache of the structure for use at file open.
76553>>>>>>>>>>>>>>>>>///
76553>>>>>>>>>>>>>>>>>/// @Assumptions
76553>>>>>>>>>>>>>>>>>/// @Status      Internal
76553>>>>>>>>>>>>>>>>>/// @Drivers     All
76553>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-23 by Aaron Gulack
76553>>>>>>>>>>>>>>>>>/// @See
76553>>>>>>>>>>>>>>>>>///
76553>>>>>>>>>>>>>>>>>/// @Syntax CLEAR_INT_CACHE
76553>>>>>>>>>>>>>>>>>
76553>>>>>>>>>>>>>>>>>//=============================================================================
76553>>>>>>>>>>>>>>>>>/// @Name        CREATE_INVERSE_KEY_FUNCTIONS
76553>>>>>>>>>>>>>>>>>/// @Description Create SQL Functions to handle Inverse Key columns.
76553>>>>>>>>>>>>>>>>>///
76553>>>>>>>>>>>>>>>>>/// @Assumptions
76553>>>>>>>>>>>>>>>>>/// @Status      Internal
76553>>>>>>>>>>>>>>>>>/// @Drivers     All (v10.1 and above)
76553>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-23 by Aaron Gulack
76553>>>>>>>>>>>>>>>>>/// @See
76553>>>>>>>>>>>>>>>>>///
76553>>>>>>>>>>>>>>>>>/// @Syntax CREATE_INVERSE_KEY_FUNCTIONS
76553>>>>>>>>>>>>>>>>>
76553>>>>>>>>>>>>>>>>>//=============================================================================
76553>>>>>>>>>>>>>>>>>/// @Name        SQL_PREPARE_STMT
76553>>>>>>>>>>>>>>>>>/// @Description Prepares a statement and opens a cursor to be executed by
76553>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT. This command tells the server to parse the SQL statement
76553>>>>>>>>>>>>>>>>>/// created by the respective SQL_SET_STMT and all subsequent SQL_APPEND_STMT
76553>>>>>>>>>>>>>>>>>/// statements and to allocate cursor handles to be used to fetch the data.
76553>>>>>>>>>>>>>>>>>/// A cursor can be thought of as a pointer to a record set. The CURSOR_TYPE
76553>>>>>>>>>>>>>>>>>/// argument is only supported by SQLFlex and by default SQLFLex is using a
76553>>>>>>>>>>>>>>>>>/// TYPE_SERVER cursor type to all embedded SQL. TYPE_CLIENT should be used only
76553>>>>>>>>>>>>>>>>>/// for the statements that are querying LOB columns i.e. TEXT, NVARCHAR(MAX),
76553>>>>>>>>>>>>>>>>>/// VARCHAR(MAX), IMAGE, VARBINARY(MAX), XML. If the cursor type is
76553>>>>>>>>>>>>>>>>>/// TYPE_SERVER and a LOB type column is selected, MS SQL Server will not be
76553>>>>>>>>>>>>>>>>>/// able to get into a transaction, either explicitly or implicitly through a
76553>>>>>>>>>>>>>>>>>/// REREAD, LOCK, SAVERECORD, etc.
76553>>>>>>>>>>>>>>>>>///
76553>>>>>>>>>>>>>>>>>/// @Assumptions
76553>>>>>>>>>>>>>>>>>/// @Status      Public
76553>>>>>>>>>>>>>>>>>/// @Drivers     All
76553>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-23 by Aaron Gulack
76553>>>>>>>>>>>>>>>>>/// @See                 SQL_SET_STMT SQL_APPEND_STMT SQL_EXECUTE_STMT SQL_CANCEL_QUERY_STMT SQL_FETCH_NEXT_ROW SQL_BINDCOLUMNS_STMT
76553>>>>>>>>>>>>>>>>>///
76553>>>>>>>>>>>>>>>>>/// @Syntax SQL_PREPARE_STMT [of {file}] CURSOR_TYPE {TYPE_NONE/TYPE_CLIENT/TYPE_SERVER}
76553>>>>>>>>>>>>>>>>>/// @Param file                         The name or number of the file (optional)
76553>>>>>>>>>>>>>>>>>/// @Param CURSOR_TYPE          Used if the cursor type is being set, do not include otherwise
76553>>>>>>>>>>>>>>>>>/// @Param TYPE_NONE            Default cursor will be used
76553>>>>>>>>>>>>>>>>>/// @Param TYPE_CLIENT          A client side cursor should be used
76553>>>>>>>>>>>>>>>>>/// @Param TYPE_SERVER          A server side cursor should be used (Default)
76553>>>>>>>>>>>>>>>>>///
76553>>>>>>>>>>>>>>>>>/// @Usage SQL_PREPARE_STMT
76553>>>>>>>>>>>>>>>>>/// @Usage SQL_PREPARE_STMT of Customer
76553>>>>>>>>>>>>>>>>>/// @Usage SQL_PREPARE_STMT CURSOR_TYPE TYPE_SERVER
76553>>>>>>>>>>>>>>>>>/// @Usage SQL_PREPARE_STMT of Customer CURSOR_TYPE TYPE_CLIENT
76553>>>>>>>>>>>>>>>>>///
76553>>>>>>>>>>>>>>>>>/// @Example
76553>>>>>>>>>>>>>>>>>/// Open Customer
76553>>>>>>>>>>>>>>>>>///
76553>>>>>>>>>>>>>>>>>/// String sID sFirstName
76553>>>>>>>>>>>>>>>>>///
76553>>>>>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
76553>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT
76553>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
76553>>>>>>>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sID sFirstName
76553>>>>>>>>>>>>>>>>>
76553>>>>>>>>>>>>>>>>>//=============================================================================
76553>>>>>>>>>>>>>>>>>/// @Name        SQL_BIND_COLUMN
76553>>>>>>>>>>>>>>>>>/// @Description Clears all cached INT info. This should be merged with
76553>>>>>>>>>>>>>>>>>/// SQL_BINDCOLUMNS_STMT, but has to remain as a separate command for
76553>>>>>>>>>>>>>>>>>/// compatibility.
76553>>>>>>>>>>>>>>>>>///
76553>>>>>>>>>>>>>>>>>/// @Assumptions
76553>>>>>>>>>>>>>>>>>/// @Status      Internal
76553>>>>>>>>>>>>>>>>>/// @Drivers     All
76553>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-26 by Aaron Gulack
76553>>>>>>>>>>>>>>>>>/// @See
76553>>>>>>>>>>>>>>>>>///
76553>>>>>>>>>>>>>>>>>/// @Syntax SQL_BIND_COLUMN FileNumber FieldNumber | DF_BIND_ALL_COLUMNS
76553>>>>>>>>>>>>>>>>>/// @Param FileNumber                   The number of the file
76553>>>>>>>>>>>>>>>>>/// @Param FieldNumber                  The number of the field
76553>>>>>>>>>>>>>>>>>
76553>>>>>>>>>>>>>>>>>//=============================================================================
76553>>>>>>>>>>>>>>>>>/// @Name        SQL_BINDCOLUMNS_STMT
76553>>>>>>>>>>>>>>>>>/// @Description This command is used to fetch the returned data of a
76553>>>>>>>>>>>>>>>>>/// specified SQL expression into the given field in the record buffer. By
76553>>>>>>>>>>>>>>>>>/// passing any number of fields to this command, the fetched record will then
76553>>>>>>>>>>>>>>>>>/// be put into the subsequent fields in the record buffer. The order of the
76553>>>>>>>>>>>>>>>>>/// fields must be the same as the order of the columns being retrieved from
76553>>>>>>>>>>>>>>>>>/// the SQL expression. SQL_FETCH_NEXT_ROW can then be called to take the data
76553>>>>>>>>>>>>>>>>>/// retrieved from the server and place it into the corresponding fields in the
76553>>>>>>>>>>>>>>>>>/// buffer. Instead of specifying each field, DF_BIND_ALL_COLUMNS can be passed,
76553>>>>>>>>>>>>>>>>>/// which will retrieve every column in the table.
76553>>>>>>>>>>>>>>>>>///
76553>>>>>>>>>>>>>>>>>/// @Assumptions
76553>>>>>>>>>>>>>>>>>/// @Status      Public
76553>>>>>>>>>>>>>>>>>/// @Drivers     All
76553>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-26 by Aaron Gulack
76553>>>>>>>>>>>>>>>>>/// @See                 SQL_SET_STMT SQL_APPEND_STMT SQL_PREPARE_STMT SQL_EXECUTE_STMT SQL_CANCEL_QUERY_STMT SQL_FETCH_NEXT_ROW
76553>>>>>>>>>>>>>>>>>///
76553>>>>>>>>>>>>>>>>>/// @Syntax SQL_BINDCOLUMNS_STMT of {file} to {field/DF_BIND_ALL_COLUMNS}
76553>>>>>>>>>>>>>>>>>///
76553>>>>>>>>>>>>>>>>>/// @Param file                 Name or number of the file
76553>>>>>>>>>>>>>>>>>/// @Param field                        Name or number of the field (can be multiple)
76553>>>>>>>>>>>>>>>>>/// @Param DF_BIND_ALL_COLUMNS  Used instead of the field to retrieve all columns in the file
76553>>>>>>>>>>>>>>>>>///
76553>>>>>>>>>>>>>>>>>/// @Example
76553>>>>>>>>>>>>>>>>>/// Open Customer
76553>>>>>>>>>>>>>>>>>///
76553>>>>>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
76553>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT
76553>>>>>>>>>>>>>>>>>/// SQL_BINDCOLUMNS_STMT of Customer to DF_BIND_ALL_COLUMNS
76553>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT of Customer
76553>>>>>>>>>>>>>>>>>/// While (Found)
76553>>>>>>>>>>>>>>>>>///     SQL_FETCH_NEXT_ROW of Customer
76553>>>>>>>>>>>>>>>>>///     Showln Customer.ID
76553>>>>>>>>>>>>>>>>>///     Showln Customer.FirstName
76553>>>>>>>>>>>>>>>>>///     Showln Customer.LastName
76553>>>>>>>>>>>>>>>>>///     Showln Customer.DOB
76553>>>>>>>>>>>>>>>>>/// Loop
76553>>>>>>>>>>>>>>>>>/// SQL_CANCEL_QUERY_STMT
76553>>>>>>>>>>>>>>>>>
76553>>>>>>>>>>>>>>>>>//=============================================================================
76553>>>>>>>>>>>>>>>>>/// @Name        SQL_EXECUTE_STMT
76553>>>>>>>>>>>>>>>>>/// @Description This command is used to execute the SQL expression created
76553>>>>>>>>>>>>>>>>>/// by the SQL_SET_STMT and any subsequent SQL_APPEND_STMT commands issued
76553>>>>>>>>>>>>>>>>>/// after a SQL_PREPARE_STMT. If the results will be sent to the record
76553>>>>>>>>>>>>>>>>>/// buffer directly, then the file must be specified. An optional parameter
76553>>>>>>>>>>>>>>>>>/// can also be passed, indicating the maximum number of rows to be sent to
76553>>>>>>>>>>>>>>>>>/// the local cache. This is done by adding the constant ROWCOUNT followed
76553>>>>>>>>>>>>>>>>>/// by the maximun number.
76553>>>>>>>>>>>>>>>>>///
76553>>>>>>>>>>>>>>>>>/// @Assumptions
76553>>>>>>>>>>>>>>>>>/// @Status      Public
76553>>>>>>>>>>>>>>>>>/// @Drivers     All
76553>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-26 by Aaron Gulack
76553>>>>>>>>>>>>>>>>>/// @See                 SQL_SET_STMT SQL_APPEND_STMT SQL_PREPARE_STMT SQL_CANCEL_QUERY_STMT SQL_FETCH_NEXT_ROW SQL_BINDCOLUMNS_STMT
76553>>>>>>>>>>>>>>>>>///
76553>>>>>>>>>>>>>>>>>/// @Syntax SQL_EXECUTE_STMT [of {file} ROWCOUNT {variable}]
76553>>>>>>>>>>>>>>>>>/// @Param file                         Name or number of the file (optional)
76553>>>>>>>>>>>>>>>>>/// @Param variable                     Maximum number of rows to send to the local cache (optional)
76553>>>>>>>>>>>>>>>>>///
76553>>>>>>>>>>>>>>>>>/// @Usage SQL_EXECUTE_STMT
76553>>>>>>>>>>>>>>>>>/// @Usage SQL_EXECUTE_STMT of Customer
76553>>>>>>>>>>>>>>>>>/// @Usage SQL_EXECUTE_STMT of Customer ROWCOUNT 10
76553>>>>>>>>>>>>>>>>>///
76553>>>>>>>>>>>>>>>>>/// @Example
76553>>>>>>>>>>>>>>>>>/// Open Customer
76553>>>>>>>>>>>>>>>>>///
76553>>>>>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
76553>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT
76553>>>>>>>>>>>>>>>>>/// SQL_BINDCOLUMNS_STMT of Customer to DF_BIND_ALL_COLUMNS
76553>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT of Customer
76553>>>>>>>>>>>>>>>>>/// While (Found)
76553>>>>>>>>>>>>>>>>>///     SQL_FETCH_NEXT_ROW of Customer
76553>>>>>>>>>>>>>>>>>///     Showln Customer.ID
76553>>>>>>>>>>>>>>>>>///     Showln Customer.FirstName
76553>>>>>>>>>>>>>>>>>///     Showln Customer.LastName
76553>>>>>>>>>>>>>>>>>///     Showln Customer.DOB
76553>>>>>>>>>>>>>>>>>/// Loop
76553>>>>>>>>>>>>>>>>>/// SQL_CANCEL_QUERY_STMT
76553>>>>>>>>>>>>>>>>>
76553>>>>>>>>>>>>>>>>>
76553>>>>>>>>>>>>>>>>>//This alias may be redundant. Is was only called from MertechInc_SQL_FUNCTION_EXECUTE
76553>>>>>>>>>>>>>>>>>//which has been recoded to directly call SQL_EXECUTE_STMT - I.S. 2009-09-19
76553>>>>>>>>>>>>>>>>>Procedure MertechInc_SQL_PROCEDURE_EXECUTE Global
76555>>>>>>>>>>>>>>>>>    SQL_EXECUTE_STMT
76595>>>>>>>>>>>>>>>>>End_Procedure
76596>>>>>>>>>>>>>>>>>
76596>>>>>>>>>>>>>>>>>//=============================================================================
76596>>>>>>>>>>>>>>>>>/// @Name        SQL_START_TRANSACTION_STMT
76596>>>>>>>>>>>>>>>>>/// @Description Transactions in SQL are used to maintain atomicity within
76596>>>>>>>>>>>>>>>>>/// an process. If one procedure in the transaction fails, then they all
76596>>>>>>>>>>>>>>>>>/// will fail. This command is used to start an SQL transaction. Inside of
76596>>>>>>>>>>>>>>>>>/// a transaction, there can be any number of SQL statements, none of which
76596>>>>>>>>>>>>>>>>>/// will be executed until SQL_COMMIT_STMT is called. Note that transactions
76596>>>>>>>>>>>>>>>>>/// are generally only needed when a table is being altered.
76596>>>>>>>>>>>>>>>>>///
76596>>>>>>>>>>>>>>>>>/// @Assumptions
76596>>>>>>>>>>>>>>>>>/// @Status      Public
76596>>>>>>>>>>>>>>>>>/// @Drivers     All
76596>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-26 by Aaron Gulack
76596>>>>>>>>>>>>>>>>>/// @See         SQL_COMMIT_STMT SQL_ROLLBACK_STMT
76596>>>>>>>>>>>>>>>>>///
76596>>>>>>>>>>>>>>>>>/// @Syntax SQL_START_TRANSACTION_STMT
76596>>>>>>>>>>>>>>>>>///
76596>>>>>>>>>>>>>>>>>/// @Example
76596>>>>>>>>>>>>>>>>>/// SQL_START_TRANSACTION_STMT
76596>>>>>>>>>>>>>>>>>/// SQL_SET_STMT to "UPDATE CUSTOMER SET STATUS = 'Inactive'"
76596>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT
76596>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
76596>>>>>>>>>>>>>>>>>/// SQL_COMMIT_STMT
76596>>>>>>>>>>>>>>>>>
76596>>>>>>>>>>>>>>>>>//=============================================================================
76596>>>>>>>>>>>>>>>>>/// @Name        SQL_COMMIT_STMT
76596>>>>>>>>>>>>>>>>>/// @Description Just as the SQL_EXECUTE_STMT is used to execute the SQL
76596>>>>>>>>>>>>>>>>>/// statement in the block, this command is used to commit the transaction
76596>>>>>>>>>>>>>>>>>/// started by SQL_START_TRANSACTION_STMT. When this command is called, any
76596>>>>>>>>>>>>>>>>>/// preceding statements or procedures that are apart of the transaction will
76596>>>>>>>>>>>>>>>>>/// be committed. If one or more of these statements fail, then none of them
76596>>>>>>>>>>>>>>>>>/// will be successful, thus maintaining atomicity.
76596>>>>>>>>>>>>>>>>>///
76596>>>>>>>>>>>>>>>>>/// @Assumptions
76596>>>>>>>>>>>>>>>>>/// @Status      Public
76596>>>>>>>>>>>>>>>>>/// @Drivers     All
76596>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-27 by Aaron Gulack
76596>>>>>>>>>>>>>>>>>/// @See                 SQL_START_TRANSACTION_STMT SQL_ROLLBACK_STMT
76596>>>>>>>>>>>>>>>>>///
76596>>>>>>>>>>>>>>>>>/// @Syntax SQL_COMMIT_STMT
76596>>>>>>>>>>>>>>>>>///
76596>>>>>>>>>>>>>>>>>/// @Example
76596>>>>>>>>>>>>>>>>>/// SQL_START_TRANSACTION_STMT
76596>>>>>>>>>>>>>>>>>/// SQL_SET_STMT to "UPDATE CUSTOMER SET STATUS = 'Inactive'"
76596>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT
76596>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
76596>>>>>>>>>>>>>>>>>/// SQL_COMMIT_STMT
76596>>>>>>>>>>>>>>>>>
76596>>>>>>>>>>>>>>>>>//=============================================================================
76596>>>>>>>>>>>>>>>>>/// @Name        SQL_ROLLBACK_STMT
76596>>>>>>>>>>>>>>>>>/// @Description Rolls back an SQL transaction, any data changes inside the
76596>>>>>>>>>>>>>>>>>/// transaction will not be committed by the server.
76596>>>>>>>>>>>>>>>>>///
76596>>>>>>>>>>>>>>>>>/// @Assumptions
76596>>>>>>>>>>>>>>>>>/// @Status      Public
76596>>>>>>>>>>>>>>>>>/// @Drivers     All
76596>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-27 by Aaron Gulack
76596>>>>>>>>>>>>>>>>>/// @See                 SQL_START_TRANSACTION_STMT SQL_COMMIT_STMT
76596>>>>>>>>>>>>>>>>>///
76596>>>>>>>>>>>>>>>>>/// @Syntax SQL_ROLLBACK_STMT
76596>>>>>>>>>>>>>>>>>///
76596>>>>>>>>>>>>>>>>>/// @Example
76596>>>>>>>>>>>>>>>>>/// SQL_START_TRANSACTION_STMT
76596>>>>>>>>>>>>>>>>>/// SQL_SET_STMT to "DELETE FROM CUSTOMER WHERE ID = 2145"
76596>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT
76596>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
76596>>>>>>>>>>>>>>>>>/// If (Err) Begin
76596>>>>>>>>>>>>>>>>>///             SQL_ERROR_MESSAGE errorString
76596>>>>>>>>>>>>>>>>>///     Showln errorString
76596>>>>>>>>>>>>>>>>>///     SQL_ROLLBACK_STMT
76596>>>>>>>>>>>>>>>>>/// End
76596>>>>>>>>>>>>>>>>>/// Else
76596>>>>>>>>>>>>>>>>>///     Showln "SQL Statement successful - committing"
76596>>>>>>>>>>>>>>>>>///     SQL_COMMIT_STMT
76596>>>>>>>>>>>>>>>>>
76596>>>>>>>>>>>>>>>>>//=============================================================================
76596>>>>>>>>>>>>>>>>>/// @Name        SET_TRANSACTIONS_ALLOWED
76596>>>>>>>>>>>>>>>>>/// @Description This command is used to toggle on or off the ability to
76596>>>>>>>>>>>>>>>>>/// complete transaction to the server. Passing false to this command will
76596>>>>>>>>>>>>>>>>>/// not allow transactions to be made, passing true will allow the transactions.
76596>>>>>>>>>>>>>>>>>///
76596>>>>>>>>>>>>>>>>>/// @Assumptions
76596>>>>>>>>>>>>>>>>>/// @Status      Internal
76596>>>>>>>>>>>>>>>>>/// @Drivers     All
76596>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-27 by Aaron Gulack
76596>>>>>>>>>>>>>>>>>/// @See
76596>>>>>>>>>>>>>>>>>///
76596>>>>>>>>>>>>>>>>>/// @Syntax SET_TRANSACTIONS_ALLOWED of {server} to {variable}
76596>>>>>>>>>>>>>>>>>/// @Param server                               The name of the server being used
76596>>>>>>>>>>>>>>>>>/// @Param variable                     Boolean to enable or disable transactions
76596>>>>>>>>>>>>>>>>>///
76596>>>>>>>>>>>>>>>>>/// @Example
76596>>>>>>>>>>>>>>>>>/// SET_TRANSACTIONS_ALLOWED of "localhost" to True
76596>>>>>>>>>>>>>>>>>
76596>>>>>>>>>>>>>>>>>//=============================================================================
76596>>>>>>>>>>>>>>>>>/// @Name        SQL_FETCH_NEXT_ROW
76596>>>>>>>>>>>>>>>>>/// @Description This command is used to fetch the next row returned by the
76596>>>>>>>>>>>>>>>>>/// associated SQL statement. The SQL statement is created from the
76596>>>>>>>>>>>>>>>>>/// SQL_SET_STMT and executed with the SQL_EXECUTE_STMT. This command can be
76596>>>>>>>>>>>>>>>>>/// used in two ways. If the results are to be attached to variables, then no
76596>>>>>>>>>>>>>>>>>/// file needs to be specified, just the variables for each column in the row.
76596>>>>>>>>>>>>>>>>>/// If the results are to be inserted into the record buffer directly, then the
76596>>>>>>>>>>>>>>>>>/// file must be specified. From there, a SQL_BINDCOLUMNS_STMT can be used to
76596>>>>>>>>>>>>>>>>>/// bind the fetched row to the specific fields in the file. Note that the
76596>>>>>>>>>>>>>>>>>/// columns are fecthed in the order that the SQL statement generates them, so
76596>>>>>>>>>>>>>>>>>/// the variables must follow the same order. The two constants, "found" and
76596>>>>>>>>>>>>>>>>>/// "finderr" are set depending on whether the next row was found.
76596>>>>>>>>>>>>>>>>>///
76596>>>>>>>>>>>>>>>>>/// @Assumptions
76596>>>>>>>>>>>>>>>>>/// @Status      Public
76596>>>>>>>>>>>>>>>>>/// @Drivers     All
76596>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-27 by Aaron Gulack
76596>>>>>>>>>>>>>>>>>/// @See                 SQL_SET_STMT SQL_APPEND_STMT SQL_PREPARE_STMT SQL_EXECUTE_STMT SQL_CANCEL_QUERY_STMT SQL_BINDCOLUMNS_STMT
76596>>>>>>>>>>>>>>>>>///
76596>>>>>>>>>>>>>>>>>/// @Syntax SQL_FETCH_NEXT_ROW [of {file}] into {variable}
76596>>>>>>>>>>>>>>>>>/// @Param  file                                The name or number of the file
76596>>>>>>>>>>>>>>>>>/// @Param  variable                    The variable that the next column in the fetched row will be put into (can be multiple)
76596>>>>>>>>>>>>>>>>>///
76596>>>>>>>>>>>>>>>>>/// @Usage SQL_FETCH_NEXT_ROW of Customer
76596>>>>>>>>>>>>>>>>>/// @Usage SQL_FETCH_NEXT_ROW into sRecnum sID
76596>>>>>>>>>>>>>>>>>///
76596>>>>>>>>>>>>>>>>>/// @Example
76596>>>>>>>>>>>>>>>>>/// String sID sRecnum
76596>>>>>>>>>>>>>>>>>///
76596>>>>>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER ID"
76596>>>>>>>>>>>>>>>>>/// SQL_APPEND_STMT to " BY NAME DESC"
76596>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT
76596>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
76596>>>>>>>>>>>>>>>>>/// While (found)
76596>>>>>>>>>>>>>>>>>///     SQL_FETCH_NEXT_ROW into sRecnum sID
76596>>>>>>>>>>>>>>>>>///     If (found) Begin
76596>>>>>>>>>>>>>>>>>///             Showln sID
76596>>>>>>>>>>>>>>>>>///    End
76596>>>>>>>>>>>>>>>>>/// Loop
76596>>>>>>>>>>>>>>>>>/// SQL_CANCEL_QUERY_STMT
76596>>>>>>>>>>>>>>>>>///
76596>>>>>>>>>>>>>>>>>/// @Example
76596>>>>>>>>>>>>>>>>>/// Open Customer
76596>>>>>>>>>>>>>>>>>///
76596>>>>>>>>>>>>>>>>>/// SQL_SET_STMT of Customer to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
76596>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT of Customer
76596>>>>>>>>>>>>>>>>>/// SQL_BINDCOLUMNS_STMT of Customer to DF_BIND_ALL_COLUMNS
76596>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT of Customer
76596>>>>>>>>>>>>>>>>>/// While (Found)
76596>>>>>>>>>>>>>>>>>///     SQL_FETCH_NEXT_ROW of Customer
76596>>>>>>>>>>>>>>>>>///     Showln Customer.ID
76596>>>>>>>>>>>>>>>>>///     Showln Customer.FirstName
76596>>>>>>>>>>>>>>>>>///             Showln Customer.LastName
76596>>>>>>>>>>>>>>>>>/// Loop
76596>>>>>>>>>>>>>>>>>/// SQL_CANCEL_QUERY_STMT
76596>>>>>>>>>>>>>>>>>
76596>>>>>>>>>>>>>>>>>//=============================================================================
76596>>>>>>>>>>>>>>>>>/// @Name        GET_RESULT_SET
76596>>>>>>>>>>>>>>>>>/// @Description Fetches the next row in the result set returned by a
76596>>>>>>>>>>>>>>>>>/// query or stored procedure.
76596>>>>>>>>>>>>>>>>>///
76596>>>>>>>>>>>>>>>>>/// @Assumptions
76596>>>>>>>>>>>>>>>>>/// @Status      Deprecated
76596>>>>>>>>>>>>>>>>>/// @Drivers     All
76596>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-27 by Aaron Gulack
76596>>>>>>>>>>>>>>>>>/// @See
76596>>>>>>>>>>>>>>>>>///
76596>>>>>>>>>>>>>>>>>/// @Syntax GET_RESULT_SET into {variable}
76596>>>>>>>>>>>>>>>>>/// @Param variable                     The variable receiving the result (can be multiple)
76596>>>>>>>>>>>>>>>>>
76596>>>>>>>>>>>>>>>>>//=============================================================================
76596>>>>>>>>>>>>>>>>>/// @Name        SQL_GET_DATA_CHUNK
76596>>>>>>>>>>>>>>>>>/// @Description This command is used to get a chunk of data from a column
76596>>>>>>>>>>>>>>>>>/// retrieved through an embedded SQL statement. By passing the column number
76596>>>>>>>>>>>>>>>>>/// and the offset number, the chunk will be put into the specified variable.
76596>>>>>>>>>>>>>>>>>/// To specify how big of a chunk to get, use the SQL_SET_CHUNK_SIZE command.
76596>>>>>>>>>>>>>>>>>/// Otherwise the maximum length will be retrieved. An optional variable can
76596>>>>>>>>>>>>>>>>>/// also be passed which will store the length of the chunk. Note that unlike
76596>>>>>>>>>>>>>>>>>/// LOB_READ, this command works for any column type, not just LOB columns.
76596>>>>>>>>>>>>>>>>>///
76596>>>>>>>>>>>>>>>>>/// @Assumptions
76596>>>>>>>>>>>>>>>>>/// @Status      Public
76596>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex
76596>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
76596>>>>>>>>>>>>>>>>>/// @See                 SQL_SET_CHUNK_SIZE SQL_GET_CHUNK_SIZE SQL_SET_MAX_DATA_SIZE SQL_GET_MAX_DATA_SIZE
76596>>>>>>>>>>>>>>>>>///
76596>>>>>>>>>>>>>>>>>/// @Syntax SQL_GET_DATA_CHUNK COLUMN {column} OFFSET {offset} to {variable} {length}
76596>>>>>>>>>>>>>>>>>/// @Param column                               Column number to get chunk from
76596>>>>>>>>>>>>>>>>>/// @Param offset                       Offset to start at for the chunk
76596>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the returned chunk
76596>>>>>>>>>>>>>>>>>/// @Param length                       Variable to hold the chunk length
76596>>>>>>>>>>>>>>>>>///
76596>>>>>>>>>>>>>>>>>/// @Example
76596>>>>>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
76596>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT
76596>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
76596>>>>>>>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sID sBio
76596>>>>>>>>>>>>>>>>>/// If (Found) Begin
76596>>>>>>>>>>>>>>>>>///     SQL_SET_CHUNK_SIZE to 150
76596>>>>>>>>>>>>>>>>>///     SQL_GET_DATA_CHUNK COLUMN 6 OFFSET 1 to sChunk iLength
76596>>>>>>>>>>>>>>>>>///     Showln sChunk
76596>>>>>>>>>>>>>>>>>///     Showln iLength
76596>>>>>>>>>>>>>>>>>/// End
76596>>>>>>>>>>>>>>>>>
76596>>>>>>>>>>>>>>>>>Function MertechInc_SQL_GET_DATA_CHUNK Global Integer iColumn Integer iOffset Returns String
76598>>>>>>>>>>>>>>>>>    Integer iChuck_Size
76598>>>>>>>>>>>>>>>>>    String sChunk
76598>>>>>>>>>>>>>>>>>
76598>>>>>>>>>>>>>>>>>    //Get current Chuck size and pre size string
76598>>>>>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_CHUNK_SIZE CALLBACK 0 PASSING iChuck_Size MertechInc_Blank 1 RESULT MertechInc_iRet
76603>>>>>>>>>>>>>>>>>    Get MertechInc_Pre_Size_String iChuck_Size to sChunk
76604>>>>>>>>>>>>>>>>>
76604>>>>>>>>>>>>>>>>>    //Get data
76604>>>>>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_GET_DATA_CHUNK CALLBACK 0 PASSING iColumn sChunk iOffset RESULT MertechInc_iRet
76609>>>>>>>>>>>>>>>>>
76609>>>>>>>>>>>>>>>>>    //sArg1 (iColumn) contains the number of bytes returned, so move it to
76609>>>>>>>>>>>>>>>>>    //MertechInc_Arg1 to pass the value back
76609>>>>>>>>>>>>>>>>>    Move iColumn to MertechInc_sArg1
76610>>>>>>>>>>>>>>>>>
76610>>>>>>>>>>>>>>>>>    Function_Return sChunk
76611>>>>>>>>>>>>>>>>>End_Function
76612>>>>>>>>>>>>>>>>>
76612>>>>>>>>>>>>>>>>>//=============================================================================
76612>>>>>>>>>>>>>>>>>/// @Name        SQL_SET_CHUNK_SIZE
76612>>>>>>>>>>>>>>>>>/// @Description This command sets the size of the chunk to retrieve when
76612>>>>>>>>>>>>>>>>>/// using SQL_GET_DATA_CHUNK. Whatever number is set here will be the
76612>>>>>>>>>>>>>>>>>/// length of the chunk that is retrieved, as long as it does not exceed
76612>>>>>>>>>>>>>>>>>/// the maximum chunk size.
76612>>>>>>>>>>>>>>>>>///
76612>>>>>>>>>>>>>>>>>/// @Assumptions
76612>>>>>>>>>>>>>>>>>/// @Status      Public
76612>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex
76612>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
76612>>>>>>>>>>>>>>>>>/// @See                 SQL_GET_DATA_CHUNK SQL_GET_CHUNK_SIZE SQL_SET_MAX_DATA_SIZE SQL_GET_MAX_DATA_SIZE
76612>>>>>>>>>>>>>>>>>///
76612>>>>>>>>>>>>>>>>>/// @Syntax SQL_SET_CHUNK_SIZE to {variable}
76612>>>>>>>>>>>>>>>>>/// @Param variable                     Length of chunk to retrive
76612>>>>>>>>>>>>>>>>>///
76612>>>>>>>>>>>>>>>>>/// @Example
76612>>>>>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
76612>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT
76612>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
76612>>>>>>>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sID sBio
76612>>>>>>>>>>>>>>>>>/// If (Found) Begin
76612>>>>>>>>>>>>>>>>>///     SQL_SET_CHUNK_SIZE to 150
76612>>>>>>>>>>>>>>>>>///     SQL_GET_DATA_CHUNK COLUMN 6 OFFSET 1 to sChunk iLength
76612>>>>>>>>>>>>>>>>>///     Showln sChunk
76612>>>>>>>>>>>>>>>>>///     Showln iLength
76612>>>>>>>>>>>>>>>>>/// End
76612>>>>>>>>>>>>>>>>>
76612>>>>>>>>>>>>>>>>>//=============================================================================
76612>>>>>>>>>>>>>>>>>/// @Name        SQL_GET_CHUNK_SIZE
76612>>>>>>>>>>>>>>>>>/// @Description This command gets the size of the chunk being retrieved
76612>>>>>>>>>>>>>>>>>/// from SQL_GET_DATA_CHUNK and puts it into the specified variable.
76612>>>>>>>>>>>>>>>>>///
76612>>>>>>>>>>>>>>>>>/// @Assumptions
76612>>>>>>>>>>>>>>>>>/// @Status      Public
76612>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex
76612>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
76612>>>>>>>>>>>>>>>>>/// @See                 SQL_SET_CHUNK_SIZE SQL_GET_DATA_CHUNK SQL_SET_MAX_DATA_SIZE SQL_GET_MAX_DATA_SIZE
76612>>>>>>>>>>>>>>>>>///
76612>>>>>>>>>>>>>>>>>/// @Syntax SQL_GET_CHUNK_SIZE to {variable}
76612>>>>>>>>>>>>>>>>>/// @Param variable             Variable to hold the chunk size
76612>>>>>>>>>>>>>>>>>///
76612>>>>>>>>>>>>>>>>>/// @Example
76612>>>>>>>>>>>>>>>>>/// SQL_GET_CHUNK_SIZE to iLength
76612>>>>>>>>>>>>>>>>>
76612>>>>>>>>>>>>>>>>>//=============================================================================
76612>>>>>>>>>>>>>>>>>/// @Name        SQL_SET_MAX_DATA_SIZE
76612>>>>>>>>>>>>>>>>>/// @Description This command sets the maximum size for data chunks
76612>>>>>>>>>>>>>>>>>/// retrieved through SQL_GET_DATA_CHUNK. If SQL_SET_CHUNK_SIZE is higher
76612>>>>>>>>>>>>>>>>>/// than the maximum size set with this command, then this will override
76612>>>>>>>>>>>>>>>>>/// it and the chunk will be no longer than the maximum size set here.
76612>>>>>>>>>>>>>>>>>///
76612>>>>>>>>>>>>>>>>>/// @Assumptions
76612>>>>>>>>>>>>>>>>>/// @Status      Public
76612>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex
76612>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
76612>>>>>>>>>>>>>>>>>/// @See                 SQL_SET_CHUNK_SIZE SQL_GET_CHUNK_SIZE SQL_GET_DATA_CHUNK SQL_GET_MAX_DATA_SIZE
76612>>>>>>>>>>>>>>>>>///
76612>>>>>>>>>>>>>>>>>/// @Syntax SQL_SET_MAX_DATA_SIZE to {variable}
76612>>>>>>>>>>>>>>>>>/// @Param variable                     Max length to allow for chunks
76612>>>>>>>>>>>>>>>>>///
76612>>>>>>>>>>>>>>>>>/// @Example
76612>>>>>>>>>>>>>>>>>/// SQL_SET_MAX_DATA_SIZE to 1000
76612>>>>>>>>>>>>>>>>>
76612>>>>>>>>>>>>>>>>>//=============================================================================
76612>>>>>>>>>>>>>>>>>/// @Name        SQL_GET_MAX_DATA_SIZE
76612>>>>>>>>>>>>>>>>>/// @Description This command returns the maximum chunk size allowed
76612>>>>>>>>>>>>>>>>>/// for SQL_GET_DATA_CHUNK.
76612>>>>>>>>>>>>>>>>>///
76612>>>>>>>>>>>>>>>>>/// @Assumptions
76612>>>>>>>>>>>>>>>>>/// @Status      Public
76612>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex
76612>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
76612>>>>>>>>>>>>>>>>>/// @See                 SQL_SET_CHUNK_SIZE SQL_GET_CHUNK_SIZE SQL_GET_DATA_CHUNK SQL_SET_MAX_DATA_SIZE
76612>>>>>>>>>>>>>>>>>///
76612>>>>>>>>>>>>>>>>>/// @Syntax SQL_GET_MAX_DATA_SIZE to {variable}
76612>>>>>>>>>>>>>>>>>/// @Param variable             Variable to hold the maximum chunk size
76612>>>>>>>>>>>>>>>>>///
76612>>>>>>>>>>>>>>>>>/// @Example
76612>>>>>>>>>>>>>>>>>/// SQL_GET_MAX_DATA_SIZE to iLength
76612>>>>>>>>>>>>>>>>>
76612>>>>>>>>>>>>>>>>>//=============================================================================
76612>>>>>>>>>>>>>>>>>/// @Name        SQL_GET_NUM_COLS
76612>>>>>>>>>>>>>>>>>/// @Description This command is used to get the number of columns retrieved
76612>>>>>>>>>>>>>>>>>/// from an SQL expression result set. Since the column number is based on
76612>>>>>>>>>>>>>>>>>/// the result set, this command cannot be used when the results are being
76612>>>>>>>>>>>>>>>>>/// bound to the record buffer.  If this command is used with the record
76612>>>>>>>>>>>>>>>>>/// buffer or if no columns are found, -1 is returned.
76612>>>>>>>>>>>>>>>>>///
76612>>>>>>>>>>>>>>>>>/// @Assumptions
76612>>>>>>>>>>>>>>>>>/// @Status      Public
76612>>>>>>>>>>>>>>>>>/// @Drivers     All
76612>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-28 by Aaron Gulack
76612>>>>>>>>>>>>>>>>>/// @See                 SQL_PREPARE_STMT SQL_EXECUTE_STMT SQL_SET_STMT
76612>>>>>>>>>>>>>>>>>///
76612>>>>>>>>>>>>>>>>>/// @Syntax SQL_GET_NUM_COLS to {variable}
76612>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the number of columns.
76612>>>>>>>>>>>>>>>>>///
76612>>>>>>>>>>>>>>>>>/// @Example
76612>>>>>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE FIRSTNAME = 'Aaron'"
76612>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT
76612>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
76612>>>>>>>>>>>>>>>>>/// GET_RESULT_SET_NUM_COLS to iNumCols
76612>>>>>>>>>>>>>>>>>/// Showln iNumCols
76612>>>>>>>>>>>>>>>>>
76612>>>>>>>>>>>>>>>>>
76612>>>>>>>>>>>>>>>>>//=============================================================================
76612>>>>>>>>>>>>>>>>>/// @Name        GET_RESULT_SET_NUM_COLS
76612>>>>>>>>>>>>>>>>>/// @Description Returns the number of columns in the result set.
76612>>>>>>>>>>>>>>>>>///
76612>>>>>>>>>>>>>>>>>/// @Assumptions
76612>>>>>>>>>>>>>>>>>/// @Status      Deprecated
76612>>>>>>>>>>>>>>>>>/// @Drivers     All
76612>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-28 by Aaron Gulack
76612>>>>>>>>>>>>>>>>>/// @See                 SQL_GET_NUM_COLS
76612>>>>>>>>>>>>>>>>>///
76612>>>>>>>>>>>>>>>>>/// @Syntax GET_RESULT_SET_NUM_COLS to {variable}
76612>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the number of columns
76612>>>>>>>>>>>>>>>>>///
76612>>>>>>>>>>>>>>>>>/// @Example
76612>>>>>>>>>>>>>>>>>/// Integer iNumCols
76612>>>>>>>>>>>>>>>>>///
76612>>>>>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE FIRSTNAME = 'Aaron'"
76612>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT
76612>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
76612>>>>>>>>>>>>>>>>>/// GET_RESULT_SET_NUM_COLS to iNumCols
76612>>>>>>>>>>>>>>>>>/// Showln iNumCols
76612>>>>>>>>>>>>>>>>>
76612>>>>>>>>>>>>>>>>>//=============================================================================
76612>>>>>>>>>>>>>>>>>/// @Name        SQL_GET_NUM_ROWS
76612>>>>>>>>>>>>>>>>>/// @Description This command is used to get the number of rows retrieved
76612>>>>>>>>>>>>>>>>>/// from a result set of an SQL expression. It cannot be used when binding
76612>>>>>>>>>>>>>>>>>/// the result set to the record buffer.
76612>>>>>>>>>>>>>>>>>///
76612>>>>>>>>>>>>>>>>>/// Note: The number of rows may not always be available, depending
76612>>>>>>>>>>>>>>>>>/// on server and cursor types.
76612>>>>>>>>>>>>>>>>>///
76612>>>>>>>>>>>>>>>>>/// @Assumptions
76612>>>>>>>>>>>>>>>>>/// @Status      Public
76612>>>>>>>>>>>>>>>>>/// @Drivers     All
76612>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-30 by Aaron Gulack
76612>>>>>>>>>>>>>>>>>/// @See                 SQL_PREPARE_STMT SQL_EXECUTE_STMT
76612>>>>>>>>>>>>>>>>>///
76612>>>>>>>>>>>>>>>>>/// @Syntax SQL_GET_NUM_ROWS to {variable}
76612>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the number of rows
76612>>>>>>>>>>>>>>>>>///
76612>>>>>>>>>>>>>>>>>/// @Example
76612>>>>>>>>>>>>>>>>>/// Integer iNumRows
76612>>>>>>>>>>>>>>>>>///
76612>>>>>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
76612>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT
76612>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
76612>>>>>>>>>>>>>>>>>/// SQL_GET_NUM_ROWS to iNumRows
76612>>>>>>>>>>>>>>>>>/// Showln iNumRows
76612>>>>>>>>>>>>>>>>>
76612>>>>>>>>>>>>>>>>>
76612>>>>>>>>>>>>>>>>>//=============================================================================
76612>>>>>>>>>>>>>>>>>/// @Name        SQL_GET_COL_NAME
76612>>>>>>>>>>>>>>>>>/// @Description This command is used to retrieve the name of a specified
76612>>>>>>>>>>>>>>>>>/// column within an SQL result set. An optional second variable can be used
76612>>>>>>>>>>>>>>>>>/// to retrieve the size of the specified column. Note that this command
76612>>>>>>>>>>>>>>>>>/// cannot be used when the results are being directly binded to the record
76612>>>>>>>>>>>>>>>>>/// buffer, it can only be used for the results of an SQL statement.
76612>>>>>>>>>>>>>>>>>///
76612>>>>>>>>>>>>>>>>>/// @Assumptions
76612>>>>>>>>>>>>>>>>>/// @Status      Public
76612>>>>>>>>>>>>>>>>>/// @Drivers     All
76612>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-30 by Aaron Gulack
76612>>>>>>>>>>>>>>>>>/// @See                 SQL_GET_NUM_COLS
76612>>>>>>>>>>>>>>>>>///
76612>>>>>>>>>>>>>>>>>/// @Syntax SQL_GET_COL_NAME {columnNumber} to {variable} [{length}]
76612>>>>>>>>>>>>>>>>>/// @Param columnNumber                 The column number being used
76612>>>>>>>>>>>>>>>>>/// @Param variable                             String variable for the column name
76612>>>>>>>>>>>>>>>>>/// @Param length                       Variable to hold the column length (optional)
76612>>>>>>>>>>>>>>>>>///
76612>>>>>>>>>>>>>>>>>/// @Example
76612>>>>>>>>>>>>>>>>>/// Open Customer
76612>>>>>>>>>>>>>>>>>///
76612>>>>>>>>>>>>>>>>>/// String sColumnName
76612>>>>>>>>>>>>>>>>>/// Integer iLength
76612>>>>>>>>>>>>>>>>>///
76612>>>>>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
76612>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT
76612>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
76612>>>>>>>>>>>>>>>>>/// SQL_GET_COL_NAME 1 to sColumnName iLength
76612>>>>>>>>>>>>>>>>>/// showln sColumnName
76612>>>>>>>>>>>>>>>>>/// showln iLength
76612>>>>>>>>>>>>>>>>>
76612>>>>>>>>>>>>>>>>>
76612>>>>>>>>>>>>>>>>>//=============================================================================
76612>>>>>>>>>>>>>>>>>/// @Name        GET_RESULT_SET_COL_NAME
76612>>>>>>>>>>>>>>>>>/// @Description Returns the column name being populated from the result set.
76612>>>>>>>>>>>>>>>>>///
76612>>>>>>>>>>>>>>>>>/// @Assumptions
76612>>>>>>>>>>>>>>>>>/// @Status      Deprecated
76612>>>>>>>>>>>>>>>>>/// @Drivers     All
76612>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-30 by Aaron Gulack
76612>>>>>>>>>>>>>>>>>/// @See                 SQL_GET_COL_NAME
76612>>>>>>>>>>>>>>>>>///
76612>>>>>>>>>>>>>>>>>/// @Syntax GET_RESULT_SET_COL_NAME {columnNumber} to {variable} [{length}]
76612>>>>>>>>>>>>>>>>>/// @Param columnNumber                 The column number being used
76612>>>>>>>>>>>>>>>>>/// @Param variable                             String variable for the column name
76612>>>>>>>>>>>>>>>>>/// @Param length                       Variable receiving the column length (optional)
76612>>>>>>>>>>>>>>>>>
76612>>>>>>>>>>>>>>>>>//=============================================================================
76612>>>>>>>>>>>>>>>>>/// @Name        SQL_GET_COL_ATTRIBUTE
76612>>>>>>>>>>>>>>>>>/// @Description This command is used to get specific column information from
76612>>>>>>>>>>>>>>>>>/// the columns in a result set of an SQL statement. By passing one of the
76612>>>>>>>>>>>>>>>>>/// supported attributes below, the command will return the desired information.
76612>>>>>>>>>>>>>>>>>/// Note that some attributes only work with specific drivers. See the list
76612>>>>>>>>>>>>>>>>>/// below for more information.
76612>>>>>>>>>>>>>>>>>///
76612>>>>>>>>>>>>>>>>>/// Supported attributes are:
76612>>>>>>>>>>>>>>>>>/// <dl>
76612>>>>>>>>>>>>>>>>>/// <dt>SIZE        </dt><dd>The maximum length of the column</dd>
76612>>>>>>>>>>>>>>>>>/// <dt>DATA_LENGTH </dt><dd>Length of data currently in the column</dd>
76612>>>>>>>>>>>>>>>>>/// <dt>DECIMALS    </dt><dd>If numeric, shows number of decimal places</dd>
76612>>>>>>>>>>>>>>>>>/// <dt>LABEL       </dt><dd>Returns the column name in ORAFlex and MySQLFlex</dd>
76612>>>>>>>>>>>>>>>>>/// <dt>COLUMN_NAME </dt><dd>Returns the name of the column</dd>
76612>>>>>>>>>>>>>>>>>/// <dt>TABLE_NAME  </dt><dd>Returns the name of the table (MySQLFlex only)</dd>
76612>>>>>>>>>>>>>>>>>/// <dt>SQLTYPE     </dt><dd>Returns the number representing the SQL data type</dd>
76612>>>>>>>>>>>>>>>>>/// <dt>NULLABLE    </dt><dd>Returns true if null is allowed, false otherwise (doesn't work in PostgreSQL)</dd>
76612>>>>>>>>>>>>>>>>>/// <dt>DFTYPE      </dt><dd>Dataflex type column is mapped to</dd>
76612>>>>>>>>>>>>>>>>>/// </dl>
76612>>>>>>>>>>>>>>>>>///
76612>>>>>>>>>>>>>>>>>/// @Assumptions
76612>>>>>>>>>>>>>>>>>/// @Status      Public
76612>>>>>>>>>>>>>>>>>/// @Drivers     All
76612>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
76612>>>>>>>>>>>>>>>>>/// @See
76612>>>>>>>>>>>>>>>>>///
76612>>>>>>>>>>>>>>>>>/// @Syntax SQL_GET_COL_ATTRIBUTE of {columnNumber} {attribute} to {variable}
76612>>>>>>>>>>>>>>>>>/// @Param columnNumber                 The number of the column that is being examined
76612>>>>>>>>>>>>>>>>>/// @Param attribute                    The attribute being checked (see list)
76612>>>>>>>>>>>>>>>>>/// @Param variable                             Variable to hold the attribute value
76612>>>>>>>>>>>>>>>>>///
76612>>>>>>>>>>>>>>>>>/// @Example
76612>>>>>>>>>>>>>>>>>/// String sFirstName sLastName sColumn1Name sColumn2Name
76612>>>>>>>>>>>>>>>>>///
76612>>>>>>>>>>>>>>>>>/// Open Customer
76612>>>>>>>>>>>>>>>>>///
76612>>>>>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
76612>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT
76612>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
76612>>>>>>>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sFirstName sLastName
76612>>>>>>>>>>>>>>>>>/// If (Found) Begin
76612>>>>>>>>>>>>>>>>>///     SQL_GET_COL_ATTRIBUTE of 1 COLUMN_NAME to sColumn1Name
76612>>>>>>>>>>>>>>>>>///     SQL_GET_COL_ATTRIBUTE of 2 COLUMN_NAME to sColumn2Name
76612>>>>>>>>>>>>>>>>>///     Showln (sColumn1Name + " = " + sFirstName)
76612>>>>>>>>>>>>>>>>>///     Showln (sColumn2Name + " = " + sLastName)
76612>>>>>>>>>>>>>>>>>/// End
76612>>>>>>>>>>>>>>>>>
76612>>>>>>>>>>>>>>>>>//=============================================================================
76612>>>>>>>>>>>>>>>>>/// @Name        DDO_GET_BIND_RSPARAMETERS
76612>>>>>>>>>>>>>>>>>/// @Description Recursively calls DO_GET_BIND_RSPARAMETERS.
76612>>>>>>>>>>>>>>>>>///
76612>>>>>>>>>>>>>>>>>/// @Assumptions
76612>>>>>>>>>>>>>>>>>/// @Status      Internal
76612>>>>>>>>>>>>>>>>>/// @Drivers     All
76612>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-30 by Aaron Gulack
76612>>>>>>>>>>>>>>>>>/// @See
76612>>>>>>>>>>>>>>>>>
76612>>>>>>>>>>>>>>>>>//=============================================================================
76612>>>>>>>>>>>>>>>>>/// @Name        DO_GET_BIND_RSPARAMETERS
76612>>>>>>>>>>>>>>>>>/// @Description Gets bound parameters values for result set call.
76612>>>>>>>>>>>>>>>>>///
76612>>>>>>>>>>>>>>>>>/// @Assumptions
76612>>>>>>>>>>>>>>>>>/// @Status      Internal
76612>>>>>>>>>>>>>>>>>/// @Drivers     All
76612>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-30 by Aaron Gulack
76612>>>>>>>>>>>>>>>>>/// @See
76612>>>>>>>>>>>>>>>>>
76612>>>>>>>>>>>>>>>>>Function MertechInc_DO_GET_BIND_RSPARAMETERS Global Integer iWhichParam Returns String
76614>>>>>>>>>>>>>>>>>    String sReturnValue
76614>>>>>>>>>>>>>>>>>
76614>>>>>>>>>>>>>>>>>    Get Value of (oMertechInc_Work(Current_Object)) item iWhichParam to MertechInc_iWork
76615>>>>>>>>>>>>>>>>>    If MertechInc_iWork lt 16384 ;        Move (Repeat("                                ", ((MertechInc_iWork/32)+1))) to sReturnValue
76618>>>>>>>>>>>>>>>>>    Else Get psWork of oMertechInc_Work to sReturnValue
76620>>>>>>>>>>>>>>>>>
76620>>>>>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function 24 CALLBACK 0 PASSING sReturnValue MertechInc_Blank (|CI$10000 * iWhichParam) RESULT MertechInc_iRet
76625>>>>>>>>>>>>>>>>>
76625>>>>>>>>>>>>>>>>>    Function_Return sReturnValue
76626>>>>>>>>>>>>>>>>>End_Function
76627>>>>>>>>>>>>>>>>>
76627>>>>>>>>>>>>>>>>>
76627>>>>>>>>>>>>>>>>>//=============================================================================
76627>>>>>>>>>>>>>>>>>/// @Name        SQL_NEXT_RESULT_SET
76627>>>>>>>>>>>>>>>>>/// @Description This command is used when working with SQL statements that
76627>>>>>>>>>>>>>>>>>/// return multiple result sets. In that scenario, calling this command will
76627>>>>>>>>>>>>>>>>>/// move to the next result set. That set can now be fetched or binded to
76627>>>>>>>>>>>>>>>>>/// columns on a table.
76627>>>>>>>>>>>>>>>>>///
76627>>>>>>>>>>>>>>>>>/// @See
76627>>>>>>>>>>>>>>>>>/// @Status      Public
76627>>>>>>>>>>>>>>>>>/// @Drivers     All
76627>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-02 by Aaron Gulack
76627>>>>>>>>>>>>>>>>>/// @See
76627>>>>>>>>>>>>>>>>>///
76627>>>>>>>>>>>>>>>>>/// @Syntax SQL_NEXT_RESULT_SET [of {file}]
76627>>>>>>>>>>>>>>>>>/// @Param file                 Name or number of the file (optional)
76627>>>>>>>>>>>>>>>>>///
76627>>>>>>>>>>>>>>>>>/// @Example
76627>>>>>>>>>>>>>>>>>/// SQL_SET_STMT to "SP_HELP CUSTOMER"
76627>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT
76627>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
76627>>>>>>>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sTable sOwner sTableType dtCreated
76627>>>>>>>>>>>>>>>>>/// If (Found) Begin
76627>>>>>>>>>>>>>>>>>///     Showln sTable
76627>>>>>>>>>>>>>>>>>///     Showln sOwner
76627>>>>>>>>>>>>>>>>>///     Showln sTableType
76627>>>>>>>>>>>>>>>>>///     Showln dtCreated
76627>>>>>>>>>>>>>>>>>/// End
76627>>>>>>>>>>>>>>>>>/// SQL_NEXT_RESULT_SET
76627>>>>>>>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sColumnName sColumnType sComputed sLength
76627>>>>>>>>>>>>>>>>>/// If (Found) Begin
76627>>>>>>>>>>>>>>>>>///     Showln sColumnName
76627>>>>>>>>>>>>>>>>>///     Showln sColumnType
76627>>>>>>>>>>>>>>>>>///     Showln sComputed
76627>>>>>>>>>>>>>>>>>///     Showln sLength
76627>>>>>>>>>>>>>>>>>/// End
76627>>>>>>>>>>>>>>>>>
76627>>>>>>>>>>>>>>>>>//=============================================================================
76627>>>>>>>>>>>>>>>>>/// @Name        DDO_PASS_ARGUMENTS
76627>>>>>>>>>>>>>>>>>/// @Description Calls DO_PASS_ARGUMENTS until the argument is "BINDING" and
76627>>>>>>>>>>>>>>>>>/// then stops.
76627>>>>>>>>>>>>>>>>>///
76627>>>>>>>>>>>>>>>>>/// @Assumptions
76627>>>>>>>>>>>>>>>>>/// @Status      Internal
76627>>>>>>>>>>>>>>>>>/// @Drivers     All
76627>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
76627>>>>>>>>>>>>>>>>>/// @See
76627>>>>>>>>>>>>>>>>>
76627>>>>>>>>>>>>>>>>>//=============================================================================
76627>>>>>>>>>>>>>>>>>/// @Name        DO_PASS_ARGUMENTS
76627>>>>>>>>>>>>>>>>>/// @Description Builds parameter statements for stored procedures and adds
76627>>>>>>>>>>>>>>>>>/// them to the current query.
76627>>>>>>>>>>>>>>>>>///
76627>>>>>>>>>>>>>>>>>/// @Assumptions
76627>>>>>>>>>>>>>>>>>/// @Status      internal
76627>>>>>>>>>>>>>>>>>/// @Drivers     All
76627>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
76627>>>>>>>>>>>>>>>>>/// @See
76627>>>>>>>>>>>>>>>>>
76627>>>>>>>>>>>>>>>>>//=============================================================================
76627>>>>>>>>>>>>>>>>>/// @Name        DDO_BIND_PARAMETERS
76627>>>>>>>>>>>>>>>>>/// @Description Recursively calls DO_BIND_PARAMETERS until the keyword
76627>>>>>>>>>>>>>>>>>/// "BINDING" is encountered.
76627>>>>>>>>>>>>>>>>>///
76627>>>>>>>>>>>>>>>>>/// @Assumptions
76627>>>>>>>>>>>>>>>>>/// @Status      Internal
76627>>>>>>>>>>>>>>>>>/// @Drivers     All
76627>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
76627>>>>>>>>>>>>>>>>>/// @See
76627>>>>>>>>>>>>>>>>>
76627>>>>>>>>>>>>>>>>>//=============================================================================
76627>>>>>>>>>>>>>>>>>/// @Name        DO_BIND_PARAMETERS
76627>>>>>>>>>>>>>>>>>/// @Description Binds parameters for a stored procedure call.
76627>>>>>>>>>>>>>>>>>///
76627>>>>>>>>>>>>>>>>>/// @Assumptions
76627>>>>>>>>>>>>>>>>>/// @Status      Internal
76627>>>>>>>>>>>>>>>>>/// @Drivers     All
76627>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
76627>>>>>>>>>>>>>>>>>/// @See
76627>>>>>>>>>>>>>>>>>
76627>>>>>>>>>>>>>>>>>Procedure MertechInc_DO_BIND_PARAMETERS Global String sValue String sName Integer iLength
76629>>>>>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_BIND_PARAMETER CALLBACK 0 PASSING sValue sName iLength RESULT MertechInc_iRet
76634>>>>>>>>>>>>>>>>>End_Procedure
76635>>>>>>>>>>>>>>>>>
76635>>>>>>>>>>>>>>>>>//=============================================================================
76635>>>>>>>>>>>>>>>>>/// @Name        DO_BIND_PAR_RET
76635>>>>>>>>>>>>>>>>>/// @Description Binds parameters for a stored procedure call.
76635>>>>>>>>>>>>>>>>>///
76635>>>>>>>>>>>>>>>>>/// @Assumptions
76635>>>>>>>>>>>>>>>>>/// @Status      Internal
76635>>>>>>>>>>>>>>>>>/// @Drivers     OraFlex
76635>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
76635>>>>>>>>>>>>>>>>>/// @See
76635>>>>>>>>>>>>>>>>>
76635>>>>>>>>>>>>>>>>>//=============================================================================
76635>>>>>>>>>>>>>>>>>/// @Name        DDO_GET_BIND_PARAMETERS
76635>>>>>>>>>>>>>>>>>/// @Description Recursively calls DO_GET_BIND_PARAMETERS.
76635>>>>>>>>>>>>>>>>>///
76635>>>>>>>>>>>>>>>>>/// @Assumptions
76635>>>>>>>>>>>>>>>>>/// @Status      Internal
76635>>>>>>>>>>>>>>>>>/// @Drivers     All
76635>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
76635>>>>>>>>>>>>>>>>>/// @See
76635>>>>>>>>>>>>>>>>>
76635>>>>>>>>>>>>>>>>>//=============================================================================
76635>>>>>>>>>>>>>>>>>/// @Name        DO_GET_BIND_PARAMETERS
76635>>>>>>>>>>>>>>>>>/// @Description Gets bound parameter values for a stored procedure call.
76635>>>>>>>>>>>>>>>>>///
76635>>>>>>>>>>>>>>>>>/// @Assumptions
76635>>>>>>>>>>>>>>>>>/// @Status      Internal
76635>>>>>>>>>>>>>>>>>/// @Drivers     All
76635>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
76635>>>>>>>>>>>>>>>>>/// @See
76635>>>>>>>>>>>>>>>>>
76635>>>>>>>>>>>>>>>>>Function MertechInc_DO_GET_BIND_PARAMETERS Global Integer bSQLFlex String sArg1 String sArg2 Integer iArg Returns String
76637>>>>>>>>>>>>>>>>>    String sReturnValue
76637>>>>>>>>>>>>>>>>>    Integer iSize
76637>>>>>>>>>>>>>>>>>
76637>>>>>>>>>>>>>>>>>    if (MertechInc_DriverName = SQLFLEX) ;                move (iArg+1) to iArg
76640>>>>>>>>>>>>>>>>>//        SQL_GET_COL_ATTRIBUTE of iArg DATA_LENGTH to iSize
76640>>>>>>>>>>>>>>>>>
76640>>>>>>>>>>>>>>>>>    Get MertechInc_Pre_Size_String (iSize+1) to sReturnValue
76641>>>>>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function 24 CALLBACK 0 PASSING sReturnValue MertechInc_Blank iArg RESULT MertechInc_iRet
76646>>>>>>>>>>>>>>>>>
76646>>>>>>>>>>>>>>>>>    Function_Return sReturnValue
76647>>>>>>>>>>>>>>>>>End_Function
76648>>>>>>>>>>>>>>>>>
76648>>>>>>>>>>>>>>>>>//=============================================================================
76648>>>>>>>>>>>>>>>>>/// @Name        SQL_GET_OUTPUT_VALUE
76648>>>>>>>>>>>>>>>>>/// @Description This command is used to get the value of a specific
76648>>>>>>>>>>>>>>>>>/// parameter associated with a stored procedure.  Although this
76648>>>>>>>>>>>>>>>>>/// command will work with any parameter, it is mostly used with
76648>>>>>>>>>>>>>>>>>/// IN/OUT or OUT parameters as their value will more often be important
76648>>>>>>>>>>>>>>>>>/// once returned. When multiple values are returned, this command can be
76648>>>>>>>>>>>>>>>>>/// more efficient than other options. Note that the specified parameter
76648>>>>>>>>>>>>>>>>>/// must first be defined using the SQL_SET_PROCEDURE_PARAMETER command
76648>>>>>>>>>>>>>>>>>/// in order to work properly.
76648>>>>>>>>>>>>>>>>>///
76648>>>>>>>>>>>>>>>>>/// @Assumptions
76648>>>>>>>>>>>>>>>>>/// @Status      Deprecated
76648>>>>>>>>>>>>>>>>>/// @Drivers     All
76648>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
76648>>>>>>>>>>>>>>>>>/// @See                 SQL_GET_PROCEDURE_PARAMETER
76648>>>>>>>>>>>>>>>>>///
76648>>>>>>>>>>>>>>>>>/// @Syntax SQL_GET_OUTPUT_VALUE {parameter} to {variable}
76648>>>>>>>>>>>>>>>>>/// @Param parameter            Number of the parameter
76648>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the parameter's value
76648>>>>>>>>>>>>>>>>>///
76648>>>>>>>>>>>>>>>>>/// @Example
76648>>>>>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_NAME "user.getCustomerStatus" NUMPAR 1
76648>>>>>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 1 to sCustomerID IN_OUT
76648>>>>>>>>>>>>>>>>>/// SQL_PROCEDURE_EXECUTE
76648>>>>>>>>>>>>>>>>>/// SQL_GET_OUTPUT_VALUE 1 to sStatus
76648>>>>>>>>>>>>>>>>>///
76648>>>>>>>>>>>>>>>>>/// Showln sStatus
76648>>>>>>>>>>>>>>>>>///
76648>>>>>>>>>>>>>>>>>/// @Example
76648>>>>>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_NAME "user.getCustomerStatus" NUMPAR 2
76648>>>>>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 1 to sCustomerID IN
76648>>>>>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 2 to sStatus OUT
76648>>>>>>>>>>>>>>>>>/// SQL_PROCEDURE_EXECUTE
76648>>>>>>>>>>>>>>>>>/// SQL_GET_OUTPUT_VALUE 2 to sStatus
76648>>>>>>>>>>>>>>>>>///
76648>>>>>>>>>>>>>>>>>/// Showln sStatus
76648>>>>>>>>>>>>>>>>>// OLI:
76648>>>>>>>>>>>>>>>>>// This function is identical in operation to SQL_GET_PROCEDURE_PARAMETER, so just do a replace
76648>>>>>>>>>>>>>>>>>
76648>>>>>>>>>>>>>>>>>//=============================================================================
76648>>>>>>>>>>>>>>>>>/// @Name        SQL_FETCH_COLUMN
76648>>>>>>>>>>>>>>>>>/// @Description This command is used to retrieve a specified column from a
76648>>>>>>>>>>>>>>>>>/// result set of an SQL statement. Note that this command cannot be used to
76648>>>>>>>>>>>>>>>>>/// replace SQL_FETCH_NEXT_ROW but is used in addition to it when only one
76648>>>>>>>>>>>>>>>>>/// column is needed. For most cases, SQL_FETCH_NEXT_ROW can be used alone
76648>>>>>>>>>>>>>>>>>/// to retrieve the columns desired so this should only be used if there is
76648>>>>>>>>>>>>>>>>>/// a specific reason to do so.
76648>>>>>>>>>>>>>>>>>///
76648>>>>>>>>>>>>>>>>>/// @Assumptions
76648>>>>>>>>>>>>>>>>>/// @Status      Public
76648>>>>>>>>>>>>>>>>>/// @Drivers     All
76648>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
76648>>>>>>>>>>>>>>>>>/// @See                 SQL_FETCH_NEXT_ROW
76648>>>>>>>>>>>>>>>>>///
76648>>>>>>>>>>>>>>>>>/// @Syntax SQL_FETCH_COLUMN {columnNumber} into {variable}
76648>>>>>>>>>>>>>>>>>/// @Param columnNumber    Number of the column to fetch
76648>>>>>>>>>>>>>>>>>/// @Param variable        Variable to hold the fetched value
76648>>>>>>>>>>>>>>>>>///
76648>>>>>>>>>>>>>>>>>/// @Example
76648>>>>>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
76648>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT
76648>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
76648>>>>>>>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW
76648>>>>>>>>>>>>>>>>>/// SQL_GET_NUM_COLS to iCols
76648>>>>>>>>>>>>>>>>>/// For fieldIndex from 1 to iCols
76648>>>>>>>>>>>>>>>>>///     SQL_FETCH_COLUMN fieldIndex into sValue
76648>>>>>>>>>>>>>>>>>///     Showln sValue
76648>>>>>>>>>>>>>>>>>/// Loop
76648>>>>>>>>>>>>>>>>>
76648>>>>>>>>>>>>>>>>>Function MertechInc_SQL_FETCH_COLUMN Global String sArg1 String sArg2 Integer iArg Returns String
76650>>>>>>>>>>>>>>>>>    String sReturnValue
76650>>>>>>>>>>>>>>>>>    Integer iSize
76650>>>>>>>>>>>>>>>>>
76650>>>>>>>>>>>>>>>>>    Move 0 to iSize
76651>>>>>>>>>>>>>>>>>        SQL_GET_COL_ATTRIBUTE of iArg DATA_LENGTH to iSize
76692>>>>>>>>>>>>>>>>>>
76692>>>>>>>>>>>>>>>>>
76692>>>>>>>>>>>>>>>>>    Get MertechInc_Pre_Size_String (iSize+1) to sReturnValue
76693>>>>>>>>>>>>>>>>>    Move (|CI$10000 * iArg) to iArg // Shift column number 16 bits to the left
76694>>>>>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function 24 CALLBACK 0 PASSING sReturnValue MertechInc_Blank iArg RESULT MertechInc_iRet
76699>>>>>>>>>>>>>>>>>
76699>>>>>>>>>>>>>>>>>    Function_Return sReturnValue
76700>>>>>>>>>>>>>>>>>End_Function
76701>>>>>>>>>>>>>>>>>
76701>>>>>>>>>>>>>>>>>//=============================================================================
76701>>>>>>>>>>>>>>>>>/// @Name        SET_SCHEMA_NAME
76701>>>>>>>>>>>>>>>>>/// @Description This command is used to set the schema name to be used when
76701>>>>>>>>>>>>>>>>>/// opening tables. Note that this command will override the schema name that
76701>>>>>>>>>>>>>>>>>/// is set in the INT file.  The default schema for the current user is used
76701>>>>>>>>>>>>>>>>>/// when no name is set.
76701>>>>>>>>>>>>>>>>>///
76701>>>>>>>>>>>>>>>>>/// @Assumptions
76701>>>>>>>>>>>>>>>>>/// @Status      Public
76701>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex and ORAFlex
76701>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-24 by Aaron Gulack
76701>>>>>>>>>>>>>>>>>/// @See                 GET_SCHEMA_NAME
76701>>>>>>>>>>>>>>>>>///
76701>>>>>>>>>>>>>>>>>/// @Syntax SET_SCHEMA_NAME to {schema}
76701>>>>>>>>>>>>>>>>>/// @Param variable                     Name of the schema
76701>>>>>>>>>>>>>>>>>///
76701>>>>>>>>>>>>>>>>>/// @Example
76701>>>>>>>>>>>>>>>>>/// SET_SCHEMA_NAME to 'CustomerSchema'
76701>>>>>>>>>>>>>>>>>/// OPEN "CUSTOMER.INT" as CUSTOMER
76701>>>>>>>>>>>>>>>>>/// SET_SCHEMA_NAME to 'SalesSchema'
76701>>>>>>>>>>>>>>>>>/// OPEN "SALESP.INT" as SALESP
76701>>>>>>>>>>>>>>>>>
76701>>>>>>>>>>>>>>>>>//=============================================================================
76701>>>>>>>>>>>>>>>>>/// @Name        GET_SCHEMA_NAME
76701>>>>>>>>>>>>>>>>>/// @Description This command is used to get the name of the schema being
76701>>>>>>>>>>>>>>>>>/// used to open tables.
76701>>>>>>>>>>>>>>>>>///
76701>>>>>>>>>>>>>>>>>/// @Assumptions
76701>>>>>>>>>>>>>>>>>/// @Status      Public
76701>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex and ORAFlex
76701>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-24 by Aaron Gulack
76701>>>>>>>>>>>>>>>>>/// @See                 SET_SCHEMA_NAME
76701>>>>>>>>>>>>>>>>>///
76701>>>>>>>>>>>>>>>>>/// @Syntax GET_SCHEMA_NAME to {variable}
76701>>>>>>>>>>>>>>>>>/// @Param variable                     variable to hold the schema name
76701>>>>>>>>>>>>>>>>>///
76701>>>>>>>>>>>>>>>>>/// @Example
76701>>>>>>>>>>>>>>>>>/// GET_SCHEMA_NAME to sName
76701>>>>>>>>>>>>>>>>>/// Showln sName
76701>>>>>>>>>>>>>>>>>
76701>>>>>>>>>>>>>>>>>//=============================================================================
76701>>>>>>>>>>>>>>>>>/// @Name        CALL_ORACLE_STORED_PROCEDURE
76701>>>>>>>>>>>>>>>>>/// @Description This command is used to call a stored procedure on the SQL
76701>>>>>>>>>>>>>>>>>/// backend. To successfully call a procedure with this command, a string
76701>>>>>>>>>>>>>>>>>/// must be passed containing a valid procedure name. In addition, if the
76701>>>>>>>>>>>>>>>>>/// procedure takes any arguments, they must also be passed using the constant
76701>>>>>>>>>>>>>>>>>/// "passing" along with all of the needed arguments. If the procedure has a
76701>>>>>>>>>>>>>>>>>/// return value, then SQL_GET_FUNCTION_RETURN or SQL_FETCH_NEXT_ROW can be
76701>>>>>>>>>>>>>>>>>/// used to get the value(s). If an error is found then the indicator "Err"
76701>>>>>>>>>>>>>>>>>/// is set to true.
76701>>>>>>>>>>>>>>>>>///
76701>>>>>>>>>>>>>>>>>/// @Assumptions
76701>>>>>>>>>>>>>>>>>/// @Status      Deprecated
76701>>>>>>>>>>>>>>>>>/// @Drivers     ORAFLex
76701>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-25 by Aaron Gulack
76701>>>>>>>>>>>>>>>>>/// @See                 CALL_STORED_PROCEDURE
76701>>>>>>>>>>>>>>>>>///
76701>>>>>>>>>>>>>>>>>/// @Syntax CALL_ORACLE_STORED_PROCEDURE {procedure} Passing {variable}
76701>>>>>>>>>>>>>>>>>/// @Param procedure            Full name of the procedure
76701>>>>>>>>>>>>>>>>>/// @Param variable                     Argument being passed to procedure (can be multiple)
76701>>>>>>>>>>>>>>>>>///
76701>>>>>>>>>>>>>>>>>/// @Example
76701>>>>>>>>>>>>>>>>>/// CALL_ORACLE_STORED_PROCEDURE "sys.sp_addmessage" passing 50003 15 "Please enter a valid date"
76701>>>>>>>>>>>>>>>>>
76701>>>>>>>>>>>>>>>>>//=============================================================================
76701>>>>>>>>>>>>>>>>>/// @Name        SQL_SET_PROCEDURE_NAME
76701>>>>>>>>>>>>>>>>>/// @Description This command is used to set the procedure to be executed.
76701>>>>>>>>>>>>>>>>>/// This is used when the procedure is being split up into multiple lines
76701>>>>>>>>>>>>>>>>>/// as shown below. When using this command, SQL_PROCEDURE_EXECUTE must be
76701>>>>>>>>>>>>>>>>>/// called after all parameters have been set to successfully execute the
76701>>>>>>>>>>>>>>>>>/// procedure. The constant "NUMPAR" is used to indicate how many parameters
76701>>>>>>>>>>>>>>>>>/// will be passed.
76701>>>>>>>>>>>>>>>>>///
76701>>>>>>>>>>>>>>>>>/// @Assumptions The procedure is a valid procedure in the SQL database
76701>>>>>>>>>>>>>>>>>/// @Status      Public
76701>>>>>>>>>>>>>>>>>/// @Drivers     All
76701>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-25 by Aaron Gulack
76701>>>>>>>>>>>>>>>>>/// @See                 SQL_SET_PROCEDURE_PARAMETER SQL_PROCEDURE_EXECUTE
76701>>>>>>>>>>>>>>>>>///
76701>>>>>>>>>>>>>>>>>/// @Syntax SQL_SET_PROCEDURE_NAME {procedure} NUMPAR {variable}
76701>>>>>>>>>>>>>>>>>/// @Param procedure            Full name of the procedure
76701>>>>>>>>>>>>>>>>>/// @Param variable                     Number of parameters to be passed
76701>>>>>>>>>>>>>>>>>///
76701>>>>>>>>>>>>>>>>>/// @Example
76701>>>>>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_NAME "sys.sp_addmessage" NUMPAR 3
76701>>>>>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 1 to 500004 IN
76701>>>>>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 2 to 15 IN
76701>>>>>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 3 to "Please enter a valid Date" IN
76701>>>>>>>>>>>>>>>>>/// SQL_PROCEDURE_EXECUTE
76701>>>>>>>>>>>>>>>>>
76701>>>>>>>>>>>>>>>>>
76701>>>>>>>>>>>>>>>>>Procedure MertechInc_SQL_SET_ORAPROCEDURE_NAME Global String strProcName Integer iNumpar
76703>>>>>>>>>>>>>>>>>    Integer iParam
76703>>>>>>>>>>>>>>>>>
76703>>>>>>>>>>>>>>>>>    Move 0 to MertechInc_iParamCount       //Redundant, but left in incase called
76704>>>>>>>>>>>>>>>>>    INDICATE ERR False              //directly and not via SQL_SET_PROCEDURE_NAME
76705>>>>>>>>>>>>>>>>>    Move ORAFlex to MertechInc_DriverName  //
76706>>>>>>>>>>>>>>>>>
76706>>>>>>>>>>>>>>>>>    SQL_SET_STMT to "BEGIN "
76738>>>>>>>>>>>>>>>>>    SQL_APPEND_STMT to strProcName
76770>>>>>>>>>>>>>>>>>    SQL_APPEND_STMT to "( "
76802>>>>>>>>>>>>>>>>>    For iParam from 1 to iNumpar
76808>>>>>>>>>>>>>>>>>>
76808>>>>>>>>>>>>>>>>>        DO_PASS_ARGUMENTS iParam
76887>>>>>>>>>>>>>>>>>    Loop
76888>>>>>>>>>>>>>>>>>>
76888>>>>>>>>>>>>>>>>>    SQL_APPEND_STMT to  " ); END;"
76920>>>>>>>>>>>>>>>>>    SQL_PREPARE_STMT
76969>>>>>>>>>>>>>>>>> End_Procedure
76970>>>>>>>>>>>>>>>>>
76970>>>>>>>>>>>>>>>>>Procedure MertechInc_SQL_SET_MYPROCEDURE_NAME Global String strProcName Integer iNumpar
76972>>>>>>>>>>>>>>>>>    Integer iParam
76972>>>>>>>>>>>>>>>>>
76972>>>>>>>>>>>>>>>>>    Move 0 to MertechInc_iParamCount           //Redundant, but left in incase called
76973>>>>>>>>>>>>>>>>>    INDICATE ERR False                  //directly and not via SQL_SET_PROCEDURE_NAME
76974>>>>>>>>>>>>>>>>>    Move MySQLFlex to MertechInc_DriverName    //
76975>>>>>>>>>>>>>>>>>
76975>>>>>>>>>>>>>>>>>    SQL_SET_STMT to "CALL "
77007>>>>>>>>>>>>>>>>>    SQL_APPEND_STMT to strProcName
77039>>>>>>>>>>>>>>>>>    SQL_APPEND_STMT to "("
77071>>>>>>>>>>>>>>>>>    For iParam from 1 to iNumpar
77077>>>>>>>>>>>>>>>>>>
77077>>>>>>>>>>>>>>>>>        DO_PASS_ARGUMENTS iParam
77156>>>>>>>>>>>>>>>>>    Loop
77157>>>>>>>>>>>>>>>>>>
77157>>>>>>>>>>>>>>>>>    SQL_APPEND_STMT to ")"
77189>>>>>>>>>>>>>>>>>    SQL_PREPARE_STMT
77238>>>>>>>>>>>>>>>>>End_Procedure
77239>>>>>>>>>>>>>>>>>
77239>>>>>>>>>>>>>>>>>Procedure MertechInc_SQL_SET_MSPROCEDURE_NAME Global String strProcName Integer iNumpar
77241>>>>>>>>>>>>>>>>>    Integer iParam
77241>>>>>>>>>>>>>>>>>    String  sParam
77241>>>>>>>>>>>>>>>>>
77241>>>>>>>>>>>>>>>>>    Move SQLFlex to MertechInc_DriverName
77242>>>>>>>>>>>>>>>>>
77242>>>>>>>>>>>>>>>>>    // This calling syntax is referred to as the "ODBC CALL escape sequence".  This syntax is
77242>>>>>>>>>>>>>>>>>    // advised over the execute command since CALL allows for the retrieval of the return codes
77242>>>>>>>>>>>>>>>>>    // from the call.
77242>>>>>>>>>>>>>>>>>    SQL_SET_STMT to "{? = CALL "
77274>>>>>>>>>>>>>>>>>    SQL_APPEND_STMT to strProcName
77306>>>>>>>>>>>>>>>>>
77306>>>>>>>>>>>>>>>>>    // Note that DO_PASS_ARGUMENTS can add the open paren for us, but only if the keyword "PASSING"
77306>>>>>>>>>>>>>>>>>    // is passed to it first time through.  This is a bit weird, so we ignore that and just add
77306>>>>>>>>>>>>>>>>>    // the open and close parens ourself to make things more clear.
77306>>>>>>>>>>>>>>>>>    If (iNumpar > 0) SQL_APPEND_STMT to " ("
77340>>>>>>>>>>>>>>>>>
77340>>>>>>>>>>>>>>>>>    For iParam from 1 to iNumpar
77346>>>>>>>>>>>>>>>>>>
77346>>>>>>>>>>>>>>>>>        DO_PASS_ARGUMENTS iParam
77425>>>>>>>>>>>>>>>>>    Loop
77426>>>>>>>>>>>>>>>>>>
77426>>>>>>>>>>>>>>>>>
77426>>>>>>>>>>>>>>>>>    If (iNumpar > 0) SQL_APPEND_STMT to ")"
77460>>>>>>>>>>>>>>>>>    SQL_APPEND_STMT to  " };"
77492>>>>>>>>>>>>>>>>>
77492>>>>>>>>>>>>>>>>>    SQL_PREPARE_STMT CURSOR_TYPE TYPE_NONE
77548>>>>>>>>>>>>>>>>>
77548>>>>>>>>>>>>>>>>>    // This bind parameter is for the "{? = " which is technically the first parameter even though
77548>>>>>>>>>>>>>>>>>    // it is the return value.  The driver will bind MertechInc_iWork to it.
77548>>>>>>>>>>>>>>>>>    DO_BIND_PARAMETERS MertechInc_iWork
77571>>>>>>>>>>>>>>>>>End_Procedure
77572>>>>>>>>>>>>>>>>>
77572>>>>>>>>>>>>>>>>>Procedure MertechInc_SQL_SET_PGPROCEDURE_NAME Global String strProcName Integer iNumpar
77574>>>>>>>>>>>>>>>>>    Integer iParam
77574>>>>>>>>>>>>>>>>>    String  sParam
77574>>>>>>>>>>>>>>>>>
77574>>>>>>>>>>>>>>>>>    Move PgFlex to MertechInc_DriverName
77575>>>>>>>>>>>>>>>>>
77575>>>>>>>>>>>>>>>>>    // For Postgres, you can call a function just by passing the function name and
77575>>>>>>>>>>>>>>>>>    // open/close parens
77575>>>>>>>>>>>>>>>>>    SQL_SET_STMT to strProcName
77607>>>>>>>>>>>>>>>>>
77607>>>>>>>>>>>>>>>>>    // Note that DO_PASS_ARGUMENTS can add the open paren for us, but only if the keyword "PASSING"
77607>>>>>>>>>>>>>>>>>    // is passed to it first time through.  This is a bit weird, so we ignore that and just add
77607>>>>>>>>>>>>>>>>>    // the open and close parens ourself to make things more clear.
77607>>>>>>>>>>>>>>>>>    SQL_APPEND_STMT to "( "
77639>>>>>>>>>>>>>>>>>
77639>>>>>>>>>>>>>>>>>    For iParam from 1 to iNumpar
77645>>>>>>>>>>>>>>>>>>
77645>>>>>>>>>>>>>>>>>        DO_PASS_ARGUMENTS iParam
77724>>>>>>>>>>>>>>>>>    Loop
77725>>>>>>>>>>>>>>>>>>
77725>>>>>>>>>>>>>>>>>
77725>>>>>>>>>>>>>>>>>    SQL_APPEND_STMT to ")"
77757>>>>>>>>>>>>>>>>>
77757>>>>>>>>>>>>>>>>>    SQL_PREPARE_STMT
77806>>>>>>>>>>>>>>>>>    // Indicate that a stored function will be executed - Query = 0, Procedure = 1, Function = 2
77806>>>>>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_EMBEDDED_SQL_TYPE CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank 1 RESULT MertechInc_iRet
77811>>>>>>>>>>>>>>>>>End_Procedure
77812>>>>>>>>>>>>>>>>>
77812>>>>>>>>>>>>>>>>>//=============================================================================
77812>>>>>>>>>>>>>>>>>/// @Name        SQL_GET_STMT
77812>>>>>>>>>>>>>>>>>/// @Description This command returns the last embedded SQL statement that
77812>>>>>>>>>>>>>>>>>/// was executed into a string. Optional parameters can be passed to specify
77812>>>>>>>>>>>>>>>>>/// what character to start the string at and also the maximum number of
77812>>>>>>>>>>>>>>>>>/// characters to allow for the string.
77812>>>>>>>>>>>>>>>>>///
77812>>>>>>>>>>>>>>>>>/// @Assumptions
77812>>>>>>>>>>>>>>>>>/// @Status      Public
77812>>>>>>>>>>>>>>>>>/// @Drivers     All
77812>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-24 by Aaron Gulack
77812>>>>>>>>>>>>>>>>>/// @See                 SQL_GET_STATEMENT
77812>>>>>>>>>>>>>>>>>///
77812>>>>>>>>>>>>>>>>>/// @Syntax SQL_GET_STMT to {variable} [{max} {start}]
77812>>>>>>>>>>>>>>>>>/// @Param variable                     SQL statement to be executed
77812>>>>>>>>>>>>>>>>>/// @Param max                          Indicates the maximum number of characters to get (optional)
77812>>>>>>>>>>>>>>>>>/// @Param start                        Indicates what character to start at for the returned string (optional)
77812>>>>>>>>>>>>>>>>>///
77812>>>>>>>>>>>>>>>>>/// @Example
77812>>>>>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
77812>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT
77812>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
77812>>>>>>>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sFirstName sLastName
77812>>>>>>>>>>>>>>>>>/// If (Found) Begin
77812>>>>>>>>>>>>>>>>>///     Showln sFirstName
77812>>>>>>>>>>>>>>>>>///     Showln sLastName
77812>>>>>>>>>>>>>>>>>/// End
77812>>>>>>>>>>>>>>>>>///
77812>>>>>>>>>>>>>>>>>/// SQL_GET_STATEMENT to sValue
77812>>>>>>>>>>>>>>>>>/// Showln sValue
77812>>>>>>>>>>>>>>>>>
77812>>>>>>>>>>>>>>>>>
77812>>>>>>>>>>>>>>>>>Function MertechInc_SQL_GET_STATEMENT Global Integer iLength Integer iStart Returns String
77814>>>>>>>>>>>>>>>>>    String sStatement
77814>>>>>>>>>>>>>>>>>
77814>>>>>>>>>>>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
77840>>>>>>>>>>>>>>>>>>
77840>>>>>>>>>>>>>>>>>
77840>>>>>>>>>>>>>>>>>    If (MertechInc_FileNumber <> -1) Begin
77842>>>>>>>>>>>>>>>>>        Get MertechInc_Pre_Size_String 0 to sStatement
77843>>>>>>>>>>>>>>>>>        Call_Driver 0 MertechInc_DriverName Function CALLDRV_GET_SQL_STMT CALLBACK 0 PASSING sStatement iStart iLength RESULT MertechInc_iRet
77848>>>>>>>>>>>>>>>>>    End
77848>>>>>>>>>>>>>>>>>>
77848>>>>>>>>>>>>>>>>>    Function_Return sStatement
77849>>>>>>>>>>>>>>>>>End_Function
77850>>>>>>>>>>>>>>>>>
77850>>>>>>>>>>>>>>>>>//=============================================================================
77850>>>>>>>>>>>>>>>>>/// @Name        SQL_SET_FUNCTION_NAME
77850>>>>>>>>>>>>>>>>>/// @Description This command is used in the same way as SQL_SET_PROCEDURE_NAME
77850>>>>>>>>>>>>>>>>>/// and SQL_SET_STMT to set the name of the function to be executed. When
77850>>>>>>>>>>>>>>>>>/// calling SQL functions in this fashion, this command must be used along with
77850>>>>>>>>>>>>>>>>>/// SQL_FUNCTION_EXECUTE (to execute the function), SQL_SET_FUNCTION_PARAMETER
77850>>>>>>>>>>>>>>>>>/// (to set the needed parameters) and SQL_GET_FUNCTION_RETURN (to get any
77850>>>>>>>>>>>>>>>>>/// returned value). The number of parameters must be set using the constant,
77850>>>>>>>>>>>>>>>>>/// NUMPAR, followed by the number of parameters. Note that when setting the
77850>>>>>>>>>>>>>>>>>/// name of the function, the user can be specified or, if left blank, the
77850>>>>>>>>>>>>>>>>>/// current user will be inserted before the function name.
77850>>>>>>>>>>>>>>>>>///
77850>>>>>>>>>>>>>>>>>/// @Assumptions
77850>>>>>>>>>>>>>>>>>/// @Status      Public
77850>>>>>>>>>>>>>>>>>/// @Drivers     All
77850>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
77850>>>>>>>>>>>>>>>>>/// @See                 SQL_FUNCTION_EXECUTE SQL_SET_FUNCTION_PARAMETER SQL_GET_FUNCTION_RETURN
77850>>>>>>>>>>>>>>>>>///
77850>>>>>>>>>>>>>>>>>/// @Syntax SQL_SET_FUNCTION_NAME {function} NUMPAR {parameters}
77850>>>>>>>>>>>>>>>>>/// @Param function                     Full name of the function
77850>>>>>>>>>>>>>>>>>/// @Param parameters           Number of parameters to pass
77850>>>>>>>>>>>>>>>>>///
77850>>>>>>>>>>>>>>>>>/// @Example
77850>>>>>>>>>>>>>>>>>/// SQL_SET_FUNCTION_NAME "getCustomerStatus" NUMPAR 1
77850>>>>>>>>>>>>>>>>>/// SQL_SET_FUNCTION_PARAMETER 1 to 'Jones' IN
77850>>>>>>>>>>>>>>>>>/// SQL_FUNCTION_EXECUTE
77850>>>>>>>>>>>>>>>>>/// SQL_GET_FUNCTION_RETURN to dDOB
77850>>>>>>>>>>>>>>>>>/// Showln dDOB
77850>>>>>>>>>>>>>>>>>
77850>>>>>>>>>>>>>>>>>Procedure MertechInc_SQL_SET_ORAFUNCTION_NAME Global String strProcName Integer iNumpar
77852>>>>>>>>>>>>>>>>>    Integer iParam
77852>>>>>>>>>>>>>>>>>
77852>>>>>>>>>>>>>>>>>    SQL_SET_STMT to "BEGIN "
77884>>>>>>>>>>>>>>>>>    SQL_APPEND_STMT to ":PAR_RET := "
77916>>>>>>>>>>>>>>>>>    SQL_APPEND_STMT to strProcName
77948>>>>>>>>>>>>>>>>>    SQL_APPEND_STMT to "( "
77980>>>>>>>>>>>>>>>>>    For iParam from 1 to iNumpar
77986>>>>>>>>>>>>>>>>>>
77986>>>>>>>>>>>>>>>>>        DO_PASS_ARGUMENTS iParam
78065>>>>>>>>>>>>>>>>>    Loop
78066>>>>>>>>>>>>>>>>>>
78066>>>>>>>>>>>>>>>>>    SQL_APPEND_STMT to  " ); END;"
78098>>>>>>>>>>>>>>>>>    SQL_PREPARE_STMT
78147>>>>>>>>>>>>>>>>>
78147>>>>>>>>>>>>>>>>>    Move IS_OUT to MertechInc_iArg
78148>>>>>>>>>>>>>>>>>    Call_Driver 0 ORAFLEX Function CALLDRV_SET_PROC_ATTRIBUTE_TYPE CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank MertechInc_iArg RESULT MertechInc_iRet
78153>>>>>>>>>>>>>>>>>
78153>>>>>>>>>>>>>>>>>    Increment MertechInc_iParamCount
78154>>>>>>>>>>>>>>>>>    Move ":PAR_RET" to MertechInc_sArg2
78155>>>>>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_BIND_PARAMETER CALLBACK 0 PASSING MertechInc_Blank MertechInc_sArg2 16384 RESULT MertechInc_iRet
78160>>>>>>>>>>>>>>>>>End_Procedure
78161>>>>>>>>>>>>>>>>>
78161>>>>>>>>>>>>>>>>>Procedure MertechInc_SQL_SET_MYFUNCTION_NAME Global String strProcName Integer iNumpar
78163>>>>>>>>>>>>>>>>>    Integer iParam
78163>>>>>>>>>>>>>>>>>
78163>>>>>>>>>>>>>>>>>    Move MySQLFlex to MertechInc_DriverName
78164>>>>>>>>>>>>>>>>>
78164>>>>>>>>>>>>>>>>>    SQL_SET_STMT to "SELECT "
78196>>>>>>>>>>>>>>>>>    SQL_APPEND_STMT to strProcName
78228>>>>>>>>>>>>>>>>>    SQL_APPEND_STMT to "("
78260>>>>>>>>>>>>>>>>>    For iParam from 1 to iNumpar
78266>>>>>>>>>>>>>>>>>>
78266>>>>>>>>>>>>>>>>>        DO_PASS_ARGUMENTS iParam
78345>>>>>>>>>>>>>>>>>    Loop
78346>>>>>>>>>>>>>>>>>>
78346>>>>>>>>>>>>>>>>>    SQL_APPEND_STMT to ")"
78378>>>>>>>>>>>>>>>>>    SQL_PREPARE_STMT
78427>>>>>>>>>>>>>>>>>End_Procedure
78428>>>>>>>>>>>>>>>>>
78428>>>>>>>>>>>>>>>>>Procedure MertechInc_SQL_SET_SQLFUNCTION_NAME Global String strProcName Integer iNumpar
78430>>>>>>>>>>>>>>>>>    Integer iParam
78430>>>>>>>>>>>>>>>>>
78430>>>>>>>>>>>>>>>>>    Move SQLFlex to MertechInc_DriverName
78431>>>>>>>>>>>>>>>>>
78431>>>>>>>>>>>>>>>>>    If (not(strProcName contains ".")) Begin
78433>>>>>>>>>>>>>>>>>        String schema
78433>>>>>>>>>>>>>>>>>        GET_SCHEMA_NAME to schema
78479>>>>>>>>>>>>>>>>>        Move (schema + "." + strProcName) to strProcName
78480>>>>>>>>>>>>>>>>>    End
78480>>>>>>>>>>>>>>>>>>
78480>>>>>>>>>>>>>>>>>
78480>>>>>>>>>>>>>>>>>    SQL_SET_STMT    to "SELECT "
78512>>>>>>>>>>>>>>>>>    SQL_APPEND_STMT to strProcName
78544>>>>>>>>>>>>>>>>>    SQL_APPEND_STMT to "("
78576>>>>>>>>>>>>>>>>>End_Procedure
78577>>>>>>>>>>>>>>>>>
78577>>>>>>>>>>>>>>>>>Procedure MertechInc_SQL_SET_PGFUNCTION_NAME Global String strProcName Integer iNumpar
78579>>>>>>>>>>>>>>>>>    Integer iParam
78579>>>>>>>>>>>>>>>>>
78579>>>>>>>>>>>>>>>>>    Move PgFlex to MertechInc_DriverName
78580>>>>>>>>>>>>>>>>>
78580>>>>>>>>>>>>>>>>>    SQL_SET_STMT    to "SELECT "
78612>>>>>>>>>>>>>>>>>    SQL_APPEND_STMT to strProcName
78644>>>>>>>>>>>>>>>>>    SQL_APPEND_STMT to "("
78676>>>>>>>>>>>>>>>>>End_Procedure
78677>>>>>>>>>>>>>>>>>
78677>>>>>>>>>>>>>>>>>//=============================================================================
78677>>>>>>>>>>>>>>>>>/// @Name        SQL_SET_PROCEDURE_PARAMETER
78677>>>>>>>>>>>>>>>>>/// @Description
78677>>>>>>>>>>>>>>>>>/// With this command you can pass one or more parameters to predefined
78677>>>>>>>>>>>>>>>>>/// stored procedures on a MySQL or Oracle server. The SQL_SET_PROCEDURE_PARAMETER
78677>>>>>>>>>>>>>>>>>/// command enables you to add a parameter to a stored procedure which you are
78677>>>>>>>>>>>>>>>>>/// planning to call. You can pass multiple parameters by calling the command
78677>>>>>>>>>>>>>>>>>/// for each parameter.
78677>>>>>>>>>>>>>>>>>///
78677>>>>>>>>>>>>>>>>>/// When passing parameters you'll have to inform the driver which variable
78677>>>>>>>>>>>>>>>>>/// you are passing, starting with 1 from left-to-right in the parameter list.
78677>>>>>>>>>>>>>>>>>///
78677>>>>>>>>>>>>>>>>>/// For each parameter you'll have to indicate if the variable is to be
78677>>>>>>>>>>>>>>>>>/// regarded as input, output or both.
78677>>>>>>>>>>>>>>>>>///
78677>>>>>>>>>>>>>>>>>///@Assumptions
78677>>>>>>>>>>>>>>>>>/// @Status      Public
78677>>>>>>>>>>>>>>>>>/// @Drivers     All
78677>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-27 by Aaron Gulack
78677>>>>>>>>>>>>>>>>>/// @See                 SQL_SET_PROCEDURE_NAME SQL_PROCEDURE_EXECUTE
78677>>>>>>>>>>>>>>>>>///
78677>>>>>>>>>>>>>>>>>/// @Syntax SQL_SET_PROCEDURE_PARAMETER {number} to {variable} {direction}
78677>>>>>>>>>>>>>>>>>/// @Param number                       Index number of the parameter being defined.
78677>>>>>>>>>>>>>>>>>/// @Param variable                     Variable holding the parameter to be passed.
78677>>>>>>>>>>>>>>>>>/// @Param direction            IN, OUT, IN_OUT, RSET, or leave blank
78677>>>>>>>>>>>>>>>>>///
78677>>>>>>>>>>>>>>>>>/// @Example
78677>>>>>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_NAME "sys.sp_addmessage" NUMPAR 3
78677>>>>>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 1 to 500004 IN
78677>>>>>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 2 to 15 IN
78677>>>>>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 3 to "Please enter a valid Date" IN
78677>>>>>>>>>>>>>>>>>/// SQL_PROCEDURE_EXECUTE
78677>>>>>>>>>>>>>>>>>
78677>>>>>>>>>>>>>>>>>
78677>>>>>>>>>>>>>>>>>
78677>>>>>>>>>>>>>>>>>//=============================================================================
78677>>>>>>>>>>>>>>>>>/// @Name        SQL_SET_QUERY_PARAMETER
78677>>>>>>>>>>>>>>>>>/// @Description
78677>>>>>>>>>>>>>>>>>/// Use this command to set the value of the parameters that are defined in your
78677>>>>>>>>>>>>>>>>>/// SQL Query. Each backend uses a different syntax for paramterized queries,
78677>>>>>>>>>>>>>>>>>/// but all have the same goal of removing the risk of SQL Injection attacks.
78677>>>>>>>>>>>>>>>>>/// Oracle and PostgreSQL allow for named parameters which this command supports
78677>>>>>>>>>>>>>>>>>/// by passing the first parameter as a string containing the named parameter
78677>>>>>>>>>>>>>>>>>/// (without the syntactical sugar). For MS-SQL and MySQL only positional
78677>>>>>>>>>>>>>>>>>/// parameters are supported and the first parameter to this command should be an
78677>>>>>>>>>>>>>>>>>/// integer containing the ordinal position of the parameter.
78677>>>>>>>>>>>>>>>>>///
78677>>>>>>>>>>>>>>>>>///
78677>>>>>>>>>>>>>>>>>///@Assumptions
78677>>>>>>>>>>>>>>>>>/// @Status      Public
78677>>>>>>>>>>>>>>>>>/// @Drivers     All
78677>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2018-03-06 by Oliver Nelson
78677>>>>>>>>>>>>>>>>>/// @See         SQL_SET_STMT SQL_EXECUTE_STMT
78677>>>>>>>>>>>>>>>>>///
78677>>>>>>>>>>>>>>>>>/// @Syntax SQL_SET_QUERY_PARAMETER {param} to {variable}
78677>>>>>>>>>>>>>>>>>/// @Param param                     Either a string containing the named parameter or an integer of it's ordinal position.
78677>>>>>>>>>>>>>>>>>/// @Param variable/constant         Variable or constant holding the parameter to be passed.
78677>>>>>>>>>>>>>>>>>///
78677>>>>>>>>>>>>>>>>>/// @Example
78677>>>>>>>>>>>>>>>>>/// SQL_SET_STMT "Select name from Customer where status = ? and city = ?"
78677>>>>>>>>>>>>>>>>>/// SQL_SET_QUERY_PARAMETER 1 to "Y"
78677>>>>>>>>>>>>>>>>>/// SQL_SET_QUERY_PARAMETER 2 to "Fresno"
78677>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
78677>>>>>>>>>>>>>>>>>
78677>>>>>>>>>>>>>>>>>Function MDS_Get_Param_Type Global Variant vVal Returns Integer
78679>>>>>>>>>>>>>>>>>    Local Integer vartype retval
78679>>>>>>>>>>>>>>>>>    Local Variant some_val
78679>>>>>>>>>>>>>>>>>    Move vVal to some_val
78680>>>>>>>>>>>>>>>>>    Move (DeRefW(AddressOf(some_val), 0)) to vartype
78681>>>>>>>>>>>>>>>>>
78681>>>>>>>>>>>>>>>>>    If (vartype = 2) Begin
78683>>>>>>>>>>>>>>>>>        Move ((13 * (2^24)) + 6) to retval
78684>>>>>>>>>>>>>>>>>    End
78684>>>>>>>>>>>>>>>>>>
78684>>>>>>>>>>>>>>>>>    Else If (vartype = 3) Begin
78687>>>>>>>>>>>>>>>>>        Move ((3 * (2^24)) + 11) to retval
78688>>>>>>>>>>>>>>>>>    End
78688>>>>>>>>>>>>>>>>>>
78688>>>>>>>>>>>>>>>>>    Else If (vartype = 4) Begin // OLE_VT_R4
78691>>>>>>>>>>>>>>>>>        Move ((10 * (2^24)) + 11) to retval
78692>>>>>>>>>>>>>>>>>    End
78692>>>>>>>>>>>>>>>>>>
78692>>>>>>>>>>>>>>>>>    Else If (vartype = 5) Begin // OLE_VT_R8
78695>>>>>>>>>>>>>>>>>        Move ((5 * (2^24)) + 26) to retval
78696>>>>>>>>>>>>>>>>>    End
78696>>>>>>>>>>>>>>>>>>
78696>>>>>>>>>>>>>>>>>    Else If (vartype = 6) Begin // OLE_VT_Currency
78699>>>>>>>>>>>>>>>>>        Move ((18 * (2^24)) + 21) to retval
78700>>>>>>>>>>>>>>>>>    End
78700>>>>>>>>>>>>>>>>>>
78700>>>>>>>>>>>>>>>>>    Else If (vartype = 7) Begin // OLE_VT_Date
78703>>>>>>>>>>>>>>>>>        Move ((9 * (2^24)) + 26) to retval
78704>>>>>>>>>>>>>>>>>    End
78704>>>>>>>>>>>>>>>>>>
78704>>>>>>>>>>>>>>>>>    Else If (vartype = 11) Begin // OLE_VT_Bool
78707>>>>>>>>>>>>>>>>>        Move ((16 * (2^24)) + 1) to retval
78708>>>>>>>>>>>>>>>>>    End
78708>>>>>>>>>>>>>>>>>>
78708>>>>>>>>>>>>>>>>>    Else If (vartype = 14) Begin // OLE_VT_Decimal
78711>>>>>>>>>>>>>>>>>        Move ((2 * (2^24)) + 34) to retval
78712>>>>>>>>>>>>>>>>>    End
78712>>>>>>>>>>>>>>>>>>
78712>>>>>>>>>>>>>>>>>    Else If (vartype = 16) Begin // OLE_VT_I1
78715>>>>>>>>>>>>>>>>>        Move ((11 * (2^24)) + 4) to retval
78716>>>>>>>>>>>>>>>>>    End
78716>>>>>>>>>>>>>>>>>>
78716>>>>>>>>>>>>>>>>>    Else If (vartype = 17) Begin // OLE_VT_Ui1
78719>>>>>>>>>>>>>>>>>        Move ((12 * (2^24)) + 3) to retval
78720>>>>>>>>>>>>>>>>>    End
78720>>>>>>>>>>>>>>>>>>
78720>>>>>>>>>>>>>>>>>    Else If (vartype = 18) Begin // OLE_VT_Ui2
78723>>>>>>>>>>>>>>>>>        Move ((14 * (2^24)) + 5) to retval
78724>>>>>>>>>>>>>>>>>    End
78724>>>>>>>>>>>>>>>>>>
78724>>>>>>>>>>>>>>>>>    Else If (vartype = 19) Begin // OLE_VT_Ui4
78727>>>>>>>>>>>>>>>>>        Move ((15 * (2^24)) + 10) to retval
78728>>>>>>>>>>>>>>>>>    End
78728>>>>>>>>>>>>>>>>>>
78728>>>>>>>>>>>>>>>>>    Else If (vartype = 17) Begin // OLE_VT_I8
78731>>>>>>>>>>>>>>>>>        Move ((4 * (2^24)) + 20) to retval
78732>>>>>>>>>>>>>>>>>    End
78732>>>>>>>>>>>>>>>>>>
78732>>>>>>>>>>>>>>>>>
78732>>>>>>>>>>>>>>>>>    Function_Return retval
78733>>>>>>>>>>>>>>>>>End_Function
78734>>>>>>>>>>>>>>>>>
78734>>>>>>>>>>>>>>>>>//=============================================================================
78734>>>>>>>>>>>>>>>>>/// @Name        SQL_GET_PROCEDURE_PARAMETER
78734>>>>>>>>>>>>>>>>>/// @Description This command is used to get the value of a specific
78734>>>>>>>>>>>>>>>>>/// parameter associated with a stored procedure.  Although this
78734>>>>>>>>>>>>>>>>>/// command will work with any parameter, it is mostly be used with
78734>>>>>>>>>>>>>>>>>/// IN/OUT or OUT parameters as their value will more often be important
78734>>>>>>>>>>>>>>>>>/// once returned. When multiple values are returned, this command can be
78734>>>>>>>>>>>>>>>>>/// more efficient than other options. Note that the specified parameter
78734>>>>>>>>>>>>>>>>>/// must first be defined using the SQL_SET_PROCEDURE_PARAMETER command
78734>>>>>>>>>>>>>>>>>/// in order to work properly.
78734>>>>>>>>>>>>>>>>>///
78734>>>>>>>>>>>>>>>>>/// @Assumptions
78734>>>>>>>>>>>>>>>>>/// @Status      Public
78734>>>>>>>>>>>>>>>>>/// @Drivers     All
78734>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
78734>>>>>>>>>>>>>>>>>/// @See                 SQL_SET_PROCEDURE_NAME SQL_SET_PROCEDURE_PARAMETER SQL_PROCEDURE_EXECUTE
78734>>>>>>>>>>>>>>>>>///
78734>>>>>>>>>>>>>>>>>/// @Syntax SQL_GET_PROCEDURE_PARAMETER {parameter} to {variable}
78734>>>>>>>>>>>>>>>>>/// @Param parameter            Number of paramater to return
78734>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the value of the parameter
78734>>>>>>>>>>>>>>>>>///
78734>>>>>>>>>>>>>>>>>/// @Example
78734>>>>>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_NAME "user.getCustomerStatus" NUMPAR 1
78734>>>>>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 1 to sCustomerID IN_OUT
78734>>>>>>>>>>>>>>>>>/// SQL_PROCEDURE_EXECUTE
78734>>>>>>>>>>>>>>>>>/// SQL_GET_PROCEDURE_PARAMETER 1 to sStatus
78734>>>>>>>>>>>>>>>>>///
78734>>>>>>>>>>>>>>>>>/// Showln sStatus
78734>>>>>>>>>>>>>>>>>///
78734>>>>>>>>>>>>>>>>>/// @Example
78734>>>>>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_NAME "user.getCustomerStatus" NUMPAR 2
78734>>>>>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 1 to sCustomerID IN
78734>>>>>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 2 to sStatus OUT
78734>>>>>>>>>>>>>>>>>/// SQL_PROCEDURE_EXECUTE
78734>>>>>>>>>>>>>>>>>/// SQL_GET_PROCEDURE_PARAMETER 2 to sStatus
78734>>>>>>>>>>>>>>>>>///
78734>>>>>>>>>>>>>>>>>/// Showln sStatus
78734>>>>>>>>>>>>>>>>>
78734>>>>>>>>>>>>>>>>>
78734>>>>>>>>>>>>>>>>>
78734>>>>>>>>>>>>>>>>>//=============================================================================
78734>>>>>>>>>>>>>>>>>/// @Name        SQL_GET_FUNCTION_RETURN
78734>>>>>>>>>>>>>>>>>/// @Description This variable is used to get the value returned from a SQL
78734>>>>>>>>>>>>>>>>>/// function call. After the function has been successfully called, this
78734>>>>>>>>>>>>>>>>>/// command takes the returned value and inserts it the given variable.
78734>>>>>>>>>>>>>>>>>///
78734>>>>>>>>>>>>>>>>>/// @Assumptions
78734>>>>>>>>>>>>>>>>>/// @Status      Public
78734>>>>>>>>>>>>>>>>>/// @Drivers     All
78734>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
78734>>>>>>>>>>>>>>>>>/// @See                 SQL_SET_FUNCTION_NAME SQL_SET_FUNCTION_PARAMETER SQL_FUNCTION_EXECUTE
78734>>>>>>>>>>>>>>>>>///
78734>>>>>>>>>>>>>>>>>/// @Syntax SQL_GET_FUNCTION_RETURN to {variable}
78734>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the returned value
78734>>>>>>>>>>>>>>>>>///
78734>>>>>>>>>>>>>>>>>/// @Example
78734>>>>>>>>>>>>>>>>>/// SQL_SET_FUNCTION_NAME "getCustomerStatus" NUMPAR 1
78734>>>>>>>>>>>>>>>>>/// SQL_SET_FUNCTION_PARAMETER 1 to 'Jones' IN
78734>>>>>>>>>>>>>>>>>/// SQL_FUNCTION_EXECUTE
78734>>>>>>>>>>>>>>>>>/// SQL_GET_FUNCTION_RETURN to dDOB
78734>>>>>>>>>>>>>>>>>/// Showln dDOB
78734>>>>>>>>>>>>>>>>>
78734>>>>>>>>>>>>>>>>>//=============================================================================
78734>>>>>>>>>>>>>>>>>/// @Name        SQL_FUNCTION_EXECUTE
78734>>>>>>>>>>>>>>>>>/// @Description This command is used to execute the function statement
78734>>>>>>>>>>>>>>>>>/// that was built by the SQL_SET_FUNCTION_NAME and subsequent
78734>>>>>>>>>>>>>>>>>/// SQL_SET_FUNCTION_PARAMETER commands. This works similarly to the
78734>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT command. Note that executing the function with this
78734>>>>>>>>>>>>>>>>>/// command will not get any returned values but will simply execute the
78734>>>>>>>>>>>>>>>>>/// function.
78734>>>>>>>>>>>>>>>>>///
78734>>>>>>>>>>>>>>>>>/// @Assumptions
78734>>>>>>>>>>>>>>>>>/// @Status      Public
78734>>>>>>>>>>>>>>>>>/// @Drivers     All
78734>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
78734>>>>>>>>>>>>>>>>>/// @See                 SQL_SET_FUNCTION_NAME SQL_SET_FUNCTION_PARAMETER SQL_GET_FUNCTION_RETURN
78734>>>>>>>>>>>>>>>>>///
78734>>>>>>>>>>>>>>>>>/// @Syntax SQL_FUNCTION_EXECUTE
78734>>>>>>>>>>>>>>>>>///
78734>>>>>>>>>>>>>>>>>/// @Example
78734>>>>>>>>>>>>>>>>>/// SQL_SET_FUNCTION_NAME "getCustomerStatus" NUMPAR 1
78734>>>>>>>>>>>>>>>>>/// SQL_SET_FUNCTION_PARAMETER 1 to 'Jones' IN
78734>>>>>>>>>>>>>>>>>/// SQL_FUNCTION_EXECUTE
78734>>>>>>>>>>>>>>>>>/// SQL_GET_FUNCTION_RETURN to dDOB
78734>>>>>>>>>>>>>>>>>/// Showln dDOB
78734>>>>>>>>>>>>>>>>>
78734>>>>>>>>>>>>>>>>>Procedure MertechInc_SQL_FUNCTION_EXECUTE Global String sDriverName
78736>>>>>>>>>>>>>>>>>    Integer iParam
78736>>>>>>>>>>>>>>>>>    String  sParam
78736>>>>>>>>>>>>>>>>>
78736>>>>>>>>>>>>>>>>>    If (sDriverName = SQLFLEX or sDriverName = PgFlex) Begin
78738>>>>>>>>>>>>>>>>>       SQL_APPEND_STMT to ')'
78770>>>>>>>>>>>>>>>>>       SQL_PREPARE_STMT
78819>>>>>>>>>>>>>>>>>    End
78819>>>>>>>>>>>>>>>>>>
78819>>>>>>>>>>>>>>>>>
78819>>>>>>>>>>>>>>>>>    SQL_EXECUTE_STMT
78859>>>>>>>>>>>>>>>>>    If (sDriverName <> ORAFLEX) Begin
78861>>>>>>>>>>>>>>>>>        SQL_FETCH_NEXT_ROW
78911>>>>>>>>>>>>>>>>>    End
78911>>>>>>>>>>>>>>>>>>
78911>>>>>>>>>>>>>>>>>End_Procedure
78912>>>>>>>>>>>>>>>>>
78912>>>>>>>>>>>>>>>>>//=============================================================================
78912>>>>>>>>>>>>>>>>>/// @Name        REEXEC_ORACLE_STORED_PROCEDURE
78912>>>>>>>>>>>>>>>>>/// @Description This command is used to re-execute a stored procedure
78912>>>>>>>>>>>>>>>>>/// when using Oracle. Although it follows the same format as
78912>>>>>>>>>>>>>>>>>/// CALL_STORED_PROCEDURE, it can be useful because it does not need to
78912>>>>>>>>>>>>>>>>>/// prepare the procedure again before executing. This can cause speed
78912>>>>>>>>>>>>>>>>>/// improvements when calling a stored procedure multiple times.
78912>>>>>>>>>>>>>>>>>///
78912>>>>>>>>>>>>>>>>>/// @Assumptions A procedure has already been created through CALL_STORED_PROCEDURE
78912>>>>>>>>>>>>>>>>>/// @Status      Public
78912>>>>>>>>>>>>>>>>>/// @Drivers     ORAFLex
78912>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
78912>>>>>>>>>>>>>>>>>/// @See                 CALL_STORED_PROCEDURE
78912>>>>>>>>>>>>>>>>>///
78912>>>>>>>>>>>>>>>>>/// @Syntax CALL_ORACLE_STORED_PROCEDURE {procedure} Passing {variable}
78912>>>>>>>>>>>>>>>>>/// @Param procedure            Full name of the procedure
78912>>>>>>>>>>>>>>>>>/// @Param variable                     Parameter to pass (optional and can be multiple)
78912>>>>>>>>>>>>>>>>>///
78912>>>>>>>>>>>>>>>>>/// @Example
78912>>>>>>>>>>>>>>>>>/// CALL_STORED_PROCEDURE "user.getCustomerStatus" Passing sCustomerID sStatus
78912>>>>>>>>>>>>>>>>>/// Showln sStatus
78912>>>>>>>>>>>>>>>>>///
78912>>>>>>>>>>>>>>>>>/// Move (sCustomerID + 1) to sCustomerID
78912>>>>>>>>>>>>>>>>>///
78912>>>>>>>>>>>>>>>>>/// REEXEC_ORACLE_STORED_PROCEDURE "user.getCustomerStatus" passing sCustomerID sStatus
78912>>>>>>>>>>>>>>>>>/// Showln sStatus
78912>>>>>>>>>>>>>>>>>
78912>>>>>>>>>>>>>>>>>
78912>>>>>>>>>>>>>>>>>//=============================================================================
78912>>>>>>>>>>>>>>>>>/// @Name        CALL_STORED_FUNCTION
78912>>>>>>>>>>>>>>>>>/// @Description This command is used to execute a function stored in the
78912>>>>>>>>>>>>>>>>>/// SQL backend. This is an alternative to building a function with the
78912>>>>>>>>>>>>>>>>>/// SQL_SET_FUNCTION_NAME, SQL_SET_FUNCTION_PARAMETER and SQL_FUNCTION_EXECUTE
78912>>>>>>>>>>>>>>>>>/// commands. This command builds and executes the function by setting the full
78912>>>>>>>>>>>>>>>>>/// function name, the parameter(s) to pass and the variable to hold the
78912>>>>>>>>>>>>>>>>>/// returned value. Note that this command can only return a single value
78912>>>>>>>>>>>>>>>>>/// so SQL_SET_FUNCTION_PARAMETER and SQL_SET_FUNCTION_NAME must be used when
78912>>>>>>>>>>>>>>>>>/// dealing with multiple return values.
78912>>>>>>>>>>>>>>>>>///
78912>>>>>>>>>>>>>>>>>/// Assumptions
78912>>>>>>>>>>>>>>>>>/// @Status      Public
78912>>>>>>>>>>>>>>>>>/// @Drivers     ORAFLex MySQLFlex PgFlex
78912>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
78912>>>>>>>>>>>>>>>>>/// @See
78912>>>>>>>>>>>>>>>>>///
78912>>>>>>>>>>>>>>>>>/// @Syntax CALL_STORED_FUNCTION {function} Returns {variable} Passing {parameters}
78912>>>>>>>>>>>>>>>>>/// @Param function                     Full name of the function
78912>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the returned value
78912>>>>>>>>>>>>>>>>>/// @Param parameters           Parameter to pass to the function (can be multiple)
78912>>>>>>>>>>>>>>>>>///
78912>>>>>>>>>>>>>>>>>/// @Example
78912>>>>>>>>>>>>>>>>>/// Move 5 to sCustomerID
78912>>>>>>>>>>>>>>>>>/// CALL_STORED_FUNCTION "getCustomerStatus" Returns sStatus Passing sCustomerID
78912>>>>>>>>>>>>>>>>>/// Showln sStatus
78912>>>>>>>>>>>>>>>>>
78912>>>>>>>>>>>>>>>>>//=============================================================================
78912>>>>>>>>>>>>>>>>>/// @Name        OUTPUT_INT_FILE
78912>>>>>>>>>>>>>>>>>/// @Description This command is used to output the int file of an opened
78912>>>>>>>>>>>>>>>>>/// table. If the file to be output to does not exist, it will be created
78912>>>>>>>>>>>>>>>>>/// upon execution of this command. Note that the INT file can be output
78912>>>>>>>>>>>>>>>>>/// into multiple types of files i.e. .doc, .txt, .int.
78912>>>>>>>>>>>>>>>>>///
78912>>>>>>>>>>>>>>>>>/// @Assumptions
78912>>>>>>>>>>>>>>>>>/// @Status      Public
78912>>>>>>>>>>>>>>>>>/// @Drivers     All
78912>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
78912>>>>>>>>>>>>>>>>>/// @See
78912>>>>>>>>>>>>>>>>>///
78912>>>>>>>>>>>>>>>>>/// @Syntax OUTPUT_INT_FILE for {FileNumber} to {variable}
78912>>>>>>>>>>>>>>>>>/// @Param FileNumber           The file number
78912>>>>>>>>>>>>>>>>>/// @Param variable                     Path of the file being output to
78912>>>>>>>>>>>>>>>>>///
78912>>>>>>>>>>>>>>>>>///@Example
78912>>>>>>>>>>>>>>>>>/// OUTPUT_INT_FILE for Customer.File_Number to "C:\Temp\Customer.int"
78912>>>>>>>>>>>>>>>>>
78912>>>>>>>>>>>>>>>>>//=============================================================================
78912>>>>>>>>>>>>>>>>>/// @Name        SQL_ERROR_MESSAGE
78912>>>>>>>>>>>>>>>>>/// @Description This command is used to get an error message
78912>>>>>>>>>>>>>>>>>/// from a given SQL statement. If the given statement is executed with
78912>>>>>>>>>>>>>>>>>/// no errors, the variable specified with this command will be blank.
78912>>>>>>>>>>>>>>>>>/// Otherwise the message will be stored in the given variable. Note that
78912>>>>>>>>>>>>>>>>>/// unless specified, strings have a size limit of 80 characters, so using
78912>>>>>>>>>>>>>>>>>/// a variant can ensure the full message is retrieved.
78912>>>>>>>>>>>>>>>>>///
78912>>>>>>>>>>>>>>>>>/// @Assumptions
78912>>>>>>>>>>>>>>>>>/// @Status      Public
78912>>>>>>>>>>>>>>>>>/// @Drivers     All
78912>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
78912>>>>>>>>>>>>>>>>>/// @See         SQL_ERROR_MESSAGE2
78912>>>>>>>>>>>>>>>>>///
78912>>>>>>>>>>>>>>>>>/// @Syntax SQL_ERROR_MESSAGE {variable}
78912>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the error message
78912>>>>>>>>>>>>>>>>>///
78912>>>>>>>>>>>>>>>>>/// @Example
78912>>>>>>>>>>>>>>>>>/// SQL_ERROR_MESSAGE sError
78912>>>>>>>>>>>>>>>>>
78912>>>>>>>>>>>>>>>>>Function MertechInc_SQL_ERROR_MESSAGE Global Returns String
78914>>>>>>>>>>>>>>>>>    String sMessage
78914>>>>>>>>>>>>>>>>>
78914>>>>>>>>>>>>>>>>>    Get MertechInc_Pre_Size_String 0 to sMessage
78915>>>>>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_SQL_ERROR_MESSAGE CALLBACK 0 PASSING MertechInc_Blank sMessage 0 RESULT MertechInc_iRet
78920>>>>>>>>>>>>>>>>>
78920>>>>>>>>>>>>>>>>>    Function_Return sMessage
78921>>>>>>>>>>>>>>>>>End_Function
78922>>>>>>>>>>>>>>>>>
78922>>>>>>>>>>>>>>>>>//=============================================================================
78922>>>>>>>>>>>>>>>>>/// @Name        SQL_ERROR_MESSAGE2
78922>>>>>>>>>>>>>>>>>/// @Description This command is used to get the last error message used
78922>>>>>>>>>>>>>>>>>/// for the specified server. This can be useful once a transaction has
78922>>>>>>>>>>>>>>>>>/// already been completed and any error messages need to be retrieved.
78922>>>>>>>>>>>>>>>>>///
78922>>>>>>>>>>>>>>>>>/// @Assumptions
78922>>>>>>>>>>>>>>>>>/// @Status      Public
78922>>>>>>>>>>>>>>>>>/// @Drivers     All
78922>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
78922>>>>>>>>>>>>>>>>>/// @See         SQL_ERROR_MESSAGE SQL_ERROR_MESSAGE2
78922>>>>>>>>>>>>>>>>>///
78922>>>>>>>>>>>>>>>>>/// @Syntax SQL_ERROR_MESSAGE2 of {server} to {variable}
78922>>>>>>>>>>>>>>>>>/// @Param server                       Name of the server
78922>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the error message
78922>>>>>>>>>>>>>>>>>///
78922>>>>>>>>>>>>>>>>>/// @Example
78922>>>>>>>>>>>>>>>>>/// SQL_ERROR_MESSAGE2 of "localhost" to sError
78922>>>>>>>>>>>>>>>>>
78922>>>>>>>>>>>>>>>>>Function MertechInc_SQL_ERROR_MESSAGE2 Global String sServer Returns String
78924>>>>>>>>>>>>>>>>>    String sMessage
78924>>>>>>>>>>>>>>>>>
78924>>>>>>>>>>>>>>>>>    Get MertechInc_Pre_Size_String 800 to sMessage
78925>>>>>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_SQL_ERROR_MESSAGE2 CALLBACK 0 PASSING sServer sMessage 0 RESULT MertechInc_iRet
78930>>>>>>>>>>>>>>>>>
78930>>>>>>>>>>>>>>>>>    Function_Return sMessage
78931>>>>>>>>>>>>>>>>>End_Function
78932>>>>>>>>>>>>>>>>>
78932>>>>>>>>>>>>>>>>>//=============================================================================
78932>>>>>>>>>>>>>>>>>/// @Name        MERTECH_WARNING_MESSAGE
78932>>>>>>>>>>>>>>>>>/// @Description When restructuring a table, i.e. Structure_Start, a warning
78932>>>>>>>>>>>>>>>>>/// message will appear to confirm the restructure before it is executed.
78932>>>>>>>>>>>>>>>>>/// This command is used to disable or enable that warning message. All that
78932>>>>>>>>>>>>>>>>>/// is passed is either the constant "Enabled" or "Disabled". By default,
78932>>>>>>>>>>>>>>>>>/// this message is enabled.
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Assumptions
78932>>>>>>>>>>>>>>>>>/// @Status      Public
78932>>>>>>>>>>>>>>>>>/// @Drivers     All
78932>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Syntax MERTECH_WARNING_MESSAGE {Enabled|Disabled}
78932>>>>>>>>>>>>>>>>>/// @Param Enabled                      Enables the restructure warning
78932>>>>>>>>>>>>>>>>>/// @Param Disabled                     Disables the restructure warning
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Example
78932>>>>>>>>>>>>>>>>>/// Move Customer.File_Number to hFile
78932>>>>>>>>>>>>>>>>>/// MERTECH_WARNING_MESSAGE Disabled
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// Structure_Start hFile
78932>>>>>>>>>>>>>>>>>///     Set_Attribute DF_FILE_OEM_TRANSLATION of hFile to True
78932>>>>>>>>>>>>>>>>>/// Structure_End hFile
78932>>>>>>>>>>>>>>>>>
78932>>>>>>>>>>>>>>>>>//=============================================================================
78932>>>>>>>>>>>>>>>>>/// @Name        DISABLE_SELECT_COLUMNS_ERRORS
78932>>>>>>>>>>>>>>>>>/// @Description When using SELECT_COLUMNS_FIND to limit the number of columns
78932>>>>>>>>>>>>>>>>>/// to fetch, the framework might still ask for columns that you do not need.
78932>>>>>>>>>>>>>>>>>/// As a result you'll end up getting runtime errors you do not want to see.
78932>>>>>>>>>>>>>>>>>/// This command gives you the ability to stop reporting errors for querying
78932>>>>>>>>>>>>>>>>>/// for data from columns that are not part of the query.
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// DISABLED_SELECT_COLUMNS_ERRORS DISABLED will disable the errors, use
78932>>>>>>>>>>>>>>>>>/// ENABLED to turn the error messages back on.
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// By default triggering error messages on unknown columns is ENABLED
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Assumptions
78932>>>>>>>>>>>>>>>>>/// @Status      Public
78932>>>>>>>>>>>>>>>>>/// @Drivers     All
78932>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2014-04-28 by Wil van Antwerpen
78932>>>>>>>>>>>>>>>>>/// @See         SELECT_COLUMNS_FIND RESET_FETCH_FIELDS
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Example
78932>>>>>>>>>>>>>>>>>/// Open Customer
78932>>>>>>>>>>>>>>>>>/// RESET_FETCH_FIELDS  CUSTOMER DF_FETCH_FALSE
78932>>>>>>>>>>>>>>>>>/// SELECT_COLUMNS_FIND CUSTOMER CUSTOMER_NUMBER NAME
78932>>>>>>>>>>>>>>>>>/// DISABLE_SELECT_COLUMNS_ERRORS DISABLED
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// Clear Customer
78932>>>>>>>>>>>>>>>>>/// Repeat
78932>>>>>>>>>>>>>>>>>///    Find Gt Customer by Index.1
78932>>>>>>>>>>>>>>>>>///    If (Found) Showln Customer.Customer_Number '-' Customer.Name
78932>>>>>>>>>>>>>>>>>/// Until (Not(Found))
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// RESET_FETCH_FIELDS Customer DF_FETCH_TRUE
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Syntax DISABLE_SELECT_COLUMNS_ERRORS {ENABLED|DISABLED}
78932>>>>>>>>>>>>>>>>>
78932>>>>>>>>>>>>>>>>>//=============================================================================
78932>>>>>>>>>>>>>>>>>/// @Name        SQLFlex_REVISION
78932>>>>>>>>>>>>>>>>>/// @Description This command will put the current version (decimals included)
78932>>>>>>>>>>>>>>>>>/// of the MSSQL driver associated with the current workspace into the
78932>>>>>>>>>>>>>>>>>/// specified variable.
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Assumptions
78932>>>>>>>>>>>>>>>>>/// @Status      Deprecated
78932>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex
78932>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
78932>>>>>>>>>>>>>>>>>/// @See                 GET_DRIVER_REVISION
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Syntax SQLFlex_REVISION {variable}
78932>>>>>>>>>>>>>>>>>/// @Param variable                     String variable to hold the returned version
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Example
78932>>>>>>>>>>>>>>>>>/// SQLFlex_REVISION sVersion
78932>>>>>>>>>>>>>>>>>
78932>>>>>>>>>>>>>>>>>//=============================================================================
78932>>>>>>>>>>>>>>>>>/// @Name        SQLFlex_MAJOR_REVISION
78932>>>>>>>>>>>>>>>>>/// @Description This command will put the major version (no decimals) of
78932>>>>>>>>>>>>>>>>>/// the the MSSQL driver associated with the current workspace into the
78932>>>>>>>>>>>>>>>>>/// specified variable.
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Assumptions
78932>>>>>>>>>>>>>>>>>/// @Status      Deprecated
78932>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex
78932>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
78932>>>>>>>>>>>>>>>>>/// @See                 GET_DRIVER_MAJOR_REVISION
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Syntax SQLFlex_MAJOR_REVISION {variable}
78932>>>>>>>>>>>>>>>>>/// @Param variable                     String variable to hold the returned version
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Example
78932>>>>>>>>>>>>>>>>>/// SQLFlex_MAJOR_REVISION sVersion
78932>>>>>>>>>>>>>>>>>
78932>>>>>>>>>>>>>>>>>//=============================================================================
78932>>>>>>>>>>>>>>>>>/// @Name        LOGGED_USERS
78932>>>>>>>>>>>>>>>>>/// @Description This command returns the number of native users that are
78932>>>>>>>>>>>>>>>>>/// using the driver currently. This number is stored in the variable that
78932>>>>>>>>>>>>>>>>>/// is passed with the command.
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Assumptions
78932>>>>>>>>>>>>>>>>>/// @Status      Public
78932>>>>>>>>>>>>>>>>>/// @Drivers     All
78932>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
78932>>>>>>>>>>>>>>>>>/// @See                 MAXIMUM_NUMBER_OF_USERS
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Syntax LOGGED_USERS {variable}
78932>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the number of users
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Example LOGGED_USERS sUsers
78932>>>>>>>>>>>>>>>>>
78932>>>>>>>>>>>>>>>>>//=============================================================================
78932>>>>>>>>>>>>>>>>>/// @Name        MAXIMUM_NUMBER_OF_USERS
78932>>>>>>>>>>>>>>>>>/// @Description This command returns the maximum number of user allowed by
78932>>>>>>>>>>>>>>>>>/// the current license.
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Assumptions
78932>>>>>>>>>>>>>>>>>/// @Status      Public
78932>>>>>>>>>>>>>>>>>/// @Drivers     All
78932>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
78932>>>>>>>>>>>>>>>>>/// @See                 LOGGED_USERS
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Syntax MAXIMUM_NUMBER_OF_USERS {variable}
78932>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the maximum number of users
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Example
78932>>>>>>>>>>>>>>>>>/// MAXIMUM_NUMBER_OF_USERS sMax
78932>>>>>>>>>>>>>>>>>
78932>>>>>>>>>>>>>>>>> //=============================================================================
78932>>>>>>>>>>>>>>>>>/// @Name        MAXIMUM_NUMBER_OF_SESSIONS
78932>>>>>>>>>>>>>>>>>/// @Description This command returns the maximum number of sessions allowed by
78932>>>>>>>>>>>>>>>>>/// the current license.
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Assumptions
78932>>>>>>>>>>>>>>>>>/// @Status      Public
78932>>>>>>>>>>>>>>>>>/// @Drivers     All
78932>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2015-06-25 by Anton
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Syntax MAXIMUM_NUMBER_OF_SESSIONS {variable}
78932>>>>>>>>>>>>>>>>>/// @Param variable         Variable to hold the maximum number of sessions
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Example
78932>>>>>>>>>>>>>>>>>/// MAXIMUM_NUMBER_OF_SESSIONS sMax
78932>>>>>>>>>>>>>>>>>
78932>>>>>>>>>>>>>>>>>//=============================================================================
78932>>>>>>>>>>>>>>>>>/// @Name        SET_DATABASE_NAME
78932>>>>>>>>>>>>>>>>>/// @Description This command overrides the database set in the INT file
78932>>>>>>>>>>>>>>>>>/// under DATABASE_SPACE_NAME. Any opens or finds will use the database
78932>>>>>>>>>>>>>>>>>/// specified here. This can be used when the database is not stated in
78932>>>>>>>>>>>>>>>>>/// the INT file or if the database needs to be dynamically changed for
78932>>>>>>>>>>>>>>>>>/// a certain query. If the database is not specified with this command
78932>>>>>>>>>>>>>>>>>/// or in the INT file, then the default database for the server will be
78932>>>>>>>>>>>>>>>>>/// used. To set the database to be used for embedded SQL statements,
78932>>>>>>>>>>>>>>>>>/// use SQL_USE_DATABASE.
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Assumptions
78932>>>>>>>>>>>>>>>>>/// @Status      Public
78932>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex, MySQLFlex and PGFlex
78932>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
78932>>>>>>>>>>>>>>>>>/// @See                 GET_DATABASE_NAME SQL_USE_DATABASE
78932>>>>>>>>>>>>>>>>>/// @INTOPT              DATABASE_SPACE_NAME
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Syntax SET_DATABASE_NAME to {database}
78932>>>>>>>>>>>>>>>>>/// @Param database                     Name of the database
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Example
78932>>>>>>>>>>>>>>>>>/// Login "localhost" "user" "pas123" "sql_drv"
78932>>>>>>>>>>>>>>>>>/// SET_DATABASE_NAME to "TestDB"
78932>>>>>>>>>>>>>>>>>/// Open Customer
78932>>>>>>>>>>>>>>>>>
78932>>>>>>>>>>>>>>>>>//=============================================================================
78932>>>>>>>>>>>>>>>>>/// @Name        GET_DATABASE_NAME
78932>>>>>>>>>>>>>>>>>/// @Description This command is used to get the name of the database
78932>>>>>>>>>>>>>>>>>/// currently being used. The name of the database is returned into the
78932>>>>>>>>>>>>>>>>>/// specified string. Even though this command works either way, it is
78932>>>>>>>>>>>>>>>>>/// typically used when the INT file does not contain the DATABASE_SPACE_NAME.
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Assumptions
78932>>>>>>>>>>>>>>>>>/// @Status      Public
78932>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex, MySQLFlex and PgFlex
78932>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
78932>>>>>>>>>>>>>>>>>/// @See SET_DATABASE_NAME SQL_USE_DATABASE
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Syntax GET_DATABASE_NAME to {variable}
78932>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the database name
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Example
78932>>>>>>>>>>>>>>>>>/// GET_DATABASE_NAME to sDbName
78932>>>>>>>>>>>>>>>>>
78932>>>>>>>>>>>>>>>>>//=============================================================================
78932>>>>>>>>>>>>>>>>>/// @Name        GET_NAME_SPACE
78932>>>>>>>>>>>>>>>>>/// @Description This command returns the name space, or schema, being
78932>>>>>>>>>>>>>>>>>/// used with the current application.
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Assumptions
78932>>>>>>>>>>>>>>>>>/// @Status      Public
78932>>>>>>>>>>>>>>>>>/// @Drivers     PgFlex
78932>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
78932>>>>>>>>>>>>>>>>>/// @See                 SET_NAME_SPACE
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Syntax GET_NAME_SPACE to {variable}
78932>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the returned name space.
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Example
78932>>>>>>>>>>>>>>>>>/// GET_NAME_SPACE to sNameSpace
78932>>>>>>>>>>>>>>>>>
78932>>>>>>>>>>>>>>>>>//=============================================================================
78932>>>>>>>>>>>>>>>>>/// @Name        SET_NAME_SPACE
78932>>>>>>>>>>>>>>>>>/// @Description This command sets the name space, or schema, to be used
78932>>>>>>>>>>>>>>>>>/// for the application. In Postgres, schemas are objects where all the
78932>>>>>>>>>>>>>>>>>/// tables,views and indexes are stored. Separate schemas are used to
78932>>>>>>>>>>>>>>>>>/// specify relational data. Note that this command will override the
78932>>>>>>>>>>>>>>>>>/// NAME_SPACE value in the INT file.
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Assumptions
78932>>>>>>>>>>>>>>>>>/// @Status      Public
78932>>>>>>>>>>>>>>>>>/// @Drivers     PgFlex
78932>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-14 By Ian Smith
78932>>>>>>>>>>>>>>>>>/// @See                 GET_NAME_SPACE
78932>>>>>>>>>>>>>>>>>/// @INTOPT              NAME_SPACE
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Syntax SET_NAME_SPACE to {variable}
78932>>>>>>>>>>>>>>>>>/// @Param variable                     Name of the name space
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Example
78932>>>>>>>>>>>>>>>>>/// SET_NAME_SPACE to "public"
78932>>>>>>>>>>>>>>>>>
78932>>>>>>>>>>>>>>>>>//=============================================================================
78932>>>>>>>>>>>>>>>>>/// @Name        SQL_USE_DATABASE
78932>>>>>>>>>>>>>>>>>/// @Description This command is used to specify which database is used
78932>>>>>>>>>>>>>>>>>/// for SQL statements only. Any normal table queries or changes will
78932>>>>>>>>>>>>>>>>>/// still use the default database, this only effects SQL statements.
78932>>>>>>>>>>>>>>>>>/// If none is specified then the default database is used. This can
78932>>>>>>>>>>>>>>>>>/// be useful if a certain SQL statement needs to query data from a
78932>>>>>>>>>>>>>>>>>/// database not currently being used. Note that this only works if
78932>>>>>>>>>>>>>>>>>/// the table name is not fully qualified in the SQl statement, i.e.
78932>>>>>>>>>>>>>>>>>/// "TestDB.Customer".
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Assumptions
78932>>>>>>>>>>>>>>>>>/// @Status      Public
78932>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex MySQLFLex PgSQL
78932>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
78932>>>>>>>>>>>>>>>>>/// @See                 SET_DATABASE_NAME GET_DATABASE_NAME
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Syntax SQL_USE_DATABASE of {server} to {database}
78932>>>>>>>>>>>>>>>>>/// @Param server                       Name of the server (Postgre only)
78932>>>>>>>>>>>>>>>>>/// @Param database                     Name of the database
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Example
78932>>>>>>>>>>>>>>>>>/// SQL_USE_DATABASE "testDB"
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
78932>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT
78932>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
78932>>>>>>>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sID sFirstName sLastName
78932>>>>>>>>>>>>>>>>>/// If (Found) Begin
78932>>>>>>>>>>>>>>>>>///     Showln sFirstName
78932>>>>>>>>>>>>>>>>>///     Showln sLastName
78932>>>>>>>>>>>>>>>>>/// End
78932>>>>>>>>>>>>>>>>>/// SQL_CANCEL_QUERY_STMT
78932>>>>>>>>>>>>>>>>>
78932>>>>>>>>>>>>>>>>>//=============================================================================
78932>>>>>>>>>>>>>>>>>/// @Name        SET_CURRENT_SQL_SERVER
78932>>>>>>>>>>>>>>>>>/// @Description This command is used to set the server to be used when
78932>>>>>>>>>>>>>>>>>/// opening tables. It will override the SERVER_NAME token in the INT file.
78932>>>>>>>>>>>>>>>>>/// If the server is not specified in the INT file or with this command,
78932>>>>>>>>>>>>>>>>>/// then the server used during login will be used. This command is only
78932>>>>>>>>>>>>>>>>>/// needed when connecting to multiple SQL servers. To set the server to
78932>>>>>>>>>>>>>>>>>/// use for embedded SQL statements, use SET_CURRENT_SQL_SERVER_CONNECTION.
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Assumptions
78932>>>>>>>>>>>>>>>>>/// @Status      Public
78932>>>>>>>>>>>>>>>>>/// @Drivers     All
78932>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
78932>>>>>>>>>>>>>>>>>/// @See                 GET_CURRENT_SQL_SERVER  SET_CURRENT_SQL_SERVER_CONNECTION GET_CURRENT_SQL_SERVER_CONNECTION
78932>>>>>>>>>>>>>>>>>/// @INTOPT              SERVER_NAME
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Syntax SET_CURRENT_SQL_SERVER to {server}
78932>>>>>>>>>>>>>>>>>/// @Param server                       Name of the server
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Example
78932>>>>>>>>>>>>>>>>>/// SET_CURRENT_SQL_SERVER to "localhost"
78932>>>>>>>>>>>>>>>>>
78932>>>>>>>>>>>>>>>>>//IGS - removed. CURRENT_SERVER is a property of Validation_List_Mixin so this
78932>>>>>>>>>>>>>>>>>//               replace conflicts with the property SET message.
78932>>>>>>>>>>>>>>>>>//#Replace SET_CURRENT_SERVER SET_CURRENT_SQL_SERVER
78932>>>>>>>>>>>>>>>>>
78932>>>>>>>>>>>>>>>>>//=============================================================================
78932>>>>>>>>>>>>>>>>>/// @Name        GET_CURRENT_SQL_SERVER
78932>>>>>>>>>>>>>>>>>/// @Description This command returns the name of the server to be used
78932>>>>>>>>>>>>>>>>>/// for opening and querying tables.
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Assumptions
78932>>>>>>>>>>>>>>>>>/// @Status      Public
78932>>>>>>>>>>>>>>>>>/// @Drivers     All
78932>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
78932>>>>>>>>>>>>>>>>>/// @See SET_CURRENT_SQL_SERVER SET_CURRENT_SQL_SERVER_CONNECTION GET_CURRENT_SQL_SERVER_CONNECTION
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Syntax GET_CURRENT_SERVER to {variable}
78932>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the server name
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Example
78932>>>>>>>>>>>>>>>>>/// GET_CURRENT_SQL_SERVER to sServer
78932>>>>>>>>>>>>>>>>>
78932>>>>>>>>>>>>>>>>>//IGS - removed. CURRENT_SERVER is a property of Validation_List_Mixin so this
78932>>>>>>>>>>>>>>>>>//               replace conflicts with the property GET message.
78932>>>>>>>>>>>>>>>>>//#Replace GET_CURRENT_SERVER GET_CURRENT_SQL_SERVER
78932>>>>>>>>>>>>>>>>>
78932>>>>>>>>>>>>>>>>>//=============================================================================
78932>>>>>>>>>>>>>>>>>/// @Name        SET_CURRENT_SQL_SERVER_CONNECTION
78932>>>>>>>>>>>>>>>>>/// @Description This command is used to specify which server to use for
78932>>>>>>>>>>>>>>>>>/// embedded SQL statements. By default, the last logged in server will
78932>>>>>>>>>>>>>>>>>/// be used. Note that in addition to setting the server, this command
78932>>>>>>>>>>>>>>>>>/// also sets the driver to be used. This command is only needed when
78932>>>>>>>>>>>>>>>>>/// connecting to multiple servers. To set the server for opening tables,
78932>>>>>>>>>>>>>>>>>/// use SET_CURRENT_SQL_SERVER.
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Assumptions
78932>>>>>>>>>>>>>>>>>/// @Status      Public
78932>>>>>>>>>>>>>>>>>/// @Drivers     All
78932>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
78932>>>>>>>>>>>>>>>>>/// @See                 GET_CURRENT_SQL_SERVER_CONNECTION GET_CURRENT_SQL_SERVER SET_CURRENT_SQL_SERVER
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Syntax SET_CURRENT_SQL_SERVER_CONNECTION of {constant} to {server}
78932>>>>>>>>>>>>>>>>>/// @Param constant                     MYSQLFLEX, ORAFLEX, PGFLEX, or SQLFLEX
78932>>>>>>>>>>>>>>>>>/// @Param server               Name of the server
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Example
78932>>>>>>>>>>>>>>>>>/// SET_CURRENT_SQL_SERVER_CONNECTION of SQLFLEX to "(localdb)\v11.0"
78932>>>>>>>>>>>>>>>>>
78932>>>>>>>>>>>>>>>>>//=============================================================================
78932>>>>>>>>>>>>>>>>>/// @Name        GET_CURRENT_SQL_SERVER_CONNECTION
78932>>>>>>>>>>>>>>>>>/// @Description This command returns the server currently being used for
78932>>>>>>>>>>>>>>>>>/// embedded SQL statements.
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Assumptions
78932>>>>>>>>>>>>>>>>>/// @Status      Public
78932>>>>>>>>>>>>>>>>>/// @Drivers     All
78932>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
78932>>>>>>>>>>>>>>>>>/// @See                 SET_CURRENT_SQL_SERVER_CONNECTION GET_CURRENT_SQL_SERVER SET_CURRENT_SQL_SERVER
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Syntax GET_CURRENT_SQL_SERVER_CONNECTION of {constant} to {variable}
78932>>>>>>>>>>>>>>>>>/// @Param constant                     MYSQLFLEX, ORAFLEX, PGFLEX, or SQLFLEX
78932>>>>>>>>>>>>>>>>>/// @Param variable             Variable to hold the name of the server
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Example
78932>>>>>>>>>>>>>>>>>/// GET_CURRENT_SQL_SERVER_CONNECTION of SQLFLEX to sServer
78932>>>>>>>>>>>>>>>>>
78932>>>>>>>>>>>>>>>>>//=============================================================================
78932>>>>>>>>>>>>>>>>>/// @Name        LOGIN_SQLFLEX
78932>>>>>>>>>>>>>>>>>/// @Description This command allows the user to login with a specified
78932>>>>>>>>>>>>>>>>>/// hostname. The default hostname that is passed is the path of the
78932>>>>>>>>>>>>>>>>>/// executable. Passing a custom hostname can be very useful for tracking
78932>>>>>>>>>>>>>>>>>/// a specific user for different situations. For example, if a company
78932>>>>>>>>>>>>>>>>>/// is using a terminal server and a whole sales team logs in under the
78932>>>>>>>>>>>>>>>>>/// same username and hostname, locating a specific user could otherwise
78932>>>>>>>>>>>>>>>>>/// be difficult. With this command, each user can pass a custom hostname,
78932>>>>>>>>>>>>>>>>>/// easily distinguishing themselves from other users.
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Assumptions
78932>>>>>>>>>>>>>>>>>/// @Status      Public
78932>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex
78932>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
78932>>>>>>>>>>>>>>>>>/// @See
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Syntax LOGIN_SQLFLEX {server} {username} {password} {hostname}
78932>>>>>>>>>>>>>>>>>/// @Param server               Server to use for login
78932>>>>>>>>>>>>>>>>>/// @Param username     Username to use for login
78932>>>>>>>>>>>>>>>>>/// @Param password     Password to use for login
78932>>>>>>>>>>>>>>>>>/// @Param hostname     Hostname to use for login
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Example
78932>>>>>>>>>>>>>>>>>/// LOGIN_SQLFLEX "localhost" "guestUser" "pas123" "WIN-MM7PQS5CP6C"
78932>>>>>>>>>>>>>>>>>
78932>>>>>>>>>>>>>>>>>//=============================================================================
78932>>>>>>>>>>>>>>>>>/// @Name        SQL_CANCEL_QUERY_STMT
78932>>>>>>>>>>>>>>>>>/// @Description This command is used to close any open cursors related to
78932>>>>>>>>>>>>>>>>>/// an SQL_EXECUTE_STMT. This should be used once the SQL statement has
78932>>>>>>>>>>>>>>>>>/// been executed and all rows have been fetched.
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Assumptions
78932>>>>>>>>>>>>>>>>>/// @Status      Public
78932>>>>>>>>>>>>>>>>>/// @Drivers     All
78932>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-03 by Aaron Gulack
78932>>>>>>>>>>>>>>>>>/// @See                 SQL_SET_STMT SQL_EXECUTE_STMT SQL_FETCH_NEXT_ROW SQL_APPEND_STMT SQL_PREPARE_STMT
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Syntax SQL_CANCEL_QUERY_STMT [of {FileName}]
78932>>>>>>>>>>>>>>>>>/// @Param FileName             Name of the file (optional)
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Example
78932>>>>>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
78932>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT
78932>>>>>>>>>>>>>>>>>/// SQL_BINDCOLUMNS_STMT of Customer to DF_BIND_ALL_COLUMNS
78932>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT of Customer
78932>>>>>>>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW of Customer
78932>>>>>>>>>>>>>>>>>/// If (Found) Begin
78932>>>>>>>>>>>>>>>>>///     Showln Customer.FirstName
78932>>>>>>>>>>>>>>>>>///     Showln Customer.LastName
78932>>>>>>>>>>>>>>>>>/// End
78932>>>>>>>>>>>>>>>>>/// SQL_CANCEL_QUERY_STMT of Customer
78932>>>>>>>>>>>>>>>>>
78932>>>>>>>>>>>>>>>>>//=============================================================================
78932>>>>>>>>>>>>>>>>>/// @Name        NATIVE_OPTIMIZATION
78932>>>>>>>>>>>>>>>>>/// @Description Allows user to turn off the use of index hints on the native
78932>>>>>>>>>>>>>>>>>/// server. Setting this command to DEFAULT will cause the server to use the
78932>>>>>>>>>>>>>>>>>/// default settings for hints. Hints are off by default in Microsoft SQL
78932>>>>>>>>>>>>>>>>>/// Server but are on in Oracle. Care should be taken with changing the
78932>>>>>>>>>>>>>>>>>/// default, and should only be used if the diagnostics tool for your server
78932>>>>>>>>>>>>>>>>>/// indicates performance problems with the type of queries that are being
78932>>>>>>>>>>>>>>>>>/// generated. Note that this can be turned off or on for the whole server
78932>>>>>>>>>>>>>>>>>/// or just for a specific table.
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// DEFAULT             - The specified server's default settings
78932>>>>>>>>>>>>>>>>>/// USE_INDEXHINT       - All Index hints will be used
78932>>>>>>>>>>>>>>>>>/// NO_INDEXHINT        - No index hints will be used
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Assumptions
78932>>>>>>>>>>>>>>>>>/// @Status      Public
78932>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex, ORAFlex
78932>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
78932>>>>>>>>>>>>>>>>>/// @See
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Syntax NATIVE_OPTIMIZATION of {scopeLevel} {variable} to {constant}
78932>>>>>>>>>>>>>>>>>/// @Param scopeLevel           TABLE or SERVER. Indicates the scope of the setting
78932>>>>>>>>>>>>>>>>>/// @Param variable                     Either the name of the server or of the table
78932>>>>>>>>>>>>>>>>>/// @Param constant                     DEFAULT, USE_INDEXHINT, or NO_INDEXHINT
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Example
78932>>>>>>>>>>>>>>>>>/// NATIVE_OPTIMIZATION of SERVER "localhost" to USE_INDEXHINT
78932>>>>>>>>>>>>>>>>>
78932>>>>>>>>>>>>>>>>>//=============================================================================
78932>>>>>>>>>>>>>>>>>/// @Name        SET_ISOLATION_LEVEL
78932>>>>>>>>>>>>>>>>>/// @Description This command sets the locking and row versioning behavior
78932>>>>>>>>>>>>>>>>>/// for SQL statements. See the options below for information on the various
78932>>>>>>>>>>>>>>>>>/// effects they can have on transactions.
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// DEFAULT  - The default isolation level for the server (READ_COMMITTED
78932>>>>>>>>>>>>>>>>>/// for MSSQL).
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// READ_COMMITTED - This option is used to prevent dirty reads. A dirty
78932>>>>>>>>>>>>>>>>>/// read is when one transaction reads data from another transaction that
78932>>>>>>>>>>>>>>>>>/// has yet to be committed. If one transaction fails, the other now is
78932>>>>>>>>>>>>>>>>>/// dealing with invalid data. By setting the isolation level to
78932>>>>>>>>>>>>>>>>>/// READ_COMMITTED, dirty reads will be avoided by not allowing transactions
78932>>>>>>>>>>>>>>>>>/// to deal with any other data that has not been committed yet. However,
78932>>>>>>>>>>>>>>>>>/// in between statements within the current transaction, data can be changed
78932>>>>>>>>>>>>>>>>>/// by other transactions. This can result in phantom data or non-repeatable
78932>>>>>>>>>>>>>>>>>/// reads. Note that this can slow down performance speeds but is usually
78932>>>>>>>>>>>>>>>>>/// good practice.
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// READ_UNCOMMITTED - This option is the least restrictive isolation level.
78932>>>>>>>>>>>>>>>>>/// With this option, dirty reads are allowed, thus no exclusive locks are
78932>>>>>>>>>>>>>>>>>/// honored and modified data from one uncommitted transaction can be read
78932>>>>>>>>>>>>>>>>>/// by other transactions.
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// REPEATABLE_READ - This option is similar to the READ_COMMITTED option
78932>>>>>>>>>>>>>>>>>/// in that locks all placed on all transactions and uncommitted data from
78932>>>>>>>>>>>>>>>>>///     other transactions cannot be read, preventing dirty reads. However, unlike
78932>>>>>>>>>>>>>>>>>/// READ_COMMITTED, new rows that are added by other transactions can be read
78932>>>>>>>>>>>>>>>>>/// by the current transaction if it is retried, possibly resulting in phantom
78932>>>>>>>>>>>>>>>>>/// reads. This option should not be used unless there is a specific reason to
78932>>>>>>>>>>>>>>>>>/// do so.
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// SERIALIZABLE - This option is the most restrictive isolation level. With
78932>>>>>>>>>>>>>>>>>/// this option, no interaction is allowed between transactions until they
78932>>>>>>>>>>>>>>>>>/// have been committed. Similar to READ_COMMITTED, no transaction can deal
78932>>>>>>>>>>>>>>>>>/// with any uncommitted data. On top of that though, range locks are placed on
78932>>>>>>>>>>>>>>>>>/// all rows being modified until the current transaction is complete. Because
78932>>>>>>>>>>>>>>>>>/// concurrency is so low with this option, performance speeds can be much lower
78932>>>>>>>>>>>>>>>>>/// and so this should only be used when there is a specific reason to do so.
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Assumptions
78932>>>>>>>>>>>>>>>>>/// @Status      Public
78932>>>>>>>>>>>>>>>>>/// @Drivers     All
78932>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
78932>>>>>>>>>>>>>>>>>/// @See
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Syntax SET_ISOLATION_LEVEL of {server} to {constant}
78932>>>>>>>>>>>>>>>>>/// @Param server                       Name of the server
78932>>>>>>>>>>>>>>>>>/// @Param constant                     DEFAULT, READ_COMMITTED, READ_UNCOMMITTED, REPEATABLE_READ, or SERIALIZABLE
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Example
78932>>>>>>>>>>>>>>>>>/// LOGIN "localhost" "user" "pass123" "SQL_DRV"
78932>>>>>>>>>>>>>>>>>/// SET_ISOLATION_LEVEL of "localhost" to READ_COMMITTED
78932>>>>>>>>>>>>>>>>>
78932>>>>>>>>>>>>>>>>>//=============================================================================
78932>>>>>>>>>>>>>>>>>/// @Name        SET_SESSION_PARAMETER
78932>>>>>>>>>>>>>>>>>/// @Description There are two sets of code pages used in windows, ANSI and
78932>>>>>>>>>>>>>>>>>/// OEM. ANSI is what is commonly used now, but some data still uses the OEM
78932>>>>>>>>>>>>>>>>>/// code pages. When migrating data, this command is used to determine whether
78932>>>>>>>>>>>>>>>>>/// the OEM data will be translated to ANSI during the migration. For example,
78932>>>>>>>>>>>>>>>>>/// migrating passwords with special characters may call for different code
78932>>>>>>>>>>>>>>>>>/// pages. Sending true will convert the OEM data to ANSI, sending false will
78932>>>>>>>>>>>>>>>>>/// not. Both OEM_TO_ANSI and OEM_TRANSLATION_STATE do essentially the same
78932>>>>>>>>>>>>>>>>>/// thing, however since MSSQL has the functionality built in, OEM_TO_ANSI
78932>>>>>>>>>>>>>>>>>/// will use MSSQL's built in translation and thus only works with SQLFlex.
78932>>>>>>>>>>>>>>>>>/// OEM_TRANSLATION_STATE is internal and built into the driver so it works
78932>>>>>>>>>>>>>>>>>/// for all drivers. Note that if using custom entries with
78932>>>>>>>>>>>>>>>>>/// SET_CUSTOM_OEM_TO_ANSI then OEM_TRANSLATION_STATE must be used. Also, if
78932>>>>>>>>>>>>>>>>>/// there are already custom entries set then turning OEM_TRANSLATION_STATE
78932>>>>>>>>>>>>>>>>>/// on will automatically enable those custom translations.
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Assumptions
78932>>>>>>>>>>>>>>>>>/// @Status      Public
78932>>>>>>>>>>>>>>>>>/// @Drivers     All
78932>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
78932>>>>>>>>>>>>>>>>>/// @See                 SET_CUSTOM_OEM_TO_ANSI GET_CUSTOM_OEM_TO_ANSI
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Syntax SET_SESSION_PARAMETER {OEM_TO_ANSI/OEM_TRANSLATION_STATE} to {variable}
78932>>>>>>>>>>>>>>>>>/// @Param variable                     Boolean variable enabling or disabling translation
78932>>>>>>>>>>>>>>>>>///
78932>>>>>>>>>>>>>>>>>/// @Example
78932>>>>>>>>>>>>>>>>>/// SET_SESSION_PARAMETER OEM_TO_ANSI to True
78932>>>>>>>>>>>>>>>>>
78932>>>>>>>>>>>>>>>>>Procedure MertechInc_SET_CUSTOM_OEM_TO_ANSI Global Integer iChar Integer iOem Integer iAnsi
78934>>>>>>>>>>>>>>>>>    Move iChar to MertechInc_sArg1
78935>>>>>>>>>>>>>>>>>    move (String(iOem) + "," + String(iAnsi)) to MertechInc_sArg2
78936>>>>>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_LICENSE_ENVIRONMENT_SET CALLBACK 0 PASSING MertechInc_sArg1 MertechInc_sArg2 CALLDRV_SET_CUSTOM_OEM_TO_ANSI RESULT MertechInc_iRet
78941>>>>>>>>>>>>>>>>>    IF MertechInc_iRet EQ -1 INDICATE ERR TRUE
78944>>>>>>>>>>>>>>>>>End_Procedure
78945>>>>>>>>>>>>>>>>>
78945>>>>>>>>>>>>>>>>>//=============================================================================
78945>>>>>>>>>>>>>>>>>/// @Name        SET_CUSTOM_OEM_TO_ANSI
78945>>>>>>>>>>>>>>>>>/// @Description In very rare situations, a custom OEM to ANSI translation
78945>>>>>>>>>>>>>>>>>/// is needed. When that is the case, this command can be used to create
78945>>>>>>>>>>>>>>>>>/// those custom entries. This is done by passing the character numbered
78945>>>>>>>>>>>>>>>>>/// position, the OEM value and the ANSI value. Note that
78945>>>>>>>>>>>>>>>>>/// OEM_TRANSLATION_STATE must be set to true for these custom entries to
78945>>>>>>>>>>>>>>>>>/// work.
78945>>>>>>>>>>>>>>>>>///
78945>>>>>>>>>>>>>>>>>/// @Assumptions
78945>>>>>>>>>>>>>>>>>/// @Status      Public
78945>>>>>>>>>>>>>>>>>/// @Drivers     All
78945>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
78945>>>>>>>>>>>>>>>>>/// @See                 GET_CUSTOM_OEM_TO_ANSI SET_SESSION_PARAMETER
78945>>>>>>>>>>>>>>>>>///
78945>>>>>>>>>>>>>>>>>/// @Syntax SET_CUSTOM_OEM_TO_ANSI {character} to OEM {value1} ANSI {value2}
78945>>>>>>>>>>>>>>>>>/// @Param character            Numbered position (0-255) of the character
78945>>>>>>>>>>>>>>>>>/// @Param value1                       Character number for the OEM value
78945>>>>>>>>>>>>>>>>>/// @Param value2                       Character number for the ANSI value
78945>>>>>>>>>>>>>>>>>
78945>>>>>>>>>>>>>>>>>Procedure MertechInc_GET_CUSTOM_OEM_TO_ANSI Global Integer iChar Integer iOem Integer iAnsi
78947>>>>>>>>>>>>>>>>>    Move iChar to MertechInc_sArg1
78948>>>>>>>>>>>>>>>>>    Move (Repeat(" ", 255)) to MertechInc_sArg2
78949>>>>>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_LICENSE_ENVIRONMENT_SET CALLBACK 0 PASSING MertechInc_sArg1 MertechInc_sArg2 CALLDRV_GET_CUSTOM_OEM_TO_ANSI RESULT MertechInc_iRet
78954>>>>>>>>>>>>>>>>>    IF MertechInc_iRet EQ -1 INDICATE ERR TRUE
78957>>>>>>>>>>>>>>>>>End_Function
78958>>>>>>>>>>>>>>>>>
78958>>>>>>>>>>>>>>>>>//=============================================================================
78958>>>>>>>>>>>>>>>>>/// @Name        GET_CUSTOM_OEM_TO_ANSI
78958>>>>>>>>>>>>>>>>>/// @Description This command returns the custom OEM and ANSI values
78958>>>>>>>>>>>>>>>>>/// respectively for a given character. If there is no custom translation
78958>>>>>>>>>>>>>>>>>/// for the specified character then no error will be raised, but nothing
78958>>>>>>>>>>>>>>>>>/// will be returned.
78958>>>>>>>>>>>>>>>>>///
78958>>>>>>>>>>>>>>>>>/// @Assumptions There exists a custom translation for the specified character
78958>>>>>>>>>>>>>>>>>/// @Status      Public
78958>>>>>>>>>>>>>>>>>/// @Drivers     All
78958>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
78958>>>>>>>>>>>>>>>>>/// @See
78958>>>>>>>>>>>>>>>>>///
78958>>>>>>>>>>>>>>>>>/// @Syntax SET_CUSTOM_OEM_TO_ANSI {character} to OEM {value1} ANSI {value2}
78958>>>>>>>>>>>>>>>>>/// @Param character            Numbered position (0-255) of the character
78958>>>>>>>>>>>>>>>>>/// @Param value1                       Variable to hold the OEM value
78958>>>>>>>>>>>>>>>>>/// @Param value2                       Variable to hold the ANSI value
78958>>>>>>>>>>>>>>>>>
78958>>>>>>>>>>>>>>>>>//=============================================================================
78958>>>>>>>>>>>>>>>>>/// @Name        SET_AUTOMATIC_NUMERIC_DATATYPE_REMAPPING
78958>>>>>>>>>>>>>>>>>/// @Description This command toggles off and on the automatic numeric
78958>>>>>>>>>>>>>>>>>/// data type remapping built into SQLFlex. When adding or creating
78958>>>>>>>>>>>>>>>>>/// smaller numeric columns during a restructure, SQLFlex will change
78958>>>>>>>>>>>>>>>>>/// the type to a more specific data type i.e. smallint or tinyint since
78958>>>>>>>>>>>>>>>>>/// they are handled more efficiently by the server. Sending false to this
78958>>>>>>>>>>>>>>>>>/// command will force SQl to keep the column as a numeric field, preserving
78958>>>>>>>>>>>>>>>>>/// the length and precision. Passing true will leave the remapping up to the
78958>>>>>>>>>>>>>>>>>/// driver.
78958>>>>>>>>>>>>>>>>>///
78958>>>>>>>>>>>>>>>>>/// @Assumptions
78958>>>>>>>>>>>>>>>>>/// @Status      Public
78958>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex
78958>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
78958>>>>>>>>>>>>>>>>>/// @See
78958>>>>>>>>>>>>>>>>>///
78958>>>>>>>>>>>>>>>>>/// @Syntax SET_AUTOMATIC_NUMERIC_DATATYPE_REMAPPING to {variable}
78958>>>>>>>>>>>>>>>>>/// @Param variable                     Boolean variable enabling or disabling remapping
78958>>>>>>>>>>>>>>>>>///
78958>>>>>>>>>>>>>>>>>/// @Example
78958>>>>>>>>>>>>>>>>>/// Structure_Start hFile
78958>>>>>>>>>>>>>>>>>///
78958>>>>>>>>>>>>>>>>>///     Create_Field hFile
78958>>>>>>>>>>>>>>>>>///
78958>>>>>>>>>>>>>>>>>///     SET_AUTOMATIC_NUMERIC_DATATYPE_REMAPPING to False
78958>>>>>>>>>>>>>>>>>///
78958>>>>>>>>>>>>>>>>>///     Set_Attribute DF_FIELD_NAME   of hFile iColumn to "Transaction_Count"
78958>>>>>>>>>>>>>>>>>///     Set_Attribute DF_FIELD_TYPE   of hFile iColumn to DF_BCD
78958>>>>>>>>>>>>>>>>>///     Set_Attribute DF_FIELD_LENGTH of hFile iColumn to 1
78958>>>>>>>>>>>>>>>>>///
78958>>>>>>>>>>>>>>>>>/// Structure_End hFile
78958>>>>>>>>>>>>>>>>>
78958>>>>>>>>>>>>>>>>>//=============================================================================
78958>>>>>>>>>>>>>>>>>/// @Name        SET_FORCE_DATE_FORMAT_INIT
78958>>>>>>>>>>>>>>>>>/// @Description At times, a stored procedure, function or trigger may
78958>>>>>>>>>>>>>>>>>/// alter the default format for dates. This could cause problems because,
78958>>>>>>>>>>>>>>>>>/// for example, if a trigger on a table does this, then every time a save
78958>>>>>>>>>>>>>>>>>/// takes place on that table, the format for dates will be changed. By
78958>>>>>>>>>>>>>>>>>/// sending true to this command, the date formats will reset to their
78958>>>>>>>>>>>>>>>>>/// default format. Note that this is essentially the same thing as running
78958>>>>>>>>>>>>>>>>>/// the SQL statement: "ALTER SESSION SET NLS_DATE_FORMAT='MM/DD/YYYY'", so
78958>>>>>>>>>>>>>>>>>/// in most situations, that should be used instead of this command.
78958>>>>>>>>>>>>>>>>>///
78958>>>>>>>>>>>>>>>>>/// @Assumptions
78958>>>>>>>>>>>>>>>>>/// @Status      Deprecated
78958>>>>>>>>>>>>>>>>>/// @Drivers     ORAFlex
78958>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
78958>>>>>>>>>>>>>>>>>/// @See
78958>>>>>>>>>>>>>>>>>///
78958>>>>>>>>>>>>>>>>>/// @Syntax SET_FORCE_DATE_FORMAT_INIT to {variable}
78958>>>>>>>>>>>>>>>>>/// @Param variable             Boolean variable enabling or disabling format reset
78958>>>>>>>>>>>>>>>>>
78958>>>>>>>>>>>>>>>>>//=============================================================================
78958>>>>>>>>>>>>>>>>>/// @Name        SET_STATIC_TABLE_OPTIMIZATION
78958>>>>>>>>>>>>>>>>>/// @Description At this time, this command no longer serves any function.
78958>>>>>>>>>>>>>>>>>///
78958>>>>>>>>>>>>>>>>>/// @Assumptions
78958>>>>>>>>>>>>>>>>>/// @Status      Deprecated
78958>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex
78958>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
78958>>>>>>>>>>>>>>>>>/// @See
78958>>>>>>>>>>>>>>>>>///
78958>>>>>>>>>>>>>>>>>/// @Syntax SET_STATIC_TABLE_OPTIMIZATION to {ENABLED/DISABLED}
78958>>>>>>>>>>>>>>>>>
78958>>>>>>>>>>>>>>>>>//=============================================================================
78958>>>>>>>>>>>>>>>>>/// @Name        GET_MAX_OBJECT_NAME_LENGTH
78958>>>>>>>>>>>>>>>>>/// @Description This command returns the maximum length allowed for object
78958>>>>>>>>>>>>>>>>>/// names in the SQl backend. This includes table names, column names,
78958>>>>>>>>>>>>>>>>>/// database names etc. The maximum length in put into the specified variable.
78958>>>>>>>>>>>>>>>>>///
78958>>>>>>>>>>>>>>>>>/// @Assumptions
78958>>>>>>>>>>>>>>>>>/// @Status      Public
78958>>>>>>>>>>>>>>>>>/// @Drivers     All
78958>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
78958>>>>>>>>>>>>>>>>>/// @See
78958>>>>>>>>>>>>>>>>>///
78958>>>>>>>>>>>>>>>>>/// @Syntax GET_MAX_OBJECT_NAME_LENGTH to {variable}
78958>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the maximum length
78958>>>>>>>>>>>>>>>>>///
78958>>>>>>>>>>>>>>>>>/// @Example
78958>>>>>>>>>>>>>>>>>/// GET_MAX_OBJECT_NAME_LENGTH to iMaxLength
78958>>>>>>>>>>>>>>>>>
78958>>>>>>>>>>>>>>>>>//=============================================================================
78958>>>>>>>>>>>>>>>>>/// @Name        SET_SQL_LOCK_TIMEOUT
78958>>>>>>>>>>>>>>>>>/// @Description This command is used to set the number of milliseconds
78958>>>>>>>>>>>>>>>>>/// an SQL statement waits for a database lock to be released before timing
78958>>>>>>>>>>>>>>>>>/// out. Locks are used with transactions to maintain atomicity. If a lock is
78958>>>>>>>>>>>>>>>>>/// not released before the timeout, then the statement will fail and an error
78958>>>>>>>>>>>>>>>>>/// will be raised. By default, the timeout is set to -1, indicating that
78958>>>>>>>>>>>>>>>>>/// statements will wait indefinitely before timing out.
78958>>>>>>>>>>>>>>>>>///
78958>>>>>>>>>>>>>>>>>/// @Assumptions
78958>>>>>>>>>>>>>>>>>/// @Status      Public
78958>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex
78958>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
78958>>>>>>>>>>>>>>>>>/// @See                 GET_SQL_LOCK_TIMEOUT
78958>>>>>>>>>>>>>>>>>///
78958>>>>>>>>>>>>>>>>>/// @Syntax SET_SQL_LOCAL_TIMEOUT of {server} to {variable}
78958>>>>>>>>>>>>>>>>>/// @Param server                       Name of the server
78958>>>>>>>>>>>>>>>>>/// @Param variable                     Number of milliseconds to wait until timeout
78958>>>>>>>>>>>>>>>>>///
78958>>>>>>>>>>>>>>>>>/// @Example
78958>>>>>>>>>>>>>>>>>/// SET_SQL_LOCK_TIMEOUT of "localhost" to 6000
78958>>>>>>>>>>>>>>>>>
78958>>>>>>>>>>>>>>>>>//=============================================================================
78958>>>>>>>>>>>>>>>>>/// @Name        GET_SQL_LOCK_TIMEOUT
78958>>>>>>>>>>>>>>>>>/// @Description This command returns the number of milliseconds an SQL
78958>>>>>>>>>>>>>>>>>/// statement will wait for a database lock to be released. If the lock
78958>>>>>>>>>>>>>>>>>/// is not released before the timeout, then the statement will fail and
78958>>>>>>>>>>>>>>>>>/// an error will be raised. Note that the default value is -1, indicating
78958>>>>>>>>>>>>>>>>>/// that the statement will wait indefinitely.
78958>>>>>>>>>>>>>>>>>///
78958>>>>>>>>>>>>>>>>>/// @Assumptions
78958>>>>>>>>>>>>>>>>>/// @Status      Public
78958>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex
78958>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
78958>>>>>>>>>>>>>>>>>/// @See                 SET_SQL_LOCK_TIMEOUT
78958>>>>>>>>>>>>>>>>>///
78958>>>>>>>>>>>>>>>>>/// @Syntax GET_SQL_LOCAL_TIMEOUT of {server} to {variable}
78958>>>>>>>>>>>>>>>>>/// @Param server                       Name of the server
78958>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the number of milliseconds
78958>>>>>>>>>>>>>>>>>///
78958>>>>>>>>>>>>>>>>>/// @Example
78958>>>>>>>>>>>>>>>>>/// GET_SQL_LOCK_TIMEOUT of "localhost" to iTimeout
78958>>>>>>>>>>>>>>>>>
78958>>>>>>>>>>>>>>>>>//=============================================================================
78958>>>>>>>>>>>>>>>>>/// @Name        DO_GET_SQLSERVER_PARAMETERS
78958>>>>>>>>>>>>>>>>>/// @Description Retrieves stored procedure parameter values.
78958>>>>>>>>>>>>>>>>>///
78958>>>>>>>>>>>>>>>>>/// @Assumptions
78958>>>>>>>>>>>>>>>>>/// @Status      Internal
78958>>>>>>>>>>>>>>>>>/// @Drivers     All
78958>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-18 By Ian Smith
78958>>>>>>>>>>>>>>>>>/// @See
78958>>>>>>>>>>>>>>>>>
78958>>>>>>>>>>>>>>>>>Function MertechInc_DO_GET_SQLSERVER_PARAMETERS Global Integer iParameter Returns String
78960>>>>>>>>>>>>>>>>>    String sValue
78960>>>>>>>>>>>>>>>>>
78960>>>>>>>>>>>>>>>>>    Get MertechInc_Pre_Size_String 0 to sValue //Need to check if Call_Driver needs pre sized strings. Until then assume it does
78961>>>>>>>>>>>>>>>>>    Call_Driver MertechInc_FileNumber MertechInc_DriverName Function 24 CALLBACK 0 PASSING sValue MertechInc_Blank iParameter RESULT MertechInc_iRet
78966>>>>>>>>>>>>>>>>>
78966>>>>>>>>>>>>>>>>>    Function_Return sValue
78967>>>>>>>>>>>>>>>>>End_Function
78968>>>>>>>>>>>>>>>>>
78968>>>>>>>>>>>>>>>>>//=============================================================================
78968>>>>>>>>>>>>>>>>>/// @Name        DO_BIND_SQLSERVER_PARAMETERS
78968>>>>>>>>>>>>>>>>>/// @Description Binds parameters for stored procedure call.
78968>>>>>>>>>>>>>>>>>///
78968>>>>>>>>>>>>>>>>>/// @Assumptions
78968>>>>>>>>>>>>>>>>>/// @Status      Internal
78968>>>>>>>>>>>>>>>>>/// @Drivers     All
78968>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-18 By Ian Smith
78968>>>>>>>>>>>>>>>>>/// @See
78968>>>>>>>>>>>>>>>>>
78968>>>>>>>>>>>>>>>>>Procedure MertechInc_DO_BIND_SQLSERVER_PARAMETERS Global String sDirection String sParameter Integer iSize
78970>>>>>>>>>>>>>>>>>    Call_Driver 0 SQLFLEX Function CALLDRV_BIND_PARAMETER CALLBACK 0 PASSING sDirection sParameter iSize RESULT MertechInc_iRet
78975>>>>>>>>>>>>>>>>>End_Procedure
78976>>>>>>>>>>>>>>>>>
78976>>>>>>>>>>>>>>>>>//=============================================================================
78976>>>>>>>>>>>>>>>>>/// @Name        DO_CHECK_BINDING
78976>>>>>>>>>>>>>>>>>/// @Description Sets MertechInc_bThereIsBinding True if any of the
78976>>>>>>>>>>>>>>>>>/// parameters is the keyword BINDING.
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Assumptions
78976>>>>>>>>>>>>>>>>>/// @Status      Internal
78976>>>>>>>>>>>>>>>>>/// @Drivers     All
78976>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-18 By Ian Smith
78976>>>>>>>>>>>>>>>>>/// @See
78976>>>>>>>>>>>>>>>>>
78976>>>>>>>>>>>>>>>>>//=============================================================================
78976>>>>>>>>>>>>>>>>>/// @Name        DO_FETCH_FIRST_ROW
78976>>>>>>>>>>>>>>>>>/// @Description Recursive - drops first parameter until the first parameter
78976>>>>>>>>>>>>>>>>>/// is BINDING and then calls SQL_FETCH_NEXT_ROW passing remaining parameters.
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Assumptions
78976>>>>>>>>>>>>>>>>>/// @Status      Internal
78976>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex
78976>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-18 By Ian Smith
78976>>>>>>>>>>>>>>>>>/// @See
78976>>>>>>>>>>>>>>>>>
78976>>>>>>>>>>>>>>>>>
78976>>>>>>>>>>>>>>>>>
78976>>>>>>>>>>>>>>>>>
78976>>>>>>>>>>>>>>>>>//=============================================================================
78976>>>>>>>>>>>>>>>>>/// @Name        CALL_STORED_PROCEDURE
78976>>>>>>>>>>>>>>>>>/// @Description This command is used to call a stored procedure on the SQL
78976>>>>>>>>>>>>>>>>>/// backend. To successfully call a procedure with this command, a string
78976>>>>>>>>>>>>>>>>>/// must be passed containing a valid procedure name. In addition, if the
78976>>>>>>>>>>>>>>>>>/// procedure takes any arguments, they must also be passed using the constant
78976>>>>>>>>>>>>>>>>>/// "passing" along with all of the needed arguments. If the procedure has a
78976>>>>>>>>>>>>>>>>>/// return value, then SQL_GET_FUNCTION_RETURN or SQL_FETCH_NEXT_ROW can be
78976>>>>>>>>>>>>>>>>>/// used to get the value(s). If an error is found then the indicator "Err"
78976>>>>>>>>>>>>>>>>>/// is set to true.
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Assumptions
78976>>>>>>>>>>>>>>>>>/// @Status      Public
78976>>>>>>>>>>>>>>>>>/// @Drivers     All
78976>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-25 by Aaron Gulack
78976>>>>>>>>>>>>>>>>>/// @See
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Syntax CALL_STORED_PROCEDURE {procedure} Passing {variable}
78976>>>>>>>>>>>>>>>>>/// @Param procedure            Full name of the procedure
78976>>>>>>>>>>>>>>>>>/// @Param variable                     Argument being passed (can be multiple)
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Example
78976>>>>>>>>>>>>>>>>>/// CALL_STORED_PROCEDURE "sys.sp_addmessage" passing 50003 15 "Please enter a valid date"
78976>>>>>>>>>>>>>>>>>
78976>>>>>>>>>>>>>>>>>//=============================================================================
78976>>>>>>>>>>>>>>>>>/// @Name        CALL_SQLSERVER_PROCEDURE
78976>>>>>>>>>>>>>>>>>/// @Description This command is used to call a stored procedure on the SQL
78976>>>>>>>>>>>>>>>>>/// backend. To successfully call a procedure with this command, a string
78976>>>>>>>>>>>>>>>>>/// must be passed containing a valid procedure name. In addition, if the
78976>>>>>>>>>>>>>>>>>/// procedure takes any arguments, they must also be passed using the constant
78976>>>>>>>>>>>>>>>>>/// "passing" along with all of the needed arguments. If the procedure has a
78976>>>>>>>>>>>>>>>>>/// return value, then SQL_GET_FUNCTION_RETURN, SQL_FETCH_NEXT_ROW or
78976>>>>>>>>>>>>>>>>>/// GET_PROCEDURE_RETURN can be used to get the value(s). If an error is found
78976>>>>>>>>>>>>>>>>>/// then the indicator "Err" is set to true.
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Status      Deprecated
78976>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex
78976>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
78976>>>>>>>>>>>>>>>>>/// @See                 CALL_STORED_PROCEDURE
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Syntax CALL_SQLSERVER_PROCEDURE {procedure} Passing {variable}
78976>>>>>>>>>>>>>>>>>/// @Param procedure            Full name of the procedure
78976>>>>>>>>>>>>>>>>>/// @Param variable                     Argument to be passed (can be multiple)
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Example
78976>>>>>>>>>>>>>>>>>/// CALL_SQLSERVER_PROCEDURE "sys.sp_addmessage" passing 50003 15 "Please enter a valid date"
78976>>>>>>>>>>>>>>>>>
78976>>>>>>>>>>>>>>>>>//=============================================================================
78976>>>>>>>>>>>>>>>>>/// @Name        END_CALL_PROCEDURE
78976>>>>>>>>>>>>>>>>>/// @Description This command is used to close any open cursors created
78976>>>>>>>>>>>>>>>>>/// by the respective stored procedure. Cursors are used in MSSQL to make
78976>>>>>>>>>>>>>>>>>/// the results from one procedure temporarily available to other procedures
78976>>>>>>>>>>>>>>>>>/// or triggers. To avoid causing unwanted results, it is good practice to
78976>>>>>>>>>>>>>>>>>/// use this command once a procedure call is completed.
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Assumptions
78976>>>>>>>>>>>>>>>>>/// @Status      Public
78976>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex
78976>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
78976>>>>>>>>>>>>>>>>>/// @See                 CALL_STORED_PROCEDURE
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Syntax END_CALL_PROCEDURE
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Example
78976>>>>>>>>>>>>>>>>>/// CALL_STORED_PROCEDURE "sys.sp_spaceused" Passing "Customer"
78976>>>>>>>>>>>>>>>>>/// GET_PROCEDURE_RETURN to sValue
78976>>>>>>>>>>>>>>>>>/// END_CALL_PROCEDURE
78976>>>>>>>>>>>>>>>>>/// Showln sValue
78976>>>>>>>>>>>>>>>>>
78976>>>>>>>>>>>>>>>>>//=============================================================================
78976>>>>>>>>>>>>>>>>>/// @Name        GET_PROCEDURE_RETURN
78976>>>>>>>>>>>>>>>>>/// @Description This command is used to get a returned value from a stored
78976>>>>>>>>>>>>>>>>>/// procedure using MSSQL. Note that this command can only handle one
78976>>>>>>>>>>>>>>>>>/// returned value and must be used after the procedure has already been
78976>>>>>>>>>>>>>>>>>/// built and executed.
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Assumptions
78976>>>>>>>>>>>>>>>>>/// @Status      Public
78976>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex
78976>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
78976>>>>>>>>>>>>>>>>>/// @See
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Syntax GET_PROCEDURE_RETURN to {variable}
78976>>>>>>>>>>>>>>>>>/// @Param variable             Variable to hold the returned value
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Example
78976>>>>>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_NAME "sys.sp_spaceused" NUMPAR 1
78976>>>>>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 1 to "Customer" IN
78976>>>>>>>>>>>>>>>>>/// SQL_PROCEDURE_EXECUTE
78976>>>>>>>>>>>>>>>>>/// GET_PROCEDURE_RETURN to sSpaceUsed
78976>>>>>>>>>>>>>>>>>/// Showln sSpaceUsed
78976>>>>>>>>>>>>>>>>>
78976>>>>>>>>>>>>>>>>>//=============================================================================
78976>>>>>>>>>>>>>>>>>/// @Name        SET_MIRROR_SERVER
78976>>>>>>>>>>>>>>>>>/// @Description This command is used to programmatically set the mirror
78976>>>>>>>>>>>>>>>>>/// server for the database. This is to be used along with SQl server
78976>>>>>>>>>>>>>>>>>/// failover mirroring. Note that this simply sets the server and database
78976>>>>>>>>>>>>>>>>>/// to be used for mirroring. All set up for the servers must already be
78976>>>>>>>>>>>>>>>>>/// working properly through SQL Server.
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Assumptions A compatible version of SQL Server is being used
78976>>>>>>>>>>>>>>>>>/// @Status      Public
78976>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex v9.2 and above
78976>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
78976>>>>>>>>>>>>>>>>>/// @See                 GET_MIRROR_SERVER
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Syntax SET_MIRROR_SERVER to {server} {database}
78976>>>>>>>>>>>>>>>>>/// @Param server                       The name of the mirror server
78976>>>>>>>>>>>>>>>>>/// @Param database                     The database acting as a mirror
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Example
78976>>>>>>>>>>>>>>>>>/// SET_MIRROR_SERVER to "(localdb)\v11.0" "MirrorDB"
78976>>>>>>>>>>>>>>>>>
78976>>>>>>>>>>>>>>>>>//=============================================================================
78976>>>>>>>>>>>>>>>>>/// @Name        GET_MIRROR_SERVER
78976>>>>>>>>>>>>>>>>>/// @Description This command is used to get the name of the server
78976>>>>>>>>>>>>>>>>>/// and database being used for failover mirroring. Mirroring must
78976>>>>>>>>>>>>>>>>>/// be properly set up in SQL Server for this command to return the
78976>>>>>>>>>>>>>>>>>/// correct values.
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Assumptions
78976>>>>>>>>>>>>>>>>>/// @Status      Public
78976>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex v9.2 and above
78976>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
78976>>>>>>>>>>>>>>>>>/// @See                 SET_MIRROR_SERVER
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Syntax GET_MIRROR_SERVER to {server} {database}
78976>>>>>>>>>>>>>>>>>/// @Param server                       Variable to hold the name of the mirrored server
78976>>>>>>>>>>>>>>>>>/// @Param database                     Variable to hold the name of the mirrored database
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Example
78976>>>>>>>>>>>>>>>>>/// GET_MIRROR_SERVER to sServer sDatabase
78976>>>>>>>>>>>>>>>>>
78976>>>>>>>>>>>>>>>>>//=============================================================================
78976>>>>>>>>>>>>>>>>>/// @Name        COPY_DATA
78976>>>>>>>>>>>>>>>>>/// @Description This command is used to copy data from a DAT file to an
78976>>>>>>>>>>>>>>>>>/// SQL table. Both the source and the destination files are opened, the
78976>>>>>>>>>>>>>>>>>/// data is copied and then the files are closed. This is usually used
78976>>>>>>>>>>>>>>>>>/// along with CREATE_TABLE_FROM_DAT_FILE, which creates the structure
78976>>>>>>>>>>>>>>>>>/// and then this command will insert the data. If needed, this command
78976>>>>>>>>>>>>>>>>>/// can also work backwards, copying data from an SQL table to a DAT file.
78976>>>>>>>>>>>>>>>>>/// This is an alternative to using the Flex2SQL Migration Tool and can
78976>>>>>>>>>>>>>>>>>/// improve performance when used in the right situations. Note that in
78976>>>>>>>>>>>>>>>>>/// order for this process to work properly the table being copied can not
78976>>>>>>>>>>>>>>>>>/// be opened. Because of this, a manual login must take place, using
78976>>>>>>>>>>>>>>>>>/// something like LOGIN_SQLFLEX or LOGIN. Since this only copies the data,
78976>>>>>>>>>>>>>>>>>/// CREATE_TABLE_FROM_DAT_FILE can be used to create the table structure.
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// Because COPY_DATA requires no user interaction, an optional callback
78976>>>>>>>>>>>>>>>>>/// function can be passed for tracing purposes. By passing the constant
78976>>>>>>>>>>>>>>>>>/// "CALLBACK" followed by the object name, a function can be used to set
78976>>>>>>>>>>>>>>>>>/// up messages for tracking and error handling. Below is more information
78976>>>>>>>>>>>>>>>>>/// regarding this callback object.
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// This function should follow this pattern:
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// Function Callback String sText Integer iStatusID Returns Integer
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// sText - Message corresponding to the current status ID
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// iStatusID - Integer value mapping to the current status constant:
78976>>>>>>>>>>>>>>>>>///                     DF_MESSAGE_PROGRESS_TITLE    Sent when SQLFlex starts the
78976>>>>>>>>>>>>>>>>>///                                                                              process
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>///             DF_MESSAGE_HEADING_1         Sent when SQLFlex is about to
78976>>>>>>>>>>>>>>>>>///                                                                              copy the source data
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>///             DF_MESSAGE_ERROR             Sent when an error occurs
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>///             DF_MESSAGE_PROGRESS_STATUS   Sent each time an additional
78976>>>>>>>>>>>>>>>>>///                                                                              10% of the data is copied
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// NOTE: Returning false each time the function is called will continue
78976>>>>>>>>>>>>>>>>>/// copying process. Returning true will end it.
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// Another optional parameter that can be used is a constrain on the data
78976>>>>>>>>>>>>>>>>>/// being copied. This is done by passing the constant "CONSTRAIN" followed
78976>>>>>>>>>>>>>>>>>/// by an SQL constrain statement. When passing a constrain but not a callback
78976>>>>>>>>>>>>>>>>>/// object, pass 0 for the callback before passsing the constrain.
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Assumptions
78976>>>>>>>>>>>>>>>>>/// @Status      Public
78976>>>>>>>>>>>>>>>>>/// @Drivers     All
78976>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
78976>>>>>>>>>>>>>>>>>/// @See                 CREATE_TABLE_FROM_DAT_FILE CONVERT_DAT_FILE
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Syntax COPY_DATA {from} to {destination} [CALLBACK {function}] [CONSTRAIN {variable}]
78976>>>>>>>>>>>>>>>>>/// @Param from                         Table to copy from.
78976>>>>>>>>>>>>>>>>>/// @Param destination          Table to copy to.
78976>>>>>>>>>>>>>>>>>/// @Param function             Object with callback function (optional)
78976>>>>>>>>>>>>>>>>>/// @Param variable                     SQL contraint to use when copying (optional)
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Example
78976>>>>>>>>>>>>>>>>>/// Object CallBackObj is a Array
78976>>>>>>>>>>>>>>>>>///     Function Callback String sText Integer iLogicalID Returns Integer
78976>>>>>>>>>>>>>>>>>///         If (iLogicalID = DF_MESSAGE_ERROR) Begin
78976>>>>>>>>>>>>>>>>>///             Showln "Error"
78976>>>>>>>>>>>>>>>>>///                             Showln sText
78976>>>>>>>>>>>>>>>>>///                             Function_Return True
78976>>>>>>>>>>>>>>>>>///         End
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>///         Else Showln sText
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>///                     Function_Return False
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>///     End_Function
78976>>>>>>>>>>>>>>>>>/// End_Object
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// Login "localhost" "user" "pass123" "sql_drv"
78976>>>>>>>>>>>>>>>>>/// CREATE_TABLE_FROM_DAT_FILE Customer.File_Number "Customer"
78976>>>>>>>>>>>>>>>>>/// COPY_DATA "Customer" to "sql_drv:Customer" CALLBACK (Callback(Self)) CONSTRAIN "STATUS = 'Active'"
78976>>>>>>>>>>>>>>>>>
78976>>>>>>>>>>>>>>>>>//=============================================================================
78976>>>>>>>>>>>>>>>>>/// @Name        ORAFlex_REVISION
78976>>>>>>>>>>>>>>>>>/// @Description This command will put the current version (decimals included)
78976>>>>>>>>>>>>>>>>>/// of the Oracle driver associated with the current workspace into the specified
78976>>>>>>>>>>>>>>>>>/// variable.
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Assumptions
78976>>>>>>>>>>>>>>>>>/// @Status      Deprecated
78976>>>>>>>>>>>>>>>>>/// @Drivers     ORAFlex
78976>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
78976>>>>>>>>>>>>>>>>>/// @See                 GET_DRIVER_REVISION
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Syntax ORAFlex_REVISION {variable}
78976>>>>>>>>>>>>>>>>>/// @Param variable                     String variable to hold the returned version
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Example
78976>>>>>>>>>>>>>>>>>/// ORAFlex_REVISION sVersion
78976>>>>>>>>>>>>>>>>>
78976>>>>>>>>>>>>>>>>>//=============================================================================
78976>>>>>>>>>>>>>>>>>/// @Name        KEEP_FILES_OPEN
78976>>>>>>>>>>>>>>>>>/// @Description Keep the files, currently in use, open after the server is
78976>>>>>>>>>>>>>>>>>/// logged out. Sometimes an application needs to login to the same server
78976>>>>>>>>>>>>>>>>>/// with a different user id. When logging out, however, the drivers
78976>>>>>>>>>>>>>>>>>/// automatically close all opened files. The overhead of opening these files
78976>>>>>>>>>>>>>>>>>/// should be avoided if the user will work with the same files that were
78976>>>>>>>>>>>>>>>>>/// closed. KEEP_FILES_OPEN keeps all files opened after a user logs out
78976>>>>>>>>>>>>>>>>>/// from the server.
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Status      Deprecated
78976>>>>>>>>>>>>>>>>>/// @Drivers     All
78976>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Syntax KEEP_FILES_OPEN of {server}
78976>>>>>>>>>>>>>>>>>/// @Param server               Name of the server
78976>>>>>>>>>>>>>>>>>
78976>>>>>>>>>>>>>>>>>
78976>>>>>>>>>>>>>>>>>//=============================================================================
78976>>>>>>>>>>>>>>>>>/// @Name        SET_MAX_OPEN_CURSORS
78976>>>>>>>>>>>>>>>>>/// @Description Set the maximum number of cursors you want the driver to use.
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// The driver will recycle the least used cursors if this limit is hit.
78976>>>>>>>>>>>>>>>>>/// The trade off is between increased resources on the server and
78976>>>>>>>>>>>>>>>>>/// re-preparing of cursors.
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// For a program that keeps 40+ files opened at the same time, 255 is a good
78976>>>>>>>>>>>>>>>>>/// number for the open cursors parameter. For programs that open less than
78976>>>>>>>>>>>>>>>>>/// 40 files, any number between 100-255 is sufficient. These numbers can be
78976>>>>>>>>>>>>>>>>>/// changed based on available server resources.
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// On Oracle this value should not exceed the value of open_cursors in
78976>>>>>>>>>>>>>>>>>/// init.ora
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// Note: Only change this setting if you are having performance issues
78976>>>>>>>>>>>>>>>>>/// and the server is indicating you are using up too many cursors or too
78976>>>>>>>>>>>>>>>>>/// much memory. GET_OPENED_CURSORS can be used to check the number of
78976>>>>>>>>>>>>>>>>>/// cursors the server has opened. If this number is hitting the limit,
78976>>>>>>>>>>>>>>>>>/// it is worth increasing the number, as long as the server has enough
78976>>>>>>>>>>>>>>>>>/// resources.
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Assumptions
78976>>>>>>>>>>>>>>>>>/// @Status      Public
78976>>>>>>>>>>>>>>>>>/// @Drivers     All
78976>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
78976>>>>>>>>>>>>>>>>>/// @See         GET_MAX_OPEN_CURSORS GET_OPENED_CURSORS
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Syntax SET_MAX_OPEN_CURSORS of {server} to {variable}
78976>>>>>>>>>>>>>>>>>/// @Param server                       The name of the server
78976>>>>>>>>>>>>>>>>>/// @Param variable                     Maximum number of cursors
78976>>>>>>>>>>>>>>>>>
78976>>>>>>>>>>>>>>>>>//=============================================================================
78976>>>>>>>>>>>>>>>>>/// @Name        GET_MAX_OPEN_CURSORS
78976>>>>>>>>>>>>>>>>>/// @Description This command will return the maximum number of open
78976>>>>>>>>>>>>>>>>>/// cursors allowed by the server.
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Assumptions
78976>>>>>>>>>>>>>>>>>/// @Status      Public
78976>>>>>>>>>>>>>>>>>/// @Drivers     All
78976>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
78976>>>>>>>>>>>>>>>>>/// @See         SET_MAX_OPEN_CURSORS GET_OPENED_CURSORS
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Syntax GET_MAX_OPEN_CURSORS of {server} to {variable}
78976>>>>>>>>>>>>>>>>>/// @Param server                       Name of the server
78976>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the maximum number of open cursors
78976>>>>>>>>>>>>>>>>>
78976>>>>>>>>>>>>>>>>>//=============================================================================
78976>>>>>>>>>>>>>>>>>/// @Name        GET_OPENED_CURSORS
78976>>>>>>>>>>>>>>>>>/// @Description This command returns the number of cursors currently
78976>>>>>>>>>>>>>>>>>/// open on the server.
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Assumptions
78976>>>>>>>>>>>>>>>>>/// @Status      Public
78976>>>>>>>>>>>>>>>>>/// @Drivers     All
78976>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
78976>>>>>>>>>>>>>>>>>/// @See         SET_MAX_OPEN_CURSORS GET_MAX_OPEN_CURSORS
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Syntax GET_MAX_OPEN_CURSORS of {server} to {variable}
78976>>>>>>>>>>>>>>>>>/// @Param server                       Name of the server
78976>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the number of cursors currently open
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>
78976>>>>>>>>>>>>>>>>>//=============================================================================
78976>>>>>>>>>>>>>>>>>/// @Name        ACTIVATE_TIME_STAMP
78976>>>>>>>>>>>>>>>>>/// @Description This command will specify whether or not to show the time
78976>>>>>>>>>>>>>>>>>/// portion of a date field. When set to ON, the time portion will be
78976>>>>>>>>>>>>>>>>>/// included, OFF will just show the date. This is the same as changing
78976>>>>>>>>>>>>>>>>>/// the date format with "ALTER SESSION SET nls_timestamp_format". Note that
78976>>>>>>>>>>>>>>>>>/// this will only take effect if the date is put into a string variable.
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Assumptions
78976>>>>>>>>>>>>>>>>>/// @Status      Deprecated
78976>>>>>>>>>>>>>>>>>/// @Drivers     OraFlex
78976>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
78976>>>>>>>>>>>>>>>>>/// @See
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Syntax ACTIVATE_TIME_STAMP of {server} to {ON/OFF}
78976>>>>>>>>>>>>>>>>>/// @Param server                       Name of the server
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Example
78976>>>>>>>>>>>>>>>>>/// ACTIVATE_TIME_STAMP of "localhost/orcl.localdomain" to OFF
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// SQL_SET_STMT to 'SELECT * from USER."Customer" '
78976>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT
78976>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
78976>>>>>>>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sID sFirstName sLastName sDOB
78976>>>>>>>>>>>>>>>>>/// If (Found) Begin
78976>>>>>>>>>>>>>>>>>///     Showln sDOB
78976>>>>>>>>>>>>>>>>>/// End
78976>>>>>>>>>>>>>>>>>
78976>>>>>>>>>>>>>>>>>//=============================================================================
78976>>>>>>>>>>>>>>>>>/// @Name        CALL_ORACLE_STORED_FUNCTION
78976>>>>>>>>>>>>>>>>>/// @Description This command is used to execute a function stored in Oracle.
78976>>>>>>>>>>>>>>>>>/// This is an alternative to building a function with the SQL_SET_FUNCTION_NAME,
78976>>>>>>>>>>>>>>>>>/// SQL_SET_FUNCTION_PARAMETER and SQL_FUNCTION_EXECUTE commands. This command
78976>>>>>>>>>>>>>>>>>/// builds and executes the function by setting the full function name, the
78976>>>>>>>>>>>>>>>>>/// parameter(s) to pass and the variable to hold the returned value. Note that
78976>>>>>>>>>>>>>>>>>/// this command can only return a single value so SQL_SET_FUNCTION_PARAMETER
78976>>>>>>>>>>>>>>>>>/// and SQL_SET_FUNCTION_NAME must be used when dealing with multiple return
78976>>>>>>>>>>>>>>>>>/// values.
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Status      Deprecated
78976>>>>>>>>>>>>>>>>>/// @Drivers     ORAFLex
78976>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
78976>>>>>>>>>>>>>>>>>/// @See                 CALL_STORED_FUNCTION
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Syntax CALL_ORACLE_STORED_FUNCTION {function} Returns {variable} Passing {argument}
78976>>>>>>>>>>>>>>>>>/// @Param function                     Full name of the function
78976>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the returned value
78976>>>>>>>>>>>>>>>>>/// @Param argument                     Argument to pass (can be multiple)
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Example
78976>>>>>>>>>>>>>>>>>/// CALL_ORACLE_STORED_FUNCTION "user.getCustomerStatus" Returns sStatus passing sCustomerID
78976>>>>>>>>>>>>>>>>>/// Showln sStatus
78976>>>>>>>>>>>>>>>>>
78976>>>>>>>>>>>>>>>>>//=============================================================================
78976>>>>>>>>>>>>>>>>>/// @Name        CALL_PGSQL_STORED_FUNCTION
78976>>>>>>>>>>>>>>>>>/// @Description This command is used to execute a function stored in Oracle.
78976>>>>>>>>>>>>>>>>>/// This is an alternative to building a function with the SQL_SET_FUNCTION_NAME,
78976>>>>>>>>>>>>>>>>>/// SQL_SET_FUNCTION_PARAMETER and SQL_FUNCTION_EXECUTE commands. This command
78976>>>>>>>>>>>>>>>>>/// builds and executes the function by setting the full function name, the
78976>>>>>>>>>>>>>>>>>/// parameter(s) to pass and the variable to hold the returned value. Note that
78976>>>>>>>>>>>>>>>>>/// this command can only return a single value so SQL_SET_FUNCTION_PARAMETER
78976>>>>>>>>>>>>>>>>>/// and SQL_SET_FUNCTION_NAME must be used when dealing with multiple return
78976>>>>>>>>>>>>>>>>>/// values.
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Status      Deprecated
78976>>>>>>>>>>>>>>>>>/// @Drivers     PGFlex
78976>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
78976>>>>>>>>>>>>>>>>>/// @See                 CALL_STORED_FUNCTION
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Syntax CALL_PGSQL_STORED_FUNCTION {function} Returns {variable} Passing {argument}
78976>>>>>>>>>>>>>>>>>/// @Param function                     Full name of the function
78976>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the returned value
78976>>>>>>>>>>>>>>>>>/// @Param argument                     Argument to pass (can be multiple)
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Example
78976>>>>>>>>>>>>>>>>>/// CALL_PGSQL_STORED_FUNCTION "user.getCustomerStatus" Returns sStatus passing sCustomerID
78976>>>>>>>>>>>>>>>>>/// Showln sStatus
78976>>>>>>>>>>>>>>>>>
78976>>>>>>>>>>>>>>>>>//=============================================================================
78976>>>>>>>>>>>>>>>>>/// @Name        MERTECH_LANGUAGE_SUPPORT
78976>>>>>>>>>>>>>>>>>/// @Description Sets the support language for the driver.
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Assumptions
78976>>>>>>>>>>>>>>>>>/// @Status      Internal
78976>>>>>>>>>>>>>>>>>/// @Drivers     ORAFLex
78976>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
78976>>>>>>>>>>>>>>>>>/// @See
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Syntax MERTECH_LANGUAGE_SUPPORT of {server} to {language}
78976>>>>>>>>>>>>>>>>>/// @Param server               The name of the server being used
78976>>>>>>>>>>>>>>>>>/// @Param language             The language to set support to
78976>>>>>>>>>>>>>>>>>
78976>>>>>>>>>>>>>>>>>//=============================================================================
78976>>>>>>>>>>>>>>>>>/// @Name        SQL_SAVE_BUFFER_BEGIN
78976>>>>>>>>>>>>>>>>>/// @Description This command is used to initialize a SAVE_BUFFER
78976>>>>>>>>>>>>>>>>>/// statement. Doing this will allow a specified set of records to be
78976>>>>>>>>>>>>>>>>>/// stored in the buffer before a save takes place. Once the buffer is
78976>>>>>>>>>>>>>>>>>/// filled, it will be saved automatically. This set of commands can be
78976>>>>>>>>>>>>>>>>>/// used to efficiently save a large number of records. Once the buffer
78976>>>>>>>>>>>>>>>>>/// is full, the save occurs automatically and the buffer will be emptied
78976>>>>>>>>>>>>>>>>>/// out. It is good practice to use this method inside of a transaction to
78976>>>>>>>>>>>>>>>>>/// maintain atomicity. Note that these commands should not be used in
78976>>>>>>>>>>>>>>>>>/// conjuction with finds.
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Assumptions
78976>>>>>>>>>>>>>>>>>/// @Status      Public
78976>>>>>>>>>>>>>>>>>/// @Drivers     All
78976>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
78976>>>>>>>>>>>>>>>>>/// @See         SQL_SAVE_BUFFER_END SQL_SAVE_BUFFER
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Syntax SQL_SAVE_BUFFER_BEGIN of {FileName} to {variable}
78976>>>>>>>>>>>>>>>>>/// @Param FileName                     Name of the file
78976>>>>>>>>>>>>>>>>>/// @Param variable                     Number of records to store in the buffer
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Example
78976>>>>>>>>>>>>>>>>>/// Open Customer
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// SQL_SAVE_BUFFER_BEGIN of Transactions to 10
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// For i from 0 to 1000
78976>>>>>>>>>>>>>>>>>///     Move i to Transactions.ID
78976>>>>>>>>>>>>>>>>>///     SQL_SAVE_BUFFER of Transactions
78976>>>>>>>>>>>>>>>>>/// Loop
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// SQL_SAVE_BUFFER_END of Customer
78976>>>>>>>>>>>>>>>>>
78976>>>>>>>>>>>>>>>>>//=============================================================================
78976>>>>>>>>>>>>>>>>>/// @Name        SQL_SAVE_BUFFER
78976>>>>>>>>>>>>>>>>>/// @Description This command is used to send a record to the "Save
78976>>>>>>>>>>>>>>>>>/// Record" buffer. It must be used along with SQL_SAVE_BUFFER_BEGIN
78976>>>>>>>>>>>>>>>>>/// and SQL_SAVE_BUFFER_END. SQL_SAVE_BUFFER_BEGIN sets the number of
78976>>>>>>>>>>>>>>>>>/// records to store in the buffer before a save is done on all the records
78976>>>>>>>>>>>>>>>>>/// at once. Each time a record is created, this command should be called
78976>>>>>>>>>>>>>>>>>/// to insert it into the buffer. Using this set of commands can be useful
78976>>>>>>>>>>>>>>>>>/// to efficiently save a large number of records. Once the buffer is full,
78976>>>>>>>>>>>>>>>>>/// the save occurs automatically and the buffer will be emptied out. It is
78976>>>>>>>>>>>>>>>>>/// good practice to use this method inside of a transaction to maintain
78976>>>>>>>>>>>>>>>>>/// atomicity.
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Assumptions
78976>>>>>>>>>>>>>>>>>/// @Status      Public
78976>>>>>>>>>>>>>>>>>/// @Drivers     All
78976>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
78976>>>>>>>>>>>>>>>>>/// @See                 SQL_SAVE_BUFFER_BEGIN SQL_SAVE_BUFFER_END
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Syntax SQL_SAVE_BUFFER of {FileName}
78976>>>>>>>>>>>>>>>>>/// @Param FileName                     Name of the file
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Example
78976>>>>>>>>>>>>>>>>>/// Open Customer
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// SQL_SAVE_BUFFER_BEGIN of Transactions to 10
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// For i from 0 to 1000
78976>>>>>>>>>>>>>>>>>///     Move i to Transactions.ID
78976>>>>>>>>>>>>>>>>>///     SQL_SAVE_BUFFER of Transactions
78976>>>>>>>>>>>>>>>>>/// Loop
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// SQL_SAVE_BUFFER_END of Customer
78976>>>>>>>>>>>>>>>>>
78976>>>>>>>>>>>>>>>>>//=============================================================================
78976>>>>>>>>>>>>>>>>>/// @Name        SQL_SAVE_BUFFER_END
78976>>>>>>>>>>>>>>>>>/// @Description This command indicates the end of the extended record
78976>>>>>>>>>>>>>>>>>/// buffer and forces a save of any data currently in the buffer.
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Assumptions
78976>>>>>>>>>>>>>>>>>/// @Status      Public
78976>>>>>>>>>>>>>>>>>/// @Drivers     All
78976>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
78976>>>>>>>>>>>>>>>>>/// @See         SQL_SAVE_BUFFER_BEGIN SQL_SAVE_BUFFER
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Syntax SQL_SAVE_BUFFER_END of {FileName}
78976>>>>>>>>>>>>>>>>>/// @Param FileName                     Name of the file
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Example
78976>>>>>>>>>>>>>>>>>/// Open Customer
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// SQL_SAVE_BUFFER_BEGIN of Transactions to 10
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// For i from 0 to 1000
78976>>>>>>>>>>>>>>>>>///     Move i to Transactions.ID
78976>>>>>>>>>>>>>>>>>///     SQL_SAVE_BUFFER of Transactions
78976>>>>>>>>>>>>>>>>>/// Loop
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// SQL_SAVE_BUFFER_END of Customer
78976>>>>>>>>>>>>>>>>>
78976>>>>>>>>>>>>>>>>>//=============================================================================
78976>>>>>>>>>>>>>>>>>/// @Name        SQL_SAVE_SET_ATTRIBUTES
78976>>>>>>>>>>>>>>>>>/// @Description Unknown - Not in help - Not call by any other macros
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Assumptions
78976>>>>>>>>>>>>>>>>>/// @Status      Internal
78976>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex
78976>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-18 By Ian Smith
78976>>>>>>>>>>>>>>>>>/// @See
78976>>>>>>>>>>>>>>>>>
78976>>>>>>>>>>>>>>>>>//=============================================================================
78976>>>>>>>>>>>>>>>>>/// @Name        ENABLE_TRACE_ON
78976>>>>>>>>>>>>>>>>>/// @Description This command enables driver level tracing to the
78976>>>>>>>>>>>>>>>>>/// specified file. Enabling trace on an application and using it
78976>>>>>>>>>>>>>>>>>/// in conjunction with SQL_TEXT_MESSAGE is a good way to study
78976>>>>>>>>>>>>>>>>>/// particular problems you encounter in the driver. SQL_TEXT_MESSAGE
78976>>>>>>>>>>>>>>>>>/// allows you to insert sections of your code into the trace file.
78976>>>>>>>>>>>>>>>>>/// This command can also set the trace to three different levels,
78976>>>>>>>>>>>>>>>>>/// allowing different amounts of information to be logged. Note that
78976>>>>>>>>>>>>>>>>>/// trace files can become very large so it is good practice to only
78976>>>>>>>>>>>>>>>>>/// turn them on when specifically needed.
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Assumptions
78976>>>>>>>>>>>>>>>>>/// @Status      Public
78976>>>>>>>>>>>>>>>>>/// @Drivers     All
78976>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
78976>>>>>>>>>>>>>>>>>/// @See                 DISABLE_TRACE_ON SQL_TEXT_MESSAGE
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Syntax ENABLE_TRACE_ON to {fileName} Debug_Level [{constant}]
78976>>>>>>>>>>>>>>>>>/// @Param fileName                     The path of the file to send the trace to
78976>>>>>>>>>>>>>>>>>/// @Param constant             DETAIL_LEVEL1, DETAIL_LEVEL2, DETAIL_LEVEL3 (optional)
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Example ENABLE_TRACE_ON TO "C:\Temp\trace_file.txt" Debug_Level DETAIL_LEVEL3
78976>>>>>>>>>>>>>>>>>
78976>>>>>>>>>>>>>>>>>//=============================================================================
78976>>>>>>>>>>>>>>>>>/// @Name        DISABLE_TRACE_ON
78976>>>>>>>>>>>>>>>>>/// @Description This command disables the current trace taking
78976>>>>>>>>>>>>>>>>>/// place on a driver.
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Assumptions
78976>>>>>>>>>>>>>>>>>/// @Status      Public
78976>>>>>>>>>>>>>>>>>/// @Drivers     All
78976>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
78976>>>>>>>>>>>>>>>>>/// @See ENABLE_TRACE_ON SQL_TEXT_MESSAGE
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Syntax DISABLE_TRACE_ON
78976>>>>>>>>>>>>>>>>>
78976>>>>>>>>>>>>>>>>>//=============================================================================
78976>>>>>>>>>>>>>>>>>/// @Name        CREATE_TABLE_FROM_DAT_FILE
78976>>>>>>>>>>>>>>>>>/// @Description This command is used to create a SQL table from a .DAT
78976>>>>>>>>>>>>>>>>>/// file. The table being copied must be not be opened in order for this
78976>>>>>>>>>>>>>>>>>/// command to work properly. This is the programmatic equivalent to
78976>>>>>>>>>>>>>>>>>/// using the Flex2SQL Migration Tool. Optional restructuring options
78976>>>>>>>>>>>>>>>>>/// can be specified here (see below) as well as an alternative table
78976>>>>>>>>>>>>>>>>>/// name than the physical name of the .DAT file. Note that this only
78976>>>>>>>>>>>>>>>>>/// creates the  table structure, no data will be copied here. To copy
78976>>>>>>>>>>>>>>>>>/// the data, use COPY_DATA after the table has been created.
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// DF_STRUCTEND_OPT_FORCE_INVK         - Deprecated
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// DF_STRUCTEND_OPT_OLD_INVK_NAME      - Deprecated
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// DF_STRUCTEND_OPT_FORCE_NOT_NULL - forces all fields to be created as NOT NULL.
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Assumptions
78976>>>>>>>>>>>>>>>>>/// @Status      Public
78976>>>>>>>>>>>>>>>>>/// @Drivers     All
78976>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
78976>>>>>>>>>>>>>>>>>/// @See                 COPY_DATA CONVERT_DAT_FILE
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Syntax CREATE_TABLE_FROM_DAT_FILE {FileNumber} [{options} {table}]
78976>>>>>>>>>>>>>>>>>/// @Param FileNumber           Number of the file
78976>>>>>>>>>>>>>>>>>/// @Param options                      DF_STRUCTEND_OPT_FORCE_INVK
78976>>>>>>>>>>>>>>>>>///                                                     DF_STRUCTEND_OPT_OLD_INVK_NAME
78976>>>>>>>>>>>>>>>>>///                                                     DF_STRUCTEND_OPT_FORCE_NOT_NULL (optional)
78976>>>>>>>>>>>>>>>>>/// @Param table            name of table to use instead of physical name (optional)
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Example
78976>>>>>>>>>>>>>>>>>/// Login "localhost" "user" "pass123" "sql_drv"
78976>>>>>>>>>>>>>>>>>/// CREATE_TABLE_FROM_DAT_FILE Customer.File_Number "Customer"
78976>>>>>>>>>>>>>>>>>/// COPY_DATA "Customer" to "sql_drv:Customer" CALLBACK (Callback(Self)) CONSTRAIN "STATUS = 'Active'"
78976>>>>>>>>>>>>>>>>>
78976>>>>>>>>>>>>>>>>>//=============================================================================
78976>>>>>>>>>>>>>>>>>/// @Name        CONVERT_DAT_FILE
78976>>>>>>>>>>>>>>>>>/// @Description This command is the programmatic equivalent to the
78976>>>>>>>>>>>>>>>>>/// Flex2SQL Migration Tool. With this command, a SQL table can be
78976>>>>>>>>>>>>>>>>>/// created from a .DAT table. This combines the COPY_DATA and
78976>>>>>>>>>>>>>>>>>/// CREATE_TABLE_FROM_DAT_FILE, creating the table structure and
78976>>>>>>>>>>>>>>>>>/// copying all the data into the new table with one command. The
78976>>>>>>>>>>>>>>>>>/// table being converted cannot be opened and so a manual login is
78976>>>>>>>>>>>>>>>>>/// needed. Note that to specify the database to copy the table to,
78976>>>>>>>>>>>>>>>>>/// use SET_DATABASE_NAME. Below is a list of the optional restructure
78976>>>>>>>>>>>>>>>>>/// options to use when creating the table.
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// DF_STRUCTEND_OPT_FORCE_INVK         - Deprecated
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// DF_STRUCTEND_OPT_OLD_INVK_NAME      - Deprecated
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// DF_STRUCTEND_OPT_FORCE_NOT_NULL - forces all fields to be created as NOT NULL.
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Assumptions
78976>>>>>>>>>>>>>>>>>/// @Status      Public
78976>>>>>>>>>>>>>>>>>/// @Drivers     All
78976>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
78976>>>>>>>>>>>>>>>>>/// @See                 CREATE_TABLE_FROM_DAT_FILE COPY_DATA
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Syntax CONVERT_DAT_FILE {FileNumber} [{options} {table}]
78976>>>>>>>>>>>>>>>>>/// @Param FileNumber           Number of the file
78976>>>>>>>>>>>>>>>>>/// @Param options                      DF_STRUCTEND_OPT_FORCE_INVK
78976>>>>>>>>>>>>>>>>>///                                                     DF_STRUCTEND_OPT_OLD_INVK_NAME
78976>>>>>>>>>>>>>>>>>///                                                     DF_STRUCTEND_OPT_FORCE_NOT_NULL (optional)
78976>>>>>>>>>>>>>>>>>/// @Param table            Name of table to use instead of physical name (optional)
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Example
78976>>>>>>>>>>>>>>>>>/// Login "localhost" "user" "pass123" "sql_drv"
78976>>>>>>>>>>>>>>>>>/// CONVERT_DAT_FILE Customer.File_Number DF_STRUCTEND_OPT_FORCE_NOT_NULL "Customer"
78976>>>>>>>>>>>>>>>>>
78976>>>>>>>>>>>>>>>>>//=============================================================================
78976>>>>>>>>>>>>>>>>>/// @Name        SET_DEFAULT_FILE_CASING
78976>>>>>>>>>>>>>>>>>/// @Description This command is used to set the file casing standard when
78976>>>>>>>>>>>>>>>>>/// creating or restructuring tables. By default, all table and column names
78976>>>>>>>>>>>>>>>>>/// are created using the specified casing. Passing FILE_CASING_UPPER or
78976>>>>>>>>>>>>>>>>>/// FILE_CASING_LOWER will allow the names to be saved in uppercase or
78976>>>>>>>>>>>>>>>>>/// lowercase respectively. This can be useful for backwards compatibility
78976>>>>>>>>>>>>>>>>>/// where casing was important. Note that the casing standard for a file can
78976>>>>>>>>>>>>>>>>>/// also be changed through mertech.ini. Below is a description of the constants
78976>>>>>>>>>>>>>>>>>/// that can be passed to this command.
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// FILE_CASING_UPPER : All created or edited object names will be converted to uppercase.
78976>>>>>>>>>>>>>>>>>/// FILE_CASING_LOWER : All created or edited object names will be converted to lowercase.
78976>>>>>>>>>>>>>>>>>/// FILE_CASING_KEEP (default) : All created or edited object names will maintain their inputed casing.
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Assumptions
78976>>>>>>>>>>>>>>>>>/// @Status      Public
78976>>>>>>>>>>>>>>>>>/// @Drivers     All
78976>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
78976>>>>>>>>>>>>>>>>>/// @See                 GET_DEFAULT_FILE_CASING
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Syntax SET_DEFAULT_FILE_CASING to {constant}
78976>>>>>>>>>>>>>>>>>/// @Param constant                     FILE_CASING_UPPER, FILE_CASING_LOWER, FILE_CASING_KEEP
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Example
78976>>>>>>>>>>>>>>>>>/// SET_DEFAULT_FILE_CASING to FILE_CASING_UPPER
78976>>>>>>>>>>>>>>>>>
78976>>>>>>>>>>>>>>>>>//=============================================================================
78976>>>>>>>>>>>>>>>>>/// @Name        GET_DEFAULT_FILE_CASING
78976>>>>>>>>>>>>>>>>>/// @Description This command returns the file casing standard used
78976>>>>>>>>>>>>>>>>>/// when creating or restructuring tables. Note that an integer is returned,
78976>>>>>>>>>>>>>>>>>/// mapping to a casing method. Below are the meanings of the possible
78976>>>>>>>>>>>>>>>>>/// returned integers.
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// 0 - FILE_CASING_UPPER : All created or edited object names will be converted to uppercase.
78976>>>>>>>>>>>>>>>>>/// 1 - FILE_CASING_LOWER : All created or edited object names will be converted to lowercase.
78976>>>>>>>>>>>>>>>>>/// 2 - FILE_CASING_KEEP : All created or edited object names will maintain their inputed casing.
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Assumptions
78976>>>>>>>>>>>>>>>>>/// @Status      Public
78976>>>>>>>>>>>>>>>>>/// @Drivers     All
78976>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
78976>>>>>>>>>>>>>>>>>/// @See                 SET_DEFAULT_FILE_CASING
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Syntax GET_DEFAULT_FILE_CASING to {variable}
78976>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the returned casing
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Example
78976>>>>>>>>>>>>>>>>>/// GET_DEFAULT_FILE_CASING TO iCasing
78976>>>>>>>>>>>>>>>>>
78976>>>>>>>>>>>>>>>>>//=============================================================================
78976>>>>>>>>>>>>>>>>>/// @Name        SET_DEFAULT_TABLESPACE
78976>>>>>>>>>>>>>>>>>/// @Description This command sets the default table space to use when
78976>>>>>>>>>>>>>>>>>/// creating tables through Dataflex. A tablespace is a container of
78976>>>>>>>>>>>>>>>>>/// segments (objects that have an allotted amount of space), i.e. tables
78976>>>>>>>>>>>>>>>>>/// and indexes.
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Assumptions
78976>>>>>>>>>>>>>>>>>/// @Status      Public
78976>>>>>>>>>>>>>>>>>/// @Drivers     ORAFlex, PgFlex
78976>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
78976>>>>>>>>>>>>>>>>>/// @See                 GET_DEFAULT_TABLESPACE SET_DEFAULT_INDEX_TABLESPACE GET_DEFAULT_INDEX_TABLESPACE
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Syntax SET_DEFAULT_TABLESPACE to {variable}
78976>>>>>>>>>>>>>>>>>/// @Param variable                     Name of the default table space
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Example
78976>>>>>>>>>>>>>>>>>/// SET_DEFAULT_TABLESPACE to "Users"
78976>>>>>>>>>>>>>>>>>
78976>>>>>>>>>>>>>>>>>//=============================================================================
78976>>>>>>>>>>>>>>>>>/// @Name        GET_DEFAULT_TABLESPACE
78976>>>>>>>>>>>>>>>>>/// @Description This command returns the default table space name for
78976>>>>>>>>>>>>>>>>>/// the current database.
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Assumptions
78976>>>>>>>>>>>>>>>>>/// @Status      Public
78976>>>>>>>>>>>>>>>>>/// @Drivers     ORAFlex, PgFlex
78976>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
78976>>>>>>>>>>>>>>>>>/// @See                 SET_DEFAULT_TABLESPACE SET_DEFAULT_INDEX_TABLESPACE GET_DEFAULT_INDEX_TABLESPACE
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Syntax GET_DEFAULT_TABLESPACE to {variable}
78976>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the default table space name.
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Example
78976>>>>>>>>>>>>>>>>>/// GET_DEFAULT_TABLESPACE to sTableSpace
78976>>>>>>>>>>>>>>>>>
78976>>>>>>>>>>>>>>>>>//=============================================================================
78976>>>>>>>>>>>>>>>>>/// @Name        SET_DEFAULT_INDEX_TABLESPACE
78976>>>>>>>>>>>>>>>>>/// @Description This command sets the default table space for indexes
78976>>>>>>>>>>>>>>>>>/// when creating tables through the DataFlex API. A tablespace is a
78976>>>>>>>>>>>>>>>>>/// container of segments (objects that have an allotted amount of space),
78976>>>>>>>>>>>>>>>>>/// i.e. tables and indexes.
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Assumptions
78976>>>>>>>>>>>>>>>>>/// @Status      Public
78976>>>>>>>>>>>>>>>>>/// @Drivers     ORAFlex, PgFlex
78976>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09-2013 by Aaron Gulack
78976>>>>>>>>>>>>>>>>>/// @See                 SET_DEFAULT_TABLESPACE GET_DEFAULT_TABLESPACE GET_DEFAULT_INDEX_TABLESPACE
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Syntax SET_DEFAULT_INDEX_TABLESPACE to {variable}
78976>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the default index table space name.
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Example
78976>>>>>>>>>>>>>>>>>/// SET_DEFAULT_INDEX_TABLESPACE to "Users"
78976>>>>>>>>>>>>>>>>>
78976>>>>>>>>>>>>>>>>>//=============================================================================
78976>>>>>>>>>>>>>>>>>/// @Name        GET_DEFAULT_INDEX_TABLESPACE
78976>>>>>>>>>>>>>>>>>/// @Description This command returns the default table space name for
78976>>>>>>>>>>>>>>>>>/// indexes in the current database.
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Assumptions
78976>>>>>>>>>>>>>>>>>/// @Status      Public
78976>>>>>>>>>>>>>>>>>/// @Drivers     ORAFlex, PgFlex
78976>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
78976>>>>>>>>>>>>>>>>>/// @See                 SET_DEFAULT_TABLESPACE GET_DEFAULT_TABLESPACE SET_DEFAULT_INDEX_TABLESPACE
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Syntax GET_DEFAULT_INDEX_TABLESPACE to {variable}
78976>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the default index table space name.
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Example
78976>>>>>>>>>>>>>>>>>/// GET_DEFAULT_INDEX_TABLESPACE to sTableSpace
78976>>>>>>>>>>>>>>>>>
78976>>>>>>>>>>>>>>>>>//=============================================================================
78976>>>>>>>>>>>>>>>>>/// @Name        ENABLE_SCRIPTING
78976>>>>>>>>>>>>>>>>>/// @Description Scripting is used for testing and preparation. This
78976>>>>>>>>>>>>>>>>>/// command allows structural changes to be compiled and tested without
78976>>>>>>>>>>>>>>>>>/// actually making any of the changes. Any table restructuring done
78976>>>>>>>>>>>>>>>>>/// between this command and DISABLE_SCRIPTING will not actually be
78976>>>>>>>>>>>>>>>>>/// committed but will instead create a mock INT file. The script and
78976>>>>>>>>>>>>>>>>>/// INT file can then be retrieved and examined for testing purposes.
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Assumptions
78976>>>>>>>>>>>>>>>>>/// @Status      Public
78976>>>>>>>>>>>>>>>>>/// @Drivers     All
78976>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
78976>>>>>>>>>>>>>>>>>/// @See                 DISABLE_SCRIPTING GET_SQL_SCRIPT_CHUNK GET_INT_CHUNK
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Syntax ENABLE_SCRIPTING
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Example
78976>>>>>>>>>>>>>>>>>/// ENABLE_SCRIPTING
78976>>>>>>>>>>>>>>>>>///     //Table restructuring would go here
78976>>>>>>>>>>>>>>>>>/// DISABLE_SCRIPTING
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// GET_SQL_SCRIPT_CHUNK OFFSET 0 to sChunk sLength
78976>>>>>>>>>>>>>>>>>/// Showln sChunk
78976>>>>>>>>>>>>>>>>>
78976>>>>>>>>>>>>>>>>>//=============================================================================
78976>>>>>>>>>>>>>>>>>/// @Name        DISABLE_SCRIPTING
78976>>>>>>>>>>>>>>>>>/// @Description This command ends any scripting started by ENABLE_SCRIPTING.
78976>>>>>>>>>>>>>>>>>/// The mock INT file and script can then be retrieved and examined.
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Assumptions
78976>>>>>>>>>>>>>>>>>/// @Status      Public
78976>>>>>>>>>>>>>>>>>/// @Drivers     All
78976>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2010-12-13 By Marcelo Nachbar
78976>>>>>>>>>>>>>>>>>/// @See                 ENABLE_SCRIPTING  GET_SQL_SCRIPT_CHUNK GET_INT_CHUNK
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Syntax DISABLE_SCRIPTING
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// @Example
78976>>>>>>>>>>>>>>>>>/// ENABLE_SCRIPTING
78976>>>>>>>>>>>>>>>>>///     //Table restructuring would go here
78976>>>>>>>>>>>>>>>>>/// DISABLE_SCRIPTING
78976>>>>>>>>>>>>>>>>>///
78976>>>>>>>>>>>>>>>>>/// GET_SQL_SCRIPT_CHUNK OFFSET 0 to sChunk sLength
78976>>>>>>>>>>>>>>>>>/// Showln sChunk
78976>>>>>>>>>>>>>>>>>
78976>>>>>>>>>>>>>>>>>Function MertechInc_GET_RESTRUCTURE_SCRIPT Global Integer iLong Integer iOffset Returns String
78978>>>>>>>>>>>>>>>>>    Integer iChuck_Size
78978>>>>>>>>>>>>>>>>>    String sChunk
78978>>>>>>>>>>>>>>>>>
78978>>>>>>>>>>>>>>>>>    //Get current Chuck size and pre size string
78978>>>>>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_CHUNK_SIZE CALLBACK 0 PASSING iChuck_Size MertechInc_Blank 1 RESULT MertechInc_iRet
78983>>>>>>>>>>>>>>>>>    Get MertechInc_Pre_Size_String iChuck_Size to sChunk
78984>>>>>>>>>>>>>>>>>
78984>>>>>>>>>>>>>>>>>    //Get data
78984>>>>>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_RESTRUCTURE_SCRIPT CALLBACK 0 PASSING sChunk iOffset iLong RESULT MertechInc_iRet
78989>>>>>>>>>>>>>>>>>
78989>>>>>>>>>>>>>>>>>    // Replace insert a CR before any LF character
78989>>>>>>>>>>>>>>>>>    Move (Replaces(Character(10), sChunk, Character(13)+Character(10))) to sChunk
78990>>>>>>>>>>>>>>>>>
78990>>>>>>>>>>>>>>>>>    Function_Return sChunk
78991>>>>>>>>>>>>>>>>>End_Function
78992>>>>>>>>>>>>>>>>>
78992>>>>>>>>>>>>>>>>>
78992>>>>>>>>>>>>>>>>>//=============================================================================
78992>>>>>>>>>>>>>>>>>/// @Name        GET_SQL_SCRIPT_CHUNK
78992>>>>>>>>>>>>>>>>>/// @Description This command returns a chunk of the script generated
78992>>>>>>>>>>>>>>>>>/// from the restructuring done inside of ENABLE_SCRIPTING and
78992>>>>>>>>>>>>>>>>>/// DISABLE_SCRIPTING. Since some scripts can be very large, the script
78992>>>>>>>>>>>>>>>>>/// can be looped through, grabbing chunks at a time.
78992>>>>>>>>>>>>>>>>>///
78992>>>>>>>>>>>>>>>>>/// @Assumptions
78992>>>>>>>>>>>>>>>>>/// @Status      Public
78992>>>>>>>>>>>>>>>>>/// @Drivers     All
78992>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
78992>>>>>>>>>>>>>>>>>/// @See                 ENABLE_SCRIPTING DISABLE_SCRIPTING GET_INT_CHUNK
78992>>>>>>>>>>>>>>>>>///
78992>>>>>>>>>>>>>>>>>/// @Syntax GET_SQL_SCRIPT_CHUNK OFFSET {offset} to {variable} [{length}]
78992>>>>>>>>>>>>>>>>>/// @Param offset                       Specifies the offset to start at for the chunk
78992>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the chunk
78992>>>>>>>>>>>>>>>>>/// @Param length                       Length of chunk returned (optional)
78992>>>>>>>>>>>>>>>>>///
78992>>>>>>>>>>>>>>>>>/// @Example
78992>>>>>>>>>>>>>>>>>/// ENABLE_SCRIPTING
78992>>>>>>>>>>>>>>>>>///     //Table restructuring would go here
78992>>>>>>>>>>>>>>>>>/// DISABLE_SCRIPTING
78992>>>>>>>>>>>>>>>>>///
78992>>>>>>>>>>>>>>>>>/// GET_SQL_SCRIPT_CHUNK OFFSET 0 to sChunk sLength
78992>>>>>>>>>>>>>>>>>/// Showln sChunk
78992>>>>>>>>>>>>>>>>>
78992>>>>>>>>>>>>>>>>>//=============================================================================
78992>>>>>>>>>>>>>>>>>/// @Name        GET_INT_CHUNK
78992>>>>>>>>>>>>>>>>>/// @Description This command returns a chunk of the INT file generated
78992>>>>>>>>>>>>>>>>>/// from the restructuring done inside of ENABLE_SCRIPTING and
78992>>>>>>>>>>>>>>>>>/// DISABLE_SCRIPTING. Since some INT files can be very large, the file
78992>>>>>>>>>>>>>>>>>/// can be looped through, grabbing chunks at a time.
78992>>>>>>>>>>>>>>>>>///
78992>>>>>>>>>>>>>>>>>/// @Assumptions
78992>>>>>>>>>>>>>>>>>/// @Status      Public
78992>>>>>>>>>>>>>>>>>/// @Drivers     All
78992>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
78992>>>>>>>>>>>>>>>>>/// @See                 ENABLE_SCRIPTING DISABLE_SCRIPTING GET_SQL_SCRIPT_CHUNK
78992>>>>>>>>>>>>>>>>>///
78992>>>>>>>>>>>>>>>>>/// @Syntax GET_INT_CHUNK OFFSET {offset} to {variable} [{length}]
78992>>>>>>>>>>>>>>>>>/// @Param offset                       Specifies the offset to start at for the chunk
78992>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the chunk
78992>>>>>>>>>>>>>>>>>/// @Param length                       Length of chunk returned (optional)
78992>>>>>>>>>>>>>>>>>///
78992>>>>>>>>>>>>>>>>>/// @Example
78992>>>>>>>>>>>>>>>>>/// ENABLE_SCRIPTING
78992>>>>>>>>>>>>>>>>>///     //Table restructuring would go here
78992>>>>>>>>>>>>>>>>>/// DISABLE_SCRIPTING
78992>>>>>>>>>>>>>>>>>///
78992>>>>>>>>>>>>>>>>>/// GET_INT_CHUNK OFFSET 0 to sChunk sLength
78992>>>>>>>>>>>>>>>>>/// Showln sChunk
78992>>>>>>>>>>>>>>>>>
78992>>>>>>>>>>>>>>>>>//=============================================================================
78992>>>>>>>>>>>>>>>>>/// @Name        REPORT_STMT
78992>>>>>>>>>>>>>>>>>/// @Description This command is an alternative to DataFlex's "Report"
78992>>>>>>>>>>>>>>>>>/// command. This allows embedded SQL to be used to fetch data instead of
78992>>>>>>>>>>>>>>>>>/// standard table queries.. All of the finds, for example, normally found
78992>>>>>>>>>>>>>>>>>/// in "Report" are replaced by SQL_FETCH_NEXT_ROW.
78992>>>>>>>>>>>>>>>>>///
78992>>>>>>>>>>>>>>>>>/// @Assumptions
78992>>>>>>>>>>>>>>>>>/// @Status      Public
78992>>>>>>>>>>>>>>>>>/// @Drivers     n/a
78992>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
78992>>>>>>>>>>>>>>>>>/// @See
78992>>>>>>>>>>>>>>>>>///
78992>>>>>>>>>>>>>>>>>/// @Syntax See DataFlex / Visual DataFlex documentation
78992>>>>>>>>>>>>>>>>>///
78992>>>>>>>>>>>>>>>>>/// @Example
78992>>>>>>>>>>>>>>>>>/// /Header
78992>>>>>>>>>>>>>>>>>/// __/__/____                                                        Page ___.
78992>>>>>>>>>>>>>>>>>///                 MERTECH DATA SYSTEMS, INC. - NOT FOR RESALE
78992>>>>>>>>>>>>>>>>>///
78992>>>>>>>>>>>>>>>>>/// ID   NAME
78992>>>>>>>>>>>>>>>>>///
78992>>>>>>>>>>>>>>>>>/// /Body
78992>>>>>>>>>>>>>>>>>/// ____ _________________________
78992>>>>>>>>>>>>>>>>>/// /Total
78992>>>>>>>>>>>>>>>>>/// Records printed = _______.
78992>>>>>>>>>>>>>>>>>/// /*
78992>>>>>>>>>>>>>>>>>///
78992>>>>>>>>>>>>>>>>>///
78992>>>>>>>>>>>>>>>>>/// OPEN SALESP
78992>>>>>>>>>>>>>>>>>/// direct_output "con:"
78992>>>>>>>>>>>>>>>>>/// // Write the complete SELECT statement to retrieve the expected records from your REPORT
78992>>>>>>>>>>>>>>>>>/// // Must include the expression to qualify the required records and specify the order by as well
78992>>>>>>>>>>>>>>>>>///
78992>>>>>>>>>>>>>>>>>/// sql_set_stmt of salesp to "select recnum, id, name from SALESP where recnum > 5 order by id"
78992>>>>>>>>>>>>>>>>>/// sql_prepare_stmt of salesp
78992>>>>>>>>>>>>>>>>>/// sql_bindcolumns_stmt of salesp to salesp.recnum salesp.id salesp.name
78992>>>>>>>>>>>>>>>>>/// sql_execute_stmt of salesp
78992>>>>>>>>>>>>>>>>>///
78992>>>>>>>>>>>>>>>>>/// Report_stmt SALESP By Index.1
78992>>>>>>>>>>>>>>>>>///
78992>>>>>>>>>>>>>>>>>/// Section Header
78992>>>>>>>>>>>>>>>>>///     Sysdate Header.1
78992>>>>>>>>>>>>>>>>>///     Move PageCount to Header.2
78992>>>>>>>>>>>>>>>>>///     output header
78992>>>>>>>>>>>>>>>>>///
78992>>>>>>>>>>>>>>>>>/// Section Body
78992>>>>>>>>>>>>>>>>>///     Print Salesp.id   to Body.1
78992>>>>>>>>>>>>>>>>>///     Print Salesp.name to Body.2
78992>>>>>>>>>>>>>>>>>///     output body
78992>>>>>>>>>>>>>>>>>/// Section Total
78992>>>>>>>>>>>>>>>>>///
78992>>>>>>>>>>>>>>>>>/// Return
78992>>>>>>>>>>>>>>>>>/// ReportEnd
78992>>>>>>>>>>>>>>>>>
78992>>>>>>>>>>>>>>>>>//=============================================================================
78992>>>>>>>>>>>>>>>>>/// @Name        GET_SERVER_CFG
78992>>>>>>>>>>>>>>>>>/// @Description This command, when passed a valid server name, returns
78992>>>>>>>>>>>>>>>>>/// the a value for the specified attribute. See the list below for an
78992>>>>>>>>>>>>>>>>>/// explanation of each attribute.
78992>>>>>>>>>>>>>>>>>///
78992>>>>>>>>>>>>>>>>>/// SERVER_REVISION    Returns the major version, to the left of the decimal, of the server
78992>>>>>>>>>>>>>>>>>/// SUPPORT_DESC       Returns 1 if Server supports descending index segments
78992>>>>>>>>>>>>>>>>>/// SUPPORT_CASE       Returns 1 if Server supports case insensitive index segments
78992>>>>>>>>>>>>>>>>>/// SERVER_VERSION     Returns the full version of the server
78992>>>>>>>>>>>>>>>>>/// SERVER_ENCODING    Returns the Server Encoding
78992>>>>>>>>>>>>>>>>>/// CONNECTION_ACTIVE  Returns 1 if the connection to the server is active
78992>>>>>>>>>>>>>>>>>/// CITEXT_SUPPORT     Returns 1 if Server supports citext, a PostgreSQL data type
78992>>>>>>>>>>>>>>>>>///
78992>>>>>>>>>>>>>>>>>/// @Assumptions
78992>>>>>>>>>>>>>>>>>/// @Status      Internal
78992>>>>>>>>>>>>>>>>>/// @Drivers     All
78992>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
78992>>>>>>>>>>>>>>>>>/// @See
78992>>>>>>>>>>>>>>>>>///
78992>>>>>>>>>>>>>>>>>/// @Syntax GET_SERVER_CFG {constant} of {server} to {variable}
78992>>>>>>>>>>>>>>>>>/// @Param constant                     SERVER_REVISION,SERVER_MIN_REVISION,SUPPORT_DESC,SUPPORT_CASE,SERVER_VERSION,SERVER_ENCODING,CONNECTION_ACTIVE
78992>>>>>>>>>>>>>>>>>/// @Param server                       Name of the server being checked
78992>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the returned value
78992>>>>>>>>>>>>>>>>>///
78992>>>>>>>>>>>>>>>>>/// @Example
78992>>>>>>>>>>>>>>>>>/// GET_SERVER_CFG SERVER_VERSION of "localhost" to sVersion
78992>>>>>>>>>>>>>>>>>
78992>>>>>>>>>>>>>>>>>Function MertechInc_GET_SERVER_CFG Global String sServer Integer iAttribute Returns String
78994>>>>>>>>>>>>>>>>>    String sReturnValue
78994>>>>>>>>>>>>>>>>>
78994>>>>>>>>>>>>>>>>>    Get MertechInc_Pre_Size_String 512 to sReturnValue
78995>>>>>>>>>>>>>>>>>
78995>>>>>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_GET_SERVER_CFG CALLBACK 0 PASSING sServer sReturnValue iAttribute RESULT MertechInc_iRet
79000>>>>>>>>>>>>>>>>>
79000>>>>>>>>>>>>>>>>>    //If iAttribute = SERVER_VERSION or SERVER_ENCODING then return sReturnValue
79000>>>>>>>>>>>>>>>>>    //else we need to return MertechInc_iRet
79000>>>>>>>>>>>>>>>>>    If ((iAttribute = 4) or (iAttribute = 5)) Function_Return sReturnValue
79003>>>>>>>>>>>>>>>>>    Else                                      Function_Return MertechInc_iRet
79005>>>>>>>>>>>>>>>>>End_Function
79006>>>>>>>>>>>>>>>>>
79006>>>>>>>>>>>>>>>>>//=============================================================================
79006>>>>>>>>>>>>>>>>>/// @Name        GET_CONNECTION_STATUS
79006>>>>>>>>>>>>>>>>>/// @Description Retrieve the connection status for the specified server.
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// @Assumptions
79006>>>>>>>>>>>>>>>>>/// @Status      Internal
79006>>>>>>>>>>>>>>>>>/// @Drivers     All
79006>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-09-25 By Ian Smith
79006>>>>>>>>>>>>>>>>>/// @See
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// @Syntax GET_CONNECTION_STATUS of <serverName> [<databaseName>] to <variable>
79006>>>>>>>>>>>>>>>>>/// @Param serverName    Server Name
79006>>>>>>>>>>>>>>>>>/// @Param databaseName  Database Name
79006>>>>>>>>>>>>>>>>>/// @Param variable      DFTRUE means connection is active
79006>>>>>>>>>>>>>>>>>
79006>>>>>>>>>>>>>>>>>//=============================================================================
79006>>>>>>>>>>>>>>>>>/// @Name        GET_CLIENT_CFG
79006>>>>>>>>>>>>>>>>>/// @Description Returns the client character encoding (or encoding ID) information.
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// @Assumptions
79006>>>>>>>>>>>>>>>>>/// @Status      Internal
79006>>>>>>>>>>>>>>>>>/// @Drivers     MySQLFlex and PgFlex
79006>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-09-25 By Ian Smith
79006>>>>>>>>>>>>>>>>>/// @See
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// @Syntax GET_CLIENT_CFG [ENCODING | ENCODING_ID] of <Server> [<MySQL_Database>] to <Var>
79006>>>>>>>>>>>>>>>>>/// @Param Server           Server name to get encoding of
79006>>>>>>>>>>>>>>>>>/// @Param MySQL_Database   Database if   is the File Name
79006>>>>>>>>>>>>>>>>>/// @Param Var              Variable to hold returned value
79006>>>>>>>>>>>>>>>>>
79006>>>>>>>>>>>>>>>>>//=============================================================================
79006>>>>>>>>>>>>>>>>>/// @Name        SET_CLIENT_CFG
79006>>>>>>>>>>>>>>>>>/// @Description Returns the client character encoding (or encoding ID) information.
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// @Assumptions
79006>>>>>>>>>>>>>>>>>/// @Status      Internal
79006>>>>>>>>>>>>>>>>>/// @Drivers     MySQLFlex and PgFlex
79006>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-09-25 By Ian Smith
79006>>>>>>>>>>>>>>>>>/// @See
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// @Syntax SET_CLIENT_CFG [ENCODING | UNIQUE_CHECKS] of <Server> [<MySQL_Database>] to <Value>
79006>>>>>>>>>>>>>>>>>/// @Param Server           Server name to get encoding of
79006>>>>>>>>>>>>>>>>>/// @Param MySQL_Database   Database if   is the File Name
79006>>>>>>>>>>>>>>>>>/// @Param Value            Value to set
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// @Comment ENCODING - Set the Client Encoding
79006>>>>>>>>>>>>>>>>>/// @Comment UNIQUE_CHECKS {DFTRUE/DFFALSE} - enable/disable uniqueness checks for secondary indexes in InnoDB tables
79006>>>>>>>>>>>>>>>>>
79006>>>>>>>>>>>>>>>>>//=============================================================================
79006>>>>>>>>>>>>>>>>>/// @Name        CALL_DB2_PROCEDURE
79006>>>>>>>>>>>>>>>>>/// @Description Executes a DB2 Server stored procedure.
79006>>>>>>>>>>>>>>>>>/// @Status      Public
79006>>>>>>>>>>>>>>>>>/// @Drivers     DB2Flex
79006>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-19 By Ian Smith
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// @Syntax CALL_DB2_PROCEDURE <OWNER> <STORED_PROC> {PASSING <ARG1> {. <ARGn>}}
79006>>>>>>>>>>>>>>>>>/// @Param Owner        Name of the Procedure's Owner.
79006>>>>>>>>>>>>>>>>>/// @Param Stored_Proc  Full name of the stored procedure being called.
79006>>>>>>>>>>>>>>>>>/// @Param Arg1..Argn   Arguments passed to the procedure.
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>
79006>>>>>>>>>>>>>>>>>//=============================================================================
79006>>>>>>>>>>>>>>>>>/// @Name        GET_RESULTS
79006>>>>>>>>>>>>>>>>>/// @Description Returns the initial result set.
79006>>>>>>>>>>>>>>>>>/// @Status      Public
79006>>>>>>>>>>>>>>>>>/// @Drivers     DB2Flex
79006>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-19 By Ian Smith
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// @Syntax GET_RESULTS
79006>>>>>>>>>>>>>>>>>
79006>>>>>>>>>>>>>>>>>//=============================================================================
79006>>>>>>>>>>>>>>>>>/// @Name        GET_MORE_RESULTS
79006>>>>>>>>>>>>>>>>>/// @Description Returns remaining values not retrieved with GET_RESULT.
79006>>>>>>>>>>>>>>>>>/// @Status      Public
79006>>>>>>>>>>>>>>>>>/// @Drivers     DB2Flex
79006>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-19 By Ian Smith
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// @Syntax GET_MORE_RESULTS
79006>>>>>>>>>>>>>>>>>
79006>>>>>>>>>>>>>>>>>//=============================================================================
79006>>>>>>>>>>>>>>>>>/// @Name        GET_CURRENT_USER_NAME
79006>>>>>>>>>>>>>>>>>/// @Description This command is used to get the name of the user currently
79006>>>>>>>>>>>>>>>>>/// logged into the server.
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// @Assumptions
79006>>>>>>>>>>>>>>>>>/// @Status      Public
79006>>>>>>>>>>>>>>>>>/// @Drivers     All
79006>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
79006>>>>>>>>>>>>>>>>>/// @See                 GET_CURRENT_USER_PASSWORD
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// @Syntax GET_CURRENT_USER_NAME of {server} to {variable}
79006>>>>>>>>>>>>>>>>>/// @Param server               The name of the server the user is in
79006>>>>>>>>>>>>>>>>>/// @Param variable             Variable to hold the username
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// @Example
79006>>>>>>>>>>>>>>>>>/// GET_CURRENT_USER_NAME of "localhost" to sUserName
79006>>>>>>>>>>>>>>>>>
79006>>>>>>>>>>>>>>>>>//=============================================================================
79006>>>>>>>>>>>>>>>>>/// @Name        GET_CURRENT_USER_PASSWORD
79006>>>>>>>>>>>>>>>>>/// @Description This command is used to get the password associated with
79006>>>>>>>>>>>>>>>>>/// the user currently logged into the server.
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// @Assumptions
79006>>>>>>>>>>>>>>>>>/// @Status      Public
79006>>>>>>>>>>>>>>>>>/// @Drivers     All
79006>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
79006>>>>>>>>>>>>>>>>>/// @See                 GET_CURRENT_USER_NAME
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// @Syntax GET_CURRENT_USER_PASSWORD of {server} to {variable}
79006>>>>>>>>>>>>>>>>>/// @Param server               The name of the server the user is in
79006>>>>>>>>>>>>>>>>>/// @Param variable             Variable to hold the password
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// @Example
79006>>>>>>>>>>>>>>>>>/// GET_CURRENT_USER_PASSWORD of "localhost" to sPassword
79006>>>>>>>>>>>>>>>>>
79006>>>>>>>>>>>>>>>>>//=============================================================================
79006>>>>>>>>>>>>>>>>>/// @Name        CREATE_DB2_DATABASE
79006>>>>>>>>>>>>>>>>>/// @Description Creates a DB2 database with the same DataFlex collating sequence.
79006>>>>>>>>>>>>>>>>>/// @Status      Public
79006>>>>>>>>>>>>>>>>>/// @Drivers     All
79006>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-12 By Ian Smith
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// @Syntax CREATE_DB2_DATABASE <DB Name> <DB Alias> <Code Set> <Territory> [<Path> <Node Name> <User ID><Password>]
79006>>>>>>>>>>>>>>>>>/// @Param DB Name     Name of the database being created
79006>>>>>>>>>>>>>>>>>/// @Param DB Alias    Alias Name applied to the database being created
79006>>>>>>>>>>>>>>>>>/// @Param Code Set    Code Set used by the database being created
79006>>>>>>>>>>>>>>>>>/// @Param Territory   Territory associated to the database being created
79006>>>>>>>>>>>>>>>>>/// @Param Path        Location of the database                                    - Optional
79006>>>>>>>>>>>>>>>>>/// @Param Node Name   Name of the machine (node) where the database is to reside  - Optional
79006>>>>>>>>>>>>>>>>>/// @Param User ID     User ID owning the database                                 - Optional
79006>>>>>>>>>>>>>>>>>/// @Param Password    Password of the User owning the database                    - Optional
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>
79006>>>>>>>>>>>>>>>>>//=============================================================================
79006>>>>>>>>>>>>>>>>>/// @Name        SQL_OPEN_CURSOR_STMT
79006>>>>>>>>>>>>>>>>>/// @Description This command is used to create a new SQl Cursor. Once
79006>>>>>>>>>>>>>>>>>/// created, SQL_SET_CURRENT_CURSOR_STMT can be called to specify which
79006>>>>>>>>>>>>>>>>>/// cursor is to be used for a given SQL statement. Creating multiple
79006>>>>>>>>>>>>>>>>>/// cursors using this command allows multiple SQL statements to be
79006>>>>>>>>>>>>>>>>>/// opened at once. Optionally a different server can be specified for each
79006>>>>>>>>>>>>>>>>>/// cursor by passing the server name to this command as well. If no
79006>>>>>>>>>>>>>>>>>/// server is specified, the current server will be used. Note that it
79006>>>>>>>>>>>>>>>>>/// is important to close all cursors at the end using SQL_CLOSE_CURSOR_STMT.
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// @Assumptions
79006>>>>>>>>>>>>>>>>>/// @Status      Public
79006>>>>>>>>>>>>>>>>>/// @Drivers     All
79006>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
79006>>>>>>>>>>>>>>>>>/// @See                 SQL_CLOSE_CURSOR_STMT SQL_SET_CURRENT_CURSOR_STMT SQL_GET_CURRENT_CURSOR_STMT
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// @Syntax SQL_OPEN_CURSOR_STMT [of {server}] to {variable}
79006>>>>>>>>>>>>>>>>>/// @Param server                       Name of the server (optional)
79006>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the returned cursor handle
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// @Example
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// Integer iCursor1 iCursor2 iCustomer
79006>>>>>>>>>>>>>>>>>/// String  sName
79006>>>>>>>>>>>>>>>>>/// Number  nOrderTotal
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// SQL_OPEN_CURSOR_STMT to iCursor1
79006>>>>>>>>>>>>>>>>>/// SQL_SET_STMT         to "SELECT CUSTOMER_NUMBER,NAME FROM CUSTOMER "
79006>>>>>>>>>>>>>>>>>/// SQL_APPEND_STMT      to "ORDER BY NAME "
79006>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT
79006>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
79006>>>>>>>>>>>>>>>>>/// Repeat
79006>>>>>>>>>>>>>>>>>///     SQL_SET_CURRENT_CURSOR_STMT TO iCursor1
79006>>>>>>>>>>>>>>>>>///     SQL_FETCH_NEXT_ROW INTO iCustomer sName
79006>>>>>>>>>>>>>>>>>///     If (Found) Begin
79006>>>>>>>>>>>>>>>>>///        SQL_OPEN_CURSOR_STMT to iCursor2
79006>>>>>>>>>>>>>>>>>///        SQL_SET_STMT         to "SELECT SUM(ORDER_TOTAL) FROM ORDERHEA "
79006>>>>>>>>>>>>>>>>>///        SQL_APPEND_STMT      to ("WHERE CUSTOMER_NUMBER = " + Trim(iCustomer))
79006>>>>>>>>>>>>>>>>>///        SQL_PREPARE_STMT
79006>>>>>>>>>>>>>>>>>///        SQL_EXECUTE_STMT
79006>>>>>>>>>>>>>>>>>///        SQL_FETCH_NEXT_ROW INTO nOrderTotal
79006>>>>>>>>>>>>>>>>>///        If (Found and nOrderTotal > 0) Begin
79006>>>>>>>>>>>>>>>>>///            Showln "Customer : " iCustomer "-" sName " - Total: " nOrderTotal
79006>>>>>>>>>>>>>>>>>///        End
79006>>>>>>>>>>>>>>>>>///        SQL_CLOSE_CURSOR_STMT to Cursor2
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>///        Indicate Found True
79006>>>>>>>>>>>>>>>>>///     End
79006>>>>>>>>>>>>>>>>>/// Until (Not(Found))
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// SQL_CLOSE_CURSOR_STMT to Cursor1
79006>>>>>>>>>>>>>>>>>
79006>>>>>>>>>>>>>>>>>//=============================================================================
79006>>>>>>>>>>>>>>>>>/// @Name        SQL_CLOSE_CURSOR_STMT
79006>>>>>>>>>>>>>>>>>/// @Description This command closes the specified cursor that was created
79006>>>>>>>>>>>>>>>>>/// from SQL_OPEN_CURSOR_STMT. It is good practice to close all cursors
79006>>>>>>>>>>>>>>>>>/// once the statements associated with them are complete.
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// @Assumptions
79006>>>>>>>>>>>>>>>>>/// @Status      Public
79006>>>>>>>>>>>>>>>>>/// @Drivers     All
79006>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
79006>>>>>>>>>>>>>>>>>/// @See                 SQL_OPEN_CURSOR_STMT SQL_SET_CURRENT_CURSOR_STMT SQL_GET_CURRENT_CURSOR_STMT
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// @Syntax SQL_CLOSE_CURSOR_STMT [of {server}] to {variable}
79006>>>>>>>>>>>>>>>>>/// @Param server                       Name of the server (optional)
79006>>>>>>>>>>>>>>>>>/// @Param variable                     Cursor handle to close
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// @Example
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// SQL_OPEN_CURSOR_STMT to hCursor1
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
79006>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT
79006>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// SQL_OPEN_CURSOR_STMT to hCursor2
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Inactive' "
79006>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT
79006>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// Repeat
79006>>>>>>>>>>>>>>>>>///     SQL_SET_CURRENT_CURSOR_STMT to hCursor1
79006>>>>>>>>>>>>>>>>>///     SQL_FETCH_NEXT_ROW INTO  sID sFirstName sLastName
79006>>>>>>>>>>>>>>>>>///     If (Found) Begin
79006>>>>>>>>>>>>>>>>>///        Showln "Active : " sID "- " sFirstName sLastName
79006>>>>>>>>>>>>>>>>>///     End
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>///     SQL_SET_CURRENT_CURSOR_STMT to hCursor2
79006>>>>>>>>>>>>>>>>>///     SQL_FETCH_NEXT_ROW into sId sFirstName sLastName
79006>>>>>>>>>>>>>>>>>///     If (Found) Begin
79006>>>>>>>>>>>>>>>>>///         Showln "Inactive : " sID "- " sFirstName sLastName
79006>>>>>>>>>>>>>>>>>///     End
79006>>>>>>>>>>>>>>>>>/// Until (FindErr)
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// SQL_CLOSE_CURSOR_STMT to hCursor1
79006>>>>>>>>>>>>>>>>>/// SQL_CLOSE_CURSOR_STMT to hCursor2
79006>>>>>>>>>>>>>>>>>
79006>>>>>>>>>>>>>>>>>//=============================================================================
79006>>>>>>>>>>>>>>>>>/// @Name        SQL_SET_CURRENT_CURSOR_STMT
79006>>>>>>>>>>>>>>>>>/// @Description This command is used to open a cursor to be used for an
79006>>>>>>>>>>>>>>>>>/// SQl statement. The cursor must be created using the SQL_OPEN_CURSOR_STMT,
79006>>>>>>>>>>>>>>>>>/// but once it has been created, this command can easily switch between
79006>>>>>>>>>>>>>>>>>/// cursors as desired. Optionally a different server can be specified for each
79006>>>>>>>>>>>>>>>>>/// cursor by passing the server name to this command as well. If no
79006>>>>>>>>>>>>>>>>>/// server is specified, the current server will be used. Note that it
79006>>>>>>>>>>>>>>>>>/// is important to close all cursors at the end using SQL_CLOSE_CURSOR_STMT.
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// @Assumptions
79006>>>>>>>>>>>>>>>>>/// @Status      Public
79006>>>>>>>>>>>>>>>>>/// @Drivers     All
79006>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
79006>>>>>>>>>>>>>>>>>/// @See                 SQL_OPEN_CURSOR_STMT SQL_CLOSE_CURSOR_STMT SQL_GET_CURRENT_CURSOR_STMT
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// @Syntax SQL_SET_CURRENT_CURSOR_STMT [of {server}] to {variable}
79006>>>>>>>>>>>>>>>>>/// @Param server                       Name of the server (optional)
79006>>>>>>>>>>>>>>>>>/// @Param variable                     Cursor handle to use
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// @Example
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// SQL_OPEN_CURSOR_STMT to hCursor1
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
79006>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT
79006>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// SQL_OPEN_CURSOR_STMT to hCursor2
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Inactive' "
79006>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT
79006>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// Repeat
79006>>>>>>>>>>>>>>>>>///     SQL_SET_CURRENT_CURSOR_STMT to hCursor1
79006>>>>>>>>>>>>>>>>>///     SQL_FETCH_NEXT_ROW INTO  sID sFirstName sLastName
79006>>>>>>>>>>>>>>>>>///     If (Found) Begin
79006>>>>>>>>>>>>>>>>>///        Showln "Active : " sID "- " sFirstName sLastName
79006>>>>>>>>>>>>>>>>>///     End
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>///     SQL_SET_CURRENT_CURSOR_STMT to hCursor2
79006>>>>>>>>>>>>>>>>>///     SQL_FETCH_NEXT_ROW into sId sFirstName sLastName
79006>>>>>>>>>>>>>>>>>///     If (Found) Begin
79006>>>>>>>>>>>>>>>>>///         Showln "Inactive : " sID "- " sFirstName sLastName
79006>>>>>>>>>>>>>>>>>///     End
79006>>>>>>>>>>>>>>>>>/// Until (FindErr)
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// SQL_CLOSE_CURSOR_STMT to hCursor1
79006>>>>>>>>>>>>>>>>>/// SQL_CLOSE_CURSOR_STMT to hCursor2
79006>>>>>>>>>>>>>>>>>
79006>>>>>>>>>>>>>>>>>//=============================================================================
79006>>>>>>>>>>>>>>>>>/// @Name        SQL_GET_CURRENT_CURSOR_STMT
79006>>>>>>>>>>>>>>>>>/// @Description This command returns the current active cursor being
79006>>>>>>>>>>>>>>>>>/// used. The cursor is returned to the specified variable.
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// @Assumptions
79006>>>>>>>>>>>>>>>>>/// @Status      Public
79006>>>>>>>>>>>>>>>>>/// @Drivers     All
79006>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
79006>>>>>>>>>>>>>>>>>/// @See SQL_OPEN_CURSOR_STMT SQL_CLOSE_CURSOR_STMT SQL_SET_CURRENT_CURSOR_STMT
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// @Syntax SQL_GET_CURRENT_CURSOR_STMT [of {server}] to {variable}
79006>>>>>>>>>>>>>>>>>/// @Param server                       Name of the server (optional)
79006>>>>>>>>>>>>>>>>>/// @Param variable         Variable to hold the current cursor handle
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// @Example
79006>>>>>>>>>>>>>>>>>/// SQL_GET_CURRENT_CURSOR_STMT to hCursor
79006>>>>>>>>>>>>>>>>>
79006>>>>>>>>>>>>>>>>>//=============================================================================
79006>>>>>>>>>>>>>>>>>/// @Name        SQL_SET_MAX_CURSORS_STMT
79006>>>>>>>>>>>>>>>>>/// @Description Sets the maximum number of simultaneous cursors allowed.
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// @Assumptions
79006>>>>>>>>>>>>>>>>>/// @Status      Deprecated
79006>>>>>>>>>>>>>>>>>/// @Drivers     All
79006>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
79006>>>>>>>>>>>>>>>>>/// @See
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// @Syntax SQL_SET_MAX_CURSORS_STMT [of {server}] to {variable}
79006>>>>>>>>>>>>>>>>>/// @Param server                       Name of the server (optional)
79006>>>>>>>>>>>>>>>>>/// @Param variable                     Maximum number of cursors allowed
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// @Example
79006>>>>>>>>>>>>>>>>>/// SQL_SET_MAX_CURSORS_STMT to 50
79006>>>>>>>>>>>>>>>>>
79006>>>>>>>>>>>>>>>>>//=============================================================================
79006>>>>>>>>>>>>>>>>>/// @Name        SQL_GET_MAX_CURSORS_STMT
79006>>>>>>>>>>>>>>>>>/// @Description Retrieves the maximum number of cursors allowed.
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// @Assumptions
79006>>>>>>>>>>>>>>>>>/// @Status      Deprecated
79006>>>>>>>>>>>>>>>>>/// @Drivers     All
79006>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
79006>>>>>>>>>>>>>>>>>/// @See
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// @Syntax SQL_GET_MAX_CURSORS_STMT [of {server}] to {variable}
79006>>>>>>>>>>>>>>>>>/// @Param server                       Name of the server (optional)
79006>>>>>>>>>>>>>>>>>/// @Param variable                     Maximum number of cursors allowed
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// @Example
79006>>>>>>>>>>>>>>>>>/// SQL_GET_MAX_CURSORS_STMT to iCursors
79006>>>>>>>>>>>>>>>>>
79006>>>>>>>>>>>>>>>>>//=============================================================================
79006>>>>>>>>>>>>>>>>>/// @Name        SQL_SET_LOCAL_TD_PATH
79006>>>>>>>>>>>>>>>>>/// @Description Sets the directory where the driver will find the LOCAL TD files.
79006>>>>>>>>>>>>>>>>>/// @Status      Deprecated
79006>>>>>>>>>>>>>>>>>/// @Drivers     All
79006>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-19 By Ian Smith
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// @Syntax SQL_SET_LOCAL_TD_PATH TO <DirectoryPath|Variable>
79006>>>>>>>>>>>>>>>>>/// @Param DirectoryPath   Directory path were the TD files are to be located.
79006>>>>>>>>>>>>>>>>>
79006>>>>>>>>>>>>>>>>>//=============================================================================
79006>>>>>>>>>>>>>>>>>/// @Name        SQL_GET_LOCAL_TD_PATH
79006>>>>>>>>>>>>>>>>>/// @Description Gets the directory where the driver is looking for the LOCAL TD files.
79006>>>>>>>>>>>>>>>>>/// @Status      Deprecated
79006>>>>>>>>>>>>>>>>>/// @Drivers     All
79006>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-19 By Ian Smith
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// @Syntax SQL_SET_LOCAL_TD_PATH TO <DirectoryPath|Variable>
79006>>>>>>>>>>>>>>>>>/// @Param DirectoryPath   Directory path were the driver is looking
79006>>>>>>>>>>>>>>>>>
79006>>>>>>>>>>>>>>>>>//=============================================================================
79006>>>>>>>>>>>>>>>>>/// @Name        GET_DRIVER_REVISION
79006>>>>>>>>>>>>>>>>>/// @Description This command will put the current version (decimals included)
79006>>>>>>>>>>>>>>>>>/// of the driver associated with the current workspace into the specified
79006>>>>>>>>>>>>>>>>>/// variable.
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// @Assumptions
79006>>>>>>>>>>>>>>>>>/// @Status      Public
79006>>>>>>>>>>>>>>>>>/// @Drivers     All
79006>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
79006>>>>>>>>>>>>>>>>>/// @See                 GET_DRIVER_MAJOR_REVISION
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// @Syntax GET_DRIVER_REVISION to {variable}
79006>>>>>>>>>>>>>>>>>/// @Param variable                     String variable to hold the returned version
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// @Example
79006>>>>>>>>>>>>>>>>>/// GET_DRIVER_REVISION to sVersion
79006>>>>>>>>>>>>>>>>>
79006>>>>>>>>>>>>>>>>>//=============================================================================
79006>>>>>>>>>>>>>>>>>/// @Name        GET_DRIVER_MAJOR_REVISION
79006>>>>>>>>>>>>>>>>>/// @Description This command will put the current version (no decimals)
79006>>>>>>>>>>>>>>>>>/// of the driver associated with the current workspace into the specified
79006>>>>>>>>>>>>>>>>>/// variable.
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// @Assumptions
79006>>>>>>>>>>>>>>>>>/// @Status      Public
79006>>>>>>>>>>>>>>>>>/// @Drivers     All
79006>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
79006>>>>>>>>>>>>>>>>>/// @See                 GET_DRIVER_REVISION
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// @Syntax GET_DRIVER_MAJOR_REVISION to {variable}
79006>>>>>>>>>>>>>>>>>/// @Param variable                     String variable to hold the returned version
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// @Example
79006>>>>>>>>>>>>>>>>>/// GET_DRIVER_MAJOR_REVISION to sVersion
79006>>>>>>>>>>>>>>>>>
79006>>>>>>>>>>>>>>>>>//=============================================================================
79006>>>>>>>>>>>>>>>>>/// @Name        GET_DRIVER_LICENSE_EXPIRATION_TIME
79006>>>>>>>>>>>>>>>>>/// @Description This command is used to find out how long until a
79006>>>>>>>>>>>>>>>>>/// specific temporary license for a driver expires. If 0 is returned,
79006>>>>>>>>>>>>>>>>>/// then the license is not a temporary license. If -1 is returned, then
79006>>>>>>>>>>>>>>>>>/// the license has already expired. Otherwise, the number returned
79006>>>>>>>>>>>>>>>>>/// is the number of days until the license will expire.
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// @Assumptions
79006>>>>>>>>>>>>>>>>>/// @Status      Public
79006>>>>>>>>>>>>>>>>>/// @Drivers     All
79006>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 Aaron Gulack
79006>>>>>>>>>>>>>>>>>/// @See                 GET_DRIVER_LICENSE_PATH SET_DRIVER_LICENSE_EXPIRATION_WARNING
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// @Syntax GET_DRIVER_LICENSE_EXPIRATION_TIME to {variable}
79006>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the days until expiration
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// @Example
79006>>>>>>>>>>>>>>>>>/// GET_DRIVER_LICENSE_EXPIRATION_TIME to iExpire
79006>>>>>>>>>>>>>>>>>/// Showln iExpire
79006>>>>>>>>>>>>>>>>>
79006>>>>>>>>>>>>>>>>>//=============================================================================
79006>>>>>>>>>>>>>>>>>/// @Name        SET_DRIVER_LICENSE_EXPIRATION_WARNING
79006>>>>>>>>>>>>>>>>>/// @Description This command is used to set a custom warning message to
79006>>>>>>>>>>>>>>>>>/// be displayed when a temporary license for a driver is close to expiring.
79006>>>>>>>>>>>>>>>>>/// Note that since the license evaluation is done during Login and before
79006>>>>>>>>>>>>>>>>>/// any open calls, this command should be called before either of those.
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// @Assumptions
79006>>>>>>>>>>>>>>>>>/// @Status      Public
79006>>>>>>>>>>>>>>>>>/// @Drivers     All
79006>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
79006>>>>>>>>>>>>>>>>>/// @See                 GET_DRIVER_LICENSE_PATH GET_DRIVER_LICENSE_EXPIRATION_TIME
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// @Syntax SET_DRIVER_LICENSE_EXPIRATION_WARNING to {variable}
79006>>>>>>>>>>>>>>>>>/// @Param variable                     New warning message for expiring license
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// @Example
79006>>>>>>>>>>>>>>>>>/// SET_DRIVER_LICENSE_EXPIRATION_WARNING to "Your license is about to expire."
79006>>>>>>>>>>>>>>>>>/// Login "localhost" "" "" "sql_drv"
79006>>>>>>>>>>>>>>>>>
79006>>>>>>>>>>>>>>>>>//=============================================================================
79006>>>>>>>>>>>>>>>>>/// @Name        GET_DRIVER_LICENSE_PATH
79006>>>>>>>>>>>>>>>>>/// @Description This command will return the current path of the license
79006>>>>>>>>>>>>>>>>>/// associated with the driver.
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// @Assumptions
79006>>>>>>>>>>>>>>>>>/// @Status      Internal
79006>>>>>>>>>>>>>>>>>/// @Drivers     All
79006>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
79006>>>>>>>>>>>>>>>>>/// @See                 SET_DRIVER_LICENSE_EXPIRATION_WARNING GET_DRIVER_LICENSE_EXPIRATION_TIME
79006>>>>>>>>>>>>>>>>>///
79006>>>>>>>>>>>>>>>>>/// @Syntax GET_DRIVER_LICENSE_PATH to {variable}
79006>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the path of the license
79006>>>>>>>>>>>>>>>>>
79006>>>>>>>>>>>>>>>>>Function MertechInc_GET_DRIVER_LICENSE_PATH Global Returns String
79008>>>>>>>>>>>>>>>>>    String sReturnValue
79008>>>>>>>>>>>>>>>>>
79008>>>>>>>>>>>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
79034>>>>>>>>>>>>>>>>>>
79034>>>>>>>>>>>>>>>>>    If (MertechInc_FileNumber <> -1) Begin
79036>>>>>>>>>>>>>>>>>        Get MertechInc_Pre_Size_String 4096 to sReturnValue
79037>>>>>>>>>>>>>>>>>        Call_Driver 0 MertechInc_DriverName Function CALLDRV_LICENSE_ENVIRONMENT_SET CALLBACK 0 PASSING sReturnValue MertechInc_Blank CALLDRV_LICENSE_PATH RESULT MertechInc_iRet
79042>>>>>>>>>>>>>>>>>        If MertechInc_iRet EQ -1 INDICATE ERR True
79045>>>>>>>>>>>>>>>>>    End
79045>>>>>>>>>>>>>>>>>>
79045>>>>>>>>>>>>>>>>>
79045>>>>>>>>>>>>>>>>>    Function_Return sReturnValue
79046>>>>>>>>>>>>>>>>>End_Function
79047>>>>>>>>>>>>>>>>>
79047>>>>>>>>>>>>>>>>>//=============================================================================
79047>>>>>>>>>>>>>>>>>/// @Name        SET_DATABASE_PORT
79047>>>>>>>>>>>>>>>>>/// @Description This command is used to dynamically change the port
79047>>>>>>>>>>>>>>>>>/// number to use for all TCP/IP connections to the server. Note that
79047>>>>>>>>>>>>>>>>>/// the port is used for the current session only.
79047>>>>>>>>>>>>>>>>>///
79047>>>>>>>>>>>>>>>>>/// @Assumptions The port is valid and available
79047>>>>>>>>>>>>>>>>>/// @Status      Public
79047>>>>>>>>>>>>>>>>>/// @Drivers     MySQLFlex PgFlex
79047>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
79047>>>>>>>>>>>>>>>>>/// @See                 GET_DATABASE_PORT
79047>>>>>>>>>>>>>>>>>///
79047>>>>>>>>>>>>>>>>>/// @Syntax SET_DATABASE_PORT of {constant} to {variable}
79047>>>>>>>>>>>>>>>>>/// @Param constant                     MYSQL or PGSQL
79047>>>>>>>>>>>>>>>>>/// @Param variable                     Port number to use to connect to server
79047>>>>>>>>>>>>>>>>>///
79047>>>>>>>>>>>>>>>>>/// @Example
79047>>>>>>>>>>>>>>>>>/// GET_DATABASE_PORT of MYSQL to 1433
79047>>>>>>>>>>>>>>>>>
79047>>>>>>>>>>>>>>>>>//=============================================================================
79047>>>>>>>>>>>>>>>>>/// @Name        GET_DATABASE_PORT
79047>>>>>>>>>>>>>>>>>/// @Description This command returns the TCP/IP port used to connect
79047>>>>>>>>>>>>>>>>>/// to the server.
79047>>>>>>>>>>>>>>>>>///
79047>>>>>>>>>>>>>>>>>/// @Assumptions
79047>>>>>>>>>>>>>>>>>/// @Status      Public
79047>>>>>>>>>>>>>>>>>/// @Drivers     MySQLFlex PgFlex
79047>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
79047>>>>>>>>>>>>>>>>>/// @See                 SET_DATABASE_PORT
79047>>>>>>>>>>>>>>>>>///
79047>>>>>>>>>>>>>>>>>/// @Syntax GET_DATABASE_PORT of {MYSQL/PGSQL} to {variable}
79047>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the TCP/IP port number
79047>>>>>>>>>>>>>>>>>///
79047>>>>>>>>>>>>>>>>>/// @Example
79047>>>>>>>>>>>>>>>>>/// GET_DATABASE_PORT of MYSQL to iPort
79047>>>>>>>>>>>>>>>>>
79047>>>>>>>>>>>>>>>>>//=============================================================================
79047>>>>>>>>>>>>>>>>>/// @Name        GET_SERIAL_NUMBER
79047>>>>>>>>>>>>>>>>>/// @Description This command returns the serial number associated with
79047>>>>>>>>>>>>>>>>>/// the current driver's license.
79047>>>>>>>>>>>>>>>>>///
79047>>>>>>>>>>>>>>>>>/// @Assumptions
79047>>>>>>>>>>>>>>>>>/// @Status      Public
79047>>>>>>>>>>>>>>>>>/// @Drivers     All
79047>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
79047>>>>>>>>>>>>>>>>>/// @See
79047>>>>>>>>>>>>>>>>>///
79047>>>>>>>>>>>>>>>>>/// @Syntax GET_SERIAL_NUMBER to {variable}
79047>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the driver's serial number
79047>>>>>>>>>>>>>>>>>///
79047>>>>>>>>>>>>>>>>>/// @Example
79047>>>>>>>>>>>>>>>>>/// GET_SERIAL_NUMBER to iSerial
79047>>>>>>>>>>>>>>>>>
79047>>>>>>>>>>>>>>>>>//=============================================================================
79047>>>>>>>>>>>>>>>>>/// @Name        SET_DATABASE_SOCKET
79047>>>>>>>>>>>>>>>>>/// @Description This command is used to set the socket used to connect
79047>>>>>>>>>>>>>>>>>/// to the server when running an application under Linux/Unix.
79047>>>>>>>>>>>>>>>>>///
79047>>>>>>>>>>>>>>>>>/// @Assumptions
79047>>>>>>>>>>>>>>>>>/// @Status      Public
79047>>>>>>>>>>>>>>>>>/// @Drivers     MySQLFlex
79047>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
79047>>>>>>>>>>>>>>>>>/// @See                 GET_DATABASE_SOCKET
79047>>>>>>>>>>>>>>>>>///
79047>>>>>>>>>>>>>>>>>/// @Syntax SET_DATABASE_SOCKET of MYSQL to {variable}
79047>>>>>>>>>>>>>>>>>/// @Param variable                     Full name of the socket
79047>>>>>>>>>>>>>>>>>
79047>>>>>>>>>>>>>>>>>//=============================================================================
79047>>>>>>>>>>>>>>>>>/// @Name        GET_DATABASE_SOCKET
79047>>>>>>>>>>>>>>>>>/// @Description This command returns the name of the socket used to
79047>>>>>>>>>>>>>>>>>/// connect to the server when running an application under Linux/Unix.
79047>>>>>>>>>>>>>>>>>///
79047>>>>>>>>>>>>>>>>>/// @Assumptions
79047>>>>>>>>>>>>>>>>>/// @Status      Public
79047>>>>>>>>>>>>>>>>>/// @Drivers     MySQLFlex
79047>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
79047>>>>>>>>>>>>>>>>>/// @See                 SET_DATABASE_SOCKET
79047>>>>>>>>>>>>>>>>>///
79047>>>>>>>>>>>>>>>>>/// @Syntax SET_DATABASE_SOCKET of MYSQL to {variable}
79047>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the full socket name
79047>>>>>>>>>>>>>>>>>
79047>>>>>>>>>>>>>>>>>//=============================================================================
79047>>>>>>>>>>>>>>>>>/// @Name        SET_AUTHENTICATION_MODE
79047>>>>>>>>>>>>>>>>>/// @Description This command is used to control what mode the user logs
79047>>>>>>>>>>>>>>>>>/// in as. When DEFAULT is passed, the user will be logged in with the
79047>>>>>>>>>>>>>>>>>/// default privileges given to it. When SYSDBA is passed, the user will
79047>>>>>>>>>>>>>>>>>/// be logged in with the roles assigned to the sysdba user, most likely
79047>>>>>>>>>>>>>>>>>/// full control over the database.
79047>>>>>>>>>>>>>>>>>///
79047>>>>>>>>>>>>>>>>>/// @Assumptions
79047>>>>>>>>>>>>>>>>>/// @Status      Public
79047>>>>>>>>>>>>>>>>>/// @Drivers     OraFlex
79047>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
79047>>>>>>>>>>>>>>>>>/// @See
79047>>>>>>>>>>>>>>>>>///
79047>>>>>>>>>>>>>>>>>/// @Syntax SET_AUTHENTICATION_MODE of Oracle to {SYSDBA/DEFAULT}
79047>>>>>>>>>>>>>>>>>///
79047>>>>>>>>>>>>>>>>>/// @Example
79047>>>>>>>>>>>>>>>>>/// SET_AUTHENTICATION_MODE of Oracle to DEFAULT
79047>>>>>>>>>>>>>>>>>
79047>>>>>>>>>>>>>>>>>//=============================================================================
79047>>>>>>>>>>>>>>>>>/// @Name        SQL_ESCAPE_STRING
79047>>>>>>>>>>>>>>>>>/// @Description This command is used to properly escape strings before
79047>>>>>>>>>>>>>>>>>/// they are used in embedded SQL statements. This can be extremely
79047>>>>>>>>>>>>>>>>>/// important when you do not have full control of the strings being passed
79047>>>>>>>>>>>>>>>>>/// to the SQL statement as this will ensure that the strings are properly
79047>>>>>>>>>>>>>>>>>/// quoted.
79047>>>>>>>>>>>>>>>>>///
79047>>>>>>>>>>>>>>>>>/// @Assumptions
79047>>>>>>>>>>>>>>>>>/// @Status      Public
79047>>>>>>>>>>>>>>>>>/// @Drivers     All
79047>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
79047>>>>>>>>>>>>>>>>>/// @See
79047>>>>>>>>>>>>>>>>>///
79047>>>>>>>>>>>>>>>>>/// @Syntax SQL_ESCAPE_STRING of {string} to {variable}
79047>>>>>>>>>>>>>>>>>/// @Param string               The string to be escaped.
79047>>>>>>>>>>>>>>>>>/// @Param variable     Variable to hold the newly escaped string
79047>>>>>>>>>>>>>>>>>///
79047>>>>>>>>>>>>>>>>>/// @Example
79047>>>>>>>>>>>>>>>>>/// SQL_ESCAPE_STRING of "They said to me, 'hello'." to sEscaped
79047>>>>>>>>>>>>>>>>>
79047>>>>>>>>>>>>>>>>>Function SQLESCAPESTRING Global String sData Returns String
79049>>>>>>>>>>>>>>>>>    String sReturnData
79049>>>>>>>>>>>>>>>>>
79049>>>>>>>>>>>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
79075>>>>>>>>>>>>>>>>>>
79075>>>>>>>>>>>>>>>>>
79075>>>>>>>>>>>>>>>>>    If (MertechInc_FileNumber <> -1) Begin
79077>>>>>>>>>>>>>>>>>        Get MertechInc_Pre_Size_String 0 to sReturnData
79078>>>>>>>>>>>>>>>>>        Call_Driver 0 MertechInc_DriverName Function CALLDRV_ESCAPE_STRING CALLBACK 0 PASSING sData sReturnData 0 RESULT MertechInc_iRet
79083>>>>>>>>>>>>>>>>>    End
79083>>>>>>>>>>>>>>>>>>
79083>>>>>>>>>>>>>>>>>
79083>>>>>>>>>>>>>>>>>    Function_Return sReturnData
79084>>>>>>>>>>>>>>>>>End_Function
79085>>>>>>>>>>>>>>>>>
79085>>>>>>>>>>>>>>>>>//=============================================================================
79085>>>>>>>>>>>>>>>>>/// @Name        DIRECT_PATH_LOAD
79085>>>>>>>>>>>>>>>>>/// @Description
79085>>>>>>>>>>>>>>>>>///
79085>>>>>>>>>>>>>>>>>/// @Assumptions
79085>>>>>>>>>>>>>>>>>/// @Status      Internal
79085>>>>>>>>>>>>>>>>>/// @Drivers     OraFlex
79085>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-09-21 By Ian Smith
79085>>>>>>>>>>>>>>>>>/// @See
79085>>>>>>>>>>>>>>>>>
79085>>>>>>>>>>>>>>>>>//=============================================================================
79085>>>>>>>>>>>>>>>>>/// @Name        SQL_INITIALIZE_SEQUENCE
79085>>>>>>>>>>>>>>>>>/// @Description This command is used to initialize all auto increment
79085>>>>>>>>>>>>>>>>>/// columns, or sequences in Oracle, of the specified table to be the
79085>>>>>>>>>>>>>>>>>/// highest number plus one. This is useful when inserting a large amount
79085>>>>>>>>>>>>>>>>>/// of records in the table and the sequence is not being updated because
79085>>>>>>>>>>>>>>>>>/// the auto incremented column is being manually filled.
79085>>>>>>>>>>>>>>>>>///
79085>>>>>>>>>>>>>>>>>/// @Assumptions
79085>>>>>>>>>>>>>>>>>/// @Status      Public
79085>>>>>>>>>>>>>>>>>/// @Drivers     OraFlex PgFlex
79085>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
79085>>>>>>>>>>>>>>>>>/// @See
79085>>>>>>>>>>>>>>>>>///
79085>>>>>>>>>>>>>>>>>/// SQL_INITIALIZE_SEQUENCE of {FileNumber}
79085>>>>>>>>>>>>>>>>>/// @Param FileNumber                   The file number
79085>>>>>>>>>>>>>>>>>
79085>>>>>>>>>>>>>>>>>//=============================================================================
79085>>>>>>>>>>>>>>>>>/// @Name        LOB_APPEND
79085>>>>>>>>>>>>>>>>>/// @Description This command is used to append data to an existing LOB
79085>>>>>>>>>>>>>>>>>/// column in the database. When called, the data corresponding field
79085>>>>>>>>>>>>>>>>>/// in the buffer is appended to the respective column in the database.
79085>>>>>>>>>>>>>>>>>/// This can be very useful when saving data that exceeds VDF size limits
79085>>>>>>>>>>>>>>>>>/// but falls within the limits of the SQL database. Note that this command
79085>>>>>>>>>>>>>>>>>/// must write to a file that is active and locked. Also the save is handled
79085>>>>>>>>>>>>>>>>>/// within the command so no extra calls are needed to save the changes made.
79085>>>>>>>>>>>>>>>>>///
79085>>>>>>>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
79085>>>>>>>>>>>>>>>>>/// @Status      Deprecated
79085>>>>>>>>>>>>>>>>>/// @Drivers     All
79085>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
79085>>>>>>>>>>>>>>>>>/// @See                 SQL_LOB_ADD_CHUNK
79085>>>>>>>>>>>>>>>>>///
79085>>>>>>>>>>>>>>>>>/// @Syntax LOB_APPEND of {FileName} {FieldNumber}
79085>>>>>>>>>>>>>>>>>/// @Param FileName                     Name of the file containing the LOB column
79085>>>>>>>>>>>>>>>>>/// @Param FieldNumber          Number of the field being appended to
79085>>>>>>>>>>>>>>>>>///
79085>>>>>>>>>>>>>>>>>/// @Example
79085>>>>>>>>>>>>>>>>>/// Clear Customer
79085>>>>>>>>>>>>>>>>>/// Find Gt Customer By Index.1
79085>>>>>>>>>>>>>>>>>///
79085>>>>>>>>>>>>>>>>>/// Direct_Input 'C:\Mertech.xml'
79085>>>>>>>>>>>>>>>>>/// Lock
79085>>>>>>>>>>>>>>>>>///    Find Eq Customer by Recnum
79085>>>>>>>>>>>>>>>>>///
79085>>>>>>>>>>>>>>>>>///    Read_Block Customer.Comments 16384
79085>>>>>>>>>>>>>>>>>///    SQL_LOB_WRITE of Customer 13 // Customer.Comments
79085>>>>>>>>>>>>>>>>>///    Repeat
79085>>>>>>>>>>>>>>>>>///        Read_Block Customer.Comments 16384
79085>>>>>>>>>>>>>>>>>///        SQL_LOB_APPEND of Customer 13 // Customer.Comments
79085>>>>>>>>>>>>>>>>>///    Until (SeqEOF)
79085>>>>>>>>>>>>>>>>>/// Unlock
79085>>>>>>>>>>>>>>>>>///
79085>>>>>>>>>>>>>>>>>/// Close_Input
79085>>>>>>>>>>>>>>>>>/// Find Eq Customer By Recnum
79085>>>>>>>>>>>>>>>>>/// SQL_LOB_LENGTH of Customer 13 to iLength
79085>>>>>>>>>>>>>>>>>/// Showln 'Length: ' iLength
79085>>>>>>>>>>>>>>>>>
79085>>>>>>>>>>>>>>>>>
79085>>>>>>>>>>>>>>>>>//=============================================================================
79085>>>>>>>>>>>>>>>>>/// @Name        LOB_LENGTH
79085>>>>>>>>>>>>>>>>>/// @Description This command returns the length of the data in the
79085>>>>>>>>>>>>>>>>>/// specified column. This command must be used after a proper FIND to
79085>>>>>>>>>>>>>>>>>/// ensure that a valid record is in the buffer. This can be a useful
79085>>>>>>>>>>>>>>>>>/// command for checking if uploaded data exceeds size limits.
79085>>>>>>>>>>>>>>>>>///
79085>>>>>>>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
79085>>>>>>>>>>>>>>>>>/// @Status      Deprecated
79085>>>>>>>>>>>>>>>>>/// @Drivers     All
79085>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
79085>>>>>>>>>>>>>>>>>/// @See                 SQL_GET_LOB_LENGTH
79085>>>>>>>>>>>>>>>>>///
79085>>>>>>>>>>>>>>>>>/// @Syntax LOB_LENGTH of {FileName} {FieldNumber} to {variable}
79085>>>>>>>>>>>>>>>>>/// @Param FileName                     Name of the file
79085>>>>>>>>>>>>>>>>>/// @Param FieldNumber          Number of the LOB field
79085>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the length
79085>>>>>>>>>>>>>>>>>///
79085>>>>>>>>>>>>>>>>>/// @Example
79085>>>>>>>>>>>>>>>>>/// Clear Customer
79085>>>>>>>>>>>>>>>>>/// Find Gt Customer By Index.1
79085>>>>>>>>>>>>>>>>>/// SQL_LOB_LENGTH of Customer 13 to iLength
79085>>>>>>>>>>>>>>>>>/// Showln 'Length: ' iLength
79085>>>>>>>>>>>>>>>>>
79085>>>>>>>>>>>>>>>>>
79085>>>>>>>>>>>>>>>>>//=============================================================================
79085>>>>>>>>>>>>>>>>>/// @Name        LOB_READ
79085>>>>>>>>>>>>>>>>>/// @Description This command reads a chunk of data from a specified LOB
79085>>>>>>>>>>>>>>>>>/// column, moving it into its corresponding field buffer. Because the
79085>>>>>>>>>>>>>>>>>/// chunk will be moved into the field buffer, it can only be as large as
79085>>>>>>>>>>>>>>>>>/// the buffer allows. To account for this, the constants FIRST or NEXT
79085>>>>>>>>>>>>>>>>>/// are passed as well indicating whether to grab the first chunk for
79085>>>>>>>>>>>>>>>>>/// the buffer or the next. Each chunk grabbed will be as large as allowed.
79085>>>>>>>>>>>>>>>>>/// All these things considered, when reading data larger than the field
79085>>>>>>>>>>>>>>>>>/// buffer, it is good practice to perform the read in a loop, adding the
79085>>>>>>>>>>>>>>>>>/// length each time. Another optional parameter that can be passed is a
79085>>>>>>>>>>>>>>>>>/// variable that will store the length of the chunk. Note that a LOB read
79085>>>>>>>>>>>>>>>>>/// must be done after a successful find on the record.
79085>>>>>>>>>>>>>>>>>///
79085>>>>>>>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
79085>>>>>>>>>>>>>>>>>/// @Status      Deprecated
79085>>>>>>>>>>>>>>>>>/// @Drivers     All
79085>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
79085>>>>>>>>>>>>>>>>>/// @See                 SQL_GET_LOB SQL_GET_LOB_CHUNK
79085>>>>>>>>>>>>>>>>>///
79085>>>>>>>>>>>>>>>>>/// @Syntax LOB_READ of {FileName} {FieldNumber} {FIRST/NEXT} [{length}]
79085>>>>>>>>>>>>>>>>>/// @Param FileName                     Name of the file containing the LOB field
79085>>>>>>>>>>>>>>>>>/// @Param FieldNumber          Number of the field being read from
79085>>>>>>>>>>>>>>>>>/// @Param FIRST                        Reads the first chunk of data
79085>>>>>>>>>>>>>>>>>/// @Param NEXT                         Reads the next chuck of data (if larger than buffer limit)
79085>>>>>>>>>>>>>>>>>/// @Param length                       Variable to hold the chunk length (optional)
79085>>>>>>>>>>>>>>>>>///
79085>>>>>>>>>>>>>>>>>/// @Example
79085>>>>>>>>>>>>>>>>>/// Direct_Output ('binary:Mertech.pdf')
79085>>>>>>>>>>>>>>>>>///
79085>>>>>>>>>>>>>>>>>/// Clear customer
79085>>>>>>>>>>>>>>>>>/// Find Gt customer by Index.1
79085>>>>>>>>>>>>>>>>>/// SQL_LOB_LENGTH of customer 13 to liLength
79085>>>>>>>>>>>>>>>>>///
79085>>>>>>>>>>>>>>>>>/// While (liLength > 0)
79085>>>>>>>>>>>>>>>>>///     Write customer.comments
79085>>>>>>>>>>>>>>>>>///     SQL_LOB_READ of customer 13 Next liLength
79085>>>>>>>>>>>>>>>>>/// Loop
79085>>>>>>>>>>>>>>>>>///
79085>>>>>>>>>>>>>>>>>/// Close_Output
79085>>>>>>>>>>>>>>>>>
79085>>>>>>>>>>>>>>>>>
79085>>>>>>>>>>>>>>>>>//=============================================================================
79085>>>>>>>>>>>>>>>>>/// @Name        LOB_WRITE
79085>>>>>>>>>>>>>>>>>/// @Description This command is used to write data to a LOB column.
79085>>>>>>>>>>>>>>>>>/// By passing the file name and field number of the LOB column, this
79085>>>>>>>>>>>>>>>>>/// command will take the current value of the respective field in
79085>>>>>>>>>>>>>>>>>/// the field buffer, write it to the database and save it. Any data
79085>>>>>>>>>>>>>>>>>/// currently in that field will be overridden by the data from the
79085>>>>>>>>>>>>>>>>>/// buffer. Note that this command must write to a file that is active
79085>>>>>>>>>>>>>>>>>/// and locked. Also this command handles the save so no extra calls
79085>>>>>>>>>>>>>>>>>/// are needed to save the changes.
79085>>>>>>>>>>>>>>>>>///
79085>>>>>>>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
79085>>>>>>>>>>>>>>>>>/// @Status      Deprecated
79085>>>>>>>>>>>>>>>>>/// @Drivers     All
79085>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
79085>>>>>>>>>>>>>>>>>/// @See                 SQL_SET_LOB SQL_ADD_LOB_CHUNK
79085>>>>>>>>>>>>>>>>>///
79085>>>>>>>>>>>>>>>>>/// @Syntax LOB_WRITE of {FileName} {FieldNumber}
79085>>>>>>>>>>>>>>>>>/// @Param FileName                     Name of the file containing the LOB field
79085>>>>>>>>>>>>>>>>>/// @Param FieldNumber          Number of the field being written to
79085>>>>>>>>>>>>>>>>>///
79085>>>>>>>>>>>>>>>>>/// @Example
79085>>>>>>>>>>>>>>>>>/// Clear Customer
79085>>>>>>>>>>>>>>>>>/// Find Gt Customer By Index.1
79085>>>>>>>>>>>>>>>>>///
79085>>>>>>>>>>>>>>>>>/// Direct_Input 'C:\Mertech.xml'
79085>>>>>>>>>>>>>>>>>/// Lock
79085>>>>>>>>>>>>>>>>>///    Find Eq Customer by Recnum
79085>>>>>>>>>>>>>>>>>///
79085>>>>>>>>>>>>>>>>>///    Read_Block Customer.Comments 16384
79085>>>>>>>>>>>>>>>>>///    SQL_LOB_WRITE of Customer 13 // Customer.Comments
79085>>>>>>>>>>>>>>>>>///    Repeat
79085>>>>>>>>>>>>>>>>>///        Read_Block Customer.Comments 16384
79085>>>>>>>>>>>>>>>>>///        SQL_LOB_APPEND of Customer 13 // Customer.Comments
79085>>>>>>>>>>>>>>>>>///    Until (SeqEOF)
79085>>>>>>>>>>>>>>>>>/// Unlock
79085>>>>>>>>>>>>>>>>>/// Close_Input
79085>>>>>>>>>>>>>>>>>///
79085>>>>>>>>>>>>>>>>>/// Find Eq Customer By Recnum
79085>>>>>>>>>>>>>>>>>/// SQL_LOB_LENGTH of Customer 13 to iLength
79085>>>>>>>>>>>>>>>>>/// Showln 'Length: ' iLength
79085>>>>>>>>>>>>>>>>>
79085>>>>>>>>>>>>>>>>>
79085>>>>>>>>>>>>>>>>>//=============================================================================
79085>>>>>>>>>>>>>>>>>/// @Name        LOB_LOADFROMFILE
79085>>>>>>>>>>>>>>>>>/// @Description This command loads an external file into a specified LOB
79085>>>>>>>>>>>>>>>>>/// column. After specifying the file name and field number, the path and
79085>>>>>>>>>>>>>>>>>/// file must then be passed respectively. When using Oracle, instead of
79085>>>>>>>>>>>>>>>>>/// passing the directory, a directory alias must be passed. This alias
79085>>>>>>>>>>>>>>>>>/// can be created using a "CREATE DIRECTORY" statement in SQL. For more
79085>>>>>>>>>>>>>>>>>/// information on setting this directory alias, see the Oracle help.
79085>>>>>>>>>>>>>>>>>/// For other servers, the file must be a local file available to the
79085>>>>>>>>>>>>>>>>>/// application that is calling the command. Note that this command must
79085>>>>>>>>>>>>>>>>>/// write to a file that is active and locked. Also this command handles
79085>>>>>>>>>>>>>>>>>/// the save so no extra calls are needed to save the changes.
79085>>>>>>>>>>>>>>>>>///
79085>>>>>>>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
79085>>>>>>>>>>>>>>>>>/// @Status      Deprecated
79085>>>>>>>>>>>>>>>>>/// @Drivers     All
79085>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
79085>>>>>>>>>>>>>>>>>/// @See                 LOB_APPEND LOB_LENGTH LOB_WRITE LOB_READ LOB_ERASE LOB_TRUNCATE FLUSH_LOB_BUFFER
79085>>>>>>>>>>>>>>>>>///
79085>>>>>>>>>>>>>>>>>/// @Syntax LOB_LOADFROMFILE of {FileName} {FieldNumber} From {path} {file}
79085>>>>>>>>>>>>>>>>>/// @Param FileName                     Name of the file containing the LOB column
79085>>>>>>>>>>>>>>>>>/// @Param FieldNumber          Number of the LOB column being used
79085>>>>>>>>>>>>>>>>>/// @Param path                         The path of the file, excluding the file name
79085>>>>>>>>>>>>>>>>>/// @Param file                         The name of the file, including the extension
79085>>>>>>>>>>>>>>>>>///
79085>>>>>>>>>>>>>>>>>/// @Example
79085>>>>>>>>>>>>>>>>>/// Clear Customer
79085>>>>>>>>>>>>>>>>>/// Find Gt Customer By Index.1
79085>>>>>>>>>>>>>>>>>/// Lock
79085>>>>>>>>>>>>>>>>>///    Find Eq Customer by Recnum
79085>>>>>>>>>>>>>>>>>///    LOB_TRUNCATE OF customel 13 to 0 // Customer.Comments
79085>>>>>>>>>>>>>>>>>///    Saverecord Customer
79085>>>>>>>>>>>>>>>>>///    // Directory name is case sensitive.
79085>>>>>>>>>>>>>>>>>///    // Make sure the name case matches
79085>>>>>>>>>>>>>>>>>///    LOB_LOADFROMFILE OF customel 13 FROM "C:\Mertech\FilesToLoad" "Mertech.XML"
79085>>>>>>>>>>>>>>>>>/// Unlock
79085>>>>>>>>>>>>>>>>>
79085>>>>>>>>>>>>>>>>>
79085>>>>>>>>>>>>>>>>>//=============================================================================
79085>>>>>>>>>>>>>>>>>/// @Name        LOB_ERASE
79085>>>>>>>>>>>>>>>>>/// @Description This command is used to erase a portion of data from a
79085>>>>>>>>>>>>>>>>>/// LOB column. For text fields, the portion of data to be erased is
79085>>>>>>>>>>>>>>>>>/// replaced with white space, and in binary fields, with 0X0. To erase
79085>>>>>>>>>>>>>>>>>/// a portion of the data, pass the length to erase as well as the number
79085>>>>>>>>>>>>>>>>>/// to offset from. For this command to work properly, it must be done
79085>>>>>>>>>>>>>>>>>/// after a valid find. Note that the save is handled inside this command
79085>>>>>>>>>>>>>>>>>/// so no extra commands are needed to save the changes.
79085>>>>>>>>>>>>>>>>>///
79085>>>>>>>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
79085>>>>>>>>>>>>>>>>>/// @Status      Deprecated
79085>>>>>>>>>>>>>>>>>/// @Drivers     All
79085>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
79085>>>>>>>>>>>>>>>>>/// @See LOB_APPEND LOB_LENGTH LOB_WRITE LOB_READ LOB_LOADFROMFILE LOB_ERASE LOB_TRUNCATE FLUSH_LOB_BUFFER
79085>>>>>>>>>>>>>>>>>///
79085>>>>>>>>>>>>>>>>>/// @Syntax LOB_ERASE OF {FileName} {FieldNumber} {length} {offset}
79085>>>>>>>>>>>>>>>>>/// @Param FileName                     Name of the file containing the LOB column
79085>>>>>>>>>>>>>>>>>/// @Param FieldNumber          Number of the LOB column being erased
79085>>>>>>>>>>>>>>>>>/// @Param Length                       Length of chunk to erase from column
79085>>>>>>>>>>>>>>>>>/// @Param offset                       Starting position for erase
79085>>>>>>>>>>>>>>>>>///
79085>>>>>>>>>>>>>>>>>/// @Example
79085>>>>>>>>>>>>>>>>>/// Clear customer
79085>>>>>>>>>>>>>>>>>/// Find Gt customer by Recnum
79085>>>>>>>>>>>>>>>>>/// Lock
79085>>>>>>>>>>>>>>>>>/// Find Eq customer by Recnum
79085>>>>>>>>>>>>>>>>>/// LOB_LENGTH OF customer 13 to liTotalLength
79085>>>>>>>>>>>>>>>>>/// LOB_ERASE  OF customer 13    liTotalLength 1
79085>>>>>>>>>>>>>>>>>/// Unlock
79085>>>>>>>>>>>>>>>>>
79085>>>>>>>>>>>>>>>>>
79085>>>>>>>>>>>>>>>>>//=============================================================================
79085>>>>>>>>>>>>>>>>>/// @Name        LOB_TRUNCATE
79085>>>>>>>>>>>>>>>>>/// @Description This command is used to trim a LOB column down to a
79085>>>>>>>>>>>>>>>>>/// specified length. By passing the table name and column number, the
79085>>>>>>>>>>>>>>>>>/// value in the column can then be trimmed down the specified length.
79085>>>>>>>>>>>>>>>>>/// This can be a useful command for clearing out a column before entering
79085>>>>>>>>>>>>>>>>>/// new data into it. Note that this command must write to a file that is active
79085>>>>>>>>>>>>>>>>>/// and locked. Also this command handles the save so no extra calls
79085>>>>>>>>>>>>>>>>>/// are needed to save the changes. This command can be used to clear out a field before adding new data
79085>>>>>>>>>>>>>>>>>///
79085>>>>>>>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
79085>>>>>>>>>>>>>>>>>/// @Status      Deprecated
79085>>>>>>>>>>>>>>>>>/// @Drivers     All
79085>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
79085>>>>>>>>>>>>>>>>>/// @See                 LOB_APPEND LOB_LENGTH LOB_WRITE LOB_READ LOB_LOADFROMFILE LOB_ERASE FLUSH_LOB_BUFFER
79085>>>>>>>>>>>>>>>>>///
79085>>>>>>>>>>>>>>>>>/// @Syntax LOB_TRUNCATE of {FileName} {FieldNumber} to {variable}
79085>>>>>>>>>>>>>>>>>/// @Param FileName                     Name of the file
79085>>>>>>>>>>>>>>>>>/// @Param FieldNumber          The field number
79085>>>>>>>>>>>>>>>>>/// @Param length                       New length to truncate to
79085>>>>>>>>>>>>>>>>>///
79085>>>>>>>>>>>>>>>>>/// @Example
79085>>>>>>>>>>>>>>>>>/// Clear Customer
79085>>>>>>>>>>>>>>>>>/// Find Gt Customer By Index.1
79085>>>>>>>>>>>>>>>>>/// Lock
79085>>>>>>>>>>>>>>>>>///    Find Eq Customer by Recnum
79085>>>>>>>>>>>>>>>>>///    SQL_LOB_TRUNCATE of Customer 13 to 0 // Customer.Comments
79085>>>>>>>>>>>>>>>>>///    Saverecord Customer
79085>>>>>>>>>>>>>>>>>/// Unlock
79085>>>>>>>>>>>>>>>>>
79085>>>>>>>>>>>>>>>>>
79085>>>>>>>>>>>>>>>>>//=============================================================================
79085>>>>>>>>>>>>>>>>>/// @Name        FLUSH_LOB_BUFFER
79085>>>>>>>>>>>>>>>>>/// @Description This command currently serves no function.
79085>>>>>>>>>>>>>>>>>///
79085>>>>>>>>>>>>>>>>>/// @Assumptions
79085>>>>>>>>>>>>>>>>>/// @Status      Deprecated
79085>>>>>>>>>>>>>>>>>/// @Drivers     MySQLFlex
79085>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
79085>>>>>>>>>>>>>>>>>/// @See
79085>>>>>>>>>>>>>>>>>///
79085>>>>>>>>>>>>>>>>>/// @Syntax FLUSH_LOB_BUFFER of {FileName}
79085>>>>>>>>>>>>>>>>>/// @Param FileName                     Name of the file
79085>>>>>>>>>>>>>>>>>
79085>>>>>>>>>>>>>>>>>
79085>>>>>>>>>>>>>>>>>//=============================================================================
79085>>>>>>>>>>>>>>>>>/// @Name        SQL_ENABLE_RECONNECT
79085>>>>>>>>>>>>>>>>>/// @Description Allow MySql Driver to auto reconnect after a time-out.
79085>>>>>>>>>>>>>>>>>///
79085>>>>>>>>>>>>>>>>>/// Driver auto-reconnect feature handles the issue where MySQL
79085>>>>>>>>>>>>>>>>>/// will kick off a user after inactivity.
79085>>>>>>>>>>>>>>>>>///
79085>>>>>>>>>>>>>>>>>/// @Status      Deprecated
79085>>>>>>>>>>>>>>>>>/// @Drivers     MySQL
79085>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-09-11 By Ian Smith
79085>>>>>>>>>>>>>>>>>///
79085>>>>>>>>>>>>>>>>>/// @Syntax SQL_ENABLE_RECONNECT of <ServerName> to dftrue/dffalse
79085>>>>>>>>>>>>>>>>>/// @Param ServerName  Server Name.
79085>>>>>>>>>>>>>>>>>///
79085>>>>>>>>>>>>>>>>>/// @Usage SQL_ENABLE_RECONNECT Of sServerID To dftrue
79085>>>>>>>>>>>>>>>>>
79085>>>>>>>>>>>>>>>>>//=============================================================================
79085>>>>>>>>>>>>>>>>>/// @Name        CALL_MYSQL_STORED_PROCEDURE
79085>>>>>>>>>>>>>>>>>/// @Description This command is used to call a stored procedure on the SQL
79085>>>>>>>>>>>>>>>>>/// backend. To successfully call a procedure with this command, a string
79085>>>>>>>>>>>>>>>>>/// must be passed containing a valid procedure name. In addition, if the
79085>>>>>>>>>>>>>>>>>/// procedure takes any arguments, they must also be passed using the constant
79085>>>>>>>>>>>>>>>>>/// "passing" along with all of the needed arguments. If the procedure has a
79085>>>>>>>>>>>>>>>>>/// return value, then SQL_GET_FUNCTION_RETURN or SQL_FETCH_NEXT_ROW can be
79085>>>>>>>>>>>>>>>>>/// used to get the value(s). If an error is found then the indicator "Err"
79085>>>>>>>>>>>>>>>>>/// is set to true.
79085>>>>>>>>>>>>>>>>>///
79085>>>>>>>>>>>>>>>>>/// @Assumptions
79085>>>>>>>>>>>>>>>>>/// @Status      Deprecated
79085>>>>>>>>>>>>>>>>>/// @Drivers     MySQLFlex
79085>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
79085>>>>>>>>>>>>>>>>>/// @See                 CALL_STORED_PROCEDURE
79085>>>>>>>>>>>>>>>>>///
79085>>>>>>>>>>>>>>>>>/// @Syntax CALL_MYSQL_STORED_PROCEDURE {procedure} Passing {argument}
79085>>>>>>>>>>>>>>>>>/// @Param procedure            Full name of the procedure
79085>>>>>>>>>>>>>>>>>/// @Param argument                     Argument to pass (can be multiple)
79085>>>>>>>>>>>>>>>>>///
79085>>>>>>>>>>>>>>>>>/// @Example
79085>>>>>>>>>>>>>>>>>/// CALL_MYSQL_STORED_PROCEDURE "getCustomerStatus" passing sCustomerID sStatus
79085>>>>>>>>>>>>>>>>>/// SQL_GET_PROCEDURE_PARAMETER 2 to sStatus
79085>>>>>>>>>>>>>>>>>/// Showln sStatus
79085>>>>>>>>>>>>>>>>>
79085>>>>>>>>>>>>>>>>>//=============================================================================
79085>>>>>>>>>>>>>>>>>/// @Name        CALL_MYSQL_STORED_FUNCTION
79085>>>>>>>>>>>>>>>>>/// @Description This command is used to execute a function stored in MySQL.
79085>>>>>>>>>>>>>>>>>/// This is an alternative to building a function with the SQL_SET_FUNCTION_NAME,
79085>>>>>>>>>>>>>>>>>/// SQL_SET_FUNCTION_PARAMETER and SQL_FUNCTION_EXECUTE commands. This command
79085>>>>>>>>>>>>>>>>>/// builds and executes the function by setting the full function name, the
79085>>>>>>>>>>>>>>>>>/// parameter(s) to pass and the variable to hold the returned value. Note that
79085>>>>>>>>>>>>>>>>>/// this command can only return a single value so SQL_SET_FUNCTION_PARAMETER
79085>>>>>>>>>>>>>>>>>/// and SQL_SET_FUNCTION_NAME must be used when dealing with multiple return
79085>>>>>>>>>>>>>>>>>/// values.
79085>>>>>>>>>>>>>>>>>///
79085>>>>>>>>>>>>>>>>>/// @Status      Deprecated
79085>>>>>>>>>>>>>>>>>/// @Drivers     MySQLFlex
79085>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
79085>>>>>>>>>>>>>>>>>/// @See                 CALL_STORED_FUNCTION
79085>>>>>>>>>>>>>>>>>///
79085>>>>>>>>>>>>>>>>>/// @Syntax CALL_MYSQL_STORED_FUNCTION {function} Returns {variable} Passing {argument}
79085>>>>>>>>>>>>>>>>>/// @Param function                     Full name of the function
79085>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the returned value
79085>>>>>>>>>>>>>>>>>/// @Param argument                     Argument to pass (can be multiple)
79085>>>>>>>>>>>>>>>>>///
79085>>>>>>>>>>>>>>>>>/// @Example
79085>>>>>>>>>>>>>>>>>/// CALL_MYSQL_STORED_FUNCTION "getCustomerStatus" Returns sStatus passing sCustomerID
79085>>>>>>>>>>>>>>>>>/// Showln sStatus
79085>>>>>>>>>>>>>>>>>
79085>>>>>>>>>>>>>>>>>//=============================================================================
79085>>>>>>>>>>>>>>>>>/// @Name        DO_SET_ALL_FUNCTION_PARAMETERS
79085>>>>>>>>>>>>>>>>>/// @Description Sets the parameters for a MySQL stored function call.
79085>>>>>>>>>>>>>>>>>///
79085>>>>>>>>>>>>>>>>>/// @Assumptions
79085>>>>>>>>>>>>>>>>>/// @Status      Internal
79085>>>>>>>>>>>>>>>>>/// @Drivers     MySQLFlex
79085>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-09-21 By Ian Smith
79085>>>>>>>>>>>>>>>>>/// @See
79085>>>>>>>>>>>>>>>>>///
79085>>>>>>>>>>>>>>>>>/// @Syntax DO_SET_ALL_FUNCTION_PARAMETERS [sParam1 [sParam2 . sParamn]]
79085>>>>>>>>>>>>>>>>>/// @Param sParam1.n    Parameters for the stored function
79085>>>>>>>>>>>>>>>>>
79085>>>>>>>>>>>>>>>>>//=============================================================================
79085>>>>>>>>>>>>>>>>>/// @Name        GET_NO_AVAILABLE_SQLSERVERS
79085>>>>>>>>>>>>>>>>>/// @Description This command is used to get the number of available MSSQL
79085>>>>>>>>>>>>>>>>>/// servers detected in the network. When used with GET_SQLSERVER_NAME,
79085>>>>>>>>>>>>>>>>>/// all the available server names can be easily retrieved.
79085>>>>>>>>>>>>>>>>>///
79085>>>>>>>>>>>>>>>>>/// @Assumptions SQL Server Browser Service is started and firewall is configured properly
79085>>>>>>>>>>>>>>>>>/// @Status      Public
79085>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex
79085>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
79085>>>>>>>>>>>>>>>>>/// @See                 GET_SQLSERVER_NAME
79085>>>>>>>>>>>>>>>>>///
79085>>>>>>>>>>>>>>>>>/// @Syntax GET_NO_AVAILABLE_SQLSERVERS to {variable}
79085>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold number of servers
79085>>>>>>>>>>>>>>>>>///
79085>>>>>>>>>>>>>>>>>/// @Example
79085>>>>>>>>>>>>>>>>>/// GET_NO_AVAILABLE_SQLSERVERS to iServers
79085>>>>>>>>>>>>>>>>>///
79085>>>>>>>>>>>>>>>>>/// While (i <= iServers)
79085>>>>>>>>>>>>>>>>>///     GET_SQLSERVER_NAME i to sServer
79085>>>>>>>>>>>>>>>>>///     Showln sServer
79085>>>>>>>>>>>>>>>>>///     Increment i
79085>>>>>>>>>>>>>>>>>/// Loop
79085>>>>>>>>>>>>>>>>>
79085>>>>>>>>>>>>>>>>>Function SQL_AVAILABLE_SQL_SERVERS Global Returns Integer
79087>>>>>>>>>>>>>>>>>    Call_Driver 0 SQLFLEX Function CALLDRV_ENUMERATE_SERVER CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank CALLDRV_ENUMERATE_SERVER_COUNT RESULT MertechInc_iRet
79092>>>>>>>>>>>>>>>>>
79092>>>>>>>>>>>>>>>>>    Function_Return MertechInc_iRet
79093>>>>>>>>>>>>>>>>>End_Function
79094>>>>>>>>>>>>>>>>>
79094>>>>>>>>>>>>>>>>>
79094>>>>>>>>>>>>>>>>>//=============================================================================
79094>>>>>>>>>>>>>>>>>/// @Name        GET_SQLSERVER_NAME
79094>>>>>>>>>>>>>>>>>/// @Description This command returns the name of the server based on the
79094>>>>>>>>>>>>>>>>>/// specified index number. The number of servers can be retrieved from
79094>>>>>>>>>>>>>>>>>/// GET_NO_AVAILABLE_SQLSERVERS and the names can be indexed from that
79094>>>>>>>>>>>>>>>>>/// number.
79094>>>>>>>>>>>>>>>>>///
79094>>>>>>>>>>>>>>>>>/// @Assumptions SQL Server Browser Service is started and firewall is configured properly
79094>>>>>>>>>>>>>>>>>/// @Status      Public
79094>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex
79094>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
79094>>>>>>>>>>>>>>>>>/// @See                 GET_NO_AVAILABLE_SQLSERVERS
79094>>>>>>>>>>>>>>>>>///
79094>>>>>>>>>>>>>>>>>/// @Syntax SQL_AVAILABLE_SQL_SERVER_NAME {index} to {variable}
79094>>>>>>>>>>>>>>>>>/// @Param index                The numbered index name to retrieve
79094>>>>>>>>>>>>>>>>>/// @Param variable             Variable to hold the server name
79094>>>>>>>>>>>>>>>>>///
79094>>>>>>>>>>>>>>>>>/// @Example
79094>>>>>>>>>>>>>>>>>/// GET_NO_AVAILABLE_SQLSERVERS to iServers
79094>>>>>>>>>>>>>>>>>///
79094>>>>>>>>>>>>>>>>>/// While (i <= iServers)
79094>>>>>>>>>>>>>>>>>///     GET_SQLSERVER_NAME i to sServer
79094>>>>>>>>>>>>>>>>>///     Showln sServer
79094>>>>>>>>>>>>>>>>>///     Increment i
79094>>>>>>>>>>>>>>>>>/// Loop
79094>>>>>>>>>>>>>>>>>
79094>>>>>>>>>>>>>>>>>Function SQL_AVAILABLE_SQL_SERVER_NAME Global Integer iIndex Returns String
79096>>>>>>>>>>>>>>>>>    String sName
79096>>>>>>>>>>>>>>>>>
79096>>>>>>>>>>>>>>>>>    Get MertechInc_Pre_Size_String 80 to sName
79097>>>>>>>>>>>>>>>>>    Call_Driver 0 SQLFLEX Function CALLDRV_ENUMERATE_SERVER CALLBACK 0 PASSING sName iIndex CALLDRV_ENUMERATE_SERVER_SERVER RESULT MertechInc_iRet
79102>>>>>>>>>>>>>>>>>
79102>>>>>>>>>>>>>>>>>    Function_Return sName
79103>>>>>>>>>>>>>>>>>End_Function
79104>>>>>>>>>>>>>>>>>
79104>>>>>>>>>>>>>>>>>
79104>>>>>>>>>>>>>>>>>//=============================================================================
79104>>>>>>>>>>>>>>>>>/// @Name        SET_USE_ROWCOUNT_IN_TRANSACTION
79104>>>>>>>>>>>>>>>>>/// @Description Turn on / off Row_Count for specified server.
79104>>>>>>>>>>>>>>>>>/// @Status      Deprecated
79104>>>>>>>>>>>>>>>>>/// @Drivers     All
79104>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-09-21 By Ian Smith
79104>>>>>>>>>>>>>>>>>///
79104>>>>>>>>>>>>>>>>>/// @Syntax SET_USE_ROWCOUNT_IN_TRANSACTION OF <Server> To <State>
79104>>>>>>>>>>>>>>>>>/// @Param Server      Name of server to turn On / Off Row_Count
79104>>>>>>>>>>>>>>>>>/// @Param State       TRUE = turn on Row_Count  FALSE = turn off Row_Count
79104>>>>>>>>>>>>>>>>>///
79104>>>>>>>>>>>>>>>>>/// @Comment This SHOULD ALWAYS BE TURNED ON
79104>>>>>>>>>>>>>>>>>
79104>>>>>>>>>>>>>>>>>Procedure Set SQL_USE_ROWCOUNT_IN_TRANSACTIONS Global String sServer Integer iState
79106>>>>>>>>>>>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
79132>>>>>>>>>>>>>>>>>>
79132>>>>>>>>>>>>>>>>>
79132>>>>>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_USE_ROWCOUNT_IN_TRANSACTIONS CALLBACK 0 PASSING sServer iState CALLDRV_VALUE_SET RESULT MertechInc_iRet
79137>>>>>>>>>>>>>>>>>    If MertechInc_iRet EQ -1 INDICATE ERR True
79140>>>>>>>>>>>>>>>>>End_Procedure
79141>>>>>>>>>>>>>>>>>
79141>>>>>>>>>>>>>>>>>//IGS - commented out by a.n. Other
79141>>>>>>>>>>>>>>>>>//#REPLACE UseRowCountInTransactions SQL_USE_ROWCOUNT_IN_TRANSACTIONS
79141>>>>>>>>>>>>>>>>>
79141>>>>>>>>>>>>>>>>>//=============================================================================
79141>>>>>>>>>>>>>>>>>/// @Name        GET_USE_ROWCOUNT_IN_TRANSACTION
79141>>>>>>>>>>>>>>>>>/// @Description Gets the Row_Count setting for specified server.
79141>>>>>>>>>>>>>>>>>/// @Status      Deprecated
79141>>>>>>>>>>>>>>>>>/// @Drivers     All
79141>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-09-21 By Ian Smith
79141>>>>>>>>>>>>>>>>>///
79141>>>>>>>>>>>>>>>>>/// @Syntax GET_USE_ROWCOUNT_IN_TRANSACTION OF <Server> To <State>
79141>>>>>>>>>>>>>>>>>/// @Param Server      Name of server to get Row_Count state of
79141>>>>>>>>>>>>>>>>>/// @Param State       Variable to hold returned value
79141>>>>>>>>>>>>>>>>>
79141>>>>>>>>>>>>>>>>>Function SQL_USE_ROWCOUNT_IN_TRANSACTIONS Global String sServer Returns Integer
79143>>>>>>>>>>>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
79169>>>>>>>>>>>>>>>>>>
79169>>>>>>>>>>>>>>>>>
79169>>>>>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_USE_ROWCOUNT_IN_TRANSACTIONS CALLBACK 0 PASSING sServer MertechInc_Blank CALLDRV_VALUE_GET RESULT MertechInc_iRet
79174>>>>>>>>>>>>>>>>>
79174>>>>>>>>>>>>>>>>>    Function_Return MertechInc_iRet
79175>>>>>>>>>>>>>>>>>End_Function
79176>>>>>>>>>>>>>>>>>
79176>>>>>>>>>>>>>>>>>
79176>>>>>>>>>>>>>>>>>//=============================================================================
79176>>>>>>>>>>>>>>>>>/// @Name        SQL_SET_DATE_FORMAT
79176>>>>>>>>>>>>>>>>>/// @Description This command controls the date format of data returned
79176>>>>>>>>>>>>>>>>>/// through embedded SQL. If set to DATAFLEX, then the dates will be
79176>>>>>>>>>>>>>>>>>/// returned in whatever format is set in DF_DATE_FORMAT. When set to
79176>>>>>>>>>>>>>>>>>/// NATIVE, this command will force dates to return dates in the format
79176>>>>>>>>>>>>>>>>>/// specified on the SQL server. Note that in order for the variables to
79176>>>>>>>>>>>>>>>>>/// be in the right form, they need to be string variables.
79176>>>>>>>>>>>>>>>>>///
79176>>>>>>>>>>>>>>>>>/// @Assumptions
79176>>>>>>>>>>>>>>>>>/// @Status      Public
79176>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex
79176>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
79176>>>>>>>>>>>>>>>>>/// @See
79176>>>>>>>>>>>>>>>>>///
79176>>>>>>>>>>>>>>>>>/// @Syntax SQL_SET_DATE_FORMAT to {DATAFLEX/NATIVE}
79176>>>>>>>>>>>>>>>>>///
79176>>>>>>>>>>>>>>>>>/// @Example
79176>>>>>>>>>>>>>>>>>/// SQL_SET_DATE_FORMAT to NATIVE
79176>>>>>>>>>>>>>>>>>
79176>>>>>>>>>>>>>>>>>Procedure Set SQL_USE_DATAFLEX_DATEFORMAT Global Integer iState
79178>>>>>>>>>>>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
79204>>>>>>>>>>>>>>>>>>
79204>>>>>>>>>>>>>>>>>
79204>>>>>>>>>>>>>>>>>    If MertechInc_DriverName eq SQLFlex Begin
79206>>>>>>>>>>>>>>>>>        Call_Driver 0 MertechInc_DriverName Function CALLDRV_USE_DFLEX_DATE_FORMAT CALLBACK 0 PASSING iState MertechInc_Blank CALLDRV_VALUE_SET RESULT MertechInc_iRet
79211>>>>>>>>>>>>>>>>>        IF MertechInc_iRet EQ -1 INDICATE ERR TRUE
79214>>>>>>>>>>>>>>>>>    End
79214>>>>>>>>>>>>>>>>>>
79214>>>>>>>>>>>>>>>>>End_Procedure
79215>>>>>>>>>>>>>>>>>
79215>>>>>>>>>>>>>>>>>Function SQL_USE_DATAFLEX_DATEFORMAT Global Returns Integer
79217>>>>>>>>>>>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
79243>>>>>>>>>>>>>>>>>>
79243>>>>>>>>>>>>>>>>>
79243>>>>>>>>>>>>>>>>>    If MertechInc_DriverName eq SQLFlex Begin
79245>>>>>>>>>>>>>>>>>        CALL_DRIVER 0 MertechInc_DriverName FUNCTION CALLDRV_USE_DFLEX_DATE_FORMAT CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank CALLDRV_VALUE_GET RESULT MertechInc_iRet
79250>>>>>>>>>>>>>>>>>    End
79250>>>>>>>>>>>>>>>>>>
79250>>>>>>>>>>>>>>>>>    Else Move DFFALSE to MertechInc_iRet
79252>>>>>>>>>>>>>>>>>
79252>>>>>>>>>>>>>>>>>    function_return MertechInc_iRet
79253>>>>>>>>>>>>>>>>>End_Function
79254>>>>>>>>>>>>>>>>>
79254>>>>>>>>>>>>>>>>>
79254>>>>>>>>>>>>>>>>>//=============================================================================
79254>>>>>>>>>>>>>>>>>/// @Name        SET_FIELDS_NOT_NULL
79254>>>>>>>>>>>>>>>>>/// @Description This command is used to specify how to handle blank
79254>>>>>>>>>>>>>>>>>/// and zero values on the SQL backend. Since blank or zero values can
79254>>>>>>>>>>>>>>>>>/// often be stored as null in the server database, this command allows
79254>>>>>>>>>>>>>>>>>/// that to be altered if needed. When set to true, a value will be
79254>>>>>>>>>>>>>>>>>/// inserted into blank records to keep them from being null. See the
79254>>>>>>>>>>>>>>>>>/// list below for what value will be stored instead of null. If set to
79254>>>>>>>>>>>>>>>>>/// false, values will be stored normally in the database. Note that this
79254>>>>>>>>>>>>>>>>>/// command effects all data types.
79254>>>>>>>>>>>>>>>>>///
79254>>>>>>>>>>>>>>>>>/// DF_ASCII and DF_TEXT -              ' ' (one blank space)
79254>>>>>>>>>>>>>>>>>///
79254>>>>>>>>>>>>>>>>>/// DF_BCD -                                    0 (zero)
79254>>>>>>>>>>>>>>>>>///
79254>>>>>>>>>>>>>>>>>/// DF_DATe and DF_DATETIME -   00/00/0000 for MYSQL
79254>>>>>>>>>>>>>>>>>///                                                             01/01/0001 for Oracle MSSQL, and Postgre
79254>>>>>>>>>>>>>>>>>///                                                             01/01/1753 for MSSQL Datetimes
79254>>>>>>>>>>>>>>>>>///
79254>>>>>>>>>>>>>>>>>/// DF_BINARY -                                 0X0
79254>>>>>>>>>>>>>>>>>///
79254>>>>>>>>>>>>>>>>>/// @Assumptions
79254>>>>>>>>>>>>>>>>>/// @Status      Public
79254>>>>>>>>>>>>>>>>>/// @Drivers     All
79254>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
79254>>>>>>>>>>>>>>>>>/// @See                 SET_FIELDS_NULL GET_FIELDS_NULL
79254>>>>>>>>>>>>>>>>>///
79254>>>>>>>>>>>>>>>>>/// @Syntax SET_FIELDS_NOT_NULL to {variable}
79254>>>>>>>>>>>>>>>>>/// @Param variable             Boolean variable to indicate how to handle null values
79254>>>>>>>>>>>>>>>>>///
79254>>>>>>>>>>>>>>>>>
79254>>>>>>>>>>>>>>>>>Procedure Set SQL_FORCE_FIELDS_NOT_NULL Global Integer iState
79256>>>>>>>>>>>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
79282>>>>>>>>>>>>>>>>>>
79282>>>>>>>>>>>>>>>>>
79282>>>>>>>>>>>>>>>>>    If (MertechInc_FileNumber <> -1) Begin
79284>>>>>>>>>>>>>>>>>        Call_Driver 0 MertechInc_DriverName Function CALLDRV_FORCE_FIELDS_NOT_NULL CALLBACK 0 PASSING iState MertechInc_Blank CALLDRV_VALUE_SET RESULT MertechInc_iRet
79289>>>>>>>>>>>>>>>>>        If MertechInc_iRet EQ -1 INDICATE ERR True
79292>>>>>>>>>>>>>>>>>    End
79292>>>>>>>>>>>>>>>>>>
79292>>>>>>>>>>>>>>>>>End_Procedure
79293>>>>>>>>>>>>>>>>>
79293>>>>>>>>>>>>>>>>>
79293>>>>>>>>>>>>>>>>>
79293>>>>>>>>>>>>>>>>>
79293>>>>>>>>>>>>>>>>>Function SQL_FORCE_FIELDS_NOT_NULL Global Returns Integer
79295>>>>>>>>>>>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
79321>>>>>>>>>>>>>>>>>>
79321>>>>>>>>>>>>>>>>>
79321>>>>>>>>>>>>>>>>>    If (MertechInc_FileNumber <> -1) Begin
79323>>>>>>>>>>>>>>>>>        Call_Driver 0 MertechInc_DriverName Function CALLDRV_FORCE_FIELDS_NOT_NULL CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank CALLDRV_VALUE_GET RESULT MertechInc_iRet
79328>>>>>>>>>>>>>>>>>    End
79328>>>>>>>>>>>>>>>>>>
79328>>>>>>>>>>>>>>>>>    Else Move DFFALSE to MertechInc_iRet
79330>>>>>>>>>>>>>>>>>
79330>>>>>>>>>>>>>>>>>    Function_Return MertechInc_iRet
79331>>>>>>>>>>>>>>>>>End_Function
79332>>>>>>>>>>>>>>>>>
79332>>>>>>>>>>>>>>>>>
79332>>>>>>>>>>>>>>>>>//=============================================================================
79332>>>>>>>>>>>>>>>>>/// @Name        SET_FIELDS_NULL
79332>>>>>>>>>>>>>>>>>/// @Description This command is used to specify how to store blank or zero
79332>>>>>>>>>>>>>>>>>/// values in the database. Since database can sometimes store these value,
79332>>>>>>>>>>>>>>>>>/// i.e. '' or 0, as null, using this command can be useful in managing that.
79332>>>>>>>>>>>>>>>>>/// When set to true, any value in a column of the given type considered blank
79332>>>>>>>>>>>>>>>>>/// or 0 will be stored as null in the database. Setting it to false will cause
79332>>>>>>>>>>>>>>>>>/// the server to save as it normally would. Note that this command is used to
79332>>>>>>>>>>>>>>>>>/// set specific data types only, it can not effect all types at once. Below is
79332>>>>>>>>>>>>>>>>>/// a list of value that would be considered blank/zero values.
79332>>>>>>>>>>>>>>>>>///
79332>>>>>>>>>>>>>>>>>/// DF_ASCII and DF_TEXT -              ' ' (one blank space)
79332>>>>>>>>>>>>>>>>>///
79332>>>>>>>>>>>>>>>>>/// DF_BCD -                                    0 (zero)
79332>>>>>>>>>>>>>>>>>///
79332>>>>>>>>>>>>>>>>>/// DF_DATe and DF_DATETIME -   00/00/0000 for MYSQL
79332>>>>>>>>>>>>>>>>>///                                                             01/01/0001 for Oracle MSSQL, and Postgre
79332>>>>>>>>>>>>>>>>>///                                                             01/01/1753 for MSSQL Datetimes
79332>>>>>>>>>>>>>>>>>///
79332>>>>>>>>>>>>>>>>>/// DF_BINARY -                                 0X0
79332>>>>>>>>>>>>>>>>>///
79332>>>>>>>>>>>>>>>>>/// @Assumptions
79332>>>>>>>>>>>>>>>>>/// @Status      Public
79332>>>>>>>>>>>>>>>>>/// @Drivers     All
79332>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
79332>>>>>>>>>>>>>>>>>/// @See                 GET_FIELDS_NULL SET_FIELDS_NOT_NULL
79332>>>>>>>>>>>>>>>>>///
79332>>>>>>>>>>>>>>>>>/// @Syntax SET_FIELDS_NULL {datatype} to {variable}
79332>>>>>>>>>>>>>>>>>/// @Param datatype                     DF_ASCII, DF_BCD, or DF_DATE
79332>>>>>>>>>>>>>>>>>/// @Param variable             Boolean to indicate how to handle blank data
79332>>>>>>>>>>>>>>>>>
79332>>>>>>>>>>>>>>>>>
79332>>>>>>>>>>>>>>>>>//=============================================================================
79332>>>>>>>>>>>>>>>>>/// @Name        GET_FIELDS_NULL
79332>>>>>>>>>>>>>>>>>/// @Description This command will return the value of SET_FIELDS_NULL for
79332>>>>>>>>>>>>>>>>>/// the specified data type.
79332>>>>>>>>>>>>>>>>>///
79332>>>>>>>>>>>>>>>>>/// @Assumptions
79332>>>>>>>>>>>>>>>>>/// @Status      Public
79332>>>>>>>>>>>>>>>>>/// @Drivers     All
79332>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
79332>>>>>>>>>>>>>>>>>/// @See                 SET_FIELDS_NULL SET_FIELDS_NOT_NULL
79332>>>>>>>>>>>>>>>>>///
79332>>>>>>>>>>>>>>>>>/// @Syntax GET_FIELDS_NULL {datatype} to {variable}
79332>>>>>>>>>>>>>>>>>/// @Param datatype                     DF_ASCII, DF_BCD, or DF_DATE
79332>>>>>>>>>>>>>>>>>/// @Param variable             Variable to hold the value of SET_FIELDS_NULL
79332>>>>>>>>>>>>>>>>>
79332>>>>>>>>>>>>>>>>>
79332>>>>>>>>>>>>>>>>>//=============================================================================
79332>>>>>>>>>>>>>>>>>/// @Name        STRUCTURE_START_DYNAMIC
79332>>>>>>>>>>>>>>>>>/// @Description This command is used when scripting structural changes.
79332>>>>>>>>>>>>>>>>>/// It is the same as using ENABLE_SCRIPTING and Structure_Start separately.
79332>>>>>>>>>>>>>>>>>/// It allows structural changes to be compiled and tested without
79332>>>>>>>>>>>>>>>>>/// actually making any of the changes. Any table restructuring done
79332>>>>>>>>>>>>>>>>>/// between this command and STRUCTURE_END_DYNAMIC will not actually be
79332>>>>>>>>>>>>>>>>>/// committed but will instead create a mock INT file. The script and
79332>>>>>>>>>>>>>>>>>/// INT file can then be retrieved and examined for testing purposes.
79332>>>>>>>>>>>>>>>>>///
79332>>>>>>>>>>>>>>>>>/// @Assumptions
79332>>>>>>>>>>>>>>>>>/// @Status      Deprecated
79332>>>>>>>>>>>>>>>>>/// @Drivers     All
79332>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
79332>>>>>>>>>>>>>>>>>/// @See                 ENABLE_SCRIPTING DISABLE_SCRIPTING
79332>>>>>>>>>>>>>>>>>///
79332>>>>>>>>>>>>>>>>>/// @Syntax STRUCTURE_START_DYNAMIC of {FileNumber}
79332>>>>>>>>>>>>>>>>>/// @Param FileNumber                   The number of the file
79332>>>>>>>>>>>>>>>>>
79332>>>>>>>>>>>>>>>>>//=============================================================================
79332>>>>>>>>>>>>>>>>>/// @Name        STRUCTURE_END_DYNAMIC
79332>>>>>>>>>>>>>>>>>/// @Description This command ends the scripting started by
79332>>>>>>>>>>>>>>>>>/// STRUCTURE_START_DYNAMIC. It is the same as calling Structure_End
79332>>>>>>>>>>>>>>>>>/// and DISABLE_SCRIPTING separately.
79332>>>>>>>>>>>>>>>>>///
79332>>>>>>>>>>>>>>>>>/// @Assumptions
79332>>>>>>>>>>>>>>>>>/// @Status      Deprecated
79332>>>>>>>>>>>>>>>>>/// @Drivers     All
79332>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
79332>>>>>>>>>>>>>>>>>/// @See                 ENABLE_SCRIPTING DISABLE_SCRIPTING
79332>>>>>>>>>>>>>>>>>///
79332>>>>>>>>>>>>>>>>>/// @Syntax STRUCTURE_START_DYNAMIC of {FileNumber}
79332>>>>>>>>>>>>>>>>>/// @Param FileNumber                   The number of the file
79332>>>>>>>>>>>>>>>>>
79332>>>>>>>>>>>>>>>>>//=============================================================================
79332>>>>>>>>>>>>>>>>>/// @Name        SQLSERVER_ATTACH_DB
79332>>>>>>>>>>>>>>>>>/// @Description Attachs an MS SQL mdf to the current server instance. If
79332>>>>>>>>>>>>>>>>>/// the passed database is already attached, no error is generated.
79332>>>>>>>>>>>>>>>>>///
79332>>>>>>>>>>>>>>>>>/// The SQLSERVER_ATTACH_DB command is intended for use with our new support
79332>>>>>>>>>>>>>>>>>/// of Microsoft LocalDB's.  When using LocalDB's a common use case might be
79332>>>>>>>>>>>>>>>>>/// to attach to a customer DB, do some work on it, and then detach this DB
79332>>>>>>>>>>>>>>>>>/// and attach to a different DB.  This was possible using stored procedures,
79332>>>>>>>>>>>>>>>>>/// but the code had some complexities that a developer need not worry about.
79332>>>>>>>>>>>>>>>>>/// When you attach a database, you must pass the database name, along with
79332>>>>>>>>>>>>>>>>>/// the path to an MDF file which contains the database.  Any associated LDF's
79332>>>>>>>>>>>>>>>>>/// (log files) and NDF's (secondary data files) must be in the same folder.
79332>>>>>>>>>>>>>>>>>///
79332>>>>>>>>>>>>>>>>>/// If you call SQLSERVER_ATTACH_DB on a database that is already attached,
79332>>>>>>>>>>>>>>>>>/// no error will be generated.  After you call SQLSERVER_ATTACH_DB, you
79332>>>>>>>>>>>>>>>>>/// should call SET_DATABASE_NAME if you wish to make the attached database
79332>>>>>>>>>>>>>>>>>/// the currently selected database.
79332>>>>>>>>>>>>>>>>>///
79332>>>>>>>>>>>>>>>>>/// SQLSERVER_ATTACH_DB will work on all supported version of SQL server.
79332>>>>>>>>>>>>>>>>>///
79332>>>>>>>>>>>>>>>>>/// @Assumptions
79332>>>>>>>>>>>>>>>>>/// @Status      Public
79332>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex
79332>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 Aaron Gulack
79332>>>>>>>>>>>>>>>>>/// @See
79332>>>>>>>>>>>>>>>>>///
79332>>>>>>>>>>>>>>>>>/// @Syntax SQLSERVER_ATTACH_DB {database} on {filePath}
79332>>>>>>>>>>>>>>>>>/// @Param database                     Name of the database
79332>>>>>>>>>>>>>>>>>/// @Param filePath                     Path of the MDF file
79332>>>>>>>>>>>>>>>>>///
79332>>>>>>>>>>>>>>>>>/// @Example
79332>>>>>>>>>>>>>>>>>/// SQLSERVER_ATTACH_DB "MTSample" ON "C:\Mertech\Data\SampleDb.mdf"
79332>>>>>>>>>>>>>>>>>
79332>>>>>>>>>>>>>>>>>//=============================================================================
79332>>>>>>>>>>>>>>>>>/// @Name        SQLSERVER_DETACH_DB
79332>>>>>>>>>>>>>>>>>/// @Description The SQLSERVER_DETACH_DB command is intended for use with our
79332>>>>>>>>>>>>>>>>>/// new support of Microsoft LocalDB's.  When using LocalDB's a common use
79332>>>>>>>>>>>>>>>>>/// case might be to attach to a customer DB, do some work on it, and then
79332>>>>>>>>>>>>>>>>>/// detach this DB and attach to a different DB.  This was possible using
79332>>>>>>>>>>>>>>>>>/// stored procedures, but the code had some complexities that a developer
79332>>>>>>>>>>>>>>>>>/// need not worry about.  A detach can only be done if the database passed
79332>>>>>>>>>>>>>>>>>/// has no open connections.  As part of the detach process, the command
79332>>>>>>>>>>>>>>>>>/// closes ALL open files (even those not associated with this database or
79332>>>>>>>>>>>>>>>>>/// driver).
79332>>>>>>>>>>>>>>>>>///
79332>>>>>>>>>>>>>>>>>/// NOTE: SQLSERVER_DETACH_DB will often fail to execute if you are testing
79332>>>>>>>>>>>>>>>>>/// your application from the studio.  This is because the studio itself
79332>>>>>>>>>>>>>>>>>/// normally has open connections to the database.  If you test your
79332>>>>>>>>>>>>>>>>>/// application outside of the studio and the studio is closed (and any
79332>>>>>>>>>>>>>>>>>/// other application or tools that access this database are closed) you
79332>>>>>>>>>>>>>>>>>/// can successfully detach the database.
79332>>>>>>>>>>>>>>>>>///
79332>>>>>>>>>>>>>>>>>/// @Assumptions
79332>>>>>>>>>>>>>>>>>/// @Status      Public
79332>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex
79332>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
79332>>>>>>>>>>>>>>>>>/// @See
79332>>>>>>>>>>>>>>>>>///
79332>>>>>>>>>>>>>>>>>/// @Syntax SQLSERVER_DETACH_DB {database}
79332>>>>>>>>>>>>>>>>>/// @Param database                     Name of the database
79332>>>>>>>>>>>>>>>>>///
79332>>>>>>>>>>>>>>>>>/// @Example
79332>>>>>>>>>>>>>>>>>/// SQLSERVER_DETACH_DB "TestDB"
79332>>>>>>>>>>>>>>>>>
79332>>>>>>>>>>>>>>>>>//=============================================================================
79332>>>>>>>>>>>>>>>>>/// @Name        SET_FIXED_FILE_RECORDS_USED
79332>>>>>>>>>>>>>>>>>/// @Description This command is used to set DF_FILE_RECORDS_USED to a
79332>>>>>>>>>>>>>>>>>/// fixed value. This can be useful because doing a SELECT COUNT(*) is
79332>>>>>>>>>>>>>>>>>/// a very expensive process to the server. Many applications do counts
79332>>>>>>>>>>>>>>>>>/// often and using this command can help cut down the server traffic.
79332>>>>>>>>>>>>>>>>>/// Sometimes when counts are used, an exact number is not necessary so
79332>>>>>>>>>>>>>>>>>/// a fixed value, updated occasionally can be used. By setting this
79332>>>>>>>>>>>>>>>>>/// command to 0 or greater, the value of DF_FILE_RECORDS_USED will be
79332>>>>>>>>>>>>>>>>>/// set to that specified value and the internal SELECT COUNT(*) will be
79332>>>>>>>>>>>>>>>>>/// suppressed. If this command is set to something less that zero,
79332>>>>>>>>>>>>>>>>>/// DF_FILE_RECORDS_USED will be dynamically calculated whenever it is
79332>>>>>>>>>>>>>>>>>/// called.
79332>>>>>>>>>>>>>>>>>///
79332>>>>>>>>>>>>>>>>>/// The default value for this command is -1
79332>>>>>>>>>>>>>>>>>///
79332>>>>>>>>>>>>>>>>>/// @Assumptions
79332>>>>>>>>>>>>>>>>>/// @Status              Public
79332>>>>>>>>>>>>>>>>>/// @Drivers     All
79332>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
79332>>>>>>>>>>>>>>>>>/// @See                 GET_FIXED_FILE_RECORDS_USED SUPPRESS_SELECT_COUNT UNSUPPRESS_SELECT_COUNT
79332>>>>>>>>>>>>>>>>>///
79332>>>>>>>>>>>>>>>>>/// @Syntax SET_FIXED_FILE_RECORDS_USED to {variable}
79332>>>>>>>>>>>>>>>>>/// @Param variable                     Fixed value for DF_FILE_RECORDS_USED
79332>>>>>>>>>>>>>>>>>///
79332>>>>>>>>>>>>>>>>>/// @Example
79332>>>>>>>>>>>>>>>>>/// SET_FIXED_FILE_RECORDS_USED to 10000
79332>>>>>>>>>>>>>>>>>
79332>>>>>>>>>>>>>>>>>//=============================================================================
79332>>>>>>>>>>>>>>>>>/// @Name        GET_FIXED_FILE_RECORDS_USED
79332>>>>>>>>>>>>>>>>>/// @Description This command returns the value of DF_FILE_RECORDS_USED
79332>>>>>>>>>>>>>>>>>/// if it has been set to a fixed value by SET_FIXED_FILE_RECORDS_USED.
79332>>>>>>>>>>>>>>>>>/// If anything greater than or equal to 0 is returned then that is the
79332>>>>>>>>>>>>>>>>>/// fixed value returned by any SELECT COUNT(*) statements, internal or
79332>>>>>>>>>>>>>>>>>/// not. If something less than zero is returned, then DF_FILE_RECORDS_USED
79332>>>>>>>>>>>>>>>>>/// returns a dynamic count whenever it is called.
79332>>>>>>>>>>>>>>>>>///
79332>>>>>>>>>>>>>>>>>/// By default the value of this is -1
79332>>>>>>>>>>>>>>>>>///
79332>>>>>>>>>>>>>>>>>/// @Assumptions
79332>>>>>>>>>>>>>>>>>/// @Status              Public
79332>>>>>>>>>>>>>>>>>/// @Drivers     All
79332>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
79332>>>>>>>>>>>>>>>>>/// @See                 SET_FIXED_FILE_RECORDS_USED SUPPRESS_SELECT_COUNT UNSUPPRESS_SELECT_COUNT
79332>>>>>>>>>>>>>>>>>///
79332>>>>>>>>>>>>>>>>>/// @Syntax GET_FILE_RECORDS_USED to {variable}
79332>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the fixed value
79332>>>>>>>>>>>>>>>>>///
79332>>>>>>>>>>>>>>>>>/// @Example
79332>>>>>>>>>>>>>>>>>/// GET_FIXED_FILE_RECORDS_USED to iRecords
79332>>>>>>>>>>>>>>>>>
79332>>>>>>>>>>>>>>>>>//=============================================================================
79332>>>>>>>>>>>>>>>>>/// @Name        SUPPRESS_SELECT_COUNT
79332>>>>>>>>>>>>>>>>>/// @Description This command sets the value of DF_FILE_RECORDS_USED to
79332>>>>>>>>>>>>>>>>>/// a fixed value of zero. That way anytime a SELECT COUNT(*) is done,
79332>>>>>>>>>>>>>>>>>/// zero is returned, cutting down on server traffic. This is the same
79332>>>>>>>>>>>>>>>>>/// as setting SET_FIXED_FILE_RECORDS_USED to 0.
79332>>>>>>>>>>>>>>>>>///
79332>>>>>>>>>>>>>>>>>/// @Assumptions
79332>>>>>>>>>>>>>>>>>/// @Status      Public
79332>>>>>>>>>>>>>>>>>/// @Drivers     All
79332>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
79332>>>>>>>>>>>>>>>>>/// @See                 UNSUPPRESS_SELECT_COUNT SET_FIXED_FILE_RECORDS_USED GET_FIXED_FILE_RECORDS_USED
79332>>>>>>>>>>>>>>>>>///
79332>>>>>>>>>>>>>>>>>/// @Syntax SUPPRESS_SELECT_COUNT
79332>>>>>>>>>>>>>>>>>
79332>>>>>>>>>>>>>>>>>//=============================================================================
79332>>>>>>>>>>>>>>>>>/// @Name        UNSUPPRESS_SELECT_COUNT
79332>>>>>>>>>>>>>>>>>/// @Description This command resets the value of DF_FILE_RECORDS_USED to
79332>>>>>>>>>>>>>>>>>/// -1. That way anytime a SELECT COUNT(*) is done, it returns the actual
79332>>>>>>>>>>>>>>>>>/// count of records. This is the same as setting SET_FIXED_FILE_RECORDS_USED
79332>>>>>>>>>>>>>>>>>/// to -1.
79332>>>>>>>>>>>>>>>>>///
79332>>>>>>>>>>>>>>>>>/// @Assumptions
79332>>>>>>>>>>>>>>>>>/// @Status      Public
79332>>>>>>>>>>>>>>>>>/// @Drivers     All
79332>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
79332>>>>>>>>>>>>>>>>>/// @See                 SUPPRESS_SELECT_COUNT SET_FIXED_FILE_RECORDS_USED GET_FIXED_FILE_RECORDS_USED
79332>>>>>>>>>>>>>>>>>///
79332>>>>>>>>>>>>>>>>>/// @Syntax UNSUPPRESS_SELECT_COUNT
79332>>>>>>>>>>>>>>>>>
79332>>>>>>>>>>>>>>>>>//=============================================================================
79332>>>>>>>>>>>>>>>>>/// @Name        SET_CONNECTION_OPTION
79332>>>>>>>>>>>>>>>>>/// @Description This command sets options that are used for the next login call.
79332>>>>>>>>>>>>>>>>>/// Because of this, it should be used after calling load_driver but before
79332>>>>>>>>>>>>>>>>>/// calling Login in most cases. Only options that are not used internally by
79332>>>>>>>>>>>>>>>>>/// the driver can be set using this command. Connection options that CANNOT be
79332>>>>>>>>>>>>>>>>>/// set: Database, Server, FailoverPartner, MarsConn, uid, pwd, Trusted_Connection,
79332>>>>>>>>>>>>>>>>>/// wsid, app, AutoTranslate, Timeout.
79332>>>>>>>>>>>>>>>>>///
79332>>>>>>>>>>>>>>>>>/// @Assumptions
79332>>>>>>>>>>>>>>>>>/// @Status      Public
79332>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex
79332>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2018-03-06 by Oliver Nelson
79332>>>>>>>>>>>>>>>>>/// @See         Get_Connection_Option, Clear_Connection_Option
79332>>>>>>>>>>>>>>>>>///
79332>>>>>>>>>>>>>>>>>/// @Syntax SET_CONNECTION_OPTION {option} to {value}
79332>>>>>>>>>>>>>>>>>/// @Param option         The connection option to set
79332>>>>>>>>>>>>>>>>>/// @Param value          The value to set the connection option to.
79332>>>>>>>>>>>>>>>>>///
79332>>>>>>>>>>>>>>>>>/// @Example
79332>>>>>>>>>>>>>>>>>/// LOAD_DRIVER "SQL_DRV"
79332>>>>>>>>>>>>>>>>>/// SET_CONNECTION_OPTION "ApplicationIntent" to "ReadOnly"
79332>>>>>>>>>>>>>>>>>/// LOGIN "localhost/sqlexpress01" "" "" "sql_drv"
79332>>>>>>>>>>>>>>>>>
79332>>>>>>>>>>>>>>>>>//=============================================================================
79332>>>>>>>>>>>>>>>>>/// @Name        GET_CONNECTION_OPTION
79332>>>>>>>>>>>>>>>>>/// @Description This command gets the value of a connection option that was set
79332>>>>>>>>>>>>>>>>>/// using SET_CONNECTION_OPTION. Only options that are not used internally by
79332>>>>>>>>>>>>>>>>>/// the driver can be retrieved using this command. Connection options that CANNOT be
79332>>>>>>>>>>>>>>>>>/// retrieved: Database, Server, FailoverPartner, MarsConn, uid, pwd,
79332>>>>>>>>>>>>>>>>>/// Trusted_Connection, wsid, app, AutoTranslate, Timeout.
79332>>>>>>>>>>>>>>>>>///
79332>>>>>>>>>>>>>>>>>/// @Assumptions
79332>>>>>>>>>>>>>>>>>/// @Status      Public
79332>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex
79332>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2018-03-06 by Oliver Nelson
79332>>>>>>>>>>>>>>>>>/// @See         Set_Connection_Option, Clear_Connection_Option
79332>>>>>>>>>>>>>>>>>///
79332>>>>>>>>>>>>>>>>>/// @Syntax GET_CONNECTION_OPTION {option} to {variable}
79332>>>>>>>>>>>>>>>>>/// @Param option         The connection option to get
79332>>>>>>>>>>>>>>>>>/// @Param value          A variable to hold the retrieved value of the connection option.
79332>>>>>>>>>>>>>>>>>///
79332>>>>>>>>>>>>>>>>>/// @Example
79332>>>>>>>>>>>>>>>>>/// GET_CONNECTION_OPTION "ApplicationIntent" to sVal
79332>>>>>>>>>>>>>>>>>
79332>>>>>>>>>>>>>>>>>//=============================================================================
79332>>>>>>>>>>>>>>>>>/// @Name        CLEAR_CONNECTION_OPTION
79332>>>>>>>>>>>>>>>>>/// @Description This command will clear any or all connections options that
79332>>>>>>>>>>>>>>>>>/// were set using SET_CONNECTION_OPTION. Passing the keyword ALL will remove
79332>>>>>>>>>>>>>>>>>/// all custom set connection options while passing a string value will clear
79332>>>>>>>>>>>>>>>>>/// just that option passed for the next login call. Connection options that
79332>>>>>>>>>>>>>>>>>/// CANNOT be cleared: Database, Server, FailoverPartner, MarsConn, uid, pwd,
79332>>>>>>>>>>>>>>>>>/// Trusted_Connection, wsid, app, AutoTranslate, Timeout.
79332>>>>>>>>>>>>>>>>>///
79332>>>>>>>>>>>>>>>>>/// @Assumptions
79332>>>>>>>>>>>>>>>>>/// @Status      Public
79332>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex
79332>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2018-03-06 by Oliver Nelson
79332>>>>>>>>>>>>>>>>>/// @See         Set_Connection_Option, Get_Connection_Option
79332>>>>>>>>>>>>>>>>>///
79332>>>>>>>>>>>>>>>>>/// @Syntax CLEAR_CONNECTION_OPTION ALL | {option}
79332>>>>>>>>>>>>>>>>>/// @Param option         The connection option to clear
79332>>>>>>>>>>>>>>>>>///
79332>>>>>>>>>>>>>>>>>/// @Example
79332>>>>>>>>>>>>>>>>>/// CLEAR_CONNECTION_OPTION "ApplicationIntent"
79332>>>>>>>>>>>>>>>>>
79332>>>>>>>>>>>>>>>>>
79332>>>>>>>>>>>>>>>>>///
79332>>>>>>>>>>>>>>>>>// Private:
79332>>>>>>>>>>>>>>>>>// Get the filenumber of a file.field parameter
79332>>>>>>>>>>>>>>>>>//
79332>>>>>>>>>>>>>>>>>
79332>>>>>>>>>>>>>>>>>///
79332>>>>>>>>>>>>>>>>>// Private:
79332>>>>>>>>>>>>>>>>>// Get the fieldnumber of a file.field parameter
79332>>>>>>>>>>>>>>>>>//
79332>>>>>>>>>>>>>>>>>
79332>>>>>>>>>>>>>>>>>
79332>>>>>>>>>>>>>>>>>
79332>>>>>>>>>>>>>>>>>
79332>>>>>>>>>>>>>>>>>//
79332>>>>>>>>>>>>>>>>>// Minimum required DataFlex version for new LOB support below is VDF 4
79332>>>>>>>>>>>>>>>>>//
79332>>>>>>>>>>>>>>>>>
79332>>>>>>>>>>>>>>>>>TYPE tMertechLOB_Args
79332>>>>>>>>>>>>>>>>>    FIELD tMertechLOB_Args.cbSize       AS WORD          // always the size of the structure (verification + versioning)
79332>>>>>>>>>>>>>>>>>    FIELD tMertechLOB_Args.nField       AS DWORD         // always the field number
79332>>>>>>>>>>>>>>>>>    FIELD tMertechLOB_Args.pszData      AS POINTER
79332>>>>>>>>>>>>>>>>>    FIELD tMertechLOB_Args.nSize        AS DWORD
79332>>>>>>>>>>>>>>>>>    FIELD tMertechLOB_Args.nOffset      AS POINTER
79332>>>>>>>>>>>>>>>>>END_TYPE
79332>>>>>>>>>>>>>>>>>
79332>>>>>>>>>>>>>>>>>//=============================================================================
79332>>>>>>>>>>>>>>>>>/// @Name        SQL_GET_DATA_CHUNK_EX
79332>>>>>>>>>>>>>>>>>/// @Description This command is used to get a chunk of data from a column
79332>>>>>>>>>>>>>>>>>/// retrieved through an embedded SQL statement. By passing the column number
79332>>>>>>>>>>>>>>>>>/// and the offset number, the chunk will be put into the specified variable.
79332>>>>>>>>>>>>>>>>>/// To specify how big of a chunk to get, use the SQL_SET_CHUNK_SIZE command.
79332>>>>>>>>>>>>>>>>>/// Otherwise the maximum length will be retrieved. An optional variable can
79332>>>>>>>>>>>>>>>>>/// also be passed which will store the length of the chunk. Note that unlike
79332>>>>>>>>>>>>>>>>>/// LOB_READ, this command works for any column type, not just LOB columns.
79332>>>>>>>>>>>>>>>>>///
79332>>>>>>>>>>>>>>>>>/// @Assumptions
79332>>>>>>>>>>>>>>>>>/// @Status      Public
79332>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex
79332>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2016-04-27 by Oliver Nelson
79332>>>>>>>>>>>>>>>>>/// @See         SQL_SET_CHUNK_SIZE SQL_GET_CHUNK_SIZE SQL_SET_MAX_DATA_SIZE SQL_GET_MAX_DATA_SIZE SQL_GET_COLUMN_DATA_SIZE
79332>>>>>>>>>>>>>>>>>///
79332>>>>>>>>>>>>>>>>>/// @Syntax SQL_GET_DATA_CHUNK COLUMN {column} OFFSET {offset} to {variable} {length}
79332>>>>>>>>>>>>>>>>>/// @Param column               Column number to get chunk from
79332>>>>>>>>>>>>>>>>>/// @Param offset               Offset to start at for the chunk
79332>>>>>>>>>>>>>>>>>/// @Param variable             Variable to hold the returned chunk
79332>>>>>>>>>>>>>>>>>/// @Param length               Variable to hold the size of the returned chunk
79332>>>>>>>>>>>>>>>>>///
79332>>>>>>>>>>>>>>>>>/// @Example
79332>>>>>>>>>>>>>>>>>/// SQL_SET_MAX_DATA_SIZE to |CI$4000000 //(64MB)
79332>>>>>>>>>>>>>>>>>/// move |CI$80000 to iChunkSize // 512KB
79332>>>>>>>>>>>>>>>>>/// SQL_SET_CHUNK_SIZE to iChunkSize
79332>>>>>>>>>>>>>>>>>///
79332>>>>>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
79332>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT
79332>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
79332>>>>>>>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sID sBio
79332>>>>>>>>>>>>>>>>>/// If (Found) Begin
79332>>>>>>>>>>>>>>>>>///     SQL_GET_COLUMN_DATA_SIZE COLUMN 6 to iDataSize
79332>>>>>>>>>>>>>>>>>///
79332>>>>>>>>>>>>>>>>>///     Repeat
79332>>>>>>>>>>>>>>>>>///         SQL_GET_DATA_CHUNK COLUMN 6 OFFSET iProgress to sChunk
79332>>>>>>>>>>>>>>>>>///         ADD iChunkSize to iProgress
79332>>>>>>>>>>>>>>>>>///         write sChunk
79332>>>>>>>>>>>>>>>>>///     until (iProgress >= iDataSize)
79332>>>>>>>>>>>>>>>>>///
79332>>>>>>>>>>>>>>>>>/// End
79332>>>>>>>>>>>>>>>>>
79332>>>>>>>>>>>>>>>>>
79332>>>>>>>>>>>>>>>>>Function MertechInc_SQL_GET_DATA_CHUNK_EX Global Integer iColumn Integer iOffset Returns String
79334>>>>>>>>>>>>>>>>>    Local String sLOB_Args
79334>>>>>>>>>>>>>>>>>    Local String sData
79334>>>>>>>>>>>>>>>>>    Local Integer iSize
79334>>>>>>>>>>>>>>>>>
79334>>>>>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_CHUNK_SIZE CALLBACK 0 PASSING iSize MertechInc_Blank 1 RESULT MertechInc_iRet
79339>>>>>>>>>>>>>>>>>
79339>>>>>>>>>>>>>>>>>    Move "" to sData
79340>>>>>>>>>>>>>>>>>    ZeroType tMertechLOB_Args to sLOB_Args
79341>>>>>>>>>>>>>>>>>    // First move the size of the structure to the Structure
79341>>>>>>>>>>>>>>>>>    Put tMertechLOB_Args_size  to sLOB_Args at tMertechLOB_Args.cbSize
79342>>>>>>>>>>>>>>>>>    Put iColumn                to sLOB_Args at tMertechLOB_Args.nField
79343>>>>>>>>>>>>>>>>>    Put iOffset                to sLOB_Args at tMertechLOB_Args.nOffset
79344>>>>>>>>>>>>>>>>>    Put iSize                  to sLOB_Args at tMertechLOB_Args.nSize
79345>>>>>>>>>>>>>>>>>
79345>>>>>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_GET_DATA_CHUNK_EX CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank (addressof(sLOB_Args)) RESULT MertechInc_iRet
79350>>>>>>>>>>>>>>>>>    GetBuff from sLOB_Args at tMertechLOB_Args.nSize to iSize
79351>>>>>>>>>>>>>>>>>
79351>>>>>>>>>>>>>>>>>    If iSize GT 0 Begin
79353>>>>>>>>>>>>>>>>>        Move (Repeat(Character(0), iSize)) to sData
79354>>>>>>>>>>>>>>>>>        Put (AddressOf(sData)) to sLOB_Args at tMertechLOB_Args.pszData
79355>>>>>>>>>>>>>>>>>        Put iSize              to sLOB_Args at tMertechLOB_Args.nSize
79356>>>>>>>>>>>>>>>>>        Put iOffset            to sLOB_Args at tMertechLOB_Args.nOffset
79357>>>>>>>>>>>>>>>>>        Call_Driver 0 MertechInc_DriverName Function CALLDRV_GET_DATA_CHUNK_EX CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank (addressof(sLOB_Args)) RESULT MertechInc_iRet
79362>>>>>>>>>>>>>>>>>        GetBuff from sLOB_Args at tMertechLOB_Args.nSize to iSize
79363>>>>>>>>>>>>>>>>>    End
79363>>>>>>>>>>>>>>>>>>
79363>>>>>>>>>>>>>>>>>    Else Begin
79364>>>>>>>>>>>>>>>>>        Move "" to sData
79365>>>>>>>>>>>>>>>>>    End
79365>>>>>>>>>>>>>>>>>>
79365>>>>>>>>>>>>>>>>>    Function_Return sData
79366>>>>>>>>>>>>>>>>>End_Function // MertechInc_SQL_GET_DATA_CHUNK_EX
79367>>>>>>>>>>>>>>>>>
79367>>>>>>>>>>>>>>>>>//=============================================================================
79367>>>>>>>>>>>>>>>>>/// @Name        SQL_GET_COLUMN_DATA_SIZE
79367>>>>>>>>>>>>>>>>>/// @Description This command is used to get the size of the data in a column
79367>>>>>>>>>>>>>>>>>/// retrieved through an embedded SQL statement. By passing the column number
79367>>>>>>>>>>>>>>>>>/// the size of the data in the column will be put into the specified variable.
79367>>>>>>>>>>>>>>>>>/// The size returned will be the smaller of the actual size of the data or
79367>>>>>>>>>>>>>>>>>/// the SQL_SET_MAX_DATA_SIZE setting. So for instance, if the data stored in
79367>>>>>>>>>>>>>>>>>/// a column is 64MB, but the SQL_SET_MAX_DATA_SIZE is set to 16MB, then this
79367>>>>>>>>>>>>>>>>>/// command will return 16MB. Note that you may need to use Set_Argument_Size
79367>>>>>>>>>>>>>>>>>/// to allow for a large chunk size because the default maximum string size
79367>>>>>>>>>>>>>>>>>/// in most modern dataflex versions is only 64KB.
79367>>>>>>>>>>>>>>>>>///
79367>>>>>>>>>>>>>>>>>/// @Assumptions
79367>>>>>>>>>>>>>>>>>/// @Status      Public
79367>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex
79367>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2016-04-27 Oliver Nelson
79367>>>>>>>>>>>>>>>>>/// @See         SQL_SET_CHUNK_SIZE SQL_GET_CHUNK_SIZE SQL_GET_DATA_CHUNK_EX SQL_SET_MAX_DATA_SIZE
79367>>>>>>>>>>>>>>>>>///
79367>>>>>>>>>>>>>>>>>/// @Syntax SQL_GET_COLUMN_DATA_SIZE COLUMN {column} to {variable}
79367>>>>>>>>>>>>>>>>>/// @Param column               Column number to get chunk from
79367>>>>>>>>>>>>>>>>>/// @Param variable             Variable to hold the returned data size
79367>>>>>>>>>>>>>>>>>///
79367>>>>>>>>>>>>>>>>>/// @Example
79367>>>>>>>>>>>>>>>>>/// SQL_SET_MAX_DATA_SIZE to |CI$4000000 //(64MB)
79367>>>>>>>>>>>>>>>>>/// move |CI$80000 to iChunkSize // 512KB
79367>>>>>>>>>>>>>>>>>/// SQL_SET_CHUNK_SIZE to iChunkSize
79367>>>>>>>>>>>>>>>>>///
79367>>>>>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
79367>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT
79367>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
79367>>>>>>>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sID sBio
79367>>>>>>>>>>>>>>>>>/// If (Found) Begin
79367>>>>>>>>>>>>>>>>>///     SQL_GET_COLUMN_DATA_SIZE COLUMN 6 to iDataSize
79367>>>>>>>>>>>>>>>>>///
79367>>>>>>>>>>>>>>>>>///     Repeat
79367>>>>>>>>>>>>>>>>>///         SQL_GET_DATA_CHUNK COLUMN 6 OFFSET iProgress to sChunk
79367>>>>>>>>>>>>>>>>>///         ADD iChunkSize to iProgress
79367>>>>>>>>>>>>>>>>>///         write sChunk
79367>>>>>>>>>>>>>>>>>///     until (iProgress >= iDataSize)
79367>>>>>>>>>>>>>>>>>///
79367>>>>>>>>>>>>>>>>>/// End
79367>>>>>>>>>>>>>>>>>
79367>>>>>>>>>>>>>>>>>
79367>>>>>>>>>>>>>>>>>Function MertechInc_SQL_GET_COLUMN_DATA_SIZE Global Integer iColumn Returns Integer
79369>>>>>>>>>>>>>>>>>    Local String sLOB_Args
79369>>>>>>>>>>>>>>>>>    Local String sData
79369>>>>>>>>>>>>>>>>>    Local Integer iSize
79369>>>>>>>>>>>>>>>>>
79369>>>>>>>>>>>>>>>>>    ZeroType tMertechLOB_Args to sLOB_Args
79370>>>>>>>>>>>>>>>>>    // First move the size of the structure to the Structure
79370>>>>>>>>>>>>>>>>>    Put tMertechLOB_Args_size  to sLOB_Args at tMertechLOB_Args.cbSize
79371>>>>>>>>>>>>>>>>>    Put iColumn                to sLOB_Args at tMertechLOB_Args.nField
79372>>>>>>>>>>>>>>>>>    Put 0                      to sLOB_Args at tMertechLOB_Args.nOffset
79373>>>>>>>>>>>>>>>>>    Put |CI$7FFFFFFF           to sLOB_Args at tMertechLOB_Args.nSize
79374>>>>>>>>>>>>>>>>>
79374>>>>>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_GET_DATA_CHUNK_EX CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank (addressof(sLOB_Args)) RESULT MertechInc_iRet
79379>>>>>>>>>>>>>>>>>    GetBuff from sLOB_Args at tMertechLOB_Args.nSize to iSize
79380>>>>>>>>>>>>>>>>>
79380>>>>>>>>>>>>>>>>>    Function_Return iSize
79381>>>>>>>>>>>>>>>>>End_Function // MertechInc_SQL_GET_COLUMN_DATA_SIZE
79382>>>>>>>>>>>>>>>>>
79382>>>>>>>>>>>>>>>>>//=============================================================================
79382>>>>>>>>>>>>>>>>>/// @Name        SQL_SET_LOB
79382>>>>>>>>>>>>>>>>>/// @Description This command replaces whatever is currently in a LOB Field
79382>>>>>>>>>>>>>>>>>/// with the data passed. It writes to a client side buffer. It can be used
79382>>>>>>>>>>>>>>>>>/// to Write an arbitrary amount of data into a LOB.
79382>>>>>>>>>>>>>>>>>/// If passed an empty String, it will remove all the contents of the LOB.
79382>>>>>>>>>>>>>>>>>/// If you wish to Set a LOB back to NULL, please use the SQL_SET_LOB_NULL
79382>>>>>>>>>>>>>>>>>/// command.
79382>>>>>>>>>>>>>>>>>/// NOTE: Unlike the previous call LOB_WRITE, this call does not
79382>>>>>>>>>>>>>>>>>/// perform the Save. This must be done separately.
79382>>>>>>>>>>>>>>>>>///
79382>>>>>>>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
79382>>>>>>>>>>>>>>>>>/// @Status      Public
79382>>>>>>>>>>>>>>>>>/// @Drivers     All
79382>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2014-07-10 by Aaron Gulack
79382>>>>>>>>>>>>>>>>>/// @See                 SQL_ADD_LOB_CHUNK SQL_GET_LOB SQL_GET_LOB_CHUNK SQL_GET_LOB_LENGTH SQL_LOB_TRUNCATE
79382>>>>>>>>>>>>>>>>>///
79382>>>>>>>>>>>>>>>>>/// @Syntax             SQL_SET_LOB {FileName.FieldName} to {variable}
79382>>>>>>>>>>>>>>>>>/// @Param              FileName                The name of the file containing the LOB field
79382>>>>>>>>>>>>>>>>>/// @Param              FieldName               The name of the LOB field being set
79382>>>>>>>>>>>>>>>>>/// @Param              variable                The variable to use to set the field's value
79382>>>>>>>>>>>>>>>>>///
79382>>>>>>>>>>>>>>>>>/// @Example
79382>>>>>>>>>>>>>>>>>/// Set_Argument_Size 262144
79382>>>>>>>>>>>>>>>>>/// String sLine
79382>>>>>>>>>>>>>>>>>///
79382>>>>>>>>>>>>>>>>>/// Clear Customer
79382>>>>>>>>>>>>>>>>>///    Move iID to Customer.ID
79382>>>>>>>>>>>>>>>>>/// Find Eq Customer by Index.1
79382>>>>>>>>>>>>>>>>>/// If (Found) Begin
79382>>>>>>>>>>>>>>>>>///    Direct_Input "C:\bigFile.xml"
79382>>>>>>>>>>>>>>>>>///    Reread Customer
79382>>>>>>>>>>>>>>>>>///       SQL_SET_LOB Customer.Comments to ""
79382>>>>>>>>>>>>>>>>>///       Read_Block sLine 262144
79382>>>>>>>>>>>>>>>>>///       SQL_SET_LOB Customer.Comments to sLine
79382>>>>>>>>>>>>>>>>>///       While (not(SeqEof))
79382>>>>>>>>>>>>>>>>>///          Read_Block sLine 262144
79382>>>>>>>>>>>>>>>>>///          SQL_ADD_LOB_CHUNK Customer.Comments to sLine
79382>>>>>>>>>>>>>>>>>///       Loop
79382>>>>>>>>>>>>>>>>>///    Saverecord Customer
79382>>>>>>>>>>>>>>>>>///    Unlock
79382>>>>>>>>>>>>>>>>>///    Close_Input
79382>>>>>>>>>>>>>>>>>/// End
79382>>>>>>>>>>>>>>>>>
79382>>>>>>>>>>>>>>>>>Procedure MertechInc_SQL_SET_LOB Global String sDriver Integer iFile Integer iField String sData
79384>>>>>>>>>>>>>>>>>    String sLOB_Args       // can drop local command if minimum vdf version is 6
79384>>>>>>>>>>>>>>>>>
79384>>>>>>>>>>>>>>>>>    ZeroType tMertechLOB_Args to sLOB_Args
79385>>>>>>>>>>>>>>>>>    // First move the size of the structure to the Structure
79385>>>>>>>>>>>>>>>>>    Put tMertechLOB_Args_size to sLOB_Args at tMertechLOB_Args.cbSize
79386>>>>>>>>>>>>>>>>>    Put iField                to sLOB_Args at tMertechLOB_Args.nField
79387>>>>>>>>>>>>>>>>>    Put (AddressOf(sData))    to sLOB_Args at tMertechLOB_Args.pszData
79388>>>>>>>>>>>>>>>>>    Put (length(sData))       to sLOB_Args at tMertechLOB_Args.nSize
79389>>>>>>>>>>>>>>>>>
79389>>>>>>>>>>>>>>>>>    Call_Driver iFile sDriver Function CALLDRV_LOB_EX_WRITE CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank (addressof(sLOB_Args)) RESULT MertechInc_iRet
79394>>>>>>>>>>>>>>>>>End_Procedure // MertechInc_SQL_SET_LOB
79395>>>>>>>>>>>>>>>>>
79395>>>>>>>>>>>>>>>>>//=============================================================================
79395>>>>>>>>>>>>>>>>>/// @Name        SQL_ADD_LOB_CHUNK
79395>>>>>>>>>>>>>>>>>/// @Description This command is used to add additional chunks to the buffer
79395>>>>>>>>>>>>>>>>>/// before saving the record. After SQL_SET_LOB has been called
79395>>>>>>>>>>>>>>>>>/// SQL_ADD_LOB_CHUNK can be called as many times as needed to add additional
79395>>>>>>>>>>>>>>>>>/// chunks of data before a save. It can also be called independent of
79395>>>>>>>>>>>>>>>>>/// SQL_SET_LOB to append data to an existing LOB column.
79395>>>>>>>>>>>>>>>>>/// NOTE: Unlike the previous call LOB_APPEND, this call does not perform
79395>>>>>>>>>>>>>>>>>/// the save. This must be done separately.
79395>>>>>>>>>>>>>>>>>///
79395>>>>>>>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
79395>>>>>>>>>>>>>>>>>/// @Status      Public
79395>>>>>>>>>>>>>>>>>/// @Drivers     All
79395>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2014-07-10 by Aaron Gulack
79395>>>>>>>>>>>>>>>>>/// @See                 SQL_SET_LOB SQL_GET_LOB SQL_GET_LOB_CHUNK SQL_GET_LOB_LENGTH SQL_LOB_TRUNCATE
79395>>>>>>>>>>>>>>>>>///
79395>>>>>>>>>>>>>>>>>/// @Syntax             SQL_ADD_LOB_CHUNK {FileName.FieldName} to {variable}
79395>>>>>>>>>>>>>>>>>/// @Param              FileName                The name of the file containing the LOB field
79395>>>>>>>>>>>>>>>>>/// @Param              FieldName               The name of the LOB field being set
79395>>>>>>>>>>>>>>>>>/// @Param              variable                The variable to add as the LOB chunk
79395>>>>>>>>>>>>>>>>>///
79395>>>>>>>>>>>>>>>>>/// @Example
79395>>>>>>>>>>>>>>>>>/// Set_Argument_Size 262144
79395>>>>>>>>>>>>>>>>>/// String sLine
79395>>>>>>>>>>>>>>>>>///
79395>>>>>>>>>>>>>>>>>/// Clear Customer
79395>>>>>>>>>>>>>>>>>///    Move iID to Customer.ID
79395>>>>>>>>>>>>>>>>>/// Find Eq Customer by Index.1
79395>>>>>>>>>>>>>>>>>/// If (Found) Begin
79395>>>>>>>>>>>>>>>>>///    Direct_Input "C:\bigFile.xml"
79395>>>>>>>>>>>>>>>>>///    Reread Customer
79395>>>>>>>>>>>>>>>>>///       SQL_SET_LOB Customer.Comments to ""
79395>>>>>>>>>>>>>>>>>///       Read_Block sLine 262144
79395>>>>>>>>>>>>>>>>>///       SQL_SET_LOB Customer.Comments to sLine
79395>>>>>>>>>>>>>>>>>///       While (not(SeqEof))
79395>>>>>>>>>>>>>>>>>///          Read_Block sLine 262144
79395>>>>>>>>>>>>>>>>>///          SQL_ADD_LOB_CHUNK Customer.Comments to sLine
79395>>>>>>>>>>>>>>>>>///       Loop
79395>>>>>>>>>>>>>>>>>///    Saverecord Customer
79395>>>>>>>>>>>>>>>>>///    Unlock
79395>>>>>>>>>>>>>>>>>///    Close_Input
79395>>>>>>>>>>>>>>>>>/// End
79395>>>>>>>>>>>>>>>>>
79395>>>>>>>>>>>>>>>>>Procedure MertechInc_SQL_ADD_LOB_CHUNK Global String sDriver Integer iFile Integer iField String sData
79397>>>>>>>>>>>>>>>>>    String sLOB_Args
79397>>>>>>>>>>>>>>>>>
79397>>>>>>>>>>>>>>>>>    ZeroType tMertechLOB_Args to sLOB_Args
79398>>>>>>>>>>>>>>>>>    // First move the size of the structure to the Structure
79398>>>>>>>>>>>>>>>>>    Put tMertechLOB_Args_size to sLOB_Args at tMertechLOB_Args.cbSize
79399>>>>>>>>>>>>>>>>>    Put iField                to sLOB_Args at tMertechLOB_Args.nField
79400>>>>>>>>>>>>>>>>>    Put (AddressOf(sData))    to sLOB_Args at tMertechLOB_Args.pszData
79401>>>>>>>>>>>>>>>>>    Put (length(sData))       to sLOB_Args at tMertechLOB_Args.nSize
79402>>>>>>>>>>>>>>>>>
79402>>>>>>>>>>>>>>>>>    Call_Driver iFile sDriver Function CALLDRV_LOB_EX_APPEND CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank (addressof(sLOB_Args)) RESULT MertechInc_iRet
79407>>>>>>>>>>>>>>>>>end_procedure // MertechInc_SQL_ADD_LOB_CHUNK
79408>>>>>>>>>>>>>>>>>
79408>>>>>>>>>>>>>>>>>//=============================================================================
79408>>>>>>>>>>>>>>>>>/// @Name        SQL_GET_LOB
79408>>>>>>>>>>>>>>>>>/// @Description This command is used for getting the value of a specified LOB
79408>>>>>>>>>>>>>>>>>/// field. Two optional parameters can be passed specifying the offset and
79408>>>>>>>>>>>>>>>>>/// length of the chunk to get. Passing these parameters essentially makes this
79408>>>>>>>>>>>>>>>>>/// call the same as SQL_GET_LOB_CHUNK.
79408>>>>>>>>>>>>>>>>>/// Depending on the situation, the two calls can be interchanged for improved
79408>>>>>>>>>>>>>>>>>/// code readability. Excluding these additional parameters will get the whole
79408>>>>>>>>>>>>>>>>>/// field value within DataFlex variable size limits.
79408>>>>>>>>>>>>>>>>>///
79408>>>>>>>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
79408>>>>>>>>>>>>>>>>>/// @Status      Public
79408>>>>>>>>>>>>>>>>>/// @Drivers     All
79408>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2014-07-10 by Aaron Gulack
79408>>>>>>>>>>>>>>>>>/// @See                 SQL_SET_LOB SQL_ADD_LOB_CHUNK SQL_GET_LOB_CHUNK SQL_GET_LOB_LENGTH SQL_LOB_TRUNCATE
79408>>>>>>>>>>>>>>>>>///
79408>>>>>>>>>>>>>>>>>/// @Syntax     SQL_GET_LOB {FileName.FieldName} TO {variable} [ OFFSET {offset} LENGTH {length} ]
79408>>>>>>>>>>>>>>>>>/// @Param              FileName                        The name of the file that contains the specified LOB field
79408>>>>>>>>>>>>>>>>>/// @Param              FieldName                       The name of the LOB field
79408>>>>>>>>>>>>>>>>>/// @Param              variable                        The variable to hold the LOB value
79408>>>>>>>>>>>>>>>>>/// @Param              offset                          Integer amount to offset when getting the LOB value (optional)
79408>>>>>>>>>>>>>>>>>/// @Param              length                          Length of value to get from the LOB field (optional)
79408>>>>>>>>>>>>>>>>>///
79408>>>>>>>>>>>>>>>>>/// @Example
79408>>>>>>>>>>>>>>>>>/// Set_Argument_Size 262144
79408>>>>>>>>>>>>>>>>>/// String sResult
79408>>>>>>>>>>>>>>>>>///
79408>>>>>>>>>>>>>>>>>/// Move 262144 to iChunkSize
79408>>>>>>>>>>>>>>>>>/// Move 0      to iChunk
79408>>>>>>>>>>>>>>>>>///
79408>>>>>>>>>>>>>>>>>/// Clear Customer
79408>>>>>>>>>>>>>>>>>///    Move iID to Customer.ID
79408>>>>>>>>>>>>>>>>>/// Find Eq Customer by Index.1
79408>>>>>>>>>>>>>>>>>/// If (Found) Begin
79408>>>>>>>>>>>>>>>>>///    Direct_Output ('Binary:' + sDestFileName)
79408>>>>>>>>>>>>>>>>>///    SQL_GET_LOB_LENGTH Customer.Comments to iLength
79408>>>>>>>>>>>>>>>>>///    While (iChunk*iChunkSize < iLength)
79408>>>>>>>>>>>>>>>>>///       SQL_GET_LOB Customer.Comments to sResult OFFSET (iChunk*iChunkSize) LENGTH iChunkSize
79408>>>>>>>>>>>>>>>>>///       Write sResult
79408>>>>>>>>>>>>>>>>>///       Increment iChunk
79408>>>>>>>>>>>>>>>>>///    Loop
79408>>>>>>>>>>>>>>>>>///    Close_Output
79408>>>>>>>>>>>>>>>>>/// End
79408>>>>>>>>>>>>>>>>>
79408>>>>>>>>>>>>>>>>>
79408>>>>>>>>>>>>>>>>>Function MertechInc_SQL_GET_LOB Global String sDriver Integer iFile Integer iField Integer iOffset Integer iLength Returns String
79410>>>>>>>>>>>>>>>>>    String sLOB_Args
79410>>>>>>>>>>>>>>>>>    String sData
79410>>>>>>>>>>>>>>>>>    DWord  nSize
79410>>>>>>>>>>>>>>>>>
79410>>>>>>>>>>>>>>>>>    Move "" To sData
79411>>>>>>>>>>>>>>>>>    ZeroType tMertechLOB_Args to sLOB_Args
79412>>>>>>>>>>>>>>>>>    // First move the size of the structure to the Structure
79412>>>>>>>>>>>>>>>>>    Put tMertechLOB_Args_size to sLOB_Args at tMertechLOB_Args.cbSize
79413>>>>>>>>>>>>>>>>>    Put iField                to sLOB_Args at tMertechLOB_Args.nField
79414>>>>>>>>>>>>>>>>>
79414>>>>>>>>>>>>>>>>>    Call_Driver iFile sDriver Function CALLDRV_LOB_EX_GET_LENGTH CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank (addressof(sLOB_Args)) RESULT MertechInc_iRet
79419>>>>>>>>>>>>>>>>>
79419>>>>>>>>>>>>>>>>>    GetBuff from sLOB_Args at tMertechLOB_Args.nSize to nSize
79420>>>>>>>>>>>>>>>>>    If (nSize > 0) Begin
79422>>>>>>>>>>>>>>>>>      If (iOffset=0 and iLength=0) Begin
79424>>>>>>>>>>>>>>>>>        move (Repeat(Character(0), nSize)) to sData
79425>>>>>>>>>>>>>>>>>            //Send Assert (AddressOf(sData) <> 0) ("AddressOf(sData) is NULL") DFTrue
79425>>>>>>>>>>>>>>>>>        Put (AddressOf(sData)) to sLOB_Args at tMertechLOB_Args.pszData
79426>>>>>>>>>>>>>>>>>      End
79426>>>>>>>>>>>>>>>>>>
79426>>>>>>>>>>>>>>>>>      Else Begin
79427>>>>>>>>>>>>>>>>>        move (Repeat(Character(0), iLength)) to sData
79428>>>>>>>>>>>>>>>>>        Put (AddressOf(sData)) to sLOB_Args at tMertechLOB_Args.pszData
79429>>>>>>>>>>>>>>>>>        Put iLength            to sLOB_Args at tMertechLOB_Args.nSize
79430>>>>>>>>>>>>>>>>>        Put iOffset            to sLOB_Args at tMertechLOB_Args.nOffset
79431>>>>>>>>>>>>>>>>>      End
79431>>>>>>>>>>>>>>>>>>
79431>>>>>>>>>>>>>>>>>      Call_Driver iFile sDriver Function CALLDRV_LOB_EX_READ CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank (addressof(sLOB_Args)) RESULT MertechInc_iRet
79436>>>>>>>>>>>>>>>>>    End
79436>>>>>>>>>>>>>>>>>>
79436>>>>>>>>>>>>>>>>>    Else Begin
79437>>>>>>>>>>>>>>>>>        Move "" to sData
79438>>>>>>>>>>>>>>>>>    End
79438>>>>>>>>>>>>>>>>>>
79438>>>>>>>>>>>>>>>>>    Function_Return sData
79439>>>>>>>>>>>>>>>>>End_Function // MertechInc_SQL_GET_LOB
79440>>>>>>>>>>>>>>>>>
79440>>>>>>>>>>>>>>>>>//=============================================================================
79440>>>>>>>>>>>>>>>>>/// @Name        SQL_GET_LOB_CHUNK
79440>>>>>>>>>>>>>>>>>/// @Description This command is used for getting a chunk of data from a specified
79440>>>>>>>>>>>>>>>>>/// LOB field. The difference between this command and SQL_GET_LOB is only that
79440>>>>>>>>>>>>>>>>>/// the parameters OFFSET and LENGTH are not optional when using this command.
79440>>>>>>>>>>>>>>>>>/// You may consider using this command to retrieve small portions of a very
79440>>>>>>>>>>>>>>>>>/// large BLOB so as to reduce memory usage.
79440>>>>>>>>>>>>>>>>>///
79440>>>>>>>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
79440>>>>>>>>>>>>>>>>>/// @Status      Public
79440>>>>>>>>>>>>>>>>>/// @Drivers     All
79440>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2014-07-10 by Aaron Gulack
79440>>>>>>>>>>>>>>>>>/// @See                 SQL_SET_LOB SQL_ADD_LOB_CHUNK SQL_GET_LOB SQL_GET_LOB_LENGTH SQL_LOB_TRUNCATE
79440>>>>>>>>>>>>>>>>>///
79440>>>>>>>>>>>>>>>>>/// @Syntax     SQL_GET_LOB_CHUNK {FileName.FieldName} TO {variable} OFFSET {offset} LENGTH {length}
79440>>>>>>>>>>>>>>>>>/// @Param              FileName                        The name of the file that contains the specified LOB field
79440>>>>>>>>>>>>>>>>>/// @Param              FieldName                       The name of the LOB field
79440>>>>>>>>>>>>>>>>>/// @Param              variable                        The variable to hold the LOB chunk
79440>>>>>>>>>>>>>>>>>/// @Param              offset                          Integer amount to offset when getting the LOB chunk
79440>>>>>>>>>>>>>>>>>/// @Param              length                          Length of chunk to get from the LOB field
79440>>>>>>>>>>>>>>>>>///
79440>>>>>>>>>>>>>>>>>/// @Example
79440>>>>>>>>>>>>>>>>>/// Set_Argument_Size 262144
79440>>>>>>>>>>>>>>>>>/// String sResult
79440>>>>>>>>>>>>>>>>>///
79440>>>>>>>>>>>>>>>>>/// Move 262144 to iChunkSize
79440>>>>>>>>>>>>>>>>>/// Move 0      to iChunk
79440>>>>>>>>>>>>>>>>>///
79440>>>>>>>>>>>>>>>>>/// Clear Customer
79440>>>>>>>>>>>>>>>>>///    Move iID to Customer.ID
79440>>>>>>>>>>>>>>>>>/// Find Eq Customer by Index.1
79440>>>>>>>>>>>>>>>>>/// If (Found) Begin
79440>>>>>>>>>>>>>>>>>///    SQL_GET_LOB_LENGTH Customer.Comments to iLength
79440>>>>>>>>>>>>>>>>>///    While (iChunk*iChunkSize < iLength)
79440>>>>>>>>>>>>>>>>>///       SQL_GET_LOB_CHUNK Customer.Comments to sResult OFFSET (iChunk*iChunkSize) LENGTH iChunkSize
79440>>>>>>>>>>>>>>>>>///       // Do something with the LOB data
79440>>>>>>>>>>>>>>>>>///       Increment iChunk
79440>>>>>>>>>>>>>>>>>///    Loop
79440>>>>>>>>>>>>>>>>>/// End
79440>>>>>>>>>>>>>>>>>
79440>>>>>>>>>>>>>>>>>//=============================================================================
79440>>>>>>>>>>>>>>>>>/// @Name        SQL_GET_LOB_LENGTH
79440>>>>>>>>>>>>>>>>>/// @Description This command is used to get the length of a specified LOB field.
79440>>>>>>>>>>>>>>>>>/// It is useful, for example, in determining the number of iterations to
79440>>>>>>>>>>>>>>>>>/// perform while reading from a LOB field using chunking.
79440>>>>>>>>>>>>>>>>>///
79440>>>>>>>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
79440>>>>>>>>>>>>>>>>>/// @Status      Public
79440>>>>>>>>>>>>>>>>>/// @Drivers     All
79440>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2014-07-10 by Aaron Gulack
79440>>>>>>>>>>>>>>>>>/// @See                 SQL_SET_LOB SQL_ADD_LOB_CHUNK SQL_GET_LOB SQL_GET_LOB_CHUNK SQL_LOB_TRUNCATE
79440>>>>>>>>>>>>>>>>>///
79440>>>>>>>>>>>>>>>>>/// @Syntax             SQL_GET_LOB_LENGTH {FileName.FieldName} to {variable}
79440>>>>>>>>>>>>>>>>>/// @Param              FileName                        The name of the file containing the LOB field
79440>>>>>>>>>>>>>>>>>/// @Param              FieldName                       The name of the specified LOB field
79440>>>>>>>>>>>>>>>>>/// @Param              variable                        The variable to hold the length of the field
79440>>>>>>>>>>>>>>>>>///
79440>>>>>>>>>>>>>>>>>/// @Example
79440>>>>>>>>>>>>>>>>>/// Set_Argument_Size 262144
79440>>>>>>>>>>>>>>>>>/// String sResult
79440>>>>>>>>>>>>>>>>>///
79440>>>>>>>>>>>>>>>>>/// Move 16384 to iChunkSize
79440>>>>>>>>>>>>>>>>>/// Move 0     to iChunk
79440>>>>>>>>>>>>>>>>>///
79440>>>>>>>>>>>>>>>>>/// Clear Customer
79440>>>>>>>>>>>>>>>>>///    Move iID to Customer.ID
79440>>>>>>>>>>>>>>>>>/// Find Eq Customer by Index.1
79440>>>>>>>>>>>>>>>>>/// If (Found) Begin
79440>>>>>>>>>>>>>>>>>///    SQL_GET_LOB_LENGTH Customer.Comments to iLength
79440>>>>>>>>>>>>>>>>>///    While (iChunk*iChunkSize < iLength)
79440>>>>>>>>>>>>>>>>>///       SQL_GET_LOB Customer.Comments to sResult OFFSET (iChunk*iChunkSize) LENGTH iChunkSize
79440>>>>>>>>>>>>>>>>>///       // Do something with the LOB data
79440>>>>>>>>>>>>>>>>>///       Increment iChunk
79440>>>>>>>>>>>>>>>>>///    Loop
79440>>>>>>>>>>>>>>>>>/// End
79440>>>>>>>>>>>>>>>>>
79440>>>>>>>>>>>>>>>>>
79440>>>>>>>>>>>>>>>>>Function MertechInc_SQL_GET_LOB_LENGTH Global String sDriver Integer iFile Integer iField Returns Integer
79442>>>>>>>>>>>>>>>>>    String sLOB_Args
79442>>>>>>>>>>>>>>>>>    DWord  nSize
79442>>>>>>>>>>>>>>>>>
79442>>>>>>>>>>>>>>>>>    ZeroType tMertechLOB_Args to sLOB_Args
79443>>>>>>>>>>>>>>>>>    // First move the size of the structure to the Structure
79443>>>>>>>>>>>>>>>>>    Put tMertechLOB_Args_size to sLOB_Args at tMertechLOB_Args.cbSize
79444>>>>>>>>>>>>>>>>>    Put iField                to sLOB_Args at tMertechLOB_Args.nField
79445>>>>>>>>>>>>>>>>>
79445>>>>>>>>>>>>>>>>>    Call_Driver iFile sDriver Function CALLDRV_LOB_EX_GET_LENGTH CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank (addressof(sLOB_Args)) RESULT MertechInc_iRet
79450>>>>>>>>>>>>>>>>>
79450>>>>>>>>>>>>>>>>>    GetBuff from sLOB_Args at tMertechLOB_Args.nSize to nSize
79451>>>>>>>>>>>>>>>>>    Function_Return nSize
79452>>>>>>>>>>>>>>>>>End_Function // MertechInc_SQL_GET_LOB_LENGTH
79453>>>>>>>>>>>>>>>>>
79453>>>>>>>>>>>>>>>>>//=============================================================================
79453>>>>>>>>>>>>>>>>>/// @Name        SQL_SET_LOB_NULL
79453>>>>>>>>>>>>>>>>>/// @Description This command is used to set a LOB column to null. Often
79453>>>>>>>>>>>>>>>>>/// LOB columns should either contain data or be null. A "blank" LOB column
79453>>>>>>>>>>>>>>>>>/// often doesn't appear empty in other environments, so settings it back to
79453>>>>>>>>>>>>>>>>>/// null is best.
79453>>>>>>>>>>>>>>>>>///
79453>>>>>>>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
79453>>>>>>>>>>>>>>>>>/// @Status      Public
79453>>>>>>>>>>>>>>>>>/// @Drivers     All
79453>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2014-07-10 by Aaron Gulack
79453>>>>>>>>>>>>>>>>>/// @See                 SQL_SET_LOB SQL_ADD_LOB_CHUNK SQL_GET_LOB SQL_GET_LOB_CHUNK SQL_LOB_TRUNCATE
79453>>>>>>>>>>>>>>>>>///
79453>>>>>>>>>>>>>>>>>/// @Syntax             SQL_SET_LOB_NULL    {FileName.FieldName}
79453>>>>>>>>>>>>>>>>>/// @Param              FileName                        The name of the file containing the LOB field
79453>>>>>>>>>>>>>>>>>/// @Param              FieldName                       The name of the specified LOB field
79453>>>>>>>>>>>>>>>>>///
79453>>>>>>>>>>>>>>>>>/// @Example
79453>>>>>>>>>>>>>>>>>////
79453>>>>>>>>>>>>>>>>>/// Clear Customer
79453>>>>>>>>>>>>>>>>>/// Move iID to Customer.ID
79453>>>>>>>>>>>>>>>>>/// Find Eq Customer by Index.1
79453>>>>>>>>>>>>>>>>>/// If (Found) Begin
79453>>>>>>>>>>>>>>>>>///    Reread Customer
79453>>>>>>>>>>>>>>>>>///        SQL_SET_LOB_NULL Customer.Comments
79453>>>>>>>>>>>>>>>>>///        Saverecord Customer
79453>>>>>>>>>>>>>>>>>///    Unlock
79453>>>>>>>>>>>>>>>>>/// End
79453>>>>>>>>>>>>>>>>>
79453>>>>>>>>>>>>>>>>>
79453>>>>>>>>>>>>>>>>>Procedure MertechInc_SQL_SET_LOB_NULL Global String sDriver Integer iFile Integer iField
79455>>>>>>>>>>>>>>>>>    String sLOB_Args
79455>>>>>>>>>>>>>>>>>
79455>>>>>>>>>>>>>>>>>    ZeroType tMertechLOB_Args to sLOB_Args
79456>>>>>>>>>>>>>>>>>    // First move the size of the structure to the Structure
79456>>>>>>>>>>>>>>>>>    Put tMertechLOB_Args_size to sLOB_Args at tMertechLOB_Args.cbSize
79457>>>>>>>>>>>>>>>>>    Put iField                to sLOB_Args at tMertechLOB_Args.nField
79458>>>>>>>>>>>>>>>>>
79458>>>>>>>>>>>>>>>>>    Call_Driver iFile sDriver Function CALLDRV_LOB_EX_SET_NULL CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank (addressof(sLOB_Args)) RESULT MertechInc_iRet
79463>>>>>>>>>>>>>>>>>End_Procedure // MertechInc_SQL_SET_LOB_NULL
79464>>>>>>>>>>>>>>>>>
79464>>>>>>>>>>>>>>>>>
#REM ***********************************************
#REM MERTECH DATA SYSTEMS INC. - MERTECH.COM
#REM END OF MERTECH.INC
#REM ***********************************************
79464>>>>>>>>>>>>>>>>>//=============================================================================
79464>>>>>>>>>>>>>>>>>// End of Mertech.inc
79464>>>>>>>>>>>>>>>>>//=============================================================================
79464>>>>>>>>>>>>>>>Use cli.pkg
79464>>>>>>>>>>>>>>>Use ParseKeyWord.pkg
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
79464>>>>>>>>>>>>>>>>>    Define CS_SQLConnectionIDText       for "DFConnectionId"
79464>>>>>>>>>>>>>>>>>
79464>>>>>>>>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
79466>>>>>>>>>>>>>>>>>    Integer iStart iEnd
79466>>>>>>>>>>>>>>>>>    String sRetval
79466>>>>>>>>>>>>>>>>>
79466>>>>>>>>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
79467>>>>>>>>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
79468>>>>>>>>>>>>>>>>>    If (iStart = 0) Begin
79470>>>>>>>>>>>>>>>>>        Function_Return ""
79471>>>>>>>>>>>>>>>>>    End
79471>>>>>>>>>>>>>>>>>>
79471>>>>>>>>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
79472>>>>>>>>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
79473>>>>>>>>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
79475>>>>>>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
79476>>>>>>>>>>>>>>>>>    End
79476>>>>>>>>>>>>>>>>>>
79476>>>>>>>>>>>>>>>>>    Else Begin
79477>>>>>>>>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
79478>>>>>>>>>>>>>>>>>    End
79478>>>>>>>>>>>>>>>>>>
79478>>>>>>>>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
79480>>>>>>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
79481>>>>>>>>>>>>>>>>>        Decrement iEnd
79482>>>>>>>>>>>>>>>>>    End
79482>>>>>>>>>>>>>>>>>>
79482>>>>>>>>>>>>>>>>>    If (iEnd <> 0) Begin
79484>>>>>>>>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
79485>>>>>>>>>>>>>>>>>    End
79485>>>>>>>>>>>>>>>>>>
79485>>>>>>>>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
79486>>>>>>>>>>>>>>>>>
79486>>>>>>>>>>>>>>>>>    Function_Return (Trim(sRetval))
79487>>>>>>>>>>>>>>>>>End_Function
79488>>>>>>>>>>>>>>>>>
79488>>>>>>>>>>>>>>>
#REM -----------------------------------------------
#REM MERTECH DATA SYSTEMS INC. - WWW.MERTECHDATA.COM
#REM MERTECH.INC VERSION 1.0.3 FOR DATAFLEX UPDATE FRAMEWORK
#REM -----------------------------------------------
79488>>>>>>>>>>>>>>>
79488>>>>>>>>>>>>>>>Struct tCLIHandleMap
79488>>>>>>>>>>>>>>>    Integer iHdbc
79488>>>>>>>>>>>>>>>    String sDriver
79488>>>>>>>>>>>>>>>    String sConnect
79488>>>>>>>>>>>>>>>End_Struct
79488>>>>>>>>>>>>>>>
79488>>>>>>>>>>>>>>>Struct tColumnMap
79488>>>>>>>>>>>>>>>    Integer iFileNum
79488>>>>>>>>>>>>>>>    Variant[] vResultColumn
79488>>>>>>>>>>>>>>>End_Struct
79488>>>>>>>>>>>>>>>
79488>>>>>>>>>>>>>>>//*** Embedded SQL statement attribute constants
79488>>>>>>>>>>>>>>>Define SQLSTMTATTRIB_COLUMNCOUNT    for 1
79488>>>>>>>>>>>>>>>Define SQLSTMTATTRIB_ROWCOUNT       for 2
79488>>>>>>>>>>>>>>>Define SQLSTMTATTRIB_ROWCOUNT_TYPE  for 3
79488>>>>>>>>>>>>>>>Define SQLSTMTATTRIB_NUMMESSAGES    for 4
79488>>>>>>>>>>>>>>>
79488>>>>>>>>>>>>>>>//*** Embedded SQL column attribute constants
79488>>>>>>>>>>>>>>>Define SQLCOLATTRIB_SIZE           for 1
79488>>>>>>>>>>>>>>>Define SQLCOLATTRIB_LENGTH         for 1
79488>>>>>>>>>>>>>>>Define SQLCOLATTRIB_PRECISION      for 2
79488>>>>>>>>>>>>>>>Define SQLCOLATTRIB_LABEL          for 3
79488>>>>>>>>>>>>>>>Define SQLCOLATTRIB_BASECOLUMNNAME for 4
79488>>>>>>>>>>>>>>>Define SQLCOLATTRIB_BASETABLENAME  for 5
79488>>>>>>>>>>>>>>>Define SQLCOLATTRIB_SQLTYPE        for 6
79488>>>>>>>>>>>>>>>Define SQLCOLATTRIB_NULLABLE       for 7
79488>>>>>>>>>>>>>>>Define SQLCOLATTRIB_DFTYPE         for 8
79488>>>>>>>>>>>>>>>
79488>>>>>>>>>>>>>>>//*** Enforced DAC SQL.PKG Compatibility
79488>>>>>>>>>>>>>>>Define SQL_DAC_HIGH_COMPATABILITY for 1
79488>>>>>>>>>>>>>>>Define SQL_DAC_NORMAL_COMPATIBILITY  for 0
79488>>>>>>>>>>>>>>>
79488>>>>>>>>>>>>>>>Global_Variable Integer giSQLCompatibilityMode
79488>>>>>>>>>>>>>>>Move SQL_DAC_NORMAL_COMPATIBILITY to giSQLCompatibilityMode
79489>>>>>>>>>>>>>>>
79489>>>>>>>>>>>>>>>//*** Global object handle for the manager
79489>>>>>>>>>>>>>>>Global_Variable Handle _embsqlghoSQLHandleMngr
79489>>>>>>>>>>>>>>>Register_Function CompareMaps tCLIHandleMap map1 tCLIHandleMap map2 Returns Integer
79489>>>>>>>>>>>>>>>
79489>>>>>>>>>>>>>>>Class cSQLStatementDUF is a cObject
79490>>>>>>>>>>>>>>>    Procedure Construct_Object
79492>>>>>>>>>>>>>>>        Forward Send Construct_Object
79494>>>>>>>>>>>>>>>
79494>>>>>>>>>>>>>>>        Property Integer phCLIHandle      0
79495>>>>>>>>>>>>>>>        Property Integer piLastColumn     0
79496>>>>>>>>>>>>>>>        Property Integer piLastArgument   0
79497>>>>>>>>>>>>>>>        Property Integer piBindFile       0
79498>>>>>>>>>>>>>>>        Property Integer piCursorNum      0
79499>>>>>>>>>>>>>>>        Property Boolean pisBeforeFetch   True
79500>>>>>>>>>>>>>>>        Property Integer piParameterCount 0
79501>>>>>>>>>>>>>>>
79501>>>>>>>>>>>>>>>        Property Integer piDataChunkOffset 0
79502>>>>>>>>>>>>>>>        Property String psProcName ""
79503>>>>>>>>>>>>>>>        Property String psSchemaName ""
79504>>>>>>>>>>>>>>>        Property Variant[] pvParams
79505>>>>>>>>>>>>>>>        Property tColumnMap ptColumnMap
79506>>>>>>>>>>>>>>>    End_Procedure
79507>>>>>>>>>>>>>>>
79507>>>>>>>>>>>>>>>
79507>>>>>>>>>>>>>>>    Function DFDateToSQLDate for cSQLStatementDUF Date dDFDate Returns String
79509>>>>>>>>>>>>>>>        Integer hoCLIHandler
79509>>>>>>>>>>>>>>>        String sSQLDate
79509>>>>>>>>>>>>>>>
79509>>>>>>>>>>>>>>>        //*** Create a CLI handler object
79509>>>>>>>>>>>>>>>        Object oDFSQLCLIHandler is a cCLIHandler
79511>>>>>>>>>>>>>>>            Move Current_Object to hoCLIHandler
79512>>>>>>>>>>>>>>>        End_Object
79513>>>>>>>>>>>>>>>
79513>>>>>>>>>>>>>>>        //*** Convert the date
79513>>>>>>>>>>>>>>>        Get CLIDFDateToSQLDate of hoCLIHandler (psDRiverID(Current_Object)) dDFDate to sSQLDate
79514>>>>>>>>>>>>>>>
79514>>>>>>>>>>>>>>>        //*** Destroy the object
79514>>>>>>>>>>>>>>>        Send Destroy_Object to hoCLIHandler
79515>>>>>>>>>>>>>>>
79515>>>>>>>>>>>>>>>        Function_Return sSQLDate
79516>>>>>>>>>>>>>>>    End_Function
79517>>>>>>>>>>>>>>>
79517>>>>>>>>>>>>>>>    Function IsProcedure String sFunctionName Returns Boolean
79519>>>>>>>>>>>>>>>        String sRoutineType
79519>>>>>>>>>>>>>>>
79519>>>>>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
79557>>>>>>>>>>>>>>>>
79557>>>>>>>>>>>>>>>
79557>>>>>>>>>>>>>>>        Case Begin
79557>>>>>>>>>>>>>>>            Case (MertechInc_DriverName = SQLFLEX)
79559>>>>>>>>>>>>>>>                sql_set_stmt to (SFormat("select type from master.sys.sysobjects where name = '%1' union all select type from sys.sysobjects where name = '%1'", sFunctionName))
79591>>>>>>>>>>>>>>>                sql_prepare_stmt
79640>>>>>>>>>>>>>>>                sql_execute_stmt
79680>>>>>>>>>>>>>>>
79680>>>>>>>>>>>>>>>                sql_fetch_next_row into sRoutineType
79855>>>>>>>>>>>>>>>                If (sRoutineType = "P") Begin
79857>>>>>>>>>>>>>>>                    Move "PROCEDURE" to sRoutineType
79858>>>>>>>>>>>>>>>                End
79858>>>>>>>>>>>>>>>>
79858>>>>>>>>>>>>>>>                Else Begin
79859>>>>>>>>>>>>>>>                    Move "FUNCTION" to sRoutineType
79860>>>>>>>>>>>>>>>                End
79860>>>>>>>>>>>>>>>>
79860>>>>>>>>>>>>>>>                Case Break
79861>>>>>>>>>>>>>>>            Case (MertechInc_DriverName = MySQLFlex)
79864>>>>>>>>>>>>>>>                sql_set_stmt to (SFormat("select routine_type from information_schema.routines where routine_name = '%1'", sFunctionName))
79896>>>>>>>>>>>>>>>                sql_prepare_stmt
79945>>>>>>>>>>>>>>>                sql_execute_stmt
79985>>>>>>>>>>>>>>>                sql_fetch_next_row into sRoutineType
80160>>>>>>>>>>>>>>>
80160>>>>>>>>>>>>>>>                Case Break
80161>>>>>>>>>>>>>>>            Case (MertechInc_DriverName = ORAFLEX)
80164>>>>>>>>>>>>>>>                sql_set_stmt  to (SFormat("SELECT object_type from all_objects where object_name = '%1'", sFunctionName))
80196>>>>>>>>>>>>>>>                sql_prepare_stmt
80245>>>>>>>>>>>>>>>                sql_execute_stmt
80285>>>>>>>>>>>>>>>                sql_fetch_next_row into sRoutineType
80460>>>>>>>>>>>>>>>
80460>>>>>>>>>>>>>>>                Case Break
80461>>>>>>>>>>>>>>>            Case (MertechInc_DriverName = PgFlex)
80464>>>>>>>>>>>>>>>                // Postgres doesn't differentiate between procedures and functions, so treat everything as procedures
80464>>>>>>>>>>>>>>>                // because that is better tested.
80464>>>>>>>>>>>>>>>                Move "PROCEDURE" to sRoutineType
80465>>>>>>>>>>>>>>>                Case Break
80466>>>>>>>>>>>>>>>        Case End
80466>>>>>>>>>>>>>>>
80466>>>>>>>>>>>>>>>        Function_Return (sRoutineType = "PROCEDURE")
80467>>>>>>>>>>>>>>>    End_Function
80468>>>>>>>>>>>>>>>
80468>>>>>>>>>>>>>>>    Function ProcParams String sFunctionName Returns Variant[]
80470>>>>>>>>>>>>>>>        Variant[] vFuncParams
80471>>>>>>>>>>>>>>>        Integer i iParamType
80471>>>>>>>>>>>>>>>
80471>>>>>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
80509>>>>>>>>>>>>>>>>
80509>>>>>>>>>>>>>>>
80509>>>>>>>>>>>>>>>        Case Begin
80509>>>>>>>>>>>>>>>            Case (MertechInc_DriverName = SQLFLEX)
80511>>>>>>>>>>>>>>>                sql_set_stmt to (SFormat("sys.sp_procedure_params_managed @procedure_name = '%1'", sFunctionName))
80543>>>>>>>>>>>>>>>                sql_prepare_stmt
80592>>>>>>>>>>>>>>>                sql_execute_stmt
80632>>>>>>>>>>>>>>>
80632>>>>>>>>>>>>>>>                Repeat
80632>>>>>>>>>>>>>>>>
80632>>>>>>>>>>>>>>>                    sql_fetch_next_row
80682>>>>>>>>>>>>>>>                    If (Found) Begin
80684>>>>>>>>>>>>>>>                        sql_fetch_column 6 into iParamType
80713>>>>>>>>>>>>>>>
80713>>>>>>>>>>>>>>>                        If (iParamType = 1) Begin
80715>>>>>>>>>>>>>>>                            Move "IN" to vFuncParams[i]
80716>>>>>>>>>>>>>>>                        End
80716>>>>>>>>>>>>>>>>
80716>>>>>>>>>>>>>>>                        If (iParamType = 2) Begin
80718>>>>>>>>>>>>>>>                            Move "INOUT" to vFuncParams[i]
80719>>>>>>>>>>>>>>>                        End
80719>>>>>>>>>>>>>>>>
80719>>>>>>>>>>>>>>>                        If (iParamType = 3) Begin
80721>>>>>>>>>>>>>>>                            Move "OUT" to vFuncParams[i]
80722>>>>>>>>>>>>>>>                        End
80722>>>>>>>>>>>>>>>>
80722>>>>>>>>>>>>>>>                        If (iParamType <> 4) Begin
80724>>>>>>>>>>>>>>>                            Increment i
80725>>>>>>>>>>>>>>>                        End
80725>>>>>>>>>>>>>>>>
80725>>>>>>>>>>>>>>>                    End
80725>>>>>>>>>>>>>>>>
80725>>>>>>>>>>>>>>>                Until (not(Found))
80727>>>>>>>>>>>>>>>
80727>>>>>>>>>>>>>>>                Function_Return vFuncParams
80728>>>>>>>>>>>>>>>
80728>>>>>>>>>>>>>>>                Case Break
80729>>>>>>>>>>>>>>>            Case (MertechInc_DriverName = MySQLFlex)
80732>>>>>>>>>>>>>>>                sql_set_stmt to (SFormat("select parameter_mode from INFORMATION_SCHEMA.PARAMETERS where SPECIFIC_NAME = '%1' order by ordinal_position", sFunctionName))
80764>>>>>>>>>>>>>>>                sql_prepare_stmt
80813>>>>>>>>>>>>>>>                sql_execute_stmt
80853>>>>>>>>>>>>>>>
80853>>>>>>>>>>>>>>>                Case Break
80854>>>>>>>>>>>>>>>            Case (MertechInc_DriverName = ORAFLEX)
80857>>>>>>>>>>>>>>>                sql_set_stmt to    "SELECT all_arguments.in_out as parameter_mode "
80889>>>>>>>>>>>>>>>                sql_append_stmt to "FROM all_objects inner join all_arguments on all_objects.object_id = all_arguments.object_id "
80921>>>>>>>>>>>>>>>                sql_append_stmt to (SFormat("WHERE all_objects.object_name = '%1' order by all_arguments.position", sFunctionName))
80953>>>>>>>>>>>>>>>                sql_prepare_stmt
81002>>>>>>>>>>>>>>>                sql_execute_stmt
81042>>>>>>>>>>>>>>>
81042>>>>>>>>>>>>>>>                Case Break
81043>>>>>>>>>>>>>>>            Case (MertechInc_DriverName = PgFlex)
81046>>>>>>>>>>>>>>>                sql_set_stmt    to "select information_schema.parameters.parameter_mode "
81078>>>>>>>>>>>>>>>                sql_append_stmt to "from information_schema.routines inner join information_schema.parameters "
81110>>>>>>>>>>>>>>>                sql_append_stmt to "on information_schema.routines.specific_name=information_schema.parameters.specific_name "
81142>>>>>>>>>>>>>>>                sql_append_stmt to (SFormat("where information_schema.routines.routine_name = '%1' ", sFunctionName))
81174>>>>>>>>>>>>>>>                sql_append_stmt to "order by information_schema.parameters.ordinal_position"
81206>>>>>>>>>>>>>>>                sql_prepare_stmt
81255>>>>>>>>>>>>>>>                sql_execute_stmt
81295>>>>>>>>>>>>>>>
81295>>>>>>>>>>>>>>>                Case Break
81296>>>>>>>>>>>>>>>        Case End
81296>>>>>>>>>>>>>>>
81296>>>>>>>>>>>>>>>        Repeat
81296>>>>>>>>>>>>>>>>
81296>>>>>>>>>>>>>>>            sql_fetch_next_row into vFuncParams[i]
81471>>>>>>>>>>>>>>>            Increment i
81472>>>>>>>>>>>>>>>        Until (not(Found))
81474>>>>>>>>>>>>>>>
81474>>>>>>>>>>>>>>>        Function_Return vFuncParams
81475>>>>>>>>>>>>>>>    End_Function
81476>>>>>>>>>>>>>>>
81476>>>>>>>>>>>>>>>    Procedure Set StoreHandleInfo Handle hConn
81478>>>>>>>>>>>>>>>        Set phCLIHandle to hConn
81479>>>>>>>>>>>>>>>    End_Procedure
81480>>>>>>>>>>>>>>>
81480>>>>>>>>>>>>>>>    Procedure FreeHandle
81482>>>>>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
81520>>>>>>>>>>>>>>>>
81520>>>>>>>>>>>>>>>
81520>>>>>>>>>>>>>>>                                 Case Begin
81520>>>>>>>>>>>>>>>            Case (MertechInc_DriverName = SQLFLEX)
81522>>>>>>>>>>>>>>>                                END_CALL_PROCEDURE
81527>>>>>>>>>>>>>>>                Case Break
81528>>>>>>>>>>>>>>>            Case (MertechInc_DriverName = MySQLFlex)
81531>>>>>>>>>>>>>>>                Case Break
81532>>>>>>>>>>>>>>>            Case (MertechInc_DriverName = ORAFLEX)
81535>>>>>>>>>>>>>>>                Case Break
81536>>>>>>>>>>>>>>>            Case (MertechInc_DriverName = PgFlex)
81539>>>>>>>>>>>>>>>                Case Break
81540>>>>>>>>>>>>>>>        Case End
81540>>>>>>>>>>>>>>>
81540>>>>>>>>>>>>>>>        SQL_CLOSE_CURSOR_STMT to (piCursorNum(Self))
81578>>>>>>>>>>>>>>>>
81578>>>>>>>>>>>>>>>        Send Destroy_Object
81579>>>>>>>>>>>>>>>    End_Procedure
81580>>>>>>>>>>>>>>>
81580>>>>>>>>>>>>>>>    Procedure SQLClose
81582>>>>>>>>>>>>>>>        Send FreeHandle
81583>>>>>>>>>>>>>>>    End_Procedure
81584>>>>>>>>>>>>>>>
81584>>>>>>>>>>>>>>>    Procedure HandleError Integer ihstmt Integer ihdbc String sDrvrId String sOriginMsg
81586>>>>>>>>>>>>>>>        Integer iErrHandle
81586>>>>>>>>>>>>>>>        Integer iErrNum
81586>>>>>>>>>>>>>>>        String  sLocationInfo
81586>>>>>>>>>>>>>>>
81586>>>>>>>>>>>>>>>        //*** Get the DataFlex statement identifier
81586>>>>>>>>>>>>>>>        Move Current_object to iErrHandle
81587>>>>>>>>>>>>>>>
81587>>>>>>>>>>>>>>>        //*** Determine error number
81587>>>>>>>>>>>>>>>        If (ihstmt = 0) ;            Move CLIERR_SQLINVALID_CLI_STMT_HANDLE to iErrNum
81590>>>>>>>>>>>>>>>        Else If (ihdbc = 0) ;            Move CLIERR_SQLINVALID_CLI_CONN_HANDLE to iErrNum
81594>>>>>>>>>>>>>>>        Else If (sDrvrId = "") ;            Move CLIERR_SQLINVALID_DRIVER_ID to iErrNum
81598>>>>>>>>>>>>>>>        Else ;            Move CLIERR_SQL_ERROR to iErrNum
81600>>>>>>>>>>>>>>>
81600>>>>>>>>>>>>>>>        //*** Create location information
81600>>>>>>>>>>>>>>>        Move "[" to sLocationInfo
81601>>>>>>>>>>>>>>>        If (sOriginMsg <> "") Begin
81603>>>>>>>>>>>>>>>            Move (Append(sLocationInfo, sOriginMsg)) to sLocationInfo
81604>>>>>>>>>>>>>>>            Move (Append(sLocationInfo, ", "))       to sLocationInfo
81605>>>>>>>>>>>>>>>        End
81605>>>>>>>>>>>>>>>>
81605>>>>>>>>>>>>>>>        Move (Append(sLocationInfo, "DataFlex hstmt = ")) to sLocationInfo
81606>>>>>>>>>>>>>>>        Move (Append(sLocationInfo, iErrHandle))          to sLocationInfo
81607>>>>>>>>>>>>>>>        Move (Append(sLocationInfo, "]"))                 to sLocationInfo
81608>>>>>>>>>>>>>>>
81608>>>>>>>>>>>>>>>        //*** Generate the error
81608>>>>>>>>>>>>>>>        Error iErrNum sLocationInfo
81609>>>>>>>>>>>>>>>>
81609>>>>>>>>>>>>>>>    End_Procedure
81610>>>>>>>>>>>>>>>
81610>>>>>>>>>>>>>>>    Procedure StmtError Integer iErrNum String sErrText String sOriginMsg
81612>>>>>>>>>>>>>>>        Integer iErrHandle
81612>>>>>>>>>>>>>>>        String  sLocationInfo
81612>>>>>>>>>>>>>>>
81612>>>>>>>>>>>>>>>        //*** Get the DataFlex statement identifier
81612>>>>>>>>>>>>>>>        Move Current_object to iErrHandle
81613>>>>>>>>>>>>>>>
81613>>>>>>>>>>>>>>>        //*** Create location information
81613>>>>>>>>>>>>>>>        Move "[" to sLocationInfo
81614>>>>>>>>>>>>>>>        If (sOriginMsg <> "") Begin
81616>>>>>>>>>>>>>>>            Move (Append(sLocationInfo, sOriginMsg)) to sLocationInfo
81617>>>>>>>>>>>>>>>            Move (Append(sLocationInfo, ", "))       to sLocationInfo
81618>>>>>>>>>>>>>>>        End
81618>>>>>>>>>>>>>>>>
81618>>>>>>>>>>>>>>>        If (sErrtext <> "") Begin
81620>>>>>>>>>>>>>>>            Move (Append(sLocationInfo, sErrtext)) to sLocationInfo
81621>>>>>>>>>>>>>>>            Move (Append(sLocationInfo, ", "))     to sLocationInfo
81622>>>>>>>>>>>>>>>        End
81622>>>>>>>>>>>>>>>>
81622>>>>>>>>>>>>>>>        Move (Append(sLocationInfo, "DataFlex hstmt = ")) to sLocationInfo
81623>>>>>>>>>>>>>>>        Move (Append(sLocationInfo, iErrHandle))          to sLocationInfo
81624>>>>>>>>>>>>>>>        Move (Append(sLocationInfo, "]"))                 to sLocationInfo
81625>>>>>>>>>>>>>>>
81625>>>>>>>>>>>>>>>        //*** Generate the error
81625>>>>>>>>>>>>>>>        Error iErrNum sLocationInfo
81626>>>>>>>>>>>>>>>>
81626>>>>>>>>>>>>>>>    End_Procedure
81627>>>>>>>>>>>>>>>
81627>>>>>>>>>>>>>>>    Procedure SQLIllegalAttribute String sErrText String sOriginMsg
81629>>>>>>>>>>>>>>>        Integer bReport
81629>>>>>>>>>>>>>>>
81629>>>>>>>>>>>>>>>        Get_Attribute DF_REPORT_UNSUPPORTED_ATTRIBUTES to bReport
81632>>>>>>>>>>>>>>>        If (bReport) ;            Send StmtError CLIERR_SQLINVALID_ATTRIBUTE sErrtext sOriginMsg
81635>>>>>>>>>>>>>>>    End_Procedure
81636>>>>>>>>>>>>>>>
81636>>>>>>>>>>>>>>>    Function SQLColumnValue Integer iCol Returns String
81638>>>>>>>>>>>>>>>        String sResult
81638>>>>>>>>>>>>>>>        Integer iCols
81638>>>>>>>>>>>>>>>        Integer iOrgDateFmt
81638>>>>>>>>>>>>>>>        Integer iOrgDateSep
81638>>>>>>>>>>>>>>>        String sType
81638>>>>>>>>>>>>>>>
81638>>>>>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
81676>>>>>>>>>>>>>>>>
81676>>>>>>>>>>>>>>>
81676>>>>>>>>>>>>>>>        SQL_GET_NUM_COLS to iCols
81710>>>>>>>>>>>>>>>>
81710>>>>>>>>>>>>>>>        If (iCol <= iCols) Begin
81712>>>>>>>>>>>>>>>            //DAC SQL Driver currently uses military format for the SQL getting of dates.
81712>>>>>>>>>>>>>>>            If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
81714>>>>>>>>>>>>>>>                Get_Attribute DF_DATE_FORMAT to iOrgDateFmt
81717>>>>>>>>>>>>>>>                Get_Attribute DF_DATE_SEPARATOR to iOrgDateSep
81720>>>>>>>>>>>>>>>                Set_Attribute DF_DATE_FORMAT to DF_DATE_MILITARY
81723>>>>>>>>>>>>>>>                Set_Attribute DF_DATE_SEPARATOR to (Ascii('-'))
81726>>>>>>>>>>>>>>>            End
81726>>>>>>>>>>>>>>>>
81726>>>>>>>>>>>>>>>
81726>>>>>>>>>>>>>>>            //DAC SQL Driver cannot directly get TEXT fields into a result.
81726>>>>>>>>>>>>>>>            If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
81728>>>>>>>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol DFTYPE to sType
81769>>>>>>>>>>>>>>>>
81769>>>>>>>>>>>>>>>                If (sType=5) Begin
81771>>>>>>>>>>>>>>>                    Move "" to sResult
81772>>>>>>>>>>>>>>>                End
81772>>>>>>>>>>>>>>>>
81772>>>>>>>>>>>>>>>                Else Begin
81773>>>>>>>>>>>>>>>                    SQL_FETCH_COLUMN iCol into sResult
81802>>>>>>>>>>>>>>>                End
81802>>>>>>>>>>>>>>>>
81802>>>>>>>>>>>>>>>            End
81802>>>>>>>>>>>>>>>>
81802>>>>>>>>>>>>>>>            Else Begin
81803>>>>>>>>>>>>>>>               SQL_FETCH_COLUMN iCol into sResult
81832>>>>>>>>>>>>>>>            End
81832>>>>>>>>>>>>>>>>
81832>>>>>>>>>>>>>>>
81832>>>>>>>>>>>>>>>            If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
81834>>>>>>>>>>>>>>>                Set_Attribute DF_DATE_FORMAT to iOrgDateFmt
81837>>>>>>>>>>>>>>>                Set_Attribute DF_DATE_SEPARATOR to iOrgDateSep
81840>>>>>>>>>>>>>>>            End
81840>>>>>>>>>>>>>>>>
81840>>>>>>>>>>>>>>>
81840>>>>>>>>>>>>>>>            Function_Return sResult
81841>>>>>>>>>>>>>>>        End
81841>>>>>>>>>>>>>>>>
81841>>>>>>>>>>>>>>>        Else Begin
81842>>>>>>>>>>>>>>>            Send HandleError (phCLIHandle(Self)) (phCLIHandle(Parent(Self))) (psDriverID(Self)) "SQLColumnValue"
81843>>>>>>>>>>>>>>>        End
81843>>>>>>>>>>>>>>>>
81843>>>>>>>>>>>>>>>        Function_Return ""
81844>>>>>>>>>>>>>>>    End_Function
81845>>>>>>>>>>>>>>>
81845>>>>>>>>>>>>>>>    Function SQLNextColumn Returns String
81847>>>>>>>>>>>>>>>        Integer iCol
81847>>>>>>>>>>>>>>>        String  sResult
81847>>>>>>>>>>>>>>>
81847>>>>>>>>>>>>>>>        Get piLastColumn to iCol
81848>>>>>>>>>>>>>>>        Increment iCol
81849>>>>>>>>>>>>>>>        Get SQLColumnValue iCol to sResult
81850>>>>>>>>>>>>>>>        Set piLastColumn to iCol
81851>>>>>>>>>>>>>>>
81851>>>>>>>>>>>>>>>        Function_Return sResult
81852>>>>>>>>>>>>>>>    End_Function
81853>>>>>>>>>>>>>>>
81853>>>>>>>>>>>>>>>    Procedure SQLPrepare String sStatement
81855>>>>>>>>>>>>>>>        tColumnMap tColumnMap
81855>>>>>>>>>>>>>>>        tColumnMap tColumnMap
81855>>>>>>>>>>>>>>>        Set ptColumnMap to tColumnMap
81856>>>>>>>>>>>>>>>        Set pisBeforeFetch to True
81857>>>>>>>>>>>>>>>
81857>>>>>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
81895>>>>>>>>>>>>>>>>
81895>>>>>>>>>>>>>>>        SQL_SET_STMT to sStatement
81927>>>>>>>>>>>>>>>
81927>>>>>>>>>>>>>>>        SQL_PREPARE_STMT
81976>>>>>>>>>>>>>>>    End_Procedure
81977>>>>>>>>>>>>>>>
81977>>>>>>>>>>>>>>>    Procedure SQLExecute
81979>>>>>>>>>>>>>>>        SQL_EXECUTE_STMT
82019>>>>>>>>>>>>>>>    End_Procedure
82020>>>>>>>>>>>>>>>
82020>>>>>>>>>>>>>>>    Procedure SQLExecDirect String sStatement
82022>>>>>>>>>>>>>>>        tColumnMap tColumnMap
82022>>>>>>>>>>>>>>>        tColumnMap tColumnMap
82022>>>>>>>>>>>>>>>        Set ptColumnMap to tColumnMap
82023>>>>>>>>>>>>>>>        Set pisBeforeFetch to True
82024>>>>>>>>>>>>>>>
82024>>>>>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
82062>>>>>>>>>>>>>>>>
82062>>>>>>>>>>>>>>>
82062>>>>>>>>>>>>>>>        SQL_SET_STMT to sStatement
82094>>>>>>>>>>>>>>>        SQL_PREPARE_STMT
82143>>>>>>>>>>>>>>>        SQL_EXECUTE_STMT
82183>>>>>>>>>>>>>>>    End_Procedure
82184>>>>>>>>>>>>>>>
82184>>>>>>>>>>>>>>>    Function SQLFetch Returns Integer
82186>>>>>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
82224>>>>>>>>>>>>>>>>
82224>>>>>>>>>>>>>>>        Set pisBeforeFetch to False
82225>>>>>>>>>>>>>>>
82225>>>>>>>>>>>>>>>        SQL_FETCH_NEXT_ROW
82275>>>>>>>>>>>>>>>        Function_Return (Found)
82276>>>>>>>>>>>>>>>    End_Function
82277>>>>>>>>>>>>>>>
82277>>>>>>>>>>>>>>>    Procedure SQLBindFile Integer iFileNum
82279>>>>>>>>>>>>>>>        tColumnMap tColumnMap
82279>>>>>>>>>>>>>>>        tColumnMap tColumnMap
82279>>>>>>>>>>>>>>>        String[] sBindFileColumns
82280>>>>>>>>>>>>>>>        Integer iColCnt i iDateFormat iResultColumnType iBindFileColumnType
82280>>>>>>>>>>>>>>>        String sColumnName
82280>>>>>>>>>>>>>>>        Variant vFieldValue
82280>>>>>>>>>>>>>>>        Boolean isRecnumTable
82280>>>>>>>>>>>>>>>
82280>>>>>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
82318>>>>>>>>>>>>>>>>
82318>>>>>>>>>>>>>>>
82318>>>>>>>>>>>>>>>        Get_Attribute DF_FILE_RECNUM_TABLE of iFileNum to isRecnumTable
82321>>>>>>>>>>>>>>>        Get ptColumnMap to tColumnMap
82322>>>>>>>>>>>>>>>
82322>>>>>>>>>>>>>>>        If (tColumnMap.iFileNum <> iFileNum) Begin
82324>>>>>>>>>>>>>>>            Move iFileNum to tColumnMap.iFileNum
82325>>>>>>>>>>>>>>>
82325>>>>>>>>>>>>>>>            // First we build an array of the column names (in order) from the file buffer to bind to
82325>>>>>>>>>>>>>>>            Get_Attribute DF_FILE_NUMBER_FIELDS of iFileNum to iColCnt
82328>>>>>>>>>>>>>>>            For i from 0 to iColCnt
82334>>>>>>>>>>>>>>>>
82334>>>>>>>>>>>>>>>                If (isRecnumTable) Begin
82336>>>>>>>>>>>>>>>                    Get_Attribute DF_FIELD_NAME of iFileNum i to sColumnName
82339>>>>>>>>>>>>>>>                End
82339>>>>>>>>>>>>>>>>
82339>>>>>>>>>>>>>>>                Else Begin
82340>>>>>>>>>>>>>>>                    Move "" to sColumnName
82341>>>>>>>>>>>>>>>                End
82341>>>>>>>>>>>>>>>>
82341>>>>>>>>>>>>>>>
82341>>>>>>>>>>>>>>>                Move (Uppercase(sColumnName)) to sBindFileColumns[i]
82342>>>>>>>>>>>>>>>            Loop
82343>>>>>>>>>>>>>>>>
82343>>>>>>>>>>>>>>>
82343>>>>>>>>>>>>>>>            // Next we iterate over the columns in the resultset.  Any column names that match we
82343>>>>>>>>>>>>>>>            // set its match location into an array that maps each resultset column to its matching
82343>>>>>>>>>>>>>>>            // column number in the file buffer.  If there is no match, we set that resultset
82343>>>>>>>>>>>>>>>            // column mappped column to -1.
82343>>>>>>>>>>>>>>>            //
82343>>>>>>>>>>>>>>>            // Since Arrays are zero based and columns are numbered from 1, when we actually map
82343>>>>>>>>>>>>>>>            // to set the value, we need to add 1 to array indexer to get the proper resultset
82343>>>>>>>>>>>>>>>            // column AND we need to add 1 to the mapped-to column since it was loaded into a zero
82343>>>>>>>>>>>>>>>            // based array also.  (Ex: vResultColumn[0] = 2 means column 1 from the resultset maps
82343>>>>>>>>>>>>>>>            // to Column 3 of the file buffer)
82343>>>>>>>>>>>>>>>
82343>>>>>>>>>>>>>>>            SQL_GET_NUM_COLS to iColCnt
82377>>>>>>>>>>>>>>>>
82377>>>>>>>>>>>>>>>            For i from 1 to iColCnt
82383>>>>>>>>>>>>>>>>
82383>>>>>>>>>>>>>>>                SQL_GET_COL_NAME i to sColumnName
82423>>>>>>>>>>>>>>>>
82423>>>>>>>>>>>>>>>                // Because SearchArray returns -1 if there isn't a match, we don't need to do
82423>>>>>>>>>>>>>>>                // anything to make an "unmapped column" have a value of -1.
82423>>>>>>>>>>>>>>>                Move (SearchArray(Uppercase(sColumnName), sBindFileColumns)) to tColumnMap.vResultColumn[i-1]
82424>>>>>>>>>>>>>>>
82424>>>>>>>>>>>>>>>                // If the types don't match between the columns, then "unmap" the column.  This
82424>>>>>>>>>>>>>>>                // should only occur when you're not mapping to the same file as the resultset.
82424>>>>>>>>>>>>>>>                // In this case, sql.pkg silently does nothing, so we need to duplicate this instead
82424>>>>>>>>>>>>>>>                // of generating an error.  If the mapping is to a string, then any type can be
82424>>>>>>>>>>>>>>>                // converted to a string so its okay.
82424>>>>>>>>>>>>>>>                If (tColumnMap.vResultColumn[i-1] <> -1) Begin
82426>>>>>>>>>>>>>>>                    SQL_GET_COL_ATTRIBUTE of i DFTYPE to iResultColumnType
82467>>>>>>>>>>>>>>>>
82467>>>>>>>>>>>>>>>                    Get_Attribute DF_FIELD_TYPE of iFileNum (tColumnMap.vResultColumn[i-1]) to iBindFileColumnType
82470>>>>>>>>>>>>>>>
82470>>>>>>>>>>>>>>>                    // If the conversion is to string (even if the resultset column is something
82470>>>>>>>>>>>>>>>                    // else) its ok, so Break out of the If block before we muck things up.
82470>>>>>>>>>>>>>>>                    If (iBindFileColumnType = DF_ASCII) Break
82473>>>>>>>>>>>>>>>
82473>>>>>>>>>>>>>>>                    // Otherwise, break the mapping
82473>>>>>>>>>>>>>>>                    If (iResultColumnType <> iBindFileColumnType) Begin
82475>>>>>>>>>>>>>>>                        Move -1 to tColumnMap.vResultColumn[i-1]
82476>>>>>>>>>>>>>>>                    End
82476>>>>>>>>>>>>>>>>
82476>>>>>>>>>>>>>>>                End
82476>>>>>>>>>>>>>>>>
82476>>>>>>>>>>>>>>>            Loop
82477>>>>>>>>>>>>>>>>
82477>>>>>>>>>>>>>>>
82477>>>>>>>>>>>>>>>            Set ptColumnMap to tColumnMap
82478>>>>>>>>>>>>>>>        End
82478>>>>>>>>>>>>>>>>
82478>>>>>>>>>>>>>>>
82478>>>>>>>>>>>>>>>        Get SQL_USE_DATAFLEX_DATEFORMAT to iDateFormat
82479>>>>>>>>>>>>>>>        Set SQL_USE_DATAFLEX_DATEFORMAT to True
82480>>>>>>>>>>>>>>>        Clear iFileNum
82481>>>>>>>>>>>>>>>        For i from 0 to (SizeOfArray(tColumnMap.vResultColumn)-1)
82487>>>>>>>>>>>>>>>>
82487>>>>>>>>>>>>>>>            If (tColumnMap.vResultColumn[i] > -1) Begin
82489>>>>>>>>>>>>>>>                SQL_FETCH_COLUMN (i+1) into vFieldValue
82518>>>>>>>>>>>>>>>                Set_Field_Value iFileNum (tColumnMap.vResultColumn[i]) to vFieldValue
82521>>>>>>>>>>>>>>>            End
82521>>>>>>>>>>>>>>>>
82521>>>>>>>>>>>>>>>        Loop
82522>>>>>>>>>>>>>>>>
82522>>>>>>>>>>>>>>>        Set_Attribute DF_FILE_STATUS of iFileNum to DF_FILE_ACTIVE
82525>>>>>>>>>>>>>>>        Set SQL_USE_DATAFLEX_DATEFORMAT to iDateFormat
82526>>>>>>>>>>>>>>>    End_Procedure
82527>>>>>>>>>>>>>>>
82527>>>>>>>>>>>>>>>    Function SQLGetData Integer iCol Integer iLen Returns String
82529>>>>>>>>>>>>>>>        String data
82529>>>>>>>>>>>>>>>        Integer retlen
82529>>>>>>>>>>>>>>>
82529>>>>>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
82567>>>>>>>>>>>>>>>>
82567>>>>>>>>>>>>>>>
82567>>>>>>>>>>>>>>>        SQL_SET_CHUNK_SIZE to iLen
82608>>>>>>>>>>>>>>>>
82608>>>>>>>>>>>>>>>        SQL_GET_DATA_CHUNK COLUMN iCol OFFSET (piDataChunkOffset(Self)) to data retlen
82642>>>>>>>>>>>>>>>>
82642>>>>>>>>>>>>>>>        Set piDataChunkOffset to (piDataChunkOffset(Self)+retlen)
82643>>>>>>>>>>>>>>>
82643>>>>>>>>>>>>>>>        Function_Return data
82644>>>>>>>>>>>>>>>    End_Function
82645>>>>>>>>>>>>>>>
82645>>>>>>>>>>>>>>>    Function SQLColumnMap String sColname Returns Integer
82647>>>>>>>>>>>>>>>        Integer iNumColumns i iIndex
82647>>>>>>>>>>>>>>>        String[] cols
82648>>>>>>>>>>>>>>>
82648>>>>>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
82686>>>>>>>>>>>>>>>>
82686>>>>>>>>>>>>>>>
82686>>>>>>>>>>>>>>>        Get SQLStmtAttribute SQLSTMTATTRIB_COLUMNCOUNT to iNumColumns
82687>>>>>>>>>>>>>>>
82687>>>>>>>>>>>>>>>        For i from 1 to iNumColumns
82693>>>>>>>>>>>>>>>>
82693>>>>>>>>>>>>>>>            SQL_GET_COL_NAME i to cols[i-1]
82733>>>>>>>>>>>>>>>>
82733>>>>>>>>>>>>>>>            Move (trim(Uppercase(cols[i-1]))) to cols[i-1]
82734>>>>>>>>>>>>>>>        Loop
82735>>>>>>>>>>>>>>>>
82735>>>>>>>>>>>>>>>
82735>>>>>>>>>>>>>>>        Move (trim(Uppercase(sColname))) to sColname
82736>>>>>>>>>>>>>>>        Move (SearchArray(sColname, cols)) to iIndex
82737>>>>>>>>>>>>>>>        Function_Return (iIndex+1)  // even if searcharray returns -1 (not found) this expects 0 for not found, so it's ok
82738>>>>>>>>>>>>>>>    End_Function
82739>>>>>>>>>>>>>>>
82739>>>>>>>>>>>>>>>    Function SQLStmtAttribute Integer iAttribId Returns String
82741>>>>>>>>>>>>>>>        Integer iCnt
82741>>>>>>>>>>>>>>>
82741>>>>>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
82779>>>>>>>>>>>>>>>>
82779>>>>>>>>>>>>>>>
82779>>>>>>>>>>>>>>>        Case Begin
82779>>>>>>>>>>>>>>>            Case (iAttribId = SQLSTMTATTRIB_COLUMNCOUNT)
82781>>>>>>>>>>>>>>>                SQL_GET_NUM_COLS to iCnt
82815>>>>>>>>>>>>>>>>
82815>>>>>>>>>>>>>>>                Function_Return iCnt
82816>>>>>>>>>>>>>>>                Case Break
82817>>>>>>>>>>>>>>>            Case (iAttribId = SQLSTMTATTRIB_ROWCOUNT)
82820>>>>>>>>>>>>>>>                SQL_GET_NUM_ROWS to iCnt
82854>>>>>>>>>>>>>>>>
82854>>>>>>>>>>>>>>>
82854>>>>>>>>>>>>>>>                //DAC Driver doesn't know the rowcount before the first fetch.
82854>>>>>>>>>>>>>>>                If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
82856>>>>>>>>>>>>>>>                    If (pisBeforeFetch(Self)) Begin
82858>>>>>>>>>>>>>>>                        Function_Return -1
82859>>>>>>>>>>>>>>>                    End
82859>>>>>>>>>>>>>>>>
82859>>>>>>>>>>>>>>>                End
82859>>>>>>>>>>>>>>>>
82859>>>>>>>>>>>>>>>
82859>>>>>>>>>>>>>>>                Function_Return iCnt
82860>>>>>>>>>>>>>>>                Case Break
82861>>>>>>>>>>>>>>>            Case (iAttribId = SQLSTMTATTRIB_ROWCOUNT_TYPE)
82864>>>>>>>>>>>>>>>                // TODO: Need something to indicate the quality of the SQL_GET_NUM_ROWS, or fake till I make it
82864>>>>>>>>>>>>>>>                Case Break
82865>>>>>>>>>>>>>>>            Case (iAttribId = SQLSTMTATTRIB_NUMMESSAGES)
82868>>>>>>>>>>>>>>>                Function_Return -1
82869>>>>>>>>>>>>>>>                // TODO: Are the messages returned in SQLGetMessage from the driver, or from the underlying connection?
82869>>>>>>>>>>>>>>>                Case Break
82870>>>>>>>>>>>>>>>            Case Else
82870>>>>>>>>>>>>>>>        Case End
82870>>>>>>>>>>>>>>>
82870>>>>>>>>>>>>>>>        Function_Return ""
82871>>>>>>>>>>>>>>>    End_Function
82872>>>>>>>>>>>>>>>
82872>>>>>>>>>>>>>>>    Function SQLColAttribute Integer iCol Integer iAttribId Returns String
82874>>>>>>>>>>>>>>>        String sValue
82874>>>>>>>>>>>>>>>        Integer iSQLType
82874>>>>>>>>>>>>>>>        Integer iDFType
82874>>>>>>>>>>>>>>>
82874>>>>>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
82912>>>>>>>>>>>>>>>>
82912>>>>>>>>>>>>>>>        SQL_GET_COL_ATTRIBUTE of iCol SQLTYPE to iSQLType
82953>>>>>>>>>>>>>>>>
82953>>>>>>>>>>>>>>>        SQL_GET_COL_ATTRIBUTE of iCol DFTYPE to iDFType
82994>>>>>>>>>>>>>>>>
82994>>>>>>>>>>>>>>>
82994>>>>>>>>>>>>>>>        Case Begin
82994>>>>>>>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_SIZE)
82996>>>>>>>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol SIZE to sValue
83037>>>>>>>>>>>>>>>>
83037>>>>>>>>>>>>>>>
83037>>>>>>>>>>>>>>>                //DAC Driver uses different values.
83037>>>>>>>>>>>>>>>                If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
83039>>>>>>>>>>>>>>>                    If (iSQLType=12) Begin
83041>>>>>>>>>>>>>>>                        Move (Integer(sValue-1)) to sValue
83042>>>>>>>>>>>>>>>                    End
83042>>>>>>>>>>>>>>>>
83042>>>>>>>>>>>>>>>                    If (iDFType=5) Begin
83044>>>>>>>>>>>>>>>                        Move "0" to sValue
83045>>>>>>>>>>>>>>>                    End
83045>>>>>>>>>>>>>>>>
83045>>>>>>>>>>>>>>>                    If (iSQLType=40) Begin
83047>>>>>>>>>>>>>>>                        Move "10" to sValue
83048>>>>>>>>>>>>>>>                    End
83048>>>>>>>>>>>>>>>>
83048>>>>>>>>>>>>>>>                End
83048>>>>>>>>>>>>>>>>
83048>>>>>>>>>>>>>>>
83048>>>>>>>>>>>>>>>                Case Break
83049>>>>>>>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_PRECISION)
83052>>>>>>>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol DECIMALS to sValue
83093>>>>>>>>>>>>>>>>
83093>>>>>>>>>>>>>>>                Case Break
83094>>>>>>>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_LABEL)
83097>>>>>>>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol COLUMN_NAME to sValue
83138>>>>>>>>>>>>>>>>
83138>>>>>>>>>>>>>>>                Case Break
83139>>>>>>>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_BASECOLUMNNAME)
83142>>>>>>>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol COLUMN_NAME to sValue
83183>>>>>>>>>>>>>>>>
83183>>>>>>>>>>>>>>>
83183>>>>>>>>>>>>>>>                //DAC Driver doesn't use Base Column Name.
83183>>>>>>>>>>>>>>>                If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
83185>>>>>>>>>>>>>>>                    Move "" to sValue
83186>>>>>>>>>>>>>>>                End
83186>>>>>>>>>>>>>>>>
83186>>>>>>>>>>>>>>>
83186>>>>>>>>>>>>>>>                Case Break
83187>>>>>>>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_BASETABLENAME)
83190>>>>>>>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol TABLE_NAME to sValue
83231>>>>>>>>>>>>>>>>
83231>>>>>>>>>>>>>>>                Case Break
83232>>>>>>>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_SQLTYPE)
83235>>>>>>>>>>>>>>>                Move iSQLType to sValue
83236>>>>>>>>>>>>>>>
83236>>>>>>>>>>>>>>>                //DAC Driver uses different values.
83236>>>>>>>>>>>>>>>                If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
83238>>>>>>>>>>>>>>>                    If (iSQLType=2) Begin
83240>>>>>>>>>>>>>>>                        Move "3" to sValue
83241>>>>>>>>>>>>>>>                    End
83241>>>>>>>>>>>>>>>>
83241>>>>>>>>>>>>>>>                    If (iSQLType=-99) Begin
83243>>>>>>>>>>>>>>>                        Move "12" to sValue
83244>>>>>>>>>>>>>>>                    End
83244>>>>>>>>>>>>>>>>
83244>>>>>>>>>>>>>>>                    If (iSQLType=40) Begin
83246>>>>>>>>>>>>>>>                        Move "91" to sValue
83247>>>>>>>>>>>>>>>                    End
83247>>>>>>>>>>>>>>>>
83247>>>>>>>>>>>>>>>                End
83247>>>>>>>>>>>>>>>>
83247>>>>>>>>>>>>>>>
83247>>>>>>>>>>>>>>>                Case Break
83248>>>>>>>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_NULLABLE)
83251>>>>>>>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol NULLABLE to sValue
83292>>>>>>>>>>>>>>>>
83292>>>>>>>>>>>>>>>                Case Break
83293>>>>>>>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_DFTYPE)
83296>>>>>>>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol DFTYPE to sValue
83337>>>>>>>>>>>>>>>>
83337>>>>>>>>>>>>>>>
83337>>>>>>>>>>>>>>>                //DAC Driver uses different values.
83337>>>>>>>>>>>>>>>                If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
83339>>>>>>>>>>>>>>>                    If (iDFType = 5) Begin
83341>>>>>>>>>>>>>>>                        Move "0" to sValue
83342>>>>>>>>>>>>>>>                    End
83342>>>>>>>>>>>>>>>>
83342>>>>>>>>>>>>>>>                End
83342>>>>>>>>>>>>>>>>
83342>>>>>>>>>>>>>>>                Case Break
83343>>>>>>>>>>>>>>>        Case End
83343>>>>>>>>>>>>>>>
83343>>>>>>>>>>>>>>>        Function_Return sValue
83344>>>>>>>>>>>>>>>    End_Function
83345>>>>>>>>>>>>>>>
83345>>>>>>>>>>>>>>>    Procedure SQLSetProcedureName String sProcName String sSchemaArg
83347>>>>>>>>>>>>>>>        Set psProcName to sProcName
83348>>>>>>>>>>>>>>>        If (Num_Arguments >= 2) ;            Set psSchemaName to sSchemaArg
83351>>>>>>>>>>>>>>>        Else ;            Set psSchemaName to ""
83353>>>>>>>>>>>>>>>    End_Procedure
83354>>>>>>>>>>>>>>>
83354>>>>>>>>>>>>>>>    Procedure SQLSetNextArgument String sArgument
83356>>>>>>>>>>>>>>>        Integer iArgnum
83356>>>>>>>>>>>>>>>
83356>>>>>>>>>>>>>>>        Get piLastArgument to iArgnum
83357>>>>>>>>>>>>>>>        Increment iArgnum
83358>>>>>>>>>>>>>>>        Send SQLSetArgument iArgnum sArgument
83359>>>>>>>>>>>>>>>        Set piLastArgument to iArgnum
83360>>>>>>>>>>>>>>>    End_Procedure
83361>>>>>>>>>>>>>>>
83361>>>>>>>>>>>>>>>    Procedure SQLSetArgument Integer iArgnum String sArgument
83363>>>>>>>>>>>>>>>        Variant[] vParams
83364>>>>>>>>>>>>>>>
83364>>>>>>>>>>>>>>>        Get pvParams to vParams
83365>>>>>>>>>>>>>>>        Move sArgument to vParams[iArgnum-1]
83366>>>>>>>>>>>>>>>        Set pvParams to vParams
83367>>>>>>>>>>>>>>>
83367>>>>>>>>>>>>>>>    End_Procedure
83368>>>>>>>>>>>>>>>
83368>>>>>>>>>>>>>>>    Procedure SQLCall
83370>>>>>>>>>>>>>>>        Variant[] vParams
83371>>>>>>>>>>>>>>>        Variant[] vParamOpts
83372>>>>>>>>>>>>>>>        Integer i
83372>>>>>>>>>>>>>>>        Integer iMax
83372>>>>>>>>>>>>>>>        Integer iParamsIn
83372>>>>>>>>>>>>>>>        String sParameter
83372>>>>>>>>>>>>>>>        Boolean bIsProcedure
83372>>>>>>>>>>>>>>>
83372>>>>>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
83410>>>>>>>>>>>>>>>>
83410>>>>>>>>>>>>>>>
83410>>>>>>>>>>>>>>>        Get pvParams to vParams
83411>>>>>>>>>>>>>>>
83411>>>>>>>>>>>>>>>        // First, we need to figure out if this is a procedure or a function. Then if
83411>>>>>>>>>>>>>>>        // it's a procedure, "analyze" it to figure out which parameters are IN,
83411>>>>>>>>>>>>>>>        // OUT, or IN_OUT.  Then we adjust how we call SQL_SET_PROCEDURE_PARAMETER
83411>>>>>>>>>>>>>>>        // so that after the call you can retrieve the value.
83411>>>>>>>>>>>>>>>
83411>>>>>>>>>>>>>>>        Get IsProcedure (psProcName(Self)) to bIsProcedure
83412>>>>>>>>>>>>>>>
83412>>>>>>>>>>>>>>>        If (bIsProcedure) Begin
83414>>>>>>>>>>>>>>>            Get ProcParams (psProcName(Self)) to vParamOpts
83415>>>>>>>>>>>>>>>
83415>>>>>>>>>>>>>>>            Move (sizeOfArray(vParamOpts)) to iMax
83416>>>>>>>>>>>>>>>            Move (SizeOfArray(vParams)) to iParamsIn
83417>>>>>>>>>>>>>>>            Set piParameterCount to iMax
83418>>>>>>>>>>>>>>>
83418>>>>>>>>>>>>>>>            SQL_SET_PROCEDURE_NAME (psProcName(Self)) NUMPAR iMax
83462>>>>>>>>>>>>>>>            For i from 1 to iMax
83468>>>>>>>>>>>>>>>>
83468>>>>>>>>>>>>>>>                If ( (i-1) >= iParamsIn) Begin
83470>>>>>>>>>>>>>>>                    Move "" to sParameter
83471>>>>>>>>>>>>>>>                End
83471>>>>>>>>>>>>>>>>
83471>>>>>>>>>>>>>>>                Else Begin
83472>>>>>>>>>>>>>>>                    Move vParams[i-1] to sParameter
83473>>>>>>>>>>>>>>>                End
83473>>>>>>>>>>>>>>>>
83473>>>>>>>>>>>>>>>
83473>>>>>>>>>>>>>>>                Case Begin
83473>>>>>>>>>>>>>>>                    Case (vParamOpts[i-1] = "IN")
83475>>>>>>>>>>>>>>>                        SQL_SET_PROCEDURE_PARAMETER i to sParameter IN
83512>>>>>>>>>>>>>>>>
83512>>>>>>>>>>>>>>>                        Case Break
83513>>>>>>>>>>>>>>>                    Case (vParamOpts[i-1] = "OUT")
83516>>>>>>>>>>>>>>>                        SQL_SET_PROCEDURE_PARAMETER i to sParameter OUT
83553>>>>>>>>>>>>>>>>
83553>>>>>>>>>>>>>>>                        Case Break
83554>>>>>>>>>>>>>>>                    Case (vParamOpts[i-1] = "IN/OUT" or vParamOpts[i-1] = "INOUT")
83557>>>>>>>>>>>>>>>                        SQL_SET_PROCEDURE_PARAMETER i to sParameter IN_OUT
83594>>>>>>>>>>>>>>>>
83594>>>>>>>>>>>>>>>                        Case Break
83595>>>>>>>>>>>>>>>                Case End
83595>>>>>>>>>>>>>>>            Loop
83596>>>>>>>>>>>>>>>>
83596>>>>>>>>>>>>>>>
83596>>>>>>>>>>>>>>>            SQL_PROCEDURE_EXECUTE
83636>>>>>>>>>>>>>>>        End
83636>>>>>>>>>>>>>>>>
83636>>>>>>>>>>>>>>>        Else Begin
83637>>>>>>>>>>>>>>>            SQL_SET_FUNCTION_NAME (psProcName(Self)) NUMPAR (SizeOfArray(vParams))
83685>>>>>>>>>>>>>>>            For i from 1 to (SizeOfArray(vParams))
83691>>>>>>>>>>>>>>>>
83691>>>>>>>>>>>>>>>                SQL_SET_FUNCTION_PARAMETER i to vParams[i-1]
83860>>>>>>>>>>>>>>>>
83860>>>>>>>>>>>>>>>            Loop
83861>>>>>>>>>>>>>>>>
83861>>>>>>>>>>>>>>>
83861>>>>>>>>>>>>>>>            SQL_FUNCTION_EXECUTE
83862>>>>>>>>>>>>>>>        End
83862>>>>>>>>>>>>>>>>
83862>>>>>>>>>>>>>>>    End_Procedure
83863>>>>>>>>>>>>>>>
83863>>>>>>>>>>>>>>>    Function SQLGetNextArgument Returns String
83865>>>>>>>>>>>>>>>        Integer iArgnum
83865>>>>>>>>>>>>>>>        String  sResult
83865>>>>>>>>>>>>>>>
83865>>>>>>>>>>>>>>>        Get piLastArgument to iArgnum
83866>>>>>>>>>>>>>>>        Increment iArgnum
83867>>>>>>>>>>>>>>>        Get SQLGetArgument iArgnum to sResult
83868>>>>>>>>>>>>>>>        Set piLastArgument to iArgnum
83869>>>>>>>>>>>>>>>
83869>>>>>>>>>>>>>>>        Function_Return sResult
83870>>>>>>>>>>>>>>>    End_Function
83871>>>>>>>>>>>>>>>
83871>>>>>>>>>>>>>>>    Function SQLGetArgument Integer iArgnum Returns String
83873>>>>>>>>>>>>>>>        String retval
83873>>>>>>>>>>>>>>>
83873>>>>>>>>>>>>>>>        If ( (piParameterCount(Self)) < iArgnum) Begin
83875>>>>>>>>>>>>>>>            Function_Return ""
83876>>>>>>>>>>>>>>>        End
83876>>>>>>>>>>>>>>>>
83876>>>>>>>>>>>>>>>        SQL_GET_PROCEDURE_PARAMETER iArgnum to retval
83932>>>>>>>>>>>>>>>>
83932>>>>>>>>>>>>>>>
83932>>>>>>>>>>>>>>>        Function_Return retval
83933>>>>>>>>>>>>>>>    End_Function
83934>>>>>>>>>>>>>>>
83934>>>>>>>>>>>>>>>    Function SQLReturnValue Returns String
83936>>>>>>>>>>>>>>>        String retval
83936>>>>>>>>>>>>>>>
83936>>>>>>>>>>>>>>>        SQL_GET_FUNCTION_RETURN to retval
84024>>>>>>>>>>>>>>>        Function_Return retval
84025>>>>>>>>>>>>>>>    End_Function
84026>>>>>>>>>>>>>>>
84026>>>>>>>>>>>>>>>    Function SQLNextResultSet Returns Integer
84028>>>>>>>>>>>>>>>        SQL_NEXT_RESULT_SET
84064>>>>>>>>>>>>>>>
84064>>>>>>>>>>>>>>>        Function_Return (Found)
84065>>>>>>>>>>>>>>>    End_Function
84066>>>>>>>>>>>>>>>
84066>>>>>>>>>>>>>>>    Function SQLGetMessage Integer iMessageNum Returns String
84068>>>>>>>>>>>>>>>        // TODO
84068>>>>>>>>>>>>>>>        Function_Return ""
84069>>>>>>>>>>>>>>>    End_Function
84070>>>>>>>>>>>>>>>
84070>>>>>>>>>>>>>>>    Procedure SQLFetchActivatesBuffer Integer iFileNum Integer bState
84072>>>>>>>>>>>>>>>        // TODO
84072>>>>>>>>>>>>>>>    End_Procedure
84073>>>>>>>>>>>>>>>
84073>>>>>>>>>>>>>>>End_Class
84074>>>>>>>>>>>>>>>
84074>>>>>>>>>>>>>>>Class cSQLConnectionDUF is a cObject
84075>>>>>>>>>>>>>>>    Procedure Construct_Object
84077>>>>>>>>>>>>>>>        Forward Send Construct_Object
84079>>>>>>>>>>>>>>>
84079>>>>>>>>>>>>>>>        Property Handle phCLIHandle 0
84080>>>>>>>>>>>>>>>        Property String psDriverID MertechInc_DriverName
84081>>>>>>>>>>>>>>>        Property Integer piBindFile 0
84082>>>>>>>>>>>>>>>        Property String psUsername ""
84083>>>>>>>>>>>>>>>        Property String psPassword ""
84084>>>>>>>>>>>>>>>
84084>>>>>>>>>>>>>>>        Property String psCurrentDatabase ""
84085>>>>>>>>>>>>>>>
84085>>>>>>>>>>>>>>>        Property tCLIHandleMap ptCLIHandleMap
84086>>>>>>>>>>>>>>>    End_Procedure
84087>>>>>>>>>>>>>>>
84087>>>>>>>>>>>>>>>    Procedure StoreHandleInfo Handle hCLIHandle String sDrvrId Handle iParentHandle
84089>>>>>>>>>>>>>>>        Set phCLIHandle      to hCLIHandle
84090>>>>>>>>>>>>>>>        Set psDriverID       to sDrvrId
84091>>>>>>>>>>>>>>>    End_Procedure
84092>>>>>>>>>>>>>>>
84092>>>>>>>>>>>>>>>    Procedure FreeHandle
84094>>>>>>>>>>>>>>>        Send Destroy
84095>>>>>>>>>>>>>>>    End_Procedure
84096>>>>>>>>>>>>>>>
84096>>>>>>>>>>>>>>>    Procedure Set SQLDatabase String sDatabase
84098>>>>>>>>>>>>>>>        tCLIHandleMap conn
84098>>>>>>>>>>>>>>>        tCLIHandleMap conn
84098>>>>>>>>>>>>>>>
84098>>>>>>>>>>>>>>>        Get ptCLIHandleMap to conn
84099>>>>>>>>>>>>>>>        Set psCurrentDatabase to sDatabase
84100>>>>>>>>>>>>>>>        SQL_USE_DATABASE of conn.sConnect to sDatabase
84138>>>>>>>>>>>>>>>>
84138>>>>>>>>>>>>>>>    End_Procedure
84139>>>>>>>>>>>>>>>
84139>>>>>>>>>>>>>>>    Function SQLConnect String sDriver String sConnect Returns Handle
84141>>>>>>>>>>>>>>>        tCLIHandleMap[] maps
84141>>>>>>>>>>>>>>>        tCLIHandleMap[] maps
84142>>>>>>>>>>>>>>>        tCLIHandleMap conn
84142>>>>>>>>>>>>>>>        tCLIHandleMap conn
84142>>>>>>>>>>>>>>>
84142>>>>>>>>>>>>>>>        Get ptCLIHandleMaps to maps
84143>>>>>>>>>>>>>>>        Move sDriver to conn.sDriver
84144>>>>>>>>>>>>>>>        Move sConnect to conn.sConnect
84145>>>>>>>>>>>>>>>
84145>>>>>>>>>>>>>>>        If (SizeOfArray(maps) > 0) Begin
84147>>>>>>>>>>>>>>>            Move (maps[(SizeOfArray(maps)-1)].iHdbc+1) to conn.iHdbc
84148>>>>>>>>>>>>>>>        End
84148>>>>>>>>>>>>>>>>
84148>>>>>>>>>>>>>>>        Else Begin
84149>>>>>>>>>>>>>>>            Move 1 to conn.iHdbc
84150>>>>>>>>>>>>>>>        End
84150>>>>>>>>>>>>>>>>
84150>>>>>>>>>>>>>>>
84150>>>>>>>>>>>>>>>        Set CurrentConnection to sDriver sConnect
84151>>>>>>>>>>>>>>>        If (not(Err)) Begin
84153>>>>>>>>>>>>>>>            Move conn to maps[(SizeOfArray(maps))]
84154>>>>>>>>>>>>>>>            Set ptCLIHandleMaps to maps
84155>>>>>>>>>>>>>>>            Set ptCLIHandleMap to conn
84156>>>>>>>>>>>>>>>        End
84156>>>>>>>>>>>>>>>>
84156>>>>>>>>>>>>>>>
84156>>>>>>>>>>>>>>>        Function_Return Self
84157>>>>>>>>>>>>>>>    End_Function
84158>>>>>>>>>>>>>>>
84158>>>>>>>>>>>>>>>    Function SQLFileConnect Integer iFileNum Returns Integer
84160>>>>>>>>>>>>>>>        Boolean bIsOpen
84160>>>>>>>>>>>>>>>        String sDriver sServer
84160>>>>>>>>>>>>>>>        tCLIHandleMap[] maps
84160>>>>>>>>>>>>>>>        tCLIHandleMap[] maps
84161>>>>>>>>>>>>>>>        tCLIHandleMap conn
84161>>>>>>>>>>>>>>>        tCLIHandleMap conn
84161>>>>>>>>>>>>>>>
84161>>>>>>>>>>>>>>>        Get_Attribute DF_FILE_OPENED of iFileNum to bIsOpen
84164>>>>>>>>>>>>>>>        If (bIsOpen) Begin
84166>>>>>>>>>>>>>>>            //*** Fill the driver id, assume longest is 255 characters
84166>>>>>>>>>>>>>>>            Move (Repeat(' ', 255)) to sDriver
84167>>>>>>>>>>>>>>>            Move (Repeat(' ', 255)) to sServer
84168>>>>>>>>>>>>>>>            Get_Attribute DF_FILE_DRIVER of iFileNum to sDriver
84171>>>>>>>>>>>>>>>            Get_Attribute DF_FILE_SERVER_NAME of iFileNum to sServer
84174>>>>>>>>>>>>>>>
84174>>>>>>>>>>>>>>>            Indicate Err False
84175>>>>>>>>>>>>>>>
84175>>>>>>>>>>>>>>>            Get ptCLIHandleMaps to maps
84176>>>>>>>>>>>>>>>            Move sDriver to conn.sDriver
84177>>>>>>>>>>>>>>>            Move sServer to conn.sConnect
84178>>>>>>>>>>>>>>>
84178>>>>>>>>>>>>>>>            If (SizeOfArray(maps) > 0) Begin
84180>>>>>>>>>>>>>>>                Move (maps[(SizeOfArray(maps)-1)].iHdbc+1) to conn.iHdbc
84181>>>>>>>>>>>>>>>            End
84181>>>>>>>>>>>>>>>>
84181>>>>>>>>>>>>>>>            Else Begin
84182>>>>>>>>>>>>>>>                Move 1 to conn.iHdbc
84183>>>>>>>>>>>>>>>            End
84183>>>>>>>>>>>>>>>>
84183>>>>>>>>>>>>>>>
84183>>>>>>>>>>>>>>>            Set CurrentConnection to sDriver sServer
84184>>>>>>>>>>>>>>>            If (not(Err)) Begin
84186>>>>>>>>>>>>>>>                Move conn to maps[(SizeOfArray(maps))]
84187>>>>>>>>>>>>>>>                Set ptCLIHandleMaps to maps
84188>>>>>>>>>>>>>>>                Set ptCLIHandleMap to conn
84189>>>>>>>>>>>>>>>            End
84189>>>>>>>>>>>>>>>>
84189>>>>>>>>>>>>>>>
84189>>>>>>>>>>>>>>>            Send StoreHandleInfo conn.iHdbc conn.sDriver
84190>>>>>>>>>>>>>>>            Set piBindFile to iFileNum
84191>>>>>>>>>>>>>>>        End
84191>>>>>>>>>>>>>>>>
84191>>>>>>>>>>>>>>>        Else Begin
84192>>>>>>>>>>>>>>>            Error 4099 "File Not Open"
84193>>>>>>>>>>>>>>>>
84193>>>>>>>>>>>>>>>        End
84193>>>>>>>>>>>>>>>>
84193>>>>>>>>>>>>>>>
84193>>>>>>>>>>>>>>>        //*** Return success status
84193>>>>>>>>>>>>>>>        Function_Return (not(Err))
84194>>>>>>>>>>>>>>>    End_Function
84195>>>>>>>>>>>>>>>
84195>>>>>>>>>>>>>>>    Procedure SQLDisconnect
84197>>>>>>>>>>>>>>>        tCLIHandleMap map
84197>>>>>>>>>>>>>>>        tCLIHandleMap map
84197>>>>>>>>>>>>>>>        tCLIHandleMap[] maps
84197>>>>>>>>>>>>>>>        tCLIHandleMap[] maps
84198>>>>>>>>>>>>>>>        Integer iFound
84198>>>>>>>>>>>>>>>
84198>>>>>>>>>>>>>>>        Get ptCLIHandleMap to map
84199>>>>>>>>>>>>>>>        Get ptCLIHandleMaps to maps
84200>>>>>>>>>>>>>>>
84200>>>>>>>>>>>>>>>        Move (SearchArray(map, maps, Parent(Self), RefFunc(CompareMaps))) to iFound
84201>>>>>>>>>>>>>>>        If (iFound > -1) Begin
84203>>>>>>>>>>>>>>>            Send FreeHandle
84204>>>>>>>>>>>>>>>        End
84204>>>>>>>>>>>>>>>>
84204>>>>>>>>>>>>>>>    End_Procedure
84205>>>>>>>>>>>>>>>
84205>>>>>>>>>>>>>>>    Function CreateHandle Returns Integer
84207>>>>>>>>>>>>>>>        Handle hSQL
84207>>>>>>>>>>>>>>>        Integer iCursor
84207>>>>>>>>>>>>>>>
84207>>>>>>>>>>>>>>>        Get Create (RefClass(cSQLStatementDUF)) to hSQL
84208>>>>>>>>>>>>>>>
84208>>>>>>>>>>>>>>>        Set piBindFile of hSQL to (piBindFile(Current_object))
84209>>>>>>>>>>>>>>>
84209>>>>>>>>>>>>>>>        SQL_OPEN_CURSOR_STMT to iCursor
84247>>>>>>>>>>>>>>>>
84247>>>>>>>>>>>>>>>        Set piCursorNum of hSQL to iCursor
84248>>>>>>>>>>>>>>>
84248>>>>>>>>>>>>>>>        Function_Return hSQL
84249>>>>>>>>>>>>>>>    End_Function
84250>>>>>>>>>>>>>>>
84250>>>>>>>>>>>>>>>    Function SQLOpen Returns Integer
84252>>>>>>>>>>>>>>>        Handle hDFHandle
84252>>>>>>>>>>>>>>>
84252>>>>>>>>>>>>>>>        Get CreateHandle to hDFHandle
84253>>>>>>>>>>>>>>>
84253>>>>>>>>>>>>>>>        Send StoreHandleInfo to hDFHandle Self (psDriverID(Self))
84254>>>>>>>>>>>>>>>
84254>>>>>>>>>>>>>>>        Function_Return hDFHandle
84255>>>>>>>>>>>>>>>    End_Function
84256>>>>>>>>>>>>>>>
84256>>>>>>>>>>>>>>>    Function DriverIndex String sDriver Returns Integer
84258>>>>>>>>>>>>>>>        String sCurrentDriver
84258>>>>>>>>>>>>>>>        Integer iDriver
84258>>>>>>>>>>>>>>>        Integer iNumDrivers
84258>>>>>>>>>>>>>>>
84258>>>>>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumDrivers
84261>>>>>>>>>>>>>>>        For iDriver from 1 to iNumDrivers
84267>>>>>>>>>>>>>>>>
84267>>>>>>>>>>>>>>>          Get_Attribute DF_DRIVER_NAME of iDriver to sCurrentDriver
84270>>>>>>>>>>>>>>>          If (Uppercase(sDriver) = Uppercase(sCurrentDriver)) ;              Function_Return iDriver
84273>>>>>>>>>>>>>>>        Loop
84274>>>>>>>>>>>>>>>>
84274>>>>>>>>>>>>>>>        Function_Return 0
84275>>>>>>>>>>>>>>>    End_Function
84276>>>>>>>>>>>>>>>
84276>>>>>>>>>>>>>>>    Function FirstServerForDriverNo Integer iDriver Returns String
84278>>>>>>>>>>>>>>>        String sServer
84278>>>>>>>>>>>>>>>        Integer iNumServers
84278>>>>>>>>>>>>>>>        Integer iServer
84278>>>>>>>>>>>>>>>
84278>>>>>>>>>>>>>>>        If (iDriver <> 0) Begin
84280>>>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iNumServers
84283>>>>>>>>>>>>>>>            If (iNumServers<>0) Begin
84285>>>>>>>>>>>>>>>                Move 1 to iServer
84286>>>>>>>>>>>>>>>                Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iServer to sServer
84289>>>>>>>>>>>>>>>            End
84289>>>>>>>>>>>>>>>>
84289>>>>>>>>>>>>>>>        End
84289>>>>>>>>>>>>>>>>
84289>>>>>>>>>>>>>>>
84289>>>>>>>>>>>>>>>        Function_Return sServer
84290>>>>>>>>>>>>>>>    End_Function
84291>>>>>>>>>>>>>>>
84291>>>>>>>>>>>>>>>    Procedure Set CurrentConnection String sDriver String sServer
84293>>>>>>>>>>>>>>>        Integer iDriver
84293>>>>>>>>>>>>>>>        String sUsername
84293>>>>>>>>>>>>>>>        String sPassword
84293>>>>>>>>>>>>>>>
84293>>>>>>>>>>>>>>>        If (sDriver="") Begin
84295>>>>>>>>>>>>>>>            DO_GETFILENUMBER_DRIVERNAME 0
84321>>>>>>>>>>>>>>>>
84321>>>>>>>>>>>>>>>            Move MertechInc_DriverName to sDriver
84322>>>>>>>>>>>>>>>        End
84322>>>>>>>>>>>>>>>>
84322>>>>>>>>>>>>>>>
84322>>>>>>>>>>>>>>>        If ("MDSMYSQL|ORA_DRV|MDSPGSQL|SQL_DRV|MDS_DB2" contains Uppercase(Trim(sDriver))) Begin
84324>>>>>>>>>>>>>>>            Move (Uppercase(Trim(sDriver))) to MertechInc_DriverName
84325>>>>>>>>>>>>>>>
84325>>>>>>>>>>>>>>>            If (Trim(sDriver) <> "") Begin
84327>>>>>>>>>>>>>>>                Move (Uppercase(Trim(sDriver))) to MertechInc_CurrentDriver
84328>>>>>>>>>>>>>>>            End
84328>>>>>>>>>>>>>>>>
84328>>>>>>>>>>>>>>>            Else Begin
84329>>>>>>>>>>>>>>>                Move "" to MertechInc_CurrentDriver
84330>>>>>>>>>>>>>>>            End
84330>>>>>>>>>>>>>>>>
84330>>>>>>>>>>>>>>>
84330>>>>>>>>>>>>>>>            Get psUsername to sUsername
84331>>>>>>>>>>>>>>>            Get psPassword to sPassword
84332>>>>>>>>>>>>>>>
84332>>>>>>>>>>>>>>>            Get DriverIndex MertechInc_CurrentDriver to iDriver
84333>>>>>>>>>>>>>>>
84333>>>>>>>>>>>>>>>            If (sServer   = "") Begin
84335>>>>>>>>>>>>>>>                Get FirstServerForDriverNo iDriver to sServer
84336>>>>>>>>>>>>>>>            End
84336>>>>>>>>>>>>>>>>
84336>>>>>>>>>>>>>>>            If (sUsername = "") Begin
84338>>>>>>>>>>>>>>>                Get_Current_User_Name of sServer to sUsername
84377>>>>>>>>>>>>>>>>
84377>>>>>>>>>>>>>>>            End
84377>>>>>>>>>>>>>>>>
84377>>>>>>>>>>>>>>>            If (sPassword = "") Begin
84379>>>>>>>>>>>>>>>                Get_Current_User_Password of sServer to sPassword
84418>>>>>>>>>>>>>>>>
84418>>>>>>>>>>>>>>>            End
84418>>>>>>>>>>>>>>>>
84418>>>>>>>>>>>>>>>
84418>>>>>>>>>>>>>>>            Move False to Err
84419>>>>>>>>>>>>>>>            Send Ignore_Error of Error_Object_Id 25000
84420>>>>>>>>>>>>>>>            Login sServer sUsername sPassword sDriver
84422>>>>>>>>>>>>>>>            Send Trap_Error of Error_Object_Id 25000
84423>>>>>>>>>>>>>>>
84423>>>>>>>>>>>>>>>            If (Err = False) Begin
84425>>>>>>>>>>>>>>>                Call_Driver 0 MertechInc_DriverName Function CALLDRV_CURRENT_SQL_SERVER_CONNECTION CALLBACK 0 PASSING sServer MertechInc_Blank 0 RESULT MertechInc_iRet
84430>>>>>>>>>>>>>>>            End
84430>>>>>>>>>>>>>>>>
84430>>>>>>>>>>>>>>>            Else Begin
84431>>>>>>>>>>>>>>>                Procedure_Return
84432>>>>>>>>>>>>>>>            End
84432>>>>>>>>>>>>>>>>
84432>>>>>>>>>>>>>>>
84432>>>>>>>>>>>>>>>            If (MertechInc_iRet = -1) Begin
84434>>>>>>>>>>>>>>>                Move True to Err
84435>>>>>>>>>>>>>>>            End
84435>>>>>>>>>>>>>>>>
84435>>>>>>>>>>>>>>>        End
84435>>>>>>>>>>>>>>>>
84435>>>>>>>>>>>>>>>        Else Begin
84436>>>>>>>>>>>>>>>            Error 4099 "Invalid Driver"
84437>>>>>>>>>>>>>>>>
84437>>>>>>>>>>>>>>>        End
84437>>>>>>>>>>>>>>>>
84437>>>>>>>>>>>>>>>
84437>>>>>>>>>>>>>>>    End_Procedure
84438>>>>>>>>>>>>>>>
84438>>>>>>>>>>>>>>>End_Class
84439>>>>>>>>>>>>>>>
84439>>>>>>>>>>>>>>>Class cSQLHandleManagerDUF is a cObject
84440>>>>>>>>>>>>>>>
84440>>>>>>>>>>>>>>>    Procedure Construct_Object
84442>>>>>>>>>>>>>>>        Forward Send Construct_Object
84444>>>>>>>>>>>>>>>
84444>>>>>>>>>>>>>>>        Property String  psDefaultDriver     ""
84445>>>>>>>>>>>>>>>        Property String  psDefaultConnection ""
84446>>>>>>>>>>>>>>>        Property tCLIHandleMap[] ptCLIHandleMaps
84447>>>>>>>>>>>>>>>    End_Procedure
84448>>>>>>>>>>>>>>>
84448>>>>>>>>>>>>>>>    Function CompareMaps tCLIHandleMap map1 tCLIHandleMap map2 Returns Integer
84450>>>>>>>>>>>>>>>        If ((map1.iHdbc = map2.iHdbc) and (map1.sConnect = map2.sConnect) and (map1.sDriver = map2.sDriver)) Begin
84452>>>>>>>>>>>>>>>            Function_Return (EQ)
84453>>>>>>>>>>>>>>>        End
84453>>>>>>>>>>>>>>>>
84453>>>>>>>>>>>>>>>        Function_Return (GT)
84454>>>>>>>>>>>>>>>    End_Function
84455>>>>>>>>>>>>>>>
84455>>>>>>>>>>>>>>>    Function CreateHandle Returns Handle
84457>>>>>>>>>>>>>>>        Handle hSQL
84457>>>>>>>>>>>>>>>
84457>>>>>>>>>>>>>>>        Get Create (RefClass(cSQLConnectionDUF)) to hSQL
84458>>>>>>>>>>>>>>>        Function_Return hSQL
84459>>>>>>>>>>>>>>>    End_Function
84460>>>>>>>>>>>>>>>
84460>>>>>>>>>>>>>>>    Procedure SQLSetConnect String sDriver String sConnect
84462>>>>>>>>>>>>>>>        Set psDefaultDriver to sDriver
84463>>>>>>>>>>>>>>>        Set psDefaultConnection to sConnect
84464>>>>>>>>>>>>>>>    End_Procedure
84465>>>>>>>>>>>>>>>
84465>>>>>>>>>>>>>>>    Function SQLConnect String sDriver String sConnect String sUID String sPWD Returns Handle
84467>>>>>>>>>>>>>>>        Handle hSql
84467>>>>>>>>>>>>>>>        Boolean bOK
84467>>>>>>>>>>>>>>>        String sServer sUsername sPassword
84467>>>>>>>>>>>>>>>
84467>>>>>>>>>>>>>>>        Get CreateHandle to hSql
84468>>>>>>>>>>>>>>>
84468>>>>>>>>>>>>>>>        If (sDriver = "" and sConnect = "") Begin
84470>>>>>>>>>>>>>>>            Get psDefaultDriver to sDriver
84471>>>>>>>>>>>>>>>            Get psDefaultConnection to sConnect
84472>>>>>>>>>>>>>>>        End
84472>>>>>>>>>>>>>>>>
84472>>>>>>>>>>>>>>>
84472>>>>>>>>>>>>>>>        If (num_arguments = 2) Begin
84474>>>>>>>>>>>>>>>            Get ParseKeyWord sConnect "SERVER"  to sServer
84475>>>>>>>>>>>>>>>            If (sServer = "") Begin
84477>>>>>>>>>>>>>>>                Get ParseKeyWord sConnect "DSN" to sServer
84478>>>>>>>>>>>>>>>            End
84478>>>>>>>>>>>>>>>>
84478>>>>>>>>>>>>>>>            Get ParseKeyWord sConnect "UID"     to sUsername
84479>>>>>>>>>>>>>>>            Get ParseKeyWord sConnect "PWD"     to sPassword
84480>>>>>>>>>>>>>>>        End
84480>>>>>>>>>>>>>>>>
84480>>>>>>>>>>>>>>>        Else Begin
84481>>>>>>>>>>>>>>>            Move sUID                           to sUsername
84482>>>>>>>>>>>>>>>            Move sPWD                           to sPassword
84483>>>>>>>>>>>>>>>        End
84483>>>>>>>>>>>>>>>>
84483>>>>>>>>>>>>>>>
84483>>>>>>>>>>>>>>>        Set psUsername of hSql to sUsername
84484>>>>>>>>>>>>>>>        Set psPassword of hSql to sPassword
84485>>>>>>>>>>>>>>>
84485>>>>>>>>>>>>>>>        Get SQLConnect of hSql sDriver sServer to bOK
84486>>>>>>>>>>>>>>>        If (not(bOK)) Begin
84488>>>>>>>>>>>>>>>            Send FreeHandle of hSQL
84489>>>>>>>>>>>>>>>            Function_Return 0
84490>>>>>>>>>>>>>>>        End
84490>>>>>>>>>>>>>>>>
84490>>>>>>>>>>>>>>>
84490>>>>>>>>>>>>>>>        Function_Return hSql
84491>>>>>>>>>>>>>>>    End_Function
84492>>>>>>>>>>>>>>>
84492>>>>>>>>>>>>>>>    Function SQLFileConnect Integer iFileNum Returns Integer
84494>>>>>>>>>>>>>>>        Handle hSql
84494>>>>>>>>>>>>>>>        Boolean bOK
84494>>>>>>>>>>>>>>>
84494>>>>>>>>>>>>>>>        //*** Allocate a new handle
84494>>>>>>>>>>>>>>>        Get CreateHandle to hSql
84495>>>>>>>>>>>>>>>        Get SQLFileConnect of hSql iFileNum to bOK
84496>>>>>>>>>>>>>>>
84496>>>>>>>>>>>>>>>        //*** If failure, kill the handle and return a 0 handle
84496>>>>>>>>>>>>>>>        If (not(bOK)) Begin
84498>>>>>>>>>>>>>>>            Send FreeHandle of hSql
84499>>>>>>>>>>>>>>>            Function_Return 0
84500>>>>>>>>>>>>>>>        End
84500>>>>>>>>>>>>>>>>
84500>>>>>>>>>>>>>>>
84500>>>>>>>>>>>>>>>        Function_Return hSql
84501>>>>>>>>>>>>>>>    End_Function
84502>>>>>>>>>>>>>>>
84502>>>>>>>>>>>>>>>End_Class
84503>>>>>>>>>>>>>>>
84503>>>>>>>>>>>>>>>
84503>>>>>>>>>>>>>>>Function CreateSQLmanager for cDesktop Returns Integer
84505>>>>>>>>>>>>>>>    Handle hSqlManager
84505>>>>>>>>>>>>>>>
84505>>>>>>>>>>>>>>>    Get Create (RefClass(cSQLHandleManagerDUF)) to hSqlManager
84506>>>>>>>>>>>>>>>    Function_Return hSqlManager
84507>>>>>>>>>>>>>>>End_Function
84508>>>>>>>>>>>>>>>
84508>>>>>>>>>>>>>>>
84508>>>>>>>>>>>>>>>
84508>>>>>>>>>>>>>>>
84508>>>>>>>>>>>>>>>Get CreateSQLManager of Desktop to _embsqlghoSQLHandleMngr
84509>>>>>>>>>>>>>>>
84509>>>>>>>>>>>>>    Use Mertech.inc
84509>>>>>>>>>>>>>
84509>>>>>>>>>>>>>Use cDbUpdateFunctionLibrary.inc
Including file: cDbUpdateFunctionLibrary.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary.inc)
84509>>>>>>>>>>>>>>>Use DUFLanguageConstants.inc
84509>>>>>>>>>>>>>>>
84509>>>>>>>>>>>>>>>Register_Function paSQLQueryMessages Returns String[]
84509>>>>>>>>>>>>>>>Register_Procedure Set paSQLQueryMessages String[] aSQLQueryMessages
84509>>>>>>>>>>>>>>>
84509>>>>>>>>>>>>>>>
84509>>>>>>>>>>>>>>>
84509>>>>>>>>>>>>>>>    Define CS_OEM_Txt for "OEM"
84509>>>>>>>>>>>>>>>
84509>>>>>>>>>>>>>>>    Define CS_ANSI_Txt for "ANSI"
84509>>>>>>>>>>>>>>>
84509>>>>>>>>>>>>>>>    Define CS_DFCONNID for "DFCONNID"
84509>>>>>>>>>>>>>>>
84509>>>>>>>>>>>>>>>    Define CS_SERVER for "SERVER"
84509>>>>>>>>>>>>>>>
84509>>>>>>>>>>>>>>>    Define CS_SERVER_NAME for "SERVER_NAME"
84509>>>>>>>>>>>>>>>
84509>>>>>>>>>>>>>>>    Define CS_DRIVER_NAME for "DRIVER_NAME"
84509>>>>>>>>>>>>>>>
84509>>>>>>>>>>>>>>>    Define CS_DATABASE_NAME for "DATABASE_NAME"
84509>>>>>>>>>>>>>>>
84509>>>>>>>>>>>>>>>    Define CS_SCHEMA_NAME for "SCHEMA_NAME"
84509>>>>>>>>>>>>>>>
84509>>>>>>>>>>>>>>>    Define CS_TABLE_CHARACTER_FORMAT for "TABLE_CHARACTER_FORMAT"
84509>>>>>>>>>>>>>>>
84509>>>>>>>>>>>>>>>    Define CS_USE_DUMMY_ZERO_DATE for "USE_DUMMY_ZERO_DATE"
84509>>>>>>>>>>>>>>>
84509>>>>>>>>>>>>>>>    Define CS_SYSTEM_FILE for "SYSTEM_FILE"
84509>>>>>>>>>>>>>>>
84509>>>>>>>>>>>>>>>    Define CS_RECNUM_TABLE for "RECNUM_TABLE"
84509>>>>>>>>>>>>>>>
84509>>>>>>>>>>>>>>>    Define CS_PRIMARY_INDEX for "PRIMARY_INDEX"
84509>>>>>>>>>>>>>>>
84509>>>>>>>>>>>>>>>    Define CS_INDEX_NUMBER for "INDEX_NUMBER"
84509>>>>>>>>>>>>>>>
84509>>>>>>>>>>>>>>>    Define CS_INDEX_NAME for "INDEX_NAME"
84509>>>>>>>>>>>>>>>
84509>>>>>>>>>>>>>>>    Define CS_DUFLowestAllowedDateValue for "01/01/1753"
84509>>>>>>>>>>>>>>>    Define CS_DUFLowestSQLDateValue     for "1753-01-01"
84509>>>>>>>>>>>>>>>
84509>>>>>>>>>>>>>>>    Define CS_DUFBackupDataFolder for "BackupData"
84509>>>>>>>>>>>>>>>
84509>>>>>>>>>>>>>>>// Global handle to a cDatabaseUpdateHandler object
84509>>>>>>>>>>>>>>>
84509>>>>>>>>>>>>>>>    Global_Variable Handle ghoDbUpdateFunctionLibrary  
84509>>>>>>>>>>>>>>>    Move 0 to ghoDbUpdateFunctionLibrary
84510>>>>>>>>>>>>>>>
84510>>>>>>>>>>>>>>>Struct tSQLScriptArray
84510>>>>>>>>>>>>>>>    Boolean bError
84510>>>>>>>>>>>>>>>    Boolean bArgumentSizeChanged
84510>>>>>>>>>>>>>>>    Integer iOrgArgumentSize
84510>>>>>>>>>>>>>>>    String[] sSQLScriptArray
84510>>>>>>>>>>>>>>>End_Struct
84510>>>>>>>>>>>>>>>
84510>>>>>>>>>>>>>>>Struct tSqlErrorArray
84510>>>>>>>>>>>>>>>    String[]  sSqlErrorArray
84510>>>>>>>>>>>>>>>    String[]  sSqlStatementArray
84510>>>>>>>>>>>>>>>    Integer[] iSqlErrorArray
84510>>>>>>>>>>>>>>>End_Struct
84510>>>>>>>>>>>>>>>
84510>>>>>>>>>>>>>>>Struct tSqlColumnNew
84510>>>>>>>>>>>>>>>    String  sBaseColumnName
84510>>>>>>>>>>>>>>>    String  sBaseTableName
84510>>>>>>>>>>>>>>>    String  sLabel
84510>>>>>>>>>>>>>>>    Integer iSqlType
84510>>>>>>>>>>>>>>>    Integer iSize
84510>>>>>>>>>>>>>>>    Integer iPrecision
84510>>>>>>>>>>>>>>>    Integer iDFType
84510>>>>>>>>>>>>>>>    Integer iDFNativeType
84510>>>>>>>>>>>>>>>End_Struct
84510>>>>>>>>>>>>>>>
84510>>>>>>>>>>>>>>>Struct tColumnType
84510>>>>>>>>>>>>>>>    String  sSQLType
84510>>>>>>>>>>>>>>>    Integer iSQLType
84510>>>>>>>>>>>>>>>    Boolean bCanEditSize
84510>>>>>>>>>>>>>>>    Integer iDefaultSize
84510>>>>>>>>>>>>>>>    Integer iMinSize
84510>>>>>>>>>>>>>>>    Number  nMaxSize
84510>>>>>>>>>>>>>>>    String  sDataFlexType
84510>>>>>>>>>>>>>>>    Integer iDataFlexType
84510>>>>>>>>>>>>>>>    Boolean bNativeDataType
84510>>>>>>>>>>>>>>>    String  sPrecision
84510>>>>>>>>>>>>>>>End_Struct
84510>>>>>>>>>>>>>>>
84510>>>>>>>>>>>>>>>// Used to store/retreive SQL keywords in a struct array.
84510>>>>>>>>>>>>>>>// Various SQL back-ends can have slightly different
84510>>>>>>>>>>>>>>>// keywords.
84510>>>>>>>>>>>>>>>Struct tSQLKeyWords
84510>>>>>>>>>>>>>>>    Integer iSQLWord
84510>>>>>>>>>>>>>>>    Integer iSQLDbType
84510>>>>>>>>>>>>>>>    String  sSQLPhrase // Can be more than one word.
84510>>>>>>>>>>>>>>>End_Struct
84510>>>>>>>>>>>>>>>
84510>>>>>>>>>>>>>>>Struct tSQLRelation
84510>>>>>>>>>>>>>>>    Integer iFileNumber
84510>>>>>>>>>>>>>>>    Integer iFieldNumber
84510>>>>>>>>>>>>>>>    String  sFileName
84510>>>>>>>>>>>>>>>    String  sFieldName
84510>>>>>>>>>>>>>>>End_Struct
84510>>>>>>>>>>>>>>>
84510>>>>>>>>>>>>>>>Struct tSQLLoggedInUser
84510>>>>>>>>>>>>>>>    String sUser
84510>>>>>>>>>>>>>>>    String sProgram
84510>>>>>>>>>>>>>>>End_Struct
84510>>>>>>>>>>>>>>>
84510>>>>>>>>>>>>>>>// Used as a start for error handing. Used by Error_Report_Mode property
84510>>>>>>>>>>>>>>>
84510>>>>>>>>>>>>>>>// We need to re-define the standard constants because several driver constants
84510>>>>>>>>>>>>>>>// have the same value and we need to be able to distinguish which data type to use when
84510>>>>>>>>>>>>>>>// SQL Back-ends (iSQLDbType in the tSQLKeywords struct).
84510>>>>>>>>>>>>>>>// They can have slightly different SQL keywords.
84510>>>>>>>>>>>>>>>// Note: If a new type is added to the list,
84510>>>>>>>>>>>>>>>//       the struct array xxx must be adjusted
84510>>>>>>>>>>>>>>>//       so that it is filled with all SQL
84510>>>>>>>>>>>>>>>//       keywords for that new type.
84510>>>>>>>>>>>>>>>Enum_List
84510>>>>>>>>>>>>>>>    Define EN_DbTypeDataFlex   for 0
84510>>>>>>>>>>>>>>>    Define EN_DbTypeMSSQL      for 1
84510>>>>>>>>>>>>>>>    Define EN_DbTypeMySQL      for 2
84510>>>>>>>>>>>>>>>    Define EN_DbTypeOracle     for 3
84510>>>>>>>>>>>>>>>    Define EN_DbTypeDB2        for 4
84510>>>>>>>>>>>>>>>    Define EN_DbTypePostgre    for 5
84510>>>>>>>>>>>>>>>    Define EN_DbTypePervasive  for 6
84510>>>>>>>>>>>>>>>//    Define EN_DbTypeMSSQL
84510>>>>>>>>>>>>>>>//    Define EN_DbTypeMySQL
84510>>>>>>>>>>>>>>>//    Define EN_DbTypeOracle
84510>>>>>>>>>>>>>>>//    Define EN_DbTypeDB2
84510>>>>>>>>>>>>>>>//    Define EN_DbTypePostgre
84510>>>>>>>>>>>>>>>//    Define EN_DbTypeDataFlex // Embedded database.
84510>>>>>>>>>>>>>>>End_Enum_List
84510>>>>>>>>>>>>>>>
84510>>>>>>>>>>>>>>>// We need to have our "own" constants for the standard DataFlex data types.
84510>>>>>>>>>>>>>>>// These can be used with SQL functions such as e.g. SQLColumnAdd, instead
84510>>>>>>>>>>>>>>>// of using one of the driver specific integer constants such as e.g. "SQL_VARCHAR".
84510>>>>>>>>>>>>>>>Define CS_DbTypeMSSQL       for "Microsoft SQL Server"
84510>>>>>>>>>>>>>>>Define CS_DbTypeMySQL       for "MySQL"
84510>>>>>>>>>>>>>>>Define CS_DbTypeOracle      for "Oracle"
84510>>>>>>>>>>>>>>>Define CS_DbTypeDB2         for "IBM DB2"
84510>>>>>>>>>>>>>>>Define CS_DbTypePostgre     for "PostgreSQL"
84510>>>>>>>>>>>>>>>Define CS_DbTypeDataFlex    for "DataFlex Embedded"
84510>>>>>>>>>>>>>>>
84510>>>>>>>>>>>>>>>// We need to re-define the standard constants because several driver constants
84510>>>>>>>>>>>>>>>// have the same value and we need to be able to distinguish which data type to use when
84510>>>>>>>>>>>>>>>// e.g. creating a column with embedded SQL (ESQL).
84510>>>>>>>>>>>>>>>Enum_List
84510>>>>>>>>>>>>>>>    Define DF_ASCII_DUF     for -1500 // All of these are DF_xxx constant values - 1500
84510>>>>>>>>>>>>>>>    Define DF_BCD_DUF       for -1499
84510>>>>>>>>>>>>>>>    Define DF_DATE_DUF      for -1498
84510>>>>>>>>>>>>>>>    Define DF_TEXT_DUF      for -1495
84510>>>>>>>>>>>>>>>    Define DF_BINARY_DUF    for -1494
84510>>>>>>>>>>>>>>>    Define DF_DATETIME_DUF  for -1493
84510>>>>>>>>>>>>>>>End_Enum_List
84510>>>>>>>>>>>>>>>
84510>>>>>>>>>>>>>>>    Define SQL_TEXT for (DF_TEXT + 1024)
84510>>>>>>>>>>>>>>>
84510>>>>>>>>>>>>>>>Define SQL_CHARBIT          for (DF_BINARY + 1024)
84510>>>>>>>>>>>>>>>Define SQL_LONGVARCHARBIT   for (DF_BINARY + 1025)
84510>>>>>>>>>>>>>>>Define SQL_VARCHARBIT       for (DF_BINARY + 1026)
84510>>>>>>>>>>>>>>>
84510>>>>>>>>>>>>>>>// These are not defined pre DF 18:
84510>>>>>>>>>>>>>>>
84510>>>>>>>>>>>>>>>Struct tSQLIntTableInfo
84510>>>>>>>>>>>>>>>    String sDriverName
84510>>>>>>>>>>>>>>>    String sServerName
84510>>>>>>>>>>>>>>>    String sDatabaseName
84510>>>>>>>>>>>>>>>    String sSchemaName
84510>>>>>>>>>>>>>>>    Boolean bRecnumTable
84510>>>>>>>>>>>>>>>    Integer iPrimaryIndex
84510>>>>>>>>>>>>>>>    Integer iGenerateRecordIdMethod  // RIM_NONE, RIM_IDENTITY_COLUMN,  RIM_DISPENSER_TABLE, RIM_EXTERNAL
84510>>>>>>>>>>>>>>>    String sTableCharacterFormat
84510>>>>>>>>>>>>>>>    Boolean bUseDummyZeroDate
84510>>>>>>>>>>>>>>>    Integer iFileDummyUpdateColumn // Init value to -1 if not exists (value can be in range 1 - number of columns)
84510>>>>>>>>>>>>>>>    Integer iFileBlockSize         // Init value to -1 if not exists
84510>>>>>>>>>>>>>>>    Integer iFileMaxRowsFetched    // Init value to -1 if not exists
84510>>>>>>>>>>>>>>>    Integer iFileGetRidAfterCreate // Init value to -1. But is boolean!
84510>>>>>>>>>>>>>>>    Integer iFileJitBinding        // Init value to -1. But is boolean!
84510>>>>>>>>>>>>>>>    String sRefindAfterSave        // Yes or No (how to handle?)
84510>>>>>>>>>>>>>>>    String sSystemFile             // Yes or No (how to handle?)
84510>>>>>>>>>>>>>>>    String sFileIndexTablespace
84510>>>>>>>>>>>>>>>    String sFileLongTablespace
84510>>>>>>>>>>>>>>>    String sTableTablespace
84510>>>>>>>>>>>>>>>End_Struct
84510>>>>>>>>>>>>>>>
84510>>>>>>>>>>>>>>>Struct tSQLIntColumnInfo
84510>>>>>>>>>>>>>>>    Integer iFieldNumber
84510>>>>>>>>>>>>>>>    Integer iFieldIndex
84510>>>>>>>>>>>>>>>    Integer iFieldRelatedFile
84510>>>>>>>>>>>>>>>    Integer iFieldRelatedField
84510>>>>>>>>>>>>>>>    Integer iIndexNumber
84510>>>>>>>>>>>>>>>    Integer iIndexNumberSegments
84510>>>>>>>>>>>>>>>    Integer iIndexSegmentField1
84510>>>>>>>>>>>>>>>    Integer iIndexSegmentField2
84510>>>>>>>>>>>>>>>    Integer iIndexSegmentFieldn
84510>>>>>>>>>>>>>>>    String  sIndexName
84510>>>>>>>>>>>>>>>End_Struct
84510>>>>>>>>>>>>>>>
84510>>>>>>>>>>>>>>>Struct tAPIColumn
84510>>>>>>>>>>>>>>>    Integer iFieldNumber
84510>>>>>>>>>>>>>>>    String  sFieldName
84510>>>>>>>>>>>>>>>    Integer iType
84510>>>>>>>>>>>>>>>    String  sType
84510>>>>>>>>>>>>>>>    Integer iLength
84510>>>>>>>>>>>>>>>    Integer iPrecision
84510>>>>>>>>>>>>>>>    Integer iOptions
84510>>>>>>>>>>>>>>>    Boolean bIsSQLType
84510>>>>>>>>>>>>>>>    Boolean bAllowNULL
84510>>>>>>>>>>>>>>>    String  sDefaultValue
84510>>>>>>>>>>>>>>>    Boolean bShouldChange
84510>>>>>>>>>>>>>>>    Boolean bCancel
84510>>>>>>>>>>>>>>>    Boolean bError
84510>>>>>>>>>>>>>>>End_Struct
84510>>>>>>>>>>>>>>>
84510>>>>>>>>>>>>>>>Struct tAPIColumnCompare
84510>>>>>>>>>>>>>>>    Integer iFieldNumber
84510>>>>>>>>>>>>>>>    // FROM database:
84510>>>>>>>>>>>>>>>    Boolean bExistsFrom
84510>>>>>>>>>>>>>>>    String  sFieldNameFrom
84510>>>>>>>>>>>>>>>    Integer iTypeFrom
84510>>>>>>>>>>>>>>>    String  sTypeFrom
84510>>>>>>>>>>>>>>>    Integer iLengthFrom
84510>>>>>>>>>>>>>>>    Integer iPrecisionFrom
84510>>>>>>>>>>>>>>>    Integer iOptionsFrom
84510>>>>>>>>>>>>>>>    Boolean bIsSQLTypeFrom
84510>>>>>>>>>>>>>>>    Boolean bAllowNULLFrom
84510>>>>>>>>>>>>>>>    String  sDefaultValueFrom
84510>>>>>>>>>>>>>>>    Boolean bShouldChangeFrom
84510>>>>>>>>>>>>>>>    Boolean bCancelFrom
84510>>>>>>>>>>>>>>>    Boolean bErrorFrom
84510>>>>>>>>>>>>>>>    // TO database:
84510>>>>>>>>>>>>>>>    Boolean bExistsTo
84510>>>>>>>>>>>>>>>    Integer iFieldNumberTo
84510>>>>>>>>>>>>>>>    String  sFieldNameTo
84510>>>>>>>>>>>>>>>    Integer iTypeTo
84510>>>>>>>>>>>>>>>    String  sTypeTo
84510>>>>>>>>>>>>>>>    Integer iLengthTo
84510>>>>>>>>>>>>>>>    Integer iPrecisionTo
84510>>>>>>>>>>>>>>>    Integer iOptionsTo
84510>>>>>>>>>>>>>>>    Boolean bIsSQLTypeTo
84510>>>>>>>>>>>>>>>    Boolean bAllowNULLTo
84510>>>>>>>>>>>>>>>    String  sDefaultValueTo
84510>>>>>>>>>>>>>>>    Boolean bShouldChangeTo
84510>>>>>>>>>>>>>>>    Boolean bCancelTo
84510>>>>>>>>>>>>>>>    Boolean bErrorTo
84510>>>>>>>>>>>>>>>End_Struct
84510>>>>>>>>>>>>>>>
84510>>>>>>>>>>>>>>>Struct tAPIRelation
84510>>>>>>>>>>>>>>>    Handle  hTableFrom
84510>>>>>>>>>>>>>>>    Integer iColumnFrom
84510>>>>>>>>>>>>>>>    Handle  hTableTo
84510>>>>>>>>>>>>>>>    Integer iColumnTo
84510>>>>>>>>>>>>>>>    String  sLogicalNameFrom
84510>>>>>>>>>>>>>>>    String  sLogicalNameTo
84510>>>>>>>>>>>>>>>    String  sFieldNameFrom
84510>>>>>>>>>>>>>>>    String  sFieldNameTo
84510>>>>>>>>>>>>>>>    Boolean bShouldChange
84510>>>>>>>>>>>>>>>    Boolean bCancel
84510>>>>>>>>>>>>>>>    Boolean bError
84510>>>>>>>>>>>>>>>End_Struct
84510>>>>>>>>>>>>>>>
84510>>>>>>>>>>>>>>>Struct tAPIRelationCompare
84510>>>>>>>>>>>>>>>    // Common:
84510>>>>>>>>>>>>>>>    Handle  hTableFrom
84510>>>>>>>>>>>>>>>    Integer iColumnFrom
84510>>>>>>>>>>>>>>>    Handle  hTableTo
84510>>>>>>>>>>>>>>>    Integer iColumnTo
84510>>>>>>>>>>>>>>>    // FROM database:
84510>>>>>>>>>>>>>>>    Boolean bExistsFrom
84510>>>>>>>>>>>>>>>    String  sLogicalNameFrom_From
84510>>>>>>>>>>>>>>>    String  sLogicalNameTo_From
84510>>>>>>>>>>>>>>>    String  sFieldNameFrom_From
84510>>>>>>>>>>>>>>>    String  sFieldNameTo_From
84510>>>>>>>>>>>>>>>    Boolean bShouldChange_From
84510>>>>>>>>>>>>>>>    Boolean bCancel_From
84510>>>>>>>>>>>>>>>    Boolean bError_From
84510>>>>>>>>>>>>>>>    // TO database:
84510>>>>>>>>>>>>>>>    Boolean bExistsTo
84510>>>>>>>>>>>>>>>    String  sLogicalNameFrom_To
84510>>>>>>>>>>>>>>>    String  sLogicalNameTo_To
84510>>>>>>>>>>>>>>>    String  sFieldNameFrom_To
84510>>>>>>>>>>>>>>>    String  sFieldNameTo_To
84510>>>>>>>>>>>>>>>    Boolean bShouldChange_To
84510>>>>>>>>>>>>>>>    Boolean bCancel_To
84510>>>>>>>>>>>>>>>    Boolean bError_To
84510>>>>>>>>>>>>>>>End_Struct
84510>>>>>>>>>>>>>>>
84510>>>>>>>>>>>>>>>Struct tAPIIndexSegment
84510>>>>>>>>>>>>>>>    Integer iFieldNumber
84510>>>>>>>>>>>>>>>    String  sFieldName
84510>>>>>>>>>>>>>>>    Boolean bUppercase
84510>>>>>>>>>>>>>>>    Boolean bAscending
84510>>>>>>>>>>>>>>>    Boolean bShouldChange
84510>>>>>>>>>>>>>>>    Boolean bCancel
84510>>>>>>>>>>>>>>>    Boolean bError
84510>>>>>>>>>>>>>>>End_Struct
84510>>>>>>>>>>>>>>>
84510>>>>>>>>>>>>>>>Struct tAPIIndex
84510>>>>>>>>>>>>>>>    Integer iIndexNumber
84510>>>>>>>>>>>>>>>    Integer iPrimaryIndex
84510>>>>>>>>>>>>>>>    String  sSQLIndexName
84510>>>>>>>>>>>>>>>    Integer iSQLIndexType
84510>>>>>>>>>>>>>>>    Boolean bIsSQLClustered
84510>>>>>>>>>>>>>>>    Boolean bIsSQLPrimaryKey
84510>>>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArray
84510>>>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArray
84510>>>>>>>>>>>>>>>    Boolean bShouldChange
84510>>>>>>>>>>>>>>>    Boolean bCancel
84510>>>>>>>>>>>>>>>    Boolean bError
84510>>>>>>>>>>>>>>>End_Struct
84510>>>>>>>>>>>>>>>
84510>>>>>>>>>>>>>>>Struct tAPIIndexCompare
84510>>>>>>>>>>>>>>>    // Common:
84510>>>>>>>>>>>>>>>    Integer iIndexNumber
84510>>>>>>>>>>>>>>>    // FROM database:
84510>>>>>>>>>>>>>>>    Boolean bExistsFrom
84510>>>>>>>>>>>>>>>    Integer iPrimaryIndexFrom
84510>>>>>>>>>>>>>>>    String  sSQLIndexNameFrom
84510>>>>>>>>>>>>>>>    Integer iSQLIndexTypeFrom
84510>>>>>>>>>>>>>>>    Boolean bIsSQLClusteredFrom
84510>>>>>>>>>>>>>>>    Boolean bIsSQLPrimaryKeyFrom
84510>>>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayFrom
84510>>>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayFrom
84510>>>>>>>>>>>>>>>    Boolean bShouldChangeFrom
84510>>>>>>>>>>>>>>>    Boolean bCancelFrom
84510>>>>>>>>>>>>>>>    Boolean bErrorFrom
84510>>>>>>>>>>>>>>>    // TO database:
84510>>>>>>>>>>>>>>>    Boolean bExistsTo
84510>>>>>>>>>>>>>>>    Integer iPrimaryIndexTo
84510>>>>>>>>>>>>>>>    String  sSQLIndexNameTo
84510>>>>>>>>>>>>>>>    Integer iSQLIndexTypeTo
84510>>>>>>>>>>>>>>>    Boolean bIsSQLClusteredTo
84510>>>>>>>>>>>>>>>    Boolean bIsSQLPrimaryKeyTo
84510>>>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayTo
84510>>>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayTo
84510>>>>>>>>>>>>>>>    Boolean bShouldChangeTo
84510>>>>>>>>>>>>>>>    Boolean bCancelTo
84510>>>>>>>>>>>>>>>    Boolean bErrorTo
84510>>>>>>>>>>>>>>>End_Struct
84510>>>>>>>>>>>>>>>
84510>>>>>>>>>>>>>>>Struct tAPITableNameInfo
84510>>>>>>>>>>>>>>>    Integer iTableNumber
84510>>>>>>>>>>>>>>>    String  sRootName
84510>>>>>>>>>>>>>>>    String  sLogicalName
84510>>>>>>>>>>>>>>>    String  sDisplayName
84510>>>>>>>>>>>>>>>    String  sDriverID
84510>>>>>>>>>>>>>>>    Boolean bIsAlias
84510>>>>>>>>>>>>>>>    Boolean bIsSQL
84510>>>>>>>>>>>>>>>    Boolean bIsSystemFile
84510>>>>>>>>>>>>>>>    Boolean bShouldChange
84510>>>>>>>>>>>>>>>    Boolean bCancel
84510>>>>>>>>>>>>>>>    Boolean bError
84510>>>>>>>>>>>>>>>End_Struct
84510>>>>>>>>>>>>>>>
84510>>>>>>>>>>>>>>>Struct tAPITableNameInfoCompare
84510>>>>>>>>>>>>>>>    Integer iTableNumber
84510>>>>>>>>>>>>>>>    // FROM
84510>>>>>>>>>>>>>>>    Boolean bExistsFrom
84510>>>>>>>>>>>>>>>    String  sRootNameFrom
84510>>>>>>>>>>>>>>>    String  sLogicalNameFrom
84510>>>>>>>>>>>>>>>    String  sDisplayNameFrom
84510>>>>>>>>>>>>>>>    String  sDriverIDFrom
84510>>>>>>>>>>>>>>>    Boolean bIsAliasFrom
84510>>>>>>>>>>>>>>>    Boolean bIsSQLFrom
84510>>>>>>>>>>>>>>>    Boolean bIsSystemFileFrom
84510>>>>>>>>>>>>>>>    // TO database:
84510>>>>>>>>>>>>>>>    Boolean bExistsTo
84510>>>>>>>>>>>>>>>    String  sRootNameTo
84510>>>>>>>>>>>>>>>    String  sLogicalNameTo
84510>>>>>>>>>>>>>>>    String  sDisplayNameTo
84510>>>>>>>>>>>>>>>    String  sDriverIDTo
84510>>>>>>>>>>>>>>>    Boolean bIsAliasTo
84510>>>>>>>>>>>>>>>    Boolean bIsSQLTo
84510>>>>>>>>>>>>>>>    Boolean bIsSystemFileTo // *** Implement!
84510>>>>>>>>>>>>>>>    Boolean bShouldChange
84510>>>>>>>>>>>>>>>    Boolean bCancel
84510>>>>>>>>>>>>>>>    Boolean bError
84510>>>>>>>>>>>>>>>End_Struct
84510>>>>>>>>>>>>>>>
84510>>>>>>>>>>>>>>>Struct tAPITable
84510>>>>>>>>>>>>>>>    Handle hTable
84510>>>>>>>>>>>>>>>    Boolean bFromTable
84510>>>>>>>>>>>>>>>    Boolean bToTable
84510>>>>>>>>>>>>>>>    tAPITableNameInfo ApiTableInfo
84510>>>>>>>>>>>>>>>    tAPITableNameInfo ApiTableInfo
84510>>>>>>>>>>>>>>>    tAPIColumn[]      aApiColumns
84510>>>>>>>>>>>>>>>    tAPIColumn[]      aApiColumns
84510>>>>>>>>>>>>>>>    tAPIIndex[]       aApiIndexes
84510>>>>>>>>>>>>>>>    tAPIIndex[]       aApiIndexes
84510>>>>>>>>>>>>>>>    tAPIRelation[]    aApiRelations
84510>>>>>>>>>>>>>>>    tAPIRelation[]    aApiRelations
84510>>>>>>>>>>>>>>>    Boolean bShouldChange
84510>>>>>>>>>>>>>>>    Boolean bCancel
84510>>>>>>>>>>>>>>>    Boolean bError
84510>>>>>>>>>>>>>>>End_Struct
84510>>>>>>>>>>>>>>>
84510>>>>>>>>>>>>>>>Struct tAPITableCompare
84510>>>>>>>>>>>>>>>    Handle hTable
84510>>>>>>>>>>>>>>>    // FROM database:
84510>>>>>>>>>>>>>>>    Boolean bExistsFrom
84510>>>>>>>>>>>>>>>    // TO database:
84510>>>>>>>>>>>>>>>    Boolean bExistsTo
84510>>>>>>>>>>>>>>>    // Both:
84510>>>>>>>>>>>>>>>    tAPITableNameInfoCompare APITableNameInfoCompare
84510>>>>>>>>>>>>>>>    tAPITableNameInfoCompare APITableNameInfoCompare
84510>>>>>>>>>>>>>>>    tAPIColumnCompare[]     aAPIColumnsCompare
84510>>>>>>>>>>>>>>>    tAPIColumnCompare[]     aAPIColumnsCompare
84510>>>>>>>>>>>>>>>    tAPIIndexCompare[]      aAPIIndexesCompare
84510>>>>>>>>>>>>>>>    tAPIIndexCompare[]      aAPIIndexesCompare
84510>>>>>>>>>>>>>>>    tAPIRelationCompare[]   aAPIRelationsCompare
84510>>>>>>>>>>>>>>>    tAPIRelationCompare[]   aAPIRelationsCompare
84510>>>>>>>>>>>>>>>    Boolean bShouldChange   // Not implemented yet (!)
84510>>>>>>>>>>>>>>>    Boolean bCancel         // User cancel
84510>>>>>>>>>>>>>>>    Boolean bError          // Error occured while collecting data
84510>>>>>>>>>>>>>>>End_Struct
84510>>>>>>>>>>>>>>>
84510>>>>>>>>>>>>>>>Struct tAPITableBooleans
84510>>>>>>>>>>>>>>>    Boolean bApiTableUpdateAuto
84510>>>>>>>>>>>>>>>    Boolean bCompareDate_DateTime
84510>>>>>>>>>>>>>>>    Boolean bCompareIndexAscending
84510>>>>>>>>>>>>>>>    Boolean bCompareIndexUppercase
84510>>>>>>>>>>>>>>>    Boolean bCompareFilelistUppercase
84510>>>>>>>>>>>>>>>End_Struct
84510>>>>>>>>>>>>>>>
84510>>>>>>>>>>>>>>>Define C_tAPIColumn_None for 0
84510>>>>>>>>>>>>>>>Define C_tAPIColumn_Identity for 1
84510>>>>>>>>>>>>>>>
84510>>>>>>>>>>>>>>>// SQL Key-Word Constants:  CI_SQLSelect CI_SQLName CI_SQLFrom  CI_SQLSys
84510>>>>>>>>>>>>>>>// Used by the _SqlFindKeyWord function to return a proper keyword depending on the backend SQL,
84510>>>>>>>>>>>>>>>// i.e. one of the EN_DbTypeXXX members from the Enum_list above.
84510>>>>>>>>>>>>>>>// E.g. the CI_SQLAlterTable is only defined once, but the _SqlFindKeyWord function can return
84510>>>>>>>>>>>>>>>// different wording content depending on the EN_xxx value also passed to the function.
84510>>>>>>>>>>>>>>>Enum_List
84510>>>>>>>>>>>>>>>    Define CI_SQLAlterDatabase         //for "ALTER DATABASE"
84510>>>>>>>>>>>>>>>    Define CI_SQLSingle_User           //for "SINGLE_USER"
84510>>>>>>>>>>>>>>>    Define CI_SQLMulti_User            //for "USER_USER"
84510>>>>>>>>>>>>>>>    Define CI_SQLRollback              //for "ROLLBACK"
84510>>>>>>>>>>>>>>>    Define CI_SQLIMMEDIATE             //for "IMMEDIATE"
84510>>>>>>>>>>>>>>>    Define CI_SQLAlterTable            //for "ALTER TABLE"
84510>>>>>>>>>>>>>>>    Define CI_SQLAlterColumn           //for "ALTER COLUMN"
84510>>>>>>>>>>>>>>>    Define CI_SQLRenameColumn          //for "RENAME COLUMN"
84510>>>>>>>>>>>>>>>    Define CI_SQLColumn                //for "COLUMN"
84510>>>>>>>>>>>>>>>    Define CI_SQLSelect                //for "SELECT"
84510>>>>>>>>>>>>>>>    Define CI_SQLWhere                 //for "WHERE"
84510>>>>>>>>>>>>>>>    Define CI_SQLInfoSchema            //for "INFORMATION_SCHEMA.COLUMNS"
84510>>>>>>>>>>>>>>>    Define CI_SQLTable_Name            //for "TABLE_NAME"
84510>>>>>>>>>>>>>>>    Define CI_SQLTable                 //for "TABLE"
84510>>>>>>>>>>>>>>>    Define CI_SQLSys                   //for "SYS"
84510>>>>>>>>>>>>>>>    Define CI_SQLSp_Help               //for "SP_HELP"
84510>>>>>>>>>>>>>>>    Define CI_SQLFrom                  //for "FROM"
84510>>>>>>>>>>>>>>>    Define CI_SQLAdd                   //for "ADD"
84510>>>>>>>>>>>>>>>    Define CI_SQLDropColumn            //for "DROP"
84510>>>>>>>>>>>>>>>    Define CI_SQLCreateDatabase        //for "CREATE DATABASE"
84510>>>>>>>>>>>>>>>    Define CI_SQLDatabaseCollation     //for "COLLATE"
84510>>>>>>>>>>>>>>>    Define CI_SQLCreateTable           //for "CREATE TABLE"
84510>>>>>>>>>>>>>>>    Define CI_SQLDropTable             //for "DROP TABLE"
84510>>>>>>>>>>>>>>>    Define CI_SQLCreateView            //for "CREATE VIEW"
84510>>>>>>>>>>>>>>>    Define CI_SQLRenameTable           //for "RENAME TABLE"
84510>>>>>>>>>>>>>>>//    Define CI_SQLSelectFromWhereName   //for "SELECT name from [master].[dbo].[sysdatabases] where name"
84510>>>>>>>>>>>>>>>    Define CI_SQLDropView              //for "DROP VIEW"
84510>>>>>>>>>>>>>>>    Define CI_SQLSetNoCountOn          //for "SET NOCOUNT ON"
84510>>>>>>>>>>>>>>>    Define CI_SQLTo                    //for "TO"
84510>>>>>>>>>>>>>>>    Define CI_SQLGO                    //for "GO"
84510>>>>>>>>>>>>>>>    Define CI_SQLUse                   //for "USE"
84510>>>>>>>>>>>>>>>    Define CI_SQLDBO                   //for "DBO"
84510>>>>>>>>>>>>>>>
84510>>>>>>>>>>>>>>>    Define CI_SQLName                  //for "NAME"
84510>>>>>>>>>>>>>>>    Define CI_SQLMaster                //for "MASTER"
84510>>>>>>>>>>>>>>>    Define CI_SQLDatabases             //for "DATABASES"
84510>>>>>>>>>>>>>>>    Define CI_SQLSysIndexes            //for "SYS.INDEXES"
84510>>>>>>>>>>>>>>>    Define CI_SQLObjectID              //for "OBJECT_ID"
84510>>>>>>>>>>>>>>>    Define CI_SQLID                    //for "ID"
84510>>>>>>>>>>>>>>>    Define CI_SQLAND                   //for "AND"
84510>>>>>>>>>>>>>>>    Define CI_SQLUpdate                //for "UPDATE"
84510>>>>>>>>>>>>>>>    Define CI_SQLSet                   //for "SET"
84510>>>>>>>>>>>>>>>    Define CI_SQLWith                  //for "WITH"
84510>>>>>>>>>>>>>>>    Define CI_SQLNotNull               //for "NOT NULL"
84510>>>>>>>>>>>>>>>    Define CI_SQL_SAFE_UPDATES         //for "SQL_SAFE_UPDATES"  
84510>>>>>>>>>>>>>>>    Define CI_SQLDescription          //for "SELECT name, description from sys.fn_helpcollations()" (Enumerates all collates)
84510>>>>>>>>>>>>>>>End_Enum_List
84510>>>>>>>>>>>>>>>
84510>>>>>>>>>>>>>>>
84510>>>>>>>>>>>
84510>>>>>>>>>>>// This needs to be after Mertech drivers are defined.
84510>>>>>>>>>>>//Use cDbUpdateFunctionLibrary_Mixin.pkg
84510>>>>>>>>>>>
84510>>>>>>>>>>>
84510>>>>>>>>>>>// Create a new PSQL identifier for the Btrieve driver.
84510>>>>>>>>>>>    Define PSQLDRV_ID for "DFBTRDRV"
84510>>>>>>>>>>>
84510>>>>>>>>>>>
84510>>>>>>>>>>>
84510>>>>>>>>>>>
84510>>>>>>>>>>>
84510>>>>>>>>>>>
84510>>>>>>>>>>>// SQL Back-ends (iSQLDbType in the tSQLKeywords struct).
84510>>>>>>>>>>>// They can have slightly different SQL keywords.
84510>>>>>>>>>>>// Note: If a new type is added to the list,
84510>>>>>>>>>>>//       the struct array xxx must be adjusted
84510>>>>>>>>>>>//       so that it is filled with all SQL
84510>>>>>>>>>>>//       keywords for that new type.
84510>>>>>>>>>>>Enum_List  
84510>>>>>>>>>>>End_Enum_List
84510>>>>>>>>>>>
84510>>>>>>>>>>>// We need to have our "own" constants for the standard DataFlex data types.
84510>>>>>>>>>>>// These can be used with SQL functions such as e.g. SQLColumnAdd, instead
84510>>>>>>>>>>>// of using one of the driver specific integer constants such as e.g. "SQL_VARCHAR".
84510>>>>>>>>>>>Define CS_DbTypeDataFlex    for "DataFlex Embedded"
84510>>>>>>>>>>>Define CS_DbTypeMSSQL       for "Microsoft SQL Server"
84510>>>>>>>>>>>Define CS_DbTypeMySQL       for "MySQL"
84510>>>>>>>>>>>Define CS_DbTypeOracle      for "Oracle"
84510>>>>>>>>>>>Define CS_DbTypeDB2         for "IBM DB2"
84510>>>>>>>>>>>Define CS_DbTypePostgre     for "PostgreSQL"
84510>>>>>>>>>>>Define CS_DbTypePervasive   for "Pervasive.SQL (Btrieve)"
84510>>>>>>>>>>>
84510>>>>>>>>>>>
84510>>>>>>>>>>>// SQLConnection.ini constants:
84510>>>>>>>>>>>Define CS_SQLIniFileName                for "SQLConnections.ini"
84510>>>>>>>>>>>Define CS_SQLDF19IniFileName            for "DFConnId.ini"
84510>>>>>>>>>>>Define CS_SQLIniConnectionSection       for "SQL Connections" // Obsolete!
84510>>>>>>>>>>>Define CS_SQLIniSectionName             for "Connection"
84510>>>>>>>>>>>Define CS_SQLODBCIniSectionName         for "ODBC"
84510>>>>>>>>>>>
84510>>>>>>>>>>>// DF 19 ini-file settings:
84510>>>>>>>>>>>Define CS_SQLIniConnectionIdKeyword     for "Id"
84510>>>>>>>>>>>Define CS_SQLIniDriverKeyword           for "Driver"
84510>>>>>>>>>>>Define CS_SQLIniConnectionKeyWord       for "Connection"
84510>>>>>>>>>>>Define CS_SQLIniUIDKeyword              for "UID"
84510>>>>>>>>>>>Define CS_SQLIniPWDKeyword              for "PWD"
84510>>>>>>>>>>>Define CS_SQLIniDFPWDKeyword            for "DFPWD"
84510>>>>>>>>>>>Define CS_SQLIniServerKeyword           for "SERVER"
84510>>>>>>>>>>>Define CS_SQLIniDSNKeyword              for "DSN"
84510>>>>>>>>>>>Define CS_SQLIniFileDSNKeyword          for "FILEDSN"
84510>>>>>>>>>>>Define CS_SQLIniDatabaseKeyword         for "DATABASE"
84510>>>>>>>>>>>Define CS_SQLIniTrustedKeyword          for "Trusted_Connection" 
84510>>>>>>>>>>>Define CS_SQLIniDisabledKeyword         for "Disabled"
84510>>>>>>>>>>>
84510>>>>>>>>>>>// Database Update Framework extended settings:
84510>>>>>>>>>>>Define CS_SQLIniDbTypeKeyword           for "DbType"
84510>>>>>>>>>>>Define CS_SQLIniSchemaKeyword           for "Schema"
84510>>>>>>>>>>>Define CS_SQLIniBaseTableSpaceKeyword   for "Base Table Space"
84510>>>>>>>>>>>Define CS_SQLIniLongTableSpaceKeyword   for "Long Table Space"
84510>>>>>>>>>>>Define CS_SQLIniIndexTableSpaceKeyword  for "Index Table Space"
84510>>>>>>>>>>>Define CS_SQLIniSilentLoginKeyword      for "Silent Login"
84510>>>>>>>>>>>Define CS_SQLIniDisabledKeyword         for "Disabled"      // For compatability with DF19.
84510>>>>>>>>>>>
84510>>>>>>>>>>>Define CS_SQLIniConnectionPWD           for "PWD"
84510>>>>>>>>>>>Define CS_SQLIniConnectionYes           for "Yes"
84510>>>>>>>>>>>Define CS_SQLIniConnectionNo            for "No"
84510>>>>>>>>>>>
84510>>>>>>>>>>>Struct tSQLConnection
84510>>>>>>>>>>>    Boolean bEnabled                // 1. There can only be one active/enabled connection at a time.
84510>>>>>>>>>>>    String sConnectionID            // 2. The name of the connection ID.
84510>>>>>>>>>>>    Integer iDbType                 // 3. Database type; "MS-SQL Server", "DB2", "Oracle", "MySQL", "PostgreSQL"
84510>>>>>>>>>>>    String sDriverID                // 4. Name of the driver. E.g. MSSQLDRV, DB2_DRV, ODBC_DRV or PSQLDRV_ID.
84510>>>>>>>>>>>    String sServer                  // 5. SQL Server/DSN/ODBC source name. (In DF19 this is the "sString" member of the tConnection struct.)
84510>>>>>>>>>>>    String sDatabase                // 6. SQL Database
84510>>>>>>>>>>>    String sConnectionString        // 7. Full connection string as is needed by e.g. the login command.
84510>>>>>>>>>>>    Boolean bTrusted                // 8. Trusted connection (then is UID & PWD not used)
84510>>>>>>>>>>>    String sUserID                  // 9. User ID
84510>>>>>>>>>>>    String sPassword                // 10. Password
84510>>>>>>>>>>>    String sSchema                  // 11. DB2 (and perhaps ODBC specific)
84510>>>>>>>>>>>    String sBaseTableSpace          // 12. DB2 specific
84510>>>>>>>>>>>    String sLongTableSpace          // 13. DB2 specific
84510>>>>>>>>>>>    String sIndexTableSpace         // 14. DB2 specific
84510>>>>>>>>>>>    Boolean bSilentLogin            // 15. True=Silent login. (i.e. don't show Database login dialog if database login to fails). Same as driver "Options" parameter.
84510>>>>>>>>>>>    Boolean bError                  // 16. Set to true on error.
84510>>>>>>>>>>>    Boolean bDAWConnection          // 17. True if a DFConnId.ini file (from DAW) has been used instead of a DUF SQLConnections.ini file.
84510>>>>>>>>>>>//    Boolean bDisabled               // 17. For compatability with DF19 Managed Connections only. Not used by DUF (Database Update Framework).
84510>>>>>>>>>>>//    Integer iDriverIndex            // 18. For compatability with DF19 Managed Connections only. Not used by DUF (Database Update Framework).
84510>>>>>>>>>>>End_Struct
84510>>>>>>>>>Use cDbUpdateFunctionLibrary.inc
84510>>>>>>>>>
84510>>>>>>>>>Class cDbUpdateFunctionLibrary_Mixin is a Mixin
84511>>>>>>>>>    Procedure CreateDbUpdateLibraryProperties
84513>>>>>>>>>        Handle hoSQLManagerMT
84513>>>>>>>>>
84513>>>>>>>>>        Property String private.psUseDatabase ""
84514>>>>>>>>>
84514>>>>>>>>>        // These are used by the Error routine to show the Table# & Field# if something goes wrong:
84514>>>>>>>>>        Property Handle  private.phCurrentTable 0
84515>>>>>>>>>        Property Integer private.piCurrentField 0
84516>>>>>>>>>
84516>>>>>>>>>        Property Handle phoCLIHandler      (Create(Self,RefClass(cCLIHandler)))
84517>>>>>>>>>        Property Handle phoSQLManager      (Create(Self,RefClass(cSQLHandleManager)))
84518>>>>>>>>>
84518>>>>>>>>>        Property Handle phoSQLManagerMT
84519>>>>>>>>>            Move (Create(Self,RefClass(cSQLHandleManagerDUF))) to hoSQLManagerMT
84520>>>>>>>>>            Set phoSQLManagerMT to hoSQLManagerMT
84521>>>>>>>>>
84521>>>>>>>>>        Property Handle phoMSSQLHandler    (Create(Self,RefClass(cMSSQLHandler)))
84522>>>>>>>>>        Property Handle phoDB2SQLHandler   (Create(Self,RefClass(cDB2Handler)))
84523>>>>>>>>>        Property Handle phoODBCSQLHandler  (Create(Self,RefClass(cODBCHandler)))
84524>>>>>>>>>        Property Handle phoSQLConnectionHandler 0
84525>>>>>>>>>        Property tSQLKeyWords[] paSQLKeywordArray
84526>>>>>>>>>
84526>>>>>>>>>        Property Boolean pbHandleQueryErrors True
84527>>>>>>>>>
84527>>>>>>>>>        Property tSqlColumnNew[] paQueryColumns
84528>>>>>>>>>        Property String[] paSQLFetchResults
84529>>>>>>>>>
84529>>>>>>>>>        // Error handling
84529>>>>>>>>>        Property Integer Error_Report_Mode DUF_ERROR_REPORT
84530>>>>>>>>>        Property Boolean pbSqlError False
84531>>>>>>>>>        Property tSqlErrorArray paSqlErrorArray
84532>>>>>>>>>        Property Boolean pbProcessingError False
84533>>>>>>>>>
84533>>>>>>>>>        // Statistics on query
84533>>>>>>>>>        Property TimeSpan ptsTotalQueryTime
84534>>>>>>>>>        Property TimeSpan ptsQueryExec
84535>>>>>>>>>        Property TimeSpan ptsFetchResults
84536>>>>>>>>>        Property Integer piColumns 0
84537>>>>>>>>>        Property Integer piRows 0
84538>>>>>>>>>        Property Integer piRowType 0
84539>>>>>>>>>        Property String[] paQueryMessages
84540>>>>>>>>>        Property String psSQLStatementString
84541>>>>>>>>>
84541>>>>>>>>>        Property Integer[] paTableConvertExceptions
84542>>>>>>>>>
84542>>>>>>>>>        Property Integer[] paTableDateCorrectionExceptions
84543>>>>>>>>>
84543>>>>>>>>>        // Number of SQL statements (chunks) to be executed when executing a really big
84543>>>>>>>>>        // SQL file that has been compiled into the program. It is way faster to divide
84543>>>>>>>>>        // the statements in smaller chunks than to execute them all at the same time.
84543>>>>>>>>>        Property Integer piChunkMax 500
84544>>>>>>>>>
84544>>>>>>>>>        // Fill the paSQLKeywordArray array with values;
84544>>>>>>>>>        Send SetupSQLKeywordArray
84545>>>>>>>>>        Move Self to ghoDbUpdateFunctionLibrary
84546>>>>>>>>>    End_Procedure
84547>>>>>>>>>
84547>>>>>>>>>    // Custom array find function. It compares both the iSQLWord & iSQLDbType params.
84547>>>>>>>>>    Function CompareFindSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
84549>>>>>>>>>        If (SQLKeywords1.iSQLWord = SQLKeywords2.iSQLWord and SQLKeywords1.iSQLDbType = SQLKeywords2.iSQLDbType) Begin
84551>>>>>>>>>            Function_Return (EQ)
84552>>>>>>>>>        End
84552>>>>>>>>>>
84552>>>>>>>>>        Function_Return (GT)
84553>>>>>>>>>    End_Function
84554>>>>>>>>>
84554>>>>>>>>>    // Custom array sort function. It compares both the iSQLWord & iSQLDbType params.
84554>>>>>>>>>    Function CompareSortSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
84556>>>>>>>>>        If (SQLKeywords1.iSQLWord   < SQLKeywords2.iSQLWord) ;            Function_Return (LT)
84559>>>>>>>>>        If (SQLKeywords1.iSQLWord   > SQLKeywords2.iSQLWord) ;            Function_Return (GT)
84562>>>>>>>>>        If (SQLKeywords1.iSQLDbType < SQLKeywords2.iSQLDbType) ;            Function_Return (LT)
84565>>>>>>>>>        If (SQLKeywords1.iSQLDbType > SQLKeywords2.iSQLDbType) ;            Function_Return (GT)
84568>>>>>>>>>
84568>>>>>>>>>        Function_Return (EQ)
84569>>>>>>>>>    End_Function
84570>>>>>>>>>
84570>>>>>>>>>    Procedure Add_Element Integer iSQLKeywordConstant Integer iEN_dbType String sSQLKeyword
84572>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
84572>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
84573>>>>>>>>>        Integer iSize
84573>>>>>>>>>
84573>>>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
84574>>>>>>>>>        Move (SizeOfArray(SQLKeywordArray)) to iSize
84575>>>>>>>>>        Move iSQLKeywordConstant to SQLKeywordArray[iSize].iSQLWord
84576>>>>>>>>>        Move iEN_dbType          to SQLKeywordArray[iSize].iSQLDbType
84577>>>>>>>>>        Move sSQLKeyword         to SQLKeywordArray[iSize].sSQLPhrase
84578>>>>>>>>>
84578>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArray
84579>>>>>>>>>    End_Procedure
84580>>>>>>>>>
84580>>>>>>>>>    // Creates a struct array with all SQL keywords
84580>>>>>>>>>    // for all EN_xxx SQL back-ends. Various back-ends can
84580>>>>>>>>>    // have slightly different wording.
84580>>>>>>>>>    // If a new EN_dbTypexxx type is added; additions
84580>>>>>>>>>    // needs to be done for every keyword group below.
84580>>>>>>>>>    Procedure SetupSQLKeywordArray
84582>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
84582>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
84584>>>>>>>>>
84584>>>>>>>>>        // This should only be called once; but in case it is
84584>>>>>>>>>        // we delete the array first.
84584>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArray
84585>>>>>>>>>
84585>>>>>>>>>        // ToDo: *** Not all SQL Key-words has been checked for other backends than MS-SQL ***
84585>>>>>>>>>        //
84585>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeMSSQL    "ALTER DATABASE"
84586>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeMySQL    "ALTER DATABASE"
84587>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeOracle   "ALTER DATABASE"
84588>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeDB2      "ALTER DATABASE"
84589>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypePostgre  "ALTER DATABASE"
84590>>>>>>>>>
84590>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeMSSQL    "SINGLE_USER"
84591>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeMySQL    "SINGLE_USER"
84592>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeOracle   "SINGLE_USER"
84593>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeDB2      "SINGLE_USER"
84594>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypePostgre  "SINGLE_USER"
84595>>>>>>>>>
84595>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeMSSQL    "MULTI_USER"
84596>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeMySQL    "MULTI_USER"
84597>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeOracle   "MULTI_USER"
84598>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeDB2      "MULTI_USER"
84599>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypePostgre  "MULTI_USER"
84600>>>>>>>>>
84600>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeMSSQL    "ROLLBACK"
84601>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeMySQL    "ROLLBACK"
84602>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeOracle   "ROLLBACK"
84603>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeDB2      "ROLLBACK"
84604>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypePostgre  "ROLLBACK"
84605>>>>>>>>>
84605>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeMSSQL    "IMMEDIATE"
84606>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeMySQL    "IMMEDIATE"
84607>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeOracle   "IMMEDIATE"
84608>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeDB2      "IMMEDIATE"
84609>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypePostgre  "IMMEDIATE"
84610>>>>>>>>>
84610>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMSSQL    "ALTER TABLE"
84611>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMySQL    "ALTER TABLE"
84612>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeOracle   "ALTER TABLE"
84613>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeDB2      "ALTER TABLE"
84614>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypePostgre  "ALTER TABLE"
84615>>>>>>>>>
84615>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMSSQL           "ADD"
84616>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMySQL           "ADD"
84617>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeOracle          "ADD"
84618>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeDB2             "ADD"
84619>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypePostgre         "ADD"
84620>>>>>>>>>
84620>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMSSQL        "UPDATE"
84621>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMySQL        "UPDATE"
84622>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeOracle       "UPDATE"
84623>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeDB2          "UPDATE"
84624>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypePostgre      "UPDATE"
84625>>>>>>>>>
84625>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMSSQL       "NOT NULL"
84626>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMySQL       "NOT NULL"
84627>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeOracle      "" // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
84628>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeDB2         "DEFAULT NOT NULL"
84629>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypePostgre     "NOT NULL"
84630>>>>>>>>>
84630>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_DbTypeMSSQL   ""
84631>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeMySQL   "SQL_SAFE_UPDATES"
84632>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeOracle  ""
84633>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeDB2     ""
84634>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypePostgre ""
84635>>>>>>>>>
84635>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMSSQL           "SET"
84636>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMySQL           "SET"
84637>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeOracle          "SET"
84638>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeDB2             "SET"
84639>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypePostgre         "SET"
84640>>>>>>>>>
84640>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeMSSQL          "WITH"
84641>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeMySQL          "WITH"
84642>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeOracle         "WITH"
84643>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeDB2            "WITH"
84644>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypePostgre        "WITH"
84645>>>>>>>>>
84645>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMSSQL    "CREATE DATABASE"
84646>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMySQL    "CREATE DATABASE"
84647>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeOracle   "CREATE DATABASE"
84648>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeDB2      "CREATE DATABASE"
84649>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypePostgre  "CREATE DATABASE"
84650>>>>>>>>>
84650>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeMSSQL    "COLLATE"
84651>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeMySQL    "COLLATE"
84652>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeOracle   "COLLATE"
84653>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeDB2      "COLLATE"
84654>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypePostgre  "COLLATE"
84655>>>>>>>>>
84655>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMSSQL    "CREATE VIEW"
84656>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMySQL    "CREATE VIEW"
84657>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeOracle   "CREATE VIEW"
84658>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeDB2      "CREATE VIEW"
84659>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypePostgre  "CREATE VIEW"
84660>>>>>>>>>
84660>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMSSQL      "DROP VIEW"
84661>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMySQL      "DROP VIEW"
84662>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeOracle     "DROP VIEW"
84663>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeDB2        "DROP VIEW"
84664>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypePostgre    "DROP VIEW"
84665>>>>>>>>>
84665>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMSSQL   "CREATE TABLE"
84666>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMySQL   "CREATE TABLE"
84667>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeOracle  "CREATE TABLE"
84668>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeDB2     "CREATE TABLE"
84669>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypePostgre "CREATE TABLE"
84670>>>>>>>>>
84670>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMSSQL     "DROP TABLE"
84671>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMySQL     "DROP TABLE"
84672>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeOracle    "DROP TABLE"
84673>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeDB2       "DROP TABLE"
84674>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypePostgre   "DROP TABLE"
84675>>>>>>>>>
84675>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMSSQL   "EXEC sp_rename"
84676>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMySQL   "RENAME TABLE"
84677>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeOracle  "RENAME TABLE"
84678>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeDB2     "RENAME TABLE"
84679>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypePostgre "RENAME TO"
84680>>>>>>>>>
84680>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMSSQL    "DROP COLUMN"
84681>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMySQL    "DROP COLUMN"
84682>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeOracle   "DROP COLUMN"
84683>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeDB2      "DROP COLUMN"
84684>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypePostgre  "DROP COLUMN"
84685>>>>>>>>>
84685>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMSSQL        "COLUMN"
84686>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMySQL        "COLUMN"
84687>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeOracle       "COLUMN"
84688>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeDB2          "COLUMN"
84689>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypePostgre      "COLUMN"
84690>>>>>>>>>
84690>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMSSQL   "ALTER COLUMN"
84691>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMySQL   "MODIFY"
84692>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeOracle  "MODIFY"
84693>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeDB2     "ALTER COLUMN"
84694>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypePostgre "ALTER COLUMN"
84695>>>>>>>>>
84695>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMSSQL   "EXEC sp_RENAME"
84696>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMySQL   "CHANGE"
84697>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeOracle  "RENAME COLUMN"
84698>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeDB2     "RENAME COLUMN"
84699>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypePostgre "RENAME COLUMN"
84700>>>>>>>>>
84700>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMSSQL        "SELECT"
84701>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMySQL        "SELECT"
84702>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeOracle       "SELECT"
84703>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeDB2          "SELECT"
84704>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypePostgre      "SELECT"
84705>>>>>>>>>
84705>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMSSQL         "WHERE"
84706>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMySQL         "WHERE"
84707>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeOracle        "WHERE"
84708>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeDB2           "WHERE"
84709>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypePostgre       "WHERE"
84710>>>>>>>>>
84710>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMSSQL          "FROM"
84711>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMySQL          "FROM"
84712>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeOracle         "FROM"
84713>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeDB2            "FROM"
84714>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypePostgre        "FROM"
84715>>>>>>>>>
84715>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMSSQL    "INFORMATION_SCHEMA.COLUMNS"
84716>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMySQL    "INFORMATION_SCHEMA.COLUMNS"
84717>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeOracle   "INFORMATION_SCHEMA.COLUMNS"
84718>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeDB2      "INFORMATION_SCHEMA.COLUMNS"
84719>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypePostgre  "INFORMATION_SCHEMA.COLUMNS"
84720>>>>>>>>>
84720>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMSSQL    "TABLE_NAME"
84721>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMySQL    "TABLE_NAME"
84722>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeOracle   "TABLE_NAME"
84723>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeDB2      "TABLE_NAME"
84724>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypePostgre  "TABLE_NAME"
84725>>>>>>>>>
84725>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMSSQL         "TABLE"
84726>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMySQL         "TABLE"
84727>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeOracle        "TABLE"
84728>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeDB2           "TABLE"
84729>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypePostgre       "TABLE"
84730>>>>>>>>>
84730>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMSSQL           "SYS"
84731>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMySQL           "SYS"
84732>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeOracle          "SYS"
84733>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeDB2             "SYS"
84734>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypePostgre         "SYS"
84735>>>>>>>>>
84735>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMSSQL       "SP_HELP"
84736>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMySQL       "SP_HELP"
84737>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeOracle      "SP_HELP"
84738>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeDB2         "SP_HELP"
84739>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypePostgre     "SP_HELP"
84740>>>>>>>>>
84740>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMSSQL      "SET NOCOUNT ON"
84741>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMySQL      "SET NOCOUNT ON"
84742>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeOracle     "SET NOCOUNT ON"
84743>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeDB2        "SET NOCOUNT ON"
84744>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypePostgre    "SET NOCOUNT ON"
84745>>>>>>>>>
84745>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMSSQL            "TO"
84746>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMySQL            "TO"
84747>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeOracle           "TO"
84748>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeDB2              "TO"
84749>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypePostgre          "TO"
84750>>>>>>>>>
84750>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMSSQL            "GO"
84751>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMySQL            "GO"
84752>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeOracle           "GO"
84753>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeDB2              "GO"
84754>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypePostgre          "GO"
84755>>>>>>>>>
84755>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMSSQL           "USE"
84756>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMySQL           "USE"
84757>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeOracle          "USE"
84758>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeDB2             "USE"
84759>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypePostgre         "USE"
84760>>>>>>>>>
84760>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMSSQL           "dbo"
84761>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMySQL           "dbo"
84762>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeOracle          "dbo"
84763>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeDB2             "dbo"
84764>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypePostgre         "dbo"
84765>>>>>>>>>
84765>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMSSQL        "MASTER"
84766>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMySQL        "MASTER"
84767>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeOracle       "MASTER"
84768>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeDB2          "MASTER"
84769>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypePostgre      "MASTER"
84770>>>>>>>>>
84770>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeMSSQL          "NAME"
84771>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeMySQL          "NAME"
84772>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeOracle         "NAME"
84773>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeDB2            "NAME"
84774>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypePostgre        "NAME"
84775>>>>>>>>>
84775>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMSSQL     "DATABASES"
84776>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMySQL     "DATABASES"
84777>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeOracle    "DATABASES"
84778>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeDB2       "DATABASES"
84779>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypePostgre   "DATABASES"
84780>>>>>>>>>
84780>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMSSQL    "SYS.INDEXES"
84781>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMySQL    "SYS.INDEXES"
84782>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeOracle   "SYS.INDEXES"
84783>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeDB2      "SYS.INDEXES"
84784>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypePostgre  "SYS.INDEXES"
84785>>>>>>>>>
84785>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMSSQL      "OBJECT_ID"
84786>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMySQL      "OBJECT_ID"
84787>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeOracle     "OBJECT_ID"
84788>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeDB2        "OBJECT_ID"
84789>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypePostgre    "OBJECT_ID"
84790>>>>>>>>>
84790>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeMSSQL            "ID"
84791>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeMySQL            "ID"
84792>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeOracle           "ID"
84793>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeDB2              "ID"
84794>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypePostgre          "ID"
84795>>>>>>>>>
84795>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMSSQL           "AND"
84796>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMySQL           "AND"
84797>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeOracle          "AND"
84798>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeDB2             "AND"
84799>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypePostgre         "AND"
84800>>>>>>>>>
84800>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeMSSQL   "DESCRIPTION"
84801>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeMySQL   "DESCRIPTION"
84802>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeOracle  "DESCRIPTION"
84803>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeDB2     "DESCRIPTION"
84804>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypePostgre "DESCRIPTION"
84805>>>>>>>>>
84805>>>>>>>>>        // In case we didn't put the above in order (and we don't need to); we sort the struct array.
84805>>>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
84806>>>>>>>>>        Move (SortArray(SQLKeywordArray, Self, (RefFunc(CompareSortSQLKeyWords)))) to SQLKeywordArraySorted
84807>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArraySorted
84808>>>>>>>>>
84808>>>>>>>>>    End_Procedure
84809>>>>>>>>>
84809>>>>>>>>>End_Class
84810>>>>>>>Use cSQLConnectionHandler.pkg
Including file: cSQLConnectionHandler.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionHandler.pkg)
84810>>>>>>>>>//****************************************************************************
84810>>>>>>>>>// $Module type: Class
84810>>>>>>>>>// $Module name: cSQLConnectionHandler.pkg
84810>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
84810>>>>>>>>>// Web-site    : http://www.rdctools.com
84810>>>>>>>>>// Created     : 2015-08-11 @ 16:02 (Military date format: YY-MM-DD)
84810>>>>>>>>>//
84810>>>>>>>>>// Description : A handler class for using CLI connection ID's to login to a database server.
84810>>>>>>>>>//
84810>>>>>>>>>// $Rev History:
84810>>>>>>>>>//    2015-08-11  Module header created
84810>>>>>>>>>//    2016-09-26  Changed name of the objecthandle from ghoCreateConnectionID to ghoSQLConnectionHandler.
84810>>>>>>>>>//                Added a new structure for passing connection data back & forth.
84810>>>>>>>>>//                Added better error handling.
84810>>>>>>>>>//                Added a decompose message for the connection string.
84810>>>>>>>>>//    2017-01-09  Added support for Mertech drivers
84810>>>>>>>>>//                Big overhaul to comply better with "Managed Connections" (DF 19)
84810>>>>>>>>>//                These changes make the class compatible with DFConnId.ini (can read/write DAW connection ini-files)
84810>>>>>>>>>//    2017-02-12  Reworked the whole connection property interface.
84810>>>>>>>>>//                Now there is one struct property that is the at cencter of a connection.
84810>>>>>>>>>//****************************************************************************
84810>>>>>>>>>Use cli.pkg
84810>>>>>>>>>Use MSSqldrv.pkg
84810>>>>>>>>>Use db2_drv.pkg
84810>>>>>>>>>Use odbc_drv.pkg
84810>>>>>>>>>Use cSQLConnectionIniFile.pkg
Including file: cSQLConnectionIniFile.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionIniFile.pkg)
84810>>>>>>>>>>>//****************************************************************************
84810>>>>>>>>>>>// $Module type: Class
84810>>>>>>>>>>>// $Module name: cSQLConnectionIniFile.pkg
84810>>>>>>>>>>>//
84810>>>>>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International.
84810>>>>>>>>>>>// Copyright (c) 2012 RDC Tools International
84810>>>>>>>>>>>// E-mail      : support@rdctools.com
84810>>>>>>>>>>>// Web-site    : http://www.rdctools.com
84810>>>>>>>>>>>//
84810>>>>>>>>>>>// Created     : 2012-09-20 @ 18:04 (Military date format - Year-Month-Day)
84810>>>>>>>>>>>//
84810>>>>>>>>>>>// Note        : The file must be USEd after declaration of the ghoApplication object, as it uses
84810>>>>>>>>>>>//               properties of that object.
84810>>>>>>>>>>>//
84810>>>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
84810>>>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
84810>>>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
84810>>>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
84810>>>>>>>>>>>// in the help folder for more details.
84810>>>>>>>>>>>//
84810>>>>>>>>>>>Use cSQLConnectionIniFile.inc
84810>>>>>>>>>>>Use cDbUpdateDatabaseDriver.pkg
Including file: cDbUpdateDatabaseDriver.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateDatabaseDriver.pkg)
84810>>>>>>>>>>>>>Use cSQLConnectionIniFile.inc
84810>>>>>>>>>>>>>
84810>>>>>>>>>>>>>Class cDbUpdateGenericDatabaseDriver is a cObject
84811>>>>>>>>>>>>>    Procedure Construct_Object
84813>>>>>>>>>>>>>        Forward Send Construct_Object
84815>>>>>>>>>>>>>        Property String psDriverID DATAFLEX_ID
84816>>>>>>>>>>>>>    End_Procedure
84817>>>>>>>>>>>>>
84817>>>>>>>>>>>>>    Function ServerKeyword String sServer Returns String
84819>>>>>>>>>>>>>        String sRetval
84819>>>>>>>>>>>>>        If (Uppercase(sServer) contains ("." + CS_SQLIniDSNKeyword)) Begin
84821>>>>>>>>>>>>>            Move CS_SQLIniFileDSNKeyword to sRetval    
84822>>>>>>>>>>>>>        End                                        
84822>>>>>>>>>>>>>>
84822>>>>>>>>>>>>>        Else Begin
84823>>>>>>>>>>>>>            Move CS_SQLIniDSNKeyword to sRetval
84824>>>>>>>>>>>>>        End
84824>>>>>>>>>>>>>>
84824>>>>>>>>>>>>>            
84824>>>>>>>>>>>>>        Function_Return sRetval
84825>>>>>>>>>>>>>    End_Function
84826>>>>>>>>>>>>>
84826>>>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
84828>>>>>>>>>>>>>        String sConnect sServerKeyWord sDriverID
84828>>>>>>>>>>>>>
84828>>>>>>>>>>>>>        Get psDriverID to sDriverID
84829>>>>>>>>>>>>>        Get ServerKeyword sServer to sServerKeyWord
84830>>>>>>>>>>>>>        Move (sConnect + sServerKeyWord + "=" + sServer) to sConnect
84831>>>>>>>>>>>>>        If (sServerKeyWord = CS_SQLIniDSNKeyword or sServerKeyWord = CS_SQLIniFileDSNKeyword) Begin
84833>>>>>>>>>>>>>            Move "" to sDatabase
84834>>>>>>>>>>>>>        End
84834>>>>>>>>>>>>>>
84834>>>>>>>>>>>>>        
84834>>>>>>>>>>>>>        // 2019-10-20 I think this was plain wrong for the DAW ODBC_DRV driver. At least it didn't work for login to an MS-SQL db.
84834>>>>>>>>>>>>>//        If (bTrusted = False and (sDriverID = ODBC_DRV_ID and sServerKeyWord = CS_SQLIniDSNKeyword)) Begin
84834>>>>>>>>>>>>>//            Function_Return sConnect
84834>>>>>>>>>>>>>//        End
84834>>>>>>>>>>>>>
84834>>>>>>>>>>>>>        If (sDatabase <> "") Begin
84836>>>>>>>>>>>>>            Move (sConnect + ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
84837>>>>>>>>>>>>>        End
84837>>>>>>>>>>>>>>
84837>>>>>>>>>>>>>        If (bTrusted = True) Begin
84839>>>>>>>>>>>>>            Move (sConnect + ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
84840>>>>>>>>>>>>>        End
84840>>>>>>>>>>>>>>
84840>>>>>>>>>>>>>        Else Begin
84841>>>>>>>>>>>>>            Move (sConnect + ";" + CS_SQLIniUIDKeyword + "=" + sUserID + ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
84842>>>>>>>>>>>>>        End
84842>>>>>>>>>>>>>>
84842>>>>>>>>>>>>>        Function_Return sConnect
84843>>>>>>>>>>>>>    End_Function
84844>>>>>>>>>>>>>
84844>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
84846>>>>>>>>>>>>>        Boolean bLoginSuccessful
84846>>>>>>>>>>>>>        String sDriverID
84846>>>>>>>>>>>>>
84846>>>>>>>>>>>>>        Get psDriverID to sDriverID
84847>>>>>>>>>>>>>        If (sDriverID = DATAFLEX_ID or sDriverID = "") Begin
84849>>>>>>>>>>>>>            Function_Return True
84850>>>>>>>>>>>>>        End
84850>>>>>>>>>>>>>>
84850>>>>>>>>>>>>>        Move 0 to LastErr  // Do NOT use the Err flag, it will be set true by the login command although it is successful.
84851>>>>>>>>>>>>>        If (bTrusted = False and sDatabase <> "") Begin
84853>>>>>>>>>>>>>            Move (SFormat("SERVER=%1;DATABASE=%2", sServer, sDatabase)) to sServer
84854>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID  
84856>>>>>>>>>>>>>        End
84856>>>>>>>>>>>>>>
84856>>>>>>>>>>>>>        Else Begin
84857>>>>>>>>>>>>>            Login sConnectionString "" "" sDriverID
84859>>>>>>>>>>>>>        End
84859>>>>>>>>>>>>>>
84859>>>>>>>>>>>>>        Move (LastErr = 0) to bLoginSuccessful
84860>>>>>>>>>>>>>        Function_Return bLoginSuccessful
84861>>>>>>>>>>>>>    End_Function
84862>>>>>>>>>>>>>End_Class
84863>>>>>>>>>>>>>
84863>>>>>>>>>>>>>Class cDbUpdateMSSQLDriver is a cDbUpdateGenericDatabaseDriver
84864>>>>>>>>>>>>>    Function ServerKeyword String sServer Returns String
84866>>>>>>>>>>>>>        Function_Return CS_SQLIniServerKeyword
84867>>>>>>>>>>>>>    End_Function
84868>>>>>>>>>>>>>End_Class
84869>>>>>>>>>>>>>
84869>>>>>>>>>>>>>Class cDbUpdateODBCDriver is a cDbUpdateGenericDatabaseDriver
84870>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
84872>>>>>>>>>>>>>        Boolean bLoginSuccessful
84872>>>>>>>>>>>>>        String sDriverID
84872>>>>>>>>>>>>>
84872>>>>>>>>>>>>>        Get psDriverID to sDriverID
84873>>>>>>>>>>>>>        Move (Trim(sDriverID)) to sDriverID
84874>>>>>>>>>>>>>        If (sDriverID = DATAFLEX_ID or sDriverID = "") Begin
84876>>>>>>>>>>>>>            Function_Return True
84877>>>>>>>>>>>>>        End
84877>>>>>>>>>>>>>>
84877>>>>>>>>>>>>>        Move 0 to LastErr  // Do NOT use the Err flag, it will be set true by the login command although it is successful.
84878>>>>>>>>>>>>>        If (bTrusted = False) Begin
84880>>>>>>>>>>>>>            If (Uppercase(sServer) contains ("." + String(CS_SQLIniDSNKeyword))) Begin
84882>>>>>>>>>>>>>                Move (CS_SQLIniFileDSNKeyword + "=" + sServer) to sServer
84883>>>>>>>>>>>>>            End
84883>>>>>>>>>>>>>>
84883>>>>>>>>>>>>>            Else If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
84886>>>>>>>>>>>>>                Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
84887>>>>>>>>>>>>>            End
84887>>>>>>>>>>>>>>
84887>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID  
84889>>>>>>>>>>>>>        End
84889>>>>>>>>>>>>>>
84889>>>>>>>>>>>>>        Else Begin
84890>>>>>>>>>>>>>            Login sConnectionString "" "" sDriverID
84892>>>>>>>>>>>>>        End
84892>>>>>>>>>>>>>>
84892>>>>>>>>>>>>>        Move (LastErr = 0) to bLoginSuccessful
84893>>>>>>>>>>>>>
84893>>>>>>>>>>>>>        Function_Return bLoginSuccessful
84894>>>>>>>>>>>>>    End_Function
84895>>>>>>>>>>>>>End_Class
84896>>>>>>>>>>>>>
84896>>>>>>>>>>>>>Class cDbUpdateDB2Driver is a cDbUpdateGenericDatabaseDriver
84897>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
84899>>>>>>>>>>>>>        Boolean bLoginSuccessful
84899>>>>>>>>>>>>>        String sDriverID
84899>>>>>>>>>>>>>
84899>>>>>>>>>>>>>        Move False to Err
84900>>>>>>>>>>>>>        Get psDriverID to sDriverID
84901>>>>>>>>>>>>>        If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
84903>>>>>>>>>>>>>            Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
84904>>>>>>>>>>>>>        End
84904>>>>>>>>>>>>>>
84904>>>>>>>>>>>>>        Login sServer sUserId sPassword sDriverID
84906>>>>>>>>>>>>>
84906>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
84907>>>>>>>>>>>>>        Function_Return bLoginSuccessful
84908>>>>>>>>>>>>>    End_Function
84909>>>>>>>>>>>>>End_Class
84910>>>>>>>>>>>>>
84910>>>>>>>>>>>>>Class cDbUpdatePSQLDriver is a cDbUpdateGenericDatabaseDriver
84911>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
84913>>>>>>>>>>>>>        Boolean bLoginSuccessful
84913>>>>>>>>>>>>>        String sDriverID
84913>>>>>>>>>>>>>
84913>>>>>>>>>>>>>        Move False to Err
84914>>>>>>>>>>>>>        Get psDriverID to sDriverID
84915>>>>>>>>>>>>>//        If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
84915>>>>>>>>>>>>>//            Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
84915>>>>>>>>>>>>>//        End
84915>>>>>>>>>>>>>        Login sServer sUserId sPassword sDriverID
84917>>>>>>>>>>>>>
84917>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
84918>>>>>>>>>>>>>        Function_Return bLoginSuccessful
84919>>>>>>>>>>>>>    End_Function
84920>>>>>>>>>>>>>End_Class
84921>>>>>>>>>>>>>
84921>>>>>>>>>>>>>Class cDbUpdateDataFlexDriver is a cDbUpdateGenericDatabaseDriver
84922>>>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
84924>>>>>>>>>>>>>        Function_Return ""
84925>>>>>>>>>>>>>    End_Function
84926>>>>>>>>>>>>>End_Class
84927>>>>>>>>>>>>>
84927>>>>>>>>>>>>>Class cDbUpdateSQLFLEXDriver is a cDbUpdateGenericDatabaseDriver
84928>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
84930>>>>>>>>>>>>>        Boolean bLoginSuccessful
84930>>>>>>>>>>>>>        String sDriverID
84930>>>>>>>>>>>>>
84930>>>>>>>>>>>>>        Get psDriverID to sDriverID
84931>>>>>>>>>>>>>        //For the Mertech driver, using the Err indicator is the sanctioned way
84931>>>>>>>>>>>>>        Move False to Err
84932>>>>>>>>>>>>>        If (bTrusted = False) Begin
84934>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID
84936>>>>>>>>>>>>>        End
84936>>>>>>>>>>>>>>
84936>>>>>>>>>>>>>        Else Begin
84937>>>>>>>>>>>>>            Login sServer "" "" sDriverID
84939>>>>>>>>>>>>>        End
84939>>>>>>>>>>>>>>
84939>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
84940>>>>>>>>>>>>>
84940>>>>>>>>>>>>>        Function_Return bLoginSuccessful
84941>>>>>>>>>>>>>    End_Function
84942>>>>>>>>>>>>>End_Class
84943>>>>>>>>>>>>>
84943>>>>>>>>>>>>>Class cDbUpdateORAFLEXDriver is a cDbUpdateGenericDatabaseDriver
84944>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
84946>>>>>>>>>>>>>        Boolean bLoginSuccessful
84946>>>>>>>>>>>>>        String sDriverID
84946>>>>>>>>>>>>>        Integer iPos
84946>>>>>>>>>>>>>
84946>>>>>>>>>>>>>        Get psDriverID to sDriverID
84947>>>>>>>>>>>>>        Move (Pos("/", sServer)) to iPos
84948>>>>>>>>>>>>>        If (iPos = 0) Begin
84950>>>>>>>>>>>>>            If (sDatabase <> "") Begin
84952>>>>>>>>>>>>>                Move (sServer + "/" + sDatabase) to sServer
84953>>>>>>>>>>>>>            End
84953>>>>>>>>>>>>>>
84953>>>>>>>>>>>>>        End
84953>>>>>>>>>>>>>>
84953>>>>>>>>>>>>>        // For the Mertech driver, using the Err indicator is the sanctioned way
84953>>>>>>>>>>>>>        Move False to Err
84954>>>>>>>>>>>>>        // For Oracle I don't believe "Trusted" doesn't exist.
84954>>>>>>>>>>>>>        Login sServer sUserId sPassword sDriverID
84956>>>>>>>>>>>>>
84956>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
84957>>>>>>>>>>>>>        Function_Return bLoginSuccessful
84958>>>>>>>>>>>>>    End_Function
84959>>>>>>>>>>>>>End_Class
84960>>>>>>>>>>>>>
84960>>>>>>>>>>>>>Class cDbUpdateMDSMySQLDriver is a cDbUpdateGenericDatabaseDriver
84961>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
84963>>>>>>>>>>>>>        Boolean bLoginSuccessful
84963>>>>>>>>>>>>>        String sDriverID
84963>>>>>>>>>>>>>
84963>>>>>>>>>>>>>        Get psDriverID to sDriverID
84964>>>>>>>>>>>>>        // For the Mertech driver, using the Err indicator is the sanctioned way
84964>>>>>>>>>>>>>        Move False to Err
84965>>>>>>>>>>>>>        If (bTrusted = False) Begin
84967>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID
84969>>>>>>>>>>>>>        End
84969>>>>>>>>>>>>>>
84969>>>>>>>>>>>>>        Else Begin
84970>>>>>>>>>>>>>            Login sServer "" "" sDriverID
84972>>>>>>>>>>>>>        End
84972>>>>>>>>>>>>>>
84972>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
84973>>>>>>>>>>>>>        Function_Return bLoginSuccessful
84974>>>>>>>>>>>>>    End_Function
84975>>>>>>>>>>>>>End_Class
84976>>>>>>>>>>>>>
84976>>>>>>>>>>>>>Class cDbUpdateMDSPgSQLDriver is a cDbUpdateGenericDatabaseDriver
84977>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
84979>>>>>>>>>>>>>        Boolean bLoginSuccessful
84979>>>>>>>>>>>>>        String sDriverID
84979>>>>>>>>>>>>>
84979>>>>>>>>>>>>>        Get psDriverID to sDriverID
84980>>>>>>>>>>>>>        // For the Mertech driver, using the Err indicator is the sanctioned way
84980>>>>>>>>>>>>>        Move False to Err
84981>>>>>>>>>>>>>        If (bTrusted = False) Begin
84983>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID
84985>>>>>>>>>>>>>        End
84985>>>>>>>>>>>>>>
84985>>>>>>>>>>>>>        Else Begin
84986>>>>>>>>>>>>>            Login sServer "" "" sDriverID
84988>>>>>>>>>>>>>        End
84988>>>>>>>>>>>>>>
84988>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
84989>>>>>>>>>>>>>        Function_Return bLoginSuccessful
84990>>>>>>>>>>>>>    End_Function
84991>>>>>>>>>>>>>End_Class
84992>>>>>>>>>>>>>
84992>>>>>>>>>>>>>Class cDbUpdateDatabaseDriver is a cObject
84993>>>>>>>>>>>>>    Procedure Construct_Object
84995>>>>>>>>>>>>>        Forward Send Construct_Object
84997>>>>>>>>>>>>>        Property String psDriverID DATAFLEX_ID
84998>>>>>>>>>>>>>        Property Handle phoDriverSpecificObject
84999>>>>>>>>>>>>>    End_Procedure
85000>>>>>>>>>>>>>
85000>>>>>>>>>>>>>    Function CreateDriver Returns Handle
85002>>>>>>>>>>>>>        String sDriverID
85002>>>>>>>>>>>>>        Handle hoDriver hcDriverClass
85002>>>>>>>>>>>>>
85002>>>>>>>>>>>>>        Get psDriverID to sDriverID
85003>>>>>>>>>>>>>        Case Begin
85003>>>>>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
85005>>>>>>>>>>>>>                Move (RefClass(cDbUpdateMSSQLDriver))    to hcDriverClass
85006>>>>>>>>>>>>>                Case Break
85007>>>>>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
85010>>>>>>>>>>>>>                Move (RefClass(cDbUpdateODBCDriver))     to hcDriverClass
85011>>>>>>>>>>>>>                Case Break
85012>>>>>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
85015>>>>>>>>>>>>>                Move (RefClass(cDbUpdateDB2Driver))      to hcDriverClass
85016>>>>>>>>>>>>>                Case Break               
85017>>>>>>>>>>>>>//            Case (sDriverID = DFBTRDRV_ID)
85017>>>>>>>>>>>>>//                Move (RefClass(cDbUpdateDatabaseDriver)) to hcDriverClass
85017>>>>>>>>>>>>>//                Case Break
85017>>>>>>>>>>>>>            Case (sDriverID = SQLFLEX)
85020>>>>>>>>>>>>>                Move (RefClass(cDbUpdateSQLFLEXDriver))  to hcDriverClass
85021>>>>>>>>>>>>>                Case Break
85022>>>>>>>>>>>>>            Case (sDriverID = ORAFLEX)
85025>>>>>>>>>>>>>                Move (RefClass(cDbUpdateORAFLEXDriver))  to hcDriverClass
85026>>>>>>>>>>>>>                Case Break
85027>>>>>>>>>>>>>            Case (sDriverID = MDSPgSQL)
85030>>>>>>>>>>>>>                Move (RefClass(cDbUpdateMDSPgSQLDriver)) to hcDriverClass
85031>>>>>>>>>>>>>                Case Break
85032>>>>>>>>>>>>>            Case (sDriverID = MDSMySQL)
85035>>>>>>>>>>>>>                Move (RefClass(cDbUpdateMDSMySQLDriver)) to hcDriverClass
85036>>>>>>>>>>>>>                Case Break
85037>>>>>>>>>>>>>            // DATAFLEX_ID = Default driver
85037>>>>>>>>>>>>>            Case Else
85037>>>>>>>>>>>>>                Move (RefClass(cDbUpdateDataFlexDriver)) to hcDriverClass
85038>>>>>>>>>>>>>                Move DATAFLEX_ID to sDriverID
85039>>>>>>>>>>>>>        Case End
85039>>>>>>>>>>>>>
85039>>>>>>>>>>>>>        Get Create hcDriverClass to hoDriver
85040>>>>>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
85041>>>>>>>>>>>>>        Set phoDriverSpecificObject to hoDriver
85042>>>>>>>>>>>>>
85042>>>>>>>>>>>>>        Function_Return hoDriver
85043>>>>>>>>>>>>>    End_Function
85044>>>>>>>>>>>>>
85044>>>>>>>>>>>>>    Procedure DestroyDriver
85046>>>>>>>>>>>>>        If (phoDriverSpecificObject(Self)) Begin
85048>>>>>>>>>>>>>            Send Destroy of (phoDriverSpecificObject(Self))
85049>>>>>>>>>>>>>        End
85049>>>>>>>>>>>>>>
85049>>>>>>>>>>>>>    End_Procedure
85050>>>>>>>>>>>>>
85050>>>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
85052>>>>>>>>>>>>>        String sConnect
85052>>>>>>>>>>>>>        Handle hoDriver
85052>>>>>>>>>>>>>
85052>>>>>>>>>>>>>        Get CreateDriver to hoDriver
85053>>>>>>>>>>>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
85054>>>>>>>>>>>>>        Send DestroyDriver
85055>>>>>>>>>>>>>        Function_Return sConnect
85056>>>>>>>>>>>>>    End_Function
85057>>>>>>>>>>>>>
85057>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
85059>>>>>>>>>>>>>        Boolean bLoginSuccessful
85059>>>>>>>>>>>>>        Handle hoDriver
85059>>>>>>>>>>>>>
85059>>>>>>>>>>>>>        Get CreateDriver to hoDriver
85060>>>>>>>>>>>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
85061>>>>>>>>>>>>>        Send DestroyDriver
85062>>>>>>>>>>>>>        Function_Return bLoginSuccessful
85063>>>>>>>>>>>>>    End_Function
85064>>>>>>>>>>>>>
85064>>>>>>>>>>>>>End_Class
85065>>>>>>>>>>>
85065>>>>>>>>>>>    Use cLoginEncryption.pkg
Including file: cLoginEncryption.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cLoginEncryption.pkg)
85065>>>>>>>>>>>>>Use cCryptographerEx.pkg
85065>>>>>>>>>>>>>
85065>>>>>>>>>>>>>Class cLoginEncryption is a cObject
85066>>>>>>>>>>>>>    
85066>>>>>>>>>>>>>    Procedure Construct_Object
85068>>>>>>>>>>>>>        Forward Send Construct_Object
85070>>>>>>>>>>>>>        // this must be set to a multi (40ish) character random key
85070>>>>>>>>>>>>>        Property String psEncryptPassword ""
85071>>>>>>>>>>>>>        
85071>>>>>>>>>>>>>        Object oDataCrypter is a cCryptographerEx
85073>>>>>>>>>>>>>            Set piHash to CALG_SHA_256
85074>>>>>>>>>>>>>            Set piCipher to CALG_AES_256
85075>>>>>>>>>>>>>            Set psProvider to "" //  Not providing a specific provider gives the default provider for the provider type
85076>>>>>>>>>>>>>            Set piProvider to PROV_RSA_AES
85077>>>>>>>>>>>>>        End_Object
85078>>>>>>>>>>>>>    End_Procedure
85079>>>>>>>>>>>>>    
85079>>>>>>>>>>>>>    // This can be augmented to return a password encryption key using any
85079>>>>>>>>>>>>>    // hidden mechanism desired.
85079>>>>>>>>>>>>>    Function GetEncryptionPassword Returns String
85081>>>>>>>>>>>>>        String sPassword
85081>>>>>>>>>>>>>        Get psEncryptPassword to sPassword
85082>>>>>>>>>>>>>        Function_Return sPassword
85083>>>>>>>>>>>>>    End_Function
85084>>>>>>>>>>>>>    
85084>>>>>>>>>>>>>    // Encrypts a string into an unreadable hash that can later be decrypted using DecryptKey.
85084>>>>>>>>>>>>>    //
85084>>>>>>>>>>>>>    // Params:
85084>>>>>>>>>>>>>    //   sPlainText     String to encrypt.
85084>>>>>>>>>>>>>    // Returns:
85084>>>>>>>>>>>>>    //   Base64 encoded hash.
85084>>>>>>>>>>>>>    Function EncryptPassword String sPlainText Returns String
85086>>>>>>>>>>>>>        String sEncryptPassword sBase64
85086>>>>>>>>>>>>>        UChar[] ucBinary
85087>>>>>>>>>>>>>        Pointer pBase64
85087>>>>>>>>>>>>>        Integer iVoid
85087>>>>>>>>>>>>>        
85087>>>>>>>>>>>>>        //  Encrypt Key
85087>>>>>>>>>>>>>        Get GetEncryptionPassword to sEncryptPassword
85088>>>>>>>>>>>>>        If (sEncryptPassword = "") Begin
85090>>>>>>>>>>>>>            Error DFERR_PROGRAM "No encryption password set"
85091>>>>>>>>>>>>>>
85091>>>>>>>>>>>>>        End
85091>>>>>>>>>>>>>>
85091>>>>>>>>>>>>>        
85091>>>>>>>>>>>>>        Get Encrypt of oDataCrypter (StringToUCharArray(sEncryptPassword)) (StringToUCharArray(sPlainText)) to ucBinary
85092>>>>>>>>>>>>>        
85092>>>>>>>>>>>>>        If (SizeOfArray(ucBinary) = 0) Begin
85094>>>>>>>>>>>>>            Error DFERR_PROGRAM "Unable to encrypt database login password"
85095>>>>>>>>>>>>>>
85095>>>>>>>>>>>>>            Function_Return ""
85096>>>>>>>>>>>>>        End
85096>>>>>>>>>>>>>>
85096>>>>>>>>>>>>>        
85096>>>>>>>>>>>>>        //  Encode binary hash to Base64
85096>>>>>>>>>>>>>        Move (Base64Encode(AddressOf(ucBinary), SizeOfArray(ucBinary))) to pBase64
85097>>>>>>>>>>>>>        Move (PointerToString(pBase64)) to sBase64
85098>>>>>>>>>>>>>        Move (Free(pBase64)) to iVoid
85099>>>>>>>>>>>>>        
85099>>>>>>>>>>>>>        Function_Return sBase64
85100>>>>>>>>>>>>>    End_Function
85101>>>>>>>>>>>>>    
85101>>>>>>>>>>>>>    
85101>>>>>>>>>>>>>    // Decrypts the unreadable hash generated by EncryptKey into a readable string.
85101>>>>>>>>>>>>>    //
85101>>>>>>>>>>>>>    // Params:
85101>>>>>>>>>>>>>    //   sBase64EncryptedPassword       Base64 Encrypted password
85101>>>>>>>>>>>>>    // Returns:
85101>>>>>>>>>>>>>    //   Readable plain text password
85101>>>>>>>>>>>>>    Function DecryptPassword String sBase64EncryptedPassword Returns String
85103>>>>>>>>>>>>>        String sEncryptPassword
85103>>>>>>>>>>>>>        UChar[] ucBinary ucPlain
85105>>>>>>>>>>>>>        Boolean bIsHex
85105>>>>>>>>>>>>>        Integer iLen iVoid
85105>>>>>>>>>>>>>        Pointer pBinary
85105>>>>>>>>>>>>>        
85105>>>>>>>>>>>>>        If (sBase64EncryptedPassword <> "") Begin
85107>>>>>>>>>>>>>            //  Decode from Base64
85107>>>>>>>>>>>>>            Move (Base64Decode(AddressOf(sBase64EncryptedPassword), &iLen)) to pBinary
85108>>>>>>>>>>>>>            
85108>>>>>>>>>>>>>            Move (ResizeArray(ucBinary, iLen, 0)) to ucBinary
85109>>>>>>>>>>>>>            Move (MemCopy(AddressOf(ucBinary), pBinary, iLen)) to iVoid
85110>>>>>>>>>>>>>                        
85110>>>>>>>>>>>>>            Move (Free(pBinary)) to iVoid
85111>>>>>>>>>>>>>            
85111>>>>>>>>>>>>>            //  Encrypted binary hash to string
85111>>>>>>>>>>>>>            Get GetEncryptionPassword to sEncryptPassword
85112>>>>>>>>>>>>>            Get Decrypt of oDataCrypter (StringToUCharArray(sEncryptPassword)) ucBinary to ucPlain
85113>>>>>>>>>>>>>        End
85113>>>>>>>>>>>>>>
85113>>>>>>>>>>>>>        
85113>>>>>>>>>>>>>        Function_Return (UCharArrayToString(ucPlain))
85114>>>>>>>>>>>>>    End_Function
85115>>>>>>>>>>>>>End_Class
85116>>>>>>>>>>>
85116>>>>>>>>>>>Class cSQLConnectionIniFile is a cIniFile
85117>>>>>>>>>>>    Procedure Construct_Object
85119>>>>>>>>>>>        Forward Send Construct_Object
85121>>>>>>>>>>>
85121>>>>>>>>>>>        Property String Private_psIniFilePath
85122>>>>>>>>>>>        Property String Private_psIniFileName CS_SQLIniFileName
85123>>>>>>>>>>>        Property String psIniSectionName (CS_SQLIniSectionName + "1")
85124>>>>>>>>>>>
85124>>>>>>>>>>>        Property Boolean pbDFConnId False
85125>>>>>>>>>>>
85125>>>>>>>>>>>        // *** You really want to change this value! ***
85125>>>>>>>>>>>        // It is used when encrypting/decrypting passwords.
85125>>>>>>>>>>>        Property String psHashString "zx!2139(LI0+?ips7433"
85126>>>>>>>>>>>
85126>>>>>>>>>>>    End_Procedure
85127>>>>>>>>>>>
85127>>>>>>>>>>>    Procedure End_Construct_Object
85129>>>>>>>>>>>        Forward Send End_Construct_Object
85131>>>>>>>>>>>    End_Procedure
85132>>>>>>>>>>>
85132>>>>>>>>>>>    Procedure Set psIniFilePath String sPath
85134>>>>>>>>>>>        String sIniFile
85134>>>>>>>>>>>        Get vFolderFormat sPath to sPath
85135>>>>>>>>>>>        Set private_psIniFilePath to sPath
85136>>>>>>>>>>>        Get psIniFileName to sIniFile
85137>>>>>>>>>>>        Set psFileName to (sPath + sIniFile)
85138>>>>>>>>>>>    End_Procedure
85139>>>>>>>>>>>
85139>>>>>>>>>>>    Function psIniFilePath Returns String
85141>>>>>>>>>>>        Function_Return (private_psIniFilePath(Self))
85142>>>>>>>>>>>    End_Function
85143>>>>>>>>>>>
85143>>>>>>>>>>>    Procedure Set psIniFileName String sFileName
85145>>>>>>>>>>>        String sPath
85145>>>>>>>>>>>        Get psIniFilePath to sPath
85146>>>>>>>>>>>        Set psFileName to (sPath + sFileName)
85147>>>>>>>>>>>        Set private_psIniFileName to sFileName
85148>>>>>>>>>>>    End_Procedure
85149>>>>>>>>>>>
85149>>>>>>>>>>>    Function psIniFileName Returns String
85151>>>>>>>>>>>        Function_Return (private_psIniFileName(Self))
85152>>>>>>>>>>>    End_Function
85153>>>>>>>>>>>
85153>>>>>>>>>>>    // *** Generalized messages to Get & Set values of the ini file.
85153>>>>>>>>>>>    // Sets a value in the program's ini file (write)
85153>>>>>>>>>>>    // Pass a section name, the value name parameter and the value itself to be written.
85153>>>>>>>>>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
85155>>>>>>>>>>>        String sIniFile sPath
85155>>>>>>>>>>>
85155>>>>>>>>>>>        Get psIniFilePath to sPath
85156>>>>>>>>>>>        Get psIniFileName to sIniFile
85157>>>>>>>>>>>        Move (sPath + sIniFile) to sIniFile
85158>>>>>>>>>>>        Set psFileName to sIniFile
85159>>>>>>>>>>>        Send WriteString sSection sValueName sValue
85160>>>>>>>>>>>    End_Procedure
85161>>>>>>>>>>>
85161>>>>>>>>>>>    // Get a value from program's ini-file (read)
85161>>>>>>>>>>>    // Pass a section name and the name of the value parameter & a default value.
85161>>>>>>>>>>>    // Returns the value
85161>>>>>>>>>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
85163>>>>>>>>>>>        String sValue sIniFile sPath
85163>>>>>>>>>>>
85163>>>>>>>>>>>        Get psIniFilePath to sPath
85164>>>>>>>>>>>        Get psIniFileName to sIniFile
85165>>>>>>>>>>>        Move (sPath + sIniFile) to sIniFile
85166>>>>>>>>>>>        Set psFileName to sIniFile
85167>>>>>>>>>>>        Get ReadString sSection sValueName sDefaultValue to sValue
85168>>>>>>>>>>>
85168>>>>>>>>>>>        Function_Return sValue
85169>>>>>>>>>>>    End_Function
85170>>>>>>>>>>>
85170>>>>>>>>>>>    // Sort function that first sorts on bEnabled & then on the connection string.
85170>>>>>>>>>>>    Function SortActiveFirst tSQLConnection SQLConnectionRow1 tSQLConnection SQLConnectionRow2 Returns Integer
85172>>>>>>>>>>>        If (SQLConnectionRow1.bEnabled > SQLConnectionRow2.bEnabled) ;            Function_Return (LT)
85175>>>>>>>>>>>        If (SQLConnectionRow1.bEnabled < SQLConnectionRow2.bEnabled) ;            Function_Return (GT)
85178>>>>>>>>>>>
85178>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionID < SQLConnectionRow2.sConnectionID) ;            Function_Return (LT)
85181>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionID > SQLConnectionRow2.sConnectionID) ;            Function_Return (GT)
85184>>>>>>>>>>>
85184>>>>>>>>>>>        If (SQLConnectionRow1.iDbType < SQLConnectionRow2.iDbType) ;            Function_Return (LT)
85187>>>>>>>>>>>        If (SQLConnectionRow1.iDbType > SQLConnectionRow2.iDbType) ;            Function_Return (GT)
85190>>>>>>>>>>>
85190>>>>>>>>>>>        If (SQLConnectionRow1.sServer < SQLConnectionRow2.sServer) ;            Function_Return (LT)
85193>>>>>>>>>>>        If (SQLConnectionRow1.sServer > SQLConnectionRow2.sServer) ;            Function_Return (GT)
85196>>>>>>>>>>>
85196>>>>>>>>>>>        If (SQLConnectionRow1.sDatabase < SQLConnectionRow2.sDatabase) ;            Function_Return (LT)
85199>>>>>>>>>>>        If (SQLConnectionRow1.sDatabase > SQLConnectionRow2.sDatabase) ;            Function_Return (GT)
85202>>>>>>>>>>>
85202>>>>>>>>>>>        If (SQLConnectionRow1.sDriverID < SQLConnectionRow2.sDriverID) ;            Function_Return (LT)
85205>>>>>>>>>>>        If (SQLConnectionRow1.sDriverID > SQLConnectionRow2.sDriverID) ;            Function_Return (GT)
85208>>>>>>>>>>>
85208>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionString < SQLConnectionRow2.sConnectionString) ;            Function_Return (LT)
85211>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionString > SQLConnectionRow2.sConnectionString) ;            Function_Return (GT)
85214>>>>>>>>>>>
85214>>>>>>>>>>>        Function_Return (EQ)
85215>>>>>>>>>>>    End_Function
85216>>>>>>>>>>>
85216>>>>>>>>>>>    Function SQLIniFileNumberOfConnections Returns Integer
85218>>>>>>>>>>>        Handle hoSections
85218>>>>>>>>>>>        Integer iItems
85218>>>>>>>>>>>
85218>>>>>>>>>>>        Send ReadSections hoSections
85219>>>>>>>>>>>        Move (Item_Count(hoSections)) to iItems
85220>>>>>>>>>>>        Function_Return iItems
85221>>>>>>>>>>>    End_Function
85222>>>>>>>>>>>
85222>>>>>>>>>>>    // The normal connection string looks something like this;
85222>>>>>>>>>>>    // "SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
85222>>>>>>>>>>>    // ...but the full connection string looks like this;
85222>>>>>>>>>>>    // "DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
85222>>>>>>>>>>>//    Function SQLIniFileAddConnection String sFullConnectionString Returns Boolean
85222>>>>>>>>>>>//        String sSection
85222>>>>>>>>>>>//        Integer iCount
85222>>>>>>>>>>>//
85222>>>>>>>>>>>//        Move False to Err
85222>>>>>>>>>>>//        Get psIniSectionName to sSection
85222>>>>>>>>>>>//        Get SQLIniFileNumberOfConnections to iCount
85222>>>>>>>>>>>//        Increment iCount
85222>>>>>>>>>>>//        Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to sFullConnectionString
85222>>>>>>>>>>>//
85222>>>>>>>>>>>//        Function_Return (Err = False)
85222>>>>>>>>>>>//    End_Function
85222>>>>>>>>>>>
85222>>>>>>>>>>>    Function SQLIniFileDeleteAllConnections Returns Boolean
85224>>>>>>>>>>>        Integer iCount
85224>>>>>>>>>>>        Boolean bExists
85224>>>>>>>>>>>        String sSection
85224>>>>>>>>>>>
85224>>>>>>>>>>>        Move False to Err
85225>>>>>>>>>>>        Move 1 to iCount
85226>>>>>>>>>>>        Get psIniSectionName to sSection
85227>>>>>>>>>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
85228>>>>>>>>>>>        While (bExists = True)
85232>>>>>>>>>>>            Send DeleteSection (CS_SQLIniSectionName + String(iCount))
85233>>>>>>>>>>>            Increment iCount
85234>>>>>>>>>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
85235>>>>>>>>>>>        Loop
85236>>>>>>>>>>>>
85236>>>>>>>>>>>        Function_Return (Err = False)
85237>>>>>>>>>>>    End_Function
85238>>>>>>>>>>>
85238>>>>>>>>>>>    Function SQLIniFileDeleteConnection Integer iItem Returns Boolean
85240>>>>>>>>>>>        Integer iCount
85240>>>>>>>>>>>        String sSection
85240>>>>>>>>>>>        Boolean bExists
85240>>>>>>>>>>>
85240>>>>>>>>>>>        Move False to Err
85241>>>>>>>>>>>        Move 1 to iCount
85242>>>>>>>>>>>        Get psIniSectionName to sSection
85243>>>>>>>>>>>        Get KeyExists sSection CS_SQLIniConnectionIdKeyword to bExists
85244>>>>>>>>>>>        While (bExists = True)
85248>>>>>>>>>>>            If (iCount = iItem) Begin
85250>>>>>>>>>>>                Send DeleteSection sSection
85251>>>>>>>>>>>//                Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to ""
85251>>>>>>>>>>>                Move 9999 to iCount // Just some ridiculously high number to get out of the loop as we're done.
85252>>>>>>>>>>>            End
85252>>>>>>>>>>>>
85252>>>>>>>>>>>            Increment iCount
85253>>>>>>>>>>>            Get KeyExists sSection (CS_SQLIniSectionName + String(iCount)) to bExists
85254>>>>>>>>>>>        Loop
85255>>>>>>>>>>>>
85255>>>>>>>>>>>
85255>>>>>>>>>>>        Function_Return (Err = False)
85256>>>>>>>>>>>    End_Function
85257>>>>>>>>>>>
85257>>>>>>>>>>>    // Returns all connection details for the passed Connection ID as a tSQLConnection
85257>>>>>>>>>>>    // If it fails the returned struct member SQLConnection.bError = True.
85257>>>>>>>>>>>    Function SQLIniFileConnectionID String sConnectionID Returns tSQLConnection
85259>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
85259>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
85260>>>>>>>>>>>        tSQLConnection   SQLConnection
85260>>>>>>>>>>>        tSQLConnection   SQLConnection
85260>>>>>>>>>>>        Integer iIndex
85260>>>>>>>>>>>
85260>>>>>>>>>>>        Get SQLIniFileConnectionIDIndex sConnectionID to iIndex
85261>>>>>>>>>>>        If (iIndex = -1) Begin
85263>>>>>>>>>>>            Move True to SQLConnection.bError
85264>>>>>>>>>>>            Function_Return SQLConnection
85265>>>>>>>>>>>        End
85265>>>>>>>>>>>>
85265>>>>>>>>>>>
85265>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
85266>>>>>>>>>>>        Move SQLConnectionsArray[iIndex -1] to SQLConnection
85267>>>>>>>>>>>
85267>>>>>>>>>>>        Function_Return SQLConnection
85268>>>>>>>>>>>    End_Function
85269>>>>>>>>>>>
85269>>>>>>>>>>>    // Returns -1 if the passed connection ID was not found, else the item number.
85269>>>>>>>>>>>    Function SQLIniFileConnectionIDIndex String sConnectionID Returns Integer
85271>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
85271>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
85272>>>>>>>>>>>        Integer iRetval iCount iSize
85272>>>>>>>>>>>        String sValue
85272>>>>>>>>>>>        Boolean bExists
85272>>>>>>>>>>>
85272>>>>>>>>>>>        Move -1 to iRetval
85273>>>>>>>>>>>
85273>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
85274>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
85275>>>>>>>>>>>        Decrement iSize
85276>>>>>>>>>>>        For iCount from 0 to iSize
85282>>>>>>>>>>>>
85282>>>>>>>>>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
85283>>>>>>>>>>>            Move (Uppercase(sValue) = Uppercase(sConnectionID)) to bExists
85284>>>>>>>>>>>            If (bExists) Begin
85286>>>>>>>>>>>                Move (iCount + 1) to iRetval // The [ConnectionX] keys are one-based (starts at 1) but the loop starts at zero.
85287>>>>>>>>>>>                Move iSize to iCount         // We're done!
85288>>>>>>>>>>>            End
85288>>>>>>>>>>>>
85288>>>>>>>>>>>        Loop
85289>>>>>>>>>>>>
85289>>>>>>>>>>>
85289>>>>>>>>>>>        Function_Return iRetval
85290>>>>>>>>>>>    End_Function
85291>>>>>>>>>>>
85291>>>>>>>>>>>    // Checks if the passed sConnectionID exists more than once in the passed struct array.
85291>>>>>>>>>>>    // Used to check that ConnectionID's are unique.
85291>>>>>>>>>>>    Function IsConnectionIDDuplicate String sConnectionID Returns Boolean
85293>>>>>>>>>>>        Integer iCount iSize iItems
85293>>>>>>>>>>>        String sValue
85293>>>>>>>>>>>        Boolean bExists
85293>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
85293>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
85294>>>>>>>>>>>
85294>>>>>>>>>>>        Move 0 to iItems
85295>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
85296>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
85297>>>>>>>>>>>        Decrement iSize
85298>>>>>>>>>>>        For iCount from 0 to iSize
85304>>>>>>>>>>>>
85304>>>>>>>>>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
85305>>>>>>>>>>>            Move (sValue = sConnectionID) to bExists
85306>>>>>>>>>>>            If (bExists) Begin
85308>>>>>>>>>>>                Increment iItems
85309>>>>>>>>>>>            End
85309>>>>>>>>>>>>
85309>>>>>>>>>>>        Loop
85310>>>>>>>>>>>>
85310>>>>>>>>>>>
85310>>>>>>>>>>>        Function_Return (iItems > 1)
85311>>>>>>>>>>>    End_Function
85312>>>>>>>>>>>
85312>>>>>>>>>>>    // To update the SQLConnections.ini file with a new default Connection ID.
85312>>>>>>>>>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
85314>>>>>>>>>>>        Boolean bOK
85314>>>>>>>>>>>        Integer iSize iCount
85314>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
85314>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
85315>>>>>>>>>>>        tSQLConnection SQLConnection
85315>>>>>>>>>>>        tSQLConnection SQLConnection
85315>>>>>>>>>>>        String sConnectionString
85315>>>>>>>>>>>
85315>>>>>>>>>>>        Move False to Err
85316>>>>>>>>>>>        Get psConnectionString to sConnectionString
85317>>>>>>>>>>>
85317>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
85318>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
85319>>>>>>>>>>>        Decrement iSize
85320>>>>>>>>>>>        // Set all current connection to inactive.
85320>>>>>>>>>>>        For iCount from 0 to iSize
85326>>>>>>>>>>>>
85326>>>>>>>>>>>            Move False to SQLConnectionsArray[iCount].bEnabled
85327>>>>>>>>>>>        Loop
85328>>>>>>>>>>>>
85328>>>>>>>>>>>
85328>>>>>>>>>>>        Get SQLIniFileConnectionID sConnectionID to SQLConnection
85329>>>>>>>>>>>        Move True              to SQLConnection.bEnabled
85330>>>>>>>>>>>        Move sConnectionString to SQLConnection.sConnectionString
85331>>>>>>>>>>>        Move (InsertInArray(SQLConnectionsArray, 0, SQLConnection)) to SQLConnectionsArray
85332>>>>>>>>>>>        Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
85333>>>>>>>>>>>
85333>>>>>>>>>>>        Function_Return (bOK = True)
85334>>>>>>>>>>>    End_Function
85335>>>>>>>>>>>
85335>>>>>>>>>>>    // Used for updating an existing connection with new data.
85335>>>>>>>>>>>    // Returns True if successful.
85335>>>>>>>>>>>    Function SQLIniFileUpdateConnection tSQLConnection SQLConnection Returns Boolean
85337>>>>>>>>>>>        Boolean bOK
85337>>>>>>>>>>>        Integer iItem iSize iCount
85337>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
85337>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
85338>>>>>>>>>>>
85338>>>>>>>>>>>        Move False to Err
85339>>>>>>>>>>>        Move -1 to iItem
85340>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
85341>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
85342>>>>>>>>>>>        Decrement iSize
85343>>>>>>>>>>>        // Set all current connection to inactive.
85343>>>>>>>>>>>        For iCount from 0 to iSize
85349>>>>>>>>>>>>
85349>>>>>>>>>>>            Move False to SQLConnectionsArray[iCount].bEnabled
85350>>>>>>>>>>>            If (SQLConnectionsArray[iCount].sConnectionID = SQLConnection.sConnectionID) Begin
85352>>>>>>>>>>>                Move iCount to iItem
85353>>>>>>>>>>>            End
85353>>>>>>>>>>>>
85353>>>>>>>>>>>        Loop
85354>>>>>>>>>>>>
85354>>>>>>>>>>>
85354>>>>>>>>>>>        If (iItem <> -1) Begin
85356>>>>>>>>>>>            Move True to SQLConnection.bEnabled
85357>>>>>>>>>>>            Move SQLConnection to SQLConnectionsArray[iItem]
85358>>>>>>>>>>>            Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
85359>>>>>>>>>>>        End
85359>>>>>>>>>>>>
85359>>>>>>>>>>>
85359>>>>>>>>>>>        Function_Return (bOK = True)
85360>>>>>>>>>>>    End_Function
85361>>>>>>>>>>>
85361>>>>>>>>>>>    Function SQLIniFileReadConnections Returns tSQLConnection[]
85363>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
85363>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
85364>>>>>>>>>>>        String sSection sValue
85364>>>>>>>>>>>        Integer iCount
85364>>>>>>>>>>>        Boolean bExists
85364>>>>>>>>>>>
85364>>>>>>>>>>>        Get psIniSectionName to sSection
85365>>>>>>>>>>>        Get SectionExists sSection to bExists
85366>>>>>>>>>>>        If (bExists = False) Begin
85368>>>>>>>>>>>            Function_Return SQLConnectionsArray
85369>>>>>>>>>>>        End
85369>>>>>>>>>>>>
85369>>>>>>>>>>>        Get SectionExists CS_SQLIniConnectionSection to bExists
85370>>>>>>>>>>>        If (bExists = True) Begin
85372>>>>>>>>>>>            Error DFERR_PROGRAM "Sorry, the format for the SQLConnections.ini file has been changed and this file has the old format that is no longer valid and thus cannot be read. You need to re-enter your connection(s)."
85373>>>>>>>>>>>>
85373>>>>>>>>>>>        End
85373>>>>>>>>>>>>
85373>>>>>>>>>>>
85373>>>>>>>>>>>        Move 1 to iCount // The section name "[ConnectionXX]" starts with "1"
85374>>>>>>>>>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
85375>>>>>>>>>>>
85375>>>>>>>>>>>        While (bExists = True)                 
85379>>>>>>>>>>>            // 2018-07-14 Change to allow disabling all connections in test environment.
85379>>>>>>>>>>>            // We always put the enabled/active connection at the top
85379>>>>>>>>>>>//            Move (iCount = 1) to bEnabled
85379>>>>>>>>>>>//            Move bEnabled to SQLConnectionsArray[iCount].bEnabled
85379>>>>>>>>>>>
85379>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionIdKeyword ""        to SQLConnectionsArray[iCount].sConnectionID
85380>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDriverKeyword       ""        to SQLConnectionsArray[iCount].sDriverID
85381>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDisabledKeyword     ""        to sValue
85382>>>>>>>>>>>            Move (If(Uppercase(sValue) = "YES", False, True))                                               to SQLConnectionsArray[iCount].bEnabled
85383>>>>>>>>>>>
85383>>>>>>>>>>>            // The iDbType might be missing from the ini-file. This is e.g. the case when a DAW Managed Connection "DFConnId.ini" file is read.
85383>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDbTypeKeyword       "99"      to sValue
85384>>>>>>>>>>>            If (sValue = "99") Begin
85386>>>>>>>>>>>                Get SqlUtilDbTypeFromDriver SQLConnectionsArray[iCount].sDriverID to sValue
85387>>>>>>>>>>>            End
85387>>>>>>>>>>>>
85387>>>>>>>>>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].iDbType
85388>>>>>>>>>>>
85388>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionKeyWord   ""        to SQLConnectionsArray[iCount].sConnectionString
85389>>>>>>>>>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnectionsArray[iCount].sServer
85390>>>>>>>>>>>            If (SQLConnectionsArray[iCount].sServer = "") Begin
85392>>>>>>>>>>>                Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniFileDSNKeyword +"=") to SQLConnectionsArray[iCount].sServer
85393>>>>>>>>>>>            End
85393>>>>>>>>>>>>
85393>>>>>>>>>>>            If (SQLConnectionsArray[iCount].sServer = "") Begin
85395>>>>>>>>>>>                Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDSNKeyword +"=")   to SQLConnectionsArray[iCount].sServer
85396>>>>>>>>>>>            End
85396>>>>>>>>>>>>
85396>>>>>>>>>>>
85396>>>>>>>>>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnectionsArray[iCount].sDatabase
85397>>>>>>>>>>>
85397>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniTrustedKeyword      ""        to sValue
85398>>>>>>>>>>>            Move (If(Uppercase(sValue) = "YES", True, False))                                               to SQLConnectionsArray[iCount].bTrusted
85399>>>>>>>>>>>
85399>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniUIDKeyword          ""        to SQLConnectionsArray[iCount].sUserID
85400>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDFPWDKeyword        ""        to sValue
85401>>>>>>>>>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
85403>>>>>>>>>>>                Get DecryptPassword sValue to sValue
85404>>>>>>>>>>>            End
85404>>>>>>>>>>>>
85404>>>>>>>>>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].sPassword
85405>>>>>>>>>>>
85405>>>>>>>>>>>            // Here we reconstruct the connection string to be complete with all params;
85405>>>>>>>>>>>            Get ConstructConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                          SQLConnectionsArray[iCount].bTrusted SQLConnectionsArray[iCount].sUserID SQLConnectionsArray[iCount].sPassword ;                                          to SQLConnectionsArray[iCount].sConnectionString
85406>>>>>>>>>>>
85406>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSchemaKeyword          ""     to SQLConnectionsArray[iCount].sSchema
85407>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniBaseTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sBaseTableSpace
85408>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniLongTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sLongTableSpace
85409>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniIndexTableSpaceKeyword ""     to SQLConnectionsArray[iCount].sIndexTableSpace
85410>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSilentLoginKeyword     ""     to sValue
85411>>>>>>>>>>>            Move (If(Uppercase(sValue) = "YES", True, False))                                               to SQLConnectionsArray[iCount].bSilentLogin
85412>>>>>>>>>>>
85412>>>>>>>>>>>            Increment iCount
85413>>>>>>>>>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
85414>>>>>>>>>>>        Loop
85415>>>>>>>>>>>>
85415>>>>>>>>>>>
85415>>>>>>>>>>>        // Lastly, we remove the very first array item as it is empty (we started at 1 because that is the first [Connection#])
85415>>>>>>>>>>>        If (SizeOfArray(SQLConnectionsArray) > 0) Begin
85417>>>>>>>>>>>            Move (RemoveFromArray(SQLConnectionsArray, 0)) to SQLConnectionsArray
85418>>>>>>>>>>>        End
85418>>>>>>>>>>>>
85418>>>>>>>>>>>
85418>>>>>>>>>>>        Function_Return SQLConnectionsArray
85419>>>>>>>>>>>    End_Function
85420>>>>>>>>>>>
85420>>>>>>>>>>>    Function SQLIniFileWriteConnections tSQLConnection[] SQLConnectionsArray Returns Boolean
85422>>>>>>>>>>>        Integer iCount iSize
85422>>>>>>>>>>>        Boolean bOK
85422>>>>>>>>>>>        String sSection sValue
85422>>>>>>>>>>>
85422>>>>>>>>>>>        // First we need to _remove_ all current connections from the ini-file.
85422>>>>>>>>>>>        Move 0 to iCount
85423>>>>>>>>>>>        Get SQLIniFileDeleteAllConnections to bOK
85424>>>>>>>>>>>        If (bOK = False) Begin
85426>>>>>>>>>>>            Function_Return False
85427>>>>>>>>>>>        End
85427>>>>>>>>>>>>
85427>>>>>>>>>>>
85427>>>>>>>>>>>        Move False to Err
85428>>>>>>>>>>>        Get psIniSectionName to sSection
85429>>>>>>>>>>>        // Sorting will make sure we have the active connection record as the first connection item in the ini-file.
85429>>>>>>>>>>>        Move (SortArray(SQLConnectionsArray, Self, (RefFunc(SortActiveFirst)))) to SQLConnectionsArray
85430>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
85431>>>>>>>>>>>        Decrement iSize
85432>>>>>>>>>>>
85432>>>>>>>>>>>        For iCount from 0 to iSize
85438>>>>>>>>>>>>
85438>>>>>>>>>>>            // DF 19 compatible settings:
85438>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionIdKeyword   to SQLConnectionsArray[iCount].sConnectionID
85439>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDriverKeyword         to SQLConnectionsArray[iCount].sDriverID
85440>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDisabledKeyword       to (If(SQLConnectionsArray[iCount].bEnabled = 0, "Yes", "No"))
85441>>>>>>>>>>>            
85441>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniUIDKeyword            to SQLConnectionsArray[iCount].sUserID
85442>>>>>>>>>>>
85442>>>>>>>>>>>            Move SQLConnectionsArray[iCount].sPassword to sValue
85443>>>>>>>>>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
85445>>>>>>>>>>>                Get EncryptPassword sValue to sValue
85446>>>>>>>>>>>            End
85446>>>>>>>>>>>>
85446>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDFPWDKeyword          to sValue
85447>>>>>>>>>>>
85447>>>>>>>>>>>            If (SQLConnectionsArray[iCount].bTrusted = True) Begin
85449>>>>>>>>>>>                Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniTrustedKeyword    to CS_SQLIniConnectionYes
85450>>>>>>>>>>>            End
85450>>>>>>>>>>>>
85450>>>>>>>>>>>
85450>>>>>>>>>>>            Get ConstructShortConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                            to SQLConnectionsArray[iCount].sConnectionString
85451>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionKeyWord     to SQLConnectionsArray[iCount].sConnectionString
85452>>>>>>>>>>>
85452>>>>>>>>>>>            // The Database Update Framework extended settings:
85452>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDbTypeKeyword          to SQLConnectionsArray[iCount].iDbType
85453>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSchemaKeyword          to SQLConnectionsArray[iCount].sSchema
85454>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniBaseTableSpaceKeyword  to SQLConnectionsArray[iCount].sBaseTableSpace
85455>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniLongTableSpaceKeyword  to SQLConnectionsArray[iCount].sLongTableSpace
85456>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniIndexTableSpaceKeyword to SQLConnectionsArray[iCount].sIndexTableSpace
85457>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSilentLoginKeyword     to (If(SQLConnectionsArray[iCount].bSilentLogin = 1, "Yes", "No"))
85458>>>>>>>>>>>        Loop
85459>>>>>>>>>>>>
85459>>>>>>>>>>>
85459>>>>>>>>>>>        Function_Return (bOK and Err = False)
85460>>>>>>>>>>>    End_Function
85461>>>>>>>>>>>
85461>>>>>>>>>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
85461>>>>>>>>>>>    //
85461>>>>>>>>>>>    // SQL utility function that returns a database type (string) constant
85461>>>>>>>>>>>    // corresponding to the passed iDbType.
85461>>>>>>>>>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
85463>>>>>>>>>>>        String sRetval
85463>>>>>>>>>>>        If (iDbType = EN_dbTypeMSSQL) Begin
85465>>>>>>>>>>>            Move CS_dbTypeMSSQL to sRetval
85466>>>>>>>>>>>        End
85466>>>>>>>>>>>>
85466>>>>>>>>>>>        If (iDbType = EN_dbTypeMySQL) Begin
85468>>>>>>>>>>>            Move CS_dbTypeMySQL to sRetval
85469>>>>>>>>>>>        End
85469>>>>>>>>>>>>
85469>>>>>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
85471>>>>>>>>>>>            Move CS_dbTypeOracle to sRetval
85472>>>>>>>>>>>        End
85472>>>>>>>>>>>>
85472>>>>>>>>>>>        If (iDbType = EN_dbTypeDB2) Begin
85474>>>>>>>>>>>            Move CS_dbTypeDB2 to sRetval
85475>>>>>>>>>>>        End
85475>>>>>>>>>>>>
85475>>>>>>>>>>>        If (iDbType = EN_dbTypePostgre) Begin
85477>>>>>>>>>>>            Move CS_dbTypePostgre to sRetval
85478>>>>>>>>>>>        End
85478>>>>>>>>>>>>
85478>>>>>>>>>>>        If (iDbType = EN_DbTypePervasive) Begin
85480>>>>>>>>>>>            Move CS_DbTypePervasive to sRetval
85481>>>>>>>>>>>        End
85481>>>>>>>>>>>>
85481>>>>>>>>>>>        Function_Return sRetval
85482>>>>>>>>>>>    End_Function
85483>>>>>>>>>>>
85483>>>>>>>>>>>    // SQL utility function that returns a database type constant (integer)
85483>>>>>>>>>>>    // corresponding to the passed sDbType string constant.
85483>>>>>>>>>>>    Function SqlUtilDbTypeToInteger String sDbType  Returns Integer
85485>>>>>>>>>>>        Integer iRetval
85485>>>>>>>>>>>        If (sDbType = CS_dbTypeMSSQL) Begin
85487>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
85488>>>>>>>>>>>        End
85488>>>>>>>>>>>>
85488>>>>>>>>>>>        If (sDbType = CS_dbTypeMySQL) Begin
85490>>>>>>>>>>>            Move EN_dbTypeMySQL to iRetval
85491>>>>>>>>>>>        End
85491>>>>>>>>>>>>
85491>>>>>>>>>>>        If (sDbType = CS_dbTypeOracle) Begin
85493>>>>>>>>>>>            Move EN_dbTypeOracle to iRetval
85494>>>>>>>>>>>        End
85494>>>>>>>>>>>>
85494>>>>>>>>>>>        If (sDbType = CS_dbTypeDB2) Begin
85496>>>>>>>>>>>            Move EN_dbTypeDB2 to iRetval
85497>>>>>>>>>>>        End
85497>>>>>>>>>>>>
85497>>>>>>>>>>>        If (sDbType = CS_dbTypePostgre) Begin
85499>>>>>>>>>>>            Move EN_dbTypePostgre to iRetval
85500>>>>>>>>>>>        End
85500>>>>>>>>>>>>
85500>>>>>>>>>>>        If (sDbType = CS_DbTypePervasive) Begin
85502>>>>>>>>>>>            Move EN_DbTypePervasive to iRetval
85503>>>>>>>>>>>        End
85503>>>>>>>>>>>>
85503>>>>>>>>>>>        Function_Return iRetval
85504>>>>>>>>>>>    End_Function
85505>>>>>>>>>>>
85505>>>>>>>>>>>    // Pass an integer DbType and function returns the database type integer as a string value.
85505>>>>>>>>>>>    // Used e.g. when reading a connection ini-file to display the database type in
85505>>>>>>>>>>>    // the SQL Connection program's grid.
85505>>>>>>>>>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
85507>>>>>>>>>>>        String sRetval
85507>>>>>>>>>>>        If (iDbType = EN_dbTypeMSSQL) Begin
85509>>>>>>>>>>>            Move "EN_dbTypeMSSQL" to sRetval
85510>>>>>>>>>>>        End
85510>>>>>>>>>>>>
85510>>>>>>>>>>>        If (iDbType = EN_dbTypeMySQL) Begin
85512>>>>>>>>>>>            Move "EN_dbTypeMySQL" to sRetval
85513>>>>>>>>>>>        End
85513>>>>>>>>>>>>
85513>>>>>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
85515>>>>>>>>>>>            Move "EN_dbTypeOracle" to sRetval
85516>>>>>>>>>>>        End
85516>>>>>>>>>>>>
85516>>>>>>>>>>>        If (iDbType = EN_dbTypeDB2) Begin
85518>>>>>>>>>>>            Move "EN_dbTypeDB2" to sRetval
85519>>>>>>>>>>>        End
85519>>>>>>>>>>>>
85519>>>>>>>>>>>        If (iDbType = EN_dbTypePostgre) Begin
85521>>>>>>>>>>>            Move "EN_dbTypePostgre" to sRetval
85522>>>>>>>>>>>        End
85522>>>>>>>>>>>>
85522>>>>>>>>>>>        If (iDbType = EN_DbTypePervasive) Begin
85524>>>>>>>>>>>            Move "EN_dbTypePervasive" to sRetval
85525>>>>>>>>>>>        End
85525>>>>>>>>>>>>
85525>>>>>>>>>>>        Function_Return sRetval
85526>>>>>>>>>>>    End_Function
85527>>>>>>>>>>>
85527>>>>>>>>>>>    // Pass a driver id and the function will return
85527>>>>>>>>>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
85527>>>>>>>>>>>    // quite work and always returns "MS SQL Server"
85527>>>>>>>>>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
85529>>>>>>>>>>>        Integer iRetval
85529>>>>>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
85531>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
85532>>>>>>>>>>>        End
85532>>>>>>>>>>>>
85532>>>>>>>>>>>        If (sDriverID = SQLFLEX) Begin
85534>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
85535>>>>>>>>>>>        End
85535>>>>>>>>>>>>
85535>>>>>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
85537>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
85538>>>>>>>>>>>        End
85538>>>>>>>>>>>>
85538>>>>>>>>>>>        If (sDriverID = MDSMySQL) Begin
85540>>>>>>>>>>>            Move EN_dbTypeMySQL to iRetval
85541>>>>>>>>>>>        End
85541>>>>>>>>>>>>
85541>>>>>>>>>>>        If (sDriverID = ORAFLEX) Begin
85543>>>>>>>>>>>            Move EN_dbTypeOracle to iRetval
85544>>>>>>>>>>>        End
85544>>>>>>>>>>>>
85544>>>>>>>>>>>        If (sDriverID = DB2_DRV_ID) Begin
85546>>>>>>>>>>>            Move EN_dbTypeDB2 to iRetval
85547>>>>>>>>>>>        End
85547>>>>>>>>>>>>
85547>>>>>>>>>>>        If (sDriverID = MDSPgSQL) Begin
85549>>>>>>>>>>>            Move EN_dbTypePostgre to iRetval
85550>>>>>>>>>>>        End
85550>>>>>>>>>>>>
85550>>>>>>>>>>>        If (sDriverID = DFBTRDRV_ID) Begin
85552>>>>>>>>>>>            Move EN_DbTypePervasive to iRetval
85553>>>>>>>>>>>        End
85553>>>>>>>>>>>>
85553>>>>>>>>>>>        Function_Return iRetval
85554>>>>>>>>>>>    End_Function
85555>>>>>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
85555>>>>>>>>>>>>
85555>>>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
85557>>>>>>>>>>>>    Integer iStart iEnd
85557>>>>>>>>>>>>    String sRetval
85557>>>>>>>>>>>>
85557>>>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
85558>>>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
85559>>>>>>>>>>>>    If (iStart = 0) Begin
85561>>>>>>>>>>>>        Function_Return ""
85562>>>>>>>>>>>>    End
85562>>>>>>>>>>>>>
85562>>>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
85563>>>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
85564>>>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
85566>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
85567>>>>>>>>>>>>    End
85567>>>>>>>>>>>>>
85567>>>>>>>>>>>>    Else Begin
85568>>>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
85569>>>>>>>>>>>>    End
85569>>>>>>>>>>>>>
85569>>>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
85571>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
85572>>>>>>>>>>>>        Decrement iEnd
85573>>>>>>>>>>>>    End
85573>>>>>>>>>>>>>
85573>>>>>>>>>>>>    If (iEnd <> 0) Begin
85575>>>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
85576>>>>>>>>>>>>    End
85576>>>>>>>>>>>>>
85576>>>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
85577>>>>>>>>>>>>
85577>>>>>>>>>>>>    Function_Return (Trim(sRetval))
85578>>>>>>>>>>>>End_Function
85579>>>>>>>>>>>>
85579>>>>>>>>>>>>
85579>>>>>>>>>>>
85579>>>>>>>>>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
85581>>>>>>>>>>>        String sConnect
85581>>>>>>>>>>>        Handle hoDriver
85581>>>>>>>>>>>
85581>>>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
85582>>>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
85583>>>>>>>>>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
85584>>>>>>>>>>>        Send Destroy of hoDriver
85585>>>>>>>>>>>
85585>>>>>>>>>>>        Function_Return sConnect
85586>>>>>>>>>>>    End_Function
85587>>>>>>>>>>>
85587>>>>>>>>>>>    // Short connection string used when writing to ini-file. This is to be compatible with DF19 DFConnId.ini files that uses this short format.
85587>>>>>>>>>>>    Function ConstructShortConnectionString String sDriverID String sServer String sDatabase Returns String
85589>>>>>>>>>>>        String sConnect
85589>>>>>>>>>>>
85589>>>>>>>>>>>        Case Begin
85589>>>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID or sDriverID = SQLFLEX)
85591>>>>>>>>>>>                Move (sConnect * CS_SQLIniServerKeyword + "=" + sServer) to sConnect
85592>>>>>>>>>>>                If (sDatabase <> "") Begin
85594>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
85595>>>>>>>>>>>                End
85595>>>>>>>>>>>>
85595>>>>>>>>>>>                Case Break
85596>>>>>>>>>>>
85596>>>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
85599>>>>>>>>>>>                If (Uppercase(sServer) contains ".DSN") Begin
85601>>>>>>>>>>>                    Move (CS_SQLIniFileDSNKeyword + "=" + sServer) to sConnect
85602>>>>>>>>>>>                End
85602>>>>>>>>>>>>
85602>>>>>>>>>>>                Else If (not(Uppercase(sServer) contains "DSN")) Begin
85605>>>>>>>>>>>                    Move (CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
85606>>>>>>>>>>>                End
85606>>>>>>>>>>>>
85606>>>>>>>>>>>
85606>>>>>>>>>>>                If (sDatabase <> "") Begin
85608>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
85609>>>>>>>>>>>                End
85609>>>>>>>>>>>>
85609>>>>>>>>>>>                Case Break
85610>>>>>>>>>>>
85610>>>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
85613>>>>>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
85614>>>>>>>>>>>                If (sDatabase <> "") Begin
85616>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
85617>>>>>>>>>>>                End
85617>>>>>>>>>>>>
85617>>>>>>>>>>>                Case Break
85618>>>>>>>>>>>
85618>>>>>>>>>>>            Case (sDriverID = ORAFLEX)
85621>>>>>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
85622>>>>>>>>>>>                If (sDatabase <> "") Begin
85624>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
85625>>>>>>>>>>>                End
85625>>>>>>>>>>>>
85625>>>>>>>>>>>                Case Break
85626>>>>>>>>>>>
85626>>>>>>>>>>>            Case (sDriverID = MDSPgSQL)
85629>>>>>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
85630>>>>>>>>>>>                If (sDatabase <> "") Begin
85632>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
85633>>>>>>>>>>>                End
85633>>>>>>>>>>>>
85633>>>>>>>>>>>                Case Break
85634>>>>>>>>>>>
85634>>>>>>>>>>>            Case (sDriverID = MDSMySQL)
85637>>>>>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
85638>>>>>>>>>>>                If (sDatabase <> "") Begin
85640>>>>>>>>>>>                    Move (sConnect * ";" +CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
85641>>>>>>>>>>>                End
85641>>>>>>>>>>>>
85641>>>>>>>>>>>                Case Break
85642>>>>>>>>>>>
85642>>>>>>>>>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
85645>>>>>>>>>>>                Break
85646>>>>>>>>>>>
85646>>>>>>>>>>>            Case Else
85646>>>>>>>>>>>                Move "" to sConnect
85647>>>>>>>>>>>        Case End
85647>>>>>>>>>>>
85647>>>>>>>>>>>        Function_Return sConnect
85648>>>>>>>>>>>    End_Function
85649>>>>>>>>>>>
85649>>>>>>>>>>>    // Use Base64
85649>>>>>>>>>>>    Function EncryptPassword String sPassword Returns String
85651>>>>>>>>>>>        String sRetval
85651>>>>>>>>>>>        Handle hoLoginEncryption
85651>>>>>>>>>>>
85651>>>>>>>>>>>        Get Create (RefClass(cLoginEncryption)) to hoLoginEncryption
85652>>>>>>>>>>>        Set psEncryptPassword of hoLoginEncryption to (psHashString(Self))
85653>>>>>>>>>>>        Get EncryptPassword of hoLoginEncryption sPassword to sRetval
85654>>>>>>>>>>>        Send Destroy of hoLoginEncryption
85655>>>>>>>>>>>          
85655>>>>>>>>>>>        Function_Return sRetval
85656>>>>>>>>>>>    End_Function
85657>>>>>>>>>>>
85657>>>>>>>>>>>    Function DecryptPassword String sPassword Returns String
85659>>>>>>>>>>>        String sRetval
85659>>>>>>>>>>>        Handle hoLoginEncryption
85659>>>>>>>>>>>
85659>>>>>>>>>>>        Get Create (RefClass(cLoginEncryption)) to hoLoginEncryption
85660>>>>>>>>>>>        Set psEncryptPassword of hoLoginEncryption to (psHashString(Self))
85661>>>>>>>>>>>        Get DecryptPassword of hoLoginEncryption sPassword to sRetval
85662>>>>>>>>>>>        Send Destroy of hoLoginEncryption
85663>>>>>>>>>>>
85663>>>>>>>>>>>        Function_Return sRetval
85664>>>>>>>>>>>    End_Function
85665>>>>>>>>>>>
85665>>>>>>>>>>>    // Returns the full path of the Application (no trailing "\")
85665>>>>>>>>>>>    Function ApplicationPath Returns String
85667>>>>>>>>>>>        String sApplicationFileName sPath
85667>>>>>>>>>>>        Integer iNumChars iRetval
85667>>>>>>>>>>>
85667>>>>>>>>>>>        Move (Repeat(Character(0), 1024))    to sApplicationFileName
85668>>>>>>>>>>>        Move (GetModuleFileName(0, AddressOf(sApplicationFileName), 1024)) to iNumChars
85669>>>>>>>>>>>        Move (CString(sApplicationFileName)) to sApplicationFileName
85670>>>>>>>>>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to iRetval
85671>>>>>>>>>>>        Move (CString(sApplicationFileName)) to sPath
85672>>>>>>>>>>>
85672>>>>>>>>>>>        Function_Return sPath
85673>>>>>>>>>>>    End_Function
85674>>>>>>>>>>>
85674>>>>>>>>>>>    // Pass a filename including the extension. The return value
85674>>>>>>>>>>>    // will be the path of of the first found "sSearchFileName in the workspace.
85674>>>>>>>>>>>    // If not found in the workspace it will be search "globally" by the Get_File_Path command.
85674>>>>>>>>>>>    Function SearchLocallyThenGloballyForFile String sSearchFileName Returns String
85676>>>>>>>>>>>        Boolean bExists
85676>>>>>>>>>>>        Handle hoPaths hoIniFile
85676>>>>>>>>>>>        String[] asWorkSpaceFiles
85677>>>>>>>>>>>        String sProgramsPath sSection sFileName sRelativePath sRelativePaths sPath sDirSep sProgramsDir
85677>>>>>>>>>>>        Integer iSize iCount iPath iNoOfPaths iCountPath
85677>>>>>>>>>>>        
85677>>>>>>>>>>>        Get psIniFilePath to sProgramsPath
85678>>>>>>>>>>>        Get vFolderFormat sProgramsPath to sProgramsPath 
85679>>>>>>>>>>>        Move (Lowercase(sSearchFileName)) to sSearchFileName
85680>>>>>>>>>>>        Get vFilePathExists (sProgramsPath + sSearchFileName) to bExists   
85681>>>>>>>>>>>        If (bExists = True) Begin
85683>>>>>>>>>>>            Function_Return sProgramsPath
85684>>>>>>>>>>>        End                      
85684>>>>>>>>>>>>
85684>>>>>>>>>>>    
85684>>>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
85685>>>>>>>>>>>        If (Right(sProgramsPath, 1) ="\") Begin
85687>>>>>>>>>>>            Move (Left(sProgramsPath, Length(sProgramsPath) -1)) to sProgramsPath        
85688>>>>>>>>>>>        End                                              
85688>>>>>>>>>>>>
85688>>>>>>>>>>>        Get StringFromRightOfChar sProgramsPath sDirSep to sProgramsDir
85689>>>>>>>>>>>        
85689>>>>>>>>>>>        Move False to bExists
85690>>>>>>>>>>>        Get Create (RefClass(Array)) to hoPaths
85691>>>>>>>>>>>        Get WorkspaceIniFiles sProgramsPath to asWorkspaceFiles
85692>>>>>>>>>>>        Move (SizeOfArray(asWorkspaceFiles)) to iSize
85693>>>>>>>>>>>        Decrement iSize       
85694>>>>>>>>>>>        
85694>>>>>>>>>>>        For iCount from 0 to iSize
85700>>>>>>>>>>>>
85700>>>>>>>>>>>            Move asWorkspaceFiles[iCount] to sFileName
85701>>>>>>>>>>>            Get Create (Refclass(cIniFile)) to hoIniFile
85702>>>>>>>>>>>            Set psFileName of hoIniFile to sFileName
85703>>>>>>>>>>>            Send ReadSection of hoIniFile "Workspace" hoPaths
85704>>>>>>>>>>>            For iPath from 0 to (Item_Count(hoPaths) -1)
85710>>>>>>>>>>>>
85710>>>>>>>>>>>                Get Value of hoPaths iPath to sSection    
85711>>>>>>>>>>>                Get ReadString of hoIniFile "Workspace" sSection "" to sRelativePath 
85712>>>>>>>>>>>                // Check if there are more than one path specified;
85712>>>>>>>>>>>                Get CountOfPaths of (phoWorkspace(ghoApplication)) sRelativePath to iNoOfPaths
85713>>>>>>>>>>>                If (iNoOfPaths > 1) Begin         
85715>>>>>>>>>>>                    Move sRelativePath to sRelativePaths
85716>>>>>>>>>>>                    For iCountPath from 1 to iNoOfPaths
85722>>>>>>>>>>>>
85722>>>>>>>>>>>                        Get PathAtIndex of (phoWorkspace(ghoApplication)) sRelativePaths iCountPath to sRelativePath
85723>>>>>>>>>>>                        Get FullPathNames of (phoWorkspace(ghoApplication)) sRelativePath to sPath   
85724>>>>>>>>>>>                        Move (Replace((sDirSep + sProgramsDir + sDirSep), sPath, sDirSep)) to sPath
85725>>>>>>>>>>>                        Get vFolderFormat sPath to sPath
85726>>>>>>>>>>>                        Get vFilePathExists (sPath + sSearchFileName) to bExists
85727>>>>>>>>>>>                        If (bExists = True) Begin
85729>>>>>>>>>>>                            Move iNoOfPaths to iCountPath
85730>>>>>>>>>>>                            Move (Item_Count(hoPaths)) to iPath // We're done.
85731>>>>>>>>>>>                            Move iSize to iCount
85732>>>>>>>>>>>                        End                                                    
85732>>>>>>>>>>>>
85732>>>>>>>>>>>                    Loop
85733>>>>>>>>>>>>
85733>>>>>>>>>>>                End
85733>>>>>>>>>>>>
85733>>>>>>>>>>>                Else Begin
85734>>>>>>>>>>>                    Get FullPathNames of (phoWorkspace(ghoApplication)) sRelativePath to sPath   
85735>>>>>>>>>>>                    Move (Replace((sDirSep + sProgramsDir + sDirSep), sPath, sDirSep)) to sPath
85736>>>>>>>>>>>                    Get vFolderFormat sPath to sPath
85737>>>>>>>>>>>                    Get vFilePathExists (sPath + sSearchFileName) to bExists
85738>>>>>>>>>>>                    If (bExists = True) Begin
85740>>>>>>>>>>>                        Move (Item_Count(hoPaths)) to iPath // We're done.
85741>>>>>>>>>>>                        Move iSize to iCount
85742>>>>>>>>>>>                    End                                                    
85742>>>>>>>>>>>>
85742>>>>>>>>>>>                End
85742>>>>>>>>>>>>
85742>>>>>>>>>>>            Loop
85743>>>>>>>>>>>>
85743>>>>>>>>>>>            If (bExists = False) Begin
85745>>>>>>>>>>>                Move "" to sPath    
85746>>>>>>>>>>>            End
85746>>>>>>>>>>>>
85746>>>>>>>>>>>            Send Destroy of hoIniFile          
85747>>>>>>>>>>>        Loop        
85748>>>>>>>>>>>>
85748>>>>>>>>>>>        Send Destroy of hoPaths
85749>>>>>>>>>>>        
85749>>>>>>>>>>>        // Then not found in workspace, look for the file in DFSysPath;
85749>>>>>>>>>>>        If (sPath = "") Begin
85751>>>>>>>>>>>            Get_File_Path sSearchFileName to sFileName   
85752>>>>>>>>>>>            Get ParseFolderName sFileName to sPath
85753>>>>>>>>>>>        End                  
85753>>>>>>>>>>>>
85753>>>>>>>>>>>        
85753>>>>>>>>>>>        Function_Return sPath    
85754>>>>>>>>>>>    End_Function
85755>>>>>>>>>>>    
85755>>>>>>>>>>>    // Pass the path to the workspace Programs folder - returns a string array
85755>>>>>>>>>>>    // with one or more .ws file names.
85755>>>>>>>>>>>    // First checks if there is a .sws file - and if so reads the name of the
85755>>>>>>>>>>>    // workspace file (.ws) and returns it as a string array.
85755>>>>>>>>>>>    // If _no_ .sws file is found, enumerates the passed sProgramsPath variable
85755>>>>>>>>>>>    Function WorkspaceIniFiles String sProgramsPath Returns String[]
85757>>>>>>>>>>>        String[] asSWSFiles asWorkspaceFiles   
85759>>>>>>>>>>>        String sFile sHomePath sDirSep
85759>>>>>>>>>>>        Integer iCh iSize
85759>>>>>>>>>>>        Boolean bExists      
85759>>>>>>>>>>>        Handle hoIniFile 
85759>>>>>>>>>>>        
85759>>>>>>>>>>>        Move (ResizeArray(asSWSFiles, 0)) to asSWSFiles
85760>>>>>>>>>>>        Move (ResizeArray(asWorkspaceFiles, 0)) to asWorkspaceFiles
85761>>>>>>>>>>>        If (Right(sProgramsPath, 1) ="\") Begin
85763>>>>>>>>>>>            Move (Left(sProgramsPath, Length(sProgramsPath) -1)) to sProgramsPath        
85764>>>>>>>>>>>        End                                              
85764>>>>>>>>>>>>
85764>>>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
85765>>>>>>>>>>>        Get StringFromRightOfChar sProgramsPath sDirSep to sHomePath
85766>>>>>>>>>>>        Move (Replace(sHomePath, sProgramsPath, "")) to sHomePath
85767>>>>>>>>>>>        Get vFolderFormat sHomePath to sHomePath 
85768>>>>>>>>>>>        
85768>>>>>>>>>>>        // First check if theres an .sws file. If there is we will open it and
85768>>>>>>>>>>>        // read the name of the .ws file name.
85768>>>>>>>>>>>        File_Exist (sHomePath + "*.sws") bExists
85769>>>>>>>>>>>        If (bExists = True) Begin
85771>>>>>>>>>>>            Get Seq_Open_input_Channel ("dir:" + sHomePath + "*.sws") to iCh
85772>>>>>>>>>>>            If (iCh < 0) Begin
85774>>>>>>>>>>>                Function_Return asSWSFiles
85775>>>>>>>>>>>            End                                 
85775>>>>>>>>>>>>
85775>>>>>>>>>>>            
85775>>>>>>>>>>>            Repeat
85775>>>>>>>>>>>>
85775>>>>>>>>>>>                Readln channel iCh sFile
85777>>>>>>>>>>>                If (Trim(sFile) <> "") Begin
85779>>>>>>>>>>>                    Move sFile to asSWSFiles[SizeOfArray(asSWSFiles)]
85780>>>>>>>>>>>                End
85780>>>>>>>>>>>>
85780>>>>>>>>>>>            Until (SeqEof = True)
85782>>>>>>>>>>>            Send Seq_Close_Channel iCh    
85783>>>>>>>>>>>            
85783>>>>>>>>>>>            Move (SizeOfArray(asSWSFiles)) to iSize
85784>>>>>>>>>>>            If (iSize <> 0) Begin
85786>>>>>>>>>>>                Get Create (RefClass(cIniFile)) to hoIniFile  
85787>>>>>>>>>>>                // Use the file with that is last as it might have the DataFlex version in it,
85787>>>>>>>>>>>                // and thus is the latest one and it is more likely it is accurate (?)...
85787>>>>>>>>>>>                Move asSWSFiles[SizeOfArray(asSWSFiles) -1] to sFile
85788>>>>>>>>>>>                Set psFileName of hoIniFile to (sHomePath + sFile)
85789>>>>>>>>>>>                Get ReadString of hoIniFile "WorkspacePaths" "ConfigFile" "" to sFile
85790>>>>>>>>>>>                If (sFile <> "") Begin
85792>>>>>>>>>>>                    Move (Replace(".", sFile, sHomePath)) to sFile
85793>>>>>>>>>>>                    Move (Replace((sDirSep + String(sDirSep)), sFile, sDirSep)) to sFile
85794>>>>>>>>>>>                    File_Exist sFile bExists
85795>>>>>>>>>>>                    If (bExists = True) Begin
85797>>>>>>>>>>>                        Move sFile to asWorkspaceFiles[0] 
85798>>>>>>>>>>>                    End
85798>>>>>>>>>>>>
85798>>>>>>>>>>>                End
85798>>>>>>>>>>>>
85798>>>>>>>>>>>                Send Destroy of hoIniFile
85799>>>>>>>>>>>            End
85799>>>>>>>>>>>>
85799>>>>>>>>>>>        End
85799>>>>>>>>>>>>
85799>>>>>>>>>>>        
85799>>>>>>>>>>>        // If no .sws file exists, enumerate the .ws files from the Programs folder:    
85799>>>>>>>>>>>        If (SizeOfArray(asWorkspaceFiles) = 0) Begin
85801>>>>>>>>>>>            Get vFolderFormat sProgramsPath to sProgramsPath 
85802>>>>>>>>>>>            File_Exist (sProgramsPath + "*.ws") bExists
85803>>>>>>>>>>>            If (bExists = False) Begin
85805>>>>>>>>>>>                Function_Return asWorkspaceFiles
85806>>>>>>>>>>>            End
85806>>>>>>>>>>>>
85806>>>>>>>>>>>        
85806>>>>>>>>>>>            Get Seq_Open_input_Channel ("dir:" + sProgramsPath + "*.ws") to iCh
85807>>>>>>>>>>>            If (iCh < 0) Begin
85809>>>>>>>>>>>                Function_Return asWorkspaceFiles
85810>>>>>>>>>>>            End                                 
85810>>>>>>>>>>>>
85810>>>>>>>>>>>            
85810>>>>>>>>>>>            Repeat
85810>>>>>>>>>>>>
85810>>>>>>>>>>>                Readln channel iCh sFile
85812>>>>>>>>>>>                If (Trim(sFile) <> "") Begin
85814>>>>>>>>>>>                    Move sFile to asWorkspaceFiles[SizeOfArray(asWorkspaceFiles)]
85815>>>>>>>>>>>                End
85815>>>>>>>>>>>>
85815>>>>>>>>>>>            Until (SeqEof = True)
85817>>>>>>>>>>>            Send Seq_Close_Channel iCh
85818>>>>>>>>>>>        End
85818>>>>>>>>>>>>
85818>>>>>>>>>>>        
85818>>>>>>>>>>>        Function_Return asWorkspaceFiles
85819>>>>>>>>>>>    End_Function
85820>>>>>>>>>>>
85820>>>>>>>>>>>End_Class
85821>>>>>>>>>Use cDbUpdateDatabaseDriver.pkg
85821>>>>>>>>>Use vWin32fh.pkg
85821>>>>>>>>>
85821>>>>>>>>>// The cConnection class is the new SQL connections class for DF 19.
85821>>>>>>>>>// If an object of the cConnection class hasn't been instantiated we use a "dummy" class in its place.
85821>>>>>>>>>
85821>>>>>>>>>// We're making references to this object handle so we need it defined
85821>>>>>>>>>// here as well as for the cDbUpdateHandler class
85821>>>>>>>>>
85821>>>>>>>>>    Global_Variable Handle ghoSQLConnectionHandler
85821>>>>>>>>>    Move 0 to ghoSQLConnectionHandler
85822>>>>>>>>>
85822>>>>>>>>>Class cSQLConnectionHandler is a cObject
85823>>>>>>>>>
85823>>>>>>>>>    Procedure Construct_Object
85825>>>>>>>>>        Forward Send Construct_Object
85827>>>>>>>>>        Move Self to ghoSQLConnectionHandler
85828>>>>>>>>>
85828>>>>>>>>>        Property Handle phoSQLConnectionIniFile (Create(Self,RefClass(cSQLConnectionIniFile)))
85829>>>>>>>>>
85829>>>>>>>>>        // These properties are used by the cDbUpdateVersion and cDbUpdateFunctionLibrary classes,
85829>>>>>>>>>        // but put here so they can be set/get in both class objects. Those classes has "relay"
85829>>>>>>>>>        // methods to this class.
85829>>>>>>>>>        Property Boolean pbUseConnectionID True
85830>>>>>>>>>        Property Boolean pbToANSI          True
85831>>>>>>>>>        Property Boolean pbRecnum          True
85832>>>>>>>>>        Property Boolean pbCopyData        True
85833>>>>>>>>>        Property Boolean pbApiTableUpdateAuto    False
85834>>>>>>>>>        Property Boolean pbCompareDate_DateTime  False
85835>>>>>>>>>        Property Boolean pbCompareIndexAscending False
85836>>>>>>>>>        Property Boolean pbCompareIndexUppercase False
85837>>>>>>>>>
85837>>>>>>>>>        // Driver default value settings:
85837>>>>>>>>>        // Note: When the object is created the corresponding values
85837>>>>>>>>>        // from the driver .int files are read.
85837>>>>>>>>>        // Sample: Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of {driverNumber} to {StringVariable}
85837>>>>>>>>>        Property String psDriverDefaultValueASCII    ""
85838>>>>>>>>>        Property String psDriverDefaultValueBinary   ""
85839>>>>>>>>>        Property String psDriverDefaultValueDate     ""
85840>>>>>>>>>        Property String psDriverDefaultValueDateTime ""
85841>>>>>>>>>        Property String psDriverDefaultValueNumeric  ""
85842>>>>>>>>>        Property String psDriverDefaultValueText     ""
85843>>>>>>>>>
85843>>>>>>>>>        // Driver "nullability" settings:
85843>>>>>>>>>        // Note: When the object is created the corresponding values
85843>>>>>>>>>        // from the driver .int files are read.
85843>>>>>>>>>        // Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII of {driverNumber} to {BooleanVariable}
85843>>>>>>>>>        Property Boolean pbDriverDefaultNullableASCII    False
85844>>>>>>>>>        Property Boolean pbDriverDefaultNullableBinary   False
85845>>>>>>>>>        Property Boolean pbDriverDefaultNullableDate     False
85846>>>>>>>>>        Property Boolean pbDriverDefaultNullableDateTime False
85847>>>>>>>>>        Property Boolean pbDriverDefaultNullableNumeric  False
85848>>>>>>>>>        Property Boolean pbDriverDefaultNullableText     False
85849>>>>>>>>>
85849>>>>>>>>>        // *** This is the central point of connection data for the Database Update Framework ***
85849>>>>>>>>>        //     It is private because the get/set version also updates the DAW/Mertech
85849>>>>>>>>>        //     driver interfaces.
85849>>>>>>>>>        //     There are also procedure/function pairs to set/get individual data members
85849>>>>>>>>>        //     of the struct they are all routed throu this struct property.
85849>>>>>>>>>        Property tSQLConnection Private.pSQLConnection
85850>>>>>>>>>
85850>>>>>>>>>    End_Procedure
85851>>>>>>>>>
85851>>>>>>>>>    Procedure End_Construct_Object
85853>>>>>>>>>        tSQLConnection SQLConnection
85853>>>>>>>>>        tSQLConnection SQLConnection
85853>>>>>>>>>
85853>>>>>>>>>        Forward Send End_Construct_Object
85855>>>>>>>>>
85855>>>>>>>>>        // Now is the time to read and apply SQL connection settings.
85855>>>>>>>>>        Get SetupSQLConnection True True to SQLConnection
85856>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
85857>>>>>>>>>    End_Procedure
85858>>>>>>>>>
85858>>>>>>>>>    // *** Properties ***
85858>>>>>>>>>    // All connection related "properties" (get/set pairs) are really done by changing the
85858>>>>>>>>>    // private.pSQLConnection struct connection property. These "properties" are
85858>>>>>>>>>    // merely here for conveniance.
85858>>>>>>>>>    //
85858>>>>>>>>>    // The pSQLConnection get/set are here so we have a "central hub"
85858>>>>>>>>>    // where we update data to/from the DAW & Mertech driver interfaces and this framework.
85858>>>>>>>>>    // This struct property contains all the connection data.
85858>>>>>>>>>    //
85858>>>>>>>>>    Procedure Set pSQLConnection tSQLConnection SQLConnection
85860>>>>>>>>>        Boolean bOK
85860>>>>>>>>>
85860>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
85861>>>>>>>>>
85861>>>>>>>>>        // When starting a program we might not have a connection id yet:
85861>>>>>>>>>        If (SQLConnection.sDriverID = DATAFLEX_ID) Begin
85863>>>>>>>>>//        If (SQLConnection.sConnectionID = "" or SQLConnection.sDriverID = DATAFLEX_ID) Begin
85863>>>>>>>>>            Procedure_Return
85864>>>>>>>>>        End
85864>>>>>>>>>>
85864>>>>>>>>>
85864>>>>>>>>>        // If a DAW DFConnId.ini file was read instead of the DUF SQLConnections.ini file we should by now
85864>>>>>>>>>        // be logged in already and don't want to do it again.
85864>>>>>>>>>        If (SQLConnection.bDAWConnection = False) Begin
85866>>>>>>>>>            // After we have set the class property we need to tell the DAW/Mertech
85866>>>>>>>>>            // driver interfaces about the change & make a new login.
85866>>>>>>>>>            Get SQLLogin SQLConnection to bOK
85867>>>>>>>>>            If (bOK = False) Begin
85869>>>>>>>>>                Error DFERR_PROGRAM "Login error."
85870>>>>>>>>>>
85870>>>>>>>>>            End
85870>>>>>>>>>>
85870>>>>>>>>>        End
85870>>>>>>>>>>
85870>>>>>>>>>
85870>>>>>>>>>        // Now is the time to setup our driver default values by reading the driver .int file:
85870>>>>>>>>>        Send SetupDriverDefaults SQLConnection.sDriverID
85871>>>>>>>>>
85871>>>>>>>>>    End_Procedure
85872>>>>>>>>>
85872>>>>>>>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
85872>>>>>>>>>    // attempt to load the driver.
85872>>>>>>>>>    // Returns true if the passed driver is SQL based.
85872>>>>>>>>>    Function IsSQLDriver String sDriverID Returns Boolean
85874>>>>>>>>>        Boolean bOK
85874>>>>>>>>>
85874>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
85875>>>>>>>>>        If (bOK = False) Begin
85877>>>>>>>>>            Get IsMertechDriver sDriverID to bOK
85878>>>>>>>>>        End
85878>>>>>>>>>>
85878>>>>>>>>>
85878>>>>>>>>>        Function_Return bOK
85879>>>>>>>>>    End_Function
85880>>>>>>>>>
85880>>>>>>>>>    // Reads the driver .int file and sets class properties of the cDbUpdateFunctionLibrary accordingly.
85880>>>>>>>>>    Procedure SetupDriverDefaults String sDriverID
85882>>>>>>>>>        String sAttributeValue
85882>>>>>>>>>        Integer iDriverID
85882>>>>>>>>>        Boolean bNULL bSQLDriver bIsMertechDriver
85882>>>>>>>>>
85882>>>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
85883>>>>>>>>>        If (bSQLDriver = False) Begin
85885>>>>>>>>>            Procedure_Return
85886>>>>>>>>>        End                                      
85886>>>>>>>>>>
85886>>>>>>>>>        Get IsMertechDriver sDriverID to bIsMertechDriver
85887>>>>>>>>>        If (bIsMertechDriver = True) Begin
85889>>>>>>>>>            Procedure_Return
85890>>>>>>>>>        End
85890>>>>>>>>>>
85890>>>>>>>>>        
85890>>>>>>>>>        Get DriverIndex sDriverID to iDriverID
85891>>>>>>>>>
85891>>>>>>>>>        // Driver default values for various data types:
85891>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_ASCII of iDriverID      to sAttributeValue
85894>>>>>>>>>        Set psDriverDefaultValueASCII                                   to sAttributeValue
85895>>>>>>>>>
85895>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_BINARY of iDriverID     to sAttributeValue
85898>>>>>>>>>        Set psDriverDefaultValueBinary                                  to sAttributeValue
85899>>>>>>>>>
85899>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATE of iDriverID       to sAttributeValue
85902>>>>>>>>>        Set psDriverDefaultValueDate                                    to sAttributeValue
85903>>>>>>>>>
85903>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATETIME of iDriverID   to sAttributeValue
85906>>>>>>>>>        Set psDriverDefaultValueDateTime                                to sAttributeValue
85907>>>>>>>>>
85907>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of iDriverID    to sAttributeValue
85910>>>>>>>>>        Set psDriverDefaultValueNumeric                                 to sAttributeValue
85911>>>>>>>>>
85911>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_TEXT of iDriverID       to sAttributeValue
85914>>>>>>>>>        Set psDriverDefaultValueText                                    to sAttributeValue
85915>>>>>>>>>
85915>>>>>>>>>        // The default setting for the "nullability" of newly created ASCII columns.
85915>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII      of iDriverID to bNULL
85918>>>>>>>>>        Set pbDriverDefaultNullableASCII to bNULL
85919>>>>>>>>>
85919>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_BINARY     of iDriverID to bNULL
85922>>>>>>>>>        Set pbDriverDefaultNullableBinary to bNULL
85923>>>>>>>>>
85923>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATE       of iDriverID to bNULL
85926>>>>>>>>>        Set pbDriverDefaultNullableDate to bNULL
85927>>>>>>>>>
85927>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATETIME   of iDriverID to bNULL
85930>>>>>>>>>        Set pbDriverDefaultNullableDateTime to bNULL
85931>>>>>>>>>
85931>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_NUMERIC    of iDriverID to bNULL
85934>>>>>>>>>        Set pbDriverDefaultNullableNumeric to bNULL
85935>>>>>>>>>
85935>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_TEXT       of iDriverID to bNULL
85938>>>>>>>>>        Set pbDriverDefaultNullableText to bNULL
85939>>>>>>>>>
85939>>>>>>>>>    End_Procedure
85940>>>>>>>>>
85940>>>>>>>>>    Function SQLLogin tSQLConnection SQLConnection Returns Boolean
85942>>>>>>>>>        Boolean bOK bIsDaw bIsMertech
85942>>>>>>>>>        String sConnectionString
85942>>>>>>>>>        Handle hoErrorObj hoDriver hoIniFile
85942>>>>>>>>>        Integer iDriverID
85942>>>>>>>>>
85942>>>>>>>>>        Move False to bOK
85943>>>>>>>>>        Get IsDAWSQLDriver SQLConnection.sDriverID to bIsDaw
85944>>>>>>>>>        If (bIsDaw = False) Begin
85946>>>>>>>>>            Get IsMertechDriver SQLConnection.sDriverID to bIsMertech
85947>>>>>>>>>            If (bIsMertech = False) Begin
85949>>>>>>>>>                Function_Return False
85950>>>>>>>>>            End
85950>>>>>>>>>>
85950>>>>>>>>>        End
85950>>>>>>>>>>
85950>>>>>>>>>
85950>>>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
85951>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to sConnectionString
85952>>>>>>>>>        Get DriverIndex SQLConnection.sDriverID to iDriverID
85953>>>>>>>>>        If (iDriverID = 0) Begin
85955>>>>>>>>>            Move hoErrorObj to Error_Object_Id
85956>>>>>>>>>            Function_Return False
85957>>>>>>>>>        End
85957>>>>>>>>>>
85957>>>>>>>>>
85957>>>>>>>>>        // There's a bug in Mertech drivers creating "an Exception error" in the debugger (probably will crash an application too.)
85957>>>>>>>>>        If (bIsMertech = False) Begin
85959>>>>>>>>>            Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriverID to SQLConnection.bSilentLogin
85962>>>>>>>>>        End
85962>>>>>>>>>>
85962>>>>>>>>>
85962>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
85963>>>>>>>>>        Set psDriverID of hoDriver to SQLConnection.sDriverID
85964>>>>>>>>>        Get DbLogin    of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
85965>>>>>>>>>        Send Destroy   of hoDriver
85966>>>>>>>>>
85966>>>>>>>>>        Function_Return bOK
85967>>>>>>>>>    End_Function
85968>>>>>>>>>
85968>>>>>>>>>    Function pSQLConnection Returns tSQLConnection
85970>>>>>>>>>        tSQLConnection SQLConnection
85970>>>>>>>>>        tSQLConnection SQLConnection
85970>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
85971>>>>>>>>>        Function_Return SQLConnection
85972>>>>>>>>>    End_Function
85973>>>>>>>>>
85973>>>>>>>>>    Procedure Set psConnectionID String sValue
85975>>>>>>>>>        tSQLConnection SQLConnection
85975>>>>>>>>>        tSQLConnection SQLConnection
85975>>>>>>>>>
85975>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
85976>>>>>>>>>        If (SQLConnection.sConnectionID = "") Begin
85978>>>>>>>>>            Move sValue to SQLConnection.sConnectionID
85979>>>>>>>>>        End
85979>>>>>>>>>>
85979>>>>>>>>>
85979>>>>>>>>>        // Else we might want to change the current connection ID
85979>>>>>>>>>        Else If (SQLConnection.sConnectionID <> "" and SQLConnection.sConnectionID <> sValue) Begin
85982>>>>>>>>>            Move False to Err
85983>>>>>>>>>            Logout SQLConnection.sDriverID
85984>>>>>>>>>            // This will also make a login to the new server.
85984>>>>>>>>>            Get SQLIniFileConnectionID of (phoSQLConnectionIniFile(Self)) sValue to SQLConnection
85985>>>>>>>>>        End
85985>>>>>>>>>>
85985>>>>>>>>>        Set pSQLConnection to SQLConnection
85986>>>>>>>>>    End_Procedure
85987>>>>>>>>>
85987>>>>>>>>>    Function psConnectionID Returns String
85989>>>>>>>>>        tSQLConnection SQLConnection
85989>>>>>>>>>        tSQLConnection SQLConnection
85989>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
85990>>>>>>>>>        Function_Return SQLConnection.sConnectionID
85991>>>>>>>>>    End_Function
85992>>>>>>>>>
85992>>>>>>>>>    // Note: If the psDriverID + other connection properties are to be changed,
85992>>>>>>>>>    //       the psDriverID *must* be the first property that is changed!
85992>>>>>>>>>    //       Otherwise errors might be raised by the driver when e.g. the format
85992>>>>>>>>>    //       for a connection string has the wrong format for that driver.
85992>>>>>>>>>    Procedure Set psDriverID String sValue
85994>>>>>>>>>        tSQLConnection SQLConnection
85994>>>>>>>>>        tSQLConnection SQLConnection
85994>>>>>>>>>        Get pSQLConnection to SQLConnection
85995>>>>>>>>>        Move sValue        to SQLConnection.sDriverID
85996>>>>>>>>>        Set pSQLConnection to SQLConnection
85997>>>>>>>>>        If (sValue <> DATAFLEX_ID) Begin
85999>>>>>>>>>            Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
86000>>>>>>>>>        End
86000>>>>>>>>>>
86000>>>>>>>>>    End_Procedure
86001>>>>>>>>>
86001>>>>>>>>>    Function psDriverID Returns String
86003>>>>>>>>>        tSQLConnection SQLConnection
86003>>>>>>>>>        tSQLConnection SQLConnection
86003>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
86004>>>>>>>>>        If (SQLConnection.sDriverID = "") Begin
86006>>>>>>>>>            Move DATAFLEX_ID to SQLConnection.sDriverID // Default is the DataFlex driver.
86007>>>>>>>>>        End
86007>>>>>>>>>>
86007>>>>>>>>>        Function_Return SQLConnection.sDriverID
86008>>>>>>>>>    End_Function
86009>>>>>>>>>
86009>>>>>>>>>    Procedure Set psConnectionString String sValue
86011>>>>>>>>>        tSQLConnection SQLConnection
86011>>>>>>>>>        tSQLConnection SQLConnection
86011>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
86012>>>>>>>>>        Move sValue        to SQLConnection.sConnectionString
86013>>>>>>>>>        Set pSQLConnection to SQLConnection
86014>>>>>>>>>    End_Procedure
86015>>>>>>>>>
86015>>>>>>>>>    Function psConnectionString Returns String
86017>>>>>>>>>        tSQLConnection SQLConnection
86017>>>>>>>>>        tSQLConnection SQLConnection
86017>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
86018>>>>>>>>>        Function_Return SQLConnection.sConnectionString
86019>>>>>>>>>    End_Function
86020>>>>>>>>>
86020>>>>>>>>>    Procedure Set psServer String sValue
86022>>>>>>>>>        tSQLConnection SQLConnection
86022>>>>>>>>>        tSQLConnection SQLConnection
86022>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
86023>>>>>>>>>        Move sValue        to SQLConnection.sServer
86024>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
86025>>>>>>>>>        Set pSQLConnection to SQLConnection
86026>>>>>>>>>    End_Procedure
86027>>>>>>>>>
86027>>>>>>>>>    Function psServer Returns String
86029>>>>>>>>>        tSQLConnection SQLConnection
86029>>>>>>>>>        tSQLConnection SQLConnection
86029>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
86030>>>>>>>>>        Function_Return SQLConnection.sServer
86031>>>>>>>>>    End_Function
86032>>>>>>>>>
86032>>>>>>>>>    Procedure Set psDatabase String sValue
86034>>>>>>>>>        tSQLConnection SQLConnection
86034>>>>>>>>>        tSQLConnection SQLConnection
86034>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
86035>>>>>>>>>        Move sValue        to SQLConnection.sDatabase
86036>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
86037>>>>>>>>>        Set pSQLConnection to SQLConnection
86038>>>>>>>>>    End_Procedure
86039>>>>>>>>>
86039>>>>>>>>>    Function psDatabase Returns String
86041>>>>>>>>>        tSQLConnection SQLConnection
86041>>>>>>>>>        tSQLConnection SQLConnection
86041>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
86042>>>>>>>>>        Function_Return SQLConnection.sDatabase
86043>>>>>>>>>    End_Function
86044>>>>>>>>>
86044>>>>>>>>>    Procedure Set psUserID String sValue
86046>>>>>>>>>        tSQLConnection SQLConnection
86046>>>>>>>>>        tSQLConnection SQLConnection
86046>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
86047>>>>>>>>>        Move sValue        to SQLConnection.sUserID
86048>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
86049>>>>>>>>>        Set pSQLConnection to SQLConnection
86050>>>>>>>>>    End_Procedure
86051>>>>>>>>>
86051>>>>>>>>>    Function psUserID Returns String
86053>>>>>>>>>        tSQLConnection SQLConnection
86053>>>>>>>>>        tSQLConnection SQLConnection
86053>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
86054>>>>>>>>>        Function_Return SQLConnection.sUserID
86055>>>>>>>>>    End_Function
86056>>>>>>>>>
86056>>>>>>>>>    // This is the uncrypted password
86056>>>>>>>>>    Procedure Set psPassword String sValue
86058>>>>>>>>>        tSQLConnection SQLConnection
86058>>>>>>>>>        tSQLConnection SQLConnection
86058>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
86059>>>>>>>>>        Move sValue        to SQLConnection.sPassword
86060>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
86061>>>>>>>>>        Set pSQLConnection to SQLConnection
86062>>>>>>>>>    End_Procedure
86063>>>>>>>>>
86063>>>>>>>>>    Function psPassword Returns String
86065>>>>>>>>>        tSQLConnection SQLConnection
86065>>>>>>>>>        tSQLConnection SQLConnection
86065>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
86066>>>>>>>>>        Function_Return SQLConnection.sPassword
86067>>>>>>>>>    End_Function
86068>>>>>>>>>
86068>>>>>>>>>    Procedure Set pbTrusted Boolean bValue
86070>>>>>>>>>        tSQLConnection SQLConnection
86070>>>>>>>>>        tSQLConnection SQLConnection
86070>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
86071>>>>>>>>>        Move bValue        to SQLConnection.bTrusted
86072>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
86073>>>>>>>>>        Set pSQLConnection to SQLConnection
86074>>>>>>>>>    End_Procedure
86075>>>>>>>>>
86075>>>>>>>>>    Function pbTrusted Returns Boolean
86077>>>>>>>>>        tSQLConnection SQLConnection
86077>>>>>>>>>        tSQLConnection SQLConnection
86077>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
86078>>>>>>>>>        Function_Return SQLConnection.bTrusted
86079>>>>>>>>>    End_Function
86080>>>>>>>>>
86080>>>>>>>>>    // *** All of these properties are special to the Database Update Framework ***
86080>>>>>>>>>    //     Thus they are not propagated to the DAW/Mertech classes and that is why
86080>>>>>>>>>    //     the Private.pSQLConnection property is set instead of the going throu
86080>>>>>>>>>    //     the central pSQLConnection "hub".
86080>>>>>>>>>    Procedure Set pbSilentLogin Boolean bValue
86082>>>>>>>>>        tSQLConnection SQLConnection
86082>>>>>>>>>        tSQLConnection SQLConnection
86082>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
86083>>>>>>>>>        Move bValue to SQLConnection.bTrusted
86084>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
86085>>>>>>>>>    End_Procedure
86086>>>>>>>>>
86086>>>>>>>>>    Function pbSilentLogin Returns Boolean
86088>>>>>>>>>        tSQLConnection SQLConnection
86088>>>>>>>>>        tSQLConnection SQLConnection
86088>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
86089>>>>>>>>>        Function_Return SQLConnection.bSilentLogin
86090>>>>>>>>>    End_Function
86091>>>>>>>>>
86091>>>>>>>>>    Procedure Set piDbType Integer iValue
86093>>>>>>>>>        tSQLConnection SQLConnection
86093>>>>>>>>>        tSQLConnection SQLConnection
86093>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
86094>>>>>>>>>        Move iValue to SQLConnection.iDbType
86095>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
86096>>>>>>>>>    End_Procedure
86097>>>>>>>>>
86097>>>>>>>>>    Function piDbType Returns Integer
86099>>>>>>>>>        tSQLConnection SQLConnection
86099>>>>>>>>>        tSQLConnection SQLConnection
86099>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
86100>>>>>>>>>        Function_Return SQLConnection.iDbType
86101>>>>>>>>>    End_Function
86102>>>>>>>>>
86102>>>>>>>>>    Procedure Set psBaseTableSpace String sValue
86104>>>>>>>>>        tSQLConnection SQLConnection
86104>>>>>>>>>        tSQLConnection SQLConnection
86104>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
86105>>>>>>>>>        Move sValue to SQLConnection.sBaseTableSpace
86106>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
86107>>>>>>>>>    End_Procedure
86108>>>>>>>>>
86108>>>>>>>>>    Function psBaseTableSpace Returns String
86110>>>>>>>>>        tSQLConnection SQLConnection
86110>>>>>>>>>        tSQLConnection SQLConnection
86110>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
86111>>>>>>>>>        Function_Return SQLConnection.sBaseTableSpace
86112>>>>>>>>>    End_Function
86113>>>>>>>>>
86113>>>>>>>>>    Procedure Set psIndexTableSpace String sValue
86115>>>>>>>>>        tSQLConnection SQLConnection
86115>>>>>>>>>        tSQLConnection SQLConnection
86115>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
86116>>>>>>>>>        Move sValue to SQLConnection.sIndexTableSpace
86117>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
86118>>>>>>>>>    End_Procedure
86119>>>>>>>>>
86119>>>>>>>>>    Function psIndexTableSpace Returns String
86121>>>>>>>>>        tSQLConnection SQLConnection
86121>>>>>>>>>        tSQLConnection SQLConnection
86121>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
86122>>>>>>>>>        Function_Return SQLConnection.sIndexTableSpace
86123>>>>>>>>>    End_Function
86124>>>>>>>>>
86124>>>>>>>>>    Procedure Set psLongTableSpace String sValue
86126>>>>>>>>>        tSQLConnection SQLConnection
86126>>>>>>>>>        tSQLConnection SQLConnection
86126>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
86127>>>>>>>>>        Move sValue to SQLConnection.sLongTableSpace
86128>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
86129>>>>>>>>>    End_Procedure
86130>>>>>>>>>
86130>>>>>>>>>    Function psLongTableSpace Returns String
86132>>>>>>>>>        tSQLConnection SQLConnection
86132>>>>>>>>>        tSQLConnection SQLConnection
86132>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
86133>>>>>>>>>        Function_Return SQLConnection.sLongTableSpace
86134>>>>>>>>>    End_Function
86135>>>>>>>>>
86135>>>>>>>>>    Procedure Set psSchema String sValue
86137>>>>>>>>>        tSQLConnection SQLConnection
86137>>>>>>>>>        tSQLConnection SQLConnection
86137>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
86138>>>>>>>>>        Move sValue to SQLConnection.sSchema
86139>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
86140>>>>>>>>>    End_Procedure
86141>>>>>>>>>
86141>>>>>>>>>    Function psSchema Returns String
86143>>>>>>>>>        tSQLConnection SQLConnection
86143>>>>>>>>>        tSQLConnection SQLConnection
86143>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
86144>>>>>>>>>        Function_Return SQLConnection.sSchema
86145>>>>>>>>>    End_Function
86146>>>>>>>>>
86146>>>>>>>>>    Procedure Set pbEnabled Boolean bValue
86148>>>>>>>>>        tSQLConnection SQLConnection
86148>>>>>>>>>        tSQLConnection SQLConnection
86148>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
86149>>>>>>>>>        Move bValue to SQLConnection.bEnabled
86150>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
86151>>>>>>>>>    End_Procedure
86152>>>>>>>>>
86152>>>>>>>>>    Function pbEnabled Returns Boolean
86154>>>>>>>>>        tSQLConnection SQLConnection
86154>>>>>>>>>        tSQLConnection SQLConnection
86154>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
86155>>>>>>>>>        Function_Return SQLConnection.bEnabled
86156>>>>>>>>>    End_Function
86157>>>>>>>>>
86157>>>>>>>>>
86157>>>>>>>>>    // ************************************
86157>>>>>>>>>    Function SetupSQLConnection Boolean bReadDFConnSettings Boolean bReadSQLConnections Returns tSQLConnection
86159>>>>>>>>>        tSQLConnection SQLConnection
86159>>>>>>>>>        tSQLConnection SQLConnection
86159>>>>>>>>>
86159>>>>>>>>>        // If this object was created by the cDbUpdateHandler class we will
86159>>>>>>>>>        // deferr reading SQL connection values until later.
86159>>>>>>>>>        If (bReadDFConnSettings = True) Begin
86161>>>>>>>>>            // This is the new SQL login logic for DF 19 and up; "Managed Connections"
86161>>>>>>>>>            If (ghoConnection > 0) Begin
86163>>>>>>>>>                Get ReadcConnections to SQLConnection
86164>>>>>>>>>            End
86164>>>>>>>>>>
86164>>>>>>>>>
86164>>>>>>>>>            // In addition to the above; there might be other values set even if a cConnection
86164>>>>>>>>>            // object is used.
86164>>>>>>>>>            If (bReadSQLConnections = True) Begin
86166>>>>>>>>>                Get ReadSQLConnectionsIniSettings to SQLConnection
86167>>>>>>>>>            End
86167>>>>>>>>>>
86167>>>>>>>>>        End
86167>>>>>>>>>>
86167>>>>>>>>>
86167>>>>>>>>>        Function_Return SQLConnection
86168>>>>>>>>>    End_Function
86169>>>>>>>>>
86169>>>>>>>>>    // This is for the new cConnection class used by DF 19 and up (only).
86169>>>>>>>>>    Function ReadcConnections Returns tSQLConnection
86171>>>>>>>>>        tConnection Connection
86171>>>>>>>>>        tConnection Connection
86171>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
86171>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
86171>>>>>>>>>        Integer iRetval iDbType
86171>>>>>>>>>        Boolean bOK bConnected
86171>>>>>>>>>        String sConnectionID
86171>>>>>>>>>
86171>>>>>>>>>            tConnection[] Connections
86171>>>>>>>>>            tConnection[] Connections
86172>>>>>>>>>            // - If the DF 19 cConnection class has been used in the cApplication object
86172>>>>>>>>>            // - and there are multiple connection id's defined for the same driver. This is
86172>>>>>>>>>            //   because otherwise we can't possibly know which connection id to use... So
86172>>>>>>>>>            //   we then generate an error and abort the program...
86172>>>>>>>>>            Get IsSinglecConnection (&sConnectionID) to bOK
86173>>>>>>>>>            If (bOK = False) Begin
86175>>>>>>>>>                Error DFERR_PROGRAM ("Programming error. The psConnectionID must be set in the cDbUpdateVersion object when a cConnect object is used in the cApplication object, and there are multiple connections defined. Program will now exit!")
86176>>>>>>>>>>
86176>>>>>>>>>                Abort
86177>>>>>>>>>>
86177>>>>>>>>>            End
86177>>>>>>>>>>
86177>>>>>>>>>            If (sConnectionID = "") Begin
86179>>>>>>>>>                Get ConnectionIDs of ghoConnection to Connections
86180>>>>>>>>>                If (SizeOfArray(Connections) > 0) Begin
86182>>>>>>>>>                    Move Connections[0].sId to sConnectionID
86183>>>>>>>>>                End
86183>>>>>>>>>>
86183>>>>>>>>>            End
86183>>>>>>>>>>
86183>>>>>>>>>
86183>>>>>>>>>            Move 0 to iRetval
86184>>>>>>>>>            // DAW DF19 connection info:
86184>>>>>>>>>            // We first check that the connection is OK:
86184>>>>>>>>>            Get ConnectionIdIndex of ghoConnection sConnectionID to iRetval
86185>>>>>>>>>            // It might happen that no connection has been setup although the object exists, in case we do nothing.
86185>>>>>>>>>            If (iRetval = -1) Begin
86187>>>>>>>>>                Function_Return SQLConnectionEmpty
86188>>>>>>>>>            End
86188>>>>>>>>>>
86188>>>>>>>>>
86188>>>>>>>>>            If (sConnectionID <> "") Begin
86190>>>>>>>>>                Get ConnectionIdInfo of ghoConnection sConnectionID to Connection
86191>>>>>>>>>            End
86191>>>>>>>>>>
86191>>>>>>>>>            If (Connection.sId = "") Begin
86193>>>>>>>>>                Move True to SQLConnectionEmpty.bError
86194>>>>>>>>>                Function_Return SQLConnectionEmpty
86195>>>>>>>>>            End
86195>>>>>>>>>>
86195>>>>>>>>>
86195>>>>>>>>>            // DUF connection info struct property:
86195>>>>>>>>>            Get Private.pSQLConnection                       to SQLConnection
86196>>>>>>>>>
86196>>>>>>>>>            Move Connection.sId to sConnectionID
86197>>>>>>>>>            Get IsConnectionIdLoggedIn of ghoConnection sConnectionID to bConnected
86198>>>>>>>>>
86198>>>>>>>>>            If (bConnected = False) Begin
86200>>>>>>>>>                Get LoginConnectionId of ghoConnection sConnectionID to iRetval
86201>>>>>>>>>                If (iRetval <> 0) Begin
86203>>>>>>>>>                    Send UserError CS_DUF_CannotLoginToServer
86204>>>>>>>>>                    Send Exit_Application
86205>>>>>>>>>                End
86205>>>>>>>>>>
86205>>>>>>>>>                Move True                                   to SQLConnection.bDAWConnection
86206>>>>>>>>>                // We need to get the DAW connection info again as it might have
86206>>>>>>>>>                // been changed in the DAW db login dialog.
86206>>>>>>>>>                Get ConnectionIdInfo of ghoConnection sConnectionID to Connection
86207>>>>>>>>>            End
86207>>>>>>>>>>
86207>>>>>>>>>
86207>>>>>>>>>            Move True                                        to SQLConnection.bEnabled
86208>>>>>>>>>            Move Connection.bTrustedConnection               to SQLConnection.bTrusted
86209>>>>>>>>>
86209>>>>>>>>>            // Not used in DUF:
86209>>>>>>>>>            // Move Connection.iDriverIndex                    to SQLConnection.iDriverIndex
86209>>>>>>>>>
86209>>>>>>>>>            Move (If(Connection.iOptions = 0, False, True))  to SQLConnection.bSilentLogin
86210>>>>>>>>>            Move Connection.sConnectionString                to SQLConnection.sConnectionString
86211>>>>>>>>>            Move Connection.sDriver                          to SQLConnection.sDriverID
86212>>>>>>>>>            Move Connection.sId                              to SQLConnection.sConnectionID
86213>>>>>>>>>            Move Connection.sUID                             to SQLConnection.sUserID
86214>>>>>>>>>            Move Connection.sPWD                             to SQLConnection.sPassword
86215>>>>>>>>>
86215>>>>>>>>>            // Not used in DUF:
86215>>>>>>>>>            // Move Connection.sSection to SQLConnection.xxx
86215>>>>>>>>>
86215>>>>>>>>>            // The rest of the properties of the SQLConnection struct should have been
86215>>>>>>>>>            // setup in the cDbUpdateHandler object, and we should be able to reach them through delegation:
86215>>>>>>>>>            If (Connection.sDriver <> ODBC_DRV_ID) Begin
86217>>>>>>>>>                Get ParseKeyWord Connection.sString (CS_SQLIniServerKeyword + "=")       to SQLConnection.sServer
86218>>>>>>>>>            End
86218>>>>>>>>>>
86218>>>>>>>>>            If (Connection.sDriver = ODBC_DRV_ID) Begin
86220>>>>>>>>>                Get ParseKeyWord Connection.sString (CS_SQLIniDSNKeyword + "=")          to SQLConnection.sServer
86221>>>>>>>>>                If (SQLConnection.sServer = "") Begin
86223>>>>>>>>>                    Get ParseKeyWord Connection.sString (CS_SQLIniFileDSNKeyword  + "=") to SQLConnection.sServer
86224>>>>>>>>>                End
86224>>>>>>>>>>
86224>>>>>>>>>            End
86224>>>>>>>>>>
86224>>>>>>>>>
86224>>>>>>>>>            Get ParseKeyWord Connection.sString (CS_SQLIniDatabaseKeyword  + "=")        to SQLConnection.sDatabase
86225>>>>>>>>>
86225>>>>>>>>>            // The DbType is a bit special. If the piDbType has _not_ been setup in object code we try to derave
86225>>>>>>>>>            // the value from the driver id:
86225>>>>>>>>>            Get SqlUtilDbTypeFromDriver of (phoSQLConnectionIniFile(Self)) Connection.sDriver to SQLConnection.iDbType
86226>>>>>>>>>            // ...but in case it has been explicitly set in the object we use that value.
86226>>>>>>>>>            Get piDbType                                     to iDbType
86227>>>>>>>>>            If (iDbType <> SQLConnection.iDbType) Begin
86229>>>>>>>>>                Move iDbType to SQLConnection.iDbType
86230>>>>>>>>>            End
86230>>>>>>>>>>
86230>>>>>>>>>            Get psBaseTableSpace                             to SQLConnection.sBaseTableSpace
86231>>>>>>>>>            Get psLongTableSpace                             to SQLConnection.sLongTableSpace
86232>>>>>>>>>            Get psIndexTableSpace                            to SQLConnection.sIndexTableSpace
86233>>>>>>>>>            Get psSchema                                     to SQLConnection.sSchema
86234>>>>>>>>>
86234>>>>>>>>>            // We finally set the struct property to the newly fetched values.
86234>>>>>>>>>            Set pSQLConnection to SQLConnection
86235>>>>>>>>>
86235>>>>>>>>>        Function_Return SQLConnection
86236>>>>>>>>>    End_Function
86237>>>>>>>>>
86237>>>>>>>>>    // Returns True if the psConnectionID has been set in the cDbUpateHandler object,
86237>>>>>>>>>    // or the DAW cConnect array of registered connection only contains one active/enabled
86237>>>>>>>>>    // connection id for a particular driver.
86237>>>>>>>>>    // So either the psConnectionID or the psDriverID can have been set in the cDbUpdateHandler
86237>>>>>>>>>    // object. We can then match a connection id from the DAW cConnect class array.
86237>>>>>>>>>    // Returns False if there are multiple connections that are enabled or the psConnectionID has
86237>>>>>>>>>    // been set in the cDbUpdateHandler object but it cannot be found amongst the registered
86237>>>>>>>>>    // connections of the DAW cConnect class.
86237>>>>>>>>>    Function IsSinglecConnection String ByRef sConnectionID Returns Boolean
86239>>>>>>>>>        tConnection[] ConnIdArray
86239>>>>>>>>>        tConnection[] ConnIdArray
86240>>>>>>>>>        Integer iCount iSize iConnectionIDCounter
86240>>>>>>>>>        Boolean bEnabled bFound
86240>>>>>>>>>        String sConnectionID2 sDriverID sDriverConn
86240>>>>>>>>>
86240>>>>>>>>>        Move False to bFound
86241>>>>>>>>>        If (ghoConnection > 0) Begin
86243>>>>>>>>>
86243>>>>>>>>>            // The property of the cDbUpdateHandler container object
86243>>>>>>>>>            Get psDriverID to sDriverID
86244>>>>>>>>>
86244>>>>>>>>>            Move 0 to iConnectionIDCounter
86245>>>>>>>>>            // This is the the DAW cConnect array with all registered connection id's.
86245>>>>>>>>>                Get ConnectionIDs of ghoConnection to ConnIdArray
86246>>>>>>>>>            Move (SizeOfArray(ConnIdArray)) to iSize
86247>>>>>>>>>            Decrement iSize
86248>>>>>>>>>            For iCount from 0 to iSize
86254>>>>>>>>>>
86254>>>>>>>>>                Move ConnIdArray[iCount].sDriver to sDriverConn
86255>>>>>>>>>                Move ConnIdArray[iCount].sId to sConnectionID2
86256>>>>>>>>>                Move (ConnIdArray[iCount].bDisabled = False) to bEnabled
86257>>>>>>>>>                // If no psConnectionID specified in the cDbUpdateHandler, we check if there is a driver
86257>>>>>>>>>                // connection in the DAW cConnect object _and_ that there is only one!
86257>>>>>>>>>                If (sConnectionID = "") Begin
86259>>>>>>>>>                    Move (sDriverID = sDriverConn and bEnabled = True) to bFound
86260>>>>>>>>>                End
86260>>>>>>>>>>
86260>>>>>>>>>                Else Begin
86261>>>>>>>>>                    If (Uppercase(sConnectionID) = Uppercase(sConnectionID2)) Begin
86263>>>>>>>>>                        Move iSize to iCount // Then we've found what we were looking for and we're out of here...
86264>>>>>>>>>                    End
86264>>>>>>>>>>
86264>>>>>>>>>                End
86264>>>>>>>>>>
86264>>>>>>>>>
86264>>>>>>>>>                If (bFound = True) Begin
86266>>>>>>>>>                    Increment iConnectionIDCounter
86267>>>>>>>>>                End
86267>>>>>>>>>>
86267>>>>>>>>>            Loop
86268>>>>>>>>>>
86268>>>>>>>>>            Move (iConnectionIDCounter <= 1 and sDriverConn <> "" and sConnectionID2 <> "") to bFound
86269>>>>>>>>>            If (bFound = True) Begin
86271>>>>>>>>>                Move sConnectionID2 to sConnectionID
86272>>>>>>>>>            End
86272>>>>>>>>>>
86272>>>>>>>>>        End
86272>>>>>>>>>>
86272>>>>>>>>>
86272>>>>>>>>>        // Special case; a cConnection object has been setup in the cApplication,
86272>>>>>>>>>        // but no DFConn.ini record has been created.
86272>>>>>>>>>        If (iSize = -1) Begin
86274>>>>>>>>>            Move True to bFound
86275>>>>>>>>>        End
86275>>>>>>>>>>
86275>>>>>>>>>
86275>>>>>>>>>        Function_Return bFound
86276>>>>>>>>>    End_Function
86277>>>>>>>>>
86277>>>>>>>>>    // Send on object creation to read the default connection string settings, and
86277>>>>>>>>>    // create a connection to the server.
86277>>>>>>>>>    Function ReadSQLConnectionsIniSettings Returns tSQLConnection
86279>>>>>>>>>        String sPath sFileName
86279>>>>>>>>>        Boolean bExists bActive
86279>>>>>>>>>        tSQLConnection[] SQLConnectionArray
86279>>>>>>>>>        tSQLConnection[] SQLConnectionArray
86280>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
86280>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
86280>>>>>>>>>        Handle hoIniFile
86280>>>>>>>>>        Integer iSize iCount iRetval
86280>>>>>>>>>
86280>>>>>>>>>        Get psIniFilePath to sPath
86281>>>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
86282>>>>>>>>>        If (sPath = "") Begin
86284>>>>>>>>>            Get ApplicationPath of hoIniFile to sPath
86285>>>>>>>>>            Set psIniFilePath   of hoIniFile to sPath
86286>>>>>>>>>        End
86286>>>>>>>>>>
86286>>>>>>>>>        Get vFolderFormat sPath to sPath
86287>>>>>>>>>        Get psIniFileName to sFileName
86288>>>>>>>>>        Get vFilePathExists (sPath + sFileName) to bExists
86289>>>>>>>>>
86289>>>>>>>>>        Get SQLIniFileReadConnections of hoIniFile to SQLConnectionArray
86290>>>>>>>>>        Move (SizeOfArray(SQLConnectionArray)) to iSize
86291>>>>>>>>>        If (iSize = 0) Begin
86293>>>>>>>>>            // This may have been set by the "ReadcConnections" function,
86293>>>>>>>>>            // if a cConnection object has been setup for DataFlex 19 or later
86293>>>>>>>>>            // in the cApplication object.
86293>>>>>>>>>            Get pSQLConnection to SQLConnection
86294>>>>>>>>>            If (SQLConnection.sConnectionID = "") Begin
86296>>>>>>>>>                Function_Return SQLConnectionEmpty
86297>>>>>>>>>            End
86297>>>>>>>>>>
86297>>>>>>>>>            Move SQLConnection to SQLConnectionArray[0] 
86298>>>>>>>>>            Move 1 to iSize
86299>>>>>>>>>        End
86299>>>>>>>>>>
86299>>>>>>>>>
86299>>>>>>>>>        Move False to bActive
86300>>>>>>>>>        // The first connection should be the one that is active, but all connections might have been disabled.
86300>>>>>>>>>        Decrement iSize
86301>>>>>>>>>        For iCount from 0 to iSize
86307>>>>>>>>>>
86307>>>>>>>>>            Move SQLConnectionArray[iCount] to SQLConnection
86308>>>>>>>>>            If (SQLConnection.bEnabled = True) Begin
86310>>>>>>>>>                Move True to bActive
86311>>>>>>>>>                Move iSize to iCount // We've found the enabled item, so we're out of here.
86312>>>>>>>>>            End
86312>>>>>>>>>>
86312>>>>>>>>>        Loop
86313>>>>>>>>>>
86313>>>>>>>>>
86313>>>>>>>>>        // In case all connections have been disabled, we're out of here.
86313>>>>>>>>>        If (bActive = False) Begin
86315>>>>>>>>>            Function_Return SQLConnectionEmpty
86316>>>>>>>>>        End
86316>>>>>>>>>>
86316>>>>>>>>>
86316>>>>>>>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID ;             SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted ;             SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bSilentLogin False
86317>>>>>>>>>
86317>>>>>>>>>        Set pSQLConnection to SQLConnection
86318>>>>>>>>>        Get AutoSetConnectionID to iRetval
86319>>>>>>>>>
86319>>>>>>>>>        Function_Return SQLConnection
86320>>>>>>>>>    End_Function
86321>>>>>>>>>
86321>>>>>>>>>    Procedure Set psIniFilePath String sPath
86323>>>>>>>>>        Set psIniFilePath of (phoSQLConnectionIniFile(Self)) to sPath
86324>>>>>>>>>    End_Procedure
86325>>>>>>>>>
86325>>>>>>>>>    Function psIniFilePath Returns String
86327>>>>>>>>>        String sRetval
86327>>>>>>>>>        Get psIniFilePath of (phoSQLConnectionIniFile(Self)) to sRetval
86328>>>>>>>>>        Function_Return sRetval
86329>>>>>>>>>    End_Function
86330>>>>>>>>>
86330>>>>>>>>>    Procedure Set psIniFileName String sFileName
86332>>>>>>>>>        Set psIniFileName of (phoSQLConnectionIniFile(Self)) to sFileName
86333>>>>>>>>>    End_Procedure
86334>>>>>>>>>
86334>>>>>>>>>    Function psIniFileName Returns String
86336>>>>>>>>>        String sRetval
86336>>>>>>>>>        Get psIniFileName of (phoSQLConnectionIniFile(Self)) to sRetval
86337>>>>>>>>>        Function_Return sRetval
86338>>>>>>>>>    End_Function
86339>>>>>>>>>
86339>>>>>>>>>    Procedure Set psIniSectionName String sSection
86341>>>>>>>>>        Set psIniSectionName of (phoSQLConnectionIniFile(Self)) to sSection
86342>>>>>>>>>    End_Procedure
86343>>>>>>>>>
86343>>>>>>>>>    Function psIniSectionName Returns String
86345>>>>>>>>>        String sRetval
86345>>>>>>>>>        Get psIniSectionName of (phoSQLConnectionIniFile(Self)) to sRetval
86346>>>>>>>>>        Function_Return sRetval
86347>>>>>>>>>    End_Function
86348>>>>>>>>>
86348>>>>>>>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
86350>>>>>>>>>        Handle ho
86350>>>>>>>>>        Get phoSQLConnectionIniFile to ho
86351>>>>>>>>>        Set IniFileValue of ho to sSection sValueName sValue
86352>>>>>>>>>    End_Procedure
86353>>>>>>>>>
86353>>>>>>>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
86355>>>>>>>>>        Handle ho
86355>>>>>>>>>        String sRetval
86355>>>>>>>>>        Get phoSQLConnectionIniFile to ho
86356>>>>>>>>>        Get IniFileValue of ho sSection sValueName sDefaultValue to sRetval
86357>>>>>>>>>        Function_Return sRetval
86358>>>>>>>>>    End_Function
86359>>>>>>>>>
86359>>>>>>>>>    Function SectionExists String sSection Returns Boolean
86361>>>>>>>>>        Handle ho
86361>>>>>>>>>        Boolean bRetval
86361>>>>>>>>>        Get phoSQLConnectionIniFile to ho
86362>>>>>>>>>        Get SectionExists of ho sSection to bRetval
86363>>>>>>>>>        Function_Return bRetval
86364>>>>>>>>>    End_Function
86365>>>>>>>>>
86365>>>>>>>>>    Function KeyExists String sSection String sKey Returns Boolean
86367>>>>>>>>>        Handle ho
86367>>>>>>>>>        Boolean bRetval
86367>>>>>>>>>        Get phoSQLConnectionIniFile to ho
86368>>>>>>>>>        Get KeyExists of ho sSection sKey to bRetval
86369>>>>>>>>>        Function_Return bRetval
86370>>>>>>>>>    End_Function
86371>>>>>>>>>
86371>>>>>>>>>    Function EncryptPassword String sPassword Returns String
86373>>>>>>>>>        Handle ho
86373>>>>>>>>>        String sRetval
86373>>>>>>>>>        Get phoSQLConnectionIniFile to ho
86374>>>>>>>>>        Get EncryptPassword of ho sPassword to sRetval
86375>>>>>>>>>        Function_Return sRetval
86376>>>>>>>>>    End_Function
86377>>>>>>>>>
86377>>>>>>>>>    Function DecryptPassword String sPassword Returns String
86379>>>>>>>>>        Handle ho
86379>>>>>>>>>        String sRetval
86379>>>>>>>>>        Get phoSQLConnectionIniFile to ho
86380>>>>>>>>>        Get DecryptPassword of ho sPassword to sRetval
86381>>>>>>>>>        Function_Return sRetval
86382>>>>>>>>>    End_Function
86383>>>>>>>>>
86383>>>>>>>>>    // *** Main Connection Message ***
86383>>>>>>>>>    Procedure CreateSQLConnection String sDriverID String sConnectionID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Boolean bSilent Boolean bExitProgram
86385>>>>>>>>>        Handle hoDriver
86385>>>>>>>>>        String sConnectionString sError
86385>>>>>>>>>        Boolean bLoginSuccessful
86385>>>>>>>>>
86385>>>>>>>>>        Get ConstructConnectionString sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnectionString
86386>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
86387>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
86388>>>>>>>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
86389>>>>>>>>>        If (bLoginSuccessful = False) Begin
86391>>>>>>>>>            Error DFERR_PROGRAM (CS_DUF_CannotLoginToServer * CS_DUF_ErrorText * String(sError) + "\nConnectionID = " * sConnectionID + "\nConnection String = " * sConnectionString)   
86392>>>>>>>>>>
86392>>>>>>>>>            If (bExitProgram = True) Begin
86394>>>>>>>>>                Send Exit_Application
86395>>>>>>>>>            End
86395>>>>>>>>>>
86395>>>>>>>>>        End
86395>>>>>>>>>>
86395>>>>>>>>>        Send Destroy of hoDriver
86396>>>>>>>>>    End_Procedure
86397>>>>>>>>>
86397>>>>>>>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
86399>>>>>>>>>        Integer iRetval
86399>>>>>>>>>        Handle hoCLI
86399>>>>>>>>>        String sDriverID
86399>>>>>>>>>
86399>>>>>>>>>        Get psDriverID to sDriverID
86400>>>>>>>>>        Get Create (Refclass(cCLIHandler)) to hoCLI
86401>>>>>>>>>        If (hoCLI <> 0) Begin
86403>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
86404>>>>>>>>>            Get RedirectConnection of hoCLI sOldConnection sNewConnection to iRetval
86405>>>>>>>>>            Send Destroy of hoCLI
86406>>>>>>>>>        End
86406>>>>>>>>>>
86406>>>>>>>>>
86406>>>>>>>>>        Function_Return iRetval
86407>>>>>>>>>    End_Function
86408>>>>>>>>>
86408>>>>>>>>>    Procedure CreateConnParamsFromConnectionString String sDriverID String sConnectionString
86410>>>>>>>>>        tSQLConnection SQLConnection
86410>>>>>>>>>        tSQLConnection SQLConnection
86410>>>>>>>>>
86410>>>>>>>>>        Set psDriverID to sDriverID
86411>>>>>>>>>        Get DeComposeConnectionString sDriverID sConnectionString to SQLConnection
86412>>>>>>>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID SQLConnection.sServer;                                 SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted False
86413>>>>>>>>>    End_Procedure
86414>>>>>>>>>
86414>>>>>>>>>    // This is needed when e.g. the connection id we have specified in the program code
86414>>>>>>>>>    // also exists in e.g. the MSSQLDRV.ini file (can either be local in the Data folder
86414>>>>>>>>>    // or the one in the DataFlex Bin folder.)
86414>>>>>>>>>    // We then need to delete the current one before creating a new one.
86414>>>>>>>>>    // This is because the parameters may differ between the program code and the
86414>>>>>>>>>    // MSSQLDRV.ini file in a deployed environment. Also DataFlex will generate an error
86414>>>>>>>>>    // when one tries to create a Connection ID that already exists.
86414>>>>>>>>>    Procedure RemoveExistingConnectionID String sDriverID String sConnectionID
86416>>>>>>>>>        Integer iResult iDriver iNumConn iConn
86416>>>>>>>>>        Handle hoCLI
86416>>>>>>>>>        String sID
86416>>>>>>>>>
86416>>>>>>>>>        If (sDriverID = "" or sConnectionID = "") Begin
86418>>>>>>>>>            Procedure_Return
86419>>>>>>>>>        End
86419>>>>>>>>>>
86419>>>>>>>>>
86419>>>>>>>>>        Move 0 to iResult
86420>>>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
86421>>>>>>>>>        If (hoCLI <> 0) Begin
86423>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
86424>>>>>>>>>            Get DriverIndex sDriverID to iDriver
86425>>>>>>>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
86428>>>>>>>>>            Decrement iNumConn
86429>>>>>>>>>            For iConn from 0 to iNumConn
86435>>>>>>>>>>
86435>>>>>>>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
86438>>>>>>>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
86440>>>>>>>>>                    Get DeleteConnectionID of hoCLI sConnectionID -1 to iResult
86441>>>>>>>>>                End
86441>>>>>>>>>>
86441>>>>>>>>>            Loop
86442>>>>>>>>>>
86442>>>>>>>>>            Send Destroy of hoCLI
86443>>>>>>>>>        End
86443>>>>>>>>>>
86443>>>>>>>>>
86443>>>>>>>>>    End_Procedure
86444>>>>>>>>>
86444>>>>>>>>>    Function ExistingConnectionSettings String sDriverID String sConnectionID Returns tSQLConnection
86446>>>>>>>>>        Integer iResult iDriver iNumConn iConn
86446>>>>>>>>>        Handle hoCLI
86446>>>>>>>>>        String sID sConnectionString sVal sDatabase
86446>>>>>>>>>        tSQLConnection SQLConnection
86446>>>>>>>>>        tSQLConnection SQLConnection
86446>>>>>>>>>        Boolean bTrusted
86446>>>>>>>>>
86446>>>>>>>>>        Move 0 to iResult
86447>>>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
86448>>>>>>>>>        If (hoCLI <> 0) Begin
86450>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
86451>>>>>>>>>            Get DriverIndex sDriverID to iDriver
86452>>>>>>>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
86455>>>>>>>>>            Decrement iNumConn
86456>>>>>>>>>            For iConn from 0 to iNumConn
86462>>>>>>>>>>
86462>>>>>>>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
86465>>>>>>>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
86467>>>>>>>>>                    Move sDriverID                                                      to SQLConnection.sDriverID      // For completeness only...
86468>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn              to SQLConnection.sConnectionID  // For completeness only...
86471>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iConn       to sConnectionString
86474>>>>>>>>>                    Move sConnectionString                                              to SQLConnection.sConnectionString
86475>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_OPTIONS of iDriver iConn      to SQLConnection.bSilentLogin
86478>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnection.sServer
86479>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnection.sDatabase
86480>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to SQLConnection.sUserID
86481>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to SQLConnection.sPassword
86482>>>>>>>>>
86482>>>>>>>>>                    Case Begin
86482>>>>>>>>>                        Case (sDriverID = MSSQLDRV_ID)
86484>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=") to sVal
86485>>>>>>>>>                            Move (If(Uppercase(sVal) = Uppercase(CS_SQLIniConnectionYes), True, False)) to bTrusted
86486>>>>>>>>>                            Move bTrusted                                               to SQLConnection.bTrusted
86487>>>>>>>>>                            Case Break
86488>>>>>>>>>                        Case (sDriverID = DB2_DRV_ID)
86491>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
86492>>>>>>>>>                            Case Break
86493>>>>>>>>>                        Case (sDriverID = ODBC_DRV_ID)
86496>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
86497>>>>>>>>>                            If (SQLConnection.sServer = "") Begin
86499>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniFileDSNKeyword  + "=") to SQLConnection.sServer
86500>>>>>>>>>                            End
86500>>>>>>>>>>
86500>>>>>>>>>                            Case Break
86501>>>>>>>>>                        Case (sDriverID = SQLFLEX)
86504>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
86505>>>>>>>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)    to sConnectionString
86506>>>>>>>>>                            If (SQLConnection.bTrusted = True) Begin
86508>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
86509>>>>>>>>>                            End
86509>>>>>>>>>>
86509>>>>>>>>>                            Else Begin
86510>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
86511>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
86512>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
86513>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
86514>>>>>>>>>                            End
86514>>>>>>>>>>
86514>>>>>>>>>                            Move sConnectionString                                         to SQLConnection.sConnectionString
86515>>>>>>>>>                            Case Break
86516>>>>>>>>>                        Case (sDriverID = MDSMySQL)
86519>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
86520>>>>>>>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)    to sConnectionString
86521>>>>>>>>>                            If (SQLConnection.bTrusted = True) Begin
86523>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
86524>>>>>>>>>                            End
86524>>>>>>>>>>
86524>>>>>>>>>                            Else Begin
86525>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
86526>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
86527>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
86528>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
86529>>>>>>>>>                            End
86529>>>>>>>>>>
86529>>>>>>>>>                            Move sConnectionString                                         to SQLConnection.sConnectionString
86530>>>>>>>>>                            Case Break
86531>>>>>>>>>                        Case (sDriverID = MDSPgSQL)
86534>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
86535>>>>>>>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)    to sConnectionString
86536>>>>>>>>>                            If (SQLConnection.bTrusted = True) Begin
86538>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
86539>>>>>>>>>                            End
86539>>>>>>>>>>
86539>>>>>>>>>                            Else Begin
86540>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
86541>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
86542>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
86543>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
86544>>>>>>>>>                            End
86544>>>>>>>>>>
86544>>>>>>>>>                            Move sConnectionString                                                to SQLConnection.sConnectionString
86545>>>>>>>>>                            Case Break
86546>>>>>>>>>
86546>>>>>>>>>                        Case (sDriverID = ORAFLEX)
86549>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to SQLConnection.sServer
86550>>>>>>>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)         to sConnectionString
86551>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
86552>>>>>>>>>                            If (sDatabase <> "" and (not(SQLConnection.sServer contains "/"))) Begin
86554>>>>>>>>>                                Move (SQLConnection.sServer + "/" + sDatabase)                  to SQLConnection.sServer
86555>>>>>>>>>                            End
86555>>>>>>>>>>
86555>>>>>>>>>                            If (SQLConnection.bTrusted = True) Begin
86557>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
86558>>>>>>>>>                            End
86558>>>>>>>>>>
86558>>>>>>>>>                            Else Begin
86559>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
86560>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
86561>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
86562>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
86563>>>>>>>>>                            End
86563>>>>>>>>>>
86563>>>>>>>>>                            Move sConnectionString                                         to SQLConnection.sConnectionString
86564>>>>>>>>>                            Case Break
86565>>>>>>>>>                        Case Else
86565>>>>>>>>>                            Error ("Wrong driver ID passed:" * sDriverID)
86566>>>>>>>>>>
86566>>>>>>>>>                            Case Break
86567>>>>>>>>>                    Case End
86567>>>>>>>>>                End
86567>>>>>>>>>>
86567>>>>>>>>>            Loop
86568>>>>>>>>>>
86568>>>>>>>>>            Send Destroy of hoCLI
86569>>>>>>>>>        End
86569>>>>>>>>>>
86569>>>>>>>>>
86569>>>>>>>>>        Function_Return SQLConnection
86570>>>>>>>>>    End_Function
86571>>>>>>>>>
86571>>>>>>>>>    Function DriverIndex String sDriverID Returns Integer
86573>>>>>>>>>        String  sCurrentDriver
86573>>>>>>>>>        Integer iNumberOfDrivers iDriver iCount
86573>>>>>>>>>
86573>>>>>>>>>        Move 0 to iDriver
86574>>>>>>>>>        Move 0 to iCount
86575>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
86578>>>>>>>>>        For iCount from 1 to iNumberOfDrivers
86584>>>>>>>>>>
86584>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
86587>>>>>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
86589>>>>>>>>>                Function_Return iCount
86590>>>>>>>>>            End
86590>>>>>>>>>>
86590>>>>>>>>>        Loop
86591>>>>>>>>>>
86591>>>>>>>>>
86591>>>>>>>>>        // If driver not previously loaded; attempt to do so now.
86591>>>>>>>>>        If (iDriver = 0) Begin
86593>>>>>>>>>            Move 0 to LastErr
86594>>>>>>>>>            Load_Driver sDriverID
86595>>>>>>>>>            // If driver could not be loaded.
86595>>>>>>>>>            If (LastErr = DFERR_CANT_LOAD_DLL) Begin
86597>>>>>>>>>                Move -1 to iCount
86598>>>>>>>>>            End
86598>>>>>>>>>>
86598>>>>>>>>>        End
86598>>>>>>>>>>
86598>>>>>>>>>        Function_Return iCount
86599>>>>>>>>>    End_Function
86600>>>>>>>>>
86600>>>>>>>>>    // This will update connection settings of the cCLIHandler object with that passed struct values.
86600>>>>>>>>>    Procedure UpdateConnectionString tSQLConnection SQLConnection
86602>>>>>>>>>        String sDriverID sConnectionID sServer sDatabase sUserID sPassword
86602>>>>>>>>>        Boolean bTrusted bSilent
86602>>>>>>>>>        Integer iRetval
86602>>>>>>>>>
86602>>>>>>>>>        Move SQLConnection.sDriverID     to sDriverID
86603>>>>>>>>>        Move SQLConnection.sConnectionID to sConnectionID
86604>>>>>>>>>        Move SQLConnection.sServer       to sServer
86605>>>>>>>>>        Move SQLConnection.sDatabase     to sDatabase
86606>>>>>>>>>        Move SQLConnection.bTrusted      to bTrusted
86607>>>>>>>>>        Move SQLConnection.sUserID       to sUserID
86608>>>>>>>>>        Move SQLConnection.sPassword     to sPassword
86609>>>>>>>>>        Move SQLConnection.bSilentLogin  to bSilent
86610>>>>>>>>>
86610>>>>>>>>>        Send CreateSQLConnection sDriverID sConnectionID sServer sDatabase bTrusted sUserID sPassword bSilent False
86611>>>>>>>>>        // Note that this message will first delete the current ConnectionID if it exists; which is needed by the cCLIHandler logic.
86611>>>>>>>>>        Get AutoSetConnectionID to iRetval
86612>>>>>>>>>    End_Procedure
86613>>>>>>>>>
86613>>>>>>>>>    // Called when the object is constructed.
86613>>>>>>>>>    // It will check the psDriverID for a ConnectionID and save it
86613>>>>>>>>>    // as psConnectionID property. It is later used whenever a login to
86613>>>>>>>>>    // the database is needed.
86613>>>>>>>>>    Function AutoSetConnectionID Returns Boolean
86615>>>>>>>>>        String sConnectionID sDriverID sConnectionString
86615>>>>>>>>>        Integer iDriver iRetval
86615>>>>>>>>>        Handle hoCLI
86615>>>>>>>>>        Boolean bOK bSilent bMertechDriver
86615>>>>>>>>>
86615>>>>>>>>>        Get pbSilentLogin      to bSilent
86616>>>>>>>>>        Get psConnectionID     to sConnectionID
86617>>>>>>>>>        Get psConnectionString to sConnectionString
86618>>>>>>>>>        // Get the driver Connection ID string & set the psConnectionString property.
86618>>>>>>>>>        Get psDriverID to sDriverID
86619>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
86620>>>>>>>>>        If (bOK = False) Begin
86622>>>>>>>>>            Function_Return False
86623>>>>>>>>>        End
86623>>>>>>>>>>
86623>>>>>>>>>
86623>>>>>>>>>        // Mertech drivers can't use connection ID's.
86623>>>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
86624>>>>>>>>>        If (bMertechDriver = True) Begin
86626>>>>>>>>>            // This ensures that the correct Server & Database attributes are set both for
86626>>>>>>>>>            // embedded SQL calls and "normal" database commands like e.g. "Open".
86626>>>>>>>>>            Get _MertechSQLManagerHandle to hoCLI
86627>>>>>>>>>            Function_Return (hoCLI <> 0)
86628>>>>>>>>>        End
86628>>>>>>>>>>
86628>>>>>>>>>
86628>>>>>>>>>        Get DriverIndex sDriverID          to iDriver
86629>>>>>>>>>        // If driver not loaded; load it.
86629>>>>>>>>>        If (iDriver = 0) Begin
86631>>>>>>>>>            Load_Driver sDriverID
86632>>>>>>>>>            Get DriverIndex sDriverID      to iDriver
86633>>>>>>>>>        End
86633>>>>>>>>>>
86633>>>>>>>>>        // This shouldn't be possible; unless the driver.dll file is missing or something...
86633>>>>>>>>>        If (iDriver = 0) Begin
86635>>>>>>>>>            Error DFERR_PROGRAM ("The database driver could not be loaded! Connection to database failed." * sDriverID)
86636>>>>>>>>>>
86636>>>>>>>>>            Function_Return False
86637>>>>>>>>>        End           
86637>>>>>>>>>>
86637>>>>>>>>>        Set_Attribute DF_DRIVER_LOGIN_ON_OPEN of iDriver to True
86640>>>>>>>>>        
86640>>>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
86641>>>>>>>>>        Set psDriverID of hoCLI            to sDriverID
86642>>>>>>>>>        // Delete the connection first; in case it exists
86642>>>>>>>>>        Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
86643>>>>>>>>>        Get CreateConnectionID of hoCLI sConnectionID sConnectionString bSilent to iRetval 
86644>>>>>>>>>        Send Destroy of hoCLI
86645>>>>>>>>>
86645>>>>>>>>>        Function_Return (iRetval = 0)
86646>>>>>>>>>    End_Function
86647>>>>>>>>>
86647>>>>>>>>>    // Returns the handle of the Mertech SQL handler.
86647>>>>>>>>>    // It also ensures that the correct Server & Database attributes are set both for
86647>>>>>>>>>    // embedded SQL calls and "normal" database commands like e.g. "Open".
86647>>>>>>>>>    // Note: This does _not_ return a proper CLI handler handle as it is not in this class.
86647>>>>>>>>>    //       So the return value is of no use! But we don't need the handle for this class.
86647>>>>>>>>>    Function _MertechSQLManagerHandle Returns Handle
86649>>>>>>>>>        Handle hoSQLHandler
86649>>>>>>>>>        String sDriverID sServer sDatabase
86649>>>>>>>>>
86649>>>>>>>>>        Move 0 to hoSQLHandler
86650>>>>>>>>>        Get psDriverID to sDriverID
86651>>>>>>>>>        Get psServer   to sServer
86652>>>>>>>>>        Get psDatabase to sDatabase
86653>>>>>>>>>        // This command is used to set the server to be used when opening tables
86653>>>>>>>>>        SET_CURRENT_SQL_SERVER to sServer
86696>>>>>>>>>>
86696>>>>>>>>>        // This command is used to specify which server to use for embedded SQL statements,
86696>>>>>>>>>        // but it has been constructed rather studidly as only constants and not variables
86696>>>>>>>>>        // are allowed...
86696>>>>>>>>>        If (sDriverID = MDSPgSQL) Begin
86698>>>>>>>>>            SET_CURRENT_SQL_SERVER_CONNECTION of MDSPgSQL to sServer
86714>>>>>>>>>        End
86714>>>>>>>>>>
86714>>>>>>>>>        If (sDriverID = MDSMySQL) Begin
86716>>>>>>>>>            SET_CURRENT_SQL_SERVER_CONNECTION of MDSMySQL to sServer
86732>>>>>>>>>        End
86732>>>>>>>>>>
86732>>>>>>>>>        If (sDriverID = ORAFLEX) Begin
86734>>>>>>>>>            SET_CURRENT_SQL_SERVER_CONNECTION of ORAFLEX to sServer
86750>>>>>>>>>        End
86750>>>>>>>>>>
86750>>>>>>>>>        If (sDriverID = SQLFLEX) Begin
86752>>>>>>>>>            SET_CURRENT_SQL_SERVER_CONNECTION of SQLFLEX to sServer
86768>>>>>>>>>        End
86768>>>>>>>>>>
86768>>>>>>>>>
86768>>>>>>>>>        // This command is used to specify which database is used for embedded SQL statements.
86768>>>>>>>>>        SQL_USE_DATABASE sDatabase
86806>>>>>>>>>>
86806>>>>>>>>>        SET_DATABASE_NAME to sDatabase
86844>>>>>>>>>>
86844>>>>>>>>>
86844>>>>>>>>>        // Can't have this here because the property is defined for the cDbUpdateFunctionLibrary class,
86844>>>>>>>>>        // which object may or may not have been created at this point. So don't use the return
86844>>>>>>>>>        // value for this function!
86844>>>>>>>>>        //Get phoSQLManagerMT to hoSQLHandler
86844>>>>>>>>>
86844>>>>>>>>>        Function_Return hoSQLHandler
86845>>>>>>>>>    End_Function
86846>>>>>>>>>
86846>>>>>>>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
86848>>>>>>>>>        Boolean bOK bMertechDriver
86848>>>>>>>>>
86848>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
86849>>>>>>>>>
86849>>>>>>>>>        If (bOK = False) Begin
86851>>>>>>>>>            Get IsMertechDriver sDriverID to bOK
86852>>>>>>>>>        End
86852>>>>>>>>>>
86852>>>>>>>>>
86852>>>>>>>>>        If (bOK = False) Begin
86854>>>>>>>>>            Get IsMertechDriver sDriverID to bMertechDriver
86855>>>>>>>>>            If (bMertechDriver = True) Begin
86857>>>>>>>>>                Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV_ID, DB2_DRV_ID, ODBC_DRV_ID, SQLFLEX, ORAFLEX, MDSPgSQL or MDSMYSQL"
86858>>>>>>>>>>
86858>>>>>>>>>            End
86858>>>>>>>>>>
86858>>>>>>>>>            Else Begin
86859>>>>>>>>>                Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV_ID, DB2_DRV_ID or ODBC_DRV_ID"
86860>>>>>>>>>>
86860>>>>>>>>>            End
86860>>>>>>>>>>
86860>>>>>>>>>            Function_Return False
86861>>>>>>>>>        End
86861>>>>>>>>>>
86861>>>>>>>>>
86861>>>>>>>>>        Function_Return True
86862>>>>>>>>>    End_Function
86863>>>>>>>>>
86863>>>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
86865>>>>>>>>>        Boolean bOK
86865>>>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID or sDriverID = DFBTRDRV_ID) to bOK
86866>>>>>>>>>        Function_Return bOK
86867>>>>>>>>>    End_Function
86868>>>>>>>>>
86868>>>>>>>>>    Function IsMertechDriver String sDriverID Returns Boolean
86870>>>>>>>>>        Boolean bOK
86870>>>>>>>>>        Move False to bOK
86871>>>>>>>>>//        #IFDEF DUF_Use_Mertech_Drivers
86871>>>>>>>>>            Move (sDriverID = SQLFLEX or sDriverID = ORAFLEX or sDriverID = MDSPgSQL or sDriverID = MDSMYSQL) to bOK
86872>>>>>>>>>//        #ENDIF
86872>>>>>>>>>        Function_Return bOK
86873>>>>>>>>>    End_Function
86874>>>>>>>>>
86874>>>>>>>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
86876>>>>>>>>>        Handle hoIniFile
86876>>>>>>>>>        String sConnect
86876>>>>>>>>>
86876>>>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
86877>>>>>>>>>        Get ConstructConnectionString of hoIniFile sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnect
86878>>>>>>>>>
86878>>>>>>>>>        Function_Return sConnect
86879>>>>>>>>>    End_Function
86880>>>>>>>>>
86880>>>>>>>>>    // Sample sConnString: "SERVER=(local)\SQLEXPRESS;UID=dbuser;PWD=secret;DATABASE=OrderEntry;, 0"
86880>>>>>>>>>    // Pass a complete driver connection string
86880>>>>>>>>>    // Returns the following as a struct:
86880>>>>>>>>>    //   sServer, sDatabase, sUser, sPassword & True if Trusted_Connection is used.
86880>>>>>>>>>    // Finally also returns a boolean TRUE if trusted_connection=yes, else false is returned.
86880>>>>>>>>>    //
86880>>>>>>>>>    Function DeComposeConnectionString String sDriverID String sConnectionString Returns tSQLConnection
86882>>>>>>>>>        tSQLConnection SQLConnection
86882>>>>>>>>>        tSQLConnection SQLConnection
86882>>>>>>>>>        String sValue sConnectionID sServer sDatabase sUserID sPassword
86882>>>>>>>>>        Boolean bTrusted bSilent bOK
86882>>>>>>>>>        Integer iPos
86882>>>>>>>>>
86882>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
86883>>>>>>>>>        If (bOK = False) Begin
86885>>>>>>>>>            Function_Return SQLConnection
86886>>>>>>>>>        End
86886>>>>>>>>>>
86886>>>>>>>>>
86886>>>>>>>>>        Move False to bTrusted
86887>>>>>>>>>        Move False to bSilent
86888>>>>>>>>>
86888>>>>>>>>>        Case Begin
86888>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
86890>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to sServer
86891>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
86892>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
86893>>>>>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
86894>>>>>>>>>                If (bTrusted = False) Begin
86896>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
86897>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
86898>>>>>>>>>                End
86898>>>>>>>>>>
86898>>>>>>>>>                Case Break
86899>>>>>>>>>
86899>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
86902>>>>>>>>>                If (uppercase(sConnectionString) contains ("." + CS_SQLIniDSNKeyword)) Begin
86904>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniFileDSNKeyword + "=")  to sServer
86905>>>>>>>>>                End
86905>>>>>>>>>>
86905>>>>>>>>>                Else Begin
86906>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
86907>>>>>>>>>                End
86907>>>>>>>>>>
86907>>>>>>>>>
86907>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
86908>>>>>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
86909>>>>>>>>>                If (bTrusted = False) Begin
86911>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
86912>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
86913>>>>>>>>>                End
86913>>>>>>>>>>
86913>>>>>>>>>                Case Break
86914>>>>>>>>>
86914>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
86917>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
86918>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
86919>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
86920>>>>>>>>>                Case Break
86921>>>>>>>>>
86921>>>>>>>>>            Case (sDriverID = SQLFLEX)
86924>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to sServer
86925>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
86926>>>>>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
86927>>>>>>>>>                If (bTrusted = False) Begin
86929>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
86930>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
86931>>>>>>>>>                End
86931>>>>>>>>>>
86931>>>>>>>>>                Case Break
86932>>>>>>>>>
86932>>>>>>>>>            Case (sDriverID = ORAFLEX)
86935>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
86936>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
86937>>>>>>>>>                If (sDatabase <> "" and (not(sServer contains "/"))) Begin
86939>>>>>>>>>                    Move (sServer + "/" + sDatabase)                                to sServer
86940>>>>>>>>>                End
86940>>>>>>>>>>
86940>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
86941>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
86942>>>>>>>>>                Case Break
86943>>>>>>>>>
86943>>>>>>>>>            Case (sDriverID = MDSPgSQL)
86946>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
86947>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
86948>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
86949>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
86950>>>>>>>>>                Case Break
86951>>>>>>>>>
86951>>>>>>>>>            Case (sDriverID = MDSMySQL)
86954>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
86955>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
86956>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
86957>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
86958>>>>>>>>>                Case Break
86959>>>>>>>>>
86959>>>>>>>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
86962>>>>>>>>>                Break
86963>>>>>>>>>        Case End
86963>>>>>>>>>
86963>>>>>>>>>        Get ParseKeyWord sConnectionString (Uppercase(CS_SQLConnectionIDText))  to sConnectionID
86964>>>>>>>>>
86964>>>>>>>>>        // bSilent?
86964>>>>>>>>>        Move (Pos(",0", sConnectionString))                                     to iPos
86965>>>>>>>>>        If (iPos = 0) Begin
86967>>>>>>>>>            Move (Pos(",1", sConnectionString))                                 to iPos
86968>>>>>>>>>        End
86968>>>>>>>>>>
86968>>>>>>>>>        If (iPos = 0) Begin
86970>>>>>>>>>            Move "0"                                                            to sValue
86971>>>>>>>>>        End
86971>>>>>>>>>>
86971>>>>>>>>>        Else Begin
86972>>>>>>>>>            Move (Mid(sConnectionString, 1, (iPos +1)))                         to sValue
86973>>>>>>>>>        End
86973>>>>>>>>>>
86973>>>>>>>>>        Move (If(sValue = 1, True, False))                                      to bSilent
86974>>>>>>>>>
86974>>>>>>>>>        Move (Trim(sDriverID))                                                  to SQLConnection.sDriverID
86975>>>>>>>>>        Move (Trim(sConnectionID))                                              to SQLConnection.sConnectionID
86976>>>>>>>>>        Move (Trim(sConnectionString))                                          to SQLConnection.sConnectionString
86977>>>>>>>>>        Move (Trim(sServer))                                                    to SQLConnection.sServer
86978>>>>>>>>>        Move (Trim(sDatabase))                                                  to SQLConnection.sDatabase
86979>>>>>>>>>        Move bTrusted                                                           to SQLConnection.bTrusted
86980>>>>>>>>>        Move (Trim(sUserID))                                                    to SQLConnection.sUserID
86981>>>>>>>>>        Move (Trim(sPassword))                                                  to SQLConnection.sPassword
86982>>>>>>>>>        Move bSilent                                                            to SQLConnection.bSilentLogin
86983>>>>>>>>>
86983>>>>>>>>>        Function_Return SQLConnection
86984>>>>>>>>>    End_Function
86985>>>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
86985>>>>>>>>>>
86985>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
86987>>>>>>>>>>    Integer iStart iEnd
86987>>>>>>>>>>    String sRetval
86987>>>>>>>>>>
86987>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
86988>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
86989>>>>>>>>>>    If (iStart = 0) Begin
86991>>>>>>>>>>        Function_Return ""
86992>>>>>>>>>>    End
86992>>>>>>>>>>>
86992>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
86993>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
86994>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
86996>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
86997>>>>>>>>>>    End
86997>>>>>>>>>>>
86997>>>>>>>>>>    Else Begin
86998>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
86999>>>>>>>>>>    End
86999>>>>>>>>>>>
86999>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
87001>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
87002>>>>>>>>>>        Decrement iEnd
87003>>>>>>>>>>    End
87003>>>>>>>>>>>
87003>>>>>>>>>>    If (iEnd <> 0) Begin
87005>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
87006>>>>>>>>>>    End
87006>>>>>>>>>>>
87006>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
87007>>>>>>>>>>
87007>>>>>>>>>>    Function_Return (Trim(sRetval))
87008>>>>>>>>>>End_Function
87009>>>>>>>>>>
87009>>>>>>>>>>
87009>>>>>>>>>
87009>>>>>>>>>    // To update the SQLSettings.ini file with updated connection data (SQLConnection struct data).
87009>>>>>>>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
87011>>>>>>>>>        Handle ho
87011>>>>>>>>>        Integer iIndex
87011>>>>>>>>>        Boolean bRetval bOK
87011>>>>>>>>>        tSQLConnection SQLConnection
87011>>>>>>>>>        tSQLConnection SQLConnection
87011>>>>>>>>>
87011>>>>>>>>>        Get pSQLConnection to SQLConnection
87012>>>>>>>>>        Get phoSQLConnectionIniFile to ho
87013>>>>>>>>>        Get SQLIniFileConnectionIDIndex of ho sConnectionID to iIndex
87014>>>>>>>>>        If (iIndex = -1) Begin
87016>>>>>>>>>            Function_Return False
87017>>>>>>>>>        End
87017>>>>>>>>>>
87017>>>>>>>>>
87017>>>>>>>>>        Get SQLIniFileUpdateConnection of ho SQLConnection to bRetval
87018>>>>>>>>>        Send UpdateConnectionString SQLConnection
87019>>>>>>>>>        If (ghoConnection > 0) Begin
87021>>>>>>>>>            Get ConnectionIdIndex of ghoConnection SQLConnection.sConnectionID to iIndex
87022>>>>>>>>>            If (iIndex <> -1) Begin
87024>>>>>>>>>                Get RedirectConnectionId of ghoConnection SQLConnection.sConnectionID (SQLConnection.sServer + ";" + CS_SQLIniDatabaseKeyword + "=" + SQLConnection.sDatabase) SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted True to bOK
87025>>>>>>>>>            End
87025>>>>>>>>>>
87025>>>>>>>>>        End
87025>>>>>>>>>>
87025>>>>>>>>>
87025>>>>>>>>>        Function_Return bRetval
87026>>>>>>>>>    End_Function
87027>>>>>>>>>
87027>>>>>>>>>End_Class
87028>>>>>>>Use vWin32fh.pkg
87028>>>>>>>Use Dfabout.pkg
Including file: DfAbout.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\DFAbout\DfAbout.pkg)
87028>>>>>>>>>
87028>>>>>>>>>Use LanguageText.pkg
87028>>>>>>>>>Use Windows.pkg
87028>>>>>>>>>Use Dfclient.pkg
87028>>>>>>>>>Use DFbitmap.pkg
87028>>>>>>>>>Use GlobalFunctionsProcedures.pkg
87028>>>>>>>>>Use cRichEdit.pkg
87028>>>>>>>>>Use cTextEdit.pkg
87028>>>>>>>>>Use cRichEdit.pkg
87028>>>>>>>>>Use gFormatNumbers.pkg
Including file: gFormatNumbers.pkg    (C:\Program Files\DataFlex 20.1\Pkg\gFormatNumbers.pkg)
87028>>>>>>>>>>>Use cFormatter.pkg
Including file: cFormatter.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cFormatter.pkg)
87028>>>>>>>>>>>>>Use VDFBase.pkg
87028>>>>>>>>>>>>>
87028>>>>>>>>>>>>>Class cFormatter is an cObject
87029>>>>>>>>>>>>>    
87029>>>>>>>>>>>>>    Procedure Construct_object
87031>>>>>>>>>>>>>        Integer iCh
87031>>>>>>>>>>>>>        Forward Send construct_object
87033>>>>>>>>>>>>>        Property String  psCurrencySymbol
87034>>>>>>>>>>>>>        Set psCurrencySymbol to (Default_Currency_Symbol())
87035>>>>>>>>>>>>>        
87035>>>>>>>>>>>>>        Property String  psLeft
87036>>>>>>>>>>>>>        Property String  psright
87037>>>>>>>>>>>>>        Property Integer pbThousandsSep
87038>>>>>>>>>>>>>        Property Integer piPoints
87039>>>>>>>>>>>>>        
87039>>>>>>>>>>>>>        Property String  psCurPosLeft
87040>>>>>>>>>>>>>        Property String  psCurPosright
87041>>>>>>>>>>>>>        Property Integer pbCurPosThousandsSep
87042>>>>>>>>>>>>>        Property Integer piCurPosPoints
87043>>>>>>>>>>>>>        
87043>>>>>>>>>>>>>        Property String  psCurNegLeft
87044>>>>>>>>>>>>>        Property String  psCurNegright
87045>>>>>>>>>>>>>        Property Integer pbCurNegThousandsSep
87046>>>>>>>>>>>>>        Property Integer piCurNegPoints
87047>>>>>>>>>>>>>        
87047>>>>>>>>>>>>>        Property String  psNumPosLeft
87048>>>>>>>>>>>>>        Property String  psNumPosright
87049>>>>>>>>>>>>>        Property Integer pbNumPosThousandsSep
87050>>>>>>>>>>>>>        Property Integer piNumPosPoints
87051>>>>>>>>>>>>>        
87051>>>>>>>>>>>>>        Property String  psNumNegLeft
87052>>>>>>>>>>>>>        Property String  psNumNegright
87053>>>>>>>>>>>>>        Property Integer pbNumNegThousandsSep
87054>>>>>>>>>>>>>        Property Integer piNumNegPoints
87055>>>>>>>>>>>>>        
87055>>>>>>>>>>>>>        Send SetFormat "$,#.##;($,#.##)" True  // currency
87056>>>>>>>>>>>>>        Send SetFormat  ",#.*"           False // numeric
87057>>>>>>>>>>>>>        
87057>>>>>>>>>>>>>    End_Procedure
87058>>>>>>>>>>>>>    
87058>>>>>>>>>>>>>    // internal
87058>>>>>>>>>>>>>    // parse passed format string and set temporary properties with result
87058>>>>>>>>>>>>>    Procedure ParseFormat String sFmt
87060>>>>>>>>>>>>>        
87060>>>>>>>>>>>>>        String sLeft sRight sDigit
87060>>>>>>>>>>>>>        Integer bSep iPos i iDigits
87060>>>>>>>>>>>>>        
87060>>>>>>>>>>>>>        // replace any literals. A "/" followed by anything.
87060>>>>>>>>>>>>>        // some literals are special. $ . , / #
87060>>>>>>>>>>>>>        Move (Replaces("/$",sFmt,Character(1)))    to sFmt
87061>>>>>>>>>>>>>        Move (Replaces("/.",sFmt,Character(2)))    to sFmt
87062>>>>>>>>>>>>>        Move (Replaces("/,",sFmt,Character(3)))    to sFmt
87063>>>>>>>>>>>>>        Move (Replaces("/"+"/",sFmt,Character(4))) to sFmt
87064>>>>>>>>>>>>>        Move (Replaces("/#",sFmt,Character(5)))    to sFmt
87065>>>>>>>>>>>>>        Move (Character(9)) to sDigit
87066>>>>>>>>>>>>>        Move (Replaces("#",sFmt,sDigit))           to sFmt
87067>>>>>>>>>>>>>        Move (Replaces("/",sFmt,""))               to sFmt // replace all others
87068>>>>>>>>>>>>>        
87068>>>>>>>>>>>>>        Move (Pos(",",sFmt))                 to bSep // if we have any , we use thousand seps
87069>>>>>>>>>>>>>        If bSep ;            Move (Replaces(",",sFmt,"")) to sFmt // remove all ,
87072>>>>>>>>>>>>>        
87072>>>>>>>>>>>>>        Move (Replaces("$",sFmt,psCurrencySymbol(Self))) to sFmt // replace any $ with currency symbol
87073>>>>>>>>>>>>>        
87073>>>>>>>>>>>>>        Move (Pos(".",sFmt)) to iPos                 // position of decimal
87074>>>>>>>>>>>>>        
87074>>>>>>>>>>>>>        // Move all the special literals back into place before parsing
87074>>>>>>>>>>>>>        Move (Replaces(Character(1),sFmt,"$")) to sFmt
87075>>>>>>>>>>>>>        Move (Replaces(Character(2),sFmt,".")) to sFmt
87076>>>>>>>>>>>>>        Move (Replaces(Character(3),sFmt,",")) to sFmt
87077>>>>>>>>>>>>>        Move (Replaces(Character(4),sFmt,"/")) to sFmt
87078>>>>>>>>>>>>>        Move (Replaces(Character(5),sFmt,"#")) to sFmt
87079>>>>>>>>>>>>>        
87079>>>>>>>>>>>>>        If (iPos>0) Begin                      // if we have a decimanl point
87081>>>>>>>>>>>>>            Move 1 to i                        // look for first non # to right and count the #s
87082>>>>>>>>>>>>>            If (mid(sFmt,1,iPos+i)="*") Begin  // the "*" is special. It means as many as you want
87084>>>>>>>>>>>>>                Move -2 to iDigits
87085>>>>>>>>>>>>>                Increment i
87086>>>>>>>>>>>>>            End
87086>>>>>>>>>>>>>>
87086>>>>>>>>>>>>>            While (mid(sFmt,1,iPos+i)=sDigit)
87090>>>>>>>>>>>>>                Increment i
87091>>>>>>>>>>>>>            Loop
87092>>>>>>>>>>>>>>
87092>>>>>>>>>>>>>            Move (Mid(sFmt,255,iPos+i)) to sRight // everything to the right of the last # is format stuff
87093>>>>>>>>>>>>>            If (iDigits=0) ;                Move (i-1) to iDigits
87096>>>>>>>>>>>>>            //
87096>>>>>>>>>>>>>            Move 1 to i                           // find the first non-# to the left of the point
87097>>>>>>>>>>>>>            While (mid(sFmt,1,iPos-i)=sDigit)     // everything to the left is format stuff
87101>>>>>>>>>>>>>                Increment i
87102>>>>>>>>>>>>>            Loop
87103>>>>>>>>>>>>>>
87103>>>>>>>>>>>>>            Move (left(sFmt,iPos-i)) to sLeft
87104>>>>>>>>>>>>>        End
87104>>>>>>>>>>>>>>
87104>>>>>>>>>>>>>        Else Begin                             // we have no decinal
87105>>>>>>>>>>>>>            Move 0 to iDigits                  // so points is none
87106>>>>>>>>>>>>>            Move (Pos(sDigit,sFmt)) to iPos    // find first #.
87107>>>>>>>>>>>>>            If (iPos=0) Begin                  // if none, entire string is left format stuff..wierd!
87109>>>>>>>>>>>>>                Move sFmt to sLeft
87110>>>>>>>>>>>>>                Move ""   to sRight
87111>>>>>>>>>>>>>            End
87111>>>>>>>>>>>>>>
87111>>>>>>>>>>>>>            Else Begin
87112>>>>>>>>>>>>>                Move (left(sFmt,iPos-1)) to sLeft // all char to left of first # is left format stuff
87113>>>>>>>>>>>>>                Move 1 to i
87114>>>>>>>>>>>>>                While (mid(sFmt,1,iPos+i)=sDigit) // find last #, all char to right is right format
87118>>>>>>>>>>>>>                    Increment i
87119>>>>>>>>>>>>>                Loop
87120>>>>>>>>>>>>>>
87120>>>>>>>>>>>>>                Move (Mid(sFmt,255,i+iPos)) to sRight
87121>>>>>>>>>>>>>            End
87121>>>>>>>>>>>>>>
87121>>>>>>>>>>>>>        End
87121>>>>>>>>>>>>>>
87121>>>>>>>>>>>>>        // set temporary format properties and exit
87121>>>>>>>>>>>>>        Set pbThousandsSep to bSep
87122>>>>>>>>>>>>>        Set psLeft         to sLeft
87123>>>>>>>>>>>>>        Set psRight        to sRight
87124>>>>>>>>>>>>>        Set piPoints       to iDigits
87125>>>>>>>>>>>>>    End_Procedure
87126>>>>>>>>>>>>>    
87126>>>>>>>>>>>>>    // Public: Sets a format string. Pass full format for Positve and negative in sFmt. Pass
87126>>>>>>>>>>>>>    //         bCurrency true is this is a currency format, false if a numeric format
87126>>>>>>>>>>>>>    //
87126>>>>>>>>>>>>>    //  e.g. Send SetFormat "$,#.##;($,#.##)" True
87126>>>>>>>>>>>>>    Procedure SetFormat String sFmt Integer bCurrency
87128>>>>>>>>>>>>>        String sPos sNeg
87128>>>>>>>>>>>>>        Integer iPos
87128>>>>>>>>>>>>>        
87128>>>>>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
87129>>>>>>>>>>>>>        If iPos Begin
87131>>>>>>>>>>>>>            Move (left(sFmt,iPos-1))    to sPos
87132>>>>>>>>>>>>>            Move (mid(sFmt,255,iPos+1)) to sNeg
87133>>>>>>>>>>>>>        End
87133>>>>>>>>>>>>>>
87133>>>>>>>>>>>>>        Else Begin
87134>>>>>>>>>>>>>            Move sFmt         to sPos
87135>>>>>>>>>>>>>            Move ("-" + sFmt) to sNeg
87136>>>>>>>>>>>>>        End
87136>>>>>>>>>>>>>>
87136>>>>>>>>>>>>>        Send ParseFormat sPos
87137>>>>>>>>>>>>>        If bCurrency Begin
87139>>>>>>>>>>>>>            Set pbCurPosThousandsSep to (pbThousandsSep(Self))
87140>>>>>>>>>>>>>            Set psCurPosLeft         to (psLeft(Self))
87141>>>>>>>>>>>>>            Set psCurPosRight        to (psRight(Self))
87142>>>>>>>>>>>>>            Set piCurPosPoints       to (piPoints(Self))
87143>>>>>>>>>>>>>        End
87143>>>>>>>>>>>>>>
87143>>>>>>>>>>>>>        Else Begin
87144>>>>>>>>>>>>>            Set pbNumPosThousandsSep to (pbThousandsSep(Self))
87145>>>>>>>>>>>>>            Set psNumPosLeft         to (psLeft(Self))
87146>>>>>>>>>>>>>            Set psNumPosRight        to (psRight(Self))
87147>>>>>>>>>>>>>            Set piNumPosPoints       to (piPoints(Self))
87148>>>>>>>>>>>>>        End
87148>>>>>>>>>>>>>>
87148>>>>>>>>>>>>>        
87148>>>>>>>>>>>>>        Send ParseFormat sNeg
87149>>>>>>>>>>>>>        If bCurrency Begin
87151>>>>>>>>>>>>>            Set pbCurNegThousandsSep to (pbThousandsSep(Self))
87152>>>>>>>>>>>>>            Set psCurNegLeft         to (psLeft(Self))
87153>>>>>>>>>>>>>            Set psCurNegRight        to (psRight(Self))
87154>>>>>>>>>>>>>            Set piCurNegPoints       to (piPoints(Self))
87155>>>>>>>>>>>>>        End
87155>>>>>>>>>>>>>>
87155>>>>>>>>>>>>>        Else Begin
87156>>>>>>>>>>>>>            Set pbNumNegThousandsSep to (pbThousandsSep(Self))
87157>>>>>>>>>>>>>            Set psNumNegLeft         to (psLeft(Self))
87158>>>>>>>>>>>>>            Set psNumNegRight        to (psRight(Self))
87159>>>>>>>>>>>>>            Set piNumNegPoints       to (piPoints(Self))
87160>>>>>>>>>>>>>        End
87160>>>>>>>>>>>>>>
87160>>>>>>>>>>>>>    End_Procedure
87161>>>>>>>>>>>>>    
87161>>>>>>>>>>>>>    // low level formatting. Pass parameters
87161>>>>>>>>>>>>>    Function Format_Num Number nNumber Integer iPoints Integer bSep ;            String sPrefix String sSuffix Returns String
87163>>>>>>>>>>>>>        String  sLeft sRight sNumber sSep sDec
87163>>>>>>>>>>>>>        Integer bIsNegative iDec iLen iCh
87163>>>>>>>>>>>>>        
87163>>>>>>>>>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iCh
87166>>>>>>>>>>>>>        Move (Character(iCh)) to sDec
87167>>>>>>>>>>>>>        
87167>>>>>>>>>>>>>        Move (abs(nNumber)) to sNumber
87168>>>>>>>>>>>>>        Move (Pos(sDec,sNumber)) to iDec
87169>>>>>>>>>>>>>        Move (If(iDec=0, sNumber, left(sNumber,iDec-1))) to sLeft
87170>>>>>>>>>>>>>        Move (If(iDec=0, "", mid(sNumber,255,iDec+1)))   to sRight
87171>>>>>>>>>>>>>        // format for decimal separator
87171>>>>>>>>>>>>>        If (iPoints>=0) ; // if -2, leave it alone, it should not be -1            Move (left(sRight+Repeat("0",iPoints),iPoints)) to sRight
87174>>>>>>>>>>>>>        
87174>>>>>>>>>>>>>        // format for thousand sep.
87174>>>>>>>>>>>>>        If bSep Begin
87176>>>>>>>>>>>>>            Get_Attribute DF_THOUSANDS_SEPARATOR to iCh
87179>>>>>>>>>>>>>            Move (Character(iCh)) to sSep
87180>>>>>>>>>>>>>            Move (Length(sLeft)) to iLen
87181>>>>>>>>>>>>>            While (iLen>3)
87185>>>>>>>>>>>>>                Move (insert(sSep,sLeft,iLen-2)) to sLeft
87186>>>>>>>>>>>>>                Move (iLen-3) to iLen
87187>>>>>>>>>>>>>            Loop
87188>>>>>>>>>>>>>>
87188>>>>>>>>>>>>>        End
87188>>>>>>>>>>>>>>
87188>>>>>>>>>>>>>        // if decimal points or -2 (allow anything) and there are points to show
87188>>>>>>>>>>>>>        If (iPoints>0 or (iPoints=-2 and sRight<>"")) ;            Move (sLeft + sDec + sright) to sLeft
87191>>>>>>>>>>>>>        Function_Return (sPrefix + sLeft+ sSuffix)
87192>>>>>>>>>>>>>    End_Function
87193>>>>>>>>>>>>>    
87193>>>>>>>>>>>>>    // Public: Format for currency
87193>>>>>>>>>>>>>    Function FormatCur Number nNumber Integer iPoints Returns String
87195>>>>>>>>>>>>>        String  sLeft sRight
87195>>>>>>>>>>>>>        Integer bSep
87195>>>>>>>>>>>>>        If (nNumber<0) Begin
87197>>>>>>>>>>>>>            Get pbCurNegThousandsSep to bSep
87198>>>>>>>>>>>>>            Get psCurNegLeft         to sLeft
87199>>>>>>>>>>>>>            Get psCurNegRight        to sRight
87200>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piCurNegPoints       to iPoints
87203>>>>>>>>>>>>>        End
87203>>>>>>>>>>>>>>
87203>>>>>>>>>>>>>        Else Begin
87204>>>>>>>>>>>>>            Get pbCurPosThousandsSep to bSep
87205>>>>>>>>>>>>>            Get psCurPosLeft         to sLeft
87206>>>>>>>>>>>>>            Get psCurPosRight        to sRight
87207>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piCurPosPoints       to iPoints
87210>>>>>>>>>>>>>        End
87210>>>>>>>>>>>>>>
87210>>>>>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
87211>>>>>>>>>>>>>    End_Function
87212>>>>>>>>>>>>>    
87212>>>>>>>>>>>>>    // Public: Format for numeric
87212>>>>>>>>>>>>>    Function FormatNum Number nNumber Integer iPoints Returns String
87214>>>>>>>>>>>>>        String  sLeft sRight
87214>>>>>>>>>>>>>        Integer bSep
87214>>>>>>>>>>>>>        If (nNumber<0) Begin
87216>>>>>>>>>>>>>            Get pbNumNegThousandsSep to bSep
87217>>>>>>>>>>>>>            Get psNumNegLeft         to sLeft
87218>>>>>>>>>>>>>            Get psNumNegRight        to sRight
87219>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piNumNegPoints       to iPoints
87222>>>>>>>>>>>>>        End
87222>>>>>>>>>>>>>>
87222>>>>>>>>>>>>>        Else Begin
87223>>>>>>>>>>>>>            Get pbNumPosThousandsSep to bSep
87224>>>>>>>>>>>>>            Get psNumPosLeft         to sLeft
87225>>>>>>>>>>>>>            Get psNumPosRight        to sRight
87226>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piNumPosPoints       to iPoints
87229>>>>>>>>>>>>>        End
87229>>>>>>>>>>>>>>
87229>>>>>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
87230>>>>>>>>>>>>>    End_Function
87231>>>>>>>>>>>>>    
87231>>>>>>>>>>>>>    
87231>>>>>>>>>>>>>    // Public: Format passing format string
87231>>>>>>>>>>>>>    Function FormatVal Number nNumber String sFmt Returns String
87233>>>>>>>>>>>>>        Integer iPos bIsNeg
87233>>>>>>>>>>>>>        String  sLeft sRight
87233>>>>>>>>>>>>>        Integer iPoints bSep
87233>>>>>>>>>>>>>        Move (nNumber<0) to bIsNeg
87234>>>>>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
87235>>>>>>>>>>>>>        Case Begin
87235>>>>>>>>>>>>>            Case (iPos and not(bIsNeg)) ;                Move (left(sFmt,iPos-1))    to sFmt
87238>>>>>>>>>>>>>            Case (iPos and bIsNeg) ;                Move (mid(sFmt,255,iPos+1)) to sFmt
87242>>>>>>>>>>>>>            Case (not(iPos) and not(bIsNeg)) ;                Move sFmt                   to sFmt
87246>>>>>>>>>>>>>            Case Else ;                Move ("-" + sFmt)           to sFmt
87248>>>>>>>>>>>>>        Case End
87248>>>>>>>>>>>>>        Send ParseFormat sFmt
87249>>>>>>>>>>>>>        Get pbThousandsSep to bSep
87250>>>>>>>>>>>>>        Get psLeft         to sLeft
87251>>>>>>>>>>>>>        Get psRight        to sRight
87252>>>>>>>>>>>>>        Get piPoints       to iPoints
87253>>>>>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
87254>>>>>>>>>>>>>    End_Function
87255>>>>>>>>>>>>>    
87255>>>>>>>>>>>>>End_Class
87256>>>>>>>>>>>
87256>>>>>>>>>>>Global_Variable Handle ghoFormatter
87256>>>>>>>>>>>Get Create of desktop U_cFormatter to ghoFormatter
87257>>>>>>>>>>>
87257>>>>>>>>>>>Function FormatNumber Global Number nNum Integer iPoints Returns String
87259>>>>>>>>>>>    Function_Return (FormatNum(ghoFormatter, nNum,iPoints))
87260>>>>>>>>>>>End_Function
87261>>>>>>>>>>>
87261>>>>>>>>>>>Function FormatCurrency Global Number nNum Integer iPoints Returns String
87263>>>>>>>>>>>    Function_Return (FormatCur(ghoFormatter, nNum,iPoints))
87264>>>>>>>>>>>End_Function
87265>>>>>>>>>>>
87265>>>>>>>>>>>Function FormatValue Global Number nNum String sFmt Returns String
87267>>>>>>>>>>>    Function_Return (FormatVal(ghoFormatter, nNum,sFmt))
87268>>>>>>>>>>>End_Function
87269>>>>>>>>>>>
87269>>>>>>>>>>>Procedure SetCurrencyFormat Global String sFmt
87271>>>>>>>>>>>    Send SetFormat of ghoFormatter sFmt True
87272>>>>>>>>>>>End_Procedure
87273>>>>>>>>>>>
87273>>>>>>>>>>>Procedure SetNumberFormat Global String sFmt
87275>>>>>>>>>>>    Send SetFormat of ghoFormatter sFmt False
87276>>>>>>>>>>>End_Procedure
87277>>>>>>>>>>>
87277>>>>>>>>>>>
87277>>>>>>>>>Use tWinStructs.pkg
87277>>>>>>>>>
87277>>>>>>>>>Use cli.pkg
87277>>>>>>>>>Use DFBTRDRV.PKG
87277>>>>>>>>>Use MSSqldrv.pkg
87277>>>>>>>>>Use db2_drv.pkg
87277>>>>>>>>>Use odbc_drv.pkg
87277>>>>>>>>>Use seq_chnl.pkg
87277>>>>>>>>>
87277>>>>>>>>>Register_Function phoWorkspace Returns Handle
87277>>>>>>>>>Register_Function Help_filename Returns String
87277>>>>>>>>>Register_Function GetHelpFile Returns String
87277>>>>>>>>>Register_Function pbEnterKeyAsTabKey Returns Boolean
87277>>>>>>>>>
87277>>>>>>>>>// Use of Mertech drivers:
87277>>>>>>>>>// Ad the line "Define DUF_Use_Mertech_Drivers" prior "Use" of this package to your source code if using Mertech drivers!
87277>>>>>>>>>    Use mertech.inc
87277>>>>>>>>>
87277>>>>>>>>>
87277>>>>>>>>>
87277>>>>>>>>>
87277>>>>>>>>>
87277>>>>>>>>>// *** Constant Declarations: ***
87277>>>>>>>>>//
87277>>>>>>>>>
87277>>>>>>>>>
87277>>>>>>>>>
87277>>>>>>>>>
87277>>>>>>>>>
87277>>>>>>>>>
87277>>>>>>>>>// 2016-12-12, Samuel:  Added section for Portuguese
87277>>>>>>>>>
87277>>>>>>>>>
87277>>>>>>>>>
87277>>>>>>>>>
87277>>>>>>>>>
87277>>>>>>>>>
87277>>>>>>>>>
87277>>>>>>>>>
87277>>>>>>>>>
87277>>>>>>>>>// System icon menu constants. If the upper left hand
87277>>>>>>>>>// icon in dialogs is clicked, shadow all menu items except Move & Close.
87277>>>>>>>>>    Define SC_RESTORE  for |CI$F120
87277>>>>>>>>>    Define SC_MOVE     for |CI$F010
87277>>>>>>>>>    Define SC_SIZE     for |CI$F000
87277>>>>>>>>>    Define SC_MINIMIZE for |CI$F020
87277>>>>>>>>>    Define SC_MAXIMIZE for |CI$F030
87277>>>>>>>>>    Define SC_CLOSE    for |CI$F060
87277>>>>>>>>>    Define SC_KEYMENU  for |CI$F100
87277>>>>>>>>>    Define SC_NEXTWINDOW for |CI$F040
87277>>>>>>>>>    Define SC_PREVWINDOW for |CI$F050
87277>>>>>>>>>
87277>>>>>>>>>Define CS_SignProgram        for "signtool.exe"
87277>>>>>>>>>Define CS_TempCertBatchFile  for "certinfo.bat"
87277>>>>>>>>>Define CS_VerifyCredentials  for "verify"
87277>>>>>>>>>Define CS_VerifyFileParam    for "/a"
87277>>>>>>>>>Define CS_DefAuthVerPolicy   for "/pa"
87277>>>>>>>>>Define SEE_MASK_NOCLOSEPROCESS for 64 //(0x00000040)
87277>>>>>>>>>
87277>>>>>>>>>// *** Struct Declarations: ***
87277>>>>>>>>>
87277>>>>>>>>>Struct AboutSHELLEXECUTEINFO
87277>>>>>>>>>    DWord   cbSize
87277>>>>>>>>>    Integer fMask
87277>>>>>>>>>    Handle  hwnd
87277>>>>>>>>>    Pointer lpVerb
87277>>>>>>>>>    Pointer lpFile
87277>>>>>>>>>    Pointer lpParameters
87277>>>>>>>>>    Pointer lpDirectory
87277>>>>>>>>>    Integer nShow
87277>>>>>>>>>    Pointer hInstApp
87277>>>>>>>>>    Pointer lpIDList
87277>>>>>>>>>    Pointer lpClass
87277>>>>>>>>>    Handle  hkeyClass
87277>>>>>>>>>    DWord   dwHotKey
87277>>>>>>>>>    Handle  hIconMonitor // Union
87277>>>>>>>>>    //Handle  hMonitor     // Union
87277>>>>>>>>>    Handle  hProcess
87277>>>>>>>>>End_Struct
87277>>>>>>>>>
87277>>>>>>>>>
87277>>>>>>>>>// OBSOLETE STRUCTURE AND WINDOWS API CALL. KEPT FOR BACKWARDS COMPATIBILITY
87277>>>>>>>>>//Type MEMORYSTATUS
87277>>>>>>>>>//   Field MEMORYSTATUS.dwLength         as DWord // sizeof(MEMORYSTATUS)
87277>>>>>>>>>//   Field MEMORYSTATUS.dwMemoryLoad     as DWord // percent Of memory in use
87277>>>>>>>>>//   Field MEMORYSTATUS.dwTotalPhys      as DWord // bytes Of physical memory
87277>>>>>>>>>//   Field MEMORYSTATUS.dwAvailPhys      as DWord // free physical memory bytes
87277>>>>>>>>>//   Field MEMORYSTATUS.dwTotalPageFile  as DWord // bytes Of paging file
87277>>>>>>>>>//   Field MEMORYSTATUS.dwAvailPageFile  as DWord // free bytes Of paging file
87277>>>>>>>>>//   Field MEMORYSTATUS.dwTotalVirtual   as DWord // user bytes Of address space
87277>>>>>>>>>//   Field MEMORYSTATUS.dwAvailVirtual   as DWord // free user bytes
87277>>>>>>>>>//End_Type
87277>>>>>>>>>
87277>>>>>>>>>// *** External Function calls: ***
87277>>>>>>>>>//
87277>>>>>>>>>    External_Function GetSystemMenu "GetSystemMenu" User32.dll Handle hWnd Boolean bRevert Returns Handle
87278>>>>>>>>>
87278>>>>>>>>>    External_Function GetRemoveMenu "RemoveMenu" user32.dll Handle hWnd UInteger uPosition UInteger uFlags Returns Handle
87279>>>>>>>>>
87279>>>>>>>>>// Do not call directly, use the wrapper function instead
87279>>>>>>>>>External_Function WNetGetUserW "WNetGetUserW" MPR.DLL ;    Pointer lpName ;    Pointer lpUser_Name ;    Pointer lpLength ;    Returns DWord
87280>>>>>>>>>
87280>>>>>>>>>    // Wrapper Function WNetGetUser
87280>>>>>>>>>    Function WNetGetUser Global ;        Pointer lpName ;        Pointer lpUser_Name ;        Pointer lpLength ;        Returns DWord
87282>>>>>>>>>
87282>>>>>>>>>        DWord   dwResult
87282>>>>>>>>>        UWide   uwName uwUserName
87282>>>>>>>>>        UWide   uwName uwUserName
87282>>>>>>>>>
87282>>>>>>>>>        Send StringToWide lpName (&uwName)
87283>>>>>>>>>
87283>>>>>>>>>        Send WideSetBuffer lpUser_Name lpLength (&uwUserName)
87284>>>>>>>>>
87284>>>>>>>>>        Move (WNetGetUserW (uwName.lpUText, uwUserName.lpUText, lpLength)) to dwResult
87285>>>>>>>>>
87285>>>>>>>>>        Send WideToString (&uwUserName) lpUser_Name
87286>>>>>>>>>
87286>>>>>>>>>        Function_Return dwResult
87287>>>>>>>>>    End_Function
87288>>>>>>>>>
87288>>>>>>>>>
87288>>>>>>>>>
87288>>>>>>>>>    External_Function GlobalMemoryStatus "GlobalMemoryStatus" Kernel32.Dll Pointer lpsMemoryStatus Returns Integer
87289>>>>>>>>>
87289>>>>>>>>>    External_Function GlobalMemoryStatusEx "GlobalMemoryStatusEx" Kernel32.Dll Pointer lpMemoryStatus Returns Integer
87290>>>>>>>>>
87290>>>>>>>>>External_Function AboutShellExecuteEx "ShellExecuteEx" Shell32.dll Pointer pExecInfo Returns Integer
87291>>>>>>>>>
87291>>>>>>>>>External_Function AboutWaitForSingleObject "WaitForSingleObject" Kernel32.dll ;  Handle hHandle ;  DWord dwMilliseconds ;  Returns DWord
87292>>>>>>>>>
87292>>>>>>>>>External_Function AboutCloseHandle "CloseHandle" Kernel32.dll Handle hHandle Returns Integer
87293>>>>>>>>>
87293>>>>>>>>>// *** Global/Desktop Function Declarations: ***
87293>>>>>>>>>
87293>>>>>>>>>Function ComputerName Desktop Returns String
87295>>>>>>>>>    String sName
87295>>>>>>>>>    Get_Environment "COMPUTERNAME" to sName
87296>>>>>>>>>>
87296>>>>>>>>>    Function_Return sName
87297>>>>>>>>>End_Function
87298>>>>>>>>>
87298>>>>>>>>>Function Network_User_Name Desktop Returns String
87300>>>>>>>>>    WString wName
87300>>>>>>>>>    Integer iRetval iLength
87300>>>>>>>>>
87300>>>>>>>>>    Move 0 to iLength
87301>>>>>>>>>    Move (WNetGetUserW (0, 0, AddressOf (iLength))) to iRetval
87302>>>>>>>>>    Move (ZeroString(iLength)) to wName
87303>>>>>>>>>    Move (WNetGetUserW (0, AddressOf (wName), AddressOf (iLength))) to iRetval
87304>>>>>>>>>
87304>>>>>>>>>    If (iRetval = NO_ERROR) Begin
87306>>>>>>>>>        Function_Return (CString (wName))
87307>>>>>>>>>    End
87307>>>>>>>>>>
87307>>>>>>>>>
87307>>>>>>>>>    Function_Return "User Unknown"
87308>>>>>>>>>End_Function
87309>>>>>>>>>
87309>>>>>>>>>Function SQLClientVersion Desktop String sDriverID Integer iClient Returns String
87311>>>>>>>>>    String sClient sDriver sClientDriver
87311>>>>>>>>>    Integer iNumberOfDrivers iDriver iCount iClientVersion
87311>>>>>>>>>    Handle hoMsqlDrv
87311>>>>>>>>>
87311>>>>>>>>>    Move 0 to iDriver
87312>>>>>>>>>    Move "" to sClient
87313>>>>>>>>>    Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
87316>>>>>>>>>    For iCount from 1 to iNumberOfDrivers
87322>>>>>>>>>>
87322>>>>>>>>>        Get_Attribute DF_DRIVER_NAME of iCount to sDriver
87325>>>>>>>>>        If (Uppercase(sDriver) = Uppercase(sDriverID)) Begin
87327>>>>>>>>>            Move iCount to iDriver
87328>>>>>>>>>            Move iNumberOfDrivers to iCount // We're done.
87329>>>>>>>>>        End
87329>>>>>>>>>>
87329>>>>>>>>>    Loop
87330>>>>>>>>>>
87330>>>>>>>>>
87330>>>>>>>>>    // This info is (at current) only available for the MS SQL driver:
87330>>>>>>>>>    If (sDriverID = MSSQLDRV_ID) Begin
87332>>>>>>>>>        Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
87335>>>>>>>>>        Get Create (RefClass(cMSSQLHandler)) to hoMsqlDrv
87336>>>>>>>>>        Get SqlServerClientVersionName of hoMsqlDrv iClientVersion to sClientDriver
87337>>>>>>>>>        Send Destroy of hoMsqlDrv
87338>>>>>>>>>        Move (SFormat("MSSQLDRV Client Version: %1", sClientDriver)) to sClient
87339>>>>>>>>>    End
87339>>>>>>>>>>
87339>>>>>>>>>
87339>>>>>>>>>    Function_Return sClient
87340>>>>>>>>>End_Function
87341>>>>>>>>>
87341>>>>>>>>>// *** Class Declarations: ***
87341>>>>>>>>>//
87341>>>>>>>>>Class cBitmapContainerDFLink is a BitmapContainer
87342>>>>>>>>>    Procedure Mouse_Click Integer iWindowNumber Integer iPosition
87344>>>>>>>>>        Send Mouse_Up iWindowNumber iPosition
87345>>>>>>>>>    End_Procedure
87346>>>>>>>>>    Procedure Mouse_Up Integer iWindowNumber Integer iPosition
87348>>>>>>>>>        Forward Send Mouse_Up iWindowNumber iPosition
87350>>>>>>>>>        Send Show_HomePage "http://www.dataaccess.com/"
87351>>>>>>>>>    End_Procedure
87352>>>>>>>>>End_Class
87353>>>>>>>>>
87353>>>>>>>>>Class cCopyEditorContentButton is a Button
87354>>>>>>>>>    Procedure Construct_Object
87356>>>>>>>>>        Forward Send Construct_Object
87358>>>>>>>>>        Property Handle phoEditorHandle
87359>>>>>>>>>        Set psToolTip to C_$DescCopy
87360>>>>>>>>>    End_Procedure
87361>>>>>>>>>
87361>>>>>>>>>    Procedure CopyToWindowsClipboard
87363>>>>>>>>>        Handle hoEditor
87363>>>>>>>>>        Boolean bCanCopy
87363>>>>>>>>>        Address aEditorAddress
87363>>>>>>>>>
87363>>>>>>>>>        Get phoEditorHandle to hoEditor
87364>>>>>>>>>        Send Select_All of hoEditor
87365>>>>>>>>>        Get CanCopy of hoEditor to bCanCopy
87366>>>>>>>>>        If (bCanCopy = True) Begin
87368>>>>>>>>>            Get paValue of hoEditor to aEditorAddress
87369>>>>>>>>>            Send Copy   of hoEditor
87370>>>>>>>>>            // Remove the selection after text is copied to the clipboard.
87370>>>>>>>>>            Send Beginning_of_Data of hoEditor
87371>>>>>>>>>            Send Info_Box C_$CopyToClipboard_Text
87372>>>>>>>>>        End
87372>>>>>>>>>>
87372>>>>>>>>>    End_Procedure
87373>>>>>>>>>End_Class
87374>>>>>>>>>
87374>>>>>>>>>Class SysinfoDisplay is a cTextEdit
87375>>>>>>>>>    Procedure Construct_Object
87377>>>>>>>>>        Forward Send Construct_Object
87379>>>>>>>>>
87379>>>>>>>>>        Set Size to 100 245
87380>>>>>>>>>        Set Location to 6 6
87381>>>>>>>>>        Set Border_Style to Border_None
87382>>>>>>>>>        Set Read_Only_State to True
87383>>>>>>>>>        Set pbWrap to True
87384>>>>>>>>>        Set peAnchors to anAll
87385>>>>>>>>>    End_Procedure
87386>>>>>>>>>
87386>>>>>>>>>    // Augmented class message to adjust certain text strings that are wrong...
87386>>>>>>>>>
87386>>>>>>>>>    Procedure AppendTextLn String sText
87388>>>>>>>>>        String sWorkspaceWSFile
87388>>>>>>>>>
87388>>>>>>>>>        // Only works for English:
87388>>>>>>>>>        If (ghoApplication > 0) Begin
87390>>>>>>>>>            If (sText contains "Workspace Name") Begin
87392>>>>>>>>>                Move "Workspace Config Filename:" to sText
87393>>>>>>>>>                Get psWorkspaceWSFile of (phoWorkspace(ghoApplication)) to sWorkspaceWSFile
87394>>>>>>>>>                Move (sText * sWorkspaceWSFile) to sText
87395>>>>>>>>>            End
87395>>>>>>>>>>
87395>>>>>>>>>        End
87395>>>>>>>>>>
87395>>>>>>>>>        Send AppendText sText
87396>>>>>>>>>        Send AppendText (character(10))
87397>>>>>>>>>    End_Procedure
87398>>>>>>>>>
87398>>>>>>>>>    //    This method will show the name Of the current directory in the system
87398>>>>>>>>>    //    information box
87398>>>>>>>>>    Procedure Show_Current_Directory
87400>>>>>>>>>        String sDir
87400>>>>>>>>>
87400>>>>>>>>>        Get_Current_Directory To sDir
87401>>>>>>>>>
87401>>>>>>>>>        Send AppendTextLn (SFormat (C_$CurrentDirectory, sDir))
87402>>>>>>>>>    End_Procedure
87403>>>>>>>>>
87403>>>>>>>>>    Procedure Show_Windows_Directory
87405>>>>>>>>>        String sWindir
87405>>>>>>>>>
87405>>>>>>>>>        Get_Windows_Directory To sWindir
87406>>>>>>>>>
87406>>>>>>>>>        Send AppendTextLn (SFormat (C_$WindowsDirectory, sWindir))
87407>>>>>>>>>    End_Procedure
87408>>>>>>>>>
87408>>>>>>>>>    Procedure Show_Current_User
87410>>>>>>>>>        Send AppendTextLn (SFormat (C_$Computer_Name, ComputerName (Self)))
87411>>>>>>>>>        Send AppendTextLn (SFormat (C_$NetworkUserName, Network_User_Name (Self)))
87412>>>>>>>>>    End_Procedure
87413>>>>>>>>>
87413>>>>>>>>>    Procedure Show_Number_Format
87415>>>>>>>>>        Integer iFormat
87415>>>>>>>>>        String sFormatText
87415>>>>>>>>>
87415>>>>>>>>>        Get_Attribute DF_THOUSANDS_SEPARATOR to iFormat
87418>>>>>>>>>        Move (Character (iFormat)) To sFormatText
87419>>>>>>>>>        Send AppendTextLn (SFormat (C_$ThousandsSeparator, sFormatText, iFormat))
87420>>>>>>>>>
87420>>>>>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iFormat
87423>>>>>>>>>        Move (Character (iFormat)) to sFormatText
87424>>>>>>>>>        Send AppendTextLn (SFormat (C_$DecimalSeparator, sFormatText))
87425>>>>>>>>>    End_Procedure
87426>>>>>>>>>
87426>>>>>>>>>    Procedure Show_Filelist_Name
87428>>>>>>>>>        String sFilename
87428>>>>>>>>>
87428>>>>>>>>>        Get_Attribute DF_FILELIST_NAME to sFilename
87431>>>>>>>>>
87431>>>>>>>>>        Send AppendTextLn (SFormat (C_$CurrentFilelist, sFilename))
87432>>>>>>>>>    End_Procedure
87433>>>>>>>>>
87433>>>>>>>>>    Procedure Show_Lock_Delay
87435>>>>>>>>>        Integer iLockdelay
87435>>>>>>>>>
87435>>>>>>>>>        Get_Attribute DF_LOCK_DELAY to iLockdelay
87438>>>>>>>>>
87438>>>>>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingDelay, iLockDelay))
87439>>>>>>>>>    End_Procedure
87440>>>>>>>>>
87440>>>>>>>>>    Procedure Show_Lock_Timeout
87442>>>>>>>>>        Integer iLockTimeout
87442>>>>>>>>>
87442>>>>>>>>>        Get_Attribute DF_LOCK_TIMEOUT to iLockTimeout
87445>>>>>>>>>
87445>>>>>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingTimeout, iLockTimeOut))
87446>>>>>>>>>    End_Procedure
87447>>>>>>>>>
87447>>>>>>>>>    Procedure Show_Screen_Size
87449>>>>>>>>>        Integer iYscreensize iXscreensize
87449>>>>>>>>>
87449>>>>>>>>>        Move (GetSystemMetrics (SM_CXSCREEN)) To iXscreensize
87450>>>>>>>>>        Move (GetSystemMetrics (SM_CYSCREEN)) To iYscreensize
87451>>>>>>>>>
87451>>>>>>>>>        Send AppendTextLn (SFormat (C_$VideoResolution, iXscreensize, iYscreensize))
87452>>>>>>>>>    End_Procedure
87453>>>>>>>>>
87453>>>>>>>>>    Procedure Show_Page_Size
87455>>>>>>>>>        Send AppendTextLn (SFormat (C_$PageEndFormFeed, Pageend, Pagefeed))
87456>>>>>>>>>    End_procedure
87457>>>>>>>>>
87457>>>>>>>>>    Procedure Show_Date
87459>>>>>>>>>        Date dToday
87459>>>>>>>>>
87459>>>>>>>>>        Move (CurrentDateTime()) to dToday
87460>>>>>>>>>
87460>>>>>>>>>        Send AppendTextLn (SFormat (C_$CurrentSystemDate, String (dToday)))
87461>>>>>>>>>    End_procedure
87462>>>>>>>>>
87462>>>>>>>>>    Procedure Show_Date_Format
87464>>>>>>>>>        Integer iDateFormat
87464>>>>>>>>>        String sDateFormat
87464>>>>>>>>>
87464>>>>>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
87467>>>>>>>>>        Case Begin
87467>>>>>>>>>            Case (iDateFormat = DF_DATE_USA)
87469>>>>>>>>>                Move C_$USA To sDateFormat
87470>>>>>>>>>                Case Break
87471>>>>>>>>>            Case (iDateFormat = DF_DATE_EUROPEAN)
87474>>>>>>>>>                Move C_$European To sDateFormat
87475>>>>>>>>>                Case Break
87476>>>>>>>>>            Case (iDateFormat = DF_DATE_MILITARY)
87479>>>>>>>>>                Move C_$Military To sDateFormat
87480>>>>>>>>>                Case Break
87481>>>>>>>>>            Case Else
87481>>>>>>>>>                Move C_$UnknownDateType To sDateFormat
87482>>>>>>>>>                Case Break
87483>>>>>>>>>        Case End
87483>>>>>>>>>
87483>>>>>>>>>        Send AppendTextLn (SFormat (C_$DateFormat, sDateformat))
87484>>>>>>>>>    End_Procedure
87485>>>>>>>>>
87485>>>>>>>>>    // 2013-08-14 NGS
87485>>>>>>>>>    // Unformatted numeric values shown doesn't look good. These looks much better.
87485>>>>>>>>>    Procedure Show_Systemresources
87487>>>>>>>>>        tWinMemoryStatusEx MemoryStatusInfo
87487>>>>>>>>>        tWinMemoryStatusEx MemoryStatusInfo
87487>>>>>>>>>        Integer iRetval
87487>>>>>>>>>        Number nValue
87487>>>>>>>>>        String sValue
87487>>>>>>>>>
87487>>>>>>>>>        Move (SizeOfType (tWinMemoryStatusEx)) to MemoryStatusInfo.dwLength
87488>>>>>>>>>        Move (GlobalMemoryStatusEx (AddressOf (MemoryStatusInfo))) to iRetval
87489>>>>>>>>>        If (iRetval = 0) Begin
87491>>>>>>>>>            Move (ShowLastError ()) to iRetval
87492>>>>>>>>>            Procedure_Return
87493>>>>>>>>>        End
87493>>>>>>>>>>
87493>>>>>>>>>
87493>>>>>>>>>        Send AppendTextLn ""
87494>>>>>>>>>        Move MemoryStatusInfo.ullTotalPhys to nValue
87495>>>>>>>>>
87495>>>>>>>>>        // Show memory in Gigabytes:
87495>>>>>>>>>        Move (nValue/1024/1024/1024) to nValue
87496>>>>>>>>>        Move (Round(nValue)) to nValue
87497>>>>>>>>>        Get FormatNumber nValue 2 to sValue
87498>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailableMemory, (sValue * "GB")))
87499>>>>>>>>>        Send AppendTextLn (SFormat (C_$MemoryUtilization, String(MemoryStatusInfo.dwMemoryLoad) * "%"))
87500>>>>>>>>>
87500>>>>>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, Real (MemoryStatusInfo.ullAvailPhys) / Real (MemoryStatusInfo.ullTotalPhys) * 100.0))
87500>>>>>>>>>        Move (Real(MemoryStatusInfo.ullAvailPhys) / Real(MemoryStatusInfo.ullTotalPhys) * 100.0) to nValue
87501>>>>>>>>>        Move (Round(nValue)) to nValue
87502>>>>>>>>>        Get FormatNumber nValue 0 to sValue
87503>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, (sValue * "%")))
87504>>>>>>>>>
87504>>>>>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, Real (MemoryStatusInfo.ullAvailPageFile) / Real (MemoryStatusInfo.ullTotalPageFile) * 100.0))
87504>>>>>>>>>        Move (Real(MemoryStatusInfo.ullAvailPageFile) / Real(MemoryStatusInfo.ullTotalPageFile) * 100.0) to nValue
87505>>>>>>>>>        Move (Round(nValue)) to nValue
87506>>>>>>>>>        Get FormatNumber nValue 0 to sValue
87507>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, (sValue * "%")))
87508>>>>>>>>>
87508>>>>>>>>>//        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, Real (MemoryStatusInfo.ullAvailVirtual) / Real (MemoryStatusInfo.ullTotalVirtual) * 100.0))
87508>>>>>>>>>        Move (Real(MemoryStatusInfo.ullAvailVirtual) / Real(MemoryStatusInfo.ullTotalVirtual) * 100.0) to nValue
87509>>>>>>>>>        Move (Round(nValue)) to nValue
87510>>>>>>>>>        Get FormatNumber nValue 0 to sValue
87511>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, (sValue * "%")))
87512>>>>>>>>>
87512>>>>>>>>>        // Add an empty row after the memory information:
87512>>>>>>>>>        Send AppendTextLn ""
87513>>>>>>>>>    End_Procedure
87514>>>>>>>>>
87514>>>>>>>>>    Procedure Show_Registration
87516>>>>>>>>>        String sRegName
87516>>>>>>>>>        Integer iSN iUsersMax iUserCount
87516>>>>>>>>>
87516>>>>>>>>>        Registration sRegName iSN
87517>>>>>>>>>>
87517>>>>>>>>>        Get_Licensed_Max_Users to iUsersMax
87518>>>>>>>>>        Get_Current_User_Count to iUserCount
87519>>>>>>>>>
87519>>>>>>>>>        Send AppendTextLn (SFormat (C_$Serial, iSN))
87520>>>>>>>>>        Send AppendTextLn (SFormat (C_$RegName, sRegName))
87521>>>>>>>>>        Send AppendTextLn (SFormat (C_$Current_User_Count, iUserCount))
87522>>>>>>>>>        Send AppendTextLn (SFormat (C_$Max_Licensed_User_Count, iUsersMax))
87523>>>>>>>>>    End_Procedure
87524>>>>>>>>>
87524>>>>>>>>>    //****************************************************************************
87524>>>>>>>>>    // If workspaces are used, we will send the message EnumerateWorkspaceData
87524>>>>>>>>>    // To the workspace object passing the an object and message To send back
87524>>>>>>>>>    // To this object. It is expected that the workspace object will send this
87524>>>>>>>>>    // message for every line Of information it wants displayed (passing the
87524>>>>>>>>>    // information To be displayed
87524>>>>>>>>>    //****************************************************************************
87524>>>>>>>>>    Register_Procedure EnumerateWorkspaceData Integer hObjId Integer hmMessId
87524>>>>>>>>>
87524>>>>>>>>>    Procedure Show_ServicePack
87526>>>>>>>>>        String sKey sVersion sDataFlex
87526>>>>>>>>>        Handle hoRegistry
87526>>>>>>>>>        Boolean bExists bOpened
87526>>>>>>>>>
87526>>>>>>>>>        Move "DataFlex"        to sDataFlex
87527>>>>>>>>>
87527>>>>>>>>>        Get Create (RefClass(cRegistry)) to hoRegistry
87528>>>>>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
87529>>>>>>>>>        Set pfAccessRights of hoRegistry to KEY_READ
87530>>>>>>>>>        Get KeyExists of hoRegistry "SOFTWARE\Wow6432Node" to bExists
87531>>>>>>>>>
87531>>>>>>>>>        If (bExists) Begin
87533>>>>>>>>>            Move ("SOFTWARE\Wow6432Node\Data Access Worldwide\" + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
87534>>>>>>>>>        End
87534>>>>>>>>>>
87534>>>>>>>>>        Else Begin
87535>>>>>>>>>            Move ("SOFTWARE\Data Access Worldwide\"             + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
87536>>>>>>>>>        End
87536>>>>>>>>>>
87536>>>>>>>>>        Get KeyExists of hoRegistry sKey to bExists
87537>>>>>>>>>        If (bExists) Begin
87539>>>>>>>>>            Get OpenKey of hoRegistry sKey to bOpened
87540>>>>>>>>>            If (bOpened) Begin
87542>>>>>>>>>                Get ValueExists of hoRegistry "CurrentVersionDescription" to bExists
87543>>>>>>>>>                If (bExists) Begin
87545>>>>>>>>>                    Get ReadString of hoRegistry "CurrentVersionDescription" to sVersion
87546>>>>>>>>>                End
87546>>>>>>>>>>
87546>>>>>>>>>                Send CloseKey of hoRegistry
87547>>>>>>>>>            End
87547>>>>>>>>>>
87547>>>>>>>>>        End
87547>>>>>>>>>>
87547>>>>>>>>>        Send Destroy of hoRegistry
87548>>>>>>>>>
87548>>>>>>>>>        If (sVersion <> "") Begin
87550>>>>>>>>>           Send AppendTextLn sVersion
87551>>>>>>>>>           Send AppendTextLn ""
87552>>>>>>>>>        End
87552>>>>>>>>>>
87552>>>>>>>>>    End_Procedure
87553>>>>>>>>>
87553>>>>>>>>>    Procedure Show_WorkspaceInformation
87555>>>>>>>>>        Integer hoWorkspace
87555>>>>>>>>>
87555>>>>>>>>>        If (ghoApplication <> 0) Begin
87557>>>>>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
87558>>>>>>>>>            If (hoWorkspace <> 0) Begin
87560>>>>>>>>>                Send EnumerateWorkspaceData of hoWorkspace Self msg_AppendTextLn
87561>>>>>>>>>            End
87561>>>>>>>>>>
87561>>>>>>>>>        End
87561>>>>>>>>>>
87561>>>>>>>>>    End_Procedure
87562>>>>>>>>>
87562>>>>>>>>>    //****************************************************************************
87562>>>>>>>>>    // If connection ids are used, we will send the message EnumerateConnections
87562>>>>>>>>>    // to the connection manager object passing the an object and message to send
87562>>>>>>>>>    // back to this object. It is expected that the connection manager object will
87562>>>>>>>>>    // send this message for every line Of information it wants displayed (passing
87562>>>>>>>>>    // the information To be displayed
87562>>>>>>>>>    //****************************************************************************
87562>>>>>>>>>    Register_Procedure EnumerateConnections Integer hObjId Integer hmMessId
87562>>>>>>>>>
87562>>>>>>>>>    Procedure Show_ConnectionIdInformation
87564>>>>>>>>>        If (ghoConnection > 0) Begin
87566>>>>>>>>>            Send EnumerateConnections of ghoConnection Self (RefProc(AppendTextLn))
87567>>>>>>>>>            Send AppendTextLn ""
87568>>>>>>>>>        End
87568>>>>>>>>>>
87568>>>>>>>>>    End_Procedure
87569>>>>>>>>>
87569>>>>>>>>>    Function VersionStr Integer iVer Integer iRev Integer iBld Returns String
87571>>>>>>>>>        Function_Return (String (iVer) - "." - String (iRev) - "." - String (iBld))
87572>>>>>>>>>    End_Function
87573>>>>>>>>>
87573>>>>>>>>>    Procedure Show_Versions
87575>>>>>>>>>        Integer iVersion iRevision iBuild
87575>>>>>>>>>
87575>>>>>>>>>        Version_information iVersion iRevision iBuild
87577>>>>>>>>>
87577>>>>>>>>>        Send AppendTextLn (SFormat (C_$RuntimeVersion, VersionStr(self,iVersion,iRevision,iBuild) ))
87578>>>>>>>>>        Send AppendTextLn (SFormat (C_$PackageVersion, VersionStr(self,PKG_VERSION, PKG_REVISION, PKG_BUILD) ))
87579>>>>>>>>>        Send AppendTextLn (SFormat (C_$FMACVersion, VersionStr(self,FMAC_VERSION, FMAC_REVISION, FMAC_BUILD) ))
87580>>>>>>>>>        Send AppendTextLn "This is a 32-bit exe file"
87581>>>>>>>>>    End_Procedure
87582>>>>>>>>>
87582>>>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
87584>>>>>>>>>        Boolean bOK
87584>>>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
87585>>>>>>>>>        Function_Return bOK
87586>>>>>>>>>    End_Function
87587>>>>>>>>>
87587>>>>>>>>>    Function IsMertechDriver String sDriverID Returns Boolean
87589>>>>>>>>>        Boolean bOK
87589>>>>>>>>>        Move (sDriverID = SQLFLEX or sDriverID = ORAFLEX or sDriverID = MDSPgSQL or sDriverID = MySQLFlex) to bOK
87590>>>>>>>>>        Function_Return bOK
87591>>>>>>>>>    End_Function
87592>>>>>>>>>
87592>>>>>>>>>    //***
87592>>>>>>>>>    //*** BW
87592>>>>>>>>>    //*** Procedure: Show_Drivers
87592>>>>>>>>>    //*** Purpose  : Show loaded database drivers
87592>>>>>>>>>    //***
87592>>>>>>>>>
87592>>>>>>>>>    Procedure Show_Drivers
87594>>>>>>>>>        String sDriverID sVersion sClient sValue
87594>>>>>>>>>        Integer iNumberOfDrivers iDriver iClient iUsersMax iSerialNo iNumServers iCount
87594>>>>>>>>>        Handle hoCLIHandler hoBtrvHandler
87594>>>>>>>>>        Boolean bStudioLicense bIsDAWDriver bIsMertechDriver
87594>>>>>>>>>
87594>>>>>>>>>        Move False to bStudioLicense
87595>>>>>>>>>
87595>>>>>>>>>        Get Create (RefClass(cCLIHandler))      to hoCLIHandler
87596>>>>>>>>>        Get Create (RefClass(cDFBtrDrvHandler)) to hoBtrvHandler
87597>>>>>>>>>
87597>>>>>>>>>        // For testing purposes:
87597>>>>>>>>>//        Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
87597>>>>>>>>>//        Load_Driver MSSQLDRV_ID
87597>>>>>>>>>//        Load_Driver ODBC_DRV_ID
87597>>>>>>>>>//        Load_Driver DB2_DRV_ID
87597>>>>>>>>>//        Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
87597>>>>>>>>>//
87597>>>>>>>>>//        #IFDEF DUF_Use_Mertech_Drivers
87597>>>>>>>>>//            Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
87597>>>>>>>>>//            Load_Driver SQLFLEX
87597>>>>>>>>>//            Load_Driver MDSPgSQL
87597>>>>>>>>>//            Load_Driver MDSMySQL
87597>>>>>>>>>//            Load_Driver ORAFLEX
87597>>>>>>>>>//            Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
87597>>>>>>>>>//        #ENDIF
87597>>>>>>>>>        Move False to Err
87598>>>>>>>>>
87598>>>>>>>>>        // Loop through all loaded drivers.
87598>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
87601>>>>>>>>>        If (iNumberOfDrivers > 1) Begin
87603>>>>>>>>>            Send AppendTextLn ""
87604>>>>>>>>>        End
87604>>>>>>>>>>
87604>>>>>>>>>        For iDriver from 1 to iNumberOfDrivers
87610>>>>>>>>>>
87610>>>>>>>>>            // For some weird reason it can happen that - when using Mertech drivers - that the driver index
87610>>>>>>>>>            // was increased in the CLI array, but it has no value. In that case a "Bad parameter..." error
87610>>>>>>>>>            // would be thrown, so we safeguard from that here.
87610>>>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
87611>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iDriver to sDriverID
87614>>>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
87615>>>>>>>>>            Get IsDAWSQLDriver  sDriverID to bIsDAWDriver
87616>>>>>>>>>            Get IsMertechDriver sDriverID to bIsMertechDriver
87617>>>>>>>>>
87617>>>>>>>>>            If (sDriverID = DFBTRDRV_ID or bIsDAWDriver = True or bIsMertechDriver = True) Begin
87619>>>>>>>>>
87619>>>>>>>>>                // Pervasive/Btrieve database
87619>>>>>>>>>                If (sDriverID = DFBTRDRV_ID) Begin
87621>>>>>>>>>                    Get CKRevision of hoBtrvHandler to sVersion
87622>>>>>>>>>                    Get PSQLLocalEngineVersionInfo of hoBtrvHandler 0 to sClient
87623>>>>>>>>>                    If (sClient <> "0.0.0") Begin
87625>>>>>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Local_Engine_Version, sClient))
87626>>>>>>>>>                    End
87626>>>>>>>>>>
87626>>>>>>>>>                    Get PSQLServerEngineVersionInfo of hoBtrvHandler 0 to sClient
87627>>>>>>>>>                    If (sClient <> "0.0.0") Begin
87629>>>>>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Server_Engine_Version, sClient))
87630>>>>>>>>>                    End
87630>>>>>>>>>>
87630>>>>>>>>>                End
87630>>>>>>>>>>
87630>>>>>>>>>
87630>>>>>>>>>                Else Begin
87631>>>>>>>>>                    Set psDriverID of hoCLIHandler to sDriverID
87632>>>>>>>>>                    Move 0 to iNumServers
87633>>>>>>>>>                    If (sDriverID <> DATAFLEX_ID) Begin
87635>>>>>>>>>                        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iNumServers
87638>>>>>>>>>                    End
87638>>>>>>>>>>
87638>>>>>>>>>
87638>>>>>>>>>                    If (bIsDAWDriver = True) Begin
87640>>>>>>>>>                        If (sDriverID = MSSQLDRV_ID) Begin
87642>>>>>>>>>                            Get SQLClientVersion sDriverID iClient to sClient
87643>>>>>>>>>                        End
87643>>>>>>>>>>
87643>>>>>>>>>                        Get CKRevision of hoCLIHandler to sVersion
87644>>>>>>>>>                    End
87644>>>>>>>>>>
87644>>>>>>>>>
87644>>>>>>>>>                    If (bIsMertechDriver = True) Begin
87646>>>>>>>>>                        GET_DRIVER_REVISION to sVersion
87683>>>>>>>>>>
87683>>>>>>>>>                    End
87683>>>>>>>>>>
87683>>>>>>>>>
87683>>>>>>>>>                    // If the serialnumber is = 0, it means that the
87683>>>>>>>>>                    // Studio licens is in use and there is no
87683>>>>>>>>>                    // number of max users defined because the driver is
87683>>>>>>>>>                    // relying on the info from the VDF license.
87683>>>>>>>>>                    If (bStudioLicense = False) Begin
87685>>>>>>>>>                        Get SerialNumber of hoCLIHandler to iSerialNo
87686>>>>>>>>>                        Move (iSerialNo = 0) to bStudioLicense
87687>>>>>>>>>                    End
87687>>>>>>>>>>
87687>>>>>>>>>                End
87687>>>>>>>>>>
87687>>>>>>>>>                Send AppendTextLn (SFormat (C_$DatabaseDriver, (sDriverID * "-" * (C_$Version + ": " + sVersion))))
87688>>>>>>>>>                If (sClient <> "" and sDriverID = MSSQLDRV_ID) Begin
87690>>>>>>>>>                    Send AppendTextLn (C_$SQL_Client_Text * sClient)
87691>>>>>>>>>                End
87691>>>>>>>>>>
87691>>>>>>>>>                If (iNumServers <> 0) Begin
87693>>>>>>>>>                    For iCount from 1 to iNumServers
87699>>>>>>>>>>
87699>>>>>>>>>                        Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
87702>>>>>>>>>                        If (not(sValue contains ";PWD=")) Begin
87704>>>>>>>>>                            Send AppendTextLn ("    " + C_$SQLServerText * sValue)
87705>>>>>>>>>                        End
87705>>>>>>>>>>
87705>>>>>>>>>                    Loop
87706>>>>>>>>>>
87706>>>>>>>>>                End
87706>>>>>>>>>>
87706>>>>>>>>>            End
87706>>>>>>>>>>
87706>>>>>>>>>        Loop
87707>>>>>>>>>>
87707>>>>>>>>>
87707>>>>>>>>>        Send AppendTextLn ""
87708>>>>>>>>>        If (bStudioLicense = False) Begin
87710>>>>>>>>>            Get MaxUsers of hoCLIHandler to iUsersMax
87711>>>>>>>>>            Send AppendTextLn (SFormat (C_$Max_DbDriver_Licensed_User_Count, iUsersMax))
87712>>>>>>>>>        End
87712>>>>>>>>>>
87712>>>>>>>>>        Else Begin
87713>>>>>>>>>            Send AppendTextLn C_$DF_Studio_License_Text
87714>>>>>>>>>        End
87714>>>>>>>>>>
87714>>>>>>>>>        Send Destroy of hoCLIHandler
87715>>>>>>>>>        Send Destroy of hoBtrvHandler
87716>>>>>>>>>    End_Procedure
87717>>>>>>>>>
87717>>>>>>>>>    Procedure Show_HelpFile
87719>>>>>>>>>        String sHelpFile
87719>>>>>>>>>        Integer eHelpType
87719>>>>>>>>>
87719>>>>>>>>>        If (ghoApplication <> 0) Begin
87721>>>>>>>>>            Get peHelpType Of ghoApplication To eHelpType
87722>>>>>>>>>            If (eHelpType = htHtmlHelp and ghoHtmlHelp) Begin
87724>>>>>>>>>                Get GetHelpFile Of ghoHtmlHelp To sHelpFile
87725>>>>>>>>>            End
87725>>>>>>>>>>
87725>>>>>>>>>            Else If (eHelpType = htWinHelp and Help_object_id) Begin
87728>>>>>>>>>                Get Help_filename Of Help_object_id To sHelpFile
87729>>>>>>>>>            End
87729>>>>>>>>>>
87729>>>>>>>>>            Else Begin
87730>>>>>>>>>                Move C_$ThereIsNoHelpfileDefined To sHelpFile
87731>>>>>>>>>            End
87731>>>>>>>>>>
87731>>>>>>>>>
87731>>>>>>>>>            Send AppendTextLn (SFormat (C_$HelpFile, sHelpFile))
87732>>>>>>>>>        End
87732>>>>>>>>>>
87732>>>>>>>>>    End_Procedure
87733>>>>>>>>>
87733>>>>>>>>>    Procedure Show_EnterAsTab
87735>>>>>>>>>        Boolean bEnterKeyAsTabKey
87735>>>>>>>>>        String sText
87735>>>>>>>>>
87735>>>>>>>>>        If (ghoApplication <> 0) Begin
87737>>>>>>>>>            Get pbEnterKeyAsTabKey Of ghoApplication To bEnterKeyAsTabKey
87738>>>>>>>>>            If (bEnterKeyAsTabKey) Begin
87740>>>>>>>>>                Move "True" To sText
87741>>>>>>>>>            End
87741>>>>>>>>>>
87741>>>>>>>>>            Else Begin
87742>>>>>>>>>                Move "False" To sText
87743>>>>>>>>>            End
87743>>>>>>>>>>
87743>>>>>>>>>            Send AppendTextLn (SFormat (C_$EnterKeyNavForward, sText))
87744>>>>>>>>>        End
87744>>>>>>>>>>
87744>>>>>>>>>    End_Procedure
87745>>>>>>>>>
87745>>>>>>>>>    //    During activation we will remove the old information and add the newly
87745>>>>>>>>>    //    found systeminformation
87745>>>>>>>>>    Procedure Add_Focus Integer hoRoot
87747>>>>>>>>>        Forward Send Add_Focus hoRoot
87749>>>>>>>>>
87749>>>>>>>>>        Send Delete_Data
87750>>>>>>>>>
87750>>>>>>>>>        Set Changed_State To False
87751>>>>>>>>>        Set Read_Only_State To True
87752>>>>>>>>>
87752>>>>>>>>>        Send Show_Registration
87753>>>>>>>>>        Send Show_Drivers
87754>>>>>>>>>        Send Show_ServicePack
87755>>>>>>>>>        Send Show_Versions
87756>>>>>>>>>        Send AppendTextLn ""
87757>>>>>>>>>
87757>>>>>>>>>        If (ghoApplication <> 0) Begin
87759>>>>>>>>>            Send Show_WorkSpaceInformation
87760>>>>>>>>>            Send Show_HelpFile
87761>>>>>>>>>            Send AppendTextLn ""
87762>>>>>>>>>        End
87762>>>>>>>>>>
87762>>>>>>>>>        Else Begin
87763>>>>>>>>>            Send AppendTextLn ""
87764>>>>>>>>>        End
87764>>>>>>>>>>
87764>>>>>>>>>
87764>>>>>>>>>        If (ghoConnection <> 0) Begin
87766>>>>>>>>>            Send Show_ConnectionIdInformation
87767>>>>>>>>>        End
87767>>>>>>>>>>
87767>>>>>>>>>
87767>>>>>>>>>        Send Show_Current_User
87768>>>>>>>>>        Send Show_Windows_Directory
87769>>>>>>>>>        Send Show_Current_Directory
87770>>>>>>>>>
87770>>>>>>>>>        // This is already shown in the workspace details,
87770>>>>>>>>>        // unless no workspace object is present:
87770>>>>>>>>>        If (ghoApplication = 0) Begin
87772>>>>>>>>>            Send Show_Filelist_Name
87773>>>>>>>>>        End
87773>>>>>>>>>>
87773>>>>>>>>>
87773>>>>>>>>>        If (ghoApplication <> 0) Begin
87775>>>>>>>>>            Send AppendTextLn ""
87776>>>>>>>>>            Send Show_EnterAsTab
87777>>>>>>>>>        End
87777>>>>>>>>>>
87777>>>>>>>>>
87777>>>>>>>>>        Send Show_Screen_Size
87778>>>>>>>>>        Send Show_Page_Size
87779>>>>>>>>>        Send Show_Number_Format
87780>>>>>>>>>        Send Show_Date_Format
87781>>>>>>>>>        Send Show_Lock_Delay
87782>>>>>>>>>        Send Show_Lock_Timeout
87783>>>>>>>>>        Send Show_Date
87784>>>>>>>>>        Send Show_Systemresources
87785>>>>>>>>>        Send Beginning_of_Data
87786>>>>>>>>>
87786>>>>>>>>>        Set Icon to 'default.ico'
87787>>>>>>>>>    End_Procedure
87788>>>>>>>>>End_Class
87789>>>>>>>>>
87789>>>>>>>>>Class SysInfoDialog is a ModalPanel
87790>>>>>>>>>    Procedure Construct_Object
87792>>>>>>>>>        Forward Send Construct_Object
87794>>>>>>>>>
87794>>>>>>>>>        Set Label to C_$SystemInformation
87795>>>>>>>>>        Set Size to 140 267
87796>>>>>>>>>        Set Locate_Mode to CENTER_ON_PARENT
87797>>>>>>>>>        Set Border_Style to Border_Thick
87798>>>>>>>>>        Set Sysmenu_Icon to False
87799>>>>>>>>>
87799>>>>>>>>>        // "+1" will make the panel to paint correctly.
87799>>>>>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)) +1)
87800>>>>>>>>>
87800>>>>>>>>>        // 2014-09-14 NGS
87800>>>>>>>>>        // Added a container object around the cTexteditor
87800>>>>>>>>>        // object to get a border around the text.
87800>>>>>>>>>        Object oSysinfoDisplayContainer is a Container3d
87802>>>>>>>>>            Set Location to 2 4
87803>>>>>>>>>            Set Size to 110 255
87804>>>>>>>>>            Set Border_Style to Border_ClientEdge
87805>>>>>>>>>            Set Color to clWhite
87806>>>>>>>>>            Set peAnchors to anAll
87807>>>>>>>>>
87807>>>>>>>>>            Object oSysinfoDisplay is a SysInfoDisplay
87809>>>>>>>>>            End_Object
87810>>>>>>>>>
87810>>>>>>>>>        End_Object
87811>>>>>>>>>
87811>>>>>>>>>        Object oCloseButton is a Button
87813>>>>>>>>>            Set Label to C_$Close
87814>>>>>>>>>            Set Location to 120 210
87815>>>>>>>>>            Set Message item 0 to msg_Close_Panel
87816>>>>>>>>>            Set Default_State To True
87817>>>>>>>>>            // In case someone likes to make the AboutDialog's Border_Style to thick,
87817>>>>>>>>>            // and changes its peAnchors, we might as well prepare this object
87817>>>>>>>>>            // for that situation.
87817>>>>>>>>>            Set peAnchors to anBottomRight
87818>>>>>>>>>        End_Object
87819>>>>>>>>>
87819>>>>>>>>>        Object oCopyButton is a cCopyEditorContentButton
87821>>>>>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
87822>>>>>>>>>            Set Size to 14 50
87823>>>>>>>>>            Set Location to 120 158
87824>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
87824>>>>>>>>>            // we might as well prepare the object for it.
87824>>>>>>>>>            Set peAnchors to anBottomRight
87825>>>>>>>>>            Set phoEditorHandle to (oSysinfoDisplay(Self))
87826>>>>>>>>>        End_Object
87827>>>>>>>>>
87827>>>>>>>>>        On_Key kCancel Send Close_Panel
87828>>>>>>>>>    End_Procedure
87829>>>>>>>>>
87829>>>>>>>>>    Procedure Page Integer iPageObject
87831>>>>>>>>>        Handle hMenu
87831>>>>>>>>>        Integer iPrevState
87831>>>>>>>>>
87831>>>>>>>>>        Forward Send Page iPageObject
87833>>>>>>>>>
87833>>>>>>>>>        // Ok, this seems to have been fixed in VDF 17.1!
87833>>>>>>>>>        //
87833>>>>>>>>>    End_Procedure
87834>>>>>>>>>
87834>>>>>>>>>End_Class
87835>>>>>>>>>
87835>>>>>>>>>Class cAboutEdit is an cRichEdit
87836>>>>>>>>>    Procedure Construct_Object
87838>>>>>>>>>        Forward Send Construct_Object
87840>>>>>>>>>
87840>>>>>>>>>        Property String psContentText
87841>>>>>>>>>
87841>>>>>>>>>        Set Size to 77 153
87842>>>>>>>>>        Set Location to 8 60
87843>>>>>>>>>        Set Read_Only_State to True
87844>>>>>>>>>        Set Skip_State to True
87845>>>>>>>>>        // Font size is calculated in "Twips", which are 1/1440 of an inch,
87845>>>>>>>>>        // or 1/20 of a printer's point.
87845>>>>>>>>>        Set piRightMargin to (0.1 * 1440)
87846>>>>>>>>>        Set Border_Style  to Border_None
87847>>>>>>>>>    End_Procedure
87848>>>>>>>>>
87848>>>>>>>>>    // Adds a line of text to the edit object
87848>>>>>>>>>    Procedure Add_Line String sText
87850>>>>>>>>>        String sContentText
87850>>>>>>>>>        Get psContentText to sContentText
87851>>>>>>>>>        Move (sContentText + String(sText)) to sContentText
87852>>>>>>>>>        Set psContentText to sContentText
87853>>>>>>>>>    End_Procedure
87854>>>>>>>>>
87854>>>>>>>>>    // Compared to Add_Line above, this adds an extra empty line after the passed value.
87854>>>>>>>>>    // Note that we use a property psContentText and add to it,
87854>>>>>>>>>    // because the object isn't paged yet when we add these
87854>>>>>>>>>    // values and the COM edit object needs to be paged
87854>>>>>>>>>    // for the text to become visible. See Also: Procedure Page below.
87854>>>>>>>>>    Procedure Add_LineLn String sText
87856>>>>>>>>>        String sContentText sCR
87856>>>>>>>>>
87856>>>>>>>>>        Move (Character(10) + String(Character(13))) to sCR
87857>>>>>>>>>        Get psContentText to sContentText
87858>>>>>>>>>        Move (sContentText + String(sText) + sCR) to sContentText
87859>>>>>>>>>        Set psContentText to sContentText
87860>>>>>>>>>    End_Procedure
87861>>>>>>>>>
87861>>>>>>>>>    Procedure OnLinkClicked Integer iPositionStart Integer iPositionEnd
87863>>>>>>>>>        String sLinkText
87863>>>>>>>>>        Get TextRange iPositionStart iPositionEnd to sLinkText
87864>>>>>>>>>        Send Show_HomePage sLinkText
87865>>>>>>>>>    End_Procedure
87866>>>>>>>>>
87866>>>>>>>>>    Procedure Page Integer iPageObject
87868>>>>>>>>>        String sContentText
87868>>>>>>>>>
87868>>>>>>>>>        Forward Send Page iPageObject
87870>>>>>>>>>        Get psContentText to sContentText
87871>>>>>>>>>        Send AppendText sContentText
87872>>>>>>>>>        send Beginning_of_Data
87873>>>>>>>>>    End_Procedure
87874>>>>>>>>>
87874>>>>>>>>>End_Class
87875>>>>>>>>>
87875>>>>>>>>>Class AboutDialog is a ModalPanel
87876>>>>>>>>>    Procedure Construct_Object
87878>>>>>>>>>
87878>>>>>>>>>        Forward Send Construct_Object
87880>>>>>>>>>
87880>>>>>>>>>        Set Label to C_$About
87881>>>>>>>>>        Set Size to 118 230
87882>>>>>>>>>        Set Locate_Mode to CENTER_ON_PARENT
87883>>>>>>>>>        Set Border_Style to Border_Thick
87884>>>>>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
87885>>>>>>>>>
87885>>>>>>>>>        Object oSysInfoDialog is a SysInfoDialog
87887>>>>>>>>>        End_Object
87888>>>>>>>>>
87888>>>>>>>>>        Object oBox is a Container3d
87890>>>>>>>>>            Set Border_Style to Border_Normal
87891>>>>>>>>>            Set Size to 90 220
87892>>>>>>>>>            Set Location to 4 5
87893>>>>>>>>>            Set Color to clWhite
87894>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
87894>>>>>>>>>            // we might as well prepare the object for it.
87894>>>>>>>>>            Set peAnchors to anAll
87895>>>>>>>>>
87895>>>>>>>>>            Object oAboutGraphic is a BitmapContainer
87897>>>>>>>>>                Set Border_Style To Border_None
87898>>>>>>>>>                Set Bitmap_Style to Bitmap_Center
87899>>>>>>>>>                Set Color to clWhite
87900>>>>>>>>>                Set Size to 45 50
87901>>>>>>>>>                Set Location to 0 3
87902>>>>>>>>>            End_Object
87903>>>>>>>>>
87903>>>>>>>>>            Object oPoweredByDFGraphic is a cBitmapContainerDFLink
87905>>>>>>>>>                Set Border_Style to Border_None
87906>>>>>>>>>                Set Bitmap_Style to Bitmap_Center
87907>>>>>>>>>                Set Color to clWhite
87908>>>>>>>>>                Set Size to 30 55
87909>>>>>>>>>                Set Location to 50 3
87910>>>>>>>>>            End_Object
87911>>>>>>>>>
87911>>>>>>>>>            Object oInfoList_Editor is an cAboutEdit
87913>>>>>>>>>                // In case someone wants to set the AboutDialog's Border_Style to thick,
87913>>>>>>>>>                // we might as well prepare the object for it.
87913>>>>>>>>>                Set peAnchors to anAll
87914>>>>>>>>>            End_Object
87915>>>>>>>>>
87915>>>>>>>>>            // These objects are here for backwards compatability only.
87915>>>>>>>>>            // They are not used.
87915>>>>>>>>>            Object oProductName is a TextBox
87917>>>>>>>>>                Set Label To C_$ProductName
87918>>>>>>>>>                Set Size To 10 45
87919>>>>>>>>>                Set Location To 8 53
87920>>>>>>>>>                Set Visible_State to False
87921>>>>>>>>>                Set Focus_Mode to NonFocusable
87922>>>>>>>>>            End_Object
87923>>>>>>>>>
87923>>>>>>>>>            Object oVersion is a TextBox
87925>>>>>>>>>                Set Label To C_$Version
87926>>>>>>>>>                Set Size To 10 25
87927>>>>>>>>>                Set Location To 21 53
87928>>>>>>>>>                Set Visible_State to False
87929>>>>>>>>>                Set Focus_Mode to NonFocusable
87930>>>>>>>>>            End_Object
87931>>>>>>>>>
87931>>>>>>>>>            Object oCopyright is a TextBox
87933>>>>>>>>>                Set Label To C_$Copyright
87934>>>>>>>>>                Set Size To 10 31
87935>>>>>>>>>                Set Location To 34 53
87936>>>>>>>>>                Set Visible_State to False
87937>>>>>>>>>                Set Focus_Mode to NonFocusable
87938>>>>>>>>>            End_Object
87939>>>>>>>>>
87939>>>>>>>>>            Object oAuthor is a TextBox
87941>>>>>>>>>                Set Label To C_$Author
87942>>>>>>>>>                Set Size To 10 22
87943>>>>>>>>>                Set Location To 46 53
87944>>>>>>>>>                Set Visible_State to False
87945>>>>>>>>>                Set Focus_Mode to NonFocusable
87946>>>>>>>>>            End_Object
87947>>>>>>>>>
87947>>>>>>>>>        End_Object
87948>>>>>>>>>
87948>>>>>>>>>        Object oOKButton is a Button
87950>>>>>>>>>            On_Item C_$Close Send Close_Panel
87951>>>>>>>>>            Set Location to 98 176
87952>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
87952>>>>>>>>>            // we might as well prepare the object for it.
87952>>>>>>>>>            Set peAnchors to anBottomRight
87953>>>>>>>>>        End_Object
87954>>>>>>>>>
87954>>>>>>>>>        Object oSysInfoButton is a Button
87956>>>>>>>>>            On_Item C_$SystemInfo Send Show_Sysinfo
87957>>>>>>>>>            Set Location to 98 123
87958>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
87958>>>>>>>>>            // we might as well prepare the object for it.
87958>>>>>>>>>            Set peAnchors to anBottomRight
87959>>>>>>>>>        End_Object
87960>>>>>>>>>
87960>>>>>>>>>        Object oCopyButton is a cCopyEditorContentButton
87962>>>>>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
87963>>>>>>>>>            Set Size to 14 50
87964>>>>>>>>>            Set Location to 98 70
87965>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
87965>>>>>>>>>            // we might as well prepare the object for it.
87965>>>>>>>>>            Set peAnchors to anBottomRight
87966>>>>>>>>>            Set phoEditorHandle to (oInfoList_Editor(Self))
87967>>>>>>>>>        End_Object
87968>>>>>>>>>
87968>>>>>>>>>        On_Key Kcancel Send KeyAction of oOKButton
87969>>>>>>>>>        Set Logo   to "DacAbout.bmp"  // Square bitmaps of 80x80 work best
87970>>>>>>>>>        Set LogoDF to "DF32.bmp"
87971>>>>>>>>>//        Set LogoVDF to "PoweredByOrange.bmp"
87971>>>>>>>>>    End_Procedure
87972>>>>>>>>>
87972>>>>>>>>>    Procedure Page Integer iPageObject
87974>>>>>>>>>        Handle hMenu
87974>>>>>>>>>        Integer iPrevState
87974>>>>>>>>>
87974>>>>>>>>>        Forward Send Page iPageObject
87976>>>>>>>>>        // Due to a bug in the ModalPanel class, we need to set the icon here:
87976>>>>>>>>>        Set Icon to "Default.ico"
87977>>>>>>>>>
87977>>>>>>>>>        // Shadow upper left corner menu items: (icon menu items)
87977>>>>>>>>>        Move (GetSystemMenu(Window_Handle(Self), False)) to hMenu
87978>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_RESTORE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
87979>>>>>>>>>        // The "Move" menu command may come in handy to have.
87979>>>>>>>>>        // Move (EnableMenuItem(hMenu, SC_MOVE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
87979>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_SIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
87980>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_MINIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
87981>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_MAXIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
87982>>>>>>>>>        // The "Close" menu command may be good to have.
87982>>>>>>>>>        // Move (EnableMenuItem(hMenu, SC_CLOSE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
87982>>>>>>>>>    End_Procedure
87983>>>>>>>>>
87983>>>>>>>>>    Procedure Set ProductName String sText
87985>>>>>>>>>        Set Value of oProductName to sText
87986>>>>>>>>>    End_Procedure
87987>>>>>>>>>
87987>>>>>>>>>    Procedure Set Copyright String sText
87989>>>>>>>>>        Set Value of oCopyright to sText
87990>>>>>>>>>    End_Procedure
87991>>>>>>>>>
87991>>>>>>>>>    Procedure Set Author String sText
87993>>>>>>>>>        Set Value of oAuthor to sText
87994>>>>>>>>>    End_Procedure
87995>>>>>>>>>
87995>>>>>>>>>    Procedure Set Version String sVersion
87997>>>>>>>>>        Handle hoVersionInfo
87997>>>>>>>>>        Boolean bIncluded
87997>>>>>>>>>        Integer iMajor iMinor iRelease iBuild
87997>>>>>>>>>        Date dCompileDate
87997>>>>>>>>>        String sCertInfo
87997>>>>>>>>>
87997>>>>>>>>>        If (sVersion = "") Begin
87999>>>>>>>>>            // This automatically shows the program version of the program, if available.
87999>>>>>>>>>            // It will be displayed as the second item in the edit object.
87999>>>>>>>>>            If (ghoApplication <> 0) Begin
88001>>>>>>>>>                Get phoVersionInfo of ghoApplication to hoVersionInfo
88002>>>>>>>>>                If (hoVersionInfo <> 0) Begin
88004>>>>>>>>>                    Get pbIncluded of hoVersionInfo to bIncluded
88005>>>>>>>>>                    If (bIncluded) Begin
88007>>>>>>>>>                        Get piVersionMajor of hoVersionInfo to iMajor
88008>>>>>>>>>                        Get piVersionMinor of hoVersionInfo to iMinor
88009>>>>>>>>>                        Get piVersionRelease of hoVersionInfo to iRelease
88010>>>>>>>>>                        Get piVersionBuild of hoVersionInfo to iBuild
88011>>>>>>>>>                        Move (SFormat (C_$VERSION + ": %1.%2.%3.%4", iMajor, iMinor, iRelease, iBuild)) to sVersion
88012>>>>>>>>>                    End
88012>>>>>>>>>>
88012>>>>>>>>>                End
88012>>>>>>>>>>
88012>>>>>>>>>            End
88012>>>>>>>>>>
88012>>>>>>>>>        End
88012>>>>>>>>>>
88012>>>>>>>>>
88012>>>>>>>>>        // Display the compiled date as the next row in the edit object, after the program version.
88012>>>>>>>>>        Get GetCompileDate to dCompileDate
88013>>>>>>>>>        If (sVersion <> "") Begin
88015>>>>>>>>>            Send Add_Lineln (sVersion + (Character(13)) + C_$Compile_Date * String(dCompileDate))
88016>>>>>>>>>        End
88016>>>>>>>>>>
88016>>>>>>>>>
88016>>>>>>>>>        Get IsProgramDigitallySigned to sCertInfo
88017>>>>>>>>>        If (sCertInfo <> "-1") Begin
88019>>>>>>>>>            If (sCertInfo <> "") Begin
88021>>>>>>>>>                Send Add_LineLn sCertInfo
88022>>>>>>>>>            End
88022>>>>>>>>>>
88022>>>>>>>>>            Else Begin
88023>>>>>>>>>                Send Add_LineLn "The program has NOT been digitally signed, or there is a problem with the digical certificate."
88024>>>>>>>>>            End
88024>>>>>>>>>>
88024>>>>>>>>>        End
88024>>>>>>>>>>
88024>>>>>>>>>    End_Procedure
88025>>>>>>>>>
88025>>>>>>>>>    Function IsDate Desktop String sDate Returns Boolean
88027>>>>>>>>>        Boolean bIsDate
88027>>>>>>>>>        String sGoodCharacters sChar
88027>>>>>>>>>        Integer iCount iLength
88027>>>>>>>>>
88027>>>>>>>>>        Move True to bIsDate
88028>>>>>>>>>        Move "0123456789-/" to sGoodCharacters
88029>>>>>>>>>        Move (Length(sDate)) to iLength
88030>>>>>>>>>        For iCount from 1 to iLength
88036>>>>>>>>>>
88036>>>>>>>>>            Move (Left(sDate, 1)) to sChar
88037>>>>>>>>>            Move (Mid(sDate, 12, 2)) to sDate
88038>>>>>>>>>            Move (sGoodCharacters contains sChar) to bIsDate
88039>>>>>>>>>            If (bIsDate = False) Begin
88041>>>>>>>>>                Move iLength to iCount
88042>>>>>>>>>            End
88042>>>>>>>>>>
88042>>>>>>>>>        Loop
88043>>>>>>>>>>
88043>>>>>>>>>        Function_Return bIsDate
88044>>>>>>>>>    End_Function
88045>>>>>>>>>
88045>>>>>>>>>    Function GetCompileDate Returns Date
88047>>>>>>>>>        Date dCompileDate
88047>>>>>>>>>        String sAppFilename sProgram sData sCompileDate
88047>>>>>>>>>        Integer iChannel iPos iDateFormat iCount iSize
88047>>>>>>>>>        Boolean bIsValid
88047>>>>>>>>>
88047>>>>>>>>>        Move 0 to dCompileDate
88048>>>>>>>>>        // Get full path to the current running executable
88048>>>>>>>>>        Get GetApplicationFileName of ghoApplication to sAppFilename
88049>>>>>>>>>        Get GetApplicationName     of ghoApplication to sProgram
88050>>>>>>>>>
88050>>>>>>>>>        //Read the current file  up to where the data we're interesting in is (this was hand calced and so could vary)
88050>>>>>>>>>        Get Seq_Open_Input_Channel ("binary:" * sAppFilename) to iChannel
88051>>>>>>>>>
88051>>>>>>>>>        Get_Argument_Size to iSize
88052>>>>>>>>>        Read_Block channel iChannel sData 15000000   // This must be big enough to reach the compile date location
88054>>>>>>>>>        Move (Pos(sProgram,sData)) to iPos
88055>>>>>>>>>        If (iPos > 0) Begin
88057>>>>>>>>>            // The compile date is 10 characters long and starts 3 characters after the program name
88057>>>>>>>>>            Move (Mid(sData, 10, iPos + Length(sProgram) + 3)) to sCompileDate  // In US format
88058>>>>>>>>>
88058>>>>>>>>>            // If the current date format is non US, we need to temporary
88058>>>>>>>>>            // change the format and then move the string to the date variable.
88058>>>>>>>>>            Get_Attribute DF_DATE_FORMAT to iDateFormat
88061>>>>>>>>>            Set_Attribute DF_DATE_FORMAT to DF_DATE_USA
88064>>>>>>>>>            Move (Date(sCompileDate))    to dCompileDate
88065>>>>>>>>>            Set_Attribute DF_DATE_FORMAT to iDateFormat // Reset date format
88068>>>>>>>>>        End
88068>>>>>>>>>>
88068>>>>>>>>>//        Else Begin
88068>>>>>>>>>//            Error DFERR_PROGRAM "Compile Date location in .exe not found"
88068>>>>>>>>>//        End
88068>>>>>>>>>
88068>>>>>>>>>        Send Seq_Close_Channel iChannel
88069>>>>>>>>>//        Read_Block channel iChannel sData (8 * 1024)    // First 8K is .exe header skip it
88069>>>>>>>>>//        Read_Block channel iChannel sData 75            // The compile information we're interested in
88069>>>>>>>>>
88069>>>>>>>>>        // The data is padded with Character(0)s. Strip them out
88069>>>>>>>>>//        Move (CString(sData)) to sData
88069>>>>>>>>>
88069>>>>>>>>>        // The compile date is after the first ", ", so string parsing is required
88069>>>>>>>>>//        Move (Pos(", ", sData)) to iPos
88069>>>>>>>>>//        Move (Mid(sData, 10, (iPos + 2) ))  to sCompileDate // In US format
88069>>>>>>>>>        // If the current date format is non US, we need to temporary
88069>>>>>>>>>        // change the format and then move the string to the date variable.
88069>>>>>>>>>//        Get_Attribute DF_DATE_FORMAT        to iDateFormat
88069>>>>>>>>>//        Set_Attribute DF_DATE_FORMAT        to DF_DATE_USA
88069>>>>>>>>>//
88069>>>>>>>>>//        // Note the build in IsDateValid can return the wrong result
88069>>>>>>>>>//        // when controls characters are part of the sCompileDate.
88069>>>>>>>>>//        Get IsDate sCompileDate))           to bIsValid
88069>>>>>>>>>//        If (bIsValid = True) Begin
88069>>>>>>>>>//            Move (Date(sCompileDate))       to dCompileDate
88069>>>>>>>>>//        End
88069>>>>>>>>>//
88069>>>>>>>>>//        // As of DataFlex 19.1 the header has changed; and so has the compile date location.
88069>>>>>>>>>//        // It seems to me that the position for the compilation date can vary. So we read line-by-line
88069>>>>>>>>>//        // until we encounter the program name that appears just in front of the compile date.
88069>>>>>>>>>//        // Although I'm not sure about if/how the position varies, the below seems to work just fine.
88069>>>>>>>>>//        If (dCompileDate = 0) Begin
88069>>>>>>>>>//            Move "" to sCompileDate
88069>>>>>>>>>//            Move 30000 to iSize
88069>>>>>>>>>//            For iCount from 1 to iSize
88069>>>>>>>>>//                Readln channel iChannel sData
88069>>>>>>>>>//                Move (Pos(sProgram, sData)) to iPos
88069>>>>>>>>>//                If (iPos <> 0) Begin
88069>>>>>>>>>//                    Move (Mid(sData, 10, (iPos + (Length(sProgram) + 2)))) to sCompileDate
88069>>>>>>>>>//                    Move (Trim(sCompileDate)) to sCompileDate
88069>>>>>>>>>//                    Move iSize to iCount // We're out of here.
88069>>>>>>>>>//                End
88069>>>>>>>>>//            Loop
88069>>>>>>>>>//            If (Left(sCompileDate, 1) = "0") Begin
88069>>>>>>>>>//                Move ("1" + String(sCompileDate)) to sCompileDate
88069>>>>>>>>>//            End
88069>>>>>>>>>//            Get IsDate sCompileDate)) to bIsValid
88069>>>>>>>>>//            If (bIsValid = True) Begin
88069>>>>>>>>>//                Move (Date(sCompileDate)) to dCompileDate
88069>>>>>>>>>//            End
88069>>>>>>>>>//        End
88069>>>>>>>>>//        Send Seq_Close_Channel iChannel
88069>>>>>>>>>//        Set_Attribute DF_DATE_FORMAT to iDateFormat // Reset date format
88069>>>>>>>>>
88069>>>>>>>>>        Function_Return dCompileDate
88070>>>>>>>>>    End_Function
88071>>>>>>>>>
88071>>>>>>>>>    // A variant of the ShellExecute Win API, but it waits until the process that is started
88071>>>>>>>>>    // (the passed program), has been finished
88071>>>>>>>>>    // The DOS box does also _not_ flash briefly.
88071>>>>>>>>>    Procedure RunProgramWait String sProgram String sParameter
88073>>>>>>>>>        Handle hProcess
88073>>>>>>>>>        Integer iVoid
88073>>>>>>>>>        AboutSHELLEXECUTEINFO sInfo
88073>>>>>>>>>        AboutSHELLEXECUTEINFO sInfo
88073>>>>>>>>>
88073>>>>>>>>>        Move (SizeOfType(AboutSHELLEXECUTEINFO)) to sInfo.cbSize
88074>>>>>>>>>
88074>>>>>>>>>        Move SEE_MASK_NOCLOSEPROCESS to sInfo.fMask
88075>>>>>>>>>        Move SW_SHOW                 to sInfo.nShow
88076>>>>>>>>>
88076>>>>>>>>>        Move (AddressOf(sProgram))   to sInfo.lpFile
88077>>>>>>>>>        Move (AddressOf(sParameter)) to sInfo.lpParameters
88078>>>>>>>>>        // This will "hide" the DOS box from showing (no flasing box):
88078>>>>>>>>>        Move 0                       to sInfo.nShow
88079>>>>>>>>>
88079>>>>>>>>>        Move (AboutShellExecuteEx(AddressOf(sInfo))) to iVoid
88080>>>>>>>>>        Move sInfo.hProcess to hProcess
88081>>>>>>>>>        If (hProcess) Begin
88083>>>>>>>>>            Move (AboutWaitForSingleObject(hProcess, -1)) to iVoid
88084>>>>>>>>>            Move (AboutCloseHandle(hProcess)) to iVoid
88085>>>>>>>>>        End
88085>>>>>>>>>>
88085>>>>>>>>>    End_Procedure
88086>>>>>>>>>
88086>>>>>>>>>    Function AddFolderDelimiter String sPath Returns String
88088>>>>>>>>>        String sDirSep
88088>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
88089>>>>>>>>>        Move (Trim(sPath)) to sPath
88090>>>>>>>>>        If (Right(sPath, 1) <> sDirSep) Begin
88092>>>>>>>>>            Move (sPath + sDirSep) to sPath
88093>>>>>>>>>        End
88093>>>>>>>>>>
88093>>>>>>>>>        Function_Return sPath
88094>>>>>>>>>    End_Function
88095>>>>>>>>>
88095>>>>>>>>>    // Returns an empty string if the current program is not digitally signed,
88095>>>>>>>>>    // or there is a problem with the certificate.
88095>>>>>>>>>    // Note: A copy of the Microsoft signtool.exe program must reside in the Programs folder,
88095>>>>>>>>>    //       else nothing is shown in the About object. (Size 355 KB)
88095>>>>>>>>>    Function IsProgramDigitallySigned Returns String
88097>>>>>>>>>        Boolean bExists
88097>>>>>>>>>        String sPath sProgram sParams sRetval
88097>>>>>>>>>        Integer iCh
88097>>>>>>>>>
88097>>>>>>>>>        Move "" to sRetval
88098>>>>>>>>>        Get psProgramPath of (phoWorkspace(ghoApplication)) to sPath
88099>>>>>>>>>        Get AddFolderDelimiter sPath to sPath
88100>>>>>>>>>        File_Exist (sPath + CS_SignProgram) bExists
88101>>>>>>>>>        If (bExists = False) Begin
88103>>>>>>>>>            Function_Return "-1"
88104>>>>>>>>>        End
88104>>>>>>>>>>
88104>>>>>>>>>
88104>>>>>>>>>        Get GetApplicationFileName of ghoApplication to sProgram
88105>>>>>>>>>        Move (CS_VerifyCredentials * CS_DefAuthVerPolicy) to sParams
88106>>>>>>>>>        Move (sParams * '"' + sProgram + '"') to sParams
88107>>>>>>>>>        Move (sParams * String("| clip"))    to sParams
88108>>>>>>>>>        Get Seq_New_Channel to iCh
88109>>>>>>>>>        Direct_Output channel iCh (sPath + CS_TempCertBatchFile)
88111>>>>>>>>>            Writeln channel iCh ('"' + sPath + CS_SignProgram + '"' * sParams)
88114>>>>>>>>>        Close_Output channel iCh
88116>>>>>>>>>        // New ShellExecute based message that waits for the passed process to end.
88116>>>>>>>>>        Send RunProgramWait (sPath + CS_TempCertBatchFile) ""
88117>>>>>>>>>        Direct_Input channel iCh "CLIPBOARD:"
88119>>>>>>>>>            Readln channel iCh sRetval
88121>>>>>>>>>            Readln channel iCh sRetval
88123>>>>>>>>>            Readln channel iCh sRetval
88125>>>>>>>>>            Readln channel iCh sRetval
88127>>>>>>>>>        Close_Input channel iCh
88129>>>>>>>>>        Send Seq_Release_Channel iCh
88130>>>>>>>>>        If (Lowercase(sRetval) contains "authenticode") Begin
88132>>>>>>>>>            Move "This program has been digitally signed and the certificate is valid." to sRetval
88133>>>>>>>>>        End
88133>>>>>>>>>>
88133>>>>>>>>>        Else Begin
88134>>>>>>>>>            Move "" to sRetval
88135>>>>>>>>>        End
88135>>>>>>>>>>
88135>>>>>>>>>//        Get DeleteFile (sPath + CS_TempCertBatchFile) to iRetval
88135>>>>>>>>>        EraseFile (sPath + CS_TempCertBatchFile)
88136>>>>>>>>>>
88136>>>>>>>>>        Function_Return sRetval
88137>>>>>>>>>    End_Function
88138>>>>>>>>>
88138>>>>>>>>>    Procedure Add_LineLn String sValue
88140>>>>>>>>>        Send Add_LineLn of oInfoList_Editor sValue
88141>>>>>>>>>    End_Procedure
88142>>>>>>>>>
88142>>>>>>>>>    Procedure Add_Line String sValue
88144>>>>>>>>>        Send Add_Line of oInfoList_Editor sValue
88145>>>>>>>>>    End_Procedure
88146>>>>>>>>>
88146>>>>>>>>>    Procedure Set Logo string sLogo
88148>>>>>>>>>        // Square bitmaps of 80x80 work best
88148>>>>>>>>>        Set Bitmap of oAboutGraphic to sLogo
88149>>>>>>>>>    End_Procedure
88150>>>>>>>>>
88150>>>>>>>>>    Procedure Set LogoDF String sLogo
88152>>>>>>>>>        Set Bitmap of oPoweredByDFGraphic to sLogo
88153>>>>>>>>>    End_Procedure
88154>>>>>>>>>
88154>>>>>>>>>    Procedure Show_Sysinfo
88156>>>>>>>>>        Send Popup_Modal of oSysinfoDialog
88157>>>>>>>>>    End_Procedure
88158>>>>>>>>>
88158>>>>>>>>>    Procedure Show_HomePage String sWebpage
88160>>>>>>>>>        Handle hWnd
88160>>>>>>>>>        Get Window_Handle to hWnd
88161>>>>>>>>>        Runprogram Shell Background (Trim(sWebpage))
88162>>>>>>>>>    End_Procedure
88163>>>>>>>>>
88163>>>>>>>>>End_Class
88164>>>>>>>
88164>>>>>>>// Martin Moleman on SQL Server and DateTime2 (Don't use DataTime any longer !)
88164>>>>>>>// One remark about your change: I would not change to datetime2(7) (7 decimals) but to
88164>>>>>>>// datetime2(3) (3 decimals = milliseconds) or If you don't need the milliseconds datetime2(0).
88164>>>>>>>// The reason is that the DataFlex DateTime type only allows 3 decimals. When using 7
88164>>>>>>>// decimals you may Get truncation that again may cause problems with finding.
88164>>>>>>>//
88164>>>>>>>// Important! The conversion from DateTime to Date or datetime2 will also convert all dummy zero Date values from 1753-01-01 to 0001-01-01.
88164>>>>>>>// This is important to realize. The conversion will actually change the data in the database (done by the driver)
88164>>>>>>>
88164>>>>>>>
88164>>>>>>>// DF_DATABASE_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA
88164>>>>>>>// Determines for all DataFlex data types, which SQL native types willbe used when creating new columns.
88164>>>>>>>// Set_Attribute DF_DATABASE_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA of {driverNumber} {databaseHandle} ;
88164>>>>>>>// to {MAP_DF_TO_SQL_TYPE_SQL2000|MAP_DF_TO_SQL_TYPE_SQL2005|MAP_DF_TO_SQL_TYPE_SQL2008|MAP_DF_TO_SQL_TYPE_SQL2012}
88164>>>>>>>//
88164>>>>>>>
88164>>>>>>>Class cDbUpdateFunctionLibrary is a cObject
88165>>>>>>>    Import_Class_Protocol cDbUpdateFunctionLibrary_Mixin
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
88166>>>>>>>>
88166>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
88168>>>>>>>>    Integer iStart iEnd
88168>>>>>>>>    String sRetval
88168>>>>>>>>
88168>>>>>>>>    Move (Trim(sConnect)) to sConnect
88169>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
88170>>>>>>>>    If (iStart = 0) Begin
88172>>>>>>>>        Function_Return ""
88173>>>>>>>>    End
88173>>>>>>>>>
88173>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
88174>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
88175>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
88177>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
88178>>>>>>>>    End
88178>>>>>>>>>
88178>>>>>>>>    Else Begin
88179>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
88180>>>>>>>>    End
88180>>>>>>>>>
88180>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
88182>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
88183>>>>>>>>        Decrement iEnd
88184>>>>>>>>    End
88184>>>>>>>>>
88184>>>>>>>>    If (iEnd <> 0) Begin
88186>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
88187>>>>>>>>    End
88187>>>>>>>>>
88187>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
88188>>>>>>>>
88188>>>>>>>>    Function_Return (Trim(sRetval))
88189>>>>>>>>End_Function
88190>>>>>>>>
88190>>>>>>>>
88190>>>>>>>
88190>>>>>>>    Procedure Construct_Object
88192>>>>>>>        Handle ho
88192>>>>>>>        Forward Send Construct_Object
88194>>>>>>>
88194>>>>>>>        Move Self to ghoDbUpdateFunctionLibrary
88195>>>>>>>
88195>>>>>>>        Send CreateDbUpdateLibraryProperties
88196>>>>>>>        // If no ghoSQLConnectionHandler object has been created prior to this object,
88196>>>>>>>        // we will create one as it is used for all ConnectionID, ConnectionString
88196>>>>>>>        // etc settings.
88196>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
88198>>>>>>>            Get Create (RefClass(cSQLConnectionHandler)) to ho
88199>>>>>>>            Set phoSQLConnectionHandler to ho
88200>>>>>>>        End   
88200>>>>>>>>
88200>>>>>>>        
88200>>>>>>>        Property String private.psCollation "Latin1_General_CS_AS"
88201>>>>>>>
88201>>>>>>>    End_Procedure
88202>>>>>>>
88202>>>>>>>    Procedure End_Construct_Object
88204>>>>>>>        Forward Send End_Construct_Object
88206>>>>>>>    End_Procedure
88207>>>>>>>
88207>>>>>>>    // *** SQL Messages for making changes to the SQL back-end ***
88207>>>>>>>    //
88207>>>>>>>    // * Dummy function for the Studio's Code Explorer *
88207>>>>>>>    Function SQL_DATABASE_FUNCTIONS Returns Boolean
88209>>>>>>>        Function_Return False
88210>>>>>>>    End_Function
88211>>>>>>>
88211>>>>>>>    // Function for creating a new *Database*.
88211>>>>>>>    // Note: This is for creating SQL DATABASES - not tables!
88211>>>>>>>    // Returns True if successful.
88211>>>>>>>    // ToDo: Currently only works for MS-SQL...
88211>>>>>>>    Function SqlDatabaseCreate String sDriverID String sDatabase Boolean bUpdateConnectionString Boolean bPermanantly Returns Boolean
88213>>>>>>>        String sSQL sSQL1 sConnectionID sConnectionString
88213>>>>>>>        String sCreateDatabaseKeyWord sSelectFromWhereName sCollation sCollateKeyWord
88213>>>>>>>        Handle hConnection hStmt hoSQLManager
88213>>>>>>>        Integer iFetchResult iDbType
88213>>>>>>>        Boolean bOK bMertechDriver bExists
88213>>>>>>>
88213>>>>>>>        Get piDbType to iDbType
88214>>>>>>>//        If (iDbType <> EN_DbTypeMSSQL and sDriverID <> MDSMySQL and sDriverID <> MDSDB2 and sDriverID <> ODBC_DRV_ID) Begin
88214>>>>>>>        If (iDbType <> EN_DbTypeMSSQL and iDbType <> EN_DbTypeDB2 and iDbType <> EN_DbTypeMySQL and iDbType <> EN_DbTypePostgre) Begin
88216>>>>>>>            Error DFERR_PROGRAM "Sorry, the SqlDatabaseCreate function is currently only supported for MS-SQL, MySQL & PostGre and DB2 with Mertech drivers"
88217>>>>>>>>
88217>>>>>>>            Function_Return False
88218>>>>>>>        End
88218>>>>>>>>
88218>>>>>>>
88218>>>>>>>        Get SqlUtilCheckIfDatabaseExists sDatabase to bExists
88219>>>>>>>        If (bExists = True) Begin
88221>>>>>>>            Function_Return True
88222>>>>>>>        End
88222>>>>>>>>
88222>>>>>>>
88222>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
88223>>>>>>>        If (bMertechDriver = False) Begin
88225>>>>>>>            Get phoSQLManager to hoSQLManager
88226>>>>>>>        End
88226>>>>>>>>
88226>>>>>>>        Else Begin
88227>>>>>>>            Get _MertechSQLManagerHandle to hoSQLManager
88228>>>>>>>        End
88228>>>>>>>>
88228>>>>>>>
88228>>>>>>>        Get psConnectionID     to sConnectionID
88229>>>>>>>        Get psConnectionString to sConnectionString
88230>>>>>>>        Move 0 to LastErr
88231>>>>>>>
88231>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
88233>>>>>>>            // If an ODBC data source (DSN) we cannot pass the UID & PWD; so strip them from the connection string.
88233>>>>>>>            // ToDo: 2018-08-11 I think this is wrong and the uid & pw should be there.
88233>>>>>>>//            If (Uppercase(sConnectionString) contains CS_SQLIniDSNKeyword) Begin
88233>>>>>>>//                Move (Pos(";", sConnectionString)) to iPos
88233>>>>>>>//                If (iPos > 0) Begin
88233>>>>>>>//                    Move (Left(sConnectionString, (iPos - 1))) to sConnectionString
88233>>>>>>>//                    Move (Trim(sConnectionString)) to sConnectionString
88233>>>>>>>//                End
88233>>>>>>>//            End
88233>>>>>>>        End
88233>>>>>>>>
88233>>>>>>>
88233>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
88234>>>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
88235>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
88236>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
88238>>>>>>>            Error DFERR_PROGRAM (CS_DUF_LoginToDbServerFailed + "\n" + sConnectionString)
88239>>>>>>>>
88239>>>>>>>            Function_Return False
88240>>>>>>>        End
88240>>>>>>>>
88240>>>>>>>
88240>>>>>>>        Get SqlOpen of hConnection to hStmt
88241>>>>>>>
88241>>>>>>>        If (hStmt = 0) Begin
88243>>>>>>>            Send SqlDisconnect of hoSQLManager
88244>>>>>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
88245>>>>>>>>
88245>>>>>>>            Function_Return False
88246>>>>>>>        End
88246>>>>>>>>
88246>>>>>>>
88246>>>>>>>        Get psCollation to sCollation
88247>>>>>>>
88247>>>>>>>        Case Begin
88247>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
88249>>>>>>>                Get _SqlFindKeyWord CI_SQLCreateDatabase to sCreateDatabaseKeyWord
88250>>>>>>>                Get _SqlSelectFromWhereName to sSelectFromWhereName
88251>>>>>>>                Move (sSelectFromWhereName + "='" + sDatabase + "'") to sSQL
88252>>>>>>>
88252>>>>>>>                // Check if database exists
88252>>>>>>>                Send SqlExecDirect of hStmt sSQL
88253>>>>>>>                Get SqlFetch of hStmt to iFetchResult
88254>>>>>>>                Send SqlClose of hStmt
88255>>>>>>>                Send SqlDisconnect of hConnection
88256>>>>>>>                // If database already exists we're out of here!
88256>>>>>>>                // Note that we return True as this is not an error.
88256>>>>>>>                If (iFetchResult > 0) Begin
88258>>>>>>>                    Function_Return True
88259>>>>>>>                End
88259>>>>>>>>
88259>>>>>>>                // Database doesn't exist, create it.
88259>>>>>>>                If (iFetchResult = 0) Begin
88261>>>>>>>                    Move (sCreateDatabaseKeyWord + " [" + sDatabase + "]") to sSQL1
88262>>>>>>>                    Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88263>>>>>>>                    If (sCollation <> "") Begin
88265>>>>>>>                        Get _SqlFindKeyWord CI_SQLDatabaseCollation to sCollateKeyWord
88266>>>>>>>                        Move (sSQL1 * String(sCollateKeyWord) * String(sCollation)) to sSQL1
88267>>>>>>>                    End
88267>>>>>>>>
88267>>>>>>>                    Send SqlUtilExecuteQuery sSQL1 sDriverID
88268>>>>>>>                    Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88269>>>>>>>                    If (LastErr = CLIERR_GENERAL_ERROR) Begin
88271>>>>>>>                        Function_Return False
88272>>>>>>>                    End
88272>>>>>>>>
88272>>>>>>>                    // We need to wait a short time for Sql to finish, especially Windows to write the new file to disk.
88272>>>>>>>                    Sleep 1
88273>>>>>>>                    Send SqlUtilExecuteQuery sSQL sDriverID
88274>>>>>>>                End
88274>>>>>>>>
88274>>>>>>>                Case Break
88275>>>>>>>
88275>>>>>>>            Case (sDriverID = MDSPgSQL)
88278>>>>>>>                SQLIncludeScriptFile ..\Scripts\CreatePostgreSQLDatabase.sql as CreatePostgreSQLDatabase.sql
88278>>>>>>>                Get _SqlUtilCreatePostGreSQLDatabaseByScript "CreatePostgreSQLDatabase.sql" sDatabase to bOK
88279>>>>>>>                Case Break
88280>>>>>>>
88280>>>>>>>            Case (sDriverID = MDSMySQL or (iDbType = EN_DbTypeMySQL and sDriverID = ODBC_DRV_ID))
88283>>>>>>>                // ToDo: How should this be set/checked?
88283>>>>>>>//                If (Lowercase(Left(sCollation, 3)) <> "utf") Begin
88283>>>>>>>//                    Set psCollation to "utf8"
88283>>>>>>>//                End
88283>>>>>>>                SQLIncludeScriptFile ..\Scripts\CreateMySQLDatabase.sql as CreateMySQLDatabase.sql
88283>>>>>>>                Get _SqlUtilCreateMySQLDatabaseByScript "CreateMySQLDatabase.sql" sDatabase to bOK
88284>>>>>>>                Case Break
88285>>>>>>>
88285>>>>>>>            Case (sDriverID = MDSDB2)
88288>>>>>>>                        CompilerWarnings Off
88288>>>>>>>                        CREATE_DB2_DATABASE sDatabase "" sCollation ""
88320>>>>>>>                        CompilerWarnings Off
88320>>>>>>>                Case Break
88321>>>>>>>
88321>>>>>>>            Case Else
88321>>>>>>>                Error DFERR_PROGRAM "Unsupported database type"
88322>>>>>>>>
88322>>>>>>>        Case End
88322>>>>>>>
88322>>>>>>>        If (Err = False) Begin
88324>>>>>>>            Send LogError ("The Database:" * String(sDatabase) * "was created successfully for driver:" * String(sDriverID)) False
88325>>>>>>>        End
88325>>>>>>>>
88325>>>>>>>        // If used in e.g. the cDbUpdateHandler we want to change the login database name to
88325>>>>>>>        // the one we just created.
88325>>>>>>>        If (bUpdateConnectionString = True and Err = False) Begin
88327>>>>>>>            Set psDatabase to sDatabase
88328>>>>>>>            //...and perhaps also the SQLConnections.ini file setting.
88328>>>>>>>            If (bPermanantly = True) Begin
88330>>>>>>>                If (ghoSQLConnectionHandler <> 0) Begin
88332>>>>>>>                    Get SQLIniFileSetDefaultConnection of ghoSQLConnectionHandler sConnectionID to bOK
88333>>>>>>>                End
88333>>>>>>>>
88333>>>>>>>            End
88333>>>>>>>>
88333>>>>>>>        End
88333>>>>>>>>
88333>>>>>>>
88333>>>>>>>        Function_Return (Err = False)
88334>>>>>>>    End_Function
88335>>>>>>>
88335>>>>>>>    // Backs up an SQL database to a folder of choice. If no path is passed the SQL default backup folder
88335>>>>>>>    // will be used.
88335>>>>>>>    Function SqlDatabaseBackupToDisk String sDatabase String sBackupName String sPath Boolean bShowProg Returns Boolean
88337>>>>>>>        Boolean bOK bExists bShowProgress bErr
88337>>>>>>>        String sStatement sDriverID
88337>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
88337>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
88337>>>>>>>        Integer iDbType
88337>>>>>>>
88337>>>>>>>        If (sDatabase = "") Begin
88339>>>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
88340>>>>>>>>
88340>>>>>>>            Function_Return False
88341>>>>>>>        End
88341>>>>>>>>
88341>>>>>>>        If (sBackupName = "") Begin
88343>>>>>>>            Error DFERR_PROGRAM "The database backup name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
88344>>>>>>>>
88344>>>>>>>            Function_Return False
88345>>>>>>>        End
88345>>>>>>>>
88345>>>>>>>
88345>>>>>>>        // Create backup-folder if it doesn't exist
88345>>>>>>>        Get vFolderExists sPath to bExists
88346>>>>>>>        If (bExists = False) Begin
88348>>>>>>>            Get vCreateDirectory sPath to bErr
88349>>>>>>>            If (bErr = True) Begin
88351>>>>>>>                Error DFERR_PROGRAM ("Could not create database backup folder:" * sPath)
88352>>>>>>>>
88352>>>>>>>                Function_Return False
88353>>>>>>>            End
88353>>>>>>>>
88353>>>>>>>        End
88353>>>>>>>>
88353>>>>>>>        // Make sure the path ends with a back-slash
88353>>>>>>>        If (sPath <> "") Begin
88355>>>>>>>            Get vFolderFormat sPath to sPath
88356>>>>>>>        End
88356>>>>>>>>
88356>>>>>>>
88356>>>>>>>        Get psDriverID to sDriverID
88357>>>>>>>        Get piDbType   to iDbType
88358>>>>>>>        If (num_arguments > 3) Begin
88360>>>>>>>            Move bShowProg to bShowProgress
88361>>>>>>>        End
88361>>>>>>>>
88361>>>>>>>
88361>>>>>>>        Case Begin
88361>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
88363>>>>>>>                SQLIncludeScriptFile ..\Scripts\BackupMSSQLDatabase.sql as BackupMSSQLDatabase.sql
88363>>>>>>>                SQLIncludeScriptFile ..\Scripts\GetPercentageBackupCompletionMSSQL.sql as GetPercentageBackupCompletionMSSQL.sql
88363>>>>>>>                Get SqlUtilReadResource of ghoDbUpdateFunctionLibrary "BackupMSSQLDatabase.sql" sDriverID False to SQLScriptArray
88364>>>>>>>                Get SqlUtilReadResource of ghoDbUpdateFunctionLibrary "GetPercentageBackupCompletionMSSQL.sql" sDriverID False to SQLScriptArrayPercentReady
88365>>>>>>>
88365>>>>>>>                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
88366>>>>>>>                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase))   to sStatement
88367>>>>>>>                Move (Replaces("BACKUP_PATH_XXX",   sStatement, sPath))       to sStatement
88368>>>>>>>                Move (Replaces("BACKUP_NAME_XXX",   sStatement, sBackupName)) to sStatement
88369>>>>>>>                Move sStatement to SQLScriptArray.sSQLScriptArray[0]
88370>>>>>>>                Get SqlUtilExecuteEmbeddedScript of ghoDbUpdateFunctionLibrary SQLScriptArray sDriverID False "" bShowProgress to bOK
88371>>>>>>>                Case Break
88372>>>>>>>            Case Else
88372>>>>>>>                Send Info_Box ("The SqlUtilBackupDatabaseToDisk function is currently not implemented for the driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and add a little ESQL code snippet to make it work for that driver! Thanks for helping out.")
88373>>>>>>>        Case End
88373>>>>>>>
88373>>>>>>>        Function_Return bOK
88374>>>>>>>    End_Function
88375>>>>>>>
88375>>>>>>>    Function SqlDatabaseCollationQuery String sDatabase Boolean bSilent Returns String
88377>>>>>>>//        Boolean bOK bExists
88377>>>>>>>        String sStatement sDriverID sRetval //sPrevious
88377>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
88377>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
88377>>>>>>>        Integer iDbType iRows iFetchResult //iColumn
88377>>>>>>>        Handle hoSQLHandler hoSQLConnect hstmt
88377>>>>>>>        tSQLConnection SQLConnection
88377>>>>>>>        tSQLConnection SQLConnection
88377>>>>>>>
88377>>>>>>>        If (sDatabase = "") Begin
88379>>>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilDatabaseCollation' function"
88380>>>>>>>>
88380>>>>>>>            Function_Return ""
88381>>>>>>>        End
88381>>>>>>>>
88381>>>>>>>
88381>>>>>>>        Move "" to sRetval
88382>>>>>>>        Get psDriverID to sDriverID
88383>>>>>>>        Get piDbType   to iDbType
88384>>>>>>>
88384>>>>>>>        Case Begin
88384>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
88386>>>>>>>                SQLIncludeScriptFile ..\Scripts\QueryMSSQLCollation.sql as QueryMSSQLCollation.sql
88386>>>>>>>                Get SqlUtilReadResource of ghoDbUpdateFunctionLibrary "QueryMSSQLCollation.sql" sDriverID False to SQLScriptArray
88387>>>>>>>
88387>>>>>>>                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
88388>>>>>>>                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase)) to sStatement
88389>>>>>>>                Get phoSQLManager to hoSQLHandler
88390>>>>>>>
88390>>>>>>>                If (hoSQLHandler <> 0) Begin
88392>>>>>>>                    Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
88393>>>>>>>                    Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
88394>>>>>>>
88394>>>>>>>                    If (hoSQLConnect <> 0) Begin
88396>>>>>>>                        Get SQLOpen of hoSQLConnect to hstmt
88397>>>>>>>                        If (hstmt <> 0) Begin
88399>>>>>>>                            Send SqlExecDirect of hstmt sStatement
88400>>>>>>>                            Get SqlStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
88401>>>>>>>                            Get SQLFetch of hstmt to iFetchResult
88402>>>>>>>                            If (iFetchResult <> 0) Begin
88404>>>>>>>                                Get SQLColumnValue of hstmt 2 to sRetval // Column 1 = Database Name, 2 = Collation Name.
88405>>>>>>>                            End
88405>>>>>>>>
88405>>>>>>>                            Send SQLClose of hstmt
88406>>>>>>>                        End
88406>>>>>>>>
88406>>>>>>>                        Send SQLDisconnect of hoSQLConnect
88407>>>>>>>                    End
88407>>>>>>>>
88407>>>>>>>                End
88407>>>>>>>>
88407>>>>>>>                Case Break
88408>>>>>>>            Case Else
88408>>>>>>>                If (bSilent = False) Begin
88410>>>>>>>                    Send Info_Box ("The SqlDatabaseCollationQuery function is currently not implemented for this driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and create a little SQL code snippet and send it to RDC Tools to make this routine work for this driver! Thanks for helping out.")
88411>>>>>>>                End
88411>>>>>>>>
88411>>>>>>>        Case End
88411>>>>>>>
88411>>>>>>>        Function_Return sRetval
88412>>>>>>>    End_Function
88413>>>>>>>
88413>>>>>>>    Function SqlDatabaseCollationChange String sDatabase String sSQLCollation Returns Boolean
88415>>>>>>>        Boolean bMertechDriver // bOK bExists 
88415>>>>>>>        String sDriverID sSQL sConnectionID sConnectionString sSet sWith // sSQL1 
88415>>>>>>>        String sAlterDatabaseKeyWord sCollateKeyWord sSQLCollationCheck sSingle_User sMulti_User sRollback sImmediate
88415>>>>>>>        Handle hConnection hStmt hoSQLManager
88415>>>>>>>        Integer iDbType // iFetchResult
88415>>>>>>>
88415>>>>>>>        If (sDatabase = "") Begin
88417>>>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
88418>>>>>>>>
88418>>>>>>>            Function_Return False
88419>>>>>>>        End
88419>>>>>>>>
88419>>>>>>>
88419>>>>>>>        If (sSQLCollation = "") Begin
88421>>>>>>>            Error DFERR_PROGRAM "The SQL Collation name was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
88422>>>>>>>>
88422>>>>>>>            Function_Return False
88423>>>>>>>        End
88423>>>>>>>>
88423>>>>>>>
88423>>>>>>>        Get psDriverID to sDriverID
88424>>>>>>>        Get piDbType   to iDbType
88425>>>>>>>
88425>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
88426>>>>>>>        If (bMertechDriver = False) Begin
88428>>>>>>>            Get phoSQLManager to hoSQLManager
88429>>>>>>>        End
88429>>>>>>>>
88429>>>>>>>        Else Begin
88430>>>>>>>            Get _MertechSQLManagerHandle to hoSQLManager
88431>>>>>>>        End
88431>>>>>>>>
88431>>>>>>>
88431>>>>>>>        Get psConnectionID     to sConnectionID
88432>>>>>>>        Get psConnectionString to sConnectionString
88433>>>>>>>        Move 0 to LastErr
88434>>>>>>>
88434>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
88435>>>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
88436>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
88437>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
88439>>>>>>>            Error DFERR_PROGRAM ("Login failed to the database server. The following connect string was used:\n" + sConnectionString)
88440>>>>>>>>
88440>>>>>>>            Function_Return False
88441>>>>>>>        End
88441>>>>>>>>
88441>>>>>>>
88441>>>>>>>        Get SqlOpen of hConnection to hStmt
88442>>>>>>>
88442>>>>>>>        If (hStmt = 0) Begin
88444>>>>>>>            Send SqlDisconnect of hoSQLManager
88445>>>>>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
88446>>>>>>>>
88446>>>>>>>            Function_Return False
88447>>>>>>>        End
88447>>>>>>>>
88447>>>>>>>
88447>>>>>>>        // Check if collation already exists
88447>>>>>>>        Get SqlDatabaseCollationQuery sDatabase False to sSQLCollationCheck
88448>>>>>>>        // If the current collate is the same as the new; do nothing.
88448>>>>>>>        If (sSQLCollation = sSQLCollationCheck) Begin
88450>>>>>>>            Function_Return True
88451>>>>>>>        End
88451>>>>>>>>
88451>>>>>>>
88451>>>>>>>        Get _SqlFindKeyWord CI_SQLSet               to sSet
88452>>>>>>>        Get _SqlFindKeyWord CI_SQLWith              to sWith
88453>>>>>>>        Get _SqlFindKeyWord CI_SQLSingle_User       to sSingle_User
88454>>>>>>>        Get _SqlFindKeyWord CI_SQLMulti_User        to sMulti_User
88455>>>>>>>        Get _SqlFindKeyWord CI_SQLRollback          to sRollback
88456>>>>>>>        Get _SqlFindKeyWord CI_SQLIMMEDIATE         to sImmediate
88457>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterDatabase     to sAlterDatabaseKeyWord
88458>>>>>>>        Get _SqlFindKeyWord CI_SQLDatabaseCollation to sCollateKeyWord
88459>>>>>>>
88459>>>>>>>        // MS-SQL Syntax:
88459>>>>>>>        // ALTER DATABASE [database] SET SINGLE_USER WITH ROLLBACK IMMEDIATE;
88459>>>>>>>        // ALTER DATABASE [database] COLLATE SQL_1xCompat_CP850_CI_AS;
88459>>>>>>>        // ALTER DATABASE [database] SET MULTI_USER;
88459>>>>>>>        Move (              sAlterDatabaseKeyWord  * String(sDatabase) * String(sSet) * String(sSingle_User) * String(sWith) * String(sRollback) * String(sImmediate)) to sSQL
88460>>>>>>>        Move (sSQL * String(sAlterDatabaseKeyWord) * String(sDatabase) * String(sCollateKeyWord) * String(sSQLCollation)) to sSQL
88461>>>>>>>        Move (sSQL * String(sAlterDatabaseKeyWord) * String(sDatabase) * String(sSet) * String(sMulti_User)) to sSQL
88462>>>>>>>//        Move (sAlterDatabaseKeyWord * String(sDatabase) * String(sCollateKeyWord) * String(sSQLCollation)) to sSQL
88462>>>>>>>
88462>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88463>>>>>>>        Send SqlUtilExecuteQuery sSQL sDriverID False
88464>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88465>>>>>>>        If (LastErr = CLIERR_GENERAL_ERROR) Begin
88467>>>>>>>           Function_Return False
88468>>>>>>>        End
88468>>>>>>>>
88468>>>>>>>
88468>>>>>>>        Function_Return (Err = False)
88469>>>>>>>    End_Function
88470>>>>>>>
88470>>>>>>>
88470>>>>>>>    // * Dummy function for the Studio's Code Explorer *
88470>>>>>>>    Function SQL_TABLE_FUNCTIONS Returns Boolean
88472>>>>>>>        Function_Return False
88473>>>>>>>    End_Function
88474>>>>>>>
88474>>>>>>>    // Converts from SQL to Embedded (DataFlex .dat files).
88474>>>>>>>    // To convert from SQL -> SQL (e.g. from Oracle - > MS SQL)
88474>>>>>>>    //   first use SQLTableConvertToEmbedded in one cDbUpdateVersion object,
88474>>>>>>>    //   and then use the ApiTableConvertToSQL method in a second cDbUpdateVersion object.
88474>>>>>>>    // Note: To convert an embedded table to SQL use ApiTableConvertToSQL.
88474>>>>>>>    Function SqlTableConvertToEmbedded Handle hTable Boolean bCpyDat Returns Boolean
88476>>>>>>>        Handle hToTable
88476>>>>>>>        Boolean bOK bExists bOpened bMertechDriver bCopyData
88476>>>>>>>        String sDriverID sPhysicalName sRootName sDisplayName
88476>>>>>>>        tSQLConnection SQLConnection
88476>>>>>>>        tSQLConnection SQLConnection
88476>>>>>>>        Integer iPos iMaxRecords
88476>>>>>>>
88476>>>>>>>        Get psDriverID to sDriverID
88477>>>>>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
88478>>>>>>>        If (bExists = False) Begin
88480>>>>>>>            Function_Return False
88481>>>>>>>        End
88481>>>>>>>>
88481>>>>>>>
88481>>>>>>>        If (num_arguments > 1) Begin
88483>>>>>>>            Move bCpyDat to bCopyData
88484>>>>>>>        End
88484>>>>>>>>
88484>>>>>>>        Else Begin
88485>>>>>>>            Move False to bCopyData
88486>>>>>>>        End
88486>>>>>>>>
88486>>>>>>>
88486>>>>>>>        Open hTable
88488>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
88491>>>>>>>        If (bOpened = False) Begin
88493>>>>>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
88494>>>>>>>>
88494>>>>>>>            Function_Return False
88495>>>>>>>        End
88495>>>>>>>>
88495>>>>>>>        Move 0 to hToTable
88496>>>>>>>
88496>>>>>>>        Move 16711679 to iMaxRecords
88497>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
88500>>>>>>>        Move (Pos(".", sDisplayName)) to iPos
88501>>>>>>>        If (iPos > 0) Begin
88503>>>>>>>            Move (Mid(sDisplayName, 200, (iPos +1))) to sDisplayName
88504>>>>>>>        End
88504>>>>>>>>
88504>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
88507>>>>>>>        Get _TableNameOnly sRootName                 to sRootName
88508>>>>>>>        Move (sRootName + ".dat")                    to sPhysicalName
88509>>>>>>>
88509>>>>>>>        If (ghoProgressBar <> 0) Begin
88511>>>>>>>            Send DoAdvance of ghoProgressBar
88512>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Converting to Embedded - Table:" * String(sRootName) * "Number:" * String(hTable))
88513>>>>>>>        End
88513>>>>>>>>
88513>>>>>>>
88513>>>>>>>        Move False to Err
88514>>>>>>>
88514>>>>>>>        Structure_Start hToTable DATAFLEX_ID
88515>>>>>>>            Structure_Copy hTable to hToTable
88516>>>>>>>
88516>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
88519>>>>>>>            Set_Attribute DF_FILE_REUSE_DELETED of hToTable to DF_FILE_DELETED_REUSE
88522>>>>>>>            Set_Attribute DF_FILE_MULTIUSER     of hToTable to DF_FILE_USER_MULTI
88525>>>>>>>            Set_Attribute DF_FILE_TRANSACTION   of hToTable to DF_FILE_TRANSACTION_CLIENT_ATOMIC
88528>>>>>>>            Set_Attribute DF_FILE_MAX_RECORDS   of hToTable to iMaxRecords
88531>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88532>>>>>>>
88532>>>>>>>        Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88534>>>>>>>
88534>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88535>>>>>>>        Move (not(Err)) to bOK
88536>>>>>>>        If (bOK = True and bCopyData = True) Begin
88538>>>>>>>            Get ApiTableCopyData hTable sPhysicalName sRootName DATAFLEX_ID to bOK
88539>>>>>>>        End
88539>>>>>>>>
88539>>>>>>>
88539>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
88540>>>>>>>        If (bMertechDriver = True) Begin
88542>>>>>>>            Open hTable
88544>>>>>>>        End
88544>>>>>>>>
88544>>>>>>>
88544>>>>>>>        // This must be after copying data...
88544>>>>>>>        If (Err = False) Begin
88546>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
88549>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
88552>>>>>>>        End
88552>>>>>>>>
88552>>>>>>>        Move (not(Err)) to bOK
88553>>>>>>>
88553>>>>>>>        Function_Return (bOK = True)
88554>>>>>>>    End_Function
88555>>>>>>>
88555>>>>>>>    Function AddFolderDelimiter String sPath Returns String
88557>>>>>>>        String sDirSep
88557>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
88558>>>>>>>        Move (Trim(sPath)) to sPath
88559>>>>>>>        If (Right(sPath, 1) <> sDirSep) Begin
88561>>>>>>>            Move (sPath + sDirSep) to sPath
88562>>>>>>>        End
88562>>>>>>>>
88562>>>>>>>        Function_Return sPath
88563>>>>>>>    End_Function
88564>>>>>>>
88564>>>>>>>    // Creates an SQL Table at the SQL end by its filelist number;
88564>>>>>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
88564>>>>>>>    Function SqlTableCreate Integer hTable Returns Boolean
88566>>>>>>>        String sTableName sSQLString sPath sCreateTable sDriverID
88566>>>>>>>        Integer iDbType
88566>>>>>>>        Boolean bExists
88566>>>>>>>
88566>>>>>>>        Get psDriverID to sDriverID
88567>>>>>>>        Get UtilTableHandleToString hTable to sTableName
88568>>>>>>>        Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
88569>>>>>>>        If (bExists = True) Begin
88571>>>>>>>            Function_Return False
88572>>>>>>>        End
88572>>>>>>>>
88572>>>>>>>
88572>>>>>>>        Get psDataPathFirstPart to sPath
88573>>>>>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
88574>>>>>>>
88574>>>>>>>        Get piDbType to iDbType
88575>>>>>>>        Get _SqlProperTableName sTableName to sTableName
88576>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
88577>>>>>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
88578>>>>>>>
88578>>>>>>>        Move False to Err
88579>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
88580>>>>>>>
88580>>>>>>>        Function_Return (Err = False)
88581>>>>>>>    End_Function
88582>>>>>>>
88582>>>>>>>    // Same as SqlTableCreate but creates an SQL Table at the SQL end by a table name;
88582>>>>>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
88582>>>>>>>    Function SqlTableCreateByTableName String sTableName  Returns Boolean
88584>>>>>>>        String sSQLString sPath sCreateTable sDriverID
88584>>>>>>>        Integer iDbType
88584>>>>>>>        Boolean bExists
88584>>>>>>>
88584>>>>>>>        Get psDriverID to sDriverID
88585>>>>>>>        Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
88586>>>>>>>        If (bExists = True) Begin
88588>>>>>>>            Function_Return False
88589>>>>>>>        End
88589>>>>>>>>
88589>>>>>>>
88589>>>>>>>        Get psDataPathFirstPart to sPath
88590>>>>>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
88591>>>>>>>        If (bExists = True) Begin
88593>>>>>>>            // ToDo: What should we do if an .int file already exists?
88593>>>>>>>        End
88593>>>>>>>>
88593>>>>>>>
88593>>>>>>>        Get piDbType to iDbType
88594>>>>>>>        Get _SqlProperTableName sTableName to sTableName
88595>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
88596>>>>>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
88597>>>>>>>
88597>>>>>>>        Move False to Err
88598>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
88599>>>>>>>
88599>>>>>>>        Function_Return (Err = False)
88600>>>>>>>    End_Function
88601>>>>>>>    
88601>>>>>>>    // ToDo: 2019-09-23 This needs to be finilized 
88601>>>>>>>    // It resets SQL constraints after a Structure_End, if necessary.
88601>>>>>>>    Function SqlTableRecreateConstraints Handle hTable Returns Boolean
88603>>>>>>>        Boolean bOK                                                            
88603>>>>>>>        String sStatement
88603>>>>>>>        Move "ALTER TABLE [dbo].[THREADS] ADD  DEFAULT ((0)) FOR [SEGMENTS]" to sStatement
88604>>>>>>>        Function_Return bOK
88605>>>>>>>    End_Function
88606>>>>>>>    
88606>>>>>>>    // First deletes the data cache file and then drops the passed SQL table.
88606>>>>>>>    // Note: The table needs to exist in filelist.cfg, and it must be possible to open it,
88606>>>>>>>    //       else try using the SqlTableRemoveByTableName message.
88606>>>>>>>    Function SqlTableRemove Handle hTable Returns Boolean
88608>>>>>>>        String sSQLString sPath sDropTable sTableName sDriverID
88608>>>>>>>        Integer iRetval iDbType
88608>>>>>>>        Boolean bExists bMertechDriver bOK
88608>>>>>>>
88608>>>>>>>        Get psDriverID to sDriverID
88609>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
88610>>>>>>>        Get UtilTableHandleToString hTable to sTableName
88611>>>>>>>        Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
88612>>>>>>>        If (bExists = False) Begin
88614>>>>>>>            Function_Return False
88615>>>>>>>        End
88615>>>>>>>>
88615>>>>>>>
88615>>>>>>>        Get psDataPathFirstPart to sPath
88616>>>>>>>        Get UtilDeleteCacheFile sTableName to iRetval
88617>>>>>>>
88617>>>>>>>        Get piDbType to iDbType
88618>>>>>>>        Get _SqlProperTableName sTableName to sTableName
88619>>>>>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
88620>>>>>>>        Move (sDropTable * String(sTableName)) to sSQLString
88621>>>>>>>
88621>>>>>>>        Move False to Err
88622>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
88623>>>>>>>
88623>>>>>>>        // We also need to remove the cache-file since the table has been changed
88623>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
88624>>>>>>>
88624>>>>>>>        Function_Return (Err = False)
88625>>>>>>>    End_Function
88626>>>>>>>
88626>>>>>>>    // First deletes the data cache file and then drops the passed data table.
88626>>>>>>>    Function SqlTableRemoveByTableName String sTableName Returns Boolean
88628>>>>>>>        String sSQLString sPath sDropTable sVal sSchema sDriverID
88628>>>>>>>        Integer iRetval iDbType
88628>>>>>>>        Boolean bMertechDriver bOK
88628>>>>>>>
88628>>>>>>>        Get psDriverID to sDriverID
88629>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
88630>>>>>>>        Get psDataPathFirstPart to sPath
88631>>>>>>>        Get UtilDeleteCacheFile sTableName to iRetval
88632>>>>>>>
88632>>>>>>>        Get piDbType to iDbType
88633>>>>>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
88634>>>>>>>        Get psSchema to sSchema
88635>>>>>>>        If (sSchema = "") Begin
88637>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
88638>>>>>>>        End
88638>>>>>>>>
88638>>>>>>>        Move (Uppercase(sTableName)) to sVal
88639>>>>>>>        If (not(sVal contains (sSchema + "."))) Begin
88641>>>>>>>            Move (Lowercase(sSchema) + "." + sTableName) to sTableName
88642>>>>>>>        End
88642>>>>>>>>
88642>>>>>>>        Move (sDropTable * String(sTableName)) to sSQLString
88643>>>>>>>
88643>>>>>>>        Move False to Err
88644>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
88645>>>>>>>
88645>>>>>>>        // We also need to remove the cache-file since the table has been changed
88645>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
88646>>>>>>>
88646>>>>>>>        Function_Return (Err = False)
88647>>>>>>>    End_Function
88648>>>>>>>
88648>>>>>>>    // *** Sql View Messages ***
88648>>>>>>>
88648>>>>>>>    // First deletes the data cache file and then drops the passed Sql data view.
88648>>>>>>>    Function SqlViewRemove String sDataView Returns Boolean
88650>>>>>>>        String sDriverID sSQLString sDropViewKeyWord
88650>>>>>>>        Integer iRetval
88650>>>>>>>        Boolean bMertechDriver bOK
88650>>>>>>>
88650>>>>>>>        Get psDriverID to sDriverID
88651>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
88652>>>>>>>        Get UtilDeleteCacheFile sDataView to iRetval
88653>>>>>>>
88653>>>>>>>        Get _SqlFindKeyWord CI_SQLDropView to sDropViewKeyWord
88654>>>>>>>        Move (sDropViewKeyWord * String(sDataView)) to sSQLString
88655>>>>>>>        Set psSQLStatementString to sSQLString
88656>>>>>>>
88656>>>>>>>        // As we don't check if the view exist or not, it might happen
88656>>>>>>>        // that it doesn't and that would through an error, so guard for that eventuality (just ignore it).
88656>>>>>>>        Move False to Err
88657>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88658>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
88659>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88660>>>>>>>        Move 0 to LastErr
88661>>>>>>>
88661>>>>>>>        // We also need to remove the cache-file since the table has been changed
88661>>>>>>>        Get UtilDeleteCacheFile sDataView to bOK
88662>>>>>>>
88662>>>>>>>        Function_Return (Err = False)
88663>>>>>>>    End_Function
88664>>>>>>>
88664>>>>>>>    Function SqlTableRename Handle hTable String sCurrentTableName String sNewtTableName Returns Boolean
88666>>>>>>>        Boolean bOK
88666>>>>>>>        Integer iDbType
88666>>>>>>>        String sDriverID sAlterTable sRenameTable sSQLTo sSQLString
88666>>>>>>>
88666>>>>>>>        Get psDriverID to sDriverID
88667>>>>>>>        Get piDbType   to iDbType
88668>>>>>>>
88668>>>>>>>        Case Begin
88668>>>>>>>            Case (iDbType = EN_DbTypeDB2)
88670>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
88671>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
88672>>>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
88673>>>>>>>            Break
88674>>>>>>>
88674>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
88677>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
88678>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
88679>>>>>>>                Move (sRenameTable * "'" - sCurrentTableName - "', '" - String(sNewtTableName) - "'") to sSQLString
88680>>>>>>>            Break
88681>>>>>>>
88681>>>>>>>            Case (iDbType = EN_DbTypeOracle)
88684>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
88685>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
88686>>>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
88687>>>>>>>            Break
88688>>>>>>>
88688>>>>>>>            Case (iDbType = EN_DbTypePostgre)
88691>>>>>>>                Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
88692>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
88693>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
88694>>>>>>>                Move (sAlterTable * sCurrentTableName * sRenameTable * sSQLTo * String(sNewtTableName)) to sSQLString
88695>>>>>>>            Break
88696>>>>>>>
88696>>>>>>>            Case (iDbType = EN_DbTypeMySQL)
88699>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
88700>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
88701>>>>>>>                Move (Replaces("-", sNewtTableName, "_")) to sNewtTableName
88702>>>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
88703>>>>>>>            Break
88704>>>>>>>        Case End
88704>>>>>>>
88704>>>>>>>        Move False to Err
88705>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
88706>>>>>>>        Move (Err = False) to bOK
88707>>>>>>>
88707>>>>>>>        Function_Return bOK
88708>>>>>>>    End_Function
88709>>>>>>>
88709>>>>>>>    // * Dummy function for the Studio's Code Explorer *
88709>>>>>>>    Function SQL_COLUMN_FUNCTIONS Returns Boolean
88711>>>>>>>        Function_Return False
88712>>>>>>>    End_Function
88713>>>>>>>
88713>>>>>>>    // Sample: Get SqlColumnAdd MyTable.File_Number "NewColumnName" True "InitValue" DF_ASCII_DUF 35
88713>>>>>>>    Function SqlColumnAdd Integer hTable String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
88715>>>>>>>        Integer iLength iDecimals
88715>>>>>>>        String sColumnValue
88715>>>>>>>        String sTableName sDriverID
88715>>>>>>>        Boolean bOK bInitializeValue
88715>>>>>>>
88715>>>>>>>        Get psDriverID to sDriverID
88716>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
88717>>>>>>>        If (bOK = False) Begin
88719>>>>>>>            Function_Return False
88720>>>>>>>        End
88720>>>>>>>>
88720>>>>>>>
88720>>>>>>>        Get UtilTableHandleToString hTable to sTableName
88721>>>>>>>        If (sTableName = "") Begin
88723>>>>>>>            Function_Return False
88724>>>>>>>        End
88724>>>>>>>>
88724>>>>>>>
88724>>>>>>>        If (num_arguments > 3) Begin
88726>>>>>>>            Move iLen     to iLength
88727>>>>>>>            Move iDec     to iDecimals
88728>>>>>>>            Move bInitVal to bInitializeValue
88729>>>>>>>            Move sColVal  to sColumnValue
88730>>>>>>>        End
88730>>>>>>>>
88730>>>>>>>
88730>>>>>>>        Get SqlColumnAddByTableName sTableName sColumnName iDataType iLen iDecimals bInitializeValue sColumnValue to bOK
88731>>>>>>>
88731>>>>>>>        Function_Return (bOK = True)
88732>>>>>>>    End_Function
88733>>>>>>>
88733>>>>>>>    // Sample: Get SqlColumnAddByTableName "MyTable" "NewColumnName" DF_ASCII_DUF 35 0 True "InitValue"
88733>>>>>>>    Function SqlColumnAddByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
88735>>>>>>>        Integer iDbType iLength iDecimals iDriver
88735>>>>>>>        String sStmt sAlterTable sAddColumn sVal sDataType sLengthAndDecimals sColumnValue
88735>>>>>>>        String sDriverID sNotNull
88735>>>>>>>        Boolean bOK bInitializeValue bRetval bFixed bDriverIgnoreErrorState bIsMertechDriver
88735>>>>>>>        Handle hTable
88735>>>>>>>
88735>>>>>>>        Get psDriverID to sDriverID
88736>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
88737>>>>>>>        If (bOK = False) Begin
88739>>>>>>>            Function_Return True
88740>>>>>>>        End
88740>>>>>>>>
88740>>>>>>>
88740>>>>>>>        Get UtilTableNameToHandle sTableName to hTable
88741>>>>>>>        If (hTable = 0) Begin
88743>>>>>>>            Get NextFreeFilelistSlot to hTable
88744>>>>>>>        End
88744>>>>>>>>
88744>>>>>>>
88744>>>>>>>        Get piDbType to iDbType
88745>>>>>>>        // If a field/column already exists; we just ignore the request to not add unneccesary errors to the log.
88745>>>>>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
88746>>>>>>>        If (Uppercase(sVal) = Uppercase(sColumnName)) Begin
88748>>>>>>>            Function_Return True
88749>>>>>>>        End
88749>>>>>>>>
88749>>>>>>>
88749>>>>>>>        Get DriverIndex sDriverID to iDriver
88750>>>>>>>        Get IsMertechDriver sDriverID to bIsMertechDriver
88751>>>>>>>        If (bIsMertechDriver = False) Begin
88753>>>>>>>            Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
88756>>>>>>>            Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
88759>>>>>>>        End
88759>>>>>>>>
88759>>>>>>>
88759>>>>>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
88760>>>>>>>        If (num_arguments > 3) Begin
88762>>>>>>>            Move iLen     to iLength
88763>>>>>>>            Move iDec     to iDecimals
88764>>>>>>>            Move bInitVal to bInitializeValue
88765>>>>>>>            Move sColVal  to sColumnValue
88766>>>>>>>        End
88766>>>>>>>>
88766>>>>>>>
88766>>>>>>>        Get _SqlProperTableName sTableName   to sTableName
88767>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
88768>>>>>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
88769>>>>>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
88770>>>>>>>
88770>>>>>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
88771>>>>>>>        If (bFixed = False) Begin
88773>>>>>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
88774>>>>>>>        End
88774>>>>>>>>
88774>>>>>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
88775>>>>>>>
88775>>>>>>>        Move False to Err
88776>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
88777>>>>>>>
88777>>>>>>>        If (bInitializeValue = True and Err = False) Begin
88779>>>>>>>            Get SQLColumnUpdateValue hTable sColumnName sColumnValue to bRetval
88780>>>>>>>        End
88780>>>>>>>>
88780>>>>>>>
88780>>>>>>>        If (Err = False) Begin
88782>>>>>>>            Get SqlUtilAdjustAuxFiles hTable sTableName sColumnName to bOK
88783>>>>>>>        End
88783>>>>>>>>
88783>>>>>>>
88783>>>>>>>        Move (not(Err)) to bRetval
88784>>>>>>>
88784>>>>>>>        // We also need to remove the cache-file since the table has been changed
88784>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
88785>>>>>>>        If (bIsMertechDriver = False) Begin
88787>>>>>>>            Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
88790>>>>>>>        End
88790>>>>>>>>
88790>>>>>>>        Function_Return bRetval
88791>>>>>>>    End_Function
88792>>>>>>>
88792>>>>>>>    // To update all current rows for a table column with a common value.
88792>>>>>>>    Function SqlColumnUpdateValue Handle hTable String sColumnName String sColumnValue Returns Boolean
88794>>>>>>>        String sDriverID sTableName sUpdate sSet sNoCountOn sSqlSafe_Updates sStmt
88794>>>>>>>        Boolean bRetval bSQLDriver
88794>>>>>>>        Integer iCurrErr iDbType
88794>>>>>>>
88794>>>>>>>        Move False to bRetval
88795>>>>>>>        Get piDbType to iDbType
88796>>>>>>>        Get psDriverID to sDriverID
88797>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
88798>>>>>>>        If (bSQLDriver = False) Begin
88800>>>>>>>            Function_Return bRetval
88801>>>>>>>        End
88801>>>>>>>>
88801>>>>>>>        Get UtilTableHandleToString hTable to sTableName
88802>>>>>>>
88802>>>>>>>        Move Err to iCurrErr
88803>>>>>>>        Move False to Err
88804>>>>>>>        Get _SqlFindKeyWord CI_SQLUpdate       to sUpdate
88805>>>>>>>        Get _SqlFindKeyWord CI_SQLSet          to sSet
88806>>>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountOn
88807>>>>>>>        If (sDriverID = MDSMySQL) Begin
88809>>>>>>>            Get _SqlFindKeyWord CI_SQL_SAFE_UPDATES to sSqlSafe_Updates
88810>>>>>>>            Move (sSet * sSqlSafe_Updates + "=0;" * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'" * sSet * sSqlSafe_Updates + "=1") to sStmt
88811>>>>>>>        End
88811>>>>>>>>
88811>>>>>>>        // If MySQL and DAW's ODBC driver is used we need to do it slightly different.
88811>>>>>>>        If (iDbType = EN_DbTypeMySQL) Begin
88813>>>>>>>            Get _SqlFindKeyWord CI_SQL_SAFE_UPDATES to sSqlSafe_Updates
88814>>>>>>>            Move (sSet * sSqlSafe_Updates + "=0;" * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'") to sStmt
88815>>>>>>>        End
88815>>>>>>>>
88815>>>>>>>        Else Begin
88816>>>>>>>            Move (sNoCountOn * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'") to sStmt
88817>>>>>>>        End
88817>>>>>>>>
88817>>>>>>>
88817>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
88818>>>>>>>        Move (Err = False) to bRetval
88819>>>>>>>        Move iCurrErr to Err
88820>>>>>>>
88820>>>>>>>        Function_Return bRetval
88821>>>>>>>    End_Function
88822>>>>>>>
88822>>>>>>>    // The fourth & fifth arguments are optional, depending on the iDataType
88822>>>>>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
88822>>>>>>>    Function SqlColumnChange Handle hTable String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
88824>>>>>>>        String sDriverID sTableName
88824>>>>>>>        Boolean bOK
88824>>>>>>>
88824>>>>>>>        Get psDriverID to sDriverID
88825>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
88826>>>>>>>        If (bOK = False) Begin
88828>>>>>>>            Function_Return False
88829>>>>>>>        End
88829>>>>>>>>
88829>>>>>>>
88829>>>>>>>        Get UtilTableHandleToString hTable to sTableName
88830>>>>>>>        Get SqlColumnChangeByTableName sTableName sColumnName iDataType iLen iDec to bOK
88831>>>>>>>
88831>>>>>>>        Function_Return (Err = False)
88832>>>>>>>    End_Function
88833>>>>>>>
88833>>>>>>>    // Same as SqlColumnChange but instead of passing a filelist number; pass the table name as a string.
88833>>>>>>>    // The fourth & fifth arguments are optional, depending on the iDataType
88833>>>>>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
88833>>>>>>>    Function SqlColumnChangeByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
88835>>>>>>>        Integer iDbType iLength iDecimals
88835>>>>>>>        String sDriverID sStmt sAlterTable sAlterColumn sDataType sLengthAndDecimals sNotNull
88835>>>>>>>        Boolean bExists bOK bFixed
88835>>>>>>>        Handle hTable
88835>>>>>>>
88835>>>>>>>        Get psDriverID to sDriverID
88836>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
88837>>>>>>>        If (bOK = False) Begin
88839>>>>>>>            Function_Return False
88840>>>>>>>        End
88840>>>>>>>>
88840>>>>>>>
88840>>>>>>>        Get UtilTableNameToHandle sTableName to hTable
88841>>>>>>>        If (hTable = 0) Begin
88843>>>>>>>            Get NextFreeFilelistSlot to hTable
88844>>>>>>>        End
88844>>>>>>>>
88844>>>>>>>        Get SQLUtilColumnExists sTableName sColumnName to bExists
88845>>>>>>>        If (bExists = False) Begin
88847>>>>>>>            Function_Return False
88848>>>>>>>        End
88848>>>>>>>>
88848>>>>>>>
88848>>>>>>>        If (num_arguments > 3) Begin
88850>>>>>>>            Move iLen to iLength
88851>>>>>>>        End
88851>>>>>>>>
88851>>>>>>>        If (num_arguments > 4) Begin
88853>>>>>>>            Move iDec to iDecimals
88854>>>>>>>        End
88854>>>>>>>>
88854>>>>>>>
88854>>>>>>>        Get piDbType to iDbType
88855>>>>>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
88856>>>>>>>
88856>>>>>>>        Move False to Err
88857>>>>>>>        Get _SqlProperTableName sTableName    to sTableName
88858>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
88859>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterColumn to sAlterColumn
88860>>>>>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
88861>>>>>>>
88861>>>>>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
88862>>>>>>>        If (bFixed = False) Begin
88864>>>>>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
88865>>>>>>>        End
88865>>>>>>>>
88865>>>>>>>
88865>>>>>>>        Move (sAlterTable * sTableName * sAlterColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
88866>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
88867>>>>>>>
88867>>>>>>>        // We also need to remove the cache-file since the table has been changed
88867>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
88868>>>>>>>
88868>>>>>>>        Function_Return (Err = False)
88869>>>>>>>    End_Function
88870>>>>>>>
88870>>>>>>>    Function SqlColumnDefaultValue Handle hTable Integer iColumn String sValue Returns Boolean
88872>>>>>>>        Boolean bOK bErr bIsSQLDriver
88872>>>>>>>        String sDriverID
88872>>>>>>>        Integer iDataType
88872>>>>>>>
88872>>>>>>>        Get psDriverID to sDriverID
88873>>>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
88874>>>>>>>        If (bIsSQLDriver = False) Begin
88876>>>>>>>            Function_Return False
88877>>>>>>>        End
88877>>>>>>>>
88877>>>>>>>
88877>>>>>>>        Move Err to bErr
88878>>>>>>>        Move False to bErr
88879>>>>>>>
88879>>>>>>>        // There seems to be a problem with the ODBC_DRV driver that sometimes
88879>>>>>>>        // inserts randomly character(10) and spaces, so we correct from that here:
88879>>>>>>>        Move (Replaces(Character(10), Trim(sValue), "")) to sValue
88880>>>>>>>        Get_Attribute DF_FIELD_TYPE of hTable iColumn to iDataType
88883>>>>>>>        If (iDataType = DF_BCD and Left(sValue, 1 <> "[")) Begin
88885>>>>>>>            Move ("[" + String(sValue) + "]") to sValue
88886>>>>>>>        End
88886>>>>>>>>
88886>>>>>>>
88886>>>>>>>        Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sValue
88889>>>>>>>        Move (not(Err)) to bOK
88890>>>>>>>        Move bErr to Err
88891>>>>>>>
88891>>>>>>>        Function_Return bOK
88892>>>>>>>    End_Function
88893>>>>>>>
88893>>>>>>>    Function SqlColumnNullable Handle hTable Integer iColumn Boolean bNullable Returns Boolean
88895>>>>>>>        Boolean bOK bErr bCurrentState bOpen bIsSQLDriver
88895>>>>>>>        String sDriverID
88895>>>>>>>
88895>>>>>>>        Get psDriverID to sDriverID
88896>>>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
88897>>>>>>>        If (bIsSQLDriver = False) Begin
88899>>>>>>>            Function_Return False
88900>>>>>>>        End
88900>>>>>>>>
88900>>>>>>>
88900>>>>>>>        Move Err to bErr
88901>>>>>>>        Move False to bErr
88902>>>>>>>        Get_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bCurrentState
88905>>>>>>>        If (bNullable = bCurrentState) Begin
88907>>>>>>>            Function_Return True
88908>>>>>>>        End
88908>>>>>>>>
88908>>>>>>>
88908>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
88911>>>>>>>        If (bOpen = False) Begin
88913>>>>>>>            Get AutoConnectionIDLogin to bOK
88914>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
88915>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
88916>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88917>>>>>>>            Open hTable
88919>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
88920>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
88921>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88922>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
88925>>>>>>>        End
88925>>>>>>>>
88925>>>>>>>        If (bOpen = True) Begin
88927>>>>>>>            Structure_Start hTable sDriverID
88928>>>>>>>                Set_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bNullable
88931>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
88932>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88934>>>>>>>            Set Action_Text of ghoStatusPanel to ""
88935>>>>>>>        End
88935>>>>>>>>
88935>>>>>>>
88935>>>>>>>        Move (not(Err)) to bOK
88936>>>>>>>        Move bErr to Err
88937>>>>>>>
88937>>>>>>>        Function_Return bOK
88938>>>>>>>    End_Function
88939>>>>>>>
88939>>>>>>>    // Drop column by its table handle
88939>>>>>>>    Function SqlColumnRemove Handle hTable String sColumnName Returns Boolean
88941>>>>>>>        String sDriverID sTableName
88941>>>>>>>        Boolean bOK
88941>>>>>>>
88941>>>>>>>        Get psDriverID to sDriverID
88942>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
88943>>>>>>>        If (bOK = False) Begin
88945>>>>>>>            Function_Return False
88946>>>>>>>        End
88946>>>>>>>>
88946>>>>>>>
88946>>>>>>>        Get UtilTableHandleToString hTable to sTableName
88947>>>>>>>        If (sTableName = "") Begin
88949>>>>>>>            Function_Return False
88950>>>>>>>        End
88950>>>>>>>>
88950>>>>>>>
88950>>>>>>>        Get SqlColumnRemoveByTableName sTableName sColumnName to bOK
88951>>>>>>>
88951>>>>>>>        Function_Return (bOK = True)
88952>>>>>>>    End_Function
88953>>>>>>>
88953>>>>>>>    // Drop column by its table name as a string.
88953>>>>>>>    Function SqlColumnRemoveByTableName String sTableName String sColumnName Returns Boolean
88955>>>>>>>        Integer iDbType iDriver
88955>>>>>>>        String sDriverID sStmt sAlterTable sDropColumn
88955>>>>>>>        Boolean bExists bOK bRetval bDriverIgnoreErrorState
88955>>>>>>>        Handle hTable
88955>>>>>>>
88955>>>>>>>        Get psDriverID to sDriverID
88956>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
88957>>>>>>>        If (bOK = False) Begin
88959>>>>>>>            Function_Return False
88960>>>>>>>        End
88960>>>>>>>>
88960>>>>>>>
88960>>>>>>>        Get DriverIndex sDriverID to iDriver
88961>>>>>>>        Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
88964>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
88967>>>>>>>
88967>>>>>>>        Get UtilTableNameToHandle sTableName to hTable
88968>>>>>>>        If (hTable <> 0) Begin
88970>>>>>>>            Get SQLUtilColumnExists sTableName sColumnName to bExists
88971>>>>>>>            If (bExists = False) Begin
88973>>>>>>>                Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
88976>>>>>>>                Function_Return False
88977>>>>>>>            End
88977>>>>>>>>
88977>>>>>>>        End
88977>>>>>>>>
88977>>>>>>>
88977>>>>>>>        Get piDbType to iDbType
88978>>>>>>>        If (iDbType = EN_DbTypeMSSQL) Begin
88980>>>>>>>            Get _SqlUtilRemoveTableColumnMSSQL sTableName sColumnName to bOK
88981>>>>>>>            Get UtilDeleteCacheFile sTableName to bOK
88982>>>>>>>            Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
88985>>>>>>>            Function_Return bOK
88986>>>>>>>        End
88986>>>>>>>>
88986>>>>>>>
88986>>>>>>>        Move False to Err
88987>>>>>>>        Get _SqlProperTableName sTableName    to sTableName
88988>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
88989>>>>>>>        Get _SqlFindKeyWord CI_SQLDropColumn  to sDropColumn
88990>>>>>>>
88990>>>>>>>        Move (sAlterTable * sTableName * sDropColumn * sColumnName) to sStmt
88991>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
88992>>>>>>>        Move (not(Err)) to bRetval
88993>>>>>>>
88993>>>>>>>        // We also need to remove the cache-file since the table has been changed
88993>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
88994>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
88997>>>>>>>
88997>>>>>>>        Function_Return bRetval
88998>>>>>>>    End_Function
88999>>>>>>>
88999>>>>>>>    // Rename a field/column by table handle (filelist number)
88999>>>>>>>    Function SqlColumnRename Integer hTable String sColumnName String sNewColumnName Returns Boolean
89001>>>>>>>        String sDriverID sTableName
89001>>>>>>>        Boolean bOK
89001>>>>>>>
89001>>>>>>>        Get psDriverID to sDriverID
89002>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
89003>>>>>>>        If (bOK = False) Begin
89005>>>>>>>            Function_Return False
89006>>>>>>>        End
89006>>>>>>>>
89006>>>>>>>
89006>>>>>>>        Get UtilTableHandleToString hTable to sTableName
89007>>>>>>>        Get SqlColumnRenameByTableName sTableName sColumnName sNewColumnName to bOK
89008>>>>>>>
89008>>>>>>>        Function_Return (Err = False)
89009>>>>>>>    End_Function
89010>>>>>>>
89010>>>>>>>    // Rename a field/column by table name.
89010>>>>>>>    Function SqlColumnRenameByTableName String sTableName String sColumnName String sNewColumnName Returns Boolean
89012>>>>>>>        Integer iDbType iDataType
89012>>>>>>>        String sDriverID sStmt sAlterTable sRenameColumn sVal sColumnKeyWord sOrgTableName sDatabase sDataType
89012>>>>>>>        Boolean bOK bRetval
89012>>>>>>>        Handle hTable
89012>>>>>>>
89012>>>>>>>        Move sTableName to sOrgTableName
89013>>>>>>>        Get psDriverID to sDriverID
89014>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
89015>>>>>>>        If (bOK = False) Begin
89017>>>>>>>            Function_Return False
89018>>>>>>>        End
89018>>>>>>>>
89018>>>>>>>
89018>>>>>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
89019>>>>>>>        If (sVal = "") Begin
89021>>>>>>>            Function_Return False
89022>>>>>>>        End
89022>>>>>>>>
89022>>>>>>>
89022>>>>>>>        Get piDbType to iDbType
89023>>>>>>>        Get _SqlFindKeyWord CI_SQLColumn       to sColumnKeyWord
89024>>>>>>>        Get _SqlProperTableName sTableName     to sTableName
89025>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable   to sAlterTable
89026>>>>>>>        Get _SqlFindKeyWord CI_SQLRenameColumn to sRenameColumn
89027>>>>>>>
89027>>>>>>>        Case Begin
89027>>>>>>>            Case (iDbType = EN_dbTypeMSSQL)
89029>>>>>>>                Move (sRenameColumn * "'" + sTableName + "." + sColumnName + "'," * "'" + sNewColumnName + "'," * "'" + sColumnKeyWord + "'") to sStmt
89030>>>>>>>                Case Break
89031>>>>>>>            // Alter table "SYS"."Customer" rename column "Comments" to "NewColumnName"
89031>>>>>>>            Case (iDbType = EN_dbTypeOracle)
89034>>>>>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
89035>>>>>>>                Case Break
89036>>>>>>>            // ALTER TABLE Schema.TableName RENAME COLUMN "deptnumb" TO "deptnum"
89036>>>>>>>            Case (iDbType = EN_dbTypeDB2)
89039>>>>>>>                Move (sAlterTable *  sTableName * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
89040>>>>>>>                Case Break
89041>>>>>>>            // ALTER TABLE "Customer" RENAME COLUMN "Comments" TO "NewColumnName"
89041>>>>>>>            Case (iDbType = EN_dbTypePostgre)
89044>>>>>>>                Move sOrgTableName to sTableName
89045>>>>>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
89046>>>>>>>                Case Break
89047>>>>>>>            Case (iDbType = EN_dbTypeMySQL)
89050>>>>>>>                // ALTER TABLE orderentry.customer CHANGE Comments NewColumnName text // Note: The last token is the column type!
89050>>>>>>>                Move sOrgTableName to sTableName
89051>>>>>>>                Get psDatabase to sDatabase
89052>>>>>>>                Get UtilTableNameToHandle sTableName to hTable
89053>>>>>>>                If (hTable = 0) Begin
89055>>>>>>>                    Get UtilTableOpen hTable sTableName DF_SHARE to bOK
89056>>>>>>>                    If (bOK = False) Begin
89058>>>>>>>                        Function_Return False
89059>>>>>>>                    End
89059>>>>>>>>
89059>>>>>>>                    Get NextFreeFilelistSlot to hTable
89060>>>>>>>                End
89060>>>>>>>>
89060>>>>>>>                Else Begin
89061>>>>>>>                    Open hTable
89063>>>>>>>                End
89063>>>>>>>>
89063>>>>>>>                Get SQLColumnType sDriverID hTable sTableName sColumnName to iDataType
89064>>>>>>>                Get UtilColumnTypeToString sDriverID iDbType iDataType    to sDataType
89065>>>>>>>                Move (sAlterTable * sDatabase + "." + sTableName * sRenameColumn * sColumnName * sNewColumnName * sDataType) to sStmt
89066>>>>>>>                Case Break
89067>>>>>>>            Case Else
89067>>>>>>>                Move (sAlterTable * "'" + sTableName + "'" * sRenameColumn * "'" + sTableName + "." + sColumnName + "'" * "TO" * "'" + sNewColumnName + "'") to sStmt
89068>>>>>>>        Case End
89068>>>>>>>
89068>>>>>>>        Move False to Err
89069>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
89070>>>>>>>        Move (Err = False) to bRetval
89071>>>>>>>        // We also need to remove the cache-file since the table has been changed
89071>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
89072>>>>>>>
89072>>>>>>>        Function_Return bRetval
89073>>>>>>>    End_Function
89074>>>>>>>
89074>>>>>>>    Function SqlColumnType String sDriverID Handle hTable String sTableName String sColumnName Returns Integer
89076>>>>>>>        Handle hoSQLHandler hSQLConnect hStmt
89076>>>>>>>        Boolean bMertechDriver
89076>>>>>>>        Integer iNumCols iCount iDataType
89076>>>>>>>        String sValue
89076>>>>>>>
89076>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
89077>>>>>>>        If (bMertechDriver = False) Begin
89079>>>>>>>            Get phoSQLManager to hoSQLHandler
89080>>>>>>>        End
89080>>>>>>>>
89080>>>>>>>        Else Begin
89081>>>>>>>            Get _MertechSQLManagerHandle to hoSQLHandler
89082>>>>>>>        End
89082>>>>>>>>
89082>>>>>>>
89082>>>>>>>        Get SQLFileConnect of hoSQLHandler hTable to hSQLConnect
89083>>>>>>>        If (hSQLConnect <> 0) Begin
89085>>>>>>>            Get SQLOpen of hSQLConnect to hStmt
89086>>>>>>>            If (hStmt <> 0) Begin
89088>>>>>>>                Send SQLExecDirect of hStmt ("select * from" * sTableName)
89089>>>>>>>
89089>>>>>>>                Get SQLStmtAttribute of hStmt SQLSTMTATTRIB_COLUMNCOUNT to iNumCols
89090>>>>>>>                For iCount from 1 to iNumCols
89096>>>>>>>>
89096>>>>>>>                    Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_LABEL to sValue
89097>>>>>>>                    If (Lowercase(sValue) = Lowercase(sColumnName)) Begin
89099>>>>>>>                        Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_SQLTYPE to iDataType
89100>>>>>>>                        Move iNumCols to iCount // We're out of here
89101>>>>>>>                    End
89101>>>>>>>>
89101>>>>>>>                Loop
89102>>>>>>>>
89102>>>>>>>
89102>>>>>>>                Send SQLClose of hStmt
89103>>>>>>>            End
89103>>>>>>>>
89103>>>>>>>            Send SQLDisconnect of hSQLConnect
89104>>>>>>>        End
89104>>>>>>>>
89104>>>>>>>
89104>>>>>>>        Function_Return iDataType
89105>>>>>>>    End_Function
89106>>>>>>>
89106>>>>>>>    // * Dummy function for the Studio's Code Explorer *
89106>>>>>>>    Function SQL_EXECUTE_FUNCTIONS Returns Boolean
89108>>>>>>>        Function_Return False
89109>>>>>>>    End_Function
89110>>>>>>>
89110>>>>>>>    Procedure SqlUtilExecuteQuery String sStmt String sDriverID Boolean bShowProgr
89112>>>>>>>        String sMessage // sConnectionString
89112>>>>>>>        Handle hoSqlHandler hoSQLConnect hoStmt hoError
89112>>>>>>>        Integer i iMsgs iFetchResult iRowType iRows iErr iMessage iLastErr
89112>>>>>>>        String[] sMsg aSQLQueryMessages aSQLFetchResults
89115>>>>>>>        DateTime dtQueryExecStart dtQueryExecEnd dtFetchStart dtFetchEnd
89115>>>>>>>        TimeSpan tsQuery tsFetch
89115>>>>>>>        tSqlErrorArray aSqlErrorArray
89115>>>>>>>        tSqlErrorArray aSqlErrorArray
89115>>>>>>>        Boolean bOK bMertechDriver bShowProgress
89115>>>>>>>        tSQLConnection SQLConnection
89115>>>>>>>        tSQLConnection SQLConnection
89115>>>>>>>
89115>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
89116>>>>>>>        If (bOK = False) Begin
89118>>>>>>>            Procedure_Return
89119>>>>>>>        End
89119>>>>>>>>
89119>>>>>>>
89119>>>>>>>        If (num_arguments > 2) Begin
89121>>>>>>>            Move bShowProgr to bShowProgress
89122>>>>>>>        End
89122>>>>>>>>
89122>>>>>>>
89122>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
89123>>>>>>>
89123>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
89124>>>>>>>        If (bMertechDriver = True) Begin
89126>>>>>>>            Get _MertechSQLConnect sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
89127>>>>>>>        End
89127>>>>>>>>
89127>>>>>>>        If (bMertechDriver = False) Begin
89129>>>>>>>            Get phoSQLManager to hoSqlHandler
89130>>>>>>>            Send SqlSetConnect of hoSqlHandler sDriverID SQLConnection.sConnectionString
89131>>>>>>>            Get SqlConnect     of hoSqlHandler "" "" to hoSQLConnect
89132>>>>>>>        End
89132>>>>>>>>
89132>>>>>>>
89132>>>>>>>        If (hoSQLConnect <> 0) Begin
89134>>>>>>>            Get SqlOpen of hoSQLConnect to hoStmt
89135>>>>>>>            If (hoStmt <> 0) Begin
89137>>>>>>>                // record starting date/time stamp
89137>>>>>>>                Move (CurrentDateTime()) to dtQueryExecStart
89138>>>>>>>                // turn on error handling if enabled
89138>>>>>>>                If (pbHandleQueryErrors(Self)) Begin
89140>>>>>>>                    Set pbSqlError to False
89141>>>>>>>                    Set paSqlErrorArray to aSqlErrorArray
89142>>>>>>>                    Move Error_Object_Id to hoError
89143>>>>>>>                    If (ghoDbUpdateHandler <> 0) Begin
89145>>>>>>>                        Move ghoDbUpdateHandler to Error_Object_Id
89146>>>>>>>                    End
89146>>>>>>>>
89146>>>>>>>                    Else Begin
89147>>>>>>>                        Move Self to Error_Object_Id
89148>>>>>>>                    End
89148>>>>>>>>
89148>>>>>>>                End
89148>>>>>>>>
89148>>>>>>>
89148>>>>>>>                // Before we execute the statement; save it so we can display the faulty statement in the error log.
89148>>>>>>>                Set psSQLStatementString to sStmt
89149>>>>>>>                Send Cursor_Wait of Cursor_Control
89150>>>>>>>                Send SqlExecDirect of hoStmt sStmt
89151>>>>>>>                Send Cursor_Ready of Cursor_Control
89152>>>>>>>
89152>>>>>>>                If (pbHandleQueryErrors(Self)) Begin
89154>>>>>>>                    Move hoError to Error_Object_Id
89155>>>>>>>                End
89155>>>>>>>>
89155>>>>>>>
89155>>>>>>>                Move 0 to iMsgs
89156>>>>>>>                // ToDo: There seems to be some issues with this code and Mertech drivers that makes
89156>>>>>>>                // the debugger crash in some cases like an error in the ESQL statement; so we exclude it for now.
89156>>>>>>>                If (bMertechDriver = False) Begin
89158>>>>>>>                    Move Err to iErr
89159>>>>>>>                    Move LastErr to iLastErr
89160>>>>>>>                    Get SqlStmtAttribute of hoStmt SQLSTMTATTRIB_NUMMESSAGES   to iMsgs
89161>>>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT      to iRows
89162>>>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
89163>>>>>>>                    Send _SqlColumnInfo hoStmt
89164>>>>>>>                    Send Ignore_Error of Error_Object_Id 12289
89165>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89166>>>>>>>                    Repeat
89166>>>>>>>>
89166>>>>>>>                        Get SqlFetch of hoStmt to iFetchResult
89167>>>>>>>                        If (iFetchResult <> 0) Begin
89169>>>>>>>                            Get SQLColumnValue of hoStmt 1 to aSQLFetchResults[SizeOfArray(aSQLFetchResults)]
89170>>>>>>>                        End
89170>>>>>>>>
89170>>>>>>>                    Until (iFetchResult = 0)
89172>>>>>>>                    Send Trap_Error of Error_Object_Id 12289
89173>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
89174>>>>>>>                    Move iErr to Err
89175>>>>>>>                    Move iLastErr to LastErr
89176>>>>>>>                    Set paSQLFetchResults to aSQLFetchResults
89177>>>>>>>                End
89177>>>>>>>>
89177>>>>>>>
89177>>>>>>>                Set piRows    to iRows
89178>>>>>>>                Set piRowType to iRowType
89179>>>>>>>                Move (CurrentDateTime()) to dtQueryExecEnd
89180>>>>>>>                Move (CurrentDateTime()) to dtFetchStart
89181>>>>>>>
89181>>>>>>>                If (iMsgs <> 0) Begin
89183>>>>>>>                    If (ghoDbUpdateHandler > 0) Begin
89185>>>>>>>                        Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
89186>>>>>>>                    End
89186>>>>>>>>
89186>>>>>>>                    For i from 1 to iMsgs
89192>>>>>>>>
89192>>>>>>>                        Get SqlGetMessage of hoStmt i to sMessage
89193>>>>>>>                        Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
89194>>>>>>>                        If (bShowProgress = True) Begin
89196>>>>>>>                            If (Active_State(ghoStatusPanel)) Begin
89198>>>>>>>                                Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
89199>>>>>>>                            End
89199>>>>>>>>
89199>>>>>>>                            Else Begin
89200>>>>>>>                                Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
89202>>>>>>>                            End
89202>>>>>>>>
89202>>>>>>>                        End
89202>>>>>>>>
89202>>>>>>>                        Move sMessage to sMsg[SizeOfArray(sMsg)]
89203>>>>>>>                        Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
89204>>>>>>>                    Loop
89205>>>>>>>>
89205>>>>>>>                    If (ghoDbUpdateHandler > 0) Begin
89207>>>>>>>                        Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
89208>>>>>>>                    End
89208>>>>>>>>
89208>>>>>>>                    Set paQueryMessages to sMsg
89209>>>>>>>                End
89209>>>>>>>>
89209>>>>>>>                Else Begin
89210>>>>>>>                    If (bShowProgress = True) Begin
89212>>>>>>>                        Get paSqlErrorArray to aSqlErrorArray
89213>>>>>>>                        If (SizeOfArray(aSqlErrorArray.iSqlErrorArray)) Begin
89215>>>>>>>                            Move (SizeOfArray(aSqlErrorArray.iSqlErrorArray)) to iMsgs
89216>>>>>>>                            Decrement iMsgs
89217>>>>>>>                            For i from 0 to iMsgs
89223>>>>>>>>
89223>>>>>>>                                Showln "Embedded SQL Statement: " aSqlErrorArray.sSqlStatementArray[i]
89226>>>>>>>                                Showln "SQL Error Message     : " aSqlErrorArray.sSqlErrorArray[i]
89229>>>>>>>                            Loop
89230>>>>>>>>
89230>>>>>>>                        End
89230>>>>>>>>
89230>>>>>>>                    End
89230>>>>>>>>
89230>>>>>>>                End
89230>>>>>>>>
89230>>>>>>>                Move (CurrentDateTime()) to dtFetchEnd
89231>>>>>>>            End
89231>>>>>>>>
89231>>>>>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
89232>>>>>>>            Move (dtFetchStart - dtFetchEnd) to tsFetch
89233>>>>>>>            Set ptsQueryExec to tsQuery
89234>>>>>>>            Set ptsFetchResults to tsFetch
89235>>>>>>>            Send SqlClose of hoStmt
89236>>>>>>>        End
89236>>>>>>>>
89236>>>>>>>
89236>>>>>>>        Send SqlDisconnect of hoSQLConnect
89237>>>>>>>    End_Procedure
89238>>>>>>>
89238>>>>>>>    // *** Main message for executing an SQL script that has been compiled into the program as a resource ***
89238>>>>>>>    // Use the SQLIncludeScriptFile command to include an SQL script into the program.
89238>>>>>>>    // Returns False if no error occured.
89238>>>>>>>    Function SqlUtilExecuteResource String sMemFileName String sDriverID Boolean bCreateScriptFile Boolean bShowProgr Returns Boolean
89240>>>>>>>        Boolean bOK bShowProgress
89240>>>>>>>        tSQLScriptArray SQLScriptArray
89240>>>>>>>        tSQLScriptArray SQLScriptArray
89240>>>>>>>        DateTime dtTotalQueryStart dtTotalQueryEnd
89240>>>>>>>        TimeSpan tsTotalTime
89240>>>>>>>
89240>>>>>>>        Move (CurrentDateTime()) to dtTotalQueryStart
89241>>>>>>>        Get SqlUtilReadResource sMemFileName to SQLScriptArray
89242>>>>>>>        If (SQLScriptArray.bError = True) Begin
89244>>>>>>>            Function_Return False
89245>>>>>>>        End
89245>>>>>>>>
89245>>>>>>>
89245>>>>>>>        If (num_arguments > 3) Begin
89247>>>>>>>            Move bShowProgr to bShowProgress
89248>>>>>>>        End
89248>>>>>>>>
89248>>>>>>>
89248>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89249>>>>>>>        Get SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID bCreateScriptFile sMemFileName bShowProgress to bOK
89250>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
89251>>>>>>>
89251>>>>>>>        Move (CurrentDateTime()) to dtTotalQueryEnd
89252>>>>>>>        Move (dtTotalQueryEnd - dtTotalQueryStart) to tsTotalTime
89253>>>>>>>        Set ptsTotalQueryTime to tsTotalTime
89254>>>>>>>
89254>>>>>>>        Function_Return bOK
89255>>>>>>>    End_Function
89256>>>>>>>
89256>>>>>>>    // Reads a SQL script file that has been compiled into the .exe program as a resource.
89256>>>>>>>    // Pass: The memory resource reference and a boolean True if you want to create the file on disk (in the Home folder).
89256>>>>>>>    // Returns: A tSQLScriptArray Struct with the Sql script as an uChar Array will be returned along with the a bError boolean.
89256>>>>>>>    Function SqlUtilReadResource String sMemFileName Returns tSQLScriptArray
89258>>>>>>>        Integer iChannel iArgumentSize iCount
89258>>>>>>>        Number nByteCount
89258>>>>>>>        String sSQLScript
89258>>>>>>>        tSQLScriptArray SqlScriptArray
89258>>>>>>>        tSQLScriptArray SqlScriptArray
89258>>>>>>>        UChar[] uCharData
89259>>>>>>>
89259>>>>>>>        Move False to Err
89260>>>>>>>        Get Seq_New_Channel to iChannel
89261>>>>>>>        If (iChannel = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
89263>>>>>>>            Error DFERR_PROGRAM 'No channel available...'
89264>>>>>>>>
89264>>>>>>>            Move True to SqlScriptArray.bError
89265>>>>>>>            Function_Return SqlScriptArray
89266>>>>>>>        End
89266>>>>>>>>
89266>>>>>>>
89266>>>>>>>        // First decide the size of the script
89266>>>>>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
89268>>>>>>>        Read_Block channel iChannel uCharData -1 // -1 means that all data should be read.
89270>>>>>>>        Close_Input channel iChannel
89272>>>>>>>
89272>>>>>>>        Move (SizeOfArray(uCharData)) to nByteCount
89273>>>>>>>        If (nByteCount  < 1) Begin
89275>>>>>>>            Send Seq_Release_Channel iChannel
89276>>>>>>>            Move True to SqlScriptArray.bError
89277>>>>>>>            Function_Return SqlScriptArray
89278>>>>>>>        End
89278>>>>>>>>
89278>>>>>>>
89278>>>>>>>        // If necessary change the string argument_size
89278>>>>>>>        // Read the script file from memory line-by-line
89278>>>>>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
89280>>>>>>>            Move 0 to iCount
89281>>>>>>>            Repeat
89281>>>>>>>>
89281>>>>>>>                Readln channel iChannel sSQLScript
89283>>>>>>>                Move sSQLScript to SqlScriptArray.sSQLScriptArray[iCount]
89284>>>>>>>                Increment iCount
89285>>>>>>>            Until (SeqEof = True)
89287>>>>>>>        Close_Input channel iChannel
89289>>>>>>>        Send Seq_Release_Channel iChannel
89290>>>>>>>
89290>>>>>>>        // Finally "sanitize" the script by removing all comments.
89290>>>>>>>        Get _SqlUtilSanitizeScript SqlScriptArray to SqlScriptArray
89291>>>>>>>
89291>>>>>>>        Function_Return SqlScriptArray
89292>>>>>>>    End_Function
89293>>>>>>>
89293>>>>>>>    Function SqlUtilExecuteEmbeddedScript tSQLScriptArray SQLScriptArray String sDriverID Boolean bCreateScriptFile String sMemFileName Boolean bShowProgr Returns Boolean
89295>>>>>>>        String sSQLVal sStmt sCR sGOKeyWord sNoCountKeyWord sMessage sExportFile
89295>>>>>>>        Handle hoSql hoSQLConnect hoStmt hoError
89295>>>>>>>        Integer i iMsgs iRows iRowType iCount iChunkCounter iChunkMax iOut iNextSet iMessage iPos
89295>>>>>>>        String[] sMsg aSQLQueryMessages
89297>>>>>>>        DateTime dtQueryExecStart dtQueryExecEnd
89297>>>>>>>        TimeSpan tsQuery
89297>>>>>>>        tSqlErrorArray aSqlErrorArray
89297>>>>>>>        tSqlErrorArray aSqlErrorArray
89297>>>>>>>        tSQLConnection SQLConnection
89297>>>>>>>        tSQLConnection SQLConnection
89297>>>>>>>        Boolean bMertechDriver bShowProgress
89297>>>>>>>
89297>>>>>>>        If (num_arguments > 4) Begin
89299>>>>>>>            Move bShowProgr to bShowProgress
89300>>>>>>>        End
89300>>>>>>>>
89300>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
89301>>>>>>>        If (bMertechDriver = False) Begin
89303>>>>>>>            Get phoSQLManager to hoSql
89304>>>>>>>        End
89304>>>>>>>>
89304>>>>>>>        Else Begin
89305>>>>>>>            Get _MertechSQLManagerHandle to hoSql
89306>>>>>>>        End
89306>>>>>>>>
89306>>>>>>>
89306>>>>>>>        Get _SqlFindKeyWord CI_SQLGO to sGOKeyWord
89307>>>>>>>        // There seems to be a problem to pass strings when their value gets really big, aka
89307>>>>>>>        // above the argument_size level. It isn't clear when these problems starts but sooner
89307>>>>>>>        // or later SqlExecDirect stops working correctly with no error messages!
89307>>>>>>>        // To guard from this we set a max number of lines (iChunkMax) that can be processed
89307>>>>>>>        // at a time. Testing with the Create Chinook Database script; 500 seems like a number that works fine.
89307>>>>>>>        // A bonus of this is that it turns out that it is actually faster to run in chunks!
89307>>>>>>>        Get piChunkMax to iChunkMax
89308>>>>>>>        Move 0 to iChunkCounter
89309>>>>>>>        Move "" to sStmt
89310>>>>>>>
89310>>>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
89311>>>>>>>        Move (Character(13) + Character(10)) to sCR
89312>>>>>>>
89312>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
89313>>>>>>>
89313>>>>>>>        If (bMertechDriver = True) Begin
89315>>>>>>>            Get _MertechSQLConnect sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
89316>>>>>>>        End
89316>>>>>>>>
89316>>>>>>>        If (bMertechDriver = False) Begin
89318>>>>>>>            Get phoSQLManager  to hoSQL
89319>>>>>>>            If (sDriverID = ODBC_DRV_ID) Begin
89321>>>>>>>                If (Uppercase(SQLConnection.sConnectionString) contains CS_SQLIniDSNKeyword) Begin
89323>>>>>>>                    Move (Pos(";", SQLConnection.sConnectionString)) to iPos
89324>>>>>>>                    If (iPos > 0) Begin
89326>>>>>>>                        Move (Left(SQLConnection.sConnectionString, (iPos - 1))) to SQLConnection.sConnectionString
89327>>>>>>>                        Move (Trim(SQLConnection.sConnectionString)) to SQLConnection.sConnectionString
89328>>>>>>>                    End
89328>>>>>>>>
89328>>>>>>>                End
89328>>>>>>>>
89328>>>>>>>            End
89328>>>>>>>>
89328>>>>>>>            Send SqlSetConnect of hoSQL sDriverID SQLConnection.sConnectionString
89329>>>>>>>            Get SqlConnect     of hoSQL "" "" to hoSQLConnect
89330>>>>>>>        End
89330>>>>>>>>
89330>>>>>>>
89330>>>>>>>        If (hoSQLConnect <> 0) Begin
89332>>>>>>>            Move False to Err
89333>>>>>>>            Get SqlOpen of hoSQLConnect to hoStmt
89334>>>>>>>            If (hoStmt <> 0) Begin
89336>>>>>>>
89336>>>>>>>                // If the embedded resource should be written as a script file to disk:
89336>>>>>>>                If (bCreateScriptFile = True) Begin
89338>>>>>>>                    Get psHome of (phoWorkspace(ghoApplication)) to sExportFile
89339>>>>>>>                    Get vFolderFormat sExportFile to sExportFile
89340>>>>>>>                    Move (sExportFile + sMemFileName) to sExportFile
89341>>>>>>>                    Get Seq_New_Channel to iOut
89342>>>>>>>                    If (iOut <> DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
89344>>>>>>>                        Direct_Output channel iOut sExportFile
89346>>>>>>>                    End
89346>>>>>>>>
89346>>>>>>>                End
89346>>>>>>>>
89346>>>>>>>
89346>>>>>>>                // Record starting date/time stamp
89346>>>>>>>                Move (CurrentDateTime()) to dtQueryExecStart
89347>>>>>>>                // Turn on error handling if enabled
89347>>>>>>>                If (pbHandleQueryErrors(Self)) Begin
89349>>>>>>>                    Set pbSqlError to False
89350>>>>>>>                    Set paSqlErrorArray to aSqlErrorArray
89351>>>>>>>                    Move Error_Object_Id to hoError
89352>>>>>>>                    Move Self to Error_Object_Id
89353>>>>>>>                End
89353>>>>>>>>
89353>>>>>>>
89353>>>>>>>                Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iRows
89354>>>>>>>                Decrement iRows
89355>>>>>>>                If (sDriverID = MSSQLDRV_ID) Begin
89357>>>>>>>                    Move (sNoCountKeyWord + sCR) to sStmt
89358>>>>>>>                End
89358>>>>>>>>
89358>>>>>>>
89358>>>>>>>                For iCount from 0 to iRows
89364>>>>>>>>
89364>>>>>>>                    Move (SQLScriptArray.sSQLScriptArray[iCount]) to sSQLVal
89365>>>>>>>
89365>>>>>>>                    If (Uppercase(sSQLVal) <> sGOKeyWord) Begin
89367>>>>>>>                        If (sSQLVal <> "") Begin
89369>>>>>>>                            Move (sSQLVal + sCR) to sSQLVal
89370>>>>>>>                        End
89370>>>>>>>>
89370>>>>>>>                        Move (Append(sStmt, (sSQLVal))) to sStmt
89371>>>>>>>                    End
89371>>>>>>>>
89371>>>>>>>
89371>>>>>>>                    // - Each time we encounter a "GO" statement we execute it,
89371>>>>>>>                    // or if at the very end of the script.
89371>>>>>>>                    If (Uppercase(sSQLVal) = sGOKeyWord or iChunkCounter >= iChunkMax or iCount = iRows) Begin
89373>>>>>>>
89373>>>>>>>                        // - It turns out it can be at least 10 times faster to execute SQL statements in chunks,
89373>>>>>>>                        // instead of all in one go.
89373>>>>>>>                        Send SqlExecDirect of hoStmt sStmt
89374>>>>>>>
89374>>>>>>>                        If (bCreateScriptFile = True) Begin
89376>>>>>>>                            Write channel iOut sStmt
89378>>>>>>>                        End
89378>>>>>>>>
89378>>>>>>>                        Move "" to sStmt
89379>>>>>>>                        Move 0 to iChunkCounter
89380>>>>>>>                    End
89380>>>>>>>>
89380>>>>>>>                    Increment iChunkCounter
89381>>>>>>>                Loop
89382>>>>>>>>
89382>>>>>>>
89382>>>>>>>                // ToDo: This sometimes generates a GPF with Mertech drivers;
89382>>>>>>>                //       so not used for now.
89382>>>>>>>                If (bMertechDriver = False) Begin
89384>>>>>>>                    Repeat
89384>>>>>>>>
89384>>>>>>>                        If (pbHandleQueryErrors(Self)) Begin
89386>>>>>>>                            Move hoError to Error_Object_Id
89387>>>>>>>                        End
89387>>>>>>>>
89387>>>>>>>                        Move (CurrentDateTime()) to dtQueryExecEnd
89388>>>>>>>
89388>>>>>>>                        Send _SqlColumnInfo hoStmt
89389>>>>>>>                        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT to iRows
89390>>>>>>>                        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
89391>>>>>>>                        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_NUMMESSAGES to iMsgs
89392>>>>>>>                        Set piRows    to iRows
89393>>>>>>>                        Set piRowType to iRowType
89394>>>>>>>
89394>>>>>>>                        If (iMsgs <> 0) Begin
89396>>>>>>>                            If (ghoDbUpdateHandler > 0) Begin
89398>>>>>>>                                Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
89399>>>>>>>                            End
89399>>>>>>>>
89399>>>>>>>                            For i from 1 to iMsgs
89405>>>>>>>>
89405>>>>>>>                                Get SqlGetMessage of hoStmt i to sMessage
89406>>>>>>>                                Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
89407>>>>>>>                                If (bShowProgress = True) Begin
89409>>>>>>>                                    If (Active_State(ghoStatusPanel)) Begin
89411>>>>>>>                                        Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
89412>>>>>>>                                    End
89412>>>>>>>>
89412>>>>>>>                                    Else Begin
89413>>>>>>>                                        Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
89415>>>>>>>                                    End
89415>>>>>>>>
89415>>>>>>>                                End
89415>>>>>>>>
89415>>>>>>>                                Move sMessage to sMsg[SizeOfArray(sMsg)]
89416>>>>>>>                                Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
89417>>>>>>>                            Loop
89418>>>>>>>>
89418>>>>>>>
89418>>>>>>>
89418>>>>>>>                            If (ghoDbUpdateHandler > 0) Begin
89420>>>>>>>                                Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
89421>>>>>>>                            End
89421>>>>>>>>
89421>>>>>>>                            Set paQueryMessages to sMsg
89422>>>>>>>                        End
89422>>>>>>>>
89422>>>>>>>
89422>>>>>>>                        Get SQLNextResultSet of hoStmt to iNextSet
89423>>>>>>>                    Until (iNextSet = 0)
89425>>>>>>>                End
89425>>>>>>>>
89425>>>>>>>                Move (CurrentDateTime()) to dtQueryExecEnd
89426>>>>>>>            End
89426>>>>>>>>
89426>>>>>>>
89426>>>>>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
89427>>>>>>>            Set ptsQueryExec to tsQuery
89428>>>>>>>            Send SqlClose of hoStmt
89429>>>>>>>
89429>>>>>>>            If (bCreateScriptFile = True) Begin
89431>>>>>>>                Close_Output channel iOut
89433>>>>>>>                Send Seq_Release_Channel iOut
89434>>>>>>>            End
89434>>>>>>>>
89434>>>>>>>        End
89434>>>>>>>>
89434>>>>>>>        Send SqlDisconnect of hoSQLConnect
89435>>>>>>>
89435>>>>>>>        Function_Return (hoSQLConnect <> 0 and Err = False)
89436>>>>>>>    End_Function
89437>>>>>>>
89437>>>>>>>    // * Dummy function for the Studio's Code Explorer *
89437>>>>>>>    Function SQL_UTILITY_FUNCTIONS Returns Boolean
89439>>>>>>>        Function_Return False
89440>>>>>>>    End_Function
89441>>>>>>>
89441>>>>>>>    // Does three things with auxilirary files;
89441>>>>>>>    // 1) Deletes the cache file in the first Data folder of the psDataPath property as the table at the SQL end has been changed.
89441>>>>>>>    // 2) Adds the sColumnName to the TableName.tag file in the first Data folder of the psDataPath property
89441>>>>>>>    // 3) Creates a new TableName.fd file if the DdSrc folder is available (if this is a development environment)
89441>>>>>>>    Function SqlUtilAdjustAuxFiles Handle hTable String sTableName String sColumnName Returns Boolean
89443>>>>>>>        String sDataPath sDDSrcPath sDriverID
89443>>>>>>>        Boolean bOK bExists bMertechDriver
89443>>>>>>>        Integer iCount iCh iPos
89443>>>>>>>
89443>>>>>>>        // If table name equals e.g. "dbo.MyTable" we need to remove the prefix.
89443>>>>>>>        If (sTableName contains ".") Begin
89445>>>>>>>            Move (Pos(".", sTableName)) to iPos
89446>>>>>>>            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
89447>>>>>>>        End
89447>>>>>>>>
89447>>>>>>>
89447>>>>>>>        Get psDriverID to sDriverID
89448>>>>>>>        Get psDataPathFirstPart to sDataPath
89449>>>>>>>        Get vFolderExists sDataPath to bOK
89450>>>>>>>        If (bOK = False) Begin
89452>>>>>>>            Error DFERR_PROGRAM "Function SqlUtilAdjustAuxFiles; psDataPath not found!"
89453>>>>>>>>
89453>>>>>>>            Function_Return False
89454>>>>>>>        End
89454>>>>>>>>
89454>>>>>>>
89454>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
89455>>>>>>>        // First delete the cache file:
89455>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
89456>>>>>>>
89456>>>>>>>        Get Seq_New_Channel to iCh
89457>>>>>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
89459>>>>>>>            Function_Return False
89460>>>>>>>        End
89460>>>>>>>>
89460>>>>>>>
89460>>>>>>>        Get vFilePathExists (sDataPath + sTableName + ".tag") to bExists
89461>>>>>>>        If (bExists = False) Begin
89463>>>>>>>            Function_Return False
89464>>>>>>>        End
89464>>>>>>>>
89464>>>>>>>
89464>>>>>>>        Get SqlUtilUpdateIntFile hTable to bOK
89465>>>>>>>        // Add the new column name to the .tag filen (if it doesn't exist):
89465>>>>>>>        Get UtilUpdateTAGFile (sDataPath + sTableName + ".tag") sColumnName to bOK
89466>>>>>>>
89466>>>>>>>        // If in development environment; output new .fd file:
89466>>>>>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
89467>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
89468>>>>>>>        If (iCount > 1) Begin
89470>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
89471>>>>>>>        End
89471>>>>>>>>
89471>>>>>>>        Get vFolderExists sDDSrcPath to bExists
89472>>>>>>>        If (bExists = True) Begin
89474>>>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
89475>>>>>>>            Move False to Err
89476>>>>>>>            Get AutoConnectionIDLogin to bOK
89477>>>>>>>            If (hTable <> 0) Begin
89479>>>>>>>                Open hTable
89481>>>>>>>            End
89481>>>>>>>>
89481>>>>>>>            Else Begin
89482>>>>>>>                Get UtilTableOpen hTable sTableName DF_SHARE to bOK
89483>>>>>>>            End
89483>>>>>>>>
89483>>>>>>>
89483>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOK
89486>>>>>>>            If (bOK = True) Begin
89488>>>>>>>                Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
89490>>>>>>>            End
89490>>>>>>>>
89490>>>>>>>            If (Err = True) Begin
89492>>>>>>>                Move False to bOK
89493>>>>>>>            End
89493>>>>>>>>
89493>>>>>>>        End
89493>>>>>>>>
89493>>>>>>>
89493>>>>>>>        Function_Return (bOK = True)
89494>>>>>>>    End_Function
89495>>>>>>>
89495>>>>>>>    Function UtilUpdateTAGFile String sFullTAGFileName String sColumnName Returns Boolean
89497>>>>>>>        Integer iChIn iChOut // iCount
89497>>>>>>>        Boolean bExists
89497>>>>>>>        String sExistingColumn
89497>>>>>>>
89497>>>>>>>        Move False to bExists
89498>>>>>>>        Get Seq_New_Channel to iChIn
89499>>>>>>>        Get Seq_New_Channel to iChOut
89500>>>>>>>        If (iChIn = DF_SEQ_CHANNEL_NOT_AVAILABLE or iChOut = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
89502>>>>>>>            Function_Return True
89503>>>>>>>        End
89503>>>>>>>>
89503>>>>>>>
89503>>>>>>>        Move False to Err
89504>>>>>>>        // The following line should also use the channel attribute. (Thank you, Hans van de Laar)
89504>>>>>>>        Direct_Input channel iChIn ("'" + sFullTAGFileName + "'")
89506>>>>>>>        While (not(SeqEof))
89510>>>>>>>            Readln channel iChIn sExistingColumn
89512>>>>>>>            If (Uppercase(sExistingColumn) = Uppercase(sColumnName)) Begin
89514>>>>>>>                Move True to bExists
89515>>>>>>>            End
89515>>>>>>>>
89515>>>>>>>            If (Trim(sExistingColumn) = "") Begin
89517>>>>>>>                Move True to SeqEof
89518>>>>>>>            End
89518>>>>>>>>
89518>>>>>>>        Loop
89519>>>>>>>>
89519>>>>>>>        Close_Input channel iChIn
89521>>>>>>>        Send Seq_Release_Channel iChIn
89522>>>>>>>
89522>>>>>>>        If (bExists = False) Begin
89524>>>>>>>            Append_Output channel iChOut sFullTAGFileName
89526>>>>>>>            Writeln channel iChOut sColumnName
89529>>>>>>>            Close_Output channel iChOut
89531>>>>>>>            Send Seq_Release_Channel iChOut
89532>>>>>>>        End
89532>>>>>>>>
89532>>>>>>>
89532>>>>>>>        Function_Return (Err = False)
89533>>>>>>>    End_Function
89534>>>>>>>
89534>>>>>>>    // Message for changing .int files to use connection ID's
89534>>>>>>>    //
89534>>>>>>>    // Changes all ".int" files for the passed sDataPath to use a sConnectionID,
89534>>>>>>>    // OR changes an existing connection id to a new id.
89534>>>>>>>    // Pass the full path to the data folder and the name of the connection id (string value).
89534>>>>>>>    // Pass a True for the bShowResult parameter to show work in progress (showln's).
89534>>>>>>>    Procedure SqlUtilChangeIntFilesToConnectionIDs String sDataPath String sConnectionID Boolean bShowResult
89536>>>>>>>        String sFileName sDriverID sDriverFile sConnectionString
89536>>>>>>>        String[] sFilesData
89537>>>>>>>        Boolean bOK bCancel
89537>>>>>>>        Integer iSize iCount
89537>>>>>>>
89537>>>>>>>        Get SqlUtilEnumerateIntFiles sDataPath to sFilesData
89538>>>>>>>        Move (SizeOfArray(sFilesData))    to iSize
89539>>>>>>>        If (iSize = 0) Begin
89541>>>>>>>            If (ghoStatusPanel <> 0) Begin
89543>>>>>>>                If (Active_State(ghoStatusPanel)) Begin
89545>>>>>>>                    Send Stop_StatusPanel of ghoStatusPanel
89546>>>>>>>                End
89546>>>>>>>>
89546>>>>>>>            End
89546>>>>>>>>
89546>>>>>>>            Send Info_Box CS_DUF_NoIntFilesFound
89547>>>>>>>            Procedure_Return
89548>>>>>>>        End
89548>>>>>>>>
89548>>>>>>>
89548>>>>>>>        Move (Trim(sConnectionID)) to sConnectionID
89549>>>>>>>        Get vFolderFormat sDataPath to sDataPath
89550>>>>>>>        Decrement iSize
89551>>>>>>>        For iCount from 0 to iSize
89557>>>>>>>>
89557>>>>>>>            Move sFilesData[iCount] to sFileName
89558>>>>>>>            // This makes sure that we also can change an existing connection id to something new:
89558>>>>>>>            Get UtilChangeSourceCodeLine (sDataPath + sFileName) CS_SERVER_NAME (CS_SERVER_NAME * CS_DFCONNID + "=" + sConnectionID) bShowResult to bOK
89559>>>>>>>            If (ghoStatusPanel <> 0) Begin
89561>>>>>>>                If (Active_State(ghoStatusPanel)) Begin
89563>>>>>>>                    Get Check_StatusPanel of ghoStatusPanel to bCancel
89564>>>>>>>                    If (bCancel = True) Begin
89566>>>>>>>                        Send Deactivate of ghoStatusPanel
89567>>>>>>>                        Procedure_Return
89568>>>>>>>                    End
89568>>>>>>>>
89568>>>>>>>                End
89568>>>>>>>>
89568>>>>>>>            End
89568>>>>>>>>
89568>>>>>>>        Loop
89569>>>>>>>>
89569>>>>>>>
89569>>>>>>>        Get psDriverID to sDriverID
89570>>>>>>>
89570>>>>>>>         // Finally also change the driver file e.g. MSSQLDRV.int file in the Data folder in case it has a "DFconnectionID xxxxID,SERVER..."
89570>>>>>>>        Move "" to sFileName
89571>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
89573>>>>>>>            Move "MSSQLDrv.int" to sFileName
89574>>>>>>>        End
89574>>>>>>>>
89574>>>>>>>        If (sDriverID = DB2_DRV_ID) Begin
89576>>>>>>>            Move "DB2_Drv.int" to sFileName
89577>>>>>>>        End
89577>>>>>>>>
89577>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
89579>>>>>>>            Move "ODBC_Drv.int" to sFileName
89580>>>>>>>        End
89580>>>>>>>>
89580>>>>>>>        If (sFileName <> "") Begin
89582>>>>>>>            Move "" to sDriverFile
89583>>>>>>>            Get_File_Path sFileName to sDriverFile
89584>>>>>>>            If (sDriverFile <> "") Begin
89586>>>>>>>                Get psConnectionString to sConnectionString
89587>>>>>>>                Get UtilChangeSourceCodeLine sDriverFile CS_SQLConnectionIDText (CS_SQLConnectionIDText * String(sConnectionID) + "," * String(sConnectionString) * String(",0")) bShowResult to bOK
89588>>>>>>>            End
89588>>>>>>>>
89588>>>>>>>        End
89588>>>>>>>>
89588>>>>>>>    End_Procedure
89589>>>>>>>
89589>>>>>>>    // Checks if the database exists in SQL. Returns = True if it does.
89589>>>>>>>    Function SqlUtilCheckIfDatabaseExists String sDatabase Returns Boolean
89591>>>>>>>        String[] sDatabaseArray
89592>>>>>>>        String sVal sServer sDriverID
89592>>>>>>>        Integer iCount iSize iPos
89592>>>>>>>        Boolean bExists
89592>>>>>>>        tSQLConnection SQLConnection
89592>>>>>>>        tSQLConnection SQLConnection
89592>>>>>>>
89592>>>>>>>        Move False to bExists
89593>>>>>>>        Get psDriverID to sDriverID
89594>>>>>>>        // DB2 doesn't have a "Database" name, so we always return True.
89594>>>>>>>        If (sDriverID = DB2_DRV_ID) Begin
89596>>>>>>>            Function_Return bExists
89597>>>>>>>        End
89597>>>>>>>>
89597>>>>>>>
89597>>>>>>>        Get SqlUtilEnumerateDatabases sDriverID to sDatabaseArray
89598>>>>>>>        If (SizeOfArray(sDatabaseArray) = 0) Begin
89600>>>>>>>            Function_Return False
89601>>>>>>>        End
89601>>>>>>>>
89601>>>>>>>
89601>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
89602>>>>>>>        Move SQLConnection.sServer to sServer
89603>>>>>>>
89603>>>>>>>        // Special code to handle a FILEDSN that also can contain "/"
89603>>>>>>>        If (Uppercase(sServer) contains ("." + CS_SQLIniDSNKeyword)) Begin
89605>>>>>>>            Move sDatabaseArray[0] to sVal  // Dummy!
89606>>>>>>>        End
89606>>>>>>>>
89606>>>>>>>        Else If (sServer contains "/") Begin
89609>>>>>>>            Move (Pos("/", sServer)) to iPos
89610>>>>>>>            Move (Mid(sServer, 999, (iPos +1))) to sDatabase
89611>>>>>>>        End
89611>>>>>>>>
89611>>>>>>>
89611>>>>>>>        Move (SizeOfArray(sDatabaseArray)) to iSize
89612>>>>>>>        Decrement iSize
89613>>>>>>>        For iCount from 0 to iSize
89619>>>>>>>>
89619>>>>>>>            Move sDatabaseArray[iCount] to sVal
89620>>>>>>>            If (Uppercase(sVal) = Uppercase(sDatabase)) Begin
89622>>>>>>>                Move True to bExists
89623>>>>>>>                If (bExists = True) Begin
89625>>>>>>>                    Move iSize to iCount // We're done.
89626>>>>>>>                End
89626>>>>>>>>
89626>>>>>>>            End
89626>>>>>>>>
89626>>>>>>>        Loop
89627>>>>>>>>
89627>>>>>>>
89627>>>>>>>        Function_Return bExists
89628>>>>>>>    End_Function
89629>>>>>>>
89629>>>>>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
89629>>>>>>>    Function SqlUtilCheckIfTableHandleExists Handle hTable String sDriverID Returns Boolean
89631>>>>>>>        String sDatabase sSchema sTableName sVal
89631>>>>>>>        Boolean bExists
89631>>>>>>>        String[] sTablesArray
89632>>>>>>>        Integer iSize iCount
89632>>>>>>>
89632>>>>>>>        Move False to bExists
89633>>>>>>>        Get UtilTableHandleToString hTable to sTableName
89634>>>>>>>        Get psDatabase to sDatabase
89635>>>>>>>        Get psSchema   to sSchema
89636>>>>>>>        Get SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
89637>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
89638>>>>>>>        Decrement iSize
89639>>>>>>>        For iCount from 0 to iSize
89645>>>>>>>>
89645>>>>>>>            Move sTablesArray[iCount] to sVal
89646>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
89648>>>>>>>                Move True to bExists
89649>>>>>>>                Move iSize to iCount // We're done!
89650>>>>>>>            End
89650>>>>>>>>
89650>>>>>>>        Loop
89651>>>>>>>>
89651>>>>>>>
89651>>>>>>>        Function_Return bExists
89652>>>>>>>    End_Function
89653>>>>>>>
89653>>>>>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
89653>>>>>>>    Function SqlUtilCheckIfTableNameExists String sTableName String sDriverID Returns Boolean
89655>>>>>>>        String sDatabase sSchema sVal
89655>>>>>>>        Boolean bExists
89655>>>>>>>        String[] sTablesArray
89656>>>>>>>        Integer iSize iCount
89656>>>>>>>
89656>>>>>>>        Move False to bExists
89657>>>>>>>        Get psDatabase to sDatabase
89658>>>>>>>        Get psSchema   to sSchema
89659>>>>>>>        Get SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
89660>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
89661>>>>>>>        Decrement iSize
89662>>>>>>>        For iCount from 0 to iSize
89668>>>>>>>>
89668>>>>>>>            Move sTablesArray[iCount] to sVal
89669>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
89671>>>>>>>                Move True to bExists
89672>>>>>>>                Move iSize to iCount // We're done!
89673>>>>>>>            End
89673>>>>>>>>
89673>>>>>>>        Loop
89674>>>>>>>>
89674>>>>>>>
89674>>>>>>>        Function_Return bExists
89675>>>>>>>    End_Function
89676>>>>>>>
89676>>>>>>>    Function SqlUtilCheckIfTableNameSpelling String sDriverID String sDatabase String sTableName String sSchema Returns String
89678>>>>>>>        String sVal sTableSpelledCorrectly
89678>>>>>>>        Boolean bExists
89678>>>>>>>        String[] sTablesArray
89679>>>>>>>        Integer iSize iCount
89679>>>>>>>
89679>>>>>>>        Move False to bExists
89680>>>>>>>        Move sTableName to sTableSpelledCorrectly
89681>>>>>>>        Get SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
89682>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
89683>>>>>>>        Decrement iSize
89684>>>>>>>        For iCount from 0 to iSize
89690>>>>>>>>
89690>>>>>>>            Move sTablesArray[iCount] to sVal
89691>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
89693>>>>>>>                Move sVal to sTableSpelledCorrectly
89694>>>>>>>                Move iSize to iCount // We're done!
89695>>>>>>>            End
89695>>>>>>>>
89695>>>>>>>        Loop
89696>>>>>>>>
89696>>>>>>>
89696>>>>>>>        Function_Return sTableSpelledCorrectly
89697>>>>>>>    End_Function
89698>>>>>>>
89698>>>>>>>    // ToDo: This index name function needs to be finished...
89698>>>>>>>    Function SqlUtilCheckIfIndexNameExists Handle hTable String sIndexName Returns Boolean
89700>>>>>>>        String sSchema sTableName sDriverID
89700>>>>>>>        Boolean bExists
89700>>>>>>>
89700>>>>>>>        Get psDriverID to sDriverID
89701>>>>>>>        Get psSchema to sSchema
89702>>>>>>>        Get UtilTableHandleToString hTable to sTableName
89703>>>>>>>
89703>>>>>>>        Function_Return bExists
89704>>>>>>>    End_Function
89705>>>>>>>
89705>>>>>>>    // Checks if a column/field name exists in a SQL table definition
89705>>>>>>>    // Returns True if it does
89705>>>>>>>    // Sample:
89705>>>>>>>    //   Get SQLUtilColumnExists "MySQLTable" "MyColumnName" to bExists
89705>>>>>>>    Function SqlUtilColumnExists String sTableName String sFieldName Returns Boolean
89707>>>>>>>        Integer iNumColumns iColumn
89707>>>>>>>        String sColumn sDriverID
89707>>>>>>>        String[] sColumnsArray
89708>>>>>>>        Boolean bExists bOK
89708>>>>>>>
89708>>>>>>>        Move False to bExists
89709>>>>>>>        Get AutoConnectionIDLogin to bOK
89710>>>>>>>        Get psDriverID to sDriverID
89711>>>>>>>
89711>>>>>>>        Get SqlUtilEnumerateColumns sDriverID sTableName to sColumnsArray
89712>>>>>>>        Move (SizeOfArray(sColumnsArray)) to iNumColumns
89713>>>>>>>        Decrement iNumColumns
89714>>>>>>>        For iColumn from 0 to iNumColumns
89720>>>>>>>>
89720>>>>>>>            Move sColumnsArray[iColumn] to sColumn
89721>>>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
89723>>>>>>>                Move True to bExists
89724>>>>>>>                Move iNumColumns to iColumn // We're out of here
89725>>>>>>>            End
89725>>>>>>>>
89725>>>>>>>        Loop
89726>>>>>>>>
89726>>>>>>>
89726>>>>>>>        Function_Return bExists
89727>>>>>>>    End_Function
89728>>>>>>>
89728>>>>>>>    Function SqlUtilConvertColumnTypesToSQL2008 Handle hTable Returns Boolean
89730>>>>>>>        Integer iNumColumns iColumn iDFType iNativeType
89730>>>>>>>        Boolean bOpened bOK
89730>>>>>>>        String sColumnName sNativeTypeName
89730>>>>>>>
89730>>>>>>>        Get AutoConnectionIDLogin to bOK
89731>>>>>>>        Get OpenTableExclusive hTable to bOK
89732>>>>>>>        If (bOK = False) Begin
89734>>>>>>>            Function_Return False
89735>>>>>>>        End
89735>>>>>>>>
89735>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
89738>>>>>>>        If (bOpened = False) Begin
89740>>>>>>>            Error DFERR_PROGRAM ("Function SQLUtilConvertColumnTypesToSQL2008; Could not open table" * String(hTable))
89741>>>>>>>>
89741>>>>>>>            Function_Return False
89742>>>>>>>        End
89742>>>>>>>>
89742>>>>>>>
89742>>>>>>>        Move False to Err
89743>>>>>>>
89743>>>>>>>        Structure_Start hTable
89744>>>>>>>            Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
89747>>>>>>>
89747>>>>>>>            For iColumn from 1 to iNumColumns
89753>>>>>>>>
89753>>>>>>>                Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iDfType
89756>>>>>>>                Get_Attribute DF_FIELD_NAME             of hTable iColumn to sColumnName
89759>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iNativeType
89762>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE_Name of hTable iColumn to sNativeTypeName
89765>>>>>>>
89765>>>>>>>                Case Begin
89765>>>>>>>                    Case (iDFType = DF_DATE)
89767>>>>>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
89769>>>>>>>                            // Convert datetime to date
89769>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_DATE
89772>>>>>>>                        End
89772>>>>>>>>
89772>>>>>>>                        Case Break
89773>>>>>>>                    Case (iDFType = DF_DATETIME)
89776>>>>>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
89778>>>>>>>                            // Convert datetime to datetime2
89778>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_TIMESTAMP2
89781>>>>>>>                        End
89781>>>>>>>>
89781>>>>>>>                        Case Break
89782>>>>>>>                    Case (iDFType = DF_ASCII)
89785>>>>>>>                        If (iNativeType = SQL_CHAR) Begin
89787>>>>>>>                            // Convert char to varchar
89787>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
89790>>>>>>>                        End
89790>>>>>>>>
89790>>>>>>>                        Case Break
89791>>>>>>>                    Case (iDFType = DF_TEXT)
89794>>>>>>>                        If (iNativeType = SQL_LONGVARCHAR) Begin
89796>>>>>>>                            // Convert text to varchar(max)
89796>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
89799>>>>>>>                        End
89799>>>>>>>>
89799>>>>>>>                        Case Break
89800>>>>>>>                    Case (iDFType = DF_BINARY)
89803>>>>>>>                        If (iNativeType = SQL_LONGVARBINARY) Begin
89805>>>>>>>                            // Convert image to varbinary(max)
89805>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARBINARY
89808>>>>>>>                        End
89808>>>>>>>>
89808>>>>>>>                        Case Break
89809>>>>>>>                Case End
89809>>>>>>>            Loop
89810>>>>>>>>
89810>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
89811>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89813>>>>>>>
89813>>>>>>>        Set Action_Text of ghoStatusPanel to ""
89814>>>>>>>        Function_Return (Err = False)
89815>>>>>>>    End_Function
89816>>>>>>>
89816>>>>>>>
89816>>>>>>>    // Will create an SQL table with the passed sTableName & sColumnName as Numeric 4.2 to keep
89816>>>>>>>    // the DbUpdateVersion database revision in.
89816>>>>>>>    // Also pass the file number of the current (embedded?) table number used in development.
89816>>>>>>>    // It will first create the SQL Table & column, then create the .int file and change Filelist.cfg
89816>>>>>>>    Function SqlUtilCreateDbVersionTable Handle hTable String sColumnName String sDriverID Returns Boolean
89818>>>>>>>        Boolean bOK bOpened
89818>>>>>>>        String sTableName sDataType sAlterTable sAddColumn sLengthAndDecimals sStmt
89818>>>>>>>
89818>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
89821>>>>>>>        Get _TableNameOnly sTableName to sTableName
89822>>>>>>>        If (sTableName = "") Begin
89824>>>>>>>            Function_Return False
89825>>>>>>>        End
89825>>>>>>>>
89825>>>>>>>
89825>>>>>>>        // This just creates the table and a "dummy" column.
89825>>>>>>>        Get SqlTableCreate hTable sDriverID to bOK
89826>>>>>>>        If (bOK = False) Begin
89828>>>>>>>            Function_Return False
89829>>>>>>>        End
89829>>>>>>>>
89829>>>>>>>
89829>>>>>>>        Close hTable
89830>>>>>>>        Move False to Err
89831>>>>>>>
89831>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
89832>>>>>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
89833>>>>>>>        Move "Decimal" to sDataType
89834>>>>>>>        Get _SqlFormatLengthAndDecimalAsString 4 2 to sLengthAndDecimals
89835>>>>>>>
89835>>>>>>>        // Adds the "sColumnName" passed to the function
89835>>>>>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals) to sStmt
89836>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
89837>>>>>>>
89837>>>>>>>        // Now we can delete the dummy column:
89837>>>>>>>        Get SqlColumnRemoveByTableName sTableName "Dummy" to bOK
89838>>>>>>>
89838>>>>>>>        // Finally, we attach to the newly created table.
89838>>>>>>>        If (Err = False) Begin
89840>>>>>>>            Get ApiTableAttachToSQL hTable True to bOK
89841>>>>>>>        End
89841>>>>>>>>
89841>>>>>>>        Open hTable
89843>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
89846>>>>>>>
89846>>>>>>>        Function_Return (Err = False and bOK = True and bOpened = True)
89847>>>>>>>    End_Function
89848>>>>>>>
89848>>>>>>>    // The table must already exist in the filelist for this function to work.
89848>>>>>>>    // It creates a rudimentary .int file in the first Data folder of the psDataPath property.
89848>>>>>>>    Function SqlUtilCreateIntFile Handle hTable String sDriverID String sConnectionID Boolean bAnsi Boolean bSysFile Returns Boolean
89850>>>>>>>        Boolean bOK bExists bUseConnectionID bMertech
89850>>>>>>>        String sDataPath sRootName sLogicalName sPhysicalFileName sConnectionString sDatabaseName sSchemaName sANSI_OEM
89850>>>>>>>        String[] sIndexArray
89851>>>>>>>        Integer iCount iCh iSize
89851>>>>>>>
89851>>>>>>>        Move (Trim(sConnectionID) <> "") to bUseConnectionID
89852>>>>>>>        Get psConnectionString to sConnectionString
89853>>>>>>>
89853>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
89854>>>>>>>        If (bANSI = False) Begin
89856>>>>>>>            Move CS_OEM_Txt to sANSI_OEM
89857>>>>>>>        End
89857>>>>>>>>
89857>>>>>>>
89857>>>>>>>        Get psDataPathFirstPart to sDataPath
89858>>>>>>>        Get vFolderExists sDataPath to bOK
89859>>>>>>>        If (bOK = False) Begin
89861>>>>>>>            Error DFERR_PROGRAM "Function SqlUtilCreateIntFile; psDataPath not found!"
89862>>>>>>>>
89862>>>>>>>            Function_Return False
89863>>>>>>>        End
89863>>>>>>>>
89863>>>>>>>        Get vFolderFormat sDataPath to sDataPath
89864>>>>>>>
89864>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
89867>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
89870>>>>>>>        Get _TableNameOnly sRootName to sDatabaseName
89871>>>>>>>        Move sLogicalName  to sPhysicalFileName
89872>>>>>>>        Move (sPhysicalFileName + ".int") to sPhysicalFileName
89873>>>>>>>
89873>>>>>>>        Get IsMertechDriver sDriverID to bMertech
89874>>>>>>>        If (bMertech = True) Begin
89876>>>>>>>            // This should not be called here. Instead it is called by the SqlUtilUpdateIntFile!
89876>>>>>>>            // Else it will create an error in the error log (although it won't do anything...)
89876>>>>>>>            // Get _MertechSqlUtilCreateIntFile hTable sLogicalName sDataPath sPhysicalFileName to bOK
89876>>>>>>>            Function_Return (bOK = True)
89877>>>>>>>        End
89877>>>>>>>>
89877>>>>>>>
89877>>>>>>>        Get psSchema hTable to sSchemaName
89878>>>>>>>        If (sSchemaName = "") Begin
89880>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchemaName
89881>>>>>>>        End
89881>>>>>>>>
89881>>>>>>>
89881>>>>>>>        // If the .int file already exists; we rename it to "FileName" + ".bak"
89881>>>>>>>        Get vFilePathExists (sDataPath + sPhysicalFileName) to bExists
89882>>>>>>>        If (bExists = True) Begin
89884>>>>>>>            Get vRenameFile (sDataPath + sPhysicalFileName) (sDataPath + sPhysicalFileName + ".bak") to bOK
89885>>>>>>>        End
89885>>>>>>>>
89885>>>>>>>
89885>>>>>>>        Get UtilDeleteCacheFile sRootName to bOK
89886>>>>>>>        Get SqlUtilEnumerateIndexes sRootName sDriverID to sIndexArray
89887>>>>>>>
89887>>>>>>>        Get Seq_Open_Output_Channel (sDataPath + sPhysicalFileName) to iCh
89888>>>>>>>            Writeln channel iCh CS_DRIVER_NAME     " " sDriverID
89893>>>>>>>            If (bUseConnectionID = True) Begin
89895>>>>>>>                Writeln channel iCh CS_SERVER_NAME " " CS_DFCONNID "=" sConnectionID
89902>>>>>>>            End
89902>>>>>>>>
89902>>>>>>>            Else Begin
89903>>>>>>>                Writeln channel iCh CS_SERVER_NAME " " CS_SERVER "=" sConnectionString
89910>>>>>>>            End
89910>>>>>>>>
89910>>>>>>>            Writeln channel iCh CS_DATABASE_NAME          " " sDatabaseName
89915>>>>>>>            Writeln channel iCh CS_SCHEMA_NAME            " " (Lowercase(sSchemaName))
89920>>>>>>>            // There seems to be a new order how these are set from DF19.
89920>>>>>>>            If (bSysFile = True) Begin
89922>>>>>>>                Writeln channel iCh CS_RECNUM_TABLE       " " "NO"
89927>>>>>>>            End
89927>>>>>>>>
89927>>>>>>>            Writeln channel iCh CS_TABLE_CHARACTER_FORMAT " " sANSI_OEM
89932>>>>>>>            Writeln channel iCh CS_USE_DUMMY_ZERO_DATE    " " "YES" // ToDo: We maybe need to paramerize this setting?
89937>>>>>>>            If (bSysFile = True) Begin
89939>>>>>>>                Writeln channel iCh CS_SYSTEM_FILE        " " "YES"
89944>>>>>>>            End
89944>>>>>>>>
89944>>>>>>>
89944>>>>>>>            If (bSysFile = False) Begin
89946>>>>>>>                Move (SizeOfArray(sIndexArray)) to iSize
89947>>>>>>>                Move (SortArray(sIndexArray)) to sIndexArray
89948>>>>>>>                If (iSize > 0) Begin
89950>>>>>>>                    Writeln channel iCh (CS_PRIMARY_INDEX * String("0"))
89953>>>>>>>                    Writeln channel iCh // Just an empty line
89955>>>>>>>                End
89955>>>>>>>>
89955>>>>>>>                Decrement iSize
89956>>>>>>>                For iCount from 0 to iSize
89962>>>>>>>>
89962>>>>>>>                    Writeln channel iCh (CS_INDEX_NUMBER * String(iCount))
89965>>>>>>>                    Writeln channel iCh (CS_INDEX_NAME   * String(sIndexArray[iCount]))
89968>>>>>>>                    Writeln channel iCh
89970>>>>>>>                Loop
89971>>>>>>>>
89971>>>>>>>            End
89971>>>>>>>>
89971>>>>>>>        Send Seq_Close_Channel iCh
89972>>>>>>>
89972>>>>>>>        // Wait a sec for Windows to finish writing the file:
89972>>>>>>>        Sleep 1
89973>>>>>>>
89973>>>>>>>        Function_Return (bOK = True)
89974>>>>>>>    End_Function
89975>>>>>>>
89975>>>>>>>    // Returns a handle to the SQL server associated with the passed driver ID.
89975>>>>>>>    // Pass e.g. the psServer property to determine the current connection server.
89975>>>>>>>    // Returns a handle to the database connection, or a zero (0) if it fails.
89975>>>>>>>    // This handle can be used to obtain attributes about the server, such as default
89975>>>>>>>    // column types.
89975>>>>>>>    Function SqlUtilDatabaseHandle String sDriverID String sServer Returns Handle
89977>>>>>>>        Handle hDatabase
89977>>>>>>>        Integer iDriver iServers iCount
89977>>>>>>>        String sValue
89977>>>>>>>
89977>>>>>>>        If (sServer = "") Begin
89979>>>>>>>            Function_Return 0
89980>>>>>>>        End
89980>>>>>>>>
89980>>>>>>>
89980>>>>>>>        Get DriverIndex sDriverID to iDriver
89981>>>>>>>        If (iDriver = 0) Begin
89983>>>>>>>            Function_Return 0
89984>>>>>>>        End
89984>>>>>>>>
89984>>>>>>>
89984>>>>>>>        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iServers
89987>>>>>>>        For iCount from 1 to iServers
89993>>>>>>>>
89993>>>>>>>            Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
89996>>>>>>>            If (Uppercase(sValue) contains Uppercase(sServer)) Begin
89998>>>>>>>                Get_Attribute DF_DATABASE_ID of iDriver iCount to hDatabase
90001>>>>>>>            End
90001>>>>>>>>
90001>>>>>>>        Loop
90002>>>>>>>>
90002>>>>>>>
90002>>>>>>>        Function_Return hDatabase
90003>>>>>>>    End_Function
90004>>>>>>>
90004>>>>>>>//    Function UtilIsFilelistEntryDriverBased Integer hTable String sDriverID Returns Boolean
90004>>>>>>>//        String sRootName
90004>>>>>>>//        Boolean bOK
90004>>>>>>>//
90004>>>>>>>//        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
90004>>>>>>>//        Move (sRootName contains sDriverID) to bOK
90004>>>>>>>//
90004>>>>>>>//        Function_Return bOK
90004>>>>>>>//    End_Function
90004>>>>>>>
90004>>>>>>>//    Function UtilFilelistAddDriverInfo Integer hTable Returns Boolean
90004>>>>>>>//        String sDriverID sRootName sDisplayName sSchema sVal
90004>>>>>>>//        Integer iDbType
90004>>>>>>>//        Boolean bOK
90004>>>>>>>//
90004>>>>>>>//        Get UtilIsFilelistEntryDriverBased to bOK
90004>>>>>>>//        If (bOK = True) Begin
90004>>>>>>>//            Function_Return False
90004>>>>>>>//        End
90004>>>>>>>//
90004>>>>>>>//        Get psDriverID to sDriverID
90004>>>>>>>//        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
90004>>>>>>>//        Move (sDriverID + ":" + sRootName)           to sRootName
90004>>>>>>>//        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
90004>>>>>>>//
90004>>>>>>>//        Get psDriverID to sDriverID
90004>>>>>>>//        Get piDbType   to iDbType
90004>>>>>>>//        Get psSchema   to sSchema
90004>>>>>>>//        If (sSchema = "") Begin
90004>>>>>>>//            Get _SqlFindKeyWord CI_SQLDBO to sSchema
90004>>>>>>>//        End
90004>>>>>>>//
90004>>>>>>>//        Move (Uppercase(sDisplayName)) to sVal
90004>>>>>>>//        If (not(sVal contains (sSchema + "."))) Begin
90004>>>>>>>//            If (iDbType = EN_dbTypeDB2) Begin
90004>>>>>>>//                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
90004>>>>>>>//            End
90004>>>>>>>//            Else Begin
90004>>>>>>>//                Move (sSchema + "." + sDisplayName) to sDisplayName
90004>>>>>>>//            End
90004>>>>>>>//        End
90004>>>>>>>//
90004>>>>>>>//        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
90004>>>>>>>//        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
90004>>>>>>>//
90004>>>>>>>//        Function_Return True
90004>>>>>>>//    End_Function
90004>>>>>>>
90004>>>>>>>    // Removes all driver identifications (e.g. "MSSQLDRV:MyTable")
90004>>>>>>>    // from the passed filelist.
90004>>>>>>>    // Returns the number of tables affected.
90004>>>>>>>    Function SqlUtilFilelistRemoveDriverInfo String sFilelist Returns Integer
90006>>>>>>>        String sCurrentFileList sRootName sDisplayName sLogicalName sVal
90006>>>>>>>        Integer iRetval
90006>>>>>>>        Handle hTable
90006>>>>>>>
90006>>>>>>>        // We first save the current filelist as the passed filelist name
90006>>>>>>>        // may come from another workspace, to restore it when we're ready.
90006>>>>>>>        Get_Attribute DF_FILELIST_NAME to sCurrentFileList
90009>>>>>>>        Set_Attribute DF_FILELIST_NAME to sFilelist
90012>>>>>>>        Move 0 to hTable
90013>>>>>>>        Move 0 to iRetval
90014>>>>>>>
90014>>>>>>>        Repeat
90014>>>>>>>>
90014>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
90017>>>>>>>            If (hTable <> 0) Begin
90019>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
90022>>>>>>>                Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
90025>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
90028>>>>>>>                Move (Uppercase(sRootName)) to sVal
90029>>>>>>>                If (sVal contains MSSQLDRV_ID or sVal contains DB2_DRV_ID or sVal contains ODBC_DRV_ID) Begin
90031>>>>>>>                    // Prefixes:
90031>>>>>>>                    Move (Replace((MSSQLDRV_ID + ":"), sRootName, "")) to sRootName
90032>>>>>>>                    Move (Replace((DB2_DRV_ID  + ":"), sRootName, "")) to sRootName
90033>>>>>>>                    Move (Replace((ODBC_DRV_ID + ":"), sRootName, "")) to sRootName
90034>>>>>>>                    // Suffixes:
90034>>>>>>>                    Move (Replace(("." + MSSQLDRV_ID), sRootName, "")) to sRootName
90035>>>>>>>                    Move (Replace(("." + DB2_DRV_ID),  sRootName, "")) to sRootName
90036>>>>>>>                    Move (Replace(("." + ODBC_DRV_ID), sRootName, "")) to sRootName
90037>>>>>>>
90037>>>>>>>                    // Change Filelist entry:
90037>>>>>>>                    Set_Attribute DF_FILE_ROOT_NAME of hTable          to sRootName
90040>>>>>>>
90040>>>>>>>                    Move (Lowercase(sDisplayName)) to sVal
90041>>>>>>>                    If (sVal contains "dbo.") Begin
90043>>>>>>>                        Move (Replace("dbo.", sDisplayName, ""))       to sDisplayName
90044>>>>>>>
90044>>>>>>>                        // Change Filelist entry:
90044>>>>>>>                        Set_Attribute DF_FILE_DISPLAY_NAME of hTable   to sDisplayName
90047>>>>>>>                    End
90047>>>>>>>>
90047>>>>>>>                    Increment iRetval
90048>>>>>>>                End
90048>>>>>>>>
90048>>>>>>>            End
90048>>>>>>>>
90048>>>>>>>        Until (hTable = 0)
90050>>>>>>>
90050>>>>>>>        Set_Attribute DF_FILELIST_NAME to sCurrentFileList
90053>>>>>>>
90053>>>>>>>        Function_Return iRetval
90054>>>>>>>    End_Function
90055>>>>>>>
90055>>>>>>>    // To open all Sql based tables in Filelist.cfg
90055>>>>>>>    Procedure SqlUtilOpenAllTables
90057>>>>>>>        Handle hTable
90057>>>>>>>        String sRoot sDriverID
90057>>>>>>>        Boolean bOK
90057>>>>>>>
90057>>>>>>>        Move 0 to hTable
90058>>>>>>>        Move "" to sDriverID
90059>>>>>>>        Get AutoConnectionIDLogin to bOK
90060>>>>>>>
90060>>>>>>>        Repeat
90060>>>>>>>>
90060>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
90063>>>>>>>            If (hTable > 0) Begin
90065>>>>>>>                Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
90068>>>>>>>                If (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) Begin
90070>>>>>>>                    Get_Attribute DF_FILE_ROOT_NAME of hTable to sRoot
90073>>>>>>>                    If (Uppercase(sRoot) contains ".INT" or Uppercase(sRoot) contains MSSQLDRV_ID or Uppercase(sRoot) contains DB2_DRV_ID or Uppercase(sRoot) contains ODBC_DRV_ID) Begin
90075>>>>>>>                        Open hTable
90077>>>>>>>                    End
90077>>>>>>>>
90077>>>>>>>                End
90077>>>>>>>>
90077>>>>>>>            End
90077>>>>>>>>
90077>>>>>>>
90077>>>>>>>        Until (hTable = 0)
90079>>>>>>>    End_Procedure
90080>>>>>>>
90080>>>>>>>//    Function SqlUtilSchemaName Handle hTable Returns String
90080>>>>>>>//        String sRetval sDriverID
90080>>>>>>>//        String sTableName
90080>>>>>>>//        Integer iDbType iIndex
90080>>>>>>>//        Boolean bOK
90080>>>>>>>//
90080>>>>>>>//        Get psDriverID to sDriverID
90080>>>>>>>//        Get _SqlCheckCurrentDriver sDriverID to bOK
90080>>>>>>>//        If (hTable = 0 or bOK = False) Begin
90080>>>>>>>//            Function_Return ""
90080>>>>>>>//        End
90080>>>>>>>//
90080>>>>>>>//        Move False to Err
90080>>>>>>>//        Get UtilTableHandleToString hTable to sTableName
90080>>>>>>>//        Get piDbType to iDbType
90080>>>>>>>//        Get _SqlUtilEnumerateTableIndex sTableName sDriverID to iIndex
90080>>>>>>>//        If (iIndex = -1) Begin
90080>>>>>>>//            Function_Return ""
90080>>>>>>>//        End
90080>>>>>>>//
90080>>>>>>>//        Function_Return sRetval
90080>>>>>>>//    End_Function
90080>>>>>>>
90080>>>>>>>    // Checks if the passed Table;
90080>>>>>>>    // 1) Already has a Filelist entry that points to SQL and
90080>>>>>>>    // 2) It has an .int file.
90080>>>>>>>    // If both is True it should already be connected to SQL
90080>>>>>>>    Function SqlUtilTableIsAttached String sDriverID Handle hTable Returns Boolean
90082>>>>>>>        Boolean bExists bRootName
90082>>>>>>>        String sRootName sDataPath
90082>>>>>>>
90082>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
90085>>>>>>>        Move (sRootName contains sDriverID) to bRootName
90086>>>>>>>
90086>>>>>>>        Get psDataPathFirstPart to sDataPath
90087>>>>>>>        Get vFolderExists sDataPath to bExists
90088>>>>>>>        If (bExists = False) Begin
90090>>>>>>>            // If the path doesn't exist it cannot have an .int file and we're done, although it shouldn't happen.
90090>>>>>>>            Function_Return False
90091>>>>>>>        End
90091>>>>>>>>
90091>>>>>>>
90091>>>>>>>        Get vFolderFormat sDataPath to sDataPath
90092>>>>>>>        Get _TableNameOnly sRootName to sRootName
90093>>>>>>>        Get vFilePathExists (sDataPath + sRootName + ".int") to bExists
90094>>>>>>>
90094>>>>>>>        Function_Return (bRootName = True and bExists = True)
90095>>>>>>>    End_Function
90096>>>>>>>
90096>>>>>>>    Function SqlUtilTableIsViewType String sDriverID Handle hTable Returns Boolean
90098>>>>>>>        Boolean bViewTableType bOpen bOK
90098>>>>>>>        Integer iTableCount iNumTables
90098>>>>>>>        String sTableName sOwner sTableType sEnumTableName sEnumSchemaName
90098>>>>>>>        Handle hoCliHandler
90098>>>>>>>        tSQLConnection SQLConnection
90098>>>>>>>        tSQLConnection SQLConnection
90098>>>>>>>
90098>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
90101>>>>>>>        If (bOpen = False) Begin
90103>>>>>>>            Get AutoConnectionIDLogin to bOK
90104>>>>>>>            Open hTable
90106>>>>>>>        End
90106>>>>>>>>
90106>>>>>>>
90106>>>>>>>        Get pSQLConnection to SQLConnection
90107>>>>>>>        Get phoCLIHandler to hoCliHandler
90108>>>>>>>        Set psDriverID of hoCliHandler to sDriverID
90109>>>>>>>
90109>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
90112>>>>>>>        Get _TableNameOnly sTableName to sTableName
90113>>>>>>>        Get_Attribute DF_FILE_OWNER     of hTable to sOwner
90116>>>>>>>        Get EnumerateTables of hoCliHandler SQLConnection.sConnectionString to iNumTables
90117>>>>>>>
90117>>>>>>>        For iTableCount from 1 to iNumTables
90123>>>>>>>>
90123>>>>>>>            Get TableName  of hoCliHandler iTableCount to sEnumTableName
90124>>>>>>>            Get SchemaName of hoCliHandler iTableCount to sEnumSchemaName
90125>>>>>>>            If ((Uppercase(sEnumTableName)  = Uppercase(sTableName)) and (Uppercase(sEnumSchemaName) = Uppercase(sOwner))) Begin
90127>>>>>>>                Get TableType of hoCliHandler iTableCount to sTableType
90128>>>>>>>                Move iNumTables to iTableCount // We're done.
90129>>>>>>>            End
90129>>>>>>>>
90129>>>>>>>        Loop
90130>>>>>>>>
90130>>>>>>>
90130>>>>>>>        Move (sTableType = "VIEW") to bViewTableType
90131>>>>>>>        If (bOpen = False) Begin
90133>>>>>>>            Close hTable
90134>>>>>>>        End
90134>>>>>>>>
90134>>>>>>>
90134>>>>>>>        Function_Return bViewTableType
90135>>>>>>>    End_Function
90136>>>>>>>
90136>>>>>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
90136>>>>>>>    //
90136>>>>>>>    // SQL utility function that returns a database type (string) constant
90136>>>>>>>    // corresponding to the passed iDbType.
90136>>>>>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
90138>>>>>>>        String sRetval
90138>>>>>>>        Get SqlUtilDbTypeToString of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
90139>>>>>>>        Function_Return sRetval
90140>>>>>>>    End_Function
90141>>>>>>>
90141>>>>>>>    // SQL utility function that returns a database type constant (integer)
90141>>>>>>>    // corresponding to the passed sDbType string constant.
90141>>>>>>>    Function SqlUtilDbTypeToInteger String sDbType Returns Integer
90143>>>>>>>        Integer iRetval
90143>>>>>>>        Get SqlUtilDbTypeToInteger of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDbType to iRetval
90144>>>>>>>        Function_Return iRetval
90145>>>>>>>    End_Function
90146>>>>>>>
90146>>>>>>>    // Pass an integer DbType and function returns the database type integer as a string value.
90146>>>>>>>    // Used e.g. when reading a connection ini-file to display the database type in
90146>>>>>>>    // the SQL Connection program's grid.
90146>>>>>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
90148>>>>>>>        String sRetval
90148>>>>>>>        Get SqlUtilDbTypeIntegerToStringConstant of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
90149>>>>>>>        Function_Return sRetval
90150>>>>>>>    End_Function
90151>>>>>>>
90151>>>>>>>    // Pass a driver name as a string and the function will return
90151>>>>>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
90151>>>>>>>    // quite work and always returns "MS SQL Server"
90151>>>>>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
90153>>>>>>>        Integer iRetval
90153>>>>>>>        Get SqlUtilDbTypeFromDriver of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDriverID to iRetval
90154>>>>>>>        Function_Return iRetval
90155>>>>>>>    End_Function
90156>>>>>>>
90156>>>>>>>    // Returns a temp table name that consists of the RootName, an underscore and as much of a GUID
90156>>>>>>>    // that "fits" in the max allowed length for table names.
90156>>>>>>>    // Max number of characters allowed for table names;
90156>>>>>>>    // IBM DB2      = 128
90156>>>>>>>    // MS-SQL       = 128
90156>>>>>>>    // Oracle       = 128 (Version 12.2 and later. 30 characters for earlier versions)
90156>>>>>>>    // MySQL        = 64
90156>>>>>>>    // PostgreSQL   = 64
90156>>>>>>>    Function SqlUtilGUIDTempTableName String sRootName Returns String
90158>>>>>>>        String sGUIDName
90158>>>>>>>        Integer iDbType iLength
90158>>>>>>>
90158>>>>>>>        Get piDbType to iDbType
90159>>>>>>>        Move (RandomHexUUID()) to sGUIDName
90160>>>>>>>        Move (sRootName + "_" + sGUIDName) to sGUIDName
90161>>>>>>>        Move (Length(sGUIDName)) to iLength
90162>>>>>>>
90162>>>>>>>        Case Begin
90162>>>>>>>            Case (iDbType = EN_DbTypeDB2)
90164>>>>>>>            If (iLength > 128) Begin
90166>>>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
90167>>>>>>>            End
90167>>>>>>>>
90167>>>>>>>            Case Break
90168>>>>>>>
90168>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
90171>>>>>>>            If (iLength > 128) Begin
90173>>>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
90174>>>>>>>            End
90174>>>>>>>>
90174>>>>>>>            Case Break
90175>>>>>>>
90175>>>>>>>            Case (iDbType = EN_DbTypeOracle) // Note: We assume an Oracle version of 12.2 or later.
90178>>>>>>>            If (iLength > 128) Begin
90180>>>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
90181>>>>>>>            End
90181>>>>>>>>
90181>>>>>>>            Case Break
90182>>>>>>>
90182>>>>>>>            Case (iDbType = EN_DbTypeMySQL)
90185>>>>>>>            If (iLength > 64) Begin
90187>>>>>>>                Move (Left(sGUIDName, 64)) to sGUIDName
90188>>>>>>>            End
90188>>>>>>>>
90188>>>>>>>            Case Break
90189>>>>>>>
90189>>>>>>>            Case (iDbType = EN_DbTypePostgre)
90192>>>>>>>            If (iLength > 64) Begin
90194>>>>>>>                Move (Left(sGUIDName, 64)) to sGUIDName
90195>>>>>>>            End
90195>>>>>>>>
90195>>>>>>>        Case End
90195>>>>>>>
90195>>>>>>>        Function_Return sGUIDName
90196>>>>>>>    End_Function
90197>>>>>>>
90197>>>>>>>    // Reads a resource that has been embedded by the compiler and writes it to disk.
90197>>>>>>>    // Pass the memory resource file reference and the filename to be created,
90197>>>>>>>    // including full path.
90197>>>>>>>    Procedure SqlUtilCreateFileFromMemory String sMemFileName String sFileName
90199>>>>>>>        String sText
90199>>>>>>>        Integer iCh iSize iArgSize
90199>>>>>>>
90199>>>>>>>        Move ("Resource:" + sMemFileName) to sMemFileName
90200>>>>>>>        Get Seq_Open_Input_Channel sMemFileName to iCh
90201>>>>>>>        Get_Channel_Size iCh to iSize
90202>>>>>>>        Read_Block channel iCh sText iSize
90204>>>>>>>        Send Seq_Close_Channel iCh
90205>>>>>>>
90205>>>>>>>        Get Seq_Open_Output_Channel sFileName to iCh
90206>>>>>>>            Write channel iCh sText
90208>>>>>>>        Send Seq_Close_Channel iCh
90209>>>>>>>
90209>>>>>>>        // Wait for file to be written to disk.
90209>>>>>>>        Sleep 2
90210>>>>>>>    End_Procedure
90211>>>>>>>
90211>>>>>>>    Function SqlUtilDefaultNullValue String sDriverID Integer iDbType Integer iDataType Returns String
90213>>>>>>>        String sNotNull sRetval sDefaultValue
90213>>>>>>>        Boolean bOK
90213>>>>>>>
90213>>>>>>>        Get IsSQLDriver sDriverID to bOK
90214>>>>>>>        If (bOK = False) Begin
90216>>>>>>>            Function_Return ""
90217>>>>>>>        End
90217>>>>>>>>
90217>>>>>>>
90217>>>>>>>        Get UtilDataTypeDefaultValue sDriverID iDbType iDataType to sDefaultValue
90218>>>>>>>        Get _SqlFindKeyWord CI_SQLNotNull to sNotNull
90219>>>>>>>
90219>>>>>>>        Case Begin
90219>>>>>>>            Case (iDbType = EN_dbTypeMSSQL)
90221>>>>>>>                Move ("DEFAULT" * String(sDefaultValue) * String(sNotNull)) to sRetval
90222>>>>>>>                Case Break
90223>>>>>>>            Case (iDbType = EN_dbTypeMySQL)
90226>>>>>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
90227>>>>>>>                Case Break
90228>>>>>>>            Case (iDbType = EN_dbTypePostgre)
90231>>>>>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
90232>>>>>>>                Case Break
90233>>>>>>>            Case (iDbType = EN_dbTypeDB2)
90236>>>>>>>                Move (String(sNotNull))                                     to sRetval
90237>>>>>>>                Case Break
90238>>>>>>>
90238>>>>>>>            // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
90238>>>>>>>            // ToDo: We need to look deeper into how Oracle handles NULL
90238>>>>>>>            Case (iDbType = EN_dbTypeOracle)
90241>>>>>>>                Move  ""                                                    to sRetval
90242>>>>>>>                Case Break
90243>>>>>>>
90243>>>>>>>            Case Else
90243>>>>>>>                Move  ""                                                    to sRetval
90244>>>>>>>        Case End
90244>>>>>>>
90244>>>>>>>        Function_Return sRetval
90245>>>>>>>    End_Function
90246>>>>>>>
90246>>>>>>>    Function SqlUtilUpdateIntFile Integer hTable Returns Boolean
90248>>>>>>>        String sOrgFormat sNewFormat sRootName sDatabaseName sPhysicalFileName sDriverID sDataPath
90248>>>>>>>        Boolean bOpened bOK bMertech
90248>>>>>>>
90248>>>>>>>        // For some reason this .int file update screws up of CodeMast & CodeType .int files
90248>>>>>>>        // which makes the program unable to run because they can't be opened.
90248>>>>>>>        // ToDo: This needs further investigation but for now we just skip CodeMast & CodeType .int files update...
90248>>>>>>>        // Also note that there is another helper function "UtilTableCreateCodeMastCodeTypeIntFiles" to create
90248>>>>>>>        // proper .int files for the two tables.
90248>>>>>>>        If (Uppercase(sDatabaseName) = "CODETYPE" or Uppercase(sDatabaseName) = "CODEMAST") Begin
90250>>>>>>>            Function_Return True
90251>>>>>>>        End
90251>>>>>>>>
90251>>>>>>>
90251>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
90254>>>>>>>        Get _TableNameOnly sRootName to sDatabaseName
90255>>>>>>>        Move CS_OEM_Txt  to sOrgFormat
90256>>>>>>>        Move CS_ANSI_Txt to sNewFormat
90257>>>>>>>        Get AutoConnectionIDLogin to bOK
90258>>>>>>>
90258>>>>>>>        // It seems this can be called to quickly; causing a 13001 error "Cannot open cache file for write"
90258>>>>>>>        Sleep 1
90259>>>>>>>
90259>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
90262>>>>>>>        If (bOpened = False) Begin
90264>>>>>>>            Open hTable
90266>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpened
90269>>>>>>>        End
90269>>>>>>>>
90269>>>>>>>        If (bOpened = False) Begin
90271>>>>>>>            Function_Return False
90272>>>>>>>        End
90272>>>>>>>>
90272>>>>>>>
90272>>>>>>>        Get psDriverID to sDriverID
90273>>>>>>>        Get IsMertechDriver sDriverID to bMertech
90274>>>>>>>        If (bMertech = True) Begin
90276>>>>>>>            Get psDataPathFirstPart to sDataPath
90277>>>>>>>            Get vFolderExists sDataPath to bOK
90278>>>>>>>            If (bOK = False) Begin
90280>>>>>>>                Error DFERR_PROGRAM "Function SqlUtilUpdateIntFile; psDataPath not found!"
90281>>>>>>>>
90281>>>>>>>                Function_Return False
90282>>>>>>>            End
90282>>>>>>>>
90282>>>>>>>            Get vFolderFormat sDataPath to sDataPath
90283>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
90286>>>>>>>            Get _TableNameOnly sRootName to sDatabaseName
90287>>>>>>>            Move sDatabaseName to sPhysicalFileName
90288>>>>>>>            Move (sPhysicalFileName + ".int") to sPhysicalFileName
90289>>>>>>>            Get _MertechSqlUtilCreateIntFile hTable sDatabaseName sDataPath sPhysicalFileName to bOK
90290>>>>>>>            Function_Return (bOK = True)
90291>>>>>>>        End
90291>>>>>>>>
90291>>>>>>>
90291>>>>>>>        Move False to Err
90292>>>>>>>        Get_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
90295>>>>>>>        Move (Uppercase(sOrgFormat)) to sOrgFormat
90296>>>>>>>        // Lets swap the OEM/ANSI format, just to make a change in Structure_Start below (and back),
90296>>>>>>>        // to "touch" the table so the driver feels there has been a change and updates the .int file.
90296>>>>>>>        Move (If(sOrgFormat = CS_OEM_Txt, CS_ANSI_Txt, CS_OEM_Txt)) to sNewFormat
90297>>>>>>>
90297>>>>>>>        Move False to Err
90298>>>>>>>
90298>>>>>>>        If (hTable > 0) Begin
90300>>>>>>>            Structure_Start hTable
90301>>>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
90304>>>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
90307>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
90309>>>>>>>        End
90309>>>>>>>>
90309>>>>>>>        Else Begin
90310>>>>>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
90313>>>>>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
90316>>>>>>>        End
90316>>>>>>>>
90316>>>>>>>        Function_Return (Err = False)
90317>>>>>>>    End_Function
90318>>>>>>>
90318>>>>>>>    Function SqlProcedureArrayMertech String sStmt String sArgument Returns String[]
90320>>>>>>>        String[] sReturnArray
90321>>>>>>>        String sValue // sUserID sPassword
90321>>>>>>>        Handle hoSQLHandler hoSQLConnect hStmt
90321>>>>>>>        Integer iFetchResult iRetval
90321>>>>>>>        tSQLConnection SQLConnection
90321>>>>>>>        tSQLConnection SQLConnection
90321>>>>>>>
90321>>>>>>>        Get _MertechSQLManagerHandle to hoSQLHandler
90322>>>>>>>        If (hoSQLHandler <> 0) Begin
90324>>>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
90325>>>>>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
90326>>>>>>>            If (hoSQLConnect <> 0) Begin
90328>>>>>>>                Get SQLOpen of hoSQLConnect to hStmt
90329>>>>>>>                If (hStmt <> 0) Begin
90331>>>>>>>                    Send SQLSetProcedureName of hStmt sStmt
90332>>>>>>>                    If (sArgument <> "") Begin
90334>>>>>>>                        Send SqlSetArgument  of hStmt 1 sArgument
90335>>>>>>>                    End
90335>>>>>>>>
90335>>>>>>>                    Send SQLCall of hStmt
90336>>>>>>>
90336>>>>>>>                    Get SqlReturnValue       of hStmt to iRetval
90337>>>>>>>                    If (iRetval = 0) Begin
90339>>>>>>>                        Repeat
90339>>>>>>>>
90339>>>>>>>                            Get SQLFetch of hStmt to iFetchResult
90340>>>>>>>                            If (iFetchResult <> 0) Begin
90342>>>>>>>                                Get SQLColumnValue of hStmt 1 to sValue
90343>>>>>>>                                Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
90344>>>>>>>                            End
90344>>>>>>>>
90344>>>>>>>                        Until (iFetchResult = 0)
90346>>>>>>>                        Send SQLClose of hStmt
90347>>>>>>>                    End
90347>>>>>>>>
90347>>>>>>>                End
90347>>>>>>>>
90347>>>>>>>                Send SQLDisconnect of hoSQLConnect
90348>>>>>>>            End
90348>>>>>>>>
90348>>>>>>>        End
90348>>>>>>>>
90348>>>>>>>
90348>>>>>>>        Function_Return sReturnArray
90349>>>>>>>    End_Function
90350>>>>>>>
90350>>>>>>>    // * Dummy function for the Studio's Code Explorer *
90350>>>>>>>    Function SQL_ENUMERATION_FUNCTIONS Returns Boolean
90352>>>>>>>        Function_Return False
90353>>>>>>>    End_Function
90354>>>>>>>
90354>>>>>>>    // Enumerate SQL Servers.
90354>>>>>>>    // Pass a driver id. Returns a string array.
90354>>>>>>>    // The iDataSourceType (iDatSrcType) parameter is optional and is for the ODBC driver only.
90354>>>>>>>    // Note: Returns servers for MSSQLDRV; else data-sources on the machine.
90354>>>>>>>    Function SqlUtilEnumerateServers String sDriverID Integer iDatSrcType Returns String[]
90356>>>>>>>        String[] sReturnArray
90357>>>>>>>        Handle hoSQLHandler
90357>>>>>>>        String sServer
90357>>>>>>>        Integer iCount iNumItems iDataSourceType
90357>>>>>>>
90357>>>>>>>        If (num_arguments > 1) Begin
90359>>>>>>>            Move iDatSrcType to iDataSourceType
90360>>>>>>>        End
90360>>>>>>>>
90360>>>>>>>
90360>>>>>>>        Case Begin
90360>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
90362>>>>>>>                Get phoMSSQLHandler to hoSQLHandler
90363>>>>>>>                Get EnumerateServers of hoSQLHandler to iNumItems
90364>>>>>>>                For iCount from 0 to (iNumItems - 1)
90370>>>>>>>>
90370>>>>>>>                    Get String_Value of hoSQLHandler iCount to sServer
90371>>>>>>>                    Move (Trim(sServer)) to sReturnArray[iCount]
90372>>>>>>>                Loop
90373>>>>>>>>
90373>>>>>>>                Case Break
90374>>>>>>>
90374>>>>>>>            Case (sDriverID = DB2_DRV_ID)
90377>>>>>>>                Get phoDB2SQLHandler to hoSQLHandler
90378>>>>>>>                Send SeedDataSources of hoSQLHandler
90379>>>>>>>                Move 0 to iCount
90380>>>>>>>                Repeat
90380>>>>>>>>
90380>>>>>>>                    Get DataSources of hoSQLHandler to sServer
90381>>>>>>>                    If (sServer <> "") Begin
90383>>>>>>>                        Move (Replace(",", sServer, "")) to sServer
90384>>>>>>>                        Move sServer to sReturnArray[iCount]
90385>>>>>>>                    End
90385>>>>>>>>
90385>>>>>>>                    Increment iCount
90386>>>>>>>                Until (sServer = "")
90388>>>>>>>                Case Break
90389>>>>>>>
90389>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
90392>>>>>>>                Get phoODBCSQLHandler to hoSQLHandler
90393>>>>>>>                Set DataSourceType of hoSQLHandler to iDataSourceType
90394>>>>>>>                Move 0 to iCount
90395>>>>>>>                Repeat
90395>>>>>>>>
90395>>>>>>>                    Get DataSources of hoSQLHandler to sServer
90396>>>>>>>                    If (sServer <> "") Begin
90398>>>>>>>                        Move (Replace(",", sServer, ", ")) to sServer
90399>>>>>>>                        Move sServer to sReturnArray[iCount]
90400>>>>>>>                    End
90400>>>>>>>>
90400>>>>>>>                    Increment iCount
90401>>>>>>>                Until (sServer = "")
90403>>>>>>>                Case Break
90404>>>>>>>
90404>>>>>>>            Case (sDriverID = SQLFLEX)
90407>>>>>>>                Get _MertechEnumerateSQLFlexServers to sReturnArray
90408>>>>>>>                Case Break
90409>>>>>>>
90409>>>>>>>            Case (sDriverID = ORAFLEX)
90412>>>>>>>                Get _MertechEnumerateORAFLEXServers to sReturnArray
90413>>>>>>>                Case Break
90414>>>>>>>
90414>>>>>>>            // There appearantly is no way to enumerate servers for this backend.
90414>>>>>>>            Case (sDriverID = MDSPgSQL)
90417>>>>>>>                Move "localhost" to sReturnArray[0]
90418>>>>>>>                Case Break
90419>>>>>>>
90419>>>>>>>            // There appearantly is no way to enumerate servers for this backend.
90419>>>>>>>            Case (sDriverID = MDSMySQL)
90422>>>>>>>                Move "localhost" to sReturnArray[0]
90423>>>>>>>                Case Break
90424>>>>>>>
90424>>>>>>>            Case Else
90424>>>>>>>                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateServers function"
90425>>>>>>>>
90425>>>>>>>        Case End
90425>>>>>>>
90425>>>>>>>        Function_Return sReturnArray
90426>>>>>>>    End_Function
90427>>>>>>>
90427>>>>>>>    // Returns all databases as a string array for the passed driver id.
90427>>>>>>>    Function SqlUtilEnumerateDatabases String sDriverID Returns String[]
90429>>>>>>>        String[] sReturnArray
90430>>>>>>>        String sServer sVal
90430>>>>>>>        tSQLIntTableInfo[] sReturnStructArray
90430>>>>>>>        tSQLIntTableInfo[] sReturnStructArray
90431>>>>>>>        tSQLConnection SQLConnection
90431>>>>>>>        tSQLConnection SQLConnection
90431>>>>>>>        Boolean bOK
90431>>>>>>>        Integer iCount iSize
90431>>>>>>>
90431>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
90432>>>>>>>        If (bOK = False) Begin
90434>>>>>>>            Function_Return sReturnArray
90435>>>>>>>        End
90435>>>>>>>>
90435>>>>>>>
90435>>>>>>>        Case Begin
90435>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
90437>>>>>>>                Get _SqlDatabasesArrayMSSQL to sReturnArray
90438>>>>>>>                Case Break
90439>>>>>>>            Case (sDriverID = DB2_DRV_ID)
90442>>>>>>>                Get _SqlDatabasesArrayDB2 to sReturnArray
90443>>>>>>>                Case Break
90444>>>>>>>
90444>>>>>>>            // This is needed to be able to check if a database exists or not.
90444>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
90447>>>>>>>                Get _SqlDatabasesArrayODBC to sReturnStructArray
90448>>>>>>>                If (SizeOfArray(sReturnStructArray)) Begin
90450>>>>>>>                    If (SizeOfArray(sReturnStructArray) = 1 and sReturnStructArray[0].sServerName = "") Begin
90452>>>>>>>                        // If a FILEDSN: (can only be one database name)
90452>>>>>>>                        Move sReturnStructArray[0].sDatabaseName to sReturnArray[0]
90453>>>>>>>                    End
90453>>>>>>>>
90453>>>>>>>                    Else Begin
90454>>>>>>>                        // Else the DSN's were read from the registry.
90454>>>>>>>                        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
90455>>>>>>>                        Move SQLConnection.sServer to sServer
90456>>>>>>>                        Move (SizeOfArray(sReturnStructArray)) to iSize
90457>>>>>>>                        Decrement iSize
90458>>>>>>>                        for iCount from 0 to iSize
90464>>>>>>>>
90464>>>>>>>                            Move (sReturnStructArray[iCount].sServerName) to sVal
90465>>>>>>>                            If (Uppercase(sServer) = Uppercase(sVal)) Begin
90467>>>>>>>                                Move sReturnStructArray[iCount].sDatabaseName to sReturnArray[0]
90468>>>>>>>                                Move iSize to iCount // We're done.
90469>>>>>>>                            End
90469>>>>>>>>
90469>>>>>>>                        Loop
90470>>>>>>>>
90470>>>>>>>                    End
90470>>>>>>>>
90470>>>>>>>                End
90470>>>>>>>>
90470>>>>>>>                Case Break
90471>>>>>>>
90471>>>>>>>            Case (sDriverID = SQLFLEX)
90474>>>>>>>                Get SqlProcedureArrayMertech "sp_databases" "" to sReturnArray
90475>>>>>>>                Case Break
90476>>>>>>>
90476>>>>>>>            Case (sDriverID = MDSPgSQL)
90479>>>>>>>                Get SqlEnumerateEsqlMertech "SELECT datname FROM pg_database" to sReturnArray
90480>>>>>>>                Case Break
90481>>>>>>>
90481>>>>>>>            Case (sDriverID = MDSMySQL)
90484>>>>>>>                Get SqlEnumerateEsqlMertech "show databases" to sReturnArray
90485>>>>>>>                Case Break
90486>>>>>>>
90486>>>>>>>            Case (sDriverID = ORAFLEX)
90489>>>>>>>                Get SqlEnumerateEsqlMertech "SELECT NAME FROM v$database" to sReturnArray
90490>>>>>>>                Case Break
90491>>>>>>>
90491>>>>>>>            Case Else
90491>>>>>>>//                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateDatabases function"
90491>>>>>>>        Case End
90491>>>>>>>
90491>>>>>>>        Function_Return sReturnArray
90492>>>>>>>    End_Function
90493>>>>>>>
90493>>>>>>>    // Returns all table spaces as a string array for the passed driver id.
90493>>>>>>>    Function SqlUtilEnumerateTableSpaces String sDriverID Returns String[]
90495>>>>>>>        String[] sReturnArray
90496>>>>>>>        Boolean bOK
90496>>>>>>>
90496>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
90497>>>>>>>        If (bOK = False) Begin
90499>>>>>>>            Function_Return sReturnArray
90500>>>>>>>        End
90500>>>>>>>>
90500>>>>>>>
90500>>>>>>>        Case Begin
90500>>>>>>>            Case (sDriverID = DB2_DRV_ID)
90502>>>>>>>                Get SqlEnumerateEsqlDAW "select tablespace_name from dba_tablespaces" 1 to sReturnArray
90503>>>>>>>                Case Break
90504>>>>>>>
90504>>>>>>>            Case (sDriverID = MDSPgSQL)
90507>>>>>>>                Get SqlEnumerateEsqlMertech "SELECT spcname FROM pg_tablespace" 1 to sReturnArray
90508>>>>>>>                Case Break
90509>>>>>>>
90509>>>>>>>            Case (sDriverID = ORAFLEX)
90512>>>>>>>                Get SqlEnumerateEsqlMertech "SELECT TABLESPACE_NAME FROM USER_TABLESPACES" 1 to sReturnArray
90513>>>>>>>                Case Break
90514>>>>>>>
90514>>>>>>>            Case Else
90514>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateTableSpaces function."
90515>>>>>>>>
90515>>>>>>>                Case Break
90516>>>>>>>        Case End
90516>>>>>>>
90516>>>>>>>        Function_Return sReturnArray
90517>>>>>>>    End_Function
90518>>>>>>>
90518>>>>>>>    // Returns all schemas as a string array for the passed driver id.
90518>>>>>>>    Function SqlUtilEnumerateSchemas String sDriverID Returns String[]
90520>>>>>>>        String[] sReturnArray
90521>>>>>>>        Boolean bOK
90521>>>>>>>
90521>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
90522>>>>>>>        If (bOK = False) Begin
90524>>>>>>>            Function_Return sReturnArray
90525>>>>>>>        End
90525>>>>>>>>
90525>>>>>>>
90525>>>>>>>        Case Begin
90525>>>>>>>            Case (sDriverID = DB2_DRV_ID)
90527>>>>>>>                Get SqlEnumerateEsqlDAW "select schemaname from syscat.schemata" 1 to sReturnArray
90528>>>>>>>                Case Break
90529>>>>>>>
90529>>>>>>>            Case (sDriverID = MDSPgSQL)
90532>>>>>>>                Get SqlEnumerateEsqlMertech "select schema_name from information_schema.schemata" 1 to sReturnArray
90533>>>>>>>                Case Break
90534>>>>>>>
90534>>>>>>>            Case (sDriverID = ORAFLEX)
90537>>>>>>>                Get SqlEnumerateEsqlMertech "SELECT username from dba_users WHERE default_tablespace not in ('SYSTEM','SYSAUX')" 1 to sReturnArray
90538>>>>>>>                Case Break
90539>>>>>>>
90539>>>>>>>            Case Else
90539>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateSchemas function."
90540>>>>>>>>
90540>>>>>>>                Case Break
90541>>>>>>>        Case End
90541>>>>>>>
90541>>>>>>>        Function_Return sReturnArray
90542>>>>>>>    End_Function
90543>>>>>>>
90543>>>>>>>    // Returns a string array with all tables for the current database.
90543>>>>>>>    Function SqlUtilEnumerateTables String sDriverID String sDatabase String sSchema Returns String[]
90545>>>>>>>        String[] sReturnArray sArray
90547>>>>>>>        String sConnectionString sSelect
90547>>>>>>>        Integer iSize iCount iDbType
90547>>>>>>>        Boolean bOK
90547>>>>>>>
90547>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
90549>>>>>>>            Function_Return sArray
90550>>>>>>>        End
90550>>>>>>>>
90550>>>>>>>
90550>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
90551>>>>>>>        If (bOK = False) Begin
90553>>>>>>>            Function_Return sReturnArray
90554>>>>>>>        End
90554>>>>>>>>
90554>>>>>>>        If (sSchema = "") Begin
90556>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
90557>>>>>>>        End
90557>>>>>>>>
90557>>>>>>>
90557>>>>>>>        Get psConnectionString to sConnectionString
90558>>>>>>>
90558>>>>>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
90558>>>>>>>        // the dbType.
90558>>>>>>>        Get piDbType to iDbType
90559>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
90561>>>>>>>            If (iDbType = EN_DbTypeMySQL) Begin
90563>>>>>>>                Move MDSMySQL to sDriverID
90564>>>>>>>            End
90564>>>>>>>>
90564>>>>>>>            If (iDbType = EN_DbTypeMSSQL) Begin
90566>>>>>>>                Move MSSQLDRV_ID to sDriverID
90567>>>>>>>            End
90567>>>>>>>>
90567>>>>>>>            If (iDbType = EN_DbTypeDB2) Begin
90569>>>>>>>                Move DB2_DRV_ID to sDriverID
90570>>>>>>>            End
90570>>>>>>>>
90570>>>>>>>            If (iDbType = EN_DbTypePostgre) Begin
90572>>>>>>>                Move MDSPgSQL to sDriverID
90573>>>>>>>            End
90573>>>>>>>>
90573>>>>>>>        End
90573>>>>>>>>
90573>>>>>>>
90573>>>>>>>        Case Begin
90573>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
90575>>>>>>>                Get _SqlTableArrayDAW to sReturnArray
90576>>>>>>>                Case Break
90577>>>>>>>
90577>>>>>>>            Case (sDriverID = DB2_DRV_ID)
90580>>>>>>>                Get _SqlTableArrayDAW to sReturnArray
90581>>>>>>>                Case Break
90582>>>>>>>
90582>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
90585>>>>>>>                Get _SqlTableArrayDAW to sReturnArray
90586>>>>>>>                Case Break
90587>>>>>>>
90587>>>>>>>            Case (sDriverID = SQLFLEX)
90590>>>>>>>                Move ("SELECT TABLE_NAME FROM" * sDatabase + ".INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE != 'VIEW'") to sSelect
90591>>>>>>>                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
90592>>>>>>>                Case Break
90593>>>>>>>
90593>>>>>>>            Case (sDriverID = MDSMySQL)
90596>>>>>>>                Move ("SELECT TABLE_NAME from INFORMATION_SCHEMA.TABLES where TABLE_SCHEMA = '" + sDatabase + "' and TABLE_TYPE = 'BASE TABLE' order by TABLE_NAME") to sSelect
90597>>>>>>>                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
90598>>>>>>>                Case Break
90599>>>>>>>
90599>>>>>>>            Case (sDriverID = MDSPgSQL)
90602>>>>>>>                Move "select tablename, schemaname from pg_catalog.pg_tables order by tablename"  to sSelect
90603>>>>>>>                Get SqlEnumerateEsqlMertech sSelect "" to sReturnArray
90604>>>>>>>                Case Break
90605>>>>>>>
90605>>>>>>>            Case (sDriverID = ORAFLEX)
90608>>>>>>>                Move "SELECT table_name from user_tables" to sSelect
90609>>>>>>>                Get SqlEnumerateEsqlMertech sSelect to sArray
90610>>>>>>>                Move (SizeOfArray(sArray)) to iSize
90611>>>>>>>                Decrement iSize
90612>>>>>>>                For iCount from 0 to iSize
90618>>>>>>>>
90618>>>>>>>                    If (not(sArray[iCount] contains "$")) Begin
90620>>>>>>>                        Move sArray[iCount] to sReturnArray[SizeOfArray(sReturnArray)]
90621>>>>>>>                    End
90621>>>>>>>>
90621>>>>>>>                Loop
90622>>>>>>>>
90622>>>>>>>                Case Break
90623>>>>>>>
90623>>>>>>>            Case Else
90623>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateTables function."
90624>>>>>>>>
90624>>>>>>>                Case Break
90625>>>>>>>        Case End
90625>>>>>>>
90625>>>>>>>        Function_Return sReturnArray
90626>>>>>>>    End_Function
90627>>>>>>>
90627>>>>>>>    // Returns a string array with all table columns/fields for the passed table handle and driver id.
90627>>>>>>>    Function SqlUtilEnumerateColumns String sDriverID String sTableName Returns String[]
90629>>>>>>>        String[] sReturnArray
90630>>>>>>>        String sConnectionString sSelect sSchema
90630>>>>>>>        Boolean bOK
90630>>>>>>>        Integer iDbType
90630>>>>>>>
90630>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
90631>>>>>>>        If (bOK = False) Begin
90633>>>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
90634>>>>>>>>
90634>>>>>>>            Function_Return sReturnArray
90635>>>>>>>        End
90635>>>>>>>>
90635>>>>>>>
90635>>>>>>>        Get psConnectionString to sConnectionString
90636>>>>>>>        Get psSchema to sSchema
90637>>>>>>>
90637>>>>>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
90637>>>>>>>        // the dbType.
90637>>>>>>>        Get piDbType to iDbType
90638>>>>>>>
90638>>>>>>>        Case Begin
90638>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
90640>>>>>>>                If (iDbType = EN_DbTypeMySQL) Begin
90642>>>>>>>                    Move ("SHOW COLUMNS FROM" * sTableName) to sSelect
90643>>>>>>>                End
90643>>>>>>>>
90643>>>>>>>                If (iDbType = EN_DbTypePostgre) Begin
90645>>>>>>>                    Move ("select column_name, data_type, character_maximum_length from INFORMATION_SCHEMA.COLUMNS where table_name = '" +sTableName + "'") to sSelect
90646>>>>>>>                End
90646>>>>>>>>
90646>>>>>>>                If (iDbType = EN_DbTypeMSSQL) Begin
90648>>>>>>>                    Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
90649>>>>>>>                End
90649>>>>>>>>
90649>>>>>>>
90649>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
90650>>>>>>>                Case Break
90651>>>>>>>
90651>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
90654>>>>>>>                Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
90655>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
90656>>>>>>>                Case Break
90657>>>>>>>
90657>>>>>>>            Case (sDriverID = DB2_DRV_ID)
90660>>>>>>>                Move ("SELECT colname from syscat.columns WHERE tabschema = '" + sSchema + "'" * "AND tabname = '" + sTableName + "'") to sSelect
90661>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
90662>>>>>>>                Case Break
90663>>>>>>>
90663>>>>>>>            Case (sDriverID = SQLFLEX)
90666>>>>>>>                Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
90667>>>>>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
90668>>>>>>>                Case Break
90669>>>>>>>
90669>>>>>>>            Case (sDriverID = MDSMySQL)
90672>>>>>>>                Move ("SHOW COLUMNS FROM" * sTableName) to sSelect
90673>>>>>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
90674>>>>>>>                Case Break
90675>>>>>>>
90675>>>>>>>            Case (sDriverID = MDSPgSQL)
90678>>>>>>>                Move ("select column_name, data_type, character_maximum_length from INFORMATION_SCHEMA.COLUMNS where table_name = '" +sTableName + "'") to sSelect
90679>>>>>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
90680>>>>>>>                Case Break
90681>>>>>>>
90681>>>>>>>            Case (sDriverID = ORAFLEX)
90684>>>>>>>                Move ("SELECT column_name from user_tab_cols WHERE table_name = '" + sTableName + "'") to sSelect
90685>>>>>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
90686>>>>>>>                Case Break
90687>>>>>>>
90687>>>>>>>            Case Else
90687>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateColumns function."
90688>>>>>>>>
90688>>>>>>>                Case Break
90689>>>>>>>        Case End
90689>>>>>>>
90689>>>>>>>        Function_Return sReturnArray
90690>>>>>>>    End_Function
90691>>>>>>>
90691>>>>>>>
90691>>>>>>>    // Returns a string array with all table indexes for the passed table handle and driver id.
90691>>>>>>>    Function SqlUtilEnumerateIndexes String sTableName String sDriverID Returns String[]
90693>>>>>>>        String[] sReturnArray sReturnArray2
90695>>>>>>>        String sConnectionString sSelect sSchema
90695>>>>>>>        Boolean bOK
90695>>>>>>>        Integer iCount iSize
90695>>>>>>>
90695>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
90696>>>>>>>        If (bOK = False) Begin
90698>>>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
90699>>>>>>>>
90699>>>>>>>            Function_Return sReturnArray
90700>>>>>>>        End
90700>>>>>>>>
90700>>>>>>>
90700>>>>>>>        Get psConnectionString to sConnectionString
90701>>>>>>>        Get psSchema to sSchema
90702>>>>>>>
90702>>>>>>>        Case Begin
90702>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
90704>>>>>>>                Move ("select * from sys.indexes where object_id = (select object_id from sys.objects where name = '" + sTableName + "')") to sSelect
90705>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
90706>>>>>>>                Case Break
90707>>>>>>>
90707>>>>>>>            Case (sDriverID = DB2_DRV_ID)
90710>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
90711>>>>>>>>
90711>>>>>>>//                Move () to sSelect
90711>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
90711>>>>>>>                Case Break
90712>>>>>>>
90712>>>>>>>            Case (sDriverID = SQLFLEX)
90715>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
90716>>>>>>>>
90716>>>>>>>//                Move () to sSelect
90716>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
90716>>>>>>>                Case Break
90717>>>>>>>
90717>>>>>>>            Case (sDriverID = MDSMySQL)
90720>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
90721>>>>>>>>
90721>>>>>>>//                Move () to sSelect
90721>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
90721>>>>>>>                Case Break
90722>>>>>>>
90722>>>>>>>            Case (sDriverID = MDSPgSQL)
90725>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
90726>>>>>>>>
90726>>>>>>>//                Move () to sSelect
90726>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
90726>>>>>>>                Case Break
90727>>>>>>>
90727>>>>>>>            Case (sDriverID = ORAFLEX)
90730>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
90731>>>>>>>>
90731>>>>>>>//                Move () to sSelect
90731>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
90731>>>>>>>                Case Break
90732>>>>>>>
90732>>>>>>>            Case Else
90732>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateIndexes function."
90733>>>>>>>>
90733>>>>>>>                Case Break
90734>>>>>>>        Case End
90734>>>>>>>
90734>>>>>>>        Move (SizeOfArray(sReturnArray)) to iSize
90735>>>>>>>        Decrement iSize
90736>>>>>>>        For iCount from 0 to iSize
90742>>>>>>>>
90742>>>>>>>            If (Trim(sReturnArray[iCount]) <> "") Begin
90744>>>>>>>                Move sReturnArray[iCount] to sReturnArray2[SizeOfArray(sReturnArray2)]
90745>>>>>>>            End
90745>>>>>>>>
90745>>>>>>>        Loop
90746>>>>>>>>
90746>>>>>>>
90746>>>>>>>        Function_Return sReturnArray2
90747>>>>>>>    End_Function
90748>>>>>>>
90748>>>>>>>    // Returns a string array with all table names the passed table handle has relation ships with.
90748>>>>>>>    // The format of the array is "TableName.FieldName"
90748>>>>>>>    Function SqlUtilEnumerateRelations String sTableName String sDriverID Returns tSQLRelation[]
90750>>>>>>>        String[] sFileNameArray sFieldNameArray
90752>>>>>>>        tSQLRelation[] sRelationsArray
90752>>>>>>>        tSQLRelation[] sRelationsArray
90753>>>>>>>        String sConnectionString sSelect sSchema sFileName sFieldName
90753>>>>>>>        Boolean bOK
90753>>>>>>>        Integer iCount iSize iLength
90753>>>>>>>
90753>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
90754>>>>>>>        If (bOK = False) Begin
90756>>>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
90757>>>>>>>>
90757>>>>>>>            Function_Return sRelationsArray
90758>>>>>>>        End
90758>>>>>>>>
90758>>>>>>>
90758>>>>>>>        Get psConnectionString to sConnectionString
90759>>>>>>>        Get psSchema to sSchema
90760>>>>>>>
90760>>>>>>>        Case Begin
90760>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
90762>>>>>>>                Move ("SELECT object_name(parent_object_id), object_name(referenced_object_id), name from sys.foreign_keys WHERE parent_object_id = object_id( '" + sTableName + "')") to sSelect
90763>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 2 to sFileNameArray
90764>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
90765>>>>>>>                Case Break
90766>>>>>>>
90766>>>>>>>            Case (sDriverID = DB2_DRV_ID)
90769>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
90770>>>>>>>>
90770>>>>>>>//                Move () to sSelect
90770>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
90770>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
90770>>>>>>>                Case Break
90771>>>>>>>
90771>>>>>>>            Case (sDriverID = SQLFLEX)
90774>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
90775>>>>>>>>
90775>>>>>>>//                Move () to sSelect
90775>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
90775>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
90775>>>>>>>                Case Break
90776>>>>>>>
90776>>>>>>>            Case (sDriverID = MDSMySQL)
90779>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
90780>>>>>>>>
90780>>>>>>>//                Move () to sSelect
90780>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
90780>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
90780>>>>>>>                Case Break
90781>>>>>>>
90781>>>>>>>            Case (sDriverID = MDSPgSQL)
90784>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
90785>>>>>>>>
90785>>>>>>>//                Move () to sSelect
90785>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
90785>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
90785>>>>>>>                Case Break
90786>>>>>>>
90786>>>>>>>            Case (sDriverID = ORAFLEX)
90789>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
90790>>>>>>>>
90790>>>>>>>//                Move () to sSelect
90790>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
90790>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
90790>>>>>>>                Case Break
90791>>>>>>>
90791>>>>>>>            Case Else
90791>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to the SqlUtilEnumerateRelations function."
90792>>>>>>>>
90792>>>>>>>                Case Break
90793>>>>>>>        Case End
90793>>>>>>>
90793>>>>>>>        Move (Length(sTableName)) to iLength
90794>>>>>>>        Move (iLength + 4)        to iLength // The related to field key has the format "FK_TableName + FieldName"
90795>>>>>>>        Move (SizeOfArray(sFileNameArray)) to iSize
90796>>>>>>>        Decrement iSize
90797>>>>>>>        For iCount from 0 to iSize
90803>>>>>>>>
90803>>>>>>>            If (Trim(sFileNameArray[iCount]) <> "") Begin
90805>>>>>>>                Move sFileNameArray[iCount]         to sFileName
90806>>>>>>>                Move sFieldNameArray[iCount]        to sFieldName
90807>>>>>>>                Move (Mid(sFieldName, 99, iLength)) to sFieldName
90808>>>>>>>                Move sFileName  to sRelationsArray[iCount].sFileName
90809>>>>>>>                Move sFieldName to sRelationsArray[iCount].sFieldName
90810>>>>>>>            End
90810>>>>>>>>
90810>>>>>>>        Loop
90811>>>>>>>>
90811>>>>>>>
90811>>>>>>>        Function_Return sRelationsArray
90812>>>>>>>    End_Function
90813>>>>>>>
90813>>>>>>>    Function SqlUtilEnumerateLoggedInUsers String sDriverID String sDatabase Returns tSQLLoggedInUser[]
90815>>>>>>>        tSQLLoggedInUser[] SQLLoggedInUser
90815>>>>>>>        tSQLLoggedInUser[] SQLLoggedInUser
90816>>>>>>>        String[] sUsers sPrograms
90818>>>>>>>        String sSelect
90818>>>>>>>        Integer iSize iCount
90818>>>>>>>
90818>>>>>>>        Case Begin
90818>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
90820>>>>>>>                Move ("SELECT RTRIM(SP.nt_username) AS Inlog, RTRIM(SP.program_name) as Programma from master.dbo.sysprocesses SP INNER JOIN master.dbo.sysdatabases SD ON SP.dbid = SD.dbid WHERE (SP.nt_username <> '') and (SP.nt_username <> 'SYSTEM') and (SD.name = '" ;                + sDatabase + "') ORDER by Inlog") to sSelect
90821>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sUsers
90822>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 2 to sPrograms
90823>>>>>>>                Case Break
90824>>>>>>>            Case (sDriverID = SQLFLEX)
90827>>>>>>>                Move ("SELECT RTRIM(SP.nt_username) AS Inlog, RTRIM(SP.program_name) as Programma from master.dbo.sysprocesses SP INNER JOIN master.dbo.sysdatabases SD ON SP.dbid = SD.dbid WHERE (SP.nt_username <> '') and (SP.nt_username <> 'SYSTEM') and (SD.name = '" ;                + sDatabase + "') ORDER by Inlog") to sSelect
90828>>>>>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sUsers
90829>>>>>>>                Get SqlEnumerateEsqlMertech sSelect 2 to sPrograms
90830>>>>>>>                Case Break
90831>>>>>>>            Case Else
90831>>>>>>>                Error DFERR_PROGRAM ("Not implemented yet for this driver (" + sDriverID + ")")
90832>>>>>>>>
90832>>>>>>>        Case End
90832>>>>>>>
90832>>>>>>>        Move (SizeOfArray(sUsers)) to iSize
90833>>>>>>>        Decrement iSize
90834>>>>>>>        For iCount from 0 to iSize
90840>>>>>>>>
90840>>>>>>>            Move sUsers[iCount]    to SQLLoggedInUser[iCount].sUser
90841>>>>>>>            Move sPrograms[iCount] to SQLLoggedInUser[iCount].sProgram
90842>>>>>>>        Loop
90843>>>>>>>>
90843>>>>>>>
90843>>>>>>>        Function_Return SQLLoggedInUser
90844>>>>>>>    End_Function
90845>>>>>>>
90845>>>>>>>    // Returns an array with all ".int" files for the passed sDataPath, _except_ for the driver .int files;
90845>>>>>>>    // "MSSQLDRV.int", "DB2_DRV.int" & "ODBC_DRV.int".
90845>>>>>>>    Function SqlUtilEnumerateIntFiles String sDataPath Returns String[]
90847>>>>>>>        String[] sFilesData
90848>>>>>>>        Boolean bExists
90848>>>>>>>        Integer iCh
90848>>>>>>>        String sFileName sExt
90848>>>>>>>
90848>>>>>>>        Get vFolderExists sDataPath to bExists
90849>>>>>>>        If (bExists = True) Begin
90851>>>>>>>            Move (Utf8ToAnsi(Trim(sDataPath))) to sDataPath
90852>>>>>>>            Move ("dir:" + sDataPath)      to sDataPath
90853>>>>>>>            Get Seq_New_Channel to iCh  // get free channel for input
90854>>>>>>>            Direct_Input channel iCh sDataPath
90856>>>>>>>                Repeat
90856>>>>>>>>
90856>>>>>>>                    Readln channel iCh sFileName
90858>>>>>>>                    Get ParseFileExtension sFileName to sExt
90859>>>>>>>                    If (Uppercase(sExt) = "INT") Begin
90861>>>>>>>                        If (not(Uppercase(sFileName) contains "MSSQLDRV" and Uppercase(sFileName) contains "DB2_DRV" and Uppercase(sFileName) contains "ODBC_DRV")) Begin
90863>>>>>>>                            Move sFileName to sFilesData[SizeOfArray(sFilesData)]
90864>>>>>>>                        End
90864>>>>>>>>
90864>>>>>>>                    End
90864>>>>>>>>
90864>>>>>>>                Until (SeqEof = True)
90866>>>>>>>            Close_Input channel iCh
90868>>>>>>>            Send Seq_Release_Channel iCh
90869>>>>>>>        End
90869>>>>>>>>
90869>>>>>>>        Function_Return sFilesData
90870>>>>>>>    End_Function
90871>>>>>>>
90871>>>>>>>    // Only done for MSSQLDRV_ID so far...
90871>>>>>>>    Function SqlEnumerateDatabaseCollations String sDriverID Returns String[]
90873>>>>>>>        Boolean bMertechDriver
90873>>>>>>>        String sSQL sConnectionID sConnectionString sSelect sName sPre
90873>>>>>>>        String sDescription sFrom sSys sValue sPrevious
90873>>>>>>>        Handle hStmt hoSQLManager hoSQLConnect
90873>>>>>>>        Integer iFetchResult iRows iColumn iPos
90873>>>>>>>        tSQLConnection SQLConnection
90873>>>>>>>        tSQLConnection SQLConnection
90873>>>>>>>        String[] asCollations
90874>>>>>>>        
90874>>>>>>>        If (sDriverID = "") Begin
90876>>>>>>>            Error DFERR_PROGRAM "The database driver ID was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
90877>>>>>>>>
90877>>>>>>>            Function_Return asCollations
90878>>>>>>>        End
90878>>>>>>>>
90878>>>>>>>
90878>>>>>>>        // Only done for MSSQLDRV_ID so far...
90878>>>>>>>        If (sDriverID <> MSSQLDRV_ID) Begin
90880>>>>>>>            Function_Return asCollations
90881>>>>>>>        End                 
90881>>>>>>>>
90881>>>>>>>
90881>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
90882>>>>>>>        If (bMertechDriver = False) Begin
90884>>>>>>>            Get phoSQLManager to hoSQLManager
90885>>>>>>>        End
90885>>>>>>>>
90885>>>>>>>        Else Begin
90886>>>>>>>            Get _MertechSQLManagerHandle to hoSQLManager
90887>>>>>>>        End
90887>>>>>>>>
90887>>>>>>>
90887>>>>>>>        Get psConnectionID     to sConnectionID
90888>>>>>>>        Get psConnectionString to sConnectionString
90889>>>>>>>        Move 0 to LastErr
90890>>>>>>>
90890>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
90891>>>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hoSQLConnect
90892>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
90893>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
90895>>>>>>>            Error DFERR_PROGRAM ("Login failed to the database server. The following connect string was used:\n" + sConnectionString)
90896>>>>>>>>
90896>>>>>>>            Function_Return asCollations
90897>>>>>>>        End
90897>>>>>>>>
90897>>>>>>>
90897>>>>>>>        Get SqlOpen of hoSQLConnect to hStmt
90898>>>>>>>
90898>>>>>>>        If (hStmt = 0) Begin
90900>>>>>>>            Send SqlDisconnect of hoSQLManager
90901>>>>>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
90902>>>>>>>>
90902>>>>>>>            Function_Return asCollations
90903>>>>>>>        End
90903>>>>>>>>
90903>>>>>>>
90903>>>>>>>        Get _SqlFindKeyWord CI_SQLSelect      to sSelect
90904>>>>>>>        Get _SqlFindKeyWord CI_SQLName        to sName
90905>>>>>>>        Get _SqlFindKeyWord CI_SQLDescription to sDescription
90906>>>>>>>        Get _SqlFindKeyWord CI_SQLFrom        to sFrom
90907>>>>>>>        Get _SqlFindKeyWord CI_SQLSys         to sSys
90908>>>>>>>
90908>>>>>>>        // MS-SQL Syntax:  
90908>>>>>>>        // SELECT name, description
90908>>>>>>>        //   from sys.fn_helpcollations();
90908>>>>>>>        Move (sSelect  * String(sName) * String(",") * String(sDescription) * String(sFrom) * String(sSys) * String(".fn_helpcollations();")) to sSQL
90909>>>>>>>
90909>>>>>>>        Move 1 to iColumn
90910>>>>>>>        Send SqlExecDirect of hStmt sSQL
90911>>>>>>>        Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_ROWCOUNT to iRows
90912>>>>>>>        Repeat
90912>>>>>>>>
90912>>>>>>>            Get SQLFetch of hStmt to iFetchResult
90913>>>>>>>            If (iFetchResult <> 0) Begin
90915>>>>>>>                Get SQLColumnValue of hStmt iColumn to sValue 
90916>>>>>>>                If (sValue <> sPrevious) Begin         
90918>>>>>>>                    // We need to skip all collations starting with "SQL" because they
90918>>>>>>>                    // are obsolete and for pre-SQL Server 2000.
90918>>>>>>>                    Move (Pos("SQL", Uppercase(sValue))) to iPos
90919>>>>>>>                    If (iPos <> 1) Begin
90921>>>>>>>                        Move (Trim(sValue)) to asCollations[SizeOfArray(asCollations)
90922>>>>>>>                    End
90922>>>>>>>>
90922>>>>>>>                End
90922>>>>>>>>
90922>>>>>>>                Move sValue to sPrevious
90923>>>>>>>            End
90923>>>>>>>>
90923>>>>>>>        Until (iFetchResult = 0)
90925>>>>>>>        Send SQLClose of hStmt
90926>>>>>>>        Send SQLDisconnect of hoSQLConnect
90927>>>>>>>
90927>>>>>>>        Function_Return asCollations
90928>>>>>>>    End_Function
90929>>>>>>>
90929>>>>>>>    // To enumerate SQL database resources with ESQL and return the result as a string array,
90929>>>>>>>    // for DAW drivers.
90929>>>>>>>    // Returns: A string array.
90929>>>>>>>    Function SqlEnumerateEsqlDAW String sStmt Integer iColumn Returns String[]
90931>>>>>>>        String[] sReturnArray
90932>>>>>>>        String sValue sPrevious
90932>>>>>>>        Handle hoSQLHandler hoSQLConnect hstmt
90932>>>>>>>        Integer iFetchResult iRows
90932>>>>>>>        tSQLConnection SQLConnection
90932>>>>>>>        tSQLConnection SQLConnection
90932>>>>>>>
90932>>>>>>>        Get phoSQLManager to hoSQLHandler
90933>>>>>>>
90933>>>>>>>        If (hoSQLHandler <> 0) Begin
90935>>>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
90936>>>>>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
90937>>>>>>>
90937>>>>>>>            If (hoSQLConnect <> 0) Begin
90939>>>>>>>                Get SQLOpen of hoSQLConnect to hstmt
90940>>>>>>>                If (hstmt <> 0) Begin
90942>>>>>>>                    Send SqlExecDirect of hstmt sStmt
90943>>>>>>>                    Get SqlStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
90944>>>>>>>                    Repeat
90944>>>>>>>>
90944>>>>>>>                        Get SQLFetch of hstmt to iFetchResult
90945>>>>>>>                        If (iFetchResult <> 0) Begin
90947>>>>>>>                            Get SQLColumnValue of hstmt iColumn to sValue
90948>>>>>>>                            If (sValue <> sPrevious) Begin
90950>>>>>>>                                Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
90951>>>>>>>                            End
90951>>>>>>>>
90951>>>>>>>                            Move sValue to sPrevious
90952>>>>>>>                        End
90952>>>>>>>>
90952>>>>>>>                    Until (iFetchResult = 0)
90954>>>>>>>                    Send SQLClose of hstmt
90955>>>>>>>                End
90955>>>>>>>>
90955>>>>>>>                Send SQLDisconnect of hoSQLConnect
90956>>>>>>>            End
90956>>>>>>>>
90956>>>>>>>        End
90956>>>>>>>>
90956>>>>>>>
90956>>>>>>>        Function_Return sReturnArray
90957>>>>>>>    End_Function
90958>>>>>>>
90958>>>>>>>    // To enumerate SQL database resources with ESQL and return the result as a string array,
90958>>>>>>>    // for Mertech drivers.
90958>>>>>>>    // Returns: A string array.
90958>>>>>>>    Function SqlEnumerateEsqlMertech String sStmt Returns String[]
90960>>>>>>>        String[] sReturnArray
90961>>>>>>>        String sValue
90961>>>>>>>        Handle hoSQLHandler hoSQLConnect hStmt
90961>>>>>>>        Integer iFetchResult iRows
90961>>>>>>>        tSQLConnection SQLConnection
90961>>>>>>>        tSQLConnection SQLConnection
90961>>>>>>>
90961>>>>>>>        Get _MertechSQLManagerHandle to hoSQLHandler
90962>>>>>>>
90962>>>>>>>        If (hoSQLHandler <> 0) Begin
90964>>>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
90965>>>>>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
90966>>>>>>>
90966>>>>>>>            If (hoSQLConnect <> 0) Begin
90968>>>>>>>                Get SQLOpen of hoSQLConnect to hStmt
90969>>>>>>>                If (hStmt <> 0) Begin
90971>>>>>>>                    Send SqlExecDirect of hStmt sStmt
90972>>>>>>>                    Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_ROWCOUNT to iRows
90973>>>>>>>                    Repeat
90973>>>>>>>>
90973>>>>>>>                        Get SQLFetch of hStmt to iFetchResult
90974>>>>>>>                        If (iFetchResult <> 0) Begin
90976>>>>>>>                            Get SQLColumnValue of hStmt 1 to sValue
90977>>>>>>>                            Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
90978>>>>>>>                        End
90978>>>>>>>>
90978>>>>>>>                    Until (iFetchResult = 0)
90980>>>>>>>                    Send SQLClose of hStmt
90981>>>>>>>                End
90981>>>>>>>>
90981>>>>>>>                Send SQLDisconnect of hoSQLConnect
90982>>>>>>>            End
90982>>>>>>>>
90982>>>>>>>        End
90982>>>>>>>>
90982>>>>>>>
90982>>>>>>>        Function_Return sReturnArray
90983>>>>>>>    End_Function
90984>>>>>>>
90984>>>>>>>    // * Dummy function for the Studio's Code Explorer *
90984>>>>>>>    Function PRIVATE_SQL_SUB_FUNCTIONS Returns Boolean
90986>>>>>>>        Function_Return False
90987>>>>>>>    End_Function
90988>>>>>>>
90988>>>>>>>    // Returns the index for the passed sTableName
90988>>>>>>>    // Returns >= 0 if successful. It is e.g. needed to get the SchemaName for a table.
90988>>>>>>>    Function _SqlUtilEnumerateTableIndex String sTableName String sDriverID Returns Integer
90990>>>>>>>        Integer iIndex iSize iCount
90990>>>>>>>        String[] sTablesArray
90991>>>>>>>        String sDatabase sSchema sVal sConnectionString
90991>>>>>>>
90991>>>>>>>        Move -1 to iIndex
90992>>>>>>>        Get psConnectionString to sConnectionString
90993>>>>>>>        Get psDatabase to sDatabase
90994>>>>>>>        Get psSchema   to sSchema
90995>>>>>>>        Get SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
90996>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
90997>>>>>>>        Decrement iSize
90998>>>>>>>        For iCount from 0 to iSize
91004>>>>>>>>
91004>>>>>>>            Move sTablesArray[iCount] to sVal
91005>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
91007>>>>>>>                Move iCount to iIndex // We found it!
91008>>>>>>>                Move iSize to iCount  // End the loop
91009>>>>>>>            End
91009>>>>>>>>
91009>>>>>>>        Loop
91010>>>>>>>>
91010>>>>>>>
91010>>>>>>>        Function_Return iIndex
91011>>>>>>>    End_Function
91012>>>>>>>
91012>>>>>>>    // Helper function that builds a string like;
91012>>>>>>>    // "SELECT name from [Master].[sys].[databases] where name"
91012>>>>>>>    Function _SqlSelectFromWhereName Returns String
91014>>>>>>>        String sRetval sSelect sName sFrom sMaster sSys sDatabases sWhere sDBO
91014>>>>>>>
91014>>>>>>>        Get _SqlFindKeyWord CI_SQLSelect       to sSelect
91015>>>>>>>        Get _SqlFindKeyWord CI_SQLName         to sName
91016>>>>>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBO
91017>>>>>>>        Get _SqlFindKeyWord CI_SQLFrom         to sFrom
91018>>>>>>>        Get _SqlFindKeyWord CI_SQLMaster       to sMaster
91019>>>>>>>        Get _SqlFindKeyWord CI_SQLSys          to sSys
91020>>>>>>>        Get _SqlFindKeyWord CI_SQLDatabases    to sDatabases
91021>>>>>>>        Get _SqlFindKeyWord CI_SQLWhere        to sWhere
91022>>>>>>>        Move (sSelect * sName * sFrom * "[" + sMaster + "].[" + sDBO + "].[" + sSys + sDatabases + "]" * sWhere * sName) to sRetval
91023>>>>>>>        Function_Return sRetval
91024>>>>>>>    End_Function
91025>>>>>>>
91025>>>>>>>    // Helper function to create a SQL statement like;
91025>>>>>>>    // "SELECT * FROM SYS.INDEXES WHERE NAME = MyIndexName AND OBJECT_ID = OBJECT_ID([MySchmaName].[MyTableName])"
91025>>>>>>>    // Used for checking if an index exists.
91025>>>>>>>    Function _SqlQueryIfIndexExists String sSchemaName String sTableName String sIndexName Returns String
91027>>>>>>>        String sRetval sSelect sFrom sSysIndexes sWhere sObjectID sAnd sName
91027>>>>>>>
91027>>>>>>>        Get _SqlFindKeyWord CI_SQLSelect to sSelect
91028>>>>>>>        Get _SqlFindKeyWord CI_SQLFrom to sFrom
91029>>>>>>>        Get _SqlFindKeyWord CI_SQLSysIndexes to sSysIndexes
91030>>>>>>>        Get _SqlFindKeyWord CI_SQLWhere to sWhere
91031>>>>>>>        Get _SqlFindKeyWord CI_SQLObjectID to sObjectID
91032>>>>>>>        Get _SqlFindKeyWord CI_SQLAND to sAnd
91033>>>>>>>        Get _SqlFindKeyWord CI_SQLName to sName
91034>>>>>>>
91034>>>>>>>        Move (sSelect * String("*") * sFrom * sSysIndexes * sWhere * sName * "=" * sIndexName * sAnd * sObjectID * "=([" + sSchemaName + "].[" + sTableName + "])") to sRetval
91035>>>>>>>
91035>>>>>>>        Function_Return sRetval
91036>>>>>>>    End_Function
91037>>>>>>>
91037>>>>>>>    // Formats a columns iLenght & iDecimal parameters as SQL expects them in a string.
91037>>>>>>>    // E.g. (4,2), where 4 is the iLength and 2 the iDecimals param.
91037>>>>>>>    Function _SqlFormatLengthAndDecimalAsString Integer iLength Integer iDecimals Returns String
91039>>>>>>>        String sRetval
91039>>>>>>>        If (iLength <> 0) Begin
91041>>>>>>>            Move ("(" + String(iLength)) to sRetval
91042>>>>>>>            If (iDecimals <> 0) Begin
91044>>>>>>>                Move (sRetval + "," + String(iDecimals)) to sRetval
91045>>>>>>>            End
91045>>>>>>>>
91045>>>>>>>            Move (sRetval + ")") to sRetval
91046>>>>>>>        End
91046>>>>>>>>
91046>>>>>>>        Function_Return sRetval
91047>>>>>>>    End_Function
91048>>>>>>>
91048>>>>>>>    Procedure _SqlColumnInfo Handle hoStmt
91050>>>>>>>        Integer i iCols iItem
91050>>>>>>>        tSqlColumnNew[] aQueryColumns
91050>>>>>>>        tSqlColumnNew[] aQueryColumns
91051>>>>>>>
91051>>>>>>>        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
91052>>>>>>>        For i from 1 to iCols
91058>>>>>>>>
91058>>>>>>>            Move (SizeOfArray(aQueryColumns)) to iItem
91059>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASECOLUMNNAME to aQueryColumns[iItem].sBaseColumnName
91060>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASETABLENAME  to aQueryColumns[iItem].sBaseTableName
91061>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_LABEL          to aQueryColumns[iItem].sLabel
91062>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SQLTYPE        to aQueryColumns[iItem].iSqlType
91063>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_DFTYPE         to aQueryColumns[iItem].iDFType
91064>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SIZE           to aQueryColumns[iItem].iSize
91065>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_PRECISION      to aQueryColumns[iItem].iPrecision
91066>>>>>>>        Loop
91067>>>>>>>>
91067>>>>>>>        Set piColumns to iCols
91068>>>>>>>        Set paQueryColumns to aQueryColumns
91069>>>>>>>    End_Procedure
91070>>>>>>>
91070>>>>>>>    // Checks that the passed sDriverID is defined.
91070>>>>>>>    // Also checks if the driver has been loaded; else it gets loaded.
91070>>>>>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
91072>>>>>>>        Boolean bOK
91072>>>>>>>        Integer iDriver
91072>>>>>>>
91072>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
91074>>>>>>>            Function_Return False
91075>>>>>>>        End
91075>>>>>>>>
91075>>>>>>>
91075>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
91076>>>>>>>
91076>>>>>>>        If (bOK = False) Begin
91078>>>>>>>            Get IsMertechDriver sDriverID to bOK
91079>>>>>>>        End
91079>>>>>>>>
91079>>>>>>>
91079>>>>>>>        If (bOK = False) Begin
91081>>>>>>>            Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV, DB2_DRV, ODBC_DRV, SQLFLEX, ORAFLEX, MDSPgSQL or MDSMySQL"
91082>>>>>>>>
91082>>>>>>>            Function_Return False
91083>>>>>>>        End
91083>>>>>>>>
91083>>>>>>>
91083>>>>>>>        Get DriverIndex sDriverID to iDriver
91084>>>>>>>        If (iDriver = 0) Begin
91086>>>>>>>            Load_Driver sDriverID
91087>>>>>>>        End
91087>>>>>>>>
91087>>>>>>>
91087>>>>>>>        Function_Return True
91088>>>>>>>    End_Function
91089>>>>>>>
91089>>>>>>>    // Checks that the length parameter has been passed correctly.
91089>>>>>>>    // This is only of concern for certain SQL data types.
91089>>>>>>>    Function _SqlCheckLengthParamForDataType Integer iDataType Integer iLen Returns Boolean
91091>>>>>>>        Integer iLength
91091>>>>>>>        Boolean bOK bCheckTypeLength
91091>>>>>>>
91091>>>>>>>        If (num_arguments > 1) Begin
91093>>>>>>>            Move iLen to iLength
91094>>>>>>>        End
91094>>>>>>>>
91094>>>>>>>        Move (iDataType = SQL_DECIMAL   or iDataType = SQL_NUMERIC or iDataType = SQL_FLOAT   or iDataType = SQL_INTEGER or;              iDataType = SQL_VARBINARY or iDataType = SQL_BINARY  or iDataType = SQL_VARCHAR or iDataType = SQL_CHAR or;              iDataType = SQL_BIGINT    or iDataType = SQL_REAL) to bCheckTypeLength
91095>>>>>>>
91095>>>>>>>        If (bCheckTypeLength = True) Begin
91097>>>>>>>            Move (iLength > 0) to bOK
91098>>>>>>>        End
91098>>>>>>>>
91098>>>>>>>
91098>>>>>>>        Function_Return (bOK = True)
91099>>>>>>>    End_Function
91100>>>>>>>
91100>>>>>>>    Function _SqlProperTableName String sTableName Returns String
91102>>>>>>>        String sVal sSchema sDriverID
91102>>>>>>>        Integer iDbType
91102>>>>>>>
91102>>>>>>>        If (Trim(sTableName) = "") Begin
91104>>>>>>>            Function_Return ""
91105>>>>>>>        End
91105>>>>>>>>
91105>>>>>>>
91105>>>>>>>        Get psDriverID to sDriverID
91106>>>>>>>        Get piDbType   to iDbType
91107>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
91109>>>>>>>            Get psUserID to sSchema
91110>>>>>>>            // Not sure about this uppercasing but it seems like Oracle wants that?
91110>>>>>>>            Move (Uppercase(sSchema)) to sSchema
91111>>>>>>>            Move ('"' + sSchema + '"."' + sTableName + '"') to sTableName
91112>>>>>>>            Function_Return sTableName
91113>>>>>>>        End
91113>>>>>>>>
91113>>>>>>>        If (iDbType = EN_DbTypeMySQL) Begin
91115>>>>>>>            Get psDatabase to sVal
91116>>>>>>>            Move (sVal + "." + sTableName) to sTableName
91117>>>>>>>            Function_Return sTableName
91118>>>>>>>        End
91118>>>>>>>>
91118>>>>>>>        If (iDbType = EN_DbTypePostgre) Begin
91120>>>>>>>            Move ('"' + sTableName + '"') to sTableName
91121>>>>>>>            Function_Return sTableName
91122>>>>>>>        End
91122>>>>>>>>
91122>>>>>>>
91122>>>>>>>        Get psSchema to sSchema
91123>>>>>>>        If (sSchema = "") Begin
91125>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
91126>>>>>>>        End
91126>>>>>>>>
91126>>>>>>>
91126>>>>>>>        Move (Uppercase(sTableName)) to sVal
91127>>>>>>>        If (not(sVal contains (sSchema + "."))) Begin
91129>>>>>>>            If (iDbType = EN_dbTypeDB2) Begin
91131>>>>>>>                Move (Lowercase(sSchema) + "." + sTableName) to sTableName
91132>>>>>>>            End
91132>>>>>>>>
91132>>>>>>>            Else Begin
91133>>>>>>>                Move (sSchema + "." + sTableName) to sTableName
91134>>>>>>>            End
91134>>>>>>>>
91134>>>>>>>        End
91134>>>>>>>>
91134>>>>>>>
91134>>>>>>>        Function_Return sTableName
91135>>>>>>>    End_Function
91136>>>>>>>
91136>>>>>>>    // SQL column names can be case-sensitive. This function is used to check that
91136>>>>>>>    // the passed sFieldName has the correct spelling.
91136>>>>>>>    // Used with Embedded SQL statement calls.
91136>>>>>>>    // If the spelling or fieldname doesn't exist, the return value is "" (blank).
91136>>>>>>>    Function _SqlFindColumnName String sTableName String sColumnName Returns String
91138>>>>>>>        String sRetval sValue sDriverID
91138>>>>>>>        String[] sColumnNamesArray
91139>>>>>>>        Integer iCount iColumns
91139>>>>>>>
91139>>>>>>>        Move "" to sRetval
91140>>>>>>>        Get psDriverID to sDriverID
91141>>>>>>>        Get SqlUtilEnumerateColumns sDriverID sTableName to sColumnNamesArray
91142>>>>>>>        Move (SizeOfArray(sColumnNamesArray)) to iColumns
91143>>>>>>>        Decrement iColumns
91144>>>>>>>
91144>>>>>>>        For iCount from 0 to iColumns
91150>>>>>>>>
91150>>>>>>>            Move sColumnNamesArray[iCount] to sValue
91151>>>>>>>            If (Uppercase(sColumnName) = Uppercase(sValue)) Begin
91153>>>>>>>                Move sValue to sRetval
91154>>>>>>>                Move iColumns to iCount // We're done.
91155>>>>>>>            End
91155>>>>>>>>
91155>>>>>>>        Loop
91156>>>>>>>>
91156>>>>>>>
91156>>>>>>>        Function_Return sRetval
91157>>>>>>>    End_Function
91158>>>>>>>
91158>>>>>>>    Function _SqlDatabasesArrayMSSQL Returns String[]
91160>>>>>>>        String[] sReturnArray
91161>>>>>>>        Handle hoSQLHandler
91161>>>>>>>        Integer iCount iSize iItem
91161>>>>>>>        String sServer
91161>>>>>>>        tSQLConnection SQLConnection
91161>>>>>>>        tSQLConnection SQLConnection
91161>>>>>>>
91161>>>>>>>        Get phoMSSQLHandler to hoSQLHandler
91162>>>>>>>        Send Delete_Data    of hoSQLHandler
91163>>>>>>>        Get pSQLConnection  of ghoSQLConnectionHandler to SQLConnection
91164>>>>>>>
91164>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
91165>>>>>>>        Get EnumerateDatabases of hoSQLHandler SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to iSize
91166>>>>>>>        Decrement iSize
91167>>>>>>>
91167>>>>>>>        For iCount from 0 to iSize
91173>>>>>>>>
91173>>>>>>>            Get String_Value of hoSQLHandler iCount to sServer
91174>>>>>>>            Move (Trim(sServer)) to sReturnArray[iItem]
91175>>>>>>>            Increment iItem
91176>>>>>>>        Loop
91177>>>>>>>>
91177>>>>>>>
91177>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
91178>>>>>>>
91178>>>>>>>        Function_Return sReturnArray
91179>>>>>>>    End_Function
91180>>>>>>>
91180>>>>>>>    Function _SqlTableArrayDAW Returns String[]
91182>>>>>>>        String[] sReturnArray
91183>>>>>>>        String sTable sTableType sSchema sDefSchema sComment sTableKeyWord sSysKeyWord sConnectionString
91183>>>>>>>        Handle hoSQLHandler
91183>>>>>>>        Integer iCount iSize iItem iPos
91183>>>>>>>        Boolean bOK
91183>>>>>>>        tSQLConnection SQLConnection
91183>>>>>>>        tSQLConnection SQLConnection
91183>>>>>>>
91183>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
91184>>>>>>>        If (SQLConnection.sConnectionString = "") Begin
91186>>>>>>>            Function_Return sReturnArray
91187>>>>>>>        End
91187>>>>>>>>
91187>>>>>>>
91187>>>>>>>        Move SQLConnection.sSchema      to sDefSchema
91188>>>>>>>        Move (Uppercase(sDefSchema))    to sDefSchema
91189>>>>>>>        Get _SqlFindKeyWord CI_SQLTable to sTableKeyWord
91190>>>>>>>        Get _SqlFindKeyWord CI_SQLSys   to sSysKeyWord
91191>>>>>>>
91191>>>>>>>        Get phoCLIHandler to hoSQLHandler
91192>>>>>>>        Set psDriverID    of hoSQLHandler to SQLConnection.sDriverID
91193>>>>>>>        Send Delete_Data  of hoSQLHandler
91194>>>>>>>
91194>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
91195>>>>>>>        Move SQLConnection.sConnectionString to sConnectionString
91196>>>>>>>        // 2020-03-14 This was not correct when testing a MS-SQL ODBC driver connection from CMOS.
91196>>>>>>>//        If (SQLConnection.sDriverID = ODBC_DRV_ID) Begin
91196>>>>>>>//            If (Uppercase(sConnectionString) contains CS_SQLIniDSNKeyword) Begin
91196>>>>>>>//                Move (Pos(";", sConnectionString)) to iPos
91196>>>>>>>//                If (iPos > 0) Begin
91196>>>>>>>//                    Move (Left(sConnectionString, (iPos - 1))) to sConnectionString
91196>>>>>>>//                    Move (Trim(sConnectionString)) to sConnectionString
91196>>>>>>>//                End
91196>>>>>>>//            End
91196>>>>>>>//        End
91196>>>>>>>
91196>>>>>>>        Get EnumerateTables of hoSQLHandler sConnectionString to iSize
91197>>>>>>>        Move False to Err
91198>>>>>>>        Move 0 to iItem
91199>>>>>>>
91199>>>>>>>        // Note that the enumeration starts from table no 1. (not zero)
91199>>>>>>>        for iCount from 1 to iSize
91205>>>>>>>>
91205>>>>>>>            Get TableName    of hoSQLHandler iCount to sTable
91206>>>>>>>            Get TableType    of hoSQLHandler iCount to sTableType
91207>>>>>>>            Get SchemaName   of hoSQLHandler iCount to sSchema
91208>>>>>>>            If (sSchema = "") Begin
91210>>>>>>>                Get _SqlFindKeyWord CI_SQLDBO to sSchema
91211>>>>>>>            End
91211>>>>>>>>
91211>>>>>>>            Get TableComment of hoSQLHandler iCount to sComment
91212>>>>>>>            Move (Trim(sTable)) to sTable
91213>>>>>>>            If (SQLConnection.sDriverID = DB2_DRV_ID) Begin
91215>>>>>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) = sDefSchema) to bOK
91216>>>>>>>            End
91216>>>>>>>>
91216>>>>>>>            Else Begin
91217>>>>>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) <> sSysKeyWord and Uppercase(sSchema) <> "SYSTOOLS") to bOK
91218>>>>>>>            End
91218>>>>>>>>
91218>>>>>>>            If (bOK = True) Begin
91220>>>>>>>                Move sTable to sReturnArray[iItem]
91221>>>>>>>                Increment iItem
91222>>>>>>>            End
91222>>>>>>>>
91222>>>>>>>        Loop
91223>>>>>>>>
91223>>>>>>>
91223>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
91224>>>>>>>
91224>>>>>>>        Function_Return sReturnArray
91225>>>>>>>    End_Function
91226>>>>>>>
91226>>>>>>>    Function _SqlProcedureArrayDAW String sStmt String sArgument Returns String[]
91228>>>>>>>        String[] sReturnArray
91229>>>>>>>        String sValue
91229>>>>>>>        Handle hoSQLHandler hoSQLConnect hStmt
91229>>>>>>>        Integer iRetval iCols iFetchResult
91229>>>>>>>        tSQLConnection SQLConnection
91229>>>>>>>        tSQLConnection SQLConnection
91229>>>>>>>
91229>>>>>>>        Get phoSQLManager to hoSQLHandler
91230>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
91231>>>>>>>        Get SqlConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
91232>>>>>>>
91232>>>>>>>        If (hoSQLConnect <> 0) Begin
91234>>>>>>>            Get SqlOpen of hoSQLConnect to hStmt
91235>>>>>>>            If (hStmt <> 0) Begin
91237>>>>>>>                Send SqlSetProcedurename of hStmt sStmt
91238>>>>>>>                If (sArgument <> "") Begin
91240>>>>>>>                    Send SqlSetArgument  of hStmt 1 sArgument
91241>>>>>>>                End
91241>>>>>>>>
91241>>>>>>>
91241>>>>>>>                Send SqlCall             of hStmt
91242>>>>>>>                Get SqlReturnValue       of hStmt to iRetval
91243>>>>>>>                If (iRetval = 0) Begin
91245>>>>>>>                    Repeat
91245>>>>>>>>
91245>>>>>>>                        Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
91246>>>>>>>                        If (iCols > 0) Begin
91248>>>>>>>                            Repeat
91248>>>>>>>>
91248>>>>>>>                                Get SqlFetch of hStmt to iFetchResult
91249>>>>>>>                                If (iFetchResult <> 0) Begin
91251>>>>>>>                                    Get SqlColumnValue of hStmt 1 to sValue
91252>>>>>>>                                    Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)]
91253>>>>>>>                                End
91253>>>>>>>>
91253>>>>>>>                            Until (iFetchResult = 0)
91255>>>>>>>                        End
91255>>>>>>>>
91255>>>>>>>                        Get SqlNextResultSet of hStmt to iRetval
91256>>>>>>>                    Until (iRetval = 0)
91258>>>>>>>                    Send SqlClose of hStmt
91259>>>>>>>                End
91259>>>>>>>>
91259>>>>>>>            End
91259>>>>>>>>
91259>>>>>>>            Send SqlDisconnect of hoSQLConnect
91260>>>>>>>        End
91260>>>>>>>>
91260>>>>>>>        Function_Return sReturnArray
91261>>>>>>>    End_Function
91262>>>>>>>
91262>>>>>>>    Function _SqlDatabasesArrayDB2 Returns String[]
91264>>>>>>>        String[] sReturnArray
91265>>>>>>>        String sDataSource
91265>>>>>>>        Handle hoSQLHandler
91265>>>>>>>        Integer iItem
91265>>>>>>>
91265>>>>>>>        Get phoDB2SQLHandler to hoSQLHandler
91266>>>>>>>        Send SeedDataSources of hoSQLHandler
91267>>>>>>>
91267>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
91268>>>>>>>
91268>>>>>>>        Repeat
91268>>>>>>>>
91268>>>>>>>            Get DataSources of hoSQLHandler to sDataSource
91269>>>>>>>            Move (Replaces(",", sDataSource, "")) to sDataSource
91270>>>>>>>            Move (Trim(sDataSource)) to sReturnArray[iItem]
91271>>>>>>>            Increment iItem
91272>>>>>>>        Until (sDataSource = "")
91274>>>>>>>
91274>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
91275>>>>>>>
91275>>>>>>>        Function_Return sReturnArray
91276>>>>>>>    End_Function
91277>>>>>>>
91277>>>>>>>    Function _SqlDatabaseSourcesArrayODBC Returns String[]
91279>>>>>>>        String[] sReturnArray
91280>>>>>>>        String sDataSource
91280>>>>>>>        Handle hoSQLHandler
91280>>>>>>>        Integer iItem
91280>>>>>>>
91280>>>>>>>        Get phoODBCSQLHandler to hoSQLHandler
91281>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
91282>>>>>>>
91282>>>>>>>        Send SeedDataSources of hoSQLHandler
91283>>>>>>>
91283>>>>>>>        Repeat
91283>>>>>>>>
91283>>>>>>>            Get DataSources of hoSQLHandler to sDataSource
91284>>>>>>>            If (Trim(sDataSource) <> "" and not(sDataSource contains "*.")) Begin
91286>>>>>>>                Move (Trim(sDataSource)) to sReturnArray[iItem]
91287>>>>>>>                Increment iItem
91288>>>>>>>            End
91288>>>>>>>>
91288>>>>>>>        Until (sDataSource = "")
91290>>>>>>>
91290>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
91291>>>>>>>
91291>>>>>>>        Function_Return sReturnArray
91292>>>>>>>    End_Function
91293>>>>>>>
91293>>>>>>>    Function _SqlDatabasesArrayODBC Returns tSQLIntTableInfo[]
91295>>>>>>>        String[] sDataSources
91296>>>>>>>        tSQLConnection SQLConnection
91296>>>>>>>        tSQLConnection SQLConnection
91296>>>>>>>        tSQLIntTableInfo[] sReturnArray
91296>>>>>>>        tSQLIntTableInfo[] sReturnArray
91297>>>>>>>        Integer iDataSources iCount iItem
91297>>>>>>>        String sConnection sServer sDatabase sKey sSubKey
91297>>>>>>>        Handle hoIniFile hoRegistry hoODBCDataSources
91297>>>>>>>        Boolean bExists bKeyOpened
91297>>>>>>>
91297>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
91298>>>>>>>        Move SQLConnection.sConnectionString to sConnection
91299>>>>>>>        Move SQLConnection.sServer           to sServer
91300>>>>>>>
91300>>>>>>>        // FileDSN - read DATABASE name from DSN ini-file
91300>>>>>>>        If (Uppercase(sServer) contains ("." + String(CS_SQLIniDSNKeyword))) Begin
91302>>>>>>>            Get Create (RefClass(cIniFile)) to hoIniFile
91303>>>>>>>            Set psFileName of hoIniFile to sServer
91304>>>>>>>            Get ReadString of hoIniFile CS_SQLODBCIniSectionName CS_SQLIniDatabaseKeyword "" to sDatabase
91305>>>>>>>            Move sDatabase to sReturnArray[0].sDatabaseName
91306>>>>>>>            Send Destroy of hoIniFile
91307>>>>>>>        End
91307>>>>>>>>
91307>>>>>>>
91307>>>>>>>        // DSN - read DATABASE name from the registry
91307>>>>>>>        Else Begin
91308>>>>>>>            Get Create (RefClass(cRegistry)) to hoRegistry
91309>>>>>>>
91309>>>>>>>            // We start with checking the "System DNS" area in the registry as it is the
91309>>>>>>>            // most probably place the info is kept that we're after.
91309>>>>>>>            Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
91310>>>>>>>            Set pfAccessRights of hoRegistry to Key_Read
91311>>>>>>>            Get KeyExists of hoRegistry "SOFTWARE\Wow6432Node" to bExists
91312>>>>>>>            If (bExists = True) Begin
91314>>>>>>>                Move "SOFTWARE\Wow6432Node\ODBC\ODBC.INI" to sKey
91315>>>>>>>            End
91315>>>>>>>>
91315>>>>>>>            Else Begin
91316>>>>>>>                Move "SOFTWARE\ODBC\ODBC.INI" to sKey
91317>>>>>>>            End
91317>>>>>>>>
91317>>>>>>>
91317>>>>>>>            Get KeyExists of hoRegistry sKey to bExists
91318>>>>>>>            If (bExists) Begin
91320>>>>>>>                Get OpenKey of hoRegistry sKey to bKeyOpened
91321>>>>>>>                If (bKeyOpened) Begin
91323>>>>>>>                    Get Create (RefClass(Array)) to hoODBCDataSources
91324>>>>>>>                    Get GetSubkeys of hoRegistry hoODBCDataSources to iDataSources
91325>>>>>>>                    If (iDataSources > 0) Begin
91327>>>>>>>                        Move (ResizeArray(sDataSources, iDataSources)) to sDataSources
91328>>>>>>>                        Decrement iDataSources
91329>>>>>>>                        for iCount from 0 to iDataSources
91335>>>>>>>>
91335>>>>>>>                            Get Value of hoODBCDataSources iCount to sDataSources[iCount]
91336>>>>>>>                        Loop
91337>>>>>>>>
91337>>>>>>>                        Move 0 to iItem
91338>>>>>>>                        for iCount from 0 to iDataSources
91344>>>>>>>>
91344>>>>>>>                            Move sDataSources[iCount] to sSubKey
91345>>>>>>>                            Get OpenKey of hoRegistry (sKey + "\" + String(sSubKey)) to bKeyOpened
91346>>>>>>>                            If (bKeyOpened = True) Begin
91348>>>>>>>                                Get ValueExists of hoRegistry CS_SQLIniDatabaseKeyword to bExists
91349>>>>>>>                                If (bExists = True) Begin
91351>>>>>>>                                    Move sSubKey to sReturnArray[iItem].sServerName
91352>>>>>>>                                    Get ReadString of hoRegistry CS_SQLIniDatabaseKeyword to sReturnArray[iItem].sDatabaseName
91353>>>>>>>                                    Increment iItem
91354>>>>>>>                                End
91354>>>>>>>>
91354>>>>>>>                            End
91354>>>>>>>>
91354>>>>>>>                        Loop
91355>>>>>>>>
91355>>>>>>>                    End
91355>>>>>>>>
91355>>>>>>>                    Send CloseKey of hoRegistry
91356>>>>>>>                    Send Destroy of hoODBCDataSources
91357>>>>>>>                End
91357>>>>>>>>
91357>>>>>>>            End
91357>>>>>>>>
91357>>>>>>>
91357>>>>>>>            // We then check the "User DNS" area in the registry.
91357>>>>>>>            Set phRootKey of hoRegistry to HKEY_CURRENT_USER
91358>>>>>>>            Set pfAccessRights of hoRegistry to Key_Read
91359>>>>>>>            Move "SOFTWARE\ODBC\ODBC.INI" to sKey
91360>>>>>>>            Get KeyExists of hoRegistry sKey to bExists
91361>>>>>>>
91361>>>>>>>            If (bExists) Begin
91363>>>>>>>                Get OpenKey of hoRegistry sKey to bKeyOpened
91364>>>>>>>                If (bKeyOpened) Begin
91366>>>>>>>                    Get Create (RefClass(Array)) to hoODBCDataSources
91367>>>>>>>                    Get GetSubkeys of hoRegistry hoODBCDataSources to iDataSources
91368>>>>>>>                    If (iDataSources > 0) Begin
91370>>>>>>>                        Move (ResizeArray(sDataSources, iDataSources)) to sDataSources
91371>>>>>>>                        Decrement iDataSources
91372>>>>>>>                        for iCount from 0 to iDataSources
91378>>>>>>>>
91378>>>>>>>                            Get Value of hoODBCDataSources iCount to sDataSources[iCount]
91379>>>>>>>                        Loop
91380>>>>>>>>
91380>>>>>>>                        for iCount from 0 to iDataSources
91386>>>>>>>>
91386>>>>>>>                            Move sDataSources[iCount] to sSubKey
91387>>>>>>>                            Get OpenKey of hoRegistry (sKey + "\" + String(sSubKey)) to bKeyOpened
91388>>>>>>>                            If (bKeyOpened = True) Begin
91390>>>>>>>                                Get ValueExists of hoRegistry CS_SQLIniDatabaseKeyword to bExists
91391>>>>>>>                                If (bExists = True) Begin
91393>>>>>>>                                    Move sSubKey to sReturnArray[iItem].sServerName
91394>>>>>>>                                    Get ReadString of hoRegistry CS_SQLIniDatabaseKeyword to sReturnArray[iItem].sDatabaseName
91395>>>>>>>                                    Increment iItem
91396>>>>>>>                                End
91396>>>>>>>>
91396>>>>>>>                            End
91396>>>>>>>>
91396>>>>>>>                        Loop
91397>>>>>>>>
91397>>>>>>>                    End
91397>>>>>>>>
91397>>>>>>>                    Send CloseKey of hoRegistry
91398>>>>>>>                    Send Destroy of hoODBCDataSources
91399>>>>>>>                End
91399>>>>>>>>
91399>>>>>>>            End
91399>>>>>>>>
91399>>>>>>>
91399>>>>>>>            Send Destroy of hoRegistry
91400>>>>>>>        End
91400>>>>>>>>
91400>>>>>>>
91400>>>>>>>        Function_Return sReturnArray
91401>>>>>>>    End_Function
91402>>>>>>>
91402>>>>>>>    // We might have a split Sql script where the info about which database to use is
91402>>>>>>>    // put on top of the Sql script, we then need to save it to be able to retrieve it later and
91402>>>>>>>    // insert it for scriplets to come after the first one.
91402>>>>>>>    Function _SqlFormatStatement String sStmt Returns String
91404>>>>>>>        String sUseDatabase sTmp sUseKeyWord sCreateViewKeyWord sDBOKeyWord sNoCountKeyWord sDriverID
91404>>>>>>>        Integer iStart iEnd iDbType
91404>>>>>>>        Boolean bOK
91404>>>>>>>
91404>>>>>>>        Get piDbType to iDbType
91405>>>>>>>        Get psDriverID to sDriverID
91406>>>>>>>        Get _SqlFindKeyWord CI_SQLUse          to sUseKeyWord
91407>>>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
91408>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateView   to sCreateViewKeyWord
91409>>>>>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBOKeyWord
91410>>>>>>>        Move (Replaces(" ", sStmt, "")) to sTmp
91411>>>>>>>        If (Uppercase(sTmp) contains (sUseKeyWord +"[")) Begin
91413>>>>>>>            Move (Pos("[", (Uppercase(sTmp)))) to iStart
91414>>>>>>>            Move (Pos("]", sTmp)) to iEnd
91415>>>>>>>            Move (Mid(sTmp, (iEnd -iStart +1), iStart)) to sUseDatabase
91416>>>>>>>            Move (sUseKeyWord * sUseDatabase + " ") to sUseDatabase
91417>>>>>>>            Set Private.psUseDatabase to sUseDatabase
91418>>>>>>>        End
91418>>>>>>>>
91418>>>>>>>        Else Begin
91419>>>>>>>            Move (Uppercase(sStmt)) to sTmp
91420>>>>>>>
91420>>>>>>>            // A "Create View" statement _must_ be the very first words in a Sql statement.
91420>>>>>>>            If (not(sTmp contains sCreateViewKeyWord)) Begin
91422>>>>>>>                Get Private.psUseDatabase to sUseDatabase
91423>>>>>>>                Move (Insert(sUseDatabase, sStmt, 1)) to sStmt
91424>>>>>>>            End
91424>>>>>>>>
91424>>>>>>>
91424>>>>>>>            // This is a bit special to place here but was done so because it was easier that way.
91424>>>>>>>            // We will get an error when trying to create a view if it already exists.
91424>>>>>>>            // So to avoid such errors; we first remove it & then recreate it.
91424>>>>>>>            Else If (sTmp contains sCreateViewKeyWord) Begin
91427>>>>>>>                // Make sure we only have one space between statements/words.
91427>>>>>>>                Move (Replaces("  ", sTmp, " ")) to sTmp
91428>>>>>>>                Move (Replace(sCreateViewKeyWord, sTmp, "")) to sTmp
91429>>>>>>>                Move (Trim(sTmp)) to sTmp
91430>>>>>>>                Move (Pos(" ", sTmp)) to iEnd
91431>>>>>>>                Move (Left(sTmp, iEnd)) to sTmp
91432>>>>>>>                If ((not(sTmp contains ("[" + sDBOKeyWord + "]."))) and (not(sTmp contains (sDBOKeyWord + ".")))) Begin
91434>>>>>>>                    Move (sDBOKeyWord + "." + Trim(sTmp)) to sTmp
91435>>>>>>>                End
91435>>>>>>>>
91435>>>>>>>                Move (Trim(sTmp)) to sTmp
91436>>>>>>>                // Remove data view as it already exists!
91436>>>>>>>                Get SqlViewRemove sDriverID sTmp to bOK
91437>>>>>>>            End
91437>>>>>>>>
91437>>>>>>>        End
91437>>>>>>>>
91437>>>>>>>
91437>>>>>>>        Function_Return sStmt
91438>>>>>>>    End_Function
91439>>>>>>>
91439>>>>>>>    // Returns the proper Sql language key word(s) for the passed SQL key-word constant
91439>>>>>>>    Function _SqlFindKeyWord Integer iSQLKeywordConstant Returns String
91441>>>>>>>        String sRetval
91441>>>>>>>        Integer iDbType iIndex
91441>>>>>>>        tSQLKeyWords[] SQLKeywordArray
91441>>>>>>>        tSQLKeyWords[] SQLKeywordArray
91442>>>>>>>        tSQLKeyWords   SQLKeyWords
91442>>>>>>>        tSQLKeyWords   SQLKeyWords
91442>>>>>>>
91442>>>>>>>        // Sql back-end type. E.g. MS-SQL, MySQL, Oracle, DB2...
91442>>>>>>>        Move "" to sRetval
91443>>>>>>>        Get piDbType to iDbType
91444>>>>>>>        Move iDbType             to SQLKeyWords.iSQLDbType
91445>>>>>>>        Move iSQLKeywordConstant to SQLKeyWords.iSQLWord
91446>>>>>>>
91446>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
91447>>>>>>>        Move (SearchArray(SQLKeyWords, SQLKeywordArray, Self, RefFunc(CompareFindSQLKeyWords))) to iIndex
91448>>>>>>>        If (iIndex >= 0) Begin
91450>>>>>>>            Move SQLKeywordArray[iIndex].sSQLPhrase to sRetval
91451>>>>>>>        End
91451>>>>>>>>
91451>>>>>>>
91451>>>>>>>        Function_Return sRetval
91452>>>>>>>    End_Function
91453>>>>>>>
91453>>>>>>>    // Function will "clean/sanitize" the script by removing all comments and blank lines.
91453>>>>>>>    Function _SqlUtilSanitizeScript tSQLScriptArray SqlScriptArray Returns tSQLScriptArray[]
91455>>>>>>>        String[] sSQLScriptArray
91456>>>>>>>        String sText sLine sTmp sCommentStart sCommentEnd sDashComment
91456>>>>>>>        Integer iSize iCount
91456>>>>>>>        Boolean bCommentStart bCommentEnd bDashComment
91456>>>>>>>
91456>>>>>>>        Move False to bCommentStart
91457>>>>>>>        Move False to bCommentEnd
91458>>>>>>>        Move False to bDashComment
91459>>>>>>>        Move "/*"  to sCommentStart   // These are the standard comment start & stop tokens...
91460>>>>>>>        Move "*/"  to sCommentEnd
91461>>>>>>>        Move "--"  to sDashComment    // ...but a comment can also start with two dashes "--".
91462>>>>>>>
91462>>>>>>>        Move (SizeOfArray(SqlScriptArray.sSQLScriptArray)) to iSize
91463>>>>>>>        Decrement iSize
91464>>>>>>>        Move "" to sText
91465>>>>>>>
91465>>>>>>>        For iCount from 0 to iSize
91471>>>>>>>>
91471>>>>>>>            Move SqlScriptArray.sSQLScriptArray[iCount] to sLine
91472>>>>>>>            Move (Trim(sLine)) to sTmp
91473>>>>>>>            If (sTmp <> "") Begin
91475>>>>>>>                Move (Left(sTmp, 2) = sDashComment) to bDashComment
91476>>>>>>>                If (bCommentStart = False) Begin
91478>>>>>>>                    Move (Left(sTmp, 2) = sCommentStart) to bCommentStart
91479>>>>>>>                    If (bCommentStart = False) Begin
91481>>>>>>>                    End
91481>>>>>>>>
91481>>>>>>>                End
91481>>>>>>>>
91481>>>>>>>                Move (sTmp contains sCommentEnd) to bCommentEnd
91482>>>>>>>                If (bCommentEnd = True) Begin
91484>>>>>>>                    Move False to bCommentStart
91485>>>>>>>                End
91485>>>>>>>>
91485>>>>>>>                If (bDashComment = False and bCommentStart = False and bCommentEnd = False) Begin
91487>>>>>>>                    Move sLine to sSQLScriptArray[SizeOfArray(sSQLScriptArray)]
91488>>>>>>>                End
91488>>>>>>>>
91488>>>>>>>            End
91488>>>>>>>>
91488>>>>>>>        Loop
91489>>>>>>>>
91489>>>>>>>
91489>>>>>>>        // Update the retval struct array:
91489>>>>>>>        Move sSQLScriptArray to SqlScriptArray.sSQLScriptArray
91490>>>>>>>        Function_Return SqlScriptArray
91491>>>>>>>    End_Function
91492>>>>>>>
91492>>>>>>>
91492>>>>>>>    // *** Database API Functions: ***
91492>>>>>>>    // Instead of using Sql Scripts (ESQL), we can opt to use the DataFlex Database API's to
91492>>>>>>>    // make changes/updates to the database.
91492>>>>>>>
91492>>>>>>>    // * Dummy function for the Studio's Code Explorer *
91492>>>>>>>    Function API_TABLE_FUNCTIONS Returns Boolean
91494>>>>>>>        Function_Return False
91495>>>>>>>    End_Function
91496>>>>>>>
91496>>>>>>>    // This might not do what you think - Here's what it does:
91496>>>>>>>    // It checks that the passed hTable TableName in filelist.cfg is exactly the same as at the SQL back-end.
91496>>>>>>>    // If that is True; it creates an .int file for it and changes Filelist.cfg to point
91496>>>>>>>    // to the SQL table.
91496>>>>>>>    // Typical usage for this function is when an entry exists in the Filelist for a table and the table
91496>>>>>>>    // already exists in SQL.
91496>>>>>>>    // This is a bit fiddly as the DF_FILE_PHYSICAL_NAME attribute can only be set inside a
91496>>>>>>>    // Structure_Start ... Structure_End operation when creating a NEW table. Thus it cannot be set when
91496>>>>>>>    // restructuring an existing table.
91496>>>>>>>    Function ApiTableAttachToSql Handle hTable Boolean bUseConnID Returns Boolean
91498>>>>>>>        Boolean bExists bOpened bOK bSystemFile bMertechDriver bUseConnectionID bIsAlias
91498>>>>>>>        String sDriverID sConnectionID sConnectionString sDisplayName sRootName sLogicalName sPhysicalName sSchema
91498>>>>>>>        Handle hToTable
91498>>>>>>>
91498>>>>>>>        Move True to bUseConnectionID
91499>>>>>>>        If (num_arguments > 1) Begin
91501>>>>>>>            Move bUseConnID to bUseConnectionID
91502>>>>>>>        End
91502>>>>>>>>
91502>>>>>>>
91502>>>>>>>        Get psDriverID to sDriverID
91503>>>>>>>        // If the table doesn't exist on the SQL back-end we do nothing.
91503>>>>>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
91504>>>>>>>        If (bExists = False) Begin
91506>>>>>>>            Function_Return False
91507>>>>>>>        End
91507>>>>>>>>
91507>>>>>>>
91507>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias
91508>>>>>>>
91508>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
91509>>>>>>>        If (bOK = False) Begin
91511>>>>>>>            Function_Return False
91512>>>>>>>        End
91512>>>>>>>>
91512>>>>>>>
91512>>>>>>>        // Then we need to check that the function hasn't been called before; which in case
91512>>>>>>>        // we do nothing
91512>>>>>>>        Get SQLUtilTableIsAttached sDriverID hTable to bExists
91513>>>>>>>        If (bExists = True) Begin
91515>>>>>>>            Function_Return False
91516>>>>>>>        End
91516>>>>>>>>
91516>>>>>>>
91516>>>>>>>        Get psConnectionID     to sConnectionID
91517>>>>>>>        Get psConnectionString to sConnectionString
91518>>>>>>>        If (sConnectionID = "" or sConnectionString = "") Begin
91520>>>>>>>            Error DFERR_PROGRAM ("An SQL connection has NOT been setup correctly. Could not attach table:" * String(hTable) * "to SQL")
91521>>>>>>>>
91521>>>>>>>            Function_Return False
91522>>>>>>>        End
91522>>>>>>>>
91522>>>>>>>
91522>>>>>>>        Set Private.phCurrentTable to hTable
91523>>>>>>>        Get psSchema to sSchema
91524>>>>>>>        If (sSchema = "") Begin
91526>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
91527>>>>>>>        End
91527>>>>>>>>
91527>>>>>>>
91527>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
91528>>>>>>>
91528>>>>>>>        // Mertech drivers don't use connection id's, so if the passed bUseConnectionID = True that
91528>>>>>>>        // was a programmer's error and we adjust for it here.
91528>>>>>>>        If (bMertechDriver = True) Begin
91530>>>>>>>            Move False to bUseConnectionID
91531>>>>>>>        End
91531>>>>>>>>
91531>>>>>>>
91531>>>>>>>        // If we should use a connection id we need to check it exists;
91531>>>>>>>        // else we create it before attempting creating the table
91531>>>>>>>        If (bUseConnectionID = True) Begin
91533>>>>>>>            Get AutoConnectionIDLogin to bOK
91534>>>>>>>            If (bOk = False) Begin
91536>>>>>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
91537>>>>>>>>
91537>>>>>>>                Function_Return False
91538>>>>>>>            End
91538>>>>>>>>
91538>>>>>>>        End
91538>>>>>>>>
91538>>>>>>>
91538>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
91541>>>>>>>        Get _TableNameOnly sRootName to sRootName
91542>>>>>>>        If (sRootName = "") Begin
91544>>>>>>>            Function_Return False
91545>>>>>>>        End
91545>>>>>>>>
91545>>>>>>>        Move (sRootName + ".int")                    to sPhysicalName
91546>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
91549>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
91552>>>>>>>
91552>>>>>>>        // The Studio no longer adds the schema to the DISPLAY_NAME, so commented out.
91552>>>>>>>        //
91552>>>>>>>        // We don't want to change the display name if it starts with an ampersand ("@"),
91552>>>>>>>        // because then the table should not be visible to users.
91552>>>>>>>//        Move (Pos("@", sDisplayName)) to iPos
91552>>>>>>>//        If (iPos <> 1) Begin
91552>>>>>>>//            If (sDisplayName contains ".") Begin
91552>>>>>>>//                Move (Pos(".", sDisplayName)) to iPos
91552>>>>>>>//                Move (Mid(sDisplayName, 200 ,(iPos + 1))) to sDisplayName
91552>>>>>>>//                Move (sSchema + "." + sDisplayName)       to sDisplayName
91552>>>>>>>//            End
91552>>>>>>>//            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
91552>>>>>>>//                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
91552>>>>>>>//            End
91552>>>>>>>//        End
91552>>>>>>>
91552>>>>>>>        If (bIsAlias = False) Begin
91554>>>>>>>            Get OpenTableExclusive hTable to bOpened
91555>>>>>>>            If (bOpened = False) Begin
91557>>>>>>>                Error DFERR_PROGRAM ("Function ApiTableAttachToSQL - Could not open table number:" * String(hTable) * sLogicalName)
91558>>>>>>>>
91558>>>>>>>                Function_Return False
91559>>>>>>>            End
91559>>>>>>>>
91559>>>>>>>        End
91559>>>>>>>>
91559>>>>>>>
91559>>>>>>>        If (ghoProgressBar <> 0) Begin
91561>>>>>>>            Send DoAdvance of ghoProgressBar
91562>>>>>>>            Set Message_Text of ghoStatusPanel to ""
91563>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Attaching to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable) * "to SQL")
91564>>>>>>>        End
91564>>>>>>>>
91564>>>>>>>        // Note: The hToTable will get changed by the Structure_xxx command...
91564>>>>>>>        Move hTable to hToTable
91565>>>>>>>        Move False to Err
91566>>>>>>>
91566>>>>>>>        // We now create a stub .int file and after Structure_end and also change the Filelist.cfg,
91566>>>>>>>        // then we do a pseudo .int file change with the "SqlUtilUpdateIntFile" function. After that we have
91566>>>>>>>        // a proper and updated .int file.
91566>>>>>>>        Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bSystemFile
91569>>>>>>>        Get SqlUtilCreateIntFile hTable sDriverID sConnectionID True bSystemFile to bOK
91570>>>>>>>
91570>>>>>>>        If (bIsAlias = False) Begin
91572>>>>>>>            Structure_Start hToTable sDriverID
91573>>>>>>>                Set Private.phCurrentTable to hTable
91574>>>>>>>                If (bUseConnectionID = True) Begin
91576>>>>>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to (CS_DFCONNID + "=" + sConnectionID)
91579>>>>>>>                End
91579>>>>>>>>
91579>>>>>>>                Else Begin
91580>>>>>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to sConnectionString
91583>>>>>>>                End
91583>>>>>>>>
91583>>>>>>>                Set_Attribute DF_FILE_OWNER         of hToTable to (Lowercase(sSchema))
91586>>>>>>>                // For unknown reason the above sometimes triggers an error and it doesn't help to try to trap the error; so we cheat...
91586>>>>>>>                Move False to Err
91587>>>>>>>                Move 0 to LastErr
91588>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
91589>>>>>>>            Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
91591>>>>>>>            Set Action_Text of ghoStatusPanel to ""
91592>>>>>>>        End
91592>>>>>>>>
91592>>>>>>>
91592>>>>>>>        Move (not(Err)) to bOK
91593>>>>>>>        If (bOK = True) Begin
91595>>>>>>>            // The attributes set above will always trigger an error
91595>>>>>>>            // We also adjust the Filelist entries
91595>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to (sDriverID + ":" + sRootName)
91598>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
91601>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
91604>>>>>>>
91604>>>>>>>            // This updates the .int file to make it up-to-date with the SQL back-end.
91604>>>>>>>            Get SqlUtilUpdateIntFile hTable to bOK
91605>>>>>>>        End
91605>>>>>>>>
91605>>>>>>>
91605>>>>>>>        Function_Return (bOK = True)
91606>>>>>>>    End_Function
91607>>>>>>>
91607>>>>>>>    // Sample usage:
91607>>>>>>>    //    Get ApiTableChangeAttribute SysInfo.File_Number DF_FILE_IS_SYSTEM_FILE True to bOK
91607>>>>>>>    //    Get ApiTableChangeAttribute OrderHea.File_Number DF_FILE_REUSE_DELETED DF_FILE_DELETED_NOREUSE to bOK
91607>>>>>>>    Function ApiTableChangeAttribute Handle hTable Integer iAttribute Integer iValue Returns Boolean
91609>>>>>>>        Boolean bOK bIsSQLTable
91609>>>>>>>
91609>>>>>>>        Get AutoConnectionIDLogin to bOK
91610>>>>>>>        Move False to Err
91611>>>>>>>        Get OpenTableExclusive hTable to bOK
91612>>>>>>>        If (bOK = False) Begin
91614>>>>>>>            Function_Return False
91615>>>>>>>        End
91615>>>>>>>>
91615>>>>>>>
91615>>>>>>>        // ToDo: Add to all table change functions!
91615>>>>>>>            Get UtilTableIsSQL hTable to bIsSQLTable
91616>>>>>>>            If (bIsSQLTable = True) Begin
91618>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
91621>>>>>>>            End
91621>>>>>>>>
91621>>>>>>>
91621>>>>>>>        Set Private.phCurrentTable to hTable
91622>>>>>>>        Structure_Start hTable
91623>>>>>>>            Set_Attribute iAttribute of hTable to iValue
91626>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
91627>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
91629>>>>>>>
91629>>>>>>>        Set Action_Text of ghoStatusPanel to ""
91630>>>>>>>        Function_Return (Err = False)
91631>>>>>>>    End_Function
91632>>>>>>>
91632>>>>>>>    Function ApiTableMoveFileListEntry String sRootName String sLogicalName String sDisplayName Handle hFromSlot Handle hToSlot String sDriverID Returns Boolean
91634>>>>>>>        Boolean bOK
91634>>>>>>>        
91634>>>>>>>        Get ApiTableChangeFileListSlot sRootName sLogicalName sDisplayName hToSlot sDriverID to bOK
91635>>>>>>>        If (bOK = True) Begin
91637>>>>>>>            Get ApiTableChangeFileListSlot "" "" "" hFromSlot sDriverID to bOK
91638>>>>>>>        End
91638>>>>>>>>
91638>>>>>>>        
91638>>>>>>>        Function_Return (bOK = True)
91639>>>>>>>    End_Function
91640>>>>>>>    
91640>>>>>>>    // To use a filelist slot for the passed FileName, TableName & DisplayName,
91640>>>>>>>    // or to change the filelist slot names.
91640>>>>>>>    Function ApiTableChangeFileListSlot String sRootName String sLogicalName String sDisplayName Handle hTable String sDriverID Returns Boolean
91642>>>>>>>        String sFileListName
91642>>>>>>>        
91642>>>>>>>        Move False to Err
91643>>>>>>>
91643>>>>>>>        If (ghoProgressBar <> 0) Begin
91645>>>>>>>            Send DoAdvance of ghoProgressBar
91646>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Changing Filelist slot for Table:" * String(sLogicalName) * "Number:" * String(hTable))
91647>>>>>>>        End
91647>>>>>>>>
91647>>>>>>>        // If all strings are empty it means that we should remove this entry from filelist.
91647>>>>>>>        If (sRootName = "" and sLogicalName = "" and sDisplayName = "") Begin
91649>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
91652>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
91655>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
91658>>>>>>>            Function_Return (Err = False) // And we're done.
91659>>>>>>>        End
91659>>>>>>>>
91659>>>>>>>
91659>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
91661>>>>>>>//            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
91661>>>>>>>            Move (sDriverID + ":" + sRootName) to sRootName
91662>>>>>>>        End
91662>>>>>>>>
91662>>>>>>>//        Else Begin
91662>>>>>>>//            Set_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
91662>>>>>>>//        End
91662>>>>>>>//
91662>>>>>>>//        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
91662>>>>>>>//        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
91662>>>>>>>
91662>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
91665>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
91668>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
91671>>>>>>>        
91671>>>>>>>        Function_Return (Err = False)
91672>>>>>>>    End_Function
91673>>>>>>>
91673>>>>>>>    Function ApiTableChangeRecordLength Handle hTable Integer iRecordLength Returns Boolean
91675>>>>>>>        Boolean bOK
91675>>>>>>>
91675>>>>>>>        Get AutoConnectionIDLogin to bOK
91676>>>>>>>        Move False to Err
91677>>>>>>>        Get OpenTableExclusive hTable to bOK
91678>>>>>>>        If (bOK = False) Begin
91680>>>>>>>            Function_Return False
91681>>>>>>>        End
91681>>>>>>>>
91681>>>>>>>
91681>>>>>>>        Set Private.phCurrentTable to hTable
91682>>>>>>>        Structure_Start hTable
91683>>>>>>>            Set_Attribute DF_FILE_RECORD_LENGTH of hTable to iRecordLength
91686>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
91687>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
91689>>>>>>>
91689>>>>>>>        Set Action_Text of ghoStatusPanel to ""
91690>>>>>>>        Function_Return (Err = False)
91691>>>>>>>    End_Function
91692>>>>>>>
91692>>>>>>>    Function ApiTableChangeRelation Handle hTable Handle hToTable Integer iFromField Integer iToField Returns Boolean
91694>>>>>>>        Boolean bOK bIsSQLTable
91694>>>>>>>
91694>>>>>>>        Move False to Err
91695>>>>>>>        Get AutoConnectionIDLogin to bOK
91696>>>>>>>        Open hToTable
91698>>>>>>>        Get OpenTableExclusive hTable to bOK
91699>>>>>>>        If (bOK = False) Begin
91701>>>>>>>            Function_Return False
91702>>>>>>>        End
91702>>>>>>>>
91702>>>>>>>
91702>>>>>>>            Get UtilTableIsSQL hTable to bIsSQLTable
91703>>>>>>>            If (bIsSQLTable = True) Begin
91705>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
91708>>>>>>>            End
91708>>>>>>>>
91708>>>>>>>
91708>>>>>>>        Set Private.phCurrentTable to hTable
91709>>>>>>>        Structure_Start hTable
91710>>>>>>>            Set_Attribute DF_FIELD_RELATED_FILE  of hTable iFromField to hToTable
91713>>>>>>>            Set_Attribute DF_FIELD_RELATED_FIELD of hTable iFromField to iToField
91716>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
91717>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
91719>>>>>>>
91719>>>>>>>        Set Action_Text of ghoStatusPanel to ""
91720>>>>>>>        Function_Return (Err = False)
91721>>>>>>>    End_Function
91722>>>>>>>
91722>>>>>>>    Procedure ApiTableConvertAllAddException Integer hTable
91724>>>>>>>        Integer[] aTableConvertExceptions
91725>>>>>>>        Get paTableConvertExceptions to aTableConvertExceptions
91726>>>>>>>        Move hTable to aTableConvertExceptions[SizeOfArray(aTableConvertExceptions)]
91727>>>>>>>        Set paTableConvertExceptions to aTableConvertExceptions
91728>>>>>>>    End_Procedure
91729>>>>>>>
91729>>>>>>>    Procedure ApiTableDateCorrectionAddException Integer hTable
91731>>>>>>>        Integer[] aTableDateCorrectionExceptions
91732>>>>>>>        Get paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
91733>>>>>>>        Move hTable to aTableDateCorrectionExceptions[SizeOfArray(aTableDateCorrectionExceptions)]
91734>>>>>>>        Set paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
91735>>>>>>>    End_Procedure
91736>>>>>>>
91736>>>>>>>    Procedure ApiTableConvertALLToSql
91738>>>>>>>        Integer[] iTablesArray
91739>>>>>>>        Integer iSize iCount
91739>>>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
91739>>>>>>>        String sDriverID
91739>>>>>>>
91739>>>>>>>        Get psDriverID to sDriverID
91740>>>>>>>        Get pbUseConnectionID to bUseConnectionID
91741>>>>>>>        Get pbToANSI          to bToANSI
91742>>>>>>>        Get pbRecnum          to bRecnum
91743>>>>>>>        Get pbCopyData        to bCopyData
91744>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
91746>>>>>>>            Get pbContinueOnError to bContinueOnError
91747>>>>>>>        End
91747>>>>>>>>
91747>>>>>>>
91747>>>>>>>        Get _AllTablesToConvert to iTablesArray
91748>>>>>>>        Move (SizeOfArray(iTablesArray)) to iSize
91749>>>>>>>        Set pbVisible   of ghoProgressBarOverall to True
91750>>>>>>>        Set piPosition  of ghoProgressBarOverall to 0
91751>>>>>>>        Set piAdvanceBy of ghoProgressBarOverall to 1
91752>>>>>>>        Set piMaximum   of ghoProgressBarOverall to iSize
91753>>>>>>>
91753>>>>>>>        Decrement iSize
91754>>>>>>>        For iCount from 0 to iSize
91760>>>>>>>>
91760>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount
91761>>>>>>>            Get ApiTableConvertToSQL_Ex iTablesArray[iCount] sDriverID bUseConnectionID bToANSI bRecnum bCopyData to bOK
91762>>>>>>>            // Probably the right logic here is to just continue trying to convert every table even
91762>>>>>>>            // if there was an error converting one table...
91762>>>>>>>            //If (bContinueOnError = False and bOK = False) Break
91762>>>>>>>        Loop
91763>>>>>>>>
91763>>>>>>>
91763>>>>>>>    End_Procedure
91764>>>>>>>
91764>>>>>>>    Procedure ApiTableAttachALLToSql
91766>>>>>>>        Integer[] iTablesArray
91767>>>>>>>        Integer iSize iCount
91767>>>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
91767>>>>>>>        String sDriverID
91767>>>>>>>
91767>>>>>>>        Get psDriverID to sDriverID
91768>>>>>>>        Get pbUseConnectionID to bUseConnectionID
91769>>>>>>>        Get pbToANSI          to bToANSI
91770>>>>>>>        Get pbRecnum          to bRecnum
91771>>>>>>>        Get pbCopyData        to bCopyData
91772>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
91774>>>>>>>            Get pbContinueOnError to bContinueOnError
91775>>>>>>>        End
91775>>>>>>>>
91775>>>>>>>
91775>>>>>>>        Get _AllTablesToConvert to iTablesArray
91776>>>>>>>        Move (SizeOfArray(iTablesArray)) to iSize
91777>>>>>>>        Decrement iSize
91778>>>>>>>        For iCount from 0 to iSize
91784>>>>>>>>
91784>>>>>>>            Get ApiTableAttachToSQL iTablesArray[iCount] bUseConnectionID to bOK
91785>>>>>>>        Loop
91786>>>>>>>>
91786>>>>>>>
91786>>>>>>>    End_Procedure
91787>>>>>>>
91787>>>>>>>    // Subfunction to the ApiTableUpdate function (et al)
91787>>>>>>>    Function _UtilTableCheckChangeFilelistNames tAPITableNameInfo APITableNameInfoFrom Boolean bIsSQLTableTo Returns Boolean
91789>>>>>>>        Handle hTable
91789>>>>>>>        String sConnectionID
91789>>>>>>>        Boolean bTableExists bSameTableNames bANSI bOK
91789>>>>>>>
91789>>>>>>>        Get ApiTableFilelistNamesCompare True APITableNameInfoFrom to bSameTableNames
91790>>>>>>>        If (bSameTableNames = True) Begin
91792>>>>>>>            Function_Return True
91793>>>>>>>        End
91793>>>>>>>>
91793>>>>>>>
91793>>>>>>>        Move True to bOK
91794>>>>>>>        Move APITableNameInfoFrom.iTableNumber  to hTable
91795>>>>>>>        Set Private.phCurrentTable              to hTable
91796>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME         of hTable to APITableNameInfoFrom.sRootName
91799>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME      of hTable to APITableNameInfoFrom.sLogicalName
91802>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME      of hTable to APITableNameInfoFrom.sDisplayName
91805>>>>>>>
91805>>>>>>>        If (APITableNameInfoFrom.bIsSQL = True) Begin
91807>>>>>>>            Get psConnectionID to sConnectionID
91808>>>>>>>            Get UtilTableExists hTable to bTableExists
91809>>>>>>>            If (bTableExists = True) Begin
91811>>>>>>>                Get SqlUtilUpdateIntFile hTable to bOK
91812>>>>>>>            End
91812>>>>>>>>
91812>>>>>>>            Else Begin
91813>>>>>>>                Get pbToANSI to bANSI
91814>>>>>>>                Get SqlUtilCreateIntFile hTable APITableNameInfoFrom.sDriverID sConnectionID bANSI False to bOK
91815>>>>>>>            End
91815>>>>>>>>
91815>>>>>>>        End
91815>>>>>>>>
91815>>>>>>>
91815>>>>>>>        Function_Return bOK
91816>>>>>>>    End_Function
91817>>>>>>>
91817>>>>>>>    Function ApiTableConvertToSql_Ex Handle hTable String sDriverID Boolean bUseConnectionID Boolean bToAnsi Boolean bRecnum Boolean bCopyData Returns Boolean
91819>>>>>>>        Handle hToTable hoLogFile
91819>>>>>>>        Boolean bOK bExists bOpened bMertechDriver bDAWDriver bContinueOnError bIsAlias
91819>>>>>>>        String sPhysicalName sRootName sLogicalName sDisplayName sConnectionID sConnectionString
91819>>>>>>>        String sANSI_OEM sSchema sBaseTableSpace sLongTableSpace sIndexTableSpace sDatabase sGUIDName sWarning
91819>>>>>>>        tSQLConnection SQLConnection
91819>>>>>>>        tSQLConnection SQLConnection
91819>>>>>>>
91819>>>>>>>        Get UtilTableExists hTable to bExists
91820>>>>>>>        If (bExists = False) Begin
91822>>>>>>>            Set Private.phCurrentTable to hTable
91823>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end.(Or Filelist.cfg contains a driver but the table doesn't exists on the SQL back-end)"
91824>>>>>>>>
91824>>>>>>>            Function_Return False
91825>>>>>>>        End
91825>>>>>>>>
91825>>>>>>>
91825>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias
91826>>>>>>>        // If this is an Alias file there is nothing to convert to SQL.
91826>>>>>>>        // Instead we change the Filelist.cfg by adding the driver id to the rootname and create an .int file
91826>>>>>>>        If (bIsAlias = True) Begin
91828>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
91831>>>>>>>            If (sDriverID <> DATAFLEX_ID and not(sRootName contains ":")) Begin
91833>>>>>>>                Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
91836>>>>>>>                Get psConnectionID to sConnectionID
91837>>>>>>>                Get SqlUtilCreateIntFile hTable sDriverID sConnectionID True False to bOK
91838>>>>>>>            End
91838>>>>>>>>
91838>>>>>>>            Function_Return True
91839>>>>>>>        End
91839>>>>>>>>
91839>>>>>>>
91839>>>>>>>        Set Private.phCurrentTable to hTable
91840>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
91843>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
91846>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
91849>>>>>>>
91849>>>>>>>        If (ghoProgressBar <> 0) Begin
91851>>>>>>>            Send DoAdvance of ghoProgressBar
91852>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * "Number:" * String(hTable) * String(sLogicalName))
91853>>>>>>>            Set Message_Text   of ghoStatusPanel to ""
91854>>>>>>>            Set Action_Text    of ghoStatusPanel to ""
91855>>>>>>>        End
91855>>>>>>>>
91855>>>>>>>
91855>>>>>>>        // Marco Kuipers suggestion;
91855>>>>>>>        // If Filelist.cfg points to an embedded .dat table and the table already exists as
91855>>>>>>>        // an SQL table; Instead of creating the table in SQL, attach it to the existing
91855>>>>>>>        // SQL table.
91855>>>>>>>        Get UtilTableIsSQL hTable to bOK
91856>>>>>>>        If (bOK = False) Begin
91858>>>>>>>            Get SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
91859>>>>>>>            If (bExists = True) Begin
91861>>>>>>>//                Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
91861>>>>>>>//                Get SqlTableRename hTable sLogicalName sGUIDName to bOK
91861>>>>>>>                Get phoLogFile to hoLogFile
91862>>>>>>>                If (hoLogFile <> 0) Begin          
91864>>>>>>>                    Move ("WARNING! Function: ApiTableConvertToSQL_Ex. The table" * sLogicalName * "pointed to an embedded table in Filelist.cfg that already existed as an SQL table! The table was NOT converted to SQL but instead ATTACHED to the existing SQL table.") to sWarning
91865>>>>>>>//                    Move ("WARNING! Function: ApiTableConvertToSQL_Ex. The table" * sLogicalName * "pointed to an embedded table in Filelist.cfg that already existed as an SQL table! The existing SQL table was renamed to:" * String(sGUIDName) * "and then converted again.") to sWarning
91865>>>>>>>                    Send LogError sWarning False
91866>>>>>>>                End
91866>>>>>>>>
91866>>>>>>>                Else Begin
91867>>>>>>>                    Error DFERR_PROGRAM sWarning
91868>>>>>>>>
91868>>>>>>>                End                                                       
91868>>>>>>>>
91868>>>>>>>                Get ApiTableAttachToSql hTable bUseConnectionID to bOK
91869>>>>>>>                Function_Return bOK // We're done (We have attached to an existing SQL table instead of converting it.
91870>>>>>>>            End
91870>>>>>>>>
91870>>>>>>>        End
91870>>>>>>>>
91870>>>>>>>
91870>>>>>>>        // Does the rootname contain a driver?
91870>>>>>>>        If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
91872>>>>>>>            // Does the table already exist as an SQL table?
91872>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
91873>>>>>>>            // It can happen that the table is missing from Filelist.cfg but still
91873>>>>>>>            // exist on the SQL side, in case we want to search for the table by its name.
91873>>>>>>>            If (bExists = False) Begin
91875>>>>>>>                Get SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
91876>>>>>>>            End
91876>>>>>>>>
91876>>>>>>>            If (bExists = True) Begin
91878>>>>>>>                Set TableName_Text of ghoStatusPanel to ""
91879>>>>>>>                Function_Return False
91880>>>>>>>            End
91880>>>>>>>>
91880>>>>>>>        End
91880>>>>>>>>
91880>>>>>>>        Move (If(bToAnsi = True, CS_ANSI_Txt, CS_OEM_Txt)) to sANSI_OEM
91881>>>>>>>
91881>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWDriver
91882>>>>>>>        // Mertech drivers don't use Connection ID's; so if bUseConnectionID was
91882>>>>>>>        // passed as True, we adjust for that here.
91882>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
91883>>>>>>>        If (bMertechDriver = True and bUseConnectionID = True) Begin
91885>>>>>>>            Move False to bUseConnectionID
91886>>>>>>>        End
91886>>>>>>>>
91886>>>>>>>
91886>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
91887>>>>>>>        Move SQLConnection.sSchema           to sSchema
91888>>>>>>>        If (sSchema = "") Begin
91890>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO    to sSchema
91891>>>>>>>            Move (Lowercase(sSchema))        to sSchema
91892>>>>>>>        End
91892>>>>>>>>
91892>>>>>>>
91892>>>>>>>        If (sDriverID = ORAFLEX) Begin
91894>>>>>>>            Move SQLConnection.sUserID       to sSchema
91895>>>>>>>        End
91895>>>>>>>>
91895>>>>>>>
91895>>>>>>>        Move SQLConnection.sDatabase         to sDatabase
91896>>>>>>>        Move SQLConnection.sConnectionID     to sConnectionID
91897>>>>>>>        Move SQLConnection.sConnectionString to sConnectionString
91898>>>>>>>        If (sConnectionID = "" or sConnectionString = "") Begin
91900>>>>>>>            Error DFERR_PROGRAM ("The SQL connection info has NOT been setup. Could not convert table:" * String(hTable) * "to SQL")
91901>>>>>>>>
91901>>>>>>>            Function_Return False
91902>>>>>>>        End
91902>>>>>>>>
91902>>>>>>>
91902>>>>>>>        Get AutoConnectionIDLogin to bOK
91903>>>>>>>        Open hTable
91905>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
91908>>>>>>>        If (bOpened = False) Begin
91910>>>>>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
91911>>>>>>>>
91911>>>>>>>            Function_Return False
91912>>>>>>>        End
91912>>>>>>>>
91912>>>>>>>
91912>>>>>>>        If (ghoProgressBar <> 0) Begin
91914>>>>>>>            Send DoAdvance of ghoProgressBar
91915>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Converting to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable))
91916>>>>>>>        End
91916>>>>>>>>
91916>>>>>>>
91916>>>>>>>        Move 0 to hToTable
91917>>>>>>>        Get _TableNameOnly sRootName                 to sRootName
91918>>>>>>>        Move (sRootName + ".int")                    to sPhysicalName
91919>>>>>>>
91919>>>>>>>        Case Begin
91919>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
91921>>>>>>>                Case Break
91922>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
91925>>>>>>>                Case Break
91926>>>>>>>            Case (sDriverID = DB2_DRV_ID)
91929>>>>>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
91930>>>>>>>                Move SQLConnection.sLongTableSpace  to sLongTableSpace
91931>>>>>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
91932>>>>>>>                Case Break
91933>>>>>>>            Case (sDriverID = ORAFLEX)
91936>>>>>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
91937>>>>>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
91938>>>>>>>                Case Break
91939>>>>>>>            Case (sDriverID = MDSMySQL)
91942>>>>>>>                Case Break
91943>>>>>>>            Case (sDriverID = MDSPgSQL)
91946>>>>>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
91947>>>>>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
91948>>>>>>>                Case Break
91949>>>>>>>            Case (sDriverID = DATAFLEX_ID)
91952>>>>>>>                Case Break
91953>>>>>>>            Case Else
91953>>>>>>>                Error DFERR_PROGRAM "Wrong database driver passed to the 'ApiTableConvertToSQL_Ex' function."
91954>>>>>>>>
91954>>>>>>>                Case Break
91955>>>>>>>        Case End
91955>>>>>>>
91955>>>>>>>        Move False to Err
91956>>>>>>>
91956>>>>>>>        If (bMertechDriver = True) Begin
91958>>>>>>>            // Note: This function also sets the Err flag.
91958>>>>>>>            Get _MertechApiTableConvertToSQL hTable sRootName sDatabase sDriverID sBaseTableSpace sIndexTableSpace bToAnsi bCopyData to bOK
91959>>>>>>>        End
91959>>>>>>>>
91959>>>>>>>
91959>>>>>>>        If (bMertechDriver = False) Begin
91961>>>>>>>            Structure_Start hToTable sDriverID
91962>>>>>>>                Structure_Copy hTable to hToTable
91963>>>>>>>                Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
91966>>>>>>>
91966>>>>>>>                If (sDriverID <> DATAFLEX_ID) Begin
91968>>>>>>>                    If (bUseConnectionID = True) Begin
91970>>>>>>>                        Set_Attribute DF_FILE_LOGIN of hToTable to (CS_DFCONNID + "=" + sConnectionID)
91973>>>>>>>                    End
91973>>>>>>>>
91973>>>>>>>                    Else Begin
91974>>>>>>>                        Set_Attribute DF_FILE_LOGIN of hToTable to sConnectionString
91977>>>>>>>                    End
91977>>>>>>>>
91977>>>>>>>
91977>>>>>>>                    Set_Attribute DF_FILE_RECNUM_TABLE of hToTable to bRecnum
91980>>>>>>>
91980>>>>>>>                    If (sSchema <> "") Begin
91982>>>>>>>                        Set_Attribute DF_FILE_OWNER of hToTable to sSchema
91985>>>>>>>                    End
91985>>>>>>>>
91985>>>>>>>
91985>>>>>>>                    If (sDriverID = DB2_DRV_ID) Begin
91987>>>>>>>                        If (sLongTableSpace <> "") Begin
91989>>>>>>>                            Set_Attribute DF_FILE_LONG_TABLESPACE  of hToTable to sLongTableSpace
91992>>>>>>>                        End
91992>>>>>>>>
91992>>>>>>>                        If (sBaseTableSpace <> "") Begin
91994>>>>>>>                            Set_Attribute DF_FILE_TABLE_TABLESPACE of hToTable to sBaseTableSpace
91997>>>>>>>                        End
91997>>>>>>>>
91997>>>>>>>                        If (sIndexTableSpace <> "") Begin
91999>>>>>>>                            Set_Attribute DF_FILE_INDEX_TABLESPACE of hToTable to sIndexTableSpace
92002>>>>>>>                        End
92002>>>>>>>>
92002>>>>>>>                    End
92002>>>>>>>>
92002>>>>>>>                End
92002>>>>>>>>
92002>>>>>>>
92002>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
92003>>>>>>>            Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
92005>>>>>>>            Set Action_Text of ghoStatusPanel to ""
92006>>>>>>>        End
92006>>>>>>>>
92006>>>>>>>
92006>>>>>>>        Move (not(Err)) to bOK
92007>>>>>>>
92007>>>>>>>        If (bOK = True and bCopyData = True) Begin
92009>>>>>>>            If (bMertechDriver = False) Begin
92011>>>>>>>                Get ApiTableCopyData hTable sPhysicalName sRootName sDriverID to bOK
92012>>>>>>>            End
92012>>>>>>>>
92012>>>>>>>            Else Begin
92013>>>>>>>                Get _MertechCopyDataToSQL hTable sRootName sDriverID to bOK
92014>>>>>>>            End
92014>>>>>>>>
92014>>>>>>>
92014>>>>>>>            If (ghoDbUpdateHandler > 0) Begin
92016>>>>>>>                Get pbContinueOnError to bContinueOnError
92017>>>>>>>            End
92017>>>>>>>>
92017>>>>>>>            // If the data copy failed we will keep the newly created SQL table but
92017>>>>>>>            // rename it by adding a GUID to the end of the table name
92017>>>>>>>            // - or as much as "fit" because different SQL back-ends have
92017>>>>>>>            // different rules how long a table name can be.
92017>>>>>>>            // The new table will probably contain data but something went
92017>>>>>>>            // wrong while converting the data from embedded to SQL.
92017>>>>>>>            If (bOK = False and bContinueOnError = False) Begin
92019>>>>>>>                Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
92020>>>>>>>                Get SqlTableRename hTable sLogicalName sGUIDName to bOK
92021>>>>>>>                Error DFERR_PROGRAM ("Copying of" * sLogicalName * " data failed due to bad data. Either duplicate records and/or bad e.g Date/DateTime data. The SQL table was renamed to:" * String(sGUIDName) * "and its Filelist.cfg entry was NOT changed.")
92022>>>>>>>>
92022>>>>>>>            End
92022>>>>>>>>
92022>>>>>>>        End
92022>>>>>>>>
92022>>>>>>>
92022>>>>>>>        // This must be after copying data...
92022>>>>>>>        If (Err = False) Begin
92024>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
92027>>>>>>>            // It seems the Studio does not do this any more, so commented out.
92027>>>>>>>            // We also adjust the display name by prefixing it by the schema name;
92027>>>>>>>            //            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
92027>>>>>>>            //                // The max length for the display_name is 31 characters...
92027>>>>>>>            //                If (Length(sSchema + "." + sDisplayName) < 31) Begin
92027>>>>>>>            //                    Set_Attribute DF_FILE_DISPLAY_NAME of hTable to (Lowercase(sSchema) + "." + sDisplayName)
92027>>>>>>>            //                End
92027>>>>>>>            //            End
92027>>>>>>>        End
92027>>>>>>>>
92027>>>>>>>
92027>>>>>>>        Close hTable
92028>>>>>>>        Move (not(Err)) to bOK
92029>>>>>>>        Function_Return bOK
92030>>>>>>>    End_Function
92031>>>>>>>
92031>>>>>>>    // Calls a driver function directly to copy data from one table to another (table structures needs to be the same).
92031>>>>>>>    // It will first drop all indicies, copy the data and then recreate indicies.
92031>>>>>>>    // An error log file with the sRootname + ".err" will be created in the Data folder.
92031>>>>>>>    Function ApiTableCopyData Integer hFromTable String sPhysicalName String sRootName String sDriverID Returns Boolean
92033>>>>>>>        Boolean bOpened bOK
92033>>>>>>>        Integer hToTable iIndex iRetval iVoid iOrgFreq
92033>>>>>>>        String sErrorFile sEmpty sPath
92033>>>>>>>
92033>>>>>>>        Get_Attribute DF_FILE_NEXT_EMPTY of 0 to hToTable
92036>>>>>>>        Get AutoConnectionIDLogin to bOK
92037>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
92039>>>>>>>            Send IncreaseSortBufferSize
92040>>>>>>>//            Send SetAllIndexesToBatch hToTable
92040>>>>>>>        End
92040>>>>>>>>
92040>>>>>>>
92040>>>>>>>        Move False to Err
92041>>>>>>>        Open sPhysicalName as hToTable
92043>>>>>>>        Get_Attribute DF_FILE_OPENED of hToTable to bOpened
92046>>>>>>>        If (bOpened = False) Begin
92048>>>>>>>            Function_Return False
92049>>>>>>>        End
92049>>>>>>>>
92049>>>>>>>
92049>>>>>>>        If (ghoStatusPanel <> 0) Begin
92051>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Copying Data for Table:" * sRootName * "Number:" * String(hFromTable))
92052>>>>>>>            Set piMinimum of ghoProgressBar to 0
92053>>>>>>>            Set piMaximum of ghoProgressBar to 100 // 100%
92054>>>>>>>        End
92054>>>>>>>>
92054>>>>>>>
92054>>>>>>>        Move "" to sEmpty
92055>>>>>>>        Move False to Err
92056>>>>>>>        Move True to bOK
92057>>>>>>>        Set Private.phCurrentTable to hToTable
92058>>>>>>>
92058>>>>>>>        // No need to get the record identifier
92058>>>>>>>        Set_Attribute DF_FILE_GET_RID_AFTER_CREATE of hToTable to False
92061>>>>>>>        Get_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
92064>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
92066>>>>>>>            // Remove all indices to speed up copying of data:
92066>>>>>>>            Call_Driver hToTable sDriverID Function CLI_DROPINDICES Callback ghoDbUpdateHandler Passing sEmpty sEmpty iVoid Result iRetval
92071>>>>>>>            If (iRetval <> 0) Begin       
92073>>>>>>>                Error DFERR_PROGRAM ("Failed dropping indices for table Number:" * String(hToTable) * "Name:" * String(sRootName))
92074>>>>>>>>
92074>>>>>>>                Close hToTable
92075>>>>>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
92078>>>>>>>                Function_Return False
92079>>>>>>>            End
92079>>>>>>>>
92079>>>>>>>        End
92079>>>>>>>>
92079>>>>>>>
92079>>>>>>>        Move (sRootName + ".err") to sErrorFile
92080>>>>>>>        Move 0 to iIndex
92081>>>>>>>        Move False to Err
92082>>>>>>>
92082>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
92084>>>>>>>            Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to 10
92087>>>>>>>            Call_Driver hToTable sDriverID Function CLI_BCP CallBack ghoDbUpdateHandler Passing iIndex sEmpty hFromTable Result iRetval
92092>>>>>>>            If (iRetval <> 0) Begin
92094>>>>>>>                Error DFERR_PROGRAM ("Failed copying data for table Number:" * String(hToTable) * "Name:" * String(sRootName))
92095>>>>>>>>
92095>>>>>>>                Close hToTable
92096>>>>>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
92099>>>>>>>                Function_Return False
92100>>>>>>>            End
92100>>>>>>>>
92100>>>>>>>        End
92100>>>>>>>>
92100>>>>>>>        Else Begin
92101>>>>>>>            Copy_Records hFromTable to hToTable using 0 Callback ghoDbUpdateHandler
92104>>>>>>>        End
92104>>>>>>>>
92104>>>>>>>
92104>>>>>>>        If (Err = False) Begin
92106>>>>>>>            Get psHome of (phoWorkspace(ghoApplication)) to sPath
92107>>>>>>>            Get vDeleteFile (sPath + sErrorFile) to iRetval
92108>>>>>>>        End
92108>>>>>>>>
92108>>>>>>>
92108>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
92110>>>>>>>            // Recreate indices:
92110>>>>>>>            Call_Driver hToTable sDriverID Function CLI_CREATEINDICES Callback ghoDbUpdateHandler Passing sEmpty sEmpty iVoid Result iRetval
92115>>>>>>>            If (iRetval <> 0) Begin
92117>>>>>>>                Error DFERR_PROGRAM ("Failed creating indices for table Number:" * String(hToTable) * "Name:" * String(sRootName))
92118>>>>>>>>
92118>>>>>>>                Close hToTable
92119>>>>>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
92122>>>>>>>                Function_Return False
92123>>>>>>>            End
92123>>>>>>>>
92123>>>>>>>        End
92123>>>>>>>>
92123>>>>>>>
92123>>>>>>>        Close hToTable
92124>>>>>>>        Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
92127>>>>>>>
92127>>>>>>>        If (bOK = True) Begin
92129>>>>>>>            Move (not(Err)) to bOK
92130>>>>>>>        End
92130>>>>>>>>
92130>>>>>>>
92130>>>>>>>        If (ghoStatusPanel <> 0) Begin
92132>>>>>>>            Set TableName_Text of ghoStatusPanel to ""
92133>>>>>>>            Set Message_Text   of ghoStatusPanel to ""
92134>>>>>>>            Set Action_Text    of ghoStatusPanel to ""
92135>>>>>>>        End
92135>>>>>>>>
92135>>>>>>>
92135>>>>>>>        Function_Return (bOK = True)
92136>>>>>>>    End_Function
92137>>>>>>>
92137>>>>>>>    // The bANSI parameter's default value = True, meaning a table in ANSI format will be created.
92137>>>>>>>    // i.e. DF_FILE_TABLE_CHARACTER_FORMAT {"OEM"|"ANSI"}
92137>>>>>>>    Function ApiTableCreate Handle hTable String sRootName String sDisplayName String sLogicalName Boolean bUseConnectionID Boolean bANSI Boolean bRecnum tAPIColumn[] aColumnIn Returns Boolean
92139>>>>>>>        Handle hFile
92139>>>>>>>        String sConnectionID sPhysicalFile sANSI_OEM sVal sSchema sOriginalDriverID sDriverID sTableName
92139>>>>>>>        Integer iIdentityType iDataType iDbType iCount iSize
92139>>>>>>>        Boolean bOk bExists bSqlDriver bMertechDriver bDeleteDummy bExistsInFilelist bSysFile
92139>>>>>>>        tSQLConnection SQLConnection
92139>>>>>>>        tSQLConnection SQLConnection
92139>>>>>>>        tAPIColumn[] aColumns
92139>>>>>>>        tAPIColumn[] aColumns
92140>>>>>>>        tColumnType ColumnType
92140>>>>>>>        tColumnType ColumnType
92140>>>>>>>
92140>>>>>>>        // First check if the passed filenumber already exists; in case we do nothing
92140>>>>>>>        Get UtilTableExists hTable to bOk
92141>>>>>>>        If (bOk = True) Begin
92143>>>>>>>            Function_Return False
92144>>>>>>>        End
92144>>>>>>>>
92144>>>>>>>
92144>>>>>>>        Set Private.phCurrentTable to hTable
92145>>>>>>>        Move sLogicalName to sTableName
92146>>>>>>>        If (ghoProgressBar <> 0) Begin
92148>>>>>>>            Send DoAdvance of ghoProgressBar
92149>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Creating Table:" * String(sTableName) * "Number:" * String(hTable) * String(sLogicalName))
92150>>>>>>>        End
92150>>>>>>>>
92150>>>>>>>
92150>>>>>>>        Get UtilTableLogicalNameIsInUse sTableName to bExistsInFilelist
92151>>>>>>>        Get psDriverID to sDriverID
92152>>>>>>>        Get IsSQLDriver sDriverID to bSqlDriver
92153>>>>>>>        Get piDbType to iDbType
92154>>>>>>>
92154>>>>>>>        // If no columns passed in, we need to create a "dummy" column
92154>>>>>>>        Move False to bDeleteDummy
92155>>>>>>>        If (Num_Arguments = 8) Begin
92157>>>>>>>            Move aColumnIn to aColumns
92158>>>>>>>        End
92158>>>>>>>>
92158>>>>>>>        If ((SizeOfArray(aColumns)) = 0) Begin
92160>>>>>>>            Get UtilDFDataTypeToSqlTypeMapping sDriverID iDbType DF_BCD to ColumnType
92161>>>>>>>            Move ColumnType.iSQLType to iDataType
92162>>>>>>>            If (bRecnum = False) Begin
92164>>>>>>>                Move C_tAPIColumn_Identity to iIdentityType
92165>>>>>>>            End
92165>>>>>>>>
92165>>>>>>>            Else Begin
92166>>>>>>>                Move C_tAPIColumn_None     to iIdentityType
92167>>>>>>>            End
92167>>>>>>>>
92167>>>>>>>            Get _AppendAPIColumn aColumns "temp" iDataType 10 0 iIdentityType to aColumns
92168>>>>>>>            Move True to bDeleteDummy
92169>>>>>>>        End
92169>>>>>>>>
92169>>>>>>>
92169>>>>>>>        // If columns have been passed as an array we need to check if an identity column
92169>>>>>>>        // has been specified (aColumns[iCounter].iOptions = C_tAPIColumn_Identity), and
92169>>>>>>>        // if so auto-set the bRecnum to FALSE. This is because else there would be
92169>>>>>>>        // two identity columns and SQL doesn't like that and throws an error.
92169>>>>>>>        If (bRecnum = True and (SizeOfArray(aColumns)) <> 0) Begin
92171>>>>>>>            Move (SizeOfArray(aColumns)) to iSize
92172>>>>>>>            Decrement iSize
92173>>>>>>>            for iCount from 0 to iSize
92179>>>>>>>>
92179>>>>>>>                If (aColumns[iCount].iOptions = C_tAPIColumn_Identity) Begin
92181>>>>>>>                    Move False to bRecnum
92182>>>>>>>                    Move iSize to iCount
92183>>>>>>>                End
92183>>>>>>>>
92183>>>>>>>            Loop
92184>>>>>>>>
92184>>>>>>>        End
92184>>>>>>>>
92184>>>>>>>
92184>>>>>>>        // If this is a SQL based driver we also check if the table exists
92184>>>>>>>        // in the SQL back end; in case we do nothing.
92184>>>>>>>        If (bSqlDriver = True) Begin
92186>>>>>>>            // Get all connection properties
92186>>>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
92187>>>>>>>            Move SQLConnection.sSchema to sSchema
92188>>>>>>>            If (sSchema = "") Begin
92190>>>>>>>                Get _SqlFindKeyWord CI_SQLDBO to sSchema
92191>>>>>>>            End
92191>>>>>>>>
92191>>>>>>>
92191>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
92192>>>>>>>            // It can happen that the table is missing from Filelist.cfg but still
92192>>>>>>>            // exist on the SQL side, in case we want to search for the table by its name.
92192>>>>>>>            If (bExists = False) Begin
92194>>>>>>>                Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
92195>>>>>>>            End
92195>>>>>>>>
92195>>>>>>>            // If the table exists on the SQL back-end but not in Filelist.cfg,
92195>>>>>>>            // we will just add it to Filelist.cfg
92195>>>>>>>            If (bExists = True) Begin
92197>>>>>>>                If (bExistsInFilelist = False) Begin
92199>>>>>>>                    If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
92201>>>>>>>                        Move (sDriverID + ":" + sRootName) to sRootName
92202>>>>>>>                    End
92202>>>>>>>>
92202>>>>>>>                    Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
92205>>>>>>>                    Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
92208>>>>>>>                    Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
92211>>>>>>>                    Move False to bSysFile
92212>>>>>>>                    Get SqlUtilCreateIntFile hTable sDriverID SQLConnection.sConnectionID bANSI bSysFile to bOK
92213>>>>>>>                End
92213>>>>>>>>
92213>>>>>>>                Function_Return False
92214>>>>>>>            End
92214>>>>>>>>
92214>>>>>>>        End
92214>>>>>>>>
92214>>>>>>>
92214>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
92215>>>>>>>        If (num_arguments > 6) Begin
92217>>>>>>>            If (bANSI = False) Begin
92219>>>>>>>                Move CS_OEM_Txt to sANSI_OEM
92220>>>>>>>            End
92220>>>>>>>>
92220>>>>>>>        End
92220>>>>>>>>
92220>>>>>>>
92220>>>>>>>        // Mertech drivers don't use connection id's, so if the passed bUseConnectionID = True that
92220>>>>>>>        // is a programmer's error and we auto-correct for it here.
92220>>>>>>>        // This is also a bit messy. If a Mertech driver is used and we want to create a new table,
92220>>>>>>>        // we first need to create it as embedded (DataFlex) and then convert it to SQL (!)
92220>>>>>>>        // So we set the driver ID temporarily to "DataFlex" to get the table created as embedded and later
92220>>>>>>>        // set it back and use a Mertech function to convert it to SQL.
92220>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
92221>>>>>>>        If (bMertechDriver = True) Begin
92223>>>>>>>            If (bUseConnectionID = True) Begin
92225>>>>>>>                Move False to bUseConnectionID
92226>>>>>>>            End
92226>>>>>>>>
92226>>>>>>>            Move sDriverID to sOriginalDriverID
92227>>>>>>>            Move DATAFLEX_ID to sDriverID
92228>>>>>>>        End
92228>>>>>>>>
92228>>>>>>>
92228>>>>>>>        Move False to Err
92229>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
92231>>>>>>>            Move sRootName to sPhysicalFile
92232>>>>>>>        End
92232>>>>>>>>
92232>>>>>>>
92232>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
92234>>>>>>>            Move SQLConnection.sConnectionID to sConnectionID
92235>>>>>>>
92235>>>>>>>            // If DAW driver and we should use a connection id we need to
92235>>>>>>>            // check if the connection ID exists; else we create it before attempting creating the table
92235>>>>>>>            If (bMertechDriver = False and bUseConnectionID = True) Begin
92237>>>>>>>                Get IsConnectionID sConnectionID sDriverID to bExists
92238>>>>>>>                If (bExists = False) Begin
92240>>>>>>>                    Get AutoSetConnectionID sConnectionID to bOk
92241>>>>>>>                    If (bOk = False) Begin
92243>>>>>>>                        Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
92244>>>>>>>>
92244>>>>>>>                        Function_Return False
92245>>>>>>>                    End
92245>>>>>>>>
92245>>>>>>>                End
92245>>>>>>>>
92245>>>>>>>            End
92245>>>>>>>>
92245>>>>>>>
92245>>>>>>>            If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
92247>>>>>>>                Move (sTableName + ".int") to sPhysicalFile
92248>>>>>>>            End
92248>>>>>>>>
92248>>>>>>>            Else Begin
92249>>>>>>>                Move (sRootName + ".int") to sPhysicalFile
92250>>>>>>>            End
92250>>>>>>>>
92250>>>>>>>            Move (Uppercase(sDisplayName)) to sVal
92251>>>>>>>//            If (not(sVal contains (sSchema + "."))) Begin
92251>>>>>>>//                Move (Lowercase(sSchema) + "." + sTableName) to sDisplayName
92251>>>>>>>//            End
92251>>>>>>>        End
92251>>>>>>>>
92251>>>>>>>        Move False to Err
92252>>>>>>>        Move 0 to hFile
92253>>>>>>>
92253>>>>>>>        Structure_Start hFile sDriverID
92254>>>>>>>            If (sDriverID <> DATAFLEX_ID) Begin
92256>>>>>>>                If (bUseConnectionID = True) Begin
92258>>>>>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to (CS_DFCONNID + "=" + sConnectionID)
92261>>>>>>>                End
92261>>>>>>>>
92261>>>>>>>                Else Begin
92262>>>>>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to SQLConnection.sConnectionString
92265>>>>>>>                End
92265>>>>>>>>
92265>>>>>>>                Set_Attribute DF_FILE_TABLE_NAME               of hFile to sTableName
92268>>>>>>>                Set_Attribute DF_FILE_USE_DUMMY_ZERO_DATE      of hFile to True
92271>>>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT   of hFile to sANSI_OEM
92274>>>>>>>                Set_Attribute DF_FILE_RECNUM_TABLE             of hFile to bRecnum
92277>>>>>>>
92277>>>>>>>                If (sSchema <> "") Begin
92279>>>>>>>                    Set_Attribute DF_FILE_OWNER                of hFile to sSchema
92282>>>>>>>                End
92282>>>>>>>>
92282>>>>>>>
92282>>>>>>>                If (sDriverID = DB2_DRV_ID) Begin
92284>>>>>>>                    If (SQLConnection.sLongTableSpace <> "") Begin
92286>>>>>>>                        Set_Attribute DF_FILE_LONG_TABLESPACE  of hFile to SQLConnection.sLongTableSpace
92289>>>>>>>                    End
92289>>>>>>>>
92289>>>>>>>                End
92289>>>>>>>>
92289>>>>>>>                If (sDriverID = DB2_DRV_ID or sDriverID = ORAFLEX or sDriverID = MDSPgSQL) Begin
92291>>>>>>>                    If (SQLConnection.sBaseTableSpace <> "") Begin
92293>>>>>>>                        Set_Attribute DF_FILE_TABLE_TABLESPACE of hFile to SQLConnection.sBaseTableSpace
92296>>>>>>>                    End
92296>>>>>>>>
92296>>>>>>>                    If (SQLConnection.sIndexTableSpace <> "") Begin
92298>>>>>>>                        Set_Attribute DF_FILE_INDEX_TABLESPACE of hFile to SQLConnection.sIndexTableSpace
92301>>>>>>>                    End
92301>>>>>>>>
92301>>>>>>>                End
92301>>>>>>>>
92301>>>>>>>            End
92301>>>>>>>>
92301>>>>>>>
92301>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hFile to sPhysicalFile
92304>>>>>>>            Get ApiColumnsAddToTable hFile aColumns True to bOk
92305>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
92306>>>>>>>        Structure_End hFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
92308>>>>>>>        Set Action_Text of ghoStatusPanel to ""
92309>>>>>>>
92309>>>>>>>        // If Mertech driver we convert the newly created embedded table (DataFlex) to SQL
92309>>>>>>>        If (bMertechDriver = True) Begin
92311>>>>>>>            Move sOriginalDriverID to sDriverID
92312>>>>>>>            If (not(sVal contains (sSchema + "."))) Begin
92314>>>>>>>                Move (Lowercase(sSchema) + "." + sTableName) to sDisplayName
92315>>>>>>>            End
92315>>>>>>>>
92315>>>>>>>            // Note: This function also sets the Err flag.
92315>>>>>>>            //Get _MertechApiTableConvertToSQL hTable sRootName SQLConnection.sDatabase sDriverID SQLConnection.sBaseTableSpace SQLConnection.sIndexTableSpace False to bOK
92315>>>>>>>        End
92315>>>>>>>>
92315>>>>>>>
92315>>>>>>>        Move (not(Err)) to bOK
92316>>>>>>>        If (bOk = True) Begin
92318>>>>>>>            If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
92320>>>>>>>                Move (sDriverID + ":" + sRootName) to sRootName
92321>>>>>>>            End
92321>>>>>>>>
92321>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
92324>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
92327>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
92330>>>>>>>
92330>>>>>>>            // Lastly we remove the temporary column we created above, if all went well.
92330>>>>>>>            If (bDeleteDummy) Begin
92332>>>>>>>                Get ApiColumnRemove hTable "temp" to bOk
92333>>>>>>>            End
92333>>>>>>>>
92333>>>>>>>        End
92333>>>>>>>>
92333>>>>>>>
92333>>>>>>>        Set TableName_Text of ghoStatusPanel to ""
92334>>>>>>>        Close hTable
92335>>>>>>>        Function_Return (bOK = True)
92336>>>>>>>    End_Function
92337>>>>>>>
92337>>>>>>>    Function ApiTableCreateAlias String sFileName String sDisplayName String sAliasName Integer iFilelistSlot Returns Boolean
92339>>>>>>>        Move False to Err
92340>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of iFilelistSlot to sFileName
92343>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of iFilelistSlot to sDisplayName
92346>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of iFilelistSlot to sAliasName
92349>>>>>>>
92349>>>>>>>        Function_Return (Err = False)
92350>>>>>>>    End_Function
92351>>>>>>>
92351>>>>>>>    // ToDo: Needs to be revised
92351>>>>>>>    Procedure ApiTableCreateFromDEF String sPath String sFileName String sTableName String sDisplayName Integer iFilelistSlot
92353>>>>>>>        Handle hTable
92353>>>>>>>        String sDEFName sDataPath
92353>>>>>>>        Boolean bExists
92353>>>>>>>
92353>>>>>>>        // Do nothing if MSSQL Driver.
92353>>>>>>>//        Get IsMSSQLDriver to bExists
92353>>>>>>>//        If (bExists = True) Begin
92353>>>>>>>//            Procedure_Return
92353>>>>>>>//        End
92353>>>>>>>
92353>>>>>>>        Get psDataPathFirstPart to sDataPath
92354>>>>>>>        Get vFilePathExists (sDataPath + sFileName + ".dat") to bExists
92355>>>>>>>        If (bExists = True) Begin
92357>>>>>>>            // We also needs to check if it is an Alias file, in case the sFileName.dat exists, but it may
92357>>>>>>>            // still be missing from the filelist and needs to be added.
92357>>>>>>>            Get UtilTableNumberIsInUse iFilelistSlot to bExists
92358>>>>>>>            If (bExists = True) Begin
92360>>>>>>>                Procedure_Return
92361>>>>>>>            End
92361>>>>>>>>
92361>>>>>>>            // Do _not_ use the DEF file if an alias, it will overwrite the base table data.
92361>>>>>>>            Else Begin
92362>>>>>>>                Set_Attribute DF_FILE_ROOT_NAME    of iFilelistSlot to sFileName
92365>>>>>>>                Set_Attribute DF_FILE_LOGICAL_NAME of iFilelistSlot to sTableName
92368>>>>>>>                Set_Attribute DF_FILE_DISPLAY_NAME of iFilelistSlot to sDisplayName
92371>>>>>>>                Procedure_Return
92372>>>>>>>            End
92372>>>>>>>>
92372>>>>>>>        End
92372>>>>>>>>
92372>>>>>>>
92372>>>>>>>        Move (sPath + sFileName + ".def") to sDEFName
92373>>>>>>>        Move 0 to hTable
92374>>>>>>>        Move False to Err
92375>>>>>>>
92375>>>>>>>        Structure_Start hTable DATAFLEX_ID
92376>>>>>>>            Load_Def sDEFName Onto hTable
92377>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hTable to sFileName
92380>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
92381>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
92383>>>>>>>        Set Action_Text of ghoStatusPanel to ""
92384>>>>>>>
92384>>>>>>>        Move iFilelistSlot to hTable
92385>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sFileName
92388>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
92391>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
92394>>>>>>>
92394>>>>>>>    End_Procedure
92395>>>>>>>
92395>>>>>>>    Function ApiTableMoveToFileSlot Integer iFromFileSlot Integer iToFileSlot String sDriverID Returns Boolean
92397>>>>>>>        Boolean bTmp bErr bOK
92397>>>>>>>        String sTableName sDisplayName sFileName
92397>>>>>>>
92397>>>>>>>        // We preserve the value of the Err flag, by saving its current state and resetting it before end of function.
92397>>>>>>>        Move Err to bTmp
92398>>>>>>>        Move False to Err
92399>>>>>>>
92399>>>>>>>        Get AutoConnectionIDLogin to bOK
92400>>>>>>>        // First get the info for the current filelist slot:
92400>>>>>>>        Open iFromFileSlot
92402>>>>>>>        Get_Attribute DF_FILE_OPENED of iFromFileSlot to bOK
92405>>>>>>>        If (bOK = True) Begin
92407>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to sFileName
92410>>>>>>>            Get_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to sTableName
92413>>>>>>>            Get_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to sDisplayName
92416>>>>>>>
92416>>>>>>>            //...then move it.
92416>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of iToFileSlot to sFileName
92419>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iToFileSlot to sTableName
92422>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iToFileSlot to sDisplayName
92425>>>>>>>
92425>>>>>>>            //...and finally remove the old filelist values.
92425>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to ""
92428>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to ""
92431>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to ""
92434>>>>>>>        End
92434>>>>>>>>
92434>>>>>>>        Close iFromFileSlot
92435>>>>>>>
92435>>>>>>>        Move Err to bErr
92436>>>>>>>        Move bTmp to Err
92437>>>>>>>        Function_Return (bErr = False)
92438>>>>>>>    End_Function
92439>>>>>>>
92439>>>>>>>    Function ApiTableRelate Handle hTableFrom Handle hTableTo Integer iColumnFrom Integer iColumnTo Returns Boolean
92441>>>>>>>        Handle hTable
92441>>>>>>>        Boolean bOK
92441>>>>>>>        String sDriverID
92441>>>>>>>
92441>>>>>>>        Get UtilTableExists hTableFrom to bOK
92442>>>>>>>        If (bOK = False) Begin
92444>>>>>>>            Set Private.phCurrentTable to hTableFrom
92445>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
92446>>>>>>>>
92446>>>>>>>            Function_Return False
92447>>>>>>>        End
92447>>>>>>>>
92447>>>>>>>
92447>>>>>>>        Get UtilTableExists hTableTo to bOK
92448>>>>>>>        If (bOK = False) Begin
92450>>>>>>>            Set Private.phCurrentTable to hTableTo
92451>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
92452>>>>>>>>
92452>>>>>>>            Function_Return False
92453>>>>>>>        End
92453>>>>>>>>
92453>>>>>>>
92453>>>>>>>        Get AutoConnectionIDLogin to bOK
92454>>>>>>>        Get UtilTableOpen hTableFrom "" DF_EXCLUSIVE to bOK
92455>>>>>>>        If (bOK = False) Begin
92457>>>>>>>            Function_Return False
92458>>>>>>>        End
92458>>>>>>>>
92458>>>>>>>
92458>>>>>>>        Move False to Err
92459>>>>>>>        Open hTableTo
92461>>>>>>>
92461>>>>>>>        Move hTableFrom to hTable
92462>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
92465>>>>>>>        Set Private.phCurrentTable to hTable
92466>>>>>>>
92466>>>>>>>        Structure_Start hTable sDriverID
92467>>>>>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumnFrom to hTableTo
92470>>>>>>>            If (iColumnTo <> 0) Begin
92472>>>>>>>                Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumnFrom to iColumnTo
92475>>>>>>>            End
92475>>>>>>>>
92475>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
92476>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
92478>>>>>>>        Set Action_Text of ghoStatusPanel to ""
92479>>>>>>>
92479>>>>>>>        If (hTableTo > 0) Begin
92481>>>>>>>            Close hTableTo
92482>>>>>>>        End
92482>>>>>>>>
92482>>>>>>>
92482>>>>>>>        Function_Return (Err = False)
92483>>>>>>>    End_Function
92484>>>>>>>
92484>>>>>>>    // Removes the passed table name completely from disk, filelist (& Sql Server if an Sql-driver)
92484>>>>>>>    Function ApiTableRemove Handle hTable Returns Boolean
92486>>>>>>>        String sTableName sDriverID
92486>>>>>>>        Boolean bOk
92486>>>>>>>        String sDataPath
92486>>>>>>>
92486>>>>>>>        Get AutoConnectionIDLogin to bOK
92487>>>>>>>        Move False to Err
92488>>>>>>>        Get psDriverID to sDriverID
92489>>>>>>>        Get UtilTableHandleToString hTable sDriverID to sTableName
92490>>>>>>>        If (sTableName = "") Begin
92492>>>>>>>            Function_Return False
92493>>>>>>>        End
92493>>>>>>>>
92493>>>>>>>
92493>>>>>>>        Set Private.phCurrentTable to hTable
92494>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
92495>>>>>>>        Delete_db sTableName
92496>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
92497>>>>>>>
92497>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
92499>>>>>>>//            Get SqlTableRemoveByTableName sTableName to bOk  // We don't have to do this because the database is already removed by 'delete_db' above
92499>>>>>>>            Get psDataPathFirstPart to sDataPath
92500>>>>>>>            Get vDeleteFile (sDataPath + sTableName + ".int") to bOk
92501>>>>>>>        End
92501>>>>>>>>
92501>>>>>>>        // Also remove table from filelist.cfg in case the physical file didn't exist.
92501>>>>>>>        If (hTable <> 0) Begin
92503>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
92506>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
92509>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
92512>>>>>>>        End
92512>>>>>>>>
92512>>>>>>>
92512>>>>>>>        Close hTable
92513>>>>>>>        Function_Return (hTable <> 0)
92514>>>>>>>    End_Function
92515>>>>>>>
92515>>>>>>>    Function ApiTableRemoveRelation Handle hTableFrom Integer iColumn Returns Boolean
92517>>>>>>>        Handle hTable
92517>>>>>>>        Boolean bOK
92517>>>>>>>
92517>>>>>>>        Get AutoConnectionIDLogin to bOK
92518>>>>>>>        Move False to Err
92519>>>>>>>        Open hTableFrom Mode DF_EXCLUSIVE
92521>>>>>>>        Move hTableFrom to hTable
92522>>>>>>>
92522>>>>>>>        Structure_Start hTable
92523>>>>>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to 0
92526>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
92527>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
92529>>>>>>>        Set Action_Text of ghoStatusPanel to ""
92530>>>>>>>
92530>>>>>>>        Close hTableFrom
92531>>>>>>>        Function_Return (Err = False)
92532>>>>>>>    End_Function
92533>>>>>>>
92533>>>>>>>    Function ApiTableRename Handle hTable String sRootName String sDisplayName String sLogicalName Returns Boolean
92535>>>>>>>        String sPhysicalName sRootNameTo sLogicalNameTo sDataPath sDriverID sSchema sPhysicalNameTo
92535>>>>>>>        Boolean bOK bExists bOpened
92535>>>>>>>        tAPITableNameInfo APITableNameInfo
92535>>>>>>>        tAPITableNameInfo APITableNameInfo
92535>>>>>>>
92535>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
92538>>>>>>>        If (bOpened = False) Begin
92540>>>>>>>            Get OpenTableExclusive hTable to bOpened
92541>>>>>>>            If (bOpened = False) Begin
92543>>>>>>>                Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
92544>>>>>>>                Function_Return False
92545>>>>>>>            End
92545>>>>>>>>
92545>>>>>>>        End
92545>>>>>>>>
92545>>>>>>>
92545>>>>>>>        Set Private.phCurrentTable to hTable
92546>>>>>>>        Move hTable         to APITableNameInfo.iTableNumber
92547>>>>>>>        Move sRootName      to APITableNameInfo.sRootName
92548>>>>>>>        Move sLogicalName   to APITableNameInfo.sLogicalName
92549>>>>>>>        Move sDisplayName   to APITableNameInfo.sDisplayName
92550>>>>>>>        Get ApiTableFilelistNamesCompare True APITableNameInfo to bExists
92551>>>>>>>        If (bExists = True) Begin
92553>>>>>>>            Function_Return True
92554>>>>>>>        End
92554>>>>>>>>
92554>>>>>>>
92554>>>>>>>        Set Private.phCurrentTable to hTable
92555>>>>>>>        Move False to Err
92556>>>>>>>        Get psDataPathFirstPart to sDataPath
92557>>>>>>>        Get_Attribute DF_FILE_PHYSICAL_NAME of hTable to sPhysicalName
92560>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo
92563>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo
92566>>>>>>>
92566>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
92569>>>>>>>        Close hTable
92570>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
92572>>>>>>>            Get vFilePathExists (sDataPath + sRootNameTo + ".dat") to bExists
92573>>>>>>>            If (bExists = True) Begin
92575>>>>>>>                If (Uppercase(sRootName) <> Uppercase(sRootNameTo)) Begin
92577>>>>>>>                    Copy_db (sDataPath + sRootNameTo) to (sDataPath + sRootName)
92580>>>>>>>                    // We need a short break here before attempting to delete the physical old files or Windows
92580>>>>>>>                    // might report "File in use..." and the deletion will fail.
92580>>>>>>>                    Sleep 2
92581>>>>>>>                    Get vDeleteFile (sDataPath + sRootNameTo + ".*") to bOK
92582>>>>>>>                End
92582>>>>>>>>
92582>>>>>>>            End
92582>>>>>>>>
92582>>>>>>>        End
92582>>>>>>>>
92582>>>>>>>
92582>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
92584>>>>>>>            If (not(sPhysicalName contains ".")) Begin
92586>>>>>>>                Move (sPhysicalName + String(".int")) to sPhysicalName
92587>>>>>>>            End
92587>>>>>>>>
92587>>>>>>>
92587>>>>>>>            // Change the table name in the .int file to the new table new:
92587>>>>>>>            Get UtilChangeSourceCodeLine (sDataPath + sPhysicalName) (CS_DATABASE_NAME * String(sLogicalNameTo)) (CS_DATABASE_NAME * String(sLogicalName)) False to bOK
92588>>>>>>>            If (bOK = False) Begin
92590>>>>>>>                Function_Return False
92591>>>>>>>            End
92591>>>>>>>>
92591>>>>>>>
92591>>>>>>>            // Change table name at the SQL side:
92591>>>>>>>            Get psSchema to sSchema
92592>>>>>>>            Get SqlTableRename hTable sLogicalNameTo sLogicalName to bOK
92593>>>>>>>
92593>>>>>>>            Get _TableNameOnly sRootName to sPhysicalNameTo
92594>>>>>>>            // Remove cache file and Rename the physical file names:
92594>>>>>>>            Get vDeleteFile (sDataPath + sPhysicalNameTo + ".cch")                                  to bOK
92595>>>>>>>            Get vRenameFile (sDataPath + sPhysicalName)            (sDataPath + sRootName + ".int") to bOK
92596>>>>>>>            Get vRenameFile (sDataPath + sPhysicalNameTo + ".tag") (sDataPath + sRootName + ".tag") to bOK
92597>>>>>>>            Move (sDriverID + ":" + sRootName) to sRootName
92598>>>>>>>
92598>>>>>>>            // The Studio no longer adds the schema to the DISPLAY_NAME, so commented out.
92598>>>>>>>//            If (not(sDisplayName contains ".")) Begin
92598>>>>>>>//                Move (sSchema + "." + sDisplayName) to sDisplayName
92598>>>>>>>//            End
92598>>>>>>>        End
92598>>>>>>>>
92598>>>>>>>
92598>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
92601>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
92604>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
92607>>>>>>>
92607>>>>>>>        Function_Return (Err = False)
92608>>>>>>>    End_Function
92609>>>>>>>
92609>>>>>>>    Function ApiTableRenameAlias Integer hTable String sDisplayName String sLogicalName Returns Boolean
92611>>>>>>>        Move False to Err
92612>>>>>>>        Set Private.phCurrentTable to hTable
92613>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
92616>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
92619>>>>>>>
92619>>>>>>>        Function_Return (Err = False)
92620>>>>>>>    End_Function
92621>>>>>>>
92621>>>>>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
92621>>>>>>>    // Note that it first removes any driver prefixes in the rootname.
92621>>>>>>>    Function ApiTableFilelistNamesCompare Boolean bCompareFilelistUppercase tAPITableNameInfo APITableInfo Returns Boolean
92623>>>>>>>        String sRootNameFrom sRootNameTo sDisplayNameTo sLogicalNameTo
92623>>>>>>>        Handle hTable
92623>>>>>>>        Boolean bIsSame
92623>>>>>>>
92623>>>>>>>        Move APITableInfo.iTableNumber      to hTable
92624>>>>>>>        Get _TableNameOnly APITableInfo.sRootName     to sRootNameFrom
92625>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo
92628>>>>>>>        Get _TableNoPrefix sRootNameTo                to sRootNameTo
92629>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo
92632>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayNameTo
92635>>>>>>>        Get _TableNoPrefix sDisplayNameTo             to sDisplayNameTo
92636>>>>>>>
92636>>>>>>>        If (bCompareFilelistUppercase = True) Begin
92638>>>>>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(APITableInfo.sLogicalName) = Uppercase(sLogicalNameTo) and ;                  Uppercase(APITableInfo.sDisplayName) = Uppercase(sDisplayNameTo)) to bIsSame
92639>>>>>>>        End
92639>>>>>>>>
92639>>>>>>>        Else Begin
92640>>>>>>>            Move (sRootNameFrom = sRootNameTo and APITableInfo.sLogicalName = sLogicalNameTo and APITableInfo.sDisplayName = sDisplayNameTo) to bIsSame
92641>>>>>>>        End
92641>>>>>>>>
92641>>>>>>>
92641>>>>>>>        Function_Return bIsSame
92642>>>>>>>    End_Function
92643>>>>>>>
92643>>>>>>>    // Note: This table update function does _not_ convert an embedded table to SQL. Use function ApiTableConvertToSQL first for that.
92643>>>>>>>    Function ApiTableUpdate tAPITableNameInfo APITableNameInfoFrom tAPIColumn[] aColumnsFrom tAPIIndex[] aIndexesFrom tAPIRelation[] aRelationsFrom Returns Boolean
92645>>>>>>>        Handle hTable
92645>>>>>>>        String sTableName
92645>>>>>>>        String sDriverIDFrom sDriverIDTo
92645>>>>>>>        Integer iDbType
92645>>>>>>>        Boolean bOk bMertechDriver bOpened bApiTableUpdateAuto
92645>>>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase bTableExists
92645>>>>>>>        Boolean bIsSame bFilelistError bIsAliasFrom bIsSQLTableFrom bIsSQLTableTo
92645>>>>>>>        tSQLConnection SQLConnection
92645>>>>>>>        tSQLConnection SQLConnection
92645>>>>>>>        tAPITable      APITableFrom APITableTo
92645>>>>>>>        tAPITable      APITableFrom APITableTo
92645>>>>>>>        tColumnType    ColumnType
92645>>>>>>>        tColumnType    ColumnType
92645>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
92645>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
92646>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
92646>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
92647>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
92647>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
92648>>>>>>>
92648>>>>>>>        // We don't allow changes to the framework's DbVersion table.
92648>>>>>>>        If (Lowercase(sTableName) = "dbversion") Begin
92650>>>>>>>            Function_Return False
92651>>>>>>>        End
92651>>>>>>>>
92651>>>>>>>
92651>>>>>>>        Move APITableNameInfoFrom.sDriverID     to sDriverIDFrom
92652>>>>>>>        Get piDbType                            to iDbType
92653>>>>>>>        Get pbRecnum                            to bRecnum
92654>>>>>>>        Get pbToANSI                            to bToANSI
92655>>>>>>>        Get pbCopyData                          to bCopyData
92656>>>>>>>        Get pbApiTableUpdateAuto                to bApiTableUpdateAuto
92657>>>>>>>        Get pbCompareDate_DateTime              to bCompareDate_DateTime
92658>>>>>>>        Get pbCompareIndexAscending             to bCompareIndexAscending
92659>>>>>>>        Get pbCompareIndexUppercase             to bCompareIndexUppercase
92660>>>>>>>        Get IsMertechDriver sDriverIDFrom       to bMertechDriver
92661>>>>>>>        Get pbUseConnectionID                   to bUseConnectionID
92662>>>>>>>        If (bMertechDriver = True and bUseConnectionID = True) Begin
92664>>>>>>>            Move False                          to bUseConnectionID
92665>>>>>>>        End
92665>>>>>>>>
92665>>>>>>>
92665>>>>>>>        Move APITableNameInfoFrom.iTableNumber  to hTable
92666>>>>>>>        Set Private.phCurrentTable              to hTable
92667>>>>>>>        Get UtilTableExists  hTable             to bTableExists
92668>>>>>>>
92668>>>>>>>        If (ghoProgressBar <> 0) Begin
92670>>>>>>>            Send DoAdvance of ghoProgressBar
92671>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * "Number:" * String(hTable) * String(APITableNameInfoFrom.sLogicalName))
92672>>>>>>>            Set Message_Text   of ghoStatusPanel to ""
92673>>>>>>>            Set Action_Text    of ghoStatusPanel to ""
92674>>>>>>>        End
92674>>>>>>>>
92674>>>>>>>
92674>>>>>>>        Move APITableNameInfoFrom.bIsAlias      to bIsAliasFrom
92675>>>>>>>        Move APITableNameInfoFrom.bIsSQL        to bIsSQLTableFrom
92676>>>>>>>        Get UtilTableIsSQL hTable               to bIsSQLTableTo
92677>>>>>>>        Get UtilDriverFromTableNumber hTable    to sDriverIDTo
92678>>>>>>>        Move True                               to APITableFrom.bFromTable
92679>>>>>>>        Move hTable                             to APITableFrom.hTable
92680>>>>>>>        Move APITableNameInfoFrom               to APITableFrom.ApiTableInfo
92681>>>>>>>        Move aColumnsFrom                       to APITableFrom.aApiColumns
92682>>>>>>>        Move aIndexesFrom                       to APITableFrom.aApiIndexes
92683>>>>>>>        Move aRelationsFrom                     to APITableFrom.aApiRelations
92684>>>>>>>
92684>>>>>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
92686>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverIDFrom to bOk
92687>>>>>>>            If (bOk = True) Begin
92689>>>>>>>                Get ApiTableAttachToSql hTable True to bOk
92690>>>>>>>                Function_Return bOk
92691>>>>>>>            End 
92691>>>>>>>>
92691>>>>>>>        End
92691>>>>>>>>
92691>>>>>>>
92691>>>>>>>        If (bTableExists = True) Begin
92693>>>>>>>            If (bIsSQLTableTo = True) Begin
92695>>>>>>>                Get UtilDeleteCacheFile APITableFrom.ApiTableInfo.sLogicalName to bOk
92696>>>>>>>            End
92696>>>>>>>>
92696>>>>>>>
92696>>>>>>>            Get OpenTableExclusive hTable to bOpened
92697>>>>>>>            If (bOpened = False) Begin
92699>>>>>>>                Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
92700>>>>>>>                Function_Return False
92701>>>>>>>            End
92701>>>>>>>>
92701>>>>>>>            Get UtilTableStructFill hTable False                                                        to APITableTo
92702>>>>>>>            Get UtilColumnCombineFromAndToArrays   APITableFrom.aApiColumns   APITableTo.aApiColumns    to aAPIColumnCompare
92703>>>>>>>            Get UtilIndexCombineFromAndToArrays    APITableFrom.aApiIndexes   APITableTo.aApiIndexes    to aAPIIndexCompare
92704>>>>>>>            Get UtilRelationCombineFromAndToArrays APITableFrom.aApiRelations APITableTo.aApiRelations  to aAPIRelationCompare
92705>>>>>>>        End
92705>>>>>>>>
92705>>>>>>>
92705>>>>>>>        Move False to Err
92706>>>>>>>        Case Begin
92706>>>>>>>            // Alias table:
92706>>>>>>>            Case (bIsAliasFrom = True)
92708>>>>>>>                Get _UtilTableCheckChangeFilelistNames APITableNameInfoFrom to bOk
92709>>>>>>>                Case Break
92710>>>>>>>
92710>>>>>>>            // New Table:
92710>>>>>>>            Case (bTableExists = False)
92713>>>>>>>                Get ApiTableCreate      hTable APITableNameInfoFrom.sRootName APITableNameInfoFrom.sDisplayName APITableNameInfoFrom.sLogicalName bUseConnectionID bToANSI bRecnum aColumnsFrom to bOk
92714>>>>>>>                //LR 20191112 Begin: Make file a system file if bIsSystemFile = True
92714>>>>>>>                If (APITableNameInfoFrom.bIsSystemFile) Begin
92716>>>>>>>                    Get ApiTableChangeAttribute of ghoDbUpdateFunctionLibrary hTable DF_FILE_IS_SYSTEM_FILE True to bOK
92717>>>>>>>                End                                                                 
92717>>>>>>>>
92717>>>>>>>                Get UtilIndexesUpdate   hTable bIsSQLTableFrom bIsSQLTableTo APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
92718>>>>>>>                Get UtilRelationsUpdate hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
92719>>>>>>>                Case Break
92720>>>>>>>
92720>>>>>>>            // Update table:
92720>>>>>>>            Case (bTableExists = True)
92723>>>>>>>                Get UtilTableCompare APITableFrom APITableTo False (&bFilelistError) to bIsSame
92724>>>>>>>                If (bIsSame = True) Begin
92726>>>>>>>                    Case Break
92727>>>>>>>                End
92727>>>>>>>>
92727>>>>>>>                If (bFilelistError = True) Begin
92729>>>>>>>                    Get ApiTableRename hTable APITableNameInfoFrom.sRootName APITableNameInfoFrom.sDisplayName APITableNameInfoFrom.sLogicalName to bOk
92730>>>>>>>                    If (bOk = False) Begin
92732>>>>>>>                        Case Break
92733>>>>>>>                    End
92733>>>>>>>>
92733>>>>>>>                End
92733>>>>>>>>
92733>>>>>>>
92733>>>>>>>                If (ghoProgressBar <> 0) Begin
92735>>>>>>>                    Send DoAdvance of ghoProgressBar
92736>>>>>>>                    Set TableName_Text of ghoStatusPanel to ("Updating Table:" * "Number:" * String(hTable) * String(APITableNameInfoFrom.sLogicalName))
92737>>>>>>>                End
92737>>>>>>>>
92737>>>>>>>
92737>>>>>>>                // Columns:
92737>>>>>>>                Move True to bOk
92738>>>>>>>                Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom bIsSQLTableTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
92739>>>>>>>                If (bIsSame = False) Begin
92741>>>>>>>                    Get ApiColumnsUpdate sDriverIDFrom hTable bIsSQLTableFrom APITableFrom.aApiColumns APITableTo.aApiColumns bCompareDate_DateTime to bOk
92742>>>>>>>                End
92742>>>>>>>>
92742>>>>>>>                If (bOk = False) Begin
92744>>>>>>>                    Case Break
92745>>>>>>>                End
92745>>>>>>>>
92745>>>>>>>
92745>>>>>>>                // Indexes:
92745>>>>>>>                Get UtilIndexesCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare bCompareIndexUppercase bCompareIndexAscending to bIsSame
92746>>>>>>>                If (bIsSame = False) Begin
92748>>>>>>>                    Get UtilIndexesUpdate hTable bIsSQLTableFrom bIsSQLTableTo APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
92749>>>>>>>                End
92749>>>>>>>>
92749>>>>>>>
92749>>>>>>>                // Relations:
92749>>>>>>>                Get UtilRelationsCompare hTable aAPIRelationCompare to bIsSame
92750>>>>>>>                If (bIsSame = False) Begin
92752>>>>>>>                    Get UtilRelationsUpdate hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
92753>>>>>>>                    If (bOk = False) Begin
92755>>>>>>>                        Case Break
92756>>>>>>>                    End
92756>>>>>>>>
92756>>>>>>>                End
92756>>>>>>>>
92756>>>>>>>
92756>>>>>>>                Case Break
92757>>>>>>>
92757>>>>>>>            Case Else
92757>>>>>>>                Error DFERR_PROGRAM "Unknown Case structure exit in Function ApiTableUpdate"
92758>>>>>>>>
92758>>>>>>>                Move False to bOk
92759>>>>>>>        Case End
92759>>>>>>>        
92759>>>>>>>        // Note: If the from table was SQL; we should either connect to an existing SQL to table,
92759>>>>>>>        // or convert an embedded table to SQL
92759>>>>>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
92761>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverIDFrom to bOk
92762>>>>>>>            If (bOk = False) Begin
92764>>>>>>>                Get ApiTableConvertToSql_Ex hTable sDriverIDFrom bUseConnectionID bToANSI bRecnum bCopyData to bOK
92765>>>>>>>            End
92765>>>>>>>>
92765>>>>>>>        End
92765>>>>>>>>
92765>>>>>>>        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
92768>>>>>>>            Get SqlTableConvertToEmbedded hTable True to bOk
92769>>>>>>>        End
92769>>>>>>>>
92769>>>>>>>        
92769>>>>>>>        // Filelist Names:
92769>>>>>>>        Get _UtilTableCheckChangeFilelistNames APITableNameInfoFrom to bOk
92770>>>>>>>        Close hTable
92771>>>>>>>        Set TableName_Text of ghoStatusPanel to ""
92772>>>>>>>
92772>>>>>>>        Function_Return (bOK = True)
92773>>>>>>>    End_Function
92774>>>>>>>
92774>>>>>>>    // * Dummy function for the Studio's Code Explorer *
92774>>>>>>>    Function API_COLUMN_FUNCTIONS Returns Boolean
92776>>>>>>>        Function_Return False
92777>>>>>>>    End_Function
92778>>>>>>>
92778>>>>>>>    // Adds a column name to the passed table number.
92778>>>>>>>    Function ApiColumnAdd Handle hTable String sFieldName Integer iType Integer iLength Integer iPrec Boolean bInitVal String sColVal Returns Boolean
92780>>>>>>>        Integer iColumn iCount iFile iPrecision iLastErr
92780>>>>>>>        Boolean bExists bOK bInitializeValue bRetval bMertechDriver
92780>>>>>>>        String sDataPath sDdSrcPath sTableName sColumnValue sDriverID
92780>>>>>>>
92780>>>>>>>        Get UtilColumnExists hTable sFieldName to bExists
92781>>>>>>>        If (bExists = True) Begin
92783>>>>>>>            Function_Return False
92784>>>>>>>        End
92784>>>>>>>>
92784>>>>>>>
92784>>>>>>>        Move False to Err
92785>>>>>>>        If (num_arguments > 4) Begin
92787>>>>>>>            Move iPrec to iPrecision
92788>>>>>>>        End
92788>>>>>>>>
92788>>>>>>>        If (num_arguments > 6) Begin
92790>>>>>>>            Move bInitVal to bInitializeValue
92791>>>>>>>            Move sColVal  to sColumnValue
92792>>>>>>>        End
92792>>>>>>>>
92792>>>>>>>        If (iType < -1490) Begin
92794>>>>>>>            Move (iType + 1500) to iType
92795>>>>>>>        End
92795>>>>>>>>
92795>>>>>>>
92795>>>>>>>        Move hTable to iFile
92796>>>>>>>        Get psDriverID to sDriverID
92797>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
92798>>>>>>>        Get AutoConnectionIDLogin to bOK
92799>>>>>>>        Move False to Err
92800>>>>>>>        Move LastErr to iLastErr
92801>>>>>>>        Get OpenTableExclusive iFile to bOK
92802>>>>>>>//        Open iFile Mode DF_EXCLUSIVE
92802>>>>>>>        Set Private.phCurrentTable to hTable
92803>>>>>>>            MERTECH_WARNING_MESSAGE Disabled
92836>>>>>>>>
92836>>>>>>>        Structure_Start iFile sDriverID
92837>>>>>>>            Move 0 to iColumn
92838>>>>>>>            Set Private.piCurrentField to iColumn
92839>>>>>>>            Create_Field hTable At iColumn
92840>>>>>>>            Set_Attribute DF_FIELD_NAME      of iFile iColumn to sFieldName
92843>>>>>>>            If (bMertechDriver = True) Begin
92845>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
92846>>>>>>>                Send Ignore_Error of Error_Object_Id DFERR_BAD_ATTRIBUTE_VALUE
92847>>>>>>>            End
92847>>>>>>>>
92847>>>>>>>            Set_Attribute DF_FIELD_TYPE      of iFile iColumn to iType
92850>>>>>>>            If (bMertechDriver = True) Begin
92852>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
92853>>>>>>>                Send Trap_Error of Error_Object_Id DFERR_BAD_ATTRIBUTE_VALUE
92854>>>>>>>                Move False to Err
92855>>>>>>>                Move iLastErr to LastErr
92856>>>>>>>            End
92856>>>>>>>>
92856>>>>>>>            Set_Attribute DF_FIELD_LENGTH    of iFile iColumn to (iLength + iPrecision)
92859>>>>>>>            Set_Attribute DF_FIELD_PRECISION of iFile iColumn to iPrecision
92862>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
92863>>>>>>>        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
92865>>>>>>>            MERTECH_WARNING_MESSAGE Enabled
92898>>>>>>>>
92898>>>>>>>
92898>>>>>>>        Set Action_Text of ghoStatusPanel to ""
92899>>>>>>>
92899>>>>>>>        // If in development environment; create .fd file:
92899>>>>>>>        Open hTable
92901>>>>>>>        Get psDdSrcPath  of (phoWorkspace(ghoApplication)) to sDDSrcPath
92902>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
92903>>>>>>>        If (iCount > 1) Begin
92905>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
92906>>>>>>>        End
92906>>>>>>>>
92906>>>>>>>        Get vFolderExists sDDSrcPath to bExists
92907>>>>>>>        If (bExists = True) Begin
92909>>>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
92910>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
92913>>>>>>>            Get _TableNameOnly sTableName to sTableName
92914>>>>>>>            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
92916>>>>>>>        End
92916>>>>>>>>
92916>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin  // We only want a tag if DataFlex embedded db
92918>>>>>>>            Get psDataPath  of (phoWorkspace(ghoApplication)) to sDataPath
92919>>>>>>>            Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
92920>>>>>>>            If (iCount > 1) Begin
92922>>>>>>>                Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
92923>>>>>>>            End
92923>>>>>>>>
92923>>>>>>>            Get vFolderFormat sDataPath to sDataPath
92924>>>>>>>            // Add the new column name to the .tag filen (if it doesn't exist):
92924>>>>>>>            // The following line should not be necexxary for the DataFlex driver. (Thank you, Hans van de Laar)
92924>>>>>>>            //Get UtilUpdateTAGFile (sDataPath + sTableName + ".tag") sFieldName to bOK
92924>>>>>>>        End
92924>>>>>>>>
92924>>>>>>>        // Check for a default value
92924>>>>>>>        If (bInitializeValue = True and sColumnValue <> "" and Err = False) Begin
92926>>>>>>>            Get ApiColumnUpdateValue hTable sFieldName sColumnValue to bRetval
92927>>>>>>>        End
92927>>>>>>>>
92927>>>>>>>        Close hTable
92928>>>>>>>
92928>>>>>>>        Function_Return (Err = False)
92929>>>>>>>    End_Function
92930>>>>>>>
92930>>>>>>>    // Adds a column name to the passed table number.
92930>>>>>>>    Function ApiColumnInsert String sDriverIDFrom Handle hTable Integer iColumn String sFieldName Integer iType Integer iLength Integer iPrec Boolean bIsSQLType Returns Boolean
92932>>>>>>>        Integer iCount iFile iPrecision iNumberOfFields iDbType
92932>>>>>>>        Boolean bExists bOK bIsDateType bIsSQLTypeTo
92932>>>>>>>        String sDdSrcPath sTableName
92932>>>>>>>
92932>>>>>>>        Get UtilColumnExists hTable sFieldName to bExists
92933>>>>>>>        Move False to Err
92934>>>>>>>        If (bExists = True) Begin
92936>>>>>>>            Function_Return False
92937>>>>>>>        End
92937>>>>>>>>
92937>>>>>>>        If (num_arguments > 4) Begin
92939>>>>>>>            Move iPrec to iPrecision
92940>>>>>>>        End
92940>>>>>>>>
92940>>>>>>>        If (iType < -1490) Begin
92942>>>>>>>            Move (iType + 1500) to iType
92943>>>>>>>        End
92943>>>>>>>>
92943>>>>>>>
92943>>>>>>>        Get AutoConnectionIDLogin to bOK
92944>>>>>>>        Move False to Err
92945>>>>>>>        Get UtilTableIsSql hTable to bIsSQLTypeTo
92946>>>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
92946>>>>>>>        // data types between Embedded and SQL, else we can't compare the data types. 
92946>>>>>>>        Get piDbType to iDbType
92947>>>>>>>        If (bIsSQLTypeTo = False) Begin
92949>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iType iLength to iType
92950>>>>>>>            If (iType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
92952>>>>>>>                Move DF_DATE to iType
92953>>>>>>>            End
92953>>>>>>>>
92953>>>>>>>        End
92953>>>>>>>>
92953>>>>>>>
92953>>>>>>>        // Structure_start will change the value of hTable...
92953>>>>>>>        Move hTable to iFile
92954>>>>>>>        Get OpenTableExclusive iFile to bOK
92955>>>>>>>        If (bOK = False) Begin
92957>>>>>>>            Function_Return False
92958>>>>>>>        End
92958>>>>>>>>
92958>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iNumberOfFields
92961>>>>>>>
92961>>>>>>>        // If the passed column number is higher than the current number of fields
92961>>>>>>>        // in the table, this means we should _not_ insert a field but rather add
92961>>>>>>>        // a new field to the end:
92961>>>>>>>        If (iColumn > iNumberOfFields) Begin
92963>>>>>>>            Move 0 to iColumn
92964>>>>>>>        End
92964>>>>>>>>
92964>>>>>>>
92964>>>>>>>        Set Private.phCurrentTable to hTable
92965>>>>>>>        Set Private.piCurrentField to iColumn
92966>>>>>>>
92966>>>>>>>        Structure_Start iFile
92967>>>>>>>            Create_Field iFile At iColumn
92968>>>>>>>            Set_Attribute DF_FIELD_NAME            of iFile iColumn to sFieldName
92971>>>>>>>            If (bIsSQLTypeTo = False) Begin
92973>>>>>>>                Set_Attribute DF_FIELD_TYPE        of iFile iColumn to iType
92976>>>>>>>            End
92976>>>>>>>>
92976>>>>>>>            Else Begin
92977>>>>>>>                Set_Attribute DF_FIELD_NATIVE_TYPE of iFile iColumn to iType
92980>>>>>>>            End
92980>>>>>>>>
92980>>>>>>>            Get UtilColumnIsDateType iType bIsSQLTypeTo to bIsDateType
92981>>>>>>>            If (bIsDateType = False) Begin
92983>>>>>>>                Set_Attribute DF_FIELD_LENGTH       of iFile iColumn to (iLength + iPrecision)
92986>>>>>>>                Set_Attribute DF_FIELD_PRECISION    of iFile iColumn to iPrecision
92989>>>>>>>            End
92989>>>>>>>>
92989>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
92990>>>>>>>        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
92992>>>>>>>
92992>>>>>>>        Set Action_Text of ghoStatusPanel to ""
92993>>>>>>>        // If in development environment; create .fd file:
92993>>>>>>>        Open hTable
92995>>>>>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
92996>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
92997>>>>>>>        If (iCount > 1) Begin
92999>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
93000>>>>>>>        End
93000>>>>>>>>
93000>>>>>>>        Get vFolderExists sDDSrcPath to bExists
93001>>>>>>>        If (bExists = True) Begin
93003>>>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
93004>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
93007>>>>>>>            Get _TableNameOnly sTableName to sTableName
93008>>>>>>>            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
93010>>>>>>>        End
93010>>>>>>>>
93010>>>>>>>
93010>>>>>>>        // Check for a default value
93010>>>>>>>        Close hTable
93011>>>>>>>
93011>>>>>>>        Function_Return (Err = False)
93012>>>>>>>    End_Function
93013>>>>>>>
93013>>>>>>>//    Function ApiColumnAddMultiple Handle hTable tAPIColumn[] aColumns Returns Boolean
93013>>>>>>>//        Integer iColumn iCount iFile
93013>>>>>>>//        Boolean bExists bOK
93013>>>>>>>//        String sDdSrcPath sTableName
93013>>>>>>>//
93013>>>>>>>//        Get AutoConnectionIDLogin to bOK
93013>>>>>>>//        Move False to Err
93013>>>>>>>//
93013>>>>>>>//        // Structure_start will change the value of hTable...
93013>>>>>>>//        Move hTable to iFile
93013>>>>>>>//        Open iFile Mode DF_EXCLUSIVE
93013>>>>>>>//
93013>>>>>>>//        Structure_Start iFile
93013>>>>>>>//            Send ApiColumnsAddToTable iFile aColumns False
93013>>>>>>>//        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
93013>>>>>>>//
93013>>>>>>>//        // If in development environment; create .fd file:
93013>>>>>>>//        Open hTable
93013>>>>>>>//        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
93013>>>>>>>//        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
93013>>>>>>>//        If (iCount > 1) Begin
93013>>>>>>>//            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
93013>>>>>>>//        End
93013>>>>>>>//        Get vFolderExists sDDSrcPath to bExists
93013>>>>>>>//        If (bExists = True) Begin
93013>>>>>>>//            Get vFolderFormat sDDSrcPath to sDDSrcPath
93013>>>>>>>//            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
93013>>>>>>>//            Get _TableNameOnly sTableName to sTableName
93013>>>>>>>//            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
93013>>>>>>>//        End
93013>>>>>>>//        Close hTable
93013>>>>>>>//
93013>>>>>>>//        Function_Return (Err = False)
93013>>>>>>>//    End_Function
93013>>>>>>>
93013>>>>>>>    // To update all records for a table column with a fixed value.
93013>>>>>>>    Function ApiColumnUpdateValue Handle hTable String sFieldName String sColumnValue Returns Boolean
93015>>>>>>>        Integer iRecs iCurrErr iField iRecord
93015>>>>>>>        Boolean bRetval bOpen
93015>>>>>>>
93015>>>>>>>        Move 0 to iRecs
93016>>>>>>>        Move False to bRetval
93017>>>>>>>        Move Err to iCurrErr
93018>>>>>>>        Move False to Err
93019>>>>>>>
93019>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
93022>>>>>>>        If (bOpen = False) Begin
93024>>>>>>>            Open hTable
93026>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
93029>>>>>>>            If (bOpen = False) Begin
93031>>>>>>>                Function_Return bRetval
93032>>>>>>>            End
93032>>>>>>>>
93032>>>>>>>        End
93032>>>>>>>>
93032>>>>>>>
93032>>>>>>>        Field_Map hTable sFieldName to iField
93034>>>>>>>        If (iField <> 0) Begin
93036>>>>>>>            Set Private.phCurrentTable to hTable
93037>>>>>>>            Set Private.piCurrentField to iField
93038>>>>>>>            Clear hTable
93039>>>>>>>            Repeat
93039>>>>>>>>
93039>>>>>>>                Vfind hTable 0 GT
93041>>>>>>>                If (Found) Begin
93043>>>>>>>                    If (ghoStatusPanel <> 0) Begin
93045>>>>>>>                        Get_Field_Value hTable 0 to iRecord
93048>>>>>>>                        Send Update_StatusPanel of ghoStatusPanel (CS_DUF_UpdateVersion * String(iRecord))
93049>>>>>>>                    End
93049>>>>>>>>
93049>>>>>>>                    Reread hTable
93053>>>>>>>                        Set_Field_Value hTable iField to sColumnValue
93056>>>>>>>                        SaveRecord hTable
93057>>>>>>>                    Unlock
93058>>>>>>>>
93058>>>>>>>                End
93058>>>>>>>>
93058>>>>>>>           Until (not(Found))
93060>>>>>>>        End
93060>>>>>>>>
93060>>>>>>>
93060>>>>>>>        Move (Err = False) to bRetval
93061>>>>>>>        Move iCurrErr to Err
93062>>>>>>>
93062>>>>>>>        Function_Return bRetval
93063>>>>>>>    End_Function
93064>>>>>>>
93064>>>>>>>    // Note: This can only be used from within a Structure_Start/End construct.
93064>>>>>>>    Function ApiColumnsAddToTable Handle hTable tAPIColumn[] aColumns Boolean bCreating Returns Boolean
93066>>>>>>>        Integer iCount iSize iColumn iType iDataFlexType iIndex iDbType
93066>>>>>>>        Boolean bFieldExists bNativeType bIsSQLDriver bIsDAWSqlDriver bIsSqlTable bRecnumTable bIsOpen bIsDateType
93066>>>>>>>        String sFieldName sDriverID sTableName sDefaultValue
93066>>>>>>>
93066>>>>>>>//        Set Private.phCurrentTable to hTable
93066>>>>>>>        Get psDriverID to sDriverID
93067>>>>>>>        Get piDbType to iDbType
93068>>>>>>>        Get UtilTableHandleToString hTable to sTableName
93069>>>>>>>        Get IsSQLDriver    sDriverID to bIsSQLDriver
93070>>>>>>>        Get IsDAWSQLDriver sDriverID to bIsDAWSqlDriver
93071>>>>>>>        Get UtilTableIsSQL hTable to bIsSqlTable
93072>>>>>>>        If (bIsSqlTable = False and bCreating = True and bIsSQLDriver = True) Begin
93074>>>>>>>            Move True to bIsSqlTable
93075>>>>>>>        End
93075>>>>>>>>
93075>>>>>>>        Move False to bIsOpen
93076>>>>>>>        If (hTable > 0) Begin
93078>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
93081>>>>>>>        End
93081>>>>>>>>
93081>>>>>>>        If (bIsOpen = True) Begin
93083>>>>>>>            Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
93086>>>>>>>        End
93086>>>>>>>>
93086>>>>>>>        Else Begin
93087>>>>>>>            Get pbRecnum to bRecnumTable
93088>>>>>>>        End
93088>>>>>>>>
93088>>>>>>>
93088>>>>>>>        Move False to Err
93089>>>>>>>        Move (SizeOfArray(aColumns)) to iSize
93090>>>>>>>        Decrement iSize
93091>>>>>>>        for iCount from 0 to iSize
93097>>>>>>>>
93097>>>>>>>            Move aColumns[iCount].sFieldName to sFieldName
93098>>>>>>>            If (hTable > 0) Begin
93100>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
93101>>>>>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
93102>>>>>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn to sFieldName
93105>>>>>>>                Move (Trim(sFieldName) <> "") to bFieldExists
93106>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
93107>>>>>>>                Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
93108>>>>>>>            End
93108>>>>>>>>
93108>>>>>>>            Else Begin
93109>>>>>>>                Move False to bFieldExists
93110>>>>>>>            End
93110>>>>>>>>
93110>>>>>>>
93110>>>>>>>            If (bFieldExists = False) Begin
93112>>>>>>>                Move 0 to iColumn
93113>>>>>>>                Create_Field hTable At iColumn
93114>>>>>>>            End
93114>>>>>>>>
93114>>>>>>>            Else Begin
93115>>>>>>>                Move iCount to iColumn
93116>>>>>>>            End
93116>>>>>>>>
93116>>>>>>>
93116>>>>>>>            Set Private.piCurrentField to iColumn
93117>>>>>>>
93117>>>>>>>            Move                                        iColumn to aColumns[iCount].iFieldNumber
93118>>>>>>>            Set_Attribute DF_FIELD_NAME       of hTable iColumn to aColumns[iCount].sFieldName
93121>>>>>>>
93121>>>>>>>            Move aColumns[iCount].iType to iType
93122>>>>>>>            Move (not(iType < -1490)) to bNativeType
93123>>>>>>>            If (iType < -1490) Begin
93125>>>>>>>                Move (iType + 1500) to iType
93126>>>>>>>            End
93126>>>>>>>>
93126>>>>>>>
93126>>>>>>>            If (bIsSqlTable = True) Begin
93128>>>>>>>                If (aColumns[iCount].bIsSQLType = True) Begin
93130>>>>>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iDataFlexType
93131>>>>>>>                    Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iDataFlexType
93134>>>>>>>                    Set_Attribute DF_FIELD_NATIVE_TYPE   of hTable iColumn to iType
93137>>>>>>>                    Set_Attribute DF_FIELD_NULL_ALLOWED  of hTable iColumn to aColumns[iCount].bAllowNULL
93140>>>>>>>
93140>>>>>>>                    Move aColumns[iCount].sDefaultValue                    to sDefaultValue
93141>>>>>>>                    If (iDataFlexType = DF_BCD and Left(String(sDefaultValue), 1) <> "[") Begin
93143>>>>>>>                        Move ("[" + String(sDefaultValue) + "]") to sDefaultValue
93144>>>>>>>                    End
93144>>>>>>>>
93144>>>>>>>                    Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sDefaultValue
93147>>>>>>>
93147>>>>>>>                End
93147>>>>>>>>
93147>>>>>>>                Else Begin
93148>>>>>>>                    Set_Attribute DF_FIELD_TYPE        of hTable iColumn to iType
93151>>>>>>>                End
93151>>>>>>>>
93151>>>>>>>            End
93151>>>>>>>>
93151>>>>>>>            Else Begin
93152>>>>>>>                If (bCreating = False) Begin
93154>>>>>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iType
93155>>>>>>>                    If (iType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
93157>>>>>>>                        Move DF_DATE to iType
93158>>>>>>>                    End
93158>>>>>>>>
93158>>>>>>>                End
93158>>>>>>>>
93158>>>>>>>                Set_Attribute DF_FIELD_TYPE of hTable iColumn to iType
93161>>>>>>>            End
93161>>>>>>>>
93161>>>>>>>
93161>>>>>>>            Get UtilColumnIsDateType iType bIsSqlTable to bIsDateType
93162>>>>>>>            If (bIsDateType = False) Begin
93164>>>>>>>                Set_Attribute DF_FIELD_LENGTH     of hTable iColumn to aColumns[iCount].iLength
93167>>>>>>>                Set_Attribute DF_FIELD_PRECISION  of hTable iColumn to aColumns[iCount].iPrecision
93170>>>>>>>            End
93170>>>>>>>>
93170>>>>>>>
93170>>>>>>>            If (aColumns[iCount].iOptions iand C_tAPIColumn_Identity) Begin
93172>>>>>>>                Move 0 to iIndex
93173>>>>>>>                Create_Index hTable at iIndex
93174>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to 1
93177>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD   of hTable iIndex 1 to iColumn
93180>>>>>>>                Set_Attribute DF_FILE_PRIMARY_INDEX    of hTable iIndex to 1
93183>>>>>>>
93183>>>>>>>                // If we have an identity table - we must create a primary_key table.
93183>>>>>>>                If (bIsSqlTable = True) Begin
93185>>>>>>>                End
93185>>>>>>>>
93185>>>>>>>            End
93185>>>>>>>>
93185>>>>>>>        Loop
93186>>>>>>>>
93186>>>>>>>
93186>>>>>>>        Function_Return (Err = False)
93187>>>>>>>    End_Function
93188>>>>>>>
93188>>>>>>>    // Changes a field type, length and precision for the passed table number and field name
93188>>>>>>>    Function ApiColumnChange Handle hTable String sFieldNameFrom Integer iTypeFrom Integer iLengthFrom Integer iPrec Returns Boolean
93190>>>>>>>        Integer iColumn iPrecFrom iTypeTo iLengthTo iPrecTo
93190>>>>>>>        Boolean bOK bIsSqlTable
93190>>>>>>>        String sFieldNameTo
93190>>>>>>>
93190>>>>>>>        If (num_arguments > 4) Begin
93192>>>>>>>            Move iPrec to iPrecFrom
93193>>>>>>>        End
93193>>>>>>>>
93193>>>>>>>        If (iTypeFrom < -1490) Begin
93195>>>>>>>            Move (iTypeFrom + 1500) to iTypeFrom
93196>>>>>>>        End
93196>>>>>>>>
93196>>>>>>>
93196>>>>>>>        Get AutoConnectionIDLogin to bOK
93197>>>>>>>        Move False to Err
93198>>>>>>>        Get OpenTableExclusive hTable to bOK
93199>>>>>>>        If (bOK = False) Begin
93201>>>>>>>            Function_Return False
93202>>>>>>>        End
93202>>>>>>>>
93202>>>>>>>
93202>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
93203>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
93204>>>>>>>        Field_Map hTable sFieldNameFrom to iColumn
93206>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
93207>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
93208>>>>>>>        If (Err = True) Begin
93210>>>>>>>            Function_Return False
93211>>>>>>>        End
93211>>>>>>>>
93211>>>>>>>
93211>>>>>>>        Get_Attribute DF_FIELD_NAME                  of hTable iColumn to sFieldNameTo
93214>>>>>>>        Get UtilTableIsSQL hTable to bIsSqlTable
93215>>>>>>>        If (bIsSqlTable = False) Begin
93217>>>>>>>            Get_Attribute DF_FIELD_TYPE              of hTable iColumn to iTypeTo
93220>>>>>>>        End
93220>>>>>>>>
93220>>>>>>>        Else Begin
93221>>>>>>>            Get_Attribute DF_FIELD_NATIVE_TYPE       of hTable iColumn to iTypeTo
93224>>>>>>>        End
93224>>>>>>>>
93224>>>>>>>        // Let the driver decide the other values;
93224>>>>>>>        Get_Attribute DF_FIELD_LENGTH                of hTable iColumn to iLengthTo
93227>>>>>>>        Get_Attribute DF_FIELD_PRECISION             of hTable iColumn to iPrecTo
93230>>>>>>>
93230>>>>>>>        If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo) Begin
93232>>>>>>>            Function_Return False
93233>>>>>>>        End
93233>>>>>>>>
93233>>>>>>>
93233>>>>>>>        Set Private.phCurrentTable to hTable
93234>>>>>>>        Set Private.piCurrentField to iColumn
93235>>>>>>>
93235>>>>>>>        Structure_Start hTable
93236>>>>>>>            Set_Attribute DF_FIELD_NAME              of hTable iColumn to sFieldNameFrom
93239>>>>>>>//            If (bIsSqlTable = False) Begin
93239>>>>>>>                Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iTypeFrom
93242>>>>>>>//            End
93242>>>>>>>//            Else Begin
93242>>>>>>>//                Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iTypeFrom
93242>>>>>>>//                Set_Attribute DF_FIELD_NATIVE_TYPE   of hTable iColumn to iTypeFrom
93242>>>>>>>//            End
93242>>>>>>>            Set_Attribute DF_FIELD_LENGTH            of hTable iColumn to (iLengthFrom + iPrecFrom)
93245>>>>>>>            Set_Attribute DF_FIELD_PRECISION         of hTable iColumn to iPrecFrom
93248>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
93249>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
93251>>>>>>>
93251>>>>>>>        Set Action_Text of ghoStatusPanel to ""
93252>>>>>>>        Function_Return (Err = False)
93253>>>>>>>    End_Function
93254>>>>>>>
93254>>>>>>>    // Changes a field type, length and precision for the passed table number and field name
93254>>>>>>>    Function ApiColumnChangeByColumnNumber String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo String sFieldNameFrom Integer iColumn Integer iTypeFrom Integer iLengthFrom Integer iPrec Integer iOpt Returns Boolean
93256>>>>>>>        Integer iPrecFrom iTypeTo iLengthTo iPrecTo iDbType iOptionFrom iOptionTo iDataFlexType iIndex
93256>>>>>>>        Boolean bOK bCompareDate_DateTime bSkip bRecnumTable bIsSameDataType
93256>>>>>>>        String sFieldNameTo sDriverIDTo
93256>>>>>>>        tColumnType ColumnType
93256>>>>>>>        tColumnType ColumnType
93256>>>>>>>
93256>>>>>>>        Get pbCompareDate_DateTime to bCompareDate_DateTime
93257>>>>>>>        Get piDbType to iDbType
93258>>>>>>>        If (num_arguments > 4) Begin
93260>>>>>>>            Move iPrec to iPrecFrom
93261>>>>>>>            Move iOpt  to iOptionFrom
93262>>>>>>>        End
93262>>>>>>>>
93262>>>>>>>        If (iTypeFrom < -1490) Begin
93264>>>>>>>            Move (iTypeFrom + 1500) to iTypeFrom
93265>>>>>>>        End
93265>>>>>>>>
93265>>>>>>>
93265>>>>>>>        Get AutoConnectionIDLogin to bOK
93266>>>>>>>        Move False to Err
93267>>>>>>>        Close hTable
93268>>>>>>>        Get OpenTableExclusive hTable to bOK
93269>>>>>>>        If (bOK = False) Begin
93271>>>>>>>            Function_Return False
93272>>>>>>>        End
93272>>>>>>>>
93272>>>>>>>
93272>>>>>>>        Get_Attribute DF_FILE_DRIVER                of hTable         to sDriverIDTo
93275>>>>>>>        Get_Attribute DF_FILE_RECNUM_TABLE          of hTable         to bRecnumTable
93278>>>>>>>        Get UtilSQLColumnTypeToDataFlexType sDriverIDTo iDbType iTypeTo iLengthTo to iDataFlexType
93279>>>>>>>        If (iDataFlexType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
93281>>>>>>>            Move DF_DATE to iDataFlexType
93282>>>>>>>        End
93282>>>>>>>>
93282>>>>>>>        Get_Attribute DF_FIELD_NAME                 of hTable iColumn to sFieldNameTo
93285>>>>>>>
93285>>>>>>>        If (bIsSQLTableTo = True) Begin
93287>>>>>>>            Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iTypeTo
93290>>>>>>>        End
93290>>>>>>>>
93290>>>>>>>        Else Begin
93291>>>>>>>            Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iTypeTo
93294>>>>>>>        End
93294>>>>>>>>
93294>>>>>>>
93294>>>>>>>        Get_Attribute DF_FIELD_LENGTH               of hTable iColumn to iLengthTo
93297>>>>>>>        Get_Attribute DF_FIELD_PRECISION            of hTable iColumn to iPrecTo
93300>>>>>>>            Get_Attribute DF_FIELD_IS_IDENTITY      of hTable iColumn to iOptionTo
93303>>>>>>>
93303>>>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
93303>>>>>>>        // data types between Embedded and SQL, else we can't compare the data types.
93303>>>>>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
93305>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iTypeTo
93306>>>>>>>            If (iTypeTo = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
93308>>>>>>>                Move DF_DATE to iTypeTo  
93309>>>>>>>            End
93309>>>>>>>>
93309>>>>>>>        End
93309>>>>>>>>
93309>>>>>>>        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
93312>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDTo   iDbType iTypeTo   iLengthTo   to iTypeFrom
93313>>>>>>>        End
93313>>>>>>>>
93313>>>>>>>        Move (iTypeFrom = iTypeTo) to bIsSameDataType
93314>>>>>>>
93314>>>>>>>        If (bCompareDate_DateTime = False) Begin
93316>>>>>>>            Move ((iTypeFrom = SQL_TYPE_DATE or iTypeFrom = SQL_TYPE_TIME or iTypeFrom = SQL_TYPE_TIMESTAMP) and (iTypeTo = SQL_TYPE_DATE or iTypeTo = SQL_TYPE_TIME or iTypeTo = SQL_TYPE_TIMESTAMP)) to bSkip
93317>>>>>>>            If (bSkip = True) Begin
93319>>>>>>>                If (sFieldNameFrom = sFieldNameTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
93321>>>>>>>                    Function_Return True
93322>>>>>>>                End
93322>>>>>>>>
93322>>>>>>>            End
93322>>>>>>>>
93322>>>>>>>        End
93322>>>>>>>>
93322>>>>>>>        Else If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
93325>>>>>>>            Function_Return True
93326>>>>>>>        End
93326>>>>>>>>
93326>>>>>>>
93326>>>>>>>        Set Private.phCurrentTable to hTable
93327>>>>>>>        Set Private.piCurrentField to iColumn
93328>>>>>>>
93328>>>>>>>        Structure_Start hTable
93329>>>>>>>            If (sFieldNameFrom <> sFieldNameTo) Begin
93331>>>>>>>                Set_Attribute DF_FIELD_NAME             of hTable iColumn to sFieldNameFrom
93334>>>>>>>            End
93334>>>>>>>>
93334>>>>>>>
93334>>>>>>>            If (bIsSameDataType = False) Begin
93336>>>>>>>                Set_Attribute DF_FIELD_TYPE             of hTable iColumn to iDataFlexType
93339>>>>>>>                If (bIsSQLTableTo = True) Begin
93341>>>>>>>                    Set_Attribute DF_FIELD_NATIVE_TYPE  of hTable iColumn to iTypeFrom
93344>>>>>>>                End
93344>>>>>>>>
93344>>>>>>>            End
93344>>>>>>>>
93344>>>>>>>
93344>>>>>>>            If (iLengthFrom <> iLengthTo) Begin
93346>>>>>>>                Set_Attribute DF_FIELD_LENGTH           of hTable iColumn to iLengthFrom
93349>>>>>>>            End
93349>>>>>>>>
93349>>>>>>>            If (iPrecFrom <> iPrecTo) Begin
93351>>>>>>>                Set_Attribute DF_FIELD_PRECISION        of hTable iColumn to iPrecFrom
93354>>>>>>>            End
93354>>>>>>>>
93354>>>>>>>
93354>>>>>>>            If (bIsSQLTableTo = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
93356>>>>>>>                // Can't set a recnum table to "DF_FIELD_IS_IDENTITY"
93356>>>>>>>                If (bRecnumTable = True) Begin
93358>>>>>>>                    Set_Attribute DF_FILE_RECNUM_TABLE  of hTable to False
93361>>>>>>>                End
93361>>>>>>>>
93361>>>>>>>
93361>>>>>>>                // We might need to create an index here.
93361>>>>>>>                // To be able to set the DF_FIELD_IS_IDENTITY the index must already exist, but it might not at this stage.
93361>>>>>>>                // This should probably fix that problem and if an adjustment is needed, it will get done with the normal
93361>>>>>>>                // index update checking logic.
93361>>>>>>>                Get_Attribute DF_FIELD_INDEX               of hTable iColumn to iIndex
93364>>>>>>>                If (iIndex = 0 and Uppercase(sFieldNameTo) <> "RECNUM") Begin
93366>>>>>>>                    Create_Index hTable At iIndex
93367>>>>>>>                    Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex   to 1
93370>>>>>>>                End
93370>>>>>>>>
93370>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD       of hTable iIndex 1 to iColumn
93373>>>>>>>                Set_Attribute DF_FILE_PRIMARY_INDEX        of hTable          to iIndex
93376>>>>>>>                    Set_Attribute DF_FIELD_IS_IDENTITY     of hTable iColumn  to True
93379>>>>>>>                If (bIsSQLTableTo = True) Begin
93381>>>>>>>                    Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex   to True
93384>>>>>>>                End
93384>>>>>>>>
93384>>>>>>>            End
93384>>>>>>>>
93384>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
93385>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
93387>>>>>>>
93387>>>>>>>        Set Action_Text of ghoStatusPanel to ""
93388>>>>>>>        Function_Return (Err = False)
93389>>>>>>>    End_Function
93390>>>>>>>
93390>>>>>>>    Function ApiColumnChangeMainIndex Handle hTable Integer iIndex Integer iColumn Returns Boolean
93392>>>>>>>        Boolean bOK
93392>>>>>>>
93392>>>>>>>        Get AutoConnectionIDLogin to bOK
93393>>>>>>>        Move False to Err
93394>>>>>>>        Get OpenTableExclusive hTable to bOK
93395>>>>>>>        If (bOK = False) Begin
93397>>>>>>>            Function_Return False
93398>>>>>>>        End
93398>>>>>>>>
93398>>>>>>>
93398>>>>>>>        Structure_Start hTable
93399>>>>>>>            Set_Attribute DF_FIELD_INDEX of hTable iColumn to iIndex
93402>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
93403>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
93405>>>>>>>
93405>>>>>>>        Set Action_Text of ghoStatusPanel to ""
93406>>>>>>>        Function_Return (Err = False)
93407>>>>>>>    End_Function
93408>>>>>>>
93408>>>>>>>    // To move an existing field to another position in a table.
93408>>>>>>>    Function ApiColumnMove Handle hTable Integer iOld Integer iNew Boolean bIsSQLType Integer iLength Integer iPrecision Returns Boolean
93410>>>>>>>        String sColumn sDriverID
93410>>>>>>>        Integer iType
93410>>>>>>>        Boolean bOK bIsDate
93410>>>>>>>
93410>>>>>>>        Close hTable
93411>>>>>>>        Get AutoConnectionIDLogin to bOK
93412>>>>>>>        Get OpenTableExclusive hTable to bOK
93413>>>>>>>        If (bOK = False) Begin
93415>>>>>>>            Function_Return False
93416>>>>>>>        End
93416>>>>>>>>
93416>>>>>>>
93416>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
93419>>>>>>>        If (sDriverID = DFBTRDRV_ID) Begin
93421>>>>>>>            Error DFERR_PROGRAM "Function 'ColumnMove' is not supported for the Pervasive database."
93422>>>>>>>>
93422>>>>>>>            Function_Return False
93423>>>>>>>        End
93423>>>>>>>>
93423>>>>>>>
93423>>>>>>>        Get_Attribute DF_FIELD_NAME of hTable iOld to sColumn
93426>>>>>>>        Get_Attribute DF_FIELD_TYPE of hTable iOld to iType
93429>>>>>>>        Get UtilColumnIsDateType iType bIsSQLType  to bIsDate
93430>>>>>>>
93430>>>>>>>        Set Private.phCurrentTable to hTable
93431>>>>>>>        Set Private.piCurrentField to iOld
93432>>>>>>>
93432>>>>>>>//        If (bIsDate = False) Begin
93432>>>>>>>//            Get_Attribute DF_FIELD_LENGTH    of hTable iOld to iLength
93432>>>>>>>//            Get_Attribute DF_FIELD_PRECISION of hTable iOld to iPrecision
93432>>>>>>>//        End
93432>>>>>>>//        Else Begin
93432>>>>>>>//            Move 6 to iLength
93432>>>>>>>//            Move 0 to iPrecision
93432>>>>>>>//        End
93432>>>>>>>
93432>>>>>>>        Move False to Err
93433>>>>>>>
93433>>>>>>>        Structure_Start hTable
93434>>>>>>>            Delete_Field hTable iOld
93435>>>>>>>            Create_Field hTable At iNew
93436>>>>>>>            Set_Attribute DF_FIELD_OLD_NUMBER of hTable iNew to iOld
93439>>>>>>>
93439>>>>>>>            Set_Attribute DF_FIELD_NAME of hTable iNew to sColumn
93442>>>>>>>            If (bIsSQLType = False) Begin
93444>>>>>>>                Set_Attribute DF_FIELD_TYPE of hTable iNew to iType
93447>>>>>>>            End
93447>>>>>>>>
93447>>>>>>>            Else Begin
93448>>>>>>>                Set_Attribute DF_FIELD_TYPE of hTable iNew to iType
93451>>>>>>>//                Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iNew to iSQLType
93451>>>>>>>            End
93451>>>>>>>>
93451>>>>>>>
93451>>>>>>>            If (bIsDate = False) Begin
93453>>>>>>>                Set_Attribute DF_FIELD_LENGTH    of hTable iNew to iLength
93456>>>>>>>                Set_Attribute DF_FIELD_PRECISION of hTable iNew to iPrecision
93459>>>>>>>            End
93459>>>>>>>>
93459>>>>>>>
93459>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
93460>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
93462>>>>>>>
93462>>>>>>>        Set Action_Text of ghoStatusPanel to ""
93463>>>>>>>        Function_Return (Err = False)
93464>>>>>>>    End_Function
93465>>>>>>>
93465>>>>>>>    // Deletes a column name for the passed table number (and column number).
93465>>>>>>>    Function ApiColumnRemove Handle hTable String sFieldName Returns Boolean
93467>>>>>>>        Integer iColumn
93467>>>>>>>        Boolean bOK
93467>>>>>>>
93467>>>>>>>        Get AutoConnectionIDLogin to bOK
93468>>>>>>>        Move False to Err
93469>>>>>>>        Close hTable
93470>>>>>>>        Get OpenTableExclusive hTable to bOK
93471>>>>>>>        If (bOK = False) Begin
93473>>>>>>>            Function_Return False
93474>>>>>>>        End
93474>>>>>>>>
93474>>>>>>>
93474>>>>>>>        If (not(Err)) Begin
93476>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
93477>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
93478>>>>>>>            Field_Map hTable sFieldName to iColumn
93480>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
93481>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
93482>>>>>>>            If (iColumn = 0) Begin
93484>>>>>>>                Move 0 to LastErr
93485>>>>>>>                Function_Return False
93486>>>>>>>            End
93486>>>>>>>>
93486>>>>>>>            Move False to Err
93487>>>>>>>
93487>>>>>>>            Set Private.phCurrentTable to hTable
93488>>>>>>>            Set Private.piCurrentField to iColumn
93489>>>>>>>
93489>>>>>>>            Structure_Start hTable
93490>>>>>>>                Delete_Field hTable iColumn
93491>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
93492>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
93494>>>>>>>            Set Action_Text of ghoStatusPanel to ""
93495>>>>>>>        End
93495>>>>>>>>
93495>>>>>>>        Else Begin
93496>>>>>>>            Error DFERR_PROGRAM ("The table number:" * String(hTable) * "could not be opened exclusiv. This indicates the table is in use!")
93497>>>>>>>>
93497>>>>>>>        End
93497>>>>>>>>
93497>>>>>>>
93497>>>>>>>        Function_Return (Err = False)
93498>>>>>>>    End_Function
93499>>>>>>>
93499>>>>>>>    // Renames a field for the passed table number & old field name & new field name
93499>>>>>>>    // Returns True if no errors occured.
93499>>>>>>>    // Sample usage:
93499>>>>>>>    //   Get ColumnRename Quote.File_Number "ID#" "ID" to bOK
93499>>>>>>>    Function ApiColumnRename Integer hTable String sOldFieldName String sNewFieldName Returns Boolean
93501>>>>>>>        Integer iField
93501>>>>>>>        Boolean bOK bExists bIsOpen
93501>>>>>>>
93501>>>>>>>        Get UtilColumnExists hTable sNewFieldName to bExists
93502>>>>>>>        If (bExists = True) Begin
93504>>>>>>>            Function_Return False
93505>>>>>>>        End
93505>>>>>>>>
93505>>>>>>>
93505>>>>>>>        // Note: The Field_Map command does _not_ work if the table has been
93505>>>>>>>        //       opened exclusively, so we first open it in normal mode.
93505>>>>>>>        Close hTable
93506>>>>>>>        Open hTable
93508>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
93511>>>>>>>        If (bIsOpen = False) Begin
93513>>>>>>>            Function_Return False
93514>>>>>>>        End
93514>>>>>>>>
93514>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
93515>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
93516>>>>>>>        Field_Map hTable sOldFieldName to iField
93518>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
93519>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
93520>>>>>>>
93520>>>>>>>        Get AutoConnectionIDLogin to bOK
93521>>>>>>>        Get OpenTableExclusive hTable to bOK
93522>>>>>>>        If (bOK = False) Begin
93524>>>>>>>            Function_Return False
93525>>>>>>>        End
93525>>>>>>>>
93525>>>>>>>
93525>>>>>>>        Move False to Err
93526>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
93527>>>>>>>        Set Private.phCurrentTable to hTable
93528>>>>>>>        Set Private.piCurrentField to iField
93529>>>>>>>
93529>>>>>>>        If (iField > 0) Begin
93531>>>>>>>            Structure_Start hTable
93532>>>>>>>                Set_Attribute DF_FIELD_NAME of hTable iField to sNewFieldName
93535>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
93536>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
93538>>>>>>>        End
93538>>>>>>>>
93538>>>>>>>        Else Begin
93539>>>>>>>            Move 0 to LastErr
93540>>>>>>>            Move False to Err
93541>>>>>>>        End
93541>>>>>>>>
93541>>>>>>>
93541>>>>>>>        Set Action_Text of ghoStatusPanel to ""
93542>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
93543>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
93544>>>>>>>
93544>>>>>>>        Function_Return (Err = False)
93545>>>>>>>    End_Function
93546>>>>>>>
93546>>>>>>>    Function UtilColumnsCheckForInserts Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
93548>>>>>>>        tAPIColumnCompare[] aAPIColumnsToInsert
93548>>>>>>>        tAPIColumnCompare[] aAPIColumnsToInsert
93549>>>>>>>        Integer iSize iCount iItem iFieldTo iNumberOfFieldsTo iColumnNumber
93549>>>>>>>        Boolean bRenameField
93549>>>>>>>
93549>>>>>>>        Open hTable
93551>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
93552>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
93553>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
93554>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumberOfFieldsTo
93557>>>>>>>        Move (iSize max iNumberOfFieldsTo) to iSize
93558>>>>>>>        Decrement iSize
93559>>>>>>>        for iCount from 0 to iSize
93565>>>>>>>>
93565>>>>>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
93567>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
93568>>>>>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
93569>>>>>>>
93569>>>>>>>                Field_Map hTable aAPIColumnCompare[iCount].sFieldNameFrom to iFieldTo
93571>>>>>>>                If (aAPIColumnCompare[iCount].bExistsFrom = True and iFieldTo = 0) Begin
93573>>>>>>>                    Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iColumnNumber
93574>>>>>>>                    Get UtilColumnShouldBeRenamed aAPIColumnCompare[iCount]      to bRenameField
93575>>>>>>>                    If (iColumnNumber = -1 and bRenameField = False) Begin
93577>>>>>>>                        Move aAPIColumnCompare[iCount].iFieldNumber     to aAPIColumnsToInsert[iItem].iFieldNumber
93578>>>>>>>                        Move aAPIColumnCompare[iCount].sFieldNameFrom   to aAPIColumnsToInsert[iItem].sFieldNameFrom
93579>>>>>>>                        Move aAPIColumnCompare[iCount].iTypeFrom        to aAPIColumnsToInsert[iItem].iTypeFrom
93580>>>>>>>                        Move aAPIColumnCompare[iCount].sTypeFrom        to aAPIColumnsToInsert[iItem].sTypeFrom
93581>>>>>>>                        Move aAPIColumnCompare[iCount].iLengthFrom      to aAPIColumnsToInsert[iItem].iLengthFrom
93582>>>>>>>                        Move aAPIColumnCompare[iCount].iPrecisionFrom   to aAPIColumnsToInsert[iItem].iPrecisionFrom
93583>>>>>>>                        Move aAPIColumnCompare[iCount].bIsSQLTypeFrom   to aAPIColumnsToInsert[iItem].bIsSQLTypeFrom
93584>>>>>>>                        Move aAPIColumnCompare[iCount].bIsSQLTypeTo     to aAPIColumnsToInsert[iItem].bIsSQLTypeTo
93585>>>>>>>                        Move True                                       to aAPIColumnsToInsert[iItem].bExistsFrom
93586>>>>>>>                        Move False                                      to aAPIColumnsToInsert[iItem].bExistsTo
93587>>>>>>>                        Increment iItem
93588>>>>>>>                    End
93588>>>>>>>>
93588>>>>>>>                End
93588>>>>>>>>
93588>>>>>>>            End
93588>>>>>>>>
93588>>>>>>>        Loop
93589>>>>>>>>
93589>>>>>>>
93589>>>>>>>        Move False to Err
93590>>>>>>>        Move 0 to LastErr
93591>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
93592>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
93593>>>>>>>        Function_Return aAPIColumnsToInsert
93594>>>>>>>    End_Function
93595>>>>>>>
93595>>>>>>>    Function UtilColumnsInsert String sDriverIDFrom Handle hTable tAPIColumnCompare[] aAPIColumnsToInsert Returns Boolean
93597>>>>>>>        Integer iSize iCount
93597>>>>>>>        Boolean bOK
93597>>>>>>>        tAPIColumn[] aColumnsTo
93597>>>>>>>        tAPIColumn[] aColumnsTo
93598>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
93598>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
93599>>>>>>>
93599>>>>>>>        Move (SizeOfArray(aAPIColumnsToInsert)) to iSize
93600>>>>>>>        If (iSize = 0) Begin
93602>>>>>>>            Function_Return True
93603>>>>>>>        End
93603>>>>>>>>
93603>>>>>>>
93603>>>>>>>        Move False to Err
93604>>>>>>>        Decrement iSize
93605>>>>>>>        for iCount from 0 to iSize
93611>>>>>>>>
93611>>>>>>>            Get ApiColumnInsert sDriverIDFrom hTable aAPIColumnsToInsert[iCount].iFieldNumber aAPIColumnsToInsert[iCount].sFieldNameFrom aAPIColumnsToInsert[iCount].iTypeFrom aAPIColumnsToInsert[iCount].iLengthFrom aAPIColumnsToInsert[iCount].iPrecisionFrom aAPIColumnsToInsert[iCount].bIsSQLTypeFrom to bOK
93612>>>>>>>        Loop
93613>>>>>>>>
93613>>>>>>>
93613>>>>>>>        Function_Return bOK
93614>>>>>>>    End_Function
93615>>>>>>>
93615>>>>>>>    // Returns a struct array with fields that has the same names but different field numbers.
93615>>>>>>>    Function UtilColumnsCheckForMoves Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
93617>>>>>>>        tAPIColumnCompare[] aAPIColumnsToMove
93617>>>>>>>        tAPIColumnCompare[] aAPIColumnsToMove
93618>>>>>>>        Integer iSize iCount iItem iShouldMove
93618>>>>>>>
93618>>>>>>>        Move 0 to iItem
93619>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
93620>>>>>>>        Decrement iSize
93621>>>>>>>        for iCount from 0 to iSize
93627>>>>>>>>
93627>>>>>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
93629>>>>>>>                Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iShouldMove
93630>>>>>>>                If (iShouldMove <> -1) Begin
93632>>>>>>>                    Move aAPIColumnCompare[iCount] to aAPIColumnsToMove[iItem]
93633>>>>>>>                    Move iShouldMove               to aAPIColumnsToMove[iItem].iFieldNumberTo
93634>>>>>>>                    Move aAPIColumnCompare[iShouldMove - 1].sFieldNameTo to aAPIColumnsToMove[iItem].sFieldNameTo
93635>>>>>>>                    Increment iItem
93636>>>>>>>                End
93636>>>>>>>>
93636>>>>>>>            End
93636>>>>>>>>
93636>>>>>>>        Loop
93637>>>>>>>>
93637>>>>>>>
93637>>>>>>>        Move False to Err
93638>>>>>>>        Move 0 to LastErr
93639>>>>>>>        Function_Return aAPIColumnsToMove
93640>>>>>>>    End_Function
93641>>>>>>>
93641>>>>>>>    Function UtilColumnsMove Handle hTable tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo tAPIColumnCompare[] aAPIColumnsToMove Returns Boolean
93643>>>>>>>        Integer iSize iCount
93643>>>>>>>        Boolean bOK
93643>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
93643>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
93644>>>>>>>
93644>>>>>>>        Move (SizeOfArray(aAPIColumnsToMove)) to iSize
93645>>>>>>>        If (iSize = 0) Begin
93647>>>>>>>            Function_Return True
93648>>>>>>>        End
93648>>>>>>>>
93648>>>>>>>
93648>>>>>>>        Move False to Err
93649>>>>>>>        Decrement iSize
93650>>>>>>>        for iCount from 0 to iSize
93656>>>>>>>>
93656>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
93657>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
93658>>>>>>>            If (aAPIColumnsToMove[iCount].bExistsFrom = True and aAPIColumnsToMove[iCount].bExistsTo = True) Begin
93660>>>>>>>                Get ApiColumnMove hTable aAPIColumnsToMove[iCount].iFieldNumberTo aAPIColumnsToMove[iCount].iFieldNumber aAPIColumnsToMove[iCount].bIsSQLTypeFrom aAPIColumnsToMove[iCount].iLengthFrom aAPIColumnsToMove[iCount].iPrecisionFrom to bOK
93661>>>>>>>                Get UtilColumnsStructFill hTable to aColumnsTo
93662>>>>>>>                Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
93663>>>>>>>                Get UtilColumnsCheckForMoves hTable aAPIColumnCompare to aAPIColumnsToMove
93664>>>>>>>                If (SizeOfArray(aAPIColumnsToMove)) Begin
93666>>>>>>>                    Move (SizeOfArray(aAPIColumnsToMove)) to iSize
93667>>>>>>>                    Decrement iSize
93668>>>>>>>                    Move 0 to iCount
93669>>>>>>>                End
93669>>>>>>>>
93669>>>>>>>            End
93669>>>>>>>>
93669>>>>>>>        Loop
93670>>>>>>>>
93670>>>>>>>
93670>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
93671>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
93672>>>>>>>        If (LastErr = DFERR_ARRAY_INDEX_OUT_OF_BOUNDS) Begin
93674>>>>>>>            Move 0 to LastErr
93675>>>>>>>        End
93675>>>>>>>>
93675>>>>>>>        Function_Return bOK
93676>>>>>>>    End_Function
93677>>>>>>>
93677>>>>>>>    // Checks if the "FROM" and "TO" database field is the same _except_ for the field name.
93677>>>>>>>    // We then assume this field should be renamed.
93677>>>>>>>//    Function UtilColumCheckRename Handle hTable tAPIColumnCompare aAPIColumnCompare Returns Boolean
93677>>>>>>>//        Boolean bDifferentFieldNames bShouldBeRenamed
93677>>>>>>>//
93677>>>>>>>//        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
93677>>>>>>>//        Move (Uppercase(aAPIColumnCompare.sFieldNameFrom) <> Uppercase(aAPIColumnCompare.sFieldNameTo)) to bDifferentFieldNames
93677>>>>>>>//
93677>>>>>>>//        If (bDifferentFieldNames = True) Begin
93677>>>>>>>//            Move (aAPIColumnCompare.iFieldNumber = aAPIColumnCompare.iFieldNumberTo) to bShouldBeRenamed
93677>>>>>>>//            If (bShouldBeRenamed = False) Begin
93677>>>>>>>//                Set Error_Report_Mode to DUF_ERROR_REPORT
93677>>>>>>>//                Function_Return False
93677>>>>>>>//            End
93677>>>>>>>//
93677>>>>>>>//            Move (aAPIColumnCompare.iTypeFrom = aAPIColumnCompare.iTypeTo) to bShouldBeRenamed
93677>>>>>>>//            If (bShouldBeRenamed = False) Begin
93677>>>>>>>//                Set Error_Report_Mode to DUF_ERROR_REPORT
93677>>>>>>>//                Function_Return False
93677>>>>>>>//            End
93677>>>>>>>//
93677>>>>>>>//            Move (aAPIColumnCompare.iLengthFrom = aAPIColumnCompare.iLengthTo) to bShouldBeRenamed
93677>>>>>>>//            If (bShouldBeRenamed = False) Begin
93677>>>>>>>//                Set Error_Report_Mode to DUF_ERROR_REPORT
93677>>>>>>>//                Function_Return False
93677>>>>>>>//            End
93677>>>>>>>//
93677>>>>>>>//            Move (aAPIColumnCompare.iPrecisionFrom = aAPIColumnCompare.iPrecisionTo) to bShouldBeRenamed
93677>>>>>>>//            If (bShouldBeRenamed = False) Begin
93677>>>>>>>//                Set Error_Report_Mode to DUF_ERROR_REPORT
93677>>>>>>>//                Function_Return False
93677>>>>>>>//            End
93677>>>>>>>//        End
93677>>>>>>>//
93677>>>>>>>//        Set Error_Report_Mode to DUF_ERROR_REPORT
93677>>>>>>>//        Function_Return True
93677>>>>>>>//    End_Function
93677>>>>>>>
93677>>>>>>>    // Takes a tAPIColumnCompare struct as parameter and returns True if;
93677>>>>>>>    // - Field Numbers, Data Types, Lengths and Precisions are all equal.
93677>>>>>>>    // - The "FROM" field name is <> "TO" field name
93677>>>>>>>//    // - The "FROM" field name also exists in the "TO" table; or the "TO" is part
93677>>>>>>>//    //   of the "FROM" field name. E.g. "FROM" = LATEST_REPL_COST_DATE, "TO" = Latest_Repl_Cos would results in a TRUE.
93677>>>>>>>    Function UtilColumnShouldBeRenamed tAPIColumnCompare aAPIColumnCompare Returns Boolean
93679>>>>>>>        Boolean bShouldRename
93679>>>>>>>        String sFieldNameFrom sFieldNameTo
93679>>>>>>>
93679>>>>>>>        Move (Uppercase(aAPIColumnCompare.sFieldNameFrom)) to sFieldNameFrom
93680>>>>>>>        Move (Uppercase(aAPIColumnCompare.sFieldNameTo))   to sFieldNameTo
93681>>>>>>>        If (sFieldNameFrom = sFieldNameTo) Begin
93683>>>>>>>            Function_Return False
93684>>>>>>>        End
93684>>>>>>>>
93684>>>>>>>
93684>>>>>>>        Move (aAPIColumnCompare.bExistsFrom    = aAPIColumnCompare.bExistsTo      and ;              aAPIColumnCompare.iFieldNumber   = aAPIColumnCompare.iFieldNumberTo and ;              aAPIColumnCompare.iTypeFrom      = aAPIColumnCompare.iTypeTo        and ;              aAPIColumnCompare.iLengthFrom    = aAPIColumnCompare.iLengthTo      and ;              aAPIColumnCompare.iPrecisionFrom = aAPIColumnCompare.iPrecisionTo   and ;              aAPIColumnCompare.iOptionsFrom   = aAPIColumnCompare.iOptionsTo) to bShouldRename
93685>>>>>>>//        If (bShouldRename = False) Begin
93685>>>>>>>//            Function_Return False
93685>>>>>>>//        End
93685>>>>>>>//
93685>>>>>>>//        If (sFieldNameFrom contains sFieldNameTo) Begin
93685>>>>>>>//            Function_Return True
93685>>>>>>>//        End
93685>>>>>>>
93685>>>>>>>        Function_Return bShouldRename
93686>>>>>>>    End_Function
93687>>>>>>>
93687>>>>>>>    // Returns -1 if the passed iColumn number doesn't exist with the same name in the aAPIColumnCompare struct array.
93687>>>>>>>    // Else it returns the column/field number of the field that exists in another position.
93687>>>>>>>    Function UtilColumnExistsWithOtherNumber tAPIColumnCompare[] aAPIColumnCompare Integer iColumn Returns Integer
93689>>>>>>>        Integer iCount iSize iRetval
93689>>>>>>>        String sFieldNameFrom
93689>>>>>>>
93689>>>>>>>        Move -1 to iRetval
93690>>>>>>>        If (aAPIColumnCompare[iColumn].bExistsFrom = False or aAPIColumnCompare[iColumn].bExistsTo = False) Begin
93692>>>>>>>            Function_Return iRetval
93693>>>>>>>        End
93693>>>>>>>>
93693>>>>>>>
93693>>>>>>>        Move (Uppercase(aAPIColumnCompare[iColumn].sFieldNameFrom)) to sFieldNameFrom
93694>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
93695>>>>>>>        Decrement iSize
93696>>>>>>>        for iCount from 0 to iSize
93702>>>>>>>>
93702>>>>>>>            // We're only interested in fields other than the passed field/column number:
93702>>>>>>>            If (iCount <> iColumn) Begin
93704>>>>>>>                If (Uppercase(aAPIColumnCompare[iCount].sFieldNameTo) = sFieldNameFrom) Begin
93706>>>>>>>                    Move (iCount + 1) to iRetval
93707>>>>>>>                End
93707>>>>>>>>
93707>>>>>>>            End
93707>>>>>>>>
93707>>>>>>>        Loop
93708>>>>>>>>
93708>>>>>>>
93708>>>>>>>        Move 0 to LastErr
93709>>>>>>>        Function_Return iRetval
93710>>>>>>>    End_Function
93711>>>>>>>
93711>>>>>>>    Function UtilColumnsCheckForRenames Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
93713>>>>>>>        tAPIColumnCompare[] aAPIColumnsToRename
93713>>>>>>>        tAPIColumnCompare[] aAPIColumnsToRename
93714>>>>>>>        Integer iSize iCount iItem iFieldTo iShouldMove
93714>>>>>>>        Boolean bRenameField
93714>>>>>>>
93714>>>>>>>        Open hTable
93716>>>>>>>        Move 0 to iItem
93717>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
93718>>>>>>>        Decrement iSize
93719>>>>>>>        for iCount from 0 to iSize
93725>>>>>>>>
93725>>>>>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
93727>>>>>>>                // Check if the field exists in another position (other field number)
93727>>>>>>>                Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iShouldMove
93728>>>>>>>                Get UtilColumnShouldBeRenamed aAPIColumnCompare[iCount] to bRenameField
93729>>>>>>>                If (aAPIColumnCompare[iCount].bExistsFrom = True and iShouldMove = -1 and bRenameField = True) Begin
93731>>>>>>>                    Move aAPIColumnCompare[iCount].iFieldNumber     to aAPIColumnsToRename[iItem].iFieldNumber
93732>>>>>>>                    Move iFieldTo                                   to aAPIColumnsToRename[iItem].iFieldNumberTo
93733>>>>>>>                    Move aAPIColumnCompare[iCount].sFieldNameFrom   to aAPIColumnsToRename[iItem].sFieldNameFrom
93734>>>>>>>                    Move aAPIColumnCompare[iCount].sFieldNameTo     to aAPIColumnsToRename[iItem].sFieldNameTo
93735>>>>>>>                    Increment iItem
93736>>>>>>>                End
93736>>>>>>>>
93736>>>>>>>            End
93736>>>>>>>>
93736>>>>>>>        Loop
93737>>>>>>>>
93737>>>>>>>
93737>>>>>>>        Move False to Err
93738>>>>>>>        Move 0 to LastErr
93739>>>>>>>        Function_Return aAPIColumnsToRename
93740>>>>>>>    End_Function
93741>>>>>>>
93741>>>>>>>    Function UtilColumnsRename Handle hTable tAPIColumnCompare[] aAPIColumnsToRename Returns Boolean
93743>>>>>>>        Integer iSize iCount
93743>>>>>>>        Boolean bOK
93743>>>>>>>        tAPIColumn[] aColumnsTo
93743>>>>>>>        tAPIColumn[] aColumnsTo
93744>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
93744>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
93745>>>>>>>
93745>>>>>>>        Move (SizeOfArray(aAPIColumnsToRename)) to iSize
93746>>>>>>>        If (iSize = 0) Begin
93748>>>>>>>            Function_Return True
93749>>>>>>>        End
93749>>>>>>>>
93749>>>>>>>
93749>>>>>>>        Move False to Err
93750>>>>>>>        Decrement iSize
93751>>>>>>>        For iCount from 0 to iSize
93757>>>>>>>>
93757>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
93758>>>>>>>            Get ApiColumnRename hTable aAPIColumnsToRename[iCount].sFieldNameTo aAPIColumnsToRename[iCount].sFieldNameFrom to bOK
93759>>>>>>>        Loop
93760>>>>>>>>
93760>>>>>>>
93760>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
93761>>>>>>>        Function_Return bOK
93762>>>>>>>    End_Function
93763>>>>>>>
93763>>>>>>>    Function UtilColumnIsDateType Integer iType Boolean bIsSQLTableTo Returns Boolean
93765>>>>>>>        Boolean bDateType
93765>>>>>>>
93765>>>>>>>        If (bIsSQLTableTo = True) Begin
93767>>>>>>>            Move (iType = SQL_TYPE_DATE or iType = SQL_TYPE_TIMESTAMP or iType = SQL_TYPE_TIMESTAMP2) to bDateType
93768>>>>>>>        End
93768>>>>>>>>
93768>>>>>>>        Else Begin
93769>>>>>>>            Move (iType = DF_DATE or iType = DF_DATETIME) to bDateType
93770>>>>>>>        End
93770>>>>>>>>
93770>>>>>>>
93770>>>>>>>        Function_Return bDateType
93771>>>>>>>    End_Function
93772>>>>>>>
93772>>>>>>>    Function ApiColumnsUpdate String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo Boolean bCompareDate_DateTime Returns Boolean
93774>>>>>>>        Integer iCount iColumns iColumn iTypeFrom iTypeTo iDataFlexType iIndex iLengthFrom iLengthTo iPrecisionFrom iPrecisionTo iOptionFrom iOptionTo iDbType
93774>>>>>>>        Integer iCount2 iColumn2
93774>>>>>>>        Handle hFile
93774>>>>>>>        Boolean bFieldExistsFrom bFieldExistsTo bIsSQLDriver bIsSame bOK bSkip
93774>>>>>>>        Boolean bRecnum bIsSQLTableTo bRecnumTable bIsOpen bSkipTypeChange bIsDateType
93774>>>>>>>        String sFieldNameFrom sFieldNameTo sDriverIDTo sDefaultValue
93774>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare aApiInsertColumns aAPIMoveColumns aAPIRenameColumns aAPIRemoveColumns
93774>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare aApiInsertColumns aAPIMoveColumns aAPIRenameColumns aAPIRemoveColumns
93779>>>>>>>        tColumnType ColumnType
93779>>>>>>>        tColumnType ColumnType
93779>>>>>>>
93779>>>>>>>        Move False to Err
93780>>>>>>>        Close hTable
93781>>>>>>>        Get OpenTableExclusive hTable to bIsOpen
93782>>>>>>>        If (bIsOpen = False) Begin
93784>>>>>>>            Error DFERR_PROGRAM ("Function 'ApiColumnsUpdate'. Can't open table number:" * String(hTable))
93785>>>>>>>>
93785>>>>>>>            Function_Return False
93786>>>>>>>        End 
93786>>>>>>>>
93786>>>>>>>        
93786>>>>>>>        Get piDbType to iDbType
93787>>>>>>>        Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
93790>>>>>>>        Move bIsSQLTableFrom to bIsSQLDriver
93791>>>>>>>        Get UtilTableIsSQL hTable to bIsSQLTableTo
93792>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverIDTo
93795>>>>>>>
93795>>>>>>>        Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
93796>>>>>>>
93796>>>>>>>        // Before we start to change the table we need to do three things;
93796>>>>>>>        // 1) Insert any new fields
93796>>>>>>>        Get UtilColumnsCheckForInserts hTable aAPIColumnCompare to aApiInsertColumns
93797>>>>>>>        If (SizeOfArray(aApiInsertColumns)) Begin
93799>>>>>>>            Get UtilColumnsInsert sDriverIDFrom hTable aApiInsertColumns to bOK
93800>>>>>>>            If (bOK = False) Begin
93802>>>>>>>                Function_Return False
93803>>>>>>>            End
93803>>>>>>>>
93803>>>>>>>            // Update info with changes made.
93803>>>>>>>            Get UtilColumnsStructFill hTable to aColumnsTo
93804>>>>>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
93805>>>>>>>        End
93805>>>>>>>>
93805>>>>>>>
93805>>>>>>>        // 2) Move fields with same names
93805>>>>>>>        Get UtilColumnsCheckForMoves hTable aAPIColumnCompare to aAPIMoveColumns
93806>>>>>>>        If (SizeOfArray(aAPIMoveColumns)) Begin
93808>>>>>>>            Get UtilColumnsMove hTable aColumnsFrom aColumnsTo aAPIMoveColumns to bOK
93809>>>>>>>            If (bOK = False) Begin
93811>>>>>>>                Function_Return False
93812>>>>>>>            End
93812>>>>>>>>
93812>>>>>>>            Get UtilColumnsStructFill hTable to aColumnsTo
93813>>>>>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
93814>>>>>>>        End
93814>>>>>>>>
93814>>>>>>>        
93814>>>>>>>        // 3) Rename fields
93814>>>>>>>        Get UtilColumnsCheckForRenames hTable aAPIColumnCompare to aAPIRenameColumns
93815>>>>>>>        If (SizeOfArray(aAPIRenameColumns)) Begin
93817>>>>>>>            Get UtilColumnsRename hTable aAPIRenameColumns to bOK
93818>>>>>>>            If (bOK = False) Begin
93820>>>>>>>                Function_Return False
93821>>>>>>>            End
93821>>>>>>>>
93821>>>>>>>            Get UtilColumnsStructFill hTable to aColumnsTo
93822>>>>>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
93823>>>>>>>        End
93823>>>>>>>>
93823>>>>>>>
93823>>>>>>>        // 4) Remove fields if more fields currently exists compared to the new table definition.
93823>>>>>>>//        Get utilColumnsCheckForRemoves hTable aAPIColumnCompare to aAPIRemoveColumns
93823>>>>>>>//        If (SizeOfArray(aAPIRemoveColumns)) Begin
93823>>>>>>>//            Get UtilColumnsRemove hTable aAPIRemoveColumns to bOK
93823>>>>>>>//            If (bOK = False) Begin
93823>>>>>>>//                Function_Return False
93823>>>>>>>//            End
93823>>>>>>>//            Get UtilColumnsStructFill hTable to aColumnsTo
93823>>>>>>>//            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
93823>>>>>>>//        End
93823>>>>>>>
93823>>>>>>>        // If any of the fields were changed by "Insert", "Rename" or "Move", we need to compare the fields again:
93823>>>>>>>        If (SizeOfArray(aApiInsertColumns) or SizeOfArray(aAPIRenameColumns) or SizeOfArray(aAPIMoveColumns)) Begin
93825>>>>>>>            Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom bIsSQLTableTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
93826>>>>>>>            If (bIsSame = True) Begin
93828>>>>>>>                Function_Return True
93829>>>>>>>            End
93829>>>>>>>>
93829>>>>>>>        End
93829>>>>>>>>
93829>>>>>>>
93829>>>>>>>        // We can now continue to make standard field changes:
93829>>>>>>>        Get OpenTableExclusive hTable to bIsOpen
93830>>>>>>>        Set Private.phCurrentTable to hTable
93831>>>>>>>        Move hTable to hFile
93832>>>>>>>        Structure_Start hFile sDriverIDTo
93833>>>>>>>
93833>>>>>>>            Move (SizeOfArray(aAPIColumnCompare)) to iColumns
93834>>>>>>>            Decrement iColumns
93835>>>>>>>            for iCount from 0 to iColumns
93841>>>>>>>>
93841>>>>>>>                Send DoAdvance of ghoProgressBar
93842>>>>>>>
93842>>>>>>>                Move aAPIColumnCompare[iCount].iFieldNumber to iColumn
93843>>>>>>>                Set Private.piCurrentField                  to iColumn
93844>>>>>>>                Get UtilColumnCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom aAPIColumnCompare[iCount].bIsSQLTypeTo aAPIColumnCompare[iCount] bCompareDate_DateTime to bIsSame
93845>>>>>>>                If (bIsSame = False) Begin
93847>>>>>>>
93847>>>>>>>                    Move aAPIColumnCompare[iCount].bExistsFrom          to bFieldExistsFrom
93848>>>>>>>                    If (bFieldExistsFrom = True) Begin
93850>>>>>>>                        Move aAPIColumnCompare[iCount].bExistsTo        to bFieldExistsTo
93851>>>>>>>                        Move aAPIColumnCompare[iCount].sFieldNameFrom   to sFieldNameFrom
93852>>>>>>>                        Move aAPIColumnCompare[iCount].iLengthFrom      to iLengthFrom
93853>>>>>>>                        Move aAPIColumnCompare[iCount].iPrecisionFrom   to iPrecisionFrom
93854>>>>>>>                        Move aAPIColumnCompare[iCount].iOptionsFrom     to iOptionFrom
93855>>>>>>>
93855>>>>>>>                        Move aAPIColumnCompare[iCount].iTypeFrom        to iTypeFrom
93856>>>>>>>                        Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iDataFlexType
93857>>>>>>>                        If (iTypeFrom < -1490) Begin
93859>>>>>>>                            Move (iTypeFrom + 1500)                     to iTypeFrom
93860>>>>>>>                        End
93860>>>>>>>>
93860>>>>>>>
93860>>>>>>>                        // If one of the two tables are SQL and the other Embedded we need to "translate"
93860>>>>>>>                        // data types between Embedded and SQL, else we can't compare the data types.
93860>>>>>>>                        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
93862>>>>>>>                            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iTypeFrom
93863>>>>>>>                            If (iTypeFrom = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
93865>>>>>>>                                Move DF_DATE to iTypeFrom
93866>>>>>>>                            End
93866>>>>>>>>
93866>>>>>>>                        End
93866>>>>>>>>
93866>>>>>>>                        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
93869>>>>>>>                            Get UtilSqlColumnTypeToDataFlexType sDriverIDTo   iDbType iTypeTo   iLengthTo   to iTypeTo
93870>>>>>>>                        End
93870>>>>>>>>
93870>>>>>>>
93870>>>>>>>                        Move aAPIColumnCompare[iCount].sFieldNameTo to sFieldNameTo
93871>>>>>>>                        Move aAPIColumnCompare[iCount].iLengthTo    to iLengthTo
93872>>>>>>>                        Move aAPIColumnCompare[iCount].iPrecisionTo to iPrecisionTo
93873>>>>>>>                        Move aAPIColumnCompare[iCount].iOptionsTo   to iOptionTo
93874>>>>>>>                        Move aAPIColumnCompare[iCount].iTypeTo      to iTypeTo
93875>>>>>>>
93875>>>>>>>                        Move False to bSkipTypeChange
93876>>>>>>>                        If (bCompareDate_DateTime = False) Begin
93878>>>>>>>                            Move ((iTypeFrom = SQL_TYPE_DATE or iTypeFrom = SQL_TYPE_TIME or iTypeFrom = SQL_TYPE_TIMESTAMP) and (iTypeTo = SQL_TYPE_DATE or iTypeTo = SQL_TYPE_TIME or iTypeTo = SQL_TYPE_TIMESTAMP)) to bSkipTypeChange
93879>>>>>>>                        End
93879>>>>>>>>
93879>>>>>>>
93879>>>>>>>                        If (bFieldExistsTo = False) Begin
93881>>>>>>>                            Move 0 to iColumn
93882>>>>>>>                            Create_Field hFile At iColumn
93883>>>>>>>                            Set Private.piCurrentField to iColumn
93884>>>>>>>                        End
93884>>>>>>>>
93884>>>>>>>
93884>>>>>>>                        If (sFieldNameFrom <> sFieldNameTo) Begin
93886>>>>>>>                            Set_Attribute DF_FIELD_NAME of hFile iColumn to sFieldNameFrom
93889>>>>>>>                        End
93889>>>>>>>>
93889>>>>>>>
93889>>>>>>>                        If (bIsSQLTableFrom = True and bIsSQLTableTo = True and aAPIColumnCompare[iCount].iOptionsFrom <> C_tAPIColumn_Identity) Begin
93891>>>>>>>                            Set_Attribute DF_FIELD_NULL_ALLOWED  of hFile iColumn to aAPIColumnCompare[iCount].bAllowNULLFrom
93894>>>>>>>                            Move aAPIColumnCompare[iCount].sDefaultValueFrom to sDefaultValue
93895>>>>>>>                            If (iDataFlexType = DF_BCD and Left(String(sDefaultValue), 1) <> "[") Begin
93897>>>>>>>                                Move ("[" + String(sDefaultValue) + "]") to sDefaultValue
93898>>>>>>>                            End
93898>>>>>>>>
93898>>>>>>>                            Set_Attribute DF_FIELD_DEFAULT_VALUE of hFile iColumn to sDefaultValue
93901>>>>>>>                        End
93901>>>>>>>>
93901>>>>>>>
93901>>>>>>>                        If (bSkipTypeChange = False) Begin
93903>>>>>>>                            If (iTypeFrom <> iTypeTo) Begin
93905>>>>>>>                                If (bIsSQLTableTo = True) Begin
93907>>>>>>>                                    Set_Attribute DF_FIELD_NATIVE_TYPE of hFile iColumn to iTypeFrom
93910>>>>>>>                                End
93910>>>>>>>>
93910>>>>>>>                                Else Begin                                                   
93911>>>>>>>                                    If (iDataFlexType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
93913>>>>>>>                                        Move DF_DATE to iDataFlexType  // Date
93914>>>>>>>                                    End
93914>>>>>>>>
93914>>>>>>>                                    Set_Attribute DF_FIELD_TYPE of hFile iColumn to iDataFlexType
93917>>>>>>>                                End
93917>>>>>>>>
93917>>>>>>>                            End
93917>>>>>>>>
93917>>>>>>>                        End
93917>>>>>>>>
93917>>>>>>>
93917>>>>>>>                        Get UtilColumnIsDateType iTypeFrom bIsSQLTableTo to bIsDateType
93918>>>>>>>                        // We can't set the length or precision for Date type columns (they are fixed).
93918>>>>>>>                        If (bIsDateType = False) Begin
93920>>>>>>>                            If (iLengthFrom <> iLengthTo) Begin
93922>>>>>>>                                Set_Attribute DF_FIELD_LENGTH of hFile iColumn to iLengthFrom
93925>>>>>>>                            End
93925>>>>>>>>
93925>>>>>>>                            If (iPrecisionFrom <> iPrecisionTo) Begin
93927>>>>>>>                                Set_Attribute DF_FIELD_PRECISION of hFile iColumn to iPrecisionFrom
93930>>>>>>>                            End
93930>>>>>>>>
93930>>>>>>>                        End
93930>>>>>>>>
93930>>>>>>>
93930>>>>>>>                        If (bIsSQLTableTo = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
93932>>>>>>>                            // Can't set a recnum table to "DF_FIELD_IS_IDENTITY"
93932>>>>>>>                            If (bRecnumTable = True) Begin
93934>>>>>>>                                Set_Attribute DF_FILE_RECNUM_TABLE of hTable to False
93937>>>>>>>                            End
93937>>>>>>>>
93937>>>>>>>
93937>>>>>>>                            // We might need to create an index here.
93937>>>>>>>                            // To be able to set the DF_FIELD_IS_IDENTITY the index must already exist, but it might not at this stage.
93937>>>>>>>                            // This should probably fix that problem and if an adjustment is needed, it will get done with the normal
93937>>>>>>>                            // index update checking logic.
93937>>>>>>>                            Get_Attribute DF_FIELD_INDEX           of hFile iColumn to iIndex
93940>>>>>>>                            If (iIndex = 0 and Uppercase(sFieldNameTo) <> "RECNUM") Begin
93942>>>>>>>                                Create_Index hFile at iIndex
93943>>>>>>>                                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hFile iIndex to 1
93946>>>>>>>                            End
93946>>>>>>>>
93946>>>>>>>
93946>>>>>>>                            Set_Attribute DF_INDEX_SEGMENT_FIELD   of hFile iIndex 1 to iColumn
93949>>>>>>>                            Set_Attribute DF_FILE_PRIMARY_INDEX    of hFile          to iIndex
93952>>>>>>>                                // Note: The order of these two are crucial!
93952>>>>>>>                                Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hFile iIndex to True
93955>>>>>>>                                Set_Attribute DF_FIELD_IS_IDENTITY of hFile iColumn    to True
93958>>>>>>>                        End
93958>>>>>>>>
93958>>>>>>>                    End
93958>>>>>>>>
93958>>>>>>>                    Else Begin
93959>>>>>>>                        Delete_Field hFile iColumn
93960>>>>>>>                        Move (RemoveFromArray(aColumnsTo, iCount)) to aColumnsTo
93961>>>>>>>                        Move (SizeOfArray(aColumnsTo)) to iCount2
93962>>>>>>>                        Decrement iCount2
93963>>>>>>>                        // We need to adjust FieldNumbers in the array with one, as we just deleted a field,
93963>>>>>>>                        // starting with the array number we just deleted the field for.
93963>>>>>>>                        for iColumn2 from iCount to iCount2
93969>>>>>>>>
93969>>>>>>>                            Move (aColumnsTo[iColumn2].iFieldNumber - 1) to aColumnsTo[iColumn2].iFieldNumber
93970>>>>>>>                        Loop
93971>>>>>>>>
93971>>>>>>>                        Decrement iCount
93972>>>>>>>                        Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
93973>>>>>>>                        Move (SizeOfArray(aAPIColumnCompare)) to iColumns
93974>>>>>>>                        If (SizeOfArray(aColumnsFrom) = SizeOfArray(aColumnsTo)) Begin
93976>>>>>>>                            Move iColumns to iCount 
93977>>>>>>>                        End
93977>>>>>>>>
93977>>>>>>>                    End
93977>>>>>>>>
93977>>>>>>>                End
93977>>>>>>>>
93977>>>>>>>            Loop
93978>>>>>>>>
93978>>>>>>>
93978>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
93979>>>>>>>        Structure_End hFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
93981>>>>>>>
93981>>>>>>>        Set Action_Text of ghoStatusPanel to ""
93982>>>>>>>        Function_Return (Err = False)
93983>>>>>>>    End_Function
93984>>>>>>>
93984>>>>>>>    // * Dummy function for the Studio's Code Explorer *
93984>>>>>>>    Function API_INDEX_FUNCTIONS Returns Boolean
93986>>>>>>>        Function_Return False
93987>>>>>>>    End_Function
93988>>>>>>>
93988>>>>>>>    // Get ApiIndexCreate Customers.File_Number 1 2 0 1 -1 -1 -1 -1 -1 -1 -1 -1 to bOK
93988>>>>>>>    // Note: the "-1" can be left out as this function is overloaded to make it easier to call.
93988>>>>>>>    // Note: This doesn't set Descending attributes - Use function IndexChangeDirection to do that.
93988>>>>>>>    Function ApiIndexCreate Handle hTable Integer iIndex Integer iSegments Integer iSgmnt1 Integer iSgmnt2 Integer iSgmnt3 Integer iSgmnt4 Integer iSgmnt5 Integer iSgmnt6 Integer iSgmnt7 Integer iSgmnt8 Integer iSgmnt9 Integer iSgmnt10 Returns Boolean
93990>>>>>>>        Integer iTableNo iSegment1 iSegment2 iSegment3 iSegment4 iSegment5 iSegment6 iSegment7 iSegment8 iSegment9 iSegment10  iIndexSegments
93990>>>>>>>        String sDriverID
93990>>>>>>>        Boolean bOK bExists bIsMertechDriver bIsSQLTable
93990>>>>>>>
93990>>>>>>>        Get AutoConnectionIDLogin to bOK
93991>>>>>>>        Get OpenTableExclusive hTable to bOK
93992>>>>>>>        If (bOK = False) Begin
93994>>>>>>>            Function_Return False
93995>>>>>>>        End
93995>>>>>>>>
93995>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
93998>>>>>>>
93998>>>>>>>            Get UtilTableIsSQL hTable to bIsSQLTable
93999>>>>>>>            If (bIsSQLTable = True) Begin
94001>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
94004>>>>>>>            End
94004>>>>>>>>
94004>>>>>>>
94004>>>>>>>            Get IsMertechDriver sDriverID to bIsMertechDriver
94005>>>>>>>            If (bIsMertechDriver = True) Begin
94007>>>>>>>                Get_Attribute DF_INDEX_NATIVE_CREATED of hTable iIndex to bExists
94010>>>>>>>            End
94010>>>>>>>>
94010>>>>>>>            Else Begin
94011>>>>>>>                Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iIndexSegments
94014>>>>>>>                Move (iIndexSegments > 0) to bExists
94015>>>>>>>            End
94015>>>>>>>>
94015>>>>>>>        If (bExists = True) Begin
94017>>>>>>>            Function_Return True
94018>>>>>>>        End
94018>>>>>>>>
94018>>>>>>>
94018>>>>>>>        Move -1 to iSegment1
94019>>>>>>>        Move -1 to iSegment2
94020>>>>>>>        Move -1 to iSegment3
94021>>>>>>>        Move -1 to iSegment4
94022>>>>>>>        Move -1 to iSegment5
94023>>>>>>>        Move -1 to iSegment6
94024>>>>>>>        Move -1 to iSegment7
94025>>>>>>>        Move -1 to iSegment8
94026>>>>>>>        Move -1 to iSegment9
94027>>>>>>>        Move -1 to iSegment10
94028>>>>>>>
94028>>>>>>>        If (num_arguments > 3) Begin
94030>>>>>>>            Move iSgmnt1 to iSegment1
94031>>>>>>>        End
94031>>>>>>>>
94031>>>>>>>        If (num_arguments > 4) Begin
94033>>>>>>>            Move iSgmnt2 to iSegment2
94034>>>>>>>        End
94034>>>>>>>>
94034>>>>>>>        If (num_arguments > 5) Begin
94036>>>>>>>            Move iSgmnt3 to iSegment3
94037>>>>>>>        End
94037>>>>>>>>
94037>>>>>>>        If (num_arguments > 6) Begin
94039>>>>>>>            Move iSgmnt4 to iSegment4
94040>>>>>>>        End
94040>>>>>>>>
94040>>>>>>>        If (num_arguments > 7) Begin
94042>>>>>>>            Move iSgmnt5 to iSegment5
94043>>>>>>>        End
94043>>>>>>>>
94043>>>>>>>        If (num_arguments > 8) Begin
94045>>>>>>>            Move iSgmnt6 to iSegment6
94046>>>>>>>        End
94046>>>>>>>>
94046>>>>>>>        If (num_arguments > 9) Begin
94048>>>>>>>            Move iSgmnt7 to iSegment7
94049>>>>>>>        End
94049>>>>>>>>
94049>>>>>>>        If (num_arguments > 10) Begin
94051>>>>>>>            Move iSgmnt8 to iSegment8
94052>>>>>>>        End
94052>>>>>>>>
94052>>>>>>>        If (num_arguments > 11) Begin
94054>>>>>>>            Move iSgmnt9 to iSegment9
94055>>>>>>>        End
94055>>>>>>>>
94055>>>>>>>        If (num_arguments > 12) Begin
94057>>>>>>>            Move iSgmnt10 to iSegment10
94058>>>>>>>        End
94058>>>>>>>>
94058>>>>>>>
94058>>>>>>>        Move False to Err
94059>>>>>>>        Move hTable to iTableNo
94060>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
94061>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
94062>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_NON_FATAL_RESTRUCTURE_ERROR
94063>>>>>>>
94063>>>>>>>        // We start by deleting the index, if it exists.
94063>>>>>>>        If (bExists = True) Begin
94065>>>>>>>            Structure_Start hTable sDriverID
94066>>>>>>>                Delete_Index iTableNo iIndex
94067>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
94068>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
94070>>>>>>>        End
94070>>>>>>>>
94070>>>>>>>
94070>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
94071>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
94072>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_NON_FATAL_RESTRUCTURE_ERROR
94073>>>>>>>        Set Action_Text of ghoStatusPanel to ""
94074>>>>>>>        Move False to Err
94075>>>>>>>        Move 0 to LastErr
94076>>>>>>>
94076>>>>>>>        // Need to re-open if index deleted.
94076>>>>>>>        Move iTableNo to hTable
94077>>>>>>>        Get OpenTableExclusive hTable to bOK
94078>>>>>>>        If (bOK = False) Begin
94080>>>>>>>            Function_Return False
94081>>>>>>>        End
94081>>>>>>>>
94081>>>>>>>
94081>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
94082>>>>>>>        Structure_Start hTable sDriverID
94083>>>>>>>            Create_Index hTable At iIndex
94084>>>>>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iSegments
94087>>>>>>>
94087>>>>>>>            If (iSgmnt1 <> -1) Begin
94089>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 1 to iSegment1
94092>>>>>>>            End
94092>>>>>>>>
94092>>>>>>>            If (iSegment2 <> -1) Begin
94094>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 2 to iSegment2
94097>>>>>>>            End
94097>>>>>>>>
94097>>>>>>>            If (iSegment3 <> -1) Begin
94099>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 3 to iSegment3
94102>>>>>>>            End
94102>>>>>>>>
94102>>>>>>>            If (iSegment4 <> -1) Begin
94104>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 4 to iSegment4
94107>>>>>>>            End
94107>>>>>>>>
94107>>>>>>>            If (iSegment5 <> -1) Begin
94109>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 5 to iSegment5
94112>>>>>>>            End
94112>>>>>>>>
94112>>>>>>>            If (iSegment6 <> -1) Begin
94114>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 6 to iSegment6
94117>>>>>>>            End
94117>>>>>>>>
94117>>>>>>>            If (iSegment7 <> -1) Begin
94119>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 7 to iSegment7
94122>>>>>>>            End
94122>>>>>>>>
94122>>>>>>>            If (iSegment8 <> -1) Begin
94124>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 8 to iSegment8
94127>>>>>>>            End
94127>>>>>>>>
94127>>>>>>>            If (iSegment9 <> -1) Begin
94129>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 9 to iSegment9
94132>>>>>>>            End
94132>>>>>>>>
94132>>>>>>>            If (iSegment10 <> -1) Begin
94134>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 10 to iSegment10
94137>>>>>>>            End
94137>>>>>>>>
94137>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
94138>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
94140>>>>>>>
94140>>>>>>>        Set Action_Text of ghoStatusPanel to ""
94141>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
94142>>>>>>>
94142>>>>>>>        Function_Return (Err = False)
94143>>>>>>>    End_Function
94144>>>>>>>
94144>>>>>>>    // Example:
94144>>>>>>>    // Get ApiIndexCreateEx hTable 1 (StrSplitToArray("1,5,6,7,8,2,3,4,10,9,11", ",")) to bOk
94144>>>>>>>    // Note: The StrSplitToArray function was introduced with DataFlex 18.2
94144>>>>>>>    Function ApiIndexCreateEx Handle hTable Integer iIndex Integer[] iSgmnts Returns Boolean
94146>>>>>>>        Integer iTableNo iNumSgmnt iNumSgmnts
94146>>>>>>>        String sDriverID
94146>>>>>>>        Boolean bOK bIsSQLTable
94146>>>>>>>
94146>>>>>>>        Get AutoConnectionIDLogin to bOK
94147>>>>>>>
94147>>>>>>>        Move False to Err
94148>>>>>>>        Move hTable to iTableNo
94149>>>>>>>        Get OpenTableExclusive hTable to bOK
94150>>>>>>>        If (bOK = False) Begin
94152>>>>>>>            Function_Return False
94153>>>>>>>        End
94153>>>>>>>>
94153>>>>>>>
94153>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
94156>>>>>>>            Get UtilTableIsSQL hTable to bIsSQLTable
94157>>>>>>>            If (bIsSQLTable = True) Begin
94159>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
94162>>>>>>>            End
94162>>>>>>>>
94162>>>>>>>
94162>>>>>>>        // We start by deleting the index
94162>>>>>>>        Structure_Start hTable sDriverID
94163>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
94164>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
94165>>>>>>>            Delete_Index iTableNo iIndex
94166>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
94167>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
94168>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
94170>>>>>>>
94170>>>>>>>        Move False to Err
94171>>>>>>>        Move iTableNo to hTable
94172>>>>>>>        Get OpenTableExclusive hTable to bOK
94173>>>>>>>        If (bOK = False) Begin
94175>>>>>>>            Function_Return False
94176>>>>>>>        End
94176>>>>>>>>
94176>>>>>>>
94176>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
94177>>>>>>>        Structure_Start hTable sDriverID
94178>>>>>>>            Move (SizeOfArray(iSgmnts)) to iNumSgmnts
94179>>>>>>>
94179>>>>>>>            Create_Index hTable at iIndex
94180>>>>>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSgmnts
94183>>>>>>>
94183>>>>>>>            for iNumSgmnt from 0 to (iNumSgmnts - 1)
94189>>>>>>>>
94189>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex (iNumSgmnt + 1) to iSgmnts[iNumSgmnt]
94192>>>>>>>            Loop
94193>>>>>>>>
94193>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
94195>>>>>>>
94195>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
94196>>>>>>>
94196>>>>>>>        Function_Return (Err = False)
94197>>>>>>>    End_Function
94198>>>>>>>
94198>>>>>>>    Function APIIndexCreateByFieldNames Handle hTable tAPIIndex APIIndex tAPIIndex[] APIIndexTo tAPIIndexSegment[] aIndexSegments Returns Boolean
94200>>>>>>>        Integer iCount iSegmentsFrom iFieldFrom iSegmentsTo iSQLIndexType iTableNo
94200>>>>>>>        String sDriverID sSQLIndexName
94200>>>>>>>        Boolean bOK bIsSQLTable bIsOpen bIsSQLPrimaryKey bIsSQLClustered bIsSQLTemporaryIndex bExists
94200>>>>>>>
94200>>>>>>>        Move (SizeOfArray(aIndexSegments)) to iSegmentsFrom
94201>>>>>>>        If (iSegmentsFrom = 0) Begin
94203>>>>>>>            Function_Return False
94204>>>>>>>        End
94204>>>>>>>>
94204>>>>>>>
94204>>>>>>>        Get AutoConnectionIDLogin to bOK
94205>>>>>>>        Move False to Err
94206>>>>>>>        Get OpenTableExclusive hTable to bIsOpen
94207>>>>>>>        If (bIsOpen = False) Begin
94209>>>>>>>            Function_Return False
94210>>>>>>>        End
94210>>>>>>>>
94210>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
94213>>>>>>>        Get UtilTableIsSql hTable to bIsSQLTable
94214>>>>>>>            If (bIsSQLTable = True) Begin
94216>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
94219>>>>>>>            End
94219>>>>>>>>
94219>>>>>>>
94219>>>>>>>        Move 0     to iSegmentsTo
94220>>>>>>>        Move 0     to iSQLIndexType
94221>>>>>>>        Move ""    to sSQLIndexName
94222>>>>>>>        Move False to bIsSQLTemporaryIndex
94223>>>>>>>        Move False to bIsSQLPrimaryKey
94224>>>>>>>        Move False to bIsSQLClustered
94225>>>>>>>
94225>>>>>>>            Get UtilIndexTempRenameSQLName hTable APIIndex.sSQLIndexName sDriverID          to bOK
94226>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber              to iSegmentsTo
94229>>>>>>>        Move (iSegmentsTo > 0) to bExists
94230>>>>>>>        If (bExists = True) Begin
94232>>>>>>>            If (bIsSQLTable = True and iSegmentsTo > 0) Begin
94234>>>>>>>                Get_Attribute DF_INDEX_NAME of hTable APIIndex.iIndexNumber                 to sSQLIndexName
94237>>>>>>>                    Get_Attribute DF_INDEX_SQL_TYPE of hTable APIIndex.iIndexNumber         to iSQLIndexType
94240>>>>>>>                    Move (iSQLIndexType = DF_INDEX_TEMPORARY)                               to bIsSQLTemporaryIndex
94241>>>>>>>                    Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex.iIndexNumber  to bIsSQLPrimaryKey
94244>>>>>>>                    Get_Attribute DF_INDEX_CLUSTERED       of hTable APIIndex.iIndexNumber  to bIsSQLClustered
94247>>>>>>>            End
94247>>>>>>>>
94247>>>>>>>        End
94247>>>>>>>>
94247>>>>>>>
94247>>>>>>>        Move hTable to iTableNo
94248>>>>>>>        Move False to Err
94249>>>>>>>        Move 0 to LastErr
94250>>>>>>>
94250>>>>>>>        // Note: If the SQL index type = DF_INDEX_TEMPORARY, we _must_ set the DF_INDEX_SQL_TYPE
94250>>>>>>>        //       _outside_ the Structure_Start/End construct.
94250>>>>>>>//        Move False to bIsSQLTemporaryIndex
94250>>>>>>>//        #IF (!@ > 170)
94250>>>>>>>//            If (bIsSQLTemporaryIndex = True and APIIndex.iIndexNumber <= iLastIndex) Begin
94250>>>>>>>//                If (APIIndex.iSQLIndexType <> iSQLIndexType) Begin
94250>>>>>>>//                    Set_Attribute DF_INDEX_SQL_TYPE of hTable APIIndex.iIndexNumber to APIIndex.iSQLIndexType // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
94250>>>>>>>//                End
94250>>>>>>>//            End
94250>>>>>>>//        #ENDIF
94250>>>>>>>
94250>>>>>>>        Structure_Start hTable sDriverID
94251>>>>>>>            If (bExists = True) Begin
94253>>>>>>>                Delete_Index iTableNo APIIndex.iIndexNumber
94254>>>>>>>            End
94254>>>>>>>>
94254>>>>>>>
94254>>>>>>>            Create_Index hTable At APIIndex.iIndexNumber
94255>>>>>>>
94255>>>>>>>            If (bIsSQLTable = True) Begin // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
94257>>>>>>>                Set_Attribute DF_INDEX_SQL_TYPE        of hTable APIIndex.iIndexNumber to APIIndex.iSQLIndexType
94260>>>>>>>                Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex.iIndexNumber to APIIndex.bIsSQLPrimaryKey
94263>>>>>>>                Set_Attribute DF_INDEX_CLUSTERED       of hTable APIIndex.iIndexNumber to APIIndex.bIsSQLClustered
94266>>>>>>>                Set_Attribute DF_INDEX_NAME            of hTable APIIndex.iIndexNumber to APIIndex.sSQLIndexName
94269>>>>>>>            End
94269>>>>>>>>
94269>>>>>>>
94269>>>>>>>                    Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber to iSegmentsFrom
94272>>>>>>>
94272>>>>>>>            for iCount from 0 to (iSegmentsFrom -1)
94278>>>>>>>>
94278>>>>>>>                Move aIndexSegments[iCount].iFieldNumber to iFieldFrom
94279>>>>>>>                If (iFieldFrom <> -1 ) Begin
94281>>>>>>>                        Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable APIIndex.iIndexNumber (iCount +1) to iFieldFrom
94284>>>>>>>                        Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable APIIndex.iIndexNumber (iCount +1) to aIndexSegments[iCount].bAscending
94287>>>>>>>                        Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable APIIndex.iIndexNumber (iCount +1) to aIndexSegments[iCount].bUppercase
94290>>>>>>>                End
94290>>>>>>>>
94290>>>>>>>            Loop
94291>>>>>>>>
94291>>>>>>>
94291>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
94292>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
94294>>>>>>>
94294>>>>>>>        Set Action_Text of ghoStatusPanel to ""
94295>>>>>>>
94295>>>>>>>        Function_Return (Err = False)
94296>>>>>>>    End_Function
94297>>>>>>>
94297>>>>>>>    // If an SQL index is to be renamed we need to check that the name doesn't exist already, but
94297>>>>>>>    // with another index number. If we find one we temporarily renames it by adding "TMP" to the SQL name.
94297>>>>>>>    Function UtilIndexTempRenameSQLName Handle hTable String sSQLIndexName String sDriverID Returns Boolean
94299>>>>>>>        Integer iLastIndex iCount iTableNo iSegments
94299>>>>>>>        String sSQLIndexNameCompare sTmpIndexName
94299>>>>>>>        Boolean bIsOpen bExists bIsSQLDriver bIsMertechDriver
94299>>>>>>>
94299>>>>>>>        // The Mertech drivers DF_INDEX_NAME property is read_only,
94299>>>>>>>        // so we can then not rename the index.
94299>>>>>>>        Get IsMertechDriver sDriverID to bIsMertechDriver
94300>>>>>>>        If (bIsMertechDriver = True) Begin
94302>>>>>>>            Function_Return False
94303>>>>>>>        End    
94303>>>>>>>>
94303>>>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
94304>>>>>>>        
94304>>>>>>>        If (bIsSQLDriver = False) Begin
94306>>>>>>>            Function_Return False
94307>>>>>>>        End
94307>>>>>>>>
94307>>>>>>>
94307>>>>>>>        Move False to Err
94308>>>>>>>        Move hTable to iTableNo
94309>>>>>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
94312>>>>>>>        for iCount from 0 to iLastIndex
94318>>>>>>>>
94318>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iCount to iSegments
94321>>>>>>>            Move (iSegments > 0) to bExists
94322>>>>>>>            If (bExists = True) Begin
94324>>>>>>>                Get_Attribute DF_INDEX_NAME of hTable iCount to sSQLIndexNameCompare
94327>>>>>>>                If (Lowercase(sSQLIndexName) = Lowercase(sSQLIndexNameCompare)) Begin
94329>>>>>>>                    Move (sSQLIndexNameCompare + String("_TMP")) to sTmpIndexName
94330>>>>>>>                    Structure_Start iTableNo sDriverID
94331>>>>>>>                        Set_Attribute DF_INDEX_NAME of iTableNo iCount to sTmpIndexName
94334>>>>>>>                    Structure_End iTableNo DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
94336>>>>>>>                    Open hTable
94338>>>>>>>                End
94338>>>>>>>>
94338>>>>>>>            End
94338>>>>>>>>
94338>>>>>>>        Loop
94339>>>>>>>>
94339>>>>>>>
94339>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
94342>>>>>>>        If (bIsOpen = False) Begin
94344>>>>>>>            Get OpenTableExclusive hTable to bIsOpen
94345>>>>>>>        End
94345>>>>>>>>
94345>>>>>>>        If (bIsOpen = False) Begin
94347>>>>>>>            Function_Return False
94348>>>>>>>        End
94348>>>>>>>>
94348>>>>>>>
94348>>>>>>>        Function_Return (Err = False)
94349>>>>>>>    End_Function
94350>>>>>>>
94350>>>>>>>    // Checks if an SQL Index name for the "FROM" database already exists in the TO database,
94350>>>>>>>    // but with another Index number. We can then not rename the SQL index name for the TO database table.
94350>>>>>>>    Function UtilIndexSQLIndexNameExists Handle hTable Integer iIndexNumberFrom String sSQLIndexNameFrom tAPIIndex[] APIIndexTo Returns Integer
94352>>>>>>>        Integer iSize iCount
94352>>>>>>>        Integer iRetVal
94352>>>>>>>
94352>>>>>>>        Move 0 to iRetVal
94353>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndexNumberFrom to iRetVal
94356>>>>>>>        If (iRetVal = 0) Begin
94358>>>>>>>            Function_Return 0
94359>>>>>>>        End
94359>>>>>>>>
94359>>>>>>>        Move (SizeOfArray(APIIndexTo)) to iSize
94360>>>>>>>        Decrement iSize
94361>>>>>>>        for iCount from 0 to iSize
94367>>>>>>>>
94367>>>>>>>            If (Uppercase(sSQLIndexNameFrom) = Uppercase(APIIndexTo[iCount].sSQLIndexName)) Begin
94369>>>>>>>                If (iIndexNumberFrom <> APIIndexTo[iCount].iIndexNumber) Begin
94371>>>>>>>                    Move APIIndexTo[iCount].iIndexNumber to iRetVal
94372>>>>>>>                End
94372>>>>>>>>
94372>>>>>>>            End
94372>>>>>>>>
94372>>>>>>>        Loop
94373>>>>>>>>
94373>>>>>>>
94373>>>>>>>        Function_Return iRetVal
94374>>>>>>>    End_Function
94375>>>>>>>
94375>>>>>>>    Function ApiIndexDeleteSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
94377>>>>>>>        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
94377>>>>>>>        Boolean bIsSQLTable
94377>>>>>>>        
94377>>>>>>>            Get UtilTableIsSQL hTable to bIsSQLTable
94378>>>>>>>            If (bIsSQLTable = True) Begin
94380>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
94383>>>>>>>            End
94383>>>>>>>>
94383>>>>>>>
94383>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
94386>>>>>>>        If (iSegment = iNumSegments) Begin
94388>>>>>>>//            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
94388>>>>>>>        End
94388>>>>>>>>
94388>>>>>>>
94388>>>>>>>        Else If (iSegment > 0 and iSegment < iNumSegments) Begin
94391>>>>>>>            for iCurSegment from iSegment to (iNumSegments - 1)
94397>>>>>>>>
94397>>>>>>>                //*** Move index segment attributes
94397>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
94400>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
94403>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
94406>>>>>>>
94406>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment to iSegmentCase
94409>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment to iSegmentDirection
94412>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment to iSegmentColumn
94415>>>>>>>            Loop
94416>>>>>>>>
94416>>>>>>>
94416>>>>>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
94419>>>>>>>        End
94419>>>>>>>>
94419>>>>>>>
94419>>>>>>>        Function_Return (Err = False)
94420>>>>>>>    End_Function
94421>>>>>>>
94421>>>>>>>    Function APIIndexRemoveAllIndexes Handle hTable tAPIIndex[] APIIndex Returns Boolean
94423>>>>>>>        Integer iCount iSize iIndex
94423>>>>>>>        String sDriverID
94423>>>>>>>        Boolean bOK bIsSQLTable bIsOpen
94423>>>>>>>
94423>>>>>>>        Move (SizeOfArray(APIIndex)) to iSize
94424>>>>>>>        If (iSize = 0) Begin
94426>>>>>>>            Function_Return True
94427>>>>>>>        End
94427>>>>>>>>
94427>>>>>>>
94427>>>>>>>        Get AutoConnectionIDLogin to bOK
94428>>>>>>>        Move False to Err
94429>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
94432>>>>>>>        If (bIsOpen = False) Begin
94434>>>>>>>            Get OpenTableExclusive hTable to bIsOpen
94435>>>>>>>            If (bIsOpen = False) Begin
94437>>>>>>>                Function_Return False
94438>>>>>>>            End
94438>>>>>>>>
94438>>>>>>>        End
94438>>>>>>>>
94438>>>>>>>
94438>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
94441>>>>>>>        Get UtilTableIsSql hTable to bIsSQLTable
94442>>>>>>>            If (bIsSQLTable = True) Begin
94444>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
94447>>>>>>>            End
94447>>>>>>>>
94447>>>>>>>
94447>>>>>>>        Move False to Err
94448>>>>>>>        Move 0 to LastErr
94449>>>>>>>        Decrement iSize
94450>>>>>>>
94450>>>>>>>        Structure_Start hTable sDriverID
94451>>>>>>>            for iCount from 0 to iSize
94457>>>>>>>>
94457>>>>>>>//                Move False to bIsSQLPrimaryKey
94457>>>>>>>//                #IF (!@ > 180)   // DF 18.1 and up
94457>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_NO_REPORT
94457>>>>>>>//                    Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex[iCount].iIndexNumber to bIsSQLPrimaryKey
94457>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
94457>>>>>>>//                #ENDIF
94457>>>>>>>                // We can't delete if this is a primary key index:
94457>>>>>>>//                If (bIsSQLPrimaryKey = False) Begin
94457>>>>>>>                    Move APIIndex[iCount].iIndexNumber to iIndex
94458>>>>>>>                    Delete_Index hTable iIndex
94459>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
94459>>>>>>>//                End
94459>>>>>>>            Loop
94460>>>>>>>>
94460>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
94461>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
94463>>>>>>>//        Move False to Err
94463>>>>>>>        Move 0 to LastErr
94464>>>>>>>
94464>>>>>>>        Set Action_Text of ghoStatusPanel to ""
94465>>>>>>>        Function_Return (Err = False)
94466>>>>>>>    End_Function
94467>>>>>>>
94467>>>>>>>    Function ApiIndexChangeDirection Handle hTable Integer iIndex Integer iSegment Integer iDirection Returns Boolean
94469>>>>>>>        Boolean bOK
94469>>>>>>>
94469>>>>>>>        Get AutoConnectionIDLogin to bOK
94470>>>>>>>        Move False to Err
94471>>>>>>>        Get OpenTableExclusive hTable to bOK
94472>>>>>>>        If (bOK = False) Begin
94474>>>>>>>            Function_Return False
94475>>>>>>>        End
94475>>>>>>>>
94475>>>>>>>        Structure_Start hTable
94476>>>>>>>            Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to iDirection
94479>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
94480>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
94482>>>>>>>
94482>>>>>>>        Set Action_Text of ghoStatusPanel to ""
94483>>>>>>>        Function_Return (Err = False)
94484>>>>>>>    End_Function
94485>>>>>>>
94485>>>>>>>    Function ApiIndexChangeUppercase Handle hTable Integer iIndex Integer iSegment Boolean bUppercase Returns Boolean
94487>>>>>>>        Integer iCase
94487>>>>>>>        Boolean bOK
94487>>>>>>>
94487>>>>>>>        If (bUppercase = True) Begin
94489>>>>>>>            Move DF_CASE_IGNORED to iCase
94490>>>>>>>        End
94490>>>>>>>>
94490>>>>>>>        Else Begin
94491>>>>>>>            Move DF_CASE_USED to iCase
94492>>>>>>>        End
94492>>>>>>>>
94492>>>>>>>
94492>>>>>>>        Get AutoConnectionIDLogin to bOK
94493>>>>>>>        Move False to Err
94494>>>>>>>        Get OpenTableExclusive hTable to bOK
94495>>>>>>>        If (bOK = False) Begin
94497>>>>>>>            Function_Return False
94498>>>>>>>        End
94498>>>>>>>>
94498>>>>>>>        Structure_Start hTable
94499>>>>>>>            Set_Attribute DF_INDEX_SEGMENT_CASE of hTable iIndex iSegment to iCase
94502>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
94503>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
94505>>>>>>>
94505>>>>>>>        Set Action_Text of ghoStatusPanel to ""
94506>>>>>>>        Function_Return (Err = False)
94507>>>>>>>    End_Function
94508>>>>>>>
94508>>>>>>>    // To delete an index
94508>>>>>>>    Function ApiIndexRemove Handle hTable Integer iIndex Returns Boolean
94510>>>>>>>        Integer iTableNo iNumSegments
94510>>>>>>>        String sDriverID
94510>>>>>>>        Boolean bOK bIsSQLTable
94510>>>>>>>
94510>>>>>>>        Get AutoConnectionIDLogin to bOK
94511>>>>>>>        Move False to Err
94512>>>>>>>        Move hTable to iTableNo
94513>>>>>>>        Get OpenTableExclusive hTable to bOK
94514>>>>>>>        If (bOK = False) Begin
94516>>>>>>>            Function_Return False
94517>>>>>>>        End
94517>>>>>>>>
94517>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
94520>>>>>>>            Get UtilTableIsSQL hTable to bIsSQLTable
94521>>>>>>>            If (bIsSQLTable = True) Begin
94523>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
94526>>>>>>>            End
94526>>>>>>>>
94526>>>>>>>
94526>>>>>>>        // Check to see if the index exists or not...
94526>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
94529>>>>>>>        If (iNumSegments = 0) Begin
94531>>>>>>>            Function_Return True // Then nothing to do.
94532>>>>>>>        End
94532>>>>>>>>
94532>>>>>>>
94532>>>>>>>        Structure_Start hTable sDriverID
94533>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
94534>>>>>>>            Delete_Index iTableNo iIndex
94535>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
94536>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
94537>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
94539>>>>>>>
94539>>>>>>>        Set Action_Text of ghoStatusPanel to ""
94540>>>>>>>        Function_Return (Err = False)
94541>>>>>>>    End_Function
94542>>>>>>>
94542>>>>>>>    // Delete an Index Segment
94542>>>>>>>    Function ApiIndexRemoveSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
94544>>>>>>>        Boolean bOK bSQLDriver bIndexTemporary bIsSQLTable
94544>>>>>>>        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
94544>>>>>>>        Integer iIndexType
94544>>>>>>>        String sDriverID
94544>>>>>>>
94544>>>>>>>        Get AutoConnectionIDLogin to bOK
94545>>>>>>>        Move False to Err
94546>>>>>>>
94546>>>>>>>        Get OpenTableExclusive hTable to bOK
94547>>>>>>>        If (bOK = False) Begin
94549>>>>>>>            Function_Return False
94550>>>>>>>        End
94550>>>>>>>>
94550>>>>>>>
94550>>>>>>>            Get UtilTableIsSQL hTable to bIsSQLTable
94551>>>>>>>            If (bIsSQLTable = True) Begin
94553>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
94556>>>>>>>            End
94556>>>>>>>>
94556>>>>>>>
94556>>>>>>>        // Check to see if the index exists or not...
94556>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
94559>>>>>>>        If (iNumSegments = 0) Begin
94561>>>>>>>            Function_Return False
94562>>>>>>>        End
94562>>>>>>>>
94562>>>>>>>
94562>>>>>>>        Move False to bIndexTemporary
94563>>>>>>>        Get psDriverID to sDriverID
94564>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
94565>>>>>>>        If (bSQLDriver) Begin
94567>>>>>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
94570>>>>>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
94573>>>>>>>                Move True to bIndexTemporary
94574>>>>>>>        End
94574>>>>>>>>
94574>>>>>>>
94574>>>>>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
94574>>>>>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
94576>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
94579>>>>>>>            If (iSegment = iNumSegments) Begin
94581>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
94584>>>>>>>            End
94584>>>>>>>>
94584>>>>>>>            Else If (iSegment > 0 and iSegment < iNumSegments) Begin
94587>>>>>>>                For iCurSegment from iSegment to (iNumSegments - 1)
94593>>>>>>>>
94593>>>>>>>                    //*** Move index segment attributes
94593>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
94596>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
94599>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
94602>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
94605>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
94608>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
94611>>>>>>>                Loop
94612>>>>>>>>
94612>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
94615>>>>>>>            End
94615>>>>>>>>
94615>>>>>>>        End
94615>>>>>>>>
94615>>>>>>>
94615>>>>>>>        Else Begin
94616>>>>>>>           Structure_Start hTable
94617>>>>>>>               Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
94620>>>>>>>               If (iSegment = iNumSegments) Begin
94622>>>>>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
94625>>>>>>>               End
94625>>>>>>>>
94625>>>>>>>               Else If (iSegment > 0 and iSegment < iNumSegments) Begin
94628>>>>>>>                   for iCurSegment from iSegment to (iNumSegments - 1)
94634>>>>>>>>
94634>>>>>>>                       //*** Move index segment attributes
94634>>>>>>>                       Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
94637>>>>>>>                       Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
94640>>>>>>>                       Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
94643>>>>>>>                       Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
94646>>>>>>>                       Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
94649>>>>>>>                       Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
94652>>>>>>>                   Loop
94653>>>>>>>>
94653>>>>>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
94656>>>>>>>               End
94656>>>>>>>>
94656>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
94657>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
94659>>>>>>>            Set Action_Text of ghoStatusPanel to ""
94660>>>>>>>        End
94660>>>>>>>>
94660>>>>>>>
94660>>>>>>>        Function_Return (Err = False)
94661>>>>>>>    End_Function
94662>>>>>>>
94662>>>>>>>    // Add/Insert an Index Segment
94662>>>>>>>    Function ApiIndexInsertSegment Handle hTable Integer iIndex Integer iSegment Integer iSegmentColumn Integer iSegmentCase Integer iSegmentDirection Returns Boolean
94664>>>>>>>        Boolean bOK bSQLDriver bIndexTemporary bIsSQLTable
94664>>>>>>>        Integer iNumSegments iCurSegment iCurSegmentColumn iCurSegmentCase iCurSegmentDirection
94664>>>>>>>        Integer iIndexType
94664>>>>>>>        String sDriverId
94664>>>>>>>
94664>>>>>>>        Get AutoConnectionIDLogin to bOK
94665>>>>>>>        Move False to Err
94666>>>>>>>
94666>>>>>>>        Get OpenTableExclusive hTable to bOK
94667>>>>>>>        If (bOK = False) Begin
94669>>>>>>>            Function_Return False
94670>>>>>>>        End
94670>>>>>>>>
94670>>>>>>>
94670>>>>>>>            Get UtilTableIsSQL hTable to bIsSQLTable
94671>>>>>>>            If (bIsSQLTable = True) Begin
94673>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
94676>>>>>>>            End
94676>>>>>>>>
94676>>>>>>>
94676>>>>>>>        Move False to bIndexTemporary
94677>>>>>>>        // Check to see if the index exists or not...
94677>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
94680>>>>>>>        If (iNumSegments = 0) Begin
94682>>>>>>>            Function_Return False
94683>>>>>>>        End
94683>>>>>>>>
94683>>>>>>>
94683>>>>>>>        Get psDriverID to sDriverID
94684>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
94685>>>>>>>        If (bSQLDriver) Begin
94687>>>>>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
94690>>>>>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
94693>>>>>>>                Move True to bIndexTemporary
94694>>>>>>>        End
94694>>>>>>>>
94694>>>>>>>
94694>>>>>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
94694>>>>>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
94696>>>>>>>           Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
94699>>>>>>>
94699>>>>>>>           If (iSegment > iNumSegments) Begin
94701>>>>>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
94704>>>>>>>               Move (iNumSegments + 1) to iCurSegment
94705>>>>>>>           End
94705>>>>>>>>
94705>>>>>>>           Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
94708>>>>>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
94711>>>>>>>               Move iNumSegments to iCurSegment
94712>>>>>>>
94712>>>>>>>               While (iCurSegment > iSegment)
94716>>>>>>>                   //*** Move index segment attributes
94716>>>>>>>                   Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iCurSegmentCase
94719>>>>>>>                   Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iCurSegmentDirection
94722>>>>>>>                   Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
94725>>>>>>>                   Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iCurSegmentCase
94728>>>>>>>                   Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iCurSegmentDirection
94731>>>>>>>                   Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iCurSegmentColumn
94734>>>>>>>                   Decrement iCurSegment
94735>>>>>>>               Loop
94736>>>>>>>>
94736>>>>>>>
94736>>>>>>>               //*** Now set new segment attributes
94736>>>>>>>               Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
94739>>>>>>>               Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
94742>>>>>>>               Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
94745>>>>>>>           End
94745>>>>>>>>
94745>>>>>>>        End
94745>>>>>>>>
94745>>>>>>>
94745>>>>>>>        Else Begin
94746>>>>>>>        Structure_Start hTable
94747>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
94750>>>>>>>
94750>>>>>>>            If (iSegment > iNumSegments) Begin
94752>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
94755>>>>>>>                Move (iNumSegments + 1) to iCurSegment
94756>>>>>>>            End
94756>>>>>>>>
94756>>>>>>>            Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
94759>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
94762>>>>>>>                Move iNumSegments to iCurSegment
94763>>>>>>>
94763>>>>>>>                While (iCurSegment > iSegment)
94767>>>>>>>                    //*** Move index segment attributes
94767>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iSegmentCase
94770>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iSegmentDirection
94773>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
94776>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
94779>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
94782>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
94785>>>>>>>                    Decrement iCurSegment
94786>>>>>>>                Loop
94787>>>>>>>>
94787>>>>>>>
94787>>>>>>>                //*** Now set new segment attributes
94787>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
94790>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
94793>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
94796>>>>>>>            End
94796>>>>>>>>
94796>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
94797>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
94799>>>>>>>            Set Action_Text of ghoStatusPanel to ""
94800>>>>>>>        End
94800>>>>>>>>
94800>>>>>>>
94800>>>>>>>        Function_Return (Err = False)
94801>>>>>>>    End_Function
94802>>>>>>>
94802>>>>>>>    // * Dummy function for the Studio's Code Explorer *
94802>>>>>>>    Function TABLE_UTILITY_FUNCTIONS Returns Boolean
94804>>>>>>>        Function_Return False
94805>>>>>>>    End_Function  
94806>>>>>>>    
94806>>>>>>>    // Preparation message before an SQL onversion. It will check and wash all embedded data tables and prepare them
94806>>>>>>>    // for an SQL conversion.
94806>>>>>>>    Function UtilPrepareDataFolderForSQLConversion Boolean bMoveMiscFilesToBackup Boolean bFixALLBogusFilelistEntries Boolean bConvertTo30Format Boolean bRepairAndReindex Boolean bFixBogusDates Returns Boolean
94808>>>>>>>        Boolean bConvertTo30FormatbOK bRepairAndReindexOK bFixBogusDatesOK bMoveMiscFilesToBackupOK
94808>>>>>>>        
94808>>>>>>>        Move True to bConvertTo30FormatbOK
94809>>>>>>>        Move True to bRepairAndReindexOK
94810>>>>>>>        Move True to bFixBogusDatesOK
94811>>>>>>>        Move True to bMoveMiscFilesToBackupOK
94812>>>>>>>        
94812>>>>>>>        If (bMoveMiscFilesToBackup = True) Begin   
94814>>>>>>>            Set Message_Text of ghoStatusPanel to "Moving misc. files to backup..."
94815>>>>>>>            Get UtilMoveMiscFilesToBackupFolder to bMoveMiscFilesToBackupOK
94816>>>>>>>        End                                                                                
94816>>>>>>>>
94816>>>>>>>        If (bFixALLBogusFilelistEntries = True) Begin
94818>>>>>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus Filelist.cfg entries..."
94819>>>>>>>            Get UtilTableFixALLBogusFilelistEntries to bFixALLBogusFilelistEntries
94820>>>>>>>        End
94820>>>>>>>>
94820>>>>>>>        If (bConvertTo30Format = True) Begin
94822>>>>>>>            Set Message_Text of ghoStatusPanel to "Converting .dat files from 2.3->..."
94823>>>>>>>            Get UtilTableConvertALLTablesFrom23Format to bConvertTo30FormatbOK
94824>>>>>>>        End                                                 
94824>>>>>>>>
94824>>>>>>>        If (bRepairAndReindex = True) Begin
94826>>>>>>>            Set Message_Text of ghoStatusPanel to "Repairing and reindexing..."
94827>>>>>>>            Get UtilTableRepairAndReindexALL to bRepairAndReindexOK
94828>>>>>>>        End  
94828>>>>>>>>
94828>>>>>>>        If (bFixBogusDates = True) Begin
94830>>>>>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus date values..."
94831>>>>>>>            Get UtilTablesFixAllDateBogusValues True False to bFixBogusDatesOK
94832>>>>>>>        End                                    
94832>>>>>>>>
94832>>>>>>>        
94832>>>>>>>        Function_Return (bConvertTo30FormatbOK = True and bFixALLBogusFilelistEntries = True and bRepairAndReindexOK = True and bFixBogusDatesOK = True and bMoveMiscFilesToBackupOK = True)
94833>>>>>>>    End_Function
94834>>>>>>>
94834>>>>>>>    Function UtilTableConvertALLTablesFrom23Format Returns Boolean
94836>>>>>>>        Boolean bOK bFlexErrs bTemp
94836>>>>>>>        Handle hTable
94836>>>>>>>        String sTableName
94836>>>>>>>        Integer iCount iSize
94836>>>>>>>        
94836>>>>>>>        Move True to bOK
94837>>>>>>>        Move 0 to hTable    
94838>>>>>>>
94838>>>>>>>        Get UtilFilelistNoOfTables to iSize
94839>>>>>>>        Set pbVisible    of ghoProgressBarOverall to True
94840>>>>>>>        Set piPosition   of ghoProgressBarOverall to 0
94841>>>>>>>        Set piMaximum    of ghoProgressBarOverall to iSize
94842>>>>>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
94843>>>>>>>
94843>>>>>>>        Repeat
94843>>>>>>>>
94843>>>>>>>            Set Action_Text of ghoStatusPanel to "Checking if table is in 2.3 format..."
94844>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount  
94845>>>>>>>            Increment iCount
94846>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
94849>>>>>>>            If (hTable > 0) Begin
94851>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
94854>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
94855>>>>>>>                If (bFlexErrs = False) Begin
94857>>>>>>>                    Get UtilTableConvertFrom23Format hTable to bTemp
94858>>>>>>>                    If (bTemp = False) Begin
94860>>>>>>>                        Move False to bOK
94861>>>>>>>                    End
94861>>>>>>>>
94861>>>>>>>                End
94861>>>>>>>>
94861>>>>>>>            End
94861>>>>>>>>
94861>>>>>>>        Until (hTable = 0)
94863>>>>>>>        
94863>>>>>>>        Set Action_Text of ghoStatusPanel to ""
94864>>>>>>>        Function_Return bOK
94865>>>>>>>    End_Function
94866>>>>>>>    
94866>>>>>>>    // Converts an embedded table from 2.3 -> 3.0.
94866>>>>>>>    // Returns: FALSE only if the table can't be opened or the conversion fails.
94866>>>>>>>    // It will return a TRUE if successful or the table is an SQL table.
94866>>>>>>>    Function UtilTableConvertFrom23Format Handle hTable Returns Boolean
94868>>>>>>>        Boolean bOK bIsEmbedded bIsAlias
94868>>>>>>>        String sRevision
94868>>>>>>>        
94868>>>>>>>        Get AutoConnectionIDLogin to bOK
94869>>>>>>>        If (bOK = False) Begin
94871>>>>>>>            Function_Return True
94872>>>>>>>        End
94872>>>>>>>>
94872>>>>>>>        Get OpenTableExclusive hTable to bOK
94873>>>>>>>        If (bOK = False) Begin
94875>>>>>>>            Function_Return True
94876>>>>>>>        End
94876>>>>>>>>
94876>>>>>>>        Get UtilTableIsEmbedded hTable to bIsEmbedded
94877>>>>>>>        If (bIsEmbedded = False) Begin
94879>>>>>>>            Function_Return True
94880>>>>>>>        End                             
94880>>>>>>>>
94880>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias
94881>>>>>>>        If (bIsAlias = True) Begin
94883>>>>>>>            Function_Return True
94884>>>>>>>        End                     
94884>>>>>>>>
94884>>>>>>>        
94884>>>>>>>        Move False to Err
94885>>>>>>>        Get_Attribute DF_FILE_REVISION of hTable to sRevision
94888>>>>>>>        If (sRevision contains "2.3") Begin
94890>>>>>>>            Move False to Err
94891>>>>>>>            Set Private.phCurrentTable to hTable
94892>>>>>>>            Structure_Start hTable    
94893>>>>>>>                Set_Attribute DF_FILE_INTEGRITY_CHECK of hTable to True
94896>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table to 3.0/4.0"
94897>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_FORCE "." ghoDbUpdateHandler
94899>>>>>>>            Set Action_Text of ghoStatusPanel to ""
94900>>>>>>>        End
94900>>>>>>>>
94900>>>>>>>        
94900>>>>>>>        Function_Return (Err = False)
94901>>>>>>>    End_Function
94902>>>>>>>
94902>>>>>>>    Function UtilTableFixALLBogusFilelistEntries Returns Boolean
94904>>>>>>>        Boolean bIgnore bExists bOK bResponse
94904>>>>>>>        Handle hTable   
94904>>>>>>>        String sTableName
94904>>>>>>>        
94904>>>>>>>        Move False to Err 
94905>>>>>>>        Move True to bOK
94906>>>>>>>        Move 0 to hTable
94907>>>>>>>        Repeat
94907>>>>>>>>
94907>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
94910>>>>>>>            If (hTable > 0) Begin
94912>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
94915>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS" or Uppercase(sTableName) = "CODETYPE" or Uppercase(sTableName) = "CODEMAST")  to bIgnore
94916>>>>>>>                If (bIgnore = False) Begin
94918>>>>>>>                    Get UtilTableExists hTable to bExists
94919>>>>>>>                    If (bExists = False) Begin
94921>>>>>>>                        Get ApiTableChangeFileListSlot "" "" "" hTable DATAFLEX_ID to bResponse
94922>>>>>>>                        If (bResponse = False) Begin
94924>>>>>>>                            Move False to bOK
94925>>>>>>>                        End
94925>>>>>>>>
94925>>>>>>>                        
94925>>>>>>>                    End
94925>>>>>>>>
94925>>>>>>>                End
94925>>>>>>>>
94925>>>>>>>            End
94925>>>>>>>>
94925>>>>>>>        Until (hTable = 0)                     
94927>>>>>>>        
94927>>>>>>>        Set Action_Text of ghoStatusPanel to "" 
94928>>>>>>>        Function_Return bOK
94929>>>>>>>    End_Function
94930>>>>>>>    
94930>>>>>>>    // Replaces all date values with CS_DUFLowestAllowedDateValue for all tables in Filelist.cfg,
94930>>>>>>>    // _except_ those tables that has been excluded with the "ApiTableDateCorrectionAddException" message.
94930>>>>>>>    // If the passed bAllowZeroDates = True, date columns that are = 0 will not be changed.
94930>>>>>>>    // This is for prepairing embedded tables (*.dat) before an SQL conversion.
94930>>>>>>>    //
94930>>>>>>>    // The root of the problem is the following:
94930>>>>>>>    // The data type Date in SQL has a range of accepted values from 01-01-0001 through 12-31-9999
94930>>>>>>>    // while the data type DateTime has a range of accepted values from 01-01-1753 through 12-31-9999
94930>>>>>>>    // So if you happen to have a Date from before 1753, or an empty / NULL value - this will be outside
94930>>>>>>>    // the range that DateTime can handle and if you then try to change a Date column to a DateTime,
94930>>>>>>>    // an SQL error will be thrown;
94930>>>>>>>    // "The conversion of a date data type to a datetime data type resulted in an out-of-range value".
94930>>>>>>>    Function UtilTablesFixAllDateBogusValues Boolean bFixZeroDates Boolean bResetIndexesToOnLine Returns Boolean
94932>>>>>>>        Boolean bOK bIsAlias bIsSQL
94932>>>>>>>        Integer iCount iSize iDateSize
94932>>>>>>>        Handle hTable
94932>>>>>>>        String sLogicalName
94932>>>>>>>        Integer[] aTablesToCheck aDateFields
94934>>>>>>>
94934>>>>>>>        Get _AllTablesDateCorrections to aTablesToCheck
94935>>>>>>>        Move (SizeOfArray(aTablesToCheck)) to iSize
94936>>>>>>>        Set pbVisible    of ghoProgressBarOverall to True
94937>>>>>>>        Set piPosition   of ghoProgressBarOverall to 0
94938>>>>>>>        Set piMaximum    of ghoProgressBarOverall to iSize
94939>>>>>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
94940>>>>>>>
94940>>>>>>>        Move True to bOK
94941>>>>>>>        Decrement iSize
94942>>>>>>>        for iCount from 0 to iSize
94948>>>>>>>>
94948>>>>>>>            Move aTablesToCheck[iCount] to hTable
94949>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount
94950>>>>>>>            Get UtilTableIsAlias hTable to bIsAlias
94951>>>>>>>            Get UtilTableIsSql   hTable to bIsSQL
94952>>>>>>>
94952>>>>>>>            Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
94955>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Processing Table Number:" * String(hTable) * "Name:" * String(sLogicalName))
94956>>>>>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus date values..."
94957>>>>>>>
94957>>>>>>>            If (bIsAlias = False and bIsSQL = False) Begin
94959>>>>>>>                Get UtilCheckForDateFields hTable to aDateFields
94960>>>>>>>                Move (SizeOfArray(aDateFields)) to iDateSize
94961>>>>>>>                If (iDateSize > 0) Begin
94963>>>>>>>                    Get UtilTableCorrectBogusDateValues hTable aDateFields bFixZeroDates bResetIndexesToOnLine to bOK
94964>>>>>>>                    Close hTable
94965>>>>>>>                End
94965>>>>>>>>
94965>>>>>>>            End
94965>>>>>>>>
94965>>>>>>>        Loop
94966>>>>>>>>
94966>>>>>>>
94966>>>>>>>        Close DF_ALL
94967>>>>>>>        Function_Return bOK
94968>>>>>>>    End_Function
94969>>>>>>>
94969>>>>>>>    // Returns all fields of type Date or DateTime in an integer array with the field numbers.
94969>>>>>>>    Function UtilCheckForDateFields Handle hTable Returns Integer[]
94971>>>>>>>        Integer[] aDateFields aDateFieldsEmpty
94973>>>>>>>        Integer iSize iCount iType
94973>>>>>>>        Boolean bOpen bOK
94973>>>>>>>        
94973>>>>>>>        Get UtilTableExists hTable to bOK
94974>>>>>>>        If (bOK = False) Begin
94976>>>>>>>            Set Private.phCurrentTable to hTable
94977>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
94978>>>>>>>>
94978>>>>>>>            Function_Return aDateFieldsEmpty
94979>>>>>>>        End
94979>>>>>>>>
94979>>>>>>>        Set Private.phCurrentTable to hTable
94980>>>>>>>        Set Private.piCurrentField to 0
94981>>>>>>>
94981>>>>>>>//        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
94981>>>>>>>        Open hTable
94983>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
94986>>>>>>>//        Set Error_Report_Mode to DUF_ERROR_REPORT
94986>>>>>>>        If (bOpen = False) Begin
94988>>>>>>>//            Error DFERR_PROGRAM ("Table could not be opened." * String(hTable))
94988>>>>>>>            Function_Return aDateFieldsEmpty
94989>>>>>>>        End
94989>>>>>>>>
94989>>>>>>>
94989>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iSize
94992>>>>>>>        For iCount from 1 to iSize
94998>>>>>>>>
94998>>>>>>>            Get_Attribute DF_FIELD_TYPE of hTable iCount to iType
95001>>>>>>>            If (iType = DF_DATE or iType = DF_DATETIME) Begin
95003>>>>>>>                Move iCount to aDateFields[SizeOfArray(aDateFields)]
95004>>>>>>>            End
95004>>>>>>>>
95004>>>>>>>        Loop
95005>>>>>>>>
95005>>>>>>>
95005>>>>>>>        Function_Return aDateFields
95006>>>>>>>    End_Function
95007>>>>>>>
95007>>>>>>>    // Loops through all records for the passed hTable, and checks that all Date values
95007>>>>>>>    // for the passed aDateFields array are OK. Else the Data value is set to CS_DUFLowestAllowedDateValue
95007>>>>>>>    // and the record is saved
95007>>>>>>>    // If the passed bAllowZeroDates = True, date columns that are = 0 will not be changed.
95007>>>>>>>    // Note: It first sets all indexes to BATCH and reset them at the end.
95007>>>>>>>    Function UtilTableCorrectBogusDateValues Handle hTable Integer[] aDateFields Boolean bFixZeroDates Boolean bResetIndexesToOnLine Returns Boolean
95009>>>>>>>        Integer iSize iCount iField iRecord iTotalRecords iDateFormat iDriverIndex
95009>>>>>>>        String sDriverID sDateMin
95009>>>>>>>        Boolean bCancel bFound bOK bChange bOpened bSaveChanges 
95009>>>>>>>        Date dDate dDateMin
95009>>>>>>>        Integer[] iaChangeField
95010>>>>>>>
95010>>>>>>>        Get UtilTableExists hTable to bOK
95011>>>>>>>        // I believe we should just skip files not found and not report an error.
95011>>>>>>>        // This is because a filelist may have entries but no files/tables on disk, but
95011>>>>>>>        // this may be adjusted by other calls to DUF in a later update package. 
95011>>>>>>>        // Especially considering that this call is probably done at the very
95011>>>>>>>        // beginning of a DUF update.
95011>>>>>>>        If (bOK = False) Begin
95013>>>>>>>//            Set Private.phCurrentTable to hTable
95013>>>>>>>//            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
95013>>>>>>>//            Function_Return False
95013>>>>>>>            Function_Return True
95014>>>>>>>        End
95014>>>>>>>>
95014>>>>>>>
95014>>>>>>>        // The CS_DUFLowestAllowedDateValue is defined as "01/01/1753", so we first set the
95014>>>>>>>        // date format to "USA" = "MM/DD/YYYY"
95014>>>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
95017>>>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_USA
95020>>>>>>>
95020>>>>>>>//        Send SetAllIndexesToBatch hTable True
95020>>>>>>>        Open hTable
95022>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
95025>>>>>>>        If (bOpened = False) Begin
95027>>>>>>>            Function_Return False
95028>>>>>>>        End
95028>>>>>>>>
95028>>>>>>>        
95028>>>>>>>        Set Private.phCurrentTable to hTable
95029>>>>>>>        Move 0 to iRecord
95030>>>>>>>        Move (SizeOfArray(aDateFields)) to iSize
95031>>>>>>>        Decrement iSize
95032>>>>>>>
95032>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
95035>>>>>>>        Get DriverIndex sDriverID to iDriverIndex
95036>>>>>>>        If (iDriverIndex <> 0) Begin
95038>>>>>>>            Get_Attribute DF_DRIVER_DUMMY_ZERO_DATE_VALUE of iDriverIndex to sDateMin
95041>>>>>>>            If (sDateMin = "") Begin
95043>>>>>>>                Move CS_DUFLowestAllowedDateValue to dDateMin
95044>>>>>>>            End
95044>>>>>>>>
95044>>>>>>>            Else Begin
95045>>>>>>>                If (IsDate(sDateMin)) Begin
95047>>>>>>>                    Move sDateMin to dDateMin
95048>>>>>>>                End
95048>>>>>>>>
95048>>>>>>>                Else Begin
95049>>>>>>>                    Move CS_DUFLowestAllowedDateValue to dDateMin
95050>>>>>>>                End
95050>>>>>>>>
95050>>>>>>>            End
95050>>>>>>>>
95050>>>>>>>        End
95050>>>>>>>>
95050>>>>>>>        Else Begin
95051>>>>>>>            Move CS_DUFLowestAllowedDateValue to dDateMin
95052>>>>>>>        End
95052>>>>>>>>
95052>>>>>>>
95052>>>>>>>        Get_Attribute DF_FILE_RECORDS_USED of hTable to iTotalRecords
95055>>>>>>>        Set piPosition   of ghoProgressBar to 0
95056>>>>>>>        Set piAdvanceBy  of ghoProgressBar to 100
95057>>>>>>>        Set piMaximum    of ghoProgressBar to iTotalRecords
95058>>>>>>>        Move False to Err
95059>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
95060>>>>>>>
95060>>>>>>>        Clear hTable
95061>>>>>>>        Repeat
95061>>>>>>>>
95061>>>>>>>            Vfind hTable 0 GT
95063>>>>>>>            Move Found to bFound
95064>>>>>>>            If (bFound = True) Begin
95066>>>>>>>                Move False to bSaveChanges
95067>>>>>>>                Move (ResizeArray(iaChangeField, 0)) to iaChangeField
95068>>>>>>>                Move (SizeOfArray(aDateFields)) to iSize
95069>>>>>>>                Decrement iSize
95070>>>>>>>                For iCount from 0 to iSize
95076>>>>>>>>
95076>>>>>>>                    Move aDateFields[iCount] to iField
95077>>>>>>>                    Get_Field_Value hTable iField to dDate
95080>>>>>>>                    If (bFixZeroDates = True) Begin
95082>>>>>>>                        Move (dDate = 0 or dDate < dDateMin) to bChange
95083>>>>>>>                    End
95083>>>>>>>>
95083>>>>>>>                    Else Begin
95084>>>>>>>                        Move (dDate <> 0 and dDate < dDateMin) to bChange
95085>>>>>>>                    End
95085>>>>>>>>
95085>>>>>>>                    If (bChange = True) Begin
95087>>>>>>>                        Move iField to iaChangeField[SizeOfArray(iaChangeField)]
95088>>>>>>>                    End
95088>>>>>>>>
95088>>>>>>>                Loop
95089>>>>>>>>
95089>>>>>>>
95089>>>>>>>                // Only change Date fields that needs to be changed.
95089>>>>>>>                If (SizeOfArray(iaChangeField)) Begin
95091>>>>>>>                    Reread hTable
95095>>>>>>>                        Move (SizeOfArray(iaChangeField)) to iSize
95096>>>>>>>                        Decrement iSize
95097>>>>>>>                        For iCount from 0 to iSize
95103>>>>>>>>
95103>>>>>>>                            Move iaChangeField[iCount] to iField
95104>>>>>>>                            Set Private.piCurrentField to iField
95105>>>>>>>                            Set_Field_Value hTable iField to dDateMin
95108>>>>>>>                        Loop
95109>>>>>>>>
95109>>>>>>>                        Move False to Err
95110>>>>>>>                        SaveRecord hTable
95111>>>>>>>                    Unlock
95112>>>>>>>>
95112>>>>>>>                End
95112>>>>>>>>
95112>>>>>>>
95112>>>>>>>                Increment iRecord
95113>>>>>>>                // Increment the StatusPanel counter and check the
95113>>>>>>>                // cancel status every 100 records rather than every
95113>>>>>>>                // record, it's way faster.
95113>>>>>>>                If (Mod(iRecord, 100) = 0) Begin
95115>>>>>>>                    Send DoAdvance of ghoProgressBar
95116>>>>>>>                    Set Action_Text of ghoStatusPanel to ("Record:" * String(iRecord))
95117>>>>>>>                    Get Check_StatusPanel of ghoStatusPanel to bCancel
95118>>>>>>>                End
95118>>>>>>>>
95118>>>>>>>            End
95118>>>>>>>>
95118>>>>>>>        Until (bFound = False)
95120>>>>>>>
95120>>>>>>>        Set_Attribute DF_DATE_FORMAT to iDateFormat
95123>>>>>>>        If (bResetIndexesToOnLine = True) Begin
95125>>>>>>>            Send SetAllIndexesToBatch hTable False
95126>>>>>>>        End
95126>>>>>>>>
95126>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
95127>>>>>>>
95127>>>>>>>        Function_Return (Err = False)
95128>>>>>>>    End_Function
95129>>>>>>>
95129>>>>>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
95129>>>>>>>    // Note that it first removes any driver prefixes in the rootname.
95129>>>>>>>    Function UtilTableInfoCompare Boolean bCompareFilelistUppercase tAPITableNameInfoCompare APITableInfoCompare Returns Boolean
95131>>>>>>>        Boolean bIsSame
95131>>>>>>>        String sRootNameFrom sRootNameTo sLogicalNameFrom sLogicalNameTo sDisplayNameFrom sDisplayNameTo
95131>>>>>>>
95131>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sRootNameFrom    to sRootNameFrom
95132>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sRootNameTo      to sRootNameTo
95133>>>>>>>        Move APITableInfoCompare.sLogicalNameFrom               to sLogicalNameFrom
95134>>>>>>>        Move APITableInfoCompare.sLogicalNameTo                 to sLogicalNameTo
95135>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sDisplayNameFrom to sDisplayNameFrom
95136>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sDisplayNameTo   to sDisplayNameTo
95137>>>>>>>
95137>>>>>>>        If (bCompareFilelistUppercase = True) Begin
95139>>>>>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(sLogicalNameFrom) = Uppercase(sLogicalNameTo)) to bIsSame
95140>>>>>>>        End
95140>>>>>>>>
95140>>>>>>>        Else Begin
95141>>>>>>>            Move (sRootNameFrom = sRootNameTo and sLogicalNameFrom = sLogicalNameTo and sDisplayNameFrom = sDisplayNameTo) to bIsSame
95142>>>>>>>        End
95142>>>>>>>>
95142>>>>>>>        If (bIsSame = False) Begin
95144>>>>>>>            Function_Return False
95145>>>>>>>        End
95145>>>>>>>>
95145>>>>>>>
95145>>>>>>>        Move (APITableInfoCompare.bIsAliasFrom = APITableInfoCompare.bIsAliasTo) to bIsSame
95146>>>>>>>        If (bIsSame = False) Begin
95148>>>>>>>            Function_Return False
95149>>>>>>>        End
95149>>>>>>>>
95149>>>>>>>
95149>>>>>>>        Move (APITableInfoCompare.bIsSQLFrom = APITableInfoCompare.bIsSQLTo) to bIsSame
95150>>>>>>>        If (bIsSame = False) Begin
95152>>>>>>>            Function_Return False
95153>>>>>>>        End
95153>>>>>>>>
95153>>>>>>>
95153>>>>>>>        Move (APITableInfoCompare.bIsSystemFileFrom = APITableInfoCompare.bIsSystemFileTo) to bIsSame
95154>>>>>>>        If (bIsSame = False) Begin
95156>>>>>>>            Function_Return False
95157>>>>>>>        End
95157>>>>>>>>
95157>>>>>>>
95157>>>>>>>        Function_Return bIsSame
95158>>>>>>>    End_Function
95159>>>>>>>
95159>>>>>>>    Function UtilTableCompare tAPITable APITableFrom tAPITable APITableTo Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
95161>>>>>>>        Handle hTableFrom hTableTo
95161>>>>>>>        Boolean bIsSame bIsSQLFrom bIsSQLTo
95161>>>>>>>        Boolean bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase
95161>>>>>>>        String sRootName sDriverIDFrom sDriverIDTo
95161>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
95161>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
95162>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
95162>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
95163>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
95163>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
95164>>>>>>>
95164>>>>>>>        Move (IsSameStruct(APITableFrom, APITableTo)) to bIsSame
95165>>>>>>>        If (bIsSame = True) Begin
95167>>>>>>>            Function_Return True
95168>>>>>>>        End
95168>>>>>>>>
95168>>>>>>>
95168>>>>>>>        Move False to bFilelistError
95169>>>>>>>        Move True to bIsSame
95170>>>>>>>        Get pbCompareDate_DateTime  to bCompareDate_DateTime
95171>>>>>>>        Get pbCompareIndexAscending to bCompareIndexAscending
95172>>>>>>>        Get pbCompareIndexUppercase to bCompareIndexUppercase
95173>>>>>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
95174>>>>>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo
95175>>>>>>>
95175>>>>>>>        Move APITableFrom.ApiTableInfo.sRootName to sRootName
95176>>>>>>>        Get _TableNameOnly sRootName             to sRootName
95177>>>>>>>        Move sRootName to APITableTo.ApiTableInfo.sRootName
95178>>>>>>>
95178>>>>>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg is the same).
95178>>>>>>>        // bCodeGenerateMode = True = Code Generation mode.
95178>>>>>>>        If (bCodeGenerateMode = True) Begin
95180>>>>>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
95180>>>>>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
95182>>>>>>>                Function_Return False
95183>>>>>>>            End
95183>>>>>>>>
95183>>>>>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
95184>>>>>>>            If (bIsSame = False) Begin
95186>>>>>>>                Send UserError ("Yikes! There is a serious problem with the Filelist.cfg slot number:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * ".\nThis needs to be fixed before you can generate code for this table number.")
95187>>>>>>>                Move True to bFilelistError
95188>>>>>>>                Function_Return False
95189>>>>>>>            End
95189>>>>>>>>
95189>>>>>>>        End
95189>>>>>>>>
95189>>>>>>>
95189>>>>>>>        If (bCodeGenerateMode = False) Begin
95191>>>>>>>            // Then we want to create this table
95191>>>>>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
95193>>>>>>>                Function_Return False
95194>>>>>>>            End
95194>>>>>>>>
95194>>>>>>>
95194>>>>>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
95195>>>>>>>            If (bIsSame = False) Begin
95197>>>>>>>                Error DFERR_PROGRAM ("'UtilTableCompare function' problem in Filelist.cfg! Table No:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * "No changes was made for this entry.")
95198>>>>>>>>
95198>>>>>>>                Move True to bFilelistError
95199>>>>>>>                Function_Return False
95200>>>>>>>            End
95200>>>>>>>>
95200>>>>>>>        End
95200>>>>>>>>
95200>>>>>>>
95200>>>>>>>        // Check columns:
95200>>>>>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
95201>>>>>>>        Move APITableFrom.ApiTableInfo.bIsSQL       to bIsSQLFrom
95202>>>>>>>        Move APITableFrom.ApiTableInfo.sDriverID    to sDriverIDFrom
95203>>>>>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo
95204>>>>>>>        Move APITableTo.ApiTableInfo.bIsSQL         to bIsSQLTo
95205>>>>>>>        Move APITableTo.ApiTableInfo.sDriverID      to sDriverIDTo
95206>>>>>>>        Get UtilColumnsStructFill hTableTo          to APITableTo.aApiColumns
95207>>>>>>>        Get UtilColumnCombineFromAndToArrays APITableFrom.aApiColumns APITableTo.aApiColumns to aAPIColumnCompare
95208>>>>>>>        Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
95209>>>>>>>        If (bIsSame = False) Begin
95211>>>>>>>            Function_Return False
95212>>>>>>>        End
95212>>>>>>>>
95212>>>>>>>
95212>>>>>>>        // ...then check indexes:
95212>>>>>>>        Get UtilIndexesStructFill hTableFrom to APITableTo.aApiIndexes
95213>>>>>>>        Get UtilIndexCombineFromAndToArrays APITableFrom.aApiIndexes APITableTo.aApiIndexes to aAPIIndexCompare
95214>>>>>>>        Get UtilIndexesCompare bIsSQLFrom bIsSQLTo aAPIIndexCompare bCompareIndexUppercase bCompareIndexAscending to bIsSame
95215>>>>>>>        If (bIsSame = False) Begin
95217>>>>>>>            Function_Return False
95218>>>>>>>        End
95218>>>>>>>>
95218>>>>>>>
95218>>>>>>>        // ...and finally relationships:
95218>>>>>>>        Get UtilRelationsStructFill hTableFrom to APITableTo.aApiRelations
95219>>>>>>>        Get UtilRelationCombineFromAndToArrays APITableFrom.aApiRelations APITableTo.aApiRelations to aAPIRelationCompare
95220>>>>>>>        Move (IsSameArray(APITableFrom.aApiRelations, APITableTo.aApiRelations)) to bIsSame
95221>>>>>>>        Get UtilRelationsCompare hTableFrom aAPIRelationCompare to bIsSame
95222>>>>>>>
95222>>>>>>>        Function_Return (bIsSame = True)
95223>>>>>>>    End_Function
95224>>>>>>>
95224>>>>>>>    // Similar to UtilTableCompare, but takes a tAPITableCompare struct array and a tAPITableBooleans struct as params.
95224>>>>>>>    Function UtilTableCompare_Ex tAPITableCompare APITableCompare tAPITableBooleans CompareTableBooleans Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
95226>>>>>>>        Handle hTable
95226>>>>>>>        Boolean bIsSame bIsSQLFrom bIsSQLTo
95226>>>>>>>        String sRootName sDriverIDFrom sDriverIDTo
95226>>>>>>>
95226>>>>>>>        If (APITableCompare.APITableNameInfoCompare.bExistsFrom = False and APITableCompare.APITableNameInfoCompare.bExistsTo = False) Begin
95228>>>>>>>            Move True to bFilelistError
95229>>>>>>>            Function_Return False
95230>>>>>>>        End
95230>>>>>>>>
95230>>>>>>>
95230>>>>>>>        Move APITableCompare.hTable to hTable
95231>>>>>>>        Move True  to bIsSame
95232>>>>>>>        Move False to bFilelistError
95233>>>>>>>
95233>>>>>>>        If (APITableCompare.bExistsFrom = True) Begin
95235>>>>>>>            Move APITableCompare.APITableNameInfoCompare.sRootNameFrom to sRootName
95236>>>>>>>        End
95236>>>>>>>>
95236>>>>>>>        Else Begin
95237>>>>>>>            Move APITableCompare.APITableNameInfoCompare.sRootNameTo   to sRootName
95238>>>>>>>        End
95238>>>>>>>>
95238>>>>>>>        Get _TableNameOnly sRootName                                   to sRootName
95239>>>>>>>
95239>>>>>>>        Move APITableCompare.APITableNameInfoCompare.sDriverIDFrom     to sDriverIDFrom
95240>>>>>>>        Move APITableCompare.APITableNameInfoCompare.sDriverIDTo       to sDriverIDTo
95241>>>>>>>        Move APITableCompare.APITableNameInfoCompare.bIsSQLFrom        to bIsSQLFrom
95242>>>>>>>        Move APITableCompare.APITableNameInfoCompare.bIsSQLTo          to bIsSQLTo
95243>>>>>>>
95243>>>>>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg are the same).
95243>>>>>>>        // bCodeGenerateMode = True = Code Generation mode.
95243>>>>>>>        If (bCodeGenerateMode = True) Begin
95245>>>>>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
95245>>>>>>>            If (APITableCompare.bExistsTo = False) Begin
95247>>>>>>>                Function_Return False
95248>>>>>>>            End
95248>>>>>>>>
95248>>>>>>>            Move (Uppercase(APITableCompare.APITableNameInfoCompare.sLogicalNameFrom) = Uppercase(APITableCompare.APITableNameInfoCompare.sLogicalNameTo)) to bIsSame
95249>>>>>>>            If (bIsSame = False) Begin
95251>>>>>>>                Send UserError ("Yikes! There is a problem with the Filelist.cfg slot number:" * String(hTable) + ;                    ".\nThe FROM table logical name is:" * String(APITableCompare.APITableNameInfoCompare.sLogicalNameFrom) * "\nwhile the TO table logical name is:" * ;                    String(APITableCompare.APITableNameInfoCompare.sLogicalNameTo) * ".\nThis needs to be fixed before you can generate code for this table number.")
95252>>>>>>>                Move True to bFilelistError
95253>>>>>>>                Function_Return False
95254>>>>>>>            End
95254>>>>>>>>
95254>>>>>>>        End
95254>>>>>>>>
95254>>>>>>>
95254>>>>>>>        If (bCodeGenerateMode = False) Begin
95256>>>>>>>            If (APITableCompare.bExistsTo = False) Begin
95258>>>>>>>                // Then we might want to create this table
95258>>>>>>>                Function_Return False
95259>>>>>>>            End
95259>>>>>>>>
95259>>>>>>>
95259>>>>>>>            Move (APITableCompare.APITableNameInfoCompare.bIsAliasFrom = APITableCompare.APITableNameInfoCompare.bIsAliasTo) to bIsSame
95260>>>>>>>            If (bIsSame = False) Begin
95262>>>>>>>                Function_Return False
95263>>>>>>>            End
95263>>>>>>>>
95263>>>>>>>
95263>>>>>>>            Move (APITableCompare.APITableNameInfoCompare.bIsSQLFrom = APITableCompare.APITableNameInfoCompare.bIsSQLTo) to bIsSame
95264>>>>>>>            If (bIsSame = False) Begin
95266>>>>>>>                Function_Return False
95267>>>>>>>            End
95267>>>>>>>>
95267>>>>>>>
95267>>>>>>>            Move (APITableCompare.APITableNameInfoCompare.bIsSystemFileFrom = APITableCompare.APITableNameInfoCompare.bIsSystemFileTo) to bIsSame
95268>>>>>>>            If (bIsSame = False) Begin
95270>>>>>>>                Function_Return False
95271>>>>>>>            End
95271>>>>>>>>
95271>>>>>>>
95271>>>>>>>            // Check table names et al.
95271>>>>>>>            Get UtilTableInfoCompare CompareTableBooleans.bCompareFilelistUppercase APITableCompare.APITableNameInfoCompare to bIsSame
95272>>>>>>>            If (bIsSame = False) Begin
95274>>>>>>>                Function_Return False
95275>>>>>>>            End
95275>>>>>>>>
95275>>>>>>>        End
95275>>>>>>>>
95275>>>>>>>
95275>>>>>>>        // Check Columns:
95275>>>>>>>        Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo APITableCompare.aAPIColumnsCompare CompareTableBooleans.bCompareDate_DateTime to bIsSame
95276>>>>>>>        If (bIsSame = False) Begin
95278>>>>>>>            Function_Return False
95279>>>>>>>        End
95279>>>>>>>>
95279>>>>>>>
95279>>>>>>>        // ...then check Indexes:
95279>>>>>>>        Get UtilIndexesCompare bIsSQLFrom bIsSQLTo APITableCompare.aAPIIndexesCompare CompareTableBooleans.bCompareIndexUppercase CompareTableBooleans.bCompareIndexAscending to bIsSame
95280>>>>>>>        If (bIsSame = False) Begin
95282>>>>>>>            Function_Return False
95283>>>>>>>        End
95283>>>>>>>>
95283>>>>>>>
95283>>>>>>>        // ...and finally Relationships:
95283>>>>>>>        Get UtilRelationsCompare hTable APITableCompare.aAPIRelationsCompare to bIsSame
95284>>>>>>>
95284>>>>>>>        Function_Return (bIsSame = True)
95285>>>>>>>    End_Function
95286>>>>>>>
95286>>>>>>>    // To fill a complete Table array structure (tAPITable[]) with data.
95286>>>>>>>    // The data + filelist.cfg path, login et al must have been setup properly first.
95286>>>>>>>    // Pass a True as first parameter if the ghoStatusPanel is active and progress info should be shown.
95286>>>>>>>    // Pass a second True if this is a comparison and the text should either reflect "FROM" or "TO" database.
95286>>>>>>>    Function UtilTablesStructArrayFill Boolean bStatusPanel Boolean bCompareUtil Boolean bFromTables Returns tAPITable[]
95288>>>>>>>        tAPITableNameInfo ApiTableNameInfo
95288>>>>>>>        tAPITableNameInfo ApiTableNameInfo
95288>>>>>>>        tAPITable[]     aApiTables aApiTablesEmpty
95288>>>>>>>        tAPITable[]     aApiTables aApiTablesEmpty
95290>>>>>>>        tAPIColumn[]    aApiColumns
95290>>>>>>>        tAPIColumn[]    aApiColumns
95291>>>>>>>        tAPIIndex[]     aApiIndexes
95291>>>>>>>        tAPIIndex[]     aApiIndexes
95292>>>>>>>        tAPIRelation[]  aApiRelations
95292>>>>>>>        tAPIRelation[]  aApiRelations
95293>>>>>>>        Handle hTable
95293>>>>>>>        Integer iCount
95293>>>>>>>        Boolean bUserCancel bOK
95293>>>>>>>        String sLogicalName sMessageText
95293>>>>>>>
95293>>>>>>>        Get AutoConnectionIDLogin to bOK
95294>>>>>>>        Move 0 to hTable
95295>>>>>>>        If (bFromTables = True) Begin
95297>>>>>>>            Move "Reading 'FROM' Table Structure:" to sMessageText
95298>>>>>>>            If (bCompareUtil = True) Begin
95300>>>>>>>                Move (sMessageText * "(1 of 3)") to sMessageText
95301>>>>>>>            End
95301>>>>>>>>
95301>>>>>>>        End
95301>>>>>>>>
95301>>>>>>>        Else Begin
95302>>>>>>>            Move "Reading 'TO' Table Structure:" to sMessageText
95303>>>>>>>            If (bCompareUtil = True) Begin
95305>>>>>>>                Move (sMessageText * "(2 of 3)") to sMessageText
95306>>>>>>>            End
95306>>>>>>>>
95306>>>>>>>        End
95306>>>>>>>>
95306>>>>>>>        Set Message_Text of ghoStatusPanel to sMessageText
95307>>>>>>>
95307>>>>>>>        Get UtilFilelistNoOfTables to iCount
95308>>>>>>>        Set piMaximum of ghoProgressBar to iCount
95309>>>>>>>        Move 0 to iCount
95310>>>>>>>
95310>>>>>>>        Repeat
95310>>>>>>>>
95310>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
95313>>>>>>>            If (hTable > 0 and hTable <> 50) Begin
95315>>>>>>>
95315>>>>>>>                Open hTable
95317>>>>>>>                // ToDo: Needs to be revised
95317>>>>>>>                // For some reason tables may be reported as "unopened", while in
95317>>>>>>>                // fact the open was successful (!)
95317>>>>>>>//                Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
95317>>>>>>>//                If (bIsOpen = False) Begin
95317>>>>>>>//                    Move True to aApiTablesEmpty[0].bError
95317>>>>>>>//                    Move hTable to aApiTablesEmpty[0].ApiTableInfo.iTableNumber
95317>>>>>>>//                    Function_Return aApiTablesEmpty
95317>>>>>>>//                End
95317>>>>>>>
95317>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
95320>>>>>>>                Set piPosition of ghoProgressBar to iCount
95321>>>>>>>                Send DoAdvance of ghoProgressBarOverall
95322>>>>>>>                Set Action_Text of ghoStatusPanel to ("Number:" * String(hTable) * String(sLogicalName))
95323>>>>>>>
95323>>>>>>>                Get UtilTableStructFill hTable bFromTables to aApiTables[iCount]
95324>>>>>>>//                Close hTable DF_PERMANENT
95324>>>>>>>                Increment iCount
95325>>>>>>>            End
95325>>>>>>>>
95325>>>>>>>
95325>>>>>>>            If (bStatusPanel = True) Begin
95327>>>>>>>                Get Check_StatusPanel of ghoStatusPanel to bUserCancel
95328>>>>>>>                If (bUserCancel = True) Begin
95330>>>>>>>                    Move True to aApiTablesEmpty[0].bCancel
95331>>>>>>>                    Function_Return aApiTablesEmpty
95332>>>>>>>                End
95332>>>>>>>>
95332>>>>>>>            End
95332>>>>>>>>
95332>>>>>>>
95332>>>>>>>        Until (hTable = 0)
95334>>>>>>>
95334>>>>>>>        Function_Return aApiTables
95335>>>>>>>    End_Function
95336>>>>>>>
95336>>>>>>>    // Returns a 'single' table APITable struct.
95336>>>>>>>    Function UtilTableStructFill Handle hTable Boolean bFromTables Returns tAPITable
95338>>>>>>>        tAPITableNameInfo ApiTableNameInfo
95338>>>>>>>        tAPITableNameInfo ApiTableNameInfo
95338>>>>>>>        tAPITable         ApiTable ApiTableEmpty
95338>>>>>>>        tAPITable         ApiTable ApiTableEmpty
95338>>>>>>>        tAPIColumn[]     aApiColumns
95338>>>>>>>        tAPIColumn[]     aApiColumns
95339>>>>>>>        tAPIIndex[]      aApiIndexes
95339>>>>>>>        tAPIIndex[]      aApiIndexes
95340>>>>>>>        tAPIRelation[]   aApiRelations
95340>>>>>>>        tAPIRelation[]   aApiRelations
95341>>>>>>>        Boolean bIsOpen
95341>>>>>>>
95341>>>>>>>        Open hTable
95343>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
95346>>>>>>>        If (bIsOpen = False) Begin
95348>>>>>>>            Move True to ApiTableEmpty.bError
95349>>>>>>>            Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
95350>>>>>>>            Function_Return ApiTableEmpty
95351>>>>>>>        End
95351>>>>>>>>
95351>>>>>>>
95351>>>>>>>        // Fill Table Name Info
95351>>>>>>>        Get UtilTableNameInfoStructFill hTable to ApiTableNameInfo
95352>>>>>>>
95352>>>>>>>        // Fill columns
95352>>>>>>>        Get UtilColumnsStructFill hTable to aApiColumns
95353>>>>>>>        If (SizeOfArray(aApiColumns)) Begin
95355>>>>>>>            If (aApiColumns[0].bCancel = True) Begin
95357>>>>>>>                Move True to ApiTableEmpty.bError
95358>>>>>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
95359>>>>>>>                Function_Return ApiTableEmpty
95360>>>>>>>            End
95360>>>>>>>>
95360>>>>>>>        End
95360>>>>>>>>
95360>>>>>>>
95360>>>>>>>        // Fill indexes
95360>>>>>>>        Get UtilIndexesStructFill hTable to aApiIndexes
95361>>>>>>>        If (SizeOfArray(aApiIndexes)) Begin
95363>>>>>>>            If (aApiIndexes[0].bCancel = True) Begin
95365>>>>>>>                Move True to ApiTableEmpty.bError
95366>>>>>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
95367>>>>>>>                Function_Return ApiTableEmpty
95368>>>>>>>            End
95368>>>>>>>>
95368>>>>>>>        End
95368>>>>>>>>
95368>>>>>>>
95368>>>>>>>        // Fill relationships
95368>>>>>>>        Get UtilRelationsStructFill hTable to aApiRelations
95369>>>>>>>        If (SizeOfArray(aApiRelations)) Begin
95371>>>>>>>            If (aApiRelations[0].bCancel = True) Begin
95373>>>>>>>                Move True to ApiTableEmpty.bError
95374>>>>>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
95375>>>>>>>                Function_Return ApiTableEmpty
95376>>>>>>>            End
95376>>>>>>>>
95376>>>>>>>        End
95376>>>>>>>>
95376>>>>>>>
95376>>>>>>>        Move hTable             to ApiTable.hTable
95377>>>>>>>        Move bFromTables        to ApiTable.bFromTable
95378>>>>>>>        Move (not(bFromTables)) to ApiTable.bToTable
95379>>>>>>>
95379>>>>>>>        Move ApiTableNameInfo   to ApiTable.ApiTableInfo
95380>>>>>>>        Move aApiColumns        to ApiTable.aApiColumns
95381>>>>>>>        Move aApiIndexes        to ApiTable.aApiIndexes
95382>>>>>>>        Move aApiRelations      to ApiTable.aApiRelations
95383>>>>>>>
95383>>>>>>>        Function_Return ApiTable
95384>>>>>>>    End_Function
95385>>>>>>>
95385>>>>>>>    Function UtilTableNameInfoStructFill Handle hTable Returns tAPITableNameInfo
95387>>>>>>>        tAPITableNameInfo APITableNameInfo APITableNameInfoEmpty
95387>>>>>>>        tAPITableNameInfo APITableNameInfo APITableNameInfoEmpty
95387>>>>>>>        Boolean bIsOpen
95387>>>>>>>
95387>>>>>>>        Open hTable
95389>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
95392>>>>>>>        If (bIsOpen = False) Begin
95394>>>>>>>            Move True   to APITableNameInfoEmpty.bError
95395>>>>>>>            Move hTable to APITableNameInfoEmpty.iTableNumber
95396>>>>>>>            Function_Return APITableNameInfoEmpty
95397>>>>>>>        End
95397>>>>>>>>
95397>>>>>>>
95397>>>>>>>        Move hTable                                  to APITableNameInfo.iTableNumber
95398>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to APITableNameInfo.sRootName
95401>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to APITableNameInfo.sLogicalName
95404>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to APITableNameInfo.sDisplayName
95407>>>>>>>        Get_Attribute DF_FILE_DRIVER       of hTable to APITableNameInfo.sDriverID
95410>>>>>>>
95410>>>>>>>        Get UtilTableIsAlias                  hTable to APITableNameInfo.bIsAlias
95411>>>>>>>        Get UtilTableIsSQL                    hTable to APITableNameInfo.bIsSQL
95412>>>>>>>
95412>>>>>>>        Function_Return APITableNameInfo
95413>>>>>>>    End_Function
95414>>>>>>>
95414>>>>>>>    Function UtilFindTableArrayItem tAPITable[] ByRef aTableStructure String sLogicalTableName Returns Integer
95416>>>>>>>        Integer iSize iCount iItem
95416>>>>>>>        tAPITableNameInfo ApiTableNameInfo
95416>>>>>>>        tAPITableNameInfo ApiTableNameInfo
95416>>>>>>>
95416>>>>>>>        Move -1 to iItem
95417>>>>>>>        Move (SizeOfArray(aTableStructure)) to iSize
95418>>>>>>>        Decrement iSize
95419>>>>>>>        for iCount from 0 to iSize
95425>>>>>>>>
95425>>>>>>>            Move aTableStructure[iCount].ApiTableInfo to ApiTableNameInfo
95426>>>>>>>            If (Uppercase(ApiTableNameInfo.sLogicalName) = Uppercase(sLogicalTableName)) Begin
95428>>>>>>>                Move iCount to iItem
95429>>>>>>>                Move iSize  to iCount // We're done.
95430>>>>>>>            End
95430>>>>>>>>
95430>>>>>>>        Loop
95431>>>>>>>>
95431>>>>>>>
95431>>>>>>>        Function_Return iItem
95432>>>>>>>    End_Function
95433>>>>>>>
95433>>>>>>>    Function UtilTableArrayCompare tAPITable APITableFrom tAPITable APITableTo Returns Integer
95435>>>>>>>        If (APITableFrom.hTable  > APITableTo.hTable) ;            Function_Return (GT)
95438>>>>>>>        If (APITableFrom.hTable  < APITableTo.hTable) ;            Function_Return (LT)
95441>>>>>>>
95441>>>>>>>        If (APITableFrom.bFromTable = True)  ;            Function_Return (LT)
95444>>>>>>>        If (APITableFrom.bFromTable = False) ;            Function_Return (GT)
95447>>>>>>>
95447>>>>>>>        Function_Return (EQ)
95448>>>>>>>    End_Function
95449>>>>>>>
95449>>>>>>>    Function UtilTableCombineFromAndToArrays tAPITable[] aAPITableFrom tAPITable[] aAPITableTo Returns tAPITableCompare[]
95451>>>>>>>        Integer iCount iSize iSizeFrom iSizeTo iItemFrom iItemTo iItem
95451>>>>>>>        Handle hTable
95451>>>>>>>        tAPITable[] aAPITableFromAndTo
95451>>>>>>>        tAPITable[] aAPITableFromAndTo
95452>>>>>>>        tAPITable   APITableFrom APITableTo APITableEmpty
95452>>>>>>>        tAPITable   APITableFrom APITableTo APITableEmpty
95452>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
95452>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
95452>>>>>>>        tAPITableCompare[]    aAPITableCompare // This is the result set for this function
95452>>>>>>>        tAPITableCompare[]    aAPITableCompare // This is the result set for this function
95453>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
95453>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
95454>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
95454>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
95455>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
95455>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
95456>>>>>>>        tAPITableNameInfo ApiTableInfoEmpty ApiTableInfoFrom ApiTableInfoTo
95456>>>>>>>        tAPITableNameInfo ApiTableInfoEmpty ApiTableInfoFrom ApiTableInfoTo
95456>>>>>>>        tAPIColumn[]   aApiColumnsEmpty aApiColumnsFrom aApiColumnsTo
95456>>>>>>>        tAPIColumn[]   aApiColumnsEmpty aApiColumnsFrom aApiColumnsTo
95459>>>>>>>        tAPIIndex[]    aApiIndexEmpty aApiIndexFrom aApiIndexTo
95459>>>>>>>        tAPIIndex[]    aApiIndexEmpty aApiIndexFrom aApiIndexTo
95462>>>>>>>        tAPIRelation[] aApiRelationEmpty aApiRelationFrom aApiRelationTo
95462>>>>>>>        tAPIRelation[] aApiRelationEmpty aApiRelationFrom aApiRelationTo
95465>>>>>>>
95465>>>>>>>        Move (SizeOfArray(aAPITableFrom)) to iSizeFrom
95466>>>>>>>        Move (SizeOfArray(aAPITableTo))   to iSizeTo
95467>>>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
95469>>>>>>>            Function_Return aAPITableCompare
95470>>>>>>>        End
95470>>>>>>>>
95470>>>>>>>
95470>>>>>>>        Move (AppendArray(aAPITableFrom, aAPITableTo)) to aAPITableFromAndTo
95471>>>>>>>        Move (SortArray(aAPITableFromAndTo, Self, RefFunc(UtilTableArrayCompare))) to aAPITableFromAndTo
95472>>>>>>>
95472>>>>>>>        Move 0 to iItem
95473>>>>>>>        Move (SizeOfArray(aAPITableFromAndTo)) to iSize
95474>>>>>>>        Decrement iSize
95475>>>>>>>        for iCount from 0 to iSize
95481>>>>>>>>
95481>>>>>>>
95481>>>>>>>            Move iCount to iItemFrom
95482>>>>>>>            Move iCount to iItemTo
95483>>>>>>>            Move APITableEmpty to APITableFrom
95484>>>>>>>            Move APITableEmpty to APITableTo
95485>>>>>>>
95485>>>>>>>            If (aAPITableFromAndTo[iCount].bFromTable = True) Begin
95487>>>>>>>                Move aAPITableFromAndTo[iCount]     to APITableFrom
95488>>>>>>>            End
95488>>>>>>>>
95488>>>>>>>            If (aAPITableFromAndTo[iCount].bToTable = True) Begin
95490>>>>>>>                Move aAPITableFromAndTo[iCount]     to APITableTo
95491>>>>>>>            End
95491>>>>>>>>
95491>>>>>>>            If (aAPITableFromAndTo[iCount].hTable = aAPITableFromAndTo[iCount + 1].hTable) Begin
95493>>>>>>>                Move aAPITableFromAndTo[iCount]     to APITableFrom
95494>>>>>>>                Move (iCount + 1) to iItemTo
95495>>>>>>>                Move aAPITableFromAndTo[iItemTo]    to APITableTo
95496>>>>>>>            End
95496>>>>>>>>
95496>>>>>>>            If (APITableFrom.hTable > APITableTo.hTable) Begin
95498>>>>>>>                Get FindTableNumber aAPITableTo APITableFrom.hTable to iItemTo
95499>>>>>>>                If (iItemTo <> -1) Begin
95501>>>>>>>                    Move aAPITableTo[iItemTo] to APITableTo
95502>>>>>>>                End
95502>>>>>>>>
95502>>>>>>>                Else Begin
95503>>>>>>>                    Move APITableEmpty to APITableTo
95504>>>>>>>                End
95504>>>>>>>>
95504>>>>>>>            End
95504>>>>>>>>
95504>>>>>>>
95504>>>>>>>            Move APITableFrom.ApiTableInfo  to ApiTableInfoFrom
95505>>>>>>>            Move APITableFrom.aApiColumns   to aApiColumnsFrom
95506>>>>>>>            Move APITableFrom.aApiIndexes   to aApiIndexFrom
95507>>>>>>>            Move APITableFrom.aApiRelations to aApiRelationFrom
95508>>>>>>>
95508>>>>>>>            Move APITableTo.ApiTableInfo    to ApiTableInfoTo
95509>>>>>>>            Move APITableTo.aApiColumns     to aApiColumnsTo
95510>>>>>>>            Move APITableTo.aApiIndexes     to aApiIndexTo
95511>>>>>>>            Move APITableTo.aApiRelations   to aApiRelationTo
95512>>>>>>>
95512>>>>>>>            Move aAPITableFromAndTo[iCount].hTable to hTable
95513>>>>>>>
95513>>>>>>>            If (hTable > 0) Begin
95515>>>>>>>
95515>>>>>>>                // Table info:
95515>>>>>>>                Get UtilTableINFOCombineFromAndToArrays ApiTableInfoFrom ApiTableInfoTo to APITableNameInfoCompare
95516>>>>>>>                Move APITableNameInfoCompare.iTableNumber                               to aAPITableCompare[iItem].hTable
95517>>>>>>>                Move APITableNameInfoCompare.bExistsFrom                                to aAPITableCompare[iItem].bExistsFrom
95518>>>>>>>                Move APITableNameInfoCompare.bExistsTo                                  to aAPITableCompare[iItem].bExistsTo
95519>>>>>>>                Move APITableNameInfoCompare                                            to aAPITableCompare[iItem].APITableNameInfoCompare
95520>>>>>>>
95520>>>>>>>                // Column info:
95520>>>>>>>                Get UtilColumnCombineFromAndToArrays aApiColumnsFrom aApiColumnsTo      to aAPIColumnCompare
95521>>>>>>>                Move aAPIColumnCompare                                                  to aAPITableCompare[iItem].aAPIColumnsCompare
95522>>>>>>>
95522>>>>>>>                // Index info:
95522>>>>>>>                Get UtilIndexCombineFromAndToArrays aApiIndexFrom aApiIndexTo           to aAPIIndexCompare
95523>>>>>>>                Move aAPIIndexCompare                                                   to aAPITableCompare[iItem].aAPIIndexesCompare
95524>>>>>>>
95524>>>>>>>                // Relation info:
95524>>>>>>>                Get UtilRelationCombineFromAndToArrays aApiRelationFrom aApiRelationTo  to aAPIRelationCompare
95525>>>>>>>                Move aAPIRelationCompare                                                to aAPITableCompare[iItem].aAPIRelationsCompare
95526>>>>>>>
95526>>>>>>>                Move False                                                              to aAPITableCompare[iItem].bShouldChange
95527>>>>>>>                Move False                                                              to aAPITableCompare[iItem].bCancel
95528>>>>>>>                Move False                                                              to aAPITableCompare[iItem].bError
95529>>>>>>>                If (iItemTo > iItemFrom) Begin
95531>>>>>>>                    Increment iCount
95532>>>>>>>                End
95532>>>>>>>>
95532>>>>>>>                Increment iItem
95533>>>>>>>            End
95533>>>>>>>>
95533>>>>>>>
95533>>>>>>>        Loop
95534>>>>>>>>
95534>>>>>>>
95534>>>>>>>        Function_Return aAPITableCompare
95535>>>>>>>    End_Function
95536>>>>>>>
95536>>>>>>>    Function FindTableNumber tAPITable[] ByRef aTableStructure Handle hTable Returns Integer
95538>>>>>>>        Integer iSize iCount iItem
95538>>>>>>>        tAPITableNameInfo ApiTableNameInfo
95538>>>>>>>        tAPITableNameInfo ApiTableNameInfo
95538>>>>>>>
95538>>>>>>>        Move -1 to iItem
95539>>>>>>>        Move (SizeOfArray(aTableStructure)) to iSize
95540>>>>>>>        Decrement iSize
95541>>>>>>>        For iCount from 0 to iSize
95547>>>>>>>>
95547>>>>>>>            Move aTableStructure[iCount].ApiTableInfo to ApiTableNameInfo
95548>>>>>>>            If (ApiTableNameInfo.iTableNumber = hTable) Begin
95550>>>>>>>                Move iCount to iItem
95551>>>>>>>                Move iSize  to iCount // We're done.
95552>>>>>>>            End
95552>>>>>>>>
95552>>>>>>>        Loop
95553>>>>>>>>
95553>>>>>>>
95553>>>>>>>        Function_Return iItem
95554>>>>>>>    End_Function
95555>>>>>>>
95555>>>>>>>    Function UtilTableInfoCombineFromAndToArrays tAPITableNameInfo APITableNameInfoFrom tAPITableNameInfo APITableNameInfoTo Returns tAPITableNameInfoCompare
95557>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
95557>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
95557>>>>>>>
95557>>>>>>>        If (APITableNameInfoFrom.iTableNumber = 0 and APITableNameInfoTo.iTableNumber = 0) Begin
95559>>>>>>>            Function_Return APITableNameInfoCompare
95560>>>>>>>        End
95560>>>>>>>>
95560>>>>>>>
95560>>>>>>>        // FROM database info:
95560>>>>>>>        If (APITableNameInfoFrom.iTableNumber > 0) Begin
95562>>>>>>>            Move APITableNameInfoFrom.iTableNumber  to APITableNameInfoCompare.iTableNumber
95563>>>>>>>            Move APITableNameInfoFrom.sRootName     to APITableNameInfoCompare.sRootNameFrom
95564>>>>>>>            Move APITableNameInfoFrom.sLogicalName  to APITableNameInfoCompare.sLogicalNameFrom
95565>>>>>>>            Move APITableNameInfoFrom.sDisplayName  to APITableNameInfoCompare.sDisplayNameFrom
95566>>>>>>>            Move APITableNameInfoFrom.sDriverID     to APITableNameInfoCompare.sDriverIDFrom
95567>>>>>>>            Move APITableNameInfoFrom.bIsAlias      to APITableNameInfoCompare.bIsAliasFrom
95568>>>>>>>            Move APITableNameInfoFrom.bIsSQL        to APITableNameInfoCompare.bIsSQLFrom
95569>>>>>>>            Move True                               to APITableNameInfoCompare.bExistsFrom
95570>>>>>>>        End
95570>>>>>>>>
95570>>>>>>>
95570>>>>>>>        // TO database info:
95570>>>>>>>        If (APITableNameInfoTo.iTableNumber > 0) Begin
95572>>>>>>>            Move APITableNameInfoTo.iTableNumber    to APITableNameInfoCompare.iTableNumber
95573>>>>>>>            Move APITableNameInfoTo.sRootName       to APITableNameInfoCompare.sRootNameTo
95574>>>>>>>            Move APITableNameInfoTo.sLogicalName    to APITableNameInfoCompare.sLogicalNameTo
95575>>>>>>>            Move APITableNameInfoTo.sDisplayName    to APITableNameInfoCompare.sDisplayNameTo
95576>>>>>>>            Move APITableNameInfoTo.sDriverID       to APITableNameInfoCompare.sDriverIDTo
95577>>>>>>>            Move APITableNameInfoTo.bIsAlias        to APITableNameInfoCompare.bIsAliasTo
95578>>>>>>>            Move APITableNameInfoTo.bIsSQL          to APITableNameInfoCompare.bIsSQLTo
95579>>>>>>>            Move True                               to APITableNameInfoCompare.bExistsTo
95580>>>>>>>        End
95580>>>>>>>>
95580>>>>>>>
95580>>>>>>>        Function_Return APITableNameInfoCompare
95581>>>>>>>    End_Function
95582>>>>>>>
95582>>>>>>>    // Note:
95582>>>>>>>    // The DF_FILE_TABLE_NAME attribute holds the name of the table at the back end. Depending on the back end, table
95582>>>>>>>    // names may be case sensitive, contain spaces or other special characters. This attribute is used to determine a table's
95582>>>>>>>    // back end name when using Embedded SQL. Since Embedded SQL works on the back end directly, the back end's name must be used.
95582>>>>>>>    // In most cases the back end name will be the same as the table name used in DataFlex.
95582>>>>>>>    // To do the opposite; To get the file handle from a table name string use the UtilTableNameToHandle function.
95582>>>>>>>    Function UtilTableHandleToString Handle hTable Returns String
95584>>>>>>>        String sTableName
95584>>>>>>>        Boolean bOpen bExists bOK
95584>>>>>>>
95584>>>>>>>        Get UtilTableNumberIsInUse hTable to bExists
95585>>>>>>>        If (bExists = False) Begin
95587>>>>>>>            Function_Return ""
95588>>>>>>>        End
95588>>>>>>>>
95588>>>>>>>
95588>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
95589>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
95592>>>>>>>        If (bOpen = False) Begin
95594>>>>>>>            Get AutoConnectionIDLogin to bOK
95595>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
95596>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
95597>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
95598>>>>>>>            Open hTable
95600>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
95601>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
95602>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
95603>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
95606>>>>>>>        End
95606>>>>>>>>
95606>>>>>>>        If (bOpen = True) Begin
95608>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
95609>>>>>>>            Get_Attribute DF_FILE_TABLE_NAME of hTable to sTableName
95612>>>>>>>            // If blank it is an embedded table:
95612>>>>>>>            If (sTableName = "") Begin
95614>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
95617>>>>>>>                Move 0 to LastErr
95618>>>>>>>                Move False to Err
95619>>>>>>>            End
95619>>>>>>>>
95619>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
95620>>>>>>>        End
95620>>>>>>>>
95620>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
95621>>>>>>>        Move 0 to LastErr
95622>>>>>>>
95622>>>>>>>        Function_Return sTableName
95623>>>>>>>    End_Function
95624>>>>>>>
95624>>>>>>>    // Returns the filenumber for the passed Table name from Filelist.cfg.
95624>>>>>>>    // Returns 0 if unsuccessful.
95624>>>>>>>    // To do the opposite; To get the string value from a table handle string use the UtilTableHandleToString function.
95624>>>>>>>    Function UtilTableNameToHandle String sTableName Returns Integer
95626>>>>>>>        String sValue sPrefixTableName sDriverID
95626>>>>>>>        Handle hTable hRetval
95626>>>>>>>
95626>>>>>>>        Get psDriverID to sDriverID
95627>>>>>>>        If (sDriverID <> DATAFLEX_ID and not(sTableName contains ":")) Begin
95629>>>>>>>            Move (sDriverID + ":" + sTableName) to sPrefixTableName
95630>>>>>>>        End
95630>>>>>>>>
95630>>>>>>>        Move 0 to hTable
95631>>>>>>>        Move 0 to hRetval
95632>>>>>>>        Repeat
95632>>>>>>>>
95632>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
95635>>>>>>>            If (hTable <> 0) Begin
95637>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sValue
95640>>>>>>>                If (Uppercase(sValue) = Uppercase(sTableName) or Uppercase(sValue) = Uppercase(sPrefixTableName)) Begin
95642>>>>>>>                    Move hTable to hRetval
95643>>>>>>>                    Move 0 to hTable
95644>>>>>>>                End
95644>>>>>>>>
95644>>>>>>>            End
95644>>>>>>>>
95644>>>>>>>        Until (hTable = 0)
95646>>>>>>>
95646>>>>>>>        Function_Return hRetval
95647>>>>>>>    End_Function
95648>>>>>>>
95648>>>>>>>    // Use function to move all *.dat, *.k?? & *.hdr files to a "Data\Backup" folder
95648>>>>>>>    // _after_ all tables have successfully been converted to SQL (.int files)
95648>>>>>>>    Function UtilMoveAllEmbeddedToBackupFolder Returns Boolean
95650>>>>>>>        Boolean bOK bExists
95650>>>>>>>        String sDataPath sBackupFolder
95650>>>>>>>
95650>>>>>>>        Close DF_ALL DF_PERMANENT
95651>>>>>>>        Send DoAdvance of ghoProgressBar
95652>>>>>>>
95652>>>>>>>        Set Message_Text of ghoStatusPanel to "Moving Embedded (*.dat) files to Backup folder."
95653>>>>>>>        Move CS_DUFBackupDataFolder to sBackupFolder
95654>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
95655>>>>>>>        Get vFolderFormat sDataPath to sDataPath
95656>>>>>>>
95656>>>>>>>        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
95657>>>>>>>        If (bExists = False) Begin
95659>>>>>>>            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
95660>>>>>>>            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
95661>>>>>>>            If (bExists = False) Begin
95663>>>>>>>                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all *.dat and *.k?? files to. You need to move them somewhere manually.")
95664>>>>>>>>
95664>>>>>>>                Function_Return False
95665>>>>>>>            End
95665>>>>>>>>
95665>>>>>>>        End
95665>>>>>>>>
95665>>>>>>>
95665>>>>>>>        Get vMoveFile (sDataPath + "*.dat") (sDataPath + sBackupFolder) to bOK
95666>>>>>>>        Get vMoveFile (sDataPath + "*.hdr") (sDataPath + sBackupFolder) to bOK
95667>>>>>>>        Get vMoveFile (sDataPath + "*.k??") (sDataPath + sBackupFolder) to bOK
95668>>>>>>>        Get vMoveFile (sDataPath + "*.vld") (sDataPath + sBackupFolder) to bOK
95669>>>>>>>        // We need to wait for Windows before we can copy files back
95669>>>>>>>        Sleep 2  
95670>>>>>>>        
95670>>>>>>>        //...except for these files that needs to be copied back to the Data folder:
95670>>>>>>>        Get vCopyFile (sBackupFolder + "\CodeMast.*")  sDataPath to bOK 
95671>>>>>>>        Get vCopyFile (sBackupFolder + "\CodeType.*")  sDataPath to bOK                                 
95672>>>>>>>        Get vCopyFile (sBackupFolder + "\Flexerrs.*")  sDataPath to bOK                                 
95673>>>>>>>        Get vCopyFile (sBackupFolder + "\DFErr001.*")  sDataPath to bOK                                 
95674>>>>>>>        Get vCopyFile (sBackupFolder + "\DFErr002.*")  sDataPath to bOK                                 
95675>>>>>>>        Get vCopyFile (sBackupFolder + "\DFErr003.*")  sDataPath to bOK                                 
95676>>>>>>>//            Get vCopyFile (sBackupFolder + "\DbVersion.*") sDataPath to bOK  
95676>>>>>>>        
95676>>>>>>>
95676>>>>>>>        Set Message_Text of ghoStatusPanel to ""
95677>>>>>>>        Function_Return True
95678>>>>>>>    End_Function
95679>>>>>>>    
95679>>>>>>>    Function UtilTableRepairAndReindexALL Returns Boolean
95681>>>>>>>        Boolean bOK bRetval
95681>>>>>>>        Handle hTable
95681>>>>>>>        Integer iSize iCount
95681>>>>>>>        
95681>>>>>>>        Move True to bOK
95682>>>>>>>        Get UtilFilelistNoOfTables to iSize
95683>>>>>>>        Set pbVisible    of ghoProgressBarOverall to True
95684>>>>>>>        Set piPosition   of ghoProgressBarOverall to 0
95685>>>>>>>        Set piMaximum    of ghoProgressBarOverall to iSize
95686>>>>>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
95687>>>>>>>
95687>>>>>>>        Repeat
95687>>>>>>>>
95687>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount
95688>>>>>>>            Increment iCount
95689>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
95692>>>>>>>            If (hTable <> 0 and hTable <> 50) Begin // 50 = Flexerrs.
95694>>>>>>>                Get UtilTableRepairAndReindex hTable to bRetval
95695>>>>>>>                If (bRetval = False) Begin
95697>>>>>>>                    Move False to bOK
95698>>>>>>>                End
95698>>>>>>>>
95698>>>>>>>            End
95698>>>>>>>>
95698>>>>>>>        Until (hTable = 0)
95700>>>>>>>                
95700>>>>>>>        Function_Return bOK
95701>>>>>>>    End_Function           
95702>>>>>>>    
95702>>>>>>>    // Checks if an Embedded (DataFlex) data-file needs to be repaired.
95702>>>>>>>    // After the header has been repaired - also makes a re-index.  
95702>>>>>>>    // Returns TRUE if successful OR the table was an an ALIAS or SQL table in case we do nothing.
95702>>>>>>>    Function UtilTableRepairAndReindex Handle hTable Returns Boolean
95704>>>>>>>        Boolean bOK bIsAlias bIsEmbedded bIsOpen bBadExists
95704>>>>>>>        Integer iRetval
95704>>>>>>>        String sRootName sFileName sDataPath
95704>>>>>>>        
95704>>>>>>>        Move False to Err
95705>>>>>>>        Move 0 to LastErr 
95706>>>>>>>        Move True to bOK
95707>>>>>>>        
95707>>>>>>>        Get UtilTableIsEmbedded hTable to bIsEmbedded
95708>>>>>>>        If (bIsEmbedded = False or hTable = 50) Begin // 50 = Flexerrs
95710>>>>>>>            Function_Return True
95711>>>>>>>        End
95711>>>>>>>>
95711>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias 
95712>>>>>>>        If (bIsAlias = True) Begin
95714>>>>>>>            Function_Return True
95715>>>>>>>        End
95715>>>>>>>>
95715>>>>>>>        
95715>>>>>>>        // Check for bad file and remove if exists
95715>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
95718>>>>>>>        Set private.phCurrentTable to hTable  
95719>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT  
95720>>>>>>>        
95720>>>>>>>        // This is important! Else it can happen that the table can't be opened,
95720>>>>>>>        // with a "4077 - File in use" error.
95720>>>>>>>        Close DF_ALL DF_PERMANENT    
95721>>>>>>>        Open hTable
95723>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
95726>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
95727>>>>>>>        If (bIsOpen = False) Begin
95729>>>>>>>            Error DFERR_PROGRAM ("Could not open table to be repaired and reindexed:" * String(sRootName))
95730>>>>>>>>
95730>>>>>>>            Function_Return False        
95731>>>>>>>        End
95731>>>>>>>>
95731>>>>>>>
95731>>>>>>>        Get vFilePathExists (sRootName + ".BAD")  to bBadExists
95732>>>>>>>        If (bBadExists = True) Begin
95734>>>>>>>            Get_File_Path (sRootName + ".BAD") to sFileName
95735>>>>>>>            Get vDeleteFile sFileName to iRetval
95736>>>>>>>        End
95736>>>>>>>>
95736>>>>>>>        
95736>>>>>>>        Set TableName_Text of ghoStatusPanel to ("Repairing and reindex Table Name:" * sRootName * "Number:" * String(hTable))
95737>>>>>>>        
95737>>>>>>>        Move False to Err
95738>>>>>>>        // **** Repair and reindex the table. ****
95738>>>>>>>        Get UtilTableRepairEmbedded hTable sRootName to bOK
95739>>>>>>>
95739>>>>>>>        // Check for bad file: if it exists, something went wrong
95739>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
95740>>>>>>>        Get vFolderFormat sDataPath to sDataPath
95741>>>>>>>        Get vFilePathExists (sDataPath + sRootName + ".BAD") to bBadExists
95742>>>>>>>        If (bBadExists = True) Begin
95744>>>>>>>            Error DFERR_PROGRAM ("Error while sorting data. .BAD file created:"  * String(sRootName) + ".BAD")
95745>>>>>>>>
95745>>>>>>>            Move False to bOK
95746>>>>>>>        End
95746>>>>>>>>
95746>>>>>>>        Close hTable
95747>>>>>>>
95747>>>>>>>        Function_Return bOK
95748>>>>>>>    End_Function
95749>>>>>>>
95749>>>>>>>    // Repair and reindex the named DataFlex data-table.
95749>>>>>>>    // No checks are done if the passed table name is an embedded or SQL,
95749>>>>>>>    // so use with care (make sure you only pass embedded table names).
95749>>>>>>>    Function UtilTableRepairEmbedded Handle hTable String sTableName Returns Boolean
95751>>>>>>>        String sMode
95751>>>>>>>        Integer iVoid
95751>>>>>>>
95751>>>>>>>        Set Message_Text of ghoStatusPanel to "Repair/Reindex in progress..."
95752>>>>>>>        Move "0" to sMode   // 0=Reindex after repair!    
95753>>>>>>>        Close hTable        // The table needs to be closed, else error 4177 "Table in use".
95754>>>>>>>        Call_Driver 0 DATAFLEX_ID Function FLEX_REPAIR_FILE Callback ghoDbUpdateHandler Passing sTableName sMode 0 Result iVoid 
95759>>>>>>>        Set Message_Text of ghoStatusPanel to ""
95760>>>>>>>        Function_Return (iVoid = 0)
95761>>>>>>>    End_Function
95762>>>>>>>
95762>>>>>>>    // Returns _two_ arrays.
95762>>>>>>>    // Returns all files that are Master files in array ByRef iaFileIsMaster
95762>>>>>>>    // Also returns all files that are Alias files in a second array.
95762>>>>>>>    // IMPORTANT: All master & alias files _must_ have been included into
95762>>>>>>>    //            the DoSetAllMasterAndAlias message.
95762>>>>>>>    Function UtilTableAllMasterAndAliasFiles Integer[] ByRef iaFileIsMaster Returns Integer[]
95764>>>>>>>        Integer[] iaFileIsAlias
95765>>>>>>>        Integer hTable iFileAlias iSize
95765>>>>>>>        Boolean bOpen
95765>>>>>>>
95765>>>>>>>        Move 0 to hTable
95766>>>>>>>        Repeat
95766>>>>>>>>
95766>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
95769>>>>>>>            If (hTable <> 0) Begin
95771>>>>>>>                Open hTable
95773>>>>>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
95776>>>>>>>                If (bOpen = True) Begin
95778>>>>>>>                    Get_Attribute DF_FILE_ALIAS of hTable to iFileAlias
95781>>>>>>>                    If (iFileAlias = DF_FILE_IS_MASTER) Begin
95783>>>>>>>                        Move (SizeOfArray(iaFileIsMaster)) to iSize
95784>>>>>>>                        Move hTable to iaFileIsMaster[iSize]
95785>>>>>>>                    End
95785>>>>>>>>
95785>>>>>>>                    Else If (iFileAlias = DF_FILE_IS_ALIAS) Begin
95788>>>>>>>                        Move (SizeOfArray(iaFileIsAlias)) to iSize
95789>>>>>>>                        Move hTable to iaFileIsAlias[iSize]
95790>>>>>>>                    End
95790>>>>>>>>
95790>>>>>>>                End
95790>>>>>>>>
95790>>>>>>>            End
95790>>>>>>>>
95790>>>>>>>        Until (hTable = 0)
95792>>>>>>>
95792>>>>>>>        Function_Return iaFileIsAlias
95793>>>>>>>    End_Function  
95794>>>>>>>    
95794>>>>>>>    // Is a repair of the data-header necessary? (Embedded tables only)
95794>>>>>>>    Function UtilTableRepairIsNeeded Handle hTable String sTableName Returns Integer
95796>>>>>>>        String sMode
95796>>>>>>>        Integer iRepairNeeded bIsOpen
95796>>>>>>>
95796>>>>>>>        Move "0" to sMode
95797>>>>>>>        Set private.phCurrentTable to hTable 
95798>>>>>>>        Close hTable
95799>>>>>>>        Open hTable
95801>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
95804>>>>>>>        Call_Driver hTable DATAFLEX_ID Function FLEX_GET_REPAIRS_NEEDED Callback 0 Passing sTableName sMode 0 Result iRepairNeeded
95809>>>>>>>
95809>>>>>>>        Function_Return iRepairNeeded
95810>>>>>>>    End_Function
95811>>>>>>>
95811>>>>>>>
95811>>>>>>>    // Helper function
95811>>>>>>>    // Takes two params:
95811>>>>>>>    //   1. An array with all master table numbers  (Function UtilTableAllMasterAndAliasFiles)
95811>>>>>>>    //   2. An array with all alias table numbers   (Function UtilTableAllMasterAndAliasFiles)
95811>>>>>>>    // Returns:
95811>>>>>>>    //  DF_FILE_ALIAS_DEFAULT if no master or alias
95811>>>>>>>    //  DF_FILE_IS_MASTER if master
95811>>>>>>>    //  DF_FILE_IS_ALIAS if alias
95811>>>>>>>    Function UtilTableIsMasterAlias Handle hTable Integer[] iaFileIsMaster Integer[] iaFileIsAlias Returns Integer
95813>>>>>>>        Integer i iSize
95813>>>>>>>
95813>>>>>>>        Move (SizeOfArray(iaFileIsMaster)) to iSize
95814>>>>>>>        Decrement iSize
95815>>>>>>>        for i from 0 to iSize
95821>>>>>>>>
95821>>>>>>>            If (hTable = iaFileIsMaster[i]) Begin
95823>>>>>>>                Function_Return DF_FILE_IS_MASTER
95824>>>>>>>            End
95824>>>>>>>>
95824>>>>>>>        Loop
95825>>>>>>>>
95825>>>>>>>
95825>>>>>>>        Move (SizeOfArray(iaFileIsAlias)) to iSize
95826>>>>>>>        Decrement iSize
95827>>>>>>>        for i from 0 to iSize
95833>>>>>>>>
95833>>>>>>>            If (hTable = iaFileIsAlias[i]) Begin
95835>>>>>>>                Function_Return DF_FILE_IS_ALIAS
95836>>>>>>>            End
95836>>>>>>>>
95836>>>>>>>        Loop
95837>>>>>>>>
95837>>>>>>>
95837>>>>>>>        Function_Return DF_FILE_ALIAS_DEFAULT
95838>>>>>>>    End_Function
95839>>>>>>>
95839>>>>>>>    // Determine the available indexes of a table.
95839>>>>>>>    //
95839>>>>>>>    // Arguments:
95839>>>>>>>    //   Handle hTable - The number of the table
95839>>>>>>>    //
95839>>>>>>>    // Returns:
95839>>>>>>>    //   String - A string to be used with the sort command
95839>>>>>>>    //   to re-index all indexes of a table.
95839>>>>>>>    Function UtilTableIndexString Handle hTable Returns String
95841>>>>>>>        String  sSortString
95841>>>>>>>        Integer iLastIndex iNumSegments iCount
95841>>>>>>>
95841>>>>>>>        Move "" to sSortString
95842>>>>>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
95845>>>>>>>
95845>>>>>>>        for iCount from 1 to iLastIndex
95851>>>>>>>>
95851>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iCount to iNumSegments
95854>>>>>>>            If iNumSegments Begin
95856>>>>>>>                If (Length(sSortString)) ;                    Move (Append(sSortString, " ")) to sSortString
95859>>>>>>>                Move (Append(sSortString, iCount)) to sSortString
95860>>>>>>>            End
95860>>>>>>>>
95860>>>>>>>        Loop
95861>>>>>>>>
95861>>>>>>>
95861>>>>>>>        Function_Return sSortString
95862>>>>>>>    End_Function
95863>>>>>>>
95863>>>>>>>    
95863>>>>>>>    // * Dummy function for the Studio's Code Explorer *
95863>>>>>>>    Function API_COLUMN_UTILITY_FUNCTIONS Returns Boolean
95865>>>>>>>        Function_Return False
95866>>>>>>>    End_Function
95867>>>>>>>
95867>>>>>>>    // Compare multiple columns. (For 'FROM' & 'TO' tables)
95867>>>>>>>    Function UtilColumnsCompare String sDriverIDFrom String sDriverIDTo Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare[] aAPIColumnCompare Boolean bCompareDate_DataTime Returns Boolean
95869>>>>>>>        Boolean bIsSame
95869>>>>>>>        Integer iCount iColumns iColumn
95869>>>>>>>
95869>>>>>>>        Move True to bIsSame
95870>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iColumns
95871>>>>>>>        Set piMaximum of ghoProgressBar  to iColumns
95872>>>>>>>        Decrement iColumns
95873>>>>>>>
95873>>>>>>>        for iCount from 0 to iColumns
95879>>>>>>>>
95879>>>>>>>            Set piPosition of ghoProgressBar to iCount
95880>>>>>>>            Get UtilColumnCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare[iCount] bCompareDate_DataTime to bIsSame
95881>>>>>>>            If (bIsSame = False) Begin
95883>>>>>>>                Function_Return False
95884>>>>>>>            End
95884>>>>>>>>
95884>>>>>>>        Loop
95885>>>>>>>>
95885>>>>>>>
95885>>>>>>>        Function_Return (bIsSame = True)
95886>>>>>>>    End_Function
95887>>>>>>>
95887>>>>>>>    // Compares a single column (For 'FROM' & 'TO' tables)
95887>>>>>>>    Function UtilColumnCompare String sDriverIDFrom String sDriverIDTo Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare APIColumnCompare Boolean bCompareDate_DataTime Returns Boolean
95889>>>>>>>        Integer iFromType iToType iDbType
95889>>>>>>>        tColumnType ColumnType
95889>>>>>>>        tColumnType ColumnType
95889>>>>>>>        Boolean bIsDateTypeFrom bIsDateTypeTo
95889>>>>>>>
95889>>>>>>>        If (APIColumnCompare.bCancelFrom = True or APIColumnCompare.bCancelTo = True) Begin
95891>>>>>>>            Function_Return False
95892>>>>>>>        End
95892>>>>>>>>
95892>>>>>>>        If (APIColumnCompare.bExistsFrom = False or APIColumnCompare.bExistsTo = False) Begin
95894>>>>>>>            Function_Return False
95895>>>>>>>        End
95895>>>>>>>>
95895>>>>>>>        If (Uppercase(APIColumnCompare.sFieldNameFrom) <> Uppercase(APIColumnCompare.sFieldNameTo)) Begin
95897>>>>>>>            Function_Return False
95898>>>>>>>        End                                                                
95898>>>>>>>>
95898>>>>>>>
95898>>>>>>>        If (bIsSQLFrom = True and bIsSQLTo = True) Begin
95900>>>>>>>            If (APIColumnCompare.bAllowNULLFrom <> APIColumnCompare.bAllowNULLTo) Begin
95902>>>>>>>                Function_Return False
95903>>>>>>>            End
95903>>>>>>>>
95903>>>>>>>            If (APIColumnCompare.sDefaultValueFrom <> APIColumnCompare.sDefaultValueTo) Begin
95905>>>>>>>                If ((APIColumnCompare.sDefaultValueFrom = ""   and APIColumnCompare.sDefaultValueTo = "''") or ;                    (APIColumnCompare.sDefaultValueFrom = "''" and APIColumnCompare.sDefaultValueTo = "")) Begin
95907>>>>>>>                    End
95907>>>>>>>>
95907>>>>>>>                Else Begin
95908>>>>>>>                    Function_Return False
95909>>>>>>>                End
95909>>>>>>>>
95909>>>>>>>            End
95909>>>>>>>>
95909>>>>>>>        End
95909>>>>>>>>
95909>>>>>>>
95909>>>>>>>        Get piDbType                       to iDbType
95910>>>>>>>        Move APIColumnCompare.iTypeFrom    to iFromType
95911>>>>>>>        Move APIColumnCompare.iTypeTo      to iToType
95912>>>>>>>
95912>>>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
95912>>>>>>>        // data types between Embedded and SQL.
95912>>>>>>>        If (bIsSQLFrom = True and bIsSQLTo = False) Begin
95914>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iFromType APIColumnCompare.iLengthFrom to iFromType
95915>>>>>>>        End
95915>>>>>>>>
95915>>>>>>>        If (bIsSQLFrom = False and bIsSQLTo = True) Begin
95917>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDTo iDbType iToType APIColumnCompare.iLengthTo to iToType
95918>>>>>>>        End
95918>>>>>>>>
95918>>>>>>>
95918>>>>>>>        Get UtilColumnIsDateType iFromType bIsSQLFrom to bIsDateTypeFrom
95919>>>>>>>        Get UtilColumnIsDateType iToType   bIsSQLTo   to bIsDateTypeTo
95920>>>>>>>
95920>>>>>>>        // Make Date and DateTime comparison?
95920>>>>>>>        If (bCompareDate_DataTime = True) Begin
95922>>>>>>>            If (iFromType <> iToType) Begin
95924>>>>>>>                Function_Return False
95925>>>>>>>            End
95925>>>>>>>>
95925>>>>>>>        End
95925>>>>>>>>
95925>>>>>>>
95925>>>>>>>        // This is when not checking for Date/DateTime differences but all other other field types...
95925>>>>>>>        If (bCompareDate_DataTime = False and bIsDateTypeFrom = False) Begin
95927>>>>>>>            If (iFromType <> iToType) Begin
95929>>>>>>>                Function_Return False
95930>>>>>>>            End
95930>>>>>>>>
95930>>>>>>>        End
95930>>>>>>>>
95930>>>>>>>
95930>>>>>>>        // Only if the field is not a Date type (any of them) we compare length & precision.
95930>>>>>>>        If (bIsDateTypeFrom = False) Begin
95932>>>>>>>            If (APIColumnCompare.iLengthFrom <> APIColumnCompare.iLengthTo) Begin
95934>>>>>>>                Function_Return False
95935>>>>>>>            End
95935>>>>>>>>
95935>>>>>>>            If (APIColumnCompare.iPrecisionFrom <> APIColumnCompare.iPrecisionTo) Begin
95937>>>>>>>                Function_Return False
95938>>>>>>>            End
95938>>>>>>>>
95938>>>>>>>        End
95938>>>>>>>>
95938>>>>>>>
95938>>>>>>>        If (APIColumnCompare.iOptionsFrom <> APIColumnCompare.iOptionsTo) Begin
95940>>>>>>>            Function_Return False
95941>>>>>>>        End
95941>>>>>>>>
95941>>>>>>>
95941>>>>>>>        Function_Return True
95942>>>>>>>    End_Function
95943>>>>>>>
95943>>>>>>>    Function UtilColumnsStructFill Handle hTable Returns tAPIColumn[]
95945>>>>>>>        Integer iNumColumns iColumn iCount iOptions iDbType iType iCheckFieldNumber
95945>>>>>>>        Boolean bIdentityKey bDawSqlDriver bSqlDriver bIsOpen bExists bIsSqlTable bUserCancel
95945>>>>>>>        tAPIColumn[] APIColumns APIColumnsEmpty
95945>>>>>>>        tAPIColumn[] APIColumns APIColumnsEmpty
95947>>>>>>>        String sDriverID sRootName sLogicalName
95947>>>>>>>
95947>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
95948>>>>>>>        Get piDbType to iDbType
95949>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
95952>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
95955>>>>>>>
95955>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
95958>>>>>>>        If (bIsOpen = False) Begin
95960>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
95961>>>>>>>            Open hTable
95963>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
95964>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
95967>>>>>>>            If (bIsOpen = False) Begin
95969>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
95970>>>>>>>                Move True to APIColumnsEmpty[0].bError
95971>>>>>>>                Function_Return APIColumnsEmpty
95972>>>>>>>            End
95972>>>>>>>>
95972>>>>>>>        End
95972>>>>>>>>
95972>>>>>>>
95972>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
95975>>>>>>>        Get IsSQLDriver    sDriverID to bSqlDriver
95976>>>>>>>        Get IsDAWSQLDriver sDriverID to bDawSqlDriver
95977>>>>>>>
95977>>>>>>>        Get UtilTableIsSQLByRootName sRootName to bIsSqlTable
95978>>>>>>>        If (bIsSqlTable = True) Begin
95980>>>>>>>            Get UtilTableExists hTable to bExists
95981>>>>>>>            If (bExists = False) Begin
95983>>>>>>>                Move True to APIColumnsEmpty[0].bError
95984>>>>>>>                Function_Return APIColumnsEmpty
95985>>>>>>>            End
95985>>>>>>>>
95985>>>>>>>        End
95985>>>>>>>>
95985>>>>>>>
95985>>>>>>>        Move 0 to iCount
95986>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
95989>>>>>>>        Set piMaximum of ghoProgressBar to iNumColumns
95990>>>>>>>
95990>>>>>>>        for iColumn from 1 to iNumColumns
95996>>>>>>>>
95996>>>>>>>            Move 0 to iOptions
95997>>>>>>>            Move False to bIdentityKey
95998>>>>>>>            Move False to Err
95999>>>>>>>            Move 0     to LastErr
96000>>>>>>>            Move bIsSqlTable to APIColumns[iCount].bIsSQLType
96001>>>>>>>            Set piPosition of ghoProgressBar to iColumn
96002>>>>>>>            If (bDawSqlDriver = True) Begin
96004>>>>>>>                Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
96005>>>>>>>                If (bIsSqlTable = True) Begin
96007>>>>>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iType
96010>>>>>>>                    Move iType                                                to APIColumns[iCount].iType
96011>>>>>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE_NAME of hTable iColumn to APIColumns[iCount].sType
96014>>>>>>>                    Get_Attribute DF_FIELD_NULL_ALLOWED     of hTable iColumn to APIColumns[iCount].bAllowNULL
96017>>>>>>>                    Get_Attribute DF_FIELD_DEFAULT_VALUE    of hTable iColumn to APIColumns[iCount].sDefaultValue
96020>>>>>>>                End
96020>>>>>>>>
96020>>>>>>>                Else Begin
96021>>>>>>>                    Get_Attribute DF_FIELD_TYPE             of hTable iColumn to APIColumns[iCount].iType
96024>>>>>>>                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
96025>>>>>>>                End
96025>>>>>>>>
96025>>>>>>>
96025>>>>>>>                // If the array value is out of bounce it means that this column doesn't exist on the backend.
96025>>>>>>>                Get_Attribute DF_Field_Number of hTable iColumn to iCheckFieldNumber
96028>>>>>>>                Move (iCheckFieldNumber >= 0) to bExists
96029>>>>>>>                If (bExists = False) Begin
96031>>>>>>>                    Move 0 to APIColumns[iCount].iType
96032>>>>>>>                End
96032>>>>>>>>
96032>>>>>>>                If (bExists = True) Begin
96034>>>>>>>                    Get_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to bIdentityKey
96037>>>>>>>                End
96037>>>>>>>>
96037>>>>>>>                Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
96038>>>>>>>                If (bIdentityKey = True) Begin
96040>>>>>>>                    Move C_tAPIColumn_Identity to APIColumns[iCount].iOptions
96041>>>>>>>                End
96041>>>>>>>>
96041>>>>>>>            End
96041>>>>>>>>
96041>>>>>>>            Else Begin
96042>>>>>>>                Move False to Err
96043>>>>>>>                Move 0     to LastErr
96044>>>>>>>                If (bIsSqlTable = True) Begin
96046>>>>>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to APIColumns[iCount].iType
96049>>>>>>>                End
96049>>>>>>>>
96049>>>>>>>                Else Begin
96050>>>>>>>                    Get_Attribute DF_FIELD_TYPE        of hTable iColumn to APIColumns[iCount].iType
96053>>>>>>>                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
96054>>>>>>>                End
96054>>>>>>>>
96054>>>>>>>                // If the array value is out of bounce it means that this column doesn't exist on the backend.
96054>>>>>>>                Move (LastErr <> DFERR_ARRAY_INDEX_OUT_OF_BOUNDS) to bExists
96055>>>>>>>                If (bExists = False) Begin
96057>>>>>>>                    Move 0 to APIColumns[iCount].iType
96058>>>>>>>                End
96058>>>>>>>>
96058>>>>>>>            End
96058>>>>>>>>
96058>>>>>>>
96058>>>>>>>            If (bExists = True) Begin
96060>>>>>>>                Move iColumn to APIColumns[iCount].iFieldNumber
96061>>>>>>>                Get_Attribute DF_FIELD_NAME        of hTable iColumn to APIColumns[iCount].sFieldName
96064>>>>>>>                // ToDo: Can't use native_size as it can get way to big and causes "out of memory" problems.
96064>>>>>>>//                If (bIsSqlTable = True) Begin
96064>>>>>>>//                    Get_Attribute DF_FIELD_NATIVE_SIZE of hTable iColumn to APIColumns[iCount].iLength
96064>>>>>>>//                    Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
96064>>>>>>>//                End
96064>>>>>>>                Get_Attribute DF_FIELD_LENGTH      of hTable iColumn to APIColumns[iCount].iLength
96067>>>>>>>                Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
96070>>>>>>>
96070>>>>>>>                // If the length was zero we might have an Overlap(!) field.
96070>>>>>>>                // We then need check the DF_FIELD_TYPE if it really is and reset data for this array item.
96070>>>>>>>                If (APIColumns[iCount].iLength = 0) Begin
96072>>>>>>>                    Get_Attribute DF_FIELD_TYPE    of hTable iColumn to iType
96075>>>>>>>                    If (iType = DF_OVERLAP) Begin
96077>>>>>>>                        Move 0 to APIColumns[iCount].iFieldNumber
96078>>>>>>>                        Move 0 to APIColumns[iCount].iLength
96079>>>>>>>                        Move 0 to APIColumns[iCount].iOptions
96080>>>>>>>                        Move 0 to APIColumns[iCount].iPrecision
96081>>>>>>>                        Move DF_OVERLAP to APIColumns[iCount].iType
96082>>>>>>>                        Move "" to APIColumns[iCount].sFieldName
96083>>>>>>>                        Decrement iCount
96084>>>>>>>                    End
96084>>>>>>>>
96084>>>>>>>                End
96084>>>>>>>>
96084>>>>>>>            End
96084>>>>>>>>
96084>>>>>>>            Get Check_StatusPanel of ghoStatusPanel to bUserCancel
96085>>>>>>>            If (bUserCancel = True) Begin
96087>>>>>>>                Move True to APIColumnsEmpty[0].bCancel
96088>>>>>>>                Function_Return APIColumnsEmpty
96089>>>>>>>            End
96089>>>>>>>>
96089>>>>>>>            Increment iCount
96090>>>>>>>        Loop
96091>>>>>>>>
96091>>>>>>>
96091>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
96092>>>>>>>        Function_Return APIColumns
96093>>>>>>>    End_Function
96094>>>>>>>
96094>>>>>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
96094>>>>>>>    // The combined data will be sorted on the first struct member: iIndexNumber
96094>>>>>>>    // This is needed because index numbers can start at any number. The range for a particular table might also
96094>>>>>>>    // have "holes" in the series of index numbers.
96094>>>>>>>    Function UtilColumnCombineFromAndToArrays tAPIColumn[] APIColumnFrom tAPIColumn[] APIColumnTo Returns tAPIIndexCompare[]
96096>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
96096>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
96097>>>>>>>        tAPIColumnCompare   APIColumnCompare
96097>>>>>>>        tAPIColumnCompare   APIColumnCompare
96097>>>>>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
96097>>>>>>>
96097>>>>>>>        Move (SizeOfArray(APIColumnFrom)) to iSizeFrom
96098>>>>>>>        Decrement iSizeFrom
96099>>>>>>>        for iCount from 0 to iSizeFrom
96105>>>>>>>>
96105>>>>>>>            Move APIColumnFrom[iCount].iFieldNumber     to aAPIColumnCompare[iCount].iFieldNumber
96106>>>>>>>            Move APIColumnFrom[iCount].sFieldName       to aAPIColumnCompare[iCount].sFieldNameFrom
96107>>>>>>>            Move APIColumnFrom[iCount].iType            to aAPIColumnCompare[iCount].iTypeFrom
96108>>>>>>>            Move APIColumnFrom[iCount].sType            to aAPIColumnCompare[iCount].sTypeFrom
96109>>>>>>>            Move APIColumnFrom[iCount].iLength          to aAPIColumnCompare[iCount].iLengthFrom
96110>>>>>>>            Move APIColumnFrom[iCount].iPrecision       to aAPIColumnCompare[iCount].iPrecisionFrom
96111>>>>>>>            Move APIColumnFrom[iCount].iOptions         to aAPIColumnCompare[iCount].iOptionsFrom
96112>>>>>>>            Move APIColumnFrom[iCount].bIsSQLType       to aAPIColumnCompare[iCount].bIsSQLTypeFrom
96113>>>>>>>            Move APIColumnFrom[iCount].bAllowNULL       to aAPIColumnCompare[iCount].bAllowNULLFrom
96114>>>>>>>            Move APIColumnFrom[iCount].sDefaultValue    to aAPIColumnCompare[iCount].sDefaultValueFrom
96115>>>>>>>            Move APIColumnFrom[iCount].bShouldChange    to aAPIColumnCompare[iCount].bShouldChangeFrom
96116>>>>>>>            Move APIColumnFrom[iCount].bCancel          to aAPIColumnCompare[iCount].bCancelFrom
96117>>>>>>>            Move APIColumnFrom[iCount].bError           to aAPIColumnCompare[iCount].bErrorFrom
96118>>>>>>>            Move True                                   to aAPIColumnCompare[iCount].bExistsFrom
96119>>>>>>>        Loop
96120>>>>>>>>
96120>>>>>>>
96120>>>>>>>        Move (SizeOfArray(APIColumnTo)) to iSizeTo
96121>>>>>>>        Decrement iSizeTo
96122>>>>>>>        for iCount from 0 to iSizeTo
96128>>>>>>>>
96128>>>>>>>            Move APIColumnTo[iCount].iFieldNumber       to APIColumnCompare.iFieldNumber
96129>>>>>>>            // Search if the field number already exists in the array; else add it.
96129>>>>>>>            Move (SearchArray(APIColumnCompare, aAPIColumnCompare)) to iItem
96130>>>>>>>            If (iItem = -1) Begin
96132>>>>>>>                Move (SizeOfArray(aAPIColumnCompare))   to iItem
96133>>>>>>>            End
96133>>>>>>>>
96133>>>>>>>
96133>>>>>>>            Move APIColumnCompare.iFieldNumber          to aAPIColumnCompare[iItem].iFieldNumber
96134>>>>>>>            Move APIColumnTo[iCount].iFieldNumber       to aAPIColumnCompare[iItem].iFieldNumberTo
96135>>>>>>>            Move APIColumnTo[iCount].sFieldName         to aAPIColumnCompare[iItem].sFieldNameTo
96136>>>>>>>            Move APIColumnTo[iCount].iType              to aAPIColumnCompare[iItem].iTypeTo
96137>>>>>>>            Move APIColumnTo[iCount].sType              to aAPIColumnCompare[iItem].sTypeTo
96138>>>>>>>            Move APIColumnTo[iCount].iLength            to aAPIColumnCompare[iItem].iLengthTo
96139>>>>>>>            Move APIColumnTo[iCount].iPrecision         to aAPIColumnCompare[iItem].iPrecisionTo
96140>>>>>>>            Move APIColumnTo[iCount].iOptions           to aAPIColumnCompare[iItem].iOptionsTo
96141>>>>>>>            Move APIColumnTo[iCount].bIsSQLType         to aAPIColumnCompare[iItem].bIsSQLTypeTo
96142>>>>>>>            Move APIColumnTo[iCount].bAllowNULL         to aAPIColumnCompare[iItem].bAllowNULLTo
96143>>>>>>>            Move APIColumnTo[iCount].sDefaultValue      to aAPIColumnCompare[iItem].sDefaultValueTo
96144>>>>>>>            Move APIColumnTo[iCount].bShouldChange      to aAPIColumnCompare[iItem].bShouldChangeTo
96145>>>>>>>            Move APIColumnTo[iCount].bCancel            to aAPIColumnCompare[iItem].bCancelTo
96146>>>>>>>            Move APIColumnTo[iCount].bError             to aAPIColumnCompare[iItem].bErrorTo
96147>>>>>>>            Move True                                   to aAPIColumnCompare[iItem].bExistsTo
96148>>>>>>>        Loop
96149>>>>>>>>
96149>>>>>>>
96149>>>>>>>        Move (SortArray(aAPIColumnCompare)) to aAPIColumnCompare
96150>>>>>>>
96150>>>>>>>        Function_Return aAPIColumnCompare
96151>>>>>>>    End_Function
96152>>>>>>>
96152>>>>>>>    // Checks if a field name exists in a table definition
96152>>>>>>>    // Returns True if it does
96152>>>>>>>    // Sample:
96152>>>>>>>    //   Get UtilColumnExists MyTable.File_Number "MyColumnName" to iExists
96152>>>>>>>    Function UtilColumnExists Handle hTable String sFieldName Returns Boolean
96154>>>>>>>        Integer iNumColumns iColumn
96154>>>>>>>        String sColumn
96154>>>>>>>        Boolean bExists bOK bOpen
96154>>>>>>>
96154>>>>>>>        Get AutoConnectionIDLogin to bOK
96155>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
96156>>>>>>>        Open hTable
96158>>>>>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
96159>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
96162>>>>>>>        If (bOpen = False) Begin
96164>>>>>>>            Function_Return False
96165>>>>>>>        End
96165>>>>>>>>
96165>>>>>>>
96165>>>>>>>        Move False to bExists
96166>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
96169>>>>>>>        for iColumn from 1 to iNumColumns
96175>>>>>>>>
96175>>>>>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
96178>>>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
96180>>>>>>>                Move iNumColumns to iColumn
96181>>>>>>>                Move True to bExists
96182>>>>>>>            End
96182>>>>>>>>
96182>>>>>>>        Loop
96183>>>>>>>>
96183>>>>>>>        Close hTable
96184>>>>>>>
96184>>>>>>>        Function_Return bExists
96185>>>>>>>    End_Function
96186>>>>>>>
96186>>>>>>>    // Returns the field/column number for the passed FieldName as an integer.
96186>>>>>>>    Function UtilColumnNameToColumnNumber Handle hTable String sFieldName Returns Integer
96188>>>>>>>        Integer iNumColumns iColumn iRetval
96188>>>>>>>        String sColumn
96188>>>>>>>        Boolean bOK bOpen
96188>>>>>>>
96188>>>>>>>        Get AutoConnectionIDLogin to bOK
96189>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
96190>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
96191>>>>>>>        Open hTable
96193>>>>>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
96194>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
96197>>>>>>>        If (bOpen = False) Begin
96199>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
96200>>>>>>>            Function_Return False
96201>>>>>>>        End
96201>>>>>>>>
96201>>>>>>>
96201>>>>>>>        Move 0 to iColumn
96202>>>>>>>        Move 0 to iRetval
96203>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
96206>>>>>>>        for iColumn from 1 to iNumColumns
96212>>>>>>>>
96212>>>>>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
96215>>>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
96217>>>>>>>                Move iColumn to iRetval
96218>>>>>>>                Move iNumColumns to iColumn
96219>>>>>>>            End
96219>>>>>>>>
96219>>>>>>>        Loop
96220>>>>>>>>
96220>>>>>>>        Close hTable
96221>>>>>>>
96221>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
96222>>>>>>>        Function_Return iRetval
96223>>>>>>>    End_Function
96224>>>>>>>
96224>>>>>>>    // To convert between a data type string name and its integer constant declaration. E.g."VarChar" -> SQL_VarChar
96224>>>>>>>    // The reciprocal function is UtilColumnTypeToInteger.
96224>>>>>>>    Function UtilColumnTypeToInteger String sDriverID Integer iDbType String sDataType Returns Integer
96226>>>>>>>        tColumnType RetvalType
96226>>>>>>>        tColumnType RetvalType
96226>>>>>>>
96226>>>>>>>        Get _UtilColumnType sDriverID iDbType 0 sDataType False to RetvalType
96227>>>>>>>        Function_Return RetvalType.iSQLType
96228>>>>>>>    End_Function
96229>>>>>>>
96229>>>>>>>    // To convert between an integer data type constant and its string value. E.g. SQL_VarChar -> "VarChar".
96229>>>>>>>    // The reciprocal function is UtilColumnTypeToString.
96229>>>>>>>    Function UtilColumnTypeToString String sDriverID Integer iDbType Integer iDataType Returns String
96231>>>>>>>        tColumnType RetvalType
96231>>>>>>>        tColumnType RetvalType
96231>>>>>>>
96231>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
96232>>>>>>>        Function_Return RetvalType.sSQLType
96233>>>>>>>    End_Function
96234>>>>>>>
96234>>>>>>>    Function UtilColumnTypePrecision String sDriverID Integer iDbType Integer iDataType Returns String
96236>>>>>>>        tColumnType RetvalType
96236>>>>>>>        tColumnType RetvalType
96236>>>>>>>
96236>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
96237>>>>>>>        Function_Return RetvalType.sPrecision
96238>>>>>>>    End_Function
96239>>>>>>>
96239>>>>>>>    Function UtilColumnTypeFixed String sDriverID Integer iDbType Integer iDataType Returns Boolean
96241>>>>>>>        tColumnType RetvalType
96241>>>>>>>        tColumnType RetvalType
96241>>>>>>>
96241>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
96242>>>>>>>        // Nils 2019-02-15. This return value seems to have been wrong. The function should return False
96242>>>>>>>        // if the column type length is _not_ fixed.
96242>>>>>>>        Function_Return (RetvalType.bCanEditSize = False)
96243>>>>>>>    End_Function
96244>>>>>>>
96244>>>>>>>    Function UtilColumnTypePrecisionSize String sDriverID Integer iDbType Integer iDataType Returns Integer
96246>>>>>>>        tColumnType RetvalType
96246>>>>>>>        tColumnType RetvalType
96246>>>>>>>        String sValue
96246>>>>>>>        Integer iRetval iPos
96246>>>>>>>
96246>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
96247>>>>>>>        Move RetvalType.sPrecision to sValue
96248>>>>>>>        Move (Pos(".", sValue)) to iPos
96249>>>>>>>        If (iPos <> 0) Begin
96251>>>>>>>            Move (Left(sValue, (iPos -1))) to iRetval
96252>>>>>>>        End
96252>>>>>>>>
96252>>>>>>>        Else Begin
96253>>>>>>>            Move sValue to iRetval
96254>>>>>>>        End
96254>>>>>>>>
96254>>>>>>>        Function_Return iRetval
96255>>>>>>>    End_Function
96256>>>>>>>
96256>>>>>>>    Function UtilColumnTypePrecisionDec String sDriverID Integer iDbType Integer iDataType Returns Integer
96258>>>>>>>        tColumnType RetvalType
96258>>>>>>>        tColumnType RetvalType
96258>>>>>>>        String sValue
96258>>>>>>>        Integer iRetval iPos
96258>>>>>>>
96258>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
96259>>>>>>>        Move RetvalType.sPrecision to sValue
96260>>>>>>>        Move (Pos(".", sValue)) to iPos
96261>>>>>>>        If (iPos = 0) Begin
96263>>>>>>>            Function_Return 0
96264>>>>>>>        End
96264>>>>>>>>
96264>>>>>>>        Move (Mid(sValue, 99, (iPos + 1))) to iRetval
96265>>>>>>>
96265>>>>>>>        Function_Return iRetval
96266>>>>>>>    End_Function
96267>>>>>>>
96267>>>>>>>    // * Dummy function for the Studio's Code Explorer *
96267>>>>>>>    Function API_INDEX_UTILITY_FUNCTIONS Returns Boolean
96269>>>>>>>        Function_Return False
96270>>>>>>>    End_Function
96271>>>>>>>
96271>>>>>>>    // Compares multiple indexes for a 'FROM' and a 'TO' table.
96271>>>>>>>    Function UtilIndexesCompare Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndexCompare[] aAPIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
96273>>>>>>>        Boolean bIsSame
96273>>>>>>>        Integer iCount iSize
96273>>>>>>>
96273>>>>>>>        Move True to bIsSame
96274>>>>>>>        Move (SizeOfArray(aAPIIndexCompare)) to iSize
96275>>>>>>>        Decrement iSize
96276>>>>>>>        For iCount from 0 to iSize
96282>>>>>>>>
96282>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
96283>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
96284>>>>>>>            Get UtilIndexCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
96285>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
96286>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
96287>>>>>>>            If (bIsSame = False) Begin
96289>>>>>>>                Function_Return False
96290>>>>>>>            End
96290>>>>>>>>
96290>>>>>>>        Loop
96291>>>>>>>>
96291>>>>>>>
96291>>>>>>>        Function_Return bIsSame
96292>>>>>>>    End_Function
96293>>>>>>>
96293>>>>>>>    // Compares a single index for a 'FROM' and a 'TO' table.
96293>>>>>>>    Function UtilIndexCompare Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndexCompare APIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
96295>>>>>>>        Boolean bIsSame
96295>>>>>>>        Integer iSegment
96295>>>>>>>
96295>>>>>>>        Move (APIIndexCompare.bExistsFrom = APIIndexCompare.bExistsTo) to bIsSame
96296>>>>>>>        If (bIsSame = False) Begin
96298>>>>>>>            Function_Return False
96299>>>>>>>        End
96299>>>>>>>>
96299>>>>>>>        Move (APIIndexCompare.iPrimaryIndexFrom = APIIndexCompare.iPrimaryIndexTo) to bIsSame
96300>>>>>>>        If (bIsSame = False) Begin
96302>>>>>>>            Function_Return False
96303>>>>>>>        End
96303>>>>>>>>
96303>>>>>>>
96303>>>>>>>        If (bIsSqlTableFrom = True and bIsSqlTableTo = True) Begin
96305>>>>>>>            // * We should probably not compare SQL index names?
96305>>>>>>>            // Move (Uppercase(aIndexFrom.sSQLIndexName) = Uppercase(aIndexTo.sSQLIndexName)) to bIsSame
96305>>>>>>>            // If (bIsSame = False) Begin   DF_INDEX_SERVER_ONLY
96305>>>>>>>            //     Function_Return False
96305>>>>>>>            // End
96305>>>>>>>            Move (APIIndexCompare.bIsSQLPrimaryKeyFrom = APIIndexCompare.bIsSQLPrimaryKeyTo) to bIsSame
96306>>>>>>>            If (bIsSame = False) Begin
96308>>>>>>>                Function_Return False
96309>>>>>>>            End
96309>>>>>>>>
96309>>>>>>>            Move (APIIndexCompare.bIsSQLClusteredFrom = APIIndexCompare.bIsSQLClusteredTo) to bIsSame
96310>>>>>>>            If (bIsSame = False) Begin
96312>>>>>>>                Function_Return False
96313>>>>>>>            End
96313>>>>>>>>
96313>>>>>>>            Move (APIIndexCompare.iSQLIndexTypeFrom = APIIndexCompare.iSQLIndexTypeTo) to bIsSame
96314>>>>>>>            If (bIsSame = False) Begin
96316>>>>>>>                Function_Return False
96317>>>>>>>            End
96317>>>>>>>>
96317>>>>>>>            Move (Uppercase(APIIndexCompare.sSQLIndexNameFrom) = Uppercase(APIIndexCompare.sSQLIndexNameTo)) to bIsSame
96318>>>>>>>            If (bIsSame = False) Begin
96320>>>>>>>                Function_Return False
96321>>>>>>>            End
96321>>>>>>>>
96321>>>>>>>        End
96321>>>>>>>>
96321>>>>>>>
96321>>>>>>>        Get UtilIndexSegmentsCompare APIIndexCompare.IndexSegmentArrayFrom APIIndexCompare.IndexSegmentArrayTo bCompareIndexUppercase bCompareIndexAscending to iSegment
96322>>>>>>>        Move (iSegment = -1) to bIsSame
96323>>>>>>>
96323>>>>>>>        Function_Return (bIsSame = True)
96324>>>>>>>    End_Function
96325>>>>>>>
96325>>>>>>>    // Compares each segment for the passed index.
96325>>>>>>>    // Returns -1 if same; else returns the index segment that differs.
96325>>>>>>>    Function UtilIndexSegmentsCompare tAPIIndexSegment[] aIndexSegmentFrom tAPIIndexSegment[] aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
96327>>>>>>>        Integer iNumSegmentsFrom iNumSegmentsTo iNumSegments iSegment
96327>>>>>>>        Boolean bIsSame
96327>>>>>>>
96327>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
96328>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
96329>>>>>>>        Move (SizeOfArray(aIndexSegmentFrom))      to iNumSegmentsFrom
96330>>>>>>>        Move (SizeOfArray(aIndexSegmentTo))        to iNumSegmentsTo
96331>>>>>>>        Move (iNumSegmentsFrom max iNumSegmentsTo) to iNumSegments
96332>>>>>>>
96332>>>>>>>        Decrement iNumSegments
96333>>>>>>>        for iSegment from 0 to iNumSegments
96339>>>>>>>>
96339>>>>>>>            Move False to bIsSame
96340>>>>>>>            If (iSegment < iNumSegmentsFrom and iSegment < iNumSegmentsTo) Begin
96342>>>>>>>                Get UtilIndexSegmentCompare aIndexSegmentFrom[iSegment] aIndexSegmentTo[iSegment] bCompareIndexUppercase bCompareIndexAscending to bIsSame
96343>>>>>>>            End
96343>>>>>>>>
96343>>>>>>>            If (bIsSame = False) Begin
96345>>>>>>>                Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
96346>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
96347>>>>>>>                Function_Return iSegment
96348>>>>>>>            End
96348>>>>>>>>
96348>>>>>>>        Loop
96349>>>>>>>>
96349>>>>>>>
96349>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
96350>>>>>>>        Function_Return -1 // This means bIsSame = True
96351>>>>>>>    End_Function
96352>>>>>>>
96352>>>>>>>    Function UtilIndexSegmentCompare tAPIIndexSegment aIndexSegmentFrom tAPIIndexSegment aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
96354>>>>>>>        Boolean bIsSame
96354>>>>>>>
96354>>>>>>>        Move (aIndexSegmentFrom.iFieldNumber = aIndexSegmentTo.iFieldNumber) to bIsSame
96355>>>>>>>        If (bIsSame = False) Begin
96357>>>>>>>            Function_Return False
96358>>>>>>>        End
96358>>>>>>>>
96358>>>>>>>        If (bCompareIndexUppercase = True) Begin
96360>>>>>>>            Move (aIndexSegmentFrom.bUppercase = aIndexSegmentTo.bUppercase) to bIsSame
96361>>>>>>>            If (bIsSame = False) Begin
96363>>>>>>>                Function_Return False
96364>>>>>>>            End
96364>>>>>>>>
96364>>>>>>>        End
96364>>>>>>>>
96364>>>>>>>        If (bCompareIndexAscending = True) Begin
96366>>>>>>>            Move (aIndexSegmentFrom.bAscending = aIndexSegmentTo.bAscending) to bIsSame
96367>>>>>>>            If (bIsSame = False) Begin
96369>>>>>>>                Function_Return False
96370>>>>>>>            End
96370>>>>>>>>
96370>>>>>>>        End
96370>>>>>>>>
96370>>>>>>>
96370>>>>>>>        Function_Return True
96371>>>>>>>    End_Function
96372>>>>>>>
96372>>>>>>>    Function UtilIndexesUpdate Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndex[] aIndexesFrom tAPIIndex[] aIndexesTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
96374>>>>>>>        Boolean bIsSame bOK
96374>>>>>>>        Integer iSize iSizeTo iCount
96374>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
96374>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
96375>>>>>>>
96375>>>>>>>        Move (SizeOfArray(aIndexesFrom)) to iSize
96376>>>>>>>        If (iSize = 0) Begin
96378>>>>>>>            Function_Return True
96379>>>>>>>        End
96379>>>>>>>>
96379>>>>>>>        Move (SizeOfArray(aIndexesTo)) to iSizeTo
96380>>>>>>>        Get UtilTableIsSql hTable to bIsSQLTableTo
96381>>>>>>>        Get UtilIndexCombineFromAndToArrays aIndexesFrom aIndexesTo to aAPIIndexCompare
96382>>>>>>>
96382>>>>>>>        for iCount from 0 to (iSize - 1)
96388>>>>>>>>
96388>>>>>>>            Get UtilIndexCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
96389>>>>>>>            If (bIsSame = False) Begin
96391>>>>>>>                Get APIIndexCreateByFieldNames hTable aIndexesFrom[iCount] aIndexesTo aIndexesFrom[iCount].IndexSegmentArray to bOK
96392>>>>>>>            End
96392>>>>>>>>
96392>>>>>>>        Loop
96393>>>>>>>>
96393>>>>>>>
96393>>>>>>>        // We probably should delete other indexes if they exists.
96393>>>>>>>        for iCount from (iSize +1) to iSizeTo
96399>>>>>>>>
96399>>>>>>>            Get ApiIndexRemove hTable iCount to bOK
96400>>>>>>>        Loop
96401>>>>>>>>
96401>>>>>>>
96401>>>>>>>        Function_Return bOK
96402>>>>>>>    End_Function
96403>>>>>>>
96403>>>>>>>//    Function UtilIsSameColumnDefinitions Handle hTable tAPIColumn[] aColumns Returns Boolean
96403>>>>>>>//        Boolean bEqual bIdentityKey bSqlDriver bDawSqlDriver bIsOpen
96403>>>>>>>//        Integer iCount iColumn iSize iOptions iLength iPrecision iType
96403>>>>>>>//        String sFieldName sDriverID
96403>>>>>>>//
96403>>>>>>>//        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
96403>>>>>>>//        If (bIsOpen = False) Begin
96403>>>>>>>//            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
96403>>>>>>>//            Open hTable
96403>>>>>>>//            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
96403>>>>>>>//            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
96403>>>>>>>//            If (bIsOpen = False) Begin
96403>>>>>>>//                Function_Return False
96403>>>>>>>//            End
96403>>>>>>>//        End
96403>>>>>>>//
96403>>>>>>>//        Move True to bEqual
96403>>>>>>>//        Get psDriverID to sDriverID
96403>>>>>>>//        Get IsSQLDriver    sDriverID to bSqlDriver
96403>>>>>>>//        Get IsDAWSQLDriver sDriverID to bDawSqlDriver
96403>>>>>>>//        Move (SizeOfArray(aColumns)) to iSize
96403>>>>>>>//        Decrement iSize
96403>>>>>>>//
96403>>>>>>>//        For iCount from 0 to iSize
96403>>>>>>>//            Move 0 to iOptions
96403>>>>>>>//            Move False to bIdentityKey
96403>>>>>>>//            Move aColumns[iCount].sFieldName to sFieldName
96403>>>>>>>//
96403>>>>>>>//            // We need to use the column name - not the column integer as
96403>>>>>>>//            // the order does not need to be the same, and the logic should still work.
96403>>>>>>>//            Get UtilColumnNameToColumnNumber hTable sFieldName to iColumn
96403>>>>>>>//            If (iColumn > 0) Begin
96403>>>>>>>//                If (bDawSqlDriver = True) Begin
96403>>>>>>>//                    Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
96403>>>>>>>//                    Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to iType
96403>>>>>>>//                    If (iType <> aColumns[iCount].iSQLType) Begin
96403>>>>>>>//                        Move False to bEqual
96403>>>>>>>//                    End
96403>>>>>>>//                    Get_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to bIdentityKey
96403>>>>>>>//                    If (bIdentityKey = True) Begin
96403>>>>>>>//                        Move C_tAPIColumn_Identity to iOptions
96403>>>>>>>//                    End
96403>>>>>>>//                    If (iOptions <> aColumns[iCount].iOptions) Begin
96403>>>>>>>//                        Move False to bEqual
96403>>>>>>>//                    End
96403>>>>>>>//                    Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
96403>>>>>>>//                End
96403>>>>>>>//                Else Begin
96403>>>>>>>//                    Get_Attribute DF_FIELD_TYPE     of hTable iColumn to iType
96403>>>>>>>//                    If (iType <> aColumns[iCount].iSQLType) Begin
96403>>>>>>>//                        Move False to bEqual
96403>>>>>>>//                    End
96403>>>>>>>//                End
96403>>>>>>>//                Get_Attribute DF_FIELD_LENGTH       of hTable iColumn to iLength
96403>>>>>>>//                If (iLength <> aColumns[iCount].iLength) Begin
96403>>>>>>>//                    Move False to bEqual
96403>>>>>>>//                End
96403>>>>>>>//                Get_Attribute DF_FIELD_PRECISION    of hTable iColumn to iPrecision
96403>>>>>>>//                If (iPrecision <> aColumns[iCount].iPrecision) Begin
96403>>>>>>>//                    Move False to bEqual
96403>>>>>>>//                End
96403>>>>>>>//                If (bEqual = False) Begin
96403>>>>>>>//                    Function_Return False
96403>>>>>>>//                End
96403>>>>>>>//            End
96403>>>>>>>//
96403>>>>>>>//            Else Begin
96403>>>>>>>//                Function_Return False
96403>>>>>>>//            End
96403>>>>>>>//        Loop
96403>>>>>>>//
96403>>>>>>>//        Function_Return bEqual
96403>>>>>>>//    End_Function
96403>>>>>>>
96403>>>>>>>    Function UtilIndexesStructFill Handle hTable Returns tAPIIndex[]
96405>>>>>>>        tAPIIndex[] APIIndexes
96405>>>>>>>        tAPIIndex[] APIIndexes
96406>>>>>>>        Integer iCount iIndex iIndexes iSegment iSegmentCount iNumSegments iColumn
96406>>>>>>>        String sDriverID
96406>>>>>>>        Boolean bDAWSQLDriver bIsOpen bIsSQLTable
96406>>>>>>>
96406>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
96407>>>>>>>        Get psDriverID to sDriverID
96408>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
96409>>>>>>>        Get UtilTableIsSQL hTable to bIsSQLTable
96410>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
96413>>>>>>>        If (bIsOpen = False) Begin
96415>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
96416>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
96417>>>>>>>            Open hTable
96419>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
96420>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
96421>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
96424>>>>>>>            If (bIsOpen = False) Begin
96426>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
96427>>>>>>>                Move True to APIIndexes[0].bError
96428>>>>>>>                Function_Return APIIndexes
96429>>>>>>>            End
96429>>>>>>>>
96429>>>>>>>        End
96429>>>>>>>>
96429>>>>>>>
96429>>>>>>>        Move 0 to iCount
96430>>>>>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iIndexes
96433>>>>>>>        for iIndex from 1 to iIndexes
96439>>>>>>>>
96439>>>>>>>            // This is a test that the index exists as there might be "holes" aka the index
96439>>>>>>>            // numbers doesn't not need to be consequitive:
96439>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
96442>>>>>>>            If (iNumSegments > 0) Begin
96444>>>>>>>
96444>>>>>>>                Move iIndex                                                     to APIIndexes[iCount].iIndexNumber
96445>>>>>>>                Get_Attribute DF_FILE_PRIMARY_INDEX of hTable                   to APIIndexes[iCount].iPrimaryIndex
96448>>>>>>>                If (bIsSQLTable = True) Begin
96450>>>>>>>                    Get_Attribute DF_INDEX_NAME         of hTable iIndex        to APIIndexes[iCount].sSQLIndexName
96453>>>>>>>                        Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex to APIIndexes[iCount].bIsSQLPrimaryKey
96456>>>>>>>                        Get_Attribute DF_INDEX_CLUSTERED of hTable iIndex       to APIIndexes[iCount].bIsSQLClustered
96459>>>>>>>                        Get_Attribute DF_INDEX_SQL_TYPE of hTable iIndex        to APIIndexes[iCount].iSQLIndexType // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
96462>>>>>>>                End
96462>>>>>>>>
96462>>>>>>>
96462>>>>>>>                Move 0 to iSegmentCount
96463>>>>>>>                Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
96466>>>>>>>                For iSegment from 1 to iNumSegments
96472>>>>>>>>
96472>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iSegment to iColumn
96475>>>>>>>                    Move iColumn                                                       to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].iFieldNumber
96476>>>>>>>                    Get_Attribute DF_FIELD_NAME              of hTable iColumn         to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].sFieldName
96479>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bUppercase
96482>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bAscending
96485>>>>>>>                    Increment iSegmentCount
96486>>>>>>>                Loop
96487>>>>>>>>
96487>>>>>>>                Increment iCount
96488>>>>>>>            End
96488>>>>>>>>
96488>>>>>>>        Loop
96489>>>>>>>>
96489>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
96490>>>>>>>
96490>>>>>>>        Function_Return APIIndexes
96491>>>>>>>    End_Function
96492>>>>>>>
96492>>>>>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
96492>>>>>>>    // The combined data will be sorted on the first struct member: iIndexNumber
96492>>>>>>>    // This is needed because index numbers can start at any number. The range for a particular table might also
96492>>>>>>>    // have "holes" in the series of index numbers.
96492>>>>>>>    Function UtilIndexCombineFromAndToArrays tAPIIndex[] APIIndexFrom tAPIIndex[] APIIndexTo Returns tAPIIndexCompare[]
96494>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
96494>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
96495>>>>>>>        tAPIIndexCompare   APIIndexCompare
96495>>>>>>>        tAPIIndexCompare   APIIndexCompare
96495>>>>>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
96495>>>>>>>
96495>>>>>>>        Move (SizeOfArray(APIIndexFrom)) to iSizeFrom
96496>>>>>>>        Move (SizeOfArray(APIIndexTo)) to iSizeTo
96497>>>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
96499>>>>>>>            Function_Return aAPIIndexCompare
96500>>>>>>>        End
96500>>>>>>>>
96500>>>>>>>
96500>>>>>>>        Decrement iSizeFrom
96501>>>>>>>        for iCount from 0 to iSizeFrom
96507>>>>>>>>
96507>>>>>>>            Move APIIndexFrom[iCount].iIndexNumber      to aAPIIndexCompare[iCount].iIndexNumber
96508>>>>>>>            Move APIIndexFrom[iCount].iPrimaryIndex     to aAPIIndexCompare[iCount].iPrimaryIndexFrom
96509>>>>>>>            Move APIIndexFrom[iCount].sSQLIndexName     to aAPIIndexCompare[iCount].sSQLIndexNameFrom
96510>>>>>>>            Move APIIndexFrom[iCount].iSQLIndexType     to aAPIIndexCompare[iCount].iSQLIndexTypeFrom
96511>>>>>>>            Move APIIndexFrom[iCount].bIsSQLClustered   to aAPIIndexCompare[iCount].bIsSQLClusteredFrom
96512>>>>>>>            Move APIIndexFrom[iCount].bIsSQLPrimaryKey  to aAPIIndexCompare[iCount].bIsSQLPrimaryKeyFrom
96513>>>>>>>            Move APIIndexFrom[iCount].IndexSegmentArray to aAPIIndexCompare[iCount].IndexSegmentArrayFrom
96514>>>>>>>            Move APIIndexFrom[iCount].bShouldChange     to aAPIIndexCompare[iCount].bShouldChangeFrom
96515>>>>>>>            Move APIIndexFrom[iCount].bCancel           to aAPIIndexCompare[iCount].bCancelFrom
96516>>>>>>>            Move APIIndexFrom[iCount].bError            to aAPIIndexCompare[iCount].bErrorFrom
96517>>>>>>>            Move True                                   to aAPIIndexCompare[iCount].bExistsFrom
96518>>>>>>>        Loop
96519>>>>>>>>
96519>>>>>>>
96519>>>>>>>        Decrement iSizeTo
96520>>>>>>>        for iCount from 0 to iSizeTo
96526>>>>>>>>
96526>>>>>>>            Move APIIndexTo[iCount].iIndexNumber        to APIIndexCompare.iIndexNumber
96527>>>>>>>            // Search if the Index number already exists in the array; else add it.
96527>>>>>>>            Move (SearchArray(APIIndexCompare, aAPIIndexCompare)) to iItem
96528>>>>>>>            If (iItem = -1) Begin
96530>>>>>>>                Move (SizeOfArray(aAPIIndexCompare))    to iItem
96531>>>>>>>            End
96531>>>>>>>>
96531>>>>>>>
96531>>>>>>>            Move APIIndexCompare.iIndexNumber           to aAPIIndexCompare[iItem].iIndexNumber
96532>>>>>>>            Move APIIndexTo[iCount].iPrimaryIndex       to aAPIIndexCompare[iItem].iPrimaryIndexTo
96533>>>>>>>            Move APIIndexTo[iCount].sSQLIndexName       to aAPIIndexCompare[iItem].sSQLIndexNameTo
96534>>>>>>>            Move APIIndexTo[iCount].iSQLIndexType       to aAPIIndexCompare[iItem].iSQLIndexTypeTo
96535>>>>>>>            Move APIIndexTo[iCount].bIsSQLClustered     to aAPIIndexCompare[iItem].bIsSQLClusteredTo
96536>>>>>>>            Move APIIndexTo[iCount].bIsSQLPrimaryKey    to aAPIIndexCompare[iItem].bIsSQLPrimaryKeyTo
96537>>>>>>>            Move APIIndexTo[iCount].IndexSegmentArray   to aAPIIndexCompare[iItem].IndexSegmentArrayTo
96538>>>>>>>            Move APIIndexTo[iCount].bShouldChange       to aAPIIndexCompare[iItem].bShouldChangeTo
96539>>>>>>>            Move APIIndexTo[iCount].bCancel             to aAPIIndexCompare[iItem].bCancelTo
96540>>>>>>>            Move APIIndexTo[iCount].bError              to aAPIIndexCompare[iItem].bErrorTo
96541>>>>>>>            Move True                                   to aAPIIndexCompare[iItem].bExistsTo
96542>>>>>>>        Loop
96543>>>>>>>>
96543>>>>>>>
96543>>>>>>>        Move (SortArray(aAPIIndexCompare)) to aAPIIndexCompare
96544>>>>>>>
96544>>>>>>>        Function_Return aAPIIndexCompare
96545>>>>>>>    End_Function
96546>>>>>>>
96546>>>>>>>    // This is the same as the UtilIndexCompare function but it takes tAPIIndex structs as params.
96546>>>>>>>    Function UtilIndexTypeNumberCompare Handle hTable tAPIIndex aIndexFrom tAPIIndex aIndexTo Returns Boolean
96548>>>>>>>        Boolean bIsSame bDAWSQLDriver bIsSqlTable
96548>>>>>>>        String sDriverID
96548>>>>>>>
96548>>>>>>>        Get psDriverID to sDriverID
96549>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
96550>>>>>>>        Get IsSQLDriver sDriverID to bIsSqlTable
96551>>>>>>>        If (bIsSqlTable = True) Begin
96553>>>>>>>            Get UtilTableIsSQL hTable to bIsSqlTable
96554>>>>>>>        End
96554>>>>>>>>
96554>>>>>>>
96554>>>>>>>        Move (aIndexFrom.iIndexNumber = aIndexTo.iIndexNumber) to bIsSame
96555>>>>>>>        If (bIsSame = False) Begin
96557>>>>>>>            Function_Return False
96558>>>>>>>        End
96558>>>>>>>>
96558>>>>>>>
96558>>>>>>>        If (bDAWSQLDriver = True and bIsSqlTable = True) Begin
96560>>>>>>>            // Don't think we should do this. Or should we?
96560>>>>>>>            // Move (aIndexesFrom[iCount].sSQLIndexName = aIndexesTo[iCount].sSQLIndexName) to bIsSame
96560>>>>>>>
96560>>>>>>>            Move (aIndexFrom.iSQLIndexType = aIndexTo.iSQLIndexType) to bIsSame
96561>>>>>>>            If (bIsSame = False) Begin
96563>>>>>>>                Function_Return False
96564>>>>>>>            End
96564>>>>>>>>
96564>>>>>>>            Move (aIndexFrom.iPrimaryIndex = aIndexTo.iPrimaryIndex) to bIsSame
96565>>>>>>>            If (bIsSame = False) Begin
96567>>>>>>>                Function_Return False
96568>>>>>>>            End
96568>>>>>>>>
96568>>>>>>>            Move (aIndexFrom.bIsSQLPrimaryKey = aIndexTo.bIsSQLPrimaryKey) to bIsSame
96569>>>>>>>            If (bIsSame = False) Begin
96571>>>>>>>                Function_Return False
96572>>>>>>>            End
96572>>>>>>>>
96572>>>>>>>            Move (aIndexFrom.bIsSQLClustered = aIndexTo.bIsSQLClustered) to bIsSame
96573>>>>>>>            If (bIsSame = False) Begin
96575>>>>>>>                Function_Return False
96576>>>>>>>            End
96576>>>>>>>>
96576>>>>>>>        End
96576>>>>>>>>
96576>>>>>>>
96576>>>>>>>        Function_Return bIsSame
96577>>>>>>>    End_Function
96578>>>>>>>
96578>>>>>>>    // DF_INDEX_SQL_TYPE values
96578>>>>>>>    // Pass one of the DF_INDEX_XXX integer constants and the function
96578>>>>>>>    // returns a string with the name.
96578>>>>>>>    Function UtilIndexTypeToString Integer iIndexType Returns String
96580>>>>>>>        String sRetval
96580>>>>>>>        Case Begin
96580>>>>>>>            Case (iIndexType = DF_INDEX_CLIENT)
96582>>>>>>>                Move "DF_INDEX_CLIENT" to sRetval
96583>>>>>>>                Case Break
96584>>>>>>>            Case (iIndexType = DF_INDEX_SERVER)
96587>>>>>>>                Move "DF_INDEX_SERVER" to sRetval
96588>>>>>>>                Case Break
96589>>>>>>>            Case (iIndexType = DF_INDEX_SERVER_ONLY)
96592>>>>>>>                Move "DF_INDEX_SERVER_ONLY" to sRetval
96593>>>>>>>                Case Break
96594>>>>>>>            Case (iIndexType = DF_INDEX_TEMPORARY)
96597>>>>>>>                Move "DF_INDEX_TEMPORARY" to sRetval
96598>>>>>>>                Case Break
96599>>>>>>>            Case Else
96599>>>>>>>                Move "UNKNOWN INDEX TYPE" to sRetval
96600>>>>>>>        Case End
96600>>>>>>>        Function_Return sRetval
96601>>>>>>>    End_Function
96602>>>>>>>
96602>>>>>>>    // * Dummy function for the Studio's Code Explorer *
96602>>>>>>>    Function API_RELATION_UTILITY_FUNCTIONS Returns Boolean
96604>>>>>>>        Function_Return False
96605>>>>>>>    End_Function
96606>>>>>>>
96606>>>>>>>    // Compares multiple relationships for a 'FROM' and a 'TO' databases
96606>>>>>>>    Function UtilRelationsCompare Handle hTable tAPIRelationCompare[] aAPIRelationCompare Returns Boolean
96608>>>>>>>        Boolean bIsSame
96608>>>>>>>        Integer iSize iCount
96608>>>>>>>
96608>>>>>>>        Move True to bIsSame
96609>>>>>>>        Move (SizeOfArray(aAPIRelationCompare)) to iSize
96610>>>>>>>        Decrement iSize
96611>>>>>>>        For iCount from 0 to iSize
96617>>>>>>>>
96617>>>>>>>            Get UtilRelationCompare hTable aAPIRelationCompare[iCount] to bIsSame
96618>>>>>>>            If (bIsSame = False) Begin
96620>>>>>>>                Function_Return False
96621>>>>>>>            End
96621>>>>>>>>
96621>>>>>>>        Loop
96622>>>>>>>>
96622>>>>>>>
96622>>>>>>>        Function_Return bIsSame
96623>>>>>>>    End_Function
96624>>>>>>>
96624>>>>>>>    // Compares a single relationship for a 'FROM' and a 'TO' table
96624>>>>>>>    Function UtilRelationCompare Handle hTable tAPIRelationCompare APIRelationCompare Returns Boolean
96626>>>>>>>        Boolean bIsSame
96626>>>>>>>
96626>>>>>>>        Move True to bIsSame
96627>>>>>>>        If (APIRelationCompare.bExistsFrom <> APIRelationCompare.bExistsTo) Begin
96629>>>>>>>            Function_Return False
96630>>>>>>>        End
96630>>>>>>>>
96630>>>>>>>        If (APIRelationCompare.hTableFrom = 0 or APIRelationCompare.hTableTo = 0) Begin
96632>>>>>>>            Function_Return False
96633>>>>>>>        End
96633>>>>>>>>
96633>>>>>>>
96633>>>>>>>        // We could also compare field names, but I don't think that is necessary...
96633>>>>>>>
96633>>>>>>>        Function_Return bIsSame
96634>>>>>>>    End_Function
96635>>>>>>>
96635>>>>>>>    // This message is different from ApiTableCreate in that it will not do a function_return if the table
96635>>>>>>>    // already exists.
96635>>>>>>>    Function UtilRelationsUpdate Handle hTable tAPIRelation[] aRelationsFrom tAPIRelation[] aRelationsTo Returns Boolean
96637>>>>>>>        Boolean bOK
96637>>>>>>>        Integer iSizeTo iSize iCount iColumn
96637>>>>>>>        String sDriverID
96637>>>>>>>
96637>>>>>>>        Move True to bOK
96638>>>>>>>        Move (SizeOfArray(aRelationsTo))   to iSizeTo
96639>>>>>>>        If (iSizeTo > 0) Begin
96641>>>>>>>            Get AutoConnectionIDLogin to bOK
96642>>>>>>>            Move False to Err
96643>>>>>>>            Open hTable Mode DF_EXCLUSIVE
96645>>>>>>>            Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
96648>>>>>>>            Decrement iSizeTo
96649>>>>>>>
96649>>>>>>>            // We should probably not make any comparison between "FROM" and "TO" database; instead just create all "FROM" relations
96649>>>>>>>            // for the "TO" database. But start by deleting all current "TO" relations:
96649>>>>>>>            Structure_Start hTable sDriverID
96650>>>>>>>                for iCount from 0 to iSizeTo
96656>>>>>>>>
96656>>>>>>>                    Move aRelationsTo[iCount].iColumnFrom to iColumn
96657>>>>>>>                    Set_Attribute DF_FIELD_RELATED_FILE  of hTable iColumn to 0
96660>>>>>>>                    Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn to 0
96663>>>>>>>                Loop
96664>>>>>>>>
96664>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
96665>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
96667>>>>>>>            Set Action_Text of ghoStatusPanel to ""
96668>>>>>>>        End
96668>>>>>>>>
96668>>>>>>>
96668>>>>>>>        Move (SizeOfArray(aRelationsFrom)) to iSize
96669>>>>>>>        Decrement iSize
96670>>>>>>>        for iCount from 0 to iSize
96676>>>>>>>>
96676>>>>>>>            Get ApiTableRelate aRelationsFrom[iCount].hTableFrom aRelationsFrom[iCount].hTableTo aRelationsFrom[iCount].iColumnFrom aRelationsFrom[iCount].iColumnTo aRelationsTo to bOK
96677>>>>>>>        Loop
96678>>>>>>>>
96678>>>>>>>
96678>>>>>>>        Function_Return bOK
96679>>>>>>>    End_Function
96680>>>>>>>
96680>>>>>>>    Function UtilRelationsStructFill Handle hTable Returns tAPIRelation[]
96682>>>>>>>        tAPIRelation[] APIRelations
96682>>>>>>>        tAPIRelation[] APIRelations
96683>>>>>>>        Integer iColumn iColumnTo iNumColumns iCount
96683>>>>>>>        Handle hParent
96683>>>>>>>        Boolean bIsOpen
96683>>>>>>>
96683>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
96684>>>>>>>        Move 0 to iCount
96685>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
96688>>>>>>>        If (bIsOpen = False) Begin
96690>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
96691>>>>>>>            Open hTable
96693>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
96694>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
96697>>>>>>>            If (bIsOpen = False) Begin
96699>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
96700>>>>>>>                Move True to APIRelations[0].bError
96701>>>>>>>                Function_Return APIRelations
96702>>>>>>>            End
96702>>>>>>>>
96702>>>>>>>        End
96702>>>>>>>>
96702>>>>>>>
96702>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
96705>>>>>>>        For iColumn from 1 to iNumColumns
96711>>>>>>>>
96711>>>>>>>            Get_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to hParent
96714>>>>>>>            If (hParent <> 0) Begin
96716>>>>>>>                Open hParent
96718>>>>>>>                Move hTable                                             to APIRelations[iCount].hTableFrom
96719>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable            to APIRelations[iCount].sLogicalNameFrom
96722>>>>>>>                Move iColumn                                            to APIRelations[iCount].iColumnFrom
96723>>>>>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn           to APIRelations[iCount].sFieldNameFrom
96726>>>>>>>
96726>>>>>>>                Move hParent                                            to APIRelations[iCount].hTableTo
96727>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hParent           to APIRelations[iCount].sLogicalNameTo
96730>>>>>>>                Get_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn  to iColumnTo
96733>>>>>>>                Move iColumnTo                                          to APIRelations[iCount].iColumnTo
96734>>>>>>>                Get_Attribute DF_FIELD_NAME of hParent iColumnTo        to APIRelations[iCount].sFieldNameTo
96737>>>>>>>                Move False                                              to APIRelations[iCount].bShouldChange
96738>>>>>>>                Move False                                              to APIRelations[iCount].bCancel
96739>>>>>>>                Move False                                              to APIRelations[iCount].bError
96740>>>>>>>                Close hParent
96741>>>>>>>                Increment iCount
96742>>>>>>>            End
96742>>>>>>>>
96742>>>>>>>        Loop
96743>>>>>>>>
96743>>>>>>>
96743>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
96744>>>>>>>        Function_Return APIRelations
96745>>>>>>>    End_Function
96746>>>>>>>
96746>>>>>>>    Function UtilRelationArrayCompare tAPIRelation RelationCurrent tAPIRelation RelationNew Returns Integer
96748>>>>>>>        If (RelationCurrent.hTableFrom  = RelationNew.hTableFrom and ;            RelationCurrent.iColumnFrom = RelationNew.iColumnFrom and ;            RelationCurrent.hTableTo    = RelationNew.hTableTo and ;            RelationCurrent.iColumnTo   = RelationNew.iColumnTo) Begin
96750>>>>>>>            Function_Return (EQ)
96751>>>>>>>        End
96751>>>>>>>>
96751>>>>>>>
96751>>>>>>>        Function_Return (GT)
96752>>>>>>>    End_Function
96753>>>>>>>
96753>>>>>>>    Function SearchRelationCompare tAPIRelationCompare RelationCompareCurrent tAPIRelationCompare RelationCompareNew Returns Integer
96755>>>>>>>        If (RelationCompareCurrent.hTableFrom  = RelationCompareNew.hTableFrom and ;            RelationCompareCurrent.iColumnFrom = RelationCompareNew.iColumnFrom and ;            RelationCompareCurrent.hTableTo    = RelationCompareNew.hTableTo and ;            RelationCompareCurrent.iColumnTo   = RelationCompareNew.iColumnTo) ;            Function_Return (EQ)
96758>>>>>>>
96758>>>>>>>        Function_Return (GT)
96759>>>>>>>    End_Function
96760>>>>>>>
96760>>>>>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
96760>>>>>>>    // The combined data will be sorted on the first 4 struct members: hTableFrom, iColumnFrom, hTableTo and iColumnTo
96760>>>>>>>    Function UtilRelationCombineFromAndToArrays tAPIRelation[] aAPIRelationFrom tAPIRelation[] aAPIRelationTo Returns tAPIIndexCompare[]
96762>>>>>>>        tAPIRelation[] aAPIRelationFromAndTo
96762>>>>>>>        tAPIRelation[] aAPIRelationFromAndTo
96763>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
96763>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
96764>>>>>>>        tAPIRelationCompare   APIRelationCompare
96764>>>>>>>        tAPIRelationCompare   APIRelationCompare
96764>>>>>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
96764>>>>>>>
96764>>>>>>>        Move (SizeOfArray(aAPIRelationFrom)) to iSizeFrom
96765>>>>>>>        Move (SizeOfArray(aAPIRelationTo))   to iSizeTo
96766>>>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
96768>>>>>>>            Function_Return aAPIRelationCompare
96769>>>>>>>        End
96769>>>>>>>>
96769>>>>>>>
96769>>>>>>>        Move (AppendArray(aAPIRelationFrom, aAPIRelationTo)) to aAPIRelationFromAndTo
96770>>>>>>>        Move (SortArray(aAPIRelationFromAndTo, Self, RefFunc(UtilRelationArrayCompare))) to aAPIRelationFromAndTo
96771>>>>>>>
96771>>>>>>>        Decrement iSizeFrom
96772>>>>>>>        for iCount from 0 to iSizeFrom
96778>>>>>>>>
96778>>>>>>>            Move aAPIRelationFrom[iCount].hTableFrom        to aAPIRelationCompare[iCount].hTableFrom
96779>>>>>>>            Move aAPIRelationFrom[iCount].iColumnFrom       to aAPIRelationCompare[iCount].iColumnFrom
96780>>>>>>>            Move aAPIRelationFrom[iCount].hTableTo          to aAPIRelationCompare[iCount].hTableTo
96781>>>>>>>            Move aAPIRelationFrom[iCount].iColumnTo         to aAPIRelationCompare[iCount].iColumnTo
96782>>>>>>>            Move aAPIRelationFrom[iCount].sLogicalNameFrom  to aAPIRelationCompare[iCount].sLogicalNameFrom_From
96783>>>>>>>            Move aAPIRelationFrom[iCount].sLogicalNameTo    to aAPIRelationCompare[iCount].sLogicalNameTo_From
96784>>>>>>>            Move aAPIRelationFrom[iCount].sFieldNameFrom    to aAPIRelationCompare[iCount].sFieldNameFrom_From
96785>>>>>>>            Move aAPIRelationFrom[iCount].sFieldNameTo      to aAPIRelationCompare[iCount].sFieldNameTo_From
96786>>>>>>>            Move aAPIRelationFrom[iCount].bShouldChange     to aAPIRelationCompare[iCount].bShouldChange_From
96787>>>>>>>            Move aAPIRelationFrom[iCount].bCancel           to aAPIRelationCompare[iCount].bCancel_From
96788>>>>>>>            Move aAPIRelationFrom[iCount].bError            to aAPIRelationCompare[iCount].bError_From
96789>>>>>>>            Move True                                       to aAPIRelationCompare[iCount].bExistsFrom
96790>>>>>>>        Loop
96791>>>>>>>>
96791>>>>>>>
96791>>>>>>>        Decrement iSizeTo
96792>>>>>>>        for iCount from 0 to iSizeTo
96798>>>>>>>>
96798>>>>>>>            Move aAPIRelationTo[iCount].hTableFrom          to APIRelationCompare.hTableFrom
96799>>>>>>>            Move aAPIRelationTo[iCount].iColumnFrom         to APIRelationCompare.iColumnFrom
96800>>>>>>>            Move aAPIRelationTo[iCount].hTableTo            to APIRelationCompare.hTableTo
96801>>>>>>>            Move aAPIRelationTo[iCount].iColumnTo           to APIRelationCompare.iColumnTo
96802>>>>>>>
96802>>>>>>>            // Search if the relation already exists in the array; else add it.
96802>>>>>>>            Move (SearchArray(APIRelationCompare, aAPIRelationCompare, Self, RefFunc(SearchRelationCompare))) to iItem
96803>>>>>>>            If (iItem = -1) Begin
96805>>>>>>>                Move (SizeOfArray(aAPIRelationCompare))     to iItem
96806>>>>>>>            End
96806>>>>>>>>
96806>>>>>>>
96806>>>>>>>            Move APIRelationCompare.hTableFrom              to aAPIRelationCompare[iItem].hTableFrom
96807>>>>>>>            Move APIRelationCompare.iColumnFrom             to aAPIRelationCompare[iItem].iColumnFrom
96808>>>>>>>            Move APIRelationCompare.hTableTo                to aAPIRelationCompare[iItem].hTableTo
96809>>>>>>>            Move APIRelationCompare.iColumnTo               to aAPIRelationCompare[iItem].iColumnTo
96810>>>>>>>            Move aAPIRelationTo[iCount].sLogicalNameFrom    to aAPIRelationCompare[iItem].sLogicalNameFrom_To
96811>>>>>>>            Move aAPIRelationTo[iCount].sLogicalNameTo      to aAPIRelationCompare[iItem].sLogicalNameTo_To
96812>>>>>>>            Move aAPIRelationTo[iCount].sFieldNameFrom      to aAPIRelationCompare[iItem].sFieldNameFrom_To
96813>>>>>>>            Move aAPIRelationTo[iCount].sFieldNameTo        to aAPIRelationCompare[iItem].sFieldNameTo_To
96814>>>>>>>            Move aAPIRelationTo[iCount].bShouldChange       to aAPIRelationCompare[iItem].bShouldChange_To
96815>>>>>>>            Move aAPIRelationTo[iCount].bCancel             to aAPIRelationCompare[iItem].bCancel_To
96816>>>>>>>            Move aAPIRelationTo[iCount].bError              to aAPIRelationCompare[iItem].bError_To
96817>>>>>>>            Move True                                       to aAPIRelationCompare[iItem].bExistsTo
96818>>>>>>>        Loop
96819>>>>>>>>
96819>>>>>>>
96819>>>>>>>        Move (SortArray(aAPIRelationCompare, Self, RefFunc(SearchRelationCompare))) to aAPIRelationCompare
96820>>>>>>>
96820>>>>>>>        Function_Return aAPIRelationCompare
96821>>>>>>>    End_Function
96822>>>>>>>
96822>>>>>>>    // * Dummy function for the Studio's Code Explorer *
96822>>>>>>>    Function CODEMAST_UTILITY_FUNCTIONS Returns Boolean
96824>>>>>>>        Function_Return False
96825>>>>>>>    End_Function
96826>>>>>>>
96826>>>>>>>    // To add a value to the CodeMast & CodeType tables. Pass; a) bCodeType if it is CodeType that should be updated.
96826>>>>>>>    // Else it is CodeMast. b) sTypeValue; either to be added If bCodeType = True, or it will be used to find the correct
96826>>>>>>>    // CodeType record. c) sValue1 and d) sValue2 is the CodeType Description & Comment, or CodeMast Type and Code values.
96826>>>>>>>    Function UtilCodeMasterAddValue Boolean bCodeType String sTypeValue String sValue2 String sValue3 Returns Boolean
96828>>>>>>>        Boolean bFound
96828>>>>>>>
96828>>>>>>>        Move False to Err
96829>>>>>>>        Open CodeMast
96831>>>>>>>        Open CodeType
96833>>>>>>>
96833>>>>>>>        If (bCodeType = True) Begin
96835>>>>>>>            Set Private.phCurrentTable to CODETYPE.File_Number
96836>>>>>>>            Clear CodeType
96837>>>>>>>            Move sTypeValue to CODETYPE.Type
96838>>>>>>>            Find eq CODETYPE by 1
96839>>>>>>>>
96839>>>>>>>            Move Found to bFound
96840>>>>>>>            If (bFound = True) Begin
96842>>>>>>>                Reread CodeType
96846>>>>>>>            End
96846>>>>>>>>
96846>>>>>>>            Else Begin
96847>>>>>>>                Clear CodeType
96848>>>>>>>            End
96848>>>>>>>>
96848>>>>>>>
96848>>>>>>>            Move sTypeValue to CODETYPE.Type
96849>>>>>>>            Move sValue2    to CODETYPE.Description
96850>>>>>>>            Move sValue3    to CODETYPE.Comment
96851>>>>>>>            SaveRecord CODETYPE
96852>>>>>>>
96852>>>>>>>            If (bFound = True) Begin
96854>>>>>>>                Unlock
96855>>>>>>>>
96855>>>>>>>            End
96855>>>>>>>>
96855>>>>>>>        End
96855>>>>>>>>
96855>>>>>>>
96855>>>>>>>        If (bCodeType = False) Begin
96857>>>>>>>            Set Private.phCurrentTable to CODEMAST.File_Number
96858>>>>>>>            Clear CODEMAST
96859>>>>>>>            Move sTypeValue to CODEMAST.Type
96860>>>>>>>            Move sValue2    to CODEMAST.Code
96861>>>>>>>            Find eq CODEMAST by 1
96862>>>>>>>>
96862>>>>>>>            Move Found to bFound
96863>>>>>>>            If (bFound = True) Begin
96865>>>>>>>                Reread CODEMAST
96869>>>>>>>            End
96869>>>>>>>>
96869>>>>>>>            Else Begin
96870>>>>>>>                Clear CODEMAST
96871>>>>>>>            End
96871>>>>>>>>
96871>>>>>>>
96871>>>>>>>            Move sTypeValue to CODEMAST.Type
96872>>>>>>>            Move sValue2    to CODEMAST.Code
96873>>>>>>>            Move sValue3    to CODEMAST.Description
96874>>>>>>>            SaveRecord CODEMAST
96875>>>>>>>
96875>>>>>>>            If (bFound = True) Begin
96877>>>>>>>                Unlock
96878>>>>>>>>
96878>>>>>>>            End
96878>>>>>>>>
96878>>>>>>>        End
96878>>>>>>>>
96878>>>>>>>
96878>>>>>>>        Close CodeMast
96879>>>>>>>        Close CodeType
96880>>>>>>>
96880>>>>>>>        Function_Return (Err = False)
96881>>>>>>>    End_Function
96882>>>>>>>
96882>>>>>>>    // Changes values in CodeType & CodeMast - From type value To type value. It first changes the type value in
96882>>>>>>>    // CodeType and then spins through all CodeMast records to change all related records.
96882>>>>>>>    Function UtilCodeMasterChangeValue String sFromValue String sToValue Returns Boolean
96884>>>>>>>        Boolean bFound
96884>>>>>>>
96884>>>>>>>        Move False to Err
96885>>>>>>>        Open CodeMast
96887>>>>>>>        Open CodeType
96889>>>>>>>
96889>>>>>>>        Clear CodeType
96890>>>>>>>        Move sFromValue to CODETYPE.Type
96891>>>>>>>        Find eq CODETYPE.Type
96892>>>>>>>>
96892>>>>>>>        If (Found = True) Begin
96894>>>>>>>            Reread CODETYPE
96898>>>>>>>                Move sToValue to CODETYPE.Type
96899>>>>>>>                SaveRecord CODETYPE
96900>>>>>>>            Unlock
96901>>>>>>>>
96901>>>>>>>        End
96901>>>>>>>>
96901>>>>>>>
96901>>>>>>>        Clear CODEMAST
96902>>>>>>>        Find gt CODEMAST by Recnum
96903>>>>>>>>
96903>>>>>>>        While (Found = True)
96907>>>>>>>            Move (Trim(Uppercase(CODEMAST.Type) = Trim(Uppercase(sFromValue)))) to bFound
96908>>>>>>>            If (bFound = True) Begin
96910>>>>>>>                Reread CODEMAST
96914>>>>>>>                    Move sToValue to CODEMAST.Type
96915>>>>>>>                    SaveRecord CODEMAST
96916>>>>>>>                Unlock
96917>>>>>>>>
96917>>>>>>>            End
96917>>>>>>>>
96917>>>>>>>            Find gt CODEMAST by Recnum
96918>>>>>>>>
96918>>>>>>>        Loop
96919>>>>>>>>
96919>>>>>>>
96919>>>>>>>        Close CodeMast
96920>>>>>>>        Close CodeType
96921>>>>>>>
96921>>>>>>>        Function_Return (Err = False)
96922>>>>>>>    End_Function
96923>>>>>>>
96923>>>>>>>    // Removes a value from CodeMast. Pass the sTypeValue and the sValue2 to remove.
96923>>>>>>>    Function UtilCodeMasterRemoveValue String sTypeValue String sValue2 Returns Boolean
96925>>>>>>>        Boolean bFound
96925>>>>>>>
96925>>>>>>>        Move False to Err
96926>>>>>>>        Open CodeMast
96928>>>>>>>
96928>>>>>>>        Clear CODEMAST
96929>>>>>>>        Move sTypeValue to CODEMAST.Type
96930>>>>>>>        Move sValue2    to CODEMAST.Code
96931>>>>>>>        Find eq CODEMAST.Code
96932>>>>>>>>
96932>>>>>>>        Move Found to bFound
96933>>>>>>>        If (bFound = True) Begin
96935>>>>>>>            Delete CODEMAST
96936>>>>>>>        End
96936>>>>>>>>
96936>>>>>>>
96936>>>>>>>        Close CodeMast
96937>>>>>>>
96937>>>>>>>        Function_Return (Err = False)
96938>>>>>>>    End_Function
96939>>>>>>>
96939>>>>>>>    Function UtilTableCreateCodeMastCodeTypeIntFiles String sDataPath Returns Boolean
96941>>>>>>>        Boolean bRecnum bToAnsi
96941>>>>>>>        Integer iCh
96941>>>>>>>        String sFileName sDriverID sConnectionID sSchemaName sANSI_OEM
96941>>>>>>>
96941>>>>>>>        If (Trim(sDataPath) = "") Begin
96943>>>>>>>            Function_Return False
96944>>>>>>>        End
96944>>>>>>>>
96944>>>>>>>
96944>>>>>>>        Move False to Err
96945>>>>>>>        Get psDriverID     to sDriverID
96946>>>>>>>        Get psConnectionID to sConnectionID
96947>>>>>>>        Get psSchema       to sSchemaName
96948>>>>>>>        Get True           to bRecnum
96949>>>>>>>        Get pbToANSI       to bToAnsi
96950>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
96951>>>>>>>        If (bToAnsi = False) Begin
96953>>>>>>>            Move CS_OEM_Txt to sANSI_OEM
96954>>>>>>>        End
96954>>>>>>>>
96954>>>>>>>
96954>>>>>>>        Get vFolderFormat sDataPath to sDataPath
96955>>>>>>>        Move "CodeMast.int"         to sFileName
96956>>>>>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
96957>>>>>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
96960>>>>>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
96963>>>>>>>            Writeln channel iCh ("DATABASE_NAME CODEMAST")
96966>>>>>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
96969>>>>>>>            Writeln channel iCh ("")
96972>>>>>>>            Writeln channel iCh ("RECNUM_TABLE YES")
96975>>>>>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
96978>>>>>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
96981>>>>>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
96984>>>>>>>            Writeln channel iCh ("")
96987>>>>>>>            Writeln channel iCh ("INDEX_NUMBER 1")
96990>>>>>>>            Writeln channel iCh ("INDEX_NAME CODEMAST001_PK")
96993>>>>>>>            Writeln channel iCh ("")
96996>>>>>>>        Send Seq_Close_Channel iCh
96997>>>>>>>
96997>>>>>>>        Get vFolderFormat sDataPath to sDataPath
96998>>>>>>>        Move "CodeType.int"         to sFileName
96999>>>>>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
97000>>>>>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
97003>>>>>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
97006>>>>>>>            Writeln channel iCh ("DATABASE_NAME CODETYPE")
97009>>>>>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
97012>>>>>>>            Writeln channel iCh ("")
97015>>>>>>>            Writeln channel iCh ("RECNUM_TABLE YES")
97018>>>>>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
97021>>>>>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
97024>>>>>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
97027>>>>>>>            Writeln channel iCh ("")
97030>>>>>>>            Writeln channel iCh ("INDEX_NUMBER 0")
97033>>>>>>>            Writeln channel iCh ("INDEX_NAME CODETYPE000")
97036>>>>>>>            Writeln channel iCh ("")
97039>>>>>>>            Writeln channel iCh ("INDEX_NUMBER 1")
97042>>>>>>>            Writeln channel iCh ("INDEX_NAME CODETYPE001_PK")
97045>>>>>>>            Writeln channel iCh ("")
97048>>>>>>>        Send Seq_Close_Channel iCh
97049>>>>>>>
97049>>>>>>>        Function_Return (Err = False)
97050>>>>>>>    End_Function
97051>>>>>>>
97051>>>>>>>    // * Dummy function for the Studio's Code Explorer *
97051>>>>>>>    Function OTHER_UTILITY_FUNCTIONS Returns Boolean
97053>>>>>>>        Function_Return False
97054>>>>>>>    End_Function
97055>>>>>>>
97055>>>>>>>    // Use function to move *.fd, termlist.*, collate.*, dfcollate.* files to a "Data\Backup" folder,
97055>>>>>>>    // and to remove all *.cch files (DAW SQL driver cache files. They will get recreated when needed.)
97055>>>>>>>    Function UtilMoveMiscFilesToBackupFolder Returns Boolean
97057>>>>>>>        Boolean bOK bExists
97057>>>>>>>        String sDataPath sBackupFolder
97057>>>>>>>
97057>>>>>>>        Set Message_Text of ghoStatusPanel to "Moving misc. files to Backup folder."
97058>>>>>>>        Move CS_DUFBackupDataFolder to sBackupFolder
97059>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
97060>>>>>>>        Get vFolderFormat sDataPath to sDataPath
97061>>>>>>>
97061>>>>>>>        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
97062>>>>>>>        If (bExists = False) Begin
97064>>>>>>>            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
97065>>>>>>>            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
97066>>>>>>>            If (bExists = False) Begin
97068>>>>>>>                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all misc. files to. You need to move them somewhere manually.")
97069>>>>>>>>
97069>>>>>>>                Function_Return False
97070>>>>>>>            End
97070>>>>>>>>
97070>>>>>>>            Get vMoveFile (sDataPath + "*.fd")         (sDataPath + sBackupFolder) to bOK  
97071>>>>>>>            Get vMoveFile (sDataPath + "*.bad")        (sDataPath + sBackupFolder) to bOK  
97072>>>>>>>            Get vMoveFile (sDataPath + "*.err")        (sDataPath + sBackupFolder) to bOK  
97073>>>>>>>            Get vMoveFile (sDataPath + "*.bak")        (sDataPath + sBackupFolder) to bOK
97074>>>>>>>            Get vMoveFile (sDataPath + "*.def")        (sDataPath + sBackupFolder) to bOK
97075>>>>>>>            Get vMoveFile (sDataPath + "*.fil")        (sDataPath + sBackupFolder) to bOK
97076>>>>>>>            Get vMoveFile (sDataPath + "*.hlp")        (sDataPath + sBackupFolder) to bOK
97077>>>>>>>            Get vMoveFile (sDataPath + "*.old")        (sDataPath + sBackupFolder) to bOK           
97078>>>>>>>            Get vMoveFile (sDataPath + "*.prn")        (sDataPath + sBackupFolder) to bOK           
97079>>>>>>>            Get vMoveFile (sDataPath + "*.sts")        (sDataPath + sBackupFolder) to bOK           
97080>>>>>>>            Get vMoveFile (sDataPath + "*.td")         (sDataPath + sBackupFolder) to bOK           
97081>>>>>>>            Get vMoveFile (sDataPath + "*.log")        (sDataPath + sBackupFolder) to bOK           
97082>>>>>>>            Get vMoveFile (sDataPath + "*.bat")        (sDataPath + sBackupFolder) to bOK           
97083>>>>>>>            Get vMoveFile (sDataPath + "*.cmd")        (sDataPath + sBackupFolder) to bOK           
97084>>>>>>>            Get vMoveFile (sDataPath + "*.zip")        (sDataPath + sBackupFolder) to bOK           
97085>>>>>>>            Get vMoveFile (sDataPath + "*.abs")        (sDataPath + sBackupFolder) to bOK           
97086>>>>>>>            Get vMoveFile (sDataPath + "termlist.*")   (sDataPath + sBackupFolder) to bOK
97087>>>>>>>            Get vMoveFile (sDataPath + "*.dfr")        (sDataPath + sBackupFolder) to bOK
97088>>>>>>>            Get vMoveFile (sDataPath + "vsutil.cfg")   (sDataPath + sBackupFolder) to bOK
97089>>>>>>>            Get vMoveFile (sDataPath + "collate.*")    (sDataPath + sBackupFolder) to bOK
97090>>>>>>>            Get vMoveFile (sDataPath + "df_collate.*") (sDataPath + sBackupFolder) to bOK
97091>>>>>>>            Get vDeleteFile (sDataPath + "*.cch")                                  to bOK
97092>>>>>>>        End
97092>>>>>>>>
97092>>>>>>>
97092>>>>>>>        Set Message_Text of ghoStatusPanel to ""
97093>>>>>>>        Function_Return True
97094>>>>>>>    End_Function
97095>>>>>>>    
97095>>>>>>>    // Check if the file exists in the Data folder,
97095>>>>>>>    // else creates it from memory as it has been compiled into the program as a resource:
97095>>>>>>>    Function UtilCheckCreateIfFileExists String sFileName String sResourceName Boolean bDataFile Returns Boolean
97097>>>>>>>        String sPath
97097>>>>>>>        Boolean bExists
97097>>>>>>>
97097>>>>>>>        Get psDataPathFirstPart to sPath
97098>>>>>>>        Move (sPath + sFileName) to sFileName
97099>>>>>>>        Get vFilePathExists sFileName to bExists
97100>>>>>>>
97100>>>>>>>        If (bExists = False) Begin
97102>>>>>>>            // Read from memory & create file on disk.
97102>>>>>>>            Send SqlUtilCreateFileFromMemory sResourceName sFileName
97103>>>>>>>            Get vFilePathExists sFileName to bExists
97104>>>>>>>        End
97104>>>>>>>>
97104>>>>>>>        Function_Return bExists
97105>>>>>>>    End_Function
97106>>>>>>>
97106>>>>>>>    Function UtilSqlColumnTypeToDataFlexType String sDriverID Integer iDbType Integer iDataType Integer iLength Returns Integer
97108>>>>>>>        tColumnType RetvalType
97108>>>>>>>        tColumnType RetvalType
97108>>>>>>>        Integer iRetval
97108>>>>>>>
97108>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
97109>>>>>>>        Move RetvalType.iDataFlexType to iRetval
97110>>>>>>>        If (RetvalType.iDataFlexType = DF_TEXT) Begin
97112>>>>>>>            If (iLength <= 255) Begin
97114>>>>>>>                Move DF_ASCII to iRetval
97115>>>>>>>            End
97115>>>>>>>>
97115>>>>>>>        End
97115>>>>>>>>
97115>>>>>>>        Function_Return iRetval
97116>>>>>>>    End_Function
97117>>>>>>>
97117>>>>>>>    Function UtilDataFlexDataTypeToString Integer iDataType Returns String
97119>>>>>>>        String sRetval
97119>>>>>>>
97119>>>>>>>        Case Begin
97119>>>>>>>            Case (iDataType = DF_ASCII)
97121>>>>>>>                Move "DF_ASCII" to sRetval
97122>>>>>>>                Case Break
97123>>>>>>>            Case (iDataType = DF_BCD)
97126>>>>>>>                Move "DF_BCD" to sRetval
97127>>>>>>>                Case Break
97128>>>>>>>            Case (iDataType = DF_BINARY)
97131>>>>>>>                Move "DF_BINARY" to sRetval
97132>>>>>>>                Case Break
97133>>>>>>>            Case (iDataType = DF_DATE)
97136>>>>>>>                Move "DF_DATE" to sRetval
97137>>>>>>>                Case Break
97138>>>>>>>            Case (iDataType = DF_DATETIME)
97141>>>>>>>                Move "DF_DATETIME" to sRetval
97142>>>>>>>                Case Break
97143>>>>>>>            Case (iDataType = DF_TEXT)
97146>>>>>>>                Move "DF_TEXT" to sRetval
97147>>>>>>>                Case Break
97148>>>>>>>            Case Else
97148>>>>>>>                Move "" to sRetval
97149>>>>>>>        Case End
97149>>>>>>>
97149>>>>>>>        Function_Return sRetval
97150>>>>>>>    End_Function
97151>>>>>>>
97151>>>>>>>    // The default value used for a datatype as specified in the driver int file.
97151>>>>>>>    Function UtilDataTypeDefaultValue String sDriverID Integer iDbType Integer iDataType Returns String
97153>>>>>>>        String sRetval sServer
97153>>>>>>>        tColumnType RetvalType
97153>>>>>>>        tColumnType RetvalType
97153>>>>>>>        Integer iDriver iDataFlexType
97153>>>>>>>        Handle hDatabase
97153>>>>>>>
97153>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
97154>>>>>>>        Move RetvalType.iDataFlexType to iDataFlexType
97155>>>>>>>        Get DriverIndex sDriverID to iDriver
97156>>>>>>>        Get psServer to sServer
97157>>>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
97158>>>>>>>        If (hDatabase = 0) Begin
97160>>>>>>>            Function_Return ""
97161>>>>>>>        End
97161>>>>>>>>
97161>>>>>>>
97161>>>>>>>        Case Begin
97161>>>>>>>            Case (iDataFlexType = DF_ASCII)
97163>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_ASCII     of iDriver hDatabase to sRetval
97166>>>>>>>                Case Break
97167>>>>>>>            Case (iDataFlexType = DF_BCD)
97170>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_NUMERIC   of iDriver hDatabase to sRetval
97173>>>>>>>                Case Break
97174>>>>>>>            Case (iDataFlexType = DF_BINARY)
97177>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_BINARY    of iDriver hDatabase to sRetval
97180>>>>>>>                Case Break
97181>>>>>>>            Case (iDataFlexType = DF_DATE)
97184>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE      of iDriver hDatabase to sRetval
97187>>>>>>>                Case Break
97188>>>>>>>            Case (iDataFlexType = DF_DATETIME)
97191>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME  of iDriver hDatabase to sRetval
97194>>>>>>>                Case Break
97195>>>>>>>            Case (iDataFlexType = DF_TEXT)
97198>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_TEXT      of iDriver hDatabase to sRetval
97201>>>>>>>                Case Break
97202>>>>>>>            Case Else
97202>>>>>>>                Move "" to sRetval
97203>>>>>>>        Case End
97203>>>>>>>
97203>>>>>>>        Function_Return sRetval
97204>>>>>>>    End_Function
97205>>>>>>>
97205>>>>>>>    Procedure Set Df_Database_Default_Default_Date_DUF String sDateValue
97207>>>>>>>        String sDriverID sServer
97207>>>>>>>        tColumnType RetvalType
97207>>>>>>>        tColumnType RetvalType
97207>>>>>>>        Integer iDbType iDriver
97207>>>>>>>        Handle hDatabase
97207>>>>>>>
97207>>>>>>>        Get psDriverID to sDriverID
97208>>>>>>>        Get piDbType   to iDbType
97209>>>>>>>        Get DriverIndex sDriverID to iDriver
97210>>>>>>>        Get psServer to sServer
97211>>>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
97212>>>>>>>        If (hDatabase = 0) Begin
97214>>>>>>>            Error DFERR_PROGRAM "Could not change the Default Date Value. Could not get a handle to the database. (Check that at least one connection is 'Enabled')"
97215>>>>>>>>
97215>>>>>>>            Procedure_Return
97216>>>>>>>        End
97216>>>>>>>>
97216>>>>>>>
97216>>>>>>>        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE of iDriver hDatabase to sDateValue
97219>>>>>>>
97219>>>>>>>    End_Procedure
97220>>>>>>>
97220>>>>>>>    Procedure Set Df_Database_Default_Default_Datetime_DUF String sDateValue
97222>>>>>>>        String sDriverID sServer
97222>>>>>>>        tColumnType RetvalType
97222>>>>>>>        tColumnType RetvalType
97222>>>>>>>        Integer iDbType iDriver
97222>>>>>>>        Handle hDatabase
97222>>>>>>>
97222>>>>>>>        Get psDriverID to sDriverID
97223>>>>>>>        Get piDbType   to iDbType
97224>>>>>>>        Get DriverIndex sDriverID to iDriver
97225>>>>>>>        Get psServer to sServer
97226>>>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
97227>>>>>>>        If (hDatabase = 0) Begin
97229>>>>>>>            Error DFERR_PROGRAM "Could not change the Default DateTime Value. Could not get a handle to the database."
97230>>>>>>>>
97230>>>>>>>            Procedure_Return
97231>>>>>>>        End
97231>>>>>>>>
97231>>>>>>>
97231>>>>>>>        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME of iDriver hDatabase to sDateValue
97234>>>>>>>
97234>>>>>>>    End_Procedure
97235>>>>>>>
97235>>>>>>>    // Returns a struct array with the default column types for the SQL back-end and how they
97235>>>>>>>    // are mapped to the standard DataFlex data types.
97235>>>>>>>    // The DataFlex data types are: "ASCII", "BINARY", "DATE", "DATETIME", "NUMERIC" and "TEXT".
97235>>>>>>>    Function UtilDefaultSqlTypeMappings String sDriverID Integer iDbType Returns tColumnType[]
97237>>>>>>>        tColumnType[] ColumnTypeArray EmptyArray
97237>>>>>>>        tColumnType[] ColumnTypeArray EmptyArray
97239>>>>>>>        String sDataType
97239>>>>>>>        Integer iDataType iDriverID iCount
97239>>>>>>>        Boolean bSQLDriver
97239>>>>>>>
97239>>>>>>>        Move 0 to iCount
97240>>>>>>>        Get DriverIndex sDriverID to iDriverID
97241>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
97242>>>>>>>        If (bSQLDriver = False) Begin
97244>>>>>>>            Function_Return EmptyArray
97245>>>>>>>        End
97245>>>>>>>>
97245>>>>>>>
97245>>>>>>>        // DF_ASCII
97245>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
97247>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
97250>>>>>>>        End
97250>>>>>>>>
97250>>>>>>>        Else Begin
97251>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
97254>>>>>>>        End
97254>>>>>>>>
97254>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
97255>>>>>>>        Move DF_ASCII    to ColumnTypeArray[iCount].iDataFlexType
97256>>>>>>>        Move "ASCII"     to ColumnTypeArray[iCount].sDataFlexType
97257>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
97258>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
97259>>>>>>>        Increment iCount
97260>>>>>>>
97260>>>>>>>        // DF_BINARY
97260>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
97262>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
97265>>>>>>>        End
97265>>>>>>>>
97265>>>>>>>        Else Begin
97266>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
97269>>>>>>>        End
97269>>>>>>>>
97269>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
97270>>>>>>>        Move DF_BINARY   to ColumnTypeArray[iCount].iDataFlexType
97271>>>>>>>        Move "Binary"    to ColumnTypeArray[iCount].sDataFlexType
97272>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
97273>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
97274>>>>>>>        Increment iCount
97275>>>>>>>
97275>>>>>>>        // DF_DATE
97275>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
97277>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
97280>>>>>>>        End
97280>>>>>>>>
97280>>>>>>>        Else Begin
97281>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
97284>>>>>>>        End
97284>>>>>>>>
97284>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
97285>>>>>>>        Move DF_DATE     to ColumnTypeArray[iCount].iDataFlexType
97286>>>>>>>        Move "Date"      to ColumnTypeArray[iCount].sDataFlexType
97287>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
97288>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
97289>>>>>>>        Increment iCount
97290>>>>>>>
97290>>>>>>>        // DF_DATETIME
97290>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
97292>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
97295>>>>>>>        End
97295>>>>>>>>
97295>>>>>>>        Else Begin
97296>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
97299>>>>>>>        End
97299>>>>>>>>
97299>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
97300>>>>>>>        Move DF_DATETIME to ColumnTypeArray[iCount].iDataFlexType
97301>>>>>>>        Move "DateTime"  to ColumnTypeArray[iCount].sDataFlexType
97302>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
97303>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
97304>>>>>>>        Increment iCount
97305>>>>>>>
97305>>>>>>>        // DF_NUMERIC
97305>>>>>>>        // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
97305>>>>>>>        // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
97305>>>>>>>        // we make them here all "Numeric"...
97305>>>>>>>        Case Begin
97305>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
97307>>>>>>>                Move SQL_NUMERIC to iDataType
97308>>>>>>>                Move "numeric"   to sDataType
97309>>>>>>>                Case Break
97310>>>>>>>            Case (sDriverID = DB2_DRV_ID)
97313>>>>>>>                Move SQL_NUMERIC to iDataType
97314>>>>>>>                Move "NUMERIC"   to sDataType
97315>>>>>>>                Case Break
97316>>>>>>>            Case (sDriverID = SQLFLEX)
97319>>>>>>>                Move eSQLServer_NUMERIC to iDataType
97320>>>>>>>                Move "numeric"   to sDataType
97321>>>>>>>                Case Break
97322>>>>>>>            Case (sDriverID = MDSMySQL)
97325>>>>>>>                Move eMySQL_DECIMAL to iDataType
97326>>>>>>>                Move "decimal"   to sDataType
97327>>>>>>>                Case Break
97328>>>>>>>            Case (sDriverID = ORAFLEX)
97331>>>>>>>                Move eOracle_NUMBER to iDataType
97332>>>>>>>                Move "NUMBER"   to sDataType
97333>>>>>>>                Case Break
97334>>>>>>>            Case (sDriverID = MDSPgSQL)
97337>>>>>>>                Move ePgSQL_FLOAT4 to iDataType
97338>>>>>>>                Move "decimal"   to sDataType
97339>>>>>>>                Case Break
97340>>>>>>>            Case Else
97340>>>>>>>                Move DF_BCD      to iDataType
97341>>>>>>>                Move "Numeric"   to sDataType
97342>>>>>>>        Case End
97342>>>>>>>        Move DF_BCD      to ColumnTypeArray[iCount].iDataFlexType
97343>>>>>>>        Move "Numeric"   to ColumnTypeArray[iCount].sDataFlexType
97344>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
97345>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
97346>>>>>>>        Increment iCount
97347>>>>>>>
97347>>>>>>>        // DF_TEXT
97347>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
97349>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
97352>>>>>>>        End
97352>>>>>>>>
97352>>>>>>>        Else Begin
97353>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
97356>>>>>>>        End
97356>>>>>>>>
97356>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
97357>>>>>>>        Move DF_TEXT     to ColumnTypeArray[iCount].iDataFlexType
97358>>>>>>>        Move "Text"      to ColumnTypeArray[iCount].sDataFlexType
97359>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
97360>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
97361>>>>>>>
97361>>>>>>>        Function_Return ColumnTypeArray
97362>>>>>>>    End_Function
97363>>>>>>>
97363>>>>>>>    Function UtilDFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
97365>>>>>>>        tColumnType[] ColumnTypeArray
97365>>>>>>>        tColumnType[] ColumnTypeArray
97366>>>>>>>        tColumnType   ColumnType
97366>>>>>>>        tColumnType   ColumnType
97366>>>>>>>        Integer iCount iSize
97366>>>>>>>
97366>>>>>>>        Get UtilDefaultSqlTypeMappings sDriverID iDbType iType to ColumnTypeArray
97367>>>>>>>        Move (SizeOfArray(ColumnTypeArray)) to iSize
97368>>>>>>>        Decrement iSize
97369>>>>>>>
97369>>>>>>>        for iCount from 0 to iSize
97375>>>>>>>>
97375>>>>>>>            If (iType = ColumnTypeArray[iCount].iDataFlexType) Begin
97377>>>>>>>                Move ColumnTypeArray[iCount].bCanEditSize   to ColumnType.bCanEditSize
97378>>>>>>>                Move ColumnTypeArray[iCount].iDataFlexType  to ColumnType.iDataFlexType
97379>>>>>>>                Move ColumnTypeArray[iCount].iSQLType       to ColumnType.iSQLType
97380>>>>>>>                Move ColumnTypeArray[iCount].sDataFlexType  to ColumnType.sDataFlexType
97381>>>>>>>                Move ColumnTypeArray[iCount].sPrecision     to ColumnType.sPrecision
97382>>>>>>>                Move ColumnTypeArray[iCount].sSQLType       to ColumnType.sSQLType
97383>>>>>>>                Move iSize to iCount
97384>>>>>>>            End
97384>>>>>>>>
97384>>>>>>>        Loop
97385>>>>>>>>
97385>>>>>>>
97385>>>>>>>        Function_Return ColumnType
97386>>>>>>>    End_Function
97387>>>>>>>
97387>>>>>>>    // Returns a struct with the default column types for the SQL back-end and how they
97387>>>>>>>    // are mapped to a DUF data type.
97387>>>>>>>    Function UtilDUFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
97389>>>>>>>        tColumnType ColumnType
97389>>>>>>>        tColumnType ColumnType
97389>>>>>>>        String sDataType
97389>>>>>>>        Integer iDriverID iCount
97389>>>>>>>
97389>>>>>>>        Move 0 to iCount
97390>>>>>>>        Get DriverIndex sDriverID to iDriverID
97391>>>>>>>
97391>>>>>>>        Case Begin
97391>>>>>>>            // DF_ASCII
97391>>>>>>>            Case (iType = DF_ASCII_DUF)
97393>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
97395>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
97398>>>>>>>                End
97398>>>>>>>>
97398>>>>>>>                Else Begin
97399>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
97402>>>>>>>                End
97402>>>>>>>>
97402>>>>>>>                Move DF_ASCII    to ColumnType.iDataFlexType
97403>>>>>>>                Move "ASCII"     to ColumnType.sDataFlexType
97404>>>>>>>                Move sDataType   to ColumnType.sSQLType
97405>>>>>>>                Move DF_ASCII    to ColumnType.iSQLType
97406>>>>>>>                Move False       to ColumnType.bCanEditSize
97407>>>>>>>                Case Break
97408>>>>>>>
97408>>>>>>>            // DF_BINARY
97408>>>>>>>            Case (iType = DF_BINARY_DUF)
97411>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
97413>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
97416>>>>>>>                End
97416>>>>>>>>
97416>>>>>>>                Else Begin
97417>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
97420>>>>>>>                End
97420>>>>>>>>
97420>>>>>>>                Move DF_BINARY   to ColumnType.iDataFlexType
97421>>>>>>>                Move "Binary"    to ColumnType.sDataFlexType
97422>>>>>>>                Move sDataType   to ColumnType.sSQLType
97423>>>>>>>                Move DF_BINARY   to ColumnType.iSQLType
97424>>>>>>>                Move False       to ColumnType.bCanEditSize
97425>>>>>>>                Case Break
97426>>>>>>>
97426>>>>>>>            // DF_DATE
97426>>>>>>>            Case (iType = DF_DATE_DUF)
97429>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
97431>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
97434>>>>>>>                End
97434>>>>>>>>
97434>>>>>>>                Else Begin
97435>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
97438>>>>>>>                End
97438>>>>>>>>
97438>>>>>>>                Move DF_DATE     to ColumnType.iDataFlexType
97439>>>>>>>                Move "Date"      to ColumnType.sDataFlexType
97440>>>>>>>                Move sDataType   to ColumnType.sSQLType
97441>>>>>>>                Move DF_DATE     to ColumnType.iSQLType
97442>>>>>>>                Move True        to ColumnType.bCanEditSize
97443>>>>>>>                Case Break
97444>>>>>>>
97444>>>>>>>            // DF_DATETIME
97444>>>>>>>            Case (iType = DF_DATETIME_DUF)
97447>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
97449>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
97452>>>>>>>                End
97452>>>>>>>>
97452>>>>>>>                Else Begin
97453>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
97456>>>>>>>                End
97456>>>>>>>>
97456>>>>>>>                Move DF_DATETIME to ColumnType.iDataFlexType
97457>>>>>>>                Move "DateTime"  to ColumnType.sDataFlexType
97458>>>>>>>                Move sDataType   to ColumnType.sSQLType
97459>>>>>>>                Move DF_DATETIME to ColumnType.iSQLType
97460>>>>>>>                Move True        to ColumnType.bCanEditSize
97461>>>>>>>                Case Break
97462>>>>>>>
97462>>>>>>>            // DF_NUMERIC
97462>>>>>>>            // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
97462>>>>>>>            // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
97462>>>>>>>            // we make them here all "Numeric"...
97462>>>>>>>            // If (sDriverID = ODBC_DRV_ID) Begin
97462>>>>>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
97462>>>>>>>            // End
97462>>>>>>>            // Else Begin
97462>>>>>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
97462>>>>>>>            // End
97462>>>>>>>            // ToDo: How should we find the best "Numeric" data type here?
97462>>>>>>>            Case (iType = DF_BCD_DUF)
97465>>>>>>>                Move DF_BCD      to ColumnType.iDataFlexType
97466>>>>>>>                Move "Numeric"   to ColumnType.sDataFlexType
97467>>>>>>>                Move "Numeric"   to ColumnType.sSQLType
97468>>>>>>>                Move SQL_NUMERIC to ColumnType.iSQLType
97469>>>>>>>                Move False       to ColumnType.bCanEditSize
97470>>>>>>>                Case Break
97471>>>>>>>
97471>>>>>>>            // DF_TEXT
97471>>>>>>>            Case (iType = DF_TEXT_DUF)
97474>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
97476>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
97479>>>>>>>                End
97479>>>>>>>>
97479>>>>>>>                Else Begin
97480>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
97483>>>>>>>                End
97483>>>>>>>>
97483>>>>>>>                Move DF_TEXT     to ColumnType.iDataFlexType
97484>>>>>>>                Move "Text"      to ColumnType.sDataFlexType
97485>>>>>>>                Move sDataType   to ColumnType.sSQLType
97486>>>>>>>                Move DF_TEXT     to ColumnType.iSQLType
97487>>>>>>>                Move False       to ColumnType.bCanEditSize
97488>>>>>>>                Case Break
97489>>>>>>>
97489>>>>>>>            Case Else
97489>>>>>>>                Move -1999       to ColumnType.iDataFlexType
97490>>>>>>>                Move "Undefined" to ColumnType.sDataFlexType
97491>>>>>>>                Move "Undefined" to ColumnType.sSQLType
97492>>>>>>>                Move -1999       to ColumnType.iSQLType
97493>>>>>>>                Move True        to ColumnType.bCanEditSize
97494>>>>>>>
97494>>>>>>>        Case End
97494>>>>>>>
97494>>>>>>>        Function_Return ColumnType
97495>>>>>>>    End_Function
97496>>>>>>>
97496>>>>>>>    Function UtilDeleteCacheFile String sTableName Returns Boolean
97498>>>>>>>        String sDataPath sDriverID
97498>>>>>>>        Boolean bMertechDriver bOK
97498>>>>>>>        Integer iPos
97498>>>>>>>
97498>>>>>>>        If (sTableName contains ".") Begin
97500>>>>>>>            Move (Pos(".", sTableName)) to iPos
97501>>>>>>>            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
97502>>>>>>>        End
97502>>>>>>>>
97502>>>>>>>
97502>>>>>>>        Get psDriverID to sDriverID
97503>>>>>>>        Get psDataPathFirstPart to sDataPath
97504>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
97505>>>>>>>        // First delete the cache file:
97505>>>>>>>        If (bMertechDriver = False) Begin
97507>>>>>>>            Get vDeleteFile (sDataPath + sTableName + ".cch") to bOK
97508>>>>>>>        End
97508>>>>>>>>
97508>>>>>>>        Else Begin
97509>>>>>>>            Get _MertechDeleteTDFile sTableName to bOK
97510>>>>>>>        End
97510>>>>>>>>
97510>>>>>>>
97510>>>>>>>        Function_Return bOK
97511>>>>>>>    End_Function
97512>>>>>>>
97512>>>>>>>    // Changes source code files.
97512>>>>>>>    // Pass a file name with full path and a value to search for, together with the value
97512>>>>>>>    // to change to. Can e.g. be used for changing all .int files from using a fixed server name,
97512>>>>>>>    // to use a Connection ID.
97512>>>>>>>    // Sample: Get UtilChangeSourceCodeLine "C:\DataFlex 18.2 Examples\Order Entry\Data\Order.int" "SERVER_NAME SERVER=(local)\SQLEXPRESS1" "SERVER_NAME DFCONNID=ChinookDb"
97512>>>>>>>    // Pass "True" for the bShowResult if you want to see the result while it works. Showln will then be used for output
97512>>>>>>>    // Returns True if no errors occured.
97512>>>>>>>    Function UtilChangeSourceCodeLine String sFileName String sChangeFrom String sChangeTo Boolean bShowResult Returns Boolean
97514>>>>>>>        Integer iCh iRow iItems iCount
97514>>>>>>>        String sValue sRow
97514>>>>>>>        String[] sFileArray
97515>>>>>>>        Boolean bExists bIsActive
97515>>>>>>>
97515>>>>>>>        Move False to Err
97516>>>>>>>        Move 0 to iRow
97517>>>>>>>
97517>>>>>>>        If (ghoStatusPanel <> 0) Begin
97519>>>>>>>            Get Active_state of ghoStatusPanel to bIsActive
97520>>>>>>>        End
97520>>>>>>>>
97520>>>>>>>
97520>>>>>>>        Get vFilePathExists sFileName to bExists
97521>>>>>>>        If (bExists = False) Begin
97523>>>>>>>            If (bShowResult = True) Begin
97525>>>>>>>                If (bIsActive = True) Begin
97527>>>>>>>                    Send Update_StatusPanel of ghoStatusPanel ("File does not exist:" * String(sFileName))
97528>>>>>>>                End
97528>>>>>>>>
97528>>>>>>>                Else Begin
97529>>>>>>>                    Showln "File does not exist: " sFileName
97532>>>>>>>                End
97532>>>>>>>>
97532>>>>>>>            End
97532>>>>>>>>
97532>>>>>>>            Function_Return False
97533>>>>>>>        End
97533>>>>>>>>
97533>>>>>>>
97533>>>>>>>        Get Seq_Open_Input_Channel sFileName to iCh
97534>>>>>>>        If (iCh < 1) Begin
97536>>>>>>>            Function_Return False
97537>>>>>>>        End
97537>>>>>>>>
97537>>>>>>>
97537>>>>>>>        If (bShowResult = True) Begin
97539>>>>>>>            If (ghoStatusPanel <> 0) Begin
97541>>>>>>>                Get Active_state of ghoStatusPanel to bIsActive
97542>>>>>>>                If (bIsActive = True) Begin
97544>>>>>>>                    Set Message_Text of ghoStatusPanel to sFileName
97545>>>>>>>                    Send Update_StatusPanel of ghoStatusPanel ("sChangeFrom =" * String(sChangeFrom) * "sChangeTo =" * String(sChangeTo))
97546>>>>>>>                    Send DoAdvance of ghoProgressBar
97547>>>>>>>                End
97547>>>>>>>>
97547>>>>>>>            End
97547>>>>>>>>
97547>>>>>>>            Else Begin
97548>>>>>>>                Showln ""
97550>>>>>>>                Showln "sFileName = " sFileName
97553>>>>>>>                Showln "sChangeFrom = " sChangeFrom " sChangeTo = " sChangeTo
97558>>>>>>>            End
97558>>>>>>>>
97558>>>>>>>        End
97558>>>>>>>>
97558>>>>>>>
97558>>>>>>>        While (not(SeqEof))
97562>>>>>>>            Readln channel iCh sRow
97564>>>>>>>            If (Uppercase(sRow) contains Uppercase(sChangeFrom)) Begin
97566>>>>>>>//                If (bShowResult = True) Begin
97566>>>>>>>//                    If (bIsActive = True) Begin
97566>>>>>>>//                        Send Update_StatusPanel of ghoStatusPanel ("Changed from:" * String(sRow) * "to:" * String(sChangeTo))
97566>>>>>>>//                    End
97566>>>>>>>//                    Else Begin
97566>>>>>>>//                        Showln "Changed from: " sRow " to: " sChangeTo
97566>>>>>>>//                    End
97566>>>>>>>//                End
97566>>>>>>>                // Change the whole line to the new connection id:
97566>>>>>>>                Move sChangeTo to sRow
97567>>>>>>>                // Move (Replaces(sChangeFrom, sRow, sChangeTo)) to sValue
97567>>>>>>>            End
97567>>>>>>>>
97567>>>>>>>            Move sRow to sFileArray[iRow]
97568>>>>>>>            Increment iRow
97569>>>>>>>        Loop
97570>>>>>>>>
97570>>>>>>>        Send Seq_Close_Channel iCh
97571>>>>>>>
97571>>>>>>>        Sleep 1 // Wait for Windows to close the file
97572>>>>>>>
97572>>>>>>>        Get Seq_Open_Output_Channel sFileName to iCh
97573>>>>>>>        If (iCh < 1) Begin
97575>>>>>>>            Function_Return False
97576>>>>>>>        End
97576>>>>>>>>
97576>>>>>>>        Move (SizeOfArray(sFileArray)) to iItems
97577>>>>>>>        Decrement iItems
97578>>>>>>>
97578>>>>>>>        For iCount from 0 to iItems
97584>>>>>>>>
97584>>>>>>>            Move sFileArray[iCount] to sValue
97585>>>>>>>            Writeln channel iCh sValue
97588>>>>>>>        Loop
97589>>>>>>>>
97589>>>>>>>        Send Seq_Close_Channel iCh
97590>>>>>>>
97590>>>>>>>        Function_Return (Err = False)
97591>>>>>>>    End_Function
97592>>>>>>>
97592>>>>>>>    Function AutoSetConnectionID String sConnectionID Returns Boolean
97594>>>>>>>        Integer iRetval
97594>>>>>>>        Move 1 to iRetval
97595>>>>>>>        If (ghoSQLConnectionHandler <> 0) Begin
97597>>>>>>>            Set psConnectionID of ghoSQLConnectionHandler to sConnectionID
97598>>>>>>>            Get AutoSetConnectionID of ghoSQLConnectionHandler to iRetval
97599>>>>>>>        End
97599>>>>>>>>
97599>>>>>>>        Function_Return (iRetval = 0)
97600>>>>>>>    End_Function
97601>>>>>>>
97601>>>>>>>    // *** DEPRECIATED ***
97601>>>>>>>    // Use the AutoSetConnectionID function instead.
97601>>>>>>>    // This might be needed by API-methods when a connection id is to be used and
97601>>>>>>>    // the connection ID hasn't been established with the driver's CLI interface.
97601>>>>>>>    // NOTE: Only applicable for DAW drivers, as Mertech drivers doesn't use connection ID's.
97601>>>>>>>//    Function UtilCreateConnectionID String sConnectionID Returns Boolean
97601>>>>>>>//        String sConnectionString sDriverID
97601>>>>>>>//        Boolean bOK bSilent bDawDriver
97601>>>>>>>//        Handle hoCLI
97601>>>>>>>//
97601>>>>>>>//        Move False to bOK
97601>>>>>>>//        Get psDriverID to sDriverID
97601>>>>>>>//        Get IsDAWSQLDriver sDriverID to bDawDriver
97601>>>>>>>//        If (bDawDriver = False) Begin
97601>>>>>>>//            Error DFERR_PROGRAM "The UtilCreateConnectionID function is only available for DAW drivers. (Not Mertech)."
97601>>>>>>>//            Function_Return False
97601>>>>>>>//        End
97601>>>>>>>//
97601>>>>>>>//        Get psConnectionString to sConnectionString
97601>>>>>>>//        Get pbSilentLogin      to bSilent
97601>>>>>>>//
97601>>>>>>>//        Get phoCLIHandler to hoCLI
97601>>>>>>>//        If (hoCLI <> 0) Begin
97601>>>>>>>//            Set psDriverID of hoCLI to sDriverID
97601>>>>>>>//            Get CreateConnectionID of hoCLI sConnectionID sConnectionString bSilent to bOK
97601>>>>>>>//        End
97601>>>>>>>//
97601>>>>>>>//        Function_Return (bOK = False)
97601>>>>>>>//    End_Function
97601>>>>>>>
97601>>>>>>>    // This message creates an error log in the "Home" folder named "SQLErrorLog.txt",
97601>>>>>>>    // and opens it in "notepad.exe".
97601>>>>>>>    // Note: This is _not_ used by the cDbUpdateHandler & cDbUpdateVersion classes!
97601>>>>>>>    //       Instead the cDbUpdateLogFile's WriteErrorLog & ShowErrorLog are used.
97601>>>>>>>    Procedure UtilShowErrorList
97603>>>>>>>        tSqlErrorArray aSqlErrorArray
97603>>>>>>>        tSqlErrorArray aSqlErrorArray
97603>>>>>>>        Integer iRows iCount iCh iErrorNum
97603>>>>>>>        String sPath sFileName sErrorTxt sStatement
97603>>>>>>>
97603>>>>>>>        Get psHome of (phoWorkspace(ghoApplication)) to sPath
97604>>>>>>>        Get vFolderFormat sPath to sPath
97605>>>>>>>        Move "SQLErrorLog.txt"  to sFileName
97606>>>>>>>        Get Seq_Open_Output_Channel (sPath + sFileName) to iCh
97607>>>>>>>            Get paSqlErrorArray to aSqlErrorArray
97608>>>>>>>            Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iRows
97609>>>>>>>            If (iRows > 0) Begin
97611>>>>>>>                Decrement iRows
97612>>>>>>>                for iCount from 0 to iRows
97618>>>>>>>>
97618>>>>>>>                    Move aSqlErrorArray.sSqlErrorArray[iCount]      to sErrorTxt
97619>>>>>>>                    Move aSqlErrorArray.sSqlStatementArray[iCount]  to sStatement
97620>>>>>>>                    Move aSqlErrorArray.iSqlErrorArray[iCount]      to iErrorNum
97621>>>>>>>                    Writeln channel iCh "Error No: " iErrorNum " Error Text: " sErrorTxt
97627>>>>>>>                    Writeln channel iCh "SQL Statement: " sStatement
97631>>>>>>>                Loop
97632>>>>>>>>
97632>>>>>>>            End
97632>>>>>>>>
97632>>>>>>>        Send Seq_Close_Channel iCh
97633>>>>>>>
97633>>>>>>>        If (iRows > 0) Begin
97635>>>>>>>            Runprogram Shell Background (sPath + sFileName)
97636>>>>>>>        End
97636>>>>>>>>
97636>>>>>>>    End_Procedure
97637>>>>>>>
97637>>>>>>>    // For this to be returning a True value, the table number needs to be in the Filelist.cfg,
97637>>>>>>>    // and the table needs to exist as an SQL table.
97637>>>>>>>    Function UtilTableIsSql Handle hTable Returns Boolean
97639>>>>>>>        String sRootName sDriverID
97639>>>>>>>        Boolean bIsSQL
97639>>>>>>>
97639>>>>>>>        Move False to bIsSQL
97640>>>>>>>        If (hTable > 0) Begin
97642>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
97645>>>>>>>            Get UtilTableIsSqlByRootName sRootName to bIsSQL
97646>>>>>>>            If (bIsSQL = True) Begin
97648>>>>>>>                Get psDriverID to sDriverID
97649>>>>>>>                Get _TableNameOnly sRootName to sRootName
97650>>>>>>>                Get SqlUtilCheckIfTableNameExists sRootName sDriverID to bIsSQL
97651>>>>>>>            End
97651>>>>>>>>
97651>>>>>>>        End
97651>>>>>>>>
97651>>>>>>>
97651>>>>>>>        Function_Return bIsSQL
97652>>>>>>>    End_Function
97653>>>>>>>
97653>>>>>>>    Function UtilTableIsSqlByRootName String sRootName Returns Boolean
97655>>>>>>>        Boolean bIsSQL
97655>>>>>>>        Move (sRootName contains ":") to bIsSQL
97656>>>>>>>        Function_Return bIsSQL
97657>>>>>>>    End_Function
97658>>>>>>>
97658>>>>>>>    // Checks that the passed hTable number both exists in Filelist.cfg and
97658>>>>>>>    // that the embedded .dat file exists on disk.
97658>>>>>>>    Function UtilTableIsEmbedded Handle hTable Returns Boolean
97660>>>>>>>        Boolean bExists bIsEmbedded
97660>>>>>>>        String sDataPath sRootName
97660>>>>>>>
97660>>>>>>>        Get UtilTableNumberIsInUse hTable to bExists
97661>>>>>>>        If (bExists = False) Begin
97663>>>>>>>            Function_Return False
97664>>>>>>>        End
97664>>>>>>>>
97664>>>>>>>
97664>>>>>>>        Move False to bIsEmbedded
97665>>>>>>>        If (hTable > 0) Begin
97667>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
97670>>>>>>>            Move (not(sRootName contains ":")) to bIsEmbedded
97671>>>>>>>        End
97671>>>>>>>>
97671>>>>>>>        If (bIsEmbedded = True) Begin
97673>>>>>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
97674>>>>>>>            Get vFolderFormat sDataPath to sDataPath
97675>>>>>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bIsEmbedded
97676>>>>>>>        End
97676>>>>>>>>
97676>>>>>>>
97676>>>>>>>        Function_Return bIsEmbedded
97677>>>>>>>    End_Function
97678>>>>>>>
97678>>>>>>>
97678>>>>>>>    // Returns True if the passed hTable (filelist slot number) is an Alias table.
97678>>>>>>>    // An Alias file/table is a filelist number that share the same Physical filename
97678>>>>>>>    // but the Logical name is different.
97678>>>>>>>    // Note: If the table cannot be opened; the table is not considered to be an Alias.
97678>>>>>>>    Function UtilTableIsAlias Handle hTable Returns Boolean
97680>>>>>>>        String sRootName sRootNameCompare sLogicalName sLogicalNameCompare
97680>>>>>>>        Handle hInTable hMasterTable 
97680>>>>>>>        Boolean bIsAlias
97680>>>>>>>        
97680>>>>>>>        Move hTable to hInTable
97681>>>>>>>        Move False to bIsAlias
97682>>>>>>>        Move 0 to hMasterTable
97683>>>>>>>        
97683>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
97686>>>>>>>        // Remove any prefix with a driver name.
97686>>>>>>>        Get _TableNameOnly sRootName to sRootName     
97687>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
97690>>>>>>>        Get _TableNameOnly sLogicalName to sLogicalName     
97691>>>>>>>        
97691>>>>>>>        // If the table has the same root and logical name it can't be an alias,
97691>>>>>>>        // so we can safely return a "False".
97691>>>>>>>        If (Uppercase(sRootName) = Uppercase(sLogicalName)) Begin
97693>>>>>>>            Function_Return False
97694>>>>>>>        End
97694>>>>>>>>
97694>>>>>>>        
97694>>>>>>>        // Now we need to find a master table with the same root name (sRootName above),
97694>>>>>>>        // as the passed hTable root name.
97694>>>>>>>        // A master table always has the same root and logical name.
97694>>>>>>>        Move 0 to hTable
97695>>>>>>>        Repeat
97695>>>>>>>>
97695>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
97698>>>>>>>            If (hTable > 0 and hTable <> 50) Begin
97700>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootNameCompare
97703>>>>>>>                Get _TableNameOnly sRootNameCompare to sRootNameCompare
97704>>>>>>>                // If we found another table with the same root and logical name
97704>>>>>>>                // we have found a master table.
97704>>>>>>>                If (Uppercase(sRootName) = Uppercase(sRootNameCompare)) Begin
97706>>>>>>>                    Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalNameCompare
97709>>>>>>>                    Get _TableNameOnly sLogicalNameCompare to sLogicalNameCompare     
97710>>>>>>>                    If (Uppercase(sRootNameCompare) = Uppercase(sLogicalNameCompare)) Begin
97712>>>>>>>                        Move hTable to hMasterTable   
97713>>>>>>>                        Move 0 to hTable // To end the loop.
97714>>>>>>>                    End
97714>>>>>>>>
97714>>>>>>>                End
97714>>>>>>>>
97714>>>>>>>            End
97714>>>>>>>>
97714>>>>>>>        Until (hTable = 0)
97716>>>>>>>        
97716>>>>>>>        If (hMasterTable <> 0 and hMasterTable <> hInTable) Begin
97718>>>>>>>            Move True to bIsAlias
97719>>>>>>>        End
97719>>>>>>>>
97719>>>>>>>        
97719>>>>>>>        Function_Return bIsAlias
97720>>>>>>>    End_Function
97721>>>>>>>
97721>>>>>>>    // To Open a table with any driver.
97721>>>>>>>    // Note: If the driver is <> DATAFLEX_ID  - login credentials are used; it is then assumed
97721>>>>>>>    //       that the proper login properties has been setup properly with the cSQLConnections object.
97721>>>>>>>    //
97721>>>>>>>    // If the open command fails the Err flag will be reset to false, at the end of the function!
97721>>>>>>>    // The found flag is still used to indicate if the open was successful or not. The function
97721>>>>>>>    // returns a True if successful (table could be opened).
97721>>>>>>>    //
97721>>>>>>>    // Using the "Open As" syntax with drivers means that we don't need to rely on .int file settings.
97721>>>>>>>    // This is good because with DFConnectionID's those credentials doesn't need to be available in
97721>>>>>>>    // the .int file (and probably aren't). As long as the login properties of this object have been
97721>>>>>>>    // set properly we can open the table.
97721>>>>>>>    //
97721>>>>>>>    // DAW Driver Syntax:
97721>>>>>>>    //  <CKId>:<Schema>#<Table>@<ConnectString>|<Filename>.int
97721>>>>>>>    //  Now the @<ConnectString> can be followed by a pipe character '|' followed by the name of the INT file.
97721>>>>>>>    //  Doing so, the driver will apply the information from the .INT file to the passed direct Open String.
97721>>>>>>>    //  Note that when an INT file has been passed, it will skip the keyword DRIVER_NAME, SERVER_NAME,
97721>>>>>>>    //  DATABASE_NAME and SCHEMA_NAME from the INT file because those are supposed to be supplied in the String already.
97721>>>>>>>    //  Open mode; iMode = DF_SHARE or DF_EXCLUSIVE.
97721>>>>>>>    //
97721>>>>>>>    // DAW Driver Sample:
97721>>>>>>>    //   Open "MSSQLDRV:dbo#MyFile@SERVER=(local)\SQLEXPRESS;Trusted_Connection=yes;DATABASE=OrderEntry|options|intfile=MyFile.int"
97721>>>>>>>    //
97721>>>>>>>    // Mertech Driver Samples:
97721>>>>>>>    //   SQLFlex:   Open "sql_drv:\\<serverName>\<database>*<owner>*<tableName>=<numberFieds>" as table
97721>>>>>>>    //   MySQLFlex: Open "mdsmysql:\\<serverName>\<database>*<tableName>=<numberFieds>" as table
97721>>>>>>>    //   PgFlex:    Open "mdspgsql:\\<serverName>\<database>*<schema>*<tableName>=<numberFieds>" as table
97721>>>>>>>    //   ORAFlex:   Open "ora_drv:\\<serverName>\<owner>*<tableName>=<numberFieds>" as table
97721>>>>>>>    Function UtilTableOpen Integer hTable String sTableName Integer iMode Returns Boolean
97723>>>>>>>        String sTableNameOrg
97723>>>>>>>        Boolean bOpen bOK
97723>>>>>>>        tSQLConnection SQLConnection
97723>>>>>>>        tSQLConnection SQLConnection
97723>>>>>>>        
97723>>>>>>>        Move False to bOpen
97724>>>>>>>        Move sTableName to sTableNameOrg
97725>>>>>>>        If (hTable > 0) Begin
97727>>>>>>>            Send Ignore_Error of Error_Object_Id 20529
97728>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
97729>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
97730>>>>>>>            Send Ignore_Error of Error_Object_Id 10
97731>>>>>>>            Open hTable Mode iMode
97733>>>>>>>            Send Trap_Error of Error_Object_Id 20529
97734>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
97735>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
97736>>>>>>>            Send Trap_Error of Error_Object_Id 10
97737>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
97740>>>>>>>            If (bOpen = True) Begin
97742>>>>>>>                Function_Return True
97743>>>>>>>            End
97743>>>>>>>>
97743>>>>>>>        End
97743>>>>>>>>
97743>>>>>>>
97743>>>>>>>        Get UtilTableOpenAsIntFile hTable sTableName iMode to bOK 
97744>>>>>>>        If (hTable > 0) Begin
97746>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
97749>>>>>>>        End
97749>>>>>>>>
97749>>>>>>>
97749>>>>>>>        Function_Return bOpen
97750>>>>>>>    End_Function
97751>>>>>>>
97751>>>>>>>    Function UtilTableOpenAsIntFile Integer hTable String sTableName Integer iMode Returns Boolean
97753>>>>>>>        String sDriverID sConnection sSchema sExt sTableNameShort sTableNameOrg
97753>>>>>>>        Boolean bOpen bMertechDriver bOK
97753>>>>>>>        tSQLConnection SQLConnection
97753>>>>>>>        tSQLConnection SQLConnection
97753>>>>>>>
97753>>>>>>>        If (hTable < 1) Begin
97755>>>>>>>            Function_Return False
97756>>>>>>>        End
97756>>>>>>>>
97756>>>>>>>
97756>>>>>>>        Move sTableName to sTableNameOrg
97757>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
97758>>>>>>>        Move SQLConnection.sDriverID to sDriverID
97759>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
97760>>>>>>>        Move SQLConnection.sConnectionString to sConnection
97761>>>>>>>        Move SQLConnection.sSchema to sSchema
97762>>>>>>>        If (sSchema = "") Begin
97764>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
97765>>>>>>>        End
97765>>>>>>>>
97765>>>>>>>
97765>>>>>>>        // We need to remove the ".int" part of the table name because
97765>>>>>>>        // the table name after the "#" in the connection syntax below wants the
97765>>>>>>>        // "bare" table name without any extension.
97765>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
97767>>>>>>>            If (Lowercase(sTableName) contains ".int") Begin
97769>>>>>>>                Get ParseFileExtension sTableName to sExt
97770>>>>>>>                Move (Replace(("." + sExt), sTableName, "")) to sTableNameShort
97771>>>>>>>            End
97771>>>>>>>>
97771>>>>>>>            Else Begin
97772>>>>>>>                Move sTableName to sTableNameShort
97773>>>>>>>                Move (Append(sTableName, ".int")) to sTableName
97774>>>>>>>            End
97774>>>>>>>>
97774>>>>>>>            If (bMertechDriver = False) Begin
97776>>>>>>>                Move (sDriverID + ":" + sSchema + "#" + sTableNameShort + "@" + sConnection + "|options|intfile=" + sTableName) to sConnection
97777>>>>>>>                Move sConnection to sTableName
97778>>>>>>>            End
97778>>>>>>>>
97778>>>>>>>        End
97778>>>>>>>>
97778>>>>>>>
97778>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
97779>>>>>>>        Send Ignore_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
97780>>>>>>>        If (hTable = 0) Begin
97782>>>>>>>            Get NextFreeFilelistSlot to hTable
97783>>>>>>>        End
97783>>>>>>>>
97783>>>>>>>
97783>>>>>>>        Case Begin
97783>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
97785>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
97785>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
97787>>>>>>>                    Close hTable
97788>>>>>>>                    Open sTableName as hTable
97790>>>>>>>                End
97790>>>>>>>>
97790>>>>>>>                Else Begin
97791>>>>>>>                    Get OpenTableExclusive hTable to bOK
97792>>>>>>>                    If (bOK = False) Begin
97794>>>>>>>                        Function_Return False
97795>>>>>>>                    End
97795>>>>>>>>
97795>>>>>>>                End
97795>>>>>>>>
97795>>>>>>>                Case Break
97796>>>>>>>
97796>>>>>>>            Case (sDriverID = DB2_DRV_ID)
97799>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
97799>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
97801>>>>>>>                    Close hTable
97802>>>>>>>                    Open sTableName as hTable
97804>>>>>>>                End
97804>>>>>>>>
97804>>>>>>>                Else Begin
97805>>>>>>>                    Get OpenTableExclusive hTable to bOK
97806>>>>>>>                    If (bOK = False) Begin
97808>>>>>>>                        Function_Return False
97809>>>>>>>                    End
97809>>>>>>>>
97809>>>>>>>                End
97809>>>>>>>>
97809>>>>>>>                Case Break
97810>>>>>>>
97810>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
97813>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
97813>>>>>>>                If (iMode = DF_SHARE) Begin
97815>>>>>>>                    Close hTable
97816>>>>>>>                    Open sTableName as hTable
97818>>>>>>>                End
97818>>>>>>>>
97818>>>>>>>                Else Begin
97819>>>>>>>                    Get OpenTableExclusive hTable to bOK
97820>>>>>>>                    If (bOK = False) Begin
97822>>>>>>>                        Function_Return False
97823>>>>>>>                    End
97823>>>>>>>>
97823>>>>>>>                End
97823>>>>>>>>
97823>>>>>>>                Case Break
97824>>>>>>>
97824>>>>>>>            Case (sDriverID = SQLFLEX)
97827>>>>>>>                // ToDo: What is the <owner>? Same as Schema?
97827>>>>>>>                // SQLFlex:   Open "sql_drv:\\<serverName>\<database>*<owner>*<tableName>=<numberFieds>" as table
97827>>>>>>>                Move (SQLFLEX + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sDatabase + SQLConnection.sSchema + "*" + sTableNameOrg) to sTableName
97828>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
97828>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
97830>>>>>>>                    Close hTable
97831>>>>>>>                    Open sTableName as hTable
97833>>>>>>>                End
97833>>>>>>>>
97833>>>>>>>                Else Begin
97834>>>>>>>                    Get OpenTableExclusive hTable to bOK
97835>>>>>>>                    If (bOK = False) Begin
97837>>>>>>>                        Function_Return False
97838>>>>>>>                    End
97838>>>>>>>>
97838>>>>>>>                End
97838>>>>>>>>
97838>>>>>>>                Case Break
97839>>>>>>>
97839>>>>>>>            Case (sDriverID = MDSMySQL)
97842>>>>>>>                // MySQLFlex: Open "mdsmysql:\\<serverName>\<database>*<tableName>=<numberFieds>" as table
97842>>>>>>>                Move (MDSMySQL + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sDatabase + "*" + sTableNameOrg) to sTableName
97843>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
97843>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
97845>>>>>>>                    Close hTable
97846>>>>>>>                    Open sTableName as hTable
97848>>>>>>>                End
97848>>>>>>>>
97848>>>>>>>                Else Begin
97849>>>>>>>                    Get OpenTableExclusive hTable to bOK
97850>>>>>>>                    If (bOK = False) Begin
97852>>>>>>>                        Function_Return False
97853>>>>>>>                    End
97853>>>>>>>>
97853>>>>>>>                End
97853>>>>>>>>
97853>>>>>>>                Case Break
97854>>>>>>>
97854>>>>>>>            Case (sDriverID = MDSPgSQL)
97857>>>>>>>                // PgFlex: Open "mdspgsql:\\<serverName>\<database>*<schema>*<tableName>=<numberFieds>" as table
97857>>>>>>>                Move (MDSPgSQL + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sDatabase + "*" + SQLConnection.sSchema + "*" + sTableNameOrg) to sTableName
97858>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
97858>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
97860>>>>>>>                    Close hTable
97861>>>>>>>                    Open sTableName as hTable
97863>>>>>>>                End
97863>>>>>>>>
97863>>>>>>>                Else Begin
97864>>>>>>>                    Get OpenTableExclusive hTable to bOK
97865>>>>>>>                    If (bOK = False) Begin
97867>>>>>>>                        Function_Return False
97868>>>>>>>                    End
97868>>>>>>>>
97868>>>>>>>                End
97868>>>>>>>>
97868>>>>>>>                Case Break
97869>>>>>>>
97869>>>>>>>            Case (sDriverID = ORAFLEX)
97872>>>>>>>                // ToDo: What is the <owner>? Same as Schema?
97872>>>>>>>                // ORAFlex: Open "ora_drv:\\<serverName>\<owner>*<tableName>=<numberFieds>" as table
97872>>>>>>>                Move (ORAFLEX + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sSchema + "*" + sTableName) to sTableName
97873>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
97873>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
97875>>>>>>>                    Close hTable
97876>>>>>>>                    Open sTableName as hTable
97878>>>>>>>                End
97878>>>>>>>>
97878>>>>>>>                Else Begin
97879>>>>>>>                    Get OpenTableExclusive hTable to bOK
97880>>>>>>>                    If (bOK = False) Begin
97882>>>>>>>                        Function_Return False
97883>>>>>>>                    End
97883>>>>>>>>
97883>>>>>>>                End
97883>>>>>>>>
97883>>>>>>>                Case Break
97884>>>>>>>
97884>>>>>>>            Case (sDriverID = DATAFLEX_ID)
97887>>>>>>>                If (sTableName <> "" and iMode <> DF_EXCLUSIVE) Begin
97889>>>>>>>                    Close hTable
97890>>>>>>>                    Open sTableName as hTable
97892>>>>>>>                End
97892>>>>>>>>
97892>>>>>>>                Else If (iMode = DF_EXCLUSIVE) Begin
97895>>>>>>>                    Get OpenTableExclusive hTable to bOK
97896>>>>>>>                    If (bOK = False) Begin
97898>>>>>>>                        Function_Return False
97899>>>>>>>                    End
97899>>>>>>>>
97899>>>>>>>                End
97899>>>>>>>>
97899>>>>>>>                Else Begin
97900>>>>>>>                    Open hTable
97902>>>>>>>                End
97902>>>>>>>>
97902>>>>>>>                Case Break
97903>>>>>>>
97903>>>>>>>            Case Else
97903>>>>>>>                Error DFERR_PROGRAM ("Invalid driver:" * sDriverID)
97904>>>>>>>>
97904>>>>>>>        Case End
97904>>>>>>>
97904>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
97905>>>>>>>        Send Trap_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
97906>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
97908>>>>>>>            Move False to Found
97909>>>>>>>        End
97909>>>>>>>>
97909>>>>>>>        // If open failed, the Err is set to true,
97909>>>>>>>        // but we don't want that because it could end our loop.
97909>>>>>>>        Move False to Err
97910>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
97913>>>>>>>
97913>>>>>>>        Function_Return bOpen
97914>>>>>>>    End_Function
97915>>>>>>>
97915>>>>>>>    // Checks that the passed hTable number both exists in Filelist.cfg and
97915>>>>>>>    // that the embedded .dat file exists on disk _or_ that the SQL table exists
97915>>>>>>>    // if it is an SQL table
97915>>>>>>>    Function UtilTableExists Handle hTable Returns Boolean
97917>>>>>>>        Boolean bExists bIsSQLTable
97917>>>>>>>        String sDataPath sRootName
97917>>>>>>>
97917>>>>>>>        Get UtilTableNumberIsInUse hTable to bExists
97918>>>>>>>        If (bExists = False) Begin
97920>>>>>>>            Function_Return False
97921>>>>>>>        End
97921>>>>>>>>
97921>>>>>>>
97921>>>>>>>        Move False to bIsSQLTable
97922>>>>>>>        If (hTable > 0) Begin
97924>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
97927>>>>>>>            Move (sRootName contains ":") to bIsSQLTable
97928>>>>>>>        End
97928>>>>>>>>
97928>>>>>>>        If (bIsSQLTable = True) Begin
97930>>>>>>>            Get UtilTableIsSQL hTable to bExists
97931>>>>>>>            Function_Return bExists
97932>>>>>>>        End
97932>>>>>>>>
97932>>>>>>>        Else Begin
97933>>>>>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
97934>>>>>>>            Get vFolderFormat sDataPath to sDataPath
97935>>>>>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bExists
97936>>>>>>>        End
97936>>>>>>>>
97936>>>>>>>
97936>>>>>>>        Function_Return bExists
97937>>>>>>>    End_Function
97938>>>>>>>
97938>>>>>>>    // Pass a table handle
97938>>>>>>>    // Returns True if the table exists in filelist.cfg.
97938>>>>>>>    Function UtilTableNumberIsInUse Handle hCheckTable Returns Boolean
97940>>>>>>>        Handle hTable
97940>>>>>>>        Boolean bFound
97940>>>>>>>
97940>>>>>>>        Move False to bFound
97941>>>>>>>        Move 0 to hTable
97942>>>>>>>        Repeat
97942>>>>>>>>
97942>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
97945>>>>>>>            If (hTable > 0) Begin
97947>>>>>>>                If (hTable = hCheckTable) Begin
97949>>>>>>>                    Move True to bFound
97950>>>>>>>                End
97950>>>>>>>>
97950>>>>>>>            End
97950>>>>>>>>
97950>>>>>>>            If (bFound = True) ;                Break
97953>>>>>>>        Until (hTable = 0)
97955>>>>>>>
97955>>>>>>>        Function_Return (bFound = True)
97956>>>>>>>    End_Function
97957>>>>>>>
97957>>>>>>>    // Pass a table's logical name
97957>>>>>>>    // Returns True if the table exists in filelist.cfg.
97957>>>>>>>    Function UtilTableLogicalNameIsInUse String sCheckTable Returns Boolean
97959>>>>>>>        Handle hTable
97959>>>>>>>        Boolean bFound
97959>>>>>>>        String sCompareTable
97959>>>>>>>
97959>>>>>>>        Move False to bFound
97960>>>>>>>        Move 0 to hTable
97961>>>>>>>        Repeat
97961>>>>>>>>
97961>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
97964>>>>>>>            If (hTable > 0) Begin
97966>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sCompareTable
97969>>>>>>>                If (Uppercase(sCompareTable) = Uppercase(sCheckTable)) Begin
97971>>>>>>>                    Move True to bFound
97972>>>>>>>                End
97972>>>>>>>>
97972>>>>>>>            End
97972>>>>>>>>
97972>>>>>>>            If (bFound = True) ;                Break
97975>>>>>>>        Until (hTable = 0)
97977>>>>>>>
97977>>>>>>>        Function_Return (bFound = True)
97978>>>>>>>    End_Function
97979>>>>>>>
97979>>>>>>>    // Function will report the default driver "DATAFLEX" if table can't be opened
97979>>>>>>>    Function UtilDriverFromTableNumber Handle hTable Returns String
97981>>>>>>>        Boolean bOK bExists
97981>>>>>>>        String sDriverID
97981>>>>>>>
97981>>>>>>>        Get UtilTableExists hTable to bExists
97982>>>>>>>        If (bExists = False) Begin
97984>>>>>>>            Function_Return DATAFLEX_ID
97985>>>>>>>        End
97985>>>>>>>>
97985>>>>>>>        Get OpenTableExclusive hTable to bOK
97986>>>>>>>        If (bOK = False) Begin
97988>>>>>>>            Function_Return DATAFLEX_ID
97989>>>>>>>        End
97989>>>>>>>>
97989>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
97992>>>>>>>        Function_Return sDriverID
97993>>>>>>>    End_Function
97994>>>>>>>
97994>>>>>>>    // Number of tables in Filelist.cfg. Returns integger
97994>>>>>>>    Function UtilFilelistNoOfTables Returns Integer
97996>>>>>>>        Handle hTable
97996>>>>>>>        Integer iRetval
97996>>>>>>>
97996>>>>>>>        Move 0 to hTable
97997>>>>>>>        Move 0 to iRetval
97998>>>>>>>
97998>>>>>>>        Repeat
97998>>>>>>>>
97998>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
98001>>>>>>>            If (hTable > 0) Begin
98003>>>>>>>                Increment iRetval
98004>>>>>>>            End
98004>>>>>>>>
98004>>>>>>>        Until (hTable = 0)
98006>>>>>>>
98006>>>>>>>        Function_Return iRetval
98007>>>>>>>    End_Function
98008>>>>>>>
98008>>>>>>>    // Checks if any of the tables in Filelist.cfg is an SQL driver and returns the first Driver ID.
98008>>>>>>>    Function UtilIsAnyFilelistEntrySQLtable Returns String
98010>>>>>>>        Handle hTable
98010>>>>>>>        String sRoot sDriverID
98010>>>>>>>        Boolean bIsSQLTable
98010>>>>>>>        Integer iPos
98010>>>>>>>
98010>>>>>>>        Move 0 to hTable
98011>>>>>>>        Move "" to sDriverID
98012>>>>>>>        Move False to bIsSQLTable
98013>>>>>>>
98013>>>>>>>        Repeat
98013>>>>>>>>
98013>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
98016>>>>>>>            If (hTable > 0) Begin
98018>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRoot
98021>>>>>>>                If (sRoot contains ":") Begin
98023>>>>>>>                    Move (Pos(":", sRoot)) to iPos
98024>>>>>>>                    Move (Left(sRoot, (iPos -1))) to sDriverID
98025>>>>>>>                End
98025>>>>>>>>
98025>>>>>>>                Get IsSQLDriver sDriverID to bIsSQLTable
98026>>>>>>>            End
98026>>>>>>>>
98026>>>>>>>
98026>>>>>>>        Until (hTable = 0 or bIsSQLTable = True)
98028>>>>>>>
98028>>>>>>>        Function_Return sDriverID
98029>>>>>>>    End_Function
98030>>>>>>>
98030>>>>>>>    Function UtilIsAllFilelistEntriesDataFlexTables Returns Boolean
98032>>>>>>>        String sRootName
98032>>>>>>>        Boolean bIsSQL
98032>>>>>>>        Handle hTable
98032>>>>>>>
98032>>>>>>>        Move False to bIsSQL
98033>>>>>>>        Move 0 to hTable
98034>>>>>>>        Repeat
98034>>>>>>>>
98034>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
98037>>>>>>>            If (hTable > 0) Begin
98039>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
98042>>>>>>>                Get UtilTableIsSqlByRootName sRootName to bIsSQL
98043>>>>>>>                If (bIsSQL = True) Begin
98045>>>>>>>                    Move 0 to hTable
98046>>>>>>>                End
98046>>>>>>>>
98046>>>>>>>            End
98046>>>>>>>>
98046>>>>>>>        Until (hTable = 0)
98048>>>>>>>
98048>>>>>>>        Function_Return (bIsSQL = False)
98049>>>>>>>    End_Function
98050>>>>>>>
98050>>>>>>>    // * Dummy function for the Studio's Code Explorer *
98050>>>>>>>    Function UTIL_ENUMERATION_FUNCTIONS Returns Boolean
98052>>>>>>>        Function_Return False
98053>>>>>>>    End_Function
98054>>>>>>>
98054>>>>>>>    Function UtilEnumerateOverlapFields Integer hTable Integer iField Returns String[]
98056>>>>>>>        String  sRetval
98056>>>>>>>        String[] sOverlapFieldsArray
98057>>>>>>>        Integer iType iColumn iColumns
98057>>>>>>>        Boolean bOpen bOverlap
98057>>>>>>>
98057>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
98060>>>>>>>        If (bOpen = False) Begin
98062>>>>>>>            Open hTable
98064>>>>>>>        End
98064>>>>>>>>
98064>>>>>>>
98064>>>>>>>        Move "" to sRetval
98065>>>>>>>
98065>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iColumns
98068>>>>>>>
98068>>>>>>>        for iColumn from 0 to iColumns
98074>>>>>>>>
98074>>>>>>>            Get_Attribute DF_FIELD_TYPE of hTable iColumn to iType
98077>>>>>>>            If (iField <> iColumn and iType <> DF_OVERLAP) Begin
98079>>>>>>>                Get_Attribute DF_FIELD_OVERLAP of hTable iField iColumn to bOverlap
98082>>>>>>>                If (bOverlap) Begin
98084>>>>>>>                    If (sRetval <> "") Begin
98086>>>>>>>                        Append sRetval ","
98087>>>>>>>                    End
98087>>>>>>>>
98087>>>>>>>                    Append sRetval iColumn
98088>>>>>>>                End
98088>>>>>>>>
98088>>>>>>>            End
98088>>>>>>>>
98088>>>>>>>        Loop
98089>>>>>>>>
98089>>>>>>>
98089>>>>>>>        If (bOpen = False) Begin
98091>>>>>>>            Close hTable
98092>>>>>>>        End
98092>>>>>>>>
98092>>>>>>>
98092>>>>>>>        Get StrSplitToArray sRetval "," to sOverlapFieldsArray
98093>>>>>>>
98093>>>>>>>        Function_Return sOverlapFieldsArray
98094>>>>>>>    End_Function
98095>>>>>>>
98095>>>>>>>    // Returns a struct array with all data types for the passed driver & dbtype.
98095>>>>>>>    Function UtilEnumerateColumnTypes String sDriverID Integer iDbType Returns tColumnType[]
98097>>>>>>>        tColumnType[] ColumnType
98097>>>>>>>        tColumnType[] ColumnType
98098>>>>>>>
98098>>>>>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
98098>>>>>>>        // the dbType.
98098>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
98100>>>>>>>            If (iDbType = EN_DbTypeMySQL) Begin
98102>>>>>>>                Move MDSMySQL to sDriverID
98103>>>>>>>            End
98103>>>>>>>>
98103>>>>>>>            If (iDbType = EN_DbTypeMSSQL) Begin
98105>>>>>>>                Move MSSQLDRV_ID to sDriverID
98106>>>>>>>            End
98106>>>>>>>>
98106>>>>>>>            If (iDbType = EN_DbTypeDB2) Begin
98108>>>>>>>                Move DB2_DRV_ID to sDriverID
98109>>>>>>>            End
98109>>>>>>>>
98109>>>>>>>            If (iDbType = EN_DbTypePostgre) Begin
98111>>>>>>>                Move MDSPgSQL to sDriverID
98112>>>>>>>            End
98112>>>>>>>>
98112>>>>>>>        End
98112>>>>>>>>
98112>>>>>>>
98112>>>>>>>        Case Begin
98112>>>>>>>            Case (iDbType = EN_dbTypeDataFlex)
98114>>>>>>>                Get _UtilEnumerateDataFlexTypes to ColumnType
98115>>>>>>>                Case Break
98116>>>>>>>
98116>>>>>>>            Case (iDbType = EN_DbTypeDB2)
98119>>>>>>>                Get _UtilEnumerateDB2Types to ColumnType
98120>>>>>>>                Case Break
98121>>>>>>>
98121>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
98124>>>>>>>                Get _UtilEnumerateMSSQLTypes sDriverID to ColumnType
98125>>>>>>>                Case Break
98126>>>>>>>
98126>>>>>>>            Case (sDriverID = MDSMySQL)
98129>>>>>>>                Get _UtilEnumerateMySQLTypes to ColumnType
98130>>>>>>>                Case Break
98131>>>>>>>
98131>>>>>>>            Case (sDriverID = ORAFLEX)
98134>>>>>>>                Get _UtilEnumerateOracleTypes to ColumnType
98135>>>>>>>                Case Break
98136>>>>>>>
98136>>>>>>>            Case (sDriverID = MDSPgSQL)
98139>>>>>>>                Get _UtilEnumeratePostgreSQLTypes to ColumnType
98140>>>>>>>                Case Break
98141>>>>>>>        Case End
98141>>>>>>>
98141>>>>>>>        Function_Return ColumnType
98142>>>>>>>    End_Function
98143>>>>>>>
98143>>>>>>>    Function UtilEnumerateODBCDrivers Returns String
98145>>>>>>>        Handle hoRegistry hoODBCDriverNames
98145>>>>>>>        Boolean bExists bKeyOpened
98145>>>>>>>        String sKey
98145>>>>>>>        String[] sDrivers
98146>>>>>>>        Integer iDriverNames iDriverName
98146>>>>>>>
98146>>>>>>>        Get Create (RefClass (cRegistry)) to hoRegistry
98147>>>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
98148>>>>>>>        Set pfAccessRights of hoRegistry to Key_Read
98149>>>>>>>        Move "SOFTWARE\ODBC\ODBCINST.INI\ODBC Drivers" to sKey
98150>>>>>>>        Get KeyExists of hoRegistry sKey to bExists
98151>>>>>>>        If (bExists) Begin
98153>>>>>>>            Get OpenKey of hoRegistry sKey to bKeyOpened
98154>>>>>>>            If (bKeyOpened) Begin
98156>>>>>>>                Get Create (RefClass (Array)) to hoODBCDriverNames
98157>>>>>>>                Get GetValues of hoRegistry hoODBCDriverNames to iDriverNames
98158>>>>>>>                If (iDriverNames > 0) Begin
98160>>>>>>>                    Move (ResizeArray (sDrivers, iDriverNames)) to sDrivers
98161>>>>>>>                    Decrement iDriverNames
98162>>>>>>>                    for iDriverName from 0 to iDriverNames
98168>>>>>>>>
98168>>>>>>>                        Get Value of hoODBCDriverNames iDriverName to sDrivers[iDriverName]
98169>>>>>>>                    Loop
98170>>>>>>>>
98170>>>>>>>                End
98170>>>>>>>>
98170>>>>>>>                Send CloseKey of hoRegistry
98171>>>>>>>            End
98171>>>>>>>>
98171>>>>>>>        End
98171>>>>>>>>
98171>>>>>>>        Send Destroy of hoRegistry
98172>>>>>>>
98172>>>>>>>        Function_Return sDrivers
98173>>>>>>>    End_Function
98174>>>>>>>
98174>>>>>>>    // DataFlex Embedded Database Data Types:
98174>>>>>>>    // Helper function for UtilEnumerateColumnTypes
98174>>>>>>>    Function _UtilEnumerateDataFlexTypes Returns tColumnType[]
98176>>>>>>>        tColumnType[] ColumnType
98176>>>>>>>        tColumnType[] ColumnType
98177>>>>>>>        Integer i
98177>>>>>>>
98177>>>>>>>        Move DF_ASCII           to ColumnType[i].iSQLType
98178>>>>>>>        Move "ASCII"            to ColumnType[i].sSQLType
98179>>>>>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
98180>>>>>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
98181>>>>>>>        Move "254"              to ColumnType[i].sPrecision
98182>>>>>>>        Increment i
98183>>>>>>>
98183>>>>>>>        Move DF_BCD             to ColumnType[i].iSQLType
98184>>>>>>>        Move "Numeric"          to ColumnType[i].sSQLType
98185>>>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
98186>>>>>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
98187>>>>>>>        Move "14.8"             to ColumnType[i].sPrecision
98188>>>>>>>        Increment i
98189>>>>>>>
98189>>>>>>>        Move DF_DATE            to ColumnType[i].iSQLType
98190>>>>>>>        Move "Date"             to ColumnType[i].sSQLType
98191>>>>>>>        Move DF_DATE            to ColumnType[i].iDataFlexType
98192>>>>>>>        Move "Date"             to ColumnType[i].sDataFlexType
98193>>>>>>>        Move "6.0"              to ColumnType[i].sPrecision
98194>>>>>>>        Move True               to ColumnType[i].bCanEditSize
98195>>>>>>>        Increment i
98196>>>>>>>
98196>>>>>>>        Move DF_TEXT            to ColumnType[i].iSQLType
98197>>>>>>>        Move "Text"             to ColumnType[i].sSQLType
98198>>>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
98199>>>>>>>        Move "Text"             to ColumnType[i].sDataFlexType
98200>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
98201>>>>>>>        Increment i
98202>>>>>>>
98202>>>>>>>        Move DF_BINARY          to ColumnType[i].iSQLType
98203>>>>>>>        Move "Binary"           to ColumnType[i].sSQLType
98204>>>>>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
98205>>>>>>>        Move "Binary"           to ColumnType[i].sDataFlexType
98206>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
98207>>>>>>>        Increment i
98208>>>>>>>
98208>>>>>>>        Move DF_DATETIME        to ColumnType[i].iSQLType
98209>>>>>>>        Move "DateTime"         to ColumnType[i].sSQLType
98210>>>>>>>        Move DF_DATETIME        to ColumnType[i].iDataFlexType
98211>>>>>>>        Move "DateTime"         to ColumnType[i].sDataFlexType
98212>>>>>>>        Move "23"               to ColumnType[i].sPrecision
98213>>>>>>>        Move True               to ColumnType[i].bCanEditSize
98214>>>>>>>        Increment i
98215>>>>>>>
98215>>>>>>>        Move DF_OVERLAP         to ColumnType[i].iSQLType
98216>>>>>>>        Move "Overlap"          to ColumnType[i].sSQLType
98217>>>>>>>        Move DF_OVERLAP         to ColumnType[i].iDataFlexType
98218>>>>>>>        Move "Overlap"          to ColumnType[i].sDataFlexType
98219>>>>>>>        Move "0.0"              to ColumnType[i].sPrecision
98220>>>>>>>
98220>>>>>>>        Function_Return ColumnType
98221>>>>>>>    End_Function
98222>>>>>>>
98222>>>>>>>    Function _UtilEnumerateDB2Types Returns tColumnType[]
98224>>>>>>>        tColumnType[] aColumnType
98224>>>>>>>        tColumnType[] aColumnType
98225>>>>>>>        Integer i
98225>>>>>>>
Including file: DB2_DRV_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DB2_DRV_DriverDef.inc)
98225>>>>>>>>// Generated By The Database Update Framework
98225>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.1\bin\MSSQLDRV_DriverDef.xml
98225>>>>>>>>// Driver COLUMN DATA TYPES
98225>>>>>>>>//
98225>>>>>>>>// Created: 2019-07-18 18:57:13.935
98225>>>>>>>>
98225>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
98226>>>>>>>>            Move -5                                      to aColumnType[i].iSQLType
98227>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
98228>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98229>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
98230>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
98231>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
98232>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
98233>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
98234>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
98235>>>>>>>>            Increment i
98236>>>>>>>>
98236>>>>>>>>            Move "binary"                                to aColumnType[i].sSQLType
98237>>>>>>>>            Move -2                                      to aColumnType[i].iSQLType
98238>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
98239>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98240>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
98241>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
98242>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
98243>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98244>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98245>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
98246>>>>>>>>            Increment i
98247>>>>>>>>
98247>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
98248>>>>>>>>            Move -7                                      to aColumnType[i].iSQLType
98249>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
98250>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98251>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
98252>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
98253>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
98254>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98255>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98256>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
98257>>>>>>>>            Increment i
98258>>>>>>>>
98258>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
98259>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
98260>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
98261>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98262>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
98263>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
98264>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
98265>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98266>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98267>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
98268>>>>>>>>            Increment i
98269>>>>>>>>
98269>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
98270>>>>>>>>            Move 91                                      to aColumnType[i].iSQLType
98271>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
98272>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98273>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
98274>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
98275>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
98276>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98277>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98278>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
98279>>>>>>>>            Increment i
98280>>>>>>>>
98280>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
98281>>>>>>>>            Move 93                                      to aColumnType[i].iSQLType
98282>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
98283>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98284>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
98285>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
98286>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
98287>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98288>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98289>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
98290>>>>>>>>            Increment i
98291>>>>>>>>
98291>>>>>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
98292>>>>>>>>            Move -200                                    to aColumnType[i].iSQLType
98293>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
98294>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98295>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
98296>>>>>>>>            Move 23                                      to aColumnType[i].iMinSize
98297>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
98298>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98299>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98300>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
98301>>>>>>>>            Increment i
98302>>>>>>>>
98302>>>>>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
98303>>>>>>>>            Move -155                                    to aColumnType[i].iSQLType
98304>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
98305>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98306>>>>>>>>            Move 34                                      to aColumnType[i].iDefaultSize
98307>>>>>>>>            Move 34                                      to aColumnType[i].iMinSize
98308>>>>>>>>            Move 34                                      to aColumnType[i].nMaxSize
98309>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98310>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98311>>>>>>>>            Move 34                                      to aColumnType[i].sPrecision
98312>>>>>>>>            Increment i
98313>>>>>>>>
98313>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
98314>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
98315>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
98316>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98317>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
98318>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
98319>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
98320>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
98321>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
98322>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
98323>>>>>>>>            Increment i
98324>>>>>>>>
98324>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
98325>>>>>>>>            Move 6                                       to aColumnType[i].iSQLType
98326>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
98327>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98328>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
98329>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
98330>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
98331>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
98332>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
98333>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
98334>>>>>>>>            Increment i
98335>>>>>>>>
98335>>>>>>>>            Move "image"                                 to aColumnType[i].sSQLType
98336>>>>>>>>            Move -4                                      to aColumnType[i].iSQLType
98337>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
98338>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98339>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
98340>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
98341>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
98342>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98343>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98344>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
98345>>>>>>>>            Increment i
98346>>>>>>>>
98346>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
98347>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
98348>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
98349>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98350>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
98351>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
98352>>>>>>>>            Move 10                                      to aColumnType[i].nMaxSize
98353>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
98354>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
98355>>>>>>>>            Move 10                                      to aColumnType[i].sPrecision
98356>>>>>>>>            Increment i
98357>>>>>>>>
98357>>>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
98358>>>>>>>>            Move -204                                    to aColumnType[i].iSQLType
98359>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
98360>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98361>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
98362>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
98363>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
98364>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98365>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98366>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
98367>>>>>>>>            Increment i
98368>>>>>>>>
98368>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
98369>>>>>>>>            Move -8                                      to aColumnType[i].iSQLType
98370>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
98371>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98372>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
98373>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
98374>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
98375>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98376>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98377>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
98378>>>>>>>>            Increment i
98379>>>>>>>>
98379>>>>>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
98380>>>>>>>>            Move -10                                     to aColumnType[i].iSQLType
98381>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
98382>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98383>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
98384>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
98385>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
98386>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98387>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98388>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
98389>>>>>>>>            Increment i
98390>>>>>>>>
98390>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
98391>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
98392>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
98393>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98394>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
98395>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
98396>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
98397>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
98398>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
98399>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
98400>>>>>>>>            Increment i
98401>>>>>>>>
98401>>>>>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
98402>>>>>>>>            Move -9                                      to aColumnType[i].iSQLType
98403>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
98404>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98405>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
98406>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
98407>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
98408>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98409>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98410>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
98411>>>>>>>>            Increment i
98412>>>>>>>>
98412>>>>>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
98413>>>>>>>>            Move -202                                    to aColumnType[i].iSQLType
98414>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
98415>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98416>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
98417>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
98418>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
98419>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98420>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98421>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
98422>>>>>>>>            Increment i
98423>>>>>>>>
98423>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
98424>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
98425>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
98426>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98427>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
98428>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
98429>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
98430>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
98431>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
98432>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
98433>>>>>>>>            Increment i
98434>>>>>>>>
98434>>>>>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
98435>>>>>>>>            Move -206                                    to aColumnType[i].iSQLType
98436>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
98437>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98438>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
98439>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
98440>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
98441>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98442>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98443>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
98444>>>>>>>>            Increment i
98445>>>>>>>>
98445>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
98446>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
98447>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
98448>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98449>>>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
98450>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
98451>>>>>>>>            Move 5                                       to aColumnType[i].nMaxSize
98452>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
98453>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
98454>>>>>>>>            Move 5                                       to aColumnType[i].sPrecision
98455>>>>>>>>            Increment i
98456>>>>>>>>
98456>>>>>>>>            Move "smallmoney"                            to aColumnType[i].sSQLType
98457>>>>>>>>            Move -205                                    to aColumnType[i].iSQLType
98458>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
98459>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98460>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
98461>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
98462>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
98463>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98464>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98465>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
98466>>>>>>>>            Increment i
98467>>>>>>>>
98467>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
98468>>>>>>>>            Move -1                                      to aColumnType[i].iSQLType
98469>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
98470>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98471>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
98472>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
98473>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
98474>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98475>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98476>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
98477>>>>>>>>            Increment i
98478>>>>>>>>
98478>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
98479>>>>>>>>            Move -154                                    to aColumnType[i].iSQLType
98480>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
98481>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98482>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
98483>>>>>>>>            Move 10                                      to aColumnType[i].iMinSize
98484>>>>>>>>            Move 19                                      to aColumnType[i].nMaxSize
98485>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98486>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98487>>>>>>>>            Move 19                                      to aColumnType[i].sPrecision
98488>>>>>>>>            Increment i
98489>>>>>>>>
98489>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
98490>>>>>>>>            Move -6                                      to aColumnType[i].iSQLType
98491>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
98492>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98493>>>>>>>>            Move 3                                       to aColumnType[i].iDefaultSize
98494>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
98495>>>>>>>>            Move 3                                       to aColumnType[i].nMaxSize
98496>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98497>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98498>>>>>>>>            Move 3                                       to aColumnType[i].sPrecision
98499>>>>>>>>            Increment i
98500>>>>>>>>
98500>>>>>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
98501>>>>>>>>            Move -11                                     to aColumnType[i].iSQLType
98502>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
98503>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98504>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
98505>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
98506>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
98507>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98508>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98509>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
98510>>>>>>>>            Increment i
98511>>>>>>>>
98511>>>>>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
98512>>>>>>>>            Move -3                                      to aColumnType[i].iSQLType
98513>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
98514>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98515>>>>>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
98516>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
98517>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
98518>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98519>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98520>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
98521>>>>>>>>            Increment i
98522>>>>>>>>
98522>>>>>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
98523>>>>>>>>            Move -203                                    to aColumnType[i].iSQLType
98524>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
98525>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98526>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
98527>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
98528>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
98529>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98530>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98531>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
98532>>>>>>>>            Increment i
98533>>>>>>>>
98533>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
98534>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
98535>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
98536>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98537>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
98538>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
98539>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
98540>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98541>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98542>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
98543>>>>>>>>            Increment i
98544>>>>>>>>
98544>>>>>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
98545>>>>>>>>            Move -201                                    to aColumnType[i].iSQLType
98546>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
98547>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98548>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
98549>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
98550>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
98551>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98552>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98553>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
98554>>>>>>>>            Increment i
98555>>>>>>>>
98555>>>>>>>>            Move "xml"                                   to aColumnType[i].sSQLType
98556>>>>>>>>            Move -152                                    to aColumnType[i].iSQLType
98557>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
98558>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98559>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
98560>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
98561>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
98562>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98563>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98564>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
98565>>>>>>>>            Increment i
98566>>>>>>>>
98566>>>>>>>>
98566>>>>>>>//        Move SQL_DBCLOB         to ColumnType[i].iSQLType
98566>>>>>>>//        Move "DBCLOB"           to ColumnType[i].sSQLType
98566>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
98566>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
98566>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
98566>>>>>>>//        Increment i
98566>>>>>>>//
98566>>>>>>>//        Move SQL_BIGINT         to ColumnType[i].iSQLType
98566>>>>>>>//        Move "BIGINT"           to ColumnType[i].sSQLType
98566>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
98566>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
98566>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
98566>>>>>>>//        Increment i
98566>>>>>>>//
98566>>>>>>>//        Move SQL_BLOB           to ColumnType[i].iSQLType
98566>>>>>>>//        Move "BLOB"             to ColumnType[i].sSQLType
98566>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
98566>>>>>>>//        Move "BINARY"           to ColumnType[i].sDataFlexType
98566>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
98566>>>>>>>//        Increment i
98566>>>>>>>//
98566>>>>>>>//        Move SQL_CHAR           to ColumnType[i].iSQLType
98566>>>>>>>//        Move "CHAR"             to ColumnType[i].sSQLType
98566>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
98566>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
98566>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
98566>>>>>>>//        Increment i
98566>>>>>>>//
98566>>>>>>>//        // ToDo: We need to change the sType when using this!
98566>>>>>>>//        Move SQL_CHARBIT            to ColumnType[i].iSQLType
98566>>>>>>>//        Move "CHAR FOR BIT DATA"    to ColumnType[i].sSQLType
98566>>>>>>>//        Move DF_BINARY              to ColumnType[i].iDataFlexType
98566>>>>>>>//        Move "Binary"               to ColumnType[i].sDataFlexType
98566>>>>>>>//        Move "254"                  to ColumnType[i].sPrecision
98566>>>>>>>//        Increment i
98566>>>>>>>//
98566>>>>>>>//        Move SQL_DATE           to ColumnType[i].iSQLType
98566>>>>>>>//        Move "DATE"             to ColumnType[i].sSQLType
98566>>>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
98566>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
98566>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
98566>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
98566>>>>>>>//        Increment i
98566>>>>>>>//
98566>>>>>>>//        Move SQL_CLOB           to ColumnType[i].iSQLType
98566>>>>>>>//        Move "CLOB"             to ColumnType[i].sSQLType
98566>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
98566>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
98566>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
98566>>>>>>>//        Increment i
98566>>>>>>>//
98566>>>>>>>//        Move SQL_DECIMAL        to ColumnType[i].iSQLType
98566>>>>>>>//        Move "DECIMAL"          to ColumnType[i].sSQLType
98566>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
98566>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
98566>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
98566>>>>>>>//        Increment i
98566>>>>>>>//
98566>>>>>>>//        Move SQL_DOUBLE         to ColumnType[i].iSQLType
98566>>>>>>>//        Move "DOUBLE"           to ColumnType[i].sSQLType
98566>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
98566>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
98566>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
98566>>>>>>>//        Increment i
98566>>>>>>>//
98566>>>>>>>//        Move SQL_FLOAT          to ColumnType[i].iSQLType
98566>>>>>>>//        Move "FLOAT"            to ColumnType[i].sSQLType
98566>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
98566>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
98566>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
98566>>>>>>>//        Increment i
98566>>>>>>>//
98566>>>>>>>//        Move SQL_GRAPHIC        to ColumnType[i].iSQLType
98566>>>>>>>//        Move "GRAPHIC"          to ColumnType[i].sSQLType
98566>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
98566>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
98566>>>>>>>//        Move "255"              to ColumnType[i].sPrecision
98566>>>>>>>//        Increment i
98566>>>>>>>//
98566>>>>>>>//        Move SQL_INTEGER        to ColumnType[i].iSQLType
98566>>>>>>>//        Move "INTEGER"          to ColumnType[i].sSQLType
98566>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
98566>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
98566>>>>>>>//        Move "9.0"              to ColumnType[i].sPrecision
98566>>>>>>>//        Increment i
98566>>>>>>>//
98566>>>>>>>//        Move SQL_LONGVARCHAR    to ColumnType[i].iSQLType
98566>>>>>>>//        Move "LONG VARCHAR"     to ColumnType[i].sSQLType
98566>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
98566>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
98566>>>>>>>//        Move "32000"            to ColumnType[i].sPrecision
98566>>>>>>>//        Increment i
98566>>>>>>>//
98566>>>>>>>//        Move SQL_LONGVARCHARBIT to ColumnType[i].iSQLType
98566>>>>>>>//        Move "LONG VARCHAR BIT" to ColumnType[i].sSQLType
98566>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
98566>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
98566>>>>>>>//        Move "32000"            to ColumnType[i].sPrecision
98566>>>>>>>//        Increment i
98566>>>>>>>//
98566>>>>>>>//        Move SQL_LONGVARGRAPHIC to ColumnType[i].iSQLType
98566>>>>>>>//        Move "LONG VARGRAPHIC"  to ColumnType[i].sSQLType
98566>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
98566>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
98566>>>>>>>//        Move "32000"            to ColumnType[i].sPrecision
98566>>>>>>>//        Increment i
98566>>>>>>>//
98566>>>>>>>//        Move SQL_NUMERIC        to ColumnType[i].iSQLType
98566>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sSQLType
98566>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
98566>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
98566>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
98566>>>>>>>//        Increment i
98566>>>>>>>//
98566>>>>>>>//        Move SQL_REAL           to ColumnType[i].iSQLType
98566>>>>>>>//        Move "REAL"             to ColumnType[i].sSQLType
98566>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
98566>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
98566>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
98566>>>>>>>//        Increment i
98566>>>>>>>//
98566>>>>>>>//        Move SQL_SMALLINT       to ColumnType[i].iSQLType
98566>>>>>>>//        Move "SMALLINT"         to ColumnType[i].sSQLType
98566>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
98566>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
98566>>>>>>>//        Move "5.0"              to ColumnType[i].sPrecision
98566>>>>>>>//        Increment i
98566>>>>>>>//
98566>>>>>>>//        Move SQL_TIME           to ColumnType[i].iSQLType
98566>>>>>>>//        Move "TIME"             to ColumnType[i].sSQLType
98566>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
98566>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
98566>>>>>>>//        Move "19.0"             to ColumnType[i].sPrecision
98566>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
98566>>>>>>>//        Increment i
98566>>>>>>>//
98566>>>>>>>//        Move SQL_TIMESTAMP      to ColumnType[i].iSQLType
98566>>>>>>>//        Move "TIMESTAMP"        to ColumnType[i].sSQLType
98566>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
98566>>>>>>>//        Move "DATETIME"         to ColumnType[i].sDataFlexType
98566>>>>>>>//        Move "23.6"             to ColumnType[i].sPrecision
98566>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
98566>>>>>>>//        Increment i
98566>>>>>>>//
98566>>>>>>>//        Move SQL_VARCHAR        to ColumnType[i].iSQLType
98566>>>>>>>//        Move "VARCHAR"          to ColumnType[i].sSQLType
98566>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
98566>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
98566>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
98566>>>>>>>//        Increment i
98566>>>>>>>//
98566>>>>>>>//        // ToDo: We need to change the sType when using this!
98566>>>>>>>//        Move SQL_VARCHARBIT         to ColumnType[i].iSQLType
98566>>>>>>>//        Move "VARCHAR FOR BIT DATA" to ColumnType[i].sSQLType
98566>>>>>>>//        Move DF_TEXT                to ColumnType[i].iDataFlexType
98566>>>>>>>//        Move "TEXT"                 to ColumnType[i].sDataFlexType
98566>>>>>>>//        Move "16384"                to ColumnType[i].sPrecision
98566>>>>>>>//        Increment i
98566>>>>>>>//
98566>>>>>>>//        Move SQL_VARGRAPHIC     to ColumnType[i].iSQLType
98566>>>>>>>//        Move "VARGRAPHIC"       to ColumnType[i].sSQLType
98566>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
98566>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
98566>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
98566>>>>>>>//
98566>>>>>>>//        Move SQL_XML            to ColumnType[i].iSQLType
98566>>>>>>>//        Move "XML"              to ColumnType[i].sSQLType
98566>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
98566>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
98566>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
98566>>>>>>>
98566>>>>>>>        Function_Return aColumnType
98567>>>>>>>    End_Function
98568>>>>>>>
98568>>>>>>>    // Microsoft SQL Server Database Data Types:
98568>>>>>>>    // Helper function for UtilEnumerateColumnTypes
98568>>>>>>>    Function _UtilEnumerateMSSQLTypes String sDriverID Returns tColumnType[]
98570>>>>>>>        tColumnType[] aColumnType
98570>>>>>>>        tColumnType[] aColumnType
98571>>>>>>>        Integer i
98571>>>>>>>
98571>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
Including file: MSSQLDRV_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\MSSQLDRV_DriverDef.inc)
98573>>>>>>>>// Generated By The Database Update Framework
98573>>>>>>>>// Driver XML File: C:\Program Files\DataFlex 20.0\Lib\MSSQLDRV_DriverDef.xml
98573>>>>>>>>// Driver COLUMN DATA TYPES
98573>>>>>>>>//
98573>>>>>>>>// Created: 2019-11-15 21:57:51.001
98573>>>>>>>>
98573>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
98574>>>>>>>>            Move -5                                      to aColumnType[i].iSQLType
98575>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
98576>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98577>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
98578>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
98579>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
98580>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
98581>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
98582>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
98583>>>>>>>>            Increment i
98584>>>>>>>>
98584>>>>>>>>            Move "binary"                                to aColumnType[i].sSQLType
98585>>>>>>>>            Move -2                                      to aColumnType[i].iSQLType
98586>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
98587>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98588>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
98589>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
98590>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
98591>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
98592>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
98593>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
98594>>>>>>>>            Increment i
98595>>>>>>>>
98595>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
98596>>>>>>>>            Move -7                                      to aColumnType[i].iSQLType
98597>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
98598>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98599>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
98600>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
98601>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
98602>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98603>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98604>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
98605>>>>>>>>            Increment i
98606>>>>>>>>
98606>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
98607>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
98608>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
98609>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98610>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
98611>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
98612>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
98613>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98614>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98615>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
98616>>>>>>>>            Increment i
98617>>>>>>>>
98617>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
98618>>>>>>>>            Move 91                                      to aColumnType[i].iSQLType
98619>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
98620>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98621>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
98622>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
98623>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
98624>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
98625>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
98626>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
98627>>>>>>>>            Increment i
98628>>>>>>>>
98628>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
98629>>>>>>>>            Move 93                                      to aColumnType[i].iSQLType
98630>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
98631>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98632>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
98633>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
98634>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
98635>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
98636>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
98637>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
98638>>>>>>>>            Increment i
98639>>>>>>>>
98639>>>>>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
98640>>>>>>>>            Move -200                                    to aColumnType[i].iSQLType
98641>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
98642>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98643>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
98644>>>>>>>>            Move 23                                      to aColumnType[i].iMinSize
98645>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
98646>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
98647>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
98648>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
98649>>>>>>>>            Increment i
98650>>>>>>>>
98650>>>>>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
98651>>>>>>>>            Move -155                                    to aColumnType[i].iSQLType
98652>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
98653>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98654>>>>>>>>            Move 34                                      to aColumnType[i].iDefaultSize
98655>>>>>>>>            Move 34                                      to aColumnType[i].iMinSize
98656>>>>>>>>            Move 34                                      to aColumnType[i].nMaxSize
98657>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
98658>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
98659>>>>>>>>            Move 34                                      to aColumnType[i].sPrecision
98660>>>>>>>>            Increment i
98661>>>>>>>>
98661>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
98662>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
98663>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
98664>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98665>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
98666>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
98667>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
98668>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
98669>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
98670>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
98671>>>>>>>>            Increment i
98672>>>>>>>>
98672>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
98673>>>>>>>>            Move 6                                       to aColumnType[i].iSQLType
98674>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
98675>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98676>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
98677>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
98678>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
98679>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
98680>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
98681>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
98682>>>>>>>>            Increment i
98683>>>>>>>>
98683>>>>>>>>            Move "image"                                 to aColumnType[i].sSQLType
98684>>>>>>>>            Move -4                                      to aColumnType[i].iSQLType
98685>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
98686>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98687>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
98688>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
98689>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
98690>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
98691>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
98692>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
98693>>>>>>>>            Increment i
98694>>>>>>>>
98694>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
98695>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
98696>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
98697>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98698>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
98699>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
98700>>>>>>>>            Move 10                                      to aColumnType[i].nMaxSize
98701>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
98702>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
98703>>>>>>>>            Move 10                                      to aColumnType[i].sPrecision
98704>>>>>>>>            Increment i
98705>>>>>>>>
98705>>>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
98706>>>>>>>>            Move -204                                    to aColumnType[i].iSQLType
98707>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
98708>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98709>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
98710>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
98711>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
98712>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
98713>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
98714>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
98715>>>>>>>>            Increment i
98716>>>>>>>>
98716>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
98717>>>>>>>>            Move -8                                      to aColumnType[i].iSQLType
98718>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
98719>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98720>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
98721>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
98722>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
98723>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98724>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98725>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
98726>>>>>>>>            Increment i
98727>>>>>>>>
98727>>>>>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
98728>>>>>>>>            Move -10                                     to aColumnType[i].iSQLType
98729>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
98730>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98731>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
98732>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
98733>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
98734>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
98735>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
98736>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
98737>>>>>>>>            Increment i
98738>>>>>>>>
98738>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
98739>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
98740>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
98741>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98742>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
98743>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
98744>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
98745>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
98746>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
98747>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
98748>>>>>>>>            Increment i
98749>>>>>>>>
98749>>>>>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
98750>>>>>>>>            Move -9                                      to aColumnType[i].iSQLType
98751>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
98752>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98753>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
98754>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
98755>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
98756>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98757>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98758>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
98759>>>>>>>>            Increment i
98760>>>>>>>>
98760>>>>>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
98761>>>>>>>>            Move -202                                    to aColumnType[i].iSQLType
98762>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
98763>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98764>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
98765>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
98766>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
98767>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98768>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98769>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
98770>>>>>>>>            Increment i
98771>>>>>>>>
98771>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
98772>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
98773>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
98774>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98775>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
98776>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
98777>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
98778>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
98779>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
98780>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
98781>>>>>>>>            Increment i
98782>>>>>>>>
98782>>>>>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
98783>>>>>>>>            Move -206                                    to aColumnType[i].iSQLType
98784>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
98785>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98786>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
98787>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
98788>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
98789>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
98790>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
98791>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
98792>>>>>>>>            Increment i
98793>>>>>>>>
98793>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
98794>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
98795>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
98796>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98797>>>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
98798>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
98799>>>>>>>>            Move 5                                       to aColumnType[i].nMaxSize
98800>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
98801>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
98802>>>>>>>>            Move 5                                       to aColumnType[i].sPrecision
98803>>>>>>>>            Increment i
98804>>>>>>>>
98804>>>>>>>>            Move "smallmoney"                            to aColumnType[i].sSQLType
98805>>>>>>>>            Move -205                                    to aColumnType[i].iSQLType
98806>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
98807>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98808>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
98809>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
98810>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
98811>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
98812>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
98813>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
98814>>>>>>>>            Increment i
98815>>>>>>>>
98815>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
98816>>>>>>>>            Move -1                                      to aColumnType[i].iSQLType
98817>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
98818>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98819>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
98820>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
98821>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
98822>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
98823>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
98824>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
98825>>>>>>>>            Increment i
98826>>>>>>>>
98826>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
98827>>>>>>>>            Move -154                                    to aColumnType[i].iSQLType
98828>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
98829>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98830>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
98831>>>>>>>>            Move 10                                      to aColumnType[i].iMinSize
98832>>>>>>>>            Move 19                                      to aColumnType[i].nMaxSize
98833>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98834>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98835>>>>>>>>            Move 19                                      to aColumnType[i].sPrecision
98836>>>>>>>>            Increment i
98837>>>>>>>>
98837>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
98838>>>>>>>>            Move -6                                      to aColumnType[i].iSQLType
98839>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
98840>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98841>>>>>>>>            Move 3                                       to aColumnType[i].iDefaultSize
98842>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
98843>>>>>>>>            Move 3                                       to aColumnType[i].nMaxSize
98844>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
98845>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
98846>>>>>>>>            Move 3                                       to aColumnType[i].sPrecision
98847>>>>>>>>            Increment i
98848>>>>>>>>
98848>>>>>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
98849>>>>>>>>            Move -11                                     to aColumnType[i].iSQLType
98850>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
98851>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98852>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
98853>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
98854>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
98855>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98856>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98857>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
98858>>>>>>>>            Increment i
98859>>>>>>>>
98859>>>>>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
98860>>>>>>>>            Move -3                                      to aColumnType[i].iSQLType
98861>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
98862>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98863>>>>>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
98864>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
98865>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
98866>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
98867>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
98868>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
98869>>>>>>>>            Increment i
98870>>>>>>>>
98870>>>>>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
98871>>>>>>>>            Move -203                                    to aColumnType[i].iSQLType
98872>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
98873>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98874>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
98875>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
98876>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
98877>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98878>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98879>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
98880>>>>>>>>            Increment i
98881>>>>>>>>
98881>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
98882>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
98883>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
98884>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98885>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
98886>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
98887>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
98888>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98889>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98890>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
98891>>>>>>>>            Increment i
98892>>>>>>>>
98892>>>>>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
98893>>>>>>>>            Move -201                                    to aColumnType[i].iSQLType
98894>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
98895>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98896>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
98897>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
98898>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
98899>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
98900>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
98901>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
98902>>>>>>>>            Increment i
98903>>>>>>>>
98903>>>>>>>>            Move "xml"                                   to aColumnType[i].sSQLType
98904>>>>>>>>            Move -152                                    to aColumnType[i].iSQLType
98905>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
98906>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98907>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
98908>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
98909>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
98910>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
98911>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
98912>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
98913>>>>>>>>            Increment i
98914>>>>>>>>
98914>>>>>>>>
98914>>>>>>>
98914>>>>>>>//            Move SQL_BIGINT         to ColumnType[i].iSQLType
98914>>>>>>>//            Move "bigint"           to ColumnType[i].sSQLType
98914>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
98914>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
98914>>>>>>>//            Move "14.0"             to ColumnType[i].sPrecision
98914>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
98914>>>>>>>//            Increment i
98914>>>>>>>//
98914>>>>>>>//            Move SQL_BINARY         to ColumnType[i].iSQLType
98914>>>>>>>//            Move "binary"           to ColumnType[i].sSQLType
98914>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
98914>>>>>>>//            Move "Binary"           to ColumnType[i].sDataFlexType
98914>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
98914>>>>>>>//            Increment i
98914>>>>>>>//
98914>>>>>>>//            Move SQL_BIT            to ColumnType[i].iSQLType
98914>>>>>>>//            Move "bit"              to ColumnType[i].sSQLType
98914>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
98914>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
98914>>>>>>>//            Move "1.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
98914>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
98914>>>>>>>//            Increment i
98914>>>>>>>//
98914>>>>>>>//            Move SQL_CHAR           to ColumnType[i].iSQLType
98914>>>>>>>//            Move "char"             to ColumnType[i].sSQLType
98914>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
98914>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
98914>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
98914>>>>>>>//            Increment i
98914>>>>>>>//
98914>>>>>>>//            Move SQL_DATE           to ColumnType[i].iSQLType
98914>>>>>>>//            Move "date"             to ColumnType[i].sSQLType
98914>>>>>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
98914>>>>>>>//            Move "Date"             to ColumnType[i].sDataFlexType
98914>>>>>>>//            Move "6.0"              to ColumnType[i].sPrecision
98914>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
98914>>>>>>>//            Increment i
98914>>>>>>>//
98914>>>>>>>//            Move SQL_DATETIME       to ColumnType[i].iSQLType
98914>>>>>>>//            Move "datetime"         to ColumnType[i].sSQLType
98914>>>>>>>//            Move DF_DATETIME        to ColumnType[i].iDataFlexType
98914>>>>>>>//            Move "DateTime"         to ColumnType[i].sDataFlexType
98914>>>>>>>//            Move "23.3"             to ColumnType[i].sPrecision
98914>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
98914>>>>>>>//            Increment i
98914>>>>>>>//
98914>>>>>>>//            Move SQL_TYPE_TIMESTAMP2 to ColumnType[i].iSQLType
98914>>>>>>>//            Move "datetime2"         to ColumnType[i].sSQLType
98914>>>>>>>//            Move DF_DATETIME         to ColumnType[i].iDataFlexType
98914>>>>>>>//            Move "DateTime"          to ColumnType[i].sDataFlexType
98914>>>>>>>//            Move "23.6"              to ColumnType[i].sPrecision
98914>>>>>>>//            Move True                to ColumnType[i].bCanEditSize
98914>>>>>>>//            Increment i
98914>>>>>>>//
98914>>>>>>>//            Move SQL_SS_TIMESTAMPOFFSET to ColumnType[i].iSQLType
98914>>>>>>>//            Move "datetimeoffset"       to ColumnType[i].sSQLType
98914>>>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
98914>>>>>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
98914>>>>>>>//            Move "34.0"                 to ColumnType[i].sPrecision
98914>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
98914>>>>>>>//            Increment i
98914>>>>>>>//
98914>>>>>>>//            Move SQL_DECIMAL        to ColumnType[i].iSQLType
98914>>>>>>>//            Move "decimal"          to ColumnType[i].sSQLType
98914>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
98914>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
98914>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
98914>>>>>>>//            Increment i
98914>>>>>>>//
98914>>>>>>>//            Move SQL_FLOAT          to ColumnType[i].iSQLType
98914>>>>>>>//            Move "float"            to ColumnType[i].sSQLType
98914>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
98914>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
98914>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
98914>>>>>>>//            Increment i
98914>>>>>>>//
98914>>>>>>>//            Move SQL_INTEGER        to ColumnType[i].iSQLType
98914>>>>>>>//            Move "int"              to ColumnType[i].sSQLType
98914>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
98914>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
98914>>>>>>>//            Move "8.0"              to ColumnType[i].sPrecision
98914>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
98914>>>>>>>//            Increment i
98914>>>>>>>//
98914>>>>>>>//            Move SQL_TYPE_MONEY     to ColumnType[i].iSQLType
98914>>>>>>>//            Move "money"            to ColumnType[i].sSQLType
98914>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
98914>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
98914>>>>>>>//            Move "15.4"             to ColumnType[i].sPrecision // Studio 18.0 (!)
98914>>>>>>>//            Increment i
98914>>>>>>>//
98914>>>>>>>//            Move SQL_WCHAR          to ColumnType[i].iSQLType
98914>>>>>>>//            Move "nchar"            to ColumnType[i].sSQLType
98914>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
98914>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
98914>>>>>>>//            Move "4000"             to ColumnType[i].sPrecision
98914>>>>>>>//            Increment i
98914>>>>>>>//
98914>>>>>>>//            Move SQL_WLONGVARCHAR   to ColumnType[i].iSQLType
98914>>>>>>>//            Move "ntext"            to ColumnType[i].sSQLType
98914>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
98914>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
98914>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
98914>>>>>>>//            Increment i
98914>>>>>>>//
98914>>>>>>>//            Move SQL_NUMERIC        to ColumnType[i].iSQLType
98914>>>>>>>//            Move "numeric"          to ColumnType[i].sSQLType
98914>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
98914>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
98914>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
98914>>>>>>>//            Increment i
98914>>>>>>>//
98914>>>>>>>//            Move SQL_WVARCHAR       to ColumnType[i].iSQLType
98914>>>>>>>//            Move "nvarchar"         to ColumnType[i].sSQLType
98914>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
98914>>>>>>>//            Move "Text"             to ColumnType[i].sDataFlexType
98914>>>>>>>//            Move "4000"             to ColumnType[i].sPrecision
98914>>>>>>>//            Increment i
98914>>>>>>>//
98914>>>>>>>//            Move SQL_VARCHARMAX     to ColumnType[i].iSQLType
98914>>>>>>>//            Move "nvarchar(max)"    to ColumnType[i].sSQLType
98914>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
98914>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
98914>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
98914>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
98914>>>>>>>//            Increment i
98914>>>>>>>//
98914>>>>>>>//            Move SQL_REAL           to ColumnType[i].iSQLType
98914>>>>>>>//            Move "real"             to ColumnType[i].sSQLType
98914>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
98914>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
98914>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
98914>>>>>>>//            Increment i
98914>>>>>>>//
98914>>>>>>>//            Move SQL_TYPE_SMALLDATETIME to ColumnType[i].iSQLType
98914>>>>>>>//            Move "smalldatetime"        to ColumnType[i].sSQLType
98914>>>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
98914>>>>>>>//            Move "DATETIME"             to ColumnType[i].sDataFlexType
98914>>>>>>>//            Move "23.0"                 to ColumnType[i].sPrecision
98914>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
98914>>>>>>>//            Increment i
98914>>>>>>>//
98914>>>>>>>//            Move SQL_SMALLINT       to ColumnType[i].iSQLType
98914>>>>>>>//            Move "smallint"         to ColumnType[i].sSQLType
98914>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
98914>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
98914>>>>>>>//            Move "4.0"              to ColumnType[i].sPrecision
98914>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
98914>>>>>>>//            Increment i
98914>>>>>>>//
98914>>>>>>>//            Move SQL_TYPE_SMALLMONEY to ColumnType[i].iSQLType
98914>>>>>>>//            Move "smallmoney"        to ColumnType[i].sSQLType
98914>>>>>>>//            Move DF_BCD              to ColumnType[i].iDataFlexType
98914>>>>>>>//            Move "NUMERIC"           to ColumnType[i].sDataFlexType
98914>>>>>>>//            Move "10.0"              to ColumnType[i].sPrecision
98914>>>>>>>//            Increment i
98914>>>>>>>//
98914>>>>>>>//            Move SQL_TEXT           to ColumnType[i].iSQLType
98914>>>>>>>//            Move "text"             to ColumnType[i].sSQLType
98914>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
98914>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
98914>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
98914>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
98914>>>>>>>//            Increment i
98914>>>>>>>//
98914>>>>>>>//            Move SQL_TIME           to ColumnType[i].iSQLType
98914>>>>>>>//            Move "time"             to ColumnType[i].sSQLType
98914>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
98914>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
98914>>>>>>>//            Move "19.0"             to ColumnType[i].sPrecision
98914>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
98914>>>>>>>//            Increment i
98914>>>>>>>//
98914>>>>>>>//            Move SQL_TINYINT        to ColumnType[i].iSQLType
98914>>>>>>>//            Move "tinyint"          to ColumnType[i].sSQLType
98914>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
98914>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
98914>>>>>>>//            Move "2.0"              to ColumnType[i].sPrecision
98914>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
98914>>>>>>>//            Increment i
98914>>>>>>>//
98914>>>>>>>//            Move SQL_GUID           to ColumnType[i].iSQLType
98914>>>>>>>//            Move "uniqueidentifier" to ColumnType[i].sSQLType
98914>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
98914>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
98914>>>>>>>//            Move "36"               to ColumnType[i].sPrecision
98914>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
98914>>>>>>>//            Increment i
98914>>>>>>>//
98914>>>>>>>//            Move SQL_VARBINARY      to ColumnType[i].iSQLType
98914>>>>>>>//            Move "varbinary"        to ColumnType[i].sSQLType
98914>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
98914>>>>>>>//            Move "BINARY"           to ColumnType[i].sDataFlexType
98914>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
98914>>>>>>>//            Increment i
98914>>>>>>>//
98914>>>>>>>//            Move SQL_LONGVARBINARY  to ColumnType[i].iSQLType
98914>>>>>>>//            Move "varbinary(max)"   to ColumnType[i].sSQLType
98914>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
98914>>>>>>>//            Move "BINARY"           to ColumnType[i].sDataFlexType
98914>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
98914>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
98914>>>>>>>//            Increment i
98914>>>>>>>//
98914>>>>>>>//            Move SQL_VARCHAR        to ColumnType[i].iSQLType
98914>>>>>>>//            Move "varchar"          to ColumnType[i].sSQLType
98914>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType // ToDo: Under 255 = ASCII type! How to deal with this?
98914>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
98914>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
98914>>>>>>>//            Increment i
98914>>>>>>>//
98914>>>>>>>//            Move SQL_LONGVARCHAR    to ColumnType[i].iSQLType
98914>>>>>>>//            Move "varchar(max)"     to ColumnType[i].sSQLType
98914>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
98914>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
98914>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
98914>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
98914>>>>>>>//            Increment i
98914>>>>>>>//
98914>>>>>>>//            Move SQL_SS_XML         to ColumnType[i].iSQLType
98914>>>>>>>//            Move "xml"              to ColumnType[i].sSQLType
98914>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
98914>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
98914>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
98914>>>>>>>//            Increment i
98914>>>>>>>//
98914>>>>>>>//            Move SQL_TYPE_DATE      to ColumnType[i].iSQLType
98914>>>>>>>//            Move "DATE"             to ColumnType[i].sSQLType
98914>>>>>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
98914>>>>>>>//            Move "date"             to ColumnType[i].sDataFlexType
98914>>>>>>>//            Move "6.0"              to ColumnType[i].sPrecision
98914>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
98914>>>>>>>//            Increment i
98914>>>>>>>//
98914>>>>>>>//            Move SQL_TYPE_TIME      to ColumnType[i].iSQLType
98914>>>>>>>//            Move "time"             to ColumnType[i].sSQLType
98914>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
98914>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
98914>>>>>>>//            Move "8.7"              to ColumnType[i].sPrecision
98914>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
98914>>>>>>>//            Increment i
98914>>>>>>>//
98914>>>>>>>//            Move SQL_TYPE_TIMESTAMP to ColumnType[i].iSQLType
98914>>>>>>>//            Move "datetime"         to ColumnType[i].sSQLType
98914>>>>>>>//            Move DF_DATETIME        to ColumnType[i].iDataFlexType
98914>>>>>>>//            Move "DateTime"         to ColumnType[i].sDataFlexType
98914>>>>>>>//            Move "23.6"             to ColumnType[i].sPrecision
98914>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
98914>>>>>>>//            Increment i
98914>>>>>>>
98914>>>>>>>        End
98914>>>>>>>>
98914>>>>>>>
98914>>>>>>>        // Mertech SQLFlex driver
98914>>>>>>>        If (sDriverID = SQLFLEX) Begin
98916>>>>>>>
Including file: sql_drv_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\sql_drv_DriverDef.inc)
98916>>>>>>>>// Generated By The Database Update Framework
98916>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\sql_drv_DriverDef.xml
98916>>>>>>>>// Driver COLUMN DATA TYPES
98916>>>>>>>>//
98916>>>>>>>>// Created: 2018-03-14 23:47:46.885
98916>>>>>>>>
98916>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
98917>>>>>>>>            Move -5                                      to aColumnType[i].iSQLType
98918>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
98919>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98920>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
98921>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
98922>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
98923>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
98924>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
98925>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
98926>>>>>>>>            Increment i
98927>>>>>>>>
98927>>>>>>>>            Move "binary"                                to aColumnType[i].sSQLType
98928>>>>>>>>            Move -2                                      to aColumnType[i].iSQLType
98929>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
98930>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98931>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
98932>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
98933>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
98934>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
98935>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
98936>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
98937>>>>>>>>            Increment i
98938>>>>>>>>
98938>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
98939>>>>>>>>            Move -7                                      to aColumnType[i].iSQLType
98940>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
98941>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98942>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
98943>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
98944>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
98945>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98946>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98947>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
98948>>>>>>>>            Increment i
98949>>>>>>>>
98949>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
98950>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
98951>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
98952>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98953>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
98954>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
98955>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
98956>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98957>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98958>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
98959>>>>>>>>            Increment i
98960>>>>>>>>
98960>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
98961>>>>>>>>            Move 40                                      to aColumnType[i].iSQLType
98962>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
98963>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98964>>>>>>>>            Move 12                                      to aColumnType[i].iDefaultSize
98965>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
98966>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
98967>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98968>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98969>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
98970>>>>>>>>            Increment i
98971>>>>>>>>
98971>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
98972>>>>>>>>            Move 11                                      to aColumnType[i].iSQLType
98973>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
98974>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98975>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
98976>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
98977>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
98978>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98979>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98980>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
98981>>>>>>>>            Increment i
98982>>>>>>>>
98982>>>>>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
98983>>>>>>>>            Move 42                                      to aColumnType[i].iSQLType
98984>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
98985>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98986>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
98987>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
98988>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
98989>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
98990>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
98991>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
98992>>>>>>>>            Increment i
98993>>>>>>>>
98993>>>>>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
98994>>>>>>>>            Move 43                                      to aColumnType[i].iSQLType
98995>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
98996>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
98997>>>>>>>>            Move 12                                      to aColumnType[i].iDefaultSize
98998>>>>>>>>            Move 12                                      to aColumnType[i].iMinSize
98999>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
99000>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99001>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99002>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
99003>>>>>>>>            Increment i
99004>>>>>>>>
99004>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
99005>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
99006>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99007>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99008>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
99009>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99010>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
99011>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
99012>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
99013>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
99014>>>>>>>>            Increment i
99015>>>>>>>>
99015>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
99016>>>>>>>>            Move 6                                       to aColumnType[i].iSQLType
99017>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99018>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99019>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
99020>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99021>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
99022>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
99023>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
99024>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
99025>>>>>>>>            Increment i
99026>>>>>>>>
99026>>>>>>>>            Move "geography"                             to aColumnType[i].sSQLType
99027>>>>>>>>            Move 130                                     to aColumnType[i].iSQLType
99028>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
99029>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99030>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
99031>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
99032>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
99033>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99034>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99035>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
99036>>>>>>>>            Increment i
99037>>>>>>>>
99037>>>>>>>>            Move "geometry"                              to aColumnType[i].sSQLType
99038>>>>>>>>            Move 129                                     to aColumnType[i].iSQLType
99039>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
99040>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99041>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
99042>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
99043>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
99044>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99045>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99046>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
99047>>>>>>>>            Increment i
99048>>>>>>>>
99048>>>>>>>>            Move "hierarchyid"                           to aColumnType[i].sSQLType
99049>>>>>>>>            Move 128                                     to aColumnType[i].iSQLType
99050>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
99051>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99052>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
99053>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
99054>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
99055>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99056>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99057>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
99058>>>>>>>>            Increment i
99059>>>>>>>>
99059>>>>>>>>            Move "image"                                 to aColumnType[i].sSQLType
99060>>>>>>>>            Move -4                                      to aColumnType[i].iSQLType
99061>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99062>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99063>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
99064>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99065>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
99066>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
99067>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
99068>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
99069>>>>>>>>            Increment i
99070>>>>>>>>
99070>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
99071>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
99072>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99073>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99074>>>>>>>>            Move 11                                      to aColumnType[i].iDefaultSize
99075>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99076>>>>>>>>            Move 11                                      to aColumnType[i].nMaxSize
99077>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
99078>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
99079>>>>>>>>            Move 11                                      to aColumnType[i].sPrecision
99080>>>>>>>>            Increment i
99081>>>>>>>>
99081>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
99082>>>>>>>>            Move -8                                      to aColumnType[i].iSQLType
99083>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99084>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99085>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
99086>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99087>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
99088>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99089>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99090>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
99091>>>>>>>>            Increment i
99092>>>>>>>>
99092>>>>>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
99093>>>>>>>>            Move -10                                     to aColumnType[i].iSQLType
99094>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99095>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99096>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
99097>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99098>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
99099>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
99100>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
99101>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
99102>>>>>>>>            Increment i
99103>>>>>>>>
99103>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
99104>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
99105>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99106>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99107>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
99108>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99109>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
99110>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
99111>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
99112>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
99113>>>>>>>>            Increment i
99114>>>>>>>>
99114>>>>>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
99115>>>>>>>>            Move -9                                      to aColumnType[i].iSQLType
99116>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99117>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99118>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
99119>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99120>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
99121>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99122>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99123>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
99124>>>>>>>>            Increment i
99125>>>>>>>>
99125>>>>>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
99126>>>>>>>>            Move -100                                    to aColumnType[i].iSQLType
99127>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99128>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99129>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
99130>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99131>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
99132>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99133>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99134>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
99135>>>>>>>>            Increment i
99136>>>>>>>>
99136>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
99137>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
99138>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99139>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99140>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
99141>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99142>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
99143>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
99144>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
99145>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
99146>>>>>>>>            Increment i
99147>>>>>>>>
99147>>>>>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
99148>>>>>>>>            Move 58                                      to aColumnType[i].iSQLType
99149>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99150>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99151>>>>>>>>            Move 12                                      to aColumnType[i].iDefaultSize
99152>>>>>>>>            Move 12                                      to aColumnType[i].iMinSize
99153>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
99154>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99155>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99156>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
99157>>>>>>>>            Increment i
99158>>>>>>>>
99158>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
99159>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
99160>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99161>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99162>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
99163>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
99164>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
99165>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
99166>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
99167>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
99168>>>>>>>>            Increment i
99169>>>>>>>>
99169>>>>>>>>            Move "sql_variant"                           to aColumnType[i].sSQLType
99170>>>>>>>>            Move -150                                    to aColumnType[i].iSQLType
99171>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
99172>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99173>>>>>>>>            Move 8016                                    to aColumnType[i].iDefaultSize
99174>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
99175>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
99176>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99177>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99178>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
99179>>>>>>>>            Increment i
99180>>>>>>>>
99180>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
99181>>>>>>>>            Move -1                                      to aColumnType[i].iSQLType
99182>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99183>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99184>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
99185>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99186>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
99187>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
99188>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
99189>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
99190>>>>>>>>            Increment i
99191>>>>>>>>
99191>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
99192>>>>>>>>            Move 41                                      to aColumnType[i].iSQLType
99193>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99194>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99195>>>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
99196>>>>>>>>            Move 8                                       to aColumnType[i].iMinSize
99197>>>>>>>>            Move 16                                      to aColumnType[i].nMaxSize
99198>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99199>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99200>>>>>>>>            Move 16                                      to aColumnType[i].sPrecision
99201>>>>>>>>            Increment i
99202>>>>>>>>
99202>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
99203>>>>>>>>            Move 93                                      to aColumnType[i].iSQLType
99204>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
99205>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99206>>>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
99207>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
99208>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
99209>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
99210>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
99211>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
99212>>>>>>>>            Increment i
99213>>>>>>>>
99213>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
99214>>>>>>>>            Move -6                                      to aColumnType[i].iSQLType
99215>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99216>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99217>>>>>>>>            Move 3                                       to aColumnType[i].iDefaultSize
99218>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
99219>>>>>>>>            Move 3                                       to aColumnType[i].nMaxSize
99220>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
99221>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
99222>>>>>>>>            Move 3                                       to aColumnType[i].sPrecision
99223>>>>>>>>            Increment i
99224>>>>>>>>
99224>>>>>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
99225>>>>>>>>            Move -11                                     to aColumnType[i].iSQLType
99226>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
99227>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99228>>>>>>>>            Move 38                                      to aColumnType[i].iDefaultSize
99229>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
99230>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
99231>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99232>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99233>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
99234>>>>>>>>            Increment i
99235>>>>>>>>
99235>>>>>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
99236>>>>>>>>            Move -3                                      to aColumnType[i].iSQLType
99237>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99238>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99239>>>>>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
99240>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99241>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
99242>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
99243>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
99244>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
99245>>>>>>>>            Increment i
99246>>>>>>>>
99246>>>>>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
99247>>>>>>>>            Move -98                                     to aColumnType[i].iSQLType
99248>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99249>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99250>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
99251>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99252>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
99253>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99254>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99255>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
99256>>>>>>>>            Increment i
99257>>>>>>>>
99257>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
99258>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
99259>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99260>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99261>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
99262>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99263>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
99264>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99265>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99266>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
99267>>>>>>>>            Increment i
99268>>>>>>>>
99268>>>>>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
99269>>>>>>>>            Move -99                                     to aColumnType[i].iSQLType
99270>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99271>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99272>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
99273>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99274>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
99275>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99276>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99277>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
99278>>>>>>>>            Increment i
99279>>>>>>>>
99279>>>>>>>>            Move "xml"                                   to aColumnType[i].sSQLType
99280>>>>>>>>            Move -370                                    to aColumnType[i].iSQLType
99281>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99282>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99283>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
99284>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99285>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
99286>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99287>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99288>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
99289>>>>>>>>            Increment i
99290>>>>>>>>
99290>>>>>>>>
99290>>>>>>>
99290>>>>>>>//            Move eSQLServer_BIGINT  to ColumnType[i].iSQLType
99290>>>>>>>//            Move "BigInt"           to ColumnType[i].sSQLType
99290>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
99290>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
99290>>>>>>>//            Move "14.0"             to ColumnType[i].sPrecision
99290>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
99290>>>>>>>//            Increment i
99290>>>>>>>//
99290>>>>>>>//            Move eSQLServer_BINARY  to ColumnType[i].iSQLType
99290>>>>>>>//            Move "Binary"           to ColumnType[i].sSQLType
99290>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
99290>>>>>>>//            Move "Binary"           to ColumnType[i].sDataFlexType
99290>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
99290>>>>>>>//            Increment i
99290>>>>>>>//
99290>>>>>>>//            Move eSQLServer_BIT     to ColumnType[i].iSQLType
99290>>>>>>>//            Move "Bit"              to ColumnType[i].sSQLType
99290>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
99290>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
99290>>>>>>>//            Move "1.0"              to ColumnType[i].sPrecision
99290>>>>>>>//            Move True               to ColumnType[i].bCanEditSize // In SQL allows 1, 0, or "NULL"
99290>>>>>>>//            Increment i
99290>>>>>>>//
99290>>>>>>>//            Move eSQLServer_CHAR    to ColumnType[i].iSQLType
99290>>>>>>>//            Move "Char"             to ColumnType[i].sSQLType
99290>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
99290>>>>>>>//            Move "Text"             to ColumnType[i].sDataFlexType
99290>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
99290>>>>>>>//            Increment i
99290>>>>>>>//
99290>>>>>>>//            Move eSQLServer_DATE    to ColumnType[i].iSQLType
99290>>>>>>>//            Move "Date"             to ColumnType[i].sSQLType
99290>>>>>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
99290>>>>>>>//            Move "Date"             to ColumnType[i].sDataFlexType
99290>>>>>>>//            Move "6.0"              to ColumnType[i].sPrecision
99290>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
99290>>>>>>>//            Increment i
99290>>>>>>>//
99290>>>>>>>//            Move eSQLServer_DATETIME    to ColumnType[i].iSQLType
99290>>>>>>>//            Move "DateTime"             to ColumnType[i].sSQLType
99290>>>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
99290>>>>>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
99290>>>>>>>//            Move "23.3"                 to ColumnType[i].sPrecision
99290>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
99290>>>>>>>//            Increment i
99290>>>>>>>//
99290>>>>>>>//            Move eSQLServer_DATETIME2   to ColumnType[i].iSQLType
99290>>>>>>>//            Move "DateTime2"            to ColumnType[i].sSQLType
99290>>>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
99290>>>>>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
99290>>>>>>>//            Move "23.6"                 to ColumnType[i].sPrecision
99290>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
99290>>>>>>>//            Increment i
99290>>>>>>>//
99290>>>>>>>//            Move eSQLServer_DATETIMEOFFSET  to ColumnType[i].iSQLType
99290>>>>>>>//            Move "DateTimeOffest"           to ColumnType[i].sSQLType
99290>>>>>>>//            Move DF_DATETIME                to ColumnType[i].iDataFlexType
99290>>>>>>>//            Move "DateTime"                 to ColumnType[i].sDataFlexType
99290>>>>>>>//            Move "23.0"                     to ColumnType[i].sPrecision
99290>>>>>>>//            Move True                       to ColumnType[i].bCanEditSize
99290>>>>>>>//            Increment i
99290>>>>>>>//
99290>>>>>>>//            Move eSQLServer_DECIMAL to ColumnType[i].iSQLType
99290>>>>>>>//            Move "Decimal"          to ColumnType[i].sSQLType
99290>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
99290>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
99290>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
99290>>>>>>>//            Increment i
99290>>>>>>>//
99290>>>>>>>//            Move eSQLServer_DOUBLE  to ColumnType[i].iSQLType
99290>>>>>>>//            Move "Double"           to ColumnType[i].sSQLType
99290>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
99290>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
99290>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
99290>>>>>>>//            Increment i
99290>>>>>>>//
99290>>>>>>>//            Move eSQLServer_FLOAT   to ColumnType[i].iSQLType
99290>>>>>>>//            Move "Float"            to ColumnType[i].sSQLType
99290>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
99290>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
99290>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
99290>>>>>>>//            Increment i
99290>>>>>>>//
99290>>>>>>>//            Move eSQLServer_INT     to ColumnType[i].iSQLType
99290>>>>>>>//            Move "Int"              to ColumnType[i].sSQLType
99290>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
99290>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
99290>>>>>>>//            Move "11.0"             to ColumnType[i].sPrecision
99290>>>>>>>//            Increment i
99290>>>>>>>//
99290>>>>>>>//            Move eSQLServer_NCHAR   to ColumnType[i].iSQLType
99290>>>>>>>//            Move "Nchar"            to ColumnType[i].sSQLType
99290>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
99290>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
99290>>>>>>>//            Move "4000"             to ColumnType[i].sPrecision
99290>>>>>>>//            Increment i
99290>>>>>>>//
99290>>>>>>>//            Move eSQLServer_NTEXT   to ColumnType[i].iSQLType
99290>>>>>>>//            Move "Ntext"            to ColumnType[i].sSQLType
99290>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
99290>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
99290>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
99290>>>>>>>//            Increment i
99290>>>>>>>//
99290>>>>>>>//            Move eSQLServer_NUMERIC to ColumnType[i].iSQLType
99290>>>>>>>//            Move "Numeric"          to ColumnType[i].sSQLType
99290>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
99290>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
99290>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
99290>>>>>>>//            Increment i
99290>>>>>>>//
99290>>>>>>>//            Move eSQLServer_NVARCHAR    to ColumnType[i].iSQLType
99290>>>>>>>//            Move "NvarChar"             to ColumnType[i].sSQLType
99290>>>>>>>//            Move DF_TEXT                to ColumnType[i].iDataFlexType
99290>>>>>>>//            Move "Text"                 to ColumnType[i].sDataFlexType
99290>>>>>>>//            Move "4000"                 to ColumnType[i].sPrecision
99290>>>>>>>//            Increment i
99290>>>>>>>//
99290>>>>>>>//            Move eSQLServer_NVARCHARMAX to ColumnType[i].iSQLType
99290>>>>>>>//            Move "NvarCharMax"          to ColumnType[i].sSQLType
99290>>>>>>>//            Move DF_TEXT                to ColumnType[i].iDataFlexType
99290>>>>>>>//            Move "Text"                 to ColumnType[i].sDataFlexType
99290>>>>>>>//            Move "16384"                to ColumnType[i].sPrecision
99290>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
99290>>>>>>>//            Increment i
99290>>>>>>>//
99290>>>>>>>//            Move eSQLServer_REAL    to ColumnType[i].iSQLType
99290>>>>>>>//            Move "Real"             to ColumnType[i].sSQLType
99290>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
99290>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
99290>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
99290>>>>>>>//            Increment i
99290>>>>>>>//
99290>>>>>>>//            Move eSQLServer_SMALLDATETIME   to ColumnType[i].iSQLType
99290>>>>>>>//            Move "SmallDateTime"            to ColumnType[i].sSQLType
99290>>>>>>>//            Move DF_DATETIME                to ColumnType[i].iDataFlexType
99290>>>>>>>//            Move "DATETIME"                 to ColumnType[i].sDataFlexType
99290>>>>>>>//            Move "23.0"                     to ColumnType[i].sPrecision
99290>>>>>>>//            Move True                       to ColumnType[i].bCanEditSize
99290>>>>>>>//            Increment i
99290>>>>>>>//
99290>>>>>>>//            Move eSQLServer_SMALLINT    to ColumnType[i].iSQLType
99290>>>>>>>//            Move "SmallInt"             to ColumnType[i].sSQLType
99290>>>>>>>//            Move DF_BCD                 to ColumnType[i].iDataFlexType
99290>>>>>>>//            Move "NUMERIC"              to ColumnType[i].sDataFlexType
99290>>>>>>>//            Move "6.0"                  to ColumnType[i].sPrecision
99290>>>>>>>//            Increment i
99290>>>>>>>//
99290>>>>>>>//            Move eSQLServer_TEXT    to ColumnType[i].iSQLType
99290>>>>>>>//            Move "Text"             to ColumnType[i].sSQLType
99290>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
99290>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
99290>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
99290>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
99290>>>>>>>//            Increment i
99290>>>>>>>//
99290>>>>>>>//            Move eSQLServer_TIME    to ColumnType[i].iSQLType
99290>>>>>>>//            Move "Time"             to ColumnType[i].sSQLType
99290>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
99290>>>>>>>//            Move "Date"             to ColumnType[i].sDataFlexType
99290>>>>>>>//            Move "16.0"             to ColumnType[i].sPrecision
99290>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
99290>>>>>>>//            Increment i
99290>>>>>>>//
99290>>>>>>>//            Move eSQLServer_TIMESTAMP   to ColumnType[i].iSQLType
99290>>>>>>>//            Move "TimeStamp"            to ColumnType[i].sSQLType
99290>>>>>>>//            Move DF_ASCII               to ColumnType[i].iDataFlexType
99290>>>>>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
99290>>>>>>>//            Move "8.0"                  to ColumnType[i].sPrecision
99290>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
99290>>>>>>>//            Increment i
99290>>>>>>>//
99290>>>>>>>//            Move eSQLServer_TINYINT to ColumnType[i].iSQLType
99290>>>>>>>//            Move "TinyInt"          to ColumnType[i].sSQLType
99290>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
99290>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
99290>>>>>>>//            Move "3.0"              to ColumnType[i].sPrecision
99290>>>>>>>//            Increment i
99290>>>>>>>//
99290>>>>>>>//            Move eSQLServer_GUID    to ColumnType[i].iSQLType
99290>>>>>>>//            Move "UniqueIdentifier" to ColumnType[i].sSQLType
99290>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
99290>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
99290>>>>>>>//            Move "38"               to ColumnType[i].sPrecision
99290>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
99290>>>>>>>//            Increment i
99290>>>>>>>//
99290>>>>>>>//            Move eSQLServer_VARBINARY   to ColumnType[i].iSQLType
99290>>>>>>>//            Move "VarBinary"            to ColumnType[i].sSQLType
99290>>>>>>>//            Move DF_BINARY              to ColumnType[i].iDataFlexType
99290>>>>>>>//            Move "BINARY"               to ColumnType[i].sDataFlexType
99290>>>>>>>//            Move "8000"                 to ColumnType[i].sPrecision
99290>>>>>>>//            Increment i
99290>>>>>>>//
99290>>>>>>>//            Move eSQLServer_VARBINARYMAX to ColumnType[i].iSQLType
99290>>>>>>>//            Move "VarBinary(Max)"        to ColumnType[i].sSQLType
99290>>>>>>>//            Move DF_BINARY               to ColumnType[i].iDataFlexType
99290>>>>>>>//            Move "BINARY"                to ColumnType[i].sDataFlexType
99290>>>>>>>//            Move "16384"                 to ColumnType[i].sPrecision
99290>>>>>>>//            Move True                    to ColumnType[i].bCanEditSize
99290>>>>>>>//            Increment i
99290>>>>>>>//
99290>>>>>>>//            Move eSQLServer_VARCHAR to ColumnType[i].iSQLType
99290>>>>>>>//            Move "VarChar"          to ColumnType[i].sSQLType
99290>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType // ToDo: Under 255 = ASCII type! How to deal with this?
99290>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
99290>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
99290>>>>>>>//            Increment i
99290>>>>>>>//
99290>>>>>>>//            Move eSQLServer_VARCHARMAX  to ColumnType[i].iSQLType
99290>>>>>>>//            Move "VarChar(Max)"         to ColumnType[i].sSQLType
99290>>>>>>>//            Move DF_TEXT                to ColumnType[i].iDataFlexType
99290>>>>>>>//            Move "TEXT"                 to ColumnType[i].sDataFlexType
99290>>>>>>>//            Move "16384"                to ColumnType[i].sPrecision
99290>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
99290>>>>>>>//            Increment i
99290>>>>>>>//
99290>>>>>>>//            Move eSQLServer_SQLVARIANT  to ColumnType[i].iSQLType
99290>>>>>>>//            Move "SQL_Variant"          to ColumnType[i].sSQLType
99290>>>>>>>//            Move DF_BINARY              to ColumnType[i].iDataFlexType
99290>>>>>>>//            Move "Binary"               to ColumnType[i].sDataFlexType
99290>>>>>>>//            Move "8016"                 to ColumnType[i].sPrecision
99290>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
99290>>>>>>>//            Increment i
99290>>>>>>>//
99290>>>>>>>//            Move eSQLServer_XML     to ColumnType[i].iSQLType
99290>>>>>>>//            Move "XML"              to ColumnType[i].sSQLType
99290>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
99290>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
99290>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
99290>>>>>>>        End
99290>>>>>>>>
99290>>>>>>>
99290>>>>>>>        Function_Return aColumnType
99291>>>>>>>    End_Function
99292>>>>>>>
99292>>>>>>>    // MySQL Data Types
99292>>>>>>>    Function _UtilEnumerateMySQLTypes Returns tColumnType[]
99294>>>>>>>        tColumnType[] aColumnType
99294>>>>>>>        tColumnType[] aColumnType
99295>>>>>>>        Integer i
99295>>>>>>>
Including file: mdsmysql_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\mdsmysql_DriverDef.inc)
99295>>>>>>>>// Generated By The Database Update Framework
99295>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\mdsmysql_DriverDef.xml
99295>>>>>>>>// Driver COLUMN DATA TYPES
99295>>>>>>>>//
99295>>>>>>>>// Created: 2018-03-14 23:46:49.593
99295>>>>>>>>
99295>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
99296>>>>>>>>            Move 8                                       to aColumnType[i].iSQLType
99297>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99298>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99299>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
99300>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99301>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
99302>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
99303>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
99304>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
99305>>>>>>>>            Increment i
99306>>>>>>>>
99306>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
99307>>>>>>>>            Move 16                                      to aColumnType[i].iSQLType
99308>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99309>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99310>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
99311>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
99312>>>>>>>>            Move 64                                      to aColumnType[i].nMaxSize
99313>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99314>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99315>>>>>>>>            Move 64                                      to aColumnType[i].sPrecision
99316>>>>>>>>            Increment i
99317>>>>>>>>
99317>>>>>>>>            Move "blob"                                  to aColumnType[i].sSQLType
99318>>>>>>>>            Move 252                                     to aColumnType[i].iSQLType
99319>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99320>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99321>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
99322>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99323>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
99324>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
99325>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
99326>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
99327>>>>>>>>            Increment i
99328>>>>>>>>
99328>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
99329>>>>>>>>            Move 254                                     to aColumnType[i].iSQLType
99330>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99331>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99332>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
99333>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99334>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
99335>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99336>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99337>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
99338>>>>>>>>            Increment i
99339>>>>>>>>
99339>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
99340>>>>>>>>            Move 10                                      to aColumnType[i].iSQLType
99341>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
99342>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99343>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
99344>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
99345>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
99346>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
99347>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
99348>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
99349>>>>>>>>            Increment i
99350>>>>>>>>
99350>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
99351>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
99352>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99353>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99354>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
99355>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
99356>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
99357>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
99358>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
99359>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
99360>>>>>>>>            Increment i
99361>>>>>>>>
99361>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
99362>>>>>>>>            Move 246                                     to aColumnType[i].iSQLType
99363>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99364>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99365>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
99366>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
99367>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
99368>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99369>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99370>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
99371>>>>>>>>            Increment i
99372>>>>>>>>
99372>>>>>>>>            Move "decimal-MySQL4"                        to aColumnType[i].sSQLType
99373>>>>>>>>            Move 0                                       to aColumnType[i].iSQLType
99374>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99375>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99376>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
99377>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
99378>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
99379>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
99380>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
99381>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
99382>>>>>>>>            Increment i
99383>>>>>>>>
99383>>>>>>>>            Move "double"                                to aColumnType[i].sSQLType
99384>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
99385>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99386>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99387>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
99388>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
99389>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
99390>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
99391>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
99392>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
99393>>>>>>>>            Increment i
99394>>>>>>>>
99394>>>>>>>>            Move "enum"                                  to aColumnType[i].sSQLType
99395>>>>>>>>            Move 247                                     to aColumnType[i].iSQLType
99396>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99397>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99398>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
99399>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
99400>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
99401>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99402>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99403>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
99404>>>>>>>>            Increment i
99405>>>>>>>>
99405>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
99406>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
99407>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99408>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99409>>>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
99410>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
99411>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
99412>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
99413>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
99414>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
99415>>>>>>>>            Increment i
99416>>>>>>>>
99416>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
99417>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
99418>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99419>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99420>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
99421>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
99422>>>>>>>>            Move 11                                      to aColumnType[i].nMaxSize
99423>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
99424>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
99425>>>>>>>>            Move 11                                      to aColumnType[i].sPrecision
99426>>>>>>>>            Increment i
99427>>>>>>>>
99427>>>>>>>>            Move "longblob"                              to aColumnType[i].sSQLType
99428>>>>>>>>            Move 251                                     to aColumnType[i].iSQLType
99429>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99430>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99431>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
99432>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99433>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
99434>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
99435>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
99436>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
99437>>>>>>>>            Increment i
99438>>>>>>>>
99438>>>>>>>>            Move "longtext"                              to aColumnType[i].sSQLType
99439>>>>>>>>            Move -251                                    to aColumnType[i].iSQLType
99440>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99441>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99442>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
99443>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99444>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
99445>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
99446>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
99447>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
99448>>>>>>>>            Increment i
99449>>>>>>>>
99449>>>>>>>>            Move "mediumblob"                            to aColumnType[i].sSQLType
99450>>>>>>>>            Move 250                                     to aColumnType[i].iSQLType
99451>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99452>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99453>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
99454>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99455>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
99456>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
99457>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
99458>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
99459>>>>>>>>            Increment i
99460>>>>>>>>
99460>>>>>>>>            Move "mediumint"                             to aColumnType[i].sSQLType
99461>>>>>>>>            Move 9                                       to aColumnType[i].iSQLType
99462>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99463>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99464>>>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
99465>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99466>>>>>>>>            Move 9                                       to aColumnType[i].nMaxSize
99467>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
99468>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
99469>>>>>>>>            Move 9                                       to aColumnType[i].sPrecision
99470>>>>>>>>            Increment i
99471>>>>>>>>
99471>>>>>>>>            Move "mediumtext"                            to aColumnType[i].sSQLType
99472>>>>>>>>            Move -250                                    to aColumnType[i].iSQLType
99473>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99474>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99475>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
99476>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99477>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
99478>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
99479>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
99480>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
99481>>>>>>>>            Increment i
99482>>>>>>>>
99482>>>>>>>>            Move "set"                                   to aColumnType[i].sSQLType
99483>>>>>>>>            Move 248                                     to aColumnType[i].iSQLType
99484>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99485>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99486>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
99487>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
99488>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
99489>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99490>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99491>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
99492>>>>>>>>            Increment i
99493>>>>>>>>
99493>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
99494>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
99495>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99496>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99497>>>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
99498>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99499>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
99500>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
99501>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
99502>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
99503>>>>>>>>            Increment i
99504>>>>>>>>
99504>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
99505>>>>>>>>            Move -252                                    to aColumnType[i].iSQLType
99506>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99507>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99508>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
99509>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99510>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
99511>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
99512>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
99513>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
99514>>>>>>>>            Increment i
99515>>>>>>>>
99515>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
99516>>>>>>>>            Move 11                                      to aColumnType[i].iSQLType
99517>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
99518>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99519>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
99520>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
99521>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
99522>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99523>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99524>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
99525>>>>>>>>            Increment i
99526>>>>>>>>
99526>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
99527>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
99528>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99529>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99530>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
99531>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
99532>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
99533>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
99534>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
99535>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
99536>>>>>>>>            Increment i
99537>>>>>>>>
99537>>>>>>>>            Move "tinyblob"                              to aColumnType[i].sSQLType
99538>>>>>>>>            Move 249                                     to aColumnType[i].iSQLType
99539>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99540>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99541>>>>>>>>            Move 255                                     to aColumnType[i].iDefaultSize
99542>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99543>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
99544>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
99545>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
99546>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
99547>>>>>>>>            Increment i
99548>>>>>>>>
99548>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
99549>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
99550>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99551>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99552>>>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
99553>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99554>>>>>>>>            Move 4                                       to aColumnType[i].nMaxSize
99555>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
99556>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
99557>>>>>>>>            Move 4                                       to aColumnType[i].sPrecision
99558>>>>>>>>            Increment i
99559>>>>>>>>
99559>>>>>>>>            Move "tinytext"                              to aColumnType[i].sSQLType
99560>>>>>>>>            Move -249                                    to aColumnType[i].iSQLType
99561>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99562>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99563>>>>>>>>            Move 255                                     to aColumnType[i].iDefaultSize
99564>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99565>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
99566>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99567>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99568>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
99569>>>>>>>>            Increment i
99570>>>>>>>>
99570>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
99571>>>>>>>>            Move 253                                     to aColumnType[i].iSQLType
99572>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99573>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99574>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
99575>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
99576>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
99577>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99578>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99579>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
99580>>>>>>>>            Increment i
99581>>>>>>>>
99581>>>>>>>>            Move "year"                                  to aColumnType[i].sSQLType
99582>>>>>>>>            Move 13                                      to aColumnType[i].iSQLType
99583>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
99584>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99585>>>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
99586>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
99587>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
99588>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
99589>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
99590>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
99591>>>>>>>>            Increment i
99592>>>>>>>>
99592>>>>>>>>
99592>>>>>>>
99592>>>>>>>//        Move eMySQL_LONGLONG    to ColumnType[i].iSQLType
99592>>>>>>>//        Move "bigint"           to ColumnType[i].sSQLType
99592>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
99592>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
99592>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
99592>>>>>>>//        Increment i
99592>>>>>>>//
99592>>>>>>>//        Move eMySQL_BIT         to ColumnType[i].iSQLType
99592>>>>>>>//        Move "bit"              to ColumnType[i].sSQLType
99592>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
99592>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
99592>>>>>>>//        Move "4.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
99592>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
99592>>>>>>>//        Increment i
99592>>>>>>>//
99592>>>>>>>//        Move eMySQL_BLOB        to ColumnType[i].iSQLType
99592>>>>>>>//        Move "blob"             to ColumnType[i].sSQLType
99592>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
99592>>>>>>>//        Move "BINARY"           to ColumnType[i].sDataFlexType
99592>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
99592>>>>>>>//        Increment i
99592>>>>>>>//
99592>>>>>>>//        Move eMySQL_STRING      to ColumnType[i].iSQLType
99592>>>>>>>//        Move "char"             to ColumnType[i].sSQLType
99592>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
99592>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
99592>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
99592>>>>>>>//        Increment i
99592>>>>>>>//
99592>>>>>>>//        Move eMySQL_DATE        to ColumnType[i].iSQLType
99592>>>>>>>//        Move "date"             to ColumnType[i].sSQLType
99592>>>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
99592>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
99592>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
99592>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
99592>>>>>>>//        Increment i
99592>>>>>>>//
99592>>>>>>>//        Move eMySQL_DATETIME    to ColumnType[i].iSQLType
99592>>>>>>>//        Move "datetime"         to ColumnType[i].sSQLType
99592>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
99592>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
99592>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
99592>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
99592>>>>>>>//        Increment i
99592>>>>>>>//
99592>>>>>>>//        Move eMySQL_DECIMAL     to ColumnType[i].iSQLType
99592>>>>>>>//        Move "decimal"          to ColumnType[i].sSQLType
99592>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
99592>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
99592>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
99592>>>>>>>//        Increment i
99592>>>>>>>//
99592>>>>>>>//        Move eMySQL_DOUBLE      to ColumnType[i].iSQLType
99592>>>>>>>//        Move "double"           to ColumnType[i].sSQLType
99592>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
99592>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
99592>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
99592>>>>>>>//        Increment i
99592>>>>>>>//
99592>>>>>>>//        Move eMySQL_ENUM        to ColumnType[i].iSQLType
99592>>>>>>>//        Move "enum"             to ColumnType[i].sSQLType
99592>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
99592>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
99592>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
99592>>>>>>>//        Increment i
99592>>>>>>>//
99592>>>>>>>//        Move eMySQL_FLOAT       to ColumnType[i].iSQLType
99592>>>>>>>//        Move "float"            to ColumnType[i].sSQLType
99592>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
99592>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
99592>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
99592>>>>>>>//        Increment i
99592>>>>>>>//
99592>>>>>>>//        Move eMySQL_INT24       to ColumnType[i].iSQLType
99592>>>>>>>//        Move "int"              to ColumnType[i].sSQLType
99592>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
99592>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
99592>>>>>>>//        Move "11.0"             to ColumnType[i].sPrecision
99592>>>>>>>//        Increment i
99592>>>>>>>//
99592>>>>>>>//        Move eMySQL_LONG_BLOB   to ColumnType[i].iSQLType
99592>>>>>>>//        Move "longblob"         to ColumnType[i].sSQLType
99592>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
99592>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
99592>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
99592>>>>>>>//        Increment i
99592>>>>>>>//
99592>>>>>>>//        Move eMySQL_LONG_TEXT   to ColumnType[i].iSQLType
99592>>>>>>>//        Move "longtext"         to ColumnType[i].sSQLType
99592>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
99592>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
99592>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
99592>>>>>>>//        Increment i
99592>>>>>>>//
99592>>>>>>>//        Move eMySQL_MEDIUM_BLOB to ColumnType[i].iSQLType
99592>>>>>>>//        Move "mediumblob"       to ColumnType[i].sSQLType
99592>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
99592>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
99592>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
99592>>>>>>>//        Increment i
99592>>>>>>>//
99592>>>>>>>//        Move eMySQL_INT24       to ColumnType[i].iSQLType
99592>>>>>>>//        Move "mediumint"        to ColumnType[i].sSQLType
99592>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
99592>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
99592>>>>>>>//        Move "9.0"              to ColumnType[i].sPrecision
99592>>>>>>>//
99592>>>>>>>//        Move eMySQL_MEDIUM_TEXT to ColumnType[i].iSQLType
99592>>>>>>>//        Move "mediumtext"       to ColumnType[i].sSQLType
99592>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
99592>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
99592>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
99592>>>>>>>//        Increment i
99592>>>>>>>//
99592>>>>>>>//        Move eMySQL_SET         to ColumnType[i].iSQLType
99592>>>>>>>//        Move "set"              to ColumnType[i].sSQLType
99592>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
99592>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
99592>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
99592>>>>>>>//        Increment i
99592>>>>>>>//
99592>>>>>>>//        Move eMySQL_SHORT       to ColumnType[i].iSQLType
99592>>>>>>>//        Move "smallint"         to ColumnType[i].sSQLType
99592>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
99592>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
99592>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
99592>>>>>>>//        Increment i
99592>>>>>>>//
99592>>>>>>>//        Move eMySQL_TEXT        to ColumnType[i].iSQLType
99592>>>>>>>//        Move "text"             to ColumnType[i].sSQLType
99592>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
99592>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
99592>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
99592>>>>>>>//        Increment i
99592>>>>>>>//
99592>>>>>>>//        Move eMySQL_TIME        to ColumnType[i].iSQLType
99592>>>>>>>//        Move "time"             to ColumnType[i].sSQLType
99592>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
99592>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
99592>>>>>>>//        Move "10.0"             to ColumnType[i].sPrecision
99592>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
99592>>>>>>>//        Increment i
99592>>>>>>>//
99592>>>>>>>//        Move eMySQL_TIMESTAMP   to ColumnType[i].iSQLType
99592>>>>>>>//        Move "timestamp"        to ColumnType[i].sSQLType
99592>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
99592>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
99592>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
99592>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
99592>>>>>>>//        Increment i
99592>>>>>>>//
99592>>>>>>>//        Move eMySQL_TINY_BLOB   to ColumnType[i].iSQLType
99592>>>>>>>//        Move "tinyblob"         to ColumnType[i].sSQLType
99592>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
99592>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
99592>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
99592>>>>>>>//        Increment i
99592>>>>>>>//
99592>>>>>>>//        Move eMySQL_TINY        to ColumnType[i].iSQLType
99592>>>>>>>//        Move "tinyint"          to ColumnType[i].sSQLType
99592>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
99592>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
99592>>>>>>>//        Move "4.0"              to ColumnType[i].sPrecision
99592>>>>>>>//        Increment i
99592>>>>>>>//
99592>>>>>>>//        Move eMySQL_TINY_TEXT   to ColumnType[i].iSQLType
99592>>>>>>>//        Move "tinytext"         to ColumnType[i].sSQLType
99592>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
99592>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
99592>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
99592>>>>>>>//        Increment i
99592>>>>>>>//
99592>>>>>>>//        Move eMySQL_VAR_STRING  to ColumnType[i].iSQLType
99592>>>>>>>//        Move "varchar"          to ColumnType[i].sSQLType
99592>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
99592>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
99592>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
99592>>>>>>>//        Increment i
99592>>>>>>>//
99592>>>>>>>//        Move eMySQL_YEAR        to ColumnType[i].iSQLType
99592>>>>>>>//        Move "year"             to ColumnType[i].sSQLType
99592>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
99592>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
99592>>>>>>>//        Move "4.0"              to ColumnType[i].sPrecision
99592>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
99592>>>>>>>//        Increment i
99592>>>>>>>
99592>>>>>>>        Function_Return aColumnType
99593>>>>>>>    End_Function
99594>>>>>>>
99594>>>>>>>    // Oracle Data Types
99594>>>>>>>    Function _UtilEnumerateOracleTypes Returns tColumnType[]
99596>>>>>>>        tColumnType[] aColumnType
99596>>>>>>>        tColumnType[] aColumnType
99597>>>>>>>        Integer i
99597>>>>>>>
Including file: ora_drv_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ora_drv_DriverDef.inc)
99597>>>>>>>>// Generated By The Database Update Framework
99597>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\ora_drv_DriverDef.xml
99597>>>>>>>>// Driver COLUMN DATA TYPES
99597>>>>>>>>//
99597>>>>>>>>// Created: 2018-03-14 23:47:34.82
99597>>>>>>>>
99597>>>>>>>>            Move "blob"                                  to aColumnType[i].sSQLType
99598>>>>>>>>            Move 113                                     to aColumnType[i].iSQLType
99599>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99600>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99601>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
99602>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99603>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
99604>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
99605>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
99606>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
99607>>>>>>>>            Increment i
99608>>>>>>>>
99608>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
99609>>>>>>>>            Move 96                                      to aColumnType[i].iSQLType
99610>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99611>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99612>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
99613>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99614>>>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
99615>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99616>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99617>>>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
99618>>>>>>>>            Increment i
99619>>>>>>>>
99619>>>>>>>>            Move "clob"                                  to aColumnType[i].sSQLType
99620>>>>>>>>            Move 112                                     to aColumnType[i].iSQLType
99621>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99622>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99623>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
99624>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99625>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
99626>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
99627>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
99628>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
99629>>>>>>>>            Increment i
99630>>>>>>>>
99630>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
99631>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
99632>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99633>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99634>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
99635>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
99636>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
99637>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
99638>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
99639>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
99640>>>>>>>>            Increment i
99641>>>>>>>>
99641>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
99642>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
99643>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99644>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99645>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
99646>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99647>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
99648>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
99649>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
99650>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
99651>>>>>>>>            Increment i
99652>>>>>>>>
99652>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
99653>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
99654>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99655>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99656>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
99657>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99658>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
99659>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
99660>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
99661>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
99662>>>>>>>>            Increment i
99663>>>>>>>>
99663>>>>>>>>            Move "intervalds"                            to aColumnType[i].sSQLType
99664>>>>>>>>            Move 190                                     to aColumnType[i].iSQLType
99665>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
99666>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99667>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
99668>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
99669>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
99670>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
99671>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
99672>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
99673>>>>>>>>            Increment i
99674>>>>>>>>
99674>>>>>>>>            Move "intervalym"                            to aColumnType[i].sSQLType
99675>>>>>>>>            Move 189                                     to aColumnType[i].iSQLType
99676>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
99677>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99678>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
99679>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
99680>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
99681>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
99682>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
99683>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
99684>>>>>>>>            Increment i
99685>>>>>>>>
99685>>>>>>>>            Move "long"                                  to aColumnType[i].sSQLType
99686>>>>>>>>            Move 8                                       to aColumnType[i].iSQLType
99687>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99688>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99689>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
99690>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99691>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
99692>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99693>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99694>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
99695>>>>>>>>            Increment i
99696>>>>>>>>
99696>>>>>>>>            Move "longraw"                               to aColumnType[i].sSQLType
99697>>>>>>>>            Move 24                                      to aColumnType[i].iSQLType
99698>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99699>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99700>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
99701>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99702>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
99703>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
99704>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
99705>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
99706>>>>>>>>            Increment i
99707>>>>>>>>
99707>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
99708>>>>>>>>            Move 286                                     to aColumnType[i].iSQLType
99709>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99710>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99711>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
99712>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99713>>>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
99714>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99715>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99716>>>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
99717>>>>>>>>            Increment i
99718>>>>>>>>
99718>>>>>>>>            Move "nclob"                                 to aColumnType[i].sSQLType
99719>>>>>>>>            Move 288                                     to aColumnType[i].iSQLType
99720>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99721>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99722>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
99723>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99724>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
99725>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
99726>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
99727>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
99728>>>>>>>>            Increment i
99729>>>>>>>>
99729>>>>>>>>            Move "number"                                to aColumnType[i].sSQLType
99730>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
99731>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99732>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99733>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
99734>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99735>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
99736>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
99737>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
99738>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
99739>>>>>>>>            Increment i
99740>>>>>>>>
99740>>>>>>>>            Move "nvarchar2"                             to aColumnType[i].sSQLType
99741>>>>>>>>            Move 287                                     to aColumnType[i].iSQLType
99742>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99743>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99744>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
99745>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99746>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
99747>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99748>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99749>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
99750>>>>>>>>            Increment i
99751>>>>>>>>
99751>>>>>>>>            Move "raw"                                   to aColumnType[i].sSQLType
99752>>>>>>>>            Move 23                                      to aColumnType[i].iSQLType
99753>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99754>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99755>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
99756>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99757>>>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
99758>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
99759>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
99760>>>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
99761>>>>>>>>            Increment i
99762>>>>>>>>
99762>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
99763>>>>>>>>            Move 187                                     to aColumnType[i].iSQLType
99764>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
99765>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99766>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
99767>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
99768>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
99769>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
99770>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
99771>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
99772>>>>>>>>            Increment i
99773>>>>>>>>
99773>>>>>>>>            Move "timestampltz"                          to aColumnType[i].sSQLType
99774>>>>>>>>            Move 232                                     to aColumnType[i].iSQLType
99775>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
99776>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99777>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
99778>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
99779>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
99780>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
99781>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
99782>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
99783>>>>>>>>            Increment i
99784>>>>>>>>
99784>>>>>>>>            Move "timestamptz"                           to aColumnType[i].sSQLType
99785>>>>>>>>            Move 188                                     to aColumnType[i].iSQLType
99786>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
99787>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99788>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
99789>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
99790>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
99791>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
99792>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
99793>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
99794>>>>>>>>            Increment i
99795>>>>>>>>
99795>>>>>>>>            Move "varchar2"                              to aColumnType[i].sSQLType
99796>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
99797>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99798>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99799>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
99800>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99801>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
99802>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99803>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99804>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
99805>>>>>>>>            Increment i
99806>>>>>>>>
99806>>>>>>>>
99806>>>>>>>
99806>>>>>>>//        Move eOracle_BLOB       to ColumnType[i].iSQLType
99806>>>>>>>//        Move "BLOB"             to ColumnType[i].sSQLType
99806>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
99806>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
99806>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
99806>>>>>>>//        Increment i
99806>>>>>>>//
99806>>>>>>>//        Move eOracle_CHAR       to ColumnType[i].iSQLType
99806>>>>>>>//        Move "CHAR"             to ColumnType[i].sSQLType
99806>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
99806>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
99806>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
99806>>>>>>>//        Increment i
99806>>>>>>>//
99806>>>>>>>//        Move eOracle_CLOB       to ColumnType[i].iSQLType
99806>>>>>>>//        Move "CLOB"             to ColumnType[i].sSQLType
99806>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
99806>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
99806>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
99806>>>>>>>//        Increment i
99806>>>>>>>//
99806>>>>>>>//        Move eOracle_DATE       to ColumnType[i].iSQLType
99806>>>>>>>//        Move "DATE"             to ColumnType[i].sSQLType
99806>>>>>>>//        Move DF_Date            to ColumnType[i].iDataFlexType
99806>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
99806>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
99806>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
99806>>>>>>>//        Increment i
99806>>>>>>>//
99806>>>>>>>//        Move eOracle_FLOAT      to ColumnType[i].iSQLType
99806>>>>>>>//        Move "FLOAT"            to ColumnType[i].sSQLType
99806>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
99806>>>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
99806>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
99806>>>>>>>//        Increment i
99806>>>>>>>//
99806>>>>>>>//        Move eOracle_INT        to ColumnType[i].iSQLType
99806>>>>>>>//        Move "INT"              to ColumnType[i].sSQLType
99806>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
99806>>>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
99806>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
99806>>>>>>>//        Increment i
99806>>>>>>>//
99806>>>>>>>//        Move eOracle_INTERVALDS to ColumnType[i].iSQLType
99806>>>>>>>//        Move "INTERVALDAYTOSEC" to ColumnType[i].sSQLType
99806>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
99806>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
99806>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
99806>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
99806>>>>>>>//        Increment i
99806>>>>>>>//
99806>>>>>>>//        Move eOracle_INTERVALYM  to ColumnType[i].iSQLType
99806>>>>>>>//        Move "INTERVALYEARTOMON" to ColumnType[i].sSQLType
99806>>>>>>>//        Move DF_DATETIME         to ColumnType[i].iDataFlexType
99806>>>>>>>//        Move "DateTime"          to ColumnType[i].sDataFlexType
99806>>>>>>>//        Move "23.0"              to ColumnType[i].sPrecision
99806>>>>>>>//        Move True                to ColumnType[i].bCanEditSize
99806>>>>>>>//        Increment i
99806>>>>>>>//
99806>>>>>>>//        Move eOracle_RAW        to ColumnType[i].iSQLType
99806>>>>>>>//        Move "LONG"             to ColumnType[i].sSQLType
99806>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
99806>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
99806>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
99806>>>>>>>//        Increment i
99806>>>>>>>//
99806>>>>>>>//        Move eOracle_LONGRAW    to ColumnType[i].iSQLType
99806>>>>>>>//        Move "LONG RAW"         to ColumnType[i].sSQLType
99806>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
99806>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
99806>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
99806>>>>>>>//        Increment i
99806>>>>>>>//
99806>>>>>>>//        Move eOracle_NCHAR      to ColumnType[i].iSQLType
99806>>>>>>>//        Move "NCHAR"            to ColumnType[i].sSQLType
99806>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
99806>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
99806>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
99806>>>>>>>//        Increment i
99806>>>>>>>//
99806>>>>>>>//        Move eOracle_NCLOB      to ColumnType[i].iSQLType
99806>>>>>>>//        Move "NCLOB"            to ColumnType[i].sSQLType
99806>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
99806>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
99806>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
99806>>>>>>>//        Increment i
99806>>>>>>>//
99806>>>>>>>//        Move eOracle_NUMBER     to ColumnType[i].iSQLType
99806>>>>>>>//        Move "NUMBER"           to ColumnType[i].sSQLType
99806>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
99806>>>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
99806>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
99806>>>>>>>//        Increment i
99806>>>>>>>//
99806>>>>>>>//        Move eOracle_NVARCHAR2  to ColumnType[i].iSQLType
99806>>>>>>>//        Move "NVARCHAR2"        to ColumnType[i].sSQLType
99806>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
99806>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
99806>>>>>>>//        Move "4000"             to ColumnType[i].sPrecision
99806>>>>>>>//        Increment i
99806>>>>>>>//
99806>>>>>>>//        Move eOracle_RAW        to ColumnType[i].iSQLType
99806>>>>>>>//        Move "RAW"              to ColumnType[i].sSQLType
99806>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
99806>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
99806>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
99806>>>>>>>//        Increment i
99806>>>>>>>//
99806>>>>>>>//        Move eOracle_ROWID      to ColumnType[i].iSQLType
99806>>>>>>>//        Move "ROWID"            to ColumnType[i].sSQLType
99806>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
99806>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
99806>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
99806>>>>>>>//        Increment i
99806>>>>>>>//
99806>>>>>>>//        Move eOracle_TIMESTAMP  to ColumnType[i].iSQLType
99806>>>>>>>//        Move "TimeStamp"        to ColumnType[i].sSQLType
99806>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
99806>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
99806>>>>>>>//        Move "11.0"             to ColumnType[i].sPrecision
99806>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
99806>>>>>>>//        Increment i
99806>>>>>>>//
99806>>>>>>>//        Move eOracle_TIMESTAMPLTZ   to ColumnType[i].iSQLType
99806>>>>>>>//        Move "TIMESTAMPLOCALTZ"     to ColumnType[i].sSQLType
99806>>>>>>>//        Move DF_DATETIME            to ColumnType[i].iDataFlexType
99806>>>>>>>//        Move "DateTime"             to ColumnType[i].sDataFlexType
99806>>>>>>>//        Move "13.0"                 to ColumnType[i].sPrecision
99806>>>>>>>//        Move True                   to ColumnType[i].bCanEditSize
99806>>>>>>>//        Increment i
99806>>>>>>>//
99806>>>>>>>//        Move eOracle_TIMESTAMPTZ    to ColumnType[i].iSQLType
99806>>>>>>>//        Move "TIMEZONETIMEZONE"     to ColumnType[i].sSQLType
99806>>>>>>>//        Move DF_DATETIME            to ColumnType[i].iDataFlexType
99806>>>>>>>//        Move "DateTime"             to ColumnType[i].sDataFlexType
99806>>>>>>>//        Move "11.0"                 to ColumnType[i].sPrecision
99806>>>>>>>//        Move True                   to ColumnType[i].bCanEditSize
99806>>>>>>>//        Increment i
99806>>>>>>>//
99806>>>>>>>//        Move eOracle_VARCHAR2   to ColumnType[i].iSQLType
99806>>>>>>>//        Move "VARCHAR"          to ColumnType[i].sSQLType
99806>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
99806>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
99806>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
99806>>>>>>>
99806>>>>>>>        Function_Return aColumnType
99807>>>>>>>    End_Function
99808>>>>>>>
99808>>>>>>>    // PostgreSQL Data Types
99808>>>>>>>    Function _UtilEnumeratePostgreSQLTypes Returns tColumnType[]
99810>>>>>>>        tColumnType[] aColumnType
99810>>>>>>>        tColumnType[] aColumnType
99811>>>>>>>        Integer i
99811>>>>>>>
Including file: mdspgsql_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\mdspgsql_DriverDef.inc)
99811>>>>>>>>// Generated By The Database Update Framework
99811>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\mdspgsql_DriverDef.xml
99811>>>>>>>>// Driver COLUMN DATA TYPES
99811>>>>>>>>//
99811>>>>>>>>// Created: 2018-03-14 23:47:02.984
99811>>>>>>>>
99811>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
99812>>>>>>>>            Move 20                                      to aColumnType[i].iSQLType
99813>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99814>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99815>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
99816>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99817>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
99818>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
99819>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
99820>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
99821>>>>>>>>            Increment i
99822>>>>>>>>
99822>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
99823>>>>>>>>            Move 1560                                    to aColumnType[i].iSQLType
99824>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99825>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99826>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
99827>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99828>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
99829>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
99830>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
99831>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
99832>>>>>>>>            Increment i
99833>>>>>>>>
99833>>>>>>>>            Move "boolean"                               to aColumnType[i].sSQLType
99834>>>>>>>>            Move 16                                      to aColumnType[i].iSQLType
99835>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
99836>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99837>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
99838>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
99839>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
99840>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99841>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99842>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
99843>>>>>>>>            Increment i
99844>>>>>>>>
99844>>>>>>>>            Move "bytea"                                 to aColumnType[i].sSQLType
99845>>>>>>>>            Move 17                                      to aColumnType[i].iSQLType
99846>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99847>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99848>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
99849>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99850>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
99851>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
99852>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
99853>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
99854>>>>>>>>            Increment i
99855>>>>>>>>
99855>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
99856>>>>>>>>            Move 18                                      to aColumnType[i].iSQLType
99857>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99858>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99859>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
99860>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99861>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
99862>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99863>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99864>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
99865>>>>>>>>            Increment i
99866>>>>>>>>
99866>>>>>>>>            Move "citext"                                to aColumnType[i].sSQLType
99867>>>>>>>>            Move -25                                     to aColumnType[i].iSQLType
99868>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99869>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99870>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
99871>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99872>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
99873>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99874>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99875>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
99876>>>>>>>>            Increment i
99877>>>>>>>>
99877>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
99878>>>>>>>>            Move 1082                                    to aColumnType[i].iSQLType
99879>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
99880>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99881>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
99882>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
99883>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
99884>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
99885>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
99886>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
99887>>>>>>>>            Increment i
99888>>>>>>>>
99888>>>>>>>>            Move "double"                                to aColumnType[i].sSQLType
99889>>>>>>>>            Move 701                                     to aColumnType[i].iSQLType
99890>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99891>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99892>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
99893>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99894>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
99895>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99896>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99897>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
99898>>>>>>>>            Increment i
99899>>>>>>>>
99899>>>>>>>>            Move "integer"                               to aColumnType[i].sSQLType
99900>>>>>>>>            Move 23                                      to aColumnType[i].iSQLType
99901>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99902>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99903>>>>>>>>            Move 11                                      to aColumnType[i].iDefaultSize
99904>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99905>>>>>>>>            Move 11                                      to aColumnType[i].nMaxSize
99906>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
99907>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
99908>>>>>>>>            Move 11                                      to aColumnType[i].sPrecision
99909>>>>>>>>            Increment i
99910>>>>>>>>
99910>>>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
99911>>>>>>>>            Move 790                                     to aColumnType[i].iSQLType
99912>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99913>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99914>>>>>>>>            Move 30                                      to aColumnType[i].iDefaultSize
99915>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99916>>>>>>>>            Move 30                                      to aColumnType[i].nMaxSize
99917>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
99918>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
99919>>>>>>>>            Move 30                                      to aColumnType[i].sPrecision
99920>>>>>>>>            Increment i
99921>>>>>>>>
99921>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
99922>>>>>>>>            Move 1700                                    to aColumnType[i].iSQLType
99923>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99924>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99925>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
99926>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99927>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
99928>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99929>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99930>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
99931>>>>>>>>            Increment i
99932>>>>>>>>
99932>>>>>>>>            Move "oid"                                   to aColumnType[i].sSQLType
99933>>>>>>>>            Move 26                                      to aColumnType[i].iSQLType
99934>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
99935>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99936>>>>>>>>            Move 20                                      to aColumnType[i].iDefaultSize
99937>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
99938>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
99939>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
99940>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
99941>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
99942>>>>>>>>            Increment i
99943>>>>>>>>
99943>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
99944>>>>>>>>            Move 700                                     to aColumnType[i].iSQLType
99945>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99946>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99947>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
99948>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99949>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
99950>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
99951>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
99952>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
99953>>>>>>>>            Increment i
99954>>>>>>>>
99954>>>>>>>>            Move "regproc"                               to aColumnType[i].sSQLType
99955>>>>>>>>            Move 24                                      to aColumnType[i].iSQLType
99956>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
99957>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99958>>>>>>>>            Move 64                                      to aColumnType[i].iDefaultSize
99959>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
99960>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
99961>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99962>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99963>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
99964>>>>>>>>            Increment i
99965>>>>>>>>
99965>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
99966>>>>>>>>            Move 21                                      to aColumnType[i].iSQLType
99967>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99968>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99969>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
99970>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99971>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
99972>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
99973>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
99974>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
99975>>>>>>>>            Increment i
99976>>>>>>>>
99976>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
99977>>>>>>>>            Move 25                                      to aColumnType[i].iSQLType
99978>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99979>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99980>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
99981>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
99982>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
99983>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99984>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99985>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
99986>>>>>>>>            Increment i
99987>>>>>>>>
99987>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
99988>>>>>>>>            Move 1083                                    to aColumnType[i].iSQLType
99989>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
99990>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
99991>>>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
99992>>>>>>>>            Move 8                                       to aColumnType[i].iMinSize
99993>>>>>>>>            Move 15                                      to aColumnType[i].nMaxSize
99994>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
99995>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
99996>>>>>>>>            Move 15                                      to aColumnType[i].sPrecision
99997>>>>>>>>            Increment i
99998>>>>>>>>
99998>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
99999>>>>>>>>            Move 1114                                    to aColumnType[i].iSQLType
100000>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
100001>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100002>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
100003>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
100004>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
100005>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
100006>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
100007>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
100008>>>>>>>>            Increment i
100009>>>>>>>>
100009>>>>>>>>            Move "timestamptz"                           to aColumnType[i].sSQLType
100010>>>>>>>>            Move 1184                                    to aColumnType[i].iSQLType
100011>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
100012>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100013>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
100014>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
100015>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
100016>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
100017>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
100018>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
100019>>>>>>>>            Increment i
100020>>>>>>>>
100020>>>>>>>>            Move "uuid"                                  to aColumnType[i].sSQLType
100021>>>>>>>>            Move 2950                                    to aColumnType[i].iSQLType
100022>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
100023>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100024>>>>>>>>            Move 40                                      to aColumnType[i].iDefaultSize
100025>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
100026>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
100027>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
100028>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
100029>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
100030>>>>>>>>            Increment i
100031>>>>>>>>
100031>>>>>>>>            Move "varbit"                                to aColumnType[i].sSQLType
100032>>>>>>>>            Move 1562                                    to aColumnType[i].iSQLType
100033>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100034>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100035>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
100036>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
100037>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
100038>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
100039>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
100040>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
100041>>>>>>>>            Increment i
100042>>>>>>>>
100042>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
100043>>>>>>>>            Move 1043                                    to aColumnType[i].iSQLType
100044>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
100045>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
100046>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
100047>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
100048>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
100049>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
100050>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
100051>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
100052>>>>>>>>            Increment i
100053>>>>>>>>
100053>>>>>>>>
100053>>>>>>>
100053>>>>>>>//        Move ePgSQL_INT8        to ColumnType[i].iSQLType
100053>>>>>>>//        Move "bigint"           to ColumnType[i].sSQLType
100053>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
100053>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
100053>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
100053>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
100053>>>>>>>//        Increment i
100053>>>>>>>//
100053>>>>>>>//        Move ePgSQL_BIT         to ColumnType[i].iSQLType
100053>>>>>>>//        Move "bit"              to ColumnType[i].sSQLType
100053>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
100053>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
100053>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
100053>>>>>>>//        Increment i
100053>>>>>>>//
100053>>>>>>>//        Move ePgSQL_BOOL        to ColumnType[i].iSQLType
100053>>>>>>>//        Move "boolean"          to ColumnType[i].sSQLType
100053>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
100053>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
100053>>>>>>>//        Move "1"                to ColumnType[i].sPrecision
100053>>>>>>>//        Increment i
100053>>>>>>>//
100053>>>>>>>//        Move ePgSQL_BYTEA       to ColumnType[i].iSQLType
100053>>>>>>>//        Move "bytea"            to ColumnType[i].sSQLType
100053>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
100053>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
100053>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
100053>>>>>>>//        Increment i
100053>>>>>>>//
100053>>>>>>>//        Move ePgSQL_CHAR        to ColumnType[i].iSQLType
100053>>>>>>>//        Move "char"             to ColumnType[i].sSQLType
100053>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
100053>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
100053>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
100053>>>>>>>//        Increment i
100053>>>>>>>//
100053>>>>>>>//        Move ePgSQL_CITEXT      to ColumnType[i].iSQLType
100053>>>>>>>//        Move "citext"           to ColumnType[i].sSQLType
100053>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
100053>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
100053>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
100053>>>>>>>//        Increment i
100053>>>>>>>//
100053>>>>>>>//        Move ePgSQL_DATE        to ColumnType[i].iSQLType
100053>>>>>>>//        Move "date"             to ColumnType[i].sSQLType
100053>>>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
100053>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
100053>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
100053>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
100053>>>>>>>//        Increment i
100053>>>>>>>//
100053>>>>>>>//        Move ePgSQL_FLOAT4      to ColumnType[i].iSQLType
100053>>>>>>>//        Move "decimal"          to ColumnType[i].sSQLType
100053>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
100053>>>>>>>//        Move "Decimal"          to ColumnType[i].sDataFlexType
100053>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
100053>>>>>>>//        Increment i
100053>>>>>>>//
100053>>>>>>>//        Move ePgSQL_FLOAT8      to ColumnType[i].iSQLType
100053>>>>>>>//        Move "double"           to ColumnType[i].sSQLType
100053>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
100053>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
100053>>>>>>>//        Move "22"               to ColumnType[i].sPrecision
100053>>>>>>>//        Increment i
100053>>>>>>>//
100053>>>>>>>//        Move ePgSQL_INT4        to ColumnType[i].iSQLType
100053>>>>>>>//        Move "integer"          to ColumnType[i].sSQLType
100053>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
100053>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
100053>>>>>>>//        Move "8.0"              to ColumnType[i].sPrecision
100053>>>>>>>//        Increment i
100053>>>>>>>//
100053>>>>>>>//        Move ePgSQL_MONEY       to ColumnType[i].iSQLType
100053>>>>>>>//        Move "money"            to ColumnType[i].sSQLType
100053>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
100053>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
100053>>>>>>>//        Move "8.0"              to ColumnType[i].sPrecision
100053>>>>>>>//        Increment i
100053>>>>>>>//
100053>>>>>>>//        Move ePgSQL_OID         to ColumnType[i].iSQLType
100053>>>>>>>//        Move "oid"              to ColumnType[i].sSQLType
100053>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
100053>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
100053>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
100053>>>>>>>//        Increment i
100053>>>>>>>//
100053>>>>>>>//        Move ePgSQL_FLOAT4      to ColumnType[i].iSQLType
100053>>>>>>>//        Move "real"             to ColumnType[i].sSQLType
100053>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
100053>>>>>>>//        Move "Real"             to ColumnType[i].sDataFlexType
100053>>>>>>>//        Move "6.6"              to ColumnType[i].sPrecision
100053>>>>>>>//        Increment i
100053>>>>>>>//
100053>>>>>>>//        Move ePgSQL_REGPROC     to ColumnType[i].iSQLType
100053>>>>>>>//        Move "regproc"          to ColumnType[i].sSQLType
100053>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
100053>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
100053>>>>>>>//        Move "64"               to ColumnType[i].sPrecision
100053>>>>>>>//        Increment i
100053>>>>>>>//
100053>>>>>>>//        Move ePgSQL_INT2        to ColumnType[i].iSQLType
100053>>>>>>>//        Move "smallint"         to ColumnType[i].sSQLType
100053>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
100053>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
100053>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
100053>>>>>>>//        Increment i
100053>>>>>>>//
100053>>>>>>>//        Move ePgSQL_TEXT        to ColumnType[i].iSQLType
100053>>>>>>>//        Move "text"             to ColumnType[i].sSQLType
100053>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
100053>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
100053>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
100053>>>>>>>//        Increment i
100053>>>>>>>//
100053>>>>>>>//        Move ePgSQL_TIME        to ColumnType[i].iSQLType
100053>>>>>>>//        Move "time"             to ColumnType[i].sSQLType
100053>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
100053>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
100053>>>>>>>//        Move "15.0"             to ColumnType[i].sPrecision
100053>>>>>>>//        Increment i
100053>>>>>>>//
100053>>>>>>>//        Move ePgSQL_TIMESTAMP   to ColumnType[i].iSQLType
100053>>>>>>>//        Move "timestamp"        to ColumnType[i].sSQLType
100053>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
100053>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
100053>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
100053>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
100053>>>>>>>//        Increment i
100053>>>>>>>//
100053>>>>>>>//        Move ePgSQL_UUID        to ColumnType[i].iSQLType
100053>>>>>>>//        Move "uuid"             to ColumnType[i].sSQLType
100053>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
100053>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
100053>>>>>>>//        Move "40"               to ColumnType[i].sPrecision
100053>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
100053>>>>>>>//        Increment i
100053>>>>>>>//
100053>>>>>>>//        Move ePgSQL_VARCHAR     to ColumnType[i].iSQLType
100053>>>>>>>//        Move "varchar"          to ColumnType[i].sSQLType
100053>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
100053>>>>>>>//        Move "DF_TEXT"          to ColumnType[i].sDataFlexType
100053>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
100053>>>>>>>//        Increment i
100053>>>>>>>
100053>>>>>>>        Function_Return aColumnType
100054>>>>>>>    End_Function
100055>>>>>>>
100055>>>>>>>    // Internal usage. Use the UtilColumnTypeXXX functions instead.
100055>>>>>>>    Function _UtilColumnType String sDriverID Integer iDbType Integer iType String sType Boolean bIntegerInputType Returns tColumnType
100057>>>>>>>        Integer iValue iSize iCount iStart
100057>>>>>>>        tColumnType[] ColumnTypeArray
100057>>>>>>>        tColumnType[] ColumnTypeArray
100058>>>>>>>        tColumnType RetvalType
100058>>>>>>>        tColumnType RetvalType
100058>>>>>>>        String sValue
100058>>>>>>>        Boolean bFrameworkDataFlexType
100058>>>>>>>
100058>>>>>>>        Move "Undefined" to RetvalType.sSQLType
100059>>>>>>>        Move -1999       to RetvalType.iSQLType
100060>>>>>>>
100060>>>>>>>        Move 0 to iStart
100061>>>>>>>        Move (Uppercase(sType)) to sType
100062>>>>>>>        Move (iType <= -1490) to bFrameworkDataFlexType
100063>>>>>>>        If (bFrameworkDataFlexType = True) Begin
100065>>>>>>>            Get UtilDUFDataTypeToSqlTypeMapping sDriverID iDbType iType to RetvalType
100066>>>>>>>            Function_Return RetvalType
100067>>>>>>>        End
100067>>>>>>>>
100067>>>>>>>
100067>>>>>>>        Get UtilEnumerateColumnTypes sDriverID iDbType to ColumnTypeArray
100068>>>>>>>
100068>>>>>>>        Move (SizeOfArray(ColumnTypeArray)) to iSize
100069>>>>>>>        Decrement iSize
100070>>>>>>>
100070>>>>>>>        for iCount from iStart to iSize
100076>>>>>>>>
100076>>>>>>>            Move ColumnTypeArray[iCount].iSQLType to iValue
100077>>>>>>>            Move ColumnTypeArray[iCount].sSQLType to sValue
100078>>>>>>>            If (bIntegerInputType = True) Begin
100080>>>>>>>                If (iValue = iType) Begin
100082>>>>>>>                    Move ColumnTypeArray[iCount].sSQLType       to RetvalType.sSQLType
100083>>>>>>>                    Move iType                                  to RetvalType.iSQLType
100084>>>>>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
100085>>>>>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
100086>>>>>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
100087>>>>>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
100088>>>>>>>                    Move iSize to iCount // We're done!
100089>>>>>>>                End
100089>>>>>>>>
100089>>>>>>>            End
100089>>>>>>>>
100089>>>>>>>            Else Begin
100090>>>>>>>                Move (Uppercase(sValue)) to sValue
100091>>>>>>>                If (sValue = sType) Begin
100093>>>>>>>                    Move sType                                  to RetvalType.sSQLType
100094>>>>>>>                    Move ColumnTypeArray[iCount].iSQLType       to RetvalType.iSQLType
100095>>>>>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
100096>>>>>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
100097>>>>>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
100098>>>>>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
100099>>>>>>>                    Move iSize to iCount // We're done!
100100>>>>>>>                End
100100>>>>>>>>
100100>>>>>>>            End
100100>>>>>>>>
100100>>>>>>>        Loop
100101>>>>>>>>
100101>>>>>>>
100101>>>>>>>        // If no match was found it was probably because it was a DataFlex standard type that was passed.
100101>>>>>>>        // In which case we search for a match in DataFlex standard types:
100101>>>>>>>        If (RetvalType.sSQLType = "Undefined") Begin
100103>>>>>>>            Get _UtilEnumerateDataFlexTypes to ColumnTypeArray
100104>>>>>>>            Move (SizeOfArray(ColumnTypeArray)) to iSize
100105>>>>>>>            Decrement iSize
100106>>>>>>>
100106>>>>>>>            for iCount from iStart to iSize
100112>>>>>>>>
100112>>>>>>>                Move ColumnTypeArray[iCount].iSQLType to iValue
100113>>>>>>>                Move ColumnTypeArray[iCount].sSQLType to sValue
100114>>>>>>>                If (iValue = iType) Begin
100116>>>>>>>                    Move ColumnTypeArray[iCount].sSQLType       to RetvalType.sSQLType
100117>>>>>>>                    Move iType                                  to RetvalType.iSQLType
100118>>>>>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
100119>>>>>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
100120>>>>>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
100121>>>>>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
100122>>>>>>>                    Move iSize to iCount // We're done!
100123>>>>>>>                End
100123>>>>>>>>
100123>>>>>>>            Loop
100124>>>>>>>>
100124>>>>>>>        End
100124>>>>>>>>
100124>>>>>>>
100124>>>>>>>        Function_Return RetvalType
100125>>>>>>>    End_Function
100126>>>>>>>
100126>>>>>>>    Function _AllTablesToConvert Returns Integer[]
100128>>>>>>>        Integer[] aTableConvertExceptions iTablesArray
100130>>>>>>>        Handle hTable
100130>>>>>>>        Integer iIndex
100130>>>>>>>        String sTableName
100130>>>>>>>        Boolean bFlexErrs
100130>>>>>>>
100130>>>>>>>        // a) Get the exception table array the developer has specified
100130>>>>>>>        Get paTableConvertExceptions to aTableConvertExceptions
100131>>>>>>>
100131>>>>>>>        // b) Add CodeMast, CodeType & DbVersion to exceptions
100131>>>>>>>        Repeat
100131>>>>>>>>
100131>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
100134>>>>>>>            If (hTable <> 0) Begin
100136>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
100139>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
100140>>>>>>>                If (bFlexErrs = False) Begin
100142>>>>>>>                    If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE" or Uppercase(sTableName) = "DBVERSION") Begin
100144>>>>>>>                        Move (SearchArray(hTable, aTableConvertExceptions)) to iIndex
100145>>>>>>>                        If (iIndex = -1) Begin
100147>>>>>>>                            Move hTable to aTableConvertExceptions[SizeOfArray(aTableConvertExceptions)]
100148>>>>>>>                        End
100148>>>>>>>>
100148>>>>>>>                    End
100148>>>>>>>>
100148>>>>>>>                End
100148>>>>>>>>
100148>>>>>>>            End
100148>>>>>>>>
100148>>>>>>>        Until (hTable = 0)
100150>>>>>>>
100150>>>>>>>        Move 0 to hTable
100151>>>>>>>
100151>>>>>>>        // c) Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
100151>>>>>>>        Repeat
100151>>>>>>>>
100151>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
100154>>>>>>>            If (hTable > 0) Begin
100156>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
100159>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
100160>>>>>>>                If (bFlexErrs = False) Begin
100162>>>>>>>                    Move (SearchArray(hTable, aTableConvertExceptions)) to iIndex
100163>>>>>>>                    If (iIndex = -1) Begin
100165>>>>>>>                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
100166>>>>>>>                    End
100166>>>>>>>>
100166>>>>>>>                End
100166>>>>>>>>
100166>>>>>>>            End
100166>>>>>>>>
100166>>>>>>>        Until (hTable = 0)
100168>>>>>>>
100168>>>>>>>        Function_Return iTablesArray
100169>>>>>>>    End_Function
100170>>>>>>>
100170>>>>>>>    Function _AllTablesDateCorrections Returns Integer[]
100172>>>>>>>        Integer[] aTableDateCorrectionExceptions iTablesArray
100174>>>>>>>        Handle hTable
100174>>>>>>>        Integer iIndex
100174>>>>>>>        String sTableName
100174>>>>>>>        Boolean bFlexErrs
100174>>>>>>>
100174>>>>>>>        Get paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
100175>>>>>>>        Move 0 to hTable
100176>>>>>>>
100176>>>>>>>        // Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
100176>>>>>>>        Repeat
100176>>>>>>>>
100176>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
100179>>>>>>>            If (hTable > 0) Begin
100181>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
100184>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
100185>>>>>>>                If (bFlexErrs = False) Begin
100187>>>>>>>                    Move (SearchArray(hTable, aTableDateCorrectionExceptions)) to iIndex
100188>>>>>>>                    If (iIndex = -1) Begin
100190>>>>>>>                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
100191>>>>>>>                    End
100191>>>>>>>>
100191>>>>>>>                End
100191>>>>>>>>
100191>>>>>>>            End
100191>>>>>>>>
100191>>>>>>>        Until (hTable = 0)
100193>>>>>>>
100193>>>>>>>        Function_Return iTablesArray
100194>>>>>>>    End_Function
100195>>>>>>>
100195>>>>>>>    Function _AppendAPIColumn tAPIColumn[] aCurrent String sFieldName Integer iType Integer iLength Integer iPrecision Integer iOptions Returns tAPIColumn[]
100197>>>>>>>        tAPIColumn NewAPIColumn
100197>>>>>>>        tAPIColumn NewAPIColumn
100197>>>>>>>
100197>>>>>>>        Move sFieldName to NewAPIColumn.sFieldName
100198>>>>>>>        Move iType      to NewAPIColumn.iType
100199>>>>>>>        Move iLength    to NewAPIColumn.iLength
100200>>>>>>>        Move iPrecision to NewAPIColumn.iPrecision
100201>>>>>>>        Move iOptions   to NewAPIColumn.iOptions
100202>>>>>>>
100202>>>>>>>        Move NewAPIColumn to aCurrent[SizeOfArray(aCurrent)]
100203>>>>>>>
100203>>>>>>>        Function_Return aCurrent
100204>>>>>>>    End_Function
100205>>>>>>>
100205>>>>>>>    Function _UtilIndexAppendSegmentFieldNames tAPIIndexSegment[] APIIndexSegment Returns String
100207>>>>>>>        String sRetval sFieldName
100207>>>>>>>        Integer iCount iSize
100207>>>>>>>
100207>>>>>>>        Move (SizeOfArray(APIIndexSegment)) to iSize
100208>>>>>>>        Decrement iSize
100209>>>>>>>        for iCount from 0 to iSize
100215>>>>>>>>
100215>>>>>>>            Move APIIndexSegment[iCount].sFieldName to sFieldName
100216>>>>>>>            Move (sRetval * (String(sFieldName))) to sRetval
100217>>>>>>>        Loop
100218>>>>>>>>
100218>>>>>>>        Move (Trim(sRetval)) to sRetval
100219>>>>>>>
100219>>>>>>>        Function_Return sRetval
100220>>>>>>>    End_Function
100221>>>>>>>
100221>>>>>>>    // *** Miscellaneous other functions ***
100221>>>>>>>    // Some of which can be used by both "Sqlxxx" and "Apixxx" functions.
100221>>>>>>>    //
100221>>>>>>>
100221>>>>>>>    // Callback functionality used when e.g. calling driver functions directly.
100221>>>>>>>    Function Callback String sCallback_Text Integer iCallback_Type Returns Integer
100223>>>>>>>        Integer iPerc
100223>>>>>>>        Number nReady nTotal
100223>>>>>>>
100223>>>>>>>        Send DoAdvance of ghoProgressBar
100224>>>>>>>
100224>>>>>>>        If (sCallback_Text contains "Copy records") Begin
100226>>>>>>>            Move CS_DUF_CopyingData to sCallback_Text
100227>>>>>>>        End
100227>>>>>>>>
100227>>>>>>>        If (sCallback_Text contains "Dropping index" or sCallback_Text contains "Temporary delete of all indices of table") Begin
100229>>>>>>>            Move (Replace("Dropping index", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
100230>>>>>>>            Move (Replace("Temporary delete of all indices of table", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
100231>>>>>>>        End
100231>>>>>>>>
100231>>>>>>>        If (sCallback_Text contains "Creating index") Begin
100233>>>>>>>            Move (Replace("Creating index", sCallback_Text, CS_DUF_CreatingIndex)) to sCallback_Text
100234>>>>>>>        End
100234>>>>>>>>
100234>>>>>>>
100234>>>>>>>        Case Begin
100234>>>>>>>            Case (iCallback_Type = DF_Message_Text)
100236>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
100237>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
100238>>>>>>>                Case Break
100239>>>>>>>            Case (iCallback_Type = DF_Message_Heading_1)
100242>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
100243>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
100244>>>>>>>                Case Break
100245>>>>>>>            Case (iCallback_Type = DF_Message_Heading_2)
100248>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
100249>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
100250>>>>>>>                Case Break
100251>>>>>>>            Case (iCallback_Type = DF_Message_Heading_3)
100254>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
100255>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
100256>>>>>>>                Case Break
100257>>>>>>>            Case (iCallback_Type = DF_Message_Heading_4)
100260>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
100261>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
100262>>>>>>>                Case Break
100263>>>>>>>            Case (iCallback_Type = DF_Message_Heading_5)
100266>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
100267>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
100268>>>>>>>                Case Break
100269>>>>>>>            Case (iCallback_Type = DF_Message_Warning)
100272>>>>>>>                Send None
100273>>>>>>>                Case Break
100274>>>>>>>            Case (iCallback_Type = DF_Message_Progress_Title)
100277>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
100278>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
100279>>>>>>>                Case Break
100280>>>>>>>            Case (iCallback_Type = DF_Message_Progress_Value)
100283>>>>>>>                //*** Interpret numbers
100283>>>>>>>                Move (Left(sCallback_Text, (Pos(",", sCallback_Text) - 1)))                       to nReady
100284>>>>>>>                Move (Right(sCallback_Text, (Length(sCallback_Text) - Pos(",", sCallback_Text)))) to nTotal
100285>>>>>>>                Move ((nReady / nTotal) * 100)                                                    to iPerc
100286>>>>>>>                Set Action_Text of ghoStatusPanel to (String(iPerc) * String("% Done (Total Number of Records:") * String(nTotal) + ")")
100287>>>>>>>                Case Break
100288>>>>>>>            Case Else
100288>>>>>>>                Set Message_Text to ""
100289>>>>>>>                Set Action_Text  to ""
100290>>>>>>>        Case End
100290>>>>>>>
100290>>>>>>>        Send ProcessEvents of ghoStatusPanel
100291>>>>>>>        Function_Return False
100292>>>>>>>    End_Function
100293>>>>>>>
100293>>>>>>>    Procedure IncreaseSortBufferSize
100295>>>>>>>        String sNull
100295>>>>>>>        Integer iSortBufferSize
100295>>>>>>>        Boolean bBufferSet
100295>>>>>>>
100295>>>>>>>        Move "" to sNull
100296>>>>>>>        Move (1024 * 128) to iSortBufferSize
100297>>>>>>>        Call_Driver 0 DATAFLEX_ID Function FLEX_SET_MAX_SORT_BUFFER Callback ghoDbUpdateHandler Passing sNull sNull iSortBufferSize Result bBufferSet
100302>>>>>>>
100302>>>>>>>    End_Procedure
100303>>>>>>>
100303>>>>>>>    Procedure SetAllIndexesToBatch Handle hTable Boolean bSetToBatch
100305>>>>>>>        Integer iLastIndex iIndex iNumSegments
100305>>>>>>>        Boolean bOK
100305>>>>>>>        String sDriverID
100305>>>>>>>
100305>>>>>>>        If (hTable > 0) Begin
100307>>>>>>>            Get UtilDriverFromTableNumber hTable to sDriverID
100308>>>>>>>            Close hTable
100309>>>>>>>            Get OpenTableExclusive hTable to bOK
100310>>>>>>>            If (bOK = False) Begin
100312>>>>>>>                Procedure_Return
100313>>>>>>>            End
100313>>>>>>>>
100313>>>>>>>            Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
100316>>>>>>>            Structure_Start hTable sDriverID
100317>>>>>>>                for iIndex from 1 to iLastIndex
100323>>>>>>>>
100323>>>>>>>                    Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
100326>>>>>>>                    If (iNumSegments > 0) Begin
100328>>>>>>>                        If (bSetToBatch = True) Begin
100330>>>>>>>                            Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_BATCH
100333>>>>>>>                        End
100333>>>>>>>>
100333>>>>>>>                        Else Begin
100334>>>>>>>                            Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_ONLINE
100337>>>>>>>                        End
100337>>>>>>>>
100337>>>>>>>                    End
100337>>>>>>>>
100337>>>>>>>                Loop
100338>>>>>>>>
100338>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
100340>>>>>>>        End
100340>>>>>>>>
100340>>>>>>>    End_Procedure
100341>>>>>>>
100341>>>>>>>    Function NextFreeFilelistSlot Returns Handle
100343>>>>>>>        Handle hTable
100343>>>>>>>
100343>>>>>>>        Move 0 to hTable
100344>>>>>>>        Get_Attribute DF_FILE_NEXT_EMPTY of hTable to hTable
100347>>>>>>>
100347>>>>>>>        Function_Return hTable
100348>>>>>>>    End_Function
100349>>>>>>>
100349>>>>>>>    // For debugging purposes. To print Sql statements as they are build...
100349>>>>>>>    Procedure DebugPrint String sStmt String sFileName
100351>>>>>>>        Integer iCh
100351>>>>>>>        Get Seq_Append_Output_Channel sFileName to iCh
100352>>>>>>>            Write channel iCh sStmt
100354>>>>>>>        Send Seq_Close_Channel iCh
100355>>>>>>>    End_Procedure
100356>>>>>>>
100356>>>>>>>    // Returns the integer number for the passed Driver ID that is
100356>>>>>>>    // needed by some database API calls.
100356>>>>>>>    Function DriverIndex String sDriverID Returns Integer
100358>>>>>>>        String  sCurrentDriver
100358>>>>>>>        Integer iNumberOfDrivers iDriver iCount
100358>>>>>>>
100358>>>>>>>        Move 0 to iDriver
100359>>>>>>>
100359>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
100362>>>>>>>        for iCount from 1 to iNumberOfDrivers
100368>>>>>>>>
100368>>>>>>>
100368>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
100371>>>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
100373>>>>>>>                Move iCount to iDriver
100374>>>>>>>            End
100374>>>>>>>>
100374>>>>>>>        Loop
100375>>>>>>>>
100375>>>>>>>
100375>>>>>>>        // In case it was not found, it wasn't loaded so we do that now.
100375>>>>>>>        If (iDriver = 0) Begin
100377>>>>>>>            Move False to Err
100378>>>>>>>            Load_Driver sDriverID
100379>>>>>>>            If (Err = False) Begin
100381>>>>>>>                Get_Attribute DF_NUMBER_DRIVERS to iDriver
100384>>>>>>>            End
100384>>>>>>>>
100384>>>>>>>        End
100384>>>>>>>>
100384>>>>>>>
100384>>>>>>>        Function_Return iDriver
100385>>>>>>>    End_Function
100386>>>>>>>
100386>>>>>>>    
100386>>>>>>>    Function MinMSSQLDRV_And_ClientVersion String sMSSQLDRVVersion Integer iClientVersion Boolean bShowErrorDialog Boolean bExitProgram Returns String
100388>>>>>>>        String sDriverID sVersion sClient sClientLowest sRetval
100388>>>>>>>        Integer iNumberOfDrivers iDriver iClient
100388>>>>>>>        Handle hoCLIHandler hoMSSQLHandler   
100388>>>>>>>        Boolean bOK
100388>>>>>>>        
100388>>>>>>>        Move "" to sRetval
100389>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLIHandler
100390>>>>>>>        Get Create (RefClass(cMSSQLHandler)) to hoMSSQLHandler
100391>>>>>>>        Load_Driver MSSQLDRV_ID
100392>>>>>>>
100392>>>>>>>        // Loop through all loaded drivers.
100392>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
100395>>>>>>>        For iDriver from 1 to iNumberOfDrivers
100401>>>>>>>>
100401>>>>>>>            Get_Attribute DF_DRIVER_NAME of iDriver to sDriverID
100404>>>>>>>            If (sDriverID = MSSQLDRV_ID) Begin
100406>>>>>>>                Set psDriverID of hoCLIHandler to sDriverID
100407>>>>>>>                Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClient   
100410>>>>>>>                Get SqlServerClientVersionName of hoMSSQLHandler iClientVersion to sClientLowest 
100411>>>>>>>                Get SqlServerClientVersionName of hoMSSQLHandler iClient to sClient 
100412>>>>>>>                Get CKRevision of hoCLIHandler to sVersion
100413>>>>>>>                Move (SFormat (String(C_$DatabaseDriver), (sDriverID * "-" * (String(C_$Version) + ": " + String(sVersion))))) to sRetval
100414>>>>>>>                If (sClient <> "" and sRetval <> "") Begin
100416>>>>>>>                    Move (String(sRetval) + "\n" + String(C_$SQL_Client_Text) + "\n" + Trim(sClient)) to sRetval
100417>>>>>>>                End                                
100417>>>>>>>>
100417>>>>>>>                Else Begin
100418>>>>>>>                    Move (String(C_$SQL_Client_Text) + "\n" + Trim(sClient) * "(" + String(iClient) + ")") to sRetval
100419>>>>>>>                End
100419>>>>>>>>
100419>>>>>>>            End
100419>>>>>>>>
100419>>>>>>>        Loop
100420>>>>>>>>
100420>>>>>>>        Send Destroy of hoCLIHandler  
100421>>>>>>>        Send Destroy of hoMSSQLHandler  
100422>>>>>>>        If (bShowErrorDialog = True) Begin
100424>>>>>>>            Get IsFirstStringGreaterThanSecond sVersion sMSSQLDRVVersion to bOK
100425>>>>>>>            If (bOK = False or (iClient < iClientVersion)) Begin
100427>>>>>>>                Move (MSSQLDRV_ID + ".dll" * String(C_$SQL_Driver_Version_Min_Text) *  String(sMSSQLDRVVersion) + String("\n") + String(C_$SQL_Client_Version_Min_Text) + "\n" + String(sClientLowest) + String("\n\n") + String(C_$SQL_Versions_Are_Text) + String("\n") + String(sRetval)) to sRetval
100428>>>>>>>                If (bExitProgram = True) Begin
100430>>>>>>>                    Move (String(sRetval) + String("\n\n") + String(C_$PleaseAdjustTxt) * String(C_$ProgramWillExit_Text)) to sRetval
100431>>>>>>>                End
100431>>>>>>>>
100431>>>>>>>                Send Stop_Box sRetval  
100432>>>>>>>                If (bExitProgram = True) Begin
100434>>>>>>>                    Send Exit_Application
100435>>>>>>>                End
100435>>>>>>>>
100435>>>>>>>            End
100435>>>>>>>>
100435>>>>>>>        End
100435>>>>>>>>
100435>>>>>>>        
100435>>>>>>>        Function_Return sRetval
100436>>>>>>>    End_Function  
100437>>>>>>>    
100437>>>>>>>    // Returns True if first "." separated string is greater than the second.
100437>>>>>>>    // It checks from left to right, one part of the string at a time.
100437>>>>>>>    // E.g. if sVersion="20.1.31.10 and sSQLVersion="6.3.0.13" the function would return TRUE.
100437>>>>>>>    Function IsFirstStringGreaterThanSecond Global String sVersion String sSQLVersion Returns Boolean
100439>>>>>>>        String[] asVersion asSQLVersion          
100441>>>>>>>        Integer iSize iCount iVersion iSQLVersion
100441>>>>>>>        
100441>>>>>>>        Move (StrSplitToArray(sVersion, "."))    to asVersion
100442>>>>>>>        Move (StrSplitToArray(sSQLVersion, ".")) to asSQLVersion
100443>>>>>>>        Move (SizeOfArray(asVersion)) to iSize
100444>>>>>>>        // Make sure the two arrays are of the same size:
100444>>>>>>>        If (SizeOfArray(asSQLVersion) < iSize) Begin
100446>>>>>>>            Move (ResizeArray(asSQLVersion, iSize, 0)) to asSQLVersion
100447>>>>>>>        End
100447>>>>>>>>
100447>>>>>>>        Decrement iSize
100448>>>>>>>        for iCount from 0 to iSize
100454>>>>>>>>
100454>>>>>>>            Move asVersion[iCount]    to iVersion
100455>>>>>>>            Move asSQLVersion[iCount] to iSQLVersion
100456>>>>>>>            CompilerWarnings Off
100456>>>>>>>            If (iVersion > iSQLVersion) Break
100459>>>>>>>            CompilerWarnings On
100459>>>>>>>        Loop
100460>>>>>>>>
100460>>>>>>>        
100460>>>>>>>        Function_Return (iVersion > iSQLVersion)
100461>>>>>>>    End_Function
100462>>>>>>>
100462>>>>>>>    // Returns TRUE if table is opened exclusive, otherwise FALSE
100462>>>>>>>    // Note: If run from the Studio, CodeMast & CodeType _is_ open by the Studio,
100462>>>>>>>    //       so in that case we "cheat" and report those tables were opened OK.
100462>>>>>>>    Function OpenTableExclusive Handle hTable Returns Boolean
100464>>>>>>>        Integer iMode
100464>>>>>>>        Boolean bOpened
100464>>>>>>>        String sTableName
100464>>>>>>>
100464>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
100465>>>>>>>        // Can't open a table properly if run through the Debugger/Studio,
100465>>>>>>>        // so we generate an error here:
100465>>>>>>>        If (IsDebuggerPresent()) Begin
100467>>>>>>>            Error DFERR_OPERATOR "It is not possible to make structural changes to the database when running through the Debugger/Studio"
100468>>>>>>>>
100468>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
100469>>>>>>>            Function_Return False
100470>>>>>>>        End
100470>>>>>>>>
100470>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
100473>>>>>>>        If (bOpened) Begin
100475>>>>>>>            If (IsDebuggerPresent()) Begin
100477>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
100480>>>>>>>                If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE") Begin
100482>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
100483>>>>>>>                    Function_Return True
100484>>>>>>>                End
100484>>>>>>>>
100484>>>>>>>            End
100484>>>>>>>>
100484>>>>>>>            Get_Attribute DF_FILE_OPEN_MODE of hTable to iMode
100487>>>>>>>            If (iMode=DF_EXCLUSIVE) Begin
100489>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
100490>>>>>>>                Function_Return True
100491>>>>>>>            End
100491>>>>>>>>
100491>>>>>>>            Close hTable
100492>>>>>>>        End
100492>>>>>>>>
100492>>>>>>>        Else Begin
100493>>>>>>>            Open hTable
100495>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpened
100498>>>>>>>            If (bOpened and IsDebuggerPresent()) Begin
100500>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
100503>>>>>>>                If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE") Begin
100505>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
100506>>>>>>>                    Function_Return True
100507>>>>>>>                End
100507>>>>>>>>
100507>>>>>>>            End
100507>>>>>>>>
100507>>>>>>>
100507>>>>>>>        End
100507>>>>>>>>
100507>>>>>>>
100507>>>>>>>        Close hTable
100508>>>>>>>        Open hTable Mode DF_EXCLUSIVE
100510>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
100513>>>>>>>
100513>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
100514>>>>>>>        Function_Return bOpened
100515>>>>>>>    End_Function
100516>>>>>>>
100516>>>>>>>    Function AutoConnectionIDLogin Returns Boolean
100518>>>>>>>        String sConnectionID sConnectionString sDriverID
100518>>>>>>>        Boolean bExists bOK bSQLDriver bMertech
100518>>>>>>>        Handle hoCLI hoDriver
100518>>>>>>>        Integer iRetval
100518>>>>>>>        tSQLConnection SQLConnection
100518>>>>>>>        tSQLConnection SQLConnection
100518>>>>>>>
100518>>>>>>>        Get psDriverID to sDriverID
100519>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
100520>>>>>>>        If (bSQLDriver = False) Begin
100522>>>>>>>            Function_Return True
100523>>>>>>>        End
100523>>>>>>>>
100523>>>>>>>
100523>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
100524>>>>>>>        Move SQLConnection.sDriverID                  to sDriverID
100525>>>>>>>        Move SQLConnection.sConnectionString          to sConnectionString
100526>>>>>>>        Get IsMertechDriver sDriverID to bMertech
100527>>>>>>>        If (bMertech = True) Begin
100529>>>>>>>            Get _MertechSQLManagerHandle to hoCLI
100530>>>>>>>            Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
100531>>>>>>>            Set psDriverID of hoDriver to SQLConnection.sDriverID
100532>>>>>>>            Get DbLogin  of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
100533>>>>>>>            Send Destroy of hoDriver
100534>>>>>>>            Function_Return bOK
100535>>>>>>>        End
100535>>>>>>>>
100535>>>>>>>
100535>>>>>>>        Move SQLConnection.sConnectionID to sConnectionID
100536>>>>>>>
100536>>>>>>>        Get IsConnectionID sConnectionID sDriverID to bExists
100537>>>>>>>        If (bExists = False) Begin
100539>>>>>>>            // We always start by deleting the current connection - if any - because the
100539>>>>>>>            // login details my have changed.
100539>>>>>>>            Get phoCLIHandler to hoCLI
100540>>>>>>>            Set psDriverID    of hoCLI to sDriverID
100541>>>>>>>            Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
100542>>>>>>>            Get AutoSetConnectionID sConnectionID to bOk
100543>>>>>>>            If (bOk = False) Begin
100545>>>>>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be changed.")
100546>>>>>>>>
100546>>>>>>>                Function_Return False
100547>>>>>>>            End
100547>>>>>>>>
100547>>>>>>>            Move bOK to bExists
100548>>>>>>>        End
100548>>>>>>>>
100548>>>>>>>
100548>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
100549>>>>>>>        Set psDriverID of hoDriver to SQLConnection.sDriverID
100550>>>>>>>        Get DbLogin of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
100551>>>>>>>        Send Destroy of hoDriver
100552>>>>>>>
100552>>>>>>>        Function_Return (bExists = True)
100553>>>>>>>    End_Function
100554>>>>>>>
100554>>>>>>>    // Scans to see if all tables can be opened exclusivly. I.e. that nobody else is running the application.
100554>>>>>>>    // Returns: False if nobody else is running
100554>>>>>>>    //          True if at least one table is open by another process (e.g. another user is running the application)
100554>>>>>>>    // N.B! Only works for Embedded DataFlex Tables! It will _not_ work for Sql tables because; these
100554>>>>>>>    //      tables are not locked as DataFlex tables are.
100554>>>>>>>    Function IsDatabaseInUse Returns Boolean
100556>>>>>>>        Handle  hTable
100556>>>>>>>        String  sRootName
100556>>>>>>>        Boolean bOpen bErr bAlias bOK bIsSQLTable bFlexErrs bExists
100556>>>>>>>        Integer iCount iTables
100556>>>>>>>
100556>>>>>>>        Move 0 to iTables
100557>>>>>>>        Set Action_Text of ghoStatusPanel to "Database in use check..."
100558>>>>>>>        Get AutoConnectionIDLogin to bOK
100559>>>>>>>        Get UtilFilelistNoOfTables to iTables
100560>>>>>>>        Set piPosition   of ghoProgressBar to 0
100561>>>>>>>        Set piAdvanceBy  of ghoProgressBar to 1
100562>>>>>>>        Set piMaximum    of ghoProgressBar to iTables
100563>>>>>>>        Move 0 to hTable
100564>>>>>>>        Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
100567>>>>>>>        Move False to bErr
100568>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
100569>>>>>>>
100569>>>>>>>        Repeat
100569>>>>>>>>
100569>>>>>>>            Set piPosition of ghoProgressBar to iCount
100570>>>>>>>            Increment iCount
100571>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
100574>>>>>>>            Move (Uppercase(sRootName) = "FLEXERRS")  to bFlexErrs
100575>>>>>>>
100575>>>>>>>            // This test is only applicable for DataFlex embedded tables; so skip test if driver based table.
100575>>>>>>>            Get UtilTableIsSQLByRootName sRootName to bIsSQLTable
100576>>>>>>>            Move False to bOpen
100577>>>>>>>            Get UtilTableExists hTable to bExists
100578>>>>>>>            // Don't bother about CodeType (253, CodeMast (254) or) FlexErrs (Normally table 50)
100578>>>>>>>            If (bIsSQLTable = False and bExists = True and hTable <> 0 and hTable <> 253 and hTable <> 254 and bFlexErrs = False) Begin
100580>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
100581>>>>>>>                Open hTable
100583>>>>>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
100586>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
100587>>>>>>>                If (bOpen = True) Begin
100589>>>>>>>                    // We cannot open an Alias file exclusive as it will generate an error (4177 - "File in use")
100589>>>>>>>                    Get UtilTableIsAlias hTable to bAlias
100590>>>>>>>                    If (bAlias = False) Begin
100592>>>>>>>                        Close hTable
100593>>>>>>>                        Get OpenTableExclusive hTable to bOpen
100594>>>>>>>                        If (bOpen = False) Begin
100596>>>>>>>                            Move True to bErr
100597>>>>>>>                        End
100597>>>>>>>>
100597>>>>>>>                    End
100597>>>>>>>>
100597>>>>>>>                End
100597>>>>>>>>
100597>>>>>>>                Close hTable
100598>>>>>>>            End
100598>>>>>>>>
100598>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
100601>>>>>>>            If (bErr = True ) ;                Break
100604>>>>>>>        Until (not(hTable))
100606>>>>>>>
100606>>>>>>>        Set Action_Text of ghoStatusPanel to ""
100607>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
100608>>>>>>>        Move False to Err
100609>>>>>>>
100609>>>>>>>        Function_Return bErr
100610>>>>>>>    End_Function
100611>>>>>>>
100611>>>>>>>    // Checks if the passed connection id exists in the CLI interface.
100611>>>>>>>    // This might be needed by API-methods when a connection id is to be used and
100611>>>>>>>    // the connection id hasn't been established with the driver's CLI interface.
100611>>>>>>>    // NOTE: Only applicable for DAW drivers.
100611>>>>>>>    Function IsConnectionID String sConnectionID String sDriverID Returns Boolean
100613>>>>>>>        String sID sConnString
100613>>>>>>>        Integer iDriver iNumConn iCount
100613>>>>>>>        Handle hoCLI
100613>>>>>>>        Boolean bOK
100613>>>>>>>
100613>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
100614>>>>>>>        If (bOK = False) Begin
100616>>>>>>>            Error DFERR_PROGRAM "Connection ID's can only be used with DAW drivers (not Mertech)."
100617>>>>>>>>
100617>>>>>>>            Function_Return False
100618>>>>>>>        End
100618>>>>>>>>
100618>>>>>>>
100618>>>>>>>        Move False to bOK
100619>>>>>>>        Get phoCLIHandler to hoCLI
100620>>>>>>>        If (hoCLI <> 0) Begin
100622>>>>>>>            Set psDriverID of hoCLI to sDriverID
100623>>>>>>>            Get DriverIndex of hoCLI sDriverID to iDriver
100624>>>>>>>
100624>>>>>>>            // If driver not loaded; load it.
100624>>>>>>>            If (iDriver = 0) Begin
100626>>>>>>>                Load_Driver sDriverID
100627>>>>>>>                Get DriverIndex sDriverID to iDriver
100628>>>>>>>            End
100628>>>>>>>>
100628>>>>>>>            If (iDriver <> 0) Begin
100630>>>>>>>                Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
100633>>>>>>>                Decrement iNumConn
100634>>>>>>>                for iCount from 0 to iNumConn
100640>>>>>>>>
100640>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iCount to sConnString
100643>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iCount to sID
100646>>>>>>>                    If (sID = sConnectionID) Begin
100648>>>>>>>                        Move True to bOK
100649>>>>>>>                    End
100649>>>>>>>>
100649>>>>>>>                Loop
100650>>>>>>>>
100650>>>>>>>            End
100650>>>>>>>>
100650>>>>>>>        End
100650>>>>>>>>
100650>>>>>>>
100650>>>>>>>        Function_Return bOK
100651>>>>>>>    End_Function
100652>>>>>>>
100652>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
100654>>>>>>>        Boolean bOK
100654>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID or sDriverID = DFBTRDRV_ID) to bOK
100655>>>>>>>        Function_Return bOK
100656>>>>>>>    End_Function
100657>>>>>>>
100657>>>>>>>    Function IsMertechDriver String sDriverID Returns Boolean
100659>>>>>>>        Boolean bOK
100659>>>>>>>        Move False to bOK
100660>>>>>>>        Move (sDriverID = SQLFLEX or sDriverID = ORAFLEX or sDriverID = MDSPgSQL or sDriverID = MDSMySQL) to bOK
100661>>>>>>>        Function_Return bOK
100662>>>>>>>    End_Function
100663>>>>>>>
100663>>>>>>>    Function IsMSSQLDriver Returns Boolean
100665>>>>>>>        Integer iDriverIndex
100665>>>>>>>
100665>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriverIndex
100666>>>>>>>
100666>>>>>>>        Function_Return (iDriverIndex <> 0)
100667>>>>>>>    End_Function
100668>>>>>>>
100668>>>>>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
100668>>>>>>>    // attempt to load the driver.
100668>>>>>>>    // Returns true if the passed driver is SQL based.
100668>>>>>>>    Function IsSQLDriver String sDriverID Returns Boolean
100670>>>>>>>        Boolean bOK
100670>>>>>>>
100670>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
100671>>>>>>>
100671>>>>>>>        If (bOK = False) Begin
100673>>>>>>>            Get IsMertechDriver sDriverID to bOK
100674>>>>>>>        End
100674>>>>>>>>
100674>>>>>>>
100674>>>>>>>        Function_Return bOK
100675>>>>>>>    End_Function
100676>>>>>>>
100676>>>>>>>    // *** Error Handler ***
100676>>>>>>>    //
100676>>>>>>>    // Note: If the cDbUpdateHandler & cDbUpdateVersion classes are used this error handler is _not_
100676>>>>>>>    //       used. Instead the Error_Report in the cDbUpdateHandler i used.
100676>>>>>>>    Procedure Error_Report Integer iErrorNumber Integer iErrorLine String sErrorText
100678>>>>>>>        Integer iSize iErrorMode
100678>>>>>>>        tSqlErrorArray aSqlErrorArray
100678>>>>>>>        tSqlErrorArray aSqlErrorArray
100678>>>>>>>
100678>>>>>>>        If (pbProcessingError(Self)) Begin
100680>>>>>>>            Procedure_Return
100681>>>>>>>        End
100681>>>>>>>>
100681>>>>>>>
100681>>>>>>>        Get Error_Report_Mode to iErrorMode
100682>>>>>>>        If (iErrorMode = DUF_ERROR_NO_REPORT) Begin
100684>>>>>>>            Procedure_Return
100685>>>>>>>        End
100685>>>>>>>>
100685>>>>>>>
100685>>>>>>>        Set pbProcessingError to True
100686>>>>>>>        Set pbSqlError to True
100687>>>>>>>        Get paSqlErrorArray      to aSqlErrorArray
100688>>>>>>>        Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iSize
100689>>>>>>>        Move sErrorText          to aSqlErrorArray.sSqlErrorArray[iSize]
100690>>>>>>>        Get psSQLStatementString to aSqlErrorArray.sSqlStatementArray[iSize]
100691>>>>>>>        Move iErrorNumber        to aSqlErrorArray.iSqlErrorArray[iSize]
100692>>>>>>>        Set paSqlErrorArray      to aSqlErrorArray
100693>>>>>>>        Set pbProcessingError to False
100694>>>>>>>    End_Procedure
100695>>>>>>>
100695>>>>>>>    // *** Miscellanous Helper Functions ***
100695>>>>>>>    //
100695>>>>>>>    // Helper function. Takes a DF_FILE_XXXX_NAME value as parameter and
100695>>>>>>>    // returns the table name only; stripped of any path or filename extension.
100695>>>>>>>    Function _TableNameOnly String sName Returns String
100697>>>>>>>        String sPath sExt
100697>>>>>>>
100697>>>>>>>        Get ParseFolderName sName to sPath
100698>>>>>>>        If (sPath <> "") Begin
100700>>>>>>>            Move (Replace(sPath, sName, "")) to sName
100701>>>>>>>        End
100701>>>>>>>>
100701>>>>>>>        Get ParseFileExtension sName to sExt
100702>>>>>>>        If (sExt <> "") Begin
100704>>>>>>>            Move (Replace(("." + sExt), sName, "")) to sName
100705>>>>>>>        End
100705>>>>>>>>
100705>>>>>>>
100705>>>>>>>        Function_Return sName
100706>>>>>>>    End_Function
100707>>>>>>>
100707>>>>>>>    // Removes any prefix to a table name.
100707>>>>>>>    // Example mssqldrv:mytable returns mytable
100707>>>>>>>    //         dbo.mytable returns mytable
100707>>>>>>>    Function _TableNoPrefix String sName Returns String
100709>>>>>>>        Integer iPos
100709>>>>>>>
100709>>>>>>>        Move (Pos(":", sName)) to iPos
100710>>>>>>>        If (iPos <> 0) Begin
100712>>>>>>>            Move (Mid(sName, 999, (iPos + 1))) to sName
100713>>>>>>>        End
100713>>>>>>>>
100713>>>>>>>        Move (Pos(".", sName)) to iPos
100714>>>>>>>        If (iPos <> 0) Begin
100716>>>>>>>            Move (Mid(sName, 999, (iPos + 1))) to sName
100717>>>>>>>        End
100717>>>>>>>>
100717>>>>>>>
100717>>>>>>>        Function_Return sName
100718>>>>>>>    End_Function
100719>>>>>>>
100719>>>>>>>    // Returns the first datapath found in the psDataPath property.
100719>>>>>>>    // The returned path always ends with a "\"
100719>>>>>>>    Function psDataPathFirstPart Returns String
100721>>>>>>>        String sDataPath
100721>>>>>>>        Integer iCount
100721>>>>>>>
100721>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
100722>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
100723>>>>>>>        If (iCount > 1) Begin
100725>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
100726>>>>>>>        End
100726>>>>>>>>
100726>>>>>>>        If (sDataPath <> "") Begin
100728>>>>>>>            Get vFolderFormat sDataPath to sDataPath
100729>>>>>>>        End
100729>>>>>>>>
100729>>>>>>>
100729>>>>>>>        Function_Return sDataPath
100730>>>>>>>    End_Function
100731>>>>>>>
100731>>>>>>>    Function psLogTextFileWithPath Returns String
100733>>>>>>>        String sFileName
100733>>>>>>>        Handle hoLogFile
100733>>>>>>>        Get phoLogFile to hoLogFile
100734>>>>>>>        Get psLogTextFileWithPath of hoLogFile to sFileName
100735>>>>>>>        Function_Return sFileName
100736>>>>>>>    End_Function
100737>>>>>>>
100737>>>>>>>    // *** Property Messages ***
100737>>>>>>>    //
100737>>>>>>>    // These "properties" are settings for the cSQLConnectionHandler class, but have been
100737>>>>>>>    // "duplicated" here so connection properties can be relayed to the ghoSQLConnectionHandler object
100737>>>>>>>    //
100737>>>>>>>
100737>>>>>>>    Function pSQLConnection Returns tSQLConnection
100739>>>>>>>        tSQLConnection SQLConnection
100739>>>>>>>        tSQLConnection SQLConnection
100739>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100741>>>>>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
100741>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100742>>>>>>>>
100742>>>>>>>            Function_Return
100743>>>>>>>        End
100743>>>>>>>>
100743>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
100744>>>>>>>        Function_Return SQLConnection
100745>>>>>>>    End_Function
100746>>>>>>>
100746>>>>>>>    // * Dummy function for the Studio's Code Explorer *
100746>>>>>>>    Function OTHER_CLASS_PROPERTIES Returns Boolean
100748>>>>>>>        Function_Return False
100749>>>>>>>    End_Function
100750>>>>>>>
100750>>>>>>>    Procedure Set psServer String sValue
100752>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100754>>>>>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
100754>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100755>>>>>>>>
100755>>>>>>>            Procedure_Return
100756>>>>>>>        End
100756>>>>>>>>
100756>>>>>>>        Set psServer of ghoSQLConnectionHandler to sValue
100757>>>>>>>    End_Procedure
100758>>>>>>>
100758>>>>>>>    Function psServer Returns String
100760>>>>>>>        String sValue
100760>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100762>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100763>>>>>>>>
100763>>>>>>>            Function_Return
100764>>>>>>>        End
100764>>>>>>>>
100764>>>>>>>        Get psServer of ghoSQLConnectionHandler to sValue
100765>>>>>>>        Function_Return sValue
100766>>>>>>>    End_Function
100767>>>>>>>
100767>>>>>>>    Procedure Set psDatabase String sValue
100769>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100771>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100772>>>>>>>>
100772>>>>>>>            Procedure_Return
100773>>>>>>>        End
100773>>>>>>>>
100773>>>>>>>        Set psDatabase of ghoSQLConnectionHandler to sValue
100774>>>>>>>    End_Procedure
100775>>>>>>>
100775>>>>>>>    Function psDatabase Returns String
100777>>>>>>>        String sValue
100777>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100779>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100780>>>>>>>>
100780>>>>>>>            Function_Return
100781>>>>>>>        End
100781>>>>>>>>
100781>>>>>>>        Get psDatabase of ghoSQLConnectionHandler to sValue
100782>>>>>>>        Function_Return sValue
100783>>>>>>>    End_Function
100784>>>>>>>
100784>>>>>>>    Procedure Set psUserID String sValue
100786>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100788>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100789>>>>>>>>
100789>>>>>>>            Procedure_Return
100790>>>>>>>        End
100790>>>>>>>>
100790>>>>>>>        Set psUserID of ghoSQLConnectionHandler to sValue
100791>>>>>>>    End_Procedure
100792>>>>>>>
100792>>>>>>>    Function psUserID Returns String
100794>>>>>>>        String sValue
100794>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100796>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100797>>>>>>>>
100797>>>>>>>            Function_Return
100798>>>>>>>        End
100798>>>>>>>>
100798>>>>>>>        Get psUserID of ghoSQLConnectionHandler to sValue
100799>>>>>>>        Function_Return sValue
100800>>>>>>>    End_Function
100801>>>>>>>
100801>>>>>>>    Procedure Set psPassword String sValue
100803>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100805>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100806>>>>>>>>
100806>>>>>>>            Procedure_Return
100807>>>>>>>        End
100807>>>>>>>>
100807>>>>>>>        Set psPassword of ghoSQLConnectionHandler to sValue
100808>>>>>>>    End_Procedure
100809>>>>>>>
100809>>>>>>>    Function psPassword Returns String
100811>>>>>>>        String sValue
100811>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100813>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100814>>>>>>>>
100814>>>>>>>            Function_Return
100815>>>>>>>        End
100815>>>>>>>>
100815>>>>>>>        Get psPassword of ghoSQLConnectionHandler to sValue
100816>>>>>>>        Function_Return sValue
100817>>>>>>>    End_Function
100818>>>>>>>
100818>>>>>>>    Procedure Set pbTrusted Boolean bValue
100820>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100822>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100823>>>>>>>>
100823>>>>>>>            Procedure_Return
100824>>>>>>>        End
100824>>>>>>>>
100824>>>>>>>        Set pbTrusted of ghoSQLConnectionHandler to bValue
100825>>>>>>>    End_Procedure
100826>>>>>>>
100826>>>>>>>    Function pbTrusted Returns Boolean
100828>>>>>>>        Boolean bValue
100828>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100830>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100831>>>>>>>>
100831>>>>>>>            Function_Return
100832>>>>>>>        End
100832>>>>>>>>
100832>>>>>>>        Get pbTrusted of ghoSQLConnectionHandler to bValue
100833>>>>>>>        Function_Return bValue
100834>>>>>>>    End_Function
100835>>>>>>>
100835>>>>>>>    Procedure Set pbSilentLogin Boolean bValue
100837>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100839>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100840>>>>>>>>
100840>>>>>>>            Procedure_Return
100841>>>>>>>        End
100841>>>>>>>>
100841>>>>>>>        Set pbSilentLogin of ghoSQLConnectionHandler to bValue
100842>>>>>>>    End_Procedure
100843>>>>>>>
100843>>>>>>>    Function pbSilentLogin Returns Boolean
100845>>>>>>>        Boolean bValue
100845>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100847>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100848>>>>>>>>
100848>>>>>>>            Function_Return
100849>>>>>>>        End
100849>>>>>>>>
100849>>>>>>>        Get pbSilentLogin of ghoSQLConnectionHandler to bValue
100850>>>>>>>        Function_Return bValue
100851>>>>>>>    End_Function
100852>>>>>>>
100852>>>>>>>    Procedure Set psConnectionID String sValue
100854>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100856>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100857>>>>>>>>
100857>>>>>>>            Procedure_Return
100858>>>>>>>        End
100858>>>>>>>>
100858>>>>>>>        Set psConnectionID of ghoSQLConnectionHandler to sValue
100859>>>>>>>    End_Procedure
100860>>>>>>>
100860>>>>>>>    Function psConnectionID Returns String
100862>>>>>>>        String sValue
100862>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100864>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100865>>>>>>>>
100865>>>>>>>            Function_Return
100866>>>>>>>        End
100866>>>>>>>>
100866>>>>>>>        Get psConnectionID of ghoSQLConnectionHandler to sValue
100867>>>>>>>        Function_Return sValue
100868>>>>>>>    End_Function
100869>>>>>>>
100869>>>>>>>    Procedure Set psConnectionString String sValue
100871>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100873>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100874>>>>>>>>
100874>>>>>>>            Procedure_Return
100875>>>>>>>        End
100875>>>>>>>>
100875>>>>>>>        Set psConnectionString of ghoSQLConnectionHandler to sValue
100876>>>>>>>    End_Procedure
100877>>>>>>>
100877>>>>>>>    Function psConnectionString Returns String
100879>>>>>>>        String sValue
100879>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100881>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100882>>>>>>>>
100882>>>>>>>            Function_Return
100883>>>>>>>        End
100883>>>>>>>>
100883>>>>>>>        Get psConnectionString of ghoSQLConnectionHandler to sValue
100884>>>>>>>        Function_Return sValue
100885>>>>>>>    End_Function
100886>>>>>>>
100886>>>>>>>    // The normal connection string looks something like this;
100886>>>>>>>    // SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
100886>>>>>>>    // ...and the full connection string looks like this;
100886>>>>>>>    // DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
100886>>>>>>>    Function psFullConnectionString Returns String
100888>>>>>>>        String sConnectionID sConnectionString
100888>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100890>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100891>>>>>>>>
100891>>>>>>>            Function_Return
100892>>>>>>>        End
100892>>>>>>>>
100892>>>>>>>        Get psConnectionID     of ghoSQLConnectionHandler to sConnectionID
100893>>>>>>>        Move (Trim(sConnectionID)) to sConnectionID
100894>>>>>>>        Get psConnectionString of ghoSQLConnectionHandler to sConnectionString
100895>>>>>>>        Function_Return (CS_SQLConnectionIDText * sConnectionID + "," * String(sConnectionString))
100896>>>>>>>    End_Function
100897>>>>>>>
100897>>>>>>>    Function piConnectionOptions Returns Integer
100899>>>>>>>        Integer iValue
100899>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100901>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100902>>>>>>>>
100902>>>>>>>            Function_Return
100903>>>>>>>        End
100903>>>>>>>>
100903>>>>>>>        Get piConnectionOptions of ghoSQLConnectionHandler to iValue
100904>>>>>>>        Function_Return iValue
100905>>>>>>>    End_Function
100906>>>>>>>
100906>>>>>>>    Procedure Set psSchema String sValue
100908>>>>>>>        tSQLConnection SQLConnection
100908>>>>>>>        tSQLConnection SQLConnection
100908>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100910>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100911>>>>>>>>
100911>>>>>>>            Procedure_Return
100912>>>>>>>        End
100912>>>>>>>>
100912>>>>>>>        Set psSchema of ghoSQLConnectionHandler to sValue
100913>>>>>>>    End_Procedure
100914>>>>>>>
100914>>>>>>>    Function psSchema Returns String
100916>>>>>>>        String sRetval
100916>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100918>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100919>>>>>>>>
100919>>>>>>>            Function_Return
100920>>>>>>>        End
100920>>>>>>>>
100920>>>>>>>        Get psSchema of ghoSQLConnectionHandler to sRetval
100921>>>>>>>        Function_Return sRetval
100922>>>>>>>    End_Function
100923>>>>>>>
100923>>>>>>>    Procedure Set psBaseTableSpace String sValue
100925>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100927>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100928>>>>>>>>
100928>>>>>>>            Procedure_Return
100929>>>>>>>        End
100929>>>>>>>>
100929>>>>>>>        Set psBaseTableSpace of ghoSQLConnectionHandler to sValue
100930>>>>>>>    End_Procedure
100931>>>>>>>
100931>>>>>>>    Function psBaseTableSpace Returns String
100933>>>>>>>        String sRetval
100933>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100935>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100936>>>>>>>>
100936>>>>>>>            Function_Return
100937>>>>>>>        End
100937>>>>>>>>
100937>>>>>>>        Get psBaseTableSpace of ghoSQLConnectionHandler to sRetval
100938>>>>>>>        Function_Return sRetval
100939>>>>>>>    End_Function
100940>>>>>>>
100940>>>>>>>    Procedure Set psLongTableSpace String sValue
100942>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100944>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100945>>>>>>>>
100945>>>>>>>            Procedure_Return
100946>>>>>>>        End
100946>>>>>>>>
100946>>>>>>>        Set psLongTableSpace of ghoSQLConnectionHandler to sValue
100947>>>>>>>    End_Procedure
100948>>>>>>>
100948>>>>>>>    Function psLongTableSpace Returns String
100950>>>>>>>        String sRetval
100950>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100952>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100953>>>>>>>>
100953>>>>>>>            Function_Return
100954>>>>>>>        End
100954>>>>>>>>
100954>>>>>>>        Get psLongTableSpace of ghoSQLConnectionHandler to sRetval
100955>>>>>>>        Function_Return sRetval
100956>>>>>>>    End_Function
100957>>>>>>>
100957>>>>>>>    Procedure Set psIndexTableSpace String sValue
100959>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100961>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100962>>>>>>>>
100962>>>>>>>            Procedure_Return
100963>>>>>>>        End
100963>>>>>>>>
100963>>>>>>>        Set psIndexTableSpace of ghoSQLConnectionHandler to sValue
100964>>>>>>>    End_Procedure
100965>>>>>>>
100965>>>>>>>    Function psIndexTableSpace Returns String
100967>>>>>>>        String sRetval
100967>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100969>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100970>>>>>>>>
100970>>>>>>>            Function_Return
100971>>>>>>>        End
100971>>>>>>>>
100971>>>>>>>        Get psIndexTableSpace of ghoSQLConnectionHandler to sRetval
100972>>>>>>>        Function_Return sRetval
100973>>>>>>>    End_Function
100974>>>>>>>
100974>>>>>>>    Procedure Set pbUseConnectionID Boolean bState
100976>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100978>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100979>>>>>>>>
100979>>>>>>>            Procedure_Return
100980>>>>>>>        End
100980>>>>>>>>
100980>>>>>>>        Set pbUseConnectionID of ghoSQLConnectionHandler to bState
100981>>>>>>>    End_Procedure
100982>>>>>>>
100982>>>>>>>    Function pbUseConnectionID Returns Boolean
100984>>>>>>>        Boolean bState
100984>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100986>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100987>>>>>>>>
100987>>>>>>>            Function_Return
100988>>>>>>>        End
100988>>>>>>>>
100988>>>>>>>        Get pbUseConnectionID of ghoSQLConnectionHandler to bState
100989>>>>>>>        Function_Return bState
100990>>>>>>>    End_Function
100991>>>>>>>
100991>>>>>>>    Procedure Set pbToANSI Boolean bState
100993>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
100995>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
100996>>>>>>>>
100996>>>>>>>            Procedure_Return
100997>>>>>>>        End
100997>>>>>>>>
100997>>>>>>>        Set pbToANSI of ghoSQLConnectionHandler to bState
100998>>>>>>>    End_Procedure
100999>>>>>>>
100999>>>>>>>    Function pbToANSI Returns Boolean
101001>>>>>>>        Boolean bState
101001>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
101003>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
101004>>>>>>>>
101004>>>>>>>            Function_Return
101005>>>>>>>        End
101005>>>>>>>>
101005>>>>>>>        Get pbToANSI of ghoSQLConnectionHandler to bState
101006>>>>>>>        Function_Return bState
101007>>>>>>>    End_Function
101008>>>>>>>
101008>>>>>>>    Procedure Set pbRecnum Boolean bState
101010>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
101012>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
101013>>>>>>>>
101013>>>>>>>            Procedure_Return
101014>>>>>>>        End
101014>>>>>>>>
101014>>>>>>>        Set pbRecnum of ghoSQLConnectionHandler to bState
101015>>>>>>>    End_Procedure
101016>>>>>>>
101016>>>>>>>    Function pbRecnum Returns Boolean
101018>>>>>>>        Boolean bState
101018>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
101020>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
101021>>>>>>>>
101021>>>>>>>            Function_Return
101022>>>>>>>        End
101022>>>>>>>>
101022>>>>>>>        Get pbRecnum of ghoSQLConnectionHandler to bState
101023>>>>>>>        Function_Return bState
101024>>>>>>>    End_Function
101025>>>>>>>
101025>>>>>>>    Procedure Set pbCopyData Boolean bState
101027>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
101029>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
101030>>>>>>>>
101030>>>>>>>            Procedure_Return
101031>>>>>>>        End
101031>>>>>>>>
101031>>>>>>>        Set pbCopyData of ghoSQLConnectionHandler to bState
101032>>>>>>>    End_Procedure
101033>>>>>>>
101033>>>>>>>    Function pbCopyData Returns Boolean
101035>>>>>>>        Boolean bState
101035>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
101037>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
101038>>>>>>>>
101038>>>>>>>            Function_Return
101039>>>>>>>        End
101039>>>>>>>>
101039>>>>>>>        Get pbCopyData of ghoSQLConnectionHandler to bState
101040>>>>>>>        Function_Return bState
101041>>>>>>>    End_Function
101042>>>>>>>
101042>>>>>>>    Procedure Set pbApiTableUpdateAuto Boolean bState
101044>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
101046>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
101047>>>>>>>>
101047>>>>>>>            Procedure_Return
101048>>>>>>>        End
101048>>>>>>>>
101048>>>>>>>        Set pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
101049>>>>>>>    End_Procedure
101050>>>>>>>
101050>>>>>>>    Function pbApiTableUpdateAuto Returns Boolean
101052>>>>>>>        Boolean bState
101052>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
101054>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
101055>>>>>>>>
101055>>>>>>>            Function_Return
101056>>>>>>>        End
101056>>>>>>>>
101056>>>>>>>        Get pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
101057>>>>>>>        Function_Return bState
101058>>>>>>>    End_Function
101059>>>>>>>
101059>>>>>>>    Procedure Set pbCompareDate_DateTime Boolean bState
101061>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
101063>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
101064>>>>>>>>
101064>>>>>>>            Procedure_Return
101065>>>>>>>        End
101065>>>>>>>>
101065>>>>>>>        Set pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
101066>>>>>>>    End_Procedure
101067>>>>>>>
101067>>>>>>>    Function pbCompareDate_DateTime Returns Boolean
101069>>>>>>>        Boolean bState
101069>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
101071>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
101072>>>>>>>>
101072>>>>>>>            Function_Return
101073>>>>>>>        End
101073>>>>>>>>
101073>>>>>>>        Get pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
101074>>>>>>>        Function_Return bState
101075>>>>>>>    End_Function
101076>>>>>>>
101076>>>>>>>    Procedure Set pbCompareIndexAscending Boolean bState
101078>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
101080>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
101081>>>>>>>>
101081>>>>>>>            Procedure_Return
101082>>>>>>>        End
101082>>>>>>>>
101082>>>>>>>        Set pbCompareIndexAscending of ghoSQLConnectionHandler to bState
101083>>>>>>>    End_Procedure
101084>>>>>>>
101084>>>>>>>    Function pbCompareIndexAscending Returns Boolean
101086>>>>>>>        Boolean bState
101086>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
101088>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
101089>>>>>>>>
101089>>>>>>>            Function_Return
101090>>>>>>>        End
101090>>>>>>>>
101090>>>>>>>        Get pbCompareIndexAscending of ghoSQLConnectionHandler to bState
101091>>>>>>>        Function_Return bState
101092>>>>>>>    End_Function
101093>>>>>>>
101093>>>>>>>    Procedure Set pbCompareIndexUppercase Boolean bState
101095>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
101097>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
101098>>>>>>>>
101098>>>>>>>            Procedure_Return
101099>>>>>>>        End
101099>>>>>>>>
101099>>>>>>>        Set pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
101100>>>>>>>    End_Procedure
101101>>>>>>>
101101>>>>>>>    Function pbCompareIndexUppercase Returns Boolean
101103>>>>>>>        Boolean bState
101103>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
101105>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
101106>>>>>>>>
101106>>>>>>>            Function_Return
101107>>>>>>>        End
101107>>>>>>>>
101107>>>>>>>        Get pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
101108>>>>>>>        Function_Return bState
101109>>>>>>>    End_Function
101110>>>>>>>
101110>>>>>>>    Procedure Set psDriverDefaultValueASCII String sValue
101112>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
101114>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
101115>>>>>>>>
101115>>>>>>>            Procedure_Return
101116>>>>>>>        End
101116>>>>>>>>
101116>>>>>>>        Set psDriverDefaultValueASCII of ghoSQLConnectionHandler to sValue
101117>>>>>>>    End_Procedure
101118>>>>>>>
101118>>>>>>>    Function psDriverDefaultValueASCII Returns String
101120>>>>>>>        String sRetval
101120>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
101122>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
101123>>>>>>>>
101123>>>>>>>            Function_Return
101124>>>>>>>        End
101124>>>>>>>>
101124>>>>>>>        Get psDriverDefaultValueASCII of ghoSQLConnectionHandler to sRetval
101125>>>>>>>        Function_Return sRetval
101126>>>>>>>    End_Function
101127>>>>>>>
101127>>>>>>>    Procedure Set psDriverDefaultValueBinary String sValue
101129>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
101131>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
101132>>>>>>>>
101132>>>>>>>            Procedure_Return
101133>>>>>>>        End
101133>>>>>>>>
101133>>>>>>>        Set psDriverDefaultValueBinary of ghoSQLConnectionHandler to sValue
101134>>>>>>>    End_Procedure
101135>>>>>>>
101135>>>>>>>    Function psDriverDefaultValueBinary Returns String
101137>>>>>>>        String sRetval
101137>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
101139>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
101140>>>>>>>>
101140>>>>>>>            Function_Return
101141>>>>>>>        End
101141>>>>>>>>
101141>>>>>>>        Get psDriverDefaultValueBinary of ghoSQLConnectionHandler to sRetval
101142>>>>>>>        Function_Return sRetval
101143>>>>>>>    End_Function
101144>>>>>>>
101144>>>>>>>    Procedure Set psDriverDefaultValueDate String sValue
101146>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
101148>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
101149>>>>>>>>
101149>>>>>>>            Procedure_Return
101150>>>>>>>        End
101150>>>>>>>>
101150>>>>>>>        Set psDriverDefaultValueDate of ghoSQLConnectionHandler to sValue
101151>>>>>>>    End_Procedure
101152>>>>>>>
101152>>>>>>>    Function psDriverDefaultValueDate Returns String
101154>>>>>>>        String sRetval
101154>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
101156>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
101157>>>>>>>>
101157>>>>>>>            Function_Return
101158>>>>>>>        End
101158>>>>>>>>
101158>>>>>>>        Get psDriverDefaultValueDate of ghoSQLConnectionHandler to sRetval
101159>>>>>>>        Function_Return sRetval
101160>>>>>>>    End_Function
101161>>>>>>>
101161>>>>>>>    Procedure Set psDriverDefaultValueDateTime String sValue
101163>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
101165>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
101166>>>>>>>>
101166>>>>>>>            Procedure_Return
101167>>>>>>>        End
101167>>>>>>>>
101167>>>>>>>        Set psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sValue
101168>>>>>>>    End_Procedure
101169>>>>>>>
101169>>>>>>>    Function psDriverDefaultValueDateTime Returns String
101171>>>>>>>        String sRetval
101171>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
101173>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
101174>>>>>>>>
101174>>>>>>>            Function_Return
101175>>>>>>>        End
101175>>>>>>>>
101175>>>>>>>        Get psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sRetval
101176>>>>>>>        Function_Return sRetval
101177>>>>>>>    End_Function
101178>>>>>>>
101178>>>>>>>    Procedure Set psDriverDefaultValueNumeric String sValue
101180>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
101182>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
101183>>>>>>>>
101183>>>>>>>            Procedure_Return
101184>>>>>>>        End
101184>>>>>>>>
101184>>>>>>>        Set psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sValue
101185>>>>>>>    End_Procedure
101186>>>>>>>
101186>>>>>>>    Function psDriverDefaultValueNumeric Returns String
101188>>>>>>>        String sRetval
101188>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
101190>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
101191>>>>>>>>
101191>>>>>>>            Function_Return
101192>>>>>>>        End
101192>>>>>>>>
101192>>>>>>>        Get psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sRetval
101193>>>>>>>        Function_Return sRetval
101194>>>>>>>    End_Function
101195>>>>>>>
101195>>>>>>>    Procedure Set psDriverDefaultValueText String sValue
101197>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
101199>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
101200>>>>>>>>
101200>>>>>>>            Procedure_Return
101201>>>>>>>        End
101201>>>>>>>>
101201>>>>>>>        Set psDriverDefaultValueText of ghoSQLConnectionHandler to sValue
101202>>>>>>>    End_Procedure
101203>>>>>>>
101203>>>>>>>    Function psDriverDefaultValueText Returns String
101205>>>>>>>        String sRetval
101205>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
101207>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
101208>>>>>>>>
101208>>>>>>>            Function_Return
101209>>>>>>>        End
101209>>>>>>>>
101209>>>>>>>        Get psDriverDefaultValueText of ghoSQLConnectionHandler to sRetval
101210>>>>>>>        Function_Return sRetval
101211>>>>>>>    End_Function
101212>>>>>>>
101212>>>>>>>    Procedure Set pbDriverDefaultNullableASCII Boolean bState
101214>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
101216>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
101217>>>>>>>>
101217>>>>>>>            Procedure_Return
101218>>>>>>>        End
101218>>>>>>>>
101218>>>>>>>        Set pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
101219>>>>>>>    End_Procedure
101220>>>>>>>
101220>>>>>>>    Function pbDriverDefaultNullableASCII Returns Boolean
101222>>>>>>>        Boolean bState
101222>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
101224>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
101225>>>>>>>>
101225>>>>>>>            Function_Return
101226>>>>>>>        End
101226>>>>>>>>
101226>>>>>>>        Get pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
101227>>>>>>>        Function_Return bState
101228>>>>>>>    End_Function
101229>>>>>>>
101229>>>>>>>    Procedure Set pbDriverDefaultNullableBinary Boolean bState
101231>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
101233>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
101234>>>>>>>>
101234>>>>>>>            Procedure_Return
101235>>>>>>>        End
101235>>>>>>>>
101235>>>>>>>        Set pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
101236>>>>>>>    End_Procedure
101237>>>>>>>
101237>>>>>>>    Function pbDriverDefaultNullableBinary Returns Boolean
101239>>>>>>>        Boolean bState
101239>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
101241>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
101242>>>>>>>>
101242>>>>>>>            Function_Return
101243>>>>>>>        End
101243>>>>>>>>
101243>>>>>>>        Get pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
101244>>>>>>>        Function_Return bState
101245>>>>>>>    End_Function
101246>>>>>>>
101246>>>>>>>    Procedure Set pbDriverDefaultNullableDate Boolean bState
101248>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
101250>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
101251>>>>>>>>
101251>>>>>>>            Procedure_Return
101252>>>>>>>        End
101252>>>>>>>>
101252>>>>>>>        Set pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
101253>>>>>>>    End_Procedure
101254>>>>>>>
101254>>>>>>>    Function pbDriverDefaultNullableDate Returns Boolean
101256>>>>>>>        Boolean bState
101256>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
101258>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
101259>>>>>>>>
101259>>>>>>>            Function_Return
101260>>>>>>>        End
101260>>>>>>>>
101260>>>>>>>        Get pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
101261>>>>>>>        Function_Return bState
101262>>>>>>>    End_Function
101263>>>>>>>
101263>>>>>>>    Procedure Set pbDriverDefaultNullableDateTime Boolean bState
101265>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
101267>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
101268>>>>>>>>
101268>>>>>>>            Procedure_Return
101269>>>>>>>        End
101269>>>>>>>>
101269>>>>>>>        Set pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
101270>>>>>>>    End_Procedure
101271>>>>>>>
101271>>>>>>>    Function pbDriverDefaultNullableDateTime Returns Boolean
101273>>>>>>>        Boolean bState
101273>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
101275>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
101276>>>>>>>>
101276>>>>>>>            Function_Return
101277>>>>>>>        End
101277>>>>>>>>
101277>>>>>>>        Get pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
101278>>>>>>>        Function_Return bState
101279>>>>>>>    End_Function
101280>>>>>>>
101280>>>>>>>    Procedure Set pbDriverDefaultNullableNumeric Boolean bState
101282>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
101284>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
101285>>>>>>>>
101285>>>>>>>            Procedure_Return
101286>>>>>>>        End
101286>>>>>>>>
101286>>>>>>>        Set pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
101287>>>>>>>    End_Procedure
101288>>>>>>>
101288>>>>>>>    Function pbDriverDefaultNullableNumeric Returns Boolean
101290>>>>>>>        Boolean bState
101290>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
101292>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
101293>>>>>>>>
101293>>>>>>>            Function_Return
101294>>>>>>>        End
101294>>>>>>>>
101294>>>>>>>        Get pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
101295>>>>>>>        Function_Return bState
101296>>>>>>>    End_Function
101297>>>>>>>
101297>>>>>>>    Procedure Set pbDriverDefaultNullableText Boolean bState
101299>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
101301>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
101302>>>>>>>>
101302>>>>>>>            Procedure_Return
101303>>>>>>>        End
101303>>>>>>>>
101303>>>>>>>        Set pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
101304>>>>>>>    End_Procedure
101305>>>>>>>
101305>>>>>>>    Function pbDriverDefaultNullableText Returns Boolean
101307>>>>>>>        Boolean bState
101307>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
101309>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
101310>>>>>>>>
101310>>>>>>>            Function_Return
101311>>>>>>>        End
101311>>>>>>>>
101311>>>>>>>        Get pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
101312>>>>>>>        Function_Return bState
101313>>>>>>>    End_Function
101314>>>>>>>
101314>>>>>>>    // Note: If the psDriverID + other connection properties are to be changed,
101314>>>>>>>    //       the psDriverID *must* be the first property that gets changed!
101314>>>>>>>    //       Otherwise errors might be raised by the driver when e.g. the format
101314>>>>>>>    //       for a connection string has the wrong format for that driver.
101314>>>>>>>    Procedure Set psDriverID String sValue
101316>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
101317>>>>>>>        Delegate Set psDriverID to sValue
101319>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
101320>>>>>>>        Set psDriverID of ghoSQLConnectionHandler to sValue
101321>>>>>>>    End_Procedure
101322>>>>>>>
101322>>>>>>>    Function psDriverID Returns String
101324>>>>>>>        String sDriverID
101324>>>>>>>
101324>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
101325>>>>>>>        // This should get it from the parent object (when using the cDbUpdateHandler class)
101325>>>>>>>        Delegate Get psDriverID to sDriverID
101327>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
101328>>>>>>>        Move False to Err
101329>>>>>>>
101329>>>>>>>        // ...and in case it didn't use property of this class. Then the library is
101329>>>>>>>        // probably used as "utilites" from a special made program and
101329>>>>>>>        // the ghoSQLConnectionHandler must have been setup
101329>>>>>>>        If (sDriverID = "") Begin
101331>>>>>>>            Get psDriverID of ghoSQLConnectionHandler to sDriverID
101332>>>>>>>        End
101332>>>>>>>>
101332>>>>>>>        Function_Return sDriverID
101333>>>>>>>    End_Function
101334>>>>>>>
101334>>>>>>>    Procedure Set piDbType Integer iValue
101336>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
101337>>>>>>>        Delegate Set piDbType to iValue
101339>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
101340>>>>>>>        Set piDbType of ghoSQLConnectionHandler to iValue
101341>>>>>>>    End_Procedure
101342>>>>>>>
101342>>>>>>>    Function piDbType Returns Integer
101344>>>>>>>        Integer iRetval
101344>>>>>>>        Get piDbType of ghoSQLConnectionHandler to iRetval
101345>>>>>>>        Function_Return iRetval
101346>>>>>>>    End_Function
101347>>>>>>>
101347>>>>>>>    Function phoLogFile Returns Handle
101349>>>>>>>        Handle hoLogFile   
101349>>>>>>>        Boolean bErr
101349>>>>>>>        
101349>>>>>>>        Move Err to bErr
101350>>>>>>>        Move 0 to hoLogFile
101351>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT  
101352>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
101353>>>>>>>        Delegate Get phoLogFile to hoLogFile
101355>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
101356>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
101357>>>>>>>        Move bErr to Err
101358>>>>>>>        
101358>>>>>>>        Function_Return hoLogFile
101359>>>>>>>    End_Function
101360>>>>>>>
101360>>>>>>>    Function pnCurrentVersionUpdate Returns Number
101362>>>>>>>        Number nCurrentVersionUpdate
101362>>>>>>>
101362>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
101363>>>>>>>        Delegate Get pnCurrentVersionUpdate to nCurrentVersionUpdate
101365>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
101366>>>>>>>
101366>>>>>>>        Function_Return nCurrentVersionUpdate
101367>>>>>>>    End_Function
101368>>>>>>>
101368>>>>>>>    Procedure LogError String sText Boolean bError
101370>>>>>>>        Handle hoLogFile
101370>>>>>>>        Number nCurrentVersionUpdate
101370>>>>>>>
101370>>>>>>>        Get phoLogFile to hoLogFile
101371>>>>>>>        If (hoLogFile = 0) Begin
101373>>>>>>>            Procedure_Return
101374>>>>>>>        End
101374>>>>>>>>
101374>>>>>>>        Get pnCurrentVersionUpdate to nCurrentVersionUpdate
101375>>>>>>>
101375>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
101376>>>>>>>        Send LogError of hoLogFile nCurrentVersionUpdate 0 sText 0 bError
101377>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
101378>>>>>>>    End_Procedure
101379>>>>>>>
101379>>>>>>>    Function pbContinueOnError Returns Boolean
101381>>>>>>>        Boolean bContinueOnError
101381>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
101383>>>>>>>            Get pbContinueOnError of ghoDbUpdateHandler to bContinueOnError
101384>>>>>>>        End
101384>>>>>>>>
101384>>>>>>>        Function_Return bContinueOnError
101385>>>>>>>    End_Function
101386>>>>>>>
101386>>>>>>>    // Latin1_General_CI_AS = General Insensitive collation
101386>>>>>>>    // Latin1_General_CS_AS = General Case Sensitive collation, AS= Accent Sensitive.
101386>>>>>>>    // For MS-SQL See: https://docs.microsoft.com/en-us/sql/t-sql/statements/windows-collation-name-transact-sql?view=sql-server-2017
101386>>>>>>>    // Good read about which collation to select:
101386>>>>>>>    // https://social.msdn.microsoft.com/Forums/sqlserver/en-US/bfdc32d3-3d36-4d63-8d87-6ee972fd8130/on-sqllatin1generalcp1cias-sql-server-2008-default-collation?forum=transactsql
101386>>>>>>>    Procedure Set psCollation String sCollation
101388>>>>>>>        Set private.psCollation to sCollation
101389>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
101391>>>>>>>            Set psCollation of ghoDbUpdateHandler to sCollation
101392>>>>>>>        End
101392>>>>>>>>
101392>>>>>>>    End_Procedure
101393>>>>>>>
101393>>>>>>>    Function psCollation Returns String
101395>>>>>>>        String sCollation
101395>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
101397>>>>>>>            Get psCollation of ghoDbUpdateHandler to sCollation
101398>>>>>>>        End   
101398>>>>>>>>
101398>>>>>>>        Else Begin
101399>>>>>>>            Get private.psCollation to sCollation
101400>>>>>>>        End
101400>>>>>>>>
101400>>>>>>>        Function_Return sCollation
101401>>>>>>>    End_Function
101402>>>>>>>
101402>>>>>>>
101402>>>>>>>    Function StrToFieldNumber Integer iFile String sField Returns Integer
101404>>>>>>>        Integer iMax iPos
101404>>>>>>>        String sName
101404>>>>>>>
101404>>>>>>>        Move (Lowercase(sField)) to sField
101405>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iMax
101408>>>>>>>        for iPos from 0 to iMax
101414>>>>>>>>
101414>>>>>>>            Get_Attribute DF_FIELD_NAME of iFile iPos to sName
101417>>>>>>>            Move (Lowercase(sName)) to sName
101418>>>>>>>            If (sName = sField) Begin
101420>>>>>>>                Function_Return iPos
101421>>>>>>>            End
101421>>>>>>>>
101421>>>>>>>        Loop
101422>>>>>>>>
101422>>>>>>>        Function_Return -1
101423>>>>>>>    End_Function
101424>>>>>>>
101424>>>>>>>
101424>>>>>>>    // * Dummy function for the Studio's Code Explorer *
101424>>>>>>>    Function PRIVATE_SUB_FUNCTIONS Returns Boolean
101426>>>>>>>        Function_Return False
101427>>>>>>>    End_Function
101428>>>>>>>
101428>>>>>>>    // *** Helper functions with compiled sql script code ***
101428>>>>>>>    //
101428>>>>>>>    // When dropping columns on some SQL back-ends they doesn't reclaim the space taken up by the columns dropped.
101428>>>>>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
101428>>>>>>>    // the new rows added after the alter statement. to get around this you need to create a clustered
101428>>>>>>>    // index on the table _or_ rebuild the clustered Index if it already has one. Rebuilding the index
101428>>>>>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
101428>>>>>>>    //   ALTER TABLE MyTable
101428>>>>>>>    //       REBUILD
101428>>>>>>>    Function _SqlUtilRemoveTableColumnMSSQL String sTableName String sColumnName Returns Boolean
101430>>>>>>>        Boolean bOK
101430>>>>>>>
101430>>>>>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
101432>>>>>>>            Function_Return False
101433>>>>>>>        End
101433>>>>>>>>
101433>>>>>>>
101433>>>>>>>        SQLIncludeScriptFile ..\Scripts\DropConstraintAndColumnNameMSSQL.sql as DropConstraintAndColumnNameMSSQL.sql
101433>>>>>>>        Get _SqlUtilRemoveTableColumnByScript "DropConstraintAndColumnNameMSSQL.sql" sTableName sColumnName to bOK
101434>>>>>>>
101434>>>>>>>        Function_Return (bOK = True)
101435>>>>>>>    End_Function
101436>>>>>>>
101436>>>>>>>    // When dropping columns SQL Sever does not reclaim the space taken up by the columns dropped.
101436>>>>>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
101436>>>>>>>    // the new rows added after the alter statement. To get around this you need to create a clustered
101436>>>>>>>    // index on the table or rebuild the clustered Index if it already has one. Rebuilding the index
101436>>>>>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
101436>>>>>>>    //   ALTER TABLE MyTable
101436>>>>>>>    //       REBUILD
101436>>>>>>>    Function _SqlUtilRemoveTableColumnByScript String sMemScriptFile String sTableName String sColumnName Returns Boolean
101438>>>>>>>        tSQLScriptArray SQLScriptArray
101438>>>>>>>        tSQLScriptArray SQLScriptArray
101438>>>>>>>        String sDriverID
101438>>>>>>>        Boolean bOK
101438>>>>>>>        Integer iSize iCount
101438>>>>>>>
101438>>>>>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
101440>>>>>>>            Function_Return False
101441>>>>>>>        End
101441>>>>>>>>
101441>>>>>>>
101441>>>>>>>        Get psDriverID to sDriverID
101442>>>>>>>        Get SqlUtilReadResource sMemScriptFile to SQLScriptArray
101443>>>>>>>        If (SQLScriptArray.bError = True) Begin
101445>>>>>>>            Function_Return False
101446>>>>>>>        End
101446>>>>>>>>
101446>>>>>>>
101446>>>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
101447>>>>>>>        Decrement iSize
101448>>>>>>>
101448>>>>>>>        for iCount from 0 to iSize
101454>>>>>>>>
101454>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "TABLE_NAME_XXX") Begin
101456>>>>>>>                Move (Replaces("TABLE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sTableName))) to SQLScriptArray.sSQLScriptArray[iCount]
101457>>>>>>>            End
101457>>>>>>>>
101457>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLUMN_NAME_XXX") Begin
101459>>>>>>>                Move (Replaces("COLUMN_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sColumnName))) to SQLScriptArray.sSQLScriptArray[iCount]
101460>>>>>>>            End
101460>>>>>>>>
101460>>>>>>>        Loop
101461>>>>>>>>
101461>>>>>>>
101461>>>>>>>        Get SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
101462>>>>>>>
101462>>>>>>>        Function_Return (bOK = True)
101463>>>>>>>    End_Function
101464>>>>>>>
101464>>>>>>>    Function _SqlUtilCreatePostGreSQLDatabaseByScript String sMemScriptFile String sDatabaseName Returns Boolean
101466>>>>>>>        tSQLScriptArray SQLScriptArray
101466>>>>>>>        tSQLScriptArray SQLScriptArray
101466>>>>>>>        String sDriverID sCollation
101466>>>>>>>        Boolean bOK
101466>>>>>>>        Integer iSize iCount
101466>>>>>>>
101466>>>>>>>        If (Trim(sDatabaseName) = "") Begin
101468>>>>>>>            Function_Return False
101469>>>>>>>        End
101469>>>>>>>>
101469>>>>>>>
101469>>>>>>>        Get psDriverID  to sDriverID
101470>>>>>>>        Get psCollation to sCollation
101471>>>>>>>        Get SqlUtilReadResource sMemScriptFile to SQLScriptArray
101472>>>>>>>        If (SQLScriptArray.bError = True) Begin
101474>>>>>>>            Function_Return False
101475>>>>>>>        End
101475>>>>>>>>
101475>>>>>>>
101475>>>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
101476>>>>>>>        Decrement iSize
101477>>>>>>>
101477>>>>>>>        for iCount from 0 to iSize
101483>>>>>>>>
101483>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "DATABASE_NAME_XXX") Begin
101485>>>>>>>                Move (Replaces("DATABASE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sDatabaseName))) to SQLScriptArray.sSQLScriptArray[iCount]
101486>>>>>>>            End
101486>>>>>>>>
101486>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLLATION_NAME_XXX") Begin
101488>>>>>>>                Move (Replaces("COLLATION_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sCollation))) to SQLScriptArray.sSQLScriptArray[iCount]
101489>>>>>>>            End
101489>>>>>>>>
101489>>>>>>>        Loop
101490>>>>>>>>
101490>>>>>>>
101490>>>>>>>        Get SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
101491>>>>>>>
101491>>>>>>>        Function_Return (bOK = True)
101492>>>>>>>    End_Function
101493>>>>>>>
101493>>>>>>>    Function _SqlUtilCreateMySQLDatabaseByScript String sMemScriptFile String sDatabaseName Returns Boolean
101495>>>>>>>        tSQLScriptArray SQLScriptArray
101495>>>>>>>        tSQLScriptArray SQLScriptArray
101495>>>>>>>        String sDriverID sCollation
101495>>>>>>>        Boolean bOK
101495>>>>>>>        Integer iSize iCount
101495>>>>>>>
101495>>>>>>>        If (Trim(sDatabaseName) = "") Begin
101497>>>>>>>            Function_Return False
101498>>>>>>>        End
101498>>>>>>>>
101498>>>>>>>
101498>>>>>>>        Get psDriverID  to sDriverID
101499>>>>>>>        Get psCollation to sCollation
101500>>>>>>>        Get SqlUtilReadResource sMemScriptFile to SQLScriptArray
101501>>>>>>>        If (SQLScriptArray.bError = True) Begin
101503>>>>>>>            Function_Return False
101504>>>>>>>        End
101504>>>>>>>>
101504>>>>>>>
101504>>>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
101505>>>>>>>        Decrement iSize
101506>>>>>>>
101506>>>>>>>        for iCount from 0 to iSize
101512>>>>>>>>
101512>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "DATABASE_NAME_XXX") Begin
101514>>>>>>>                Move (Replaces("DATABASE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sDatabaseName))) to SQLScriptArray.sSQLScriptArray[iCount]
101515>>>>>>>            End
101515>>>>>>>>
101515>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLLATION_NAME_XXX") Begin
101517>>>>>>>                Move (Replaces("COLLATION_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sCollation))) to SQLScriptArray.sSQLScriptArray[iCount]
101518>>>>>>>            End
101518>>>>>>>>
101518>>>>>>>        Loop
101519>>>>>>>>
101519>>>>>>>        // ToDo: THIS FAILS BUT THE SQL SCRIPT WORKS IN MYSQL!
101519>>>>>>>        Get SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
101520>>>>>>>
101520>>>>>>>        Function_Return (bOK = True)
101521>>>>>>>    End_Function
101522>>>>>>>
101522>>>>>>>    // *** Helper functions for Mertech Drivers ***
101522>>>>>>>    // Created to not clutter up the standard function code with lots of #IFDEF's
101522>>>>>>>    // and commands that the Studio editor knows nothing about.
101522>>>>>>>    Function _MertechDeleteTDFile String sTableName Returns Boolean
101524>>>>>>>        Integer iRetval
101524>>>>>>>        String sPath
101524>>>>>>>
101524>>>>>>>            SQL_GET_LOCAL_TD_PATH to sPath
101562>>>>>>>>
101562>>>>>>>        If (sPath = "" or sTableName = "") Begin
101564>>>>>>>            Function_Return True
101565>>>>>>>        End
101565>>>>>>>>
101565>>>>>>>
101565>>>>>>>        Get vFolderFormat sPath to sPath
101566>>>>>>>        Get vDeleteFile (sPath + String(sTableName) + ".td") to iRetval
101567>>>>>>>        Function_Return (iRetval = 0)
101568>>>>>>>    End_Function
101569>>>>>>>
101569>>>>>>>    Function _MertechSqlUtilCreateIntFile Handle hTable String sTableName String sDataPath String sPhysicalFileName Returns Boolean
101571>>>>>>>        Boolean bOpen bOK
101571>>>>>>>        Move False to Err
101572>>>>>>>            Close hTable
101573>>>>>>>            Get UtilTableOpenAsIntFile hTable sTableName DF_SHARE to bOpen
101574>>>>>>>            Set_Attribute DF_FILE_SUPPRESS_SERVERNAME_OUTPUT   of hTable to True
101577>>>>>>>            Set_Attribute DF_FILE_SUPPRESS_DATABASENAME_OUTPUT of hTable to True
101580>>>>>>>            Set_Attribute DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT   of hTable to True
101583>>>>>>>            Get UtilDeleteCacheFile sTableName to bOK
101584>>>>>>>            CLEAR_INT_CACHE
101620>>>>>>>>
101620>>>>>>>            Move (sDataPath + sPhysicalFileName) to sTableName
101621>>>>>>>            OUTPUT_INT_FILE for hTable to sTableName
101666>>>>>>>>
101666>>>>>>>        Function_Return (Err = False)
101667>>>>>>>    End_Function
101668>>>>>>>
101668>>>>>>>    Function _MertechEnumerateSQLFlexServers Returns String[]
101670>>>>>>>        Integer iNumItems iCount
101670>>>>>>>        String[] sReturnArray
101671>>>>>>>        String sServer
101671>>>>>>>
101671>>>>>>>        Get SQL_AVAILABLE_SQL_SERVERS to iNumItems
101672>>>>>>>        For iCount from 1 to iNumItems
101678>>>>>>>>
101678>>>>>>>            Get SQL_AVAILABLE_SQL_SERVER_NAME iCount to sServer
101679>>>>>>>            Move sServer to sReturnArray[iCount -1]
101680>>>>>>>        Loop
101681>>>>>>>>
101681>>>>>>>
101681>>>>>>>        Function_Return sReturnArray
101682>>>>>>>    End_Function
101683>>>>>>>
101683>>>>>>>    Function _MertechEnumerateORAFLEXServers Returns String[]
101685>>>>>>>        String[] sReturnArray
101686>>>>>>>        String sServer
101686>>>>>>>
101686>>>>>>>        GET_CURRENT_SQL_SERVER to sServer
101730>>>>>>>>
101730>>>>>>>        Move sServer to sReturnArray[0]
101731>>>>>>>
101731>>>>>>>        Function_Return sReturnArray
101732>>>>>>>    End_Function
101733>>>>>>>
101733>>>>>>>    Function _MertechSQLConnect String sDriverID String sServer String sUserID String sPassword Returns Handle
101735>>>>>>>        Handle hoSQLHandler hoSQLConnect
101735>>>>>>>
101735>>>>>>>        Move 0 to hoSQLConnect
101736>>>>>>>            Get _MertechSQLManagerHandle to hoSQLHandler
101737>>>>>>>            Get SQLConnect of hoSqlHandler sDriverID sServer sUserID sPassword to hoSQLConnect
101738>>>>>>>
101738>>>>>>>        Function_Return hoSQLConnect
101739>>>>>>>    End_Function
101740>>>>>>>
101740>>>>>>>    // Returns the handle of the Mertech SQL handler.
101740>>>>>>>    // It also ensures that the correct Server & Database attributes are set both for
101740>>>>>>>    // embedded SQL calls and "normal" database commands like e.g. "Open".
101740>>>>>>>    Function _MertechSQLManagerHandle Returns Handle
101742>>>>>>>        Handle hoSQLHandler
101742>>>>>>>        String sDriverID sServer sDatabase
101742>>>>>>>
101742>>>>>>>        Move 0 to hoSQLHandler
101743>>>>>>>        Get psDriverID to sDriverID
101744>>>>>>>        Get psServer   to sServer
101745>>>>>>>        Get psDatabase to sDatabase
101746>>>>>>>        // This command is used to set the server to be used when opening tables
101746>>>>>>>        SET_CURRENT_SQL_SERVER            to sServer
101789>>>>>>>>
101789>>>>>>>        // This command is used to specify which server to use for embedded SQL statements,
101789>>>>>>>        // but it has been constructed rather studidly as only constants and not variables
101789>>>>>>>        // are allowed...
101789>>>>>>>        If (sDriverID = MDSPgSQL) Begin
101791>>>>>>>            SET_CURRENT_SQL_SERVER_CONNECTION of MDSPgSQL to sServer
101807>>>>>>>        End
101807>>>>>>>>
101807>>>>>>>        If (sDriverID = MDSMySQL) Begin
101809>>>>>>>            SET_CURRENT_SQL_SERVER_CONNECTION of MDSMySQL to sServer
101825>>>>>>>        End
101825>>>>>>>>
101825>>>>>>>        If (sDriverID = ORAFLEX) Begin
101827>>>>>>>            SET_CURRENT_SQL_SERVER_CONNECTION of ORAFLEX to sServer
101843>>>>>>>        End
101843>>>>>>>>
101843>>>>>>>        If (sDriverID = SQLFLEX) Begin
101845>>>>>>>            SET_CURRENT_SQL_SERVER_CONNECTION of SQLFLEX to sServer
101861>>>>>>>        End
101861>>>>>>>>
101861>>>>>>>
101861>>>>>>>        // This command is used to specify which database is used for SQL statements only.
101861>>>>>>>        SQL_USE_DATABASE sDatabase
101899>>>>>>>>
101899>>>>>>>        SET_DATABASE_NAME to sDatabase
101937>>>>>>>>
101937>>>>>>>
101937>>>>>>>        Get phoSQLManagerMT to hoSQLHandler
101938>>>>>>>
101938>>>>>>>        Function_Return hoSQLHandler
101939>>>>>>>    End_Function
101940>>>>>>>
101940>>>>>>>    // For Mertech drivers we cannot use Structure_Start/End. Instead we must use
101940>>>>>>>    // macro-commands <sigh!>
101940>>>>>>>    // Note: The function sets the Err flag.
101940>>>>>>>    Function _MertechApiTableConvertToSQL Handle hTable String sRootName String sDatabase String sDriverID String sBaseTableSpace String sIndexTableSpace Boolean bToAnsi Boolean bCopyData Returns Boolean
101942>>>>>>>
101942>>>>>>>        Move False to Err
101943>>>>>>>            SET_DATABASE_NAME to sDatabase
101981>>>>>>>>
101981>>>>>>>            If (sBaseTableSpace <> "") Begin
101983>>>>>>>                SET_DEFAULT_TABLESPACE to sBaseTableSpace
102020>>>>>>>>
102020>>>>>>>            End
102020>>>>>>>>
102020>>>>>>>            If (sIndexTableSpace <> "") Begin
102022>>>>>>>                SET_DEFAULT_INDEX_TABLESPACE to sIndexTableSpace
102059>>>>>>>>
102059>>>>>>>            End
102059>>>>>>>>
102059>>>>>>>
102059>>>>>>>            MERTECH_WARNING_MESSAGE Disabled
102092>>>>>>>>
102092>>>>>>>            CONVERT_DAT_FILE hTable DF_STRUCTEND_OPT_FORCE_INVK sRootName
102130>>>>>>>>
102130>>>>>>>            MERTECH_WARNING_MESSAGE Enabled
102163>>>>>>>>
102163>>>>>>>
102163>>>>>>>//            Move hTable to iFile
102163>>>>>>>//            Structure_Start iFile sDriverID
102163>>>>>>>//                Set_Attribute DF_FILE_OEM_TRANSLATION of iFile to (bToAnsi = True)
102163>>>>>>>//            Structure_End iFile
102163>>>>>>>
102163>>>>>>>
102163>>>>>>>        Function_Return (Err = False)
102164>>>>>>>    End_Function
102165>>>>>>>
102165>>>>>>>    Function _MertechCopyDataToSQL Handle hTable String sRootName String sDriverID Returns Boolean
102167>>>>>>>        Move False to Err
102168>>>>>>>            MERTECH_WARNING_MESSAGE Disabled
102201>>>>>>>>
102201>>>>>>>            COPY_DATA sRootName to (sDriverID + ":" + sRootName) CALLBACK (Callback(Self))
102240>>>>>>>>
102240>>>>>>>            MERTECH_WARNING_MESSAGE Enabled
102273>>>>>>>>
102273>>>>>>>        Function_Return (Err = False)
102274>>>>>>>    End_Function
102275>>>>>>>
102275>>>>>>>End_Class
102276>>>>>Use for_all.pkg // Handy to have available in the OnUpdate event.
Including file: for_all.pkg    (C:\Program Files\DataFlex 20.1\Pkg\for_all.pkg)
102276>>>>>>>// This module contains the command definitions for the FOR_ALL construct.
102276>>>>>>>//
102276>>>>>>>// FOR_ALL is used to select and process a set of records in a database file;
102276>>>>>>>// FOR_ALL constructs may be nested. FOR_ALL is intended to work in
102276>>>>>>>// conjunction with constraint-clauses.
102276>>>>>>>//
102276>>>>>>>// SYNTAX:
102276>>>>>>>//
102276>>>>>>>//  For_All <File> BY|DOWN <Index> {AS QUE|QUEUE} {DO}
102276>>>>>>>//    <Constraints...>
102276>>>>>>>//    {DO}
102276>>>>>>>//      <loop body>
102276>>>>>>>//  End_For_All
102276>>>>>>>//
102276>>>>>>>// This set of macros implements a constraint-oriented file enumeration
102276>>>>>>>// syntax.  For example, to list all Customers by name in reverse order:
102276>>>>>>>//
102276>>>>>>>//   For_All Customer DOWN Customer.Customer_Name DO
102276>>>>>>>//     showln "Customer: " Customer.RecNum "  " Customer.Customer_Name
102276>>>>>>>//   End_For_All
102276>>>>>>>//
102276>>>>>>>// To list only Customers with a Balance greater than their credit limit:
102276>>>>>>>//
102276>>>>>>>//   For_All Customer BY Index.1
102276>>>>>>>//     CONSTRAIN Customer.Balance GT Customer.Credit_Limit
102276>>>>>>>//     DO
102276>>>>>>>//       showln "Customer: " Customer.RecNum "  " Customer.Customer_Name
102276>>>>>>>//   End_For_All
102276>>>>>>>//
102276>>>>>>>// Constraint clauses are:
102276>>>>>>>//
102276>>>>>>>//   CONSTRAIN <File> RELATES TO <File> ...
102276>>>>>>>//   CONSTRAIN <File> AS <Expression>
102276>>>>>>>//   CONSTRAIN <File.Field> AS <Expression>
102276>>>>>>>//   CONSTRAIN <File.Field> BETWEEN <lowBound> AND <highBound>
102276>>>>>>>//
102276>>>>>>>// For example, to list all customers with a bad status whose names start
102276>>>>>>>// with "A" and which have not made a payment in thirty days:
102276>>>>>>>//
102276>>>>>>>//    For_All Customer BY Index.2       //Index.2 = <Status>+<Name>
102276>>>>>>>//      CONSTRAIN Customer.Status EQ BAD
102276>>>>>>>//      CONSTRAIN Customer.Customer_Name GE "A"
102276>>>>>>>//      CONSTRAIN Customer.Customer_Name LT "B"
102276>>>>>>>//      CONSTRAIN Customer.Last_Pymt_Date LE (Today - 30)
102276>>>>>>>//      DO
102276>>>>>>>//        showln "Customer: " Customer.RecNum "  " Customer.Customer_Name
102276>>>>>>>//    End_For_All
102276>>>>>>>//
102276>>>>>>>
102276>>>>>>>
102276>>>>>>>//This command starts the loop process body when constraints are used;
102276>>>>>>>//If no constraints are required, DO should be specified on the FOR_ALL
102276>>>>>>>//command line, and not on a line by itself
102276>>>>>>>//
102276>>>>>>>
102276>>>>>>>//Ends a For_All loop
102276>>>>>>>//
102276>>>>>>>
102276>>>>>>>
102276>>>>>
102276>>>>>
102276>>>>>Class cDbUpdateVersion is a cObject
102277>>>>>
102277>>>>>    Procedure Construct_Object    
102279>>>>>        Boolean bOnCreateExecuted bUseCustomDbVersion
102279>>>>>        String[] aSQLQueryMessages
102280>>>>>        
102280>>>>>        Forward Send Construct_Object
102282>>>>>
102282>>>>>        // cDbUpdateHandler object event.
102282>>>>>        Delegate Get Private.pbOnCreateExecuted to bOnCreateExecuted
102284>>>>>        If (bOnCreateExecuted = False) Begin    
102286>>>>>            Delegate Get pbUseCustomDbVersion to bUseCustomDbVersion
102288>>>>>            If (bUseCustomDbVersion = False) Begin
102290>>>>>                Delegate Send CheckAutoCreateDbVersionTable 
102292>>>>>            End
102292>>>>>>
102292>>>>>            Delegate Send CheckIntFilesIntegrity
102294>>>>>            Delegate Send OnCreate
102296>>>>>            Delegate Set Private.pbOnCreateExecuted to True
102298>>>>>        End
102298>>>>>>
102298>>>>>
102298>>>>>        // Don't touch! It is used by class logic to indicate if the OnUpdate
102298>>>>>        // event was triggered, thus an actual change of the database was made.
102298>>>>>        Property Boolean pbVersionUpdate False
102299>>>>>
102299>>>>>        // This property must be manually set within each cDbUpdateVersion object
102299>>>>>        // by the programmer, to a consecutive number.
102299>>>>>        Property Number pnVersionNumber
102300>>>>>
102300>>>>>        Property Boolean pbUseConnectionID True
102301>>>>>        Property Boolean private.pbToANSI   True
102302>>>>>        Property Boolean private.pbRecnum   True
102303>>>>>        Property Boolean private.pbCopyData True
102304>>>>>        Property Boolean private.pbApiTableUpdateAuto False
102305>>>>>        Property Boolean private.pbCompareDate_DateTime False
102306>>>>>        Property Boolean private.pbCompareIndexAscending False
102307>>>>>        Property Boolean private.pbCompareIndexUppercase False
102308>>>>>        Property String private.psSchema
102309>>>>>        Property String private.psBaseTableSpace
102310>>>>>        Property String private.psLongTableSpace
102311>>>>>        Property String private.psIndexTableSpace
102312>>>>>
102312>>>>>        // Driver default value settings:
102312>>>>>        Property String private.psDriverDefaultValueASCII    ""
102313>>>>>        Property String private.psDriverDefaultValueBinary   ""
102314>>>>>        Property String private.psDriverDefaultValueDate     ""
102315>>>>>        Property String private.psDriverDefaultValueDateTime ""
102316>>>>>        Property String private.psDriverDefaultValueNumeric  ""
102317>>>>>        Property String private.psDriverDefaultValueText     ""
102318>>>>>
102318>>>>>        // Driver "nullability" settings:
102318>>>>>        Property Boolean private.pbDriverDefaultNullableASCII    False
102319>>>>>        Property Boolean private.pbDriverDefaultNullableBinary   False
102320>>>>>        Property Boolean private.pbDriverDefaultNullableDate     False
102321>>>>>        Property Boolean private.pbDriverDefaultNullableDateTime False
102322>>>>>        Property Boolean private.pbDriverDefaultNullableNumeric  False
102323>>>>>        Property Boolean private.pbDriverDefaultNullableText     False
102324>>>>>
102324>>>>>        // paSQLQueryMessages is a property of the container class cDbUpdateHandler.
102324>>>>>        // It is being used to gather ESQL message replies, and is output to the log file
102324>>>>>        // if pbVerboseState = True in the cDbUpdateHandler object.
102324>>>>>        // (See: Procedure Set pbDatabaseWasUpdated in the cDbUpdateHandler class)
102324>>>>>        // We reset it here for each cDbUpdateVersion object
102324>>>>>        Delegate Set paSQLQueryMessages to aSQLQueryMessages
102326>>>>>    End_Procedure
102327>>>>>
102327>>>>>    // *** Main hook event message ***
102327>>>>>    // Place your database update logic here!
102327>>>>>    Procedure OnUpdate
102329>>>>>    End_Procedure
102330>>>>>
102330>>>>>    // These properties also exists in the cDbUpdateFunctionLibray that is
102330>>>>>    // imported to the cDbUpdateHandler container class which should be a
102330>>>>>    // parent object to this object. To have the Studio's Property Panel
102330>>>>>    // "behave" aka show these properties we need to duplicate them in this
102330>>>>>    // class and "relay" them to the parent object.
102330>>>>>    Procedure Set pbToANSI Boolean bState
102332>>>>>        Set private.pbToANSI  to bState
102333>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
102334>>>>>        Delegate Set pbToANSI to bState
102336>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
102337>>>>>    End_Procedure
102338>>>>>
102338>>>>>    Function pbToANSI Returns Boolean
102340>>>>>        Function_Return (private.pbToAnsi(Self))
102341>>>>>    End_Function
102342>>>>>
102342>>>>>    Procedure Set pbRecnum Boolean bState
102344>>>>>        Set private.pbRecnum  to bState
102345>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
102346>>>>>        Delegate Set pbRecnum to bState
102348>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
102349>>>>>    End_Procedure
102350>>>>>
102350>>>>>    Function pbRecnum Returns Boolean
102352>>>>>        Function_Return (private.pbRecnum(Self))
102353>>>>>    End_Function
102354>>>>>
102354>>>>>    Procedure Set pbCopyData Boolean bState
102356>>>>>        Set private.pbCopyData  to bState
102357>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
102358>>>>>        Delegate Set pbCopyData to bState
102360>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
102361>>>>>    End_Procedure
102362>>>>>
102362>>>>>    Function pbCopyData Returns Boolean
102364>>>>>        Function_Return (private.pbCopyData(Self))
102365>>>>>    End_Function
102366>>>>>
102366>>>>>    // ToDo: Should we put these four properties under another "Property Panel" section?
102366>>>>>    Procedure Set pbApiTableUpdateAuto Boolean bState
102368>>>>>        Set private.pbApiTableUpdateAuto  to bState
102369>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
102370>>>>>        Set pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
102371>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
102372>>>>>    End_Procedure
102373>>>>>
102373>>>>>    Function pbApiTableUpdateAuto Returns Boolean
102375>>>>>        Function_Return (private.pbApiTableUpdateAuto(Self))
102376>>>>>    End_Function
102377>>>>>
102377>>>>>    Procedure Set pbCompareDate_DateTime Boolean bState
102379>>>>>        Set private.pbCompareDate_DateTime  to bState
102380>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
102381>>>>>        Set pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
102382>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
102383>>>>>    End_Procedure
102384>>>>>
102384>>>>>    Function pbCompareDate_DateTime Returns Boolean
102386>>>>>        Function_Return (private.pbCompareDate_DateTime(Self))
102387>>>>>    End_Function
102388>>>>>
102388>>>>>    Procedure Set pbCompareIndexAscending Boolean bState
102390>>>>>        Set private.pbCompareIndexAscending  to bState
102391>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
102392>>>>>        Set pbCompareIndexAscending of ghoSQLConnectionHandler to bState
102393>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
102394>>>>>    End_Procedure
102395>>>>>
102395>>>>>    Function pbCompareIndexAscending Returns Boolean
102397>>>>>        Function_Return (private.pbCompareIndexAscending(Self))
102398>>>>>    End_Function
102399>>>>>
102399>>>>>    Procedure Set pbCompareIndexUppercase Boolean bState
102401>>>>>        Set private.pbCompareIndexUppercase  to bState
102402>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
102403>>>>>        Set pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
102404>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
102405>>>>>    End_Procedure
102406>>>>>
102406>>>>>    Function pbCompareIndexUppercase Returns Boolean
102408>>>>>        Function_Return (private.pbCompareIndexUppercase(Self))
102409>>>>>    End_Function
102410>>>>>
102410>>>>>    Procedure Set psSchema String sValue
102412>>>>>        Set private.psSchema  to sValue
102413>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
102414>>>>>        Delegate Set psSchema to sValue
102416>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
102417>>>>>    End_Procedure
102418>>>>>
102418>>>>>    // First retrieve the private value that might have been set in the object.
102418>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
102418>>>>>    // it might have been specified in the SQLConnections.ini file.
102418>>>>>    Function psSchema Returns String
102420>>>>>        String sValue
102420>>>>>        Get private.psSchema to sValue
102421>>>>>        If (sValue = "") Begin
102423>>>>>            Get psSchema of ghoSQLConnectionHandler to sValue
102424>>>>>        End
102424>>>>>>
102424>>>>>        Function_Return sValue
102425>>>>>    End_Function
102426>>>>>
102426>>>>>    Procedure Set psBaseTableSpace String sValue
102428>>>>>        Set private.psBaseTableSpace  to sValue
102429>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
102430>>>>>        Delegate Set psBaseTableSpace to sValue
102432>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
102433>>>>>    End_Procedure
102434>>>>>
102434>>>>>    // First retrieve the private value that might have been set in the object.
102434>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
102434>>>>>    // it might have been specified in the SQLConnections.ini file.
102434>>>>>    Function psBaseTableSpace Returns String
102436>>>>>        String sValue
102436>>>>>        Get private.psBaseTableSpace to sValue
102437>>>>>        If (sValue = "") Begin
102439>>>>>            Get psBaseTableSpace of ghoSQLConnectionHandler to sValue
102440>>>>>        End
102440>>>>>>
102440>>>>>        Function_Return sValue
102441>>>>>    End_Function
102442>>>>>
102442>>>>>    Procedure Set psLongTableSpace String sValue
102444>>>>>        Set private.psLongTableSpace  to sValue
102445>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
102446>>>>>        Delegate Set psLongTableSpace to sValue
102448>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
102449>>>>>    End_Procedure
102450>>>>>
102450>>>>>    // First retrieve the private value that might have been set in the object.
102450>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
102450>>>>>    // it might have been specified in the SQLConnections.ini file.
102450>>>>>    Function psLongTableSpace Returns String
102452>>>>>        String sValue
102452>>>>>        Get private.psLongTableSpace to sValue
102453>>>>>        If (sValue = "") Begin
102455>>>>>            Get psLongTableSpace of ghoSQLConnectionHandler to sValue
102456>>>>>        End
102456>>>>>>
102456>>>>>        Function_Return sValue
102457>>>>>    End_Function
102458>>>>>
102458>>>>>    Procedure Set psIndexTableSpace String sValue
102460>>>>>        Set private.psIndexTableSpace  to sValue
102461>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
102462>>>>>        Delegate Set psIndexTableSpace to sValue
102464>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
102465>>>>>    End_Procedure
102466>>>>>
102466>>>>>    // First retrieve the private value that might have been set in the object.
102466>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
102466>>>>>    // it might have been specified in the SQLConnections.ini file.
102466>>>>>    Function psIndexTableSpace Returns String
102468>>>>>        String sValue
102468>>>>>        Get private.psIndexTableSpace to sValue
102469>>>>>        If (sValue = "") Begin
102471>>>>>            Get psIndexTableSpace of ghoSQLConnectionHandler to sValue
102472>>>>>        End
102472>>>>>>
102472>>>>>        Function_Return sValue
102473>>>>>    End_Function
102474>>>>>
102474>>>>>    Procedure Set psDriverDefaultValueASCII String sValue
102476>>>>>        Set private.psDriverDefaultValueASCII  to sValue
102477>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
102478>>>>>        Delegate Set psDriverDefaultValueASCII to sValue
102480>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
102481>>>>>    End_Procedure
102482>>>>>
102482>>>>>    // First retrieve the private value that might have been set in the object.
102482>>>>>    // If blank; get it from the parent object
102482>>>>>    Function psDriverDefaultValueASCII Returns String
102484>>>>>        String sValue
102484>>>>>        Get private.psDriverDefaultValueASCII to sValue
102485>>>>>        If (sValue = "") Begin
102487>>>>>            Delegate Get psDriverDefaultValueASCII to sValue
102489>>>>>        End
102489>>>>>>
102489>>>>>        Function_Return sValue
102490>>>>>    End_Function
102491>>>>>
102491>>>>>    Procedure Set psDriverDefaultValueBinary String sValue
102493>>>>>        Set private.psDriverDefaultValueBinary  to sValue
102494>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
102495>>>>>        Delegate Set psDriverDefaultValueBinary to sValue
102497>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
102498>>>>>    End_Procedure
102499>>>>>
102499>>>>>    // First retrieve the private value that might have been set in the object.
102499>>>>>    // If blank; get it from the parent object
102499>>>>>    Function psDriverDefaultValueBinary Returns String
102501>>>>>        String sValue
102501>>>>>        Get private.psDriverDefaultValueBinary to sValue
102502>>>>>        If (sValue = "") Begin
102504>>>>>            Delegate Get psDriverDefaultValueBinary to sValue
102506>>>>>        End
102506>>>>>>
102506>>>>>        Function_Return sValue
102507>>>>>    End_Function
102508>>>>>
102508>>>>>    Procedure Set psDriverDefaultValueDate String sValue
102510>>>>>        Set private.psDriverDefaultValueDate  to sValue
102511>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
102512>>>>>        Delegate Set psDriverDefaultValueDate to sValue
102514>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
102515>>>>>    End_Procedure
102516>>>>>
102516>>>>>    // First retrieve the private value that might have been set in the object.
102516>>>>>    // If blank; get it from the parent object
102516>>>>>    Function psDriverDefaultValueDate Returns String
102518>>>>>        String sValue
102518>>>>>        Get private.psDriverDefaultValueDate to sValue
102519>>>>>        If (sValue = "") Begin
102521>>>>>            Delegate Get psDriverDefaultValueDate to sValue
102523>>>>>        End
102523>>>>>>
102523>>>>>        Function_Return sValue
102524>>>>>    End_Function
102525>>>>>
102525>>>>>    Procedure Set psDriverDefaultValueDateTime String sValue
102527>>>>>        Set private.psDriverDefaultValueDateTime  to sValue
102528>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
102529>>>>>        Delegate Set psDriverDefaultValueDateTime to sValue
102531>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
102532>>>>>    End_Procedure
102533>>>>>
102533>>>>>    // First retrieve the private value that might have been set in the object.
102533>>>>>    // If blank; get it from the parent object
102533>>>>>    Function psDriverDefaultValueDateTime Returns String
102535>>>>>        String sValue
102535>>>>>        Get private.psDriverDefaultValueDateTime to sValue
102536>>>>>        If (sValue = "") Begin
102538>>>>>            Delegate Get psDriverDefaultValueDateTime to sValue
102540>>>>>        End
102540>>>>>>
102540>>>>>        Function_Return sValue
102541>>>>>    End_Function
102542>>>>>
102542>>>>>    Procedure Set psDriverDefaultValueNumeric String sValue
102544>>>>>        Set private.psDriverDefaultValueNumeric  to sValue
102545>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
102546>>>>>        Delegate Set psDriverDefaultValueNumeric to sValue
102548>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
102549>>>>>    End_Procedure
102550>>>>>
102550>>>>>    // First retrieve the private value that might have been set in the object.
102550>>>>>    // If blank; get it from the parent object
102550>>>>>    Function psDriverDefaultValueNumeric Returns String
102552>>>>>        String sValue
102552>>>>>        Get private.psDriverDefaultValueNumeric to sValue
102553>>>>>        If (sValue = "") Begin
102555>>>>>            Delegate Get psDriverDefaultValueNumeric to sValue
102557>>>>>        End
102557>>>>>>
102557>>>>>        Function_Return sValue
102558>>>>>    End_Function
102559>>>>>
102559>>>>>    Procedure Set psDriverDefaultValueText String sValue
102561>>>>>        Set private.psDriverDefaultValueText  to sValue
102562>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
102563>>>>>        Delegate Set psDriverDefaultValueText to sValue
102565>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
102566>>>>>    End_Procedure
102567>>>>>
102567>>>>>    // First retrieve the private value that might have been set in the object.
102567>>>>>    // If blank; get it from the parent object
102567>>>>>    Function psDriverDefaultValueText Returns String
102569>>>>>        String sValue
102569>>>>>        Get private.psDriverDefaultValueText to sValue
102570>>>>>        If (sValue = "") Begin
102572>>>>>            Delegate Get psDriverDefaultValueText to sValue
102574>>>>>        End
102574>>>>>>
102574>>>>>        Function_Return sValue
102575>>>>>    End_Function
102576>>>>>
102576>>>>>    Procedure Set pbDriverDefaultNullableASCII Boolean bState
102578>>>>>        Set private.pbDriverDefaultNullableASCII  to bState
102579>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
102580>>>>>        Delegate Set pbDriverDefaultNullableASCII to bState
102582>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
102583>>>>>    End_Procedure
102584>>>>>
102584>>>>>    // First retrieve the private value that might have been set in the object.
102584>>>>>    // If blank; get it from the parent object
102584>>>>>    Function pbDriverDefaultNullableASCII Returns Boolean
102586>>>>>        Boolean bState
102586>>>>>        Get private.pbDriverDefaultNullableASCII to bState
102587>>>>>        If (bState = False) Begin
102589>>>>>            Delegate Get pbDriverDefaultNullableASCII to bState
102591>>>>>        End
102591>>>>>>
102591>>>>>        Function_Return bState
102592>>>>>    End_Function
102593>>>>>
102593>>>>>    Procedure Set pbDriverDefaultNullableBinary Boolean bState
102595>>>>>        Set private.pbDriverDefaultNullableBinary  to bState
102596>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
102597>>>>>        Delegate Set pbDriverDefaultNullableBinary to bState
102599>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
102600>>>>>    End_Procedure
102601>>>>>
102601>>>>>    // First retrieve the private value that might have been set in the object.
102601>>>>>    // If blank; get it from the parent object
102601>>>>>    Function pbDriverDefaultNullableBinary Returns Boolean
102603>>>>>        Boolean bState
102603>>>>>        Get private.pbDriverDefaultNullableBinary to bState
102604>>>>>        If (bState = False) Begin
102606>>>>>            Delegate Get pbDriverDefaultNullableBinary to bState
102608>>>>>        End
102608>>>>>>
102608>>>>>        Function_Return bState
102609>>>>>    End_Function
102610>>>>>
102610>>>>>    Procedure Set pbDriverDefaultNullableDate Boolean bState
102612>>>>>        Set private.pbDriverDefaultNullableDate  to bState
102613>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
102614>>>>>        Delegate Set pbDriverDefaultNullableDate to bState
102616>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
102617>>>>>    End_Procedure
102618>>>>>
102618>>>>>    // First retrieve the private value that might have been set in the object.
102618>>>>>    // If blank; get it from the parent object
102618>>>>>    Function pbDriverDefaultNullableDate Returns Boolean
102620>>>>>        Boolean bState
102620>>>>>        Get private.pbDriverDefaultNullableDate to bState
102621>>>>>        If (bState = False) Begin
102623>>>>>            Delegate Get pbDriverDefaultNullableDate to bState
102625>>>>>        End
102625>>>>>>
102625>>>>>        Function_Return bState
102626>>>>>    End_Function
102627>>>>>
102627>>>>>    Procedure Set pbDriverDefaultNullableDateTime Boolean bState
102629>>>>>        Set private.pbDriverDefaultNullableDateTime  to bState
102630>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
102631>>>>>        Delegate Set pbDriverDefaultNullableDateTime to bState
102633>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
102634>>>>>    End_Procedure
102635>>>>>
102635>>>>>    // First retrieve the private value that might have been set in the object.
102635>>>>>    // If blank; get it from the parent object
102635>>>>>    Function pbDriverDefaultNullableDateTime Returns Boolean
102637>>>>>        Boolean bState
102637>>>>>        Get private.pbDriverDefaultNullableDateTime to bState
102638>>>>>        If (bState = False) Begin
102640>>>>>            Delegate Get pbDriverDefaultNullableDateTime to bState
102642>>>>>        End
102642>>>>>>
102642>>>>>        Function_Return bState
102643>>>>>    End_Function
102644>>>>>
102644>>>>>    Procedure Set pbDriverDefaultNullableNumeric Boolean bState
102646>>>>>        Set private.pbDriverDefaultNullableNumeric  to bState
102647>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
102648>>>>>        Delegate Set pbDriverDefaultNullableNumeric to bState
102650>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
102651>>>>>    End_Procedure
102652>>>>>
102652>>>>>    // First retrieve the private value that might have been set in the object.
102652>>>>>    // If blank; get it from the parent object
102652>>>>>    Function pbDriverDefaultNullableNumeric Returns Boolean
102654>>>>>        Boolean bState
102654>>>>>        Get private.pbDriverDefaultNullableNumeric to bState
102655>>>>>        If (bState = False) Begin
102657>>>>>            Delegate Get pbDriverDefaultNullableNumeric to bState
102659>>>>>        End
102659>>>>>>
102659>>>>>        Function_Return bState
102660>>>>>    End_Function
102661>>>>>
102661>>>>>    Procedure Set pbDriverDefaultNullableText Boolean bState
102663>>>>>        Set private.pbDriverDefaultNullableText  to bState
102664>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
102665>>>>>        Delegate Set pbDriverDefaultNullableText to bState
102667>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
102668>>>>>    End_Procedure
102669>>>>>
102669>>>>>    // First retrieve the private value that might have been set in the object.
102669>>>>>    // If blank; get it from the parent object
102669>>>>>    Function pbDriverDefaultNullableText Returns Boolean
102671>>>>>        Boolean bState
102671>>>>>        Get private.pbDriverDefaultNullableText to bState
102672>>>>>        If (bState = False) Begin
102674>>>>>            Delegate Get pbDriverDefaultNullableText to bState
102676>>>>>        End
102676>>>>>>
102676>>>>>        Function_Return bState
102677>>>>>    End_Function
102678>>>>>
102678>>>>>    Function ApiTableConvertToSQL Handle hTable Returns Boolean
102680>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK
102680>>>>>        String sDriverID sSchema sBaseTableSpace sLongTableSpace sIndexTableSpace
102680>>>>>
102680>>>>>        Get psDriverID to sDriverID
102681>>>>>        Get psSchema to sSchema
102682>>>>>
102682>>>>>        Get psBaseTableSpace to sBaseTableSpace
102683>>>>>        If (sBaseTableSpace <> "") Begin
102685>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
102686>>>>>            Delegate Set psBaseTableSpace to sBaseTableSpace
102688>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
102689>>>>>        End
102689>>>>>>
102689>>>>>
102689>>>>>        Get psLongTableSpace to sLongTableSpace
102690>>>>>        If (sLongTableSpace <> "") Begin
102692>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
102693>>>>>            Delegate Set psLongTableSpace to sLongTableSpace
102695>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
102696>>>>>        End
102696>>>>>>
102696>>>>>
102696>>>>>        Get psIndexTableSpace to sIndexTableSpace
102697>>>>>        If (sIndexTableSpace <> "") Begin
102699>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
102700>>>>>            Delegate Set psIndexTableSpace to sIndexTableSpace
102702>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
102703>>>>>        End
102703>>>>>>
102703>>>>>
102703>>>>>        Get pbUseConnectionID to bUseConnectionID
102704>>>>>        Get pbToANSI          to bToANSI
102705>>>>>        Get pbRecnum          to bRecnum
102706>>>>>        Get pbCopyData        to bCopyData
102707>>>>>
102707>>>>>        Get ApiTableConvertToSQL_Ex hTable sDriverID bUseConnectionID bToANSI bRecnum bCopyData to bOK
102708>>>>>
102708>>>>>        Function_Return bOK
102709>>>>>    End_Function
102710>>>>>
102710>>>>>//    Function ApiTableMoveAllToBackupFolder Returns Boolean
102710>>>>>//        Boolean bOK bExists
102710>>>>>//        String sDataPath sBackupFolder
102710>>>>>//        
102710>>>>>//        Set Message_Text of ghoStatusPanel to "Moving Embedded (*.dat) files to Backup folder."
102710>>>>>//        Move CS_DUFBackupDataFolder to sBackupFolder
102710>>>>>//        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
102710>>>>>//        Get vFolderFormat sDataPath to sDataPath
102710>>>>>//        
102710>>>>>//        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
102710>>>>>//        If (bExists = False) Begin
102710>>>>>//            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
102710>>>>>//            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
102710>>>>>//            If (bExists = False) Begin
102710>>>>>//                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all *.dat and *.k?? files to. You need to move them somewhere manually.")
102710>>>>>//                Function_Return False
102710>>>>>//            End                                                                                                                                            
102710>>>>>//            Get vMoveFile (sDataPath + "*.dat") (sDataPath + sBackupFolder) to bOK
102710>>>>>//            Get vMoveFile (sDataPath + "*.hdr") (sDataPath + sBackupFolder) to bOK
102710>>>>>//            Get vMoveFile (sDataPath + "*.k??") (sDataPath + sBackupFolder) to bOK
102710>>>>>//            Get vMoveFile (sDataPath + "*.vld") (sDataPath + sBackupFolder) to bOK
102710>>>>>//        End
102710>>>>>//        
102710>>>>>//        Set Message_Text of ghoStatusPanel to ""
102710>>>>>//        Function_Return bOK
102710>>>>>//    End_Function
102710>>>>>//
102710>>>>>    // This is automatically called after the OnUpdate
102710>>>>>    // event has been executed. It will automatically update the
102710>>>>>    // version database field/column with the "pnVersionNumber"
102710>>>>>    // value of the parent cDbUpdateHandler class - if it has been changed.
102710>>>>>    Procedure UpdateVersionColumnValue
102712>>>>>        Number nVersion nCurrentValue
102712>>>>>        Integer hTable iColumn
102712>>>>>        Boolean bVersionUpdate bDbUpdateErrorHasOccured bUseCustomDbVersion
102712>>>>>
102712>>>>>        // This is a property of the container class; cDbUpdateHandler that gets set when
102712>>>>>        // an error occurres when processing ESQL or database API messages of the cDbUpdateFunctionLibrary.
102712>>>>>        Delegate Get pbDbUpdateErrorHasOccured to bDbUpdateErrorHasOccured
102714>>>>>        Get pbVersionUpdate to bVersionUpdate
102715>>>>>
102715>>>>>        If (bVersionUpdate = True and bDbUpdateErrorHasOccured = False) Begin
102717>>>>>            Get pnVersionNumber to nVersion
102718>>>>>            Delegate Get piDbVersionFileNumber  to hTable
102720>>>>>            Delegate Get piDbVersionFieldNumber to iColumn
102722>>>>>            // NB! We need to permanently close tables as they e.g. now might no longer be embedded
102722>>>>>            // but instead SQL tables. If we don't the "old" embedded table will be opened instead.
102722>>>>>            Close DF_ALL DF_PERMANENT
102723>>>>>
102723>>>>>            Open hTable
102725>>>>>
102725>>>>>            // It is then the developer responsibility to take care of finding
102725>>>>>            // the correct record that is to be updated (The DbVersion table is not used). 
102725>>>>>            Delegate Get pbUseCustomDbVersion to bUseCustomDbVersion
102727>>>>>            If (bUseCustomDbVersion = True) Begin
102729>>>>>                Delegate Send OnFindVersionRecord   // cDbUpdateHandler object event (Programmer's hook!).
102731>>>>>            End
102731>>>>>>
102731>>>>>
102731>>>>>            Get_Field_Value hTable iColumn to nCurrentValue
102734>>>>>            If (nCurrentValue < nVersion) Begin
102736>>>>>                Lock
102737>>>>>>
102737>>>>>                    If (bUseCustomDbVersion = False) Begin
102739>>>>>                        Vfind hTable Recnum GE                            
102741>>>>>                    End
102741>>>>>>
102741>>>>>                    Set_Field_Value hTable iColumn to nVersion
102744>>>>>                    SaveRecord hTable
102745>>>>>                Unlock
102746>>>>>>
102746>>>>>            End
102746>>>>>>
102746>>>>>            Close hTable
102747>>>>>        End
102747>>>>>>
102747>>>>>    End_Procedure
102748>>>>>
102748>>>>>// Property of the container object (cDbUpdateHandler)
102748>>>>>Register_Function piCurrentErrorHandlerID Returns Integer
102748>>>>>
102748>>>>>    Procedure End_Construct_Object
102750>>>>>        Forward Send End_Construct_Object
102752>>>>>        Send ProcessUpdate True
102753>>>>>    End_Procedure
102754>>>>>    
102754>>>>>    Procedure ProcessUpdate Boolean bShouldTestForDuplicateVersionNumbers
102756>>>>>        Number nVersion nCurrentValue
102756>>>>>        Integer hTable iColumn iSize iDbVersionFileNumber iStatus
102756>>>>>        Boolean bStopOnFirstError bDbUpdateErrorHasOccured bContinueOnError bOpened bSystemTable bUseCustomDbVersion bTableExists bOnPreUpdateExecuted
102756>>>>>        String sObjectName
102756>>>>>        tDbVersionInfo[] dbVersionInfoArray
102756>>>>>        tDbVersionInfo[] dbVersionInfoArray
102757>>>>>
102757>>>>>        Delegate Set Private.pbUpdateVersionObjectError to False
102759>>>>>
102759>>>>>        // If the programmer forgot to set the version number we do not allow for the application
102759>>>>>        // to continue to run, as this potentially could endanger the integrity of the database. E.g. if
102759>>>>>        // one database update is depended on an earlier update and that earlier version
102759>>>>>        // update was never executed it could lead to disastrous results.
102759>>>>>        // This is a programmer error and should be discovered before any customer sees it. Thus no point in translating...
102759>>>>>        Get pnVersionNumber to nVersion
102760>>>>>        If (nVersion = 0) Begin
102762>>>>>            Get piCurrentErrorHandlerID to Error_Object_Id
102763>>>>>            Move (Name(Self)) to sObjectName
102764>>>>>            Error DFERR_PROGRAM ("The pnVersionNumber property was not set properly by the programmer for the following object; Program will now exit!\n\n" + sObjectName)
102765>>>>>>
102765>>>>>            Send Exit_Application
102766>>>>>        End
102766>>>>>>
102766>>>>>
102766>>>>>        // These are send to the parent container object (cDbUpdateHandler). The order is very sensitive!
102766>>>>>        // Hook event for the developer to e.g. create a database before the update events starts.
102766>>>>>        Delegate Get Private.pbOnPreUpdateExecuted to bOnPreUpdateExecuted
102768>>>>>        If (bOnPreUpdateExecuted = False) Begin
102770>>>>>            Delegate Send OnPreUpdate
102772>>>>>            Delegate Set Private.pbOnPreUpdateExecuted to True
102774>>>>>        End
102774>>>>>>
102774>>>>>        
102774>>>>>        Delegate Get piDbVersionFileNumber to iDbVersionFileNumber
102776>>>>>        
102776>>>>>        Delegate Get pbUseCustomDbVersion to bUseCustomDbVersion
102778>>>>>        If (bUseCustomDbVersion = False) Begin
102780>>>>>//            Delegate Send CheckAutoCreateDbVersionTable // cDbUpdateHandler object event.
102780>>>>>        End
102780>>>>>>
102780>>>>>        Else Begin
102781>>>>>            Get UtilTableExists of ghoDbUpdateFunctionLibrary iDbVersionFileNumber to bTableExists
102782>>>>>            If (bTableExists = False) Begin
102784>>>>>                Delegate Send OnCreateCustomDbVersionTable
102786>>>>>            End
102786>>>>>>
102786>>>>>        End
102786>>>>>>
102786>>>>>        
102786>>>>>        // We now check that two or more cDbVersion objects does not have the same pnVersionNumber.
102786>>>>>        // Note that the paDbVersionInfoArray is a property of the container object (cDbUpdateHandler)
102786>>>>>        If (bShouldTestForDuplicateVersionNumbers = True) Begin
102788>>>>>            Delegate Get paDbVersionInfoArray to dbVersionInfoArray
102790>>>>>            Move (SizeOfArray(dbVersionInfoArray)) to iSize
102791>>>>>            Move nVersion to dbVersionInfoArray[iSize].nVersionNumber
102792>>>>>            Move (Self)   to dbVersionInfoArray[iSize].hObject
102793>>>>>            Delegate Set paDbVersionInfoArray to dbVersionInfoArray
102795>>>>>            Delegate Send CheckForDuplicates nVersion   // cDbUpdateHandler object event.
102797>>>>>        End
102797>>>>>>
102797>>>>>
102797>>>>>        Delegate Get piDbVersionFileNumber  to hTable
102799>>>>>        Delegate Get piDbVersionFieldNumber to iColumn
102801>>>>>
102801>>>>>        Open hTable
102803>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
102806>>>>>        If (bOpened = False) Begin
102808>>>>>            Send Stop_Box CS_DUF_DbUpdateTableMissing
102809>>>>>            Send Exit_Application
102810>>>>>        End
102810>>>>>>
102810>>>>>        
102810>>>>>        // It can happen that the table isn't initialized with a record even though it is a system table,
102810>>>>>        // in case we take care of it here.
102810>>>>>        Get_Attribute DF_FILE_STATUS of hTable to iStatus
102813>>>>>        If (iStatus = DF_FILE_INACTIVE) Begin
102815>>>>>            Vfind hTable 0 GT
102817>>>>>        End
102817>>>>>>
102817>>>>>        Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bSystemTable
102820>>>>>        If (bSystemTable = True) Begin
102822>>>>>            Get_Field_Value hTable iColumn to nCurrentValue
102825>>>>>        End
102825>>>>>>
102825>>>>>        Else Begin
102826>>>>>            If (bUseCustomDbVersion = True) Begin
102828>>>>>                Send OnFindVersionRecord
102829>>>>>                Get_Field_Value hTable iColumn to nCurrentValue
102832>>>>>            End
102832>>>>>>
102832>>>>>        End
102832>>>>>>
102832>>>>>
102832>>>>>        Close hTable
102833>>>>>
102833>>>>>        // We also guard from missing 'DatabaseVersionInfoTable' and column properties settings.
102833>>>>>        // If not set we do nothing.
102833>>>>>        If (nCurrentValue < nVersion) Begin
102835>>>>>
102835>>>>>            // If pbStopOnFirstError is True in the parent, the idea is that we do _no_ further
102835>>>>>            // execution of database update code. So if true _and_ one error
102835>>>>>            // has already occured; we're out of here.
102835>>>>>            Delegate Get pbStopOnFirstError        to bStopOnFirstError
102837>>>>>            Delegate Get pbDbUpdateErrorHasOccured to bDbUpdateErrorHasOccured
102839>>>>>            If (bStopOnFirstError = True) Begin
102841>>>>>                If (bDbUpdateErrorHasOccured = True) Begin
102843>>>>>                    Procedure_Return
102844>>>>>                End
102844>>>>>>
102844>>>>>            End
102844>>>>>>
102844>>>>>
102844>>>>>            // This is send to the parent container object (cDbUpdateHandler)
102844>>>>>            Delegate Send InitDatabaseUpdate (Self)    // cDbUpdateHandler object event.
102846>>>>>
102846>>>>>            // If the parent property pbContinueOnError = False, an update
102846>>>>>            // of a following cDbUpdateVersion object should not take place and we're out of here.
102846>>>>>            Delegate Get pbContinueOnError to bContinueOnError
102848>>>>>            If (bContinueOnError = False and bDbUpdateErrorHasOccured = True) Begin
102850>>>>>                Procedure_Return
102851>>>>>            End
102851>>>>>>
102851>>>>>
102851>>>>>            Delegate Set pnCurrentVersionUpdate to nVersion
102853>>>>>
102853>>>>>            Set Title_Text of ghoStatusPanel to (CS_DUF_UpdateVersion * CS_DUF_UpdateFromVersion * String(nCurrentValue) * CS_DUF_UpdateToVersion * String(nVersion))
102854>>>>>
102854>>>>>            // *** Programmer's main hook event for database update functions:
102854>>>>>            Send OnUpdate
102855>>>>>
102855>>>>>            Set pbVersionUpdate to True
102856>>>>>            Send UpdateVersionColumnValue
102857>>>>>            Delegate Set pbDatabaseWasUpdated to True   // cDbUpdateHandler property.
102859>>>>>        End
102859>>>>>>
102859>>>>>
102859>>>>>    End_Procedure
102860>>>>>
102860>>>>>End_Class
102861>>>Use cDbUpdateUserCount.pkg
Including file: cDbUpdateUserCount.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateUserCount.pkg)
102861>>>>>//****************************************************************************
102861>>>>>// $Module type: Class
102861>>>>>// $Module name: cDbUpdateUserCount.pkg
102861>>>>>// $Author     : Emil Stojanov Quantaris B.V.
102861>>>>>//
102861>>>>>//               Collected from DAW's newsgroups.
102861>>>>>//
102861>>>>>// Description : It uses the windows API to lock bytes in a file.
102861>>>>>//               If the application or PC craches it will release the lock
102861>>>>>//               automatically.
102861>>>>>//
102861>>>>>// Note 1      : It will count the number of running app's, so if a
102861>>>>>//               user starts the app twice on one machine it will count as two users.
102861>>>>>// Note 2      : The class was originally named cUserCount by Emil Stojanov.
102861>>>>>//               However, to not conflict with any other usage of this class it was
102861>>>>>//               renamed to "fit" into the "Database Update Framework" (cDbUpdateHandler
102861>>>>>//               and cDbUpdateVersion classes)
102861>>>>>//
102861>>>>>// $Rev History:
102861>>>>>//    2008-10-17  Module header created (Militaty data format)
102861>>>>>//    2008-10-17  Minor changes by Nils G Svedmyr. Created UI text constants
102861>>>>>//                for easy translation to other languages.
102861>>>>>//                Added the tUserCount struct for easier passing of parameters.
102861>>>>>//                Added the ApplicationPath message.
102861>>>>>//****************************************************************************
102861>>>>>Use LanguageText.pkg
102861>>>>>Use cDbUpdateUserCount.inc
Including file: cDbUpdateUserCount.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateUserCount.inc)
102861>>>>>>>Use GlobalFunctionsProcedures.pkg
102861>>>>>>>// Sample:
102861>>>>>>>// Get DoSetDefaultPrinter "HP LaserJet 4" to bVoid
102861>>>>>>>
102861>>>>>>>
102861>>>>>>>// Symbols used by UserCounting
102861>>>>>>>    Define GENERIC_READ         for |CI$80000000
102861>>>>>>>    Define GENERIC_WRITE        for |CI$40000000
102861>>>>>>>    Define GENERIC_EXECUTE      for |CI$20000000
102861>>>>>>>    Define GENERIC_ALL          for |CI$10000000
102861>>>>>>>    Define CREATE_NEW           for 1
102861>>>>>>>    Define CREATE_ALWAYS        for 2
102861>>>>>>>    Define OPEN_EXISTING        for 3
102861>>>>>>>    Define OPEN_ALWAYS          for 4
102861>>>>>>>    Define TRUNCATE_EXISTING    for 5
102861>>>>>>>    Define FILE_BEGIN           for 0
102861>>>>>>>    Define FILE_CURRENT         for 1
102861>>>>>>>    Define FILE_END             for 2
102861>>>>>>>    Define FILE_SHARE_READ      for |CI$00000001
102861>>>>>>>    Define FILE_SHARE_WRITE     for |CI$00000002
102861>>>>>>>    Define FILE_SHARE_DELETE    for |CI$00000004
102861>>>>>>>    Define FILE_FLAG_WRITE_THROUGH            for |CI$80000000
102861>>>>>>>    Define _MAX_PATH  for 260
102861>>>>>>>    Define _MAX_DRIVE for 3
102861>>>>>>>    Define _MAX_DIR   for 256
102861>>>>>>>    Define _MAX_FNAME for 256
102861>>>>>>>    Define _MAX_EXT   for 256
102861>>>>>>>
102861>>>>>>>External_Function Win32_CreateFile "CreateFileA" KERNEL32.DLL ;    Pointer lpFileName ;              // file name    DWord dwDesiredAccess ;           // access mode    DWord dwShareMode ;               // share mode    Pointer lpSecurityAttributes ;    // SD    DWord dwCreationDisposition ;     // how to create    DWord dwFlagsAndAttributes ;      // file attributes    Handle hTemplateFile ;            // handle to template file    Returns Handle
102862>>>>>>>
102862>>>>>>>External_Function Win32_ReadFile "ReadFile" KERNEL32.DLL ;    Handle hFile ;                  // handle to file    Pointer lpBuffer ;              // pointer to the buffer that receives the data    dWord nNumberOfBytesToRead ;    // number of bytes to read    Pointer lpNumberOfBytesRead ;   // number of bytes read    Pointer lpOverlapped ;          // pointer to an overlapped structure    Returns Integer
102863>>>>>>>
102863>>>>>>>External_Function Win32_WriteFile "WriteFile" KERNEL32.DLL ;    Handle hFile ;                      // handle to file    Pointer lpBuffer ;                  // pointer to buffer containing data to write    dWord nNumberOfBytesToWrite ;       // number of bytes to write    Pointer lpNumberOfBytesWritten ;    // number of bytes written    Pointer lpOverlapped ;              // pointer to an overlapped structure    Returns Integer
102864>>>>>>>
102864>>>>>>>External_Function Win32_LockFile "LockFile" KERNEL32.DLL ;    Handle hFile ;                      // handle to file    dWord dwFileOffsetLow ;             // low-order word of startposition    dWord dwFileOffsetHigh ;            // high-order word of startposition    dWord nNumberOfBytesToLockLow ;     // low-order word of length    dWord nNumberOfBytesToLockHigh ;    // high-order word of length    Returns Integer
102865>>>>>>>
102865>>>>>>>External_Function Win32_UnlockFile "UnlockFile" KERNEL32.DLL ;    Handle hFile ;                      // handle to file    dWord dwFileOffsetLow ;             // low-order word of startposition    dWord dwFileOffsetHigh ;            // high-order word of startposition    dWord nNumberOfBytesToUnLockLow ;   // low-order word of length    dWord nNumberOfBytesToUnLockHigh ;  // high-order word of length    Returns Integer
102866>>>>>>>
102866>>>>>>>External_Function Win32_SetFilePointer "SetFilePointer" KERNEL32.DLL ;    Handle hFile ;                  // handle to file    Integer lDistanceToMove ;       // bytes to move pointer (low-order 32-bits)    Pointer lpDistanceToMoveHigh ;  // bytes to move pointer (high-order 32-bits)    dWord dwMoveMethod ;            // starting point    Returns dWord
102867>>>>>>>
102867>>>>>>>External_Function Win32_CloseHandle "CloseHandle" KERNEL32.DLL ;    Handle hObject ;    // handle to object    Returns Integer
102868>>>>>>>
102868>>>>>>>External_Function SetDefaultPrinterEf "SetDefaultPrinterA" winspool.drv Pointer lpPrinter Returns Boolean
102869>>>>>>>// Sample:
102869>>>>>>>// Get DoSetDefaultPrinter "HP LaserJet 4" to bVoid
102869>>>>>>>Function DoSetDefaultPrinter String sPrinter Returns Boolean
102871>>>>>>>    Boolean bReturn
102871>>>>>>>    Move (Utf8ToAnsi(sPrinter)) to sPrinter
102872>>>>>>>    Move (sPrinter + (Character(0))) to sPrinter
102873>>>>>>>    Move (SetDefaultPrinterEf(AddressOf(sPrinter))) to bReturn
102874>>>>>>>    Function_Return bReturn
102875>>>>>>>End_Function
102876>>>>>Use vWin32fh.pkg
102876>>>>>Use seq_chnl.pkg
102876>>>>>
102876>>>>>// User interface constant strings:
102876>>>>>    Define CS_UserCountError            for "User count error:"
102876>>>>>    Define CS_UnableToInitUserCountSys  for "Unable to initialize user counting system!"
102876>>>>>    Define CS_UnableResetUserCountSys   for "Error resetting usercounting system!"
102876>>>>>    Define CS_ErrorAdvancingPointer     for "Error advancing file pointer!"
102876>>>>>    Define CS_MaxNoOfUserExceeded       for "Maximum number of users exceeded!"
102876>>>>>
102876>>>>>
102876>>>>>
102876>>>>>
102876>>>>>
102876>>>>>
102876>>>>>
102876>>>>>
102876>>>>>
102876>>>>>
102876>>>>>
102876>>>>>
102876>>>>>
102876>>>>>    Struct tUserCount
102876>>>>>        Integer iUserCount
102876>>>>>        Integer iError
102876>>>>>        String  sErrorTxt
102876>>>>>    End_Struct
102876>>>>>
102876>>>>>    Define CI_UserCountMaxUsers for 9999
102876>>>>>
102876>>>>>Class cDbUpdateUserCount is a cObject
102877>>>>>    Procedure Construct_Object
102879>>>>>        Forward Send Construct_Object
102881>>>>>
102881>>>>>        Property String  psLockFileName
102882>>>>>        Property Integer piMaxUsers
102883>>>>>        Property Boolean pbCheckDataFlexUserCount True
102884>>>>>
102884>>>>>        Property Handle  phUserCountFile
102885>>>>>        Property Integer pdwLockPosition
102886>>>>>    End_Procedure
102887>>>>>
102887>>>>>    Function IsProgramRunning Returns Boolean
102889>>>>>        tUserCount UserCount
102889>>>>>        tUserCount UserCount
102889>>>>>
102889>>>>>        Get CheckUserCount to UserCount
102890>>>>>
102890>>>>>        Function_Return (UserCount.iUserCount > 1)
102891>>>>>    End_Function
102892>>>>>
102892>>>>>    // Returns the full path of the Application (no trailing "\")
102892>>>>>    Function ApplicationPath Returns String
102894>>>>>        String sApplicationFileName sPath
102894>>>>>        Integer iNumChars iRetval
102894>>>>>
102894>>>>>        Move (Repeat(Character(0), 1024))    to sApplicationFileName
102895>>>>>        Move (GetModuleFileName(0, AddressOf(sApplicationFileName), 1024)) to iNumChars
102896>>>>>        Move (CString(sApplicationFileName)) to sApplicationFileName
102897>>>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to iRetval
102898>>>>>        Move (CString(sApplicationFileName)) to sPath
102899>>>>>
102899>>>>>        Function_Return sPath
102900>>>>>    End_Function
102901>>>>>
102901>>>>>    Function OpenUserCountFile String sFileName Returns Handle
102903>>>>>        Handle  hFile
102903>>>>>        Pointer pFileName
102903>>>>>        String sPath sFile
102903>>>>>        Integer iCh
102903>>>>>
102903>>>>>        Move (Addressof(sFileName)) to pFileName
102904>>>>>        Move (Win32_CreateFile(pFileName, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, (FILE_ATTRIBUTE_NORMAL ior FILE_FLAG_WRITE_THROUGH), 0)) to hFile
102905>>>>>
102905>>>>>        // If lock file doesn't exist, create it.
102905>>>>>        If (hFile = INVALID_HANDLE_VALUE) Begin
102907>>>>>            Get ApplicationPath to sPath
102908>>>>>            Get vFolderFormat sPath to sPath
102909>>>>>            Move (sPath + psLockFileName(Self)) to sFile
102910>>>>>            Get Seq_Open_Output_Channel sFile to iCh
102911>>>>>            If (iCh = DF_SEQ_CHANNEL_ERROR) Begin
102913>>>>>                Function_Return 0
102914>>>>>            End
102914>>>>>>
102914>>>>>            Direct_Output channel iCh sFile
102916>>>>>                Write channel iCh ""
102918>>>>>            Send Seq_Close_Channel iCh
102919>>>>>            Move (Win32_CreateFile(pFileName, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, (FILE_ATTRIBUTE_NORMAL ior FILE_FLAG_WRITE_THROUGH), 0)) to hFile
102920>>>>>        End
102920>>>>>>
102920>>>>>
102920>>>>>        Function_Return hFile
102921>>>>>    End_Function
102922>>>>>
102922>>>>>    Function CloseUserCountFile Handle hFile Returns Integer
102924>>>>>        Integer iReturnValue 
102924>>>>>        Boolean bOK
102924>>>>>
102924>>>>>        Move (Win32_CloseHandle(hFile)) to iReturnValue
102925>>>>>        If (iReturnValue = 0) Begin
102927>>>>>            Move False to bOK
102928>>>>>        End
102928>>>>>>
102928>>>>>        Else Begin
102929>>>>>            Move True to bOK
102930>>>>>        End
102930>>>>>>
102930>>>>>        Function_Return bOK
102931>>>>>    End_Function
102932>>>>>
102932>>>>>    Function UnlockUserCountFile Handle hFile dWord dwLockPos Returns Integer
102934>>>>>        Integer iReturnValue
102934>>>>>        Boolean bOK
102934>>>>>
102934>>>>>        Move (Win32_UnLockFile(hFile, dwLockPos, 0, 1, 0)) to iReturnValue
102935>>>>>        If (iReturnValue = 0) Begin
102937>>>>>            Move False to bOK
102938>>>>>        End
102938>>>>>>
102938>>>>>        Else Begin
102939>>>>>            Move True to bOK
102940>>>>>        End           
102940>>>>>>
102940>>>>>        Function_Return bOK
102941>>>>>    End_Function
102942>>>>>
102942>>>>>    Function ReSetUserCountPointer Handle hFile Returns dWord
102944>>>>>        dWord dwCurrPos
102944>>>>>
102944>>>>>        Move (Win32_SetFilePointer(hFile, 0, 0, FILE_BEGIN)) to dwCurrPos
102945>>>>>        Function_Return dwCurrPos
102946>>>>>    End_Function
102947>>>>>
102947>>>>>    Function SetUserCountPointer Handle hFile Integer iAdvance Returns dWord
102949>>>>>        DWord dwCurrPos
102949>>>>>
102949>>>>>        Move (Win32_SetFilePointer(hFile, iAdvance, 0, FILE_CURRENT)) to dwCurrPos
102950>>>>>        Function_Return dwCurrPos
102951>>>>>    End_Function
102952>>>>>
102952>>>>>    Function ReadUserCountFile Handle hFile Returns Boolean
102954>>>>>        Integer iReturnValue                               
102954>>>>>        Boolean bOK
102954>>>>>        String  sBuffer
102954>>>>>        Pointer pBuffer
102954>>>>>        String  sSize
102954>>>>>        Pointer pSize
102954>>>>>
102954>>>>>        Move (Repeat((Character(0)),5)) to sBuffer
102955>>>>>        Move (AddressOf(sBuffer)) to pBuffer
102956>>>>>
102956>>>>>        Move (Repeat((Character(0)),4)) to sSize
102957>>>>>        Move (AddressOf(sSize)) to pSize
102958>>>>>
102958>>>>>        Move (Win32_ReadFile(hFile, pBuffer, 1, pSize, 0)) to iReturnValue
102959>>>>>        If (iReturnValue = 0) Begin
102961>>>>>            Move False to bOK
102962>>>>>        End
102962>>>>>>
102962>>>>>        Else Begin
102963>>>>>            Move True to bOK
102964>>>>>        End                 
102964>>>>>>
102964>>>>>        Function_Return bOK
102965>>>>>    End_Function
102966>>>>>
102966>>>>>    Function LockUserCountFile Handle hFile dWord dwFilePos Returns Integer
102968>>>>>        Integer iReturnValue
102968>>>>>
102968>>>>>        Move (Win32_LockFile(hFile, dwFilePos, 0, 1, 0)) to iReturnValue
102969>>>>>        Function_Return iReturnValue
102970>>>>>    End_Function
102971>>>>>
102971>>>>>    Procedure DoCheckUserCount
102973>>>>>        tUserCount UserCount
102973>>>>>        tUserCount UserCount
102973>>>>>
102973>>>>>        Get CheckUserCount to UserCount
102974>>>>>        // If all is fine, we're done.
102974>>>>>        If (UserCount.iError = 0) Begin
102976>>>>>            Procedure_Return
102977>>>>>        End
102977>>>>>>
102977>>>>>
102977>>>>>        Send UserError (CS_UserCountError * String(UserCount.iError) + "\n" + UserCount.sErrorTxt)
102978>>>>>
102978>>>>>        If (UserCount.iUserCount = CI_UserCountMaxUsers) Begin
102980>>>>>            Abort
102981>>>>>>
102981>>>>>        End
102981>>>>>>
102981>>>>>    End_Procedure
102982>>>>>
102982>>>>>    Function CheckUserCount Returns tUserCount
102984>>>>>        Handle  hFile
102984>>>>>        String  sPath sFile
102984>>>>>        Integer iResult
102984>>>>>        DWord   dwFilePos
102984>>>>>        Integer bLocked
102984>>>>>        Integer iMaxUsers
102984>>>>>        Integer iCurUser
102984>>>>>        tUserCount UserCount
102984>>>>>        tUserCount UserCount
102984>>>>>
102984>>>>>        Move 0 to UserCount.iError
102985>>>>>
102985>>>>>        Get phUserCountFile to hFile
102986>>>>>        If (not(hFile)) Begin
102988>>>>>            Get ApplicationPath to sPath
102989>>>>>            Get vFolderFormat sPath to sPath
102990>>>>>            Move (sPath + psLockFileName(Self)) to sFile
102991>>>>>            Get OpenUserCountFile sFile to hFile
102992>>>>>            If (hFile = INVALID_HANDLE_VALUE) Begin
102994>>>>>                Move 1 to UserCount.iUserCount
102995>>>>>                Move 1 to UserCount.iError
102996>>>>>                Move CS_UnableToInitUserCountSys to UserCount.sErrorTxt
102997>>>>>                Function_Return UserCount
102998>>>>>            End
102998>>>>>>
102998>>>>>            Else Begin
102999>>>>>                Move False to bLocked
103000>>>>>                Set phUserCountFile to hFile
103001>>>>>                Get piMaxUsers to iMaxUsers
103002>>>>>
103002>>>>>                // Set Filepointer to beginning of the file
103002>>>>>                Get ResetUserCountPointer hFile to dwFilePos
103003>>>>>                If (dwFilePos = -1) Begin
103005>>>>>                    Move 1 to UserCount.iUserCount
103006>>>>>                    Move 2 to UserCount.iError
103007>>>>>                    Move CS_UnableResetUserCountSys to UserCount.sErrorTxt
103008>>>>>                    Function_Return UserCount
103009>>>>>                End
103009>>>>>>
103009>>>>>                For iCurUser from 1 to iMaxUsers
103015>>>>>>
103015>>>>>                    Get LockUserCountFile hFile dwFilePos to iResult
103016>>>>>                    If (not(iResult)) Begin  // byte is locked
103018>>>>>                        Get SetUserCountPointer hFile 10 to dwFilePos
103019>>>>>                        If (dwFilePos = -1) Begin
103021>>>>>                            Move 1 to UserCount.iUserCount
103022>>>>>                            Move 3 to UserCount.iError
103023>>>>>                            Move CS_ErrorAdvancingPointer to UserCount.sErrorTxt
103024>>>>>                            Function_Return UserCount
103025>>>>>                        End
103025>>>>>>
103025>>>>>                    End
103025>>>>>>
103025>>>>>                    Else Begin  // byte is not locked
103026>>>>>                        Set pdwLockPosition to dwFilePos
103027>>>>>                        Move True to bLocked
103028>>>>>                        Move iMaxUsers to iCurUser
103029>>>>>                    End
103029>>>>>>
103029>>>>>                Loop
103030>>>>>>
103030>>>>>                If (not(bLocked)) Begin
103032>>>>>                    Move CI_UserCountMaxUsers to UserCount.iUserCount
103033>>>>>                    Move 4 to UserCount.iError
103034>>>>>                    Move CS_MaxNoOfUserExceeded to UserCount.sErrorTxt
103035>>>>>                    Function_Return UserCount
103036>>>>>                End
103036>>>>>>
103036>>>>>            End
103036>>>>>>
103036>>>>>        End
103036>>>>>>
103036>>>>>
103036>>>>>        Function_Return UserCount
103037>>>>>    End_Function
103038>>>>>
103038>>>>>
103038>>>>>    Procedure DoReleaseUserCount
103040>>>>>        Integer iResult
103040>>>>>        Handle  hFile
103040>>>>>        DWord   dwLockPos
103040>>>>>
103040>>>>>        Get phUserCountFile to hFile
103041>>>>>        Get pdwLockPosition to dwLockPos
103042>>>>>        If (hFile) Begin
103044>>>>>            If (dwLockPos) Begin
103046>>>>>                Get UnlockUserCountFile hFile dwLockPos to iResult
103047>>>>>            End
103047>>>>>>
103047>>>>>            Get CloseUserCountFile hFile to iResult
103048>>>>>        End
103048>>>>>>
103048>>>>>    End_Procedure
103049>>>>>
103049>>>>>    Function CurrentNumberOfUsers Returns Integer
103051>>>>>        Handle  hFile
103051>>>>>        Integer iMaxUsers
103051>>>>>        DWord   dwFilePos
103051>>>>>        Integer iCurUser
103051>>>>>        Integer iResult
103051>>>>>        Integer iNumberOfLocks
103051>>>>>        String  sPath sFile
103051>>>>>
103051>>>>>        Move 0 to iNumberOfLocks
103052>>>>>
103052>>>>>        Get ApplicationPath to sPath
103053>>>>>        Get vFolderFormat sPath to sPath
103054>>>>>        Move (sPath + psLockFileName(Self)) to sFile
103055>>>>>        Get OpenUserCountFile sFile to hFile
103056>>>>>        If (hFile = INVALID_HANDLE_VALUE) Begin
103058>>>>>            Send UserError CS_UnableToInitUserCountSys
103059>>>>>            Abort
103060>>>>>>
103060>>>>>        End
103060>>>>>>
103060>>>>>
103060>>>>>        If (hFile > 0) Begin
103062>>>>>            Get piMaxUsers To iMaxUsers
103063>>>>>
103063>>>>>            // Set Filepointer to beginning of the file
103063>>>>>            Get ResetUserCountPointer hFile to dwFilePos
103064>>>>>            If (dwFilePos = -1) Begin
103066>>>>>                Send UserError CS_UnableResetUserCountSys
103067>>>>>                Abort
103068>>>>>>
103068>>>>>            End
103068>>>>>>
103068>>>>>            For iCurUser from 1 to iMaxUsers
103074>>>>>>
103074>>>>>                Get LockUserCountFile hFile dwFilePos to iResult
103075>>>>>                If (Not(iResult)) Begin  // byte is locked
103077>>>>>                    Increment iNumberOfLocks
103078>>>>>                End
103078>>>>>>
103078>>>>>                Else Begin  // byte is not locked
103079>>>>>                    Get UnlockUserCountFile hFile dwFilePos to iResult
103080>>>>>                End
103080>>>>>>
103080>>>>>                Get SetUserCountPointer hFile 10 to dwFilePos
103081>>>>>                If (dwFilePos = -1) Begin
103083>>>>>                    Send UserError CS_ErrorAdvancingPointer
103084>>>>>                    Abort
103085>>>>>>
103085>>>>>                End
103085>>>>>>
103085>>>>>            Loop
103086>>>>>>
103086>>>>>        End
103086>>>>>>
103086>>>>>        Get CloseUserCountFile hFile to iResult
103087>>>>>        Function_Return iNumberOfLocks
103088>>>>>    End_Function
103089>>>>>
103089>>>>>End_Class
103090>>>Use cDbUpdateFunctionLibrary.pkg
103090>>>
103090>>>//{ DataBindable=True }
103090>>>    // Note: We import all functionality of the DatabaseFunctionLibrary into the class:
103090>>>Class cDbUpdateHandler is a cObject
103091>>>    Import_Class_Protocol cDbUpdateFunctionLibrary
103092>>>    Import_Class_Protocol cDbUpdateFunctionLibrary_Mixin
103093>>>
103093>>>    Procedure Construct_Object
103095>>>        tUserCount UserCount
103095>>>        tUserCount UserCount
103095>>>        Integer iUserCount
103095>>>        Handle ho                     
103095>>>
103095>>>        Forward Send Construct_Object
103097>>>        Move Self to ghoDbUpdateHandler  
103098>>>        
103098>>>        // Latin1_General_CI_AS = General Insensitive collation
103098>>>        // Latin1_General_CS_AS = General Case Sensitive collation, AS= Accent Sensitive.   
103098>>>        // For MS-SQL See: https://docs.microsoft.com/en-us/sql/t-sql/statements/windows-collation-name-transact-sql?view=sql-server-2017
103098>>>        // Good read about which collation to select:
103098>>>        // https://social.msdn.microsoft.com/Forums/sqlserver/en-US/bfdc32d3-3d36-4d63-8d87-6ee972fd8130/on-sqllatin1generalcp1cias-sql-server-2008-default-collation?forum=transactsql
103098>>>        Property String psCollation "Latin1_General_CS_AS" //"SQL_Latin1_General_Cp1_CS_AS"
103099>>>
103099>>>        // Struct array that will contain pnVersionNumbers & object id's of
103099>>>        // all child cDbVersion objects.
103099>>>        Property tDbVersionInfo[] paDbVersionInfoArray
103100>>>
103100>>>        Property Integer Error_Processing_State False  // internal use
103101>>>        
103101>>>        Property Boolean Private.pbDbVersionCheckDone False
103102>>>
103102>>>        Property Boolean pbUseCustomDbVersion False  
103103>>>        
103103>>>        // If this property = True _and_ no DbVersion table exists 
103103>>>        // when the framework is started, a DbVersion table will be created automatically.
103103>>>        Property Boolean pbAutoCreateDbVersionTable True
103104>>>
103104>>>        // Connected to the pbAutoCreateDbVersionTable property. If it is true,
103104>>>        // the Filelist.cfg slot number indicated by this property will be used
103104>>>        // if a DbVersion table is to be created. If this value = -1 at runtime
103104>>>        // an Unhandled Exception Error will be genereted and the program halted. So
103104>>>        // this property _must_ be set in the cDbUpdateHandler object if pbAutoCreateDbVersionTable = True,
103104>>>        // to a value that corresponds to a free Filelist.cfg slot number.
103104>>>        Property Integer Private.piDbVersionFileNumber -1
103105>>>        Property Integer Private.piDbVersionFieldNumber 1
103106>>>
103106>>>        // This is a message of the cDbUpdateFunctionLibrary_Mixin class
103106>>>        // that creates all library properties
103106>>>        Send CreateDbUpdateLibraryProperties
103107>>>
103107>>>        Property tDbUpdateHandlerMasterAlias[] paDbUpdateHandlerMasterAlias
103108>>>
103108>>>        // Error handling:
103108>>>        Property Boolean Private.pbOnCreateExecuted False
103109>>>        Property Boolean Private.pbOnPreUpdateExecuted False
103110>>>        Property Boolean Private.pbProcessingError False
103111>>>        Property Boolean pbDbUpdateErrorHasOccured False
103112>>>        // Don't touch. It is being used by the cDbUpdateVersion
103112>>>        // subclass to tell if that particular update went OK or not.
103112>>>        Property Boolean Private.pbUpdateVersionObjectError False
103113>>>        Property String[] paSQLQueryMessages
103114>>>
103114>>>        Property Integer piOrgErrorHandlerID Error_Object_Id
103115>>>        Move Self to Error_Object_Id
103116>>>        // Error handling:
103116>>>        // Temporarily redirect all errors to this object so we can silently
103116>>>        // log all errors that might appear while updating the database.
103116>>>        // We temporarily redirect all errors to this object so we can
103116>>>        // log and write errors to the log file. It will be reset after
103116>>>        // the database updates have been finished.
103116>>>        Property Integer piCurrentErrorHandlerID Error_Object_Id
103117>>>
103117>>>        Property Handle phoLogFile (Create(Self,RefClass(cDbUpdateLogFile)))
103118>>>
103118>>>        // Error Reporting Related
103118>>>        // If DUF_ERROR_NO_REPORT errors are supressed (only ERR gets set)
103118>>>        Property Integer Error_Report_Mode DUF_ERROR_REPORT
103119>>>
103119>>>        // If the pbContinueOnError = False, an update
103119>>>        // of another cDbUpdateVersion object will _not_ be
103119>>>        // performed if an error occured in a previous
103119>>>        // cDbUpdateVersion object.
103119>>>        Property Boolean pbContinueOnError False
103120>>>        // Stops execution in other cDbUpdateVersion objecs,
103120>>>        // if errors occurred in one cDbUpdateVersion object.
103120>>>        Property Boolean pbStopOnFirstError False
103121>>>        // If True errors that occured while updating the database
103121>>>        // will be shown in the default app for .txt files when done.
103121>>>        // Note: The log file will _always_ be created in the Data folder.
103121>>>        Property Boolean pbShowErrorLogPostRun True
103122>>>
103122>>>        // Be _very_ careful to set this property to true!
103122>>>        // If = True, no question will be asked if the update
103122>>>        // should begin. Also, even if the pbShowErrorLogPostRun=True,
103122>>>        // the error log won't be shown. The logfile itself will still be created though.
103122>>>        // You have to know what you're doing!
103122>>>        Property Boolean pbSilentMode False
103123>>>        
103123>>>        Property Boolean pbEnableCancelButton False
103124>>>
103124>>>        // Don't touch! Very private. The value is used by the error log to write for which
103124>>>        // cDbUpdateVersion object an error occured.
103124>>>        Property Number pnCurrentVersionUpdate 0
103125>>>
103125>>>        // The user counting logic is used to safe-guard agains anybody else is
103125>>>        // using the application when a database update is to be performed.
103125>>>        // (Garters & suspenders!)
103125>>>        Property Handle phoUserCountSystem (Create(Self,RefClass(cDbUpdateUserCount)))
103126>>>        Set psLockFileName of (phoUserCountSystem(Self)) to "DbUpdateUserCount.ucf"
103127>>>        Set piMaxUsers     of (phoUserCountSystem(Self)) to (CI_UserCountMaxUsers -1) // Large number!
103128>>>
103128>>>        // This lock file is used to guard against somebody else tries to start the
103128>>>        // application while updates are in progress.
103128>>>        Property Handle phoDatabaseUpdateLock (Create(Self,RefClass(cDbUpdateUserCount)))
103129>>>        Set psLockFileName of (phoDatabaseUpdateLock(Self)) to "DbUpdateLock.ucf"
103130>>>        Set piMaxUsers     of (phoDatabaseUpdateLock(Self)) to 1
103131>>>                                                                                      // Only the current user allowed.
103131>>>        // Properties for the table & column of a system file field/column where
103131>>>        // the database version update number gets saved.
103131>>>        Property Integer Private.Data_File  0
103132>>>        Property Integer Private.Data_Field 0
103133>>>
103133>>>        // Property that is used to indicate that we have already
103133>>>        // started the database update.
103133>>>        Property Boolean Private.pbDatabaseUpdateStarted False
103134>>>
103134>>>        // Don't touch! It is used by the child class cDbUpdateVersion logic to indicate that
103134>>>        // at least one OnUpdate child event has been triggered. Thus at least one active
103134>>>        // change of the database has been made.
103134>>>        Property Boolean Private.pbDatabaseWasUpdated False
103135>>>
103135>>>        // We need to trigger the user counting system so that a bit in the
103135>>>        // user counting file is locked. This is to guard that not more than one user
103135>>>        // is currently runnning the program.
103135>>>        Get CheckUserCount of (phoUserCountSystem(Self)) to UserCount
103136>>>
103136>>>        Get CurrentNumberOfUsers of (phoDatabaseUpdateLock(Self)) to iUserCount
103137>>>        If (iUserCount > 0) Begin
103139>>>            Send Stop_Box CS_DUF_UpdateInProgressTxt
103140>>>            Send Exit_Application
103141>>>        End
103141>>>>
103141>>>
103141>>>        Set pbHandleQueryErrors to False
103142>>>            
103142>>>        // This can't be right?    
103142>>>//        If (ghoDbUpdateFunctionLibrary = 0) Begin
103142>>>//            Move Self to ghoDbUpdateFunctionLibrary
103142>>>//        End
103142>>>
103142>>>        Property Handle phoSQLConnectionHandler 0
103143>>>        // If no ghoSQLConnectionHandler object has been created prior to this object,
103143>>>        // we will create one as it is used for all ConnectionID, ConnectionString
103143>>>        // etc information.
103143>>>        If (ghoSQLConnectionHandler = 0) Begin
103145>>>            Get Create (RefClass(cSQLConnectionHandler)) to ho
103146>>>            Set phoSQLConnectionHandler to ho
103147>>>        End             
103147>>>>
103147>>>        
103147>>>        Property Boolean pbCheckIntFiles False   
103148>>>        Property Handle  phIntFilesTable 2048
103149>>>        Property Boolean Private.pbIntFilesTablesCheckDone False
103150>>>        
103150>>>        Set Icon to "Default.ico"
103151>>>    End_Procedure
103152>>>
103152>>>    Procedure End_Construct_Object
103154>>>        Boolean bCheckIntFiles
103154>>>        
103154>>>        Forward Send End_Construct_Object
103156>>>        If (Private.pbOnCreateExecuted(Self) = False) Begin  
103158>>>            Send OnCreate
103159>>>            Set Private.pbOnCreateExecuted to True
103160>>>        End
103160>>>>
103160>>>        Send Cleanup
103161>>>    End_Procedure
103162>>>    
103162>>>    // Programmers hook event.
103162>>>    Procedure OnCreate
103164>>>    End_Procedure        
103165>>>                                 
103165>>>    // *** MAIN .Int file (and Filelist.cfg) Check Integrity Message ***
103165>>>    //                                                
103165>>>    // The logic is activated by setting the property "pbCheckIntFiles = True" in the
103165>>>    // cDbUpdateHandler object.
103165>>>    //
103165>>>    // Checks that all .int files are intact, or else writes new copies to disk. 
103165>>>    // Also checks that there is a Filelist.cfg, and if missing writes a new copy to disk.
103165>>>    //
103165>>>    // If not done previously the phIntFilesTable will be created and filled with data
103165>>>    // from the current set of .int files - iif (if-and-only-if) this is a development
103165>>>    // machine. Which is decided by checking if the DdSrc folder exists. And a copy
103165>>>    // of Filelist.cfg is made for backup purposes.
103165>>>    //
103165>>>    // Note: If an error occurrs the application will exit, as it means that at least one
103165>>>    // .int file is in error or the Filelist.cfg was missing and couldn't be recreated.
103165>>>    Procedure CheckIntFilesIntegrity
103167>>>        Boolean bCheckIntFiles bExists bOK bSaved bIsSQL bFileListExist bResult bDevelop bZipExists
103167>>>        String sPaths sDataPath sIntFileName sRootFileNname sFileListName sDDSrcPath sCurrentFolder
103167>>>        String sFileListZipFile sParam sProgram sFile 
103167>>>        Integer iDataPaths iCount
103167>>>        Handle hTable hIntFilesTable                    
103167>>>        UChar[] asFileListArray 
103168>>>        String[] asSavedIntFile
103169>>>        tDUFIntFile[] DUFIntFiles
103169>>>        tDUFIntFile[] DUFIntFiles
103170>>>        
103170>>>        Get pbCheckIntFiles to bCheckIntFiles
103171>>>        If (bCheckIntFiles = False) Begin
103173>>>            Procedure_Return
103174>>>        End
103174>>>>
103174>>>        
103174>>>        Move True to bResult        
103175>>>        
103175>>>        // Note: Include_Resource is a compiler directive!
103175>>>        // It will embedd the Filelist.cfg from the developers machine
103175>>>        // into the executable. Thus the file _must_ be named "Filelist.cfg", or you
103175>>>        // need to change the next code line.         
103175>>>        //
103175>>>        // This is a pickle (!) with the Filelist.cfg as it is "busy" as it is open in the Studio,
103175>>>        // when we get here and then it seems the compiler can't embedd it!        
103175>>>        // ToDo: Change compiler directives in Project properties (?)
103175>>>//        Include_Resource Filelist2.cfg as res_EmbeddedFilelistCfg type DF_RESOURCE_TYPE_BINARY
103175>>>//        Get ReadFileListResource "res_EmbeddedFilelistCfg" to asFileListArray
103175>>>        
103175>>>        Get psFileList of (phoWorkspace(ghoApplication)) to sFileListName
103176>>>        Get vFilePathExists sFileListName to bExists 
103177>>>        If (bExists = True) Begin
103179>>>            Get ParseFolderName sFileListName to sDataPath    
103180>>>            Get vFolderFormat sDataPath to sDataPath                              
103181>>>            Get ParseFileName sFileListName to sFile
103182>>>            // We need to create a backup copy of Filelist.cfg.
103182>>>            Get vCopyFile sFileListName (sDataPath + CS_FilelistBackupFile) to bOK
103183>>>            Get vFilePathExists (sDataPath + CS_FilelistBackupFile) to bOK
103184>>>            If (bOK = False) Begin
103186>>>                Move False to bResult
103187>>>                Error DFERR_PROGRAM ("Could not create a copy of Filelist.cfg for backup purposed! ***Please investigte the reason why this happened ***")
103188>>>>
103188>>>            End
103188>>>>
103188>>>        End
103188>>>>
103188>>>        // If the Filelist.cfg is missing - create it from a previous backup copy.
103188>>>        Else Begin
103189>>>            Get vCopyFile (sDataPath + CS_FilelistBackupFile) sFileListName to bOK
103190>>>//            Get WriteFileListResource asFileListArray sFileListName to bOK  
103190>>>            If (bOK = False) Begin   
103192>>>                Move False to bResult
103193>>>                Error DFERR_PROGRAM ("Filelist.cfg file is missing and couldn't be created!" * String(sFileListName))
103194>>>>
103194>>>            End
103194>>>>
103194>>>        End
103194>>>>
103194>>>        
103194>>>        Get phIntFilesTable to hIntFilesTable
103195>>>        Get_Attribute DF_FILE_ROOT_NAME of hIntFilesTable to sRootFileNname
103198>>>        Get _TableNoPrefix sRootFileNname to sRootFileNname
103199>>>        // This will automatically create the phIntFilesTable if not exists.
103199>>>        // It is used to save data from the current set of .int files.
103199>>>        If (sRootFileNname <> CS_IntFilesTableRootName) Begin
103201>>>            Send AutoCreateIntFilesTable
103202>>>        End                                                       
103202>>>>
103202>>>        
103202>>>        // Check if this is a development machine. *Only* then we will attempt to read .int files to the internal table. 
103202>>>        // ToDo: Or should this always be attempted? Else the 
103202>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
103203>>>        Move (IsDebuggerPresent()) to bDevelop
103204>>>        If (bDevelop = False) Begin
103206>>>            Get vFolderExists sDDSrcPath to bDevelop
103207>>>        End
103207>>>>
103207>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sPaths
103208>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sPaths to iDataPaths
103209>>>        For iCount from 1 to iDataPaths
103215>>>>
103215>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sPaths iCount to sDataPath   
103216>>>            Get vFolderFormat sDataPath to sDataPath 
103217>>>            Get vFolderExists sDataPath to bExists
103218>>>            If (bExists = True) Begin                  
103220>>>                Move 0 to hTable
103221>>>                Repeat
103221>>>>
103221>>>                    Get_Attribute DF_FILE_NEXT_USED of hTable to hTable    
103224>>>                    If (hTable <> 0) Begin
103226>>>                        Get_Attribute DF_FILE_ROOT_NAME of hTable to sIntFileName 
103229>>>                        Get UtilTableIsSqlByRootName sIntFileName to bIsSQL
103230>>>                        If (bIsSQL = True) Begin
103232>>>                            Get _TableNoPrefix sIntFileName to sIntFileName
103233>>>                            Move (sIntFileName + ".int")    to sIntFileName
103234>>>                            Get IsIntFileSaved sIntFileName to bSaved  
103235>>>                            Move True to bOK            
103236>>>                            
103236>>>                            // Save .int file to database if not done previously.
103236>>>                            // We only attempt to read .int files on a development machine.
103236>>>                            If (bDevelop = True) Begin
103238>>>                                If (bSaved = False) Begin
103240>>>                                    Get SaveIntFileData sDataPath sIntFileName to bOK
103241>>>                                    If (bOK = False) Begin
103243>>>                                        Move False to bResult    
103244>>>                                    End
103244>>>>
103244>>>                                End         
103244>>>>
103244>>>                                If (bOK = True) Begin
103246>>>                                    Get HasIntFileChanged sDataPath sIntFileName to asSavedIntFile
103247>>>                                    If (SizeOfArray(asSavedIntFile)) Begin
103249>>>                                        Get UpdateIntFileData sDataPath sIntFileName asSavedIntFile to bOK
103250>>>                                        If (bOK = False) Begin
103252>>>                                            Move False to bResult
103253>>>                                            Error DFERR_PROGRAM ("Could not update .int file data to the internal database table:" * String(sIntFileName))
103254>>>>
103254>>>                                        End
103254>>>>
103254>>>                                    End
103254>>>>
103254>>>                                End
103254>>>>
103254>>>                            End
103254>>>>
103254>>>                            
103254>>>                            Get vFilePathExists (sDataPath + sIntFileName) to bExists
103255>>>                            If (bExists = False) Begin                           
103257>>>                                // If the .int file is missing on disk; create it from database.
103257>>>                                Get CreateIntFileFromSavedData hIntFilesTable sIntFileName sDataPath to bOK
103258>>>                                If (bOK = False) Begin         
103260>>>                                    Move False to bResult
103261>>>                                    Error DFERR_PROGRAM ("Could not create .int file:" * String(sIntFileName))
103262>>>>
103262>>>                                End
103262>>>>
103262>>>                            End
103262>>>>
103262>>>                        End
103262>>>>
103262>>>                    End
103262>>>>
103262>>>                Until (hTable = 0)
103264>>>            End
103264>>>>
103264>>>        Loop       
103265>>>>
103265>>>        
103265>>>        // If an error occured we need to exit the application.
103265>>>        If (bResult = False) Begin  
103267>>>            Send Info_Box CS_DUF_DbUpdatedErrorText 
103268>>>            Send Exit_Application
103269>>>        End
103269>>>>
103269>>>        
103269>>>    End_Procedure               
103270>>>
103270>>>    // To update currently saved IntFile data to the database.
103270>>>    // Because it is much easier, we first delete all current records and
103270>>>    // then saves the changed .int file to the database.
103270>>>    Function UpdateIntFileData String sDataPath String sIntFileName String[] asSavedIntFile Returns Boolean
103272>>>        Boolean bOK
103272>>>        
103272>>>        Move False to bOK
103273>>>
103273>>>        Get DeleteIntFileData sDataPath sIntFileName to bOK
103274>>>        If (bOK = True) Begin
103276>>>            Get SaveIntFileData sDataPath sIntFileName to bOK
103277>>>        End
103277>>>>
103277>>>        
103277>>>        Function_Return bOK
103278>>>    End_Function
103279>>>    
103279>>>    Function IsIntFileSaved String sIntFileName Returns Boolean
103281>>>        Handle hTable
103281>>>        Boolean bOK
103281>>>        Integer iColumn iIndex   
103281>>>        String sFileName
103281>>>        
103281>>>        Move False to bOK
103282>>>        Get phIntFilesTable to hTable
103283>>>        Move 2              to iColumn // This is the "InfFileName" field no.
103284>>>        Move 2              to iIndex  // This is the IntFileName + ID index.
103285>>>
103285>>>        Open hTable
103287>>>        Set_Field_Value hTable iColumn to sIntFileName
103290>>>        Vfind hTable iIndex GE
103292>>>        Get_Field_Value hTable iColumn to sFileName
103295>>>        If (Trim(sIntFileName) = Trim(sFileName)) Begin
103297>>>            Move True to bOK    
103298>>>        End
103298>>>>
103298>>>        Close hTable
103299>>>        
103299>>>        Function_Return bOK       
103300>>>    End_Function   
103301>>>    
103301>>>    // Checks that the passed .int file is the same as what is saved in the database.
103301>>>    // If not same, the return string array will contain the read .int file,
103301>>>    // else the returned array will be empty.
103301>>>    Function HasIntFileChanged String sDataPath String sIntFileName Returns String[]
103303>>>        String[] asIntFileOrg asIntFile asSavedIntFile asReturnIntFile
103307>>>        Boolean bIsSame
103307>>>        
103307>>>        Get ReadIntFileData    sDataPath sIntFileName to asIntFileOrg   
103308>>>        Get CurrentIntFileData sDataPath sIntFileName to asSavedIntFile
103309>>>        Get RemoveBlankLines asIntFileOrg   to asIntFile
103310>>>        Get RemoveBlankLines asSavedIntFile to asSavedIntFile
103311>>>        
103311>>>        Move (IsSameArray(asIntFile, asSavedIntFile)) to bIsSame
103312>>>        If (bIsSame = False) Begin
103314>>>            Move asIntFileOrg to asReturnIntFile    
103315>>>        End
103315>>>>
103315>>>        
103315>>>        Function_Return asReturnIntFile    
103316>>>    End_Function                                   
103317>>>    
103317>>>    // Takes a string array as parameter and returns a new
103317>>>    // string array without any empty rows and all rows trimmed.
103317>>>    // This is e.g. used by the HasIntFileChanged message to compare
103317>>>    // two .int file arrays. 
103317>>>    Function RemoveBlankLines String[] asIntFile Returns String[]
103319>>>        Integer iSize iCount iRow
103319>>>        String sVal        
103319>>>        String[] asRetValArray
103320>>>        
103320>>>        Move (SizeOfArray(asIntFile)) to iSize
103321>>>        If (iSize = 0) Begin
103323>>>            Function_Return asRetValArray
103324>>>        End                          
103324>>>>
103324>>>        Decrement iSize         
103325>>>        Move 0 to iRow
103326>>>        
103326>>>        For iCount from 0  to iSize
103332>>>>
103332>>>            Move asIntFile[iCount] to sVal
103333>>>            Move (Trim(sVal)) to sVal
103334>>>            If (sVal <> "") Begin
103336>>>                Move sVal to asRetValArray[iRow]
103337>>>                Increment iRow        
103338>>>            End
103338>>>>
103338>>>        Loop
103339>>>>
103339>>>        
103339>>>        Function_Return asRetValArray
103340>>>    End_Function
103341>>>    
103341>>>    Function SaveIntFileData String sPath String sIntFileName Returns Boolean
103343>>>        Handle hTable
103343>>>        Boolean bOK bErr
103343>>>        Integer iIDCol iFileCol iTextCol iIndex iIDIdx iSize iCount 
103343>>>        Number iID
103343>>>        String sFileName
103343>>>        String[] asIntFile
103344>>>        
103344>>>        Move Err to bErr
103345>>>        Move False to Err
103346>>>        Move False to bOK
103347>>>        Get phIntFilesTable to hTable  
103348>>>        Move 1              to iIDCol
103349>>>        Move 2              to iFileCol
103350>>>        Move 3              to iTextCol // This is the "InfFileName" field no.
103351>>>        Move 1              to iIDIdx   // Main ID index.
103352>>>        Move 2              to iIndex   // This is the IntFileName + ID index.
103353>>>
103353>>>        Get ReadIntFileData sPath sIntFileName to asIntFile
103354>>>        Move (SizeOfArray(asIntFile)) to iSize
103355>>>        If (iSize = 0) Begin
103357>>>            Function_Return False
103358>>>        End
103358>>>>
103358>>>        Decrement iSize
103359>>>        Open hTable  
103361>>>                  
103361>>>        // Find the last used ID no:
103361>>>        Fill_Field hTable iIDCol with DF_HIGH
103363>>>        Vfind hTable iIDIdx LE
103365>>>        Get_Field_Value hTable iIDCol to iID 
103368>>>        // This only happens the very first time we save a record.
103368>>>        If (iID = 999999999999) Begin
103370>>>            Move 0 to iID
103371>>>        End
103371>>>>
103371>>>        Increment iID        
103372>>>        
103372>>>        Lock
103373>>>>
103373>>>            For iCount from 0 to iSize
103379>>>>
103379>>>                Clear hTable
103380>>>                Set_Field_Value hTable iIDCol   to iID     
103383>>>                Set_Field_Value hTable iFileCol to sIntFileName
103386>>>                Set_Field_Value hTable iTextCol to asIntFile[iCount]
103389>>>                SaveRecord hTable
103390>>>                Increment iID
103391>>>            Loop
103392>>>>
103392>>>        Unlock
103393>>>>
103393>>>        Close hTable
103394>>>        
103394>>>        Move (not(Err)) to bOK
103395>>>        Move bErr to Err
103396>>>        
103396>>>        Function_Return bOK
103397>>>    End_Function
103398>>>    
103398>>>    // Deletes all records for the passed sIntFileName value,
103398>>>    // from the phIntFilesTable.
103398>>>    // Returns True if no errors occured.
103398>>>    Function DeleteIntFileData String sPath String sIntFileName Returns Boolean
103400>>>        Handle hTable
103400>>>        Boolean bOK bErr bFound
103400>>>        Integer iFileCol iIndex
103400>>>        String sVal
103400>>>        String[] asIntFile
103401>>>        
103401>>>        Move Err to bErr
103402>>>        Move False to Err
103403>>>        Move False to bOK
103404>>>        Move 2              to iFileCol
103405>>>        Move 2              to iIndex  // This is the IntFileName + ID index.
103406>>>        Get phIntFilesTable to hTable  
103407>>>        Open hTable  
103409>>>                  
103409>>>        // Find the first record
103409>>>        Set_Field_Value hTable iFileCol to sIntFileName
103412>>>        Vfind hTable iIndex GE
103414>>>        Get_Field_Value hTable iFileCol to sVal
103417>>>        Move (Found and Trim(sVal) = Trim(sIntFileName)) to bFound
103418>>>        While (bFound = True)
103422>>>            Delete hTable
103423>>>            Vfind hTable iIndex GT
103425>>>            Get_Field_Value hTable iFileCol to sVal
103428>>>            Move (Found and Trim(sVal) = Trim(sIntFileName)) to bFound
103429>>>        Loop
103430>>>>
103430>>>        Unlock
103431>>>>
103431>>>        Close hTable
103432>>>        
103432>>>        Move (not(Err)) to bOK
103433>>>        Move bErr to Err
103434>>>        
103434>>>        Function_Return bOK
103435>>>    End_Function
103436>>>
103436>>>    // Returns all saved phIntFilesTable records for the passed 
103436>>>    // sIntFileName value as a string array.
103436>>>    Function CurrentIntFileData String sPath String sIntFileName Returns String[]
103438>>>        Handle hTable
103438>>>        Boolean bOK bErr bFound
103438>>>        Integer iFileCol iTextCol iIndex
103438>>>        String sVal sFileName
103438>>>        String[] asIntFile asEmptyArray
103440>>>        
103440>>>        Move Err to bErr
103441>>>        Move False to Err
103442>>>        Move False to bOK
103443>>>        Move 2              to iFileCol
103444>>>        Move 3              to iTextCol // This is the "InfFileName" field no.
103445>>>        Move 2              to iIndex  // This is the IntFileName + ID index.
103446>>>        Get phIntFilesTable to hTable  
103447>>>        Open hTable  
103449>>>
103449>>>        // Find the first record
103449>>>        Set_Field_Value hTable iFileCol to sIntFileName
103452>>>        Vfind hTable iIndex GE
103454>>>        Get_Field_Value hTable iFileCol to sFileName
103457>>>        Move (Found and Trim(sFileName) = Trim(sIntFileName)) to bFound
103458>>>        While (bFound = True)
103462>>>            Get_Field_Value hTable iFileCol to sFileName
103465>>>            Move (Found and Trim(sFileName) = Trim(sIntFileName)) to bFound
103466>>>            If (bFound = True) Begin
103468>>>                Get_Field_Value hTable iTextCol to sVal
103471>>>                Move (Trim(sVal)) to asIntFile[SizeOfArray(asIntFile)]
103472>>>            End
103472>>>>
103472>>>            Vfind hTable iIndex GT
103474>>>        Loop
103475>>>>
103475>>>        
103475>>>        Close hTable
103476>>>        Move (not(Err)) to bOK
103477>>>        If (bOK = False) Begin
103479>>>            Move asEmptyArray to asIntFile
103480>>>        End
103480>>>>
103480>>>        Move bErr to Err               
103481>>>        
103481>>>        Function_Return asIntFile
103482>>>    End_Function
103483>>>
103483>>>    // Reads the passed sIntFileName from disk and returns its value
103483>>>    // as a string array.
103483>>>    Function ReadIntFileData String sPath String sIntFileName Returns String[]
103485>>>        String[] asIntFile       
103486>>>        String sFileName sLine
103486>>>        Integer iCh iSize iCount
103486>>>        
103486>>>        Get vFolderFormat sPath to sPath
103487>>>        If (not(sIntFileName contains ".")) Begin
103489>>>            Move (sIntFileName + ".int") to sIntFileName
103490>>>        End
103490>>>>
103490>>>        Move (sPath + sIntFileName) to sFileName
103491>>>        Get Seq_Open_input_Channel sFileName to iCh
103492>>>        If (iCh < 0) Begin
103494>>>            Function_Return asIntFile
103495>>>        End                                 
103495>>>>
103495>>>        
103495>>>        Repeat
103495>>>>
103495>>>            Readln channel iCh sLine
103497>>>            If (SeqEof = False) Begin
103499>>>                Move sLine to asIntFile[SizeOfArray(asIntFile)]
103500>>>            End
103500>>>>
103500>>>        Until (SeqEof = True)
103502>>>        Send Seq_Close_Channel iCh    
103503>>>        
103503>>>        Function_Return asIntFile
103504>>>    End_Function
103505>>>    
103505>>>    // Reads the Filelist.cfg from memeory as a resource.
103505>>>    // The Filelist.cfg has been compiled into the program.
103505>>>    Function ReadFileListResource String sMemFileName Returns UChar[]
103507>>>        Integer iCh iCount
103507>>>        Number nByteCount
103507>>>        String[] asFileListArray sEmptyArray
103509>>>        String sLine
103509>>>        UChar[] uCharData
103510>>>        
103510>>>        Move False to Err
103511>>>        Get Seq_New_Channel to iCh
103512>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
103514>>>            Error DFERR_PROGRAM 'No channel available...'
103515>>>>
103515>>>            Function_Return sEmptyArray
103516>>>        End
103516>>>>
103516>>>
103516>>>        // First decide the size of the script
103516>>>        Direct_Input channel iCh ("Resource: " + sMemFileName)
103518>>>        Read_Block channel iCh uCharData -1 // -1 means that all data should be read.
103520>>>        Close_Input channel iCh
103522>>>        Send Seq_Release_Channel iCh
103523>>>
103523>>>        Function_Return uCharData
103524>>>    End_Function    
103525>>>    
103525>>>    // Writes a copy of the workspace Filelist.cfg to disk.
103525>>>    // It does so by reading from a memory resource, as the file has
103525>>>    // been compiled into the program.
103525>>>    Function WriteFileListResource UChar[] asFileListArray String sFileListName Returns Boolean
103527>>>        Boolean bOK bErr
103527>>>        Integer iSize iCh
103527>>>        
103527>>>        Move Err to bErr
103528>>>        Move False to Err
103529>>>        Move False to bOK
103530>>>        Move (SizeOfArray(asFileListArray)) to iSize
103531>>>        If (iSize = 0) Begin
103533>>>            Function_Return False
103534>>>        End
103534>>>>
103534>>>
103534>>>        Get Seq_New_Channel to iCh
103535>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
103537>>>            Error DFERR_PROGRAM 'No channel available...'
103538>>>>
103538>>>            Function_Return False
103539>>>        End                      
103539>>>>
103539>>>        
103539>>>        Direct_Output channel iCh sFileListName
103541>>>        Writeln channel iCh asFileListArray
103544>>>                
103544>>>        Close_Input channel iCh
103546>>>        Send Seq_Release_Channel iCh
103547>>>        Move (not(Err)) to bOK
103548>>>        Move bErr to Err
103549>>>        
103549>>>        Function_Return bOK
103550>>>    End_Function
103551>>>
103551>>>    // Writes an .int for the passed sIntFileName file to disk by reading data from the phIntFilesTable data table.
103551>>>    // It first deletes the .cch file (if any).
103551>>>    Function CreateIntFileFromSavedData Handle hTable String sIntFileName String sDataPath Returns Boolean
103553>>>        Boolean bOK bFound bExists bErr
103553>>>        Integer iCh iSize iCount
103553>>>        String sFileName sCCHFileName sVal
103553>>>        String[] asIntFile
103554>>>        
103554>>>        Move Err to bErr   
103555>>>        Move False to Err
103556>>>        Move False to bOK
103557>>>
103557>>>        Get CurrentIntFileData sDataPath sIntFileName to asIntFile
103558>>>        Move (SizeOfArray(asIntFile)) to iSize
103559>>>        If (iSize = 0) Begin
103561>>>            Function_Return False        
103562>>>        End                      
103562>>>>
103562>>>        Decrement iSize
103563>>>        
103563>>>        Get Seq_New_Channel to iCh
103564>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
103566>>>            Function_Return False
103567>>>        End   
103567>>>>
103567>>>        
103567>>>        // Before we start to actually create the new .int file, make sure we delete
103567>>>        // the .cch file first.                                     
103567>>>        Move (Uppercase(sIntFileName)) to sCCHFileName
103568>>>        Move (Replace(".INT", sCCHFileName, ".CCH")) to sCCHFileName
103569>>>        Get vFilePathExists (sDataPath + sCCHFileName) to bExists
103570>>>        If (bExists = True) Begin
103572>>>            Get vDeleteFile (sDataPath + sCCHFileName) to bOK
103573>>>            If (bOK = False) Begin
103575>>>                Function_Return False
103576>>>            End
103576>>>>
103576>>>        End
103576>>>>
103576>>>        
103576>>>        Direct_Output channel iCh (sDataPath + sIntFileName)
103578>>>        For iCount from 0 to iSize
103584>>>>
103584>>>            Writeln channel iCh asIntFile[iCount]
103587>>>        Loop
103588>>>>
103588>>>        
103588>>>        Close_Input channel iCh
103590>>>        Send Seq_Release_Channel iCh
103591>>>        Move (not(Err)) to bOK
103592>>>        Move bErr to Err
103593>>>        
103593>>>        Function_Return bOK
103594>>>    End_Function   
103595>>>              
103595>>>    // Automatically writes .int files to disk that is missing.
103595>>>    // We only need to make this test this once, but because the message is called
103595>>>    // from each child cDbUpdateVersion object (and it needs to be called from there),
103595>>>    // we use property Private.pbIntFilesTablesCheckDone to ensure it is only run once.
103595>>>    Procedure AutoCreateIntFilesTable 
103597>>>        Integer hTable 
103597>>>        Boolean bIntFilesTablesCheckDone bTableExists
103597>>>        String sInfoTxt 
103597>>>        
103597>>>        Get phIntFilesTable to hTable  
103598>>>        Get Private.pbIntFilesTablesCheckDone to bIntFilesTablesCheckDone
103599>>>        If (bIntFilesTablesCheckDone = True) Begin
103601>>>            Procedure_Return
103602>>>        End
103602>>>>
103602>>>
103602>>>        If (hTable < 1) Begin
103604>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
103605>>>            Error DFERR_PROGRAM "The phIntFilesTable has been set to 0 (!). The default value is 2048 and if changed MUST be set to a free Filelist.cfg slot in the cDbUpdateHandler object.\nProgram will now exit!"
103606>>>>
103606>>>            Procedure_Return
103607>>>        End
103607>>>>
103607>>>
103607>>>        Get UtilTableExists of ghoDbUpdateFunctionLibrary hTable to bTableExists
103608>>>        If (bTableExists = True) Begin
103610>>>            Set Private.pbIntFilesTablesCheckDone to True
103611>>>            Procedure_Return
103612>>>        End
103612>>>>
103612>>>
103612>>>        Send CreateIntFilesTable hTable
103613>>>
103613>>>        Set Private.pbIntFilesTablesCheckDone to True
103614>>>    End_Function
103615>>>                
103615>>>    Procedure CreateIntFilesTable Handle hTable
103617>>>        String sTableName sColumnName sInfoTxt sDriverID sDataPath
103617>>>        Boolean bTableExists bOK bUseConnectionID bExists
103617>>>        tAPIColumn[] APIColumn
103617>>>        tAPIColumn[] APIColumn
103618>>>
103618>>>        Get UtilTableNumberIsInUse of ghoDbUpdateFunctionLibrary hTable to bTableExists
103619>>>        If (bTableExists = True) Begin
103621>>>            Procedure_Return
103622>>>        End
103622>>>>
103622>>>
103622>>>        Move False to Err
103623>>>        Get psDriverID to sDriverID
103624>>>        Get IsSQLDriver of ghoDbUpdateFunctionLibrary sDriverID to bUseConnectionID
103625>>>
103625>>>        Move CS_IntFilesTableRootName to sTableName
103626>>>
103626>>>        Move 1                  to APIColumn[0].iFieldNumber
103627>>>        Move "ID"               to APIColumn[0].sFieldName
103628>>>        Move DF_BCD             to APIColumn[0].iType
103629>>>        Move False              to APIColumn[0].bIsSQLType
103630>>>        Move 12                 to APIColumn[0].iLength
103631>>>        Move 0                  to APIColumn[0].iPrecision
103632>>>
103632>>>        Move 2                  to APIColumn[1].iFieldNumber
103633>>>        Move "IntFileName"      to APIColumn[1].sFieldName
103634>>>        Move DF_ASCII           to APIColumn[1].iType
103635>>>        Move False              to APIColumn[1].bIsSQLType
103636>>>        Move 50                 to APIColumn[1].iLength
103637>>>        Move 0                  to APIColumn[1].iPrecision
103638>>>
103638>>>        Move 3                  to APIColumn[2].iFieldNumber
103639>>>        Move "IntLineText"      to APIColumn[2].sFieldName
103640>>>        Move DF_ASCII           to APIColumn[2].iType
103641>>>        Move False              to APIColumn[2].bIsSQLType
103642>>>        Move 100                to APIColumn[2].iLength
103643>>>        Move 0                  to APIColumn[2].iPrecision
103644>>>
103644>>>        Get ApiTableCreate of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True APIColumn to bOk
103645>>>        
103645>>>        If (bOK = True and Err = False) Begin
103647>>>            Move ("Int Files Table:" + sTableName * "was successfully created" * "at filelist slot:" * String(hTable)) to sInfoTxt
103648>>>        End
103648>>>>
103648>>>        Else Begin
103649>>>            Move ("ERROR" * "Int Files Table:" + sTableName * "could NOT be created" * "at filelist slot:" * String(hTable) * "\Program will now exit.") to sInfoTxt
103650>>>            Error sInfoTxt
103651>>>>
103651>>>            Procedure_Return
103652>>>        End
103652>>>>
103652>>>        Send LogError of (phoLogFile(Self)) 0 0 sInfoTxt 0 False
103653>>>
103653>>>        Get ApiIndexCreate hTable 1 1 1   to bOK     // Index 1 = ID
103654>>>        If (bOK = True) Begin
103656>>>            Get ApiIndexCreate hTable 2 2 2 1 to bOK // Index 2 = InteFileName, ID.
103657>>>        End
103657>>>>
103657>>>        If (bOK = False) Begin
103659>>>            Move ("ERROR" * "Indexes for Int Files Table:" + sTableName * "could NOT be created" * "at filelist slot:" * String(hTable) * "\Program will now exit.") to sInfoTxt
103660>>>            Error sInfoTxt
103661>>>>
103661>>>            Procedure_Return
103662>>>        End                    
103662>>>>
103662>>>        
103662>>>        // Check if the new .int file was created. If so and a .dat file exists - delete it.
103662>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
103663>>>        Get vFolderFormat sDataPath to sDataPath
103664>>>        Move (CS_IntFilesTableRootName + ".int") to sTableName
103665>>>        Get vFilePathExists (sDataPath + sTableName) to bExists
103666>>>        If (bExists = True) Begin
103668>>>            Move CS_IntFilesTableRootName to sTableName
103669>>>            Get vFilePathExists (sDataPath + sTableName + ".dat") to bExists
103670>>>            If (bExists = True) Begin
103672>>>                Get vDeleteFile (sDataPath + sTableName + ".dat") to bOK
103673>>>                Get vDeleteFile (sDataPath + sTableName + ".hdr") to bOK
103674>>>                Get vDeleteFile (sDataPath + sTableName + ".k??") to bOK
103675>>>            End
103675>>>>
103675>>>        End
103675>>>>
103675>>>        
103675>>>    End_Procedure
103676>>>
103676>>>    Procedure CheckAutoCreateDbVersionTable
103678>>>        Boolean bDbVersionCheckDone bUseCustomDbVersion bAutoCreateDbVersionTable bTableExists
103678>>>        Integer iDbVersionFileNumber
103678>>>
103678>>>        Get Private.pbDbVersionCheckDone to bDbVersionCheckDone
103679>>>        If (bDbVersionCheckDone = True) Begin
103681>>>            Procedure_Return
103682>>>        End
103682>>>>
103682>>>        Get pbUseCustomDbVersion to bUseCustomDbVersion
103683>>>        If (bUseCustomDbVersion = True) Begin
103685>>>            Procedure_Return
103686>>>        End
103686>>>>
103686>>>
103686>>>        Get pbAutoCreateDbVersionTable to bAutoCreateDbVersionTable
103687>>>        If (bAutoCreateDbVersionTable = True and iDbVersionFileNumber = -1) Begin
103689>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
103690>>>            Error DFERR_PROGRAM "The iDbVersionFileSlotNumber = -1. It MUST be set to a free Filelist.cfg slot in the cDbUpdateHandler object. Could not auto-create the DbVersion table.\nProgram will now exit!"
103691>>>>
103691>>>            Send Exit_Application
103692>>>        End
103692>>>>
103692>>>
103692>>>        Get piDbVersionFileNumber to iDbVersionFileNumber
103693>>>        Get UtilTableExists of ghoDbUpdateFunctionLibrary iDbVersionFileNumber to bTableExists
103694>>>        If (bTableExists = True) Begin
103696>>>            Set Private.pbDbVersionCheckDone to True
103697>>>            Procedure_Return
103698>>>        End
103698>>>>
103698>>>
103698>>>        Send CreateDbVersionTable iDbVersionFileNumber
103699>>>
103699>>>        // We only need to these DbVersion checks once, but because this message is called
103699>>>        // from each child cDbUpdateVersion object (and it needs to be called from there),
103699>>>        // we use a property to only run these tests once.
103699>>>        Set Private.pbDbVersionCheckDone to True
103700>>>    End_Procedure
103701>>>
103701>>>    Procedure CreateDbVersionTable Handle hTable
103703>>>        String sTableName sColumnName sInfoTxt sDriverID 
103703>>>        Boolean bTableExists bOK bUseConnectionID
103703>>>        tAPIColumn[] APIColumn
103703>>>        tAPIColumn[] APIColumn
103704>>>
103704>>>        Get UtilTableNumberIsInUse of ghoDbUpdateFunctionLibrary hTable to bTableExists
103705>>>        If (bTableExists = True) Begin
103707>>>            Procedure_Return
103708>>>        End
103708>>>>
103708>>>
103708>>>        Get psDriverID to sDriverID
103709>>>        Get IsSQLDriver of ghoDbUpdateFunctionLibrary sDriverID to bUseConnectionID
103710>>>
103710>>>        Move "DbVersion"        to sTableName
103711>>>        Move 1                  to APIColumn[0].iFieldNumber
103712>>>        Move "DatabaseVersion"  to APIColumn[0].sFieldName
103713>>>        Move DF_BCD             to APIColumn[0].iType
103714>>>        Move False              to APIColumn[0].bIsSQLType
103715>>>        Move 4                  to APIColumn[0].iLength
103716>>>        Move 2                  to APIColumn[0].iPrecision
103717>>>
103717>>>        Move False to Err                                
103718>>>        
103718>>>        // Note: We always create an embedded DbVersion table. To do this we temporarily need to set the psDriverID to "DATAFLEX".
103718>>>        // To convert the DbVersion table to SQL, use the 'ApiTableConvertToSQL' function.
103718>>>        Set psDriverID to DATAFLEX_ID
103719>>>        Get ApiTableCreate of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True APIColumn to bOk
103720>>>        Get ApiTableChangeAttribute of ghoDbUpdateFunctionLibrary hTable DF_FILE_IS_SYSTEM_FILE True to bOK
103721>>>        Set psDriverID to sDriverID
103722>>>        
103722>>>        If (bOK = True and Err = False) Begin
103724>>>//            Move ("Column '" + APIColumn[0].sFieldName + "'" * "NUMERIC" * String(APIColumn[0].iLength) + ", was successfully added to '" + sTableName + "'" * "(at filelist slot:" * String(hTable) + ")") to sInfoTxt
103724>>>            Move ("DbVersion table:" + sTableName * "was successfully created" * "at filelist slot:" * String(hTable)) to sInfoTxt
103725>>>        End
103725>>>>
103725>>>        Else Begin
103726>>>            Move ("The column could NOT be added. Either column" * sColumnName * "already exists or the Table name is incorrect?") to sInfoTxt
103727>>>        End
103727>>>>
103727>>>
103727>>>        Send LogError of (phoLogFile(Self)) 0 0 sInfoTxt 0 False
103728>>>    End_Procedure
103729>>>
103729>>>    Procedure Set pbVerboseState Boolean bVerboseState
103731>>>        Handle ho
103731>>>        Get phoLogFile to ho
103732>>>        Set pbVerboseState of ho to bVerboseState
103733>>>    End_Procedure
103734>>>
103734>>>    Function pbVerboseState Returns Boolean
103736>>>        Boolean bVerboseState
103736>>>        Handle ho
103736>>>        Get phoLogFile to ho
103737>>>        Get pbVerboseState of ho to bVerboseState
103738>>>        Function_Return bVerboseState
103739>>>    End_Function
103740>>>
103740>>>    // Callback functionality used when e.g. calling driver functions directly.
103740>>>    // Note that this overrules the callback function of the cDbUpdateFunctionLibrary class.
103740>>>    Function Callback String sCallback_Text Integer iCallback_Type Returns Integer
103742>>>        Integer iPerc
103742>>>        Number nReady nTotal nVersion
103742>>>        Boolean bVerboseState
103742>>>        Handle hoLogFile
103742>>>
103742>>>        Get pbVerboseState to bVerboseState
103743>>>        Get pnCurrentVersionUpdate to nVersion
103744>>>        Get phoLogFile     to hoLogFile
103745>>>        Send DoAdvance of ghoProgressBar
103746>>>
103746>>>        If (sCallback_Text contains "Dropping index" or sCallback_Text contains "Temporary delete of all indices of table") Begin
103748>>>            Move (Replace("Dropping index", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
103749>>>            Move (Replace("Temporary delete of all indices of table", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
103750>>>        End
103750>>>>
103750>>>        If (sCallback_Text contains "Creating index") Begin
103752>>>            Move (Replace("Creating index", sCallback_Text, CS_DUF_CreatingIndex)) to sCallback_Text
103753>>>        End
103753>>>>
103753>>>
103753>>>        Case Begin
103753>>>            Case (iCallback_Type = DF_Message_Text)
103755>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
103756>>>                Set Action_Text  of ghoStatusPanel to ""
103757>>>                If (bVerboseState = True) Begin
103759>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
103760>>>                End
103760>>>>
103760>>>                Case Break
103761>>>            Case (iCallback_Type = DF_Message_Heading_1)
103764>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
103765>>>                If (bVerboseState = True) Begin
103767>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
103768>>>                End
103768>>>>
103768>>>                Case Break
103769>>>            Case (iCallback_Type = DF_Message_Heading_2)
103772>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
103773>>>                Set Action_Text  of ghoStatusPanel to ""
103774>>>                If (bVerboseState = True) Begin
103776>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
103777>>>                End
103777>>>>
103777>>>                Case Break
103778>>>            Case (iCallback_Type = DF_Message_Heading_3)
103781>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
103782>>>                Set Action_Text  of ghoStatusPanel to ""
103783>>>                If (bVerboseState = True) Begin
103785>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
103786>>>                End
103786>>>>
103786>>>                Case Break
103787>>>            Case (iCallback_Type = DF_Message_Heading_4)
103790>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
103791>>>                Set Action_Text  of ghoStatusPanel to ""
103792>>>                If (bVerboseState = True) Begin
103794>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
103795>>>                End
103795>>>>
103795>>>                Case Break
103796>>>            Case (iCallback_Type = DF_Message_Heading_5)
103799>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
103800>>>                Set Action_Text  of ghoStatusPanel to ""
103801>>>                If (bVerboseState = True) Begin
103803>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
103804>>>                End
103804>>>>
103804>>>                Case Break
103805>>>            Case (iCallback_Type = DF_Message_Warning)
103808>>>                If (bVerboseState = True) Begin
103810>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
103811>>>                End
103811>>>>
103811>>>                Case Break
103812>>>            Case (iCallback_Type = DF_Message_Progress_Title)
103815>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
103816>>>                Set Action_Text  of ghoStatusPanel to ""
103817>>>                If (bVerboseState = True) Begin
103819>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
103820>>>                End
103820>>>>
103820>>>                Case Break
103821>>>            Case (iCallback_Type = DF_Message_Progress_Value)
103824>>>                //*** Interpret numbers
103824>>>                Move (Left(sCallback_Text, (Pos(",", sCallback_Text) - 1)))                       to nReady
103825>>>                Move (Right(sCallback_Text, (Length(sCallback_Text) - Pos(",", sCallback_Text)))) to nTotal
103826>>>                Move ((nReady/nTotal) * 100)                                                      to iPerc
103827>>>                Set Action_Text of ghoStatusPanel to (String(iPerc) * String("% (Total:") * String(nTotal) + ")")
103828>>>                Set piPosition of ghoProgressBar to iPerc
103829>>>                Case Break
103830>>>            Case Else
103830>>>                Set Message_Text to ""
103831>>>                Set Action_Text  to ""
103832>>>        Case End
103832>>>
103832>>>        Send ProcessEvents of ghoStatusPanel
103833>>>        Function_Return False
103834>>>    End_Function
103835>>>
103835>>>    // This was made to be a procedure/function pair so we
103835>>>    // at the same time can set the property of the cDbUpdateFunctionLibrary
103835>>>
103835>>>    Procedure Set piDbType Integer iDbType
103837>>>        If (ghoSQLConnectionHandler = 0) Begin
103839>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
103840>>>>
103840>>>            Procedure_Return
103841>>>        End
103841>>>>
103841>>>        Set piDbType of ghoSQLConnectionHandler to iDbType
103842>>>    End_Procedure
103843>>>
103843>>>    Function piDbType Returns Integer
103845>>>        Integer iDbType
103845>>>        If (ghoSQLConnectionHandler = 0) Begin
103847>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
103848>>>>
103848>>>            Function_Return ""
103849>>>        End
103849>>>>
103849>>>        Get piDbType of ghoSQLConnectionHandler to iDbType
103850>>>        Function_Return iDbType
103851>>>    End_Function
103852>>>
103852>>>    Procedure Set psDriverID String sDriverID
103854>>>        If (ghoSQLConnectionHandler = 0) Begin
103856>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
103857>>>>
103857>>>            Procedure_Return
103858>>>        End
103858>>>>
103858>>>        Set psDriverID of ghoSQLConnectionHandler to sDriverID
103859>>>    End_Procedure
103860>>>
103860>>>    Function psDriverID Returns String
103862>>>        String sValue
103862>>>        If (ghoSQLConnectionHandler = 0) Begin
103864>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
103865>>>>
103865>>>            Function_Return ""
103866>>>        End
103866>>>>
103866>>>        Get psDriverID of ghoSQLConnectionHandler to sValue
103867>>>        Function_Return sValue
103868>>>    End_Function
103869>>>
103869>>>    Procedure CreateSQLConnection String sDriverID String sConnectionID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Boolean bSilent
103871>>>        If (ghoSQLConnectionHandler = 0) Begin
103873>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
103874>>>>
103874>>>            Procedure_Return
103875>>>        End
103875>>>>
103875>>>        Send CreateSQLConnection of ghoSQLConnectionHandler sDriverID sConnectionID sServer sDatabase bTrusted sUserID sPassword bSilent
103876>>>    End_Procedure
103877>>>
103877>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
103879>>>        Integer iRetval
103879>>>        If (ghoSQLConnectionHandler = 0) Begin
103881>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
103882>>>>
103882>>>            Function_Return 2
103883>>>        End
103883>>>>
103883>>>
103883>>>        Get RedirectConnection of ghoSQLConnectionHandler to iRetval
103884>>>        Function_Return iRetval
103885>>>    End_Function
103886>>>
103886>>>    Procedure Set psConnectionID String sValue
103888>>>        If (ghoSQLConnectionHandler = 0) Begin
103890>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
103891>>>>
103891>>>            Procedure_Return
103892>>>        End
103892>>>>
103892>>>        Set psConnectionID of ghoSQLConnectionHandler to sValue
103893>>>    End_Procedure
103894>>>
103894>>>    Function psConnectionID Returns String
103896>>>        String sValue
103896>>>        If (ghoSQLConnectionHandler = 0) Begin
103898>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
103899>>>>
103899>>>            Function_Return ""
103900>>>        End
103900>>>>
103900>>>        Get psConnectionID of ghoSQLConnectionHandler to sValue
103901>>>
103901>>>        Function_Return sValue
103902>>>    End_Function
103903>>>
103903>>>    // These "properties" are settings of the cCLIHandler class, but are being
103903>>>    // relayed to the ghoSQLConnectionHandler object
103903>>>    // simply by changing one of its parameters.
103903>>>    Procedure Set psServer String sValue
103905>>>        If (ghoSQLConnectionHandler = 0) Begin
103907>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
103908>>>>
103908>>>            Procedure_Return
103909>>>        End
103909>>>>
103909>>>        Set psServer of ghoSQLConnectionHandler to sValue
103910>>>    End_Procedure
103911>>>
103911>>>    Function psServer Returns String
103913>>>        String sValue
103913>>>        If (ghoSQLConnectionHandler = 0) Begin
103915>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
103916>>>>
103916>>>            Function_Return ""
103917>>>        End
103917>>>>
103917>>>        Get psServer of ghoSQLConnectionHandler to sValue
103918>>>
103918>>>        Function_Return sValue
103919>>>    End_Function
103920>>>
103920>>>    Procedure Set psDatabase String sValue
103922>>>        If (ghoSQLConnectionHandler = 0) Begin
103924>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
103925>>>>
103925>>>            Procedure_Return
103926>>>        End
103926>>>>
103926>>>        Set psDatabase of ghoSQLConnectionHandler to sValue
103927>>>    End_Procedure
103928>>>
103928>>>    Function psDatabase Returns String
103930>>>        String sValue
103930>>>        If (ghoSQLConnectionHandler = 0) Begin
103932>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
103933>>>>
103933>>>            Function_Return ""
103934>>>        End
103934>>>>
103934>>>        Get psDatabase of ghoSQLConnectionHandler to sValue
103935>>>
103935>>>        Function_Return sValue
103936>>>    End_Function
103937>>>
103937>>>    Procedure Set psUserID String sValue
103939>>>        If (ghoSQLConnectionHandler = 0) Begin
103941>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
103942>>>>
103942>>>            Procedure_Return
103943>>>        End
103943>>>>
103943>>>        Set psUserID of ghoSQLConnectionHandler to sValue
103944>>>    End_Procedure
103945>>>
103945>>>    Function psUserID Returns String
103947>>>        String sValue
103947>>>        If (ghoSQLConnectionHandler = 0) Begin
103949>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
103950>>>>
103950>>>            Function_Return ""
103951>>>        End
103951>>>>
103951>>>        Get psUserID of ghoSQLConnectionHandler to sValue
103952>>>
103952>>>        Function_Return sValue
103953>>>    End_Function
103954>>>
103954>>>    Procedure Set psPassword String sValue
103956>>>        If (ghoSQLConnectionHandler = 0) Begin
103958>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
103959>>>>
103959>>>            Procedure_Return
103960>>>        End
103960>>>>
103960>>>        Set psPassword of ghoSQLConnectionHandler to sValue
103961>>>    End_Procedure
103962>>>
103962>>>    Function psPassword Returns String
103964>>>        String sValue
103964>>>        If (ghoSQLConnectionHandler = 0) Begin
103966>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
103967>>>>
103967>>>            Function_Return ""
103968>>>        End
103968>>>>
103968>>>        Get psPassword of ghoSQLConnectionHandler to sValue
103969>>>
103969>>>        Function_Return sValue
103970>>>    End_Function
103971>>>
103971>>>    Procedure Set pbTrusted Boolean bValue
103973>>>        If (ghoSQLConnectionHandler = 0) Begin
103975>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
103976>>>>
103976>>>            Procedure_Return
103977>>>        End
103977>>>>
103977>>>        Set pbTrusted of ghoSQLConnectionHandler to bValue
103978>>>    End_Procedure
103979>>>
103979>>>    Function pbTrusted Returns Boolean
103981>>>        Boolean bValue
103981>>>        If (ghoSQLConnectionHandler = 0) Begin
103983>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
103984>>>>
103984>>>            Function_Return False
103985>>>        End
103985>>>>
103985>>>        Get pbTrusted of ghoSQLConnectionHandler to bValue
103986>>>
103986>>>        Function_Return bValue
103987>>>    End_Function
103988>>>
103988>>>    Procedure Set psConnectionString String sValue
103990>>>        If (ghoSQLConnectionHandler = 0) Begin
103992>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
103993>>>>
103993>>>            Procedure_Return
103994>>>        End
103994>>>>
103994>>>        Set psConnectionString of ghoSQLConnectionHandler to sValue
103995>>>    End_Procedure
103996>>>
103996>>>    Function psConnectionString Returns String
103998>>>        String sValue
103998>>>        If (ghoSQLConnectionHandler = 0) Begin
104000>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
104001>>>>
104001>>>            Function_Return ""
104002>>>        End
104002>>>>
104002>>>        Get psConnectionString of ghoSQLConnectionHandler to sValue
104003>>>
104003>>>        Function_Return sValue
104004>>>    End_Function
104005>>>
104005>>>    Function piConnectionOptions Returns Integer
104007>>>        Integer iValue
104007>>>        If (ghoSQLConnectionHandler = 0) Begin
104009>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
104010>>>>
104010>>>            Function_Return 0
104011>>>        End
104011>>>>
104011>>>        Get piConnectionOptions of ghoSQLConnectionHandler to iValue
104012>>>
104012>>>        Function_Return iValue
104013>>>    End_Function
104014>>>
104014>>>
104014>>>    Procedure Set pbCheckDataFlexUserCount Boolean bState
104016>>>        Set pbCheckDataFlexUserCount of (phoUserCountSystem(Self)) to bState
104017>>>    End_Procedure
104018>>>
104018>>>    Function pbCheckDataFlexUserCount Returns Boolean
104020>>>        Boolean bState
104020>>>        Get pbCheckDataFlexUserCount of (phoUserCountSystem(Self)) to bState
104021>>>        Function_Return bState
104022>>>    End_Function
104023>>>
104023>>>    Procedure Set psLogTextFile String sValue
104025>>>        Set psLogTextFile of (phoLogFile(Self)) to sValue
104026>>>    End_Procedure
104027>>>
104027>>>    Function psLogTextFile Returns String
104029>>>        String sValue
104029>>>        Get psLogTextFile of (phoLogFile(Self)) to sValue
104030>>>        Function_Return sValue
104031>>>    End_Function
104032>>>
104032>>>    Procedure Set psEditorProgram String sValue
104034>>>        Set psEditorProgram of (phoLogFile(Self)) to sValue
104035>>>    End_Procedure
104036>>>
104036>>>    Function psEditorProgram Returns String
104038>>>        String sValue
104038>>>        Get psEditorProgram of (phoLogFile(Self)) to sValue
104039>>>        Function_Return sValue
104040>>>    End_Function
104041>>>
104041>>>    Procedure Set pbUseDataTableLog Boolean bState
104043>>>        Set pbUseDataTableLog of (phoLogFile(Self)) to bState
104044>>>    End_Procedure
104045>>>
104045>>>    Function pbUseDataTableLog Returns Boolean
104047>>>        Boolean bState
104047>>>        Get pbUseDataTableLog of (phoLogFile(Self)) to bState
104048>>>        Function_Return bState
104049>>>    End_Function
104050>>>
104050>>>    Procedure Set pbQuickWrite Boolean bState
104052>>>        Set pbQuickWrite of (phoLogFile(Self)) to bState
104053>>>    End_Procedure
104054>>>
104054>>>    Function pbQuickWrite Returns Boolean
104056>>>        Boolean bState
104056>>>        Get pbQuickWrite of (phoLogFile(Self)) to bState
104057>>>        Function_Return bState
104058>>>    End_Function
104059>>>
104059>>>    Procedure Set pbDatabaseWasUpdated Boolean bState
104061>>>        Boolean bUpdateVersionObjectError bVerboseState
104061>>>        Integer iSize iCount
104061>>>        Number nVersion
104061>>>        String[] aSQLQueryMessages
104062>>>
104062>>>        Get Private.pbUpdateVersionObjectError to bUpdateVersionObjectError
104063>>>        Set Private.pbDatabaseWasUpdated to bState
104064>>>        // If no errors occurred in the current cDbUpdateVersion object - write
104064>>>        // to the log that it was OK.
104064>>>        If (bUpdateVersionObjectError = False) Begin
104066>>>            Get pnCurrentVersionUpdate to nVersion
104067>>>            Send LogError of (phoLogFile(Self)) nVersion 0 CS_SuccessfulUpdate 0 False
104068>>>        End
104068>>>>
104068>>>
104068>>>        Get pbVerboseState to bVerboseState
104069>>>        If (bVerboseState = True) Begin
104071>>>            Get paSQLQueryMessages to aSQLQueryMessages
104072>>>            Move (SizeOfArray(aSQLQueryMessages)) to iSize
104073>>>            Decrement iSize
104074>>>            For iCount from 0 to iSize
104080>>>>
104080>>>                Send LogError of (phoLogFile(Self)) nVersion 0 aSQLQueryMessages[iCount] 0 False
104081>>>            Loop
104082>>>>
104082>>>        End
104082>>>>
104082>>>
104082>>>    End_Procedure 
104083>>>    
104083>>>    Procedure Set piDbVersionFileNumber Integer iFileNumber
104085>>>        Set Private.piDbVersionFileNumber to iFileNumber
104086>>>    End_Procedure                                         
104087>>>    
104087>>>    Function piDbVersionFileNumber Returns Integer
104089>>>        Function_Return (Private.piDbVersionFileNumber(Self))
104090>>>    End_Function
104091>>>
104091>>>    Procedure Set piDbVersionFieldNumber Integer iFieldNumber
104093>>>        Set Private.piDbVersionFieldNumber to iFieldNumber
104094>>>    End_Procedure                                         
104095>>>    
104095>>>    Function piDbVersionFieldNumber Returns Integer
104097>>>        Function_Return (Private.piDbVersionFieldNumber(Self))
104098>>>    End_Function
104099>>>
104099>>>    Function pbDatabaseWasUpdated Returns Boolean
104101>>>        Function_Return (Private.pbDatabaseWasUpdated(Self))
104102>>>    End_Function
104103>>>    
104103>>>    //
104103>>>    Procedure ReinitializeFramework  
104105>>>        tDbVersionInfo[] aDbVersionInfoArray
104105>>>        tDbVersionInfo[] aDbVersionInfoArray
104106>>>        Handle hoDbVersionObject
104106>>>        Integer iSize iCount
104106>>>        
104106>>>        Set Private.pbDatabaseUpdateStarted to False
104107>>>        Get paDbVersionInfoArray to aDbVersionInfoArray
104108>>>        Move (SizeOfArray(aDbVersionInfoArray)) to iSize
104109>>>        Decrement iSize
104110>>>        
104110>>>        For iCount from 0 to iSize
104116>>>>
104116>>>            Move aDbVersionInfoArray[0].hObject to hoDbVersionObject
104117>>>            Send ProcessUpdate                  of hoDbVersionObject False
104118>>>        Loop
104119>>>>
104119>>>        Send Cleanup
104120>>>    End_Procedure
104121>>>    
104121>>>    // This event is triggered by the cDbUpdateVersion child class when
104121>>>    // a database change is to be started, and is considered private.
104121>>>    // It is only executed once for the first cDbUpateVersion object!
104121>>>    Procedure InitDatabaseUpdate Handle hDbUpdateVersionObject
104123>>>        Boolean bDatabaseUpdateStarted bInUse bExists bCheckDataFlexUserCount
104123>>>        Integer iRetval iDataFlexUsers iUserCount
104123>>>        Handle hoUserCountSystem
104123>>>        tUserCount UserCount
104123>>>        tUserCount UserCount
104123>>>        DateTime dtUpdateStarted
104123>>>        tSQLConnection SQLConnection
104123>>>        tSQLConnection SQLConnection
104123>>>
104123>>>        // *Important:* If we already started the update; we do no further checking.
104123>>>        Get Private.pbDatabaseUpdateStarted to bDatabaseUpdateStarted
104124>>>        If (bDatabaseUpdateStarted = True) Begin
104126>>>            Procedure_Return
104127>>>        End
104127>>>>
104127>>>
104127>>>        // If not silent mode; Ask user if OK to start database update.
104127>>>        If (pbSilentMode(Self) = False) Begin
104129>>>            Get YesNo_Box CS_DUF_DatabaseNeedsUpdate CS_DUF_HeaderUpdateText to iRetval
104130>>>            If (iRetval <> MBR_Yes) Begin
104132>>>                Send Exit_Application
104133>>>            End
104133>>>>
104133>>>        End
104133>>>>
104133>>>        
104133>>>        Send EnableCancelButton     of ghoStatusPanel (pbEnableCancelButton(Self))
104134>>>        Send Initialize_StatusPanel of ghoStatusPanel ("   " + CS_DUF_WorkingUpdateText) CS_DUF_WorkingHeaderText ""
104135>>>        Send Start_StatusPanel      of ghoStatusPanel
104136>>>
104136>>>        // This will save the status of all open tables including Master/Alias settings,
104136>>>        // so we can restore them later;
104136>>>        Send SaveOpenTables
104137>>>
104137>>>        Move 0 to iDataFlexUsers
104138>>>        // Make various tests to check that the database is not in use.
104138>>>        Get IsDatabaseInUse of hDbUpdateVersionObject to bInUse
104139>>>        // We also use our own user counting mechanism to guard against the
104139>>>        // database isn't opened already as we need exclusive access to the tables.:
104139>>>        Get phoUserCountSystem to hoUserCountSystem
104140>>>        Get CheckUserCount of hoUserCountSystem to UserCount
104141>>>        Get CurrentNumberOfUsers of hoUserCountSystem to iUserCount
104142>>>
104142>>>        Get pbCheckDataFlexUserCount of hoUserCountSystem to bCheckDataFlexUserCount
104143>>>        // Check DataFlex user count to see if anybody else is using the DataFlex license...
104143>>>        If (bCheckDataFlexUserCount = True) Begin
104145>>>            Get_Current_User_Count to iDataFlexUsers
104146>>>            // For some reason DataFlex - in some cases - might think that 2 users
104146>>>            // are in use while debugging from the Studio.
104146>>>            If (IsDebuggerPresent() and iDataFlexUsers = 2) Begin
104148>>>                Decrement iDataFlexUsers
104149>>>            End
104149>>>>
104149>>>        End 
104149>>>>
104149>>>        Else Begin
104150>>>            Move 1 to iDataFlexUsers 
104151>>>            Move 1 to iUserCount
104152>>>            Move False to bInUse
104153>>>        End
104153>>>>
104153>>>
104153>>>        If (pbSilentMode(Self) = False and iDataFlexUsers > 1) Begin
104155>>>            Get YesNo_Box CS_DUF_DatabaseInUseShort to iRetval
104156>>>            If (iRetval <> MBR_Yes) Begin
104158>>>                Send Exit_Application
104159>>>            End
104159>>>>
104159>>>        End
104159>>>>
104159>>>
104159>>>        If (bInUse = True or (UserCount.iError <> 0) or (iUserCount > 1)) Begin
104161>>>            Send Stop_Box CS_DUF_DatabaseInUseText
104162>>>            Send Exit_Application
104163>>>        End
104163>>>>
104163>>>
104163>>>        // This will put a look on the DbUpdateLock.ucf file.
104163>>>        // It is released when the update process is finished
104163>>>        Get CheckUserCount of (phoDatabaseUpdateLock(Self)) to UserCount
104164>>>
104164>>>        Move (CurrentDateTime()) to dtUpdateStarted
104165>>>        Set pdtUpdateStart of (phoLogFile(Self)) to dtUpdateStarted
104166>>>        Set Private.pbDatabaseUpdateStarted to True
104167>>>
104167>>>        // We need to close all tables before starting to make changes.
104167>>>        Close DF_ALL DF_PERMANENT
104168>>>
104168>>>        // If these properties has not exclicitly been set in the object, set them
104168>>>        // to settings from the SQLConnections.ini file;
104168>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
104169>>>        If (psSchema(Self) = "") Begin
104171>>>            Set psSchema            to SQLConnection.sSchema
104172>>>        End
104172>>>>
104172>>>        If (psBaseTableSpace(Self) = "") Begin
104174>>>            Set psBaseTableSpace    to SQLConnection.sBaseTableSpace
104175>>>        End
104175>>>>
104175>>>        If (psLongTableSpace(Self) = "") Begin
104177>>>            Set psLongTableSpace    to SQLConnection.sLongTableSpace
104178>>>        End
104178>>>>
104178>>>        If (psIndexTableSpace(Self) = "") Begin
104180>>>            Set psIndexTableSpace   to SQLConnection.sIndexTableSpace
104181>>>        End
104181>>>>
104181>>>        If (SQLConnection.sDriverID = "" or SQLConnection.sDriverID = DATAFLEX_ID) Begin
104183>>>            Procedure_Return
104184>>>        End
104184>>>>
104184>>>
104184>>>        Get SQLUtilCheckIfDatabaseExists of hDbUpdateVersionObject SQLConnection.sDatabase to bExists
104185>>>        If (SQLConnection.sDatabase <> "" and bExists = False) Begin
104187>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
104188>>>            Send Stop_StatusPanel of ghoStatusPanel
104189>>>            // ToDo: NS 2019-09-23 I think we should always show an error message to the user if this occur (!)
104189>>>            Send Stop_Box (CS_DUF_DatabaseConnStringSpec + SQLConnection.sDatabase + CS_DUF_DatabaseDoesntExist )
104190>>>//            Error DFERR_PROGRAM ("The database specified in the connection string: '" + SQLConnection.sDatabase + "' doesn't exist!\n\nYou need to create it with a database management software or by using the 'SqlDatabaseCreate' function, which can be used in the 'OnPreUpdate' event of the cDbUpdateHandler object.\n\nThe program will now exit.")
104190>>>            Send Exit_Application
104191>>>        End
104191>>>>
104191>>>    End_Procedure
104192>>>
104192>>>    // *** Hook message for pre-processing ***
104192>>>    // Event to be used to auto-create a version table when "DUF_Use_Custom_DbVersion" is used.
104192>>>    // Aka, when another table than the standard "DbVersion" is used.
104192>>>    Procedure OnCreateCustomDbVersionTable
104194>>>    End_Procedure
104195>>>    
104195>>>    // *** Hook message for pre-processing ***
104195>>>    // The programmer can use this event for putting code that
104195>>>    // needs to be executed _before_ code in any of the cDbUpdateVersion
104195>>>    // child objects are executed.
104195>>>    Procedure OnPreUpdate
104197>>>    End_Procedure
104198>>>
104198>>>    // *** Hook message for post-processing ***
104198>>>    // The programmer should use this event for putting code that
104198>>>    // needs to be executed _after_ all database updates have finished.
104198>>>    Procedure OnPostUpdate
104200>>>    End_Procedure
104201>>>
104201>>>    // *** Hook message for custom DbVersion record find ***
104201>>>    // The programmer can use this event for putting code that
104201>>>    // needs to be executed to find a *custom* DbVersion table record.
104201>>>    // By default the DbVersion table is used but this can be
104201>>>    // customized by adding this line to the code;
104201>>>    // "Define DUF_Use_Custom_DbVersion" before the line "Use cDbUpdateHandler.pkg"
104201>>>    // Note: You do _not_ need to use this event if the DbVersion table is used
104201>>>    //       to save the current database version to. Only if you use your own
104201>>>    //       table _and_ it is not a system table (contains only one record).
104201>>>    Procedure OnFindVersionRecord
104203>>>        // Open MyTable
104203>>>        // Move xx to MyTable.Field1
104203>>>        // Move yy to MyTable.Field2
104203>>>        // Find le MyTable by Index.x
104203>>>    End_Procedure
104204>>>
104204>>>    // Hook event for writing header error text (pre-update) to
104204>>>    // a datatable. Only called if the pbUseDataTableLog property = True.
104204>>>    // Don't forget to Open the table first (!) as all
104204>>>    // tables have been closed at this stage.
104204>>>    // The start date & time is passed.
104204>>>    Procedure OnErrorWriteHeader_DataTable DateTime dtUpdateStart
104206>>>    End_Procedure
104207>>>
104207>>>    // Hook event to log errors to a database table.
104207>>>    // Only called if the pbUseDataTableLog = True.
104207>>>    // Don't forget to Open the table first (!) as all
104207>>>    // tables have been closed at this stage.
104207>>>    // If pbQuickWrite = True the DbUpdateErrorArray
104207>>>    // will contain just one row, as it is called for each error
104207>>>    // that occurred. Else it is called once at the end after all updates
104207>>>    // have run and contains all errors.
104207>>>    Procedure OnErrorWriteRow_DataTable tDbUpdateError[] DbUpdateErrorArray
104209>>>    End_Procedure
104210>>>
104210>>>    // Automatically send after all processing is done, but before the OnPostUpdate event.
104210>>>    Procedure Cleanup
104212>>>        Boolean bDatabaseWasUpdated bError
104212>>>
104212>>>        Send CheckAutoCreateDbVersionTable
104213>>>        Send RestoreOpenTables
104214>>>
104214>>>        // The function library have two purposes; one is to use it in the
104214>>>        // Database Update Framework, but it can also be used on its own.
104214>>>        // If that is the case it has its own error handling system, which
104214>>>        // we temporarily disbled when running updates because we have
104214>>>        // error handling/logging here too... We now restore its setting.
104214>>>        If (ghoDbUpdateFunctionLibrary > 0) Begin
104216>>>            Set pbHandleQueryErrors of ghoDbUpdateFunctionLibrary to True
104217>>>        End
104217>>>>
104217>>>        Set pbHandleQueryErrors to True
104218>>>
104218>>>        Get pbDatabaseWasUpdated to bDatabaseWasUpdated
104219>>>        Get pbDbUpdateErrorHasOccured to bError
104220>>>        If (bDatabaseWasUpdated = True or bError = True) Begin
104222>>>
104222>>>            // We should always create the log as it also contains info about
104222>>>            // the update being successful.
104222>>>            Send WriteErrorLog of (phoLogFile(Self))
104223>>>
104223>>>            // This is a programmer's hook message:
104223>>>            Send OnPostUpdate
104224>>>
104224>>>            Send Stop_StatusPanel of ghoStatusPanel
104225>>>
104225>>>            If (pbSilentMode(Self) = False) Begin
104227>>>                If (bError = True) Begin
104229>>>                    If (pbShowErrorLogPostRun(Self) = True) Begin
104231>>>                        Send ShowErrorLog of (phoLogFile(Self))
104232>>>                    End
104232>>>>
104232>>>                    Send Info_Box CS_DUF_DbUpdatedErrorText
104233>>>                    Send Exit_Application
104234>>>                End
104234>>>>
104234>>>                Else Begin
104235>>>                    If (Private.pbDatabaseWasUpdated(Self) = True) Begin
104237>>>                        Send Info_Box CS_DUF_DatabaseUpdatedText
104238>>>                    End
104238>>>>
104238>>>                    Else Begin
104239>>>                        Send Info_Box CS_DUF_DatabaseCheckedText
104240>>>                    End
104240>>>>
104240>>>
104240>>>                End
104240>>>>
104240>>>            End
104240>>>>
104240>>>        End
104240>>>>
104240>>>
104240>>>        // Restore the standard error handler:
104240>>>        Get piOrgErrorHandlerID to Error_Object_Id
104241>>>    End_Procedure
104242>>>
104242>>>    // We do this _before_ we close the database to make changes, and save
104242>>>    // all 'Master' & 'Alias' tables settings so we can restore when
104242>>>    // we reopen the database.
104242>>>    Procedure SaveOpenTables
104244>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
104244>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
104245>>>        Get _MasterAndAliasFiles to aDbUpdateHandlerMasterAlias
104246>>>        Set paDbUpdateHandlerMasterAlias to aDbUpdateHandlerMasterAlias
104247>>>    End_Procedure
104248>>>
104248>>>    // Returns a struct array with all currently open tables and a "state" that indicates if the table
104248>>>    // was opened DF_FILE_ALIAS_DEFAULT, DF_FILE_IS_MASTER or DF_FILE_IS_ALIAS
104248>>>    Function _MasterAndAliasFiles Returns tDbUpdateHandlerMasterAlias[]
104250>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
104250>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
104251>>>        Integer hTable iMasterAliasType iSize
104251>>>        Boolean bOpen
104251>>>
104251>>>        Move 0 to hTable
104252>>>        Repeat
104252>>>>
104252>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
104255>>>            If (hTable <> 0) Begin
104257>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
104260>>>                If (bOpen = True) Begin
104262>>>                    Get_Attribute DF_FILE_ALIAS of hTable to iMasterAliasType
104265>>>                    Move (SizeOfArray(aDbUpdateHandlerMasterAlias)) to iSize
104266>>>                    Move hTable to aDbUpdateHandlerMasterAlias[iSize].hTable
104267>>>                    Move iMasterAliasType to aDbUpdateHandlerMasterAlias[iSize].iMode
104268>>>                End
104268>>>>
104268>>>            End
104268>>>>
104268>>>        Until (hTable = 0)
104270>>>
104270>>>        Function_Return aDbUpdateHandlerMasterAlias
104271>>>    End_Function
104272>>>
104272>>>    // Message that re-opens all files in the filelist.cfg and restores any master & alias attributes.
104272>>>    // Takes one parameter:
104272>>>    //   A struct array with all master & alias
104272>>>    Procedure RestoreOpenTables
104274>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
104274>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
104275>>>        Integer hTable iFileAlias iSize iCount
104275>>>        Boolean bOpen
104275>>>        String sRootName
104275>>>
104275>>>        Move 0 to hTable
104276>>>        Get paDbUpdateHandlerMasterAlias to aDbUpdateHandlerMasterAlias
104277>>>        Move (SizeOfArray(aDbUpdateHandlerMasterAlias)) to iSize
104278>>>        Decrement iSize
104279>>>        For iCount from 0 to iSize
104285>>>>
104285>>>            Move aDbUpdateHandlerMasterAlias[iCount].hTable to hTable
104286>>>            // We also need to check that the table hasn't been removed...
104286>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
104289>>>            If (hTable <> 0 and sRootName <> "") Begin
104291>>>                Open hTable
104293>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
104296>>>                If (bOpen = True) Begin
104298>>>                    Move aDbUpdateHandlerMasterAlias[iCount].iMode to iFileAlias
104299>>>                    If (iFileAlias = DF_FILE_IS_MASTER) Begin
104301>>>                        Set_Attribute DF_FILE_ALIAS of hTable to DF_FILE_IS_MASTER
104304>>>                    End
104304>>>>
104304>>>                    Else If (iFileAlias = DF_FILE_IS_ALIAS) Begin
104307>>>                        Set_Attribute DF_FILE_ALIAS of hTable to DF_FILE_IS_ALIAS
104310>>>                    End
104310>>>>
104310>>>                End
104310>>>>
104310>>>            End
104310>>>>
104310>>>        Loop
104311>>>>
104311>>>    End_Procedure
104312>>>
104312>>>    // This checks for both duplicate pnVersionNumbers _and_ that
104312>>>    // the cDbVersion object pnVersionNumber's all are consecutive (higher than the previous).
104312>>>    Procedure CheckForDuplicates Number nVersion
104314>>>        tDbVersionInfo[] DbVersionInfoArray
104314>>>        tDbVersionInfo[] DbVersionInfoArray
104315>>>        Integer iCount iSize iHits iDuplicateIndex
104315>>>        Number nCompare
104315>>>        Handle hObject1 hObject2
104315>>>        String sObjectName1 sObjectName2
104315>>>        Boolean bObjectOrderError
104315>>>
104315>>>        Get paDbVersionInfoArray to DbVersionInfoArray
104316>>>        Move (SizeOfArray(DbVersionInfoArray)) to iSize
104317>>>        Decrement iSize
104318>>>        Move 0 to iHits
104319>>>        Move 0 to nCompare
104320>>>        Move False to bObjectOrderError
104321>>>        For iCount from 0 to iSize
104327>>>>
104327>>>            If (nVersion = DbVersionInfoArray[iCount].nVersionNumber) Begin
104329>>>                Increment iHits
104330>>>                If (iHits > 1) Begin
104332>>>                    Move iCount to iDuplicateIndex
104333>>>                    If (nCompare <> 0) Begin
104335>>>                        Move (nCompare >= DbVersionInfoArray[iCount].nVersionNumber) to bObjectOrderError
104336>>>                    End
104336>>>>
104336>>>                End
104336>>>>
104336>>>            End
104336>>>>
104336>>>            Move DbVersionInfoArray[iCount].nVersionNumber to nCompare
104337>>>        Loop
104338>>>>
104338>>>        If (iHits > 1) Begin
104340>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
104341>>>            Move DbVersionInfoArray[(iDuplicateIndex   )].hObject to hObject1
104342>>>            Move DbVersionInfoArray[(iDuplicateIndex -1)].hObject to hObject2
104343>>>            Move (Name(hObject1)) to sObjectName1
104344>>>            Move (Name(hObject2)) to sObjectName2
104345>>>            Error DFERR_PROGRAM ("Duplicate version numbers! The SAME pnVersionNumber value was set for the following two objects; Program will now exit!\n\n" + sObjectName1 + "\n" + sObjectName2)
104346>>>>
104346>>>            Send Exit_Application
104347>>>        End
104347>>>>
104347>>>        Else If (bObjectOrderError = True) Begin
104350>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
104351>>>            Error DFERR_PROGRAM ("cDbVersion objects out of order! One or more of the cDbVersion objects has been placed out of order. This means that at least one pnVersionNumber is HIGHER than the following object's pnVersionNumber.\nProgram will now exit!")
104352>>>>
104352>>>            Send Exit_Application
104353>>>        End
104353>>>>
104353>>>    End_Procedure
104354>>>
104354>>>    // We take care of all errors in the Error_Report below and
104354>>>    // collect them all to an array property. So just ignore any
104354>>>    // "Ignore_Error" & "Trap_Error" messages that might be send/used
104354>>>    // in some other package.
104354>>>    Procedure Ignore_Error Integer iError
104356>>>    End_Procedure
104357>>>
104357>>>    Procedure Trap_Error Integer iError
104359>>>    End_Procedure
104360>>>
104360>>>    // Build complete error description from Flexerrs and user error message.
104360>>>    Function Error_Description Integer Error# String ErrMsg Returns String
104362>>>        String Full_Error_Text
104362>>>        
104362>>>        Move (Trim(ErrMsg)) to ErrMsg
104363>>>        Move (Trim(Error_Text(DESKTOP, Error#))) to Full_Error_Text
104364>>>        
104364>>>        If (ErrMsg <> "") Begin
104366>>>            
104366>>>            If ((Full_Error_Text<>"" ) and ;                Error_Text_Available( DESKTOP, Error# ) ) Begin
104368>>>                // Make sure last character of error text is a separating symbol.
104368>>>                // if not, add a "." So we have format of "error-text. error-detail"
104368>>>                If (Pos(Right(Full_Error_Text,1),".,:;") =0) ;                    Move (Full_Error_Text - ".") to Full_Error_Text
104371>>>                Move (Full_Error_Text * ErrMsg)  to Full_Error_Text
104372>>>            End
104372>>>>
104372>>>            Else ;                Move ErrMsg to Full_Error_Text
104374>>>            
104374>>>        End
104374>>>>
104374>>>        
104374>>>        Function_Return Full_Error_Text
104375>>>    End_Function
104376>>>
104376>>>    // While we update the database we collect all errors in
104376>>>    // the struct array paDbUpdateErrorArray.
104376>>>    Procedure Error_Report Integer iErrorNumber Integer iErrorLine String sErrorText
104378>>>        Number nVersion
104378>>>        Handle hoLogFile 
104378>>>//        String sErrExtraText
104378>>>        
104378>>>        If (Private.pbProcessingError(Self)) Begin
104380>>>            Procedure_Return
104381>>>        End
104381>>>>
104381>>>
104381>>>        // The UtilTableNameFromHandleToString function does a:
104381>>>        // "Get_Attribute DF_FILE_TABLE_NAME of hTable to sTableName" call
104381>>>        // and it generates an error if the table is of the embedded type.
104381>>>        // As we don't want to trigger an error in that very specific case,
104381>>>        // we just ignore it here.
104381>>>        //
104381>>>        // If no report mode, just set the err indicator to true.
104381>>>        If (Error_Report_Mode(Self) = DUF_ERROR_NO_REPORT) Begin
104383>>>            Move False to Err
104384>>>            Procedure_Return
104385>>>        End
104385>>>>
104385>>>
104385>>>        If (iErrorNumber = DFERR_UNSUPPORTED_ATTRIBUTE) Begin
104387>>>            Procedure_Return
104388>>>        End
104388>>>>
104388>>>
104388>>>        Set Private.pbProcessingError to True
104389>>>        Set Private.pbUpdateVersionObjectError to True
104390>>>
104390>>>        Set pbDbUpdateErrorHasOccured to True
104391>>>        Get pnCurrentVersionUpdate to nVersion
104392>>>        Get phoLogFile to hoLogFile
104393>>>//        Get Error_Description iErrorLine sErrorText to sErrorText
104393>>>        Send LogError of hoLogFile nVersion iErrorNumber sErrorText iErrorLine True
104394>>>
104394>>>        Set Private.pbProcessingError to False
104395>>>    End_Procedure
104396>>>
104396>>>End_Class
104397>Use vWin32fh.pkg
104397>Use cDbUpdateVersion.pkg
104397>
104397>Object oHtmlHelp is a cHtmlHelp
104399>    Set pbAlwaysOnTop to False
104400>End_Object
104401>
104401>Define CS_PropertiesKeyWord     for "Properties"
104401>Define CS_ThemeKeyWord          for "Theme"
104401>
104401>//#IF (!@ < 190)
104401>//    Send Stop_Box "Nope, that won't work. You need at least DataFlex 19.0 to run this program."
104401>//    Send Exit_Application
104401>//#ENDIF
104401>
104401>Object oApplication is a cApplication
104403>    Set psCompany to "RDC Tools International"
104404>    Set psProduct to "DUF - Code Generator"
104405>    Set peHelpType to htHtmlHelp
104406>    // Note: The help file settings gets changed by the Help toolbar button(s).
104406>    Set psHelpFile to "Developer5.chm"
104407>
104407>    Property Handle phoDbUpdateHandler 0
104409>    Property Handle phoTableDUFCodeGenerator_vw 0
104411>    Property String private.psFilelistFromOrg ""
104413>    Property String psFilelistFrom ""
104415>    Property Integer[] piaDifferences
104417>    Property String psOrgOpenPath ""
104419>
104419>    // Set psOrgOpenPath at startup
104419>    Procedure Save_DF_OPEN_PATH
104422>        String sOrgOpenPath sDataPath sFileListPath
104422>        
104422>        Get psFileList of (phoWorkspace(ghoApplication)) to sFileListPath
104423>        Set private.psFilelistFromOrg to sFileListPath
104424>        Get_Attribute DF_OPEN_PATH to sOrgOpenPath
104427>        // First remove the current Data folder path
104427>        Get PathAtIndex of (phoWorkspace(Self)) sOrgOpenPath 1 to sDataPath
104428>        Move (Replace(sDataPath, sOrgOpenPath, "")) to sOrgOpenPath
104429>        If (Left(sOrgOpenPath, 2) = "\;") Begin
104431>            Move (Replace("\;", sOrgOpenPath, "")) to sOrgOpenPath
104432>        End
104432>        Set psOrgOpenPath to sOrgOpenPath
104433>    End_Procedure
104434>
104434>    Procedure OnWorkspaceOpened
104437>        Forward Send OnWorkspaceOpened
104439>        Send Save_DF_OPEN_PATH
104440>    End_Procedure
104441>
104441>    Procedure Restore_DF_OPEN_PATH
104444>        String sOrgOpenpath
104444>        Get psOrgOpenPath to sOrgOpenpath
104445>        Set_Attribute DF_OPEN_PATH to sOrgOpenPath
104448>    End_Procedure
104449>
104449>    Procedure ResetFilelistPathing
104452>        String sDriverID sServer sFileList sDataPath
104452>        Send Restore_DF_OPEN_PATH
104453>        Close DF_ALL DF_PERMANENT
104454>        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
104455>        Get psServer   of ghoDbUpdateFunctionLibrary to sServer  
104456>        If (sDriverID <> "") Begin
104458>            Logout sDriverID sServer
104459>        End
104459>        Set psDriverID of ghoDbUpdateFunctionLibrary to DATAFLEX_ID
104460>        Set psServer   of ghoDbUpdateFunctionLibrary to ""
104461>        Get private.psFilelistFromOrg to sFileList
104462>        Get ParseFolderName sFileList                      to sDataPath
104463>        If (Right(sDataPath, 1) = "\") Begin
104465>            Move (Left(sDataPath, (Length(sDataPath) -1))) to sDataPath
104466>        End
104466>        Set psDataPath of (phoWorkspace(Self))  to sDataPath
104467>        Set psFileList of (phoWorkspace(Self))  to sFileList
104468>        Set_Attribute DF_FILELIST_NAME          to sFileList
104471>    End_Procedure
104472>
104472>    Function ChangeFilelistPathing String sFileList Returns Boolean
104475>        String sPath sSQLConnectionsIniName sDataPath sDriverID sServer sOrgOpenPath
104475>        Boolean bExists bEmbedded bIsSQLDriver bErr
104475>        Handle hoDbUpdateHandler hoSQLConnectionHandler hoSQLConnectionIniFile
104475>        tSQLConnection SQLConnection
104475>        tSQLConnection SQLConnection
104475>        Integer iRetval iDriverID
104475>
104475>        Move False to Err
104476>        Move (Trim(sFileList)) to sFileList
104477>        Get vFilePathExists sFileList to bExists
104478>        If (bExists = False) Begin
104480>            Send Info_Box "Can't find Filelist.cfg"
104481>            Function_Return False
104482>        End
104482>
104482>        Send Cursor_Wait of Cursor_Control
104483>        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
104484>        Get psServer   of ghoDbUpdateFunctionLibrary to sServer
104485>        Send Restore_DF_OPEN_PATH
104486>        Close DF_ALL DF_PERMANENT
104487>        Logout sDriverID sServer
104488>
104488>        Get ParseFolderName sFileList                      to sDataPath
104489>        If (Right(sDataPath, 1) = "\") Begin
104491>            Move (Left(sDataPath, (Length(sDataPath) -1))) to sDataPath
104492>        End
104492>        Set psDataPath of (phoWorkspace(Self))  to sDataPath
104493>        Set psFileList of (phoWorkspace(Self))  to sFileList
104494>
104494>        // Temporarily "redirect" the Open path to the current Data folder
104494>        Get psOrgOpenPath to sOrgOpenPath
104495>        Set_Attribute DF_OPEN_PATH to (sDataPath + ";" + sOrgOpenPath)
104498>        Set_Attribute DF_FILELIST_NAME to sFileList
104501>        Get UtilIsAnyFilelistEntrySQLtable of ghoDbUpdateFunctionLibrary to sDriverID
104502>        Get IsSQLDriver of ghoDbUpdateFunctionLibrary sDriverID to bIsSQLDriver
104503>        
104503>        // If none of the tables in the Filelist.cfg are SQL, we're done. Let's get out of here!
104503>        If (bIsSQLDriver = False) Begin
104505>            Send Cursor_Ready of Cursor_Control
104506>            Function_Return True
104507>        End
104507>
104507>        // Note: We delete all cache files (*.cch) before attempting to open any
104507>        // tables as a precausion, in case a table has been changed at the SQL back-end,
104507>        // because then the .cch file is out-of-sync with the SQL table.
104507>        Get DriverIndex of ghoDbUpdateFunctionLibrary sDriverID to iDriverID
104508>        Move Err to bErr 
104509>        Send Ignore_Error of Error_Object_Id DFERR_OPERATION_NOT_ALLOWED
104510>        Get_Attribute DF_DRIVER_CACHE_PATH of iDriverID to sPath
104513>        If (sPath = "") Begin 
104515>            If (LastErr = DFERR_OPERATION_NOT_ALLOWED and bErr = False) Begin
104517>                Move False to Err
104518>            End
104518>            Move sDataPath to sPath
104519>        End
104519>        Get vFolderFormat sPath to sPath
104520>        Get vDeleteFile (sPath + "*.cch") to iRetval
104521>
104521>        // Try to make a database connection by reading the SQLConnections.ini file:
104521>        Get vFolderFormat sDataPath to sPath
104522>        Get vParentPath sDataPath   to sPath
104523>        Get vFolderFormat sPath     to sPath
104524>        Move (sPath + "Programs")   to sPath
104525>        Get vFolderFormat sPath     to sPath
104526>        Move CS_SQLIniFileName to sSQLConnectionsIniName
104527>        Get vFilePathExists (sPath + sSQLConnectionsIniName) to bExists
104528>        If (bExists = False) Begin
104530>            Get UtilIsAllFilelistEntriesDataFlexTables of ghoDbUpdateFunctionLibrary to bEmbedded
104531>            If (bEmbedded = False) Begin
104533>                Send Cursor_Ready of Cursor_Control
104534>                Get YesNo_Box ("Couldn't find the DUF SQLConnections.ini file in the workspace Programs folder. Is there a DataFlex DFConnId.ini file in the Data folder that you want to open instead?") to iRetval
104535>                If (iRetval = MBR_Yes) Begin
104537>                    Send Cursor_Wait of Cursor_Control
104538>                    Move "DFConnId.ini" to sSQLConnectionsIniName
104539>                        Send UnRegisterAllConnections of ghoConnection
104540>                        Get AddAllConnections of ghoConnection to bExists
104541>                        Set psIniFileName of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) to sSQLConnectionsIniName
104542>                        Set psIniFilePath of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) to sPath
104543>                        Get SetupSQLConnection of ghoSQLConnectionHandler True False to SQLConnection
104544>                End
104544>            End
104544>        End
104544>        Else Begin
104545>            Get phoDbUpdateHandler to hoDbUpdateHandler
104546>            Get phoSQLConnectionHandler of hoDbUpdateHandler to hoSQLConnectionHandler
104547>            Get phoSQLConnectionIniFile of hoSQLConnectionHandler to hoSQLConnectionIniFile
104548>            Set psIniFilePath of hoSQLConnectionIniFile to sPath
104549>            Set psIniFileName of hoSQLConnectionIniFile to sSQLConnectionsIniName
104550>
104550>            Get SetupSQLConnection of hoSQLConnectionHandler True True to SQLConnection
104551>            Set pSQLConnection     of hoSQLConnectionHandler to SQLConnection
104552>        End
104552>
104552>        Send Cursor_Ready of Cursor_Control
104553>        Function_Return (Err = False)
104554>    End_Function
104555>
104555>    Object oConnection is a cConnection
104557>        Use LoginEncryption.pkg
Including file: LoginEncryption.pkg    (C:\Program Files\DataFlex 20.1\Pkg\LoginEncryption.pkg)
104557>>>Use cLoginEncryption.pkg
104557>>>
104557>>>Object oLoginEncryption is a cLoginEncryption
104559>>>
104559>>>    // this must be created in your appsrc directory and must contain an encryption
104559>>>    // key that is set to psEncryptPassword. It will look something like this
104559>>>    //
104559>>>    // Set psEncryptPassword to "JchUAo7W@r.b{<Yk~OONi0nq=sMi[*Rn[A-`Vo)q"
104559>>>    //  
Including file: LoginEncryptionKey.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\LoginEncryptionKey.inc)
104559>>>>// Studio generated login encryption key
104559>>>>Set psEncryptPassword to "%sLm*XHVF>f0yB.:.PHrBx6L)8x70i7zAN{q._WC"
104560>>>>
104560>>>    
104560>>>    // use this to register this object to your cConnection Object. This object
104560>>>    // must be created after the cConnection object
104560>>>    Move Self to ghoLoginEncryption
104561>>>End_Object
104562>        Use DatabaseLoginDialog.dg
Including file: DatabaseLoginDialog.dg    (C:\Program Files\DataFlex 20.1\Pkg\DatabaseLoginDialog.dg)
104562>>>
104562>>>Use Windows.pkg
104562>>>Use cConnection.pkg
104562>>>Use dfLine.pkg
104562>>>
104562>>>Object oDatabaseLoginDialog is a ModalPanel
104564>>>    Set Label to "Database Login"
104565>>>    Set Location to 2 2
104566>>>    Set Size to 110 211
104567>>>    
104567>>>    Property String psId
104569>>>    Property Boolean pbOk False
104571>>>    Property Boolean pbChanged False
104573>>>    Property Boolean pbAllowRemember True
104575>>>    
104575>>>    // this registers this object with the cConnection object.
104575>>>    Move Self to ghoLoginConnectDialog
104576>>>    
104576>>>    Object oUserIDForm is a Form
104578>>>        Set Label to "User Name"
104579>>>        Set Size to 12 85
104580>>>        Set Location to 34 79
104581>>>        Set Label_Col_Offset to 64
104582>>>        Set peAnchors to anTopLeftRight
104583>>>    End_Object
104584>>>    
104584>>>    Object oPwdForm is a Form
104586>>>        Set Size to 12 85
104587>>>        Set Location to 49 79
104588>>>        Set Label_Col_Offset to 64
104589>>>        Set Password_State to True
104590>>>        Set peAnchors to anTopLeftRight
104591>>>        Set Label to "Password"
104592>>>    End_Object
104593>>>    
104593>>>    Object oTrustedConnection is a CheckBox
104595>>>        Set Size to 10 50
104596>>>        Set Location to 65 79
104597>>>        Set Label to "Trusted Connection"
104598>>>    End_Object
104599>>>    
104599>>>    Object oRemember is a CheckBox
104601>>>        Set Size to 10 50
104602>>>        Set Location to 79 14
104603>>>        Set Label to "Remember and don't ask again"
104604>>>        Set Checked_State to True
104605>>>    End_Object
104606>>>    
104606>>>    Object oLogin_btn is a Button
104608>>>        Set Label to "&Login"
104609>>>        Set Location to 92 102
104610>>>        Set peAnchors to anBottomRight
104611>>>        Set Default_State to True
104612>>>        
104612>>>        Procedure OnClick
104615>>>            Boolean bTrust
104615>>>            String sUser sPwd sConn sErr sId
104615>>>            Integer iError
104615>>>            Get psId to sId
104616>>>            Get Value of oUserIDForm to sUser
104617>>>            Get Value of oPwdForm to sPwd
104618>>>            Get Checked_State of oTrustedConnection to bTrust
104619>>>            
104619>>>            Get LoginConnectIdNewCredentials of ghoConnection sId sUser sPwd bTrust to iError
104620>>>            If (iError=0) Begin
104622>>>                Set pbOk to True
104623>>>                Set pbChanged to True
104624>>>                Send Close_Panel
104625>>>            End
104625>>>>
104625>>>            Else Begin
104626>>>                Get psErrorText of ghoConnection to sErr
104627>>>                Send UserError sErr "Login Error"
104628>>>            End
104628>>>>
104628>>>        End_Procedure
104629>>>    End_Object
104630>>>    
104630>>>    Object oCancel_btn is a Button
104632>>>        Set Label to "&Cancel"
104633>>>        Set Location to 92 157
104634>>>        Set peAnchors to anBottomRight
104635>>>        
104635>>>        Procedure OnClick
104638>>>            Send Close_Panel
104639>>>        End_Procedure
104640>>>    End_Object
104641>>>    
104641>>>    Object oConnectionIdInfo is a TextBox
104643>>>        Set Size to 10 50
104644>>>        Set Location to 4 14
104645>>>        Set Label to 'Connection Id='
104646>>>    End_Object
104647>>>    
104647>>>    Object oConnectionServerInfo is a TextBox
104649>>>        Set Size to 10 50
104650>>>        Set Location to 16 14
104651>>>        Set Label to 'Server'
104652>>>    End_Object
104653>>>    
104653>>>    Object oLineControl1 is a LineControl
104655>>>        Set Size to 2 202
104656>>>        Set Location to 29 5
104657>>>    End_Object
104658>>>    
104658>>>    Function LoginConnectIdDialog String sId Returns Boolean
104661>>>        Boolean bOk bChanged bTrusted bAllowRemember bRemember
104661>>>        String sUser sPwd sDescription
104661>>>        tConnection Connect
104661>>>        tConnection Connect
104661>>>        
104661>>>        Get pbAllowRemember to bAllowRemember
104662>>>        
104662>>>        
104662>>>        If not bAllowRemember Begin
104664>>>            Set Enabled_State of oRemember to bRemember
104665>>>            Set Visible_State of oRemember to bRemember
104666>>>        End
104666>>>>
104666>>>        
104666>>>        Get ConnectionIdInfo of ghoConnection sId to Connect
104667>>>        Set Value of oConnectionIdInfo to ("Connection ID="+Connect.sId)
104668>>>        Set Value of oConnectionServerInfo to Connect.sString
104669>>>        
104669>>>        Set psId to sId
104670>>>        Set pbOk to False
104671>>>        Set pbChanged to False
104672>>>        Set Value of oUserIDForm to Connect.sUID
104673>>>        Set Value of oPwdForm to ""
104674>>>        
104674>>>        Send Popup
104675>>>        
104675>>>        Get pbOk to bOk
104676>>>        Get pbChanged to bChanged
104677>>>        If (bChanged and bOk) Begin
104679>>>            If bAllowRemember Begin
104681>>>                Get Checked_State of oRemember to bRemember
104682>>>                If bRemember Begin
104684>>>                    Get Checked_State of oTrustedConnection to bTrusted
104685>>>                    If not (bTrusted) Begin
104687>>>                        Get Value of oUserIDForm to sUser
104688>>>                        Get Value of oPwdForm to sPwd
104689>>>                    End
104689>>>>
104689>>>                    Get StoreConnectionIdCredentials of ghoConnection sId sUser sPwd bTrusted to bOk
104690>>>                End
104690>>>>
104690>>>            End
104690>>>>
104690>>>        End
104690>>>>
104690>>>        Function_Return bOk
104691>>>    End_Function
104692>>>    
104692>>>    
104692>>>    On_Key Key_Alt+Key_O Send KeyAction of oLogin_btn
104693>>>    On_Key Key_Alt+Key_L Send KeyAction of oCancel_btn
104694>>>End_Object
104695>>>
104695>    End_Object
104696>
104696>End_Object
104697>
104697>Object oDbUpdateHandler is a cDbUpdateHandler
104699>    Set piDbVersionFileNumber  to 1
104700>    Set piDbVersionFieldNumber to 1
104701>    Set phoDbUpdateHandler of ghoApplication to Self
104702>
104702>    Procedure OnPreUpdate
104705>        String sVersionInfo                     // DF 18.2 MSSQLDRV
104705>//        Get MinMSSQLDRV_And_ClientVersion "6.1.0.32"  SQLSERVER2012CLIENT True True to sVersionInfo
104705>                                                // DF 19.1 MSSQLDRV
104705>        Get MinMSSQLDRV_And_ClientVersion "6.3.0.13" SQLSERVER2016CLIENT True True to sVersionInfo
104706>    End_Procedure  
104707>
104707>    Object oDbUpdateVersion1_0 is a cDbUpdateVersion
104709>        Set pnVersionNumber to 1.0
104710>//        Procedure OnUpdate
104710>//            Boolean bOK 
104710>//        End_Procedure
104710>    End_Object
104711>
104711>End_Object
104712>
104712>Object oToolTipController is a cToolTipController
104714>    Move Self to ghoToolTipController
104715>    Set pbBalloonStyle to False
104716>    Set piIcon to TTI_INFO
104717>    Set psTitle to "Information"
104718>    Set piMaxWidth to 400
104719>    Set piDurationPopup to 14000    // 14 seconds, needed for long tooltips.
104720>End_Object
104721>
104721>Use oEditContextMenu.pkg
Including file: oEditContextMenu.pkg    (C:\Program Files\DataFlex 20.1\Pkg\oEditContextMenu.pkg)
104721>>>Use cCJStandardMenuItemClasses.pkg
104721>>>
104721>>>Object oEditContextMenu is a cCJContextMenu
104723>>>    
104723>>>    Move Self to Default_Form_Floating_Menu_ID
104724>>>    
104724>>>    Object oUndoMenuItem is a cCJUndoMenuItem
104726>>>    End_Object
104727>>>    
104727>>>    Object oCutMenuItem is a cCJCutMenuItem
104729>>>        Set pbControlBeginGroup to True
104730>>>    End_Object
104731>>>    
104731>>>    Object oCopyMenuItem is a cCJCopyMenuItem
104733>>>    End_Object
104734>>>
104734>>>    Object oPasteMenuItem is a cCJPasteMenuItem
104736>>>    End_Object
104737>>>
104737>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
104739>>>    End_Object
104740>>>
104740>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
104742>>>        Set pbControlBeginGroup to True
104743>>>    End_Object
104744>>>
104744>>>End_Object
104745>>>
104745>Use oDEOEditContextMenu17.pkg
Including file: oDEOEditContextMenu17.pkg    (C:\Program Files\DataFlex 20.1\Pkg\oDEOEditContextMenu17.pkg)
104745>>>Use Windows.pkg
104745>>>Use cCJStandardMenuItemClasses.pkg
104745>>>Use cCJDeoMenuItemClasses.pkg
104745>>>
104745>>>
104745>>>Object oDEOEditContextMenu17 is a cCJContextMenu
104747>>>    
104747>>>    Move Self to Default_dbFloating_Menu_ID
104748>>>    
104748>>>    Object oUndoMenuItem is a cCJUndoMenuItem
104750>>>    End_Object
104751>>>    
104751>>>    Object oCutMenuItem is a cCJCutMenuItem
104753>>>        Set pbControlBeginGroup to True
104754>>>    End_Object
104755>>>    
104755>>>    Object oCopyMenuItem is a cCJCopyMenuItem
104757>>>    End_Object
104758>>>
104758>>>    Object oPasteMenuItem is a cCJPasteMenuItem
104760>>>    End_Object
104761>>>
104761>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
104763>>>    End_Object
104764>>>
104764>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
104766>>>        Set pbControlBeginGroup to True
104767>>>    End_Object
104768>>>
104768>>>    Object oPromptMenuItem is a cCJPromptMenuItem
104770>>>        Set pbControlBeginGroup to True
104771>>>    End_Object
104772>>>
104772>>>    Object oFindNextMenu is a cCJFindNextMenuItem
104774>>>        Set pbControlBeginGroup to True
104775>>>    End_Object
104776>>>
104776>>>    Object oFindPreviousMenu is a cCJFindPreviousMenuItem
104778>>>    End_Object
104779>>>
104779>>>    Object oClearMenuItem is a cCJClearMenuItem
104781>>>        Set pbControlBeginGroup to True
104782>>>    End_Object
104783>>>
104783>>>    Object oClearAllMenu is a cCJClearAllMenuItem
104785>>>    End_Object
104786>>>
104786>>>    Object oSaveMenu is a cCJSaveMenuItem
104788>>>    End_Object
104789>>>    
104789>>>    Object oDeleteMenu is a cCJDeleteMenuItem
104791>>>    End_Object
104792>>>
104792>>>    Object oRememberitem is a cCJRememberFieldMenuItem
104794>>>        Set pbControlBeginGroup to True
104795>>>    End_Object
104796>>>
104796>>>    Object oRetainItem is a cCJRememberLastFieldMenuItem
104798>>>    End_Object
104799>>>
104799>>>    Object oUnRememberitem is a cCJUnRememberFieldMenuItem
104801>>>    End_Object
104802>>>
104802>>>    Object oCJClearAllDynamicDefaults is a cCJUnRememberFieldAllMenuItem
104804>>>    End_Object
104805>>>
104805>>>End_Object
104806>Use CaptureWindow.pkg
Including file: CaptureWindow.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\CaptureWindow.pkg)
104806>>>Use CaptureWindow.h
Including file: CaptureWindow.h    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\CaptureWindow.h)
104806>>>>>Define C_CaptureFolderKey  for "CaptureFolder"
104806>>>>>Define C_CaptureFolderName for "Capture"
104806>>>>>Define SRCCOPY           for |CI$00CC0020
104806>>>>>Define CF_BITMAP         for |CI2
104806>>>>>
104806>>>>>Enum_List   //Enum DEVCAP_INDEX As Integer  
104806>>>>>   Define DRIVERVERSION for 0 
104806>>>>>   Define TECHNOLOGY for 2 
104806>>>>>   Define HORZSIZE for 4 
104806>>>>>   Define VERTSIZE for 6 
104806>>>>>   Define HORZRES for 8 
104806>>>>>   Define VERTRES for 10 
104806>>>>>   Define BITSPIXEL for 12 
104806>>>>>   Define PLANES for 14 
104806>>>>>   Define NUMBRUSHES for 16 
104806>>>>>   Define NUMPENS for 18 
104806>>>>>   Define NUMMARKERS for 20 
104806>>>>>   Define NUMFONTS for 22 
104806>>>>>   Define NUMCOLORS for 24 
104806>>>>>   Define PDEVICESIZE for 26 
104806>>>>>   Define CURVECAPS for 28 
104806>>>>>   Define LINECAPS for 30 
104806>>>>>   Define POLYGONALCAPS for 32 
104806>>>>>   Define TEXTCAPS for 34 
104806>>>>>   Define CLIPCAPS for 36 
104806>>>>>   Define RASTERCAPS for 38 
104806>>>>>   Define ASPECTX for 40 
104806>>>>>   Define ASPECTY for 42 
104806>>>>>   Define ASPECTXY for 44 
104806>>>>>   Define SHADEBLENDCAPS for 45 
104806>>>>>   Define SIZEPALETTE for 104 
104806>>>>>   Define NUMRESERVED for 106 
104806>>>>>   Define COLORRES for 108 
104806>>>>>   Define PHYSICALWIDTH for 110 
104806>>>>>   Define PHYSICALHEIGHT for 111 
104806>>>>>   Define PHYSICALOFFSETX for 112 
104806>>>>>   Define PHYSICALOFFSETY for 113 
104806>>>>>   Define SCALINGFACTORX for 114 
104806>>>>>   Define SCALINGFACTORY for 115 
104806>>>>>   Define VREFRESH for 116 
104806>>>>>   Define DESKTOPVERTRES for 117 
104806>>>>>   Define DESKTOPHORZRES for 118 
104806>>>>>   Define BLTALIGNMENT for 119 
104806>>>>>End_Enum_List  
104806>>>>>
104806>>>>>Enum_List   //Enum compression
104806>>>>>   Define bi_rgb for 0       //- none (also identified by bi_rgb)
104806>>>>>   Define bi_rle4 for 1      //- rle 8-bit / pixel (also identified by bi_rle4)
104806>>>>>   Define bi_rle8 for 2      //- rle 4-bit / pixel (also identified by bi_rle8)
104806>>>>>   Define bi_bitfields for 3 //- bitfields (also identified by bi_bitfields)
104806>>>>>End_Enum_List  
104806>>>>>
104806>>>>>
104806>>>>>
104806>>>>>Define DIB_PAL_COLORS for 1
104806>>>>>Define DIB_RGB_COLORS for 0
104806>>>>>
104806>>>>>Struct RECT_TYPE
104806>>>>>   Integer ileft
104806>>>>>   Integer itop
104806>>>>>   Integer iright
104806>>>>>   Integer ibottom
104806>>>>>End_Struct
104806>>>>>
104806>>>>>Struct BITMAPINFOHEADER
104806>>>>>  DWORD biSize                    // DWORD=integer
104806>>>>>  Integer biWidth                    // LONG =integer
104806>>>>>  Integer biHeight                   // LONG 
104806>>>>>  short biPlanes                   // WORD =short
104806>>>>>  short biBitCount                 // WORD 
104806>>>>>  DWORD biCompression             // DWORD
104806>>>>>  DWORD biSizeImage               // DWORD
104806>>>>>  Integer biXPelsPerMeter            // LONG 
104806>>>>>  Integer biYPelsPerMeter            // LONG 
104806>>>>>  DWORD biClrUsed                 // DWORD
104806>>>>>  DWORD biClrImportant            // DWORD
104806>>>>>end_struct
104806>>>>>
104806>>>>>struct RGBQUAD
104806>>>>>  CHAR rgbBlue            //BYTE=CHAR
104806>>>>>  CHAR rgbGreen
104806>>>>>  CHAR rgbRed
104806>>>>>  CHAR rgbReserved
104806>>>>>end_struct
104806>>>>>
104806>>>>>struct BITMAPINFO 
104806>>>>>  BITMAPINFOHEADER bmiHeader 
104806>>>>>  BITMAPINFOHEADER bmiHeader 
104806>>>>>  RGBQUAD[] bmiColors
104806>>>>>  RGBQUAD[] bmiColors
104806>>>>>end_struct
104806>>>>>
104806>>>>>struct BITMAPFILEHEADER
104806>>>>>  Short bfType         //WORD  //BM (0x4D42)
104806>>>>>  DWord bfSize        //DWORD
104806>>>>>  Short bfReserved1    //WORD 
104806>>>>>  Short bfReserved2    //WORD 
104806>>>>>  DWord bfOffBits     //DWORD
104806>>>>>end_struct
104806>>>>>
104806>>>>>Struct BITMAP 
104806>>>>>  Integer   bmType
104806>>>>>  Integer   bmWidth
104806>>>>>  Integer   bmHeight
104806>>>>>  Integer   bmWidthBytes
104806>>>>>  Short   bmPlanes
104806>>>>>  Short   bmBitsPixel
104806>>>>>  Pointer bmBits
104806>>>>>end_struct
104806>>>>>
104806>>>>>Struct DIBSECTION 
104806>>>>>  BITMAP           dsBm
104806>>>>>  BITMAP           dsBm
104806>>>>>  BITMAPINFOHEADER dsBmih
104806>>>>>  BITMAPINFOHEADER dsBmih
104806>>>>>  DWord[3]         dsBitfields
104806>>>>>  Handle           dshSection
104806>>>>>  DWord            dsOffset
104806>>>>>end_struct
104806>>>Use vWin32fh.pkg
104806>>>Use cApplication.pkg
104806>>>Use cIniFile.pkg
104806>>>
104806>>>Define CS_CaptureSection for "Capture"
104806>>>Define CS_CaptureFolder  for "Capture Folder"
104806>>>
104806>>>//   Declare Function GetActiveWindow% Lib "User" ()
104806>>>External_Function GetActiveWindow "GetActiveWindow" User32.dll ;    Returns Handle
104807>>>
104807>>>//   Declare Function GetDesktopWindow% Lib "User" ()
104807>>>
104807>>>//   Declare Sub GetWindowRect Lib "User" (ByVal Hwnd%, lpRect As RECT_Type)
104807>>>
104807>>>//   Declare Function GetDC% Lib "User" (ByVal Hwnd%)
104807>>>
104807>>>//   Declare Function CreateCompatibleDC% Lib "GDI" (ByVal hdc%)
104807>>>
104807>>>//   Declare Function CreateCompatibleBitmap% Lib "GDI" (ByVal hdc%, ByVal nWidth%, ByVal nHeight%)
104807>>>
104807>>>//   Declare Function SelectObject% Lib "GDI" (ByVal hdc%, ByVal hObject%)
104807>>>
104807>>>//   Declare Function BitBlt% Lib "GDI" (ByVal hDestDC%, ByVal X%, ByVal Y%, ByVal nWidth%, ;
104807>>>//                     ByVal nHeight%, ByVal hSrcDC%, ByVal XSrc%, ByVal YSrc%, ByVal dwRop&)
104807>>>
104807>>>//   Declare Function OpenClipboard% Lib "User" (ByVal Hwnd%)
104807>>>External_Function OpenClipboard "OpenClipboard" User32.dll  ;    Handle hWnd  Returns Integer
104808>>>
104808>>>//   Declare Function EmptyClipboard% Lib "User" ()
104808>>>External_Function EmptyClipboard "EmptyClipboard" User32.dll ;    Returns Integer
104809>>>
104809>>>//   Declare Function SetClipboardData% Lib "User" (ByVal wFormat%, ByVal hMem%)
104809>>>External_Function SetClipboardData "SetClipboardData" User32.dll ;    Integer wFormat Handle hMem Returns Integer
104810>>>
104810>>>//   Declare Function CloseClipboard% Lib "User" ()
104810>>>External_Function CloseClipboard "CloseClipboard" User32.dll ;    Returns Integer
104811>>>
104811>>>//   Declare Function ReleaseDC% Lib "User" (ByVal Hwnd%, ByVal hdc%)
104811>>>
104811>>>//   Declare Function DeleteDC% Lib "GDI" (ByVal hdc%)
104811>>>
104811>>>    External_Function CreateDIBSection "CreateDIBSection" Gdi32.dll ;        Handle hdc ;     // Handle to the device context        pointer pbmi ; //puntero a BITMAPINFO        UInteger iUsage ;        Pointer ppvBits ;        Handle hSection ;        DWord dwOffset ;        Returns Handle // HBITMAP
104812>>>
104812>>>    External_Function GetDIBits "GetDIBits" Gdi32.dll ;        handle hdc ;        handle hbmp ;        Uinteger uStartScan ;        uinteger cScanLines ;        pointer lpvBits ;        pointer lpbi ;  // LPBITMAPINFO        uinteger uUsage ;        Returns Integer
104813>>>
104813>>>External_Function Createfile "CreateFileA" kernel32.dll ;    Pointer lpFile ;      //filename    DWord dwDesAccess ;   // access mode    DWord dwShare ;       // share mode    Pointer lpSecAtt ;    // SD    DWord dwCrDisp ;      // how to create    DWord dwFlags ;       // file attributes    Handle hTempFile ;   // handle to template fil    Returns Integer      //Returns handle that can be used to access the object
104814>>>
104814>>>    External_Function WriteFile "WriteFile" Kernel32.dll ;        Handle hFile ;     // Handle to the file        Pointer lpBuffer ;  // data buffer        DWord nNumberOfBytesToWrite ;        Pointer lpNumberOfBytesWritten ;        Pointer lpOverlapped ;        Returns Boolean
104815>>>
104815>>>External_Function CloseHandle "CloseHandle" kernel32.dll ;    Handle hObject ;        // handle to object    Returns Integer
104816>>>
104816>>>
104816>>>     External_Function GetDIBColorTable "GetDIBColorTable" Gdi32.dll ;        handle hdc ;        uinteger uStartIndex ;        uinteger cEntries ;        pointer pColors ;        Returns Integer
104817>>>
104817>>>     External_Function GetObject "GetObjectA" Gdi32.dll ;        handle hgdiobj ;        integer cbBuffer ;        pointer lpvObject ;        Returns Integer
104818>>>
104818>>>
104818>>>// Check if focus is what you search or a child of it
104818>>>Function Find_Parent Global Handle hofocus Handle hofind Returns Boolean
104820>>>    If (hoFocus = hoFind) Begin
104822>>>        Function_Return True
104823>>>    End
104823>>>>
104823>>>   While (hofocus>Desktop)
104827>>>        If (Parent(hoFocus) = hoFind) Begin
104829>>>            Function_Return True
104830>>>        End
104830>>>>
104830>>>      Move (Parent(hofocus)) to hofocus
104831>>>   Loop
104832>>>>
104832>>>   Function_Return False
104833>>>End_Function
104834>>>
104834>>>// Returns the view object (outmost container) of the currently focused object.
104834>>>Function Current_View Global Returns Integer
104836>>>    Integer Obj#
104836>>>
104836>>>    Move (Focus(Self)) to Obj#
104837>>>    Repeat
104837>>>>
104837>>>        Move (Parent(Obj#)) to Obj#
104838>>>    Until (Scope_State(Obj#) = True)
104840>>>
104840>>>    Function_Return Obj#
104841>>>End_Function
104842>>>
104842>>>// Helper function. See also main message TakeSnapshot.
104842>>>// Capture an bitmap image of the current object and saves it to disk.
104842>>>Function CaptureImage Global Handle hVent String sFile Returns Integer
104844>>>    Handle hwnd deskhwnd hfile hnulo
104844>>>    Handle hdcScreen
104844>>>    Handle hdcWindow
104844>>>    Handle hdcMemDC
104844>>>    Handle hbmScreen
104844>>>    BITMAP bmpScreen
104844>>>    BITMAP bmpScreen
104844>>>    BITMAPFILEHEADER   bmfHeader
104844>>>    BITMAPFILEHEADER   bmfHeader
104844>>>    BITMAPINFOHEADER   bi
104844>>>    BITMAPINFOHEADER   bi
104844>>>    RECT_Type rcClient
104844>>>    RECT_Type rcClient
104844>>>    Integer junk fwidth fheight iret
104844>>>    DWord dwSizeofDIB dwBytesWritten dwBmpSize
104844>>>    Boolean baux
104844>>>    Pointer lpbitmap pnulo
104844>>>
104844>>>    //---------------------------------------------------
104844>>>    // Get window handle to Windows and our View
104844>>>    //---------------------------------------------------
104844>>>    Move (GetDesktopWindow()) to DeskHwnd
104845>>>    Get Window_Handle of hVent to hwnd
104846>>>
104846>>>    // Retrieve the handle to a display device context for the client
104846>>>    // area of the window.
104846>>>    Move (GetDC(hwnd)) to hdcScreen //what you want to paint (getdc(null)=full screen)
104847>>>    Move (GetDC(deskhwnd)) to hdcWindow //context = GetDC(hWnd);
104848>>>
104848>>>    // Create a compatible DC which is used in a BitBlt from the window DC
104848>>>    Move (CreateCompatibleDC(hdcWindow)) to hdcMemDC
104849>>>    Move 0 to iret
104850>>>    If (hdcMemDC) Begin
104852>>>       // Get the client area for size calculation
104852>>>       Move (GetWindowRect(hwnd,AddressOf(rcClient))) to junk
104853>>>       Move (rcClient.iright-rcClient.ileft) to fwidth
104854>>>       Move (rcClient.ibottom-rcClient.itop) to fheight
104855>>>
104855>>>       // Create a compatible bitmap from the Window DC
104855>>>       Move (CreateCompatibleBitmap(hdcWindow, fwidth, fheight)) to hbmScreen
104856>>>
104856>>>       If hbmScreen Begin
104858>>>          // Select the compatible bitmap into the compatible memory DC.
104858>>>          Move (SelectObject(hdcMemDC,hbmScreen)) to junk
104859>>>
104859>>>          // Bit block transfer into our compatible memory DC.
104859>>>          If (BitBlt(hdcMemDC,0,0, fwidth, fheight,hdcWindow, rcClient.ileft,rcClient.itop,SRCCOPY)) Begin
104861>>>             // Get the BITMAP from the HBITMAP
104861>>>             Move (GetObject(hbmScreen,SizeOfType(BITMAP),AddressOf(bmpScreen))) to junk
104862>>>             Move (SizeOfType(BITMAPINFOHEADER)) to bi.biSize
104863>>>             Move bmpScreen.bmWidth to bi.biWidth
104864>>>             Move bmpScreen.bmHeight to bi.biHeight
104865>>>             Move 1 to bi.biPlanes
104866>>>             Move 32 to bi.biBitCount
104867>>>             Move bi_rgb to bi.biCompression
104868>>>             Move 0 to bi.biSizeImage
104869>>>             Move 0 to bi.biXPelsPerMeter
104870>>>             Move 0 to bi.biYPelsPerMeter
104871>>>             Move 0 to bi.biClrUsed
104872>>>             Move 0 to bi.biClrImportant
104873>>>
104873>>>             Move (((bmpScreen.bmWidth * bi.biBitCount + 31) / 32) * 4 * bmpScreen.bmHeight ) to dwBmpSize
104874>>>             Move (Alloc(dwBmpSize+100)) to lpbitmap
104875>>>
104875>>>             // Gets the "bits" from the bitmap and copies them into a buffer
104875>>>             // which is pointed to by lpbitmap.
104875>>>             Move (GetDIBits(hdcWindow, hbmScreen, 0,bmpScreen.bmHeight, ;                 lpbitmap,AddressOf(bi), DIB_RGB_COLORS) ) to junk
104876>>>
104876>>>             // A file is created, this is where we will save the screen capture.
104876>>>             Move (CreateFile(AddressOf(sFile),GENERIC_WRITE, 0, ;                 hnulo,CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL, hnulo)) to hfile
104877>>>
104877>>>             // Add the size of the headers to the size of the bitmap to get the total file size
104877>>>             Move (dwBmpSize + SizeOfType(BITMAPFILEHEADER) + SizeOfType(BITMAPINFOHEADER)) to dwSizeofDIB
104878>>>
104878>>>             // Offset to where the actual bitmap bits start.
104878>>>             Move (SizeOfType(BITMAPFILEHEADER) + SizeOfType(BITMAPINFOHEADER)) to bmfHeader.bfOffBits
104879>>>
104879>>>             // Size of the file
104879>>>             Move dwSizeofDIB to bmfHeader.bfSize
104880>>>
104880>>>             // bfType must always be BM for Bitmaps
104880>>>             Move 19778 to bmfHeader.bfType //= 0x4D42; //BM   19778
104881>>>
104881>>>             Move 0 to dwBytesWritten
104882>>>             Move (WriteFile(hFile, AddressOf(bmfHeader), SizeOfType(BITMAPFILEHEADER), AddressOf(dwBytesWritten), pnulo)) to baux
104883>>>             Move (WriteFile(hFile, AddressOf(bi), SizeOfType(BITMAPINFOHEADER), AddressOf(dwBytesWritten), pnulo)) to baux
104884>>>             Move (WriteFile(hFile, lpbitmap, dwBmpSize, AddressOf(dwBytesWritten), pnulo))  to baux
104885>>>
104885>>>             //Close the handle for the file that was created
104885>>>             Move (CloseHandle(hFile)) to junk
104886>>>
104886>>>             // Write image from clipboard
104886>>>             Move (OpenClipboard(DeskHwnd)) to junk
104887>>>             Move (EmptyClipboard()) to junk
104888>>>             Move (SetClipboardData(CF_BITMAP,hbmScreen)) to junk
104889>>>             Move (CloseClipboard()) to junk
104890>>>
104890>>>             Move (DeleteObject(hbmScreen)) to baux
104891>>>             Move (Free(lpbitmap)) to baux
104892>>>             Move 1 to iret
104893>>>          End
104893>>>>
104893>>>       End
104893>>>>
104893>>>    End
104893>>>>
104893>>>    Move (ReleaseDC(hWnd, hdcMemDC)) to junk
104894>>>    Move (ReleaseDC(hwnd,hdcScreen)) to junk
104895>>>    Move (ReleaseDC(deskhwnd,hdcWindow)) to junk
104896>>>
104896>>>    Function_Return iret
104897>>>End_Function
104898>>>
104898>>>// *** MAIN MESSAGE ***
104898>>>// Takes a snapshot of the currently active view and saves it as a bitmap file,
104898>>>// in the current workspace's Capture folder. If that folder doesn't exist,
104898>>>// it will be created.
104898>>>// Pass False to take snapshot of the currently active view, or pass True
104898>>>// to take snapshot of the entire application.
104898>>>Procedure TakeSnapshot Global Boolean bApplicationShot
104900>>>    Integer iRetval
104900>>>    String sPath sToday sFileName
104900>>>    Handle hObjTo
104900>>>
104900>>>    Sysdate sToday
104901>>>    Move (Replace("/", sToday, "-")) to sToday
104902>>>
104902>>>    // Select the view to capture
104902>>>    If (bApplicationShot = False) Begin
104904>>>        Get Current_View to hObjTo
104905>>>    End
104905>>>>
104905>>>    Else Begin
104906>>>        Move (Parent(ghoCommandBars)) to hObjTo
104907>>>    End
104907>>>>
104907>>>
104907>>>    Get SnapShotFolder to sPath
104908>>>    Get vFolderFormat sPath to sPath
104909>>>
104909>>>    Move (sPath + (Object_Label(hObjTo)) + sToday + ".bmp") to sFileName
104910>>>    Get CaptureImage hObjTo sFileName to iRetval
104911>>>    If (iRetval <> 0) Begin
104913>>>//        Send Info_Box ("The snapshot image was saved here:\n" + sPath)
104913>>>        Move ("/select, " + sFileName) to sFileName
104914>>>        Send vShellExecute "open" "explorer.exe" sFileName ""
104915>>>//        Runprogram Shell Background sFileName
104915>>>    End
104915>>>>
104915>>>End_Procedure
104916>>>
104916>>>// Function to get the folder where snapshots are saved.
104916>>>// The pathing is read from the esqtid.ini file.
104916>>>// Returns the full folder path. If the folder doesn't exist
104916>>>// it will be created.
104916>>>// Returns: The full snapshot folder path.
104916>>>Function SnapShotFolder Global Returns String
104918>>>    String sHome sPath sWorkSpaceFile
104918>>>    Boolean bExist
104918>>>    Integer iRetval
104918>>>    Handle hoIniFile
104918>>>
104918>>>    Get psWorkspaceWSFile of (phoWorkspace(ghoApplication)) to sWorkSpaceFile
104919>>>    Get psHome of (phoWorkspace(ghoApplication)) to sHome
104920>>>    Get vFolderFormat sHome to sHome
104921>>>
104921>>>    Get Create (RefClass(cIniFile)) to hoIniFile
104922>>>    Set psFileName of hoIniFile to sWorkSpaceFile
104923>>>    Get ReadString of hoIniFile CS_CaptureSection CS_CaptureFolder CS_CaptureSection to sPath
104924>>>    Send Destroy of hoIniFile
104925>>>
104925>>>    If (Pos("..\", sPath)) Begin
104927>>>        Move (Replace("..\", sPath, "")) to sPath
104928>>>        Move (sHome + sPath) to sPath
104929>>>    End
104929>>>>
104929>>>    Else If (Pos(".\", sPath)) Begin
104932>>>        Move (Replace(".\", sPath, "")) to sPath
104933>>>        Move (sHome + sPath) to sPath
104934>>>    End
104934>>>>
104934>>>    Else Begin
104935>>>        Move (sHome + sPath) to sPath
104936>>>    End
104936>>>>
104936>>>
104936>>>    Get vFolderExists sPath to bExist
104937>>>    If (bExist = False) Begin
104939>>>        If (sPath = "") Begin
104941>>>            Get vSHGetFolderPath vCSIDL_MYPICTURES to sPath  // E.g. "C:\Documents and Settings\username\My Documents\My Pictures"
104942>>>        End
104942>>>>
104942>>>        Else Begin
104943>>>            Get vCreateDirectory sPath to iRetval
104944>>>            If (iRetval <> 0) Begin
104946>>>                Send Info_Box ("Could not create the 'Capture' folder for saving shapshots to." * sPath)
104947>>>                Function_Return ""
104948>>>            End
104948>>>>
104948>>>        End
104948>>>>
104948>>>    End
104948>>>>
104948>>>
104948>>>    Function_Return sPath
104949>>>End_Function
104950>
104950>Object oMain is a Panel
104952>    Set Label to (psProduct(ghoApplication))
104953>    Set Location to 4 3
104954>    Set Size to 350 602
104955>    Set piMinSize to 400 515
104956>    Set Icon to "DUFUpdateCodeGenerator1.ico"
104957>
104957>    Object oCommandBarSystem is a cCJCommandBarSystem
104959>        Set pbTimerUpdate to True
104960>            Set pbAutoResizeIcons to True
104961>            Set pbTabbedWorkspaces to True
104962>//            Set pbLargeIcons to True
104962>            Set peVisualTheme to xtpThemeOffice2013Publisher
104963>        Set pbLargeIcons to True
104964>
104964>        Procedure OnCreateCommandBars
104967>            Integer eTheme
104967>            Forward Send OnCreateCommandBars
104969>
104969>            Get ReadDword of ghoApplication CS_PropertiesKeyWord CS_ThemeKeyWord xtpThemeOffice2013Publisher to eTheme
104970>            Send SetTheTheme eTheme
104971>            Send DisplayTabWorkspace
104972>        End_Procedure
104973>
104973>        Procedure DisplayTabWorkspace
104976>            Variant vTab vPaintManager
104976>            Handle hoTab hoPaintManager hoOptions
104976>            Integer iSize
104976>
104976>            If (not(IsComObjectCreated(Self))) Begin
104978>                Procedure_Return
104979>            End
104979>
104979>            Get OptionsObject to hoOptions
104980>
104980>            // Create the tab workspace object. It will get created for the Client_Area so
104980>            // each view will be displayd on a separate tab-page (instead of the standard VDF MDI-interface)
104980>            Get Create (RefClass(cCJTabWorkspace)) to hoTab
104981>            Get ComShowTabWorkspace True to vTab
104982>            // Connect the CodeJock side to the DataFlex proxy object.
104982>            Set pvComObject  of hoTab to vTab
104983>
104983>            // We don't allow to close tabs as we have no menu system.
104983>            Set ComFlags of hoTab to xtpWorkspaceHideAll //xtpWorkspaceHideClose //xtpWorkspaceShowCloseTab
104984>            Send ComEnableGroups of hoTab
104985>
104985>            // Create a paint manager object that is needed to set some
104985>            // of the tab-workspace properties.
104985>            Get Create (RefClass(cCJTabPaintManager)) to hoPaintManager
104986>            Get ComPaintManager of hoTab          to vPaintManager
104987>            Set pvComObject     of hoPaintManager to vPaintManager
104988>
104988>            // Sets the tab-pages to display on the left side, instead of at the top:
104988>            Set ComPosition     of hoPaintManager to xtpTabPositionLeft
104989>
104989>            // This will truncate the middle part of long items
104989>            Set ComDrawTextPathEllipsis of hoPaintManager to True
104990>            Set ComLayout               of hoPaintManager to xtpTabLayoutMultiRow
104991>
104991>//            #IF (!@ < 190)
104991>                Move 32 to iSize
104992>                Send ComSetIconSize     of hoOptions False iSize iSize  // Set icon size for Toolbar buttons.
104993>//                Move 24 to iSize
104993>//                Send ComSetIconSize     of hoPaintManager  iSize iSize  // Set icon size for Tab-workspace.
104993>//            #ENDIF
104993>            Get Create (RefClass(cCJPaintManager)) to hoPaintManager
104994>            Get ComPaintManager of hoPaintManager  to vPaintManager
104995>            Set pvComObject     of hoPaintManager  to vPaintManager
104996>            Set ComAutoResizeIcons of hoPaintManager to True
104997>            Send Destroy of hoPaintManager
104998>            Send ComRecalcLayout
104999>            Send Destroy of hoTab
105000>        End_Procedure
105001>
105001>        Procedure OnCreateTabbedWorkspace Handle hoTabWorkspace Handle hoTabPaintManager
105004>//            Set ComShowIcons of hoTabPaintManager to True
105004>//            Send ComSetIconSize of hoTabPaintManager 24 24
105004>
105004>            // This will truncate the middle part of long text items
105004>            Set ComDrawTextPathEllipsis of hoTabPaintManager to True
105005>            Set ComFlags of hoTabWorkspace to xtpWorkspaceHideAll //xtpWorkspaceHideClose //xtpWorkspaceShowCloseTab
105006>        End_Procedure
105007>
105007>        Procedure SetTheTheme Integer eTheme
105010>            Integer iColor
105010>            Set peVisualTheme of ghoCommandBars to eTheme
105011>            Send ComRecalcLayout of ghoCommandBars
105012>            Get ComGetSpecialColor of ghoCommandBars XPCOLOR_TOOLBAR_FACE to iColor
105013>            Broadcast Recursive Set Color of (Client_Id(phoMainPanel(ghoApplication))) to iColor
105015>        End_Procedure
105016>
105016>        Object oActions_Toolbar is a cCJToolbar
105018>            Set pbCloseable to False
105019>            Set pbCustomizable to False
105020>            Set pbShowExpandButton to False
105021>            Set psTitle to "Actions"
105022>
105022>            Object oCodeGenerator_MenuItem is a cCJMenuItem
105024>                Set psCaption to "Code &Generator"
105025>                Set psImage to "SqlScript1.ico"
105026>                Set peControlStyle to xtpButtonIconAndCaption
105027>                Procedure OnExecute Variant vCommandBarControl
105030>                    Forward Send OnExecute vCommandBarControl
105032>                    Set pbChecked to True
105033>                    Set pbChecked of (oCompareDatabases_MenuItem(ghoCommandBars)) to False
105034>                    Send Activate_oTableDUFCodeGenerator of (Client_Id(phoMainPanel(ghoApplication)))
105035>                End_Procedure
105036>            End_Object
105037>
105037>            Object oCompareDatabases_MenuItem is a cCJMenuItem
105039>                Set psCaption to "Compare &Databases"
105040>                Set psImage to "DbCompare1.ico"
105041>                Set peControlStyle to xtpButtonIconAndCaption
105042>                Set pbChecked to True
105043>
105043>                Procedure OnExecute Variant vCommandBarControl  
105046>                    Forward Send OnExecute vCommandBarControl
105048>                    Set pbChecked to True
105049>                    Set pbChecked of (oCodeGenerator_MenuItem(ghoCommandBars)) to False
105050>                    Send Activate_oCompareDatabases_vw of (Client_Id(phoMainPanel(ghoApplication)))
105051>                End_Procedure
105052>            End_Object
105053>
105053>        End_Object
105054>
105054>        // This is needed to get the "Key_Shift+Key_Tab" key combination to activate
105054>        // the previous tab workspace view.
105054>
105054>        Object oEditToolBar is a cCJToolbar
105056>            Set psTitle to "Edit Toolbar"
105057>            Set pbCloseable to False
105058>            Set pbCustomizable to False
105059>            Set pbShowExpandButton to False
105060>
105060>            Object oCutToolbarItem is a cCJCutMenuItem
105062>                Set psImage to "ActionCut1.ico"
105063>            End_Object
105064>
105064>            Object oCopyToolbarItem is a cCJCopyMenuItem
105066>                Set psImage to "ActionCopy1.ico"
105067>
105067>            End_Object
105068>
105068>            Object oPasteToolbarItem is a cCJPasteMenuItem
105070>                Set psImage to "ActionPaste1.ico"
105071>            End_Object
105072>
105072>//            Object oDeleteEditToolbarItem is a cCJDeleteEditMenuItem
105072>//                Set psImage to "ActionDelete1.ico"
105072>//                Set pbControlBeginGroup to True
105072>//            End_Object
105072>
105072>            Object oPromptToolItem is a cCJPromptMenuItem
105074>                Set psImage to "ActionPrompt1.ico"
105075>                Set pbControlBeginGroup to True
105076>            End_Object
105077>
105077>            Object oClearToolItem is a cCJClearMenuItem
105079>                Set peControlStyle to xtpButtonIconAndCaption
105080>                Set psCaption      to "Clear/Add"
105081>                Set pbControlBeginGroup to True
105082>                Set psImage to "ActionClear1.ico"  
105083>                
105083>                Function IsEnabled Returns Boolean
105086>                    Function_Return True
105087>                End_Function
105088>
105088>            End_Object
105089>
105089>            Object oOpenContainingFolder_MenuItem is a cCJMenuItem
105091>                Set psImage to "ActionOpenContainingFolder1.ico"
105092>                Set psCaption to "Containing Folder"
105093>                Set psToolTip to "Open containing folder"
105094>                Set psDescription to "Open Containing Folder"
105095>                Set pbActiveUpdate to True
105096>                Set pbControlBeginGroup to True
105097>
105097>                Procedure OnExecute Variant vCommandBarControl
105100>                    String sPath sFile       
105100>                    Boolean bExists
105100>
105100>                    Forward Send OnExecute vCommandBarControl
105102>                    Get psFilelistFrom of ghoApplication to sFile
105103>                    Get ParseFolderName sFile to sPath
105104>                    Get vFilePathExists sFile to bExists
105105>                    // We want to have that file to be selected in Windows Explorer;
105105>                    If (bExists = True) Begin
105107>                        Move ("/select, " + sFile) to sPath
105108>                    End
105108>                    Send vShellExecute "open" "explorer.exe" sPath ""
105109>                End_Procedure
105110>
105110>                Function IsEnabled Returns Boolean
105113>                    String sFile
105113>                    Boolean bExists
105113>                    Get psFilelistFrom of ghoApplication to sFile
105114>                    Get vFilePathExists sFile to bExists
105115>                    Function_Return (bExists = True)
105116>                End_Function
105117>
105117>            End_Object
105118>
105118>            Object oCompareToolItem is a cCJMenuItem
105120>//                Set peControlStyle to xtpButtonIconAndCaption
105120>//                Set psCaption to "&Connection" 
105120>                Set psToolTip to "Show SQL Settings dialog"
105121>                Set psImage to "SQLSettings1.ico"
105122>                Set piShortCutKey to xtpKey_Alt VK_S
105123>                Set pbControlBeginGroup to True
105124>                Set pbActiveUpdate to True
105125>
105125>                Procedure OnExecute Variant vCommandBarControl
105128>                    tSQLConnection Connection
105128>                    tSQLConnection Connection
105128>                    String sFileListFrom sCurrentFilelist
105128>                    Handle hoFocus
105128>                    Boolean bExists bOK
105128>
105128>                    Move (Focus(Desktop)) to hoFocus
105129>                    Forward Send OnExecute vCommandBarControl
105131>
105131>                    // First change the "current" filelist depending on which
105131>                    // Filelist form is active.
105131>                    Get Value of hoFocus to sCurrentFilelist
105132>                    Get vFilePathExists sCurrentFilelist to bExists
105133>                    Get psFilelistFrom of ghoApplication to sFileListFrom
105134>                    If (sFileListFrom = "") Begin
105136>                        Procedure_Return
105137>                    End
105137>                    If (bExists = True and sCurrentFilelist <> "") Begin
105139>                        Get ChangeFilelistPathing of ghoApplication sCurrentFilelist to bOK
105140>                        Get psFilelistFrom of ghoApplication to sFileListFrom
105141>                    End
105141>
105141>                    If (sFileListFrom <> "") Begin
105143>                        Get pSQLConnection of ghoSQLConnectionHandler to Connection
105144>                    End
105144>
105144>                    Send Activate_ReadOnlySQLMaintainConnections_dg of (Client_Id(ghoCommandBars)) Connection
105145>                End_Procedure  
105146>                
105146>                Function IsEnabled Returns Boolean
105149>                    tSQLConnection Connection
105149>                    tSQLConnection Connection
105149>                    Get pSQLConnection of ghoSQLConnectionHandler to Connection
105150>                    Function_Return (Connection.sDriverID <> DATAFLEX_ID and Connection.sDriverID <> "")
105151>                End_Function
105152>
105152>            End_Object
105153>
105153>            Object oAddToStudio_MenuItem is a cCJMenuItem
105155>                Set psCaption to "Add to Studio"
105156>                Set psDescription to "Add to Studio"
105157>                Set psToolTip to "Add this tool to the DataFlex Studio's 'Tools' menu"
105158>                Set psImage to "ActionAddStudio1.ico"
105159>                Set pbControlBeginGroup to True   
105160>                
105160>                Procedure OnExecute Variant vCommandBarControl
105163>                    Forward Send OnExecute vCommandBarControl
105165>                    Send Popup of (oAddToStudio_dg(Client_Id(phoMainPanel(ghoApplication))))
105166>                End_Procedure
105167>                
105167>            End_Object
105168>
105168>//            Object oCaptureViewMenuItem is a cCJMenuItem
105168>//                Set psCaption to "E&ditor Settings"
105168>//                Set psToolTip to "Editor"
105168>//                Set psDescription to "Editor Settings (Alt+D)"
105168>//
105168>//                Set psCaption to "Take shapshot"
105168>//                Set psToolTip to "Take shapshot"
105168>//                Set psDescription to "Take a snapshot image of the current view/panel. (F10)"
105168>//                Set psImage to "Camera1.ico"
105168>//                
105168>//                Procedure OnExecute Variant vCommandBarControl
105168>//                    Send TakeSnapshot False
105168>//                End_Procedure
105168>//
105168>//                Function IsEnabled Returns Boolean
105168>//                    Function_Return
105168>//                End_Function   
105168>//            End_Object
105168>
105168>//            #IF (!@ > 182)
105168>//
105168>//            Use DatabaseSelection.pkg
105168>//    
105168>//            Object oThemeItem is a cCJMenuItem
105168>//                Set peControlType to xtpControlComboBox
105168>//                Set psToolTip to "Theme"
105168>//                Set psCaption to "Theme:"
105168>//                Set psDescription to "Select a theme from the drop down list"
105168>//                Set pbControlBeginGroup to True
105168>//                Set pbVisible to False
105168>//
105168>//                Procedure OnCreateControl Handle hoObj
105168>//                    Integer iItem eTheme
105168>//                    Set ComWidth of hoObj to 250
105168>//                    Send FillComboList hoObj
105168>//                    Get peVisualTheme to eTheme
105168>//                    Get FindDataItem hoObj eTheme to iItem
105168>//                    Set ComListIndex of hoObj to (If(iItem, iItem, 1))
105168>//                End_Procedure
105168>//
105168>//                Function FindDataItem Handle hoCombo Integer eVal Returns Integer
105168>//                    Integer iCount i eTheme
105168>//                    Get ComListCount of hoCombo to iCount
105168>//                    For i from 1 to iCount
105168>//                        Get ComItemData of hoCombo i to eTheme
105168>//                        If (eTheme = eVal) Begin
105168>//                            Send SetTheTheme eTheme
105168>//                            Function_Return i
105168>//                        End
105168>//                    Loop
105168>//                    Function_Return 0
105168>//                End_Function
105168>//
105168>//                Procedure AddTheme Handle hoCombo String sText Integer eTheme
105168>//                    Integer iCount
105168>//                    Get ComListCount of hoCombo to iCount
105168>//                    Increment iCount
105168>//                    Send ComAddItem  of hoCombo sText iCount
105168>//                    Set ComItemData  of hoCombo iCount to  eTheme
105168>//                End_Procedure
105168>//
105168>//                Procedure FillComboList Handle hoCombo
105168>//                    Send ComClear     of hoCombo
105168>//
105168>//                    #IF (!@ > 190)
105168>//                    Send AddTheme hoCombo "xtpThemeOffice2016Access" xtpThemeOffice2016Access
105168>//                    Send AddTheme hoCombo "xtpThemeOffice2016Excel" xtpThemeOffice2016Excel
105168>//                    Send AddTheme hoCombo "xtpThemeOffice2016OneNote" xtpThemeOffice2016OneNote
105168>//                    Send AddTheme hoCombo "xtpThemeOffice2016Outlook" xtpThemeOffice2016Outlook
105168>//                    Send AddTheme hoCombo "xtpThemeOffice2016PowerPoint" xtpThemeOffice2016PowerPoint
105168>//                    Send AddTheme hoCombo "xtpThemeOffice2016Publisher" xtpThemeOffice2016OneNote
105168>//                    Send AddTheme hoCombo "xtpThemeOffice2016Word" xtpThemeOffice2016Word
105168>//                    #ENDIF
105168>//
105168>//                    Send AddTheme hoCombo "xtpThemeOffice2013Word" xtpThemeOffice2013Word
105168>//                    Send AddTheme hoCombo "xtpThemeOffice2013Outlook" xtpThemeOffice2013Outlook
105168>//                    Send AddTheme hoCombo "xtpThemeOffice2013Excel" xtpThemeOffice2013Excel
105168>//                    Send AddTheme hoCombo "xtpThemeOffice2013PowerPoint" xtpThemeOffice2013PowerPoint
105168>//                    Send AddTheme hoCombo "xtpThemeOffice2013Publisher" xtpThemeOffice2013Publisher
105168>//                    Send AddTheme hoCombo "xtpThemeOffice2013OneNote" xtpThemeOffice2013OneNote
105168>//                    Send AddTheme hoCombo "xtpThemeOffice2013Access" xtpThemeOffice2013Access
105168>//                    Send AddTheme hoCombo "xtpThemeOffice2003" xtpThemeOffice2003
105168>//                    Send AddTheme hoCombo "xtpThemeOffice2000" xtpThemeOffice2000
105168>//                    Send AddTheme hoCombo "xtpThemeOfficeXP" xtpThemeOfficeXP
105168>//
105168>//                    Send AddTheme hoCombo "xtpThemeOffice2010Blue" xtpThemeOffice2010Blue
105168>//                    Send AddTheme hoCombo "xtpThemeOffice2010Black" xtpThemeOffice2010Black
105168>//                    Send AddTheme hoCombo "xtpThemeOffice2010Silver" xtpThemeOffice2010Silver
105168>//
105168>//                    Send AddTheme hoCombo "xtpThemeOffice2007Aqua" xtpThemeOffice2007Aqua
105168>//                    Send AddTheme hoCombo "xtpThemeOffice2007Black" xtpThemeOffice2007Black
105168>//                    Send AddTheme hoCombo "xtpThemeOffice2007Blue" xtpThemeOffice2007Blue
105168>//                    Send AddTheme hoCombo "xtpThemeOffice2007Silver" xtpThemeOffice2007Silver
105168>//
105168>//                    Send AddTheme hoCombo "xtpThemeVisualStudio2015Blue" xtpThemeVisualStudio2015Blue
105168>//                    Send AddTheme hoCombo "xtpThemeVisualStudio2015Light" xtpThemeVisualStudio2015Light
105168>//                    Send AddTheme hoCombo "xtpThemeVisualStudio2015Dark" xtpThemeVisualStudio2015Dark
105168>//
105168>//                    Send AddTheme hoCombo "xtpThemeVisualStudio2012Light" xtpThemeVisualStudio2012Light
105168>//                    Send AddTheme hoCombo "xtpThemeVisualStudio2012Dark" xtpThemeVisualStudio2012Dark
105168>//
105168>//                    Send AddTheme hoCombo "xtpThemeVisualStudio2008" xtpThemeVisualStudio2008
105168>//                    Send AddTheme hoCombo "xtpThemeVisualStudio6" xtpThemeVisualStudio6
105168>//
105168>//                    Send AddTheme hoCombo "xtpThemeWindows7" xtpThemeWindows7
105168>//
105168>//                    Send AddTheme hoCombo "xtpThemeWhidbey" xtpThemeWhidbey
105168>//
105168>//                    Send AddTheme hoCombo "xtpThemeNativeWinXP" xtpThemeNativeWinXP
105168>//                End_Procedure
105168>//
105168>//                Function CurrentTheme Handle vCommandBarControl Returns Integer
105168>//                    Handle hMessage hoCombo
105168>//                    Integer iIndex
105168>//                    // create and bind  proxy control
105168>//                    Get CreateProxyControl vCommandBarControl to hoCombo
105168>//                    // get the current selection
105168>//                    Get ComListIndex of hoCombo to iIndex
105168>//                    // note the index selections are 1 based
105168>//                    If (iIndex > 0) Begin
105168>//                        // get the ItemData for the selected item and send that message
105168>//                        Get ComItemData of hoCombo iIndex to hMessage
105168>//                        Function_Return hMessage
105168>//                    End
105168>//                    // dispose of the proxy control
105168>//                    Send Destroy of hoCombo 
105168>//                    Function_Return 0
105168>//                End_Function
105168>//
105168>//                Procedure OnExecute Variant vCommandBarControl
105168>//                    Integer eTheme
105168>//                    Integer iColor
105168>//                    Get CurrentTheme vCommandBarControl to eTheme
105168>//                    Set peVisualTheme of ghoCommandBars to eTheme
105168>//                    Send ComRecalcLayout of ghoCommandBars
105168>//                    Send WriteDword of ghoApplication CS_PropertiesKeyWord CS_ThemeKeyWord eTheme
105168>//                    Get ComGetSpecialColor of ghoCommandBars XPCOLOR_TOOLBAR_FACE to iColor
105168>//                    Broadcast Recursive Set Color of (Client_Id(phoMainPanel(ghoApplication))) to iColor
105168>//                End_Procedure
105168>//
105168>//                Procedure SetTheTheme Integer eTheme
105168>//                    Integer iColor
105168>//                    Set peVisualTheme of ghoCommandBars to eTheme
105168>//                    Send ComRecalcLayout of ghoCommandBars
105168>//                    Get ComGetSpecialColor of ghoCommandBars XPCOLOR_TOOLBAR_FACE to iColor
105168>//                    Broadcast Recursive Set Color of (Client_Id(phoMainPanel(ghoApplication))) to iColor
105168>//                End_Procedure
105168>//
105168>//                Function ConvertSystemColor Integer iColor Returns Integer
105168>//                    Integer iSysColor
105168>//                    If (iColor = clDefault or iColor = clNone) Begin    // If default color then use -1
105168>//                        Move clNone to iColor
105168>//                    End
105168>//                    Else If (iColor < 0) Begin    // If it is a system color (<0) then convert this into an RGB value
105168>//                        Move (iColor iand |CI$7FFFFFFF) to iSysColor    // extract the system color constant
105168>//                        Move (GetSysColor(iSysColor)) to iColor
105168>//                    End
105168>//                    Function_Return iColor
105168>//                End_Function
105168>//
105168>//                Procedure OnCreateAction
105168>//                    Integer eTheme
105168>//                    Forward Send OnCreateAction
105168>//                    Get peVisualTheme of ghoCommandBars to eTheme
105168>//                    Get ReadDword of ghoApplication CS_PropertiesKeyWord CS_ThemeKeyWord eTheme to eTheme
105168>//                    Set peVisualTheme to eTheme
105168>//                End_Procedure
105168>//
105168>//            End_Object
105168>//            #ENDIF
105168>
105168>//            Object oColorSelection_TextItem is a cCJMenuItem
105168>//                Set peControlType to xtpControlLabel
105168>//                Set pbControlBeginGroup to True
105168>//                Set psCaption to "Hotspot Color:"
105168>//            End_Object
105168>//
105168>//            Object oColorSelection_Item is a cCJMenuItem
105168>//                Set psImage to "ColorSelectorBlack1.ico"
105168>//
105168>//                Object oColorDialog is a ColorDialog
105168>//                    Function SelectColor Returns Integer
105168>//                        Integer iRgbColor
105168>//                        Boolean bColorSelected
105168>//
105168>//                        Move -1 to iRgbColor
105168>//                        Get Show_Dialog to bColorSelected
105168>//                        If (bColorSelected) Begin
105168>//                            Get SelectedColor to iRgbColor
105168>//                        End
105168>//
105168>//                        Function_Return iRgbColor
105168>//                    End_Function
105168>//                End_Object
105168>//
105168>//                Procedure OnExecute Variant vCommandBarControl
105168>//                    Integer iColor
105168>//                    Forward Send OnExecute vCommandBarControl
105168>//                    Get SelectColor of oColorDialog to iColor
105168>//                    If (iColor <> -1) Begin
105168>//                        Broadcast Recursive Set piHeaderHotspotColor of (Client_Id(phoMainPanel(ghoApplication))) to iColor
105168>//                    End
105168>//                End_Procedure
105168>//
105168>//            End_Object
105168>
105168>            Object oAbout_MenuItem is a cCJMenuItem
105170>                Set psCaption to "About"
105171>                Set psToolTip to "About Info"
105172>                Set psDescription to "About the program"
105173>                Set psImage to "ActionAbout1.ico"
105174>                Set pbControlBeginGroup to True
105175>                Procedure OnExecute Variant vCommandBarControl
105178>                    Forward Send OnExecute vCommandBarControl
105180>                    Send Activate_About of (Client_Id(ghoCommandBars))
105181>                End_Procedure
105182>            End_Object
105183>
105183>            Object oHelpMenuItem is a cCJHelpMenuItem
105185>                Set peControlType to xtpControlSplitButtonPopup
105186>                Set psImage to "ActionHelp1.ico"
105187>
105187>                Procedure OnExecute Variant vCommandBarControl
105190>                    Send ShowProgramHelp
105191>                End_Procedure
105192>
105192>                Object oHelpMenuItemLocal is a cCJMenuItem
105194>                    Set psCaption to "Local HTML Help"
105195>                    Set psImage to "ActionHelp1.ico"
105196>                    Procedure OnExecute Variant vCommandBarControl
105199>                        Send ShowProgramHelp
105200>                    End_Procedure
105201>                End_Object
105202>
105202>                Object oHelpMenuItemInternetBrowser is a cCJMenuItem
105204>                    Set psCaption to "Online HTML Help"
105205>                    Set psImage to "ActionHelpInternet1.ico"
105206>                    Procedure OnExecute Variant vCommandBarControl
105209>                        Runprogram Shell Background "http://www.rdctools.com/HTMLHelpDUF/Developer5.htm"
105210>                    End_Procedure
105211>
105211>                End_Object
105212>
105212>                Object oCheckforUpdatesMenuItem is a cCJMenuItem
105214>                    Set psCaption to "Check for Updates"
105215>                    Set psDescription to "Check for Updates..."
105216>                    Set psImage to "InternetUpdate1.ico"
105217>                    Set pbControlBeginGroup to True
105218>                    
105218>                    Procedure OnExecute Variant vCommandBarControl
105221>                        String sPath sUpdateProgram sParam
105221>                        Get psProgramPath of (phoWorkspace(ghoApplication)) to sPath
105222>                        Get vFolderFormat sPath to sPath
105223>                        Move "updater.exe" to sUpdateProgram
105224>                        Move "/checknow"   to sParam
105225>                        Runprogram Shell Wait ('"' + sPath + sUpdateProgram + '"') sParam
105226>                    End_Procedure
105227>                
105227>                End_Object
105228>                
105228>            End_Object
105229>
105229>            Object oExitMenuItem is a cCJExitMenuItem
105231>                Set psToolTip to "Exit application"
105232>                Set psDescription to "Exit the program (Alt+F4)"
105233>                Set psImage to "ActionExit1.ico"
105234>                Set pbControlBeginGroup to True
105235>            End_Object
105236>
105236>        End_Object
105237>
105237>        Object oPreviousTabAction is a cCJAction
105239>            Set piShortCutKey to (xtpKey_Shift + xtpKey_Ctrl) VK_TAB
105240>            Procedure OnExecute Variant vCommandBarControl
105243>                Handle hoCommandBars hoClientArea
105243>                Forward Send OnExecute vCommandBarControl
105245>                Get CommandBarSystemObject to hoCommandBars
105246>                Get ClientAreaObject of hoCommandBars to hoClientArea
105247>                If hoClientArea Begin
105249>                    Send Switch_Next_View of hoClientArea
105250>                End
105250>            End_Procedure
105251>        End_Object
105252>
105252>        Object oStatusBar is a cCJStatusBar
105254>
105254>            Object oStatusPane1 is a cCJStatusBarPane
105256>                Set piID to sbpIDIdlePane
105257>                Set pbStyleStretch to True
105258>            End_Object
105259>
105259>            Object oStatusPane2 is a cCJStatusBarPane
105261>                Set phoViewPane to Self
105262>                Set pbStyleStretch to True
105263>            End_Object
105264>
105264>        End_Object
105265>
105265>    End_Object
105266>
105266>    Object oClientArea is a ClientArea
105268>        Use ManageSQLConnections.dg
Including file: ManageSQLConnections.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ManageSQLConnections.dg)
105268>>>Use Windows.pkg
105268>>>Use Cursor.pkg
105268>>>Use cCJCommandBarSystem.pkg
105268>>>Use cRDCButtonDPI.pkg
Including file: cRDCButtonDPI.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cRDCButtonDPI.pkg)
105268>>>>>//****************************************************************************
105268>>>>>// $Module type: Package
105268>>>>>// $Module name: cRDCButtonDPI.pkg
105268>>>>>//
105268>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
105268>>>>>// Copyright (c) 2013 RDC Tools International
105268>>>>>// E-mail      : support@rdctools.com
105268>>>>>// Web-site    : http://www.rdctools.com
105268>>>>>//
105268>>>>>// Created     : 2013-01-05 @ 19:04 (Military date format - Year-Month-Day)
105268>>>>>//
105268>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
105268>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
105268>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
105268>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
105268>>>>>// in the help folder for more details.
105268>>>>>//
105268>>>>>//****************************************************************************
105268>>>>>Use cRDCButton.pkg
Including file: cRDCButton.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cRDCButton.pkg)
105268>>>>>>>//****************************************************************************
105268>>>>>>>// $Module type: Package
105268>>>>>>>// $Module name: cRDCButton.pkg
105268>>>>>>>//
105268>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
105268>>>>>>>// Copyright (c) 2013 RDC Tools International
105268>>>>>>>// E-mail      : support@rdctools.com
105268>>>>>>>// Web-site    : http://www.rdctools.com
105268>>>>>>>//
105268>>>>>>>// Created     : 2013-01-05 @ 19:04 (Military date format - Year-Month-Day)
105268>>>>>>>//
105268>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
105268>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
105268>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
105268>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
105268>>>>>>>// in the help folder for more details.
105268>>>>>>>//
105268>>>>>>>//****************************************************************************
105268>>>>>>>Use Windows.pkg
105268>>>>>>>Use Enclient.pkg
105268>>>>>>>Use errornum.inc
105268>>>>>>>
105268>>>>>>>Class cButtonIdleHandler is a cIdleHandler
105269>>>>>>>    Procedure Construct_Object
105271>>>>>>>        Forward Send Construct_Object
105273>>>>>>>
105273>>>>>>>    End_Procedure
105274>>>>>>>
105274>>>>>>>    Procedure OnIdle
105276>>>>>>>        Delegate Send DoUpdate
105278>>>>>>>    End_Procedure
105279>>>>>>>
105279>>>>>>>End_Class
105280>>>>>>>
105280>>>>>>>Class cRDCButton is a Button
105281>>>>>>>
105281>>>>>>>    Procedure Construct_Object
105283>>>>>>>        Forward Send Construct_Object
105285>>>>>>>
105285>>>>>>>        Property Boolean pbAutoEnable False
105286>>>>>>>
105286>>>>>>>        Property Boolean pbEnabled True
105287>>>>>>>
105287>>>>>>>        Property Handle phoIdleHandler (Create(Self, RefClass(cButtonIdleHandler)))
105288>>>>>>>
105288>>>>>>>        On_Key kCancel Send CancelIfPopupObject
105289>>>>>>>    End_Procedure
105290>>>>>>>
105290>>>>>>>    Procedure CancelIfPopupObject
105292>>>>>>>        Boolean bIsInPopupObject
105292>>>>>>>        Delegate Get Popup_State to bIsInPopupObject
105294>>>>>>>        If (bIsInPopupObject = True) Begin
105296>>>>>>>            Send Close_Panel
105297>>>>>>>        End
105297>>>>>>>>
105297>>>>>>>    End_Procedure
105298>>>>>>>
105298>>>>>>>    Procedure End_Construct_Object
105300>>>>>>>        String sTooltip sStatus_Help
105300>>>>>>>
105300>>>>>>>        Forward Send End_Construct_Object
105302>>>>>>>
105302>>>>>>>        Get psToolTip   to sTooltip
105303>>>>>>>        Get Status_Help to sStatus_Help
105304>>>>>>>        If (sTooltip = "" and sStatus_Help <> "") Begin
105306>>>>>>>            Set psToolTip to sStatus_Help
105307>>>>>>>        End
105307>>>>>>>>
105307>>>>>>>        If (sTooltip <> "" and sStatus_Help = "") Begin
105309>>>>>>>            Set Status_Help to sToolTip
105310>>>>>>>        End
105310>>>>>>>>
105310>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to (pbAutoEnable(Self))
105311>>>>>>>    End_Procedure
105312>>>>>>>
105312>>>>>>>    Procedure DoUpdate
105314>>>>>>>        If (pbAutoEnable(Self) = False) Begin
105316>>>>>>>            Procedure_Return
105317>>>>>>>        End
105317>>>>>>>>
105317>>>>>>>        Set Enabled_State to (IsEnabled(Self))
105318>>>>>>>    End_Procedure
105319>>>>>>>
105319>>>>>>>    Function IsEnabled Returns Boolean
105321>>>>>>>        Boolean bEnabled
105321>>>>>>>        Get pbEnabled to bEnabled
105322>>>>>>>        Function_Return bEnabled
105323>>>>>>>    End_Function
105324>>>>>>>
105324>>>>>>>    // Enable the idle handler timer when the button is activated
105324>>>>>>>    Procedure Activating
105326>>>>>>>        Forward Send Activating
105328>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to True
105329>>>>>>>    End_Procedure
105330>>>>>>>
105330>>>>>>>    // Disable the idle handler when the button is deactivated
105330>>>>>>>    Procedure Deactivating
105332>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to False
105333>>>>>>>        Forward Send Deactivating
105335>>>>>>>    End_Procedure
105336>>>>>>>
105336>>>>>>>End_Class
105337>>>>>
105337>>>>>// Button class that automatically shows the correct icon size for the current DPI-setting:
105337>>>>>Class cRDCButtonDPI is a cRDCButton
105338>>>>>    Procedure Construct_Object
105340>>>>>        Integer iIconSize
105340>>>>>        Forward Send Construct_Object
105342>>>>>        Set piImageMarginLeft to 10
105343>>>>>    End_Procedure
105344>>>>>
105344>>>>>    // Returns: DPI setting as an integer.
105344>>>>>    //  Normal DPI setting: iDPI=96  is "Normal setting" 100%
105344>>>>>    //                      iDPI=120 is "Medium setting" 125%
105344>>>>>    //                      iDPI= 144 is "Large setting" 150%
105344>>>>>    Function GetCurrentDPI Returns Integer
105346>>>>>        Handle hDC
105346>>>>>        Integer iPixelsX
105346>>>>>        Move (GetDC(0)) to hDC
105347>>>>>        Move (GetDeviceCaps(hDC, LOGPIXELSX)) to iPixelsX
105348>>>>>        Move (ReleaseDC(0, hDC)) to hDC
105349>>>>>        Function_Return iPixelsX
105350>>>>>    End_Function
105351>>>>>
105351>>>>>    Function GetCorrectIconSize Returns Integer
105353>>>>>        Integer iPixelsX iIndex iSize
105353>>>>>        Integer[] iaSizes
105354>>>>>
105354>>>>>        Move 16 to iaSizes[0]
105355>>>>>        Move 24 to iaSizes[1]
105356>>>>>        Move 32 to iaSizes[2]
105357>>>>>        Move 48 to iaSizes[3]
105358>>>>>        Move 64 to iaSizes[4]
105359>>>>>
105359>>>>>        Get piImageSize to iSize  // the "100%" size
105360>>>>>        Move (SearchArray(iSize,iaSizes)) to iIndex
105361>>>>>        Move (0 max iIndex) to iIndex
105362>>>>>        Get GetCurrentDPI to iPixelsX
105363>>>>>        // Use a Case Statement here. Wherever we jump in we will continue onwards, regardless of whether
105363>>>>>        // we match the remaining Case statements or not. So list our Cases in reverse order, meaning we
105363>>>>>        // will increment iIndex as many times as we need here.
105363>>>>>        Case Begin
105363>>>>>            Case (iPixelsX > 144)
105365>>>>>                Increment iIndex
105366>>>>>            Case (iPixelsX = 144)
105369>>>>>                Increment iIndex
105370>>>>>            Case (iPixelsX = 120)
105373>>>>>                Increment iIndex
105374>>>>>        Case End
105374>>>>>        Move (iIndex min 4) to iIndex
105375>>>>>        Function_Return iaSizes[iIndex]
105376>>>>>    End_Function
105377>>>>>
105377>>>>>    Procedure Set psToolTip String sToolTip
105379>>>>>        String sStatusHelp
105379>>>>>
105379>>>>>        Get Status_Help to sStatusHelp
105380>>>>>        If (sStatusHelp = "") Begin
105382>>>>>            Set Status_Help to sToolTip
105383>>>>>        End
105383>>>>>>
105383>>>>>
105383>>>>>        Forward Set psToolTip to sToolTip
105385>>>>>    End_Procedure
105386>>>>>
105386>>>>>End_Class
105387>>>Use cSQLCheckBox.pkg
Including file: cSQLCheckBox.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLCheckBox.pkg)
105387>>>>>Use Windows.pkg
105387>>>>>
105387>>>>>// Used by the "Page" message below to show
105387>>>>>// a rectangle around ComboForm and Checkbox objects.
105387>>>>>    Define WM_CHANGEUISTATE for |CI$0127
105387>>>>>    Define WM_UPDATEUISTATE for |CI$0128
105387>>>>>    Define WM_QUERYUISTATE  for |CI$0129
105387>>>>>    Define UIS_SET          for 1
105387>>>>>    Define UIS_CLEAR        for 2
105387>>>>>    Define UIS_INITIALIZE   for 3
105387>>>>>    Define UISF_HIDEFOCUS   for |CI$1
105387>>>>>    Define UISF_HIDEACCEL   for |CI$2
105387>>>>>    Define UISF_ACTIVE      for |CI$4
105387>>>>>
105387>>>>>// Note: Can't use cRDCCheckbox as then the OnChange event isn't called (Don't know why)
105387>>>>>Class cSQLCheckBox is a CheckBox
105388>>>>>    Procedure Construct_Object
105390>>>>>        Forward Send Construct_Object
105392>>>>>        // The piItem should be set to the object's corresponding tSQLConnection member (One based)
105392>>>>>        Property Integer piItem
105393>>>>>    End_Procedure
105394>>>>>
105394>>>>>    Procedure DbTypeUpdate Integer iDbType String sDriverID
105396>>>>>    End_Procedure
105397>>>>>
105397>>>>>    Procedure ReadConnectionData String[] sConnectionData
105399>>>>>        Integer iItem
105399>>>>>        Get piItem to iItem
105400>>>>>        Set Checked_State to (sConnectionData[iItem] = "1")
105401>>>>>    End_Procedure
105402>>>>>
105402>>>>>    Procedure WriteConnectionData String[] ByRef sConnectionData
105404>>>>>        Boolean bState
105404>>>>>        Integer iItem
105404>>>>>        Get piItem to iItem
105405>>>>>        Get Checked_State to bState
105406>>>>>        Move bState to sConnectionData[iItem]
105407>>>>>    End_Procedure
105408>>>>>
105408>>>>>    Procedure Set psToolTip String sToolTip
105410>>>>>        String sStatusHelp
105410>>>>>
105410>>>>>        Get Status_Help to sStatusHelp
105411>>>>>        If (sStatusHelp = "") Begin
105413>>>>>            Set Status_Help to sToolTip
105414>>>>>        End
105414>>>>>>
105414>>>>>
105414>>>>>        Forward Set psToolTip to sToolTip
105416>>>>>    End_Procedure
105417>>>>>
105417>>>>>    // Fix for a bug when using manifest files & running Vista and above.
105417>>>>>    // The bug being that the focus rectangle doesn't show.
105417>>>>>    Procedure Page Integer iPageObject
105419>>>>>        Handle hWnd
105419>>>>>        Integer iRet iState
105419>>>>>
105419>>>>>        Forward Send Page iPageObject
105421>>>>>
105421>>>>>        If (iPageObject) Begin
105423>>>>>            Get Window_Handle to hWnd
105424>>>>>            If (hWnd) Begin
105426>>>>>                Move (SendMessage(hWnd, WM_QUERYUISTATE, 0, 0)) to iRet
105427>>>>>                If (iRet iand UISF_HIDEFOCUS) Begin
105429>>>>>                    Move (UIS_CLEAR + (UISF_HIDEFOCUS * 65536)) to iState
105430>>>>>                    Move (SendMessage(hWnd, WM_UPDATEUISTATE, iState, 0)) to iRet
105431>>>>>                End
105431>>>>>>
105431>>>>>            End
105431>>>>>>
105431>>>>>        End
105431>>>>>>
105431>>>>>    End_Procedure
105432>>>>>
105432>>>>>End_Class
105433>>>Use cSQLComboForm.pkg
Including file: cSQLComboForm.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLComboForm.pkg)
105433>>>>>Use Windows.pkg
105433>>>>>Use cRDCComboForm.pkg
Including file: cRDCComboForm.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cRDCComboForm.pkg)
105433>>>>>>>//****************************************************************************
105433>>>>>>>// $Module type: Package
105433>>>>>>>// $Module name: cRDCComboform.pkg
105433>>>>>>>//
105433>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
105433>>>>>>>// Copyright (c) 2014 RDC Tools International
105433>>>>>>>// E-mail      : support@rdctools.com
105433>>>>>>>// Web-site    : http://www.rdctools.com
105433>>>>>>>//
105433>>>>>>>// Created     : 2014-03-17 @ 12:35 (Military date format - Year-Month-Day)
105433>>>>>>>//
105433>>>>>>>// Portions by : Raveen Sundram, Excellent Software Ltd
105433>>>>>>>//               The auto-size combo width logic was developed by Raveen.
105433>>>>>>>//
105433>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
105433>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
105433>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
105433>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
105433>>>>>>>// in the help folder for more details.
105433>>>>>>>//
105433>>>>>>>//****************************************************************************
105433>>>>>>>Use Windows.pkg
105433>>>>>>>
105433>>>>>>>// Used by the "Page" message below to show
105433>>>>>>>// a focus rectangle around ComboForm and Checkbox objects.
105433>>>>>>>
105433>>>>>>>Class cComboFormIdleHandler is a cIdleHandler
105434>>>>>>>    Procedure Construct_Object
105436>>>>>>>        Forward Send Construct_Object
105438>>>>>>>
105438>>>>>>>    End_Procedure
105439>>>>>>>
105439>>>>>>>    Procedure OnIdle
105441>>>>>>>        Delegate Send DoUpdate
105443>>>>>>>    End_Procedure
105444>>>>>>>
105444>>>>>>>End_Class
105445>>>>>>>
105445>>>>>>>Class cRDCComboForm is a ComboForm
105446>>>>>>>    Procedure Construct_Object
105448>>>>>>>        Forward Send Construct_Object
105450>>>>>>>
105450>>>>>>>        Property Boolean pbAutoListWidth True
105451>>>>>>>
105451>>>>>>>        Property Boolean pbAutoShadowLabelObject True
105452>>>>>>>
105452>>>>>>>        Property Boolean pbAutoEnable False
105453>>>>>>>        Set Label_Col_Offset to 2
105454>>>>>>>        Property Boolean pbEnabled True
105455>>>>>>>        Set Label_Justification_Mode to JMode_Right
105456>>>>>>>        Property Handle phoIdleHandler (Create(Self, RefClass(cComboFormIdleHandler)))
105457>>>>>>>
105457>>>>>>>    End_Procedure
105458>>>>>>>
105458>>>>>>>    Procedure End_Construct_Object
105460>>>>>>>        Boolean bAutoShadowLabelObject
105460>>>>>>>        String sTooltip sStatus_Help
105460>>>>>>>
105460>>>>>>>        Get pbAutoShadowLabelObject to bAutoShadowLabelObject
105461>>>>>>>        If (bAutoShadowLabelObject = True) Begin
105463>>>>>>>            Set Private.Label_Shadow_Display_Mode to TBSHADOW_ON_LOCAL
105464>>>>>>>        End
105464>>>>>>>>
105464>>>>>>>
105464>>>>>>>        Forward Send End_Construct_Object
105466>>>>>>>
105466>>>>>>>        Get psToolTip   to sTooltip
105467>>>>>>>        Get Status_Help to sStatus_Help
105468>>>>>>>        If (sTooltip = "" and sStatus_Help <> "") Begin
105470>>>>>>>            Set psToolTip to sStatus_Help
105471>>>>>>>        End
105471>>>>>>>>
105471>>>>>>>        Else If (sTooltip <> "" and sStatus_Help = "") Begin
105474>>>>>>>            Set Status_Help to sTooltip
105475>>>>>>>        End
105475>>>>>>>>
105475>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to (pbAutoEnable(Self))
105476>>>>>>>
105476>>>>>>>    End_Procedure
105477>>>>>>>
105477>>>>>>>    Procedure DoUpdate
105479>>>>>>>        If (pbAutoEnable(Self) = False) Begin
105481>>>>>>>            Procedure_Return
105482>>>>>>>        End
105482>>>>>>>>
105482>>>>>>>        Set Enabled_State to (IsEnabled(Self))
105483>>>>>>>    End_Procedure
105484>>>>>>>
105484>>>>>>>    Function IsEnabled Returns Boolean
105486>>>>>>>        Boolean bEnabled
105486>>>>>>>        Get pbEnabled to bEnabled
105487>>>>>>>        Function_Return bEnabled
105488>>>>>>>    End_Function
105489>>>>>>>
105489>>>>>>>    // Enable the idle handler timer when the object is activated
105489>>>>>>>    Procedure Activating
105491>>>>>>>        Forward Send Activating
105493>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to True
105494>>>>>>>    End_Procedure
105495>>>>>>>
105495>>>>>>>    // Disable the idle handler when the object is deactivated
105495>>>>>>>    Procedure Deactivating
105497>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to False
105498>>>>>>>        Forward Send Deactivating
105500>>>>>>>    End_Procedure
105501>>>>>>>
105501>>>>>>>    // To "un-select" the text in the comboform on startup
105501>>>>>>>    Procedure DoApplyAnchors Integer Arg1 Integer Arg2
105503>>>>>>>        Integer iStart iEnd
105503>>>>>>>
105503>>>>>>>        If (Focus(Desktop)=Self) Begin
105505>>>>>>>            Get SelStart to iStart
105506>>>>>>>            Get SelEnd   to iEnd
105507>>>>>>>        End
105507>>>>>>>>
105507>>>>>>>        Forward Send DoApplyAnchors Arg1 Arg2
105509>>>>>>>        Send SetSel iStart iEnd
105510>>>>>>>    End_Procedure
105511>>>>>>>
105511>>>>>>>    // Message that will drop down the list without the user clicking it,
105511>>>>>>>    // so you can send "DropDownList" to the combo to show the list.
105511>>>>>>>    Procedure DropDownList
105513>>>>>>>        Send Windows_Message CB_SHOWDROPDOWN 1 0
105514>>>>>>>    End_Procedure
105515>>>>>>>
105515>>>>>>>    Procedure SizeComboWidth
105517>>>>>>>        Integer iCount iItem iTextExt iRows iWd iNewWd iVertAdj
105517>>>>>>>        String sVal
105517>>>>>>>
105517>>>>>>>        // Initialise Width
105517>>>>>>>        Set ListWidth to 0
105518>>>>>>>        Send DoSetListWidth
105519>>>>>>>
105519>>>>>>>        Get ListRowCount     to iRows
105520>>>>>>>        Get Combo_Item_Count to iCount
105521>>>>>>>
105521>>>>>>>        // Vertical scroll-bar adjustment is needed
105521>>>>>>>        Move (iRows > 0 and iCount > iRows) to iVertAdj
105522>>>>>>>        If (iVertAdj) Begin
105524>>>>>>>            Move (GetSystemMetrics(SM_CXVSCROLL)+GetSystemMetrics(SM_CXEDGE)) to iVertAdj
105525>>>>>>>        End
105525>>>>>>>>
105525>>>>>>>        Else Begin
105526>>>>>>>            Move (GetSystemMetrics(SM_CXEDGE)) to iVertAdj
105527>>>>>>>        End
105527>>>>>>>>
105527>>>>>>>
105527>>>>>>>        // Calculate New Width
105527>>>>>>>        Decrement iCount
105528>>>>>>>        For iItem from 0 to iCount
105534>>>>>>>>
105534>>>>>>>            Get Combo_Value iItem to sVal
105535>>>>>>>            If (sVal <> "") Begin
105537>>>>>>>                Get Text_Extent sVal to iTextExt
105538>>>>>>>                Move (Low(iTextExt) + iVertAdj) to iWd
105539>>>>>>>                If (iWd > iNewWd) Begin
105541>>>>>>>                    Move (iWd + GetSystemMetrics(SM_CXFIXEDFRAME) + GetSystemMetrics(SM_CXEDGE)) to iNewWd
105542>>>>>>>                End
105542>>>>>>>>
105542>>>>>>>            End
105542>>>>>>>>
105542>>>>>>>        Loop
105543>>>>>>>>
105543>>>>>>>
105543>>>>>>>        // Set New Width
105543>>>>>>>        Set ListWidth to iNewWd
105544>>>>>>>        Send DoSetListWidth
105545>>>>>>>    End_Procedure
105546>>>>>>>
105546>>>>>>>    Procedure Combo_Add_Item String sValue
105548>>>>>>>        Forward Send Combo_Add_Item sValue
105550>>>>>>>        If (pbAutoListWidth(Self)) Begin
105552>>>>>>>            Send SizeComboWidth
105553>>>>>>>        End
105553>>>>>>>>
105553>>>>>>>    End_Procedure
105554>>>>>>>
105554>>>>>>>    Procedure Combo_Fill_List
105556>>>>>>>        Forward Send Combo_Fill_List
105558>>>>>>>        If (pbAutoListWidth(Self)) Begin
105560>>>>>>>            Send SizeComboWidth
105561>>>>>>>        End
105561>>>>>>>>
105561>>>>>>>    End_Procedure
105562>>>>>>>
105562>>>>>>>    // Fix for a bug when using manifest files & running Vista and above.
105562>>>>>>>    // The bug being that the focus rectangle doesn't show.
105562>>>>>>>    Procedure Page Integer iPageObject
105564>>>>>>>        Handle hWnd
105564>>>>>>>        Integer iRet iState
105564>>>>>>>
105564>>>>>>>        Forward Send Page iPageObject
105566>>>>>>>
105566>>>>>>>        If (iPageObject) Begin
105568>>>>>>>            Get Window_Handle to hWnd
105569>>>>>>>            If (hWnd) Begin
105571>>>>>>>                Move (SendMessage(hWnd, WM_QUERYUISTATE, 0, 0)) to iRet
105572>>>>>>>                If (iRet iand UISF_HIDEFOCUS) Begin
105574>>>>>>>                    Move (UIS_CLEAR + (UISF_HIDEFOCUS * 65536)) to iState
105575>>>>>>>                    Move (SendMessage(hWnd, WM_UPDATEUISTATE, iState, 0)) to iRet
105576>>>>>>>                End
105576>>>>>>>>
105576>>>>>>>            End
105576>>>>>>>>
105576>>>>>>>        End
105576>>>>>>>>
105576>>>>>>>
105576>>>>>>>        // To "un-select" the text in the comboform
105576>>>>>>>        If (iPageObject = 1 and Focus(Desktop) <> Self) Begin
105578>>>>>>>            Send SetSel 0 0
105579>>>>>>>        End
105579>>>>>>>>
105579>>>>>>>    End_Procedure
105580>>>>>>>
105580>>>>>>>End_Class
105581>>>>>
105581>>>>>// Used by the "Page" message below to show
105581>>>>>// a rectangle around ComboForm and Checkbox objects.
105581>>>>>//#IFNDEF WM_CHANGEUISTATE
105581>>>>>//    Define WM_CHANGEUISTATE for |CI$0127
105581>>>>>//    Define WM_UPDATEUISTATE for |CI$0128
105581>>>>>//    Define WM_QUERYUISTATE  for |CI$0129
105581>>>>>//    Define UIS_SET          for 1
105581>>>>>//    Define UIS_CLEAR        for 2
105581>>>>>//    Define UIS_INITIALIZE   for 3
105581>>>>>//    Define UISF_HIDEFOCUS   for |CI$1
105581>>>>>//    Define UISF_HIDEACCEL   for |CI$2
105581>>>>>//    Define UISF_ACTIVE      for |CI$4
105581>>>>>//#ENDIF
105581>>>>>
105581>>>>>Class cSQLComboForm is a cRDCComboForm
105582>>>>>    Procedure Construct_Object
105584>>>>>        Forward Send Construct_Object
105586>>>>>
105586>>>>>        // This will shadow the label if the form itself has its Enabled_State=False
105586>>>>>//        Property Boolean pbAutoShadowLabelObject True
105586>>>>>
105586>>>>>        // The piItem should be set to the object's corresponding tSQLConnection member (One based)
105586>>>>>        Property Integer piItem
105587>>>>>
105587>>>>>//        Set Label_Col_Offset to 2
105587>>>>>//        Set Label_Justification_Mode to JMode_Right
105587>>>>>    End_Procedure
105588>>>>>
105588>>>>>    Procedure End_Construct_Object
105590>>>>>//        Boolean bAutoShadowLabelObject
105590>>>>>//        Get pbAutoShadowLabelObject to bAutoShadowLabelObject
105590>>>>>//        If (bAutoShadowLabelObject = True) Begin
105590>>>>>//            Set Private.Label_Shadow_Display_Mode to TBSHADOW_ON_LOCAL
105590>>>>>//        End
105590>>>>>        Forward Send End_Construct_Object
105592>>>>>    End_Procedure
105593>>>>>
105593>>>>>    Procedure DbTypeUpdate Integer iDbType String sDriverID
105595>>>>>    End_Procedure
105596>>>>>
105596>>>>>    Procedure ReadConnectionData String[] sConnectionData
105598>>>>>        Integer iItem
105598>>>>>        Get piItem to iItem
105599>>>>>        Set Value to sConnectionData[iItem]
105600>>>>>    End_Procedure
105601>>>>>
105601>>>>>    Procedure WriteConnectionData String[] ByRef sConnectionData
105603>>>>>        String sValue
105603>>>>>        Integer iItem
105603>>>>>        Get piItem to iItem
105604>>>>>        Get Value to sValue
105605>>>>>        Move sValue to sConnectionData[iItem]
105606>>>>>    End_Procedure
105607>>>>>
105607>>>>>//    Procedure Set psToolTip String sToolTip
105607>>>>>//        String sStatusHelp
105607>>>>>//
105607>>>>>//        Get Status_Help to sStatusHelp
105607>>>>>//        If (sStatusHelp = "") Begin
105607>>>>>//            Set Status_Help to sToolTip
105607>>>>>//        End
105607>>>>>//
105607>>>>>//        Forward Set psToolTip to sToolTip
105607>>>>>//    End_Procedure
105607>>>>>//
105607>>>>>//    // Fix for a bug when using manifest files & running Vista and above.
105607>>>>>//    // The bug being that the focus rectangle doesn't show.
105607>>>>>//    Procedure Page Integer iPageObject
105607>>>>>//        Handle hWnd
105607>>>>>//        Integer iRet iState
105607>>>>>//
105607>>>>>//        Forward Send Page iPageObject
105607>>>>>//
105607>>>>>//        If (iPageObject) Begin
105607>>>>>//            Get Window_Handle to hWnd
105607>>>>>//            If (hWnd) Begin
105607>>>>>//                Move (SendMessage(hWnd, WM_QUERYUISTATE, 0, 0)) to iRet
105607>>>>>//                If (iRet iand UISF_HIDEFOCUS) Begin
105607>>>>>//                    Move (UIS_CLEAR + (UISF_HIDEFOCUS * 65536)) to iState
105607>>>>>//                    Move (SendMessage(hWnd, WM_UPDATEUISTATE, iState, 0)) to iRet
105607>>>>>//                End
105607>>>>>//            End
105607>>>>>//        End
105607>>>>>//    End_Procedure
105607>>>>>
105607>>>>>End_Class
105608>>>Use cSQLForm.pkg
Including file: cSQLForm.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLForm.pkg)
105608>>>>>Use Windows.pkg
105608>>>>>
105608>>>>>Class cSQLForm is a Form
105609>>>>>    Procedure Construct_Object
105611>>>>>        Forward Send Construct_Object
105613>>>>>
105613>>>>>        // This will shadow the label if the form itself has its Enabled_State=False
105613>>>>>        Property Boolean pbAutoShadowLabelObject True
105614>>>>>
105614>>>>>        // The piItem should be set to the object's corresponding tSQLConnection member (One based)
105614>>>>>        Property Integer piItem
105615>>>>>
105615>>>>>        Set Label_Justification_Mode to JMode_Right
105616>>>>>        Set Label_Col_Offset to 2
105617>>>>>    End_Procedure
105618>>>>>
105618>>>>>    Procedure End_Construct_Object
105620>>>>>        Boolean bAutoShadowLabelObject
105620>>>>>        Get pbAutoShadowLabelObject to bAutoShadowLabelObject
105621>>>>>        If (bAutoShadowLabelObject = True) Begin
105623>>>>>            Set Private.Label_Shadow_Display_Mode to TBSHADOW_ON_LOCAL
105624>>>>>        End
105624>>>>>>
105624>>>>>        Forward Send End_Construct_Object
105626>>>>>    End_Procedure
105627>>>>>
105627>>>>>    Procedure DbTypeUpdate Integer iDbType String sDriverID
105629>>>>>    End_Procedure
105630>>>>>
105630>>>>>    Procedure ReadConnectionData String[] sConnectionData
105632>>>>>        Integer iItem
105632>>>>>        Get piItem to iItem
105633>>>>>        Set Value to sConnectionData[iItem]
105634>>>>>    End_Procedure
105635>>>>>
105635>>>>>    Procedure WriteConnectionData String[] ByRef sConnectionData
105637>>>>>        String sValue
105637>>>>>        Integer iItem
105637>>>>>        Get piItem to iItem
105638>>>>>        Get Value to sValue
105639>>>>>        Move sValue to sConnectionData[iItem]
105640>>>>>    End_Procedure
105641>>>>>
105641>>>>>    Procedure Set psToolTip String sToolTip
105643>>>>>        String sStatusHelp
105643>>>>>
105643>>>>>        Get Status_Help to sStatusHelp
105644>>>>>        If (sStatusHelp = "") Begin
105646>>>>>            Set Status_Help to sToolTip
105647>>>>>        End
105647>>>>>>
105647>>>>>
105647>>>>>        Forward Set psToolTip to sToolTip
105649>>>>>    End_Procedure
105650>>>>>
105650>>>>>End_Class
105651>>>Use cSQLConnectionHandler.pkg
105651>>>Use cDbUpdateFunctionLibrary.pkg
105651>>>Use cDbUpdateDatabaseDriver.pkg
105651>>>Use DatabaseSelection.dg
Including file: DatabaseSelection.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DatabaseSelection.dg)
105651>>>>>Use Windows.pkg
105651>>>>>Use cCJGridPromptList.pkg
Including file: cCJGridPromptList.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cCJGridPromptList.pkg)
105651>>>>>>>Use Windows.pkg
105651>>>>>>>Use cCJGrid.pkg
105651>>>>>>>
105651>>>>>>>
105651>>>>>>>
105651>>>>>>>Class cCJGridPromptList is a cCJGrid
105652>>>>>>>    
105652>>>>>>>    Procedure Construct_Object
105654>>>>>>>        Forward Send Construct_Object
105656>>>>>>>        
105656>>>>>>>        Property Boolean pbAutoSeed True     // if we should seed list from invoking data
105657>>>>>>>        Property Boolean Private_pbAutoOrdering True
105658>>>>>>>        Property Boolean pbAutoSearch True  // pops up search window
105659>>>>>>>        Property Integer peUpdateMode umPromptValue
105660>>>>>>>        Property Integer piUpdateColumn 0
105661>>>>>>>        Property Integer piInitialColumn -1
105662>>>>>>>        Property String  psSeedValue ''
105663>>>>>>>        Property Handle phmPromptUpdateCallback 0
105664>>>>>>>        Property Integer phoInvokingObject
105665>>>>>>>        
105665>>>>>>>        Property Boolean pbStoredAutoSeed
105666>>>>>>>        Property Boolean pbStoredAutoOrdering
105667>>>>>>>        Property Boolean pbStoredAutoSearch
105668>>>>>>>        Property Integer peStoredUpdateMode
105669>>>>>>>        Property Integer piStoredUpdateColumn
105670>>>>>>>        Property Integer piStoredInitialColumn
105671>>>>>>>        Property Handle  phmStoredPromptUpdateCallback
105672>>>>>>>        Property Boolean pbStoredSelectionEnable
105673>>>>>>>        Property Boolean pbStoredMultipleSelection
105674>>>>>>>        
105674>>>>>>>        // internally set by list
105674>>>>>>>        // these must be set upon closing the list and can be used for manual list updates
105674>>>>>>>        Property Boolean pbCanceled
105675>>>>>>>        Property Integer[] pSelectedRows
105676>>>>>>>        
105676>>>>>>>        Property Boolean pbNeedsNewOrdering
105677>>>>>>>        Property Boolean pbRequestSearch
105678>>>>>>>        Property tGridKeyPair[] pSearchKeys
105679>>>>>>>        
105679>>>>>>>        // these properties makes a prompt list a prompt list
105679>>>>>>>        // and should not be changed.
105679>>>>>>>        Set pbEditOnKeyNavigation to False
105680>>>>>>>        Set pbEditOnClick to False
105681>>>>>>>        Set pbReadOnly to True
105682>>>>>>>        Set pbFocusSubItems to True
105683>>>>>>>        
105683>>>>>>>        // these could maybe be changed
105683>>>>>>>        Set pbShadeSortColumn to True
105684>>>>>>>        Set pbHeaderReorders to True
105685>>>>>>>        Set pbHeaderTogglesDirection to True
105686>>>>>>>        Set pbHeaderSelectsColumn to True
105687>>>>>>>        Set peHorizontalGridStyle to xtpGridNoLines
105688>>>>>>>        Set piFocusCellBackColor to clNone
105689>>>>>>>        Set piFocusCellForeColor to clNone
105690>>>>>>>        Set piFocusCellRectangleColor to clBlack
105691>>>>>>>        Set pbUseFocusCellRectangle to False
105692>>>>>>>        Set pbSelectionEnable to True
105693>>>>>>>        
105693>>>>>>>        On_Key kEnter Send Ok
105694>>>>>>>        On_Key kCancel Send Cancel
105695>>>>>>>        
105695>>>>>>>    End_Procedure
105696>>>>>>>    
105696>>>>>>>    // reorder list automatically on column change
105696>>>>>>>    // this also set pbFocusSubItems which is required to make the two states work
105696>>>>>>>    Procedure Set pbAutoOrdering Boolean bAutoOrder
105698>>>>>>>        Set Private_pbAutoOrdering to bAutoOrder
105699>>>>>>>        Set pbFocusSubItems to bAutoOrder
105700>>>>>>>    End_Procedure
105701>>>>>>>    
105701>>>>>>>    Function pbAutoOrdering Returns Boolean
105703>>>>>>>        Boolean bAutoOrder
105703>>>>>>>        Get Private_pbAutoOrdering to bAutoOrder
105704>>>>>>>        Function_Return bAutoOrder
105705>>>>>>>    End_Function
105706>>>>>>>    
105706>>>>>>>    // augmented to handle auto-ordering and invoking the search popup list
105706>>>>>>>    Procedure OnIdle
105708>>>>>>>        Boolean bNeedsReorder bSearch bOldToggle
105708>>>>>>>        Handle hoCol
105708>>>>>>>        Integer iKy1 iKy2 iCol
105708>>>>>>>        
105708>>>>>>>        Get pbNeedsNewOrdering to bNeedsReorder
105709>>>>>>>        If bNeedsReorder Begin
105711>>>>>>>            Get SelectedColumn to iCol
105712>>>>>>>            If (iCol<>-1) Begin
105714>>>>>>>                
105714>>>>>>>                Get pbHeaderTogglesDirection to bOldToggle
105715>>>>>>>                Set pbHeaderTogglesDirection to False
105716>>>>>>>                Send HeaderReorder iCol
105717>>>>>>>                Set pbHeaderTogglesDirection to bOldToggle
105718>>>>>>>                
105718>>>>>>>                Set pbNeedsNewOrdering to False
105719>>>>>>>            End
105719>>>>>>>>
105719>>>>>>>        End
105719>>>>>>>>
105719>>>>>>>        
105719>>>>>>>        Get pbRequestSearch to bSearch
105720>>>>>>>        If bSearch Begin
105722>>>>>>>            Send Request_SearchEx // will use the keys pSearchKeys as eed
105723>>>>>>>        End
105723>>>>>>>>
105723>>>>>>>        
105723>>>>>>>        Forward Send OnIdle
105725>>>>>>>    End_Procedure
105726>>>>>>>    
105726>>>>>>>    Procedure OnStoreDefaults
105728>>>>>>>        Integer iVal
105728>>>>>>>        Boolean bVal
105728>>>>>>>        
105728>>>>>>>        Get pbAutoSeed to bVal
105729>>>>>>>        Set pbStoredAutoSeed to bVal
105730>>>>>>>        
105730>>>>>>>        Get pbAutoOrdering to bVal
105731>>>>>>>        Set pbStoredAutoOrdering to bVal
105732>>>>>>>        
105732>>>>>>>        Get pbAutoSearch to bVal
105733>>>>>>>        Set pbStoredAutoSearch to bVal
105734>>>>>>>        
105734>>>>>>>        Get peUpdateMode to iVal
105735>>>>>>>        Set peStoredUpdateMode to iVal
105736>>>>>>>        
105736>>>>>>>        Get piUpdateColumn to iVal
105737>>>>>>>        Set piStoredUpdateColumn to iVal
105738>>>>>>>        
105738>>>>>>>        Get piInitialColumn to iVal
105739>>>>>>>        Set piStoredInitialColumn to iVal
105740>>>>>>>        
105740>>>>>>>        Get phmPromptUpdateCallback to iVal
105741>>>>>>>        Set phmStoredPromptUpdateCallback to iVal
105742>>>>>>>        
105742>>>>>>>        Get pbSelectionEnable to bVal
105743>>>>>>>        Set pbStoredSelectionEnable to bVal
105744>>>>>>>        
105744>>>>>>>        Get pbMultipleSelection to bVal
105745>>>>>>>        Set pbStoredMultipleSelection to bVal
105746>>>>>>>        
105746>>>>>>>    End_Procedure
105747>>>>>>>    
105747>>>>>>>    Procedure OnRestoreDefaults
105749>>>>>>>        Integer iVal
105749>>>>>>>        Boolean bVal
105749>>>>>>>        
105749>>>>>>>        Get pbStoredAutoSeed to bVal
105750>>>>>>>        Set pbAutoSeed to bVal
105751>>>>>>>        
105751>>>>>>>        Get pbStoredAutoOrdering to bVal
105752>>>>>>>        Set pbAutoOrdering to bVal
105753>>>>>>>        
105753>>>>>>>        Get pbStoredAutoSearch to bVal
105754>>>>>>>        Set pbAutoSearch to bVal
105755>>>>>>>        
105755>>>>>>>        Get peStoredUpdateMode to iVal
105756>>>>>>>        Set peUpdateMode to iVal
105757>>>>>>>        
105757>>>>>>>        Get piStoredInitialColumn to iVal
105758>>>>>>>        Set piInitialColumn to iVal
105759>>>>>>>        
105759>>>>>>>        Get phmStoredPromptUpdateCallback to iVal
105760>>>>>>>        Set phmPromptUpdateCallback to iVal
105761>>>>>>>        
105761>>>>>>>        Get pbStoredSelectionEnable to bVal
105762>>>>>>>        Set pbSelectionEnable to bVal
105763>>>>>>>        
105763>>>>>>>        Get pbStoredMultipleSelection to bVal
105764>>>>>>>        Set pbMultipleSelection to bVal
105765>>>>>>>        
105765>>>>>>>    End_Procedure
105766>>>>>>>    
105766>>>>>>>    // finds the target seed value in the updatecolumn. If we autoseed and there is a
105766>>>>>>>    // seed value (psSeedValue), attempt to find GE that value, else move to first row
105766>>>>>>>    // Suitable for augmentation
105766>>>>>>>    Procedure OnSeedData
105768>>>>>>>        Integer iUpdateColumn iSortColumn
105768>>>>>>>        Boolean bSeed bAuto
105768>>>>>>>        String sValue
105768>>>>>>>        Handle hoCol
105768>>>>>>>        
105768>>>>>>>        Get piUpdateColumn to iUpdateColumn
105769>>>>>>>        Get psSeedValue to sValue
105770>>>>>>>        Get pbAutoSeed to bSeed
105771>>>>>>>        Get piSortColumn to iSortColumn
105772>>>>>>>        Get pbAutoOrdering to bAuto
105773>>>>>>>        // if not yet sorted and this is auto ordering we will
105773>>>>>>>        // sort the data for the search column. We do this to make the
105773>>>>>>>        // column search GE logic work properly.
105773>>>>>>>        If (bSeed and bAuto and iUpdateColumn<>-1 and iSortColumn<>iUpdateColumn) Begin
105775>>>>>>>            Get ColumnObject iUpdateColumn to hoCol
105776>>>>>>>            Send SortGridByColumn hoCol False
105777>>>>>>>        End
105777>>>>>>>>
105777>>>>>>>        
105777>>>>>>>        If (bSeed and sValue<>"" and iUpdateColumn<>-1) Begin
105779>>>>>>>            Send RequestFindColumnValue iUpdateColumn sValue True 0
105780>>>>>>>        End
105780>>>>>>>>
105780>>>>>>>        Else Begin
105781>>>>>>>            Send MovetoFirstRow
105782>>>>>>>        End
105782>>>>>>>>
105782>>>>>>>        
105782>>>>>>>    End_Procedure
105783>>>>>>>    
105783>>>>>>>    Procedure OnMoveValueOutByValue
105785>>>>>>>        String sValue
105785>>>>>>>        Handle hoInvokingObject hoCol  hoDataSource
105785>>>>>>>        Integer iRow iCol
105785>>>>>>>        Integer[] SelRowsIndexes
105786>>>>>>>        
105786>>>>>>>        Get phoInvokingObject to hoInvokingObject
105787>>>>>>>        Get pSelectedRows to SelRowsIndexes
105788>>>>>>>        If (SizeOfArray(SelRowsIndexes)>0) Begin
105790>>>>>>>            Get piUpdateColumn to iCol
105791>>>>>>>            Get ColumnObject iCol to hoCol
105792>>>>>>>            Get RowValue of hoCol SelRowsIndexes[0] to sValue
105793>>>>>>>            Set Value of hoInvokingObject to sValue
105794>>>>>>>            Set Item_Changed_State of hoInvokingObject to True
105795>>>>>>>        End
105795>>>>>>>>
105795>>>>>>>    End_Procedure
105796>>>>>>>    
105796>>>>>>>    Procedure OnMoveValueOutByCustom
105798>>>>>>>    End_Procedure
105799>>>>>>>    
105799>>>>>>>    // augment to popup a search window when allowed
105799>>>>>>>    Procedure OnComKeyDown Short ByRef llKeyCode Short llShift
105801>>>>>>>        Boolean bSubFocus bAutoSearch bChar
105801>>>>>>>        Integer iVal
105801>>>>>>>        
105801>>>>>>>        Get pbFocusSubItems to bSubFocus
105802>>>>>>>        Get pbAutoSearch to bAutoSearch
105803>>>>>>>        Forward Send OnComKeyDown llKeyCode llShift
105805>>>>>>>        If (bAutoSearch and not(bSubFocus)) Begin
105807>>>>>>>            If ((llShift iand 6)=0) Begin // skip alt and ctrl
105809>>>>>>>                Get GetVKeyToAnsi llKeyCode llShift to iVal
105810>>>>>>>                Move (iVal<>0) to bChar
105811>>>>>>>            End
105811>>>>>>>>
105811>>>>>>>            If bChar Begin
105813>>>>>>>                // this can get called multiple times before a search dialog pops up
105813>>>>>>>                Send AddToSearchKeys llKeyCode llShift
105814>>>>>>>            End
105814>>>>>>>>
105814>>>>>>>        End
105814>>>>>>>>
105814>>>>>>>    End_Procedure
105815>>>>>>>    
105815>>>>>>>    Procedure OnComRequestEdit Variant llRow Variant llColumn Variant llItem Boolean ByRef llCancel
105817>>>>>>>        Boolean bAutoSearch
105817>>>>>>>        Integer iKeyCode iShiftCode
105817>>>>>>>        Get pbAutoSearch to bAutoSearch
105818>>>>>>>        If bAutoSearch Begin
105820>>>>>>>            // this can get called multiple times before a search dialog pops up
105820>>>>>>>            Get piLastKey to iKeyCode
105821>>>>>>>            Get piLastKey2 to iShiftCode
105822>>>>>>>            Send AddToSearchKeys iKeyCode iShiftCode
105823>>>>>>>        End
105823>>>>>>>>
105823>>>>>>>        Move True to llCancel
105824>>>>>>>    End_Procedure
105825>>>>>>>    
105825>>>>>>>    Procedure OnComRowDblClick Variant llRow Variant llItem
105827>>>>>>>        Send ClearSearchRequest // kill any deferred search popup
105828>>>>>>>        Forward Send OnComRowDblClick llRow llItem
105830>>>>>>>    End_Procedure
105831>>>>>>>    
105831>>>>>>>    Procedure OnRowDoubleClick Integer iRow Integer iCol
105833>>>>>>>        Send Ok
105834>>>>>>>    End_Procedure
105835>>>>>>>    
105835>>>>>>>    
105835>>>>>>>    // we don't want a menu for prompt lists
105835>>>>>>>    Function CreateContextMenu Returns Handle
105837>>>>>>>        Function_Return 0
105838>>>>>>>    End_Function
105839>>>>>>>    
105839>>>>>>>    // if we use auto-ordering, change the order when the column changes
105839>>>>>>>    Procedure ColumnChanged Integer iOld Integer iNew
105841>>>>>>>        Boolean bAutoOrder
105841>>>>>>>        Forward Send ColumnChanged iOld iNew
105843>>>>>>>        Get pbAutoOrdering to bAutoOrder
105844>>>>>>>        If bAutoOrder Begin
105846>>>>>>>            // will be reordered in idle event
105846>>>>>>>            Set pbNeedsNewOrdering to True
105847>>>>>>>        End
105847>>>>>>>>
105847>>>>>>>    End_Procedure
105848>>>>>>>    
105848>>>>>>>    
105848>>>>>>>    Procedure Add_Focus Handle hoParent Returns Integer
105850>>>>>>>        Integer eMode
105850>>>>>>>        Integer[] SelRowsIndexes
105851>>>>>>>        Set pbCanceled to True // assume cancel unless changed
105852>>>>>>>        Set pSelectedRows to SelRowsIndexes // empty
105853>>>>>>>        Get peUpdateMode to eMode
105854>>>>>>>        If (eMode<>umPromptNonInvoking) Begin
105856>>>>>>>            Send OnStoreDefaults
105857>>>>>>>        End
105857>>>>>>>>
105857>>>>>>>        Send InitializePromptList
105858>>>>>>>        Forward Send Add_Focus hoParent
105860>>>>>>>        Send LoadData
105861>>>>>>>        Set psSeedValue to ""
105862>>>>>>>    End_Procedure
105863>>>>>>>    
105863>>>>>>>    // called before the list is activated.
105863>>>>>>>    Procedure InitializePromptList
105865>>>>>>>        Integer hoInvokingObject
105865>>>>>>>        Boolean bAutoColumn bAutoSeed
105865>>>>>>>        Integer i iOldMode eUpdateMode
105865>>>>>>>        String sValue
105865>>>>>>>        
105865>>>>>>>        Get peUpdateMode to eUpdateMode
105866>>>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
105868>>>>>>>            Get Focus of Desktop to hoInvokingObject
105869>>>>>>>            If (hoInvokingObject<=Desktop) Begin
105871>>>>>>>                Error DFERR_PROGRAM "Prompt list has no invoking object"
105872>>>>>>>>
105872>>>>>>>                Procedure_Return
105873>>>>>>>            End
105873>>>>>>>>
105873>>>>>>>            
105873>>>>>>>            Set phoInvokingObject to hoInvokingObject
105874>>>>>>>            
105874>>>>>>>            Send Prompt_Callback to hoInvokingObject Self
105875>>>>>>>            Get peUpdateMode to eUpdateMode
105876>>>>>>>        End
105876>>>>>>>>
105876>>>>>>>        
105876>>>>>>>        Send ClearSearchRequest // clear the search keys
105877>>>>>>>        Set pbNeedsNewOrdering to False
105878>>>>>>>        
105878>>>>>>>        Get pbAutoSeed to bAutoSeed
105879>>>>>>>        
105879>>>>>>>        If (eUpdateMode=umPromptValue) Begin // else not used here intentionally
105881>>>>>>>            Get Value of hoInvokingObject to sValue
105882>>>>>>>            Set psSeedValue to sValue
105883>>>>>>>        End
105883>>>>>>>>
105883>>>>>>>        
105883>>>>>>>    End_Procedure
105884>>>>>>>    
105884>>>>>>>    // called after list is created and active. Load Data, seed list, select start column, etc.
105884>>>>>>>    Procedure LoadData
105886>>>>>>>        Handle hoInvokingObject hoDataSource hoInitialColumn
105886>>>>>>>        Integer iUpdateColumn iRows iInitialColumn iInitialOrder
105886>>>>>>>        Integer eUpdateMode
105886>>>>>>>        Boolean bAutoSeed bAutoColumn bCancel bSubFocus bAutoOrder
105886>>>>>>>        
105886>>>>>>>        Get phoDataSource to hoDataSource
105887>>>>>>>        Get peUpdateMode to eUpdateMode
105888>>>>>>>        Get phoInvokingObject to hoInvokingObject
105889>>>>>>>        Get pbAutoSeed to bAutoSeed
105890>>>>>>>        Get piInitialColumn to iInitialColumn
105891>>>>>>>        Get piUpdateColumn to iUpdateColumn
105892>>>>>>>        Get RowCount of hoDataSource to iRows
105893>>>>>>>        
105893>>>>>>>        // We need an initial column. if you specified an initial column that will get used for the start column
105893>>>>>>>        // and the initial sort order. If you did not, which is typical, it will use the update column
105893>>>>>>>        If (iInitialColumn=-1) Begin
105895>>>>>>>            Move iUpdateColumn to iInitialColumn
105896>>>>>>>        End
105896>>>>>>>>
105896>>>>>>>        If (iInitialColumn>=0) Begin
105898>>>>>>>            Get ColumnObject iInitialColumn to hoInitialColumn
105899>>>>>>>            Set pbVisible of hoInitialColumn to True // initial column should be visible
105900>>>>>>>        End
105900>>>>>>>>
105900>>>>>>>        Send OnSeedData // find a good starting place for the row
105901>>>>>>>        Get pbFocusSubItems to bSubFocus
105902>>>>>>>        If bSubFocus Begin
105904>>>>>>>            // if column focus, which is normal, go to initialcolumn
105904>>>>>>>            If hoInitialColumn Begin
105906>>>>>>>                Get MoveToColumnObject hoInitialColumn to bCancel
105907>>>>>>>            End
105907>>>>>>>>
105907>>>>>>>            Else Begin
105908>>>>>>>                Send MoveToFirstEnterableColumn
105909>>>>>>>            End
105909>>>>>>>>
105909>>>>>>>        End
105909>>>>>>>>
105909>>>>>>>        
105909>>>>>>>    End_Procedure
105910>>>>>>>    
105910>>>>>>>    // This is only called in a successful close
105910>>>>>>>    Procedure ClosePromptList
105912>>>>>>>        Handle hoDataSource hoInvokingObject
105912>>>>>>>        Handle hmCallBack
105912>>>>>>>        Integer iRow eUpdateMode
105912>>>>>>>        Integer[] SelRowsIndexes
105913>>>>>>>        
105913>>>>>>>        Get phoDataSource to hoDataSource
105914>>>>>>>        Get phoInvokingObject to hoInvokingObject
105915>>>>>>>        
105915>>>>>>>        If (pbMultipleSelection(Self)) Begin
105917>>>>>>>            Get GetIndexesForSelectedRows to SelRowsIndexes
105918>>>>>>>        End
105918>>>>>>>>
105918>>>>>>>        Else Begin
105919>>>>>>>            Get SelectedRow of hoDataSource to iRow
105920>>>>>>>            If (iRow<>-1) Begin
105922>>>>>>>                Move iRow to SelRowsIndexes[0]
105923>>>>>>>            End
105923>>>>>>>>
105923>>>>>>>        End
105923>>>>>>>>
105923>>>>>>>        
105923>>>>>>>        Set pbCanceled to False
105924>>>>>>>        Set pSelectedRows to SelRowsIndexes
105925>>>>>>>        
105925>>>>>>>        Get peUpdateMode to eUpdateMode
105926>>>>>>>        // if non-invoking there is by definition, no move value out
105926>>>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
105928>>>>>>>            
105928>>>>>>>            If (eUpdateMode=umPromptValue) Begin
105930>>>>>>>                Send OnMoveValueOutByValue
105931>>>>>>>            End
105931>>>>>>>>
105931>>>>>>>            Else If (eUpdateMode=umPromptCustom) Begin
105934>>>>>>>                Send OnMoveValueOutByCustom
105935>>>>>>>            End
105935>>>>>>>>
105935>>>>>>>            Get phmPromptUpdateCallback to hmCallBack
105936>>>>>>>            If hmCallBack Begin
105938>>>>>>>                Send hmCallBack of hoInvokingObject Self
105939>>>>>>>            End
105939>>>>>>>>
105939>>>>>>>        End
105939>>>>>>>>
105939>>>>>>>        
105939>>>>>>>        Send Close_Panel
105940>>>>>>>    End_Procedure
105941>>>>>>>    
105941>>>>>>>    // augment to send OnRestoreDefaults.
105941>>>>>>>    Procedure Release_Focus
105943>>>>>>>        Integer eUpdateMode
105943>>>>>>>        Get peUpdateMode to eUpdateMode
105944>>>>>>>        Forward Send Release_Focus
105946>>>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
105948>>>>>>>            Send OnRestoreDefaults
105949>>>>>>>        End
105949>>>>>>>>
105949>>>>>>>    End_Procedure
105950>>>>>>>    
105950>>>>>>>    Function SelectedRowIds Returns RowID[]
105952>>>>>>>        RowID[] SelectedRowids
105953>>>>>>>        Integer[] SelectedRows
105954>>>>>>>        Integer i iRows
105954>>>>>>>        Handle hoDataSource
105954>>>>>>>        Get phoDataSource to hoDataSource
105955>>>>>>>        Get pSelectedRows to SelectedRows
105956>>>>>>>        Move (SizeOfArray(SelectedRows)) to iRows
105957>>>>>>>        For i from 0 to (iRows-1)
105963>>>>>>>>
105963>>>>>>>            Get RowTag of hoDataSource SelectedRows[i] to SelectedRowIds[i]
105964>>>>>>>        Loop
105965>>>>>>>>
105965>>>>>>>        Function_Return SelectedRowids
105966>>>>>>>    End_Function
105967>>>>>>>    
105967>>>>>>>    Function SelectedColumnValues Integer iCol Returns String[]
105969>>>>>>>        String[] SelectedValues
105970>>>>>>>        Integer[] SelectedRows
105971>>>>>>>        Integer i iRows
105971>>>>>>>        Handle hoCol
105971>>>>>>>        Get ColumnObject iCol to hoCol
105972>>>>>>>        Get pSelectedRows to SelectedRows
105973>>>>>>>        Move (SizeOfArray(SelectedRows)) to iRows
105974>>>>>>>        For i from 0 to (iRows-1)
105980>>>>>>>>
105980>>>>>>>            Get RowValue of hoCol SelectedRows[i] to SelectedValues[i]
105981>>>>>>>        Loop
105982>>>>>>>>
105982>>>>>>>        Function_Return SelectedValues
105983>>>>>>>    End_Function
105984>>>>>>>    
105984>>>>>>>    Procedure Ok Returns Integer
105986>>>>>>>        Send ClosePromptList
105987>>>>>>>    End_Procedure
105988>>>>>>>    
105988>>>>>>>    Procedure Cancel Returns Integer
105990>>>>>>>        Send Close_Panel
105991>>>>>>>    End_Procedure
105992>>>>>>>    
105992>>>>>>>    Procedure Search
105994>>>>>>>        Send Activate // give focus back to list so focus things are correct
105995>>>>>>>        Send Request_Search 0 0
105996>>>>>>>    End_Procedure
105997>>>>>>>    
105997>>>>>>>    // do a search using the current keys in the search key buffer for the sort column.
105997>>>>>>>    // Becaue this is called via an OnIdle it is possible to have multiple keys pressed before
105997>>>>>>>    // the OnIdle. These have been stored in pSearchKeys and will be passed to the popup dialog
105997>>>>>>>    Procedure Request_SearchEx
105999>>>>>>>        tGridKeyPair[] Keys
105999>>>>>>>        tGridKeyPair[] Keys
106000>>>>>>>        Integer iCol
106000>>>>>>>        Handle hoCol hoSearchDialog
106000>>>>>>>        Boolean bOk
106000>>>>>>>        String sValue
106000>>>>>>>        
106000>>>>>>>        Get piSortColumn to iCol
106001>>>>>>>        If (iCol<>-1) Begin
106003>>>>>>>            Get ColumnObject iCol to hoCol
106004>>>>>>>            Get pSearchKeys to Keys
106005>>>>>>>            Get CreateGridSearchDialogObject to hoSearchDialog
106006>>>>>>>            Get RequestGridSearchEx of hoSearchDialog Keys hoCol (&sValue) to bOk
106007>>>>>>>            If bOk Begin
106009>>>>>>>                Send RequestFindColumnValue iCol sValue True 0
106010>>>>>>>            End
106010>>>>>>>>
106010>>>>>>>            Send Destroy of hoSearchDialog
106011>>>>>>>        End
106011>>>>>>>>
106011>>>>>>>        Send ClearSearchRequest // clear the search keys
106012>>>>>>>    End_Procedure
106013>>>>>>>    
106013>>>>>>>    // set pbRequestSearch to true and add the keys to the search buffer.
106013>>>>>>>    Procedure AddToSearchKeys Integer iKeyCode Integer iShiftCode
106015>>>>>>>        tGridKeyPair[] Keys
106015>>>>>>>        tGridKeyPair[] Keys
106016>>>>>>>        tGridKeyPair KeyPair
106016>>>>>>>        tGridKeyPair KeyPair
106016>>>>>>>        Set pbRequestSearch to True
106017>>>>>>>        Move iKeyCode to KeyPair.KeyCode
106018>>>>>>>        Move iShiftCode to KeyPair.ShiftCode
106019>>>>>>>        Get pSearchKeys to Keys
106020>>>>>>>        Move KeyPair to Keys[SizeOfArray(Keys)]
106021>>>>>>>        Set pSearchKeys to Keys
106022>>>>>>>    End_Procedure
106023>>>>>>>    
106023>>>>>>>    Procedure ClearSearchRequest
106025>>>>>>>        tGridKeyPair[] SearchKeys
106025>>>>>>>        tGridKeyPair[] SearchKeys
106026>>>>>>>        Set pSearchKeys to SearchKeys
106027>>>>>>>        Set pbRequestSearch to False
106028>>>>>>>    End_Procedure
106029>>>>>>>    
106029>>>>>>>End_Class
106030>>>>>>>
106030>>>>>Use cDbUpdateFunctionLibrary.pkg
106030>>>>>Use MSSqldrv.pkg
106030>>>>>Use db2_drv.pkg
106030>>>>>Use odbc_drv.pkg
106030>>>>>Use cRDCModalPanel.pkg
Including file: cRDCModalPanel.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\DFAbout\cRDCModalPanel.pkg)
106030>>>>>>>//****************************************************************************
106030>>>>>>>// $Module type: Class
106030>>>>>>>// $Module name: cRDCModalPanel
106030>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International
106030>>>>>>>// Created     : 2014-03-17 @ 12:33
106030>>>>>>>//
106030>>>>>>>// Description :
106030>>>>>>>//
106030>>>>>>>// $Rev History:
106030>>>>>>>//    2014-03-17  Module header created
106030>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
106030>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
106030>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
106030>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
106030>>>>>>>// in the help folder for more details.
106030>>>>>>>//
106030>>>>>>>//****************************************************************************
106030>>>>>>>Use Windows.pkg
106030>>>>>>>Use cCJCommandBarSystem.pkg   
106030>>>>>>>Use cCJSkinFramework.pkg
106030>>>>>>>
106030>>>>>>>Class cRDCModalPanel is a ModalPanel
106031>>>>>>>
106031>>>>>>>    Procedure Construct_Object
106033>>>>>>>        Forward Send Construct_Object
106035>>>>>>>
106035>>>>>>>        Set Maximize_Icon to True
106036>>>>>>>        Set Minimize_Icon to False
106037>>>>>>>        Set Border_Style to Border_Thick
106038>>>>>>>        Set Locate_Mode to Center_On_Parent
106039>>>>>>>
106039>>>>>>>        Property String Private_Icon
106040>>>>>>>        Property Handle phoDialogCommandbar
106041>>>>>>>    End_Procedure
106042>>>>>>>
106042>>>>>>>    Procedure Set Icon String sIcon
106044>>>>>>>        Forward Set Icon to sIcon
106046>>>>>>>        Set Private_Icon to sIcon
106047>>>>>>>    End_Procedure
106048>>>>>>>
106048>>>>>>>    Function Icon Returns String
106050>>>>>>>        String sIcon
106050>>>>>>>        Get Private_Icon to sIcon
106051>>>>>>>        Function_Return sIcon
106052>>>>>>>    End_Function
106053>>>>>>>
106053>>>>>>>    Procedure Page Integer iPageObject
106055>>>>>>>        String sIcon
106055>>>>>>>        Integer hWnd
106055>>>>>>>        
106055>>>>>>>        Forward Send Page iPageObject
106057>>>>>>>        Get Private_Icon to sIcon
106058>>>>>>>        If (sIcon <> "") Begin
106060>>>>>>>            Set Icon to sIcon
106061>>>>>>>        End
106061>>>>>>>>
106061>>>>>>>
106061>>>>>>>        Get Window_Handle to hWnd
106062>>>>>>>
106062>>>>>>>        If ((ghoSkinFramework <> 0) and (hWnd <> 0)) Begin
106064>>>>>>>            Send ComRemoveWindow to ghoSkinFramework hWnd
106065>>>>>>>            Send ComApplyWindow  to ghoSkinFramework hWnd
106066>>>>>>>        End
106066>>>>>>>>
106066>>>>>>>    End_Procedure
106067>>>>>>>
106067>>>>>>>    // Put a status bar at the bottom of the panel, which makes
106067>>>>>>>    // status_help work and puts a gripper in the lower right corner.
106067>>>>>>>    Procedure End_Construct_Object
106069>>>>>>>        Integer iStyle iSize iOffset
106069>>>>>>>
106069>>>>>>>        Forward Send End_Construct_Object
106071>>>>>>>
106071>>>>>>>        Get Border_Style to iStyle
106072>>>>>>>        Move 8 to iOffset
106073>>>>>>>        If (iStyle = Border_Thick) Begin
106075>>>>>>>            Object oDialogCommandbar is a cCJCommandBarSystem
106077>>>>>>>                Object oStatusBar is a cCJStatusBar
106079>>>>>>>                    Set phoDialogCommandbar to Self
106080>>>>>>>                    Object oStatusIdle is a cCJStatusBarPane
106082>>>>>>>                        Set piId to sbpIDIdlePane
106083>>>>>>>                        Set pbStyleStretch to True
106084>>>>>>>                    End_Object
106085>>>>>>>                End_Object
106086>>>>>>>            End_Object
106087>>>>>>>            Get Size to iSize
106088>>>>>>>            Set Size to (Hi(iSize) + iOffset) (Low(iSize))
106089>>>>>>>            Set piMinSize to (Hi(iSize) + iOffset) (Low(iSize))
106090>>>>>>>        End
106090>>>>>>>>
106090>>>>>>>
106090>>>>>>>    End_Procedure
106091>>>>>>>
106091>>>>>>>    Procedure Popup
106093>>>>>>>        Set Statusbar_Id to (phoDialogCommandbar(Self))
106094>>>>>>>        Forward Send Popup
106096>>>>>>>    End_Procedure
106097>>>>>>>
106097>>>>>>>End_Class
106098>>>>>
106098>>>>>Object oDatabaseSelection_sl is a cRDCModalPanel
106100>>>>>    Set Label to "SQL Database Selection"
106101>>>>>    Set Size to 119 183
106102>>>>>    Set piMinSize to 89 170
106103>>>>>    Set Location to 2 2
106104>>>>>    Set Border_Style to Border_Thick
106105>>>>>    Set Icon to "DatabaseLookup1.ico"
106106>>>>>
106106>>>>>    Property String[] psTheData
106108>>>>>
106108>>>>>    If (ghoDbUpdateFunctionLibrary = 0) Begin
106110>>>>>        Object oDbUpateFunctionLibrary is a cDbUpdateFunctionLibrary
106112>>>>>        End_Object
106113>>>>>    End
106113>>>>>>
106113>>>>>
106113>>>>>    Object oSelList is a cCJGridPromptList
106115>>>>>        Set Size to 89 167
106116>>>>>        Set Location to 6 6
106117>>>>>        Set peAnchors to anAll
106118>>>>>        Set pbAllowColumnRemove to False
106119>>>>>        Set pbUseAlternateRowBackgroundColor to True
106120>>>>>        Set pbGrayIfDisable to False
106121>>>>>        Set pbHeaderReorders to False
106122>>>>>        Set pbHeaderSelectsColumn to False
106123>>>>>        Set pbHeaderTogglesDirection to False
106124>>>>>        Set pbShadeSortColumn to False
106125>>>>>        Set piFocusCellBackColor to clDkGray
106126>>>>>
106126>>>>>        Object oName is a cCJGridColumn
106128>>>>>            Set piWidth to 334
106129>>>>>            Set psCaption to "Database Name"
106130>>>>>        End_Object
106131>>>>>
106131>>>>>        Procedure Activating
106134>>>>>            tDataSourceRow[] MyData
106134>>>>>            tDataSourceRow[] MyData
106135>>>>>            Handle hoDataSource
106135>>>>>            String[] sTheData
106136>>>>>            Integer iCount iSize
106136>>>>>
106136>>>>>            Send Cursor_Wait of Cursor_Control
106137>>>>>            Forward Send Activating
106139>>>>>
106139>>>>>            Get psTheData to sTheData
106140>>>>>            Move (SizeOfArray(sTheData)) to iSize
106141>>>>>            Decrement iSize
106142>>>>>            For iCount from 0 to iSize
106148>>>>>>
106148>>>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
106149>>>>>            Loop
106150>>>>>>
106150>>>>>
106150>>>>>            Get phoDataSource to hoDataSource
106151>>>>>            Send InitializeData of hoDataSource MyData
106152>>>>>            Send Cursor_Ready of Cursor_Control
106153>>>>>        End_Procedure
106154>>>>>
106154>>>>>    End_Object
106155>>>>>
106155>>>>>    Object oOK_Btn is a Button
106157>>>>>        Set Size to 14 50
106158>>>>>        Set Label    to "&OK"
106159>>>>>        Set Location to 98 68
106160>>>>>        Set peAnchors To anBottomRight
106161>>>>>
106161>>>>>        Procedure OnClick
106164>>>>>            Send Ok of oSelList
106165>>>>>        End_Procedure
106166>>>>>
106166>>>>>    End_Object
106167>>>>>
106167>>>>>    Object oCancel_Btn is a Button
106169>>>>>        Set Size to 14 50
106170>>>>>        Set Label    to "&Cancel"
106171>>>>>        Set Location to 98 123
106172>>>>>        Set peAnchors to anBottomRight
106173>>>>>
106173>>>>>        Procedure OnClick
106176>>>>>            Send Close_Panel
106177>>>>>        End_Procedure
106178>>>>>
106178>>>>>    End_Object
106179>>>>>
106179>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
106180>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
106181>>>>>End_Object
106182>>>Use ServerSelection.dg
Including file: ServerSelection.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ServerSelection.dg)
106182>>>>>Use Windows.pkg
106182>>>>>Use cCJGridPromptList.pkg
106182>>>>>Use MSSqldrv.pkg
106182>>>>>Use db2_drv.pkg
106182>>>>>Use odbc_drv.pkg    
106182>>>>>Use cRDCModalPanel.pkg
106182>>>>>Use cDbUpdateFunctionLibrary.pkg
106182>>>>>
106182>>>>>Object oServerSelection_sl is a cRDCModalPanel
106184>>>>>    Set Size to 105 225
106185>>>>>    Set Label to "Database Server/DSN Selection"
106186>>>>>    Set piMinSize to 89 211
106187>>>>>    Set Location to 2 2
106188>>>>>    Set Icon to "ServerLookup1.ico"
106189>>>>>
106189>>>>>    Property String[] psTheData
106191>>>>>
106191>>>>>    Object oSelList is a cCJGridPromptList
106193>>>>>        Set Size to 72 215
106194>>>>>        Set Location to 6 6
106195>>>>>        Set peAnchors to anAll
106196>>>>>        Set pbAllowColumnRemove to False
106197>>>>>        Set pbUseAlternateRowBackgroundColor to True
106198>>>>>        Set pbGrayIfDisable to False
106199>>>>>        Set pbHeaderReorders to False
106200>>>>>        Set pbHeaderSelectsColumn to False
106201>>>>>        Set pbHeaderTogglesDirection to False
106202>>>>>        Set pbShadeSortColumn to False
106203>>>>>        Set piFocusCellBackColor to clDkGray
106204>>>>>
106204>>>>>        Object oName is a cCJGridColumn
106206>>>>>            Set piWidth to 358
106207>>>>>            Set psCaption to "Name"
106208>>>>>        End_Object
106209>>>>>
106209>>>>>        Procedure Activating
106212>>>>>            tDataSourceRow[] MyData
106212>>>>>            tDataSourceRow[] MyData
106213>>>>>            Handle hoDataSource
106213>>>>>            String[] sTheData
106214>>>>>            Integer iCount iSize
106214>>>>>
106214>>>>>            Send Cursor_Wait of Cursor_Control
106215>>>>>            Get psTheData to sTheData
106216>>>>>            Move (SizeOfArray(sTheData)) to iSize
106217>>>>>            Decrement iSize
106218>>>>>            For iCount from 0 to iSize
106224>>>>>>
106224>>>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
106225>>>>>            Loop
106226>>>>>>
106226>>>>>
106226>>>>>            Forward Send Activating
106228>>>>>
106228>>>>>            Get phoDataSource to hoDataSource
106229>>>>>            Send InitializeData of hoDataSource MyData
106230>>>>>            Send Cursor_Ready of Cursor_Control
106231>>>>>        End_Procedure
106232>>>>>
106232>>>>>    End_Object
106233>>>>>
106233>>>>>    Object oOK_Btn is a Button
106235>>>>>        Set Size to 14 50
106236>>>>>        Set Label    to "&OK"
106237>>>>>        Set Location to 85 116
106238>>>>>        Set peAnchors To anBottomRight
106239>>>>>
106239>>>>>        Procedure OnClick
106242>>>>>            Send Ok of oSelList
106243>>>>>        End_Procedure
106244>>>>>
106244>>>>>    End_Object
106245>>>>>
106245>>>>>    Object oCancel_Btn is a Button
106247>>>>>        Set Size to 14 50
106248>>>>>        Set Label    to "&Cancel"
106249>>>>>        Set Location to 85 171
106250>>>>>        Set peAnchors to anBottomRight
106251>>>>>
106251>>>>>        Procedure OnClick
106254>>>>>            Send Close_Panel
106255>>>>>        End_Procedure
106256>>>>>
106256>>>>>    End_Object
106257>>>>>
106257>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
106258>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
106259>>>>>End_Object
106260>>>Use TableSpaceSelection.dg
Including file: TableSpaceSelection.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\TableSpaceSelection.dg)
106260>>>>>Use Windows.pkg
106260>>>>>Use cCJGridPromptList.pkg     
106260>>>>>Use cRDCModalPanel.pkg
106260>>>>>Use cDbUpdateFunctionLibrary.pkg
106260>>>>>
106260>>>>>Object oTableSpaceSelection_sl is a cRDCModalPanel
106262>>>>>    Set Size to 118 177
106263>>>>>    Set Label to "SQL Tablespace Selection"
106264>>>>>    Set piMinSize to 89 177
106265>>>>>    Set Location to 2 2
106266>>>>>    Set Icon to "DatabaseLookup1.ico"
106267>>>>>
106267>>>>>    Property String[] psTheData
106269>>>>>
106269>>>>>    If (ghoDbUpdateFunctionLibrary = 0) Begin
106271>>>>>        Object oDbUpateFunctionLibrary is a cDbUpdateFunctionLibrary
106273>>>>>        End_Object
106274>>>>>    End
106274>>>>>>
106274>>>>>
106274>>>>>    Object oSelList is a cCJGridPromptList
106276>>>>>        Set Size to 89 167
106277>>>>>        Set Location to 6 6
106278>>>>>        Set peAnchors to anAll
106279>>>>>        Set pbAllowColumnRemove to False
106280>>>>>        Set pbUseAlternateRowBackgroundColor to True
106281>>>>>        Set pbGrayIfDisable to False
106282>>>>>        Set pbHeaderReorders to False
106283>>>>>        Set pbHeaderSelectsColumn to False
106284>>>>>        Set pbHeaderTogglesDirection to False
106285>>>>>        Set pbShadeSortColumn to False
106286>>>>>        Set piFocusCellBackColor to clDkGray
106287>>>>>
106287>>>>>        Object oName is a cCJGridColumn
106289>>>>>            Set piWidth to 334
106290>>>>>            Set psCaption to "Table Space Name"
106291>>>>>        End_Object
106292>>>>>
106292>>>>>        Procedure Activating
106295>>>>>            tDataSourceRow[] MyData
106295>>>>>            tDataSourceRow[] MyData
106296>>>>>            Handle hoDataSource
106296>>>>>            String[] sTheData
106297>>>>>            Integer iCount iSize
106297>>>>>
106297>>>>>            Send Cursor_Wait of Cursor_Control
106298>>>>>            Forward Send Activating
106300>>>>>
106300>>>>>            Get psTheData to sTheData
106301>>>>>            Move (SizeOfArray(sTheData)) to iSize
106302>>>>>            Decrement iSize
106303>>>>>            For iCount from 0 to iSize
106309>>>>>>
106309>>>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
106310>>>>>            Loop
106311>>>>>>
106311>>>>>
106311>>>>>            Get phoDataSource to hoDataSource
106312>>>>>            Send InitializeData of hoDataSource MyData
106313>>>>>            Send Cursor_Ready of Cursor_Control
106314>>>>>        End_Procedure
106315>>>>>
106315>>>>>    End_Object
106316>>>>>
106316>>>>>    Object oOK_Btn is a Button
106318>>>>>        Set Size to 14 50
106319>>>>>        Set Label    to "&OK"
106320>>>>>        Set Location to 98 68
106321>>>>>        Set peAnchors To anBottomRight
106322>>>>>
106322>>>>>        Procedure OnClick
106325>>>>>            Send Ok of oSelList
106326>>>>>        End_Procedure
106327>>>>>
106327>>>>>    End_Object
106328>>>>>
106328>>>>>    Object oCancel_Btn is a Button
106330>>>>>        Set Size to 14 50
106331>>>>>        Set Label    to "&Cancel"
106332>>>>>        Set Location to 98 123
106333>>>>>        Set peAnchors to anBottomRight
106334>>>>>
106334>>>>>        Procedure OnClick
106337>>>>>            Send Close_Panel
106338>>>>>        End_Procedure
106339>>>>>
106339>>>>>    End_Object
106340>>>>>
106340>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
106341>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
106342>>>>>End_Object
106343>>>Use SchemasSelection.dg
Including file: SchemasSelection.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\SchemasSelection.dg)
106343>>>>>Use Windows.pkg
106343>>>>>Use cCJGridPromptList.pkg  
106343>>>>>Use cRDCModalPanel.pkg
106343>>>>>Use cDbUpdateFunctionLibrary.pkg
106343>>>>>
106343>>>>>Object oSchemasSelection_sl is a cRDCModalPanel
106345>>>>>    Set Size to 118 177
106346>>>>>    Set Label to "SQL Schemas Selection"
106347>>>>>    Set piMinSize to 89 177
106348>>>>>    Set Location to 2 2
106349>>>>>    Set Icon to "DatabaseLookup1.ico"
106350>>>>>
106350>>>>>    Property String[] psTheData
106352>>>>>
106352>>>>>    If (ghoDbUpdateFunctionLibrary = 0) Begin
106354>>>>>        Object oDbUpateFunctionLibrary is a cDbUpdateFunctionLibrary
106356>>>>>        End_Object
106357>>>>>    End
106357>>>>>>
106357>>>>>
106357>>>>>    Object oSelList is a cCJGridPromptList
106359>>>>>        Set Size to 89 167
106360>>>>>        Set Location to 6 6
106361>>>>>        Set peAnchors to anAll
106362>>>>>        Set pbAllowColumnRemove to False
106363>>>>>        Set pbUseAlternateRowBackgroundColor to True
106364>>>>>        Set pbGrayIfDisable to False
106365>>>>>        Set pbHeaderReorders to False
106366>>>>>        Set pbHeaderSelectsColumn to False
106367>>>>>        Set pbHeaderTogglesDirection to False
106368>>>>>        Set pbShadeSortColumn to False
106369>>>>>        Set piFocusCellBackColor to clDkGray
106370>>>>>
106370>>>>>        Object oName is a cCJGridColumn
106372>>>>>            Set piWidth to 334
106373>>>>>            Set psCaption to "Schema Name"
106374>>>>>        End_Object
106375>>>>>
106375>>>>>        Procedure Activating
106378>>>>>            tDataSourceRow[] MyData
106378>>>>>            tDataSourceRow[] MyData
106379>>>>>            Handle hoDataSource
106379>>>>>            String[] sTheData
106380>>>>>            Integer iCount iSize
106380>>>>>
106380>>>>>            Send Cursor_Wait of Cursor_Control
106381>>>>>            Forward Send Activating
106383>>>>>
106383>>>>>            Get psTheData to sTheData
106384>>>>>
106384>>>>>            Move (SizeOfArray(sTheData)) to iSize
106385>>>>>            Decrement iSize
106386>>>>>            For iCount from 0 to iSize
106392>>>>>>
106392>>>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
106393>>>>>            Loop
106394>>>>>>
106394>>>>>
106394>>>>>            Get phoDataSource to hoDataSource
106395>>>>>            Send InitializeData of hoDataSource MyData
106396>>>>>            Send Cursor_Ready of Cursor_Control
106397>>>>>        End_Procedure
106398>>>>>
106398>>>>>    End_Object
106399>>>>>
106399>>>>>    Object oOK_Btn is a Button
106401>>>>>        Set Size to 14 50
106402>>>>>        Set Label    to "&OK"
106403>>>>>        Set Location to 98 68
106404>>>>>        Set peAnchors To anBottomRight
106405>>>>>
106405>>>>>        Procedure OnClick
106408>>>>>            Send Ok of oSelList
106409>>>>>        End_Procedure
106410>>>>>
106410>>>>>    End_Object
106411>>>>>
106411>>>>>    Object oCancel_Btn is a Button
106413>>>>>        Set Size to 14 50
106414>>>>>        Set Label    to "&Cancel"
106415>>>>>        Set Location to 98 123
106416>>>>>        Set peAnchors to anBottomRight
106417>>>>>
106417>>>>>        Procedure OnClick
106420>>>>>            Send Close_Panel
106421>>>>>        End_Procedure
106422>>>>>
106422>>>>>    End_Object
106423>>>>>
106423>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
106424>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
106425>>>>>End_Object
106426>>>Use cRDCHeaderGroup.pkg  
Including file: cRDCHeaderGroup.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cRDCHeaderGroup.pkg)
106426>>>>>//****************************************************************************
106426>>>>>// $Module type: Package
106426>>>>>// $Module name: cRDCHeaderGroup.pkg
106426>>>>>//
106426>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
106426>>>>>// Copyright (c) 2017 RDC Tools International
106426>>>>>// E-mail      : support@rdctools.com
106426>>>>>// Web-site    : http://www.rdctools.com
106426>>>>>//
106426>>>>>// Created     : 2017-01-05 @ 19:04 (Military date format - Year-Month-Day)
106426>>>>>//
106426>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
106426>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
106426>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
106426>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
106426>>>>>// in the help folder for more details.
106426>>>>>//
106426>>>>>//****************************************************************************
106426>>>>>Use Windows.pkg
106426>>>>>Use cCommandLinkButton.pkg
Including file: cCommandLinkButton.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cCommandLinkButton.pkg)
106426>>>>>>>// This requires version 6 of common controls (vista or windows server 2008). If used with
106426>>>>>>>// older versions you will just get a regular great big button.
106426>>>>>>>
106426>>>>>>>Use Windows.pkg
106426>>>>>>>Use CharTranslate.pkg
106426>>>>>>>
106426>>>>>>>Class cCommandLinkButton is a Button
106427>>>>>>>    
106427>>>>>>>    Procedure Construct_Object
106429>>>>>>>        Forward Send Construct_Object
106431>>>>>>>        Property String psPrivateNote
106432>>>>>>>    End_Procedure
106433>>>>>>>    
106433>>>>>>>    Procedure Set psNote String sNote
106435>>>>>>>        Boolean bSupported
106435>>>>>>>        Set psPrivateNote to sNote
106436>>>>>>>        Get IsExControlSupported to bSupported
106437>>>>>>>        If bSupported Begin
106439>>>>>>>            Send SetWinNote
106440>>>>>>>        End
106440>>>>>>>>
106440>>>>>>>    End_Procedure
106441>>>>>>>    
106441>>>>>>>    Procedure SetWinNote
106443>>>>>>>        WString wNote
106443>>>>>>>        Handle hWnd
106443>>>>>>>        Integer i
106443>>>>>>>        Pointer pVar
106443>>>>>>>        Get Form_Window_Handle 0 to hWnd
106444>>>>>>>        If hWnd Begin
106446>>>>>>>            Get psNote to wNote
106447>>>>>>>            Move (SendMessage(hwnd, BCM_SETNOTE, 0, AddressOf(wNote))) to i
106448>>>>>>>        End
106448>>>>>>>>
106448>>>>>>>    End_Procedure
106449>>>>>>>    
106449>>>>>>>    
106449>>>>>>>    Function psNote Returns String
106451>>>>>>>        Function_Return (psPrivateNote(Self))
106452>>>>>>>    End_Function
106453>>>>>>>    
106453>>>>>>>    
106453>>>>>>>    Procedure Page Integer iState
106455>>>>>>>        Integer i hWnd
106455>>>>>>>        Boolean bSupported
106455>>>>>>>        Get IsExControlSupported to bSupported
106456>>>>>>>        If (iState=1 and bSupported) Begin
106458>>>>>>>            Get form_style i to i
106459>>>>>>>            Set Form_Style 0 to (i ior (BS_COMMANDLINK + BS_FLAT))
106460>>>>>>>            Forward Send Page iState
106462>>>>>>>            Send SetWinNote
106463>>>>>>>        End
106463>>>>>>>>
106463>>>>>>>        Else Begin
106464>>>>>>>            Forward Send Page iState
106466>>>>>>>        End
106466>>>>>>>>
106466>>>>>>>    End_Procedure
106467>>>>>>>    
106467>>>>>>>End_Class
106468>>>>>
106468>>>>>Define clGreenGrey      for (RGB(64, 84, 93))
106468>>>>>Define clGreenGreyLight for (RGB(7, 117, 104))
106468>>>>>
106468>>>>>Class cRDCHeaderGroupImage is a cCommandLinkButton
106469>>>>>    Procedure Construct_Object
106471>>>>>        Forward Send Construct_Object
106473>>>>>
106473>>>>>        Set Size to 18 19
106474>>>>>        Set Focus_Mode to NonFocusable
106475>>>>>        Set peImageAlign to Button_ImageList_Align_Top
106476>>>>>        Set pbAutoResizeIcons to True
106477>>>>>    End_Procedure
106478>>>>>
106478>>>>>    Procedure OnClick
106480>>>>>        Broadcast Send Prompt of (Parent(Self))
106482>>>>>    End_Procedure
106483>>>>>
106483>>>>>    Procedure Set Bitmap String sBitmapName
106485>>>>>        Forward Set psImage to sBitmapName
106487>>>>>    End_Procedure
106488>>>>>
106488>>>>>    Procedure End_Construct_Object
106490>>>>>        Set pbShield to False
106491>>>>>        Forward Send End_Construct_Object
106493>>>>>    End_Procedure
106494>>>>>
106494>>>>>End_Class
106495>>>>>
106495>>>>>// Intermediate class - don't use.
106495>>>>>Class _cRDCHeaderGroup is a Container3d
106496>>>>>
106496>>>>>    Procedure Construct_Object
106498>>>>>        Forward Send Construct_Object
106500>>>>>
106500>>>>>        Property String private.psImage
106501>>>>>        Property String private.psLabel
106502>>>>>
106502>>>>>    End_Procedure
106503>>>>>
106503>>>>>    Procedure Set psImage String sImage
106505>>>>>        Set private.psImage to sImage
106506>>>>>    End_Procedure
106507>>>>>
106507>>>>>    Function psImage Returns String
106509>>>>>        Function_Return (private.psImage(Self))
106510>>>>>    End_Function
106511>>>>>
106511>>>>>    Procedure Set psLabel String sLabel
106513>>>>>        Set private.psLabel to sLabel
106514>>>>>    End_Procedure
106515>>>>>
106515>>>>>    Function psLabel Returns String
106517>>>>>        Function_Return (private.psLabel(Self))
106518>>>>>    End_Function
106519>>>>>
106519>>>>>    // Don't display but allow to use old "Label" syntax to set the value of the oInfo_tb object (header text)
106519>>>>>    Procedure Set Label String sLabel
106521>>>>>        Set psLabel to sLabel
106522>>>>>    End_Procedure
106523>>>>>
106523>>>>>    Function Label Returns String
106525>>>>>        Function_Return (private.psLabel(Self))
106526>>>>>    End_Function
106527>>>>>
106527>>>>>End_Class
106528>>>>>
106528>>>>>Register_Procedure NavigatePrevious
106528>>>>>Register_Procedure NavigateNext
106528>>>>>
106528>>>>>Class cRDCHeaderGroup is a _cRDCHeaderGroup
106529>>>>>
106529>>>>>    Procedure Construct_Object
106531>>>>>        Forward Send Construct_Object
106533>>>>>
106533>>>>>        Set peAnchors to anTopLeftRight
106534>>>>>        Set pbAcceptDropFiles to True
106535>>>>>        Set Border_Style to Border_Normal
106536>>>>>
106536>>>>>        Property Integer private.piColorOrg
106537>>>>>        Property Boolean private.pbIsHeaderGroup True // Don't touch!
106538>>>>>        Property String private.psToolTip ""
106539>>>>>
106539>>>>>        Property Integer piImageColOffset 4
106540>>>>>        Property Integer piImageRowOffset 0
106541>>>>>        Property String psNote ""
106542>>>>>        Property Boolean pbLargeImageSize True
106543>>>>>        Property Integer private.piLargeImageSize 24
106544>>>>>        Property Integer private.piSmallImageSize 16
106545>>>>>        Property Boolean pbUseHotspotColor False
106546>>>>>        Property Integer piHeaderHotspotColor clAqua
106547>>>>>        Property String private.psLabel ""
106548>>>>>        Property Integer piLabelColor clGreenGrey
106549>>>>>        Property Boolean pbLabelFontItalics False
106550>>>>>        Property Integer piLabelLargeFontHeight 12
106551>>>>>        Property Integer piLabelSmallFontHeight 10
106552>>>>>        Property Boolean pbUseLargeFontHeight False
106553>>>>>
106553>>>>>        Property Integer piLabelFontPointWeight fw_Bold
106554>>>>>        Property Integer piLabelColOffset 28
106555>>>>>        Property Integer piLabelRowOffset 4
106556>>>>>        Property Boolean pbCreateTooltipItem True
106557>>>>>
106557>>>>>        Set pbAcceptDropFiles to True
106558>>>>>
106558>>>>>        Send Define_ToolTip_Support_Mixin
106559>>>>>
106559>>>>>        // For the Studio to render the header image
106559>>>>>        Set Bitmap to "Default32x32.bmp"
106560>>>>>        // This doesn't work... I wonder if there's a way to "trick" the Studio
106560>>>>>        // to render some text in the header when in design mode?
106560>>>>>        Set Label to "HEADER TEXT"
106561>>>>>
106561>>>>>        On_Key kLeftArrow  Send NavigatePrevious
106562>>>>>        On_Key kUpArrow    Send NavigatePrevious
106563>>>>>        On_Key kRightArrow Send NavigateNext
106564>>>>>        On_Key kDownArrow  Send NavigateNext
106565>>>>>        On_Key kSwitch     Send Switch_Next_Area
106566>>>>>    End_Procedure
106567>>>>>
106567>>>>>    Import_Class_Protocol ToolTip_Support_Mixin
106568>>>>>
106568>>>>>    Procedure Set psImage String sImage
106570>>>>>        Set Bitmap to ""
106571>>>>>        Forward Set psImage to sImage
106573>>>>>    End_Procedure
106574>>>>>
106574>>>>>    Function psImage Returns String
106576>>>>>        Function_Return (psImage(Self))
106577>>>>>    End_Function
106578>>>>>
106578>>>>>    Procedure Set Label String sLabel
106580>>>>>        Forward Set psLabel to sLabel
106582>>>>>    End_Procedure
106583>>>>>
106583>>>>>    Procedure Set psToolTip String sToolTip
106585>>>>>        Set private.psToolTip to sToolTip
106586>>>>>    End_Procedure
106587>>>>>
106587>>>>>    Function psToolTip Returns String
106589>>>>>        Function_Return (private.psToolTip(Self))
106590>>>>>    End_Function
106591>>>>>
106591>>>>>    Procedure End_Construct_Object
106593>>>>>        String sNote sLabel
106593>>>>>        Boolean bUseLargeFontHeight bLargeImageSize bCreateTooltipItem
106593>>>>>        Integer iFontHeight iImageSize iLabelRowOffset iLabelColOffset iSize iTextOffset
106593>>>>>
106593>>>>>        Forward Send End_Construct_Object
106595>>>>>
106595>>>>>        Get piLabelColOffset to iLabelColOffset
106596>>>>>        Get pbUseLargeFontHeight to bUseLargeFontHeight
106597>>>>>        If (bUseLargeFontHeight = True) Begin
106599>>>>>            Get piLabelLargeFontHeight to iFontHeight
106600>>>>>            Move 8 to iLabelRowOffset
106601>>>>>        End
106601>>>>>>
106601>>>>>        Else Begin
106602>>>>>            Get piLabelSmallFontHeight to iFontHeight
106603>>>>>            Move 6 to iLabelRowOffset
106604>>>>>        End
106604>>>>>>
106604>>>>>
106604>>>>>        Get pbLargeImageSize to bLargeImageSize
106605>>>>>        If (bLargeImageSize = True) Begin
106607>>>>>            Get private.piLargeImageSize to iImageSize
106608>>>>>        End
106608>>>>>>
106608>>>>>        Else Begin
106609>>>>>            Get private.piSmallImageSize to iImageSize
106610>>>>>            Move (iLabelColOffset - 6) to iLabelColOffset
106611>>>>>        End
106611>>>>>>
106611>>>>>
106611>>>>>        Object oHeaderGroupImage is a cRDCHeaderGroupImage
106613>>>>>            Set piImageSize to iImageSize
106614>>>>>            Set Location to (piImageRowOffset(Self)) (piImageColOffset(Self))
106615>>>>>            Set psImage to (private.psImage(Self))
106616>>>>>            Set peImageAlign to Button_ImageList_Align_Center
106617>>>>>            Set psToolTip to (private.psToolTip(Self))
106618>>>>>        End_Object
106619>>>>>
106619>>>>>        Object oHeaderGroupInfo_tb is a TextBox
106621>>>>>            Set Size to 12 100
106622>>>>>            Set Location to (piLabelRowOffset(Self)) iLabelColOffset
106623>>>>>            Set FontWeight to (piLabelFontPointWeight(Self))
106624>>>>>            Set FontItalics to (pbLabelFontItalics(Self))
106625>>>>>            Set FontPointHeight to iFontHeight
106626>>>>>            Set Label to (private.psLabel(Self))
106627>>>>>            Set TextColor to (piLabelColor(Self))
106628>>>>>            Set psToolTip to (private.psToolTip(Self))
106629>>>>>            Get Size to iSize
106630>>>>>        End_Object
106631>>>>>
106631>>>>>        // ToDo: The positioning logic for placing the info image to the right of the header text is flawed.
106631>>>>>        // How can it be improved?
106631>>>>>        Get pbCreateTooltipItem to bCreateTooltipItem
106632>>>>>        If (bCreateTooltipItem = True and private.psToolTip(Self) <> "") Begin
106634>>>>>            Get private.psLabel to sLabel
106635>>>>>            Get Text_Extent sLabel to iTextOffset
106636>>>>>            Move (Low(iTextOffset) -0)  to iTextOffset
106637>>>>>            Object oHeaderGroupTooltip_tb is a TextBox
106639>>>>>                Set Size to 10 10
106640>>>>>                If (bUseLargeFontHeight = True) Begin
106642>>>>>//                    Set Location to (piLabelRowOffset(Self)) iTextOffset //(Low(iSize) + (iTextOffset))
106642>>>>>                    Set Location to (piLabelRowOffset(Self)) (Low(iSize) + (iLabelColOffset * 2) + 10)
106643>>>>>                End
106643>>>>>>
106643>>>>>                Else Begin
106644>>>>>//                    Set Location to (piLabelRowOffset(Self)) iTextOffset
106644>>>>>                    Set Location to (piLabelRowOffset(Self)) (Low(iSize) + iLabelColOffset + 25)
106645>>>>>                End
106645>>>>>>
106645>>>>>                Set psToolTip to (private.psToolTip(Self))
106646>>>>>                Set Bitmap to "ActionAbout.bmp"
106647>>>>>            End_Object
106648>>>>>        End
106648>>>>>>
106648>>>>>
106648>>>>>        Get psNote to sNote
106649>>>>>        If (Trim(sNote) <> "") Begin
106651>>>>>            Object oHeaderGroupNote_tb is a TextBox
106653>>>>>                Set Size to 12 100
106654>>>>>                Set Location to (Hi(iSize) + iLabelRowOffset) (iLabelColOffset + 8)
106655>>>>>                Set Label to ("-" * String(sNote))
106656>>>>>                Set TextColor to (piLabelColor(Self))
106657>>>>>                Set FontPointHeight to 9
106658>>>>>                Set psToolTip to (private.psToolTip(Self))
106659>>>>>            End_Object
106660>>>>>        End
106660>>>>>>
106660>>>>>
106660>>>>>    End_Procedure
106661>>>>>
106661>>>>>    Function Popup_State Returns Boolean
106663>>>>>        Boolean bIsPopup
106663>>>>>        Get Popup_State of (Parent(Self)) to bIsPopup
106664>>>>>        Function_Return bIsPopup
106665>>>>>    End_Function
106666>>>>>
106666>>>>>    Procedure OnEnterArea Handle hoFrom
106668>>>>>        Integer iColor
106668>>>>>        Forward Send OnEnterArea hoFrom
106670>>>>>        // Not ideal, but works most of the time.
106670>>>>>        //       When navigating to i.e a popup we don't want
106670>>>>>        //       the coloring to appear. Else there will be 2
106670>>>>>        //       cRDCHeaderGroup's with the highlight color...
106670>>>>>        // Is there a better way?
106670>>>>>        If (hoFrom <> Desktop and hoFrom < Parent(Self)) Begin
106672>>>>>            Procedure_Return
106673>>>>>        End
106673>>>>>>
106673>>>>>        If (pbUseHotspotColor(Self) = True) Begin
106675>>>>>            Get Color to iColor
106676>>>>>            Set private.piColorOrg to iColor
106677>>>>>            Get piHeaderHotspotColor to iColor
106678>>>>>            Set Color to iColor
106679>>>>>            Broadcast Recursive Set Color to iColor
106681>>>>>        End
106681>>>>>>
106681>>>>>    End_Procedure
106682>>>>>
106682>>>>>    Procedure OnExitArea Handle hoFrom
106684>>>>>        Integer iColor
106684>>>>>        Forward Send OnExitArea hoFrom
106686>>>>>        If (pbUseHotspotColor(Self) = True) Begin
106688>>>>>            Get private.piColorOrg to iColor
106689>>>>>            Set Color to iColor
106690>>>>>            Broadcast Recursive Set Color to iColor
106692>>>>>        End
106692>>>>>>
106692>>>>>    End_Procedure
106693>>>>>
106693>>>>>    // Public access message to change the group header text color at runtime.
106693>>>>>    Procedure Set Label_Color Integer iColor
106695>>>>>        Set TextColor of (oHeaderGroupInfo_tb(Self)) to iColor
106696>>>>>    End_Procedure
106697>>>>>
106697>>>>>    Procedure NavigatePrevious
106699>>>>>        Integer iMulti ivoid iLastErr
106699>>>>>        Handle hWnd
106699>>>>>        Boolean bErr
106699>>>>>
106699>>>>>        Move Err to bErr
106700>>>>>        Move LastErr to iLastErr
106701>>>>>
106701>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
106702>>>>>        Get Select_Mode of (Focus(Self)) to iMulti
106703>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
106704>>>>>        If (Err) Begin
106706>>>>>            Move bErr to Err
106707>>>>>            Move iLastErr to LastErr
106708>>>>>            Procedure_Return
106709>>>>>        End
106709>>>>>>
106709>>>>>
106709>>>>>        Move bErr to Err
106710>>>>>        Move iLastErr to LastErr
106711>>>>>        If (iMulti = Multi_Select) Begin
106713>>>>>            Send Previous
106714>>>>>        End
106714>>>>>>
106714>>>>>        Else Begin
106715>>>>>            Get Form_Window_Handle of (Focus(Self)) to hWnd
106716>>>>>            Move (Sendmessage(hWnd, WM_KEYDOWN, Ascii(VK_LEFT), 0)) to iVoid
106717>>>>>        End
106717>>>>>>
106717>>>>>    End_Procedure
106718>>>>>
106718>>>>>    Procedure NavigateNext
106720>>>>>        Integer iMulti iVoid iLastErr
106720>>>>>        Handle hWnd
106720>>>>>        Boolean bErr
106720>>>>>
106720>>>>>        Move Err to bErr
106721>>>>>        Move LastErr to iLastErr
106722>>>>>
106722>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
106723>>>>>        Get Select_Mode of (Focus(Self)) to iMulti
106724>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
106725>>>>>        If (Err) Begin
106727>>>>>            Move bErr to Err
106728>>>>>            Move iLastErr to LastErr
106729>>>>>            Procedure_Return
106730>>>>>        End
106730>>>>>>
106730>>>>>
106730>>>>>        Move bErr to Err
106731>>>>>        Move iLastErr to LastErr
106732>>>>>        If (iMulti = Multi_Select) Begin
106734>>>>>            Send Next
106735>>>>>        End
106735>>>>>>
106735>>>>>        Else Begin
106736>>>>>            Get Form_Window_Handle of (Focus(Self)) to hWnd
106737>>>>>            Move (Sendmessage(hWnd, WM_KEYDOWN, Ascii(VK_LEFT), 0)) to iVoid
106738>>>>>        End
106738>>>>>>
106738>>>>>
106738>>>>>    End_Procedure
106739>>>>>
106739>>>>>    Procedure Enable_Window Integer iState
106741>>>>>        Handle hWnd
106741>>>>>        Get Window_Handle to hWnd
106742>>>>>        If hWnd Begin
106744>>>>>            Move (EnableWindow(hWnd, iState)) to hWnd
106745>>>>>        End
106745>>>>>>
106745>>>>>    End_Procedure
106746>>>>>
106746>>>>>    Procedure Page_Object Integer iState
106748>>>>>        Handle hWnd
106748>>>>>        Get Window_Handle to hWnd
106749>>>>>        Forward Send Page_Object iState
106751>>>>>        If (hWnd = 0 and iState) Begin
106753>>>>>            Send Shadow_Display
106754>>>>>        End
106754>>>>>>
106754>>>>>    End_Procedure
106755>>>>>
106755>>>>>    Procedure Shadow_Display
106757>>>>>        Send Enable_Window (not(Object_Shadow_State(Self)))
106758>>>>>    End_Procedure
106759>>>>>
106759>>>>>    Function Explicit_Shadow_State Returns Boolean
106761>>>>>        Function_Return (Private.Explicit_Shadow_State(Self))
106762>>>>>    End_Function
106763>>>>>
106763>>>>>    // For some reason we need to augment this event to allow
106763>>>>>    // files to be dropped on a cRDCHeaderGroup object; else nothing will
106763>>>>>    // happen.
106763>>>>>    Procedure OnFileDropped String sFilename Boolean bLast
106765>>>>>        Delegate Send OnFileDropped sFilename bLast
106767>>>>>    End_Procedure
106768>>>>>
106768>>>>>End_Class
106769>>>>>
106769>>>>>// We don't want the broadcast of setting color to set the background
106769>>>>>// color for forms that are within a cRDCHeaderGroup object.
106769>>>>>// If the Form is not within a cRDCHeaderGroup the Form class should
106769>>>>>// behave as it always has. But if you don't like this; just comment
106769>>>>>// it out.
106769>>>>>//Procedure Set Color for Form Integer eColor
106769>>>>>//    Boolean bIsHeaderGroup bErr bEnabled_State
106769>>>>>//    Integer iLastErr
106769>>>>>//
106769>>>>>//    Move Err to bErr
106769>>>>>//    Move LastErr to iLastErr
106769>>>>>//
106769>>>>>//    Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
106769>>>>>//    Delegate Get private.pbIsHeaderGroup to bIsHeaderGroup
106769>>>>>//    Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
106769>>>>>//    Move bErr to Err
106769>>>>>//    Move iLastErr to LastErr
106769>>>>>//    If (bIsHeaderGroup = False) Begin
106769>>>>>//        Forward Set Color to eColor
106769>>>>>//    End
106769>>>>>//End_Procedure
106769>>>Use DriverSettings.dg
Including file: DriverSettings.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DriverSettings.dg)
106769>>>>>Use cApplication.pkg
106769>>>>>Use Dfline.pkg
106769>>>>>Use cRichEdit.pkg
106769>>>>>Use cScrollingContainer.pkg
Including file: cScrollingContainer.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cScrollingContainer.pkg)
106769>>>>>>>// Provides support for scrolling containers.
106769>>>>>>>// Scrolling containers is provided by creating two objects,
106769>>>>>>>// a host (cScrollingContainer) and a scrolling clientarea (cScrollingClientArea)
106769>>>>>>>// The host has no public interface, you just drop the object. It should have only one child object
106769>>>>>>>// and that should be a scrolling client-area. If it is not, it is an error. It is also considered
106769>>>>>>>// an error to place a scrolling client area in any object other than a scrolling container.
106769>>>>>>>
106769>>>>>>>Use Windows.pkg
106769>>>>>>>Use cScrollingContainerMixin.pkg
Including file: cScrollingContainerMixin.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cScrollingContainerMixin.pkg)
106769>>>>>>>>>// Mixin classes for scrolling container support:
106769>>>>>>>>>// cScrollingContainerMixin & cScrollingClientAreaMixin
106769>>>>>>>>>// These are used by cSrollingContainer / cScrollingClientArea and
106769>>>>>>>>>// dbScrollingContainer / dbScrollingClientArea.
106769>>>>>>>>>// The scrolling container has no public interface, you just drop the object. It should have only one child object
106769>>>>>>>>>// and that should be a scrolling client-area. If it is not, it is an error. It is also considered
106769>>>>>>>>>// an error to place a scrolling client area in any object other than a scrolling container.
106769>>>>>>>>>
106769>>>>>>>>>Use Windows.pkg
106769>>>>>>>>>Use Winuser.pkg
106769>>>>>>>>>Use tWinStructs.pkg
106769>>>>>>>>>
106769>>>>>>>>>Register_Function pbTabbedWorkspaces Returns Boolean
106769>>>>>>>>>Register_Function pbCenterTabbedViews Returns Boolean
106769>>>>>>>>>// support for the scrolling client area mixin object.
106769>>>>>>>>>
106769>>>>>>>>>Class cScrollingClientAreaMixin is a Mixin
106770>>>>>>>>>    
106770>>>>>>>>>    Procedure Define_cScrollingClientAreaMixin
106772>>>>>>>>>        
106772>>>>>>>>>        Set pbSizeToClientArea to False // should already be set to this, but just in case.
106773>>>>>>>>>        Set Border_Style to Border_None
106774>>>>>>>>>        
106774>>>>>>>>>        Property Boolean pbAutoScroll True
106775>>>>>>>>>        Property Boolean pbAutoScrollFocus True
106776>>>>>>>>>        Property Integer piAutoScrollMarginX 5
106777>>>>>>>>>        Property Integer piAutoScrollMarginY 5
106778>>>>>>>>>        Property Integer piAutoScrollMinX 0
106779>>>>>>>>>        Property Integer piAutoScrollMinY 0
106780>>>>>>>>>        Property Boolean pbShowDisabledScrollBar False
106781>>>>>>>>>        
106781>>>>>>>>>        
106781>>>>>>>>>        Property Integer piLineScrollUnit  5 // minimum scrolling unit for line up/down and mouse wheel
106782>>>>>>>>>        Property Integer piMinimumHeight 0 // the minimum height that doesn't need scrolling
106783>>>>>>>>>        Property Integer piMinimumWidth 0 //(the minimum width that doesn't need scrolling
106784>>>>>>>>>        // keeps track of scrolling
106784>>>>>>>>>        Property Integer piCurrentVertScrolled 0
106785>>>>>>>>>        Property Integer piCurrentHorzScrolled 0
106786>>>>>>>>>        Property Integer piWheelDelta 0               // internal, accumulates mouse wheel clicks
106787>>>>>>>>>        Delegate Set phoScrollingClientArea to Self
106789>>>>>>>>>        
106789>>>>>>>>>        // set this true to make this a tabbed workspace view (design time)
106789>>>>>>>>>        Property Boolean pbTabWorkspaceView False
106790>>>>>>>>>        // set this false to stop auto-determination of pbTabWorkspaceView (design time)
106790>>>>>>>>>        Property Boolean pbAutoSetTabWorkspaceView True
106791>>>>>>>>>    End_Procedure
106792>>>>>>>>>    
106792>>>>>>>>>    // low level event sent from windows.
106792>>>>>>>>>    Procedure OnWmMouseWheel Integer wParam Integer lParam
106794>>>>>>>>>        Integer iWheelDelta iKeys iDelta iClicks
106794>>>>>>>>>        Move (low(abs(wParam))) to iKeys           // any keys down when pressed
106795>>>>>>>>>        Move (hi(abs(wParam))) to iDelta           // number of click units
106796>>>>>>>>>        If (wParam<0) Begin
106798>>>>>>>>>            Move (-iDelta) to iDelta     // can be up or down
106799>>>>>>>>>        End
106799>>>>>>>>>>
106799>>>>>>>>>        Get  piWheelDelta to iWheelDelta           // Current accumulated micro clicks
106800>>>>>>>>>        Move (iWheelDelta+iDelta) to iWheelDelta
106801>>>>>>>>>        // C_WHEELDATA is 120 as defined by MS as the delta to react to. Once click is usually 120
106801>>>>>>>>>        Move (iWheelDelta/C_WHEELDELTA) to iClicks // Number of clicks to react to
106802>>>>>>>>>        Set  piWheelDelta to (mod(iWheelDelta,C_WHEELDELTA)) // remainder unused microclicks
106803>>>>>>>>>        // If we have enough Clicks send OnMouseWheel
106803>>>>>>>>>        If (iClicks<>0) Begin
106805>>>>>>>>>            Send OnMouseWheel iClicks iKeys
106806>>>>>>>>>        End
106806>>>>>>>>>>
106806>>>>>>>>>        // tell windows that we've handled the event.
106806>>>>>>>>>        Set Windows_Override_State to True
106807>>>>>>>>>    End_Procedure
106808>>>>>>>>>    
106808>>>>>>>>>    
106808>>>>>>>>>    // should be sent by DF message OnWMMouseWheel , which is sent by WM_MOUSEWHEEL
106808>>>>>>>>>    Procedure OnMouseWheel Integer iClicks Integer iKey
106810>>>>>>>>>        Integer iLineScrollUnit
106810>>>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
106811>>>>>>>>>        Send VScroll (-iClicks*iLineScrollUnit*2) // (If(iClicks>0,False,True)) (abs(iClicks))
106812>>>>>>>>>    End_Procedure
106813>>>>>>>>>    
106813>>>>>>>>>    // should be sent by WM_VSCROLL
106813>>>>>>>>>    Procedure SetVScrollbox Integer iType Integer iNewPos
106815>>>>>>>>>        Boolean bOk
106815>>>>>>>>>        tWinScrollInfo ScrollInfo
106815>>>>>>>>>        tWinScrollInfo ScrollInfo
106815>>>>>>>>>        Integer iLineScrollUnit
106815>>>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
106816>>>>>>>>>        Get GetScrollBarInfo True (&ScrollInfo) to bOk
106817>>>>>>>>>        If bOk Begin
106819>>>>>>>>>            
106819>>>>>>>>>            Case Begin
106819>>>>>>>>>                Case (iType=SB_PAGEDOWN)
106821>>>>>>>>>                    Send VScroll ScrollInfo.nPage
106822>>>>>>>>>                    Case Break
106823>>>>>>>>>                
106823>>>>>>>>>                Case (iType=SB_PAGEUP)
106826>>>>>>>>>                    Send VScroll (-Integer(ScrollInfo.nPage))
106827>>>>>>>>>                    Case Break
106828>>>>>>>>>                
106828>>>>>>>>>                Case (iType=SB_LINEDOWN)
106831>>>>>>>>>                    Send VScroll iLineScrollUnit
106832>>>>>>>>>                    Case Break
106833>>>>>>>>>                
106833>>>>>>>>>                Case (iType=SB_LINEUP)
106836>>>>>>>>>                    Send VScroll (-iLineScrollUnit)
106837>>>>>>>>>                    Case Break
106838>>>>>>>>>                
106838>>>>>>>>>                Case (iType=SB_BOTTOM)
106841>>>>>>>>>                    Send VScroll (ScrollInfo.nMax-ScrollInfo.nPos)
106842>>>>>>>>>                    Case Break
106843>>>>>>>>>                
106843>>>>>>>>>                Case (iType=SB_Top)
106846>>>>>>>>>                    Send VScroll (-ScrollInfo.nPos)
106847>>>>>>>>>                    Case Break
106848>>>>>>>>>                
106848>>>>>>>>>                Case (iType=SB_THUMBPOSITION)
106851>>>>>>>>>                    Case Break
106852>>>>>>>>>                
106852>>>>>>>>>                Case (iType=SB_THUMBTRACK)
106855>>>>>>>>>                    Send VScroll (ScrollInfo.nTrackPos-ScrollInfo.nPos)
106856>>>>>>>>>                    Case Break
106857>>>>>>>>>            Case End
106857>>>>>>>>>        End
106857>>>>>>>>>>
106857>>>>>>>>>    End_Procedure
106858>>>>>>>>>    
106858>>>>>>>>>    // should be sent by WM_HSCROLL
106858>>>>>>>>>    Procedure SetHScrollbox Integer iType Integer iNewPos
106860>>>>>>>>>        Boolean bOk
106860>>>>>>>>>        tWinScrollInfo ScrollInfo
106860>>>>>>>>>        tWinScrollInfo ScrollInfo
106860>>>>>>>>>        Integer iLineScrollUnit
106860>>>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
106861>>>>>>>>>        Get GetScrollBarInfo False (&ScrollInfo) to bOk
106862>>>>>>>>>        If bOk Begin
106864>>>>>>>>>            
106864>>>>>>>>>            Case Begin
106864>>>>>>>>>                Case (iType=SB_PAGEDOWN)
106866>>>>>>>>>                    Send hScroll ScrollInfo.nPage
106867>>>>>>>>>                    Case Break
106868>>>>>>>>>                
106868>>>>>>>>>                Case (iType=SB_PAGEUP)
106871>>>>>>>>>                    Send hScroll (-Integer(ScrollInfo.nPage))
106872>>>>>>>>>                    Case Break
106873>>>>>>>>>                
106873>>>>>>>>>                Case (iType=SB_LINEDOWN)
106876>>>>>>>>>                    Send hScroll iLineScrollUnit
106877>>>>>>>>>                    Case Break
106878>>>>>>>>>                
106878>>>>>>>>>                Case (iType=SB_LINEUP)
106881>>>>>>>>>                    Send hScroll (-iLineScrollUnit)
106882>>>>>>>>>                    Case Break
106883>>>>>>>>>                
106883>>>>>>>>>                Case (iType=SB_BOTTOM)
106886>>>>>>>>>                    Send hScroll (ScrollInfo.nMax-ScrollInfo.nPos)
106887>>>>>>>>>                    Case Break
106888>>>>>>>>>                
106888>>>>>>>>>                Case (iType=SB_Top)
106891>>>>>>>>>                    Send hScroll (-ScrollInfo.nPos)
106892>>>>>>>>>                    Case Break
106893>>>>>>>>>                
106893>>>>>>>>>                Case (iType=SB_THUMBPOSITION)
106896>>>>>>>>>                    Case Break
106897>>>>>>>>>                
106897>>>>>>>>>                Case (iType=SB_THUMBTRACK)
106900>>>>>>>>>                    Send hScroll (ScrollInfo.nTrackPos-ScrollInfo.nPos)
106901>>>>>>>>>                    Case Break
106902>>>>>>>>>            Case End
106902>>>>>>>>>        End
106902>>>>>>>>>>
106902>>>>>>>>>    End_Procedure
106903>>>>>>>>>    
106903>>>>>>>>>    
106903>>>>>>>>>    // this calls SetScrollInfo with proper info
106903>>>>>>>>>    Procedure SetScrollBarInfo Boolean bVert Integer iRangeMin Integer iRangeMax Integer iPageSize
106905>>>>>>>>>        tWinScrollInfo ScrollInfo
106905>>>>>>>>>        tWinScrollInfo ScrollInfo
106905>>>>>>>>>        Integer iVoid
106905>>>>>>>>>        Handle hWnd
106905>>>>>>>>>        Boolean bShow
106905>>>>>>>>>        
106905>>>>>>>>>        Delegate Get Window_Handle to hWnd
106907>>>>>>>>>        If (hWnd <> 0) Begin
106909>>>>>>>>>            Move (SizeOfType (tWinScrollInfo)) to ScrollInfo.cbSize
106910>>>>>>>>>            
106910>>>>>>>>>            Move (SIF_RANGE ior SIF_POS ior SIF_PAGE ) to ScrollInfo.fMask
106911>>>>>>>>>            Get pbShowDisabledScrollBar to bShow
106912>>>>>>>>>            If bShow Begin
106914>>>>>>>>>                Move (ScrollInfo.fMask ior SIF_DISABLENOSCROLL) to ScrollInfo.fMask
106915>>>>>>>>>            End
106915>>>>>>>>>>
106915>>>>>>>>>            Move iRangeMin to ScrollInfo.nMin
106916>>>>>>>>>            Move iRangeMax to ScrollInfo.nMax
106917>>>>>>>>>            Move iPageSize to ScrollInfo.nPage
106918>>>>>>>>>            Move 0 to ScrollInfo.nPos
106919>>>>>>>>>            Move (SetScrollInfo (hWnd, If(bVert,SB_VERT,SB_HORZ), AddressOf (ScrollInfo), True)) to iVoid
106920>>>>>>>>>            
106920>>>>>>>>>        End
106920>>>>>>>>>>
106920>>>>>>>>>    End_Procedure
106921>>>>>>>>>    
106921>>>>>>>>>    // this wraps GetScrollInfo
106921>>>>>>>>>    Function GetScrollBarInfo Boolean bVert tWinScrollInfo ByRef ScrollInfo Returns Boolean
106923>>>>>>>>>        Boolean bOk
106923>>>>>>>>>        Handle hWnd
106923>>>>>>>>>        
106923>>>>>>>>>        Delegate Get Window_Handle to hWnd
106925>>>>>>>>>        If (hWnd <> 0) Begin
106927>>>>>>>>>            Move (SizeOfType (tWinScrollInfo)) to ScrollInfo.cbSize
106928>>>>>>>>>            Move (SIF_ALL) to ScrollInfo.fMask
106929>>>>>>>>>            Move (GetScrollInfo (hWnd, If(bVert,SB_VERT,SB_HORZ), AddressOf (ScrollInfo))) to bOk
106930>>>>>>>>>        End
106930>>>>>>>>>>
106930>>>>>>>>>        Function_Return bOk
106931>>>>>>>>>    End_Function
106932>>>>>>>>>    
106932>>>>>>>>>    // this wraps SetScrollPos
106932>>>>>>>>>    Procedure SetScrollBarPosInfo Boolean bVert Integer iPos
106934>>>>>>>>>        Integer iVoid
106934>>>>>>>>>        Handle hWnd
106934>>>>>>>>>        
106934>>>>>>>>>        Delegate Get Window_Handle to hWnd
106936>>>>>>>>>        If (hWnd <> 0) Begin
106938>>>>>>>>>            Move (SetScrollPos(hWnd, If(bVert,SB_VERT,SB_HORZ), iPos, True)) to iVoid
106939>>>>>>>>>        End
106939>>>>>>>>>>
106939>>>>>>>>>    End_Procedure
106940>>>>>>>>>    
106940>>>>>>>>>    // scrolling containers don't do anhcors. However, this gets called every time the parent's
106940>>>>>>>>>    // guiSize changes. We can use that to scroll or resize the scrolling client as needed.
106940>>>>>>>>>    Procedure DoapplyAnchors Integer Arg1 Integer Arg2
106942>>>>>>>>>        Send ScrollClientArea
106943>>>>>>>>>    End_Procedure
106944>>>>>>>>>    
106944>>>>>>>>>    // augment to handle the scrolling area initialization.
106944>>>>>>>>>    Procedure Add_Focus Handle hoParent
106946>>>>>>>>>        Forward Send Add_Focus hoParent
106948>>>>>>>>>        // at this the scrolling container and client area should both be paged.
106948>>>>>>>>>        // child objects ae also paged with initial anchors applied
106948>>>>>>>>>        Send CalculateAutoScrollMinimums
106949>>>>>>>>>    End_Procedure
106950>>>>>>>>>    
106950>>>>>>>>>    Procedure Page Integer iPage
106952>>>>>>>>>        Forward Send Page iPage
106954>>>>>>>>>        If iPage Begin
106956>>>>>>>>>            // at this the scrolling container and client area should both be paged
106956>>>>>>>>>            // but the child controls are not paged. We don't want scrollbars when
106956>>>>>>>>>            // the child items are paged (else they may get anchored oddly)
106956>>>>>>>>>            // Prior to 19.0 these were set in Add_focus which meant that the child objects were
106956>>>>>>>>>            // already paged with scrollbars present. This would result in scrollbars appearing
106956>>>>>>>>>            // before they were really needed. This should be more accurate
106956>>>>>>>>>            Send SetScrollBarInfo True 0 0 0
106957>>>>>>>>>            Send SetScrollBarInfo False 0 0 0
106958>>>>>>>>>        End
106958>>>>>>>>>>
106958>>>>>>>>>    End_Procedure
106959>>>>>>>>>    
106959>>>>>>>>>    // determine scrolling minimums and set the client area as required.
106959>>>>>>>>>    
106959>>>>>>>>>    Procedure CalculateAutoScrollMinimums
106961>>>>>>>>>        Integer iMinX iMinY iSiz iLoc iMargin
106961>>>>>>>>>        Integer iAutoMinX iAutoMinY
106961>>>>>>>>>        Boolean bAutoScroll
106961>>>>>>>>>        Handle hoNext hoFirst
106961>>>>>>>>>        
106961>>>>>>>>>        Get pbAutoScroll to bAutoScroll
106962>>>>>>>>>        Get piAutoScrollMinX to iAutoMinX
106963>>>>>>>>>        Get piAutoScrollMinY to iAutoMinY
106964>>>>>>>>>        Get DialogToGui iAutoMinY iAutoMinX to iSiz
106965>>>>>>>>>        Move (Hi(iSiz)) to iAutoMinY
106966>>>>>>>>>        Move (Low(iSiz)) to iAutoMinX
106967>>>>>>>>>        Set piMinimumHeight to iAutoMinY
106968>>>>>>>>>        Set piMinimumWidth to iAutoMinX
106969>>>>>>>>>        
106969>>>>>>>>>        If (bAutoScroll and (iAutoMinX=0 or iAutoMinY=0)) Begin
106971>>>>>>>>>            
106971>>>>>>>>>            Get Next_Level to hoFirst
106972>>>>>>>>>            Move hoFirst to hoNext
106973>>>>>>>>>            If (hoFirst) Begin
106975>>>>>>>>>                Repeat
106975>>>>>>>>>>
106975>>>>>>>>>                    Get GuiWindowSize of hoNext to iSiz
106976>>>>>>>>>                    Get GuiLocation of hoNext to iLoc
106977>>>>>>>>>                    Move (Hi(iLoc)+Hi(iSiz) max iMinY) to iMinY
106978>>>>>>>>>                    Move (Low(iLoc)+Low(iSiz) max iMinX) to iMinx
106979>>>>>>>>>                    Get Next_Focus of hoNext to hoNext
106980>>>>>>>>>                Until (hoNext=0 or hoNext=hoFirst)
106982>>>>>>>>>                
106982>>>>>>>>>                If (iAutoMinY=0) Begin
106984>>>>>>>>>                    Get piAutoScrollMarginY to iMargin
106985>>>>>>>>>                    Set piMinimumHeight to (iMinY+iMargin)
106986>>>>>>>>>                End
106986>>>>>>>>>>
106986>>>>>>>>>                
106986>>>>>>>>>                If (iAutoMinX=0) Begin
106988>>>>>>>>>                    Get piAutoScrollMarginX to iMargin
106989>>>>>>>>>                    Set piMinimumWidth to (iMinX+iMargin)
106990>>>>>>>>>                    
106990>>>>>>>>>                End
106990>>>>>>>>>>
106990>>>>>>>>>            End
106990>>>>>>>>>>
106990>>>>>>>>>        End
106990>>>>>>>>>>
106990>>>>>>>>>        
106990>>>>>>>>>        // before setting the client area, unset all anchors so DoApplyAnchors will not do anything
106990>>>>>>>>>        Broadcast Set pbAnchorCreated to False
106992>>>>>>>>>        Send ScrollClientArea
106993>>>>>>>>>        // after the scroll set up, reinitialize all anchors.
106993>>>>>>>>>        Broadcast Send DoCreateAnchors
106995>>>>>>>>>    End_Procedure
106996>>>>>>>>>    
106996>>>>>>>>>    // Scroll the client area and adjust the client area size as needed. This does all the
106996>>>>>>>>>    // work of scrolling.
106996>>>>>>>>>    
106996>>>>>>>>>    Procedure ScrollClientArea
106998>>>>>>>>>        Integer iSiz
106998>>>>>>>>>        Integer iHeight iHCur iHCuriDelta iOrig iRange bOk
106998>>>>>>>>>        Integer iWidth iWCur iWDelta iWOrig
106998>>>>>>>>>        Integer iSzY iSzX iLocX iLocY
106998>>>>>>>>>        
106998>>>>>>>>>        Delegate Get GuiClientSize to iSiz
107000>>>>>>>>>        Move (Hi(iSiz)) to iHeight
107001>>>>>>>>>        Move (Low(iSiz)) to iWidth
107002>>>>>>>>>        
107002>>>>>>>>>        // Vertical scrolling
107002>>>>>>>>>        
107002>>>>>>>>>        Get piMinimumHeight to iOrig
107003>>>>>>>>>        Get piMinimumWidth to iWOrig
107004>>>>>>>>>        
107004>>>>>>>>>        If (iOrig<>0 or iWOrig<>0) Begin
107006>>>>>>>>>            
107006>>>>>>>>>            If (iOrig<>0) Begin
107008>>>>>>>>>                Get piCurrentVertScrolled to iHCur
107009>>>>>>>>>                // If the size got bigger and we've scrolled, we want to scroll up
107009>>>>>>>>>                If (iHCur<>0 and (iHCur+iHeight>iOrig)) Begin
107011>>>>>>>>>                    Move (iOrig-iHeight max 0) to iHCur
107012>>>>>>>>>                    Set piCurrentVertScrolled to iHCur
107013>>>>>>>>>                End
107013>>>>>>>>>>
107013>>>>>>>>>                If (iHCur<>0 or iOrig>iHeight) Begin
107015>>>>>>>>>                    Send SetScrollBarInfo True 0 iOrig (iHeight min iOrig)
107016>>>>>>>>>                    Send SetScrollBarPosInfo True iHCur
107017>>>>>>>>>                End
107017>>>>>>>>>>
107017>>>>>>>>>                Else Begin
107018>>>>>>>>>                    Send SetScrollBarInfo True 0 0 0 //iOrig (iHeight min iOrig)
107019>>>>>>>>>                End
107019>>>>>>>>>>
107019>>>>>>>>>            End
107019>>>>>>>>>>
107019>>>>>>>>>            
107019>>>>>>>>>            // Horiz scrolling
107019>>>>>>>>>            
107019>>>>>>>>>            Get piCurrentHorzScrolled to iWCur
107020>>>>>>>>>            // If the size got bigger and we've scrolled, we want to scroll left
107020>>>>>>>>>            If (iWCur<>0 and (iWCur+iWidth>iWOrig)) Begin
107022>>>>>>>>>                Move (iWOrig-iWidth max 0) to iWCur
107023>>>>>>>>>                Set piCurrentHorzScrolled to iWCur
107024>>>>>>>>>            End
107024>>>>>>>>>>
107024>>>>>>>>>            If (iWCur<>0 or iWOrig>iWidth) Begin
107026>>>>>>>>>                Send SetScrollBarInfo False 0 iWOrig (iWidth min iWOrig)
107027>>>>>>>>>                Send SetScrollBarPosInfo False iWCur
107028>>>>>>>>>            End
107028>>>>>>>>>>
107028>>>>>>>>>            Else Begin
107029>>>>>>>>>                Send SetScrollBarInfo False 0 0 0
107030>>>>>>>>>            End
107030>>>>>>>>>>
107030>>>>>>>>>        End
107030>>>>>>>>>>
107030>>>>>>>>>        
107030>>>>>>>>>        // this could change depending on scrollbars appearing or not
107030>>>>>>>>>        Delegate Get GuiClientSize to iSiz
107032>>>>>>>>>        
107032>>>>>>>>>        // size of container is the the minimum allowed size (if scrolling is needed)
107032>>>>>>>>>        // or it is the actual size of the container (if scrolling not needed and it is bigger)
107032>>>>>>>>>        // This is required to make anchors work sensibly
107032>>>>>>>>>        Move (hi(iSiz) max iOrig) to iSzY
107033>>>>>>>>>        Move (low(iSiz) max iWOrig) to iSzX
107034>>>>>>>>>        Move (-iHCur) to iLocY
107035>>>>>>>>>        Move (-iWCur) to iLocX
107036>>>>>>>>>        
107036>>>>>>>>>        // Allow chance to make modifications
107036>>>>>>>>>        Send AdjustSizesLocs (&iSzY) (&iSzX) (&iLocY) (&iLocX)
107037>>>>>>>>>        
107037>>>>>>>>>        Set GuiSize to iSzY iSzX
107038>>>>>>>>>        // if we've scrolled, we need to reposition the container
107038>>>>>>>>>        Set GuiLocation to iLocY iLocX
107039>>>>>>>>>    End_Procedure
107040>>>>>>>>>    
107040>>>>>>>>>    // note that scrolling never changes the size of the scrolling client.
107040>>>>>>>>>    // this way, it does not interfere with anchors.
107040>>>>>>>>>    
107040>>>>>>>>>    Procedure VScroll Integer iDelta
107042>>>>>>>>>        Integer iHeight iCur iOrig iSiz
107042>>>>>>>>>        Delegate Get GuiClientSize to iSiz
107044>>>>>>>>>        Move (hi(iSiz)) to iHeight
107045>>>>>>>>>        Get piCurrentVertScrolled to iCur
107046>>>>>>>>>        Get piMinimumHeight to iOrig
107047>>>>>>>>>        If (iOrig=0 or  Hi(iSiz)>=iOrig) Begin
107049>>>>>>>>>            Procedure_Return
107050>>>>>>>>>        End
107050>>>>>>>>>>
107050>>>>>>>>>        // make sure delta is within range
107050>>>>>>>>>        If (iDelta+iCur<0) Begin
107052>>>>>>>>>            Move (-iCur) to iDelta
107053>>>>>>>>>        End
107053>>>>>>>>>>
107053>>>>>>>>>        Else If (iDelta+iCur>iOrig - iHeight) Begin
107056>>>>>>>>>            Move (iOrig - iHeight - iCur) to iDelta
107057>>>>>>>>>        End
107057>>>>>>>>>>
107057>>>>>>>>>        If (iDelta=0) ;            Procedure_Return
107060>>>>>>>>>        
107060>>>>>>>>>        Move (iCur + iDelta) to iCur
107061>>>>>>>>>        Set piCurrentVertScrolled to iCur
107062>>>>>>>>>        Send SetScrollBarPosInfo True iCur
107063>>>>>>>>>        Get GuiLocation to iSiz
107064>>>>>>>>>        Set GuiLocation to (cast(hi(iSiz),Integer)-iDelta) (cast(low(iSiz),Integer))
107065>>>>>>>>>        Send ScrollClientArea
107066>>>>>>>>>    End_Procedure
107067>>>>>>>>>    
107067>>>>>>>>>    
107067>>>>>>>>>    Procedure HScroll Integer iDelta
107069>>>>>>>>>        Integer iHeight iCur iOrig iSiz
107069>>>>>>>>>        Delegate Get GuiClientSize to iSiz
107071>>>>>>>>>        Move (low(iSiz)) to iHeight
107072>>>>>>>>>        Get piCurrentHorzScrolled to iCur
107073>>>>>>>>>        Get piMinimumWidth to iOrig
107074>>>>>>>>>        If (iOrig=0 or  low(iSiz)>=iOrig) Begin
107076>>>>>>>>>            Procedure_Return
107077>>>>>>>>>        End
107077>>>>>>>>>>
107077>>>>>>>>>        If (iDelta+iCur<0) Begin
107079>>>>>>>>>            Move (-iCur) to iDelta
107080>>>>>>>>>        End
107080>>>>>>>>>>
107080>>>>>>>>>        Else If (iDelta+iCur>iOrig - iHeight) Begin
107083>>>>>>>>>            Move (iOrig - iHeight - iCur) to iDelta
107084>>>>>>>>>        End
107084>>>>>>>>>>
107084>>>>>>>>>        If (iDelta=0) ;            Procedure_Return
107087>>>>>>>>>        
107087>>>>>>>>>        Move (iCur + iDelta) to iCur
107088>>>>>>>>>        Set piCurrentHorzScrolled to iCur
107089>>>>>>>>>        Send SetScrollBarPosInfo False iCur
107090>>>>>>>>>        Get GuiLocation to iSiz
107091>>>>>>>>>        Set GuiLocation to (cast(hi(iSiz),Short)) (cast(low(iSiz),Short) -iDelta)
107092>>>>>>>>>        Send ScrollClientArea
107093>>>>>>>>>    End_Procedure
107094>>>>>>>>>    
107094>>>>>>>>>    // make sure client is a 0,0
107094>>>>>>>>>    Procedure ScrollHome
107096>>>>>>>>>        Send SetVScrollbox SB_TOP 0
107097>>>>>>>>>        Send SetHScrollbox SB_TOP 0
107098>>>>>>>>>    End_Procedure
107099>>>>>>>>>    
107099>>>>>>>>>    // get relative GUI location of this object to the parent one passed.
107099>>>>>>>>>    Procedure LocationRelativeTo Handle hoContainer Handle hoControl Integer ByRef iLocY Integer ByRef iLocX
107101>>>>>>>>>        Integer ivoid
107101>>>>>>>>>        tWinRect Rect0 Rect1
107101>>>>>>>>>        tWinRect Rect0 Rect1
107101>>>>>>>>>        Move (GetWindowRect(window_handle(hoContainer),addressof(Rect0))) to ivoid
107102>>>>>>>>>        Move (GetWindowRect(window_handle(hoControl),addressof(Rect1))) to ivoid
107103>>>>>>>>>        Move ((Rect1.top) - (Rect0.top)) to iLocY
107104>>>>>>>>>        Move ((rect1.left) - (rect0.left)) to iLocX
107105>>>>>>>>>    End_Procedure
107106>>>>>>>>>    
107106>>>>>>>>>    // This scrolls this object into visual range.
107106>>>>>>>>>    Procedure ScrollObjectInRange Handle hoControl
107108>>>>>>>>>        Handle hoScrollingContainer
107108>>>>>>>>>        Integer iCurrentVertScrolled iCurrentHorzScrolled
107108>>>>>>>>>        Integer iViewHeight iViewWidth
107108>>>>>>>>>        Integer iRelLocHeight iRelLocWidth
107108>>>>>>>>>        Integer iSize iControlHeight iControlWidth
107108>>>>>>>>>        Integer iScroll
107108>>>>>>>>>        Integer iMarginX iMarginY
107108>>>>>>>>>        Integer iScrollingContainerWindowSize iScrollingContainerClientSize
107108>>>>>>>>>        
107108>>>>>>>>>        Get piAutoScrollMarginX to iMarginX
107109>>>>>>>>>        Get piAutoScrollMarginY to iMarginY
107110>>>>>>>>>        
107110>>>>>>>>>        // the scrolling container
107110>>>>>>>>>        Move Self to hoScrollingContainer
107111>>>>>>>>>        // the amount the SC is currently scrolled
107111>>>>>>>>>        Get piCurrentVertScrolled of hoScrollingContainer to iCurrentVertScrolled
107112>>>>>>>>>        Get piCurrentHorzScrolled of hoScrollingContainer to iCurrentHorzScrolled
107113>>>>>>>>>        
107113>>>>>>>>>        // size of view's client area (this is the viewport area)
107113>>>>>>>>>        Get GuiClientSize of (Parent(hoScrollingContainer)) to iSize
107114>>>>>>>>>        Move (hi(iSize)) to iViewHeight
107115>>>>>>>>>        Move (low(iSize)) to iViewWidth
107116>>>>>>>>>        
107116>>>>>>>>>        // get this object's location relative to the scrolling container
107116>>>>>>>>>        Send LocationRelativeTo hoScrollingContainer hoControl (&iRelLocHeight) (&iRelLocWidth)
107117>>>>>>>>>        
107117>>>>>>>>>        // we expect that the client size is the window size but just in case
107117>>>>>>>>>        Get GuiWindowSize of hoScrollingContainer to iScrollingContainerWindowSize
107118>>>>>>>>>        Get GuiClientSize of hoScrollingContainer to iScrollingContainerClientSize
107119>>>>>>>>>        Move (iRelLocHeight - (Hi(iScrollingContainerWindowSize)-Hi(iScrollingContainerClientSize))) to iRelLocHeight
107120>>>>>>>>>        Move (iRelLocWidth - (Low(iScrollingContainerWindowSize)-Low(iScrollingContainerClientSize))) to iRelLocWidth
107121>>>>>>>>>        
107121>>>>>>>>>        // the outer size of the control object
107121>>>>>>>>>        Get GUIWindowSize of hoControl to iSize
107122>>>>>>>>>        Move (hi(iSize)) to iControlHeight
107123>>>>>>>>>        Move (low(iSize)) to iControlWidth
107124>>>>>>>>>        
107124>>>>>>>>>        // the general idea is to make the control fully visible but to scroll as little as possible.
107124>>>>>>>>>        
107124>>>>>>>>>        // Vertical Scroll
107124>>>>>>>>>        
107124>>>>>>>>>        // Vertical Scroll down
107124>>>>>>>>>        // if the bottom of the control plus a bottom margin does not fit make it fit at the bottom
107124>>>>>>>>>        If (iRelLocHeight + iControlHeight + iMarginY - iCurrentVertScrolled >iViewHeight) Begin
107126>>>>>>>>>            
107126>>>>>>>>>            // set scroll amount so that the bottom of the control is visible
107126>>>>>>>>>            Move (iRelLocHeight + iControlHeight + iMarginY - iCurrentVertScrolled - iViewHeight ) to iScroll
107127>>>>>>>>>            
107127>>>>>>>>>            // See if this amount, scrolls the top out of range. If so just scroll enough so that the
107127>>>>>>>>>            // top of the object appears at the bottom
107127>>>>>>>>>            If (iRelLocHeight - iCurrentVertScrolled < iScroll) Begin
107129>>>>>>>>>                Move (iRelLocHeight + iMarginY  - iCurrentVertScrolled - iViewHeight  ) to iScroll
107130>>>>>>>>>            End
107130>>>>>>>>>>
107130>>>>>>>>>            // if the scroll amnt is negative it's best to just keep it where it is.
107130>>>>>>>>>            If (iScroll>0) Begin
107132>>>>>>>>>                Send VScroll of hoScrollingContainer iScroll
107133>>>>>>>>>            End
107133>>>>>>>>>>
107133>>>>>>>>>        End
107133>>>>>>>>>>
107133>>>>>>>>>        // else vertical scroll up
107133>>>>>>>>>        // We scroll if the top of the object is not visible.
107133>>>>>>>>>        Else If (iRelLocHeight + iMarginY < iCurrentVertScrolled) Begin
107136>>>>>>>>>            // if we scroll we will scroll enough to see the top of the object.
107136>>>>>>>>>            Move (iRelLocHeight -iMarginY - iCurrentVertScrolled ) to iScroll
107137>>>>>>>>>            If (iScroll<0) Begin
107139>>>>>>>>>                Send VScroll of hoScrollingContainer (iScroll max (-iCurrentVertScrolled))
107140>>>>>>>>>            End
107140>>>>>>>>>>
107140>>>>>>>>>        End
107140>>>>>>>>>>
107140>>>>>>>>>        
107140>>>>>>>>>        // Horizonal Scroll
107140>>>>>>>>>        
107140>>>>>>>>>        // if the right side of the control does not fit, scroll it so it fits
107140>>>>>>>>>        If (iRelLocWidth + iControlWidth + iMarginX - iCurrentHorzScrolled >iViewWidth) Begin
107142>>>>>>>>>            Move (iRelLocWidth + iControlWidth + iMarginX - iCurrentHorzScrolled - iViewWidth ) to iScroll
107143>>>>>>>>>            If (iRelLocWidth - iCurrentHorzScrolled - iScroll<0) Begin
107145>>>>>>>>>                Move (iRelLocWidth  - iCurrentHorzScrolled - iMarginX ) to iScroll
107146>>>>>>>>>            End
107146>>>>>>>>>>
107146>>>>>>>>>            If (iScroll>0) Begin
107148>>>>>>>>>                Send HScroll of hoScrollingContainer iScroll
107149>>>>>>>>>            End
107149>>>>>>>>>>
107149>>>>>>>>>        End
107149>>>>>>>>>>
107149>>>>>>>>>        If (iRelLocWidth - iMarginX  - iCurrentHorzScrolled <0) Begin
107151>>>>>>>>>            // if this can fit by moving all the way to left, do so.
107151>>>>>>>>>            If (iRelLocWidth + iControlWidth + iMarginX <= iViewWidth) Begin
107153>>>>>>>>>                Move (-iCurrentHorzScrolled) to iScroll
107154>>>>>>>>>            End
107154>>>>>>>>>>
107154>>>>>>>>>            Else Begin
107155>>>>>>>>>                Move (iRelLocWidth - iCurrentHorzScrolled - iMarginX) to iScroll
107156>>>>>>>>>            End
107156>>>>>>>>>>
107156>>>>>>>>>            If (iScroll<0) Begin
107158>>>>>>>>>                Send HScroll of hoScrollingContainer (iScroll max (-iCurrentHorzScrolled))
107159>>>>>>>>>            End
107159>>>>>>>>>>
107159>>>>>>>>>        End
107159>>>>>>>>>>
107159>>>>>>>>>        
107159>>>>>>>>>        
107159>>>>>>>>>    End_Procedure
107160>>>>>>>>>    
107160>>>>>>>>>    // when we receive this message, we might need to scroll to bring the new focus in to view.
107160>>>>>>>>>    Procedure NotifyFocusSetInContainer Handle hoControl
107162>>>>>>>>>        Boolean bScrollOnFocus
107162>>>>>>>>>        Get pbAutoScrollFocus to bScrollOnFocus
107163>>>>>>>>>        If bScrollOnFocus Begin
107165>>>>>>>>>            Send ScrollObjectInRange hoControl
107166>>>>>>>>>        End
107166>>>>>>>>>>
107166>>>>>>>>>        Delegate Send NotifyFocusSetInContainer hoControl
107168>>>>>>>>>    End_Procedure
107169>>>>>>>>>    
107169>>>>>>>>>    
107169>>>>>>>>>    Function CenterTabWorkspaceView Returns Boolean
107171>>>>>>>>>        Boolean bCenter
107171>>>>>>>>>        Get pbCenterTabbedViews of ghoCommandBars to bCenter
107172>>>>>>>>>        Function_Return bCenter
107173>>>>>>>>>    End_Function
107174>>>>>>>>>    
107174>>>>>>>>>    Procedure AdjustSizesLocs Integer ByRef iHeight Integer ByRef iWidth Integer ByRef iLocY Integer ByRef iLocX
107176>>>>>>>>>        Boolean bTabWorkspaceView
107176>>>>>>>>>        Get pbTabWorkspaceView to bTabWorkspaceView
107177>>>>>>>>>        If bTabWorkspaceView Begin
107179>>>>>>>>>            Send AdjustTabWorkspaceView (&iHeight) (&iWidth) (&iLocY) (&iLocX)
107180>>>>>>>>>        End
107180>>>>>>>>>>
107180>>>>>>>>>    End_Procedure
107181>>>>>>>>>    
107181>>>>>>>>>    Function ParentView Returns Handle
107183>>>>>>>>>        Function_Return (Parent(Parent(Self)))
107184>>>>>>>>>    End_Function
107185>>>>>>>>>    
107185>>>>>>>>>    Procedure AdjustTabWorkspaceView Integer ByRef iHeight Integer ByRef iWidth Integer ByRef iLocY Integer ByRef iLocX
107187>>>>>>>>>        Integer iSize iMax iDiff
107187>>>>>>>>>        Handle hoView
107187>>>>>>>>>        Boolean bCenter bModal
107187>>>>>>>>>        Get ParentView to hoView
107188>>>>>>>>>        Get Block_Mouse_State of hoView to bModal
107189>>>>>>>>>        If not bModal Begin
107191>>>>>>>>>            Get CenterTabWorkspaceView to bCenter
107192>>>>>>>>>            Get GuiSize of hoView to iSize
107193>>>>>>>>>            Get piMaxSize of hoView to iMax
107194>>>>>>>>>            Get DialogToGui (Hi(iMax)) (Low(iMax)) to iMax
107195>>>>>>>>>            If (Low(iMax) and Low(iMax)<=Low(isize)) Begin
107197>>>>>>>>>                If bCenter Begin
107199>>>>>>>>>                    Move ((Low(iSize)-Low(iMax))/2) to iLocX
107200>>>>>>>>>                End
107200>>>>>>>>>>
107200>>>>>>>>>                Move (Low(iMax)) to iWidth
107201>>>>>>>>>            End
107201>>>>>>>>>>
107201>>>>>>>>>            If (Hi(iMax) and Hi(iMax)<=Hi(iSize)) Begin
107203>>>>>>>>>                If bCenter Begin
107205>>>>>>>>>                    Move ((Hi(iSize)-Hi(iMax))/2) to iLocY
107206>>>>>>>>>                    Move (iLocy min 25) to  iLocY
107207>>>>>>>>>                End
107207>>>>>>>>>>
107207>>>>>>>>>                Move (Hi(imax)) to iHeight
107208>>>>>>>>>            End
107208>>>>>>>>>>
107208>>>>>>>>>        End
107208>>>>>>>>>>
107208>>>>>>>>>    End_Procedure
107209>>>>>>>>>    
107209>>>>>>>>>    // Automatically determine if this is a scrolling tabbed workspace view
107209>>>>>>>>>    // If determines this by checking pbAutoSetTabWorkspaceView is set (it can be
107209>>>>>>>>>    // set to stop this), if we have a global commandbar object and we are using tabbed
107209>>>>>>>>>    // workspaces. We also make sure that the expected view object is a framework view class
107209>>>>>>>>>    // This should almost always yield the right answer.
107209>>>>>>>>>    // This is called by the scrolling container's end_constructor
107209>>>>>>>>>    Procedure AutoSetTabWorkspaceView
107211>>>>>>>>>        Boolean bTabView bIsView bAutoSetTabWorkspaceView
107211>>>>>>>>>        Handle hoParent
107211>>>>>>>>>        Integer iSize
107211>>>>>>>>>        Get pbAutoSetTabWorkspaceView to bAutoSetTabWorkspaceView
107212>>>>>>>>>        If (ghoCommandBars and bAutoSetTabWorkspaceView) Begin
107214>>>>>>>>>            Get pbTabbedWorkspaces of ghoCommandBars to bTabView
107215>>>>>>>>>            // not that pbTabbedWorkspaces is a designtime only property. You can not
107215>>>>>>>>>            // change this after the commandbar is paged.
107215>>>>>>>>>            If (bTabView) Begin
107217>>>>>>>>>                Get ParentView to hoParent
107218>>>>>>>>>                Get IsObjectOfClass of hoParent (RefClass(MdiDialog)) to bIsView
107219>>>>>>>>>                If (bIsView) Begin
107221>>>>>>>>>                    // set this as a tab workspace view
107221>>>>>>>>>                    Set pbTabWorkspaceView to True
107222>>>>>>>>>                    // when tab workspaces are enabled we always enable auto-scrolling
107222>>>>>>>>>                    // when tab workspaces are not enabled, pbScroll is whatever it is
107222>>>>>>>>>                    Set pbAutoScroll to True
107223>>>>>>>>>                    
107223>>>>>>>>>                End
107223>>>>>>>>>>
107223>>>>>>>>>            End
107223>>>>>>>>>>
107223>>>>>>>>>        End
107223>>>>>>>>>>
107223>>>>>>>>>    End_Procedure
107224>>>>>>>>>    
107224>>>>>>>>>End_Class
107225>>>>>>>>>
107225>>>>>>>>>// Container scrolling class support. Nothing in here is public
107225>>>>>>>>>Class cScrollingContainerMixin is a Mixin
107226>>>>>>>>>    
107226>>>>>>>>>    Procedure Define_cScrollingContainerMixin
107228>>>>>>>>>        Forward Set Border_Style to Border_None
107230>>>>>>>>>        Set pbSizeToClientArea to False // scrollbars and clientsize do not mix
107231>>>>>>>>>        Forward Set peAnchors to anAll
107233>>>>>>>>>        
107233>>>>>>>>>        // forcing scrollbars right away seems to make painting better
107233>>>>>>>>>        Set Window_Style WS_HSCROLL to True
107234>>>>>>>>>        Set Window_Style WS_VSCROLL to True
107235>>>>>>>>>        
107235>>>>>>>>>        Property Handle phoScrollingClientArea 0
107236>>>>>>>>>    End_Procedure
107237>>>>>>>>>    
107237>>>>>>>>>    // if anchors are changed, it will not work. We won't let that happen
107237>>>>>>>>>    Procedure Set peAnchors Integer eAnchors
107239>>>>>>>>>    End_Procedure
107240>>>>>>>>>    
107240>>>>>>>>>    // if a border style is set, it will not work. We won't let that happen
107240>>>>>>>>>    Procedure Set Border_Style Integer eStyle
107242>>>>>>>>>    End_Procedure
107243>>>>>>>>>    
107243>>>>>>>>>    // redirect scrollbar events and wheel events to the scrolling client area
107243>>>>>>>>>    Procedure OnWmMouseWheel Integer wParam Integer lParam
107245>>>>>>>>>        Handle hoClient
107245>>>>>>>>>        Get phoScrollingClientArea to hoClient
107246>>>>>>>>>        If hoClient Begin
107248>>>>>>>>>            Send OnMouseWheel of hoClient wParam lParam
107249>>>>>>>>>        End
107249>>>>>>>>>>
107249>>>>>>>>>    End_Procedure
107250>>>>>>>>>    
107250>>>>>>>>>    // should be sent by WM_VSCROLL
107250>>>>>>>>>    Procedure SetVScrollbox Integer iType Integer iNewPos
107252>>>>>>>>>        Handle hoClient
107252>>>>>>>>>        Get phoScrollingClientArea to hoClient
107253>>>>>>>>>        If hoClient Begin
107255>>>>>>>>>            Send SetVScrollbox of hoClient iType iNewPos
107256>>>>>>>>>        End
107256>>>>>>>>>>
107256>>>>>>>>>    End_Procedure
107257>>>>>>>>>    
107257>>>>>>>>>    // should be sent by WM_HSCROLL
107257>>>>>>>>>    Procedure SetHScrollbox Integer iType Integer iNewPos
107259>>>>>>>>>        Handle hoClient
107259>>>>>>>>>        Get phoScrollingClientArea to hoClient
107260>>>>>>>>>        If hoClient Begin
107262>>>>>>>>>            Send SetHScrollbox of hoClient iType iNewPos
107263>>>>>>>>>        End
107263>>>>>>>>>>
107263>>>>>>>>>    End_Procedure
107264>>>>>>>>>    
107264>>>>>>>>>    // augmented to adjust its size to the size of the parent client area.
107264>>>>>>>>>    // After this is set, anchors will handle any further resizing.
107264>>>>>>>>>    Procedure Page Integer iState
107266>>>>>>>>>        Integer iSiz iHeight iWidth
107266>>>>>>>>>        Integer iTop iBottom iLeft iRight iFontSize
107266>>>>>>>>>        Boolean bGroup
107266>>>>>>>>>        Handle hoClient
107266>>>>>>>>>        If (iState =1) Begin
107268>>>>>>>>>            Delegate Get Window_Style BS_GROUPBOX to bGroup
107270>>>>>>>>>            // We have special code to support groups because they
107270>>>>>>>>>            // draw a border inside of the client rectangle
107270>>>>>>>>>            If bGroup Begin
107272>>>>>>>>>                Get Physical_FontSize to iFontSize
107273>>>>>>>>>                Move (Hi(iFontSize)) to iTop
107274>>>>>>>>>                Move 2 to iLeft
107275>>>>>>>>>                Move 2 to iRight
107276>>>>>>>>>                Move 2 to iBottom
107277>>>>>>>>>            End
107277>>>>>>>>>>
107277>>>>>>>>>            // We use GetContainerClientSize instead of GuiClientSize because
107277>>>>>>>>>            // GetContainerClientSize has a special augmentation in tab pages that
107277>>>>>>>>>            // makes anchors work properly with unpaged tab-pages
107277>>>>>>>>>            Delegate Get GetContainerClientSize to iSiz
107279>>>>>>>>>            Set GuiSize to (Hi(iSiz)-(iTop+iBottom)) (Low(iSiz)-(iLeft+iRight))
107280>>>>>>>>>            Set GuiLocation to iTop iLeft
107281>>>>>>>>>            Send Adjust_Logicals
107282>>>>>>>>>        End
107282>>>>>>>>>>
107282>>>>>>>>>        Forward Send Page iState
107284>>>>>>>>>    End_Procedure
107285>>>>>>>>>    
107285>>>>>>>>>    Procedure End_Construct_Object
107287>>>>>>>>>        Handle hoClient
107287>>>>>>>>>        Forward Send End_Construct_Object
107289>>>>>>>>>        Get phoScrollingClientArea to hoClient
107290>>>>>>>>>        If (hoClient) Begin
107292>>>>>>>>>            Send AutoSetTabWorkspaceView of hoClient
107293>>>>>>>>>        End
107293>>>>>>>>>>
107293>>>>>>>>>    End_Procedure
107294>>>>>>>>>    
107294>>>>>>>>>End_Class
107295>>>>>>>
107295>>>>>>>Class cScrollingClientArea is a Container3d
107296>>>>>>>    Import_Class_Protocol cScrollingClientAreaMixin
107297>>>>>>>    Procedure Construct_Object
107299>>>>>>>        Forward Send Construct_Object
107301>>>>>>>        Send Define_cScrollingClientAreaMixin
107302>>>>>>>    End_Procedure
107303>>>>>>>End_Class
107304>>>>>>>
107304>>>>>>>
107304>>>>>>>
107304>>>>>>>Class cScrollingContainer is a Container3d
107305>>>>>>>    Import_Class_Protocol cScrollingContainerMixin
107306>>>>>>>    Procedure Construct_Object
107308>>>>>>>        Forward Send Construct_Object
107310>>>>>>>        Send Define_cScrollingContainerMixin
107311>>>>>>>    End_Procedure
107312>>>>>>>End_Class
107313>>>>>Use cRDCModalPanel.pkg
107313>>>>>Use cRDCForm.pkg
Including file: cRDCForm.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cRDCForm.pkg)
107313>>>>>>>//****************************************************************************
107313>>>>>>>// $Module type: Class
107313>>>>>>>// $Module name: cForm
107313>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International
107313>>>>>>>// Created     : 2014-03-17 @ 12:34
107313>>>>>>>//
107313>>>>>>>// Description :
107313>>>>>>>//
107313>>>>>>>// $Rev History:
107313>>>>>>>//    2014-03-17  Module header created
107313>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
107313>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
107313>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
107313>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
107313>>>>>>>// in the help folder for more details.
107313>>>>>>>//
107313>>>>>>>//****************************************************************************
107313>>>>>>>Use Windows.pkg
107313>>>>>>>
107313>>>>>>>Class cFormIdleHandler is a cIdleHandler
107314>>>>>>>    Procedure Construct_Object
107316>>>>>>>        Forward Send Construct_Object
107318>>>>>>>
107318>>>>>>>    End_Procedure
107319>>>>>>>
107319>>>>>>>    Procedure OnIdle
107321>>>>>>>        Delegate Send DoUpdate
107323>>>>>>>    End_Procedure
107324>>>>>>>
107324>>>>>>>End_Class
107325>>>>>>>
107325>>>>>>>Class cRDCForm is a Form
107326>>>>>>>
107326>>>>>>>    Procedure Construct_Object
107328>>>>>>>        Forward Send Construct_Object
107330>>>>>>>
107330>>>>>>>        Property Boolean pbAutoEnable False
107331>>>>>>>
107331>>>>>>>        Property Boolean pbEnabled True
107332>>>>>>>
107332>>>>>>>        Property Handle phoIdleHandler (Create(Self, RefClass(cFormIdleHandler)))
107333>>>>>>>
107333>>>>>>>        Set Label_Justification_mode to JMode_Right
107334>>>>>>>        Set Label_Col_Offset to 2
107335>>>>>>>        Set Label_Row_Offset to 0
107336>>>>>>>    End_Procedure
107337>>>>>>>
107337>>>>>>>    Procedure End_Construct_Object
107339>>>>>>>        String sTooltip sStatus_Help
107339>>>>>>>
107339>>>>>>>        Forward Send End_Construct_Object
107341>>>>>>>
107341>>>>>>>        Get psToolTip   to sTooltip
107342>>>>>>>        Get Status_Help to sStatus_Help
107343>>>>>>>        If (sTooltip = "" and sStatus_Help <> "") Begin
107345>>>>>>>            Set psToolTip to sStatus_Help
107346>>>>>>>        End
107346>>>>>>>>
107346>>>>>>>        Else If (sTooltip <> "" and sStatus_Help = "") Begin
107349>>>>>>>            Set Status_Help to sTooltip
107350>>>>>>>        End
107350>>>>>>>>
107350>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to (pbAutoEnable(Self))
107351>>>>>>>    End_Procedure
107352>>>>>>>
107352>>>>>>>    Procedure DoUpdate
107354>>>>>>>        If (pbAutoEnable(Self) = False) Begin
107356>>>>>>>            Procedure_Return
107357>>>>>>>        End
107357>>>>>>>>
107357>>>>>>>        Set Enabled_State to (IsEnabled(Self))
107358>>>>>>>    End_Procedure
107359>>>>>>>
107359>>>>>>>    Function IsEnabled Returns Boolean
107361>>>>>>>        Boolean bEnabled
107361>>>>>>>        Get pbEnabled to bEnabled
107362>>>>>>>        Function_Return bEnabled
107363>>>>>>>    End_Function
107364>>>>>>>
107364>>>>>>>    // Enable the idle handler timer when the object is activated
107364>>>>>>>    Procedure Activating
107366>>>>>>>        Forward Send Activating
107368>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to True
107369>>>>>>>    End_Procedure
107370>>>>>>>
107370>>>>>>>    // Disable the idle handler when the object is deactivated
107370>>>>>>>    Procedure Deactivating
107372>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to False
107373>>>>>>>        Forward Send Deactivating
107375>>>>>>>    End_Procedure
107376>>>>>>>
107376>>>>>>>End_Class
107377>>>>>Use cRDCComboForm.pkg
107377>>>>>Use cRDCButton.pkg
107377>>>>>Use cRDCHeaderGroup.pkg
107377>>>>>Use cDbDriverSettingsForm.pkg
Including file: cDbDriverSettingsForm.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbDriverSettingsForm.pkg)
107377>>>>>>>//****************************************************************************
107377>>>>>>>// $Module type: Class
107377>>>>>>>// $Module name: cDbDriverSettingsForm
107377>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International
107377>>>>>>>// Created     : 2014-03-17 @ 12:34
107377>>>>>>>//
107377>>>>>>>// Description :
107377>>>>>>>//
107377>>>>>>>// $Rev History:
107377>>>>>>>//    2014-03-17  Module header created
107377>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
107377>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
107377>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
107377>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
107377>>>>>>>// in the help folder for more details.
107377>>>>>>>//
107377>>>>>>>//****************************************************************************
107377>>>>>>>Use Windows.pkg
107377>>>>>>>Use seq_chnl.pkg
107377>>>>>>>
107377>>>>>>>Class cDbDriverSettingsForm is a Form
107378>>>>>>>
107378>>>>>>>    Procedure Construct_Object
107380>>>>>>>        Forward Send Construct_Object
107382>>>>>>>
107382>>>>>>>        Property Boolean private.pbDriverLoadingError False
107383>>>>>>>        
107383>>>>>>>        Set Label_Col_Offset to 2
107384>>>>>>>        Set Label_Justification_Mode to JMode_Right
107385>>>>>>>        Set Size to 11 125 
107386>>>>>>>        // We use these settings and not enabled_state to be able
107386>>>>>>>        // to show tooltips.
107386>>>>>>>        Set Color to clBtnFace
107387>>>>>>>        Set Focus_Mode to NonFocusable
107388>>>>>>>        Set peAnchors to anTopLeftRight
107389>>>>>>>
107389>>>>>>>        Property String psDriverIniFile ""
107390>>>>>>>    End_Procedure
107391>>>>>>>
107391>>>>>>>    Procedure Set psToolTip String sText
107393>>>>>>>        If (Trim(sText) = "") Begin
107395>>>>>>>            Move "No info available" to sText
107396>>>>>>>        End
107396>>>>>>>>
107396>>>>>>>        Forward Set psToolTip to sText
107398>>>>>>>    End_Procedure
107399>>>>>>>
107399>>>>>>>    Function psToolTip Returns String
107401>>>>>>>        String sTooltip sSearchValue
107401>>>>>>>
107401>>>>>>>        Get Label to sSearchValue
107402>>>>>>>        Get ExtractIniFileComment sSearchValue to sTooltip
107403>>>>>>>
107403>>>>>>>        Function_Return sTooltip
107404>>>>>>>    End_Function
107405>>>>>>>
107405>>>>>>>    Procedure SetValue String sDriver String sLabel Integer iAttribute
107407>>>>>>>        Integer iDriver
107407>>>>>>>        String sValue
107407>>>>>>>
107407>>>>>>>        // Sadly driver API attributes are only supported by the CLI-drivers,
107407>>>>>>>        // and the Pervasive driver is not amongst them. So do nothing if Pervasive.
107407>>>>>>>        If (sDriver <> DFBTRDRV_ID and sDriver <> DATAFLEX_ID) Begin
107409>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
107410>>>>>>>            Get DriverIndex of ghoSQLConnectionHandler sDriver to iDriver
107411>>>>>>>            Set private.pbDriverLoadingError to (iDriver = -1)
107412>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
107413>>>>>>>            If (iDriver <= 0) Begin
107415>>>>>>>                Procedure_Return
107416>>>>>>>            End
107416>>>>>>>>
107416>>>>>>>            // Set indicator to false prior asking for the driver attribute.
107416>>>>>>>            // This way we can decide to show the object or not, based on success/failure.
107416>>>>>>>            Move False to Err
107417>>>>>>>            Get_Attribute iAttribute of iDriver to sValue
107420>>>>>>>            If (sValue = "0") Begin
107422>>>>>>>                Move "0 (False)" to sValue
107423>>>>>>>            End
107423>>>>>>>>
107423>>>>>>>            If (sValue = "1") Begin
107425>>>>>>>                Move "1 (True)"  to sValue
107426>>>>>>>            End
107426>>>>>>>>
107426>>>>>>>            Set Value to sValue
107427>>>>>>>
107427>>>>>>>            Move (Replace("DF_DRIVER_", Uppercase(sLabel), "")) to sLabel
107428>>>>>>>            // Its a bit annoying reading all caps, so "proper" case
107428>>>>>>>            // all labels (DF_DRIVER_XXX values).
107428>>>>>>>            Get Propercase sLabel to sLabel
107429>>>>>>>            Set Label to sLabel
107430>>>>>>>
107430>>>>>>>            Get ExtractIniFileComment sLabel to sValue
107431>>>>>>>            Set Status_Help to sValue
107432>>>>>>>            Set psToolTip to sValue
107433>>>>>>>        End
107433>>>>>>>>
107433>>>>>>>    End_Procedure
107434>>>>>>>
107434>>>>>>>    // Pass a driver ini filename with path & a comment value to search for.
107434>>>>>>>    // Returns: The comments in the file as a string.
107434>>>>>>>    Function ExtractIniFileComment String sSearchValue Returns String
107436>>>>>>>        String sIniFile sValue sRetval sComment sCommentMarker
107436>>>>>>>        Boolean bCommentRow bStart
107436>>>>>>>        Integer iCh
107436>>>>>>>
107436>>>>>>>        Get psDriverIniFile to sIniFile
107437>>>>>>>        Move ";" to sCommentMarker
107438>>>>>>>        Get Seq_Open_Input_Channel sIniFile to iCh
107439>>>>>>>        While (SeqEof = False)
107443>>>>>>>            Readln channel iCh sValue
107445>>>>>>>            Move (Trim(sValue)) to sValue
107446>>>>>>>
107446>>>>>>>            // Check for a ";" at pos 1 & if the line contains the passed search value (driver attribute).
107446>>>>>>>            Move (Left(sValue, 1)) to sComment
107447>>>>>>>            If (bStart = False) Begin
107449>>>>>>>                Move (sComment = sCommentMarker and Lowercase(sValue) contains Lowercase(sSearchValue)) to bStart
107450>>>>>>>            End
107450>>>>>>>>
107450>>>>>>>            If (bStart = True) Begin
107452>>>>>>>                // Have we read past end of the comment for the driver attribute? If so, quit.
107452>>>>>>>                If (sComment <> sCommentMarker) Begin
107454>>>>>>>                    Move True to SeqEof
107455>>>>>>>                End
107455>>>>>>>>
107455>>>>>>>                Else Begin
107456>>>>>>>                    Move (sComment = sCommentMarker) to bCommentRow
107457>>>>>>>                    If (bCommentRow = True) Begin
107459>>>>>>>                        Move (Replace(sCommentMarker, sValue, "")) to sValue
107460>>>>>>>
107460>>>>>>>                        // Replace all double spaces with a single space character.
107460>>>>>>>                        Move (Replaces("  ", sValue, " ")) to sValue
107461>>>>>>>
107461>>>>>>>                        If (sRetval = "") Begin
107463>>>>>>>                            Move sValue to sRetval
107464>>>>>>>                        End
107464>>>>>>>>
107464>>>>>>>                        Else Begin
107465>>>>>>>                            Move (sRetval + " " + sValue) to sRetval
107466>>>>>>>                        End
107466>>>>>>>>
107466>>>>>>>                    End
107466>>>>>>>>
107466>>>>>>>                End
107466>>>>>>>>
107466>>>>>>>            End
107466>>>>>>>>
107466>>>>>>>        Loop
107467>>>>>>>>
107467>>>>>>>        Send Seq_Close_Channel iCh
107468>>>>>>>
107468>>>>>>>CompilerWarnings Off
107468>>>>>>>        // Replaces all double spaces with a single space character.
107468>>>>>>>        // The Replaces function doesn't quite work for this.
107468>>>>>>>        Repeat
107468>>>>>>>>
107468>>>>>>>            Replace "  " in sRetval with " "
107472>>>>>>>        Until (FindErr)
107474>>>>>>>        
107474>>>>>>>        Function_Return sRetval
107475>>>>>>>    End_Function
107476>>>>>>>CompilerWarnings On
107476>>>>>>>
107476>>>>>>>    Function Propercase String sText Returns String 
107478>>>>>>>        String[] sDelimiters
107479>>>>>>>        Integer iPos
107479>>>>>>>        
107479>>>>>>>        //Lowercase everything and we'll handle uppercase by exception
107479>>>>>>>        Move (Lowercase(sText)) to sText
107480>>>>>>>        
107480>>>>>>>        Move " " to sDelimiters[SizeOfArray(sDelimiters)]
107481>>>>>>>        Move "-" to sDelimiters[SizeOfArray(sDelimiters)]
107482>>>>>>>        Move "_" to sDelimiters[SizeOfArray(sDelimiters)]
107483>>>>>>>        
107483>>>>>>>        For iPos from 1 to (Length(sText)) // 1 based loop to match MID and OVERSTRIKE
107489>>>>>>>>
107489>>>>>>>            //If the previous character is a space, uppercase the current one (alway upper the first char)
107489>>>>>>>            If ((iPos = 1) or (SearchArray( Mid(sText, 1, (iPos - 1)), sDelimiters) <> -1)) ;                Move (Overstrike( Uppercase(Mid(sText, 1, iPos)), sText, iPos )) to sText
107492>>>>>>>        Loop
107493>>>>>>>>
107493>>>>>>>        
107493>>>>>>>        Function_Return sText
107494>>>>>>>    End_Function
107495>>>>>>>
107495>>>>>>>End_Class
107496>>>>>Use cDbUpdateFunctionLibrary.pkg
107496>>>>>
107496>>>>>Register_Procedure psOrgToolTip String sTooltip
107496>>>>>
107496>>>>>Object oDriverSettings_dg is a cRDCModalPanel
107498>>>>>    Set Size to 291 345
107499>>>>>    Set Label to "Driver Configuration File Info"
107500>>>>>    Set Location to 2 2
107501>>>>>    Set Maximize_Icon to False
107502>>>>>    Set Locate_Mode to CENTER_ON_PARENT
107503>>>>>    Set Icon to "DriverSettings1.ico"
107504>>>>>    
107504>>>>>    Property String psDriverID MSSQLDRV_ID
107506>>>>>    Property Boolean pbDriverLoadingError False
107508>>>>>    
107508>>>>>    Object oCancel_Btn is a cRDCButton
107510>>>>>        Set Label    to "&Close"
107511>>>>>        Set Location to 269 287
107512>>>>>        Set peAnchors to anBottomRight
107513>>>>>
107513>>>>>        Procedure OnClick
107516>>>>>            Send Close_Panel
107517>>>>>        End_Procedure
107518>>>>>
107518>>>>>    End_Object
107519>>>>>
107519>>>>>    Object oDriver_cf is a cRDCComboForm
107521>>>>>        Set Label to "Database Driver"
107522>>>>>        Set Size to 13 80
107523>>>>>        Set Location to 8 90
107524>>>>>        Set Form_Border to 0
107525>>>>>        Set Label_Col_Offset to 2
107526>>>>>        Set Label_Justification_Mode to JMode_Right
107527>>>>>        Set Status_Help to "Database driver."
107528>>>>>        Set Enabled_State to False
107529>>>>>        Set Skip_State to True
107530>>>>>
107530>>>>>        Procedure Combo_Fill_List
107533>>>>>            Send Combo_Add_Item DATAFLEX_ID
107534>>>>>            Send Combo_Add_Item DFBTRDRV_ID
107535>>>>>            Send Combo_Add_Item ODBC_DRV_ID
107536>>>>>            Send Combo_Add_Item MSSQLDRV_ID
107537>>>>>            Send Combo_Add_Item DB2_DRV_ID
107538>>>>>        End_Procedure
107539>>>>>
107539>>>>>    End_Object
107540>>>>>
107540>>>>>    Object oDriverFileName_cf is a cRDCForm
107542>>>>>        Set Label to "Database Driver File"
107543>>>>>        Set Size to 12 193
107544>>>>>        Set Location to 24 90
107545>>>>>        Set Label_Col_Offset to 2
107546>>>>>        Set Label_Justification_Mode to JMode_Right
107547>>>>>        Set Status_Help to "Database driver to be used when creating new tables."
107548>>>>>        Set Color to clBtnFace
107549>>>>>        Set Focus_Mode to NonFocusable
107550>>>>>        Set peAnchors to anTopLeftRight
107551>>>>>
107551>>>>>        Procedure OnChange
107554>>>>>            String sDriverID sValue sDriverIntFileName sTooltip sPath
107554>>>>>
107554>>>>>            Forward Send OnChange
107556>>>>>            Get Value to sValue
107557>>>>>            Set Status_Help to sValue
107558>>>>>
107558>>>>>            Get psDriverID to sDriverID
107559>>>>>            If (sDriverID <> DATAFLEX_ID) Begin
107561>>>>>                Get DatabaseDriverIniFilePath sDriverID to sPath
107562>>>>>                If (sPath <> "") Begin
107564>>>>>                    Move (sPath + sDriverID + ".int") to sDriverIntFileName
107565>>>>>                End
107565>>>>>>
107565>>>>>            End
107565>>>>>>
107565>>>>>            Else Begin
107566>>>>>                Move sDriverID to sDriverIntFileName
107567>>>>>            End
107567>>>>>>
107567>>>>>
107567>>>>>            Set Value of oDriverIniFile_fm to sDriverIntFileName
107568>>>>>            Get psOrgToolTip of oDriverIniFile_fm to sTooltip
107569>>>>>            Set Status_Help of oDriverIniFile_fm to (sTooltip * sDriverIntFileName)
107570>>>>>
107570>>>>>            // In case driver attribute objects already exists; destroy them
107570>>>>>            Broadcast Send Destroy    of oScrollingClientArea
107572>>>>>            // Then recreate them to show driver attributes
107572>>>>>            Send DoReadDriverSettings of oScrollingClientArea sDriverID
107573>>>>>        End_Procedure  
107574>>>>>        
107574>>>>>    End_Object
107575>>>>>
107575>>>>>    Object oDriverInfo_btn is a cRDCButton
107577>>>>>        Set Size to 13 50
107578>>>>>        Set Location to 24 287
107579>>>>>        Set Label to "Version Info"
107580>>>>>        Set Status_Help to "Shows a dialog with driver properties and SQL client software version(s), license info and more."
107581>>>>>        Set peAnchors to anTopRight
107582>>>>>
107582>>>>>        Procedure OnClick
107585>>>>>            Object oSysInfoDialog is a SysInfoDialog
107587>>>>>            End_Object
107588>>>>>
107588>>>>>            Send Popup of oSysInfoDialog
107589>>>>>        End_Procedure
107590>>>>>    End_Object
107591>>>>>
107591>>>>>    Object oDriverIniFile_fm is a cRDCForm
107593>>>>>        Set Size to 13 193
107594>>>>>        Set Location to 39 90
107595>>>>>        Set Label_Col_Offset to 2
107596>>>>>        Set Label_Justification_Mode to JMode_Right
107597>>>>>        Set Label to "Driver Configuration File"
107598>>>>>        Set peAnchors to anTopLeftRight
107599>>>>>        Set Color to clBtnFace
107600>>>>>        Set Focus_Mode to NonFocusable
107601>>>>>        Property String psOrgToolTip "The file is the first found in the DF_OPEN_PATH path string."
107603>>>>>        Set Status_Help to (psOrgToolTip(Self))
107604>>>>>    End_Object
107605>>>>>
107605>>>>>    Object oOpenDriverFile_Btn is a cRDCButton
107607>>>>>        Set Size to 13 50
107608>>>>>        Set Label to "Edit File"
107609>>>>>        Set Location to 39 287
107610>>>>>        Set Status_Help to "Opens the driver configuration file that contains configuration settings that are used when tables are restructured, in Notepad."
107611>>>>>        Set psImage to "ActionEdit1.ico"
107612>>>>>        Set peAnchors to anTopRight
107613>>>>>        Set pbAutoEnable to True
107614>>>>>
107614>>>>>        Procedure OnClick
107617>>>>>            String sFileName
107617>>>>>            Get Value of oDriverIniFile_fm to sFileName
107618>>>>>            If (sFileName <> DATAFLEX_ID) Begin
107620>>>>>                Runprogram Background "Notepad.exe" sFileName
107621>>>>>            End
107621>>>>>>
107621>>>>>            Else Begin
107622>>>>>                Send Info_Box "Sorry, there exist no driver ini file for the DataFlex database driver, so nothing to show here."
107623>>>>>            End
107623>>>>>>
107623>>>>>        End_Procedure   
107624>>>>>        
107624>>>>>        Function IsEnabled Returns Boolean
107627>>>>>            String sFileName
107627>>>>>            Get Value of oDriverFileName_cf to sFileName
107628>>>>>            Function_Return (sFileName <> "")
107629>>>>>        End_Function
107630>>>>>
107630>>>>>    End_Object
107631>>>>>
107631>>>>>    Object oDumpDriverData_Btn is a cRDCButton
107633>>>>>        Set Size to 13 50
107634>>>>>        Set Label to "Dump"
107635>>>>>        Set Location to 54 233
107636>>>>>        Set peAnchors to anTopRight
107637>>>>>        Set psToolTip to "Dumps the current status of the Connectivity Kit driver to an ASCII disk file."
107638>>>>>        Set psImage to "ActionExport1.ico"
107639>>>>>        Set pbAutoEnable to True
107640>>>>>        
107640>>>>>        Procedure OnClick
107643>>>>>            Handle hoCLI
107643>>>>>            String sDriver sPath sFileName
107643>>>>>            Integer iRetval
107643>>>>>
107643>>>>>            Get psDriverID to sDriver
107644>>>>>            Get Create (RefClass(cCLIHandler)) to hoCLI
107645>>>>>            Set psDriverID of hoCLI  to sDriver
107646>>>>>            If (sDriver = DATAFLEX_ID or sDriver = DFBTRDRV_ID) Begin
107648>>>>>                Send Destroy of hoCLI
107649>>>>>                Send Info_Box "Sorry, no attributes can be shown for the selected database driver."
107650>>>>>                Procedure_Return
107651>>>>>            End
107651>>>>>>
107651>>>>>
107651>>>>>            Get psHome of (phoWorkspace(ghoApplication)) to sPath
107652>>>>>            Get vFolderFormat sPath to sPath
107653>>>>>            Move (sDriver + "dump.txt") to sFileName
107654>>>>>            Send DumpStatus of hoCLI (sPath + sFileName)
107655>>>>>            Send Destroy of hoCLI
107656>>>>>
107656>>>>>            Send vShellExecute "open" sFileName "" sPath
107657>>>>>            Sleep 1
107658>>>>>            Get vDeleteFile (sPath + sFileName) to iRetval
107659>>>>>        End_Procedure
107660>>>>>
107660>>>>>        Function IsEnabled Returns Boolean
107663>>>>>            String sFileName
107663>>>>>            Boolean bDriverLoadingError 
107663>>>>>            Get pbDriverLoadingError to bDriverLoadingError
107664>>>>>            Get Value of oDriverFileName_cf to sFileName
107665>>>>>            Function_Return (sFileName <> "" and bDriverLoadingError = False)
107666>>>>>        End_Function
107667>>>>>
107667>>>>>    End_Object
107668>>>>>
107668>>>>>    Object oReset_Btn is a cRDCButton
107670>>>>>        Set Size to 13 50
107671>>>>>        Set Label to "Refresh"
107672>>>>>        Set Status_Help to "If you edit the driver configuration file, the display of attributes above needs to be refreshed. Click here to refresh."
107673>>>>>        Set Location to 54 287
107674>>>>>        Set psImage to "ActionRefresh1.ico"
107675>>>>>        Set peAnchors to anTopRight
107676>>>>>        Set pbAutoEnable to True
107677>>>>>
107677>>>>>        Procedure OnClick
107680>>>>>            String sDriver
107680>>>>>            Get psDriverID to sDriver
107681>>>>>            Unload_Driver sDriver
107682>>>>>            Load_Driver sDriver
107683>>>>>            Send Info_Box "This dialog needs to be re-opened to display the refreshed values. Dialog will now close and you need to re-open it manually."
107684>>>>>            Send Close_Panel
107685>>>>>        End_Procedure
107686>>>>>
107686>>>>>        Function IsEnabled Returns Boolean
107689>>>>>            String sFileName
107689>>>>>            Boolean bDriverLoadingError 
107689>>>>>            Get pbDriverLoadingError to bDriverLoadingError
107690>>>>>            Get Value of oDriverFileName_cf to sFileName
107691>>>>>            Function_Return (sFileName <> "" and bDriverLoadingError = False)
107692>>>>>        End_Function
107693>>>>>
107693>>>>>    End_Object
107694>>>>>
107694>>>>>    Object oDriverSetings_grp is a cRDCHeaderGroup
107696>>>>>        Set Size to 125 328
107697>>>>>        Set Location to 74 9
107698>>>>>        Set psImage to "DriverSettings1.ico"
107699>>>>>        Set Label to "Driver Configuration File Settings"   
107700>>>>>        Set psNote to "Hover the mouse over an attribute field to read information about it."
107701>>>>>        Set peAnchors to anAll
107702>>>>>
107702>>>>>        Object oInvisible_Container is a Container3d
107704>>>>>            Set Size to 100 327
107705>>>>>            Set Location to 24 0
107706>>>>>            Set Border_Style to Border_None
107707>>>>>            Set peAnchors to anAll
107708>>>>>    
107708>>>>>            Object oScrollingContainer is a cScrollingContainer
107710>>>>>               
107710>>>>>                Object oScrollingClientArea is a cScrollingClientArea
107712>>>>>
107712>>>>>                    // Just fill the array with all available driver attributes from Cli.pkg,
107712>>>>>                    // and one object will automatically be created for each attribute
107712>>>>>                    // for the current driver by the DoReadDriverSettings procedure.
107712>>>>>                    Function GeneralDriverAttributes Returns String[]
107715>>>>>                        String[] sAttributesArray
107716>>>>>    
107716>>>>>                        Move "DF_DRIVER_DEFAULT_DEFAULT_ASCII             |CI1101" to sAttributesArray[SizeOfArray(sAttributesArray)]
107717>>>>>                        Move "DF_DRIVER_DEFAULT_NULLABLE_ASCII            |CI1102" to sAttributesArray[SizeOfArray(sAttributesArray)]
107718>>>>>                        Move "DF_DRIVER_DEFAULT_DEFAULT_NUMERIC           |CI1103" to sAttributesArray[SizeOfArray(sAttributesArray)]
107719>>>>>                        Move "DF_DRIVER_DEFAULT_NULLABLE_NUMERIC          |CI1104" to sAttributesArray[SizeOfArray(sAttributesArray)]
107720>>>>>                        Move "DF_DRIVER_DEFAULT_DEFAULT_DATE              |CI1105" to sAttributesArray[SizeOfArray(sAttributesArray)]
107721>>>>>                        Move "DF_DRIVER_DEFAULT_NULLABLE_DATE             |CI1106" to sAttributesArray[SizeOfArray(sAttributesArray)]
107722>>>>>                        Move "DF_DRIVER_DEFAULT_DEFAULT_TEXT              |CI1107" to sAttributesArray[SizeOfArray(sAttributesArray)]
107723>>>>>                        Move "DF_DRIVER_DEFAULT_NULLABLE_TEXT             |CI1108" to sAttributesArray[SizeOfArray(sAttributesArray)]
107724>>>>>                        Move "DF_DRIVER_DEFAULT_DEFAULT_BINARY            |CI1109" to sAttributesArray[SizeOfArray(sAttributesArray)]
107725>>>>>                        Move "DF_DRIVER_DEFAULT_NULLABLE_BINARY           |CI1110" to sAttributesArray[SizeOfArray(sAttributesArray)]
107726>>>>>                        Move "DF_DRIVER_DUMMY_ZERO_DATE_VALUE             |CI1111" to sAttributesArray[SizeOfArray(sAttributesArray)]
107727>>>>>                        Move "DF_DRIVER_MAX_ACTIVE_STATEMENTS             |CI1112" to sAttributesArray[SizeOfArray(sAttributesArray)]
107728>>>>>                        Move "DF_DRIVER_CACHE_PATH                        |CI1113" to sAttributesArray[SizeOfArray(sAttributesArray)]
107729>>>>>                        Move "DF_DRIVER_DRIVER_DECIMAL_SEPARATOR          |CI1114" to sAttributesArray[SizeOfArray(sAttributesArray)]
107730>>>>>                        Move "DF_DRIVER_DEFAULT_TABLE_CHARACTER_FORMAT    |CI1115" to sAttributesArray[SizeOfArray(sAttributesArray)]
107731>>>>>                        Move "DF_DRIVER_DRIVER_THOUSANDS_SEPARATOR        |CI1116" to sAttributesArray[SizeOfArray(sAttributesArray)]
107732>>>>>                        Move "DF_DRIVER_APPLICATION_CHARACTER_FORMAT      |CI1117" to sAttributesArray[SizeOfArray(sAttributesArray)]
107733>>>>>                        Move "DF_DRIVER_DRIVER_DATE_FORMAT                |CI1118" to sAttributesArray[SizeOfArray(sAttributesArray)]
107734>>>>>                        Move "DF_DRIVER_LAST_ERROR_TEXT                   |CI1119" to sAttributesArray[SizeOfArray(sAttributesArray)]
107735>>>>>                        Move "DF_DRIVER_DRIVER_DATE_SEPARATOR             |CI1120" to sAttributesArray[SizeOfArray(sAttributesArray)]
107736>>>>>    
107736>>>>>                        // Exception to the rule!
107736>>>>>                        // Someone - in its infinite wisdome - decided that the keyword in the ini file should be "DFConnectionId",
107736>>>>>                        // and not "Connection_ID" that is the API attribute name. This brakes the cDriverSettingsForm tooltip logic.
107736>>>>>                        // We fix it by changing the attribute constant string here (removed the _ (underscore) before the "ID" part.
107736>>>>>                        Move "DF_DRIVER_CONNECTIONID                      |CI1121" to sAttributesArray[SizeOfArray(sAttributesArray)]
107737>>>>>                        Move "DF_DRIVER_IGNORE_UCASE_SUPPORT              |CI1122" to sAttributesArray[SizeOfArray(sAttributesArray)]
107738>>>>>                        Move "DF_DRIVER_CONNECTION_ID_STRING              |CI1123" to sAttributesArray[SizeOfArray(sAttributesArray)]
107739>>>>>    
107739>>>>>                        Move "DF_DRIVER_IGNORE_WARNINGS                   |CI1124" to sAttributesArray[SizeOfArray(sAttributesArray)]
107740>>>>>                        Move "DF_DRIVER_USE_DF_LOCKERROR                  |CI1126" to sAttributesArray[SizeOfArray(sAttributesArray)]
107741>>>>>                        Move "DF_DRIVER_FIND_CACHE_TIMEOUT                |CI1128" to sAttributesArray[SizeOfArray(sAttributesArray)]
107742>>>>>                        Move "DF_DRIVER_JIT_TRESHOLD                      |CI1130" to sAttributesArray[SizeOfArray(sAttributesArray)]
107743>>>>>                        Move "DF_DRIVER_TRUNCATE_BINARY_ZEROES            |CI1132" to sAttributesArray[SizeOfArray(sAttributesArray)]
107744>>>>>                        Move "DF_DRIVER_ERROR_DEBUG_MODE                  |CI1134" to sAttributesArray[SizeOfArray(sAttributesArray)]
107745>>>>>                        Move "DF_DRIVER_USE_CACHE                         |CI1136" to sAttributesArray[SizeOfArray(sAttributesArray)]
107746>>>>>                        Move "DF_DRIVER_REPORT_CACHE_ERRORS               |CI1138" to sAttributesArray[SizeOfArray(sAttributesArray)]
107747>>>>>                        Move "DF_DRIVER_USE_CACHE_EXPIRATION              |CI1140" to sAttributesArray[SizeOfArray(sAttributesArray)]
107748>>>>>                        Move "DF_DRIVER_DEFAULT_USE_DUMMY_ZERO_DATE       |CI1142" to sAttributesArray[SizeOfArray(sAttributesArray)]
107749>>>>>                        Move "DF_DRIVER_DEFAULT_RECORD_IDENTITY_HIDING    |CI1144" to sAttributesArray[SizeOfArray(sAttributesArray)]
107750>>>>>                        Move "DF_DRIVER_REPORT_ACTIVE_COLUMN_ERRORS       |CI1146" to sAttributesArray[SizeOfArray(sAttributesArray)]
107751>>>>>                        Move "DF_DRIVER_SILENT_LOGIN                      |CI1148" to sAttributesArray[SizeOfArray(sAttributesArray)]
107752>>>>>                        Move "DF_DRIVER_DEFAULT_MAP_TO_RECNUM             |CI1150" to sAttributesArray[SizeOfArray(sAttributesArray)]
107753>>>>>                        Move "DF_DRIVER_CONNECTION_ID_OPTIONS             |CI1152" to sAttributesArray[SizeOfArray(sAttributesArray)]
107754>>>>>                        Move "DF_DRIVER_NUMBER_CONNECTION_IDS             |CI1154" to sAttributesArray[SizeOfArray(sAttributesArray)]
107755>>>>>                        Move "DF_DRIVER_DEFAULT_DEFAULT_DATETIME          |CI1155" to sAttributesArray[SizeOfArray(sAttributesArray)]
107756>>>>>                        Move "DF_DRIVER_DEFAULT_NULLABLE_DATETIME         |CI1156" to sAttributesArray[SizeOfArray(sAttributesArray)]
107757>>>>>                        Move "DF_DRIVER_MATCH_CLIENT_SERVER_VERSION       |CI1158" to sAttributesArray[SizeOfArray(sAttributesArray)]
107758>>>>>                        Move "DF_DRIVER_SQLSERVER_CLIENT_VERSION          |CI1160" to sAttributesArray[SizeOfArray(sAttributesArray)]
107759>>>>>                        Move "DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE            |CI1168" to sAttributesArray[SizeOfArray(sAttributesArray)]
107760>>>>>                        Move "DF_DRIVER_MAP_DFDATE_TO_SQLTYPE             |CI1169" to sAttributesArray[SizeOfArray(sAttributesArray)]
107761>>>>>                        Move "DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE        |CI1170" to sAttributesArray[SizeOfArray(sAttributesArray)]
107762>>>>>                        Move "DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE         |CI1171" to sAttributesArray[SizeOfArray(sAttributesArray)]
107763>>>>>                        Move "DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE           |CI1172" to sAttributesArray[SizeOfArray(sAttributesArray)]
107764>>>>>                        Move "DF_DRIVER_MAP_DFASCII_TO_SQLTYPE            |CI1173" to sAttributesArray[SizeOfArray(sAttributesArray)]
107765>>>>>                        Move "DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE            |CI1174" to sAttributesArray[SizeOfArray(sAttributesArray)]
107766>>>>>                        Move "DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE             |CI1175" to sAttributesArray[SizeOfArray(sAttributesArray)]
107767>>>>>                        Move "DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE          |CI1176" to sAttributesArray[SizeOfArray(sAttributesArray)]
107768>>>>>                        Move "DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE           |CI1177" to sAttributesArray[SizeOfArray(sAttributesArray)]
107769>>>>>                        Move "DF_DRIVER_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA |CI1178" to sAttributesArray[SizeOfArray(sAttributesArray)]
107770>>>>>                        Move "DF_DRIVER_LOGIN_ON_OPEN                     |CI1180" to sAttributesArray[SizeOfArray(sAttributesArray)]
107771>>>>>                        Move "DF_DRIVER_MINIMUM_CLIENT_VERSION            |CI1182" to sAttributesArray[SizeOfArray(sAttributesArray)]
107772>>>>>    
107772>>>>>                        // Sort items alphabetically
107772>>>>>                        Move (SortArray(sAttributesArray)) to sAttributesArray
107773>>>>>                        Function_Return sAttributesArray
107774>>>>>                    End_Function
107775>>>>>    
107775>>>>>                    Function SplitValue String sValue Integer ByRef iAttribute Returns String
107778>>>>>                        String sAttribute sTmp
107778>>>>>                        Integer iPos
107778>>>>>    
107778>>>>>                        Move (Pos("|", sValue)) to iPos
107779>>>>>                        Move (Left(sValue, (iPos -1))) to sAttribute
107780>>>>>                        Move (Mid(sValue, Length(sValue), iPos)) to sTmp
107781>>>>>                        Move (Trim(sAttribute)) to sAttribute
107782>>>>>                        Move (Eval(sTmp)) to iAttribute
107783>>>>>    
107783>>>>>                        Function_Return sAttribute
107784>>>>>                    End_Function
107785>>>>>    
107785>>>>>                    // Note: Creates dynamic objects.
107785>>>>>                    // They are not being destroyed by this method.
107785>>>>>                    // It is the reponsibility of the calling method to do that,
107785>>>>>                    // prior calling this method.
107785>>>>>                    Procedure DoReadDriverSettings String sDriver
107788>>>>>                        Integer iLocW iLocH iHfactor iFirstLineOffset iCount iItems iAttribute
107788>>>>>                        Handle ho hoParent
107788>>>>>                        String[] sAttributesArray
107789>>>>>                        String sValue sAttribute sDriverIniFile 
107789>>>>>                        Boolean bDriverLoadingError
107789>>>>>    
107789>>>>>                        Move (Self) to hoParent
107790>>>>>                        Move 13  to iHfactor // Height offset between form
107791>>>>>                        Move 120 to iLocW
107792>>>>>                        Move 10  to iLocH                            
107793>>>>>                        Move  0  to iFirstLineOffset // Offset from the top for the very first object.
107794>>>>>    
107794>>>>>                        Get Value of oDriverIniFile_fm to sDriverIniFile
107795>>>>>                        If (Trim(sDriverIniFile) = "") Begin
107797>>>>>                            Get Create (RefClass(cDbDriverSettingsForm)) to ho
107798>>>>>                            Move (iFirstLineOffset + iLocH) to iLocH
107799>>>>>                            Set Location of ho to iLocH (iLocW + 30)
107800>>>>>                            Set Label of ho to "No Driver Configuration File found!"
107801>>>>>                            Set Value of ho to "No attributes to display..."   
107802>>>>>                            Procedure_Return
107803>>>>>                        End
107803>>>>>>
107803>>>>>                            
107803>>>>>                        // Driver attributes aren't supported by the Pervasive driver,
107803>>>>>                        // so notify and quite.
107803>>>>>                        If (sDriver = DFBTRDRV_ID or sDriver = DATAFLEX_ID) Begin
107805>>>>>                            Get Create (RefClass(cDbDriverSettingsForm)) to ho
107806>>>>>                            Move (iFirstLineOffset + iLocH) to iLocH
107807>>>>>                            Set Location of ho to iLocH (iLocW + 30)
107808>>>>>                            Set Label of ho to "Query of driver attributes unsupported!"
107809>>>>>                            Set Value of ho to "Sorry, no attributes to display"
107810>>>>>                            Procedure_Return
107811>>>>>                        End
107811>>>>>>
107811>>>>>    
107811>>>>>                        Get GeneralDriverAttributes to sAttributesArray
107812>>>>>                        Move (SizeOfArray(sAttributesArray)) to iItems
107813>>>>>                        Decrement iItems
107814>>>>>                        Send Ignore_Error of Error_Object_Id CLIERR_CONNECTIONIDOUTOFRANGE 
107815>>>>>                        Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE  // Invalid driver value
107816>>>>>    
107816>>>>>                        For iCount from 0 to iItems
107822>>>>>>
107822>>>>>                            Move sAttributesArray[iCount] to sValue
107823>>>>>                            Get SplitValue sValue (&iAttribute) to sAttribute
107824>>>>>    
107824>>>>>                            Get Create (RefClass(cDbDriverSettingsForm)) to ho 
107825>>>>>                            Set psDriverIniFile of ho to sDriverIniFile
107826>>>>>                            Send SetValue of ho sDriver sAttribute iAttribute
107827>>>>>                            Get private.pbDriverLoadingError of ho to bDriverLoadingError
107828>>>>>                            If (bDriverLoadingError = True) Begin
107830>>>>>                                Set Label of ho to "Driver could not be loaded!"   
107831>>>>>                                If (Trim(sDriverIniFile) = "") Begin
107833>>>>>                                    Set Value of ho to "Driver .dll file not found!"
107834>>>>>                                End
107834>>>>>>
107834>>>>>                                Else Begin
107835>>>>>                                    Set Value of ho to "No attributes to display..."   
107836>>>>>                                End
107836>>>>>>
107836>>>>>                                Set psToolTip of ho to "Check that the database engine for the selected driver is installed and is running correctly!"  
107837>>>>>                                Delegate Set pbDriverLoadingError to True
107839>>>>>                                Move iItems to iCount // We're out of here.   
107840>>>>>                                Move False to Err
107841>>>>>                            End
107841>>>>>>
107841>>>>>                            If (Err = True) Begin
107843>>>>>                                Send Destroy of ho
107844>>>>>                            End
107844>>>>>>
107844>>>>>                            Else Begin
107845>>>>>                                If (iCount = 0) Begin
107847>>>>>                                    Move (iFirstLineOffset + iLocH) to iLocH
107848>>>>>                                End
107848>>>>>>
107848>>>>>                                Set Location of ho to iLocH (iLocW + 30)
107849>>>>>                                Move (iLocH + iHfactor) to iLocH
107850>>>>>                            End
107850>>>>>>
107850>>>>>                        Loop
107851>>>>>>
107851>>>>>    
107851>>>>>                        Send Trap_Error of Error_Object_Id CLIERR_CONNECTIONIDOUTOFRANGE
107852>>>>>                        Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
107853>>>>>                    End_Procedure
107854>>>>>    
107854>>>>>                End_Object
107855>>>>>
107855>>>>>            End_Object
107856>>>>>    
107856>>>>>        End_Object
107857>>>>>
107857>>>>>    End_Object
107858>>>>>
107858>>>>>    Object oInfo_edt is a cRichEdit
107860>>>>>        Set Size to 49 328
107861>>>>>        Set Location to 213 9
107862>>>>>        Set Label to "General Connectivity Kit Information:"
107863>>>>>        Set Value to "It is possible to configure the behavior of a Connectivity Kit through configuration files. Configuration files can be located anywhere in DFPATH. In general, one configuration file per install is enough. There are situations where there is a need to have different configurations for different deploy environments on one machine/network. In that case the configuration file should be placed in the deployment environment rather than in the overall DataFlex environment."
107864>>>>>        Set Skip_State to True
107865>>>>>        Set Read_Only_State to True
107866>>>>>        Set pbItalics to True
107867>>>>>        Set peAnchors to anBottomLeftRight
107868>>>>>
107868>>>>>        Procedure DoIndent
107871>>>>>            Integer iTwipsPerInch iCurrentIndent
107871>>>>>        
107871>>>>>            // number of twips per inch
107871>>>>>            Move 1440 to iTwipsPerInch
107872>>>>>        
107872>>>>>            Set piSpacingBefore to (1440 * 0.05)
107873>>>>>            // indent 0.1 inches from current indentation
107873>>>>>            Get piParagraphIndent to iCurrentIndent
107874>>>>>            Set piParagraphIndent to (iCurrentIndent + (iTwipsPerInch * 0.1))
107875>>>>>        End_Procedure
107876>>>>>        Send DoIndent
107877>>>>>
107877>>>>>    End_Object
107878>>>>>
107878>>>>>    Procedure Activating
107881>>>>>        Forward Send Activating
107883>>>>>        Send Cursor_Ready of Cursor_Control
107884>>>>>    End_Procedure
107885>>>>>
107885>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
107886>>>>>    On_Key kCancel       Send KeyAction of oCancel_Btn
107887>>>>>End_Object
107888>>>>>
107888>>>>>// General purpose access method for the dialog above:
107888>>>>>Procedure PopupDriverSettings String sDriverID 
107891>>>>>    Handle ho
107891>>>>>    String sDriverFile sPath
107891>>>>>
107891>>>>>    Send Cursor_Wait of Cursor_Control
107892>>>>>    Move (oDriverSettings_dg(Self)) to ho
107893>>>>>    Set psDriverID of ho to sDriverID
107894>>>>>    Set pbDriverLoadingError of ho to False
107895>>>>>
107895>>>>>    Set Value of (oDriver_cf(ho)) to sDriverID
107896>>>>>    Get DatabaseDriverPath sDriverID to sPath
107897>>>>>    If (sPath <> "") Begin
107899>>>>>        Move (sDriverID + ".dll")  to sDriverFile
107900>>>>>    End
107900>>>>>>
107900>>>>>    Set Value of (oDriverFileName_cf(ho)) to (sPath + sDriverFile)
107901>>>>>    Send Cursor_Ready of Cursor_Control
107902>>>>>
107902>>>>>    Send Popup of ho
107903>>>>>End_Procedure
107904>>>>>
107904>>>>>Function DatabaseDriverPath String sDriverID Returns String
107907>>>>>    String sPath sDriverFileName
107907>>>>>
107907>>>>>    Move "" to sPath
107908>>>>>    If (sDriverID = DATAFLEX_ID) Begin
107910>>>>>        Function_Return sPath
107911>>>>>    End                   
107911>>>>>>
107911>>>>>    
107911>>>>>    Move (sDriverID + ".dll") to sDriverFileName
107912>>>>>    Get SearchLocallyThenGloballyForFile of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDriverFileName to sPath
107913>>>>>    
107913>>>>>    Function_Return sPath
107914>>>>>End_Function      
107915>>>>>
107915>>>>>Function DatabaseDriverIniFilePath String sDriverID Returns String
107918>>>>>    String sPath sDriverFileName
107918>>>>>
107918>>>>>    Move "" to sPath
107919>>>>>    If (sDriverID = DATAFLEX_ID) Begin
107921>>>>>        Function_Return sPath
107922>>>>>    End                   
107922>>>>>>
107922>>>>>    
107922>>>>>    Move (sDriverID + ".int") to sDriverFileName
107923>>>>>    Get SearchLocallyThenGloballyForFile of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDriverFileName to sPath
107924>>>>>    
107924>>>>>    Function_Return sPath
107925>>>>>End_Function      
107926>>>Use CreateDatabase.dg
Including file: CreateDatabase.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\CreateDatabase.dg)
107926>>>>>Use Windows.pkg
107926>>>>>Use cRDCModalPanel.pkg
107926>>>>>Use cRDCForm.pkg 
107926>>>>>Use cRDCComboForm.pkg
107926>>>>>Use cRDCSuggestionIniForm.pkg
Including file: cRDCSuggestionIniForm.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cRDCSuggestionIniForm.pkg)
107926>>>>>>>//****************************************************************************
107926>>>>>>>// $Module type: Class
107926>>>>>>>// $Module name: cRDCSuggestionIniForm
107926>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
107926>>>>>>>// Web-site    : http://www.rdctools.com
107926>>>>>>>// Created     : 2018-09-05 @ 09:50 (Military date format: YY-MM-DD)
107926>>>>>>>//
107926>>>>>>>// Description : The class consists of a variant of DataAccess Worldwide's cSuggestionFormList
107926>>>>>>>//               It has the added ability to save/retrieve values to the workspace .ws file.
107926>>>>>>>//
107926>>>>>>>// $Rev History:
107926>>>>>>>//    2018-09-05  Module header created
107926>>>>>>>//
107926>>>>>>>//****************************************************************************
107926>>>>>>>Use Windows.pkg
107926>>>>>>>Use Windows.pkg
107926>>>>>>>Use WinSuggestion.pkg
107926>>>>>>>Use cIniFile.pkg            
107926>>>>>>>Use cRDCForm.pkg
107926>>>>>>>Use vWin32fh.pkg
107926>>>>>>>
107926>>>>>>>    Define CS_cRDCSuggestionFormList       for "Suggestion Form List"  // [Section Name]
107926>>>>>>>    Define CS_cRDCSuggestionSaveItem       for "Saved Item"            // Key=Value
107926>>>>>>>    Define CS_cRDCSuggestionFormTooltip    for "This is a suggestion form - start typing what you're looking for. Previously entered values are saved automatically."
107926>>>>>>>
107926>>>>>>>Class cRDCSuggestionIniForm is a cRDCForm
107927>>>>>>>
107927>>>>>>>    Procedure Define_cRDCSuggestionControl_mixin
107929>>>>>>>
107929>>>>>>>        Property Integer piTimeOutTicks 0
107930>>>>>>>
107930>>>>>>>        On_Key kEnter            Send SelectSuggestion
107931>>>>>>>        On_Key Key_Escape        Send DeActivateSuggestionList
107932>>>>>>>        On_Key Key_Up_Arrow      Send Up
107933>>>>>>>        On_Key Key_Down_Arrow    Send Down
107934>>>>>>>
107934>>>>>>>        // Added 'Home' & 'End' navigation keys for the drop-down list and the form object (and Ctrl+Home & Ctrl+End).
107934>>>>>>>        On_Key Key_Home          Send Home
107935>>>>>>>        On_Key Key_Ctrl+Key_Home Send Home
107936>>>>>>>        On_Key Key_End           Send End
107937>>>>>>>        On_Key Key_Ctrl+Key_End  Send End // Need this as well; else the Ctrl+Home/End keys generates a runtime error (always has).
107938>>>>>>>
107938>>>>>>>        // Just can't seem to get the popup of the suggestion list with F4 to work.
107938>>>>>>>        On_Key kPrompt           Send Prompt
107939>>>>>>>    End_Procedure
107940>>>>>>>
107940>>>>>>>    Import_Class_Protocol cSuggestionControl_mixin
107941>>>>>>>    Import_Class_Protocol cSuggestion_mixin
107942>>>>>>>
107942>>>>>>>    Procedure Construct_Object
107944>>>>>>>        Forward Send Construct_Object
107946>>>>>>>        Send Define_cRDCSuggestionControl_mixin
107947>>>>>>>        Send Define_cSuggestion_mixin
107948>>>>>>>
107948>>>>>>>        Set peSuggestionMode to smCustom
107949>>>>>>>        Set pbFullText to True
107950>>>>>>>        Set piStartAtChar to 1
107951>>>>>>>
107951>>>>>>>        Property String[] psSavedFormValues
107952>>>>>>>        Property String psIniFileSection
107953>>>>>>>        Property Integer piSuggestionListMaxItems 99 // Max no of values saved/read to ini file
107954>>>>>>>        Property Boolean pbUseWorkspaceIniFile True
107955>>>>>>>        Property Boolean pbAutoCheckValueExistsAsFile True
107956>>>>>>>        Property Boolean pbAskToRemoveMissingFile True
107957>>>>>>>        // Note: pbUseWorkspaceIniFile has presedence over the psIniFileName setting.
107957>>>>>>>        //       That means that if pbUseWorkspaceIniFile=True, psIniFilename will be set to the
107957>>>>>>>        //       worspace .ws file on program startup.
107957>>>>>>>        Property String psIniFileName "RDCSuggestionForm.ini"
107958>>>>>>>    End_Procedure
107959>>>>>>>
107959>>>>>>>    Procedure ShowSuggestions
107961>>>>>>>        tSuggestion[] aResults
107961>>>>>>>        tSuggestion[] aResults
107962>>>>>>>        Integer i iLines
107962>>>>>>>        String sSearch
107962>>>>>>>
107962>>>>>>>
107962>>>>>>>        Get pSearchResults to aResults
107963>>>>>>>        Get Value to sSearch
107964>>>>>>>
107964>>>>>>>        If (ghoSuggestionList <> 0) Begin
107966>>>>>>>            Send Delete_Data of ghoSuggestionList
107967>>>>>>>            Move (SizeOfArray(aResults)) to iLines
107968>>>>>>>            For i from 0 to (iLines-1)
107974>>>>>>>>
107974>>>>>>>                Send ShowSuggestion aResults[i] sSearch
107975>>>>>>>                If ((iLines-1)<>i) Begin
107977>>>>>>>                    Send AppendTextLn of ghoSuggestionList ""
107978>>>>>>>                End
107978>>>>>>>>
107978>>>>>>>            Loop
107979>>>>>>>>
107979>>>>>>>            Send AdjustSuggestionListSize iLines
107980>>>>>>>        End
107980>>>>>>>>
107980>>>>>>>
107980>>>>>>>        Set Cursor of Cursor_Control to IDC_ARROW
107981>>>>>>>        Send Activate of (Self)
107982>>>>>>>        Send Release_Mouse_Capture
107983>>>>>>>    End_Procedure
107984>>>>>>>
107984>>>>>>>    Procedure Home
107986>>>>>>>        If (Focus(Desktop) = Self and ghoSuggestionList) Begin
107988>>>>>>>           Send ScrollHome
107989>>>>>>>        End
107989>>>>>>>>
107989>>>>>>>        Else Begin
107990>>>>>>>            Send Key VK_HOME
107991>>>>>>>        End
107991>>>>>>>>
107991>>>>>>>    End_Procedure
107992>>>>>>>
107992>>>>>>>    Procedure ScrollHome
107994>>>>>>>        Send SelectRow of ghoSuggestionList 0
107995>>>>>>>    End_Procedure
107996>>>>>>>
107996>>>>>>>    Procedure End
107998>>>>>>>        If (Focus(Desktop) = Self and ghoSuggestionList) Begin
108000>>>>>>>           Send ScrollEnd
108001>>>>>>>        End
108001>>>>>>>>
108001>>>>>>>        Else Begin
108002>>>>>>>            Send Key VK_END
108003>>>>>>>        End
108003>>>>>>>>
108003>>>>>>>    End_Procedure
108004>>>>>>>
108004>>>>>>>    Procedure ScrollEnd
108006>>>>>>>        Integer iLine iLines
108006>>>>>>>        Get Line_Count of ghoSuggestionList  to iLines
108007>>>>>>>        Get SelectedRow of ghoSuggestionList to iLine
108008>>>>>>>        // there can be an extra line at the end
108008>>>>>>>        If (iLine < iLines - 1) Begin
108010>>>>>>>            Send SelectRow of ghoSuggestionList (iLines - 1)
108011>>>>>>>        End
108011>>>>>>>>
108011>>>>>>>    End_Procedure
108012>>>>>>>
108012>>>>>>>    Procedure Activating
108014>>>>>>>        String[] sSavedFormValues
108015>>>>>>>        If (pbUseWorkspaceIniFile(Self) = True) Begin
108017>>>>>>>            Get ReadWorkspaceIniFile to sSavedFormValues
108018>>>>>>>            Set psSavedFormValues    to sSavedFormValues
108019>>>>>>>        End
108019>>>>>>>>
108019>>>>>>>    End_Procedure
108020>>>>>>>
108020>>>>>>>    Procedure Set psToolTip String sToolTip
108022>>>>>>>        String sStatusHelp
108022>>>>>>>
108022>>>>>>>        Get Status_Help to sStatusHelp
108023>>>>>>>        If (sStatusHelp = "") Begin
108025>>>>>>>            Set Status_Help to sToolTip
108026>>>>>>>        End
108026>>>>>>>>
108026>>>>>>>
108026>>>>>>>        Move (sToolTip + String(Character(10)) + String(CS_cRDCSuggestionFormTooltip)) to sToolTip
108027>>>>>>>        Forward Set psToolTip to sToolTip
108029>>>>>>>    End_Procedure
108030>>>>>>>
108030>>>>>>>    Function ReadWorkspaceIniFile Returns String[]
108032>>>>>>>        String sWorkspaceFile sObjectName sValue
108032>>>>>>>        String[] sSavedFormValues
108033>>>>>>>        Handle hoIniFile
108033>>>>>>>        Integer iItem iCount iSize
108033>>>>>>>        Boolean bExists
108033>>>>>>>
108033>>>>>>>        If (pbUseWorkspaceIniFile(Self) = False) Begin
108035>>>>>>>            Function_Return sSavedFormValues
108036>>>>>>>        End
108036>>>>>>>>
108036>>>>>>>
108036>>>>>>>        Move 0 to iItem
108037>>>>>>>        Get Object_Label to sObjectName
108038>>>>>>>        Move (psWorkspaceWSFile(phoWorkspace(ghoApplication))) to sWorkspaceFile
108039>>>>>>>        Set psIniFileName to sWorkspaceFile
108040>>>>>>>        Get Create (RefClass(cIniFile)) to hoIniFile
108041>>>>>>>        Set psFileName of hoIniFile to sWorkspaceFile
108042>>>>>>>        Get piSuggestionListMaxItems to iSize
108043>>>>>>>
108043>>>>>>>        For iCount from 0 to iSize
108049>>>>>>>>
108049>>>>>>>            Get KeyExists of hoIniFile (CS_cRDCSuggestionFormList * String(sObjectName)) (CS_cRDCSuggestionSaveItem + String(iCount)) to bExists
108050>>>>>>>            // We need to loop through all possible values because the list of items may not start at zero.
108050>>>>>>>            Get ReadString of hoIniFile (CS_cRDCSuggestionFormList * String(sObjectName)) (CS_cRDCSuggestionSaveItem + String(iCount)) "" to sValue
108051>>>>>>>            If (Trim(sValue) <> "") Begin
108053>>>>>>>                Move sValue to sSavedFormValues[iItem]
108054>>>>>>>                Increment iItem
108055>>>>>>>            End
108055>>>>>>>>
108055>>>>>>>        Loop
108056>>>>>>>>
108056>>>>>>>
108056>>>>>>>        Send Destroy of hoIniFile
108057>>>>>>>        Function_Return sSavedFormValues
108058>>>>>>>    End_Function
108059>>>>>>>
108059>>>>>>>    Procedure WriteWorkspaceIniFile
108061>>>>>>>        String sWorkspaceFile sObjectName sValue
108061>>>>>>>        String[] sSavedFormValues
108062>>>>>>>        Handle hoIniFile
108062>>>>>>>        Integer iSize iCount
108062>>>>>>>        Boolean bExists
108062>>>>>>>
108062>>>>>>>        If (pbUseWorkspaceIniFile(Self) = False) Begin
108064>>>>>>>            Procedure_Return
108065>>>>>>>        End
108065>>>>>>>>
108065>>>>>>>
108065>>>>>>>        Get Object_Label  to sObjectName
108066>>>>>>>        Get psIniFileName to sWorkspaceFile
108067>>>>>>>        Get Create (RefClass(cIniFile)) to hoIniFile
108068>>>>>>>        Set psFileName    of hoIniFile to sWorkspaceFile
108069>>>>>>>        Get SectionExists of hoIniFile (CS_cRDCSuggestionFormList * String(sObjectName)) to bExists
108070>>>>>>>        If (bExists = True) Begin
108072>>>>>>>            Send DeleteSection of hoIniFile (CS_cRDCSuggestionFormList * String(sObjectName))
108073>>>>>>>        End
108073>>>>>>>>
108073>>>>>>>
108073>>>>>>>        Get psSavedFormValues to sSavedFormValues
108074>>>>>>>        Move (SizeOfArray(sSavedFormValues)) to iSize
108075>>>>>>>        Decrement iSize
108076>>>>>>>
108076>>>>>>>        For iCount from 0 to iSize
108082>>>>>>>>
108082>>>>>>>            Move sSavedFormValues[iCount] to sValue
108083>>>>>>>            Move (Trim(sValue)) to sValue
108084>>>>>>>            Get vFilePathExists sValue to bExists
108085>>>>>>>            If (bExists = True) Begin
108087>>>>>>>                Send WriteString of hoIniFile (CS_cRDCSuggestionFormList * String(sObjectName)) (CS_cRDCSuggestionSaveItem + String(iCount)) sSavedFormValues[iCount]
108088>>>>>>>            End
108088>>>>>>>>
108088>>>>>>>        Loop
108089>>>>>>>>
108089>>>>>>>
108089>>>>>>>        Send Destroy of hoIniFile
108090>>>>>>>    End_Procedure
108091>>>>>>>
108091>>>>>>>    Procedure Prompt      
108093>>>>>>>        If (ghoSuggestionTimer=0) Begin
108095>>>>>>>            Send CreateSuggestionTimer
108096>>>>>>>        End
108096>>>>>>>>
108096>>>>>>>        Send ActivateSuggestionList
108097>>>>>>>        Send FindSuggestions
108098>>>>>>>        Set Visible_State of ghoSuggestionList to True
108099>>>>>>>    End_Procedure 
108100>>>>>>>    
108100>>>>>>>    Procedure OnExitObject
108102>>>>>>>        String sValue
108102>>>>>>>        Boolean bExists
108102>>>>>>>        String[] sSavedFormValues
108103>>>>>>>        Integer iSize iIndex
108103>>>>>>>
108103>>>>>>>        Forward Send OnExitObject
108105>>>>>>>
108105>>>>>>>        If (pbUseWorkspaceIniFile(Self) = False) Begin
108107>>>>>>>            Procedure_Return
108108>>>>>>>        End
108108>>>>>>>>
108108>>>>>>>
108108>>>>>>>        Get Value to sValue
108109>>>>>>>        Move (Trim(sValue)) to sValue
108110>>>>>>>        Get psSavedFormValues to sSavedFormValues
108111>>>>>>>        Move (SearchArray(sValue, sSavedFormValues)) to iIndex
108112>>>>>>>        // Does it exist in the array already?
108112>>>>>>>        If (iIndex <> -1) Begin
108114>>>>>>>            Procedure_Return
108115>>>>>>>        End
108115>>>>>>>>
108115>>>>>>>        Get vFilePathExists sValue to bExists
108116>>>>>>>        If (bExists = False) Begin
108118>>>>>>>            Procedure_Return
108119>>>>>>>        End
108119>>>>>>>>
108119>>>>>>>        Move (SizeOfArray(sSavedFormValues)) to iSize
108120>>>>>>>        Move sValue to sSavedFormValues[iSize]
108121>>>>>>>        Set psSavedFormValues to sSavedFormValues
108122>>>>>>>        Send WriteWorkspaceIniFile
108123>>>>>>>    End_Procedure
108124>>>>>>>
108124>>>>>>>    // Custom code to find all matches for the search
108124>>>>>>>    Procedure OnFindSuggestions String sSearch tSuggestion[] ByRef aSuggestions
108126>>>>>>>        String[] sSavedFormValues
108127>>>>>>>        Integer i iLen iSize iCount
108127>>>>>>>
108127>>>>>>>        Move (Lowercase(sSearch)) to sSearch
108128>>>>>>>        Move (Length(sSearch)) to iLen
108129>>>>>>>        Get psSavedFormValues to sSavedFormValues
108130>>>>>>>        Move (SizeOfArray(sSavedFormValues)) to iSize
108131>>>>>>>        Decrement iSize
108132>>>>>>>        For i from 0 to iSize
108138>>>>>>>>
108138>>>>>>>            If (Lowercase(sSavedFormValues[i]) contains sSearch) Begin
108140>>>>>>>                Move sSavedFormValues[i] to aSuggestions[iCount].sRowId
108141>>>>>>>                Move sSavedFormValues[i] to aSuggestions[iCount].aValues[0]
108142>>>>>>>                Increment iCount
108143>>>>>>>            End
108143>>>>>>>>
108143>>>>>>>        Loop
108144>>>>>>>>
108144>>>>>>>    End_Procedure
108145>>>>>>>
108145>>>>>>>    Procedure OnSelectSuggestion String sSearch tSuggestion Suggestion
108147>>>>>>>        Boolean bExists bAutoCheckValueExistsAsFile bAskToRemoveMissingFile
108147>>>>>>>        Integer iRetval iIndex
108147>>>>>>>        String[] sSavedFormValues
108148>>>>>>>        String sValue
108148>>>>>>>
108148>>>>>>>//        Send Release_Mouse_Capture
108148>>>>>>>        Move Suggestion.sRowId to sValue
108149>>>>>>>        Move (Trim(sValue)) to sValue
108150>>>>>>>        Get pbAutoCheckValueExistsAsFile to bAutoCheckValueExistsAsFile
108151>>>>>>>
108151>>>>>>>        If (bAutoCheckValueExistsAsFile = True) Begin
108153>>>>>>>            Get pbAskToRemoveMissingFile to bAskToRemoveMissingFile
108154>>>>>>>            Get vFilePathExists sValue to bExists
108155>>>>>>>            If (bExists = False) Begin
108157>>>>>>>                If (bAskToRemoveMissingFile = True) Begin
108159>>>>>>>                    Get YesNo_Box ("The file" * String(sValue) + "\nDoesn't exist. Do you want to remove it from the suggestion list?") to iRetval
108160>>>>>>>                End
108160>>>>>>>>
108160>>>>>>>                // This will happen if bAskToRemoveMissingFile = False, and bAutoCheckValueExistsAsFile = True.
108160>>>>>>>                // Then the missing file will just be removed from the saved list.
108160>>>>>>>                Else Begin
108161>>>>>>>                    Move MBR_Yes to iRetval
108162>>>>>>>                End
108162>>>>>>>>
108162>>>>>>>
108162>>>>>>>                If (iRetval = MBR_Yes) Begin
108164>>>>>>>                    Get psSavedFormValues to sSavedFormValues
108165>>>>>>>                    Move (SearchArray(sValue, sSavedFormValues)) to iIndex
108166>>>>>>>                    If (iIndex <> -1) Begin
108168>>>>>>>                        Move (RemoveFromArray(sSavedFormValues, iIndex)) to sSavedFormValues
108169>>>>>>>                        Set psSavedFormValues to sSavedFormValues
108170>>>>>>>                        Send WriteWorkspaceIniFile
108171>>>>>>>                        Set Value to ""
108172>>>>>>>                        Procedure_Return
108173>>>>>>>                    End
108173>>>>>>>>
108173>>>>>>>                End
108173>>>>>>>>
108173>>>>>>>            End
108173>>>>>>>>
108173>>>>>>>        End
108173>>>>>>>>
108173>>>>>>>
108173>>>>>>>        Set Value to Suggestion.sRowId
108174>>>>>>>        Set Item_Changed_State to False
108175>>>>>>>    End_Procedure
108176>>>>>>>
108176>>>>>>>//    { MethodType=Event  NoDoc=True }
108176>>>>>>>//    Procedure Mouse_Click Integer i1 Integer i2
108176>>>>>>>//        Send Release_Mouse_Capture
108176>>>>>>>//        Forward Send Mouse_click i1 i2
108176>>>>>>>//    End_Procedure
108176>>>>>>>
108176>>>>>>>End_Class
108177>>>>>>>
108177>>>>>>>//    Procedure Mouse_Up for cRDCSuggestionList Integer iWindowNumber Integer iPosition
108177>>>>>>>//        Handle hoObj
108177>>>>>>>//        Send Release_Mouse_Capture
108177>>>>>>>//        Get phoOwner to hoObj
108177>>>>>>>//        Send Activate of hoObj // move focus to owner, which will close the list
108177>>>>>>>//        Send SelectSuggestion of hoObj
108177>>>>>>>//    End_Procedure // Mouse_Up
108177>>>>>>>
108177>>>>>>>//    Function OnWindowsHook for cRDCSuggestionHookMouse Integer i1 Integer i2 Integer i3 Returns Integer
108177>>>>>>>//        tWinMouseHookStruct MouseHook
108177>>>>>>>//        Integer ivoid hObj
108177>>>>>>>//        Handle hoOwner hoParent
108177>>>>>>>//        If (i1=0 and (i2=WM_LBUTTONDOWN or i2=WM_RBUTTONDOWN or i2=WM_MBUTTONDOWN or ;
108177>>>>>>>//                      i2=WM_NCLBUTTONDOWN or i2=WM_NCRBUTTONDOWN or i2=WM_NCMBUTTONDOWN)) Begin
108177>>>>>>>//            Send Release_Mouse_Capture
108177>>>>>>>//            Move (CopyMemory(AddressOf(MouseHook), i3, SizeOfType(tWinMouseHookStruct))) to iVoid
108177>>>>>>>//            GET_OBJECT_FROM_WINDOW MouseHook.hwnd to hObj
108177>>>>>>>//            If (hObj = Cursor_Control) Begin
108177>>>>>>>//                Move (Focus(Desktop)) to hObj
108177>>>>>>>//            End
108177>>>>>>>//            Get Parent to hoParent
108177>>>>>>>//            Get phoOwner of hoParent to hoOwner
108177>>>>>>>//            If (not(hObj) or (hObj<>hoParent and hObj<>hoOwner)) Begin
108177>>>>>>>//                Send DisableWindowsHook
108177>>>>>>>//                Send DeActivateSuggestionList of hoOwner
108177>>>>>>>//            End
108177>>>>>>>//        End
108177>>>>>>>//    End_Function
108177>>>>>>>
108177>>>>>Use cDbUpdateFunctionLibrary.pkg
108177>>>>>Use cRDCHeaderGroup.pkg
108177>>>>>Use cCommandLinkButton.pkg
108177>>>>>
108177>>>>>Object oCreateDatabase_dg is a cRDCModalPanel
108179>>>>>    Set Size to 151 312
108180>>>>>    Set Label to "Create New Database"
108181>>>>>    Set piMinSize to 53 211
108182>>>>>    Set Location to 2 2
108183>>>>>    Set Icon to "ActionCreateDatabase1.ico"
108184>>>>>    
108184>>>>>    Property String psDriverID                   
108186>>>>>    Property String psCollation 
108188>>>>>    Property String psDatabaseName 
108190>>>>>
108190>>>>>//    Object oCollate_cf is a cRDCComboForm
108190>>>>>//        Set Size to 13 216
108190>>>>>//        Set Location to 42 63
108190>>>>>//        Set Label to "Use Collation:"  
108190>>>>>//        Set psToolTip to "Select/Enter the collation to use when creating the database. If none is specified the default SQL server collation above will be used. Note: Collations starting with 'SQL_' is obsolete and should not be used."
108190>>>>>//        // This must be set to False; else the filling takes for ever.
108190>>>>>//        Set pbAutoListWidth to False
108190>>>>>//        
108190>>>>>//        Procedure Combo_Fill_List
108190>>>>>//            String[] asCollations   
108190>>>>>//            Integer iCount iSize      
108190>>>>>//            String sDriverID sCollation
108190>>>>>//            
108190>>>>>//            Get psDriverID to sDriverID      
108190>>>>>//            
108190>>>>>//            // The SqlEnumerateDatabaseCollations function is *at current* for MSSQLDRV_ID only.
108190>>>>>//            If (sDriverID = MSSQLDRV_ID) Begin
108190>>>>>//                Send Cursor_Wait of Cursor_Control
108190>>>>>//                Get SqlEnumerateDatabaseCollations of ghoDbUpdateFunctionLibrary sDriverID to asCollations
108190>>>>>//                Move (SizeOfArray(asCollations)) to iSize
108190>>>>>//                Decrement iSize
108190>>>>>//                For iCount from 0 to iSize
108190>>>>>//                    Send Combo_Add_Item asCollations[iCount]
108190>>>>>//                Loop
108190>>>>>//                
108190>>>>>//                Get psCollation of ghoDbUpdateFunctionLibrary to sCollation
108190>>>>>//                Set Value to sCollation
108190>>>>>//                Send Cursor_Ready of Cursor_Control
108190>>>>>//            End
108190>>>>>//        End_Procedure
108190>>>>>//    
108190>>>>>//        Procedure OnChange
108190>>>>>//            String sValue
108190>>>>>//            Get Value to sValue
108190>>>>>//            Set psCollation to sValue
108190>>>>>//        End_Procedure
108190>>>>>//     
108190>>>>>//    End_Object
108190>>>>>
108190>>>>>    Object oInfo_tb is a TextBox
108192>>>>>        Set Auto_Size_State to False
108193>>>>>        Set Size to 8 50
108194>>>>>        Set Location to 133 120
108195>>>>>        Set TextColor to clGreen
108196>>>>>        Set Justification_Mode to JMode_Right
108197>>>>>        Set peAnchors to anBottomRight
108198>>>>>    End_Object
108199>>>>>
108199>>>>>    Object oMain_RDCHeaderGroup is a cRDCHeaderGroup
108201>>>>>        Set Size to 108 293
108202>>>>>        Set Location to 8 10
108203>>>>>        Set psImage to "ActionCreateDatabase1.ico"
108204>>>>>        Set Label to "Create Database"
108205>>>>>        Set psNote to "Enter collation and database name"
108206>>>>>        Set peAnchors to anTopBottom
108207>>>>>
108207>>>>>        Object oDriver_fm is a cRDCForm
108209>>>>>            Set Size to 13 100
108210>>>>>            Set Location to 34 63
108211>>>>>            Set Label to "Driver"
108212>>>>>            Set Enabled_State to False  
108213>>>>>        End_Object  
108214>>>>>        
108214>>>>>        Object oServerCurrentCollating_fm is a cRDCForm
108216>>>>>            Set Size to 13 216
108217>>>>>            Set Location to 49 63
108218>>>>>            Set Label to "Default Collation"
108219>>>>>            Set psToolTip to "The SQL server's default collation. It will be used when creating a new database, if nothing else is specified."
108220>>>>>            Set Enabled_State to False  
108221>>>>>            
108221>>>>>            Procedure InitializeCollation 
108224>>>>>                String sCollation
108224>>>>>                
108224>>>>>                Move False to Err
108225>>>>>                Send Ignore_All of Error_Object_Id
108226>>>>>                // Fetch the SQL server's default collation:
108226>>>>>                // It will be used when creating a new database, if nothing else is specified.
108226>>>>>                Get SqlDatabaseCollationQuery of ghoDbUpdateFunctionLibrary "master" False to sCollation
108227>>>>>                Send Trap_All of Error_Object_Id
108228>>>>>                If (Err = True) Begin
108230>>>>>                    Move "" to sCollation
108231>>>>>                End
108231>>>>>>
108231>>>>>                Set Value to sCollation
108232>>>>>            End_Procedure     
108233>>>>>    
108233>>>>>        End_Object  
108234>>>>>        
108234>>>>>        Object oCollate_fm is a cRDCSuggestionIniForm 
108236>>>>>            Set Size to 13 216
108237>>>>>            Set Location to 65 63
108238>>>>>            Set Label to "Collation"
108239>>>>>            Set psToolTip to "Suggestion list. Select/Enter the collation to use when creating the database. If none is specified the default SQL server collation above will be used. Note: Collations starting with 'SQL_' is obsolete and should not be used."
108240>>>>>            Set pbAskToRemoveMissingFile to False
108241>>>>>            Set pbAutoCheckValueExistsAsFile to False
108242>>>>>            Set pbUseWorkspaceIniFile to True
108243>>>>>            Set piStartAtChar to 3
108244>>>>>            Set Prompt_Button_Mode to PB_PromptOn
108245>>>>>            
108245>>>>>            Function ReadWorkspaceIniFile Returns String[]
108248>>>>>                String[] asCollations   
108249>>>>>                Integer iCount iSize      
108249>>>>>                String sDriverID sCollation
108249>>>>>                
108249>>>>>                Get psDriverID to sDriverID      
108250>>>>>                // The SqlEnumerateDatabaseCollations function is at current for MSSQLDRV_ID only.
108250>>>>>                If (sDriverID <> MSSQLDRV_ID) Begin
108252>>>>>                    Function_Return asCollations
108253>>>>>                End                 
108253>>>>>>
108253>>>>>                
108253>>>>>                Send Cursor_Wait of Cursor_Control
108254>>>>>                Get SqlEnumerateDatabaseCollations of ghoDbUpdateFunctionLibrary sDriverID to asCollations
108255>>>>>                Set psSavedFormValues to asCollations
108256>>>>>                    
108256>>>>>                If (sDriverID = MSSQLDRV_ID) Begin
108258>>>>>                    Get psCollation of ghoDbUpdateFunctionLibrary to sCollation
108259>>>>>                    Set Value to sCollation
108260>>>>>                End
108260>>>>>>
108260>>>>>                Send Cursor_Ready of Cursor_Control
108261>>>>>                Function_Return asCollations
108262>>>>>            End_Function
108263>>>>>    
108263>>>>>            Procedure OnChange
108266>>>>>                String sValue
108266>>>>>                Get Value to sValue
108267>>>>>                Set psCollation to sValue
108268>>>>>            End_Procedure
108269>>>>>         
108269>>>>>            Procedure WriteWorkspaceIniFile
108272>>>>>            End_Procedure             
108273>>>>>            
108273>>>>>//            Procedure Prompt      
108273>>>>>//                If (ghoSuggestionTimer=0) Begin
108273>>>>>//                    Send CreateSuggestionTimer
108273>>>>>//                End
108273>>>>>//                Send ActivateSuggestionList
108273>>>>>//                Send FindSuggestions
108273>>>>>//                Set Visible_State of ghoSuggestionList to True
108273>>>>>//            End_Procedure 
108273>>>>>            
108273>>>>>            Procedure OnEnterObject
108276>>>>>                Set pbUseWorkspaceIniFile to True
108277>>>>>                Forward Send OnEnterObject
108279>>>>>            End_Procedure
108280>>>>>
108280>>>>>            Procedure OnExitObject
108283>>>>>                Set pbUseWorkspaceIniFile to False
108284>>>>>                Forward Send OnExitObject
108286>>>>>            End_Procedure
108287>>>>>        
108287>>>>>            On_Key kCancel Send KeyAction of oCancel_Btn   
108288>>>>>//            On_Key kPrompt Send Prompt
108288>>>>>        End_Object   
108289>>>>>        
108289>>>>>        Object oDatabaseName_fm is a cRDCForm
108291>>>>>            Set Size to 13 216
108292>>>>>            Set Location to 81 63
108293>>>>>            Set Label_Col_Offset to 2
108294>>>>>            Set Label_Justification_Mode to JMode_Right
108295>>>>>            Set Label to "Database Name"
108296>>>>>            Set psToolTip to "Specify the name of the database to be created."
108297>>>>>        End_Object
108298>>>>>    
108298>>>>>    End_Object
108299>>>>>
108299>>>>>    Object oOK_Btn is a Button
108301>>>>>        Set Label    to "&OK"
108302>>>>>        Set Location to 130 198
108303>>>>>        Set peAnchors to anBottomRight   
108304>>>>>        
108304>>>>>        Property String psWorkingText "Working..."
108306>>>>>        Property String psIdleText    ""
108308>>>>>
108308>>>>>        Procedure OnClick
108311>>>>>            String sDatabase sDriverID sCollation
108311>>>>>            Boolean bOK bExists
108311>>>>>        
108311>>>>>            Get Value of oDatabaseName_fm to sDatabase    
108312>>>>>            Get psDriverID to sDriverID
108313>>>>>            Set psDatabaseName to ""
108314>>>>>
108314>>>>>            If (sDatabase <> "" and sDriverID <> "") Begin    
108316>>>>>                Set Value of oInfo_tb to (psWorkingText(Self))
108317>>>>>                If (sDriverID <> DATAFLEX_ID) Begin
108319>>>>>                    Get psCollation to sCollation
108320>>>>>                    Set psCollation of ghoDbUpdateFunctionLibrary to sCollation
108321>>>>>                End
108321>>>>>>
108321>>>>>
108321>>>>>                Get SqlUtilCheckIfDatabaseExists of ghoDbUpdateFunctionLibrary sDatabase to bExists
108322>>>>>                If (bExists = True) Begin
108324>>>>>                    Set Value of oInfo_tb to ""
108325>>>>>                    Send Info_Box "The database already exists. No changes made."
108326>>>>>                    Procedure_Return
108327>>>>>                End
108327>>>>>>
108327>>>>>                Send Cursor_Wait of Cursor_Control     
108328>>>>>                Get SqlDatabaseCreate of ghoDbUpdateFunctionLibrary sDriverID sDatabase False False to bOK
108329>>>>>                Send Cursor_Ready of Cursor_Control
108330>>>>>                Set Value of oInfo_tb to (psIdleText(Self))
108331>>>>>                If (bOK = False) Begin
108333>>>>>                    Send Info_Box ("Something went wrong and the database could NOT be created. Please check your database manager.")
108334>>>>>                    Procedure_Return
108335>>>>>                End 
108335>>>>>>
108335>>>>>                Set psDatabaseName to sDatabase
108336>>>>>                Send Close_Panel
108337>>>>>            End                                 
108337>>>>>>
108337>>>>>            Else If (sDatabase = "") Begin
108340>>>>>                Send Info_Box ("Please enter a database name and try again.")
108341>>>>>            End
108341>>>>>>
108341>>>>>        End_Procedure
108342>>>>>
108342>>>>>    End_Object
108343>>>>>
108343>>>>>    Object oCancel_Btn is a Button
108345>>>>>        Set Label    to "&Cancel"
108346>>>>>        Set Location to 130 253
108347>>>>>        Set peAnchors to anBottomRight
108348>>>>>
108348>>>>>        Procedure OnClick
108351>>>>>            Send Close_Panel
108352>>>>>        End_Procedure
108353>>>>>
108353>>>>>    End_Object
108354>>>>>
108354>>>>>    Object oHelp_btn is a Button
108356>>>>>        Set Location to 130 75
108357>>>>>        Set Label to "Help"
108358>>>>>        Set psImage to "ActionHelpInternet1.ico"
108359>>>>>        Set psToolTip to "Show a Full List of Collations Supported in SQL Server 2017"
108360>>>>>        Set peAnchors to anBottomLeft
108361>>>>>    
108361>>>>>        Procedure OnClick
108364>>>>>            Runprogram Shell Background "https://database.guide/full-list-of-collations-supported-in-sql-server-2017/"
108365>>>>>        End_Procedure
108366>>>>>    
108366>>>>>    End_Object
108367>>>>>    
108367>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
108368>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
108369>>>>>    On_Key kCancel       Send KeyAction of oCancel_Btn
108370>>>>>End_Object
108371>>>>>
108371>>>>>Function Create_DataBase_Dialog String sDriverID Returns String
108374>>>>>    String sDatabaseName         
108374>>>>>    Handle ho
108374>>>>>    
108374>>>>>    Move (oCreateDatabase_dg(Self)) to ho
108375>>>>>    Set psDriverID of ho to sDriverID
108376>>>>>    Set Value of (oDriver_fm(ho)) to sDriverID
108377>>>>>    Set Value of (oDatabaseName_fm(ho)) to ""
108378>>>>>    Send InitializeCollation of (oServerCurrentCollating_fm(ho))
108379>>>>>    Send Popup of ho
108380>>>>>    
108380>>>>>    Get psDatabaseName of ho to sDatabaseName
108381>>>>>    Function_Return sDatabaseName
108382>>>>>End_Function                         
108383>>>
108383>>>Define CS_LoadingServers        for "Enumerating servers..."
108383>>>Define CS_LoadingDatabases      for "Enumerating databases..."
108383>>>Define CS_LoadingTableSpaces    for "Enumerating table spaces..."
108383>>>Define CS_LoadingSchemas        for "Enumerating schemas..."
108383>>>Define CS_LoginAttempt          for "Connecting..."
108383>>>Define CS_LoginSuccessful       for "Login successful!"
108383>>>Define CS_LoginFailed           for "Login failed!"
108383>>>Define CS_DF_File_Schema        for "Schema"
108383>>>Define CS_DF_File_Owner         for "Owner"
108383>>>
108383>>>Object oSQLMaintainConnections_dg is a ModalPanel
108385>>>    Set Label to "Edit SQL Connection"
108386>>>    Set Size to 315 324 //309 324
108387>>>    Set Location to 4 6
108388>>>    Set piMaxSize to (Hi(Size(Self))) (Low(Size(Self)) + 300)
108389>>>    Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
108390>>>    Set Locate_Mode to CENTER_ON_PARENT
108391>>>    Set Border_Style to Border_Thick
108392>>>    
108392>>>    Property Boolean pbReadOnly  False
108394>>>    Property Boolean pbNew       False // First time for a workspace, which means the .ini-file is empty.
108396>>>    Property Integer piCurrentRow -1   // The current row of the grid that was passed to this dialog.
108398>>>    Property Boolean pbChanged   False // If any change was made to the data.
108400>>>    Property Handle phoDialogCommandbar
108402>>>    Property tSQLConnection pSQLConnectionData
108404>>>    Property tDataSourceRow[] pTheData
108406>>>    Property Boolean pbDFConnId  False // Is set to True if this is a DAW "DFConnId.ini" file; in which case we warn to not encrypt/decrypt password. (different algorithms and don't touch password)
108408>>>    Property String psUncryptedPw      // Used if  pbDFConnId = True to temporary save the un-encrypted password.
108410>>>
108410>>>    Object oSettings_grp is a cRDCHeaderGroup
108412>>>        Set Size to 202 303
108413>>>        Set Location to 77 11 //71 11
108414>>>        Set psImage to "Settings1.ico"
108415>>>        Set psLabel to "SQL Connection Settings"
108416>>>        Set peAnchors to anTopLeftRight
108417>>>        Set psToolTip to "Setup the SQL connection."
108418>>>
108418>>>        Object oConnectionID_fm is a cSQLForm
108420>>>            Set Size to 13 115
108421>>>            Set Location to 22 82
108422>>>            Set Label to "Connection ID"
108423>>>            Set psToolTip to "The DFConnectionID keyword to set a default connection id for the driver. This is the connection ID that appear in database table .int files with the format; 'SERVER_NAME DFCONNID=MyConnID'"
108424>>>            Set piItem to 2
108425>>>            Set peAnchors to anTopLeftRight
108426>>>        End_Object
108427>>>
108427>>>        Object oEnabled_cb is a cSQLCheckBox
108429>>>            Set Size to 10 36
108430>>>            Set Location to 25 210
108431>>>            Set Label to "Enabled"
108432>>>            Set psToolTip to "Check to indicate that this is the enabled connection. Note: There can only be one enabled connection at a time."
108433>>>            Set piItem to 1
108434>>>            Set peAnchors to anTopRight
108435>>>
108435>>>            Procedure OnChange
108438>>>                Boolean bChecked bNew
108438>>>                tSQLConnection SQLConnection
108438>>>                tSQLConnection SQLConnection
108438>>>
108438>>>                Get pbNew to bNew
108439>>>                Get Checked_State to bChecked
108440>>>                If (bNew = False and bChecked = True) Begin
108442>>>                    Get pSQLConnectionData to SQLConnection
108443>>>                    Move True to SQLConnection.bEnabled
108444>>>                End
108444>>>>
108444>>>
108444>>>            End_Procedure
108445>>>
108445>>>        End_Object
108446>>>
108446>>>        Object oODBC_rgp is a RadioGroup
108448>>>            Set Location to 38 24
108449>>>            Set Size to 32 173
108450>>>//            Set psToolTip to "Only available if the ODBC_DRV has been selected. Depending on the radio button that is selected the 'Server/DSN' selection list shows different values."
108450>>>            Set peAnchors to anTopLeftRight
108451>>>            Set Label to "ODBC Source Type"
108452>>>
108452>>>            Object oRadio0 is a Radio
108454>>>                Set Label to "User data"
108455>>>                Set Size to 10 44
108456>>>                Set Location to 12 5
108457>>>            End_Object
108458>>>
108458>>>            Object oRadio1 is a Radio
108460>>>                Set Label to "System data"
108461>>>                Set Size to 10 52
108462>>>                Set Location to 12 52
108463>>>            End_Object
108464>>>
108464>>>            Object oRadio2 is a Radio
108466>>>                Set Label to "Both"
108467>>>                Set Size to 10 26
108468>>>                Set Location to 13 109
108469>>>            End_Object
108470>>>
108470>>>            Object oRadio3 is a Radio
108472>>>                Set Label to "File"
108473>>>                Set Size to 10 25
108474>>>                Set Location to 13 141
108475>>>            End_Object
108476>>>
108476>>>            Procedure Notify_Select_State Integer iToItem Integer iFromItem
108479>>>                Forward Send Notify_Select_State iToItem iFromItem 
108481>>>                If (oFileDSN_btn(Self) <> 0) Begin
108483>>>                    Set Enabled_State of oFileDSN_btn to (iToItem = 3)
108484>>>                End
108484>>>>
108484>>>            End_Procedure
108485>>>
108485>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
108488>>>                Set Enabled_State to (sDriverID = ODBC_DRV_ID)
108489>>>                Set Enabled_State of oODBC_rgp to (sDriverID = ODBC_DRV_ID)
108490>>>            End_Procedure
108491>>>
108491>>>            Set Current_Radio to 2
108492>>>        End_Object
108493>>>
108493>>>        Object oFileDSN_btn is a cRDCButton
108495>>>            Set Size to 13 78
108496>>>            Set Location to 42 210
108497>>>            Set Label to "Select File DSN..."
108498>>>            Set pbAutoEnable to True
108499>>>            Set peAnchors to anTopRight
108500>>>
108500>>>            Procedure OnClick
108503>>>                String sFileName
108503>>>                Get vSelect_File ("Data Sources (*.dsn)|*.dsn|All Files (*.*)|*.*") "Select a file data source" "" to sFileName
108504>>>                If (sFileName <> "") Begin
108506>>>                    Set Value of oServer_fm to sFileName
108507>>>                End
108507>>>>
108507>>>            End_Procedure     
108508>>>            
108508>>>            Function IsEnabled Returns Boolean
108511>>>                String sDriverID
108511>>>                Integer iRadio
108511>>>                Get Value of oDriverID_cf to sDriverID
108512>>>                Get Current_Radio of oODBC_rgp to iRadio
108513>>>                Function_Return (sDriverID = ODBC_DRV_ID and iRadio = 3)
108514>>>            End_Function
108515>>>
108515>>>        End_Object
108516>>>
108516>>>        Object oODBCAdmin_btn is a cRDCButton
108518>>>            Set Size to 13 78
108519>>>            Set Location to 57 210
108520>>>            Set Label to "ODBC Admin" 
108521>>>            Set psImage to "ODBCAD32.ico"
108522>>>            Set pbAutoEnable to True
108523>>>            Set peAnchors to anTopRight
108524>>>            
108524>>>            Procedure OnClick
108527>>>                Handle hWnd
108527>>>                Get Window_Handle to hWnd
108528>>>                If (hWnd <> 0) Begin
108530>>>                    Call_Driver 0 ODBC_DRV_ID Function ODBC_MANAGE_DATA_SOURCES Callback 0 Passing CLI$StrDummy CLI$StrDummy !1 Result CLI$IntDummy
108535>>>                End
108535>>>>
108535>>>                Else Begin
108536>>>                    Send Stop_Box "Could not get a Windows handle.."
108537>>>                End
108537>>>>
108537>>>            End_Procedure
108538>>>
108538>>>            Function IsEnabled Returns Boolean
108541>>>                String sDriverID
108541>>>                Get Value of oDriverID_cf to sDriverID
108542>>>                Function_Return (sDriverID = ODBC_DRV_ID)
108543>>>            End_Function
108544>>>
108544>>>        End_Object
108545>>>
108545>>>        Object oServer_fm is a cSQLForm
108547>>>            Set Size to 13 114
108548>>>            Set Location to 74 82
108549>>>            Set Label to "Server"
108550>>>            Set psToolTip to "Server/DSN: Depending on the selected database type the label can either display as 'Server' or 'DSN'. Either enter the name - if you know it - or by using the selection list (F4). Tip: If you are using Microsoft SQL Server and you are testing on the same machine as the MS SQL Server instance is running and you are using SQLEXPRESS you can enter e.g. '.\SQLEXPRESS'. That will mean use the SQLEXPRESS instance of Microsoft SQL Server running on this machine. If you press [F4] and the selection list comes up empty for Microsoft SQL Server it probably is because the service hasn't been started. Type 'Services' in Windows menu system to start Windows Services app. Type 'SQL' to jump to the SQL Server services. Check that the 'SQL Server Browser' service is started and set to 'Automatic'."
108551>>>            Set piItem to 5
108552>>>            Set peAnchors to anTopLeftRight
108553>>>
108553>>>            Property Handle phoPromptObject (oServerSelection_sl(Self))
108555>>>
108555>>>            Procedure Prompt
108558>>>                String sDriverID sValue
108558>>>                String[] sTheData
108559>>>                Integer iDbType iODBCType iRadio iPos
108559>>>                Handle ho
108559>>>
108559>>>                Get Prompt_Object to ho
108560>>>                If (ho = 0) Begin
108562>>>                    Procedure_Return
108563>>>                End
108563>>>>
108563>>>
108563>>>                Set Label of oShowInfo_tb to CS_LoadingServers
108564>>>                Send Cursor_Wait of Cursor_Control
108565>>>                Get SelectedDbType of oDbType_cf to iDbType
108566>>>                Get Value of oDriverID_cf to sDriverID
108567>>>                Move (Trim(sDriverID)) to sDriverID
108568>>>                Get Current_Radio of oODBC_rgp to iRadio
108569>>>                If (iRadio = 0) Begin
108571>>>                    Move SQL_FETCH_USER   to iODBCType
108572>>>                End
108572>>>>
108572>>>                If (iRadio = 1) Begin
108574>>>                    Move SQL_FETCH_SYSTEM to iODBCType
108575>>>                End
108575>>>>
108575>>>                If (iRadio = 2) Begin
108577>>>                    Move SQL_FETCH_ALL    to iODBCType
108578>>>                End
108578>>>>
108578>>>
108578>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
108579>>>                Load_Driver sDriverID
108580>>>                Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
108581>>>                If (LastErr = DFERR_CANT_LOAD_DLL) Begin
108583>>>                    Send Cursor_Ready of Cursor_Control
108584>>>                    Send Info_Box ("Can't display any items because the database driver could not be loaded. (" + sDriverID + ")")
108585>>>                    Procedure_Return
108586>>>                End
108586>>>>
108586>>>
108586>>>                Get SqlUtilEnumerateServers of ghoDbUpdateFunctionLibrary sDriverID iODBCType to sTheData
108587>>>                Set psTheData  of ho to sTheData
108588>>>                Set Label of oShowInfo_tb to ""
108589>>>
108589>>>                Forward Send Prompt
108591>>>
108591>>>                // The selection list will show the ODBC DataSource name + a comma (,) + a description.
108591>>>                // We need to remove those parts from the comma and to the end of string.
108591>>>                If (sDriverID = ODBC_DRV_ID) Begin
108593>>>                    Get Value to sValue
108594>>>                    Move (Pos(",", sValue)) to iPos
108595>>>                    Move (Left(sValue, (iPos - 1))) to sValue
108596>>>                    Set Value to sValue
108597>>>                End
108597>>>>
108597>>>            End_Procedure
108598>>>
108598>>>            Procedure OnChange
108601>>>                tSQLIntTableInfo[] sReturnStructArray
108601>>>                tSQLIntTableInfo[] sReturnStructArray
108602>>>                String sServer sDatabaseName sVal sDriverID
108602>>>                Integer iSize iCount iPos 
108602>>>                Boolean bFileDSN
108602>>>                
108602>>>                Move False to bFileDSN
108603>>>                Get Value of oDriverID_cf to sDriverID
108604>>>                If (sDriverID = "") Begin
108606>>>                    Procedure_Return
108607>>>                End
108607>>>>
108607>>>                If (sDriverID = ODBC_DRV_ID) Begin
108609>>>                    Move "" to sDatabaseName
108610>>>                    Get Value to sServer 
108611>>>                    Move (Pos(",", sServer)) to iPos
108612>>>                    If (iPos <> 0) Begin
108614>>>                        Move (Left(sServer, (iPos -1))) to sServer
108615>>>                    End
108615>>>>
108615>>>                    If (sServer <> "") Begin
108617>>>                        Set psServer of ghoDbUpdateFunctionLibrary to sServer
108618>>>                    End
108618>>>>
108618>>>                    Get _SqlDatabasesArrayODBC of ghoDbUpdateFunctionLibrary to sReturnStructArray
108619>>>                    If (SizeOfArray(sReturnStructArray)) Begin
108621>>>                        If (SizeOfArray(sReturnStructArray) = 1 and sReturnStructArray[0].sServerName = "") Begin
108623>>>                            // If a FILEDSN: (can only be one database name)
108623>>>                            Move sReturnStructArray[0].sDatabaseName to sDatabaseName
108624>>>                            Move True to bFileDSN
108625>>>                        End
108625>>>>
108625>>>                        Else Begin
108626>>>                            // Else the DSN's were read from the registry.
108626>>>                            Move (SizeOfArray(sReturnStructArray)) to iSize
108627>>>                            Decrement iSize
108628>>>                            For iCount from 0 to iSize
108634>>>>
108634>>>                                Move (sReturnStructArray[iCount].sServerName) to sVal
108635>>>                                If (Uppercase(sServer) = Uppercase(sVal)) Begin
108637>>>                                    Move sReturnStructArray[iCount].sDatabaseName to sDatabaseName
108638>>>                                    Move iSize to iCount // We're done.
108639>>>                                End
108639>>>>
108639>>>                            Loop
108640>>>>
108640>>>                        End
108640>>>>
108640>>>                    End
108640>>>>
108640>>>                    Set Value of oDatabase_fm to sDatabaseName
108641>>>                    If (bFileDSN = True) Begin
108643>>>                        Set Current_Radio of oODBC_rgp to 3
108644>>>                    End    
108644>>>>
108644>>>                    Else Begin
108645>>>                        Set Current_Radio of oODBC_rgp to 2
108646>>>                    End
108646>>>>
108646>>>                End
108646>>>>
108646>>>
108646>>>            End_Procedure
108647>>>
108647>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
108650>>>                String sLabel
108650>>>                Handle ho
108650>>>
108650>>>                Get phoPromptObject to ho
108651>>>                Set Prompt_Button_Mode to PB_PromptOn
108652>>>                Case Begin
108652>>>                    Case (iDbType = EN_dbTypeDB2)
108654>>>                        Move "DSN" to sLabel
108655>>>                        Case Break
108656>>>                    Case (iDbType = EN_dbTypeMSSQL)
108659>>>                        If (sDriverID = ODBC_DRV_ID) Begin
108661>>>                            Move "ODBC Data Source" to sLabel
108662>>>                        End
108662>>>>
108662>>>                        Else Begin
108663>>>                            Move "Server" to sLabel
108664>>>                        End
108664>>>>
108664>>>                        Case Break
108665>>>                    Case (iDbType = EN_dbTypeMySQL)
108668>>>                        If (sDriverID = ODBC_DRV_ID) Begin
108670>>>                            Move "ODBC Data Source" to sLabel
108671>>>                        End
108671>>>>
108671>>>                        Else Begin
108672>>>                            Move "DSN" to sLabel
108673>>>                        End
108673>>>>
108673>>>                        Case Break
108674>>>                    Case (iDbType = EN_dbTypeOracle)
108677>>>                        If (sDriverID = ODBC_DRV_ID) Begin
108679>>>                            Move "ODBC Data Source" to sLabel
108680>>>                        End
108680>>>>
108680>>>                        Else Begin
108681>>>                            Move "Server" to sLabel
108682>>>                        End
108682>>>>
108682>>>                        Case Break
108683>>>                    Case (iDbType = EN_dbTypePostgre)
108686>>>                        If (sDriverID = ODBC_DRV_ID) Begin
108688>>>                            Move "ODBC Data Source" to sLabel
108689>>>                        End
108689>>>>
108689>>>                        Else Begin
108690>>>                            Move "Server" to sLabel
108691>>>                        End
108691>>>>
108691>>>                        Case Break
108692>>>                    Case Else
108692>>>                Case End
108692>>>
108692>>>                Set Prompt_Object to ho
108693>>>                Set Label to sLabel
108694>>>            End_Procedure
108695>>>
108695>>>        End_Object
108696>>>
108696>>>        Object oSilentLogin_fm is a cSQLCheckBox
108698>>>            Set Size to 10 48
108699>>>            Set Location to 76 210
108700>>>            Set Label to "Silent Login"
108701>>>            Set psToolTip to "Silent login to database is to not show error if login was unsuccessive."
108702>>>            Set peAnchors to anTopRight
108703>>>            Set piItem to 15
108704>>>        End_Object
108705>>>
108705>>>        Object oTrusted_cb is a cSQLCheckbox
108707>>>            Set Size to 12 85
108708>>>            Set Location to 91 82
108709>>>            Set Label to "Use Trusted Connection"
108710>>>            Set psToolTip to "(Windows Authentication) When selected, SQL Server uses integrated login (Windows login information) security to establish connections using this data source, regardless of the current login security mode at the server."
108711>>>            Set piItem to 8
108712>>>
108712>>>            Procedure OnChange
108715>>>                Boolean bChecked
108715>>>                Get Checked_State to bChecked
108716>>>                Set Enabled_State of oUserID_fm   to (bChecked = False)
108717>>>                Set Enabled_State of oPassword_fm to (bChecked = False)
108718>>>                Set Enabled_State of oViewPassword_btn to (bChecked = False)
108719>>>            End_Procedure
108720>>>
108720>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
108723>>>                Boolean bChecked
108723>>>
108723>>>                Get Checked_State to bChecked
108724>>>                If (iDbType <> EN_dbTypeMSSQL) Begin
108726>>>                    Set Enabled_State to (iDbType = EN_dbTypeMSSQL)
108727>>>                    If (bChecked = True) Begin
108729>>>                        Set Checked_State to False
108730>>>                    End
108730>>>>
108730>>>                End
108730>>>>
108730>>>                Else Begin
108731>>>                    Set Enabled_State to True
108732>>>                End
108732>>>>
108732>>>
108732>>>                Send OnChange
108733>>>            End_Procedure
108734>>>
108734>>>        End_Object
108735>>>
108735>>>        Object oUserID_fm is a cSQLForm
108737>>>            Set Size to 13 114
108738>>>            Set Location to 103 82
108739>>>            Set Label to "User ID"
108740>>>            Set psToolTip to "Enter the user name to use for authentication when you log on to the database."
108741>>>            Set piItem to 9
108742>>>            Set peAnchors to anTopLeftRight
108743>>>        End_Object
108744>>>
108744>>>        Object oPassword_fm is a cSQLForm
108746>>>            Set Size to 13 61
108747>>>            Set Location to 103 210
108748>>>            Set Label to "Password"
108749>>>            Set psToolTip to "Enter the password for your user name. The password will automatically be encrypted & decrypted when writing/reading from the ini file. Of Special Note: If the cConnection class is used with DataFlex 19 or later and such an .ini file is edited with this program you will get a question if you would like the program to 'touch' the password or not. If you answer No, the ini-file will keep working with the DataFlex tools. You should probably never try to change the password with this program for a DFConnid.ini file as the two programs uses different encryption/decryption algorithms."
108750>>>            Set piItem to 10
108751>>>            Set Password_State to True
108752>>>            Set peAnchors to anTopRight
108753>>>            Set Label_Col_Offset to 0
108754>>>            Set Label_Justification_Mode to JMode_Top
108755>>>        End_Object
108756>>>
108756>>>        Object oShowInfo_tb is a TextBox
108758>>>            Set Auto_Size_State to False
108759>>>            Set Size to 10 114
108760>>>            Set Location to 119 82
108761>>>            Set TextColor to clGreen
108762>>>            Set Justification_Mode to JMode_Center
108763>>>            Set peAnchors to anTopRight
108764>>>        End_Object
108765>>>
108765>>>        Object oViewPassword_btn is a cRDCButton
108767>>>            Set Size to 13 15
108768>>>            Set Location to 103 273
108769>>>            Set psToolTip to "View/hide password"
108770>>>            Set psImage to "ViewPassword1.ico"
108771>>>            Set piImageMarginLeft to 2
108772>>>            Set peAnchors to anTopRight
108773>>>
108773>>>            Procedure OnClick
108776>>>                Handle ho
108776>>>                Boolean bState
108776>>>
108776>>>                Move (oPassword_fm(Self)) to ho
108777>>>                Get Password_State of ho 0 to bState
108778>>>                Send Deactivate of ho
108779>>>                Set Password_State of ho to (not(bState))
108780>>>                // Finally we need to re-add the object to the focus tree or it will be invisible.
108780>>>                Send Activate of ho (Parent(Self))
108781>>>            End_Procedure
108782>>>
108782>>>        End_Object
108783>>>
108783>>>        Object oCheckLogin_btn is a cRDCButton
108785>>>            Set Size to 13 78
108786>>>            Set Location to 119 210
108787>>>            Set Label to "Check &Login"
108788>>>            Set psImage to "ActionLogin1.ico"
108789>>>            Set psToolTip to "You should always use this button when adding a new SQL Connection to ensure that the entered credentials are correct. (Ctrl+L)"
108790>>>            Set piImageMarginLeft to 3
108791>>>            Set peAnchors to anTopRight
108792>>>
108792>>>            Procedure OnClick
108795>>>                String sConnectionString sDriverID sError //sServer sDatabase sUserId sPassword 
108795>>>                Boolean bLoginSuccessful bMertechDriver // bTrusted 
108795>>>                Integer iDriverID
108795>>>                Handle hoErrorObj
108795>>>
108795>>>                Send Cursor_Wait of Cursor_Control // Note: The Cursor_Wait changes the Err flag!
108796>>>                Move Error_Object_Id to hoErrorObj
108797>>>                Move Self to Error_Object_Id
108798>>>                Move False to Err
108799>>>
108799>>>                Set Value of oLoginInfo_tb to CS_LoginAttempt
108800>>>                Send PumpMsgQueue
108801>>>                
108801>>>                Get Value of oDriverID_cf to sDriverID
108802>>>                Move "" to sError
108803>>>                Get LoginString (&sError) to sConnectionString
108804>>>                If (sError <> "") Begin
108806>>>                    Set Value of oLoginInfo_tb to CS_LoginFailed
108807>>>                    Send Info_Box sError
108808>>>                    Procedure_Return
108809>>>                End
108809>>>>
108809>>>                
108809>>>                Get DriverIndex of ghoSQLConnectionHandler sDriverID to iDriverID
108810>>>                If (iDriverID = 0) Begin
108812>>>                    Set TextColor of oLoginInfo_tb to clRed
108813>>>                    Set Value of oLoginInfo_tb to CS_LoginFailed
108814>>>                    Send Info_Box ("The driver" * sDriverID * "could not be loaded. Is the driver installed? And equally imporant; Is the corresponding database server or client software installed?")
108815>>>                    Procedure_Return
108816>>>                End
108816>>>>
108816>>>
108816>>>                Get IsMertechDriver of ghoSQLConnectionHandler sDriverID to bMertechDriver
108817>>>                If (bMertechDriver = False) Begin
108819>>>                    Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriverID to True
108822>>>                End
108822>>>>
108822>>>
108822>>>                Move False to Err
108823>>>                Send CreateConnParamsFromConnectionString of ghoSQLConnectionHandler sDriverID sConnectionString
108824>>>
108824>>>                Move (Err = False) to bLoginSuccessful
108825>>>                If bLoginSuccessful Begin
108827>>>                    Set TextColor of oLoginInfo_tb to clGreen
108828>>>                    Set Value of oLoginInfo_tb to CS_LoginSuccessful 
108829>>>                    Set psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
108830>>>                    Set psConnectionString of ghoDbUpdateFunctionLibrary to sConnectionString
108831>>>                End
108831>>>>
108831>>>                Else Begin
108832>>>                    Set TextColor of oLoginInfo_tb to clRed
108833>>>                    Set Value of oLoginInfo_tb to CS_LoginFailed
108834>>>                End
108834>>>>
108834>>>
108834>>>                Move hoErrorObj to Error_Object_Id
108835>>>                Send Cursor_Ready of Cursor_Control
108836>>>            End_Procedure
108837>>>
108837>>>            // This method is here simply to intercept any error that may occur while logging in
108837>>>            // it does not have to do anything with the error, but it suppresses the normal error display
108837>>>            Procedure Error_Report Integer iErrNum Integer iErrLine String sErrMsg
108840>>>                    If (LastErr = 25000) Begin
108842>>>                        If (Trim(sErrMsg) <> "") Begin
108844>>>                            Send Info_Box sErrMsg
108845>>>                        End
108845>>>>
108845>>>                    End  
108845>>>>
108845>>>            End_Procedure   
108846>>>            
108846>>>        End_Object
108847>>>
108847>>>        Object oIndexTableSpace_fm is a cSQLForm
108849>>>            Set Size to 13 114
108850>>>            Set Location to 133 82
108851>>>            Set Label to "Index Table Space"
108852>>>            Set piItem to 14
108853>>>            Set psToolTip to "To set the name of the table space where indexes will be stored. Only applicable for IBM DB2, Oracle and PostgreSQL databases."
108854>>>            Set Prompt_Button_Mode to PB_PromptOn
108855>>>            Set Prompt_Object to (oTableSpaceSelection_sl(Self))
108856>>>            Set peAnchors to anTopLeftRight
108857>>>
108857>>>            Procedure Prompt
108860>>>                String[] sTheData
108861>>>                Handle ho
108861>>>                tSQLConnection SQLConnection
108861>>>                tSQLConnection SQLConnection
108861>>>
108861>>>                Set Label of oShowInfo_tb to CS_LoadingTableSpaces
108862>>>                Get ReadCurrentSQLSettings to SQLConnection
108863>>>
108863>>>                Get SqlUtilEnumerateTableSpaces of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType SQLConnection.sConnectionString to sTheData
108864>>>
108864>>>                Get Prompt_Object to ho
108865>>>                Set psTheData     of ho to sTheData
108866>>>                Set Label of oShowInfo_tb to ""
108867>>>
108867>>>                Forward Send Prompt
108869>>>            End_Procedure
108870>>>
108870>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
108873>>>                Set Enabled_State to ((iDbType = EN_dbTypeDB2 or iDbType = EN_dbTypeOracle or iDbType = EN_dbTypePostgre) and sDriverID <> ODBC_DRV_ID)
108874>>>            End_Procedure
108875>>>
108875>>>        End_Object
108876>>>
108876>>>        Object oLoginInfo_tb is a TextBox
108878>>>            Set Auto_Size_State to False
108879>>>            Set Size to 9 78
108880>>>            Set Location to 135 210
108881>>>            Set TextColor to clGreen
108882>>>            Set peAnchors to anTopRight
108883>>>            Set Justification_Mode to JMode_Left
108884>>>        End_Object
108885>>>
108885>>>        Object oBaseTableSpace_fm is a cSQLForm
108887>>>            Set Size to 13 114
108888>>>            Set Location to 148 82
108889>>>            Set Label to "Table Space"
108890>>>            Set piItem to 12
108891>>>            Set psToolTip to "Sets the name of the table space where the data will be stored. Applicable for IBM DB2, Oracle and PostgreSQL databases. Table spaces allow you to assign a physical location to logical objects (tables). They can be used to improve performance or to increase the page size, thus increasing the maximum size of a record that can be stored in the table space. You can specify what table space must be used to store table, index or long data. The index and long data table space will only be set when the table tables pace is also set."
108892>>>            Set Prompt_Button_Mode to PB_PromptOn
108893>>>            Set Prompt_Object to (oTableSpaceSelection_sl(Self))
108894>>>            Set peAnchors to anTopLeftRight
108895>>>
108895>>>            Procedure Prompt
108898>>>                String[] sTheData
108899>>>                Handle ho
108899>>>                tSQLConnection SQLConnection
108899>>>                tSQLConnection SQLConnection
108899>>>
108899>>>                Set Label of oShowInfo_tb to CS_LoadingTableSpaces
108900>>>                Get ReadCurrentSQLSettings to SQLConnection
108901>>>                Get SqlUtilEnumerateTableSpaces of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType SQLConnection.sConnectionString to sTheData
108902>>>
108902>>>                Get Prompt_Object to ho
108903>>>                Set psTheData  of ho to sTheData
108904>>>                Set Label of oShowInfo_tb to ""
108905>>>
108905>>>                Forward Send Prompt
108907>>>            End_Procedure
108908>>>
108908>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
108911>>>                Set Enabled_State to ((iDbType = EN_dbTypeDB2 or iDbType = EN_dbTypeOracle or iDbType = EN_dbTypePostgre) and sDriverID <> ODBC_DRV_ID)
108912>>>            End_Procedure
108913>>>
108913>>>        End_Object
108914>>>
108914>>>        Object oLongTableSpace_fm is a cSQLForm
108916>>>            Set Size to 13 114
108917>>>            Set Location to 163 82
108918>>>            Set Label to "Long Table Space"
108919>>>            Set piItem to 13
108920>>>            Set psToolTip to "Only applicable for IBM DB2 databases. If you are unsure on what to enter your best bet is to use the same value as for the 'Table Space' above."
108921>>>            Set Prompt_Button_Mode to PB_PromptOn
108922>>>            Set Prompt_Object to (oTableSpaceSelection_sl(Self))
108923>>>            Set peAnchors to anTopLeftRight
108924>>>
108924>>>            Procedure Prompt
108927>>>                String[] sTheData
108928>>>                Handle ho
108928>>>                tSQLConnection SQLConnection
108928>>>                tSQLConnection SQLConnection
108928>>>
108928>>>                Set Label of oShowInfo_tb to CS_LoadingTableSpaces
108929>>>                Get ReadCurrentSQLSettings to SQLConnection
108930>>>
108930>>>                Get SqlUtilEnumerateTableSpaces of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType SQLConnection.sConnectionString to sTheData
108931>>>
108931>>>                Get Prompt_Object to ho
108932>>>                Set psTheData     of ho to sTheData
108933>>>                Set Label of oShowInfo_tb to ""
108934>>>
108934>>>                Forward Send Prompt
108936>>>            End_Procedure
108937>>>
108937>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
108940>>>                Set Enabled_State to (iDbType = EN_dbTypeDB2)
108941>>>            End_Procedure
108942>>>
108942>>>        End_Object
108943>>>
108943>>>        Object oSchema_fm is a cSQLForm
108945>>>            Set Size to 13 78
108946>>>            Set Location to 163 210
108947>>>            Set Label to "Schema"
108948>>>            Set psToolTip to "The name of the schema the table belongs to. A schema is a collection of names or objects. A schema can contain tables, views, and triggers. Schemas provide a logical classification of objects in the database. It can have a slightly different meaning depending on the selected database type. Please consult your database manager to ensure the correct value is selected. Applicable for IBM DB2, Oracle and PostgreSQL databases. For IBM DB2 not specifying a schema will result in the user name being used. Microsoft SQL Server has a completely different approach to security and privileges and uses owners instead."
108949>>>            Set piItem to 11
108950>>>            Set Enabled_State to False
108951>>>
108951>>>            Property String psSchemaToolTip "The name of the schema the table belongs to. A schema is a collection of names or objects. A schema can contain tables, views, and triggers. Schemas provide a logical classification of objects in the database. It can have a slightly different meaning depending on the selected database type. Please consult a database manager to ensure the correct value is selected. Applicable for IBM DB2, Oracle and PostgreSQL databases. For IBM DB2 not specifying a schema will result in the user name being used. Microsoft SQL Server has a completely different approach to security and privileges and uses owners instead."
108953>>>            Property String psOwnerTooltip  "The owner name to use within the database where the tables must be placed. If you want to specify an owner of the table that will be converted you can do so, not specifying an owner will result in the default owner being used. The suggested owner name to use is 'dbo'"
108955>>>
108955>>>            Set peAnchors to anTopRight
108956>>>            Set Label_Justification_Mode to JMode_Top
108957>>>            Set Label_Col_Offset to 0
108958>>>
108958>>>            Procedure Prompt
108961>>>                String[] sTheData
108962>>>                Handle ho
108962>>>                tSQLConnection SQLConnection
108962>>>                tSQLConnection SQLConnection
108962>>>
108962>>>                Set Label of oShowInfo_tb to CS_LoadingSchemas
108963>>>                Get ReadCurrentSQLSettings to SQLConnection
108964>>>
108964>>>                Get SqlUtilEnumerateSchemas of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType SQLConnection.sConnectionString to sTheData
108965>>>
108965>>>                Get Prompt_Object to ho
108966>>>                Set psTheData     of ho to sTheData
108967>>>                Set Label of oShowInfo_tb to ""
108968>>>
108968>>>                Forward Send Prompt
108970>>>            End_Procedure
108971>>>
108971>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
108974>>>                String sValue
108974>>>
108974>>>                Set Enabled_State to ((iDbType = EN_dbTypeMSSQL or iDbType = EN_dbTypeDB2 or iDbType = EN_dbTypeOracle or iDbType = EN_dbTypePostgre) and sDriverID <> ODBC_DRV_ID)
108975>>>                If (iDbType = EN_dbTypeMSSQL) Begin
108977>>>                    Set Label to CS_DF_File_Owner
108978>>>                    Set Prompt_Button_Mode to PB_PromptOff
108979>>>                    Set Prompt_Object to 0
108980>>>                    Set psToolTip to (psOwnerTooltip(Self))
108981>>>                    Get Value to sValue
108982>>>                    If (Trim(sValue) = "") Begin
108984>>>                        Set Value to "dbo"
108985>>>                    End
108985>>>>
108985>>>                End
108985>>>>
108985>>>                Else Begin
108986>>>                    Set Label to CS_DF_File_Schema
108987>>>                    Set Prompt_Button_Mode to PB_PromptOn
108988>>>                    Set Prompt_Object to (oSchemasSelection_sl(Self))
108989>>>                    Set psToolTip to (psSchemaToolTip(Self))
108990>>>                    If (Trim(sValue) = "dbo") Begin
108992>>>                        Set Value to ""
108993>>>                    End
108993>>>>
108993>>>                End
108993>>>>
108993>>>                If (Enabled_State(Self) = False) Begin
108995>>>                    Set Value to ""
108996>>>                End
108996>>>>
108996>>>            End_Procedure
108997>>>
108997>>>        End_Object
108998>>>
108998>>>        Object oDatabase_fm is a cSQLForm
109000>>>            Set Size to 13 114
109001>>>            Set Location to 178 82
109002>>>            Set Label to "Database"
109003>>>            Set peAnchors to anTopLeftRight
109004>>>            Set psToolTip to "Name of the SQL database. Note: If you are setting up your first connection for a workspace and your SQL database doesn't exist yet, leave the default 'Master' as it is always available. The 'SqlDatabaseCreate' function will take care of the rest when creating your new SQL database."
109005>>>            Set piItem to 6
109006>>>            Set Prompt_Button_Mode to PB_PromptOn
109007>>>
109007>>>            Procedure Prompt
109010>>>                String[] sTheData
109011>>>                Handle ho
109011>>>                tSQLConnection SQLConnection
109011>>>                tSQLConnection SQLConnection
109011>>>
109011>>>                Set Label of oShowInfo_tb to CS_LoadingDatabases
109012>>>                Get ReadCurrentSQLSettings to SQLConnection
109013>>>
109013>>>                Get SqlUtilEnumerateDatabases of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID to sTheData
109014>>>
109014>>>                Get Prompt_Object to ho
109015>>>                Set psTheData     of ho to sTheData
109016>>>                Set Label of oShowInfo_tb to ""
109017>>>
109017>>>                Forward Send Prompt
109019>>>            End_Procedure
109020>>>
109020>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
109023>>>                Boolean bAdd
109023>>>                String sValue
109023>>>
109023>>>                If (sDriverID <> "") Begin
109025>>>                    Set Enabled_State to (sDriverID = MSSQLDRV_ID or sDriverID = SQLFLEX or sDriverID = MDSMySQL or sDriverID = MDSPgSQL or sDriverID = ORAFLEX or (sDriverID = ODBC_DRV_ID and iDbType <> EN_DbTypeOracle))
109026>>>                    If (Enabled_State(Self) = True) Begin
109028>>>                        Move (piCurrentRow(Self) = -1) to bAdd
109029>>>                        Get Value to sValue
109030>>>                        If (bAdd = True and sValue = "" and iDbType = EN_dbTypeMSSQL) Begin
109032>>>                            Set Value to "master"
109033>>>                        End
109033>>>>
109033>>>                        Else Begin
109034>>>                            Set Prompt_Button_Mode to PB_PromptOn
109035>>>                            Set Prompt_Object to (oDatabaseSelection_sl(Self))
109036>>>                            If (Value(Self) = "master") Begin
109038>>>                                Set Value to ""
109039>>>                            End
109039>>>>
109039>>>                        End
109039>>>>
109039>>>                    End
109039>>>>
109039>>>                    If (Enabled_State(Self) = False) Begin
109041>>>                        Set Value to ""
109042>>>                    End
109042>>>>
109042>>>                End
109042>>>>
109042>>>            End_Procedure
109043>>>
109043>>>        End_Object
109044>>>
109044>>>        Object oCreateDatabase_btn is a cRDCButton
109046>>>            Set Size to 13 78
109047>>>            Set Location to 178 210
109048>>>            Set Label to "Create Database..."
109049>>>            Set psImage to "ActionCreateDatabase1.ico"
109050>>>            Set pbAutoEnable to True
109051>>>            Set peAnchors to anTopRight
109052>>>        
109052>>>            Procedure OnClick                                                              
109055>>>                String sConnectionString sError sDriverID sLoginText sDatabaseName
109055>>>                
109055>>>                Get LoginString (&sError) to sConnectionString
109056>>>                If (sError <> "") Begin
109058>>>                    Send Info_Box sError
109059>>>                    Procedure_Return
109060>>>                End                         
109060>>>>
109060>>>                
109060>>>                Get Value of oDriverID_cf to sDriverID
109061>>>                Get Create_DataBase_Dialog of (Client_Id(phoMainPanel(ghoApplication))) sDriverID to sDatabaseName
109062>>>                If (sDatabaseName <> "") Begin
109064>>>                    Set Value of oDatabase_fm to sDatabaseName
109065>>>                End
109065>>>>
109065>>>            End_Procedure                
109066>>>            
109066>>>            Function IsEnabled Returns Boolean
109069>>>                Integer iDbType    
109069>>>                Boolean bReadOnly
109069>>>                Get SelectedDbType of oDbType_cf to iDbType
109070>>>                Get pbReadOnly to bReadOnly
109071>>>                Function_Return (bReadOnly = False and (iDbType = EN_DbTypeMSSQL or iDbType = EN_DbTypeDB2 or iDbType = EN_DbTypeMySQL or iDbType = EN_DbTypePostgre))
109072>>>            End_Function
109073>>>        
109073>>>        End_Object
109074>>>
109074>>>        Procedure DbTypeUpdate Integer iDbType String sDriverID
109077>>>            String sDbType
109077>>>            Get SqlUtilDbTypeToString of ghoDbUpdateFunctionLibrary iDbType to sDbType
109078>>>            Set Label to (sDbType * "Connection Details")
109079>>>        End_Procedure
109080>>>
109080>>>    End_Object
109081>>>
109081>>>    Object oOK_Btn is a cRDCButton
109083>>>        Set Label    to C_$OK
109084>>>        Set Location to 287 208 //281 208
109085>>>        Set peAnchors to anBottomRight
109086>>>
109086>>>        Procedure OnClick
109089>>>            String sLoginText
109089>>>            String[] sConnectionData
109090>>>            tSQLConnection SQLIniFileConnection
109090>>>            tSQLConnection SQLIniFileConnection
109090>>>            Boolean bNew bOK bShouldSave
109090>>>            Integer iRetval
109090>>>
109090>>>            Delegate Get Should_Save to bShouldSave
109092>>>            If (bShouldSave = False) Begin
109094>>>                Set pbChanged to False
109095>>>                Send Close_Panel
109096>>>                Procedure_Return
109097>>>            End
109097>>>>
109097>>>
109097>>>            Broadcast Recursive Send WriteConnectionData of (Parent(Self)) (&sConnectionData)
109099>>>
109099>>>            Get pbNew to bNew
109100>>>            Get MoveStringArrayToSQLConnection sConnectionData to SQLIniFileConnection
109101>>>            Case Begin
109101>>>                Case (SQLIniFileConnection.sDriverID = DB2_DRV_ID or SQLIniFileConnection.sDriverID = ODBC_DRV_ID)
109103>>>                    If (SQLIniFileConnection.sDriverID = DB2_DRV_ID) Begin
109105>>>                        Move "" to SQLIniFileConnection.sDatabase
109106>>>                    End
109106>>>>
109106>>>                    If (SQLIniFileConnection.bTrusted = True) Begin
109108>>>                        If (SQLIniFileConnection.bEnabled = True) Begin
109110>>>                        Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "") to bOK
109111>>>                        End
109111>>>>
109111>>>                        Else Begin
109112>>>                            Move (SQLIniFileConnection.sServer <> "") to bOK
109113>>>                        End
109113>>>>
109113>>>                    End
109113>>>>
109113>>>                    Else Begin
109114>>>                        // It should probably be allowed to use an UID but no password...
109114>>>                        If (SQLIniFileConnection.bEnabled = True) Begin
109116>>>                        Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sUserID <> "") to bOK
109117>>>                        End
109117>>>>
109117>>>                        Else Begin
109118>>>                            Move (SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sUserID <> "") to bOK
109119>>>                        End
109119>>>>
109119>>>                    End
109119>>>>
109119>>>                    Case Break
109120>>>                Case (SQLIniFileConnection.sDriverID = MSSQLDRV_ID or SQLIniFileConnection.sDriverID = SQLFLEX)
109123>>>                    If (SQLIniFileConnection.bTrusted = True) Begin
109125>>>                        If (SQLIniFileConnection.bEnabled = True) Begin
109127>>>                        Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sDatabase <> "") to bOK
109128>>>                        End
109128>>>>
109128>>>                        Else Begin
109129>>>                            Move (SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sDatabase <> "") to bOK
109130>>>                        End
109130>>>>
109130>>>                    End
109130>>>>
109130>>>                    Else Begin
109131>>>                        // It should probably be allowed to use an UID but no password...
109131>>>                        If (SQLIniFileConnection.bEnabled = True) Begin
109133>>>                        Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sDatabase <> "" and SQLIniFileConnection.sUserID <> "") to bOK
109134>>>                        End
109134>>>>
109134>>>                        Else Begin
109135>>>                            Move (SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sDatabase <> "" and SQLIniFileConnection.sUserID <> "") to bOK
109136>>>                        End
109136>>>>
109136>>>                    End
109136>>>>
109136>>>                    Case Break
109137>>>                Case (SQLIniFileConnection.sDriverID = ORAFLEX or SQLIniFileConnection.sDriverID = MDSPgSQL)
109140>>>                    // It should probably be allowed to use an UID but no password...
109140>>>                    If (SQLIniFileConnection.bEnabled = True) Begin
109142>>>                    Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sUserID <> "") to bOK
109143>>>                    End
109143>>>>
109143>>>                    Else Begin
109144>>>                        Move (SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sUserID <> "") to bOK
109145>>>                    End
109145>>>>
109145>>>                    Case Break
109146>>>                Case (SQLIniFileConnection.sDriverID = MDSPgSQL)
109149>>>                    // It should probably be allowed to use an UID but no password...
109149>>>                    If (SQLIniFileConnection.bEnabled = True) Begin
109151>>>                    Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sUserID <> "") to bOK
109152>>>                    End
109152>>>>
109152>>>                    Else Begin
109153>>>                        Move (SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sUserID <> "") to bOK
109154>>>                    End
109154>>>>
109154>>>                    Case Break
109155>>>                Case (SQLIniFileConnection.sDriverID = MDSMySQL)
109158>>>                    // It should probably be allowed to use an UID but no password...
109158>>>                    If (SQLIniFileConnection.bEnabled = True) Begin
109160>>>                    Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sUserID <> "") to bOK
109161>>>                    End
109161>>>>
109161>>>                    Else Begin
109162>>>                        Move (SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sUserID <> "") to bOK
109163>>>                    End
109163>>>>
109163>>>                    Case Break
109164>>>            Case End
109164>>>
109164>>>            If (bOK = False) Begin
109166>>>                Send Info_Box "Please fill in all connection data."
109167>>>                Procedure_Return
109168>>>            End
109168>>>>
109168>>>
109168>>>            Move MBR_Yes to iRetval
109169>>>            Get Label of oLoginInfo_tb to sLoginText
109170>>>            If (sLoginText = CS_LoginFailed) Begin
109172>>>                Get YesNo_Box "The login failed. Are you sure you want to use these connection settings?" to iRetval
109173>>>            End
109173>>>>
109173>>>            Else If (sLoginText = "") Begin
109176>>>                Get YesNo_Box "The login has not been tested. Are you sure you want to use these connection settings?" to iRetval
109177>>>            End
109177>>>>
109177>>>            If (iRetval <> MBR_Yes) Begin
109179>>>                Procedure_Return
109180>>>            End
109180>>>>
109180>>>
109180>>>            Set pSQLConnectionData to SQLIniFileConnection
109181>>>            Set pbChanged to True
109182>>>            Send Close_Panel
109183>>>        End_Procedure
109184>>>
109184>>>    End_Object
109185>>>
109185>>>    Object oCancel_Btn is a cRDCButton
109187>>>        Set Label    to C_$Cancel
109188>>>        Set Location to 287 264 //281 264
109189>>>        Set peAnchors to anBottomRight
109190>>>
109190>>>        Procedure OnClick
109193>>>            Set pbChanged to False
109194>>>            Send Close_Panel
109195>>>        End_Procedure
109196>>>
109196>>>    End_Object
109197>>>
109197>>>    Object oHelp_Btn is a cRDCButton
109199>>>        Set Label to C_$Help
109200>>>        Set Location to 287 11 //281 11
109201>>>        Set peAnchors to anBottomLeft
109202>>>        Set psImage to "ActionHelp1.ico"
109203>>>
109203>>>        Procedure OnClick
109206>>>            Send DoDisplayKeyword of ghoHtmlHelp "SQLConnections Tool"
109207>>>        End_Procedure
109208>>>    End_Object
109209>>>
109209>>>    Object oConnectionType_grp is a cRDCHeaderGroup
109211>>>        Set Size to 60 303
109212>>>        Set Location to 8 11 //2 11
109213>>>        Set psImage to "SQLSettings1.ico"
109214>>>        Set psLabel to "Database Type Settings"
109215>>>
109215>>>        Object oDbType_cf is a cSQLComboForm
109217>>>            Set Size to 13 115
109218>>>            Set Location to 22 82
109219>>>            Set Label to "Database Type"
109220>>>            Set Entry_State to False
109221>>>            Set Combo_Sort_State to False
109222>>>            Set psToolTip to "Select a database type, then select a driver to use for the database"
109223>>>            Set piItem to 3
109224>>>            
109224>>>            Procedure Combo_Fill_List
109227>>>                Send Combo_Add_Item CS_dbTypeMSSQL
109228>>>                Send Combo_Add_Item CS_dbTypeMySQL
109229>>>                Send Combo_Add_Item CS_dbTypeOracle
109230>>>                Send Combo_Add_Item CS_dbTypeDB2
109231>>>                Send Combo_Add_Item CS_dbTypePostgre
109232>>>            End_Procedure
109233>>>
109233>>>            Procedure OnChange
109236>>>                Integer iDbType
109236>>>                String sDriverID
109236>>>    
109236>>>                Get SelectedDbType to iDbType
109237>>>                Send Refill_Comboform of oDriverID_cf iDbType
109238>>>                Get Value of oDriverID_cf to sDriverID
109239>>>                If (sDriverID = "") Begin
109241>>>                    Move MSSQLDRV_ID to sDriverID
109242>>>                End
109242>>>>
109242>>>                Send DbTypeUpdate of oSettings_grp iDbType sDriverID
109243>>>            End_Procedure
109244>>>    
109244>>>            Function SelectedDbType Returns Integer
109247>>>                Integer iRetval
109247>>>                String sDbType
109247>>>    
109247>>>                Get Value to sDbType
109248>>>                Get SqlUtilDbTypeToInteger of ghoDbUpdateFunctionLibrary sDbType to iRetval
109249>>>    
109249>>>                Function_Return iRetval
109250>>>            End_Function
109251>>>
109251>>>        End_Object
109252>>>
109252>>>// This used to work, but it seems that the Ssms.exe is no longer part of Windows "global pathing (in DOS)".
109252>>>//        Object oStartSQLManager_btn is a cRDCButton
109252>>>//            Set Size to 13 78
109252>>>//            Set Location to 22 210
109252>>>//            Set Label to "SQL Manager"
109252>>>//            Set pbAutoEnable to True  
109252>>>//            Set psImage to "SSMS1.ico" 
109252>>>//            Set psToolTip to "Start Microsoft SQL Server Management Studio"
109252>>>//            Set peAnchors to anTopRight
109252>>>//        
109252>>>//            Procedure OnClick
109252>>>//                Runprogram Shell Background "Ssms.exe"    
109252>>>//            End_Procedure  
109252>>>//            
109252>>>//            Function IsEnabled Returns Boolean
109252>>>//                String sDbType
109252>>>//                Get Value of oDbType_cf to sDbType
109252>>>//                Function_Return (sDbType = CS_dbTypeMSSQL)
109252>>>//            End_Function
109252>>>//        
109252>>>//        End_Object
109252>>>
109252>>>        Object oDriverID_cf is a cSQLComboForm
109254>>>            Set Size to 13 115
109255>>>            Set Location to 37 82
109256>>>            Set Label to "Driver ID"
109257>>>            Set Entry_State to False
109258>>>            Set Combo_Sort_State to False
109259>>>            Set psToolTip to "Depending on the database type selected and if Mertech drivers have been installed, the comboform list will vary."
109260>>>            Set piItem to 4
109261>>>
109261>>>            Procedure Refill_Comboform Integer iDbType
109264>>>                String sValue
109264>>>
109264>>>                Send Combo_Delete_Data
109265>>>                Send Combo_Add_Item MSSQLDRV_ID
109266>>>                Send Combo_Add_Item ODBC_DRV_ID
109267>>>                Send Combo_Add_Item SQLFLEX
109268>>>                Send Combo_Add_Item ODBC_DRV_ID
109269>>>                Send Combo_Add_Item MDSMySQL
109270>>>                Send Combo_Add_Item ODBC_DRV_ID
109271>>>                Send Combo_Add_Item ORAFLEX
109272>>>                Send Combo_Add_Item DB2_DRV_ID
109273>>>                Send Combo_Add_Item ODBC_DRV_ID
109274>>>                Send Combo_Add_Item MDSPgSQL
109275>>>                Send Combo_Add_Item DATAFLEX_ID
109276>>>
109276>>>                Case Begin
109276>>>                    Case (iDbType = EN_dbTypeMSSQL)
109278>>>                        Move MSSQLDRV_ID to sValue
109279>>>                        Case Break
109280>>>                    Case (iDbType = EN_dbTypeMySQL)
109283>>>                        Move ODBC_DRV_ID to sValue
109284>>>                        Case Break
109285>>>                    Case (iDbType = EN_dbTypeOracle)
109288>>>                        Move ODBC_DRV_ID to sValue
109289>>>                        Case Break
109290>>>                    Case (iDbType = EN_dbTypeDB2)
109293>>>                        Move DB2_DRV_ID to sValue
109294>>>                        Case Break
109295>>>                    Case (iDbType = EN_dbTypePostgre)
109298>>>                        Move ODBC_DRV_ID to sValue
109299>>>                        Case Break
109300>>>                    Case Else
109300>>>                        Move DATAFLEX_ID to sValue
109301>>>                Case End
109301>>>                Set Value to sValue
109302>>>            End_Procedure
109303>>>
109303>>>            Procedure OnChange
109306>>>                String sDriverID
109306>>>                Integer iDbType
109306>>>
109306>>>                Get Value to sDriverID
109307>>>                If (sDriverID = "") Begin
109309>>>//                    Move MSSQLDRV_ID to sDriverID 
109309>>>                    Procedure_Return
109310>>>                End
109310>>>>
109310>>>                Get SelectedDbType of oDbType_cf to iDbType
109311>>>                Broadcast Recursive Send DbTypeUpdate of oSettings_grp iDbType sDriverID
109313>>>            End_Procedure
109314>>>
109314>>>        End_Object
109315>>>
109315>>>        Object oShowDriverSettings_btn is a cRDCButton
109317>>>            Set Size to 13 78
109318>>>            Set Location to 37 210
109319>>>            Set Label to "Driver Settings"
109320>>>            Set Status_Help to "Shows settings for the selected driver."
109321>>>            Set psImage to "DriverSettings1.ico"
109322>>>            Set peAnchors to anTopRight
109323>>>
109323>>>            Procedure OnClick
109326>>>                String sDriver sPath 
109326>>>                
109326>>>                Get Value of oDriverID_cf to sDriver
109327>>>                Send PopupDriverSettings sDriver 
109328>>>            End_Procedure
109329>>>    
109329>>>        End_Object
109330>>>
109330>>>    End_Object
109331>>>
109331>>>    Function ReadCurrentSQLSettings Returns tSQLConnection
109334>>>        tSQLConnection SQLConnection
109334>>>        tSQLConnection SQLConnection
109334>>>
109334>>>        Get Value of oDriverID_cf        to SQLConnection.sDriverID
109335>>>        Get SelectedDbType of oDbType_cf to SQLConnection.iDbType
109336>>>
109336>>>        Get Checked_State of oTrusted_cb to SQLConnection.bTrusted
109337>>>        Get Value of oDriverID_cf        to SQLConnection.sDriverID
109338>>>        Get Value of oServer_fm          to SQLConnection.sServer
109339>>>        Get Value of oUserID_fm          to SQLConnection.sUserID
109340>>>        Get Value of oPassword_fm        to SQLConnection.sPassword     
109341>>>        Move False to Err
109342>>>        Get ConstructConnectionString of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) ;            SQLConnection.sDriverID SQLConnection.sServer "" SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
109343>>>        Set pSQLConnection of ghoSQLConnectionHandler to SQLConnection
109344>>>        Move Err to SQLConnection.bError
109345>>>        
109345>>>        Function_Return SQLConnection
109346>>>    End_Function
109347>>>
109347>>>    Function LoginString String ByRef sError Returns String
109350>>>        String sDriverID sServer sDatabase
109350>>>        tSQLConnection SQLConnection
109350>>>        tSQLConnection SQLConnection
109350>>>        
109350>>>        Get Value of oDriverID_cf to sDriverID
109351>>>        If (sDriverID = "") Begin
109353>>>            Move "Please select a driver first, then try again." to sError
109354>>>            Function_Return ""
109355>>>        End
109355>>>>
109355>>>
109355>>>        Get Value of oServer_fm   to sServer
109356>>>        If (sServer = "") Begin
109358>>>            Move "Please select a server first, then try again." to sError
109359>>>            Function_Return ""
109360>>>        End
109360>>>>
109360>>>
109360>>>        Get Value of oDatabase_fm to sDatabase
109361>>>        If (sDatabase = "" and sDriverID = MSSQLDRV_ID) Begin
109363>>>            Move "master" to sDatabase
109364>>>        End
109364>>>>
109364>>>
109364>>>        Get ReadCurrentSQLSettings to SQLConnection
109365>>>        If (SQLConnection.bError = True) Begin
109367>>>            Move "Login Error" to sError
109368>>>        End
109368>>>>
109368>>>
109368>>>        Function_Return SQLConnection.sConnectionString
109369>>>    End_Function
109370>>>
109370>>>    // Returns True if anything has changed.
109370>>>    Function Should_Save Returns Boolean
109373>>>        String[] sConnectionData sConnectionData2
109375>>>        tSQLConnection SQLConnectionData
109375>>>        tSQLConnection SQLConnectionData
109375>>>        Boolean bState
109375>>>
109375>>>        Broadcast Recursive Send WriteConnectionData (&sConnectionData)
109377>>>        Get pSQLConnectionData to SQLConnectionData
109378>>>        Get MoveSQLConnectionToStringArray SQLConnectionData to sConnectionData2
109379>>>        // We don't have a form here for the sConnectionString, so we "blank it out"
109379>>>        // to be able to compare properly.
109379>>>        Move "" to sConnectionData2[7]
109380>>>
109380>>>            Move (IsSameArray(sConnectionData, sConnectionData2)) to bState
109381>>>        Function_Return (bState = False)
109382>>>    End_Function
109383>>>
109383>>>    Function IsConnectionIDDuplicate tSQLConnection SQLConnection Returns Boolean
109386>>>        Integer iCount iSize iItems iCurrentRow
109386>>>        String sValue sConnectionID
109386>>>        Boolean bExists
109386>>>        tDataSourceRow[] TheData
109386>>>        tDataSourceRow[] TheData
109387>>>        tDataSourceRow TheRow
109387>>>        tDataSourceRow TheRow
109387>>>
109387>>>        Move 0 to iItems
109388>>>        Get piCurrentRow to iCurrentRow
109389>>>        Move SQLConnection.sConnectionID to sConnectionID
109390>>>        Get MoveSQLConnectionToGridRow SQLConnection to TheRow
109391>>>        Get pTheData to TheData
109392>>>        Move (SizeOfArray(TheData)) to iSize
109393>>>        If (iCurrentRow <> -1) Begin
109395>>>            // This is the sConnectionID:
109395>>>            Move TheRow.sValue[2] to TheData[iCurrentRow].sValue[2]
109396>>>        End
109396>>>>
109396>>>        Else Begin
109397>>>            Move TheRow to TheData[iSize]
109398>>>        End
109398>>>>
109398>>>        Move (SizeOfArray(TheData)) to iSize
109399>>>        Decrement iSize
109400>>>        For iCount from 0 to iSize
109406>>>>
109406>>>            Move TheData[iCount].sValue[2] to sValue
109407>>>            Move (sValue = sConnectionID) to bExists
109408>>>            If (bExists) Begin
109410>>>                Increment iItems
109411>>>            End
109411>>>>
109411>>>        Loop
109412>>>>
109412>>>
109412>>>        Function_Return (iItems > 1)
109413>>>    End_Function
109414>>>
109414>>>    // Transfers data between a tSQLConnection struct and a grid data row.
109414>>>    Function MoveSQLConnectionToGridRow tSQLConnection SQLConnection Returns tDataSourceRow
109417>>>        tDataSourceRow TheRow
109417>>>        tDataSourceRow TheRow
109417>>>        Integer iDbType
109417>>>        String sValue
109417>>>
109417>>>        Move 0                                  to TheRow.sValue[0]
109418>>>        Move SQLConnection.bEnabled             to TheRow.sValue[1]
109419>>>        Move SQLConnection.sConnectionID        to TheRow.sValue[2]
109420>>>        Move SQLConnection.sDriverID            to TheRow.sValue[3]
109421>>>
109421>>>        // We only show three asterisks ("***") instead of the password in the grid.
109421>>>        Move (Replace(SQLConnection.sPassword, SQLConnection.sConnectionString, "***")) to sValue
109422>>>        Move sValue                             to TheRow.sValue[4]
109423>>>
109423>>>        Move SQLConnection.iDbType to iDbType
109424>>>        Get SqlUtilDbTypeToString of ghoDbUpdateFunctionLibrary iDbType to sValue
109425>>>        Move sValue                             to TheRow.sValue[5]
109426>>>        Move SQLConnection.sServer              to TheRow.sValue[6]
109427>>>        Move SQLConnection.sDatabase            to TheRow.sValue[7]
109428>>>
109428>>>        // Hidden columns (to make Should_Save function work)
109428>>>        Move SQLConnection.sConnectionString    to TheRow.sValue[8] // "Untouched" connection string.
109429>>>        Move SQLConnection.bTrusted             to TheRow.sValue[9]
109430>>>        Move SQLConnection.sUserID              to TheRow.sValue[10]
109431>>>        Move SQLConnection.sPassword            to TheRow.sValue[11]
109432>>>        Move SQLConnection.sSchema              to TheRow.sValue[12]
109433>>>        Move SQLConnection.sBaseTableSpace      to TheRow.sValue[13]
109434>>>        Move SQLConnection.sLongTableSpace      to TheRow.sValue[14]
109435>>>        Move SQLConnection.sIndexTableSpace     to TheRow.sValue[15]
109436>>>        Move SQLConnection.bSilentLogin         to TheRow.sValue[16]
109437>>>//        Move SQLConnection.bDisabled            to TheRow.sValue[17]
109437>>>//        Move SQLConnection.iDriverIndex         to TheRow.sValue[18]
109437>>>
109437>>>        Function_Return TheRow
109438>>>    End_Function
109439>>>
109439>>>    Function MoveSQLConnectionToStringArray tSQLConnection SQLConnection Returns String[]
109442>>>        String[] sConnectionData
109443>>>        Integer iRetval
109443>>>
109443>>>        Move SQLConnection.bEnabled          to sConnectionData[1]
109444>>>        Move SQLConnection.sConnectionID     to sConnectionData[2]
109445>>>        Get SqlUtilDbTypeToString of ghoDbUpdateFunctionLibrary SQLConnection.iDbType to sConnectionData[3]
109446>>>        Move SQLConnection.sDriverID         to sConnectionData[4]
109447>>>        Move SQLConnection.sServer           to sConnectionData[5]
109448>>>        Move SQLConnection.sDatabase         to sConnectionData[6]
109449>>>        Move SQLConnection.sConnectionString to sConnectionData[7]
109450>>>        Move SQLConnection.bTrusted          to sConnectionData[8]
109451>>>        Move SQLConnection.sUserID           to sConnectionData[9]
109452>>>
109452>>>        If (SQLConnection.sPassword <> "") Begin
109454>>>            Move MBR_Yes to iRetval
109455>>>            If (pbDFConnId(Self) = True) Begin
109457>>>                Get YesNo_Box "You are working with a DAW 'DFConnId.ini' file. Although this program can both read/write to such a file, the password encryption/decryption algorithms are (obviously) different. Thus the password will not be touched. Continue?" to iRetval
109458>>>                If (iRetval = MBR_Yes) Begin
109460>>>                    Set psUncryptedPw to SQLConnection.sPassword
109461>>>                    Move "" to SQLConnection.sPassword 
109462>>>//                    Set Enabled_State of oCheckLogin_btn to False
109462>>>                End
109462>>>>
109462>>>                Else Begin
109463>>>                    Send Stop_UI
109464>>>                End
109464>>>>
109464>>>            End
109464>>>>
109464>>>            Else Begin
109465>>>                Move SQLConnection.sPassword to sConnectionData[10]
109466>>>            End
109466>>>>
109466>>>        End
109466>>>>
109466>>>
109466>>>        Move SQLConnection.sSchema           to sConnectionData[11]
109467>>>        Move SQLConnection.sBaseTableSpace   to sConnectionData[12]
109468>>>        Move SQLConnection.sLongTableSpace   to sConnectionData[13]
109469>>>        Move SQLConnection.sIndexTableSpace  to sConnectionData[14]
109470>>>        Move SQLConnection.bSilentLogin      to sConnectionData[15]
109471>>>
109471>>>        Function_Return sConnectionData
109472>>>    End_Function
109473>>>
109473>>>    Function MoveStringArrayToSQLConnection String[] sConnectionData Returns tSQLConnection
109476>>>        tSQLConnection SQLConnection
109476>>>        tSQLConnection SQLConnection
109476>>>
109476>>>        Move sConnectionData[1]  to SQLConnection.bEnabled
109477>>>        Move sConnectionData[2]  to SQLConnection.sConnectionID
109478>>>        Get SqlUtilDbTypeToInteger of ghoDbUpdateFunctionLibrary sConnectionData[3] to SQLConnection.iDbType
109479>>>        Move sConnectionData[4]  to SQLConnection.sDriverID
109480>>>        Move sConnectionData[5]  to SQLConnection.sServer
109481>>>        Move sConnectionData[6]  to SQLConnection.sDatabase
109482>>>
109482>>>        Move sConnectionData[8]  to SQLConnection.bTrusted
109483>>>        Move sConnectionData[9]  to SQLConnection.sUserID
109484>>>
109484>>>        If (sConnectionData[10] <> "" and pbDFConnId(Self) = False) Begin
109486>>>            Move sConnectionData[10] to SQLConnection.sPassword
109487>>>        End
109487>>>>
109487>>>        // In case of we're dealing with a DfConnID.ini file (DF 19+) we don't want to change the password
109487>>>        // as DAW's 'Managed Connections' program has a different password encryption/decryption algorithm.
109487>>>        If (pbDFConnId(Self) = True) Begin
109489>>>            Get psUncryptedPw to SQLConnection.sPassword
109490>>>        End
109490>>>>
109490>>>
109490>>>        Move sConnectionData[11] to SQLConnection.sSchema
109491>>>        Move sConnectionData[12] to SQLConnection.sBaseTableSpace
109492>>>        Move sConnectionData[13] to SQLConnection.sLongTableSpace
109493>>>        Move sConnectionData[14] to SQLConnection.sIndexTableSpace
109494>>>        Move sConnectionData[15] to SQLConnection.bSilentLogin
109495>>>
109495>>>        // Connection string:
109495>>>        Get ConstructConnectionString of ghoSQLConnectionHandler SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase ;                                                                 SQLConnection.bTrusted  SQLConnection.sUserID SQLConnection.sPassword ;                                      to SQLConnection.sConnectionString
109496>>>
109496>>>        Function_Return SQLConnection
109497>>>    End_Function
109498>>>
109498>>>    Procedure Popup
109501>>>        tSQLConnection SQLIniFileConnection
109501>>>        tSQLConnection SQLIniFileConnection
109501>>>        String[] sConnectionData
109502>>>        String sDriverID
109502>>>        Integer iDbType
109502>>>        Boolean bAdd
109502>>>
109502>>>        Move (piCurrentRow(Self) = -1) to bAdd
109503>>>        Get pSQLConnectionData to SQLIniFileConnection             
109504>>>        // we need these as the oConnectionType_grp has been moved to be the last object(s) in the dialog.
109504>>>        Set Value of oDbType_cf   to SQLIniFileConnection.iDbType
109505>>>        Set Value of oDriverID_cf to ""
109506>>>        If (SQLIniFileConnection.bEnabled = False and bAdd = True) Begin
109508>>>            Move True to SQLIniFileConnection.bEnabled
109509>>>        End
109509>>>>
109509>>>        Get MoveSQLConnectionToStringArray SQLIniFileConnection to sConnectionData
109510>>>
109510>>>        Set Value of oDriverID_cf to SQLIniFileConnection.sDriverID
109511>>>        Set Value of oDbType_cf   to SQLIniFileConnection.iDbType
109512>>>        Broadcast Recursive Send ReadConnectionData sConnectionData
109514>>>
109514>>>        // We need this message to "auto-default" certain fields.
109514>>>        If (bAdd = True) Begin
109516>>>            Get SelectedDbType of oDbType_cf to iDbType
109517>>>            Get Value of oDriverID_cf to sDriverID
109518>>>            If (sDriverID = "") Begin
109520>>>                Move MSSQLDRV_ID to sDriverID
109521>>>            End
109521>>>>
109521>>>            Broadcast Recursive Send DbTypeUpdate of oSettings_grp iDbType sDriverID
109523>>>        End
109523>>>>
109523>>>
109523>>>        Set Password_State of oPassword_fm to True
109524>>>        Set Value of oLoginInfo_tb to ""
109525>>>        Set Statusbar_Id to (phoDialogCommandbar(Self))
109526>>>
109526>>>        Forward Send Popup
109528>>>    End_Procedure
109529>>>
109529>>>    Procedure Page Integer iPageObject
109532>>>        Boolean bNew bReadOnly
109532>>>        String sText
109532>>>        Handle hWnd
109532>>>
109532>>>        Send Cursor_Ready of Cursor_Control
109533>>>        Forward Send Page iPageObject
109535>>>
109535>>>        Set Icon to "SQLConnections1.ico"
109536>>>
109536>>>        Get pbNew to bNew
109537>>>        If (bNew = True) Begin
109539>>>            Move ("The" * CS_SQLIniFileName * "file doesn't exist yet for this workspace and needs to be created. Here's what you need to do:\n\n") to sText
109540>>>            Move (sText * "1. Enter a Connection ID (the same that is being used by your workspace .int files) and other data that is used to login to the database.\n") to sText
109541>>>            Move (sText * "2. Press the 'Test Login' button to ensure entered details are correct.\n") to sText
109542>>>            Move (sText * "3. Press the 'OK' button and then save your changes.\n") to sText
109543>>>            Send Info_Box sText
109544>>>        End
109544>>>>
109544>>>
109544>>>        If (ghoSkinFramework <> 0 and hWnd <> 0) Begin
109546>>>            Send ComRemoveWindow to ghoSkinFramework hWnd
109547>>>            Send ComApplyWindow  to ghoSkinFramework hWnd
109548>>>        End
109548>>>>
109548>>>
109548>>>        Get pbReadOnly to bReadOnly
109549>>>        If (bReadOnly = True) Begin
109551>>>            Broadcast Recursive Set Enabled_State    to (not(bReadOnly))
109553>>>            Set Enabled_State of oConnectionType_grp to True
109554>>>            Set Enabled_State of oSettings_grp       to True
109555>>>            Set Enabled_State of oPassword_fm        to True
109556>>>            Set Enabled_State of oViewPassword_btn   to True
109557>>>            Set Enabled_State of oCheckLogin_btn     to True
109558>>>            Set Enabled_State of oCancel_Btn         to True
109559>>>            Set Enabled_State of oHelp_Btn           to True
109560>>>            Set Enabled_State of oShowDriverSettings_btn to True
109561>>>            Set Enabled_State of oCreateDatabase_btn to False
109562>>>            Send Activate of oCancel_Btn
109563>>>        End
109563>>>>
109563>>>    End_Procedure
109564>>>
109564>>>    Function IniFileName Returns String
109567>>>        String sRetval
109567>>>        Function_Return sRetval
109568>>>    End_Function
109569>>>
109569>>>    // Put a status bar at the bottom of the panel, which makes
109569>>>    // status_help work and puts a gripper in the lower right corner.
109569>>>    Procedure End_Construct_Object
109572>>>        Integer iStyle iSize iOffset
109572>>>
109572>>>        Forward Send End_Construct_Object
109574>>>
109574>>>        Get Border_Style to iStyle
109575>>>        Move 8 to iOffset
109576>>>        If (iStyle = Border_Thick) Begin
109578>>>            Object oDialogCommandbar is a cCJCommandBarSystem
109580>>>                Object oStatusBar is a cCJStatusBar
109582>>>                    Set phoDialogCommandbar to Self
109583>>>                    Object oStatusIdle is a cCJStatusBarPane
109585>>>                        Set piId to sbpIDIdlePane
109586>>>                        Set pbStyleStretch to True
109587>>>                    End_Object
109588>>>                End_Object
109589>>>            End_Object
109590>>>
109590>>>            Get Size to iSize
109591>>>            Set Size to (Hi(iSize) + iOffset) (Low(iSize))
109592>>>        End
109592>>>>
109592>>>    End_Procedure
109593>>>
109593>>>    Procedure ShowProgramHelp
109596>>>        Send DoDisplayKeyword of ghoHtmlHelp "SQLConnections Tool"
109597>>>    End_Procedure
109598>>>
109598>>>    On_Key Key_F1         Send ShowProgramHelp
109599>>>    On_Key Key_Ctrl+Key_L Send KeyAction of oCheckLogin_btn
109600>>>    On_Key kCancel        Send KeyAction of oCancel_Btn
109601>>>End_Object
109602>>>
109602>>>// General purpose access message                                                                                                           // If ini-file= "DFConnId.ini" (DAW file)
109602>>>Procedure Activate_SQLMaintainConnections_dg Boolean bNew Integer iCurrentRow tSQLConnection ByRef SQLConnectionData Boolean ByRef bChanged Boolean bDFConnId tDataSourceRow[] TheData
109605>>>    Handle ho
109605>>>    String sPath sSQLConnectionsFileName
109605>>>    Boolean bExists
109605>>>    
109605>>>    Send Cursor_Wait of Cursor_Control
109606>>>    Move (oSQLMaintainConnections_dg(Self)) to ho
109607>>>    Set pbReadOnly              of ho to False
109608>>>    Set pbNew                   of ho to bNew
109609>>>    Set piCurrentRow            of ho to iCurrentRow
109610>>>    Set pbDFConnId              of ho to bDFConnId
109611>>>    Set pSQLConnectionData      of ho to SQLConnectionData
109612>>>    Get psIniFilePath of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) to sPath
109613>>>    Get psIniFileName of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) to sSQLConnectionsFileName
109614>>>    File_Exist (sPath + sSQLConnectionsFileName) bExists
109615>>>    If (bExists = True) Begin
109617>>>     Set Label  of ho to ("Connection Properties" * "[" + String(sPath) + String(sSQLConnectionsFileName) + "]")
109618>>>    End
109618>>>>
109618>>>    
109618>>>    Set pTheData                of ho to TheData
109619>>>
109619>>>    Send Popup                  of ho
109620>>>
109620>>>    Get pSQLConnectionData      of ho to SQLConnectionData
109621>>>    Get pbChanged               of ho to bChanged
109622>>>End_Procedure
109623>>>
109623>>>// Read-only access message
109623>>>Procedure Activate_ReadOnlySQLMaintainConnections_dg tSQLConnection SQLConnectionData
109626>>>    Handle ho
109626>>>    String sPath sSQLConnectionsFileName
109626>>>
109626>>>    Send Cursor_Wait of Cursor_Control
109627>>>    Move (oSQLMaintainConnections_dg(Self)) to ho
109628>>>    Set pbReadOnly              of ho to True
109629>>>
109629>>>    Set pSQLConnectionData      of ho to SQLConnectionData
109630>>>    Get psIniFilePath of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) to sPath
109631>>>    Get psIniFileName of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) to sSQLConnectionsFileName
109632>>>    Set Label  of ho to ("Connection Properties (Read-Only)" * "[" + String(sPath) + String(sSQLConnectionsFileName) + "]")
109633>>>
109633>>>    Send Popup of ho
109634>>>End_Procedure
109635>>>
109635>        Use AddToStudio.dg     
Including file: AddToStudio.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\AddToStudio.dg)
109635>>>Use Windows.pkg
109635>>>Use Dfspnfrm.pkg
109635>>>Use cRegistry.pkg
109635>>>Use vWin32fh.pkg
109635>>>
109635>>>Enum_List
109635>>>    Define cx_RegKeyAlreadyExist
109635>>>    Define cx_RegKeyCreated
109635>>>    Define cx_RegkeyFailed
109635>>>    Define cx_RegKeyVDFKeyDoesNotExist
109635>>>    Define CX_InstalledOkVdfUnder16
109635>>>End_Enum_List
109635>>>
109635>>>// Note: The "Visual" part will automatically be removed if
109635>>>// the current DataFlex version is above 17.
109635>>>Define CS_StudioPath        for "Software\Data Access Worldwide\Visual DataFlex Tools\"
109635>>>Define CS_StudioTools       for "\Studio\Tools"
109635>>>Define CS_RegApplication    for "<application>"
109635>>>Define CS_RegWorkspace      for "<workspace>"
109635>>>Define CS_CommandLine       for "CommandLine"
109635>>>Define CS_Name              for "Name"
109635>>>Define CS_Separator         for "Separator"
109635>>>Define CS_Command           for "Command"
109635>>>
109635>>>Object oAddToStudio_dg is a ModalPanel
109637>>>    Set Size to 79 330
109638>>>    Set Label to "Add Program To DataFlex Studio's Tools Menu"
109639>>>    Set piMinSize to 79 211
109640>>>    Set Location to 5 4
109641>>>    Set Locate_Mode to Center_On_Parent
109642>>>
109642>>>    Property String psTag CS_RegApplication
109644>>>
109644>>>    Object oStudioIntegration_grp is a Group
109646>>>        Set Size to 45 299
109647>>>        Set Location to 8 15
109648>>>        Set Label to "DataFlex Studio Integration"
109649>>>
109649>>>        Object oStudioMajorVersion_sf is a SpinForm
109651>>>            Set Size to 12 27
109652>>>            Set Location to 18 168
109653>>>            Set Maximum_Position to 30
109654>>>            Set Minimum_Position to 14
109655>>>            Set Label_Col_Offset to 2
109656>>>            Set Label_Justification_Mode to JMode_Right
109657>>>            Set Label to "Add to Studio's Tools Menu:     Major Version"
109658>>>            Set Status_Help to "DataFlex main version - e.g. '18'"
109659>>>            Set Value to FMAC_VERSION
109660>>>            Set peAnchors to anNone
109661>>>        End_Object
109662>>>
109662>>>        Object oStudioMinorVersion_sf is a SpinForm
109664>>>            Set Size to 12 27
109665>>>            Set Location to 18 254
109666>>>            Set Label_Col_Offset to 2
109667>>>            Set Label to "Minor Version"
109668>>>            Set Status_Help to "DataFlex minor version - e.g. '0'"
109669>>>            Set Maximum_Position to 9
109670>>>            Set Minimum_Position to 0
109671>>>            Set Value to FMAC_REVISION
109672>>>            Set Label_Justification_Mode to JMode_Right
109673>>>            Set peAnchors to anNone
109674>>>        End_Object
109675>>>
109675>>>    End_Object
109676>>>
109676>>>    Object oOK_btn is a Button
109678>>>        Set Location to 59 207
109679>>>        Set Label to "Add Now"
109680>>>        Set Status_Help to "Add to DataFlex Studio's Tools menu. The Studio version can be selected with the two spinforms. The program gets added to the Studios Tools menu."
109681>>>        Set peAnchors to anTopRight
109682>>>
109682>>>        Procedure OnClick
109685>>>            Integer iRetval iMajorVersion iMinorVersion
109685>>>            String sText sStudioVersion
109685>>>            Get Value of oStudioMajorVersion_sf to iMajorVersion
109686>>>            Get Value of oStudioMinorVersion_sf to iMinorVersion
109687>>>            Move (String(iMajorVersion) + "." + String(iMinorVersion)) to sStudioVersion
109688>>>            Get AddProgramToStudioToolsMenu sStudioVersion to iRetval
109689>>>            Case Begin
109689>>>                Case (iRetval = cx_RegKeyAlreadyExist)
109691>>>                    Move ("The program already exists in the" * sStudioVersion * "DataFlex Studios Tools menu.") to sText
109692>>>                    Break
109693>>>                Case (iRetval = cx_RegKeyCreated)
109696>>>                    Move ("Success. The tool was added to the" * sStudioVersion *  "DataFlex Studios Tools menu.") to sText
109697>>>                    Break
109698>>>                Case (iRetval = cx_RegkeyFailed)
109701>>>                    Move "Failed. Could not create the registry key for adding the program to the DataFlex Studio's Tools menu." to sText
109702>>>                    Break
109703>>>                Case (iRetval = cx_RegKeyVDFKeyDoesNotExist)
109706>>>                    Move ("Could not find the Studio registry key. Is DataFlex Studio version" * sStudioVersion * "really installed on this machine?") to sText
109707>>>                    Break
109708>>>                Case (iRetval = CX_InstalledOkVdfUnder16)
109711>>>                    Move ("The program was added to the" * sStudioVersion * "Studios Tools menu successfully, but because you installed for an earlier version of the Studio than 16.0 you need to compile the program under that same VDF version, else the Studio can't start the program properly. (Sorry, just a 'feature' of earlier versions of the Studio)") to sText
109712>>>                    Break
109713>>>            Case End
109713>>>
109713>>>            Send Info_Box sText
109714>>>        End_Procedure
109715>>>    End_Object
109716>>>
109716>>>    Object oCancel_Btn is a Button
109718>>>        Set Label to C_$Close
109719>>>        Set Location to 59 264
109720>>>        Set peAnchors to anBottomRight
109721>>>
109721>>>        Procedure OnClick
109724>>>            Send Close_Panel
109725>>>        End_Procedure
109726>>>
109726>>>    End_Object
109727>>>
109727>>>    Function AddProgramToStudioToolsMenu String sStudioVersion Returns Integer
109730>>>        Boolean bOk bExists bOpen
109730>>>        String sKey sValue sProgramPath sProgram sProduct sStudioPath
109730>>>        Handle hoReg hoArray
109730>>>        Integer i iItems iCreated iRetval
109730>>>
109730>>>        Move False to bOk
109731>>>        Move (CS_StudioPath + (Trim(sStudioVersion)))  to sStudioPath
109732>>>        If (sStudioVersion > "17.1") Begin
109734>>>            Move (Replace("Visual ", sStudioPath, "")) to sStudioPath
109735>>>        End
109735>>>>
109735>>>
109735>>>        Get psProgramPath of (phoWorkspace(ghoApplication)) to sProgramPath
109736>>>        Get PathAtIndex of (phoWorkspace(ghoApplication)) sProgramPath 1 to sProgramPath
109737>>>        Get vFolderFormat sProgramPath to sProgramPath
109738>>>        Get psProduct     of (phoWorkspace(ghoApplication)) to sProduct
109739>>>        Get Module_Name to sProgram
109740>>>        Get Create (RefClass(cRegistry)) to hoReg
109741>>>        Set phRootKey of hoReg to HKEY_CURRENT_USER
109742>>>
109742>>>        // First check if the VDF version is installed
109742>>>        Get KeyExists of hoReg sStudioPath to bExists
109743>>>        If (bExists = False) Begin
109745>>>            Send Destroy of hoReg
109746>>>            Function_Return cx_RegKeyVDFKeyDoesNotExist
109747>>>        End
109747>>>>
109747>>>
109747>>>        // Then check if any tools have been installed in the Tools Menu.
109747>>>        // If no tools created yet, create the Tools registry key.
109747>>>        Move (sStudioPath + CS_StudioTools) to sStudioPath
109748>>>        Get KeyExists of hoReg sStudioPath to bExists
109749>>>        If (bExists = False) Begin
109751>>>            Set pfAccessRights of hoReg to KEY_ALL_ACCESS
109752>>>            Get CreateKey of hoReg sStudioPath to iCreated
109753>>>            If (iCreated <> 0) Begin
109755>>>                Move cx_RegkeyFailed to iRetval
109756>>>            End
109756>>>>
109756>>>            Else Begin
109757>>>                Move True to bExists
109758>>>            End
109758>>>>
109758>>>        End
109758>>>>
109758>>>
109758>>>        If (bExists = True) Begin
109760>>>            Get OpenKey of hoReg sStudioPath to bOk
109761>>>            If (bOk = True) Begin
109763>>>                Get Create (RefClass(Array)) to hoArray
109764>>>                Get GetSubkeys of hoReg hoArray to iItems
109765>>>                Decrement iItems
109766>>>                Move False to bExists
109767>>>                Set pfAccessRights of hoReg to KEY_READ
109768>>>                // Check if the key already exists:
109768>>>                For i from 0 to iItems
109774>>>>
109774>>>                    Get Value of hoArray i to sKey
109775>>>                    Move (sStudioPath + "\" + sKey) to sKey
109776>>>                    Get OpenKey of hoReg sKey to bOpen
109777>>>                    If (bOpen = True) Begin
109779>>>                        Get ReadString of hoReg CS_Name to sValue
109780>>>                        If (sValue = sProduct) Begin
109782>>>                            Move True to bExists
109783>>>                        End
109783>>>>
109783>>>                    End
109783>>>>
109783>>>                Loop
109784>>>>
109784>>>                Send Destroy of hoArray
109785>>>                If (bExists = False) Begin
109787>>>                    Set pfAccessRights of hoReg to KEY_ALL_ACCESS
109788>>>                    // We need to create the next key number:
109788>>>                    // The studio expect tools menu items to be numbered 1,2,3...n
109788>>>                    Increment iItems
109789>>>                    Increment iItems
109790>>>                    Get CreateKey of hoReg (sStudioPath + "\" + String(iItems)) to iCreated
109791>>>                    If (iCreated = 0) Begin
109793>>>                        Send WriteString of hoReg CS_Name sProduct
109794>>>                        // From DataFlex 16 and up the params for the Studio's Tools menu changed slightly:
109794>>>                        If (sStudioVersion >= "16.0") Begin
109796>>>                            Send WriteString of hoReg CS_Command (sProgramPath + sProgram)
109797>>>                            Send WriteString of hoReg CS_CommandLine (psTag(Self))
109798>>>                        End
109798>>>>
109798>>>                        Else Begin
109799>>>                            Send WriteString of hoReg CS_CommandLine ('"' + sProgramPath + sProgram + ".exe" + '"' * psTag(Self))
109800>>>                            Move CX_InstalledOkVdfUnder16 to iRetval
109801>>>                        End
109801>>>>
109801>>>                        Send WriteDword  of hoReg CS_Separator 1
109802>>>                        Move cx_RegKeyCreated to iRetval
109803>>>                    End
109803>>>>
109803>>>                    Else Begin
109804>>>                        Move cx_RegkeyFailed to iRetval
109805>>>                    End
109805>>>>
109805>>>                End
109805>>>>
109805>>>                Else Begin
109806>>>                    Move cx_RegKeyAlreadyExist to iRetval
109807>>>                End
109807>>>>
109807>>>                Send CloseKey of hoReg
109808>>>            End
109808>>>>
109808>>>        End
109808>>>>
109808>>>
109808>>>        Send Destroy of hoReg
109809>>>        Function_Return iRetval
109810>>>    End_Function
109811>>>
109811>>>    Procedure Page Integer iPageObject
109814>>>        Forward Send Page iPageObject
109816>>>        Set Icon to "ActionAddStudio1.ico"
109817>>>    End_Procedure
109818>>>
109818>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
109819>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
109820>>>    On_Key kCancel       Send KeyAction of oCancel_Btn
109821>>>End_Object
109822>        Use ViewSourceCode.dg
Including file: ViewSourceCode.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ViewSourceCode.dg)
109822>>>Use Windows.pkg
109822>>>Use cRDCButtonDPI.pkg
109822>>>Use cRichEdit.pkg
109822>>>Use seq_chnl.pkg
109822>>>Use vWin32fh.pkg
109822>>>
109822>>>Object oSourceCodeDialog_dg is a ModalPanel
109824>>>    Set Size to 214 395
109825>>>    Set Label to "View Source Code Dialog"
109826>>>    Set piMinSize to 89 211
109827>>>    Set Location to 2 2
109828>>>    Set Border_Style To Border_Thick
109829>>>    Set Locate_Mode to Center_On_Parent
109830>>>
109830>>>    Property String psSourceCode ""
109832>>>    Property Integer piIndent
109834>>>
109834>>>    Object oSourceCode_edt is a cRichEdit
109836>>>        Set Size to 169 373
109837>>>        Set Location to 16 11
109838>>>        Set TextColor to clBlack
109839>>>        Set peAnchors to anAll
109840>>>        Set Label_Row_Offset to 3
109841>>>        Set Label_TextColor to clGreenGreyLight
109842>>>        Set Label_FontItalics to True
109843>>>        Set piFontSize to 200
109844>>>        Set psTypeFace to 'Consolas'
109845>>>
109845>>>        Delegate Set piIndent to (piParagraphIndent(Self))
109847>>>
109847>>>        Procedure DoSaveDocument
109850>>>            String sSourceCode
109850>>>            Boolean bOk bOkToSave bChanged
109850>>>
109850>>>            Move False to bOkToSave
109851>>>            Get pbCanUndo to bChanged
109852>>>            If (bChanged = False) Begin
109854>>>                Procedure_Return
109855>>>            End
109855>>>>
109855>>>
109855>>>            Get psSourceCode to sSourceCode
109856>>>            Send Write sSourceCode
109857>>>            // clear undo buffer on save
109857>>>            // we want undo buffer to only apply to the new document
109857>>>            Send ClearUndoBuffer
109858>>>            Send Info_Box "Changes saved."
109859>>>        End_Procedure
109860>>>
109860>>>        Procedure LoadData
109863>>>            String sSourceCode
109863>>>            Integer iTwips iIndent
109863>>>
109863>>>            Get psSourceCode to sSourceCode
109864>>>            Set Label to sSourceCode
109865>>>            Move 1440 to iTwips
109866>>>            Get piIndent to iIndent
109867>>>            Set piParagraphIndent to (iIndent + (iTwips * 0.2))
109868>>>
109868>>>            Send Read sSourceCode
109869>>>        End_Procedure
109870>>>
109870>>>        On_Key Key_Ctrl+Key_S Send DoSaveDocument
109871>>>        On_Key kCancel Send Cancel
109872>>>    End_Object
109873>>>
109873>>>    Object oCancel_Btn is a cRDCButtonDPI
109875>>>        Set Label    to "&Close"
109876>>>        Set Location to 193 334
109877>>>        Set peAnchors to anBottomRight
109878>>>
109878>>>        Procedure OnClick
109881>>>            Send Close_Panel
109882>>>        End_Procedure
109883>>>
109883>>>    End_Object
109884>>>
109884>>>
109884>>>    Object oFirstRun_btn is a cRDCButtonDPI
109886>>>        Set Location to 193 220
109887>>>        Set Label to "View &Top"
109888>>>        Set peAnchors to anBottomRight
109889>>>
109889>>>        Procedure OnClick
109892>>>            Send Beginning_of_Data to oSourceCode_edt
109893>>>        End_Procedure
109894>>>
109894>>>    End_Object
109895>>>
109895>>>    Object oLatestRun_btn is a cRDCButtonDPI
109897>>>        Set Location to 193 277
109898>>>        Set Label to "View &Bottom"
109899>>>        Set peAnchors to anBottomRight
109900>>>
109900>>>        Procedure OnClick
109903>>>            Send End_of_Data to oSourceCode_edt
109904>>>        End_Procedure
109905>>>
109905>>>    End_Object
109906>>>
109906>>>    // Automatically load data into the grid when activating.
109906>>>    Procedure Activating
109909>>>        Handle ho
109909>>>        Move (oSourceCode_edt(Self)) to ho
109910>>>        Send LoadData    of ho
109911>>>        Send Activate    of ho
109912>>>    End_Procedure
109913>>>
109913>>>    Procedure Page Integer iPageObject
109916>>>        Forward Send Page iPageObject
109918>>>        Set Icon to "ViewSourceCode1.ico"
109919>>>    End_Procedure
109920>>>
109920>>>    // Put a status bar at the bottom of the panel to add a gripper in the lower right corner.
109920>>>    Procedure End_Construct_Object
109923>>>        Integer iStyle iSize iOffset
109923>>>
109923>>>        Forward Send End_Construct_Object
109925>>>
109925>>>        Get Border_Style to iStyle
109926>>>        Move 8 to iOffset
109927>>>        If (iStyle = Border_Thick) Begin
109929>>>            Object oDialogCommandbar is a cCJCommandBarSystem
109931>>>                Object oStatusBar is a cCJStatusBar
109933>>>                    Object oStatusIdle is a cCJStatusBarPane
109935>>>                        Set piId to sbpIDIdlePane
109936>>>                        Set pbStyleStretch to True
109937>>>                    End_Object
109938>>>                End_Object
109939>>>            End_Object
109940>>>
109940>>>            Get Size to iSize
109941>>>            Set Size to (Hi(iSize) + iOffset) (Low(iSize))
109942>>>        End
109942>>>>
109942>>>    End_Procedure
109943>>>
109943>>>    On_Key Key_Alt+Key_T  Send KeyAction of oFirstRun_btn
109944>>>    On_Key Key_Ctrl+Key_T Send KeyAction of oFirstRun_btn
109945>>>    On_Key Key_Alt+Key_B  Send KeyAction of oLatestRun_btn
109946>>>    On_Key Key_Ctrl+Key_B Send KeyAction of oLatestRun_btn
109947>>>    On_Key Key_Alt+Key_C  Send KeyAction of oCancel_Btn
109948>>>End_Object
109949>>>
109949>>>Procedure ActivateSourceCodeDialog String sSourceCode
109952>>>    Handle ho
109952>>>    Boolean bExists
109952>>>
109952>>>    Get vFilePathExists sSourceCode to bExists
109953>>>    If (bExists = False) Begin
109955>>>        Send Info_Box "The file doesn't exist."
109956>>>        Procedure_Return
109957>>>    End
109957>>>>
109957>>>    Move (oSourceCodeDialog_dg(Self)) to ho
109958>>>    Set psSourceCode of ho to sSourceCode
109959>>>    Send Popup of ho
109960>>>End_Procedure
109961>        Use TableDUFCodeGenerator.vw   
Including file: TableDUFCodeGenerator.vw    (C:\Projects\DF20\DbUpdateFramework\AppSrc\TableDUFCodeGenerator.vw)
109961>>>Use Windows.pkg
109961>>>Use DFClient.pkg
109961>>>Use Cursor.pkg
109961>>>Use Batchdd.pkg
109961>>>Use cCJGrid.pkg
109961>>>Use cCJGridColumnRowIndicator.pkg
Including file: cCJGridColumnRowIndicator.pkg    (C:\Program Files\DataFlex 20.1\Pkg\cCJGridColumnRowIndicator.pkg)
109961>>>>>Use cCJGridColumn.pkg
109961>>>>>
109961>>>>>Class cCJGridColumnRowIndicator is a cCJGridColumn
109962>>>>>    
109962>>>>>    Procedure Construct_Object
109964>>>>>        Forward Send Construct_Object
109966>>>>>        
109966>>>>>        Property Integer piImage 0
109967>>>>>        
109967>>>>>        Set psCaption to ""
109968>>>>>        Set piWidth to 20
109969>>>>>        Set pbResizable to False
109970>>>>>        Set pbEditable to False
109971>>>>>        Set pbFocusable to False
109972>>>>>        Set pbAllowDrag to False
109973>>>>>        Set psToolTip to "Row Indicator"
109974>>>>>    End_Procedure
109975>>>>>    
109975>>>>>    Procedure OnCreateColumn
109977>>>>>        Integer iImage
109977>>>>>        Delegate Get AddImage "GridColumnRowIndicator.bmp" 0 to iImage
109979>>>>>        Set piImage to iImage
109980>>>>>    End_Procedure
109981>>>>>    
109981>>>>>    Procedure OnSetDisplayMetrics Handle hoGridItemMetrics Integer iRow String ByRef sValue
109983>>>>>        Integer iImage iFocusedRow
109983>>>>>        Handle hoDataSource
109983>>>>>        
109983>>>>>        Get phoDataSource to hoDataSource
109984>>>>>        Get SelectedRow of hoDataSource to iFocusedRow
109985>>>>>        Move -1 to iImage
109986>>>>>        If (iRow = iFocusedRow) Begin
109988>>>>>            Get piImage to iImage
109989>>>>>            Set ComItemIcon of hoGridItemMetrics to iImage
109990>>>>>        End
109990>>>>>>
109990>>>>>    End_Procedure
109991>>>>>    
109991>>>>>End_Class
109992>>>Use cCJGridColumn.pkg
109992>>>Use dfLine.pkg
109992>>>Use cRDCButton.pkg
109992>>>Use cDbUpdateFunctionLibrary.pkg
109992>>>Use DUFStatusPanel.pkg
109992>>>Use seq_chnl.pkg
109992>>>Use vWin32fh.pkg
109992>>>Use cRDCHeaderGroup.pkg
109992>>>Use cRDCSuggestionIniForm.pkg
109992>>>Use cSQLCheckBox.pkg
109992>>>Use WriteTestProgram.pkg
Including file: WriteTestProgram.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\WriteTestProgram.pkg)
109992>>>>>Use vWin32fh.pkg
109992>>>>>
109992>>>>>Define CS_DUFTestProgram for "DUFInternalUpdateProgram.src"
109992>>>>>
109992>>>>>Function WriteTestProgram String sSourcePackageName String sAppSrcPath Number nSourcePackageVersion Integer iDbVersionTable Integer iDbVersionField Returns Boolean
109995>>>>>    Integer iCh                                                               
109995>>>>>    
109995>>>>>    Get Seq_Open_Output_Channel sSourcePackageName to iCh
109996>>>>>    If (iCh = DF_SEQ_CHANNEL_ERROR) Begin
109998>>>>>        Send Info_Box "No free channel to write output to. Process interrupted" "Error"
109999>>>>>        Function_Return False
110000>>>>>    End  
110000>>>>>>
110000>>>>>    
110000>>>>>    Get vFolderFormat sAppSrcPath to sAppSrcPath
110001>>>>>    
110001>>>>>    Move False to Err
110002>>>>>    Direct_Output channel iCh (sAppSrcPath + CS_DUFTestProgram)
110004>>>>>        Send WriteProgramCode iCh sSourcePackageName nSourcePackageVersion iDbVersionTable iDbVersionField
110005>>>>>    Close_Output channel iCh
110007>>>>>    Send Seq_Release_Channel iCh    
110008>>>>>                                        
110008>>>>>    Function_Return (Err = False)
110009>>>>>End_Function                                   
110010>>>>>
110010>>>>>Procedure WriteProgramCode Integer iCh String sSourcePackageName Number nSourcePackageVersion Integer iDbVersionTable Integer iDbVersionField
110013>>>>>    Writeln channel iCh ("/" + "/ *** DUF Auto-Generated Program - For Internal Usage Only! ***")
110016>>>>>    Writeln channel iCh ("/" + "/ *** Use it to send to a collegue that is working on the same project, ***")
110019>>>>>    Writeln channel iCh ("/" + "/ *** to update his/her database with database changes you have made. ***")
110022>>>>>    Writeln channel iCh (SFormat("#IF (%1@ > 190)",Character(33)))
110025>>>>>    Writeln channel iCh "    CompilerLevelWarning All On"
110028>>>>>    Writeln channel iCh "#ENDIF"
110031>>>>>    Writeln channel iCh "Use cApplication.pkg"
110034>>>>>    Writeln channel iCh "Use cDbUpdateHandler.pkg"
110037>>>>>    Writeln channel iCh 
110039>>>>>    Writeln channel iCh "Object oApplication is a cApplication"
110042>>>>>    Writeln channel iCh "    Set psCompany to 'RDC Tools International'"
110045>>>>>    Writeln channel iCh "    Set psProduct to 'DUF Auto Update Program'"
110048>>>>>    Writeln channel iCh "    Set psProgram to 'Internal use/test of a DUF Update Package'"
110051>>>>>    Writeln channel iCh "    Set psVersion to '19.1'"
110054>>>>>    Writeln channel iCh "End_Object"
110057>>>>>    Writeln channel iCh 
110059>>>>>    Writeln channel iCh 'Get YesNo_Box ("This is a DUF test program written for INTERNAL usage only.\n\nUpdate your DEVELOPMENT DATABASE to version: ' (String(nSourcePackageVersion)) ' now?") to WindowIndex'
110064>>>>>    Writeln channel iCh "If (WindowIndex <> MBR_Yes) Begin"
110067>>>>>    Writeln channel iCh "    Send Exit_Application"
110070>>>>>    Writeln channel iCh "End"
110073>>>>>    Writeln channel iCh 
110075>>>>>    Writeln channel iCh "Object oDbUpdateHandler is a cDbUpdateHandler"
110078>>>>>    Writeln channel iCh "    Set piDbVersionFileNumber  to " iDbVersionTable
110082>>>>>    Writeln channel iCh "    Set piDbVersionFieldNumber to " iDbVersionField
110086>>>>>    Writeln channel iCh "    Set pbAutoCreateDbVersionTable to True"
110089>>>>>    Writeln channel iCh 
110091>>>>>    Writeln channel iCh "    Use " sSourcePackageName
110095>>>>>    Writeln channel iCh 
110097>>>>>    Writeln channel iCh "End_Object"
110100>>>>>    Writeln channel iCh 
110102>>>>>    Writeln channel ich "If (Private.pbDatabaseWasUpdated(ghoDbupdatehandler) = False) Begin"
110105>>>>>    Writeln channel ich "   Send Info_Box 'Nothing to update. (Version number has not changed)'"
110108>>>>>    Writeln channel ich "End"
110111>>>>>    Writeln channel iCh 
110113>>>>>    Writeln channel iCh "Send Exit_Application"
110116>>>>>    Writeln channel iCh ("/" + "/ *** End-Of-Program Code ***")
110119>>>>>
110119>>>>>//    Writeln channel iCh "Object oMainPanel is a BasicPanel"
110119>>>>>//    Writeln channel iCh "    Set Location to 59 173"
110119>>>>>//    Writeln channel iCh "    Set Size to 180 394"
110119>>>>>//    Writeln channel iCh "    Set piMinSize to 180 394"
110119>>>>>//    Writeln channel iCh "    Set Border_Style to Border_Thick"
110119>>>>>//    Writeln channel iCh "    Set Locate_Mode to Center_On_Screen"
110119>>>>>//    Writeln channel iCh "    Set Label to (psProduct(ghoApplication))"
110119>>>>>//    Writeln channel iCh "    Set Maximize_Icon to False"
110119>>>>>//    Writeln channel iCh "    Set peNeighborhood to nhPublic"
110119>>>>>//    Writeln channel iCh "End_Object"
110119>>>>>//    Writeln channel iCh "
110119>>>>>//    Writeln channel iCh "Start_UI oMainPanel
110119>>>>>End_Procedure
110120>>>Use cRDCCommandLinkButton.pkg
Including file: cRDCCommandLinkButton.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cRDCCommandLinkButton.pkg)
110120>>>>>//****************************************************************************
110120>>>>>// $Module type: Package
110120>>>>>// $Module name: cRDCCommandLinkButton.pkg
110120>>>>>//
110120>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
110120>>>>>// Copyright (c) 2018 RDC Tools International
110120>>>>>// E-mail      : support@rdctools.com
110120>>>>>// Web-site    : http://www.rdctools.com
110120>>>>>//
110120>>>>>// Created     : 2018-11-09 @ 17:04 (Military date format - Year-Month-Day)
110120>>>>>//
110120>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
110120>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
110120>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
110120>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
110120>>>>>// in the help folder for more details.
110120>>>>>//
110120>>>>>//****************************************************************************
110120>>>>>Use Windows.pkg
110120>>>>>Use cCommandLinkButton.pkg
110120>>>>>Use Enclient.pkg
110120>>>>>Use errornum.inc
110120>>>>>
110120>>>>>Class cRDCCommandLinkButtonIdleHandler is a cIdleHandler
110121>>>>>    Procedure Construct_Object
110123>>>>>        Forward Send Construct_Object
110125>>>>>
110125>>>>>    End_Procedure
110126>>>>>
110126>>>>>    Procedure OnIdle
110128>>>>>        Delegate Send DoUpdate
110130>>>>>    End_Procedure
110131>>>>>
110131>>>>>End_Class
110132>>>>>
110132>>>>>Class cRDCCommandLinkButton is a cCommandLinkButton
110133>>>>>
110133>>>>>    Procedure Construct_Object
110135>>>>>        Forward Send Construct_Object
110137>>>>>
110137>>>>>        Property Boolean pbAutoEnable True
110138>>>>>
110138>>>>>        Property Boolean pbEnabled True
110139>>>>>
110139>>>>>        Property Handle phoIdleHandler (Create(Self, RefClass(cRDCCommandLinkButtonIdleHandler)))
110140>>>>>
110140>>>>>        Set Border_Style to Border_Normal
110141>>>>>        Set piImageSize to 32
110142>>>>>        Set pbCenterToolTip to True
110143>>>>>
110143>>>>>    End_Procedure
110144>>>>>
110144>>>>>    Procedure End_Construct_Object
110146>>>>>        String sTooltip sStatus_Help
110146>>>>>
110146>>>>>        Forward Send End_Construct_Object
110148>>>>>
110148>>>>>        Get psToolTip   to sTooltip
110149>>>>>        Get Status_Help to sStatus_Help
110150>>>>>        If (sTooltip = "" and sStatus_Help <> "") Begin
110152>>>>>            Set psToolTip to sStatus_Help
110153>>>>>        End
110153>>>>>>
110153>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to (pbAutoEnable(Self))
110154>>>>>    End_Procedure
110155>>>>>
110155>>>>>    Procedure DoUpdate
110157>>>>>        If (pbAutoEnable(Self) = False) Begin
110159>>>>>            Procedure_Return
110160>>>>>        End
110160>>>>>>
110160>>>>>        Set Enabled_State to (IsEnabled(Self))
110161>>>>>    End_Procedure
110162>>>>>
110162>>>>>    Function IsEnabled Returns Boolean
110164>>>>>        Boolean bEnabled
110164>>>>>        Get pbEnabled to bEnabled
110165>>>>>        Function_Return bEnabled
110166>>>>>    End_Function
110167>>>>>
110167>>>>>    // Enable the idle handler timer when the button is activated
110167>>>>>    Procedure Activating
110169>>>>>        Forward Send Activating
110171>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to True
110172>>>>>    End_Procedure
110173>>>>>
110173>>>>>    // Disable the idle handler when the button is deactivated
110173>>>>>    Procedure Deactivating
110175>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to False
110176>>>>>        Forward Send Deactivating
110178>>>>>    End_Procedure
110179>>>>>
110179>>>>>    Procedure Set Color Integer eColor
110181>>>>>        Forward Set Color to clBtnFace
110183>>>>>    End_Procedure
110184>>>>>
110184>>>>>End_Class
110185>>>Use cRDCSlideButton.pkg                                 
Including file: cRDCSlideButton.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cRDCSlideButton.pkg)
110185>>>>>//****************************************************************************
110185>>>>>// $Module type: Package
110185>>>>>// $Module name: cRDCSlideButton.pkg
110185>>>>>//
110185>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
110185>>>>>// Copyright (c) 2018 RDC Tools International
110185>>>>>// E-mail      : support@rdctools.com
110185>>>>>// Web-site    : http://www.rdctools.com
110185>>>>>//
110185>>>>>// Created     : 2018-01-04 @ 16:47 (Military date format - Year-Month-Day)
110185>>>>>//
110185>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
110185>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
110185>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
110185>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
110185>>>>>// in the help folder for more details.
110185>>>>>//
110185>>>>>//****************************************************************************
110185>>>>>Use Windows.pkg
110185>>>>>Use cCommandLinkButton.pkg
110185>>>>>
110185>>>>>
110185>>>>>Enum_List
110185>>>>>    Define RDCSlideButtonSmallImage  for 16
110185>>>>>    Define RDCSlideButtonMediumImage for 24
110185>>>>>End_Enum_List                  
110185>>>>>
110185>>>>>// Used by the "Page" message below to show
110185>>>>>// a rectangle around ComboForm and Checkbox objects.
110185>>>>>
110185>>>>>Class cRDCSlideButtonImage is a cCommandLinkButton
110186>>>>>    Procedure Construct_Object
110188>>>>>        Forward Send Construct_Object
110190>>>>>
110190>>>>>        Property Handle private.phoParent 0
110191>>>>>
110191>>>>>    End_Procedure
110192>>>>>
110192>>>>>    Procedure Mouse_Up Integer iWindowNumber Integer iPosition
110194>>>>>        Forward Send Mouse_Up iWindowNumber iPosition
110196>>>>>        Send OnChange of (private.phoParent(Self))
110197>>>>>        Send Activate of (private.phoParent(Self))
110198>>>>>    End_Procedure
110199>>>>>
110199>>>>>    Procedure End_Construct_Object
110201>>>>>        Forward Send End_Construct_Object
110203>>>>>    End_Procedure
110204>>>>>
110204>>>>>End_Class
110205>>>>>
110205>>>>>Class cRDCSlideTextbox is a CheckBox
110206>>>>>
110206>>>>>    Procedure Construct_Object
110208>>>>>        Forward Send Construct_Object
110210>>>>>
110210>>>>>        Set Auto_Size_State to True
110211>>>>>    End_Procedure
110212>>>>>
110212>>>>>    Procedure End_Construct_Object
110214>>>>>        Forward Send End_Construct_Object
110216>>>>>    End_Procedure
110217>>>>>
110217>>>>>    Procedure OnChange
110219>>>>>        Delegate Send OnChange
110221>>>>>    End_Procedure
110222>>>>>
110222>>>>>    Procedure Page Integer iState
110224>>>>>        Integer iStyle iRet
110224>>>>>        Handle hWnd
110224>>>>>
110224>>>>>        If (iState = 1) Begin
110226>>>>>            Get Form_Style iStyle to iStyle
110227>>>>>            Set Form_Style 0 to (iStyle ior BS_USERBUTTON)
110228>>>>>            Forward Send Page iState
110230>>>>>            Get Window_Handle to hWnd
110231>>>>>            If (hWnd) Begin
110233>>>>>                Move (SendMessage(hWnd, WM_QUERYUISTATE, 0, 0)) to iRet
110234>>>>>                If (iRet iand UISF_HIDEFOCUS) Begin
110236>>>>>                    Move (UIS_CLEAR + (UISF_HIDEFOCUS * 65536)) to iState
110237>>>>>                    Move (SendMessage(hWnd, WM_UPDATEUISTATE, iState, 0)) to iRet
110238>>>>>                End
110238>>>>>>
110238>>>>>            End
110238>>>>>>
110238>>>>>        End
110238>>>>>>
110238>>>>>        Else Begin
110239>>>>>            Forward Send Page iState
110241>>>>>        End
110241>>>>>>
110241>>>>>    End_Procedure
110242>>>>>
110242>>>>>End_Class
110243>>>>>
110243>>>>>// Intermediate class - don't use.
110243>>>>>Class _cRDCSlideButton is a Container3d
110244>>>>>
110244>>>>>    Procedure Construct_Object
110246>>>>>        Forward Send Construct_Object
110248>>>>>
110248>>>>>        Property String private.psLabel
110249>>>>>        Property String private.psToolTip
110250>>>>>        Property String private.Status_Help
110251>>>>>
110251>>>>>        Set Border_Style to Border_None
110252>>>>>    End_Procedure
110253>>>>>
110253>>>>>    Procedure End_Construct_Object
110255>>>>>        Forward Send End_Construct_Object
110257>>>>>
110257>>>>>    End_Procedure
110258>>>>>
110258>>>>>    // We support both the "Set Label" & "Set psLabel" interface.
110258>>>>>    Procedure Set psLabel String sLabel
110260>>>>>        Set private.psLabel to sLabel
110261>>>>>    End_Procedure
110262>>>>>
110262>>>>>    Function psLabel Returns String
110264>>>>>        Function_Return (private.psLabel(Self))
110265>>>>>    End_Function
110266>>>>>
110266>>>>>    Procedure Set Label String sLabel
110268>>>>>        Set psLabel to sLabel
110269>>>>>    End_Procedure
110270>>>>>
110270>>>>>    Function Label Returns String
110272>>>>>        Function_Return (private.psLabel(Self))
110273>>>>>    End_Function
110274>>>>>
110274>>>>>    Procedure Set psToolTip String sToolTip
110276>>>>>        Set private.psToolTip to sToolTip
110277>>>>>    End_Procedure
110278>>>>>
110278>>>>>    Function psToolTip Returns String
110280>>>>>        Function_Return (private.psToolTip(Self))
110281>>>>>    End_Function             
110282>>>>>    
110282>>>>>    Procedure Set Status_Help String sStatusHelp
110284>>>>>        Set private.Status_Help to sStatusHelp
110285>>>>>    End_Procedure
110286>>>>>
110286>>>>>    Function Status_Help Returns String
110288>>>>>        Function_Return (private.Status_Help(Self))
110289>>>>>    End_Function             
110290>>>>>    
110290>>>>>End_Class
110291>>>>>
110291>>>>>Class cRDCSlideButton is a _cRDCSlideButton
110292>>>>>
110292>>>>>    Procedure Construct_Object
110294>>>>>        Forward Send Construct_Object
110296>>>>>
110296>>>>>        Property Handle private.phoButton 0
110297>>>>>        Property String private.psImage    
110298>>>>>        
110298>>>>>        Property Boolean private.Checked_State False
110299>>>>>        Property Boolean private.Auto_Size_State True
110300>>>>>        Property Integer private.piButtonHeight 15
110301>>>>>        Property Integer private.piButtonWidth  14
110302>>>>>        Property Integer private.piButtonLocationOffset -5
110303>>>>>        Property String psToggleOnImage  "ToggleOn.ico"
110304>>>>>        Property String psToggleOffImage "ToggleOff.ico"
110305>>>>>        Property Integer piImageSize RDCSlideButtonMediumImage
110306>>>>>
110306>>>>>        On_Key kSwitch Send Switch_Next_Area
110307>>>>>    End_Procedure
110308>>>>>
110308>>>>>    // We support two syntaxes "Checked_State" and "pbChecked"
110308>>>>>    Procedure Set Checked_State Boolean bState
110310>>>>>        Set private.Checked_State to (not(bState))
110311>>>>>        Send OnChange
110312>>>>>    End_Procedure
110313>>>>>
110313>>>>>    Procedure Set pbChecked Boolean bState
110315>>>>>        Set private.Checked_State to bState
110316>>>>>        Send OnChange
110317>>>>>    End_Procedure
110318>>>>>
110318>>>>>    Function Checked_State Returns Boolean
110320>>>>>        Function_Return (private.Checked_State(Self))
110321>>>>>    End_Function
110322>>>>>
110322>>>>>    Function pbChecked Returns Boolean
110324>>>>>        Function_Return (private.Checked_State(Self))
110325>>>>>    End_Function
110326>>>>>
110326>>>>>    // This adjustment is so that the Studio layout is the same as when the
110326>>>>>    // program has been compiled and run.
110326>>>>>    Procedure Set Location Integer iRowPos Integer iColPos
110328>>>>>        If (iColPos > 4) Begin
110330>>>>>            Move (iColPos -4) to iColPos
110331>>>>>        End
110331>>>>>>
110331>>>>>
110331>>>>>        Forward Set Location to iRowPos iColPos
110333>>>>>    End_Procedure
110334>>>>>
110334>>>>>    // This slight adjustment is needed so the control doesn't
110334>>>>>    // "bump into" an object to the right of it that is located really close.
110334>>>>>//    Procedure Set Size Integer iHeight Integer iWidth
110334>>>>>//        If (iWidth > 5) Begin
110334>>>>>//            Move (iWidth -5) to iWidth
110334>>>>>//        End
110334>>>>>//
110334>>>>>//        Forward Set Size to iHeight iWidth
110334>>>>>//    End_Procedure
110334>>>>>
110334>>>>>    Procedure OnChange
110336>>>>>        Handle hoButton
110336>>>>>        Boolean bChecked
110336>>>>>        String sImage
110336>>>>>
110336>>>>>        Get private.Checked_State to bChecked
110337>>>>>        Set private.Checked_State to (not(bChecked))
110338>>>>>        Get psCurrentImage to sImage
110339>>>>>        Get private.phoButton to hoButton
110340>>>>>        If (hoButton <> 0) Begin
110342>>>>>            Set psImage of hoButton to sImage
110343>>>>>            If (Desktop <> Self) Begin
110345>>>>>                Send OnChangeEvent
110346>>>>>            End
110346>>>>>>
110346>>>>>        End
110346>>>>>>
110346>>>>>    End_Procedure
110347>>>>>
110347>>>>>    Function psCurrentImage Returns String
110349>>>>>        Boolean bChecked
110349>>>>>        String sImage
110349>>>>>
110349>>>>>        Get private.Checked_State to bChecked
110350>>>>>        If (bChecked = True) Begin
110352>>>>>            Get psToggleOnImage to sImage
110353>>>>>        End
110353>>>>>>
110353>>>>>        Else Begin
110354>>>>>            Get psToggleOffImage to sImage
110355>>>>>        End
110355>>>>>>
110355>>>>>        Function_Return sImage
110356>>>>>    End_Function
110357>>>>>
110357>>>>>    Procedure OnClick
110359>>>>>        Send OnChange
110360>>>>>    End_Procedure
110361>>>>>
110361>>>>>    Procedure OnChangeEvent
110363>>>>>    End_Procedure
110364>>>>>
110364>>>>>    Procedure DoToggle
110366>>>>>        Boolean bChecked
110366>>>>>        Get Checked_State to bChecked
110367>>>>>        Set Checked_State to (not(bChecked))
110368>>>>>    End_Procedure
110369>>>>>
110369>>>>>    Procedure End_Construct_Object
110371>>>>>        Integer iSize iLoc iHeight iWidth iOffset iTextOffset iIconIndex iImageSize
110371>>>>>        Handle ho hoParent
110371>>>>>        String sImage sLabel
110371>>>>>
110371>>>>>        Forward Send End_Construct_Object
110373>>>>>        
110373>>>>>        Get piImageSize to iImageSize
110374>>>>>        Case Begin
110374>>>>>            Case (iImageSize = RDCSlideButtonSmallImage)
110376>>>>>                Set private.piButtonHeight         to 14
110377>>>>>                Set private.piButtonWidth          to 14 
110378>>>>>                Set private.piButtonLocationOffset to -5
110379>>>>>                Case Break
110380>>>>>            Case (iImageSize = RDCSlideButtonMediumImage)
110383>>>>>                Set private.piButtonHeight         to 16
110384>>>>>                Set private.piButtonWidth          to 20 
110385>>>>>                Set private.piButtonLocationOffset to -6
110386>>>>>                Case Break
110387>>>>>        Case End               
110387>>>>>
110387>>>>>        Move Self to hoParent
110388>>>>>        Get Label of hoParent to sLabel
110389>>>>>        Get Text_Extent sLabel to iTextOffset
110390>>>>>        Get Size     to iSize
110391>>>>>        Get Location to iLoc
110392>>>>>        Get psCurrentImage to sImage
110393>>>>>        Get private.piButtonHeight to iHeight
110394>>>>>        Get private.piButtonWidth  to iWidth
110395>>>>>        Set Size to (Hi(iSize)) (Low(iSize) + iWidth -7)
110396>>>>>        Get private.piButtonLocationOffset to iOffset
110397>>>>>        Get GetCorrectIconIndex  to iIconIndex
110398>>>>>        Move (iOffset + iIconIndex -1) to iOffset
110399>>>>>
110399>>>>>        Get CreateNamed (RefClass(cRDCSlideButtonImage)) "oRDCSlideButtonImage" to ho
110400>>>>>            Set Size                of ho to iHeight iWidth
110401>>>>>            Set Location            of ho to iOffset 0
110402>>>>>            Set psToolTip           of ho to (private.psToolTip(hoParent))
110403>>>>>            If (private.Status_Help(hoParent) = "") Begin
110405>>>>>                Set Status_Help     of ho to (private.psToolTip(hoParent))
110406>>>>>            End                                                
110406>>>>>>
110406>>>>>            Else Begin
110407>>>>>                Set Status_Help     of ho to (private.Status_Help(hoParent))
110408>>>>>            End
110408>>>>>>
110408>>>>>            Set psImage             of ho to sImage
110409>>>>>            Set pbAutoResizeIcons   of ho to True
110410>>>>>            Set piImageSize         of ho to (piImageSize(Self))
110411>>>>>            Set Focus_Mode          of ho to NonFocusable
110412>>>>>            Set private.phoParent   of ho to hoParent
110413>>>>>        Set private.phoButton to ho
110414>>>>>
110414>>>>>        Get CreateNamed (RefClass(cRDCSlideTextbox)) "cRDCSlideTextbox" to ho
110415>>>>>            Set Size                of ho to (Hi(iSize)) (Low(iSize) + iWidth)
110416>>>>>            Set Location            of ho to 2 iWidth
110417>>>>>            Set Label               of ho to sLabel
110418>>>>>            Set psToolTip           of ho to (private.psToolTip(Parent(ho)))
110419>>>>>            If (private.Status_Help(hoParent) = "") Begin
110421>>>>>                Set Status_Help     of ho to (private.psToolTip(hoParent))
110422>>>>>            End
110422>>>>>>
110422>>>>>            Else Begin
110423>>>>>                Set Status_Help     of ho to (private.Status_Help(hoParent))
110424>>>>>            End
110424>>>>>>
110424>>>>>
110424>>>>>        Get psCurrentImage to sImage
110425>>>>>        Set psImage of ho to sImage
110426>>>>>        Send OnChangeEvent
110427>>>>>    End_Procedure
110428>>>>>
110428>>>>>    // Returns: DPI setting as an integer.
110428>>>>>    //  Normal DPI setting: iDPI=96  is "Normal setting" 100%
110428>>>>>    //                      iDPI=120 is "Medium setting" 125%
110428>>>>>    //                      iDPI= 144 is "Large setting" 150%
110428>>>>>    Function GetCurrentDPI Returns Integer
110430>>>>>        Handle hDC
110430>>>>>        Integer iPixelsX
110430>>>>>        Move (GetDC(0)) to hDC
110431>>>>>        Move (GetDeviceCaps(hDC, LOGPIXELSX)) to iPixelsX
110432>>>>>        Move (ReleaseDC(0, hDC)) to hDC
110433>>>>>        Function_Return iPixelsX
110434>>>>>    End_Function
110435>>>>>
110435>>>>>    Function GetCorrectIconSize Returns Integer
110437>>>>>        Integer iPixelsX iIndex iSize
110437>>>>>        Integer[] iaSizes
110438>>>>>
110438>>>>>        Move 16 to iaSizes[0]
110439>>>>>        Move 24 to iaSizes[1]
110440>>>>>        Move 32 to iaSizes[2]
110441>>>>>        Move 48 to iaSizes[3]
110442>>>>>        Move 64 to iaSizes[4]
110443>>>>>
110443>>>>>        Get piImageSize to iSize  // the "100%" size
110444>>>>>        Move (SearchArray(iSize,iaSizes)) to iIndex
110445>>>>>        Move (0 max iIndex) to iIndex
110446>>>>>        Get GetCurrentDPI to iPixelsX
110447>>>>>        // Use a Case Statement here. Wherever we jump in we will continue onwards, regardless of whether
110447>>>>>        // we match the remaining Case statements or not. So list our Cases in reverse order, meaning we
110447>>>>>        // will increment iIndex as many times as we need here.
110447>>>>>        Case Begin
110447>>>>>            Case (iPixelsX > 144)
110449>>>>>                Increment iIndex
110450>>>>>            Case (iPixelsX = 144)
110453>>>>>                Increment iIndex
110454>>>>>            Case (iPixelsX = 120)
110457>>>>>                Increment iIndex
110458>>>>>        Case End
110458>>>>>        Move (iIndex min 4) to iIndex
110459>>>>>        Function_Return iaSizes[iIndex]
110460>>>>>    End_Function
110461>>>>>
110461>>>>>    Function GetCorrectIconIndex Returns Integer
110463>>>>>        Integer iPixelsX iIndex iSize
110463>>>>>        Integer[] iaSizes
110464>>>>>
110464>>>>>        Move 16 to iaSizes[0]
110465>>>>>        Move 24 to iaSizes[1]
110466>>>>>        Move 32 to iaSizes[2]
110467>>>>>        Move 48 to iaSizes[3]
110468>>>>>        Move 64 to iaSizes[4]
110469>>>>>
110469>>>>>        Get piImageSize to iSize  // the "100%" size
110470>>>>>        Move (SearchArray(iSize,iaSizes)) to iIndex
110471>>>>>        Move (0 max iIndex) to iIndex
110472>>>>>        Get GetCurrentDPI to iPixelsX
110473>>>>>        // Use a Case Statement here. Wherever we jump in we will continue onwards, regardless of whether
110473>>>>>        // we match the remaining Case statements or not. So list our Cases in reverse order, meaning we
110473>>>>>        // will increment iIndex as many times as we need here.
110473>>>>>        Case Begin
110473>>>>>            Case (iPixelsX > 144)
110475>>>>>                Increment iIndex
110476>>>>>            Case (iPixelsX = 144)
110479>>>>>                Increment iIndex
110480>>>>>            Case (iPixelsX = 120)
110483>>>>>                Increment iIndex
110484>>>>>        Case End
110484>>>>>        Move (iIndex min 4) to iIndex
110485>>>>>        Function_Return iIndex
110486>>>>>    End_Function
110487>>>>>
110487>>>>>End_Class
110488>>>Use cRDCCJSelectionGrid.pkg
Including file: cRDCCJSelectionGrid.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cRDCCJSelectionGrid.pkg)
110488>>>>>//****************************************************************************
110488>>>>>// $Module type: Package
110488>>>>>// $Module name: cRDCCJSelectionGrid.pkg
110488>>>>>//
110488>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
110488>>>>>// Copyright (c) 2018 RDC Tools International
110488>>>>>// E-mail      : support@rdctools.com
110488>>>>>// Web-site    : http://www.rdctools.com
110488>>>>>//
110488>>>>>// Created     : 2018-12-17 @ 08:04 (Military date format - Year-Month-Day)
110488>>>>>//
110488>>>>>// Note        : Grid class that uses a checkbox column for selecting items.
110488>>>>>//
110488>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
110488>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
110488>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
110488>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
110488>>>>>// in the help folder for more details.
110488>>>>>//
110488>>>>>//****************************************************************************
110488>>>>>Use cCJGrid.pkg
110488>>>>>Use cCJGridColumn.pkg
110488>>>>>Use cCJGridColumnRowIndicator.pkg
110488>>>>>Use Cursor.pkg
110488>>>>>Use vWin32fh.pkg
110488>>>>>
110488>>>>>Define CS_Settings                for "Settings"
110488>>>>>Define CS_GridRowBackgroundColor  for "GridRowBackgroundColor"
110488>>>>>
110488>>>>>Struct tsSearchResult
110488>>>>>    String sFilename
110488>>>>>    String sAlternateFileName   // 8.3 format
110488>>>>>    DateTime dtCreationDateTime
110488>>>>>    DateTime dtLastAccessDateTime
110488>>>>>    DateTime dtLastWriteDateTime
110488>>>>>    BigInt biFileSize
110488>>>>>    Integer iFileAttributes
110488>>>>>End_Struct
110488>>>>>
110488>>>>>Enum_List
110488>>>>>    Define cx_Select_All
110488>>>>>    Define cx_Select_None
110488>>>>>    Define cx_Select_Invert
110488>>>>>End_Enum_List
110488>>>>>
110488>>>>>// Classes used by the cRDCCJSelectionGrid
110488>>>>>Class cRDCCJToggleSelectMenuItem is a cCJMenuItem
110489>>>>>
110489>>>>>    Procedure Construct_Object
110491>>>>>        Forward Send Construct_Object
110493>>>>>        Set psCaption to "Toggle Current Item"
110494>>>>>        Set psImage to "ToggleOn.ico"
110495>>>>>        Set psShortcut to "Space-Bar"
110496>>>>>    End_Procedure
110497>>>>>
110497>>>>>    Procedure OnExecute Variant vCommandBarControl
110499>>>>>        Forward Send OnExecute vCommandBarControl
110501>>>>>        Send ToggleCurrentItem
110502>>>>>    End_Procedure
110503>>>>>
110503>>>>>End_Class
110504>>>>>
110504>>>>>Class cRDCCJSelectAllMenuItem is a cCJMenuItem
110505>>>>>
110505>>>>>    Procedure Construct_Object
110507>>>>>        Forward Send Construct_Object
110509>>>>>        Set pbControlBeginGroup to True
110510>>>>>        Set psCaption to "Select All"
110511>>>>>        Set psImage to "SelectAll.ico"
110512>>>>>        Set psShortcut to "Ctrl+A"
110513>>>>>    End_Procedure
110514>>>>>
110514>>>>>    Procedure OnExecute Variant vCommandBarControl
110516>>>>>        Forward Send OnExecute vCommandBarControl
110518>>>>>        Set SelectItems to cx_Select_All
110519>>>>>    End_Procedure
110520>>>>>
110520>>>>>End_Class
110521>>>>>
110521>>>>>Class cRDCCJDeSelectAllMenuItem is a cCJMenuItem
110522>>>>>
110522>>>>>    Procedure Construct_Object
110524>>>>>        Forward Send Construct_Object
110526>>>>>        Set psCaption to "Select None"
110527>>>>>        Set psImage to "SelectNone.ico"
110528>>>>>        Set psShortcut to "Ctrl+N"
110529>>>>>    End_Procedure
110530>>>>>
110530>>>>>    Procedure OnExecute Variant vCommandBarControl
110532>>>>>        Forward Send OnExecute vCommandBarControl
110534>>>>>        Set SelectItems to cx_Select_None
110535>>>>>    End_Procedure
110536>>>>>
110536>>>>>End_Class
110537>>>>>
110537>>>>>Class cRDCCJInvertSelectionsMenuItem is a cCJMenuItem
110538>>>>>
110538>>>>>    Procedure Construct_Object
110540>>>>>        Forward Send Construct_Object
110542>>>>>        Set psCaption to "Invert Selection"
110543>>>>>        Set psImage to "SelectInvert.ico"
110544>>>>>        Set psShortcut to "Ctrl+I"
110545>>>>>    End_Procedure
110546>>>>>
110546>>>>>    Procedure OnExecute Variant vCommandBarControl
110548>>>>>        Forward Send OnExecute vCommandBarControl
110550>>>>>        Set SelectItems to cx_Select_Invert
110551>>>>>    End_Procedure
110552>>>>>
110552>>>>>End_Class
110553>>>>>
110553>>>>>Class cRDCCJAddFolderMenuItem is a cCJMenuItem
110554>>>>>
110554>>>>>    Procedure Construct_Object
110556>>>>>        Forward Send Construct_Object
110558>>>>>        Set psCaption to "Add Folder"
110559>>>>>        Set psImage to "AddFolder.ico"
110560>>>>>        Set psShortcut to "Ins"
110561>>>>>    End_Procedure
110562>>>>>
110562>>>>>    Procedure OnExecute Variant vCommandBarControl
110564>>>>>        Forward Send OnExecute vCommandBarControl
110566>>>>>        Send BrowseForFolder
110567>>>>>    End_Procedure
110568>>>>>
110568>>>>>End_Class
110569>>>>>
110569>>>>>Class cRDCCJRemoveItemMenuItem is a cCJMenuItem
110570>>>>>
110570>>>>>    Procedure Construct_Object
110572>>>>>        Forward Send Construct_Object
110574>>>>>        Set psCaption to "Remove From Grid"
110575>>>>>        Set psImage to "ActionDelete.ico"
110576>>>>>        Set psShortcut to "Del"
110577>>>>>    End_Procedure
110578>>>>>
110578>>>>>    Procedure OnExecute Variant vCommandBarControl
110580>>>>>        Forward Send OnExecute vCommandBarControl
110582>>>>>        Send Request_Delete
110583>>>>>    End_Procedure
110584>>>>>
110584>>>>>End_Class
110585>>>>>
110585>>>>>Register_Function pbShowAddFolderMenuItem Returns Boolean
110585>>>>>Register_Function pbShowRemoveFolderMenuItem Returns Boolean
110585>>>>>
110585>>>>>Class cGridContext_mnu is a cCJContextMenu
110586>>>>>    Procedure Construct_Object
110588>>>>>        Handle hoMenuItem
110588>>>>>        Forward Send Construct_Object
110590>>>>>
110590>>>>>        Get Create (RefClass(cRDCCJToggleSelectMenuItem))      to hoMenuItem
110591>>>>>        Get Create (RefClass(cRDCCJSelectAllMenuItem))         to hoMenuItem
110592>>>>>        Get Create (RefClass(cRDCCJDeSelectAllMenuItem))       to hoMenuItem
110593>>>>>        Get Create (RefClass(cRDCCJInvertSelectionsMenuItem))  to hoMenuItem
110594>>>>>        If (pbShowAddFolderMenuItem(Self) = True) Begin
110596>>>>>            Get Create (RefClass(cRDCCJAddFolderMenuItem))  to hoMenuItem
110597>>>>>            Set pbControlBeginGroup of hoMenuItem to True
110598>>>>>        End
110598>>>>>>
110598>>>>>        If (pbShowRemoveFolderMenuItem(Self) = True) Begin
110600>>>>>            Get Create (RefClass(cRDCCJRemoveItemMenuItem))  to hoMenuItem
110601>>>>>            If (pbShowAddFolderMenuItem(Self) = False) Begin
110603>>>>>                Set pbControlBeginGroup of hoMenuItem to True
110604>>>>>            End
110604>>>>>>
110604>>>>>        End
110604>>>>>>
110604>>>>>    End_Procedure
110605>>>>>
110605>>>>>End_Class
110606>>>>>
110606>>>>>Class cRDCCJSelectionGrid is a cCJGrid
110607>>>>>
110607>>>>>    Procedure Construct_Object
110609>>>>>        Forward Send Construct_Object
110611>>>>>
110611>>>>>        // This must be set manually in the grid column object for the 'data' column (or one of them):
110611>>>>>        Property Handle phoData_Col 0
110612>>>>>        Property Handle phoCheckbox_Col 0
110613>>>>>
110613>>>>>        Property Boolean pbShowAddFolderMenuItem False
110614>>>>>        Property Boolean pbShowRemoveFolderMenuItem False
110615>>>>>
110615>>>>>        Set pbRestoreLayout to True
110616>>>>>        Set psLayoutSection to (Name(Self) + "_grid")
110617>>>>>        Set psNoItemsText to "No data found..."
110618>>>>>        Set pbHeaderReorders to True
110619>>>>>        Set pbHeaderPrompts to False
110620>>>>>        Set pbHeaderTogglesDirection to True
110621>>>>>        Set pbSelectionEnable to True
110622>>>>>        Set pbAllowInsertRow to False
110623>>>>>        Set pbAllowAppendRow to False
110624>>>>>        Set pbShowRowFocus to True
110625>>>>>        Set pbShowFooter to True
110626>>>>>        Set pbMultipleSelection to True
110627>>>>>        Set pbHotTracking to True
110628>>>>>        Set pbEditOnClick to True
110629>>>>>        Set piLayoutBuild to 4
110630>>>>>        Set Status_Help to "Select with the spacebar"
110631>>>>>        Set pbUseAlternateRowBackgroundColor to True
110632>>>>>        Set peAnchors to anAll
110633>>>>>        // This makes the ticked checkboxes to appear as bold.
110633>>>>>        Set peVisualTheme to xtpReportThemeVisualStudio2012Light
110634>>>>>
110634>>>>>        On_Key Key_Space      Send ToggleCurrentItem
110635>>>>>        On_Key Key_Delete     Send Request_Delete
110636>>>>>        On_Key Key_Insert     Send BrowseForFolder
110637>>>>>        On_Key Key_Ctrl+Key_A Send SelectAll
110638>>>>>        On_Key Key_Ctrl+Key_N Send SelectNone
110639>>>>>        On_Key Key_Ctrl+Key_I Send SelectInvert
110640>>>>>        On_Key kCancel        Send CancelIfPopupObject
110641>>>>>    End_Procedure
110642>>>>>
110642>>>>>    Procedure CancelIfPopupObject
110644>>>>>        Boolean bIsInPopupObject
110644>>>>>        Delegate Get Popup_State to bIsInPopupObject
110646>>>>>        If (bIsInPopupObject = True) Begin
110648>>>>>            Send Close_Panel
110649>>>>>        End
110649>>>>>>
110649>>>>>    End_Procedure
110650>>>>>
110650>>>>>    Procedure End_Construct_Object
110652>>>>>        String sColor
110652>>>>>        Handle hoContextMenu
110652>>>>>        Forward Send End_Construct_Object
110654>>>>>
110654>>>>>        Object oCheckbox_col is a cCJGridColumn
110656>>>>>            Set phoCheckbox_Col to Self
110657>>>>>            Set piWidth to 60
110658>>>>>            Set pbResizable to False
110659>>>>>            Set psCaption to "Select"
110660>>>>>            Set psToolTip to "Select an item by using the space bar or click with the mouse."
110661>>>>>            Set pbCheckbox to True
110662>>>>>            Set peHeaderAlignment to xtpAlignmentCenter
110663>>>>>            Set peFooterAlignment to xtpAlignmentCenter
110664>>>>>            Set peDataType to Mask_Numeric_Window
110665>>>>>        End_Object
110666>>>>>
110666>>>>>        Get ReadString of ghoApplication CS_Settings CS_GridRowBackgroundColor clGreenGreyLight to sColor
110667>>>>>        If (sColor = "clBlueGreyLight") Begin
110669>>>>>            Move "clGreenGrey" to sColor
110670>>>>>        End
110670>>>>>>
110670>>>>>        Set piSelectedRowBackColor to sColor
110671>>>>>        Set piHighlightBackColor   to sColor
110672>>>>>
110672>>>>>        Get Create (RefClass(cGridContext_mnu)) to hoContextMenu
110673>>>>>        Set phoContextMenu to hoContextMenu
110674>>>>>    End_Procedure   
110675>>>>>    
110675>>>>>    Procedure OnCreateGridControl 
110677>>>>>        Handle hoObject  
110677>>>>>        Integer iToolTipStyle      
110677>>>>>        Boolean bIsBalloonStyleSupported
110677>>>>>        
110677>>>>>        Forward Send OnCreateGridControl
110679>>>>>
110679>>>>>        Get phoToolTipContext to hoObject
110680>>>>>        If (hoObject <> 0) Begin
110682>>>>>            Move xtpToolTipStandard to iToolTipStyle    
110683>>>>>            // Baloon tooltip style requires IE 5.0 or later, so check if installed.
110683>>>>>            // The ComShowTitleAndDescription also requires IE 5.0.
110683>>>>>            Get ComIsBalloonStyleSupported of hoObject to bIsBalloonStyleSupported
110684>>>>>            If (bIsBalloonStyleSupported = True) Begin
110686>>>>>                Send ComShowTitleAndDescription of hoObject True xtpToolTipIconInfo
110687>>>>>            End                                                   
110687>>>>>>
110687>>>>>            Set ComStyle             of hoObject to iToolTipStyle
110688>>>>>            Set ComShowOfficeBorder  of hoObject to True
110689>>>>>            Set ComShowShadow        of hoObject to True
110690>>>>>            // Set the max width for a tooltip. 250 just seems to be a good
110690>>>>>            // compromise. After 250 pixels the text will wrap to the next line automatically.
110690>>>>>            Set ComMaxTipWidth       of hoObject to 250 // In pixels
110691>>>>>        End 
110691>>>>>>
110691>>>>>    End_Procedure
110692>>>>>
110692>>>>>    Procedure AddItem String sDataValue
110694>>>>>        Handle hoDataSource
110694>>>>>        tDataSourceRow[] TheData
110694>>>>>        tDataSourceRow[] TheData
110695>>>>>        tsSearchResult[] asFolderArray
110695>>>>>        tsSearchResult[] asFolderArray
110696>>>>>        Integer iSize iData_Col iCheckbox_Col
110696>>>>>
110696>>>>>        If (not(IsComObjectCreated(Self))) Begin
110698>>>>>            Procedure_Return
110699>>>>>        End
110699>>>>>>
110699>>>>>
110699>>>>>        Get piColumnId of (phoData_Col(Self)) to iData_Col
110700>>>>>        Get piColumnId of (phoCheckbox_Col(Self)) to iCheckbox_Col
110701>>>>>        Get phoDataSource to hoDataSource
110702>>>>>        Get DataSource of hoDataSource to TheData
110703>>>>>        Move (SizeOfArray(TheData)) to iSize
110704>>>>>        Move sDataValue to TheData[iSize].sValue[iData_Col]
110705>>>>>        Move False      to TheData[iSize].sValue[iCheckbox_Col]
110706>>>>>
110706>>>>>        Send ReInitializeData TheData False
110707>>>>>        Send MoveToFirstRow
110708>>>>>    End_Procedure
110709>>>>>
110709>>>>>    Procedure BrowseForFolder
110711>>>>>        String sFolderName
110711>>>>>        Get vSHBrowseForFolder "Select Folder to Add" to sFolderName
110712>>>>>        If (sFolderName <> "") Begin
110714>>>>>            Send AddItem sFolderName
110715>>>>>        End
110715>>>>>>
110715>>>>>    End_Procedure
110716>>>>>
110716>>>>>    // We don't want columns to be editable. But setting
110716>>>>>    // pbEditable = False or pbReadOnly makes it very hard to read,
110716>>>>>    // and makes it impossible to select the checkbox column with the mouse.
110716>>>>>    // So we disable those columns instead.
110716>>>>>    Function CanEditColumn Integer iCol Returns Boolean
110718>>>>>        Handle hoCol
110718>>>>>        Boolean bRetval
110718>>>>>
110718>>>>>        Forward Get CanEditColumn iCol to bRetval
110720>>>>>
110720>>>>>        Get piColumnId of (phoCheckbox_Col(Self)) to hoCol
110721>>>>>        If (iCol <> hoCol) Begin
110723>>>>>            Move False to bRetval
110724>>>>>        End
110724>>>>>>
110724>>>>>        Else Begin
110725>>>>>            Move True to bRetval
110726>>>>>        End
110726>>>>>>
110726>>>>>
110726>>>>>        Function_Return bRetval
110727>>>>>    End_Function
110728>>>>>
110728>>>>>    Procedure Request_Clear_All
110730>>>>>        tDataSourceRow[] EmptyData
110730>>>>>        tDataSourceRow[] EmptyData
110731>>>>>        Handle hoGrid hoDataSource
110731>>>>>
110731>>>>>        Move Self  to hoGrid
110732>>>>>        If (IsComObjectCreated(hoGrid)) Begin
110734>>>>>            Get phoDataSource of hoGrid to hoDataSource
110735>>>>>            Send InitializeData of hoGrid EmptyData
110736>>>>>            Send DoSetCheckboxFooterText
110737>>>>>        End
110737>>>>>>
110737>>>>>    End_Procedure
110738>>>>>
110738>>>>>    // Set checkboxes of the first column as selected.
110738>>>>>    // iState can be one of the following:
110738>>>>>    // cx_Select_All, cx_Select_None or cx_Select_Invert
110738>>>>>    Procedure Set SelectItems Integer iState
110740>>>>>        Integer iCount iSize iCheckbox_Col
110740>>>>>        Boolean bChecked
110740>>>>>        Handle hoDataSource
110740>>>>>        tDataSourceRow[] TheData
110740>>>>>        tDataSourceRow[] TheData
110741>>>>>
110741>>>>>        Get piColumnId of (phoCheckbox_Col(Self)) to iCheckbox_Col
110742>>>>>        Get phoDataSource               to hoDataSource
110743>>>>>        Get DataSource of hoDataSource  to TheData
110744>>>>>        Move (SizeOfArray(TheData))     to iSize
110745>>>>>        Decrement iSize
110746>>>>>        For iCount from 0 to iSize
110752>>>>>>
110752>>>>>            Case Begin
110752>>>>>                Case (iState = cx_Select_All)
110754>>>>>                    Move True to TheData[iCount].sValue[iCheckbox_Col]
110755>>>>>                    Case Break
110756>>>>>                Case (iState = cx_Select_None)
110759>>>>>                    Move False to TheData[iCount].sValue[iCheckbox_Col]
110760>>>>>                    Case Break
110761>>>>>                Case (iState = cx_Select_Invert)
110764>>>>>                    Move TheData[iCount].sValue[iCheckbox_Col] to bChecked
110765>>>>>                    Move (not(bChecked)) to TheData[iCount].sValue[iCheckbox_Col]
110766>>>>>                    Case Break
110767>>>>>            Case End
110767>>>>>        Loop
110768>>>>>>
110768>>>>>
110768>>>>>        Send ReInitializeData TheData False
110769>>>>>        Send DoSetCheckboxFooterText
110770>>>>>    End_Procedure
110771>>>>>
110771>>>>>    // Returns a string array with selected values for the data column (phoData_Col).
110771>>>>>    Function SelectedItems Returns String[]
110773>>>>>        Integer i iItems iSize iCheckbox_Col iData_Col
110773>>>>>        String[] sDataArray
110774>>>>>        Handle hoDataSource
110774>>>>>        tDataSourceRow[] TheData
110774>>>>>        tDataSourceRow[] TheData
110775>>>>>        Boolean bChecked
110775>>>>>
110775>>>>>        Get piColumnId of (phoData_Col(Self)) to iData_Col
110776>>>>>        Get piColumnId of oCheckbox_Col to iCheckbox_Col
110777>>>>>
110777>>>>>        Get phoDataSource to hoDataSource
110778>>>>>        Get DataSource of hoDataSource to TheData
110779>>>>>        Move (SizeOfArray(TheData)) to iItems
110780>>>>>        Decrement iItems
110781>>>>>
110781>>>>>        For i from 0 to iItems
110787>>>>>>
110787>>>>>            Move TheData[i].sValue[iCheckbox_Col] to bChecked
110788>>>>>            If (bChecked = True) Begin
110790>>>>>                Move (SizeOfArray(sDataArray)) to iSize
110791>>>>>                Move TheData[i].sValue[iData_Col] to sDataArray[iSize]
110792>>>>>            End
110792>>>>>>
110792>>>>>        Loop
110793>>>>>>
110793>>>>>
110793>>>>>        Function_Return sDataArray
110794>>>>>    End_Function
110795>>>>>
110795>>>>>    Procedure SelectAll
110797>>>>>        Set SelectItems to cx_Select_All
110798>>>>>    End_Procedure
110799>>>>>
110799>>>>>    Procedure SelectNone
110801>>>>>        Set SelectItems to cx_Select_None
110802>>>>>    End_Procedure
110803>>>>>
110803>>>>>    Procedure SelectInvert
110805>>>>>        Set SelectItems to cx_Select_Invert
110806>>>>>    End_Procedure
110807>>>>>
110807>>>>>    // Returns number of items.
110807>>>>>    Function ItemCount Returns Integer
110809>>>>>        Integer iItems
110809>>>>>        Handle hoDataSource
110809>>>>>        tDataSourceRow[] TheData
110809>>>>>        tDataSourceRow[] TheData
110810>>>>>
110810>>>>>        Get phoDataSource to hoDataSource
110811>>>>>        Get DataSource of hoDataSource to TheData
110812>>>>>        Move (SizeOfArray(TheData)) to iItems
110813>>>>>
110813>>>>>        Function_Return iItems
110814>>>>>    End_Function
110815>>>>>
110815>>>>>    // Returns number of checked items.
110815>>>>>    Function CheckedItems Returns Integer
110817>>>>>        Integer iCount iItems iCheckbox_Col iRetval
110817>>>>>        Handle hoDataSource
110817>>>>>        tDataSourceRow[] TheData
110817>>>>>        tDataSourceRow[] TheData
110818>>>>>        Boolean bChecked
110818>>>>>
110818>>>>>        Get piColumnId of (phoCheckbox_Col(Self)) to iCheckbox_Col
110819>>>>>        Get phoDataSource to hoDataSource
110820>>>>>        Get DataSource of hoDataSource to TheData
110821>>>>>        Move (SizeOfArray(TheData)) to iItems
110822>>>>>        Decrement iItems
110823>>>>>
110823>>>>>        For iCount from 0 to iItems
110829>>>>>>
110829>>>>>            Move TheData[iCount].sValue[iCheckbox_Col] to bChecked
110830>>>>>            If (bChecked = True) Begin
110832>>>>>                Increment iRetval
110833>>>>>            End
110833>>>>>>
110833>>>>>        Loop
110834>>>>>>
110834>>>>>
110834>>>>>        Function_Return iRetval
110835>>>>>    End_Function
110836>>>>>
110836>>>>>    // Toggles the current row on/off (the checkbox)
110836>>>>>    Procedure ToggleCurrentItem
110838>>>>>        Boolean bChecked
110838>>>>>        Integer iCol
110838>>>>>        Handle hoCol
110838>>>>>
110838>>>>>        Get piColumnId of (phoCheckbox_Col(Self)) to iCol
110839>>>>>        Get ColumnObject iCol   to hoCol
110840>>>>>        Get SelectedRowValue    of hoCol to bChecked
110841>>>>>        Send UpdateCurrentValue of hoCol (not(bChecked))
110842>>>>>        Send Request_Save
110843>>>>>        Send DoSetCheckboxFooterText
110844>>>>>    End_Procedure
110845>>>>>
110845>>>>>    Procedure OnComMouseUp Short llButton Short llShift Integer llx Integer lly
110847>>>>>        Forward Send OnComMouseUp llButton llShift llx lly
110849>>>>>        Send Request_Save
110850>>>>>        Send DoSetCheckboxFooterText
110851>>>>>    End_Procedure
110852>>>>>
110852>>>>>    Procedure DoSetCheckboxFooterText
110854>>>>>        Integer iCol iSelected iItems
110854>>>>>        Handle hoCol
110854>>>>>
110854>>>>>        If ((phoData_Col(Self) = 0)) Begin
110856>>>>>            Move 1 to iCol
110857>>>>>        End
110857>>>>>>
110857>>>>>        Else Begin
110858>>>>>            Get piColumnId of (phoData_Col(Self)) to iCol
110859>>>>>        End
110859>>>>>>
110859>>>>>        Get ItemCount to iItems
110860>>>>>        Get ColumnObject iCol to hoCol
110861>>>>>        Get CheckedItems to iSelected
110862>>>>>        Set psFooterText of hoCol  to ("Selected:" * String(iSelected) * "of" * String(iItems))
110863>>>>>    End_Procedure
110864>>>>>
110864>>>>>    // Augment to load data to the grid. Is called automatically
110864>>>>>    // from procedure Activating
110864>>>>>    Procedure LoadData
110866>>>>>    End_Procedure
110867>>>>>
110867>>>>>    // Automatically load data into the grid when activating.
110867>>>>>    Procedure Activating
110869>>>>>        Send Cursor_Wait of Cursor_Control
110870>>>>>        Send LoadData
110871>>>>>        Send Cursor_Ready of Cursor_Control
110872>>>>>    End_Procedure
110873>>>>>
110873>>>>>End_Class
110874>>>Use cRDCForm.pkg
110874>>>
110874>>>Enum_List
110874>>>    Define GenerateOK
110874>>>    Define GenerateUserCancel
110874>>>    Define GenerateError
110874>>>    Define GenerateChannelError
110874>>>    Define GenerateUserInputError
110874>>>    Define GenerateOpenTableError
110874>>>End_Enum_List
110874>>>
110874>>>Struct tGeneratorRow
110874>>>    Handle hTable
110874>>>    String sLogicalName
110874>>>    String sRootName
110874>>>    String sDisplayName
110874>>>    Boolean bIsAlias
110874>>>    Boolean bSelected
110874>>>End_Struct
110874>>>
110874>>>Activate_View Activate_oTableDUFCodeGenerator for oTableDUFCodeGenerator
110884>>>>
110884>>>Object oTableDUFCodeGenerator is a dbView
110886>>>    Set Size to 328 501
110887>>>    Set Label to "Generator"
110888>>>    Set Border_Style to Border_Thick
110889>>>    Set pbAcceptDropFiles to True
110890>>>    Set pbAutoActivate to True
110891>>>
110891>>>    Set phoTableDUFCodeGenerator_vw of ghoApplication to Self
110892>>>
110892>>>    Property String psOrgOpenPath
110894>>>    Property Handle phtable
110896>>>    Property String psTableName
110898>>>    Property Integer piDbVersionFileNumber  -1
110900>>>    Property Integer piDbVersionFieldNumber -1
110902>>>    Property Number pnSourcePackageVersion -1
110904>>>    
110904>>>    // Set psOrgOpenPath at startup
110904>>>    Procedure StartUp
110907>>>        String sOrgOpenPath sDataPath
110907>>>        Get_Attribute DF_OPEN_PATH to sOrgOpenPath
110910>>>        // First remove the current Data folder path
110910>>>        Get PathAtIndex of (phoWorkspace(ghoApplication)) sOrgOpenPath 1 to sDataPath
110911>>>        Move (Replace(sDataPath, sOrgOpenPath, "")) to sOrgOpenPath
110912>>>        If (Left(sOrgOpenPath, 2) = "\;") Begin
110914>>>            Move (Replace("\;", sOrgOpenPath, "")) to sOrgOpenPath
110915>>>        End
110915>>>>
110915>>>        Set psOrgOpenPath to sOrgOpenPath
110916>>>    End_Procedure
110917>>>    Send StartUp
110918>>>
110918>>>    Object oFromFilelist_grp is a cRDCHeaderGroup
110920>>>        Set Size to 50 473
110921>>>        Set Location to 8 15
110922>>>        Set pbAcceptDropFiles to True
110923>>>        Set psImage to "FolderLeft1.ico"
110924>>>        Set Label to "Select FROM Filelist.cfg"
110925>>>        Set psNote to "The development/latest version of the database"   
110926>>>        Set psToolTip to "Select the Filelist.cfg for your development database. This is a suggestion form. So if used before - start typing what you're looking for."
110927>>>
110927>>>        Object oFilelistPath_fm is a cRDCSuggestionIniForm
110929>>>            Set Size to 12 424
110930>>>            Set Location to 29 29
110931>>>            Set Label_Col_Offset to 0
110932>>>            Set Label_Row_Offset to 1
110933>>>            Set Label_Justification_Mode to JMode_Top
110934>>>            Set Prompt_Button_Mode to PB_PromptOn
110935>>>            Set peAnchors to anTopLeftRight
110936>>>            Set psToolTip to "Select the FROM database Filelist.cfg. This should be the development workspace Data folder's Filelist.cfg"
110937>>>            Set Prompt_Object to Self
110938>>>
110938>>>            Procedure Prompt
110941>>>                String sFileName sPath sFileMask sRetval
110941>>>
110941>>>                Get Value to sFileName
110942>>>                Get ParseFolderName sFileName to sPath
110943>>>                Move "Filelist.cfg files (*.cfg)|*.cfg" to sFileMask
110944>>>                Get vSelect_File sFileMask "Please select a Filelist.cfg file" sPath to sRetval
110945>>>                If (sRetval <> "") Begin
110947>>>                    Set Value to sRetval
110948>>>                End
110948>>>>
110948>>>            End_Procedure
110949>>>
110949>>>            Procedure OnChange
110952>>>                String sFileList
110952>>>                Boolean bOK bExists bCfgFile bHasRecords
110952>>>                Handle hTable
110952>>>                Number nVersionNumber
110952>>>
110952>>>                Move 0 to nVersionNumber
110953>>>                Get Value to sFileList
110954>>>                Get vFilePathExists sFileList to bExists
110955>>>                Move (Lowercase(sFileList) contains ".cfg") to bCfgFile
110956>>>                If (bExists = True and bCfgFile) Begin
110958>>>                    // A little trick to show the filelist.cfg in the form before we start filling the grid.
110958>>>                    Send PumpMsgQueue of Desktop
110959>>>                    Get ChangeFilelistPathing of ghoApplication sFileList to bOK
110960>>>
110960>>>                    If (bOK = True) Begin
110962>>>                        Set psFilelistFrom of ghoApplication to sFileList
110963>>>
110963>>>                        // *** LOAD DATA ***
110963>>>                        Send LoadData to oFilelist_grd
110964>>>
110964>>>                        // It just seem logical to activate the grid after populating it.
110964>>>                        // At this point there is little use of still having the oFilelist_fm active.
110964>>>                        Get HasRecords of oFilelist_grd to bHasRecords
110965>>>                        If (bHasRecords = True) Begin
110967>>>                            Send Activate of oFilelist_grd
110968>>>                        End
110968>>>>
110968>>>
110968>>>                        If (bExists = True) Begin
110970>>>                            Get phDbVersion of oFilelist_grd to hTable
110971>>>                            If (hTable <> 0) Begin
110973>>>                                Open hTable
110975>>>                                Get_Field_Value hTable 1   to nVersionNumber 
110978>>>                                // ToDo: How to handle this if not the standard "DbVersion" table is used?
110978>>>                                Set pnSourcePackageVersion to nVersionNumber
110979>>>                                Set piDbVersionFileNumber  to hTable
110980>>>                                Set piDbVersionFieldNumber to 1
110981>>>                                Close hTable
110982>>>                            End
110982>>>>
110982>>>                        End
110982>>>>
110982>>>                        If (nVersionNumber = 0) Begin
110984>>>                            Move 1.0 to nVersionNumber
110985>>>                        End   
110985>>>>
110985>>>                        Else Begin
110986>>>                            Move (nVersionNumber + .1) to nVersionNumber
110987>>>                        End
110987>>>>
110987>>>                        Set Value of oPnVersionNumber_fm to nVersionNumber
110988>>>                    End
110988>>>>
110988>>>                End
110988>>>>
110988>>>            End_Procedure
110989>>>
110989>>>            Function Window_Handle Returns Handle
110992>>>                Integer rVal
110992>>>                Get Window_Handle of (Parent(Self)) to rVal
110993>>>                Function_Return rVal
110994>>>            End_Function
110995>>>
110995>>>            Function Next_Object_Id Boolean bNoDescend Returns Integer
110998>>>                Function_Return (oFilelist_grd(Self))
110999>>>            End_Function
111000>>>
111000>>>            On_Key Key_Ctrl+Key_W Send None
111001>>>            On_Key Key_Ctrl+Key_Q Send None
111002>>>        End_Object
111003>>>
111003>>>    End_Object
111004>>>
111004>>>    Object oSelectTables_grp is a cRDCHeaderGroup
111006>>>        Set Size to 92 473
111007>>>        Set Location to 69 15
111008>>>        Set peAnchors to anAll
111009>>>        Set psImage to "SelectTables1.ico"
111010>>>        Set psLabel to "Select Tables"
111011>>>        Set psNote to "Right click grid for options"  
111012>>>        Set psToolTip to "Select one or more tables to generate 'DUF' database update code for. (Ctrl+A = 'Select All Tables'. Right-click grid for selection options."
111013>>>
111013>>>        Object oFilelist_grd is a cRDCCJSelectionGrid
111015>>>            Set Size to 56 423
111016>>>            Set Location to 27 29
111017>>>            Set piLayoutBuild to 6
111018>>>            Set Status_Help to "Select with the spacebar, or use the selection buttons above the grid"
111019>>>                Set peVisualTheme to xtpReportThemeVisualStudio2012Light
111020>>>
111020>>>            Property Handle phDbVersion
111022>>>            Property Integer piCurrentRow -1
111024>>>
111024>>>            Object oCJGridColumnRowIndicator is a cCJGridColumnRowIndicator
111026>>>                Set piWidth to 26
111027>>>            End_Object
111028>>>                         
111028>>>            Object oFilelistNumber_col is a cCJGridColumn
111030>>>                Set piWidth to 74
111031>>>                Set psCaption to "Filelist No"
111032>>>                Set psToolTip to (psCaption(Self) * "(Read-Only)")
111033>>>                Set peDataType to Mask_Numeric_Window
111034>>>                Set pbEditable to False
111035>>>                Set peTextAlignment to xtpAlignmentCenter
111036>>>            End_Object
111037>>>
111037>>>            Object oLogicalName_col is a cCJGridColumn
111039>>>                Set piWidth to 121
111040>>>                Set psCaption to "Logical Name"
111041>>>                Set psToolTip to (psCaption(Self) * "(Read-Only)")
111042>>>                Set pbEditable to False
111043>>>                Set psFooterText to "No of Tables:"
111044>>>            End_Object
111045>>>
111045>>>            Object oRootName_col is a cCJGridColumn
111047>>>                // NOTE: This must be set at one of the columns!
111047>>>                Set phoData_Col to Self
111048>>>                Set piWidth to 191
111049>>>                Set psCaption to "Table Name (Rootname)"
111050>>>                Set psToolTip to (psCaption(Self) * "(Read-Only)")
111051>>>                Set pbEditable to False
111052>>>                Set psFooterText to "Selected:"
111053>>>            End_Object
111054>>>
111054>>>            Object oDisplayName_col is a cCJGridColumn
111056>>>                Set piWidth to 267
111057>>>                Set psCaption to "Display Name"
111058>>>                Set psToolTip to (psCaption(Self) * "(Read-Only)")
111059>>>                Set pbEditable to False
111060>>>            End_Object
111061>>>
111061>>>            Object oIsAlias_Col is a cCJGridColumn
111063>>>                Set piWidth to 85
111064>>>                Set psCaption to "Is Alias"
111065>>>                Set pbCheckbox to True
111066>>>                Set peHeaderAlignment to xtpAlignmentCenter
111067>>>                Set peFooterAlignment to xtpAlignmentCenter
111068>>>                Set pbVDFEditControl to False
111069>>>                Set psToolTip to "Is table an alias table? (Read-Only)"
111070>>>                Set psFooterText to "Alias:"
111071>>>            End_Object
111072>>>
111072>>>            Procedure LoadData
111075>>>                String sFileList sLogicalName
111075>>>                Handle hoDataSource hTable
111075>>>                tDataSourceRow[] TheData TheDataEmpty
111075>>>                tDataSourceRow[] TheData TheDataEmpty
111077>>>                Integer iRow iTableNo iRoot iLogical iDisplay iIsAlias iChecked iAliasCount iNoOfTables iCount
111077>>>                Boolean bExists bIsAlias bUserCancel
111077>>>
111077>>>                Get Value of oFilelistPath_fm to sFilelist
111078>>>                Get vFilePathExists sFileList to bExists
111079>>>                If (bExists = False) Begin
111081>>>                    Procedure_Return
111082>>>                End
111082>>>>
111082>>>
111082>>>                Send Initialize_StatusPanel of ghoStatusPanel "The Database Update Framework" "Loading Filelist.cfg data" "...and checking for Alias tables"
111083>>>                Send Start_StatusPanel of ghoStatusPanel
111084>>>                Get UtilFilelistNoOfTables of ghoDbUpdateFunctionLibrary to iNoOfTables
111085>>>                Set pbVisible of ghoProgressBar to True
111086>>>                Set pbVisible of ghoProgressBarOverall to False
111087>>>                Set piMaximum of ghoProgressBar to iNoOfTables
111088>>>                Move 0 to iCount
111089>>>                Get phoDataSource to hoDataSource
111090>>>                Get DataSource of hoDataSource to TheData
111091>>>                Move TheDataEmpty to TheData
111092>>>                Get piColumnId of oFilelistNumber_col to iTableNo
111093>>>                Get piColumnId of oRootName_col       to iRoot
111094>>>                Get piColumnid of oLogicalName_col    to iLogical
111095>>>                Get piColumnId of oDisplayName_col    to iDisplay
111096>>>                Get piColumnId of oIsAlias_Col        to iIsAlias
111097>>>                Get piColumnId of oCheckbox_Col       to iChecked
111098>>>
111098>>>                Move 0 to hTable
111099>>>                Move 0 to iRow
111100>>>                Repeat
111100>>>>
111100>>>                    Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
111103>>>                    Set piPosition of ghoProgressBar to iCount
111104>>>
111104>>>                    If (hTable > 0 and hTable <> 50) Begin
111106>>>                        Move hTable                                   to TheData[iRow].sValue[iTableNo]
111107>>>                        Get_Attribute DF_FILE_ROOT_NAME     of hTable to TheData[iRow].sValue[iRoot]
111110>>>                        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
111113>>>                        Move sLogicalName                             to TheData[iRow].sValue[iLogical]
111114>>>                        If (Uppercase(sLogicalName) = "DBVERSION") Begin
111116>>>                            Set phDbVersion to hTable
111117>>>                        End
111117>>>>
111117>>>                        Get_Attribute DF_FILE_DISPLAY_NAME  of hTable to TheData[iRow].sValue[iDisplay]
111120>>>                        Get UtilTableIsAlias of ghoDbUpdateFunctionLibrary hTable to bIsAlias
111121>>>                        Move bIsAlias                                 to TheData[iRow].sValue[iIsAlias]
111122>>>                        If (bIsAlias = True) Begin
111124>>>                            Increment iAliasCount
111125>>>                        End
111125>>>>
111125>>>                        Move False to TheData[iRow].sValue[iChecked]
111126>>>                        Increment iRow
111127>>>                    End
111127>>>>
111127>>>                    Increment iCount
111128>>>                    Get Check_StatusPanel of ghoStatusPanel to bUserCancel
111129>>>                    If (bUserCancel = True) Begin
111131>>>                        Move TheDataEmpty to TheData
111132>>>                        Move 0 to iRow
111133>>>                        Move 0 to iAliasCount
111134>>>                        Move 0 to hTable
111135>>>                    End
111135>>>>
111135>>>                Until (hTable = 0)
111137>>>                                    
111137>>>                Send InitializeData TheData
111138>>>                Set psFooterText of oLogicalName_col to ("No of Tables:" * String(iRow))
111139>>>                Set psFooterText of oIsAlias_Col     to ("Alias:" * String(iAliasCount))
111140>>>                Send Stop_StatusPanel of ghoStatusPanel
111141>>>            End_Procedure
111142>>>
111142>>>            Function SelectedTableNumber Returns Handle
111145>>>                Integer hTable iTableNo iRowNo
111145>>>                Handle hoDataSource
111145>>>                tDataSourceRow[] TheData
111145>>>                tDataSourceRow[] TheData
111146>>>
111146>>>                Get phoDataSource to hoDataSource
111147>>>                Get piColumnId of oFilelistNumber_col to iTableNo
111148>>>                Get DataSource of hoDataSource to TheData
111149>>>                Get SelectedRow of hoDataSource to iRowNo
111150>>>                Move TheData[iRowNo].sValue[iTableNo] to hTable
111151>>>
111151>>>                Function_Return hTable
111152>>>            End_Function
111153>>>
111153>>>            Function GenerateSourceFileName Returns String
111156>>>                String sRetval sPath sFileListName sTableName sVersionNumber
111156>>>                Boolean bExists
111156>>>                Integer iLogical iRowNo iSelected iPos
111156>>>                tDataSourceRow[] TheData
111156>>>                tDataSourceRow[] TheData
111157>>>                Handle hoDataSource
111157>>>                Number nVersionNumber
111157>>>
111157>>>                Get Value of oFilelistPath_fm to sFileListName
111158>>>                Get vFilePathExists sFileListName to bExists
111159>>>                If (bExists = False) Begin
111161>>>                    Function_Return ""
111162>>>                End
111162>>>>
111162>>>
111162>>>                Set_Attribute DF_DECIMAL_SEPARATOR to (Ascii('.'))
111165>>>                Get Value of oPnVersionNumber_fm to sVersionNumber
111166>>>//                Move nVersionNumber to sVersionNumber
111166>>>                Move (Pos(".", sVersionNumber)) to iPos
111167>>>                If (iPos = 0) Begin
111169>>>                    Move (sVersionNumber + String(".0")) to sVersionNumber
111170>>>                End
111170>>>>
111170>>>                Move (Replaces(".", sVersionNumber, "_")) to sVersionNumber
111171>>>                Move (Replaces(",", sVersionNumber, "_")) to sVersionNumber
111172>>>
111172>>>                Get ParseFolderName sFileListName to sPath
111173>>>                Get vParentPath sPath   to sPath
111174>>>                Get vFolderFormat sPath to sPath
111175>>>                Move (sPath + "AppSrc") to sPath
111176>>>                Get vFolderFormat sPath to sPath
111177>>>
111177>>>                Get phoDataSource to hoDataSource
111178>>>                Get piColumnid of oLogicalName_col to iLogical
111179>>>                Get DataSource of hoDataSource to TheData
111180>>>                Get CheckedItems to iSelected
111181>>>                If (iSelected > 1) Begin
111183>>>                    Move "MultipleTables" to sTableName
111184>>>                End
111184>>>>
111184>>>                Else Begin
111185>>>                    If (SizeOfArray(TheData) <> 0) Begin
111187>>>                        Get SelectedRow of hoDataSource to iRowNo
111188>>>                        Move TheData[iRowNo].sValue[iLogical] to sTableName
111189>>>                    End
111189>>>>
111189>>>                End
111189>>>>
111189>>>                Move ("DUF_" + sTableName + String(sVersionNumber) + ".pkg") to sTableName
111190>>>
111190>>>                Move (sPath + sTableName) to sRetval
111191>>>
111191>>>                Function_Return sRetval
111192>>>            End_Function
111193>>>
111193>>>            Function piCheckboxCol Returns Integer
111196>>>                Integer iIndex
111196>>>                Get piColumnId of oCheckbox_Col to iIndex
111197>>>                Function_Return iIndex
111198>>>            End_Function
111199>>>
111199>>>            // Returns a string array with the selected items.
111199>>>            Function SelectedItems Returns tGeneratorRow[]
111202>>>                Integer[] SelRows
111203>>>                Integer i iItems iSize iCheckbox_Col iFilelistNo_Col iLogical_Col iRoot_Col iDisplay_Col iIsAlias_Col
111203>>>                String sFileName
111203>>>                String[] sFilesArray
111204>>>                Handle hoDataSource
111204>>>                tDataSourceRow[] TheData
111204>>>                tDataSourceRow[] TheData
111205>>>                Boolean bChecked bIsAlias
111205>>>                tGeneratorRow[] GeneratorRowArray
111205>>>                tGeneratorRow[] GeneratorRowArray
111206>>>
111206>>>                Get piColumnId of oFilelistNumber_col to iFilelistNo_Col
111207>>>                Get piColumnId of oLogicalName_col    to iLogical_Col
111208>>>                Get piColumnId of oRootName_col       to iRoot_Col
111209>>>                Get piColumnId of oDisplayName_col    to iDisplay_Col
111210>>>                Get piColumnId of oIsAlias_Col        to iIsAlias_Col
111211>>>                Get piColumnId of oCheckbox_Col       to iCheckbox_Col
111212>>>
111212>>>                Get phoDataSource to hoDataSource
111213>>>                Get DataSource of hoDataSource to TheData
111214>>>                Move (SizeOfArray(TheData)) to iItems
111215>>>                Decrement iItems
111216>>>
111216>>>                For i from 0 to iItems
111222>>>>
111222>>>                    Move TheData[i].sValue[iCheckbox_Col] to bChecked
111223>>>                    If (bChecked = True) Begin
111225>>>                        Move (SizeOfArray(GeneratorRowArray)) to iSize
111226>>>                        Move TheData[i].sValue[iFilelistNo_Col] to GeneratorRowArray[iSize].hTable
111227>>>                        Move TheData[i].sValue[iLogical_Col]    to GeneratorRowArray[iSize].sLogicalName
111228>>>                        Move TheData[i].sValue[iRoot_Col]       to GeneratorRowArray[iSize].sRootName
111229>>>                        Move TheData[i].sValue[iDisplay_Col]    to GeneratorRowArray[iSize].sDisplayName
111230>>>                        Move TheData[i].sValue[iIsAlias_Col]    to GeneratorRowArray[iSize].bIsAlias
111231>>>                        Move TheData[i].sValue[iCheckbox_Col]   to GeneratorRowArray[iSize].bSelected
111232>>>                        Move sFileName to sFilesArray[iSize]
111233>>>                    End
111233>>>>
111233>>>                Loop
111234>>>>
111234>>>
111234>>>                Function_Return GeneratorRowArray
111235>>>            End_Function
111236>>>
111236>>>            Procedure Request_Clear
111239>>>                Delegate Send Request_Clear
111241>>>            End_Procedure   
111242>>>            
111242>>>            Function HasRecords Returns Boolean
111245>>>                Handle hoDataSource
111245>>>                tDataSourceRow[] TheData
111245>>>                tDataSourceRow[] TheData
111246>>>                Integer iItems
111246>>>
111246>>>                Get phoDataSource to hoDataSource
111247>>>                Get DataSource of hoDataSource to TheData
111248>>>                Move (SizeOfArray(TheData)) to iItems
111249>>>                Function_Return (iItems <> 0)
111250>>>            End_Function
111251>>>
111251>>>            Procedure Set SelectItems Integer iState
111254>>>                String sSourceFile
111254>>>
111254>>>                Forward Set SelectItems to iState
111256>>>                Get GenerateSourceFileName  to sSourceFile
111257>>>                Set Value of oSourceName_fm to sSourceFile
111258>>>            End_Procedure     
111259>>>            
111259>>>            Procedure ToggleCurrentItem 
111262>>>                String sSourceFile
111262>>>
111262>>>                Forward Send ToggleCurrentItem
111264>>>                Get GenerateSourceFileName  to sSourceFile
111265>>>                Set Value of oSourceName_fm to sSourceFile
111266>>>                
111266>>>            End_Procedure
111267>>>
111267>>>        End_Object
111268>>>
111268>>>        // Needed to not close the view when Esc is hit in the grid.
111268>>>        On_Key kCancel Send None
111269>>>    End_Object
111270>>>
111270>>>    Object oConfigureGeneration_grp is a cRDCHeaderGroup
111272>>>        Set Size to 48 473
111273>>>        Set Location to 172 15
111274>>>        Set peAnchors to anBottomLeftRight
111275>>>        Set psLabel to "Configure Code Generation"
111276>>>        Set psImage to "Settings1.ico"   
111277>>>        Set psToolTip to "Select how code is generated. If you are not sure what the flags does, leave the default settings."
111278>>>        
111278>>>        Object oUseConnectionID_cb is a cSQLCheckBox
111280>>>            Set Size to 9 78
111281>>>            Set Location to 19 30
111282>>>            Set Label to "Use Connection ID"
111283>>>            Set Checked_State to True
111284>>>            Set psToolTip to "If True (the default); uses the Connection ID of the connection string as defined by the SQLConnection.ini setting"
111285>>>        End_Object
111286>>>
111286>>>        Object oANSI_cb is a cSQLCheckBox
111288>>>            Set Size to 9 49
111289>>>            Set Location to 19 136
111290>>>            Set Label to "ANSI/OEM"
111291>>>            Set Checked_State to True  
111292>>>            Set psToolTip to "Set property 'pbToANSI' True/False. DataFlex data is stored in OEM format. Non-DataFlex back ends may expect the data to be stored in ANSI format. When defining the conversion options you can define the table character format to be used in the converted table."
111293>>>        End_Object
111294>>>
111294>>>        Object oCompareIndexAscending_cb is a cSQLCheckBox
111296>>>            Set Size to 9 93
111297>>>            Set Location to 19 200
111298>>>            Set Label to "Change Asc/Descending"
111299>>>            Set Checked_State to False
111300>>>            Set psToolTip to "Set property 'pbCompareIndexAscending' True/False. Check if Index is Ascending/Descending. (In SQL this setting is set for the whole database by selecting a 'Collation', so with SQL checking this per table doesn't make sense)"
111301>>>        End_Object
111302>>>
111302>>>        Object oApiTableUpdateAuto_cb is a cSQLCheckBox
111304>>>            Set Size to 9 137
111305>>>            Set Location to 19 316
111306>>>            Set Label to "Auto Update Table to SQL"
111307>>>            Set Checked_State to True
111308>>>            Set psToolTip to "Set property 'pbApiTableUpdateAuto' True/False. When set to True, 'TO' tables will get converted to the same database format as the 'FROM' tables. So if a 'FROM' table is an SQL table and the 'TO' table is in the embedded format (DataFlex table), it will be converted to SQL."
111309>>>        End_Object
111310>>>
111310>>>        Object oCompareDate_DataTime_cb is a cSQLCheckBox
111312>>>            Set Size to 9 91
111313>>>            Set Location to 32 30
111314>>>            Set Label to "Change Date/DataTime"
111315>>>            Set Checked_State to False
111316>>>            Set psToolTip to "Set property 'pbCompareDate_DateTime' True/False. Check if there are Date/DateTime column differences. Tick the box if the framework should create code to change e.g. a 'To' DateTime column to a Date column if the 'FROM' table column is defined as Date. Be careful as you might loose data!"
111317>>>        End_Object
111318>>>
111318>>>        Object oRecnum_cb is a cSQLCheckBox
111320>>>            Set Size to 9 57
111321>>>            Set Location to 32 136
111322>>>            Set Label to "Use Recnum"
111323>>>            Set Checked_State to True
111324>>>            Set psToolTip to "Set property 'pbRecnum' True/False. If the program that is using the source database uses the recnum programming style, the tables should be converted to recnum tables. If the program uses the RowId programming style, converting to standard tables is recommended."
111325>>>        End_Object
111326>>>
111326>>>        Object oCompareIndexUppercase_cb is a cSQLCheckBox
111328>>>            Set Size to 9 98
111329>>>            Set Location to 32 200
111330>>>            Set Label to "Change Upper/Lowercase"
111331>>>            Set Checked_State to False
111332>>>            Set psToolTip to "Set property 'pbCompareIndexUppercase' True/False. Check if Index is Uppercase/Lowercase. (In SQL this setting is set for the whole database by selecting a 'Collation', so then checking this per table doesn't make sense)"
111333>>>        End_Object
111334>>>
111334>>>        Object oIgnoreFilelistUppercase_cb is a cSQLCheckBox
111336>>>            Set Size to 9 142
111337>>>            Set Location to 32 316
111338>>>            Set Label to "Change Upper/Lowercase Table Names"
111339>>>            Set Checked_State to True
111340>>>            Set psToolTip to "Check Filelist.cfg RootName, LogicalName and DisplayName uppercase/lowercase differences"
111341>>>        End_Object
111342>>>
111342>>>        Procedure ToggleCurrentItem
111345>>>            Boolean bChecked
111345>>>            Handle hObject
111345>>>
111345>>>            Get Focus to hObject
111346>>>            Get Checked_State of hObject to bChecked
111347>>>            Set Checked_State of hObject to (not(bChecked))
111348>>>        End_Procedure
111349>>>
111349>>>    End_Object
111350>>>
111350>>>    Object oGenerateFilename_grp is a cRDCHeaderGroup
111352>>>        Set Size to 39 473
111353>>>        Set Location to 232 15
111354>>>        Set peAnchors to anBottomLeftRight
111355>>>        Set psImage to "ActionSaveCode1.ico"
111356>>>        Set psLabel to "Generated Package File Name"  
111357>>>        Set psToolTip to "A suggestion for the package file to be generated is shown. It can be changed if needed, but you are not encouraged to do so."
111358>>>
111358>>>        Object oPnVersionNumber_fm is a cRDCForm
111360>>>            Set Size to 12 22
111361>>>            Set Location to 17 108
111362>>>            Set Label to "Next pnVersionNumber"
111363>>>            Set psToolTip to "This value is the current DbVersion.DatabaseVersion value, with a value of 0.1 added to it."
111364>>>            Set peAnchors to anBottomLeft
111365>>>            Set Label_Justification_Mode to JMode_Right
111366>>>            Set Label_Col_Offset to 2
111367>>>            Set_Attribute DF_DECIMAL_SEPARATOR to (Ascii('.'))
111370>>>            Set Form_Datatype to 2
111371>>>            Set Value to 1.0
111372>>>
111372>>>            Procedure OnChange
111375>>>                String sSourceFile
111375>>>                Number nVersionNumber 
111375>>>                Integer iDecimalSeparator                     
111375>>>                
111375>>>                Set_Attribute DF_DECIMAL_SEPARATOR to (Ascii('.'))
111378>>>                Get Value to nVersionNumber
111379>>>//                If (nVersionNumber < 1) Begin
111379>>>//                    Move 1 to nVersionNumber   
111379>>>//                    Set Value to nVersionNumber     
111379>>>//                End
111379>>>                Set pnSourcePackageVersion to nVersionNumber
111380>>>                Get GenerateSourceFileName of oFilelist_grd  to sSourceFile
111381>>>                Set Value of oSourceName_fm to sSourceFile
111382>>>            End_Procedure
111383>>>
111383>>>        End_Object
111384>>>
111384>>>        Object oSourceName_fm is a cRDCForm
111386>>>            Set Size to 12 315
111387>>>            Set Location to 17 134
111388>>>            Set peAnchors to anBottomLeftRight
111389>>>            Set Label_Col_Offset to 0
111390>>>            Set Label_Justification_Mode to JMode_Top
111391>>>            Set Label_Row_Offset to 1
111392>>>            Set psToolTip to "The name of the output file to be generated. The suggested name can be changed if needed."
111393>>>        End_Object
111394>>>
111394>>>    End_Object
111395>>>
111395>>>    Object oBusinessProcess is a BusinessProcess
111397>>>        Set Status_Panel_Id to ghoStatusPanel
111398>>>        Set Allow_Cancel_State to True
111399>>>        Set Process_Caption to "The Database Update Framework"
111400>>>        Set Process_Title to "Generating Database Update Code..."
111401>>>        Set Process_Message to "For table:"
111402>>>
111402>>>        Procedure OnProcess
111405>>>            Send StartGenerateCode
111406>>>        End_Procedure
111407>>>
111407>>>        Procedure Ignore_Error Integer iError
111410>>>        End_Procedure
111411>>>        Procedure Trap_Error Integer iError
111414>>>        End_Procedure
111415>>>
111415>>>    End_Object
111416>>>
111416>>>    Object oGenerateCode_btn is a cRDCCommandLinkButton
111418>>>        Set Size to 36 166
111419>>>        Set Location to 281 63
111420>>>        Set Label to "Generate Code!"
111421>>>        Set psNote to "Create DUF update package for the selected tables."
111422>>>        Set psToolTip to "Start generating DUF code for all selected tables."
111423>>>        Set psImage to "SqlScript1.ico"    
111424>>>        Set Default_State to True
111425>>>        Set MultiLineState to True
111426>>>        Set piImageSize to 32 
111427>>>        Set pbAutoEnable to True
111428>>>        Set peAnchors to anBottomRight
111429>>>
111429>>>        Procedure OnClick
111432>>>            Boolean bExists
111432>>>            String sSourceFile sPath
111432>>>            Integer iSelected iRetval
111432>>>
111432>>>            Get Value of oSourceName_fm to sSourceFile
111433>>>            Get vFilePathExists sSourceFile to bExists
111434>>>            If (bExists = True) Begin
111436>>>                Get YesNo_Box ("Oops, the source file" * sSourceFile * "already exists!\n\nDo you want to overwrite it?") to iRetval
111437>>>                If (iRetval <> MBR_Yes) Begin
111439>>>                    Procedure_Return
111440>>>                End
111440>>>>
111440>>>            End                     
111440>>>>
111440>>>            
111440>>>            Get ExtractFilePath sSourceFile to sPath
111441>>>            Get vFilePathExists sPath       to bExists
111442>>>            If (bExists = False) Begin
111444>>>                Send Info_Box "Please check the source file path and try again. It doesn't exist!"
111445>>>                Procedure_Return
111446>>>            End
111446>>>>
111446>>>
111446>>>            Get CheckedItems  of oFilelist_grd to iSelected
111447>>>            If (iSelected = 0) Begin
111449>>>                Send Info_Box "No tables selected. Please adjust and try again."
111450>>>                Procedure_Return
111451>>>            End
111451>>>>
111451>>>
111451>>>            Send DoProcess of oBusinessProcess
111452>>>            Send Restore_DF_OPEN_PATH of ghoApplication
111453>>>        End_Procedure
111454>>>
111454>>>        Function IsEnabled Returns Boolean
111457>>>            Integer iSelected 
111457>>>            Get CheckedItems  of oFilelist_grd to iSelected
111458>>>            Function_Return (iSelected <> 0)
111459>>>        End_Function
111460>>>            
111460>>>    End_Object
111461>>>
111461>>>    Object oGenerateInternalUpdatetProgram_btn is a cRDCCommandLinkButton
111463>>>        Set Size to 36 77
111464>>>        Set Location to 281 239
111465>>>        Set Label to "Local"
111466>>>        Set psNote to "Create local helper program"
111467>>>        Set peAnchors to anBottomRight
111468>>>        Set psToolTip to "Generates a small basic program that Use's the generated package. To be be send to a fellow developer working on the same project, to make his/hers local database identical to the selected 'FROM' database."
111469>>>        Set psImage to "SqlScript1.ico"    
111470>>>        Set piImageSize to 16 // 24
111471>>>        Set pbAutoEnable to True
111472>>>        
111472>>>        Procedure OnClick
111475>>>            Integer iRetval
111475>>>            String sText
111475>>>        
111475>>>            Move "This generates a small basic program that Use's the generated package. To be be send to a fellow developer working on the same project, to make his/hers local database identical to the selected 'FROM' database. Continue?" to sText
111476>>>            Get YesNo_Box sText to iRetval
111477>>>            If (iRetval = MBR_Yes) Begin
111479>>>                Send GenerateInternalUpdateProgram
111480>>>            End
111480>>>>
111480>>>        End_Procedure
111481>>>        
111481>>>        Procedure GenerateInternalUpdateProgram
111484>>>            String sPath sSourcePackageName
111484>>>            Integer iDbVersionFileNumber iDbVersionFieldNumber
111484>>>            Number nSourcePackageVersion
111484>>>            Boolean bOK 
111484>>>            
111484>>>            Get piDbVersionFileNumber   to iDbVersionFileNumber
111485>>>            Get piDbVersionFieldNumber  to iDbVersionFieldNumber
111486>>>            Get pnSourcePackageVersion  to nSourcePackageVersion
111487>>>            
111487>>>            Get Value of oSourceName_fm to sSourcePackageName
111488>>>            Get ParseFolderName sSourcePackageName to sPath
111489>>>            Get ParseFileName sSourcePackageName to sSourcePackageName
111490>>>                        
111490>>>            Get WriteTestProgram sSourcePackageName sPath nSourcePackageVersion iDbVersionFileNumber iDbVersionFieldNumber to bOK
111491>>>            If (bOK = True) Begin
111493>>>                Send Info_Box ("Success! The source program" * CS_DUFTestProgram * "was created in:" * sPath)        
111494>>>            End 
111494>>>>
111494>>>            Else Begin
111495>>>                Send Info_Box "The creation of the source program failed..."
111496>>>            End
111496>>>>
111496>>>        End_Procedure
111497>>>        
111497>>>        Function IsEnabled Returns Boolean
111500>>>            String sPath sSourceName
111500>>>            Boolean bExists
111500>>>            Integer iSelected 
111500>>>
111500>>>            Get CheckedItems of oFilelist_grd to iSelected
111501>>>            Get Value of oSourceName_fm to sSourceName
111502>>>            Get ParseFolderName sSourceName to sPath
111503>>>            Get vFolderExists sPath to bExists
111504>>>            Function_Return (iSelected <> 0 and bExists = True)
111505>>>        End_Function
111506>>>
111506>>>    End_Object
111507>>>
111507>>>    Object oViewSoureCode_btn is a cRDCCommandLinkButton
111509>>>        Set Size to 36 76
111510>>>        Set Location to 281 326
111511>>>        Set Label to "View"
111512>>>        Set psNote to "View source code"
111513>>>        Set peAnchors to anBottomRight
111514>>>        Set psToolTip to "Open the source file in the editor"
111515>>>        Set MultiLineState to True
111516>>>        Set psImage to "ViewSourceCode1.ico" 
111517>>>        Set piImageSize to 16 
111518>>>        Set pbAutoEnable to True
111519>>>
111519>>>        Procedure OnClick
111522>>>            String sSourceName
111522>>>            
111522>>>            Get Value of oSourceName_fm to sSourceName
111523>>>            Send ActivateSourceCodeDialog sSourceName
111524>>>        End_Procedure
111525>>>
111525>>>        Function IsEnabled Returns Boolean
111528>>>            String sSourceName
111528>>>            Boolean bExists
111528>>>
111528>>>            Get Value of oSourceName_fm to sSourceName
111529>>>            Get vFilePathExists sSourceName to bExists
111530>>>            Function_Return (bExists = True)
111531>>>        End_Function
111532>>>
111532>>>    End_Object
111533>>>
111533>>>    Object oOpenAppSrcFolder_btn is a cRDCCommandLinkButton
111535>>>        Set Size to 36 76
111536>>>        Set Location to 281 413
111537>>>        Set Label to "F&older"
111538>>>        Set psNote to "Open containing folder"
111539>>>        Set peAnchors to anBottomRight
111540>>>        Set psToolTip to "Open the source location in Windows Explorer"
111541>>>        Set MultiLineState to True
111542>>>        Set psImage to "ActionOpenFolder1.ico" 
111543>>>        Set piImageSize to 16 // 24
111544>>>        Set pbAutoEnable to True
111545>>>
111545>>>        Procedure OnClick
111548>>>            String sPath sSourceName sFile  
111548>>>            Boolean bExists
111548>>>            
111548>>>            Get Value of oSourceName_fm to sSourceName
111549>>>            Get vFilePathExists sSourceName to bExists
111550>>>            Get ParseFolderName sSourceName to sPath
111551>>>            Get ParseFileName sSourceName to sFile
111552>>>            // We want to have that file to be selected in Windows Explorer when it opens
111552>>>            If (bExists = True) Begin
111554>>>                Move ("/select, " + '"' + sSourceName + '"') to sSourceName
111555>>>            End
111555>>>>
111555>>>            Runprogram Shell Background "Explorer.exe" sSourceName
111556>>>        End_Procedure
111557>>>
111557>>>        Function IsEnabled Returns Boolean
111560>>>            String sPath sSourceName
111560>>>            Boolean bExists
111560>>>
111560>>>            Get Value of oSourceName_fm to sSourceName
111561>>>            Get ParseFolderName sSourceName to sPath
111562>>>            Get vFolderExists sPath to bExists
111563>>>            Function_Return (bExists = True)
111564>>>        End_Function
111565>>>
111565>>>    End_Object
111566>>>
111566>>>    Procedure StartGenerateCode
111569>>>        String sSourceFile
111569>>>        Boolean bUseConnectionID bANSI bRecnum bCompareIndexUppercase bCompareIndexAscending
111569>>>        Handle hTable
111569>>>        Integer iErrors
111569>>>        Number nVersionNumber
111569>>>        tGeneratorRow[] TheData
111569>>>        tGeneratorRow[] TheData
111570>>>        tAPITableBooleans CompareTableBooleans
111570>>>        tAPITableBooleans CompareTableBooleans
111570>>>
111570>>>        Set_Attribute DF_DECIMAL_SEPARATOR to (Ascii('.'))
111573>>>        Get Value of oSourceName_fm                      to sSourceFile
111574>>>        Get Checked_State of oUseConnectionID_cb         to bUseConnectionID
111575>>>        Get Checked_State of oANSI_cb                    to bANSI
111576>>>        Get Checked_State of oRecnum_cb                  to bRecnum
111577>>>        Get Checked_State of oApiTableUpdateAuto_cb      to CompareTableBooleans.bApiTableUpdateAuto
111578>>>        Get Checked_State of oCompareDate_DataTime_cb    to CompareTableBooleans.bCompareDate_DateTime
111579>>>        Get Checked_State of oCompareIndexAscending_cb   to CompareTableBooleans.bCompareIndexAscending
111580>>>        Get Checked_State of oCompareIndexUppercase_cb   to CompareTableBooleans.bCompareIndexUppercase
111581>>>        Get Checked_State of oIgnoreFilelistUppercase_cb to CompareTableBooleans.bCompareFilelistUppercase
111582>>>
111582>>>        Get SelectedItems of oFilelist_grd to TheData
111583>>>        Get pnSourcePackageVersion to nVersionNumber
111584>>>        Get GenerateDUFSourceCode sSourceFile TheData nVersionNumber bUseConnectionID bANSI bRecnum CompareTableBooleans to iErrors
111585>>>
111585>>>        If (iErrors = GenerateChannelError) Begin
111587>>>            Send Info_Box "Sorry, couldn't retrieve a free channel number. Process halted."
111588>>>        End
111588>>>>
111588>>>        If (iErrors = GenerateUserInputError) Begin
111590>>>            Send Info_Box "Table number and pnVersionNumber both needs to be > 0. Please adjust and try again."
111591>>>        End
111591>>>>
111591>>>
111591>>>        Send Stop_StatusPanel of ghoStatusPanel
111592>>>        If (iErrors = GenerateOK) Begin
111594>>>            Send Info_Box "Ready!"
111595>>>        End
111595>>>>
111595>>>        If (iErrors = GenerateError) Begin
111597>>>            Send Info_Box ("Ready! But the code contains ERRORS because there were fields with length = 0! Search the generated code for the word 'ERROR!' to see those fields.")
111598>>>        End
111598>>>>
111598>>>        If (iErrors = GenerateOpenTableError) Begin
111600>>>            Send Info_Box ("Sorry, couldn't open the table! (Table No:" * String(phTable(Self)) * String(psFileName(Self)) + ") Process halted.")
111601>>>        End
111601>>>>
111601>>>        If (iErrors = GenerateUserCancel) Begin
111603>>>            Send Info_Box "Process cancelled by user."
111604>>>        End
111604>>>>
111604>>>    End_Procedure
111605>>>
111605>>>    Function GenerateDUFSourceCode String sSourceFile tGeneratorRow[] TheData Number nVersionNumber Boolean bUseConnectionID Boolean bANSI Boolean bRecnum tAPITableBooleans CompareTableBooleans Returns Integer
111608>>>        Boolean bApiTableUpdateAuto bCompare_DateTime bCompareIndexAscending bCompareIndexUppercase bCompareFilelistUppercase
111608>>>        Integer iCh iColumn iLength iPrecision iOptions iCount iSize iTable iTables
111608>>>        Integer iIndex iIndexes iSegment iNumSegments iType iErrors iStatus
111608>>>        Boolean bOpened bOK bDawSqlDriver bIsAlias bSqlDriver bSkipTable
111608>>>        String sRootName sLogicalName sDisplayName sTableName sFieldName sDataType sDriverID
111608>>>        Handle hTable
111608>>>        tAPITableNameInfo  APITableNameInfo
111608>>>        tAPITableNameInfo  APITableNameInfo
111608>>>        tAPIColumn[]   APIColumns
111608>>>        tAPIColumn[]   APIColumns
111609>>>        tAPIRelation[] APIRelations
111609>>>        tAPIRelation[] APIRelations
111610>>>        tAPIIndex[]    APIIndexes
111610>>>        tAPIIndex[]    APIIndexes
111611>>>        DateTime dtCreationTime
111611>>>
111611>>>        Move (CurrentDateTime()) to dtCreationTime
111612>>>        Move 0 to iErrors
111613>>>        Move (SizeOfArray(TheData)) to iTables
111614>>>        Decrement iTables
111615>>>        Move 0 to iTable
111616>>>        Move TheData[iTable].hTable to hTable
111617>>>
111617>>>        Get Seq_Open_Output_Channel sSourceFile to iCh
111618>>>        If (iCh = DF_SEQ_CHANNEL_ERROR) Begin
111620>>>            Function_Return GenerateChannelError
111621>>>        End
111621>>>>
111621>>>
111621>>>        If (hTable < 1 or nVersionNumber <= 0) Begin
111623>>>            Function_Return GenerateUserInputError
111624>>>        End
111624>>>>
111624>>>
111624>>>        Send Initialize_StatusPanel of ghoStatusPanel "The Database Update Framework" "Generating Update Code" ""
111625>>>        Send Start_StatusPanel of ghoStatusPanel
111626>>>        Set pbVisible of ghoProgressBar to True
111627>>>        Set pbVisible of ghoProgressBarOverall to True
111628>>>        Set piMaximum of ghoProgressBarOverall to iTables
111629>>>        
111629>>>        Move CompareTableBooleans.bApiTableUpdateAuto       to bApiTableUpdateAuto
111630>>>        Move CompareTableBooleans.bCompareDate_DateTime     to bCompare_DateTime
111631>>>        Move CompareTableBooleans.bCompareFilelistUppercase to bCompareFilelistUppercase
111632>>>        Move CompareTableBooleans.bCompareIndexAscending    to bCompareIndexAscending
111633>>>        Move CompareTableBooleans.bCompareIndexUppercase    to bCompareIndexUppercase
111634>>>
111634>>>        Get UtilTableOpen of ghoDbUpdateFunctionLibrary hTable "" DF_SHARE to bOpened
111635>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
111638>>>        If (bOpened = False) Begin
111640>>>            Send Seq_Close_Channel iCh
111641>>>            Set phTable to hTable
111642>>>            Set psFileName to TheData[iTable].sLogicalName
111643>>>            Function_Return GenerateOpenTableError
111644>>>        End
111644>>>>
111644>>>
111644>>>        Writeln channel iCh "/" "/ " CS_DatabaseUpdateFramework
111649>>>        Writeln channel iCh ("/" + "/ Created by: 'DUF Update Code Generator'. Created:" * String(dtCreationTime))
111652>>>        Writeln channel iCh ("Use cDbUpdateVersion.pkg")
111655>>>        Writeln channel iCh
111657>>>        Writeln channel iCh ("Object oDbUpdateVersion" + String(nVersionNumber) * "is a cDbUpdateVersion")
111660>>>        Writeln channel iCh ("    Set pnVersionNumber to" * String(nVersionNumber))
111663>>>        Writeln channel iCh ("    Procedure OnUpdate")
111666>>>        Writeln channel iCh ("        Boolean bOK")
111669>>>        Writeln channel iCh ("        tAPITableNameInfo APITableNameInfo")
111672>>>        Writeln channel iCh ("        tAPIColumn[]   APIColumns APIColumnEmpty")
111675>>>        Writeln channel iCh ("        tAPIIndex[]    APIIndexes APIIndexEmpty")
111678>>>        Writeln channel iCh ("        tAPIRelation[] APIRelations APIRelationEmpty")
111681>>>        Writeln channel iCh ("        Integer iCount iSegment")
111684>>>        Writeln channel iCh ("        Handle hTable")
111687>>>        Writeln channel iCh
111689>>>        Writeln channel iCh ("        Set pbUseConnectionID       to" * If(bUseConnectionID, "True", "False"))
111692>>>        Writeln channel iCh ("        Set pbToAnsi                to" * If(bANSI, "True", "False"))
111695>>>        Writeln channel iCh ("        Set pbRecnum                to" * If(bRecnum, "True", "False"))
111698>>>        Writeln channel iCh ("        Set pbApiTableUpdateAuto    to" * If(bApiTableUpdateAuto, "True", "False"))
111701>>>        Writeln channel iCh ("        Set pbCompareDate_DateTime  to" * If(bCompare_DateTime, "True", "False"))
111704>>>        Writeln channel iCh ("        Set pbCompareIndexAscending to" * If(bCompareIndexAscending, "True", "False"))
111707>>>        Writeln channel iCh ("        Set pbCompareIndexUppercase to" * If(bCompareIndexUppercase, "True", "False"))
111710>>>        Writeln channel iCh
111712>>>        Writeln channel iCh ("        Set Allow_Cancel_State of ghoStatusPanel  to False")
111715>>>        Writeln channel iCh ("        Set pbVisible    of ghoProgressBarOverall to True")
111718>>>        Writeln channel iCh ("        Set piPosition   of ghoProgressBarOverall to 0")
111721>>>        Writeln channel iCh ("        Set piMaximum    of ghoProgressBarOverall to" * String(iTables))
111724>>>        Writeln channel iCh ("        Set piAdvanceBy  of ghoProgressBarOverall to 1")
111727>>>        Writeln channel iCh ("        Send DoAdvance   of ghoProgressBarOverall")   
111730>>>        Writeln channel iCh ("        Move 0 to iCount")
111733>>>        Writeln channel iCh
111735>>>
111735>>>        // Create Definitions:
111735>>>        Move 0 to iTable
111736>>>        For iTable from 0 to iTables
111742>>>>
111742>>>            Set piPosition of ghoProgressBarOverall to iTable
111743>>>            Move TheData[iTable].hTable to hTable
111744>>>            Get UtilTableOpen of ghoDbUpdateFunctionLibrary hTable "" DF_SHARE to bOpened
111745>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpened
111748>>>            If (bOpened = False) Begin
111750>>>                Send Seq_Close_Channel iCh
111751>>>                Set phTable to hTable
111752>>>                Set psTableName to TheData[iTable].sLogicalName
111753>>>                Function_Return GenerateOpenTableError
111754>>>            End
111754>>>>
111754>>>            
111754>>>            Move (Uppercase(TheData[iTable].sLogicalName) = "DBVERSION") to bSkipTable
111755>>>
111755>>>            If (bSkipTable = False) Begin
111757>>>                Move TheData[iTable].sLogicalName to APITableNameInfo.sLogicalName
111758>>>                Set Action_Text of ghoStatusPanel to ("Number:" * String(APITableNameInfo.iTableNumber) * String(sLogicalName))
111759>>>
111759>>>                Move hTable                       to APITableNameInfo.iTableNumber
111760>>>                Move TheData[iTable].sRootName    to sRootName
111761>>>                Get _TableNameOnly of ghoDbUpdateFunctionLibrary sRootName to sTableName
111762>>>                Move sRootName                    to APITableNameInfo.sRootName
111763>>>
111763>>>                Move TheData[iTable].sDisplayName to APITableNameInfo.sDisplayName
111764>>>                Move TheData[iTable].bIsAlias     to bIsAlias
111765>>>                Move bIsAlias                     to APITableNameInfo.bIsAlias
111766>>>                Get UtilTableIsSQL of ghoDbUpdateFunctionLibrary hTable to APITableNameInfo.bIsSQL
111767>>>
111767>>>                // Get the Driver ID
111767>>>                Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
111770>>>                Get IsDAWSQLDriver of ghoDbUpdateFunctionLibrary sDriverID to bDawSqlDriver
111771>>>                Get IsSQLDriver    of ghoDbUpdateFunctionLibrary sDriverID to bSqlDriver
111772>>>
111772>>>                If (bIsAlias = False) Begin
111774>>>                    Set Action_Text of ghoStatusPanel to ("Number:" * String(APITableNameInfo.iTableNumber) * String(APITableNameInfo.sLogicalName))
111775>>>                    Get UtilColumnsStructFill of ghoDbUpdateFunctionLibrary hTable to APIColumns
111776>>>                    If (APIColumns[0].bError = True) Begin
111778>>>                        Function_Return GenerateError
111779>>>                    End
111779>>>>
111779>>>                    If (APIColumns[0].bCancel = True) Begin
111781>>>                        Function_Return GenerateUserCancel
111782>>>                    End
111782>>>>
111782>>>                    Move (SizeOfArray(APIColumns)) to iSize
111783>>>                    Decrement iSize
111784>>>                    If (iSize >= 0) Begin
111786>>>                        Writeln channel iCh ("        // Logical Table Name:" * '"' + APITableNameInfo.sLogicalName + '"' * "Filelist.cfg Number:" * String(APITableNameInfo.iTableNumber))
111789>>>                        Writeln channel iCh ("        Move" * String(APITableNameInfo.iTableNumber)                    * "to APITableNameInfo.iTableNumber")
111792>>>                        Writeln channel iCh ("        Move" * '"' + String(APITableNameInfo.sRootName)    + '"'        * "to APITableNameInfo.sRootName")
111795>>>                        Writeln channel iCh ("        Move" * '"' + String(APITableNameInfo.sLogicalName) + '"'        * "to APITableNameInfo.sLogicalName")
111798>>>                        Writeln channel iCh ("        Move" * '"' + String(APITableNameInfo.sDisplayName) + '"'        * "to APITableNameInfo.sDisplayName")
111801>>>                        Writeln channel iCh ("        Move" * '"' + String(sDriverID)                     + '"'        * "to APITableNameInfo.sDriverID")
111804>>>                        Writeln channel iCh ("        Move" * String(If(APITableNameInfo.bIsAlias,      "True", "False")) * "to APITableNameInfo.bIsAlias")
111807>>>                        Writeln channel iCh ("        Move" * String(If(APITableNameInfo.bIsSQL,        "True", "False")) * "to APITableNameInfo.bIsSQL")
111810>>>                        Writeln channel iCh ("        Move" * String(If(APITableNameInfo.bIsSystemFile, "True", "False")) * "to APITableNameInfo.bIsSystemFile")
111813>>>                        Writeln channel iCh
111815>>>                        Writeln channel iCh ("        // Table:" * '"' + APITableNameInfo.sLogicalName + '"' * "Column: 1")
111818>>>                    End
111818>>>>
111818>>>
111818>>>                    For iCount from 0 to iSize
111824>>>>
111824>>>                        Writeln channel iCh ("        Move" *       String(APIColumns[iCount].iFieldNumber)       * "to APIColumns[iCount].iFieldNumber")
111827>>>                        Writeln channel iCh ("        Move" * '"' + String(APIColumns[iCount].sFieldName)   + '"' * "to APIColumns[iCount].sFieldName")
111830>>>                        Writeln channel iCh ("        Move" *       String(APIColumns[iCount].iType)              * "to APIColumns[iCount].iType")
111833>>>                        Writeln channel iCh ("        Move" * String(If(APIColumns[iCount].bIsSQLType, "True", "False")) * "to APIColumns[iCount].bIsSQLType")
111836>>>                        Writeln channel iCh ("        Move" * String(If(APIColumns[iCount].bAllowNULL, "True", "False")) * "to APIColumns[iCount].bAllowNULL")
111839>>>                        Writeln channel iCh ("        Move" * '"' + String(APIColumns[iCount].sDefaultValue) + '"'       * "to APIColumns[iCount].sDefaultValue")
111842>>>                        If (APIColumns[iCount].iFieldNumber = 0 and APIColumns[iCount].iLength = 0) Begin
111844>>>                            Writeln channel iCh ("        ERROR! This field has a length = 0! It must be corrected before running this code")
111847>>>                            Increment iErrors
111848>>>                        End
111848>>>>
111848>>>                        Move APIColumns[iCount].sType to sDataType
111849>>>                        If (Lowercase(sDataType) contains "identity") Begin
111851>>>                            Move (Replace("identity",sDataType, "")) to sDataType
111852>>>                            Move (Trim(sDataType)) to sDataType
111853>>>                        End
111853>>>>
111853>>>                        Writeln channel iCh ("        Move" * '"' + sDataType                               + '"' * "to APIColumns[iCount].sType")
111856>>>                        Writeln channel iCh ("        Move" *       String(APIColumns[iCount].iLength)            * "to APIColumns[iCount].iLength")
111859>>>                        Writeln channel iCh ("        Move" *       String(APIColumns[iCount].iPrecision)         * "to APIColumns[iCount].iPrecision")
111862>>>                        Writeln channel iCh ("        Move" *       String(APIColumns[iCount].iOptions)           * "to APIColumns[iCount].iOptions")
111865>>>
111865>>>                        If (iCount < iSize) Begin
111867>>>                            Writeln channel iCh ("        Increment iCount")
111870>>>                            Writeln channel iCh
111872>>>                            Writeln channel iCh ("        // Table:" * '"' + APITableNameInfo.sLogicalName + '"' * "Column:" * String(iCount + 2))
111875>>>                        End
111875>>>>
111875>>>                    Loop
111876>>>>
111876>>>
111876>>>                    // Create Index Definitions:
111876>>>                    Get UtilIndexesStructFill of ghoDbUpdateFunctionLibrary hTable to APIIndexes
111877>>>                    If (APIIndexes[0].bError = True) Begin
111879>>>                        Function_Return GenerateError
111880>>>                    End
111880>>>>
111880>>>                    If (APIIndexes[0].bCancel = True) Begin
111882>>>                        Function_Return GenerateUserCancel
111883>>>                    End
111883>>>>
111883>>>                    Move (SizeOfArray(APIIndexes)) to iIndexes
111884>>>                    Decrement iIndexes
111885>>>                    If (iIndexes >= 0) Begin
111887>>>                        Writeln channel iCh
111889>>>                        Writeln channel iCh ("        // Table:" * '"' + APITableNameInfo.sLogicalName + '"' * "Index: 1")
111892>>>                        Writeln channel iCh ("        Move 0 to iCount")
111895>>>                        Writeln channel iCh ("        Move 0 to iSegment")
111898>>>                    End
111898>>>>
111898>>>                    For iIndex from 0 to iIndexes
111904>>>>
111904>>>                        Writeln channel     iCh ("        Move" *       String(APIIndexes[iIndex].iIndexNumber)        * "to APIIndexes[iCount].iIndexNumber")
111907>>>                        Writeln channel     iCh ("        Move" *       String(APIIndexes[iIndex].iPrimaryIndex)       * "to APIIndexes[iCount].iPrimaryIndex")
111910>>>                        Writeln channel     iCh ("        Move" *       String(APIIndexes[iIndex].iSQLIndexType)       * "to APIIndexes[iCount].iSQLIndexType")
111913>>>                        Writeln channel     iCh ("        Move" *       If((APIIndexes[iIndex].bIsSQLClustered),  "True", "False") * "to APIIndexes[iCount].bIsSQLClustered")
111916>>>                        Writeln channel     iCh ("        Move" *       If((APIIndexes[iIndex].bIsSQLPrimaryKey), "True", "False") * "to APIIndexes[iCount].bIsSQLPrimaryKey")
111919>>>                        If (APIIndexes[iIndex].sSQLIndexName <> "") Begin
111921>>>                            Writeln channel iCh ("        Move" * '"' + String(APIIndexes[iIndex].sSQLIndexName) + '"' * "to APIIndexes[iCount].sSQLIndexName")
111924>>>                        End
111924>>>>
111924>>>
111924>>>                        Move (SizeOfArray(APIIndexes[iIndex].IndexSegmentArray)) to iNumSegments
111925>>>                        Decrement iNumSegments
111926>>>                        For iSegment from 0 to iNumSegments
111932>>>>
111932>>>                            Writeln channel iCh ("        Move" *       String(APIIndexes[iIndex].IndexSegmentArray[iSegment].iFieldNumber)              * "to APIIndexes[iCount].IndexSegmentArray[iSegment].iFieldNumber")
111935>>>                            Writeln channel iCh ("        Move" * '"' + String(APIIndexes[iIndex].IndexSegmentArray[iSegment].sFieldName)          + '"' * "to APIIndexes[iCount].IndexSegmentArray[iSegment].sFieldName")
111938>>>                            Writeln channel iCh ("        Move" *       If((APIIndexes[iIndex].IndexSegmentArray[iSegment].bUppercase), "True", "False") * "to APIIndexes[iCount].IndexSegmentArray[iSegment].bUppercase")
111941>>>                            Writeln channel iCh ("        Move" *       If((APIIndexes[iIndex].IndexSegmentArray[iSegment].bAscending), "True", "False") * "to APIIndexes[iCount].IndexSegmentArray[iSegment].bAscending")
111944>>>                            If (iSegment < iNumSegments) Begin
111946>>>                                Writeln channel iCh ("        Increment iSegment")
111949>>>                            End
111949>>>>
111949>>>                        Loop
111950>>>>
111950>>>
111950>>>                        If (iIndex < iIndexes) Begin
111952>>>                            Writeln channel iCh ("        Increment iCount")
111955>>>                            Writeln channel iCh
111957>>>                            Writeln channel iCh ("        // Table:" * '"' + APITableNameInfo.sLogicalName + '"' * "Index:" * String(iIndex + 2))
111960>>>                            Writeln channel iCh ("        Move 0 to iSegment")
111963>>>                        End
111963>>>>
111963>>>                    Loop
111964>>>>
111964>>>
111964>>>                    // Create Relation Definitions:
111964>>>                    Get UtilRelationsStructFill of ghoDbUpdateFunctionLibrary hTable to APIRelations
111965>>>                    If (APIRelations[0].bError = True) Begin
111967>>>                        Function_Return GenerateError
111968>>>                    End
111968>>>>
111968>>>                    If (APIRelations[0].bCancel = True) Begin
111970>>>                        Function_Return GenerateUserCancel
111971>>>                    End
111971>>>>
111971>>>                    Move (SizeOfArray(APIRelations)) to iSize
111972>>>                    Decrement iSize
111973>>>                    If (iSize >= 0) Begin
111975>>>                        Writeln channel iCh
111977>>>                        Writeln channel iCh ("        // Table:" * '"' + APITableNameInfo.sLogicalName + '"' * "Relation: 1")
111980>>>                        Writeln channel iCh ("        Move 0 to iCount")
111983>>>                    End
111983>>>>
111983>>>                    For iCount from 0 to iSize
111989>>>>
111989>>>                        Writeln channel iCh ("        Move" * String(APIRelations[iCount].hTableFrom)  * "to APIRelations[iCount].hTableFrom")
111992>>>                        Writeln channel iCh ("        Move" * String(APIRelations[iCount].iColumnFrom) * "to APIRelations[iCount].iColumnFrom")
111995>>>                        Writeln channel iCh ("        Move" * String(APIRelations[iCount].hTableTo)    * "to APIRelations[iCount].hTableTo")
111998>>>                        Writeln channel iCh ("        Move" * String(APIRelations[iCount].iColumnTo)   * "to APIRelations[iCount].iColumnTo")
112001>>>                        If (iCount < iSize) Begin
112003>>>                            Writeln channel iCh ("        Increment iCount")
112006>>>                            Writeln channel iCh
112008>>>                            Writeln channel iCh ("        // Table:" * '"' + APITableNameInfo.sLogicalName + '"' * "Relation:" * String(iCount + 2))
112011>>>                        End
112011>>>>
112011>>>                    Loop
112012>>>>
112012>>>
112012>>>                    // Create Table Update Definition:
112012>>>                    Writeln channel iCh
112014>>>                    Writeln channel iCh ("        Get ApiTableUpdate APITableNameInfo APIColumns APIIndexes APIRelations to bOK")
112017>>>                    Writeln channel iCh
112019>>>
112019>>>                    Writeln channel iCh ("        Move APIColumnEmpty   to APIColumns")
112022>>>                    Writeln channel iCh ("        Move APIRelationEmpty to APIRelations")
112025>>>                    Writeln channel iCh ("        Move APIIndexEmpty    to APIIndexes")
112028>>>                    Writeln channel iCh ("        Move 0 to iCount")
112031>>>                    Writeln channel iCh ("        Send DoAdvance of ghoProgressBarOverall")
112034>>>                    Writeln channel iCh
112036>>>                End
112036>>>>
112036>>>
112036>>>                If (bIsAlias = True) Begin
112038>>>                    // Create Alias Table Definition:
112038>>>                    Writeln channel iCh ("        // Create Alias Table Definition:")
112041>>>                    Writeln channel iCh ("        Move" * String(hTable) * "to hTable")
112044>>>                    If (bSqlDriver = True and not(APITableNameInfo.sRootName contains sDriverID)) Begin
112046>>>                        Writeln channel iCh ("        Set_Attribute DF_FILE_ROOT_NAME    of hTable to" * '"' + sDriverID + ":" + APITableNameInfo.sRootName    + '"')
112049>>>                    End
112049>>>>
112049>>>                    Else Begin
112050>>>                        Writeln channel iCh ("        Set_Attribute DF_FILE_ROOT_NAME    of hTable to" * '"' + APITableNameInfo.sRootName    + '"')
112053>>>                    End
112053>>>>
112053>>>
112053>>>                    Writeln channel iCh ("        Set_Attribute DF_FILE_LOGICAL_NAME of hTable to" * '"' + APITableNameInfo.sLogicalName + '"')
112056>>>                    Writeln channel iCh ("        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to" * '"' + APITableNameInfo.sDisplayName + '"')
112059>>>                    Writeln channel iCh
112061>>>                End
112061>>>>
112061>>>            End
112061>>>>
112061>>>            Get Check_StatusPanel of ghoStatusPanel to iStatus
112062>>>            If (iStatus <> 0) Begin
112064>>>                Send Seq_Close_Channel iCh
112065>>>                Function_Return GenerateUserCancel
112066>>>            End         
112066>>>>
112066>>>            
112066>>>            Close hTable
112067>>>        Loop // Main TheData loop
112068>>>>
112068>>>
112068>>>        Writeln channel iCh ("    End_Procedure")
112071>>>        Writeln channel iCh ("End_Object")
112074>>>
112074>>>        Send Seq_Close_Channel iCh
112075>>>        Function_Return GenerateOK
112076>>>    End_Function
112077>>>
112077>>>    Function DFTypeToDUFType Integer iDataFlexDataType Returns String
112080>>>        String sRetval
112080>>>        Case Begin
112080>>>            Case (iDataFlexDataType = DF_ASCII)
112082>>>                Move DF_ASCII_DUF to sRetval
112083>>>                Case Break
112084>>>            Case (iDataFlexDataType = DF_BCD)
112087>>>                Move "DF_BCD_DUF" to sRetval
112088>>>                Case Break
112089>>>            Case (iDataFlexDataType = DF_BINARY)
112092>>>                Move "DF_BINARY_DUF" to sRetval
112093>>>                Case Break
112094>>>            Case (iDataFlexDataType = DF_DATE)
112097>>>                Move "DF_DATE_DUF" to sRetval
112098>>>                Case Break
112099>>>            Case (iDataFlexDataType = DF_DATETIME)
112102>>>                Move "DF_DATETIME_DUF" to sRetval
112103>>>                Case Break
112104>>>            Case (iDataFlexDataType = DF_TEXT)
112107>>>                Move "DF_TEXT_DUF" to sRetval
112108>>>                Case Break
112109>>>            Case Else
112109>>>                Move iDataFlexDataType to sRetval
112110>>>        Case End
112110>>>
112110>>>        Function_Return sRetval
112111>>>    End_Function
112112>>>
112112>>>    Procedure Request_Clear    
112115>>>        tSQLConnection Connection
112115>>>        tSQLConnection Connection
112115>>>        tDataSourceRow[] EmptyData
112115>>>        tDataSourceRow[] EmptyData
112116>>>        Handle hoGrid hoDataSource
112116>>>        Integer[] iDifferencesEmpty
112117>>>        
112117>>>        Move DATAFLEX_ID to Connection.sDriverID
112118>>>        Set pSQLConnection of ghoSQLConnectionHandler to Connection
112119>>>        Move (oFilelist_grd(Self))  to hoGrid
112120>>>        Get phoDataSource of hoGrid to hoDataSource
112121>>>        Send InitializeData of hoGrid EmptyData
112122>>>        Send ResetFilelistPathing of ghoApplication
112123>>>        Set Value of oFilelistPath_fm    to ""
112124>>>        Set Value of oPnVersionNumber_fm to 1.0
112125>>>        Set Value of oSourceName_fm      to ""
112126>>>        Set phDbVersion of oFilelist_grd to 0
112127>>>        Set psFilelistFrom of ghoApplication to ""
112128>>>        Set psFooterText of oLogicalName_col to "No of Tables:"
112129>>>        Set psFooterText of oRootName_col    to "Selected:"
112130>>>        Set psFooterText of oIsAlias_Col     to "Alias:"
112131>>>        Send Activate of oFilelistPath_fm    
112132>>>    End_Procedure
112133>>>
112133>>>    Procedure TagChangedTables String sFromFilelist Integer[] iaDifferences
112136>>>        Integer iSize iCount iItem iItems iTableNo iTableNo_Col iCheckbox_Col
112136>>>        Handle hoGrid hoDataSource
112136>>>        tDataSourceRow[] TheData
112136>>>        tDataSourceRow[] TheData
112137>>>
112137>>>        Set Value of oFilelistPath_fm to sFromFilelist
112138>>>        Move (oFilelist_grd(Self)) to hoGrid
112139>>>
112139>>>        Get piColumnId of (oFilelistNumber_col(hoGrid)) to iTableNo_Col
112140>>>        Get piColumnId of (oCheckbox_Col(hoGrid))       to iCheckbox_Col
112141>>>        Get phoDataSource of hoGrid to hoDataSource
112142>>>        Get DataSource of hoDataSource to TheData
112143>>>        Move (SizeOfArray(TheData)) to iItems
112144>>>        Decrement iItems
112145>>>
112145>>>        Move (SizeOfArray(iaDifferences)) to iSize
112146>>>        If (iSize = 0) Begin
112148>>>            Procedure_Return
112149>>>        End
112149>>>>
112149>>>        Decrement iSize
112150>>>        If (iSize > 0) Begin
112152>>>//            Send KeyAction of oDeSelectAll_btn  
112152>>>            Set SelectItems of oFilelist_grd to cx_Select_None
112153>>>        End
112153>>>>
112153>>>
112153>>>        For iCount from 0 to iSize
112159>>>>
112159>>>            Move iaDifferences[iCount] to iTableNo
112160>>>            If (iTableNo > 0) Begin
112162>>>                For iItem from 0 to iItems
112168>>>>
112168>>>                    If (TheData[iItem].sValue[iTableNo_Col] = iTableNo) Begin
112170>>>                        Move True to TheData[iItem].sValue[iCheckbox_Col]
112171>>>                        Move iItems to iItem // We found it and we're out of this loop.
112172>>>                    End
112172>>>>
112172>>>                Loop
112173>>>>
112173>>>            End
112173>>>>
112173>>>        Loop
112174>>>>
112174>>>
112174>>>        Send ReInitializeData of hoGrid TheData False
112175>>>        Send DoSetCheckboxFooterText of hoGrid
112176>>>    End_Procedure
112177>>>
112177>>>    Procedure OnSetFocus
112180>>>        If (SizeOfArray(phoActiveUpdates(ghoCommandBars)) <> 0) Begin
112182>>>            Send Execute of (oCodeGenerator_MenuItem(ghoCommandBars))
112183>>>        End
112183>>>>
112183>>>    End_Procedure
112184>>>    
112184>>>    Procedure OnFileDropped String sFilename Boolean bLast
112187>>>        String sTest
112187>>>        Forward Send OnFileDropped sFilename bLast
112189>>>        If (bLast = True) Begin
112191>>>            Get ParseFileName sFilename to sTest
112192>>>            If (Uppercase(sTest) <> "FILELIST.CFG") Begin
112194>>>                Send Info_Box "Sorry, only Filist.cfg files can be dropped here..."
112195>>>                Procedure_Return
112196>>>            End
112196>>>>
112196>>>            Set Value of oFilelistPath_fm to sFilename
112197>>>        End
112197>>>>
112197>>>    End_Procedure
112198>>>
112198>>>//    On_Key Key_Ctrl+Key_A  Send KeyAction of oSelectAll_btn
112198>>>//    On_Key Key_Ctrl+Key_N  Send KeyAction of oDeSelectAll_btn
112198>>>//    On_Key Key_Ctrl+Key_I  Send KeyAction of oInvertSelection_btn
112198>>>    On_Key Key_Ctrl+Key_G  Send KeyAction of oGenerateCode_btn
112199>>>    On_Key Key_Ctrl+Key_O  Send KeyAction of oOpenAppSrcFolder_btn
112200>>>    On_Key kClear          Send Request_Clear
112201>>>    On_Key kClear_All      Send Request_Clear
112202>>>    On_Key Key_Ctrl+Key_F4 Send None
112203>>>End_Object
112204>>>
112204>>>// General purpose access message to auto-fill grid with tables with
112204>>>// differences (after "Compare Databases" has been run).
112204>>>Procedure TagFileNamesForCodeGeneration
112207>>>    String sFileListFrom sCurrentFilelist
112207>>>    Integer[] iaDifferences
112208>>>    Handle ho
112208>>>
112208>>>    Send Activate_oTableDUFCodeGenerator
112209>>>    Move (oTableDUFCodeGenerator(Self)) to ho
112210>>>    Get Value of (oFilelistPath_fm(ho)) to sCurrentFilelist
112211>>>    If (sCurrentFilelist <> "") Begin
112213>>>        Send Request_Clear of ho
112214>>>    End
112214>>>>
112214>>>
112214>>>    Get psFilelistFrom of ghoApplication to sFileListFrom
112215>>>    Get piaDifferences of ghoApplication to iaDifferences
112216>>>    Send TagChangedTables of ho sFileListFrom iaDifferences
112217>>>    Send Info_Box ("Ready marking tables. Number of different tables:" * (String(SizeOfArray(iaDifferences))))
112218>>>End_Procedure
112219>        Use CompareDatabases.vw
Including file: CompareDatabases.vw    (C:\Projects\DF20\DbUpdateFramework\AppSrc\CompareDatabases.vw)
112219>>>Use Windows.pkg
112219>>>Use Dfclient.pkg
112219>>>Use Cursor.pkg
112219>>>Use Batchdd.pkg
112219>>>Use cRDCButton.pkg
112219>>>Use cDbUpdateFunctionLibrary.pkg
112219>>>Use DUFStatusPanel.pkg
112219>>>Use seq_chnl.pkg
112219>>>Use vWin32fh.pkg
112219>>>Use cRDCHeaderGroup.pkg
112219>>>Use cRDCSuggestionIniForm.pkg
112219>>>Use cSQLCheckBox.pkg
112219>>>Use cRDCCommandLinkButton.pkg
112219>>>Use LogFileDialog.dg
Including file: LogFileDialog.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\LogFileDialog.dg)
112219>>>>>Use Windows.pkg
112219>>>>>Use cRDCButtonDPI.pkg
112219>>>>>Use cRichEdit.pkg
112219>>>>>Use seq_chnl.pkg
112219>>>>>Use vWin32fh.pkg
112219>>>>>
112219>>>>>Object oLogFileDialog_dg is a ModalPanel
112221>>>>>    Set Size to 230 435
112222>>>>>    Set Label to "Log File Dialog"
112223>>>>>    Set piMinSize to 89 211
112224>>>>>    Set Location to 2 2
112225>>>>>    Set Border_Style To Border_Thick
112226>>>>>    Set Locate_Mode to Center_On_Parent
112227>>>>>    
112227>>>>>    Property String psLogFileName ""  
112229>>>>>    Property Integer piIndent 
112231>>>>>    
112231>>>>>    Object oLogFile_edt is a cRichEdit
112233>>>>>        Set Size to 185 413
112234>>>>>        Set Location to 16 11
112235>>>>>        Set TextColor to clBlack
112236>>>>>        Set peAnchors to anAll
112237>>>>>        Set Label_Row_Offset to 3
112238>>>>>        Set Label_TextColor to clGreenGreyLight
112239>>>>>        Set Label_FontItalics to True
112240>>>>>        Set piFontSize to 200
112241>>>>>        Set psTypeFace to 'Consolas'
112242>>>>>        
112242>>>>>        Delegate Set piIndent to (piParagraphIndent(Self))
112244>>>>>        
112244>>>>>        Procedure DoSaveDocument
112247>>>>>            String sLogFileName
112247>>>>>            Boolean bOk bOkToSave bChanged
112247>>>>>        
112247>>>>>            Move False to bOkToSave       
112248>>>>>            Get pbCanUndo to bChanged
112249>>>>>            If (bChanged = False) Begin
112251>>>>>                Procedure_Return
112252>>>>>            End
112252>>>>>>
112252>>>>>        
112252>>>>>            Get psLogFileName to sLogFileName
112253>>>>>            Send Write sLogFileName
112254>>>>>            // clear undo buffer on save
112254>>>>>            // we want undo buffer to only apply to the new document
112254>>>>>            Send ClearUndoBuffer
112255>>>>>            Send Info_Box "Changes saved."
112256>>>>>        End_Procedure 
112257>>>>>        
112257>>>>>        Procedure LoadData
112260>>>>>            String sLogFileName
112260>>>>>            Integer iTwips iIndent
112260>>>>>    
112260>>>>>            Get psLogFileName to sLogFileName
112261>>>>>            Set Label to sLogFileName
112262>>>>>            Move 1440 to iTwips
112263>>>>>            Get piIndent to iIndent
112264>>>>>            Set piParagraphIndent to (iIndent + (iTwips * 0.2))
112265>>>>>            
112265>>>>>            Send Read sLogFileName
112266>>>>>        End_Procedure
112267>>>>>    
112267>>>>>        On_Key Key_Ctrl+Key_S Send DoSaveDocument
112268>>>>>        On_Key kCancel Send Cancel
112269>>>>>    End_Object
112270>>>>>
112270>>>>>    Object oCancel_Btn is a cRDCButtonDPI
112272>>>>>        Set Label    to "&Close"
112273>>>>>        Set Location to 209 374
112274>>>>>        Set peAnchors to anBottomRight
112275>>>>>
112275>>>>>        Procedure OnClick
112278>>>>>            Send Close_Panel
112279>>>>>        End_Procedure
112280>>>>>
112280>>>>>    End_Object
112281>>>>>
112281>>>>>
112281>>>>>    Object oFirstRun_btn is a cRDCButtonDPI
112283>>>>>        Set Location to 209 260
112284>>>>>        Set Label to "Beginning"
112285>>>>>        Set peAnchors to anBottomRight
112286>>>>>    
112286>>>>>        Procedure OnClick
112289>>>>>            Send Beginning_of_Data to oLogFile_edt    
112290>>>>>        End_Procedure
112291>>>>>    
112291>>>>>    End_Object
112292>>>>>    Object oLatestRun_btn is a cRDCButtonDPI
112294>>>>>        Set Location to 209 317
112295>>>>>        Set Label to "End"
112296>>>>>        Set peAnchors to anBottomRight
112297>>>>>    
112297>>>>>        Procedure OnClick
112300>>>>>            Send End_of_Data to oLogFile_edt    
112301>>>>>        End_Procedure
112302>>>>>    
112302>>>>>    End_Object
112303>>>>>
112303>>>>>    // Automatically load data into the grid when activating.
112303>>>>>    Procedure Activating 
112306>>>>>        Handle ho
112306>>>>>        Move (oLogFile_edt(Self)) to ho
112307>>>>>        Send LoadData    of ho
112308>>>>>        // We need to active before we can send end_of_data.
112308>>>>>        Send Activate    of ho
112309>>>>>//        Send End_of_Data to ho
112309>>>>>    End_Procedure
112310>>>>>
112310>>>>>    Procedure Page Integer iPageObject
112313>>>>>        Forward Send Page iPageObject
112315>>>>>        Set Icon to "ViewReportBlack1.ico"
112316>>>>>    End_Procedure      
112317>>>>>    
112317>>>>>    // Put a status bar at the bottom of the panel to add a gripper in the lower right corner.
112317>>>>>    Procedure End_Construct_Object
112320>>>>>        Integer iStyle iSize iOffset
112320>>>>>
112320>>>>>        Forward Send End_Construct_Object
112322>>>>>
112322>>>>>        Get Border_Style to iStyle
112323>>>>>        Move 8 to iOffset
112324>>>>>        If (iStyle = Border_Thick) Begin
112326>>>>>            Object oDialogCommandbar is a cCJCommandBarSystem
112328>>>>>                Object oStatusBar is a cCJStatusBar
112330>>>>>                    Object oStatusIdle is a cCJStatusBarPane
112332>>>>>                        Set piId to sbpIDIdlePane
112333>>>>>                        Set pbStyleStretch to True
112334>>>>>                    End_Object
112335>>>>>                End_Object
112336>>>>>            End_Object
112337>>>>>
112337>>>>>            Get Size to iSize
112338>>>>>            Set Size to (Hi(iSize) + iOffset) (Low(iSize))
112339>>>>>        End
112339>>>>>>
112339>>>>>    End_Procedure
112340>>>>>
112340>>>>>    On_Key Key_Alt+Key_F  Send KeyAction of oFirstRun_btn
112341>>>>>    On_Key Key_Ctrl+Key_F Send KeyAction of oFirstRun_btn
112342>>>>>    On_Key Key_Alt+Key_L  Send KeyAction of oLatestRun_btn
112343>>>>>    On_Key Key_Ctrl+Key_L Send KeyAction of oLatestRun_btn
112344>>>>>    On_Key Key_Alt+Key_C  Send KeyAction of oCancel_Btn
112345>>>>>End_Object
112346>>>>>
112346>>>>>Procedure ActivateLogFileDialog String sLogFile
112349>>>>>    Handle ho       
112349>>>>>    Boolean bExists
112349>>>>>    
112349>>>>>    Get vFilePathExists sLogFile to bExists
112350>>>>>    If (bExists = False) Begin
112352>>>>>        Send Info_Box "The logfile doesn't exist."
112353>>>>>        Procedure_Return
112354>>>>>    End
112354>>>>>>
112354>>>>>    Move (oLogFileDialog_dg(Self)) to ho
112355>>>>>    Set psLogFileName of ho to sLogFile
112356>>>>>    Send Popup of ho
112357>>>>>End_Procedure           
112358>>>
112358>>>Define CS_ReportFileName                for "DUFCompareReport"
112358>>>Define CS_ReportFileNameExtenstion      for ".txt"
112358>>>Define CS_ReportDifferenceNote          for "(*)"
112358>>>Define CS_ReportTableNotFound           for "Table doesn't exist!"
112358>>>Define CS_ReportFieldNotFound           for "Field doesn't exist!"
112358>>>Define CS_ReportIndexNotFound           for "Index doesn't exist!"
112358>>>Define CS_ReportIndexSegmentNotFound    for "Index segment doesn't exist!"
112358>>>Define CS_ReportIndexNotApplicable      for "N/A"
112358>>>Define CS_ReportRelationNotFound        for "Relationship doesn't exist!"
112358>>>Define CS_ReportHeaderUnderWrite        for "===================================================================================="
112358>>>
112358>>>Define CI_ReportColumn1                 for 17
112358>>>Define CI_ReportColumn2                 for 65
112358>>>//Define CI_ReportColumn3                 for 75
112358>>>//Define CI_ReportColumn4                 for 90
112358>>>
112358>>>Struct tRelationDiffs
112358>>>    String sFromFieldsRight
112358>>>    String sFromFields
112358>>>    String sToFields
112358>>>    String sFrom
112358>>>    String sTo
112358>>>End_Struct
112358>>>
112358>>>Global_Variable Integer giDifferenceTables
112358>>>
112358>>>Activate_View Activate_oCompareDatabases_vw for oCompareDatabases_vw
112368>>>>
112368>>>Object oCompareDatabases_vw is a dbView
112370>>>    Set Size to 323 490
112371>>>    Set Label to "Compare"
112372>>>    Set piMinSize to 89 211
112373>>>    Set Border_Style To Border_Thick
112374>>>    Set pbAutoActivate to True
112375>>>    Set pbAcceptDropFiles to True
112376>>>
112376>>>    Object oFromFilelist_grp is a cRDCHeaderGroup
112378>>>        Set Size to 50 462
112379>>>        Set Location to 8 15
112380>>>        Set psImage to "FolderLeft1.ico"
112381>>>        Set Label to "Select FROM Filelist.cfg"
112382>>>        Set psNote to "The development/latest version of the database"  
112383>>>        Set psToolTip to "Select the Filelist.cfg file for the development database"
112384>>>
112384>>>        Object oFilelistPathFrom_fm is a cRDCSuggestionIniForm
112386>>>            Set Size to 12 413
112387>>>            Set Location to 29 29
112388>>>            Set Label_Col_Offset to 0
112389>>>            Set Label_Row_Offset to 1
112390>>>            Set Label_Justification_Mode to JMode_Top
112391>>>            Set Prompt_Button_Mode to PB_PromptOn
112392>>>            Set peAnchors to anTopLeftRight
112393>>>            Set psToolTip to "Select the FROM database Filelist.cfg. This should be the development workspace Data folder's Filelist.cfg"
112394>>>            // This is needed for the toolbar's prompt icon to be active
112394>>>            Set Prompt_Object to Self
112395>>>
112395>>>            Procedure Prompt
112398>>>                String sFileName sPath sFileMask sRetval
112398>>>
112398>>>                Get Value to sFileName
112399>>>                Get ParseFolderName sFileName to sPath
112400>>>                Move "Filelist.cfg files (*.cfg)|*.cfg" to sFileMask
112401>>>                Get vSelect_File sFileMask "Please select a Filelist.cfg file" sPath to sRetval
112402>>>                If (sRetval <> "") Begin
112404>>>                    Set Value to sRetval
112405>>>                End
112405>>>>
112405>>>            End_Procedure
112406>>>
112406>>>            Procedure OnChange
112409>>>                String sValue
112409>>>                Boolean bOK bCfgFile
112409>>>
112409>>>                Get Value to sValue
112410>>>                Get vFilePathExists sValue to bOK
112411>>>                Move (Lowercase(sValue) contains ".cfg") to bCfgFile
112412>>>                If (bOK = True and bCfgFile) Begin
112414>>>                    Get ChangeFilelistPathing of ghoApplication sValue to bOK
112415>>>                    If (bOK = True) Begin
112417>>>                        Set psFilelistFrom of ghoApplication to sValue
112418>>>                    End
112418>>>>
112418>>>                End
112418>>>>
112418>>>
112418>>>            End_Procedure
112419>>>
112419>>>            On_Key Key_Ctrl+Key_W Send None
112420>>>            On_Key Key_Ctrl+Key_Q Send None
112421>>>        End_Object
112422>>>
112422>>>    End_Object
112423>>>
112423>>>    Object oToFilelist_grp is a cRDCHeaderGroup
112425>>>        Set Size to 50 462
112426>>>        Set Location to 69 15
112427>>>        Set psImage to "FolderRight1.ico"
112428>>>        Set Label to "Select TO Filelist.cfg"
112429>>>        Set psNote to "The customer/current version of the database"   
112430>>>        Set psToolTip to "Select the Filelist.cfg file for the database that needs to be updated"
112431>>>
112431>>>        Object oFilelistPathTo_fm is a cRDCSuggestionIniForm
112433>>>            Set Size to 12 413
112434>>>            Set Location to 29 28
112435>>>            Set Label_Col_Offset to 0
112436>>>            Set Label_Row_Offset to 1
112437>>>            Set Label_Justification_Mode to JMode_Top
112438>>>            Set Prompt_Button_Mode to PB_PromptOn
112439>>>            Set peAnchors to anTopLeftRight
112440>>>            Set psToolTip to "Select the TO database Filelist.cfg"
112441>>>            Set Prompt_Object to Self
112442>>>
112442>>>            Procedure Prompt
112445>>>                String sFileName sPath sFileMask sRetval
112445>>>
112445>>>                Get Value to sFileName
112446>>>                Get ParseFolderName sFileName to sPath
112447>>>                Move "Filelist.cfg files (*.cfg)|*.cfg" to sFileMask
112448>>>                Get vSelect_File sFileMask "Please select a Filelist.cfg file" sPath to sRetval
112449>>>                If (sRetval <> "") Begin
112451>>>                    Set Value to sRetval
112452>>>                End
112452>>>>
112452>>>            End_Procedure
112453>>>
112453>>>            Procedure OnChange
112456>>>                String sValue sPath sReportName sToday
112456>>>                Date dToday
112456>>>                Boolean bOK bCfgFile
112456>>>
112456>>>                Get Value to sValue
112457>>>                Get vFilePathExists sValue to bOK
112458>>>                Move (Lowercase(sValue) contains ".cfg") to bCfgFile
112459>>>                If (bOK = False or bCfgFile = False) Begin
112461>>>                    Procedure_Return
112462>>>                End
112462>>>>
112462>>>
112462>>>                Set psFilelistFrom of ghoApplication to sValue
112463>>>                Sysdate dToday  
112464>>>                Move dToday to sToday
112465>>>                Move (Replaces("/", sToday, "-")) to sToday
112466>>>                Move (Replaces(".", sToday, "-")) to sToday
112467>>>                Get Value to sPath
112468>>>                Get ParseFolderName sPath to sPath
112469>>>                Get vFolderFormat   sPath to sPath
112470>>>                Move (sPath + CS_ReportFileName + String(sToday) + CS_ReportFileNameExtenstion) to sReportName
112471>>>                Set Value of oReportFileName_fm to sReportName
112472>>>            End_Procedure
112473>>>
112473>>>            On_Key Key_Ctrl+Key_W Send None
112474>>>            On_Key Key_Ctrl+Key_Q Send None
112475>>>        End_Object
112476>>>
112476>>>    End_Object
112477>>>
112477>>>    Object oCompareProperties_grp is a cRDCHeaderGroup
112479>>>        Set Size to 59 462
112480>>>        Set Location to 130 15
112481>>>        Set Label to "Configure Database Compare"
112482>>>        Set psNote to "Select checkboxes to configure the comparison"
112483>>>        Set psImage to "Settings1.ico" 
112484>>>        Set psToolTip to "Configure what will be compared"
112485>>>        
112485>>>        Object oCompareDate_DataTime_cb is a cSQLCheckBox
112487>>>            Set Size to 9 123
112488>>>            Set Location to 28 30
112489>>>            Set Label to "Check Date/DataTime difference"
112490>>>            Set psToolTip to "Check Date to DateTime column differences"
112491>>>            Set Checked_State to False
112492>>>        End_Object
112493>>>
112493>>>        Object oCompareIndexAscending_cb is a cSQLCheckBox
112495>>>            Set Size to 9 134
112496>>>            Set Location to 28 199
112497>>>            Set Label to "Check Index Ascending/Descending"
112498>>>            Set Checked_State to False
112499>>>            Set psToolTip to "Compare if Index is Ascending/Descending. (In SQL this setting is set for the whole database by selecting a 'Collation', so then checking this per table doesn't make sense)"
112500>>>        End_Object
112501>>>
112501>>>        Object oCompareIndexUppercase_cb is a cSQLCheckBox
112503>>>            Set Size to 9 117
112504>>>            Set Location to 41 30
112505>>>            Set Label to "Check Index Lower/Uppercase"
112506>>>            Set Checked_State to False
112507>>>            Set psToolTip to "Compare if Index is Uppercase/Lowercase. (In SQL this setting is set for the whole database by selecting a 'Collation', so then checking this per table doesn't make sense)"
112508>>>        End_Object
112509>>>
112509>>>        Object oIgnoreFilelistUppercase_cb is a cSQLCheckBox
112511>>>            Set Size to 9 156
112512>>>            Set Location to 41 199
112513>>>            Set Label to "Ignore Filelist Entries Uppercase/Lowercase"
112514>>>            Set Checked_State to True
112515>>>            Set psToolTip to "Check Filelist.cfg RootName, LogicalName and DisplayName uppercase/lowercase differences"
112516>>>        End_Object
112517>>>
112517>>>    End_Object
112518>>>
112518>>>    Object oReportFilename_grp is a cRDCHeaderGroup
112520>>>        Set Size to 51 462
112521>>>        Set Location to 200 15
112522>>>        Set psImage to "ActionPrintSave1.ico"
112523>>>        Set Label to "Report File Name"
112524>>>        Set psNote to "Output file name"    
112525>>>        Set psToolTip to "The name of the report file that contains the compare result"
112526>>>        
112526>>>        Object oReportFileName_fm is a Form
112528>>>            Set Size to 12 413
112529>>>            Set Location to 29 29
112530>>>            Set Label_Col_Offset to 0
112531>>>            Set Label_Row_Offset to 1
112532>>>            Set Label_Justification_Mode to JMode_Top
112533>>>            Set Prompt_Button_Mode to PB_PromptOn
112534>>>            Set peAnchors to anTopLeftRight
112535>>>            Set psToolTip to "The name of the output text file for database differences that will be generated"
112536>>>            Set Status_Help to "The name of the output text file for database differences that will be generated"
112537>>>            Set Prompt_Object to Self
112538>>>
112538>>>            Procedure Prompt
112541>>>                String sFileName sPath sFileMask sRetval
112541>>>
112541>>>                Get Value to sFileName
112542>>>                Get ParseFolderName sFileName to sPath
112543>>>                Move "Text files (*.txt)|*.txt" to sFileMask
112544>>>                Get vSelect_File sFileMask "Please select a text file for the report" sPath to sRetval
112545>>>                If (sRetval <> "") Begin
112547>>>                    Set Value to sRetval
112548>>>                End
112548>>>>
112548>>>            End_Procedure
112549>>>
112549>>>            On_Key Key_Ctrl+Key_W Send None
112550>>>            On_Key Key_Ctrl+Key_Q Send None
112551>>>        End_Object
112552>>>
112552>>>    End_Object
112553>>>
112553>>>    Procedure MainProcess
112556>>>        String sFilelistFrom sFilelistTo
112556>>>        Integer[] iaDifferences
112557>>>        Integer iSize iRetval hTable
112557>>>        Boolean bFromExists bToExists
112557>>>        tAPITableBooleans CompareCheckBoxes
112557>>>        tAPITableBooleans CompareCheckBoxes
112557>>>        DateTime dtExecStart dtExecEnd
112557>>>        TimeSpan tsTotalTime
112557>>>
112557>>>        Move (CurrentDateTime()) to dtExecStart
112558>>>        Get Value of oFilelistPathFrom_fm to sFilelistFrom
112559>>>        Get vFilePathExists sFilelistFrom to bFromExists
112560>>>        Get Value of oFilelistPathTo_fm   to sFilelistTo
112561>>>        Get vFilePathExists sFilelistTo   to bToExists
112562>>>
112562>>>        If (bFromExists = False or bToExists = False) Begin
112564>>>            Send Info_Box "You first need to select a 'FROM' and a 'TO' Filelist.cfg."
112565>>>            Procedure_Return
112566>>>        End
112566>>>>
112566>>>
112566>>>        Move 0 to giDifferenceTables
112567>>>        Get Checked_State of oCompareDate_DataTime_cb    to CompareCheckBoxes.bCompareDate_DateTime
112568>>>        Get Checked_State of oCompareIndexAscending_cb   to CompareCheckBoxes.bCompareIndexAscending
112569>>>        Get Checked_State of oCompareIndexUppercase_cb   to CompareCheckBoxes.bCompareIndexUppercase
112570>>>        Get Checked_State of oIgnoreFilelistUppercase_cb to CompareCheckBoxes.bCompareFilelistUppercase
112571>>>
112571>>>        Get CompareAndOutputDiffs sFilelistFrom sFilelistTo CompareCheckBoxes dtExecStart to iaDifferences
112572>>>        Set piaDifferences of ghoApplication to iaDifferences
112573>>>
112573>>>        Send Stop_StatusPanel of ghoStatusPanel
112574>>>        Move (CurrentDateTime()) to dtExecEnd
112575>>>        Move (dtExecEnd - dtExecStart) to tsTotalTime
112576>>>        Move (SizeOfArray(iaDifferences)) to iSize
112577>>>
112577>>>        Case Begin
112577>>>            Case (iSize = 0)
112579>>>                Send Info_Box "No differences found. The two databases should be identical."
112580>>>                Case Break
112581>>>            Case (iaDifferences[0] >= 1)
112584>>>                Get YesNo_Box ("Ready! (Time elapsed:" * String(tsTotalTime) + ")\n" + String(iSize) * "Differences found. View the report now?") to iRetval
112585>>>                If (iRetval = MBR_Yes) Begin
112587>>>                    Send DoShowReport of oViewReport_Btn
112588>>>                End
112588>>>>
112588>>>                Case Break
112589>>>            Case (iaDifferences[0] = -1)
112592>>>                Send Info_Box "Process interrupted."
112593>>>                Case Break
112594>>>            Case (iaDifferences[0] < -1)
112597>>>                Move iaDifferences[0]  to hTable
112598>>>                Move (999999 + hTable * -1) to hTable
112599>>>                Send Info_Box ("Process not complete. Couldn't open table number:" * String(hTable))
112600>>>                Send DoShowReport of oViewReport_Btn
112601>>>                Case Break
112602>>>            Case Else
112602>>>                Send Info_Box "An unknown error occured. Process interrupted."
112603>>>        Case End
112603>>>
112603>>>        Send Activate of oFilelistPathFrom_fm
112604>>>    End_Procedure
112605>>>
112605>>>    Function CompareAndOutputDiffs String sFilelistFrom String sFilelistTo tAPITableBooleans CompareCheckBoxes DateTime dtExecStart Returns Integer[]
112608>>>        Integer iSize iCount iNoOfTablesFrom iNoOfTablesTo iCh
112608>>>        Boolean bIsSame bFilelistError bUserCancel bOK bCollationDiff bIsEmbedded
112608>>>        Handle hTable
112608>>>        String sLogicalName sDatabaseCollationFrom sDatabaseCollationTo sDatabase
112608>>>        tAPITable[] aFromStructure aToStructure
112608>>>        tAPITable[] aFromStructure aToStructure
112610>>>        tAPITableCompare[] aAPITableCompare
112610>>>        tAPITableCompare[] aAPITableCompare
112611>>>        Integer[] iaDifferences iaDifferencesEmpty 
112613>>>
112613>>>        Set Message_Text of ghoStatusPanel to ""
112614>>>        // Set up the pathing correctly for the 'FROM' Filelist.cfg so we can open tables:
112614>>>        Get ChangeFilelistPathing of ghoApplication sFilelistFrom to bOK
112615>>>        If (bOK = False) Begin
112617>>>            Move -1 to iaDifferencesEmpty[0]
112618>>>            Function_Return iaDifferencesEmpty
112619>>>        End       
112619>>>>
112619>>>        Get UtilIsAllFilelistEntriesDataFlexTables of ghoDbUpdateFunctionLibrary to bIsEmbedded
112620>>>        If (bIsEmbedded = False) Begin
112622>>>            Get psDatabase of ghoDbUpdateFunctionLibrary to sDatabase
112623>>>            Get SqlDatabaseCollationQuery of ghoDbUpdateFunctionLibrary sDatabase True to sDatabaseCollationFrom
112624>>>        End 
112624>>>>
112624>>>        Else Begin
112625>>>            Move "Embedded Database (DataFlex)" to sDatabaseCollationFrom
112626>>>        End
112626>>>>
112626>>>
112626>>>        Get UtilFilelistNoOfTables of ghoDbUpdateFunctionLibrary to iNoOfTablesFrom
112627>>>        Set pbVisible   of ghoProgressBar        to True
112628>>>        Set piPosition  of ghoProgressBar        to 0
112629>>>        Set piAdvanceBy of ghoProgressBar        to 1
112630>>>        Set pbVisible   of ghoProgressBarOverall to True
112631>>>        Set piPosition  of ghoProgressBarOverall to 0
112632>>>        Set piAdvanceBy of ghoProgressBarOverall to 1
112633>>>        Set piMaximum   of ghoProgressBarOverall to iNoOfTablesFrom
112634>>>        
112634>>>        // *** Fill the 'FROM' structure with data: (1 of 3)
112634>>>        Get UtilTablesStructArrayFill of ghoDbUpdateFunctionLibrary True True True to aFromStructure
112635>>>        
112635>>>        // Process cancelled by user?
112635>>>        If (aFromStructure[0].bCancel = True) Begin
112637>>>            Move -1 to iaDifferencesEmpty[0]
112638>>>            Function_Return iaDifferencesEmpty
112639>>>        End
112639>>>>
112639>>>        
112639>>>        // Error while filling struct array (Table could not be opened)?
112639>>>        If (aFromStructure[0].bError = True) Begin
112641>>>            Move aFromStructure[0].ApiTableInfo.iTableNumber to hTable
112642>>>            Move (-999999 - hTable) to iaDifferencesEmpty[0]
112643>>>            Function_Return iaDifferencesEmpty
112644>>>        End
112644>>>>
112644>>>
112644>>>        // Set up the pathing correctly for the 'TO' Filelist.cfg so we can open tables from the other workspace:
112644>>>        Get ChangeFilelistPathing of ghoApplication sFilelistTo to bOK
112645>>>        If (bOK = False) Begin
112647>>>            Move -1 to iaDifferencesEmpty[0]
112648>>>            Function_Return iaDifferencesEmpty
112649>>>        End
112649>>>>
112649>>>
112649>>>        If (bIsEmbedded = False) Begin
112651>>>            Get psDatabase of ghoDbUpdateFunctionLibrary to sDatabase
112652>>>            Get SqlDatabaseCollationQuery of ghoDbUpdateFunctionLibrary sDatabase True to sDatabaseCollationTo
112653>>>        End 
112653>>>>
112653>>>        Else Begin
112654>>>            Move "Embedded Database (DataFlex)" to sDatabaseCollationTo
112655>>>        End
112655>>>>
112655>>>
112655>>>        Get UtilFilelistNoOfTables of ghoDbUpdateFunctionLibrary to iNoOfTablesTo
112656>>>        Set piMaximum of ghoProgressBarOverall to iNoOfTablesTo
112657>>>        Set piAdvanceBy of ghoProgressBarOverall to 1
112658>>>
112658>>>        // *** Fill the 'TO' structure with data: (2 of 3)
112658>>>        Get UtilTablesStructArrayFill of ghoDbUpdateFunctionLibrary True True False to aToStructure
112659>>>        // Process cancelled by user?
112659>>>        If (aToStructure[0].bCancel = True) Begin
112661>>>            Move -1 to iaDifferencesEmpty[0]
112662>>>            Function_Return iaDifferencesEmpty
112663>>>        End
112663>>>>
112663>>>        // Error while filling struct array (Table could not be opened)?
112663>>>        If (aToStructure[0].bError = True) Begin
112665>>>            Move aToStructure[0].ApiTableInfo.iTableNumber to hTable
112666>>>            Move (-999999 - hTable) to iaDifferencesEmpty[0]
112667>>>//            Function_Return iaDifferencesEmpty
112667>>>        End
112667>>>>
112667>>>
112667>>>        Set Message_Text of ghoStatusPanel to "Comparing and Writing Differences: (3 of 3)"
112668>>>        Move 0 to hTable
112669>>>        Move 0 to iCount
112670>>>        Get WriteReportHeader sDatabaseCollationFrom sDatabaseCollationTo to iCh
112671>>>
112671>>>        Get UtilTableCombineFromAndToArrays of ghoDbUpdateFunctionLibrary aFromStructure aToStructure to aAPITableCompare
112672>>>        Move (SizeOfArray(aAPITableCompare))   to iSize
112673>>>        Set piMaximum of ghoProgressBar        to iSize
112674>>>        Set piMaximum of ghoProgressBarOverall to iSize
112675>>>        Decrement iSize
112676>>>
112676>>>        For iCount from 0 to iSize
112682>>>>
112682>>>            Move True to bIsSame
112683>>>            Set piPosition of ghoProgressBarOverall to iCount
112684>>>            Move aAPITableCompare[iCount].hTable to hTable
112685>>>
112685>>>            If (aAPITableCompare[iCount].bExistsFrom = True) Begin
112687>>>                Move aAPITableCompare[iCount].APITableNameInfoCompare.sLogicalNameFrom to sLogicalName
112688>>>            End
112688>>>>
112688>>>            Else Begin
112689>>>                Move aAPITableCompare[iCount].APITableNameInfoCompare.sLogicalNameTo   to sLogicalName
112690>>>            End
112690>>>>
112690>>>            Set Action_Text of ghoStatusPanel to ("Name:" * sLogicalName * String("Number:") * String(hTable))
112691>>>
112691>>>            Get UtilTableCompare_Ex of ghoDbUpdateFunctionLibrary aAPITableCompare[iCount] CompareCheckBoxes False (&bFilelistError) to bIsSame
112692>>>
112692>>>            If (bIsSame = False) Begin
112694>>>                Send MainReport (&aAPITableCompare[iCount]) (&CompareCheckBoxes) iCh
112695>>>                Move hTable to iaDifferences[SizeOfArray(iaDifferences)]
112696>>>            End
112696>>>>
112696>>>
112696>>>            Get Check_StatusPanel of ghoStatusPanel to bUserCancel
112697>>>            If (bUserCancel = True) Begin
112699>>>                Move -1 to iaDifferencesEmpty[0]
112700>>>                Function_Return iaDifferencesEmpty
112701>>>            End
112701>>>>
112701>>>        Loop
112702>>>>
112702>>>        
112702>>>        Move False to bCollationDiff
112703>>>        If (Uppercase(sDatabaseCollationFrom) <> Uppercase(sDatabaseCollationTo)) Begin
112705>>>            Move True to bCollationDiff
112706>>>        End
112706>>>>
112706>>>        Send WriteReportFooter (SizeOfArray(iaDifferences)) bCollationDiff iCh dtExecStart
112707>>>        Close DF_ALL DF_PERMANENT
112708>>>
112708>>>        Function_Return iaDifferences
112709>>>    End_Function
112710>>>
112710>>>    Procedure MainReport tAPITableCompare ByRef aAPITableCompare tAPITableBooleans ByRef CompareCheckBoxes Integer iCh
112713>>>        String sDriverIDFrom sDriverIDTo sLogicalName sFrom sTo
112713>>>        Handle hTable
112713>>>        Boolean bCompareDate_DateTime bCompareIndexUppercase bCompareIndexAscending bCompareFilelistUppercase
112713>>>        Boolean bExistsFrom bExistsTo bIsSQLFrom bIsSQLTo
112713>>>
112713>>>        Move CompareCheckBoxes.bCompareDate_DateTime     to bCompareDate_DateTime
112714>>>        Move CompareCheckBoxes.bCompareIndexAscending    to bCompareIndexAscending
112715>>>        Move CompareCheckBoxes.bCompareIndexUppercase    to bCompareIndexUppercase
112716>>>        Move CompareCheckBoxes.bCompareFilelistUppercase to bCompareFilelistUppercase
112717>>>
112717>>>        Move aAPITableCompare.bExistsFrom                            to bExistsFrom
112718>>>        Move aAPITableCompare.bExistsTo                              to bExistsTo
112719>>>        Move aAPITableCompare.APITableNameInfoCompare.bIsSQLFrom     to bIsSQLFrom
112720>>>        Move aAPITableCompare.APITableNameInfoCompare.bIsSQLTo       to bIsSQLTo
112721>>>        Move aAPITableCompare.APITableNameInfoCompare.sDriverIDFrom  to sDriverIDFrom
112722>>>        Move aAPITableCompare.APITableNameInfoCompare.sDriverIDTo    to sDriverIDTo
112723>>>        Move aAPITableCompare.APITableNameInfoCompare.iTableNumber   to hTable
112724>>>
112724>>>        If (aAPITableCompare.bExistsFrom = True) Begin
112726>>>            Move aAPITableCompare.APITableNameInfoCompare.sLogicalNameFrom to sLogicalName
112727>>>        End
112727>>>>
112727>>>        Else Begin
112728>>>            Move (aAPITableCompare.APITableNameInfoCompare.sLogicalNameTo) to sLogicalName
112729>>>        End
112729>>>>
112729>>>
112729>>>        Send WriteTableInfoDiff aAPITableCompare.APITableNameInfoCompare bCompareFilelistUppercase iCh
112730>>>        If (aAPITableCompare.bExistsFrom = True and aAPITableCompare.bExistsTo = True) Begin
112732>>>            Send WriteColumnDiffs sDriverIDFrom sDriverIDTo hTable sLogicalName bIsSQLFrom bIsSQLTo aAPITableCompare.aAPIColumnsCompare bCompareDate_DateTime iCh
112733>>>            Send WriteIndexDiffs hTable bIsSQLFrom bIsSQLTo sLogicalName aAPITableCompare.aAPIIndexesCompare bCompareIndexUppercase bCompareIndexAscending iCh
112734>>>            Send WriteRelationDiffs hTable aAPITableCompare.aAPIRelationsCompare iCh
112735>>>        End
112735>>>>
112735>>>
112735>>>    End_Procedure
112736>>>
112736>>>    Function WriteReportHeader String sDatabaseCollationFrom String sDatabaseCollationTo Returns Integer
112739>>>        Integer iCh
112739>>>        String sFilelistFrom sFilelistTo sReportName //sDriverIDFrom sDriverIDTo sLogicalName sFrom sTo sRootName sTableName
112739>>>        DateTime dtCreationTime    
112739>>>
112739>>>        Get Value of oReportFileName_fm to sReportName
112740>>>        Get Seq_Open_Output_Channel sReportName to iCh
112741>>>        If (iCh = DF_SEQ_CHANNEL_ERROR) Begin
112743>>>            Send Stop_Box "Sorry, couldn't retrieve a free channel number."
112744>>>            Function_Return 0
112745>>>        End                   
112745>>>>
112745>>>        
112745>>>        If (Uppercase(sDatabaseCollationFrom) <> Uppercase(sDatabaseCollationTo)) Begin
112747>>>            Move (sDatabaseCollationTo * String("(*)")) to sDatabaseCollationTo
112748>>>        End
112748>>>>
112748>>>
112748>>>        Get Value of oFilelistPathFrom_fm to sFilelistFrom
112749>>>        Get Value of oFilelistPathTo_fm   to sFilelistTo
112750>>>        Move (CurrentDateTime()) to dtCreationTime
112751>>>
112751>>>        Writeln channel iCh CS_ReportHeaderUnderWrite
112754>>>        Writeln channel iCh CS_DatabaseUpdateFramework
112757>>>        Writeln channel iCh (" ***  DATABASE DIFFERENCES REPORT  ***")
112760>>>        Writeln channel iCh ""
112763>>>        Writeln channel iCh ("      Date & Time Printed       :" * String(dtCreationTime))
112766>>>        Writeln channel iCh ("      FROM Database Filelist.cfg:" * String(sFilelistFrom))
112769>>>        Writeln channel iCh ("      TO   Database Filelist.cfg:" * String(sFilelistTo))
112772>>>        Writeln channel iCh ("      FROM Database Collation   :" * String(sDatabaseCollationFrom))
112775>>>        Writeln channel iCh ("      TO   Database Collation   :" * String(sDatabaseCollationTo))
112778>>>        Writeln channel iCh ""
112781>>>        Writeln channel iCh ("      Note: An asterisk in parenthesis (*) denotes a difference!")
112784>>>        Writeln channel iCh CS_ReportHeaderUnderWrite
112787>>>        Writeln channel iCh
112789>>>
112789>>>        Function_Return iCh
112790>>>    End_Function
112791>>>
112791>>>    // Note: The rootname will be first be stripped if it contains any driver id prefix.
112791>>>    Procedure WriteTableInfoDiff tAPITableNameInfoCompare APITableNameInfoCompare Boolean bCompareFilelistUppercase Integer iCh
112794>>>        String sLogicalName  sFrom sTo
112794>>>        Boolean bExistsFrom bExistsTo bIsSame
112794>>>        Handle hTable
112794>>>
112794>>>        Get UtilTableInfoCompare of ghoDbUpdateFunctionLibrary bCompareFilelistUppercase APITableNameInfoCompare to bIsSame
112795>>>        If (bIsSame = True) Begin
112797>>>            Procedure_Return
112798>>>        End
112798>>>>
112798>>>
112798>>>        Move APITableNameInfoCompare.iTableNumber to hTable
112799>>>        Move APITableNameInfoCompare.bExistsFrom  to bExistsFrom
112800>>>        Move APITableNameInfoCompare.bExistsTo    to bExistsTo
112801>>>        If (bExistsFrom = True) Begin
112803>>>            Move APITableNameInfoCompare.sLogicalNameFrom to sLogicalName
112804>>>        End
112804>>>>
112804>>>        If (bExistsTo = True) Begin
112806>>>            Move APITableNameInfoCompare.sLogicalNameTo   to sLogicalName
112807>>>        End
112807>>>>
112807>>>
112807>>>        Writeln channel iCh
112809>>>        Writeln channel iCh "Table Name Difference(s) Table Number: " hTable " - " sLogicalName
112815>>>        Writeln channel iCh CS_ReportHeaderUnderWrite
112818>>>
112818>>>        Move "FROM Database:" to sFrom
112819>>>        Get MakeStringLength sFrom CI_ReportColumn2 to sFrom
112820>>>        Move (sFrom + "TO Database:") to sFrom
112821>>>        Writeln channel iCh sFrom
112824>>>        Move (Repeat("-", Length(sFrom))) to sFrom
112825>>>        Writeln channel iCh sFrom
112828>>>
112828>>>        Move "Logical Name:"                                                to sFrom
112829>>>        Get MakeStringLength sFrom CI_ReportColumn1                         to sFrom
112830>>>        If (bExistsFrom = True) Begin
112832>>>            Move (sFrom + String(APITableNameInfoCompare.sLogicalNameFrom)) to sFrom
112833>>>        End
112833>>>>
112833>>>        If (bExistsFrom = False) Begin
112835>>>            Move (sFrom + CS_ReportTableNotFound * String(CS_ReportDifferenceNote)) to sFrom
112836>>>        End
112836>>>>
112836>>>        Get MakeStringLength sFrom CI_ReportColumn2                         to sFrom
112837>>>        If (bExistsTo = True) Begin
112839>>>            Move APITableNameInfoCompare.sLogicalNameTo                     to sTo
112840>>>        End
112840>>>>
112840>>>        If (bExistsTo = False) Begin
112842>>>            Move ""                                                         to sTo
112843>>>            Move (CS_ReportTableNotFound * String(CS_ReportDifferenceNote)) to sTo
112844>>>        End
112844>>>>
112844>>>        Writeln channel iCh sFrom sTo
112848>>>
112848>>>        Move "Root Name:"                                                   to sFrom
112849>>>        Get MakeStringLength sFrom CI_ReportColumn1                         to sFrom
112850>>>        If (bExistsFrom = True) Begin
112852>>>            Move (sFrom + String(APITableNameInfoCompare.sRootNameFrom))    to sFrom
112853>>>        End
112853>>>>
112853>>>        If (bExistsFrom = False) Begin
112855>>>            Move (sFrom + CS_ReportTableNotFound * String(CS_ReportDifferenceNote)) to sFrom
112856>>>        End
112856>>>>
112856>>>        Get MakeStringLength sFrom CI_ReportColumn2                         to sFrom
112857>>>        If (bExistsTo = True) Begin
112859>>>            Move APITableNameInfoCompare.sRootNameTo                        to sTo
112860>>>        End
112860>>>>
112860>>>        If (bExistsTo = False) Begin
112862>>>            Move ""                                                         to sTo
112863>>>            Move (CS_ReportTableNotFound * String(CS_ReportDifferenceNote)) to sTo
112864>>>        End
112864>>>>
112864>>>        Writeln channel iCh sFrom sTo
112868>>>
112868>>>        Move "Display Name:"                                                to sFrom
112869>>>        Get MakeStringLength sFrom CI_ReportColumn1                         to sFrom
112870>>>        If (bExistsFrom = True) Begin
112872>>>            Move (sFrom + String(APITableNameInfoCompare.sDisplayNameFrom)) to sFrom
112873>>>        End
112873>>>>
112873>>>        If (bExistsFrom = False) Begin
112875>>>            Move (sFrom + CS_ReportTableNotFound * String(CS_ReportDifferenceNote)) to sFrom
112876>>>        End
112876>>>>
112876>>>        Get MakeStringLength sFrom CI_ReportColumn2                         to sFrom
112877>>>        If (bExistsTo = True) Begin
112879>>>            Move APITableNameInfoCompare.sDisplayNameTo                     to sTo
112880>>>        End
112880>>>>
112880>>>        If (bExistsTo = False) Begin
112882>>>            Move ""                                                         to sTo
112883>>>            Move (CS_ReportTableNotFound * String(CS_ReportDifferenceNote)) to sTo
112884>>>        End
112884>>>>
112884>>>        Writeln channel iCh sFrom sTo
112888>>>
112888>>>        If (bExistsFrom = False or bExistsTo = False) Begin
112890>>>            Writeln channel iCh
112892>>>        End
112892>>>>
112892>>>        Writeln channel iCh
112894>>>    End_Procedure
112895>>>
112895>>>    Procedure WriteColumnDiffs String sDriverIDFrom String sDriverIDTo Handle hTable String sLogicalTableName Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare[] aAPIColumnCompare Boolean bCompareDate_DateTime Integer iCh
112898>>>        Integer iSize iCount
112898>>>        Boolean bIsSame bHeader
112898>>>        String sFrom sTo sTypeFrom sTypeTo
112898>>>
112898>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
112899>>>        If (iSize = 0) Begin
112901>>>            Procedure_Return
112902>>>        End
112902>>>>
112902>>>
112902>>>        Decrement iSize
112903>>>        For iCount from 0 to iSize
112909>>>>
112909>>>            Get UtilColumnCompare of ghoDbUpdateFunctionLibrary sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare[iCount] bCompareDate_DateTime to bIsSame
112910>>>            If (bIsSame = False) Begin
112912>>>
112912>>>                If (bHeader = False) Begin
112914>>>                    Writeln channel iCh "Field Difference(s) for Table Number: " (String(hTable)) " - " sLogicalTableName
112920>>>                    Writeln channel iCh CS_ReportHeaderUnderWrite
112923>>>                    Move "FROM Database:" to sFrom
112924>>>                    Get MakeStringLength sFrom CI_ReportColumn2 to sFrom
112925>>>                    Move (sFrom + "TO Database:") to sFrom
112926>>>                    Writeln channel iCh sFrom
112929>>>                    Move (Repeat("-", Length(sFrom))) to sFrom
112930>>>                    Writeln channel iCh sFrom
112933>>>                    Move True to bHeader
112934>>>                End
112934>>>>
112934>>>
112934>>>                Get MakeFromString "Field Number:" aAPIColumnCompare[iCount].iFieldNumber (CS_ReportFieldNotFound * CS_ReportDifferenceNote) ;                                 aAPIColumnCompare[iCount].bExistsFrom to sFrom
112935>>>                Get MakeToString aAPIColumnCompare[iCount].iFieldNumber "" (CS_ReportFieldNotFound * CS_ReportDifferenceNote) ;                                 aAPIColumnCompare[iCount].bExistsTo to sTo
112936>>>                Writeln channel iCh sFrom sTo
112940>>>
112940>>>                Get MakeFromString "Field Name" aAPIColumnCompare[iCount].sFieldNameFrom CS_ReportDifferenceNote aAPIColumnCompare[iCount].bExistsTo to sFrom
112941>>>                Get MakeToString aAPIColumnCompare[iCount].sFieldNameTo "" CS_ReportDifferenceNote (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) = ;                                 Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) to sTo
112942>>>                Writeln channel iCh sFrom sTo
112946>>>
112946>>>                Get MakeFromString "Type:" aAPIColumnCompare[iCount].sTypeFrom CS_ReportDifferenceNote aAPIColumnCompare[iCount].bExistsFrom to sFrom
112947>>>                Get MakeToString aAPIColumnCompare[iCount].sTypeTo "" CS_ReportDifferenceNote (Uppercase(aAPIColumnCompare[iCount].sTypeFrom) = ;                                 Uppercase(aAPIColumnCompare[iCount].sTypeTo)) to sTo
112948>>>                Writeln channel iCh sFrom sTo
112952>>>
112952>>>                Get MakeFromString "Length:" aAPIColumnCompare[iCount].iLengthFrom CS_ReportDifferenceNote aAPIColumnCompare[iCount].bExistsFrom to sFrom
112953>>>                Get MakeToString aAPIColumnCompare[iCount].iLengthTo "" CS_ReportDifferenceNote (aAPIColumnCompare[iCount].iLengthFrom = ;                                 aAPIColumnCompare[iCount].iLengthTo) to sTo
112954>>>                Writeln channel iCh sFrom sTo
112958>>>
112958>>>                Get MakeFromString "Precision:" aAPIColumnCompare[iCount].iPrecisionFrom CS_ReportDifferenceNote aAPIColumnCompare[iCount].bExistsFrom to sFrom
112959>>>                Get MakeToString aAPIColumnCompare[iCount].iPrecisionTo "" CS_ReportDifferenceNote (aAPIColumnCompare[iCount].iPrecisionFrom = ;                                 aAPIColumnCompare[iCount].iPrecisionTo) to sTo
112960>>>                Writeln channel iCh sFrom sTo
112964>>>
112964>>>                Get MakeFromString "Default Value:" aAPIColumnCompare[iCount].sDefaultValueFrom CS_ReportDifferenceNote aAPIColumnCompare[iCount].bExistsFrom to sFrom
112965>>>                Get MakeToString aAPIColumnCompare[iCount].sDefaultValueTo "" CS_ReportDifferenceNote (aAPIColumnCompare[iCount].sDefaultValueFrom = ;                                 aAPIColumnCompare[iCount].sDefaultValueTo) to sTo
112966>>>                Writeln channel iCh sFrom sTo
112970>>>
112970>>>                Get MakeFromString "Allow NULL:" (If(aAPIColumnCompare[iCount].bAllowNULLFrom = True, "Yes", "No")) CS_ReportDifferenceNote ;                                 aAPIColumnCompare[iCount].bExistsTo to sFrom
112971>>>                Get MakeToString (If(aAPIColumnCompare[iCount].bAllowNULLTo = True, "Yes", "No")) "" CS_ReportDifferenceNote ;                                 aAPIColumnCompare[iCount].bExistsTo to sTo
112972>>>                Writeln channel iCh sFrom sTo
112976>>>
112976>>>                Get MakeFromString "Identity Field:" (If(aAPIColumnCompare[iCount].iOptionsFrom = C_tAPIColumn_Identity, "Yes", "No")) CS_ReportDifferenceNote ;                                 aAPIColumnCompare[iCount].bExistsTo to sFrom
112977>>>                Get MakeToString (If(aAPIColumnCompare[iCount].iOptionsTo = C_tAPIColumn_Identity, "Yes", "No")) "" CS_ReportDifferenceNote ;                                 aAPIColumnCompare[iCount].bExistsTo to sTo
112978>>>                Writeln channel iCh sFrom sTo
112982>>>                Writeln channel iCh
112984>>>            End
112984>>>>
112984>>>        Loop
112985>>>>
112985>>>
112985>>>        If (bHeader = True) Begin
112987>>>            Writeln channel iCh ""
112990>>>        End
112990>>>>
112990>>>    End_Procedure
112991>>>
112991>>>    Procedure WriteIndexDiffs Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo String sLogicalTableName tAPIIndexCompare[] aAPIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Integer iCh
112994>>>        Integer iSize iCount iSegmentSizeFrom iSegmentSizeTo iCount2 iSize2 iFieldNumberFrom iFieldNumberTo
112994>>>        Integer iIndexNumberFrom iIndexNumberTo iPrimaryIndexFrom iPrimaryIndexTo
112994>>>        tAPIIndexSegment[] aApiIndexSegmentsFrom aApiIndexSegmentsTo aApiIndexSegmentsEmpty
112994>>>        tAPIIndexSegment[] aApiIndexSegmentsFrom aApiIndexSegmentsTo aApiIndexSegmentsEmpty
112997>>>        String sFrom sTo sSQLIndexTypeFrom sSQLIndexTypeTo sSQLIndexNameFrom sSQLIndexNameTo sFieldNameFrom sFieldNameTo
112997>>>        Boolean bIsSame bIsSQLPrimaryFrom bIsSQLPrimaryTo bIsSQLClusteredFrom bIsSQLClusteredTo bHeader
112997>>>
112997>>>        Move (SizeOfArray(aAPIIndexCompare)) to iSize
112998>>>        Decrement iSize
112999>>>
112999>>>        For iCount from 0 to iSize
113005>>>>
113005>>>            Get UtilIndexCompare of ghoDbUpdateFunctionLibrary bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexAscending bCompareIndexUppercase to bIsSame
113006>>>            If (bIsSame = False) Begin
113008>>>                If (bHeader = False) Begin
113010>>>                    Writeln channel iCh "Index Difference(s) for Table Number: " (String(hTable)) " - " sLogicalTableName
113016>>>                    Writeln channel iCh CS_ReportHeaderUnderWrite
113019>>>                    Move "FROM Database:" to sFrom
113020>>>                    Get MakeStringLength sFrom CI_ReportColumn2 to sFrom
113021>>>                    Move (sFrom + "TO Database:") to sFrom
113022>>>                    Writeln channel iCh sFrom
113025>>>                    Move (Repeat("-", Length(sFrom))) to sFrom
113026>>>                    Writeln channel iCh sFrom
113029>>>                    Move True to bHeader
113030>>>                End
113030>>>>
113030>>>
113030>>>                // FROM Index:
113030>>>                If (aAPIIndexCompare[iCount].bExistsFrom = True) Begin
113032>>>                    Move aAPIIndexCompare[iCount].iIndexNumber              to iIndexNumberFrom
113033>>>                    Move aAPIIndexCompare[iCount].iPrimaryIndexFrom         to iPrimaryIndexFrom
113034>>>                    Move aAPIIndexCompare[iCount].sSQLIndexNameFrom         to sSQLIndexNameFrom
113035>>>                    Move aAPIIndexCompare[iCount].bIsSQLPrimaryKeyFrom      to bIsSQLPrimaryFrom
113036>>>                    Move aAPIIndexCompare[iCount].bIsSQLClusteredFrom       to bIsSQLClusteredFrom
113037>>>                    Get UtilIndexTypeToString of ghoDbUpdateFunctionLibrary ;                         aAPIIndexCompare[iCount].iSQLIndexTypeFrom         to sSQLIndexTypeFrom
113038>>>                    Move aAPIIndexCompare[iCount].IndexSegmentArrayFrom     to aApiIndexSegmentsFrom
113039>>>                End
113039>>>>
113039>>>                Else Begin
113040>>>                    Move -1                                                 to iIndexNumberFrom
113041>>>                    Move -1                                                 to iPrimaryIndexFrom
113042>>>                    Move (String(CS_ReportDifferenceNote))                  to sSQLIndexNameFrom
113043>>>                    Move False                                              to bIsSQLPrimaryFrom
113044>>>                    Move False                                              to bIsSQLClusteredFrom
113045>>>                    Move (String(CS_ReportDifferenceNote))                  to sSQLIndexTypeFrom
113046>>>                    Move aApiIndexSegmentsEmpty                             to aApiIndexSegmentsFrom
113047>>>                End
113047>>>>
113047>>>
113047>>>                If (aAPIIndexCompare[iCount].bExistsTo = True) Begin
113049>>>                    Move aAPIIndexCompare[iCount].iIndexNumber              to iIndexNumberTo
113050>>>                    Move aAPIIndexCompare[iCount].iPrimaryIndexTo           to iPrimaryIndexTo
113051>>>                    Move aAPIIndexCompare[iCount].sSQLIndexNameTo           to sSQLIndexNameTo
113052>>>                    Move aAPIIndexCompare[iCount].bIsSQLPrimaryKeyTo        to bIsSQLPrimaryTo
113053>>>                    Move aAPIIndexCompare[iCount].bIsSQLClusteredTo         to bIsSQLClusteredTo
113054>>>                    Get UtilIndexTypeToString of ghoDbUpdateFunctionLibrary ;                        aAPIIndexCompare[iCount].iSQLIndexTypeTo            to sSQLIndexTypeTo
113055>>>                    Move aAPIIndexCompare[iCount].IndexSegmentArrayTo       to aApiIndexSegmentsTo
113056>>>                End
113056>>>>
113056>>>                Else Begin
113057>>>                    Move -1                                                 to iIndexNumberTo
113058>>>                    Move -1                                                 to iPrimaryIndexTo
113059>>>                    Move (String(CS_ReportDifferenceNote))                  to sSQLIndexNameTo
113060>>>                    Move (String(CS_ReportDifferenceNote))                  to bIsSQLPrimaryTo
113061>>>                    Move (String(CS_ReportDifferenceNote))                  to bIsSQLClusteredTo
113062>>>                    Move (String(CS_ReportDifferenceNote))                  to sSQLIndexTypeTo
113063>>>                    Move (String(CS_ReportDifferenceNote))                  to bIsSQLPrimaryTo
113064>>>                    Move aApiIndexSegmentsEmpty                             to aApiIndexSegmentsTo
113065>>>                End
113065>>>>
113065>>>
113065>>>                Get MakeFromString "Index Number:" iIndexNumberFrom CS_ReportIndexNotFound (iIndexNumberFrom <> -1) to sFrom
113066>>>                Get MakeToString iIndexNumberTo "" (CS_ReportIndexNotFound * String(CS_ReportDifferenceNote)) (iIndexNumberTo <> -1) to sTo
113067>>>                Writeln channel iCh sFrom sTo
113071>>>
113071>>>                Get MakeFromString "Primary Idx #:" iPrimaryIndexFrom CS_ReportDifferenceNote (iPrimaryIndexFrom <> -1) to sFrom
113072>>>                Get MakeToString iPrimaryIndexTo "" CS_ReportDifferenceNote (iPrimaryIndexTo <> -1) to sTo
113073>>>                Writeln channel iCh sFrom sTo
113077>>>
113077>>>                // SQL Index info:
113077>>>                If (bIsSqlTableFrom = True and bIsSqlTableTo = True) Begin
113079>>>                    Get MakeFromString "SQL Name:" sSQLIndexNameFrom CS_ReportDifferenceNote (sSQLIndexNameFrom <> "") to sFrom
113080>>>                    Get MakeToString sSQLIndexNameTo "" CS_ReportDifferenceNote (iIndexNumberFrom <> -1 and Uppercase(sSQLIndexNameFrom) = Uppercase(sSQLIndexNameTo)) to sTo
113081>>>                    Writeln channel iCh sFrom sTo
113085>>>
113085>>>                    Get MakeFromString "SQL Primary:" (If(bIsSQLPrimaryFrom = True, "Yes", "No")) CS_ReportDifferenceNote aAPIIndexCompare[iCount].bExistsFrom to sFrom
113086>>>                    Get MakeToString (If(bIsSQLPrimaryTo = True, "Yes", "No")) "" CS_ReportDifferenceNote (iIndexNumberFrom <> -1 and bIsSQLPrimaryFrom = bIsSQLPrimaryTo) to sTo
113087>>>                    Writeln channel iCh sFrom sTo
113091>>>
113091>>>                    Get MakeFromString "SQL Clustered:" (If(bIsSQLClusteredFrom = True, "Yes", "No")) CS_ReportDifferenceNote aAPIIndexCompare[iCount].bExistsFrom to sFrom
113092>>>                    Get MakeToString (If(bIsSQLClusteredTo = True, "Yes", "No")) "" CS_ReportDifferenceNote (iIndexNumberFrom <> -1 and bIsSQLClusteredFrom = bIsSQLClusteredTo) to sTo
113093>>>                    Writeln channel iCh sFrom sTo
113097>>>
113097>>>                    Get MakeFromString "SQL Type:" sSQLIndexTypeFrom CS_ReportDifferenceNote True to sFrom
113098>>>                    Get MakeToString sSQLIndexTypeTo "" CS_ReportDifferenceNote True to sTo
113099>>>                    Writeln channel iCh sFrom sTo
113103>>>                End
113103>>>>
113103>>>
113103>>>                // Index Segments:
113103>>>                Move (SizeOfArray(aApiIndexSegmentsFrom)) to iSegmentSizeFrom
113104>>>                Move (SizeOfArray(aApiIndexSegmentsTo))   to iSegmentSizeTo
113105>>>
113105>>>                Move (iSegmentSizeFrom max iSegmentSizeTo)  to iSize2
113106>>>                Decrement iSize2
113107>>>                If (iSize2 > -1) Begin
113109>>>                    Writeln channel iCh
113111>>>                End
113111>>>>
113111>>>
113111>>>                For iCount2 from 0 to iSize2
113117>>>>
113117>>>                    Move "" to sFieldNameFrom
113118>>>                    Move "" to sFieldNameTo
113119>>>                    Get MakeStringLength "Field# & Name:" CI_ReportColumn1               to sFrom
113120>>>                    If (iCount2 < iSegmentSizeFrom) Begin
113122>>>                        Move aApiIndexSegmentsFrom[iCount2].iFieldNumber                 to iFieldNumberFrom
113123>>>                        Move (sFrom + String(iFieldNumberFrom))                          to sFrom
113124>>>                        Move (String(aApiIndexSegmentsFrom[iCount2].sFieldName))         to sFieldNameFrom
113125>>>                        Move (sFrom * String(sFieldNameFrom))                            to sFrom
113126>>>                    End
113126>>>>
113126>>>                    Else Begin
113127>>>                        Move 0                                                           to iFieldNumberFrom
113128>>>                        Move (sFrom + CS_ReportIndexSegmentNotFound)                     to sFrom
113129>>>                    End
113129>>>>
113129>>>                    Get MakeStringLength sFrom CI_ReportColumn2                          to sFrom
113130>>>
113130>>>                    Move ""                                                              to sTo
113131>>>                    If (iIndexNumberTo <> -1) Begin
113133>>>                        Move aApiIndexSegmentsTo[iCount2].iFieldNumber                   to iFieldNumberTo
113134>>>                        Move (String(iFieldNumberTo))                                    to sTo
113135>>>                        Move (String(aApiIndexSegmentsTo[iCount2].sFieldName))           to sFieldNameTo
113136>>>                        Move (sTo * String(sFieldNameTo))                                to sTo
113137>>>                    End
113137>>>>
113137>>>                    If (iFieldNumberFrom <> iFieldNumberTo or Uppercase(sFieldNameFrom) <> Uppercase(sFieldNameTo)) Begin
113139>>>                        Move (sTo + String(CS_ReportDifferenceNote))                     to sTo
113140>>>                    End
113140>>>>
113140>>>                    Writeln channel iCh sFrom sTo
113144>>>
113144>>>                    // Uppercase Index Segment:
113144>>>                    If (bCompareIndexUppercase = True) Begin
113146>>>                        Get MakeStringLength "Uppercase:" CI_ReportColumn1                                        to sFrom
113147>>>                        If (bIsSqlTableFrom = True) Begin
113149>>>                            Move (sFrom + CS_ReportIndexNotApplicable)                                            to sFrom
113150>>>                        End
113150>>>>
113150>>>                        Else If (iCount <= iSegmentSizeFrom) Begin
113153>>>                            Move (sFrom + String(If(aApiIndexSegmentsFrom[iCount2].bUppercase = 1, "Yes","No")))  to sFrom
113154>>>                        End
113154>>>>
113154>>>                        Get MakeStringLength sFrom CI_ReportColumn2                                               to sFrom
113155>>>                        Move "" to sTo
113156>>>                        If (bIsSqlTableFrom = True) Begin
113158>>>                            Move CS_ReportIndexNotApplicable                                                      to sTo
113159>>>                        End
113159>>>>
113159>>>                        Else If (iCount <= iSegmentSizeTo) Begin
113162>>>                            Move (String(If(aApiIndexSegmentsTo[iCount2].bUppercase = 1, "Yes", "No")))           to sTo
113163>>>                        End
113163>>>>
113163>>>                        Writeln channel iCh sFrom sTo
113167>>>                    End
113167>>>>
113167>>>
113167>>>                    // Ascending/Descending Index:
113167>>>                    If (bCompareIndexAscending = True) Begin
113169>>>                        Get MakeStringLength "Ascending:" CI_ReportColumn1                                        to sFrom
113170>>>                        If (bIsSqlTableFrom = True) Begin
113172>>>                            Move (sFrom + CS_ReportIndexNotApplicable)                                            to sFrom
113173>>>                        End
113173>>>>
113173>>>                        Else If (iCount <= iSegmentSizeFrom) Begin
113176>>>                            Move (sFrom + String(If(aApiIndexSegmentsFrom[iCount2].bAscending = 1, "Yes", "No"))) to sFrom
113177>>>                        End
113177>>>>
113177>>>                        Get MakeStringLength sFrom CI_ReportColumn2                                               to sFrom
113178>>>                        Move "" to sTo
113179>>>                        If (bIsSqlTableFrom = True) Begin
113181>>>                            Move CS_ReportIndexNotApplicable                                                      to sTo
113182>>>                        End
113182>>>>
113182>>>                        Else If (iCount <= iSegmentSizeTo) Begin
113185>>>                            Move (String(If(aApiIndexSegmentsTo[iCount2].bAscending = 1, "Yes", "No")))           to sTo
113186>>>                        End
113186>>>>
113186>>>                        Writeln channel iCh sFrom sTo
113190>>>                    End
113190>>>>
113190>>>                Loop
113191>>>>
113191>>>                Writeln channel iCh ""
113194>>>            End
113194>>>>
113194>>>        Loop
113195>>>>
113195>>>
113195>>>        If (bHeader = True) Begin
113197>>>            Writeln channel iCh ""
113200>>>        End
113200>>>>
113200>>>    End_Procedure
113201>>>
113201>>>    Procedure WriteRelationDiffs Handle hTable tAPIRelationCompare[] aAPIRelationCompare Integer iCh
113204>>>        Integer iSizeFrom iSize iCount iRow iItem
113204>>>        Boolean bExists bIsSame bHeader
113204>>>        String sFrom sTo sFromFieldsRight sFromFields sToFields sLogicalNameFrom
113204>>>        tRelationDiffs[] asRelationDiffs
113204>>>        tRelationDiffs[] asRelationDiffs
113205>>>
113205>>>
113205>>>        Move (SizeOfArray(aAPIRelationCompare)) to iSize
113206>>>        Decrement iSize
113207>>>        For iCount from 0 to iSize
113213>>>>
113213>>>            Get UtilRelationCompare of ghoDbUpdateFunctionLibrary hTable aAPIRelationCompare[iCount] to bIsSame
113214>>>            If (bIsSame = False) Begin
113216>>>                If (bHeader = False) Begin
113218>>>                    Move aAPIRelationCompare[iCount].sLogicalNameFrom_From   to sLogicalNameFrom
113219>>>                    If (sLogicalNameFrom = "") Begin
113221>>>                        Move aAPIRelationCompare[iCount].sLogicalNameFrom_To to sLogicalNameFrom
113222>>>                    End
113222>>>>
113222>>>                    Writeln channel iCh ""
113225>>>                    Writeln channel iCh "Relation Difference(s) for Table Number: " (String(hTable)) " - " sLogicalNameFrom
113231>>>                    Writeln channel iCh CS_ReportHeaderUnderWrite
113234>>>                    Move "FROM Database:" to sFrom
113235>>>                    Get MakeStringLength sFrom CI_ReportColumn2 to sFrom
113236>>>                    Move (sFrom + "TO Database:") to sFrom
113237>>>                    Writeln channel iCh sFrom
113240>>>                    Move (Repeat("-", Length(sFrom))) to sFrom
113241>>>                    Writeln channel iCh sFrom
113244>>>                    Move True to bHeader
113245>>>                End
113245>>>>
113245>>>
113245>>>                // FROM Relation:
113245>>>                Get MakeStringLength "Table.Field:" CI_ReportColumn1                            to sFrom
113246>>>                If (aAPIRelationCompare[iCount].bExistsFrom = True) Begin
113248>>>                    Move (sFrom + String(aAPIRelationCompare[iCount].hTableFrom)   + "." ;                                + String(aAPIRelationCompare[iCount].iColumnFrom)  * "->")      to sFrom
113249>>>                    Move (sFrom * String(aAPIRelationCompare[iCount].hTableTo)     + "." ;                                + String(aAPIRelationCompare[iCount].iColumnTo))                to sFrom
113250>>>                    Get MakeStringLength sFrom CI_ReportColumn2                                 to sFrom
113251>>>                    Move (String(aAPIRelationCompare[iCount].sLogicalNameFrom_From) + "." ;                        + String(aAPIRelationCompare[iCount].sFieldNameFrom_From)   * "->")     to sFromFields
113252>>>                    Move (String(aAPIRelationCompare[iCount].sLogicalNameTo_From)   + "." ;                        + String(aAPIRelationCompare[iCount].sFieldNameTo_From))                to sFromFieldsRight
113253>>>                End
113253>>>>
113253>>>                Else Begin
113254>>>                    Move (String(CS_ReportRelationNotFound) * String(CS_ReportDifferenceNote))  to sFrom
113255>>>                    Get MakeStringLength sFrom CI_ReportColumn2                                 to sFrom
113256>>>                    Move (String(CS_ReportDifferenceNote))                                      to sFromFields
113257>>>                    Move ""                                                                     to sFromFieldsRight
113258>>>                    Move iCount                                                                 to iItem
113259>>>                End
113259>>>>
113259>>>                Move (sFromFields * String(sFromFieldsRight))                                   to sFromFields
113260>>>                Get MakeStringLength sFromFields CI_ReportColumn2                               to sFromFields
113261>>>
113261>>>                // TO Relation:
113261>>>                If (aAPIRelationCompare[iCount].bExistsTo = True) Begin
113263>>>                    Move (String(aAPIRelationCompare[iCount].hTableFrom)           + "." ;                        + String(aAPIRelationCompare[iCount].iColumnFrom)          * "->")      to sTo
113264>>>                    Move (sTo * String(aAPIRelationCompare[iCount].hTableTo)       + "." ;                        + String(aAPIRelationCompare[iCount].iColumnTo))                        to sTo
113265>>>                    Move (String(aAPIRelationCompare[iCount].sLogicalNameFrom_To)  + "." ;                        + String(aAPIRelationCompare[iCount].sFieldNameFrom_To)    * "->")      to sToFields
113266>>>                    Move (sToFields * String(aAPIRelationCompare[iCount].sLogicalNameTo_To) + "." ;                        + String(aAPIRelationCompare[iCount].sFieldNameTo_To))                  to sToFields
113267>>>                End
113267>>>>
113267>>>                Else Begin
113268>>>                    Move (CS_ReportRelationNotFound * String(CS_ReportDifferenceNote))          to sTo
113269>>>                    Move (String(CS_ReportDifferenceNote))                                      to sToFields
113270>>>                End
113270>>>>
113270>>>
113270>>>                Move sFromFieldsRight to asRelationDiffs[iRow].sFromFieldsRight
113271>>>                Move sFrom to asRelationDiffs[iRow].sFrom
113272>>>                Move sTo   to asRelationDiffs[iRow].sTo
113273>>>                Move sFromFields to asRelationDiffs[iRow].sFromFields
113274>>>                Move sToFields   to asRelationDiffs[iRow].sToFields
113275>>>                If (iCount < iSize) Begin
113277>>>                    Increment iRow
113278>>>                    Move "" to asRelationDiffs[iRow].sFrom
113279>>>                    Move "" to asRelationDiffs[iRow].sTo
113280>>>                End
113280>>>>
113280>>>                Else Begin
113281>>>                    Increment iRow
113282>>>                End
113282>>>>
113282>>>            End
113282>>>>
113282>>>        Loop
113283>>>>
113283>>>
113283>>>        // We put all relations in an array struct so we can sort it alphatically.
113283>>>        // This is to show multiple field relations from one table to another next to each other, just as the Studio does.
113283>>>        Move (SortArray(asRelationDiffs))   to asRelationDiffs
113284>>>        Move (SizeOfArray(asRelationDiffs)) to iSizeFrom
113285>>>        Decrement iSizeFrom
113286>>>        For iCount from 0 to iSizeFrom
113292>>>>
113292>>>            Writeln channel iCh asRelationDiffs[iCount].sFrom       asRelationDiffs[iCount].sTo
113296>>>            Writeln channel iCh asRelationDiffs[iCount].sFromFields asRelationDiffs[iCount].sToFields
113300>>>            Writeln channel iCh
113302>>>        Loop
113303>>>>
113303>>>
113303>>>        If (bHeader = True) Begin
113305>>>            Writeln channel iCh ""
113308>>>        End
113308>>>>
113308>>>    End_Procedure
113309>>>
113309>>>    Procedure WriteReportFooter Integer iSize Boolean bCollationDiff Integer iCh DateTime dtExecStart
113312>>>        DateTime dtExecEnd
113312>>>        TimeSpan tsTotalTime
113312>>>
113312>>>        Move (CurrentDateTime()) to dtExecEnd
113313>>>        Move (dtExecEnd - dtExecStart) to tsTotalTime
113314>>>
113314>>>        Writeln channel iCh
113316>>>        Writeln channel iCh "SUMMARY:  [Total Elapsed Time: " tsTotalTime "]"
113321>>>        Writeln channel iCh CS_ReportHeaderUnderWrite               
113324>>>        If (bCollationDiff = False) Begin
113326>>>            Writeln channel iCh "Number of Tables with differences: " (String(iSize))
113330>>>        End 
113330>>>>
113330>>>        Else Begin
113331>>>            If (iSize <> 0) Begin
113333>>>                Writeln channel iCh "Number of Tables with differences: " (String(iSize))
113337>>>            End
113337>>>>
113337>>>            Writeln channel iCh "*** IMPORTANT: The SQL collation used for the 'FROM' and 'TO' database are different! ***"
113340>>>            Writeln channel iCh 
113342>>>        End
113342>>>>
113342>>>        
113342>>>        If (iSize = 0) Begin
113344>>>            Writeln channel iCh "*** No table differences found. All tables should be identical! ***"
113347>>>        End
113347>>>>
113347>>>
113347>>>        Send Seq_Close_Channel iCh
113348>>>    End_Procedure
113349>>>
113349>>>    Function MakeStringLength String sValue Integer iReportColumnPos Returns String
113352>>>        Move (Pad(sValue, (Length(sValue) + (iReportColumnPos - Length(sValue))))) to sValue
113353>>>
113353>>>        Function_Return sValue
113354>>>    End_Function
113355>>>
113355>>>    Function MakeFromString String sStartText String sText String sMissingText Boolean bExists Returns String
113358>>>        String sFrom
113358>>>
113358>>>        Get MakeStringLength sStartText CI_ReportColumn1 to sFrom
113359>>>        If (bExists = True) Begin
113361>>>            Move (sFrom + String(sText)) to sFrom
113362>>>        End
113362>>>>
113362>>>        Else Begin
113363>>>            Move (sFrom + String(sMissingText)) to sFrom
113364>>>        End
113364>>>>
113364>>>        Get MakeStringLength sFrom CI_ReportColumn2 to sFrom
113365>>>
113365>>>        Function_Return sFrom
113366>>>    End_Function
113367>>>
113367>>>    Function MakeToString String sStartText String sText String sMissingText Boolean bSame Returns String
113370>>>        String sTo
113370>>>
113370>>>        Move (String(sStartText) * String(sText)) to sTo
113371>>>        If (bSame = False) Begin
113373>>>            If (sTo <> "-1") Begin
113375>>>                Move (sTo * String(sMissingText)) to sTo
113376>>>            End
113376>>>>
113376>>>            Else Begin
113377>>>                Move (String(sMissingText)) to sTo
113378>>>            End
113378>>>>
113378>>>        End
113378>>>>
113378>>>
113378>>>        Function_Return sTo
113379>>>    End_Function
113380>>>
113380>>>    Function FindArrayItem tAPITable[] aFromStructure tAPITable[] aToStructure Integer iCount Handle ByRef hTable Integer ByRef iItemFrom Integer ByRef iItemTo Returns String
113383>>>        Integer iSizeFrom iSizeTo
113383>>>        Handle hTableFrom hTableTo
113383>>>        String sLogicalName
113383>>>
113383>>>        Move (SizeOfArray(aFromStructure)) to iSizeFrom
113384>>>        Move (SizeOfArray(aToStructure))   to iSizeTo
113385>>>
113385>>>        Move -1 to hTableFrom
113386>>>        Move -1 to hTableTo
113387>>>        Move iCount to iItemFrom
113388>>>        Move iCount to iItemTo
113389>>>
113389>>>        // The two struct arrays may be different in size (contain different number of items/tables).
113389>>>        //
113389>>>        // To avoid "Referenced Array Index Out of Bounds" error.
113389>>>        If (iCount < iSizeFrom) Begin
113391>>>            Move aFromStructure[iCount].ApiTableInfo.iTableNumber to hTableFrom
113392>>>        End
113392>>>>
113392>>>        If (iCount < iSizeTo) Begin
113394>>>            Move aToStructure[iCount].ApiTableInfo.iTableNumber   to hTableTo
113395>>>        End
113395>>>>
113395>>>        If (hTableFrom <> -1 and hTableTo <> -1) Begin
113397>>>            Move (hTableFrom min hTableTo)                to hTable
113398>>>        End
113398>>>>
113398>>>        Else Begin
113399>>>            Move (hTableFrom max hTableTo)                to hTable
113400>>>        End
113400>>>>
113400>>>
113400>>>        If (iCount < iSizeFrom and hTableFrom <= hTableTo) Begin
113402>>>            Move aFromStructure[iCount].ApiTableInfo.sLogicalName to sLogicalName
113403>>>            Get FindTableNumber (&aToStructure) hTable to iItemTo
113404>>>        End
113404>>>>
113404>>>
113404>>>        // If the 'TO' table number is lower than 'FROM'
113404>>>        Else If (iCount < iSizeTo) Begin
113407>>>            Move aToStructure[iCount].ApiTableInfo.sLogicalName to sLogicalName
113408>>>            Get FindTableNumber (&aFromStructure) hTable to iItemFrom
113409>>>        End
113409>>>>
113409>>>        Else If (iCount = iSizeTo) Begin
113412>>>            Get FindTableNumber (&aToStructure) hTable to iItemTo
113413>>>        End
113413>>>>
113413>>>
113413>>>        Function_Return sLogicalName
113414>>>    End_Function
113415>>>
113415>>>    Function FindTableNumber tAPITable[] ByRef aTableStructure Handle hTable Returns Integer
113418>>>        Integer iSize iCount iTable iItem
113418>>>        tAPITableNameInfo ApiTableNameInfo
113418>>>        tAPITableNameInfo ApiTableNameInfo
113418>>>
113418>>>        Move -1 to iItem
113419>>>        Move (SizeOfArray(aTableStructure)) to iSize
113420>>>        Decrement iSize
113421>>>        For iCount from 0 to iSize
113427>>>>
113427>>>            Move aTableStructure[iCount].ApiTableInfo to ApiTableNameInfo
113428>>>            If (ApiTableNameInfo.iTableNumber = hTable) Begin
113430>>>                Move iCount to iItem
113431>>>                Move iSize  to iCount // We're done.
113432>>>            End
113432>>>>
113432>>>        Loop
113433>>>>
113433>>>
113433>>>        Function_Return iItem
113434>>>    End_Function
113435>>>
113435>>>    // Pass one tAPIRelation for the FROM database and a struct array with relations for the TO database
113435>>>    // Returns the item number in the aAPIRelationsTO that equals the FROM relation struct data.
113435>>>    // If not found returns -1.
113435>>>//    Function FindEqualRelation tAPIRelation APIRelationFrom tAPIRelation[] aAPIRelationsTO Returns Integer
113435>>>//        Integer iRetval iSize iCount
113435>>>//
113435>>>//        Move -1 to iRetval
113435>>>//        Move (SizeOfArray(aAPIRelationsTO)) to iSize
113435>>>//        Decrement iSize
113435>>>//        For iCount from 0 to iSize
113435>>>//            If (APIRelationFrom.hTableFrom  = aAPIRelationsTO[iCount].hTableFrom  and ;
113435>>>//                APIRelationFrom.iColumnFrom = aAPIRelationsTO[iCount].iColumnFrom and ;
113435>>>//                APIRelationFrom.hTableTo    = aAPIRelationsTO[iCount].hTableTo    and ;
113435>>>//                APIRelationFrom.iColumnTo   = aAPIRelationsTO[iCount].iColumnTo) Begin
113435>>>//                    Move iCount to iRetval
113435>>>//                End
113435>>>//        Loop
113435>>>//
113435>>>//        Function_Return iRetval
113435>>>//    End_Function
113435>>>
113435>>>    // Returns a value <> -1 if the passed iIndex was found in the APIIndex struct array.
113435>>>    // The value returned is the item number, else a -1.
113435>>>//    Function FindIndexInArray Integer iIndex tAPIIndex[] APIIndex Returns Integer
113435>>>//        Integer iRetval iSize iCount iCompareIndex
113435>>>//
113435>>>//        Move -1 to iRetval
113435>>>//        Move (SizeOfArray(APIIndex)) to iSize
113435>>>//        Decrement iSize
113435>>>//        For iCount from 0 to iSize
113435>>>//            If (iIndex = APIIndex[iCount].iIndexNumber) Begin
113435>>>//                Move iCount to iRetval
113435>>>//            End
113435>>>//        Loop
113435>>>//        Function_Return iRetval
113435>>>//    End_Function
113435>>>
113435>>>    Procedure Request_Clear
113438>>>        tSQLConnection Connection
113438>>>        tSQLConnection Connection
113438>>>        Integer[] iDifferencesEmpty
113439>>>
113439>>>        Move DATAFLEX_ID to Connection.sDriverID
113440>>>        Set pSQLConnection of ghoSQLConnectionHandler to Connection
113441>>>        Set Value of oFilelistPathFrom_fm   to ""
113442>>>        Set Value of oFilelistPathTo_fm     to ""
113443>>>        Set Value of oReportFileName_fm     to ""
113444>>>        Set psFilelistFrom of ghoApplication to ""
113445>>>        Set piaDifferences of ghoApplication to iDifferencesEmpty
113446>>>
113446>>>        Send Activate of oFilelistPathFrom_fm
113447>>>    End_Procedure
113448>>>
113448>>>    Object oBusinessProcess is a BusinessProcess
113450>>>        Set Status_Panel_Id to ghoStatusPanel
113451>>>        Set Allow_Cancel_State to True
113452>>>        Set Process_Caption to "The Database Update Framework"
113453>>>        Set Process_Title to "Comparing Database Structures..."
113454>>>//        Set Display_Error_State to True // Temp!
113454>>>
113454>>>        Procedure OnProcess
113457>>>            Send MainProcess
113458>>>        End_Procedure
113459>>>
113459>>>        Procedure Ignore_Error Integer iError
113462>>>        End_Procedure
113463>>>        Procedure Trap_Error Integer iError
113466>>>        End_Procedure
113467>>>
113467>>>    End_Object
113468>>>
113468>>>    Object oCompare_btn is a cRDCCommandLinkButton
113470>>>        Set Size to 36 166
113471>>>        Set Location to 276 139
113472>>>        Set Label to "Co&mpare Databases!"
113473>>>        Set psNote to "Compare the two selected databases."
113474>>>        Set psImage to "DbCompare1.ico"
113475>>>        Set Default_State to True
113476>>>        Set psToolTip to "Start the compare process"
113477>>>        Set piImageSize to 32 // 48
113478>>>        Set peAnchors to anBottomRight
113479>>>
113479>>>        Procedure OnClick
113482>>>            String sFilelistFrom sFilelistTo
113482>>>            Integer[] iaDifferences
113483>>>            Boolean bFromExists bToExists
113483>>>
113483>>>            Get Value of oFilelistPathFrom_fm to sFilelistFrom
113484>>>            Get vFilePathExists sFilelistFrom to bFromExists
113485>>>            Get Value of oFilelistPathTo_fm   to sFilelistTo
113486>>>            Get vFilePathExists sFilelistTo   to bToExists
113487>>>            If (bFromExists = False or bToExists = False) Begin
113489>>>                Send Info_Box "You need to both select a FROM and a TO database Filelist.cfg. Please adjust and try again."
113490>>>                Procedure_Return
113491>>>            End
113491>>>>
113491>>>
113491>>>            Send DoProcess of oBusinessProcess
113492>>>            Send Restore_DF_OPEN_PATH of ghoApplication
113493>>>        End_Procedure
113494>>>
113494>>>        Function IsEnabled Returns Boolean
113497>>>            String sFileListFrom sFileListTo
113497>>>            Boolean bExists bState
113497>>>
113497>>>            Get Value of oFilelistPathFrom_fm to sFileListFrom
113498>>>            Get vFilePathExists sFileListFrom to bExists
113499>>>            If (bExists = False) Begin
113501>>>                Function_Return False
113502>>>            End
113502>>>>
113502>>>            Get Value of oFilelistPathTo_fm to sFileListTo
113503>>>            Get vFilePathExists sFileListTo to bExists
113504>>>            Get Enabled_State to bState
113505>>>            If (bState = False and bExists = False) Begin
113507>>>                Function_Return False
113508>>>            End
113508>>>>
113508>>>            Function_Return bExists
113509>>>        End_Function
113510>>>
113510>>>    End_Object
113511>>>
113511>>>    Object oViewReport_Btn is a cRDCCommandLinkButton
113513>>>        Set Size to 36 77
113514>>>        Set Location to 276 315
113515>>>        Set Label to "&Report"
113516>>>        Set psNote to "View report"
113517>>>        Set peAnchors to anBottomRight
113518>>>        Set psImage to "ViewReport1.ico"
113519>>>        Set psToolTip to "Open the folder where the report was generated. (Ctrl+R)"
113520>>>        Set piImageSize to 16 //24
113521>>>
113521>>>        Procedure OnClick
113524>>>            Send DoShowReport
113525>>>        End_Procedure
113526>>>        
113526>>>        Procedure DoShowReport
113529>>>            String sReportName
113529>>>            Get Value of oReportFileName_fm to sReportName
113530>>>            Send ActivateLogFileDialog of (Client_Id(ghoCommandBars)) sReportName
113531>>>//            Runprogram Shell Background sReportName
113531>>>        End_Procedure
113532>>>
113532>>>        Function IsEnabled Returns Boolean
113535>>>            String sReportName
113535>>>            Boolean bExists
113535>>>
113535>>>            Get Value of oReportFileName_fm to sReportName
113536>>>            Get vFilePathExists sReportName to bExists
113537>>>            Function_Return bExists
113538>>>        End_Function
113539>>>
113539>>>    End_Object
113540>>>
113540>>>    Object oTagFilelist_Btn is a cRDCCommandLinkButton
113542>>>        Set Size to 36 76
113543>>>        Set Location to 276 402
113544>>>        Set Label to "&Tag"
113545>>>        Set psNote to "Tag differences"
113546>>>        Set peAnchors to anBottomRight
113547>>>        Set MultiLineState to True
113548>>>        Set Border_Style to Border_Normal
113549>>>        Set peImageAlign to Button_ImageList_Align_Center
113550>>>        Set psImage to "SelectInvert1.ico"
113551>>>        Set psToolTip to "Tag Tables for the 'FROM' Filelist.cfg with differences - for code generation on the 'Code Generator' view page."
113552>>>        Set pbAutoEnable to True
113553>>>        Set piImageSize to 16 // 24
113554>>>
113554>>>        Procedure OnClick
113557>>>            String sFileListFrom
113557>>>            Get Value of oFilelistPathFrom_fm    to sFileListFrom
113558>>>            Set psFilelistFrom of ghoApplication to sFileListFrom
113559>>>            Send TagFileNamesForCodeGeneration
113560>>>        End_Procedure
113561>>>
113561>>>        Function IsEnabled Returns Boolean
113564>>>            Integer[] iaDifferences
113565>>>            Get piaDifferences of ghoApplication to iaDifferences
113566>>>            Function_Return (SizeOfArray(iaDifferences))
113567>>>        End_Function
113568>>>
113568>>>    End_Object
113569>>>
113569>>>    Procedure OnSetFocus
113572>>>        If (SizeOfArray(phoActiveUpdates(ghoCommandBars)) <> 0) Begin
113574>>>            Send Execute of (oCompareDatabases_MenuItem(ghoCommandBars))
113575>>>        End
113575>>>>
113575>>>    End_Procedure
113576>>>    
113576>>>    Procedure OnFileDropped String sFilename Boolean bLast
113579>>>        String sTest sFileListFrom sFileListTo
113579>>>
113579>>>        Forward Send OnFileDropped sFilename bLast
113581>>>        Get Value of oFilelistPathFrom_fm to sFileListFrom
113582>>>        Get Value of oFilelistPathTo_fm    to sFileListTo
113583>>>        If (bLast = True) Begin
113585>>>            Get ParseFileName sFilename to sTest
113586>>>            If (Uppercase(sTest) <> "FILELIST.CFG") Begin
113588>>>                Send Info_Box "Sorry, only Filist.cfg files can be dropped here..."
113589>>>                Procedure_Return
113590>>>            End                                           
113590>>>>
113590>>>            If (sFileListFrom = "") Begin
113592>>>                Set Value of oFilelistPathFrom_fm to sFilename
113593>>>            End 
113593>>>>
113593>>>            Else Begin
113594>>>                Set Value of oFilelistPathTo_fm to sFilename
113595>>>            End
113595>>>>
113595>>>                
113595>>>        End
113595>>>>
113595>>>    End_Procedure
113596>>>
113596>>>    On_Key Key_Ctrl+Key_M  Send KeyAction of oCompare_btn
113597>>>    On_Key Key_Ctrl+Key_R  Send KeyAction of oViewReport_Btn
113598>>>    On_Key Key_Ctrl+Key_T  Send KeyAction of oTagFilelist_Btn
113599>>>    On_Key kClear          Send Request_Clear
113600>>>    On_Key kClear_All      Send Request_Clear
113601>>>    On_Key Key_Ctrl+Key_F4 Send None
113602>>>End_Object
113603>
113603>        Use StdAbout.pkg
Including file: StdAbout.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\DFAbout\StdAbout.pkg)
113603>>>//************************************************************************
113603>>>// Confidential Trade Secret.
113603>>>// Copyright (c) 1997 Data Access Corporation, Miami Florida
113603>>>// as an unpublished work.  All rights reserved.
113603>>>// DataFlex is a registered trademark of Data Access Corporation.
113603>>>//
113603>>>//************************************************************************
113603>>>//************************************************************************
113603>>>//
113603>>>// $File name  : StdAbout.pkg
113603>>>// $File title : Standard about object package for VDF
113603>>>// Notice      :
113603>>>// $Author(s)  : John Tuohy
113603>>>//
113603>>>// $Rev History
113603>>>//
113603>>>// JT 06/27/97   File created
113603>>>//************************************************************************
113603>>>
113603>>>// This provides a quick and simple way to create an about package for a program.
113603>>>// You need to create a message inside you client area called Activate_About.
113603>>>// Within this message you should send the message DoAbout passing needed
113603>>>// string information.
113603>>>//
113603>>>//       Procedure Activate_About
113603>>>//           Send DoAbout sTitle sVersion sCopyright sAuthor sBitmap
113603>>>//       End_Procedure
113603>>>//    where: sTitle =     Name of application. If none provided, uses caption
113603>>>//                        bar title
113603>>>//           sVersion   = Version Line. If none provided, will be blank
113603>>>//           sCopyRight = Copyright Line. If none provided, will be blank
113603>>>//           sAuthor    = Author name, blank if none provided
113603>>>//           sBitMap    = Bitmap logo. If none provided, standard VDF bitmap
113603>>>//                        is used.
113603>>>// It is expected that you will place this in your own object package. For
113603>>>// example an order about package may look like this:
113603>>>//
113603>>>//   // OrderAbout.pkg
113603>>>//   Use StdAbout.pkg
113603>>>//   Procedure Activate_About
113603>>>//      String sTitle sCopyright sVersion sAuthor
113603>>>//      Move "My Order Entry System" to sTitle
113603>>>//      Move "Version 2.1" to sVersion
113603>>>//      Move "Copyright 1997, Super Software Inc." to sCopyright
113603>>>//      Move "John Smith"  to sAuthor
113603>>>//      Send DoAbout sTitle sVersion sCopyright sAuthor ""
113603>>>//   end_procedure
113603>>>//   // end of file.
113603>>>
113603>>>Use DfAbout.pkg
113603>>>
113603>>>// *************************************************************************
113603>>>//  Public message. This is the default message. It is expected that you will
113603>>>//   create your own message to override this
113603>>>// *************************************************************************
113603>>>
113603>>>Procedure Activate_About
113606>>>    Send DoAbout "" "" "" "" "" "" "" "" "" ""
113607>>>End_Procedure
113608>>>
113608>>>// *************************************************************************
113608>>>//  Public message. It is expected that you will send this message (most
113608>>>//  likely from Activate_About. This creates an about object, activates it
113608>>>//  and destroys it when done. It is not exepected that you will augment this.
113608>>>// *************************************************************************
113608>>>// Sample usage:
113608>>>//   The first two params will automatically be filled from the application settings if not provided.
113608>>>//   Send DoAbout "" "" ("Copyright: 2013" * psCompany(ghoApplication)) "Created by: Your Name" "YourAppBitmap.bmp" "Internet: http://www.YourWebAddress.com" "E-mail: mailto:support@YourEmailAddress.com" "Some other description of choice" "9th param" "and last param"
113608>>>
113608>>>Procedure DoAbout String sTitle String sVersion String sCopyRight String sAuthor String sBitmap ;    String sParam6 String sParam7 String sParam8 String sParam9 String sParam10
113611>>>    Integer hoObj hoMain iArgs
113611>>>    String sValue
113611>>>
113611>>>    // Create object
113611>>>    Object About is an AboutDialog
113613>>>    // Uncomment these two lines if you would like to have a resizable About object.
113613>>>    //            Set Border_Style to Border_Thick
113613>>>    //            Set peAnchors to anAll
113613>>>
113613>>>    // Add checking for the number of arguments passed to avoid runtime errors
113613>>>    // if one of them is not passed. This makes the interface
113613>>>    // more flexible.
113613>>>        Move num_arguments to iArgs
113614>>>
113614>>>        // If no title is passed use the label of the main panel (if a main panel exists).
113614>>>        If (iArgs > 0 and sTitle = "") Begin
113616>>>            Get Main_Window of Desktop to hoMain
113617>>>            If hoMain Begin
113619>>>                Get Label of hoMain to sValue
113620>>>            End
113620>>>>
113620>>>        End
113620>>>>
113620>>>        Else If (iArgs > 0 and sTitle <> "") Begin
113623>>>            Move sTitle to sValue
113624>>>        End
113624>>>>
113624>>>        Else If (iArgs = 0) Begin
113627>>>            Get Main_Window of Desktop to hoMain
113628>>>            If hoMain Begin
113630>>>                Get Label of hoMain to sValue
113631>>>            End
113631>>>>
113631>>>        End
113631>>>>
113631>>>
113631>>>        If (sValue <> "") Begin
113633>>>            Send Add_LineLn sValue
113634>>>        End
113634>>>>
113634>>>        Move "" to sValue
113635>>>
113635>>>        // If the passed sVersion value is blank, the info will be retrieved from the cApplication object.
113635>>>        // For this to work the Project Properties Version must have been set in the Studio.
113635>>>        If (iArgs < 2) Begin
113637>>>            Move "" to sValue
113638>>>        End
113638>>>>
113638>>>        Else Begin
113639>>>            Move sVersion to sValue
113640>>>        End
113640>>>>
113640>>>        Set Version to sValue
113641>>>
113641>>>        If (iArgs > 2 and sCopyRight <> "") Begin
113643>>>            Send Add_LineLn sCopyRight
113644>>>        End
113644>>>>
113644>>>
113644>>>        // If only the five "standard" params were passed we don't add an extra linefeed;
113644>>>        // else we do.
113644>>>        If (iArgs > 3 and iArgs < 6 and sAuthor <> "") Begin
113646>>>            Send Add_Line sAuthor
113647>>>        End
113647>>>>
113647>>>        Else If (iArgs > 5 and sAuthor <> "") Begin
113650>>>            Send Add_LineLn sAuthor
113651>>>        End
113651>>>>
113651>>>
113651>>>        // Square bitmaps of 80x80 works best
113651>>>        If (iArgs > 4 and sBitmap <> "") Begin
113653>>>            Set Logo to sBitMap
113654>>>        End
113654>>>>
113654>>>
113654>>>        // Here starts handling of the five optional params:
113654>>>        If (iArgs = 6 and sParam6  <> "") Begin
113656>>>            Send Add_Line sParam6
113657>>>        End
113657>>>>
113657>>>        Else If (iArgs > 6 and sParam6  <> "") Begin
113660>>>            Send Add_LineLn sParam6
113661>>>        End
113661>>>>
113661>>>
113661>>>        If (iArgs = 7 and sParam7  <> "") Begin
113663>>>            Send Add_Line sParam7
113664>>>        End
113664>>>>
113664>>>        Else If (iArgs > 7 and sParam7  <> "") Begin
113667>>>            Send Add_LineLn sParam7
113668>>>        End
113668>>>>
113668>>>
113668>>>        If (iArgs = 8 and sParam8  <> "") Begin
113670>>>            Send Add_Line sParam8
113671>>>        End
113671>>>>
113671>>>        Else If (iArgs > 8 and sParam8  <> "") Begin
113674>>>            Send Add_LineLn sParam8
113675>>>        End
113675>>>>
113675>>>
113675>>>        If (iArgs = 9 and sParam9  <> "") Begin
113677>>>            Send Add_Line sParam9
113678>>>        End
113678>>>>
113678>>>        Else If (iArgs > 9 and sParam9  <> "") Begin
113681>>>            Send Add_LineLn sParam9
113682>>>        End
113682>>>>
113682>>>
113682>>>        If (iArgs = 10 and sParam10 <> "") Begin
113684>>>            Send Add_Line sParam10
113685>>>        End
113685>>>>
113685>>>
113685>>>        Move Self to hoObj
113686>>>    End_Object
113687>>>
113687>>>    Send Popup   of hoObj // Popup the about object
113688>>>    Send Destroy of hoObj // When done, it will be destroyed
113689>>>End_Procedure
113690>        Use CompareDatabases.rv
Including file: CompareDatabases.rv    (C:\Projects\DF20\DbUpdateFramework\AppSrc\CompareDatabases.rv)
113690>>>Use Windows.pkg
113690>>>Use DFRptVw.pkg
113690>>>Use DFRpt.pkg
113690>>>Use File_Dlg.Pkg
113690>>>Use CompareDatabases.img
Including file: CompareDatabases.img    (C:\Projects\DF20\DbUpdateFramework\AppSrc\CompareDatabases.img)
113690>>>>>// CompareDatabases Basic Report
113690>>>>>// Since report images, such as the one used here, are not fully supported by
113690>>>>>// the Studio, the images for this report are placed in a separate package.
113690>>>>>//
/HEADER
Image 1, HEADER
 ***  The Database Update Framework (DUF) DATABASE DIFFERENCES REPORT  ***
     
      Date & Time Printed       : ____________________
      FROM Database Filelist.cfg: ________________________________________________________________________________________________________________________
      TO   Database Filelist.cfg: ________________________________________________________________________________________________________________________
/Top
Image 2, TOP
                                                                           Page:___.
/SubHeader
Image 3, SUBHEADER
________ Difference(s) for Table: ____ - ______________________________    
====================================================================================
FROM Database:                                              TO Database:
------------------------------------------------------------------------
/BodyFields
Image 4, BODYFIELDS
Field Number:  ____                                         ____
Name:          ____________________________________________ ____________________________________________
Type:          ____________________________________________ ____________________________________________
Length:        ____                                         ____
Precision:     ____                                         ____
Identity Field:___                                          ___   
/Footer
Image 5, FOOTER
SUMMARY:
====================================================================================
Number of Tables with differences: ____
/*
113690>>>
113690>>>Activate_View Activate_oCompareDatabases for oCompareDatabases
113700>>>>
113700>>>Object oCompareDatabases is a ReportView
113702>>>    Set Location to 6 6
113703>>>    Set Size to 84 181
113704>>>    Set Label to "Compare Databases"
113705>>>
113705>>>    Property String psFilelistFrom
113707>>>    Property String psFilelistTo
113709>>>    Property Integer piDifferences
113711>>>
113711>>>    Object oDestination is a RadioGroup
113713>>>        Set Size to 59 171
113714>>>        Set Location to 5 5
113715>>>        Set Label to "Output Device:"
113716>>>
113716>>>        Object oScreen is a Radio
113718>>>            Set Label to "Screen"
113719>>>            Set Size to 10 39
113720>>>            Set Location to 15 10
113721>>>            Set Status_Help to "Preview the report to screen"
113722>>>        End_Object
113723>>>
113723>>>        Object oPrinter is a Radio
113725>>>            Set Label to "Printer"
113726>>>            Set Size to 10 37
113727>>>            Set Location to 30 10
113728>>>            Set Status_Help to "Send the report to the default printer"
113729>>>        End_Object
113730>>>
113730>>>        Object oFile is a Radio
113732>>>            Set Label to "File"
113733>>>            Set Size to 10 27
113734>>>            Set Location to 42 10
113735>>>            Set Status_Help to "Send the report to a file"
113736>>>        End_Object
113737>>>
113737>>>        Object oFileNameForm is a Form
113739>>>            Set Label to "FileName:"
113740>>>            Set Size to 13 116
113741>>>            Set Location to 40 50
113742>>>            Set Label_Col_Offset to 0
113743>>>            Set Label_Justification_Mode to jMode_Top
113744>>>            Set Prompt_Button_Mode to pb_PromptOn
113745>>>
113745>>>            Procedure Prompt
113748>>>                Boolean bOk
113748>>>                String sFileName sFilePath sDataPath
113748>>>                Integer hoWorkspace
113748>>>
113748>>>                Get Value To sFileName
113749>>>                If (sFileName <> "") Begin
113751>>>                    Set File_Name Of oSaveAsDialog to sFileName
113752>>>                    Get ExtractFilePath sFileName to sFilePath
113753>>>                End
113753>>>>
113753>>>                If (sFilePath = "") Begin
113755>>>                    Get phoWorkspace Of ghoApplication to hoWorkspace
113756>>>                    Get psDataPath Of hoWorkspace to sDataPath
113757>>>                    Get PathAtIndex Of hoWorkspace sDataPath 1 to sFilePath
113758>>>                End
113758>>>>
113758>>>
113758>>>                Set Initial_Folder Of oSaveAsDialog to sFilePath
113759>>>
113759>>>                Get Show_Dialog Of oSaveAsDialog to bOk
113760>>>                If (bOk) Begin
113762>>>                    Get File_Name Of oSaveAsDialog to sFileName
113763>>>                    Set Value To sFileName
113764>>>                End
113764>>>>
113764>>>            End_Procedure
113765>>>
113765>>>        End_Object
113766>>>
113766>>>        Procedure Notify_Select_State Integer iNewItem Integer iOldItem
113769>>>            Forward Send Notify_Select_State iNewItem iOldItem
113771>>>
113771>>>            Case Begin
113771>>>                Case (iNewItem = 0)
113773>>>                    Set Output_Device_Mode to PRINT_TO_WINDOW
113774>>>                    Case Break
113775>>>                Case (iNewItem = 1)
113778>>>                    Set Output_Device_Mode to PRINT_TO_PRINTER
113779>>>                    Case Break
113780>>>                Case (iNewItem = 2)
113783>>>                    Set Output_Device_Mode to PRINT_TO_FILE
113784>>>                    Case Break
113785>>>            Case End
113785>>>
113785>>>            Set Enabled_State Of oFileNameForm to (iNewItem = 2)
113786>>>        End_Procedure
113787>>>
113787>>>    End_Object
113788>>>
113788>>>    Object oOkButton is a Button
113790>>>        Set Label to "&OK"
113791>>>        Set Location to 66 71
113792>>>        Set Default_State to TRUE
113793>>>
113793>>>        Procedure OnClick
113796>>>            Send StartReport
113797>>>        End_Procedure
113798>>>
113798>>>    End_Object
113799>>>
113799>>>    Object oCancelButton is a Button
113801>>>        Set Label to "&Cancel"
113802>>>        Set Location to 66 126
113803>>>
113803>>>        Procedure OnClick
113806>>>            Send Request_Cancel
113807>>>        End_Procedure
113808>>>
113808>>>    End_Object
113809>>>
113809>>>    Object oSaveAsDialog is a SaveAsDialog
113811>>>    End_Object
113812>>>
113812>>>    Procedure StartReport
113815>>>        Integer iOutputDevice
113815>>>        Handle hoWorkspace
113815>>>        String sFileName sCurrentDirectory sDataPath
113815>>>
113815>>>        Get Output_Device_Mode to iOutputDevice
113816>>>
113816>>>        Case Begin
113816>>>            Case (iOutputDevice = PRINT_TO_WINDOW)
113818>>>                Get_Current_Directory to sCurrentDirectory
113819>>>                Get phoWorkspace Of ghoApplication to hoWorkspace
113820>>>                Get psDataPath Of hoWorkspace to sDataPath
113821>>>                Get PathAtIndex Of hoWorkspace sDataPath 1 to sDataPath
113822>>>                Set_Directory sDataPath
113823>>>                Make_Temp_File "TXT" sFileName
113824>>>                Set_Directory sCurrentDirectory
113825>>>                If (Right(sDataPath, 1) <> Sysconf(SYSCONF_DIR_SEPARATOR)) Begin
113827>>>                    Move (sDataPath - Sysconf(SYSCONF_DIR_SEPARATOR)) To sDataPath
113828>>>                End
113828>>>>
113828>>>                Move (sDataPath - sFileName) to sFileName
113829>>>                Set Output_Device_Name to sFileName
113830>>>                Case Break
113831>>>            Case (iOutputDevice = PRINT_TO_PRINTER)
113834>>>                Set Output_Device_Name to "WinLST:"
113835>>>                Case Break
113836>>>            Case (iOutputDevice = PRINT_TO_FILE)
113839>>>                Get Value Of oFileNameForm to sFileName
113840>>>                Set Output_Device_Name to sFileName
113841>>>                Case Break
113842>>>        Case End
113842>>>
113842>>>        Send Run_Report
113843>>>
113843>>>        If (iOutputDevice = PRINT_TO_WINDOW) Begin
113845>>>            //Runprogram Background "NotePad" sFileName
113845>>>            Runprogram Shell Background sFileName
113846>>>            EraseFile sFileName
113847>>>>
113847>>>        End
113847>>>>
113847>>>    End_Procedure
113848>>>
113848>>>    Object oBasicReport is a BasicReport
113850>>>
113850>>>        Function Starting_Main_Report Returns Integer
113853>>>            Integer iRetval
113853>>>
113853>>>            Forward Get Starting_Main_Report to iRetval
113855>>>
113855>>>            Function_Return iRetval
113856>>>        End_Function
113857>>>
113857>>>        Procedure_Section Report_Header as Header
113862>>>            DateTime dtCreationTime
113862>>>            String sFilelistFrom sFilelistTo
113862>>>
113862>>>            Get psFilelistFrom to sFilelistFrom
113863>>>            Get psFilelistTo   to sFilelistTo
113864>>>            Move (CurrentDateTime()) to dtCreationTime
113865>>>
113865>>>            Print sFilelistFrom
113866>>>            Print sFilelistTo
113867>>>            Print dtCreationTime
113868>>>            Output_PageCheck Header
113869>>>        End_Procedure
113870>>>
113870>>>        Procedure_Section Page_Top as Top
113875>>>            Integer iPage
113875>>>
113875>>>            Get Page_Count to iPage
113876>>>            Print iPage
113877>>>            OutPut_PageCheck
113878>>>        End_Procedure
113879>>>
113879>>>        Procedure_Section SubHeaderFields as SubHeader
113884>>>            Print "Field"
113885>>>            Print "Table#"
113886>>>            Print "Table Name"
113887>>>        End_Procedure
113888>>>
113888>>>        Procedure_Section Body as BodyFields
113893>>>            Forward Send Body
113895>>>            // Print File.Field // Gets printed at BodySection.1
113895>>>            // Print Variable // Gets printed at BodySection.2
113895>>>            // Output_PageCheck // Without this nothing gets printed
113895>>>        End_Procedure
113896>>>
113896>>>//        Procedure_Section Page_Bottom as FooterSection
113896>>>//            Forward Send Page_Bottom
113896>>>//            // Output_PageCheck // Without this nothing gets printed
113896>>>//        End_Procedure
113896>>>
113896>>>        Procedure_Section Total as Footer
113901>>>            Integer iDifferences
113901>>>            Get piDifferences to iDifferences
113902>>>            Print iDifferences
113903>>>        End_Procedure
113904>>>
113904>>>    End_Object
113905>>>
113905>>>    On_Key Key_Alt+Key_O Send KeyAction of oOkButton
113906>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancelButton
113907>>>
113907>>>End_Object
113908>        Procedure Activate_About
113911>            Send DoAbout "" "" ("Copyright 2016-2020" * psCompany(ghoApplication)) "Author: Nils Svedmyr" "DUFUpdateCodeGenerator64x64.bmp" "E-mail: mailto:support@rdctools.com" "Web-site: www.rdctools.com" ("This tool was created with DataFlex" * String(C_DFVersion) * "from Data Access Worldwide. Please visit http://www.dataaccess.com for a free personal copy of DataFlex.")
113912>        End_Procedure
113913>
113913>        On_Key Key_Ctrl+Key_Tab           Send Switch_Next_View
113914>        On_Key Key_Ctrl+Key_Shift+Key_Tab Send Switch_Prior_View
113915>    End_Object
113916>
113916>    // Note that we have overriden the cHtmlHelp "GetHelpFile" function
113916>    // in the oHtmlHelp object, so we need to explitetly send the message
113916>    // to that object.
113916>    Procedure ShowProgramHelp
113919>        Set psHelpFile of ghoApplication to "Developer5.chm"
113920>        Send DoDisplayKeyword of oHtmlHelp "DUF Code Generator"
113921>    End_Procedure
113922>
113922>    Procedure ActivateCompareView
113925>        Send Execute of (oCompareDatabases_MenuItem(ghoCommandBars))
113926>    End_Procedure
113927>
113927>    Procedure ActivateGenerateView
113930>        Send Execute of (oCodeGenerator_MenuItem(ghoCommandBars))
113931>    End_Procedure
113932>
113932>    On_Key Key_Alt+Key_D   Send ActivateCompareView
113933>    On_Key Key_Ctrl+Key_D  Send ActivateCompareView
113934>    On_Key Key_Alt+Key_G   Send ActivateGenerateView
113935>    On_Key Key_Ctrl+Key_G  Send ActivateGenerateView    
113936>    On_Key Key_F1          Send ShowProgramHelp
113937>End_Object
113938>
113938>Send Execute of (oCodeGenerator_MenuItem(ghoCommandBars))
113939>Start_UI
113940>
Including Resources...
Summary
Memory Available: 2147483646
Total Warnings : 0
Total Errors   : 0
Total Symbols  : 57752
Total Resources: 6
Total Commands : 113939
Total Windows  : 20
Total Pages    : 5
Static Data    : 954853
Message area   : 675364
Total Blocks   : 40300
