Compiling Program: C:\Projects\DF20\DbUpdateFramework\AppSrc\DUFCodeGenerator.src
Memory Available: 2147483646
1>    CompilerLevelWarning All On
1>Use DFAllEnt.pkg
Using pre-compiled package DFALLENT.PKG
Including file: dfallent.pkd    (C:\Program Files (x86)\DataFlex 19.1\Pkg\dfallent.pkd)
67438>Use cCJStandardCommandBarSystem.pkg
Including file: cCJStandardCommandBarSystem.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCJStandardCommandBarSystem.pkg)
67438>>>// these are all the packages used in a standard MDI menubar/toolbar system
67438>>>
67438>>>Use cCJCommandBarSystem.pkg
67438>>>Use cCJStandardMenuItemClasses.pkg
Including file: cCJStandardMenuItemClasses.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCJStandardMenuItemClasses.pkg)
67438>>>>>Use Dfpanel.pkg
67438>>>>>Use cCJCommandBarSystem.pkg
67438>>>>>Use LanguageText.pkg
67438>>>>>
67438>>>>>
67438>>>>>Class cCJUndoMenuItem is a cCJMenuItem
67439>>>>>    
67439>>>>>    Procedure Construct_Object
67441>>>>>        Forward Send Construct_Object
67443>>>>>        Set psCaption   to C_$CaptionUndo
67444>>>>>        Set psToolTip to C_$ToolTipUndo
67445>>>>>        Set psDescription to C_$DescUndo
67446>>>>>        Set psImage to "ActionUndo.ico"
67447>>>>>        Set pbActiveUpdate to True
67448>>>>>        Set psCategory to C_$CategoryEdit
67449>>>>>        Set psShortcut to C_$Key_Ctrl_Z
67450>>>>>    End_Procedure
67451>>>>>    
67451>>>>>    Procedure OnExecute Variant vCommandBarControl
67453>>>>>        Send Undo of (focus(Self))
67454>>>>>    End_Procedure
67455>>>>>    
67455>>>>>    Function IsEnabled Returns Boolean
67457>>>>>        Boolean bEnabled
67457>>>>>        Get CanUndo of (Focus(Self)) to bEnabled
67458>>>>>        Function_Return bEnabled
67459>>>>>    End_Function
67460>>>>>    
67460>>>>>End_Class
67461>>>>>
67461>>>>>
67461>>>>>Class cCJDeleteEditMenuItem is a cCJMenuItem
67462>>>>>    
67462>>>>>    Procedure Construct_Object
67464>>>>>        Forward Send Construct_Object
67466>>>>>        Set psCaption   to C_$CaptionDelete
67467>>>>>        Set psToolTip to C_$ToolTipDelete
67468>>>>>        Set psDescription to C_$DescDelete
67469>>>>>        Set psImage to "actionDelete.ico"
67470>>>>>        Set psShortcut to C_$Key_Delete
67471>>>>>        Set pbActiveUpdate to True
67472>>>>>        Set psCategory to C_$CategoryEdit
67473>>>>>    End_Procedure
67474>>>>>    
67474>>>>>    
67474>>>>>    Procedure OnExecute Variant vCommandBarControl
67476>>>>>        Send Delete of (focus(Self))
67477>>>>>    End_Procedure
67478>>>>>    
67478>>>>>    Function IsEnabled Returns Boolean
67480>>>>>        Boolean bEnabled
67480>>>>>        Get CanDelete of (Focus(Self)) to bEnabled
67481>>>>>        Function_Return bEnabled
67482>>>>>    End_Function
67483>>>>>    
67483>>>>>End_Class
67484>>>>>
67484>>>>>
67484>>>>>Class cCJCutMenuItem is a cCJMenuItem
67485>>>>>    
67485>>>>>    Procedure Construct_Object
67487>>>>>        Forward Send Construct_Object
67489>>>>>        Set psCaption   to C_$CaptionCut
67490>>>>>        Set psToolTip to C_$TooltipCut
67491>>>>>        Set psDescription to C_$DescCut
67492>>>>>        Set psImage to "actionCut.ico"
67493>>>>>        Set psShortcut to C_$Key_Ctrl_X
67494>>>>>        Set pbActiveUpdate to True
67495>>>>>        Set psCategory to C_$CategoryEdit
67496>>>>>    End_Procedure
67497>>>>>    
67497>>>>>    
67497>>>>>    Procedure OnExecute Variant vCommandBarControl
67499>>>>>        Send Cut of (focus(Self))
67500>>>>>    End_Procedure
67501>>>>>    
67501>>>>>    Function IsEnabled Returns Boolean
67503>>>>>        Boolean bEnabled
67503>>>>>        Get CanCut of (Focus(Self)) to bEnabled
67504>>>>>        Function_Return bEnabled
67505>>>>>    End_Function
67506>>>>>    
67506>>>>>End_Class
67507>>>>>
67507>>>>>
67507>>>>>Class cCJCopyMenuItem is a cCJMenuItem
67508>>>>>    
67508>>>>>    Procedure Construct_Object
67510>>>>>        Forward Send Construct_Object
67512>>>>>        Set psCaption   to C_$CaptionCopy
67513>>>>>        Set psToolTip to C_$ToolTipCopy
67514>>>>>        Set psDescription to C_$DescCopy
67515>>>>>        Set psImage to "actionCopy.ico"
67516>>>>>        Set psShortcut to C_$Key_Ctrl_C
67517>>>>>        Set pbActiveUpdate to True
67518>>>>>        Set psCategory to C_$CategoryEdit
67519>>>>>    End_Procedure
67520>>>>>    
67520>>>>>    
67520>>>>>    Procedure OnExecute Variant vCommandBarControl
67522>>>>>        Send Copy of (focus(Self))
67523>>>>>    End_Procedure
67524>>>>>    
67524>>>>>    Function IsEnabled Returns Boolean
67526>>>>>        Boolean bEnabled
67526>>>>>        Get CanCopy of (Focus(Self)) to bEnabled
67527>>>>>        Function_Return bEnabled
67528>>>>>    End_Function
67529>>>>>    
67529>>>>>End_Class
67530>>>>>
67530>>>>>
67530>>>>>Class cCJPasteMenuItem is a cCJMenuItem
67531>>>>>    
67531>>>>>    Procedure Construct_Object
67533>>>>>        Forward Send Construct_Object
67535>>>>>        Set psCaption   to C_$CaptionPaste
67536>>>>>        Set psToolTip to C_$ToolTipPaste
67537>>>>>        Set psDescription to C_$DescPaste
67538>>>>>        Set psImage to "actionPaste.ico"
67539>>>>>        Set pbActiveUpdate to True
67540>>>>>        Set psShortcut to C_$Key_Ctrl_V
67541>>>>>        Set psCategory to C_$CategoryEdit
67542>>>>>    End_Procedure
67543>>>>>    
67543>>>>>    
67543>>>>>    Procedure OnExecute Variant vCommandBarControl
67545>>>>>        Send Paste of (focus(Self))
67546>>>>>    End_Procedure
67547>>>>>    
67547>>>>>    Function IsEnabled Returns Boolean
67549>>>>>        Boolean bEnabled
67549>>>>>        Get CanPaste of (Focus(Self)) to bEnabled
67550>>>>>        Function_Return bEnabled
67551>>>>>    End_Function
67552>>>>>    
67552>>>>>End_Class
67553>>>>>
67553>>>>>Class cCJSelectAllMenuItem is a cCJMenuItem
67554>>>>>    
67554>>>>>    Procedure Construct_Object
67556>>>>>        Forward Send Construct_Object
67558>>>>>        Set psCaption   to C_$CaptionSelectAll
67559>>>>>        Set psToolTip to C_$ToolTipSelectAll
67560>>>>>        Set psDescription to C_$DescSelectAll
67561>>>>>        Set pbActiveUpdate to True
67562>>>>>        Set psShortcut to C_$Key_Ctrl_A
67563>>>>>        Set psCategory to C_$CategoryEdit
67564>>>>>    End_Procedure
67565>>>>>    
67565>>>>>    
67565>>>>>    Procedure OnExecute Variant vCommandBarControl
67567>>>>>        Send Select_All of (focus(Self))
67568>>>>>    End_Procedure
67569>>>>>    
67569>>>>>    Function IsEnabled Returns Boolean
67571>>>>>        Boolean bEnabled
67571>>>>>        Get CanSelect of (Focus(Self)) to bEnabled
67572>>>>>        Function_Return bEnabled
67573>>>>>    End_Function
67574>>>>>    
67574>>>>>End_Class
67575>>>>>
67575>>>>>
67575>>>>>Class cCJExitMenuItem is a cCJMenuItem
67576>>>>>    
67576>>>>>    Procedure Construct_Object
67578>>>>>        Forward Send Construct_Object
67580>>>>>        Set psCaption to C_$CaptionExit
67581>>>>>        Set psToolTip to C_$ToolTipExit
67582>>>>>        Set psDescription to C_$ToolTipExit
67583>>>>>        Set psShortcut to C_$Key_Alt_F4
67584>>>>>        Set psCategory to C_$CategoryFile
67585>>>>>    End_Procedure
67586>>>>>    
67586>>>>>    Procedure OnExecute Variant vCommandBarControl
67588>>>>>        Send Exit_Application of Desktop
67589>>>>>    End_Procedure
67590>>>>>    
67590>>>>>End_Class
67591>>>>>
67591>>>>>Class cCJHelpMenuItem is a cCJMenuItem
67592>>>>>    
67592>>>>>    Procedure Construct_Object
67594>>>>>        Forward Send Construct_Object
67596>>>>>        Set psCaption to C_$CaptionHelp
67597>>>>>        Set psDescription to C_$ToolTipHelp
67598>>>>>        Set psToolTip to C_$DescHelp
67599>>>>>        Set psImage to "ActionHelp.ico"
67600>>>>>        Set psShortcut to "F1"
67601>>>>>        Set psCategory to C_$CategoryHelp
67602>>>>>    End_Procedure
67603>>>>>    
67603>>>>>    Procedure OnExecute Variant vCommandBarControl
67605>>>>>        Send Help of (Focus(Self))
67606>>>>>    End_Procedure
67607>>>>>    
67607>>>>>End_Class
67608>>>>>
67608>>>>>Class cCJStatusbarMenuItem is a cCJMenuItem
67609>>>>>    
67609>>>>>    Procedure Construct_Object
67611>>>>>        Forward Send Construct_Object
67613>>>>>        Set psCaption to C_$CaptionAddStatusbar
67614>>>>>        Set psToolTip to C_$ToolTipAddStatusbar
67615>>>>>        Set psDescription to  C_$DescAddStatusbar
67616>>>>>        Set psCategory to C_$CategoryWindow
67617>>>>>    End_Procedure
67618>>>>>    
67618>>>>>    Procedure OnExecute Variant vCommandBarControl
67620>>>>>        Handle hoCommandBars hoClientArea
67620>>>>>        Get CommandBarSystemObject to hoCommandBars
67621>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67622>>>>>        If hoClientArea Begin
67624>>>>>            // the clientarea's parent panel has message
67624>>>>>            Send Toggle_StatusBar of (Parent(hoClientArea))
67625>>>>>        End
67625>>>>>>
67625>>>>>    End_Procedure
67626>>>>>    
67626>>>>>    Function IsChecked Returns Boolean
67628>>>>>        Boolean bOn
67628>>>>>        Handle hoCommandBars hoClientArea
67628>>>>>        Get CommandBarSystemObject to hoCommandBars
67629>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67630>>>>>        If hoClientArea Begin
67632>>>>>            // the clientarea's parent panel has message
67632>>>>>            Get StatusBar_State of (Parent(hoClientArea)) to bOn
67633>>>>>        End
67633>>>>>>
67633>>>>>        Function_Return bOn
67634>>>>>    End_Function
67635>>>>>End_Class
67636>>>>>
67636>>>>>Class cCJAutoArrangeIconsMenuItem is a cCJMenuItem
67637>>>>>    
67637>>>>>    Procedure Construct_Object
67639>>>>>        Forward Send Construct_Object
67641>>>>>        Set psCaption to C_$CaptionAutoArrangeIcons
67642>>>>>        Set psToolTip to C_$ToolTipAutoArrangeIcons
67643>>>>>        Set psDescription to C_$DescAutoArrangeIcons
67644>>>>>        Set psCategory to C_$CategoryWindow
67645>>>>>    End_Procedure
67646>>>>>    
67646>>>>>    Procedure OnExecute Variant vCommandBarControl
67648>>>>>        Handle hoCommandBars hoClientArea
67648>>>>>        Get CommandBarSystemObject to hoCommandBars
67649>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67650>>>>>        If hoClientArea Begin
67652>>>>>            // the clientarea's parent panel has message
67652>>>>>            Send Toggle_Auto_Arrange_Icons of (Parent(hoClientArea))
67653>>>>>        End
67653>>>>>>
67653>>>>>    End_Procedure
67654>>>>>    
67654>>>>>    Function IsChecked Returns Boolean
67656>>>>>        Boolean bOn
67656>>>>>        Handle hoCommandBars hoClientArea
67656>>>>>        Get CommandBarSystemObject to hoCommandBars
67657>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67658>>>>>        If hoClientArea Begin
67660>>>>>            // the clientarea's parent panel has message
67660>>>>>            Get Auto_Arrange_Icons_State of (Parent(hoClientArea)) to bOn
67661>>>>>        End
67661>>>>>>
67661>>>>>        Function_Return bOn
67662>>>>>    End_Function
67663>>>>>End_Class
67664>>>>>
67664>>>>>Class cCJRestoreMenusMenuItem is a cCJMenuItem
67665>>>>>    
67665>>>>>    Procedure Construct_Object
67667>>>>>        Forward Send Construct_Object
67669>>>>>        Set psCaption to C_$CaptionRestoreMenus
67670>>>>>        Set psToolTip to C_$ToolTipRestoreMenus
67671>>>>>        Set psDescription to C_$DescRestoreMenus
67672>>>>>        Set psCategory to C_$CategoryWindow
67673>>>>>    End_Procedure
67674>>>>>    
67674>>>>>    Procedure OnExecute Variant vCommandBarControl
67676>>>>>        Handle hoCommandBars
67676>>>>>        Get CommandBarSystemObject to hoCommandBars
67677>>>>>        Send RestoreLayout of hoCommandBars
67678>>>>>    End_Procedure
67679>>>>>    
67679>>>>>End_Class
67680>>>>>
67680>>>>>Class cCJCascadeMenuItem is a cCJMenuItem
67681>>>>>    
67681>>>>>    Procedure Construct_Object
67683>>>>>        Forward Send Construct_Object
67685>>>>>        Set psCaption to C_$CaptionCascade
67686>>>>>        Set psToolTip to C_$ToolTipCascade
67687>>>>>        Set psDescription to  C_$DescCascade
67688>>>>>        Set psImage to "ActionCascade.ico"
67689>>>>>        Set psCategory to C_$CategoryWindow
67690>>>>>    End_Procedure
67691>>>>>    
67691>>>>>    Procedure OnExecute Variant vCommandBarControl
67693>>>>>        Handle hoCommandBars hoClientArea
67693>>>>>        Get CommandBarSystemObject to hoCommandBars
67694>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67695>>>>>        If hoClientArea Begin
67697>>>>>            Send Cascade_Windows of hoClientArea
67698>>>>>        End
67698>>>>>>
67698>>>>>    End_Procedure
67699>>>>>End_Class
67700>>>>>
67700>>>>>Class cCJTileHorizontally is a cCJMenuItem
67701>>>>>    
67701>>>>>    Procedure Construct_Object
67703>>>>>        Forward Send Construct_Object
67705>>>>>        Set psCaption to C_$CaptionTileHorizontally
67706>>>>>        Set psToolTip to C_$ToolTipTileHorizontally
67707>>>>>        Set psDescription to  C_$DescTileHorizontally
67708>>>>>        Set psImage to "ActionTileHorizontally.ico"
67709>>>>>        Set psCategory to C_$CategoryWindow
67710>>>>>    End_Procedure
67711>>>>>    
67711>>>>>    Procedure OnExecute Variant vCommandBarControl
67713>>>>>        Handle hoCommandBars hoClientArea
67713>>>>>        Get CommandBarSystemObject to hoCommandBars
67714>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67715>>>>>        If hoClientArea Begin
67717>>>>>            Send Tile_Windows_Horizontal of hoClientArea
67718>>>>>        End
67718>>>>>>
67718>>>>>    End_Procedure
67719>>>>>End_Class
67720>>>>>
67720>>>>>Class cCJTileVertically is a cCJMenuItem
67721>>>>>    
67721>>>>>    Procedure Construct_Object
67723>>>>>        Forward Send Construct_Object
67725>>>>>        Set psCaption to C_$CaptionTileVertically
67726>>>>>        Set psToolTip to C_$ToolTipTileVertically
67727>>>>>        Set psDescription to  C_$DescTileVertically
67728>>>>>        Set psImage to "ActionTileVertically.ico"
67729>>>>>        Set psCategory to C_$CategoryWindow
67730>>>>>    End_Procedure
67731>>>>>    
67731>>>>>    Procedure OnExecute Variant vCommandBarControl
67733>>>>>        Handle hoCommandBars hoClientArea
67733>>>>>        Get CommandBarSystemObject to hoCommandBars
67734>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67735>>>>>        If hoClientArea Begin
67737>>>>>            Send Tile_Windows_Vertical of hoClientArea
67738>>>>>        End
67738>>>>>>
67738>>>>>    End_Procedure
67739>>>>>End_Class
67740>>>>>
67740>>>>>Class cCJMinimizeWindowsMenuItem is a cCJMenuItem
67741>>>>>    
67741>>>>>    Procedure Construct_Object
67743>>>>>        Forward Send Construct_Object
67745>>>>>        Set psCaption to C_$CaptionMinimizeWindows
67746>>>>>        Set psToolTip to C_$ToolTipMinimizeWindows
67747>>>>>        Set psDescription to  C_$DescMinimizeWindows
67748>>>>>        Set psCategory to C_$CategoryWindow
67749>>>>>    End_Procedure
67750>>>>>    
67750>>>>>    Procedure OnExecute Variant vCommandBarControl
67752>>>>>        Handle hoCommandBars hoClientArea
67752>>>>>        Get CommandBarSystemObject to hoCommandBars
67753>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67754>>>>>        If hoClientArea Begin
67756>>>>>            // the clientarea's parent panel has message
67756>>>>>            Send Minimize_all_Windows of (Parent(hoClientArea))
67757>>>>>        End
67757>>>>>>
67757>>>>>    End_Procedure
67758>>>>>End_Class
67759>>>>>
67759>>>>>
67759>>>>>Class cCJRestoreWindowsMenuItem is a cCJMenuItem
67760>>>>>    
67760>>>>>    Procedure Construct_Object
67762>>>>>        Forward Send Construct_Object
67764>>>>>        Set psCaption to C_$CaptionRestoreWindows
67765>>>>>        Set psToolTip to C_$ToolTipRestoreWindows
67766>>>>>        Set psDescription to  C_$DescRestoreWindows
67767>>>>>        Set psCategory to C_$CategoryWindow
67768>>>>>    End_Procedure
67769>>>>>    
67769>>>>>    Procedure OnExecute Variant vCommandBarControl
67771>>>>>        Handle hoCommandBars hoClientArea
67771>>>>>        Get CommandBarSystemObject to hoCommandBars
67772>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67773>>>>>        If hoClientArea Begin
67775>>>>>            // the clientarea's parent panel has message
67775>>>>>            Send Restore_all_Windows of (Parent(hoClientArea))
67776>>>>>        End
67776>>>>>>
67776>>>>>    End_Procedure
67777>>>>>End_Class
67778>>>>>
67778>>>>>Class cCJArrangeIconsMenuItem is a cCJMenuItem
67779>>>>>    
67779>>>>>    Procedure Construct_Object
67781>>>>>        Forward Send Construct_Object
67783>>>>>        Set psCaption to C_$CaptionArrangeIcons
67784>>>>>        Set psToolTip to C_$ToolTipArrangeIcons
67785>>>>>        Set psDescription to  C_$DescArrangeIcons
67786>>>>>        Set psCategory to C_$CategoryWindow
67787>>>>>    End_Procedure
67788>>>>>    
67788>>>>>    Procedure OnExecute Variant vCommandBarControl
67790>>>>>        Handle hoCommandBars hoClientArea
67790>>>>>        Get CommandBarSystemObject to hoCommandBars
67791>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67792>>>>>        If hoClientArea Begin
67794>>>>>            Send Arrange_Icons of hoClientArea
67795>>>>>        End
67795>>>>>>
67795>>>>>    End_Procedure
67796>>>>>    
67796>>>>>End_Class
67797>>>Use cCJAboutMenuItem.pkg
Including file: cCJAboutMenuItem.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCJAboutMenuItem.pkg)
67797>>>>>Use cCJCommandBarSystem.pkg
67797>>>>>Use LanguageText.pkg
67797>>>>>
67797>>>>>// It is expected that if you use this class that you provide an about object that is
67797>>>>>// activated via activate_about such as DfAbout.pkg. We don't use this for you automatically
67797>>>>>// because you may wish to create your own custom about package.
67797>>>>>
67797>>>>>Class cCJAboutMenuItem is a cCJMenuItem    
67798>>>>>
67798>>>>>    Procedure Construct_Object
67800>>>>>        Forward Send Construct_Object
67802>>>>>        Set psCaption to C_$CaptionAbout
67803>>>>>        Set psDescription to C_$ToolTipAbout
67804>>>>>        Set psToolTip to C_$DescAbout
67805>>>>>        Set psImage to "ActionAbout.ico"
67806>>>>>        Set psCategory to C_$CategoryHelp
67807>>>>>    End_Procedure
67808>>>>>    
67808>>>>>    Procedure OnExecute Variant vCommandBarControl
67810>>>>>        Handle hoCommandBars hoClientArea
67810>>>>>        Get CommandBarSystemObject to hoCommandBars
67811>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67812>>>>>        If hoClientArea Begin
67814>>>>>            Send Activate_About of hoClientArea
67815>>>>>        End
67815>>>>>>
67815>>>>>    End_Procedure
67816>>>>>
67816>>>>>End_Class
67817>>>>>
67817>>>>>
67817>>>Use cCJDeoMenuItemClasses.pkg
67817>>>Use cCJMDIWindowsMenuItem.pkg
Including file: cCJMDIWindowsMenuItem.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCJMDIWindowsMenuItem.pkg)
67817>>>>>Use cCJCommandBarSystem.pkg
67817>>>>>
67817>>>>>Register_Function Client_ID Returns Integer
67817>>>>>
67817>>>>>// only used by cCJMDIWIndowsMenuItem
67817>>>>>Class cCJMDIWindowItem is a cCJMenuItem
67818>>>>>    
67818>>>>>    Procedure Construct_Object
67820>>>>>        Forward Send Construct_Object
67822>>>>>        Property Handle phWindow 0 // object id of view
67823>>>>>        Set pbControlFlagNoMovable to True
67824>>>>>        Set pbActiveUpdate to True
67825>>>>>    End_Procedure
67826>>>>>    
67826>>>>>    Procedure OnExecute Variant vCommandBarControl
67828>>>>>        Handle hWindow
67828>>>>>        Get phWindow to hWindow
67829>>>>>        Send Activate_View of hWindow
67830>>>>>    End_Procedure
67831>>>>>    
67831>>>>>End_Class
67832>>>>>
67832>>>>>
67832>>>>>Class cCJMDIWindowsMenuItem is a cCJMenuItem
67833>>>>>    
67833>>>>>    Procedure Construct_Object
67835>>>>>        Forward Send Construct_Object
67837>>>>>        Property Handle[] phArrayOfWindows
67838>>>>>        Set peControlType to xtpControlPopup
67839>>>>>        Set psCategory to C_$CategoryWindow
67840>>>>>    End_Procedure
67841>>>>>    
67841>>>>>    // This adds MDI windows to the existing menu items.
67841>>>>>    // This removes any existing windows menus and always adds a new set to the end
67841>>>>>    
67841>>>>>    Procedure OnPopupInit Variant vCommandBarControl Handle hCommandBarControls
67843>>>>>        Handle  hClientArea hView
67843>>>>>        String  sLabel
67843>>>>>        Integer i iWindows
67843>>>>>        Handle[] hArrayOfWindows
67844>>>>>        Variant vItem
67844>>>>>        
67844>>>>>        // delete all windows actions and menu items. Assume we have an array of DF action objects for the windows
67844>>>>>        // also assume that destroying an action removes all menu instances of that action
67844>>>>>        Get phArrayOfWindows to hArrayOfWindows
67845>>>>>        Move (SizeOfArray(hArrayOfWindows)) to iWindows
67846>>>>>        For i from 0 to (iWindows-1)
67852>>>>>>
67852>>>>>            Send Destroy of hArrayOfWindows[i] // assume this removes all menu items of this action
67853>>>>>        Loop
67854>>>>>>
67854>>>>>        Move (ResizeArray(hArrayOfWindows,0)) to hArrayOfWindows
67855>>>>>        
67855>>>>>        // Add all views to this menu. Create the action and add the item
67855>>>>>        Move 0 to i
67856>>>>>        Get Client_Id to hClientArea // object id of client area
67857>>>>>        If (hClientArea > 0) Begin
67859>>>>>            Get Next_Mdi_Dialog of hClientArea True to hView // find first view
67860>>>>>            While (hView <> 0)
67864>>>>>                If (Active_State(hView)) Begin
67866>>>>>                    // create the action
67866>>>>>                    Get Create U_cCJMDIWindowItem to hArrayOfWindows[i]
67867>>>>>                    Get Label of hView to sLabel // caption bar (name) of view
67868>>>>>                    Set psCaption of hArrayOfWindows[i] to sLabel
67869>>>>>                    Set psDescription of hArrayOfWindows[i] to ("Make this view (" - trim(sLabel) - ") the active window.")
67870>>>>>                    If (current_scope(desktop)=hView and View_mode(hView)<>VIEWMODE_ICONIZE) Begin
67872>>>>>                        Set pbChecked of hArrayOfWindows[i] to True
67873>>>>>                    End
67873>>>>>>
67873>>>>>                    Set phWindow of hArrayOfWindows[i] to hView // used by custom OnExecute
67874>>>>>                    If (i=0) Begin
67876>>>>>                        Set pbControlBeginGroup of hArrayOfWindows[i] to True
67877>>>>>                    End
67877>>>>>>
67877>>>>>                    // Create a menu item for this action
67877>>>>>                    Get AddDynamicControl of hArrayOfWindows[i] hCommandBarControls to vItem
67878>>>>>                    Increment i
67879>>>>>                End
67879>>>>>>
67879>>>>>                Get Next_Mdi_Dialog of hClientArea False to hView // find next
67880>>>>>            Loop
67881>>>>>>
67881>>>>>        End
67881>>>>>>
67881>>>>>        
67881>>>>>        Set phArrayOfWindows to hArrayOfWindows
67882>>>>>        
67882>>>>>    End_Procedure
67883>>>>>    
67883>>>>>End_Class
67884>Use cCJCommandBarSystem.pkg
67884>Use Dferror.pkg
67884>Use Colr_dlg.pkg
Including file: Colr_dlg.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\Colr_dlg.pkg)
67884>>>Use VDFBase.pkg
67884>>>Use DLL.pkg
67884>>>Use RGB.pkg
67884>>>Use GlobalFunctionsProcedures.pkg
67884>>>
67884>>>
67884>>>External_Function ChooseColor 'ChooseColorA' COMDLG32.dll Pointer lpCC Returns DWord
67885>>>
67885>>>
67885>>>Class ColorDialog is a cObject
67886>>>    Procedure Construct_Object
67888>>>        Integer iLoop
67888>>>        Handle hoCustomColors
67888>>>        
67888>>>        Forward Send Construct_Object
67890>>>        
67890>>>        Property Boolean FullOpen_State        True
67891>>>        Property Boolean PreventFullOpen_State False
67892>>>        Property Boolean SelectedColor_State   True
67893>>>        Property Integer SelectedColor         0
67894>>>        
67894>>>        Property Handle phoCustomColors (Create(Self, U_Array)) // create an array to hold the custom colors
67895>>>        
67895>>>        // Set all custom colors to white...
67895>>>        Get phoCustomColors to hoCustomColors
67896>>>        For iLoop from 0 to 15
67902>>>>
67902>>>            Set Value of hoCustomColors iLoop to clWhite
67903>>>        Loop
67904>>>>
67904>>>        
67904>>>    End_Procedure
67905>>>    
67905>>>    Procedure Set Custom_Color Integer iItem Integer rgbColor
67907>>>        Set Value of (phoCustomColors(Self)) iItem to rgbColor
67908>>>    End_Procedure
67909>>>    
67909>>>    Function Custom_Color Integer iItem Returns Integer
67911>>>        Function_Return (Integer_Value(phoCustomColors(Self), iItem))
67912>>>    End_Function
67913>>>    
67913>>>    Procedure AssignCustomColors Handle hoSourceColorDialog
67915>>>        // Copies the custom colors from another ColorDialog instance
67915>>>        Integer iColor
67915>>>        
67915>>>        For iColor from 0 to 15
67921>>>>
67921>>>            Set Custom_Color iColor to (Value(hoSourceColorDialog, iColor))
67922>>>        Loop
67923>>>>
67923>>>    End_Procedure
67924>>>    
67924>>>    Function Value Integer iItem Returns String
67926>>>        // Provides support for the AssignCustomColors procedure, which requires
67926>>>        // that a "Get Value" interface is supported
67926>>>        Function_Return (Custom_Color(Self, iItem))
67927>>>    End_Function
67928>>>    
67928>>>    Function OwnerHandle Returns Handle
67930>>>        Handle hWnd
67930>>>        Handle hoObj
67930>>>        Get Focus of desktop to hoObj // start with the focus
67931>>>        Move (gOwnerWindowHandle(hoObj)) to hWnd // global function finds the right handle for us
67932>>>        Function_Return hWnd
67933>>>    End_Function
67934>>>    
67934>>>    Function Show_Dialog Returns Boolean
67936>>>        //Shows the dialog. Returns True if the OK button was clicked.
67936>>>        Handle  hContainer hoCustomColors
67936>>>        Boolean bSelected bFullOpen bNoOpen bSelColor
67936>>>        Integer rgbColor iFlags iLoop
67936>>>        String sCC sColors
67936>>>        tWinChooseColor ChseColor
67936>>>        tWinChooseColor ChseColor
67936>>>        
67936>>>        Get OwnerHandle to hContainer
67937>>>        
67937>>>        Get phoCustomColors to hoCustomColors
67938>>>        
67938>>>        Move '' to sColors
67939>>>        For iLoop from 0 to 15
67945>>>>
67945>>>            Get Value of hoCustomColors iLoop to rgbColor
67946>>>            Move (sColors + DWORDToBytes(rgbColor)) to sColors
67947>>>        Loop
67948>>>>
67948>>>        
67948>>>        Get FullOpen_State        to bFullOpen
67949>>>        Get PreventFullOpen_State to bNoOpen
67950>>>        Get SelectedColor_State   to bSelColor
67951>>>        Get SelectedColor         to rgbColor
67952>>>        
67952>>>        Move 0 to iFlags
67953>>>        If bFullOpen ;            Move (iFlags +CC_FULLOPEN)        to iFlags
67956>>>        If bNoOpen ;            Move (iFlags +CC_PREVENTFULLOPEN) to iFlags
67959>>>        If bSelColor ;            Move (iFlags +CC_RGBINIT)         to iFlags
67962>>>        
67962>>>        Move (SizeOfType(tWinChooseColor))     to ChseColor.lStructSize
67963>>>        Move hContainer           to ChseColor.hWndOWner
67964>>>        Move rgbColor             to ChseColor.rgbResult
67965>>>        Move (AddressOf(sColors)) to ChseColor.lpCustColors
67966>>>        Move iFlags               to ChseColor.flags
67967>>>        
67967>>>        Move (ChooseColor(AddressOf(ChseColor))) to bSelected
67968>>>        
67968>>>        If bSelected Begin
67970>>>            For iLoop from 0 to 15
67976>>>>
67976>>>                Move (DeRefDw(AddressOf(sColors), iLoop *4)) to rgbColor
67977>>>                Set Value of hoCustomColors iLoop to rgbColor
67978>>>            Loop
67979>>>>
67979>>>            Move ChseColor.rgbResult to rgbColor
67980>>>            Set SelectedColor to rgbColor
67981>>>        End
67981>>>>
67981>>>        Function_Return bSelected
67982>>>    End_Function
67983>>>    
67983>>>End_Class
67984>>>
67984>Use Cursor.pkg
67984>// Unmark this Define statement if using Mertech drivers!
67984>Define DUF_Use_Mertech_Drivers
67984>Use cDbUpdateHandler.pkg
Including file: cDbUpdateHandler.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateHandler.pkg)
67984>>>//****************************************************************************
67984>>>// $Module type: Class
67984>>>// $Module name: cDbUpdateHandler
67984>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
67984>>>// Web-site    : http://www.rdctools.com
67984>>>// Created     : 2016-09-27 @ 09:33 (Military date format: YY-MM-DD)
67984>>>//
67984>>>// Purpose     : A framework for doing automated code based updates of a database from within
67984>>>//               a program, when it is started.
67984>>>//
67984>>>// Description : Place _one_ object of this class right after the cApplication object.
67984>>>//               Then inside this object place a series of cDbUpdateVersion objects
67984>>>//               as childs. One child object for each new database update.
67984>>>//
67984>>>//               - OnPreUpdate is a pre-processing event called
67984>>>//               before any database changes are started.
67984>>>//               - OnPostUpdate is a post-processing event called after all
67984>>>//               database changes have taken place.
67984>>>//
67984>>>// Note        : If tables have been opened prior to an object of this class
67984>>>//               (e.g. in the cApplication object), those tables will be closed.
67984>>>//               In that case you need to use the OnPostUpdate hook event to re-open
67984>>>//               tables after the last update has finished.
67984>>>//
67984>>>// Security    : Before an update is attempted; three things are checked to ensure the
67984>>>//               database is not in use. Aka nobody else is running the application.
67984>>>//               - All tables are tested for "Open in Exclusive_Mode"
67984>>>//               - The DataFlex license User Count is checked - cannot be more than 1, unless the
67984>>>//                 pbCheckDataFlexUserCount is set to False (Default = True)
67984>>>//               - A special user count file ("DbUpdateUserCount.ucf") is created in the Programs
67984>>>//                 folder and a bit-lock is performed for each start of the application and this
67984>>>//                 user counter is checked before an update is attempted.
67984>>>//                 Important: Even if it seems like both garters & suspenders are used to guard
67984>>>//                            against the database being "in use", there is no such guarantee! The
67984>>>//                            database could e.g. be open in "Microsoft SQL Server Management Studio"
67984>>>//                            and there is no way of telling. SO BE CAUTIOUS before attempting an update!
67984>>>//                 A second "user count file" is also used - "DbUpdateLock.ucf". It is used to
67984>>>//                 lock everybody else out (with a Stop box) while the database is being updated. The lock will
67984>>>//                 automatically be released after the update is completed.
67984>>>//
67984>>>//
67984>>>// Usage       :  Use cDbUpdateHandler.pkg
67984>>>//                Object oDatabaseUpdateHandler is a cDbUpdateHandler
67984>>>//                    // Declare the table that contains a "database version" field.
67984>>>//                    Declare_Datafile Sys
67984>>>//                    // Either one of these syntaxes is fine:
67984>>>//                    Set Data_File_Field to File_Field Sys.DbUpdateVersion
67984>>>//                    Set Data_File_Field to (RefTable(Sys)) (RefTable(Sys.DbUpdateVersion))
67984>>>//
67984>>>//                    // Don't forget to increase the pnVersionNumber property for each
67984>>>//                    // cDbUpdateVersion object!
67984>>>//                    // The VersionTableColumn field/column specified above will be updated automatically
67984>>>//                    // with the value of pnVersionNumber after each update has been finished.
67984>>>//                    Object oVersionUpdate1.1 is a cDbUpdateVersion
67984>>>//                        Set pnVersionNumber to 1.1
67984>>>//                        Use VersionUpdate1_1.pkg
67984>>>//                    End_Object
67984>>>//
67984>>>//                    Object oVersionUpdate1.2 is a cDbUpdateVersion
67984>>>//                        Set pnVersionNumber to 1.2
67984>>>//                        Use VersionUpdate1_2.pkg
67984>>>//                    End_Object
67984>>>//
67984>>>//                End_Object
67984>>>//
67984>>>//
67984>>>// $Rev History:
67984>>>//    2016-09-27  Module header created
67984>>>//    2016-09-28  Removed the Master/Alias logic. All update code must
67984>>>//                take place before any tables have been opened, or errors
67984>>>//                could occur if the client database is out of sync with the
67984>>>//                compiled program.
67984>>>//                Added user counting checks + lockout while database is being
67984>>>//                updated.
67984>>>//    2016-10-03  Changed the class name from cDatabaseUpdateHandler to cDbUpdateHandler,
67984>>>//                as it is more in line with the child class cDbUpdateVersion name.
67984>>>//    2016-10-06  Moved constant declarations, structs etc. to separate cDbUpdateHandler.inc file
67984>>>//****************************************************************************
67984>>>Use VdfBase.pkg
67984>>>Use Dferror.pkg
67984>>>Use seq_chnl.pkg
67984>>>Use Datadict.pkg
67984>>>Use DUFLanguageConstants.inc
Including file: DUFLanguageConstants.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DUFLanguageConstants.inc)
67984>>>>>// *** The Database Update Framework Include file for Languages ***
67984>>>>>// Language constant declarations for all classes included in "DUF - The Database Update Framework"
67984>>>>>// They have all been placed in this central spot to make translations to various languages more convenient.
67984>>>>>//
67984>>>>>Use LanguageText.Pkg
67984>>>>>
67984>>>>>    // *** cSQLConnectionsIniFile.pkg Class Language Constants ***
67984>>>>>    Define CS_DUF_DuplicateConnectionIDPre  for "Cannot register connection ID"
67984>>>>>    Define CS_DUF_DuplicateConnectionIDPost for "This ID already exists."
67984>>>>>    // *** cSQLConnectionsHandler.pkg Class Language Constants ***
67984>>>>>    Define CS_DUF_SetupErrorcConnection     for "Cannot login to the database server as the cConnection hasn't been setup properly. Can't continue. Program will now exit."
67984>>>>>    Define CS_DUF_CannotLoginToServer       for "Could not login to the database server. Can't continue. Program will now exit."
67984>>>>>    Define CS_DUF_ErrorText                 for "\n\nError Text:"
67984>>>>>    // *** cDbUpdateFunctionLibrary.pkg Class Language Constants ***
67984>>>>>    Define CS_DUF_ConnectError              for "SQL error. Could not connect to the SQL database manager"
67984>>>>>    Define CS_DUF_AttachError               for "Could not attach to the database:"
67984>>>>>    Define CS_DUF_DeletingIndex             for "Deleting index"
67984>>>>>    Define CS_DUF_CopyingData               for "Copying data"
67984>>>>>    Define CS_DUF_CreatingIndex             for "Creating index"
67984>>>>>    Define CS_DUF_LoginToDbServerFailed     for  "Login failed to the database server. The following connect string was used:\n"
67984>>>>>    Define CS_DUF_DoYouWantToExit           for "Do you want to stop the database update and exit?"  
67984>>>>>    Define CS_DUF_NoIntFilesFound           for "No .int files found! Nothing was changed."
67984>>>>>    // *** cDbUpdateVersion.pkg Class Language Constants ***
67984>>>>>    Define CS_DUF_UpdateVersion             for "Updating database"
67984>>>>>    Define CS_DUF_UpdateFromVersion         for "from version"
67984>>>>>    Define CS_DUF_UpdateToVersion           for "to version:"
67984>>>>>    Define CS_DUF_DbUpdateTableMissing      for "Cannot open the 'DbVersion' table that is used when updating the database! Cannot continue!"
67984>>>>>    // *** cDbUpdateHandler.inc Language Constants ***
67984>>>>>    Define CS_DUF_DatabaseInUseShort        for "There are others using the application/database. Are you sure you still want to update the database?"
67984>>>>>    Define CS_DUF_DatabaseNeedsUpdate       for ("The database needs to be updated." + "\n\nATTENTION! The database may not be in use while this work is performed. Make sure that nobody else is using the application before clicking 'Yes' below.\n\n" + "Start update now?")
67984>>>>>    Define CS_DUF_HeaderUpdateText          for "Important!"
67984>>>>>    Define CS_DUF_DatabaseInUseText         for "There are others using the application/database or at least one table could NOT be opened exclusively. Please close all other applications using the database and try again. The Application will now close."
67984>>>>>    Define CS_DUF_WorkingHeaderText         for "Working!"
67984>>>>>    Define CS_DUF_WorkingUpdateText         for "The database is being updated. Please wait..."
67984>>>>>    Define CS_DUF_DatabaseUpdatedText       for "Ready! The database was updated."
67984>>>>>    Define CS_DUF_DatabaseCheckedText       for "Ready! The database was checked but no updates was needed."
67984>>>>>    Define CS_DUF_DbUpdatedErrorText        for "One or more errors occured while the database was updated. Please check the logfile.\n\nThe program will now close."
67984>>>>>    Define CS_DUF_UpdateInProgressTxt       for ("System locked!\n\nThe database is being updated. Please try again later...\n\n" * "The program will now close.")
67984>>>>>    // *** cDbUpdateHandler.pkg Class Language Constants ***
67984>>>>>    Define CS_DUF_DatabaseConnStringSpec    for "The database specified in the connection string: '"
67984>>>>>    Define CS_DUF_DatabaseDoesntExist       for "' doesn't exist!\n\nYou need to create it with a database management software or by using the 'SqlDatabaseCreate' function, which can be used in the 'OnPreUpdate' event of the cDbUpdateHandler object.\n\nThe program will now exit."
67984>>>>>    // *** cDbUpdateLogFile.pkg Class Language Constants ***   
67984>>>>>    Define CS_DUF_LogFileNotFound           for "Could not locate the log file:\n\n"
67984>>>>>
67984>>>>>
67984>>>>>
67984>>>>>
67984>>>>>
67984>>>>>
67984>>>>>
67984>>>>>
67984>>>>>
67984>>>>>
67984>>>>>
67984>>>>>
67984>>>Use DUFStatusPanel.pkg
Including file: DUFStatusPanel.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DUFStatusPanel.pkg)
67984>>>>>// StatPnl.pkg - creates the standard status_panel object.
67984>>>>>//
67984>>>>>//
67984>>>>>// This is the default Status Panel object used by any of the Visual DataFlex classes that
67984>>>>>// invoke the standard status panel. The standard has always been that the package name
67984>>>>>// is StatPnl.pkg and the name of the object is Status_Panel. As of 12.0, there are major
67984>>>>>// changes in the way the status panel operates The Sentinel based external status panel used in
67984>>>>>// prior revisions has been replace with status panel that is part of the application.
67984>>>>>// This should work much better and faster than the old sentinel based solution.
67984>>>>>// While the way this operates has changed, the interface has not and therefore this should work
67984>>>>>// with most applications.
67984>>>>>//
67984>>>>>// As of 12.0, we have added a global handle that contains the object ID of this status panel.
67984>>>>>// This variable ghoStatusPanel can be used in place of the object name Status_Panel. This provides
67984>>>>>// a cleaner more robust interface.
67984>>>>>//
67984>>>>>//
67984>>>>>// Compatibility Note:
67984>>>>>//
67984>>>>>// When used in the standard way, this change will require no changes. A developer will only need to
67984>>>>>// change their code if they've modified the sentinel program, which was a difficult thing to do.
67984>>>>>//
67984>>>>>// If for some reason you application will not work using this as a replacement for the old status
67984>>>>>// panel, you've probably done something special with the old status-panel. If you don't want to
67984>>>>>// figure out how to use the new one and you want to continue using the old one you are going to need
67984>>>>>// to add some code to include the old status panel in your application. Add the following to your project (your src).
67984>>>>>//
67984>>>>>// Use StatPnl.pkg    // Make sure you load the new status panel object first. this is not optional!
67984>>>>>// Use OldStatPnl.pkg // load the old status panel. Status_Panel is now this old object
67984>>>>>//
67984>>>>>// If you do this, you will lose access to the new status-panel via Status_Panel. However, you
67984>>>>>// can still access the new object via the ghoStatusPanel handle.
67984>>>>>//
67984>>>>>//
67984>>>>>// Creating your own Status Panel objects
67984>>>>>//
67984>>>>>// If a developer wishes to create a custom panel, they should use this package as their template.
67984>>>>>// This panel can be visually modeled and changed any way you wish. Just save your new custom panel
67984>>>>>// with a different file and object name and direct your status panel request to the new object.
67984>>>>>//
67984>>>>>// If the new panel changes the interface and updates objects that are not currently defined, you
67984>>>>>// want to make sure you send the message ProcessEvents after you've updated the object. This allows
67984>>>>>// the object to paint when inside of a tight loop. For example, if you wanted to add a progress
67984>>>>>// bar (cProgressBar) you would want to Send ProcessEvents after you update the progress bar.
67984>>>>>// e.g.
67984>>>>>//       Procedure UpdateStatusBar
67984>>>>>//           Send DoAdvance of oProgressBar
67984>>>>>//           Send ProcessEvents
67984>>>>>//       End_Procedure
67984>>>>>//
67984>>>>>// of course, if you use the standard interfaces in status bar and your forward send these
67984>>>>>// messages this will be done for you.
67984>>>>>//
67984>>>>>// the standard Interface for status panels are:
67984>>>>>//
67984>>>>>// Send Initialize_StatusPanel - initializes values for caption, title & message
67984>>>>>// Send Start_StatusPanel      - start the status panel
67984>>>>>// Send Stop_StatusPanel       - stop the status panel
67984>>>>>// Send Update_StatusPanel     - update the status panel's action area
67984>>>>>// Get  Check_StatusPanel      - check for cancel (if cancel or pbCancel is set, close the panel)
67984>>>>>//
67984>>>>>// Get/Set Caption_Text - updates the caption bar
67984>>>>>// Get/Set Title_Text   - updates the title area
67984>>>>>// Get/Set Message_Text - updates the Message area
67984>>>>>// Get/Set Action_Text  - updates the action area
67984>>>>>// Get/Set Button_Text  - updates the button area
67984>>>>>//
67984>>>>>// Get/Set Allow_cancel_state - determines if panel can be canceled
67984>>>>>// Send EnableCancelButton - code you should provide to enable/disable cancel button
67984>>>>>//
67984>>>>>// ghoStatusPanel - global handle that points to the standard status panel.
67984>>>>>Use cProcessStatusPanel.pkg
67984>>>>>Use cCJSkinFramework.pkg
Including file: cCJSkinFramework.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCJSkinFramework.pkg)
67984>>>>>>>Use windows.pkg
67984>>>>>>>Use cCJComSkinFramework.pkg
Including file: cCJComSkinFramework.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCJComSkinFramework.pkg)
67984>>>>>>>>>// DataFlex COM proxy classes generated from C:\Program Files (x86)\Codejock Software\ActiveX\Xtreme SuitePro ActiveX v18.3.0\Bin\Codejock.SkinFramework.v18.3.0.ocx
67984>>>>>>>>>Use FlexCom20.pkg
67984>>>>>>>>>
67984>>>>>>>>>// Changes to Imported package
67984>>>>>>>>>//     OLEXTPxx to XTPxx
67984>>>>>>>>>//     OLExtpxx to xtpxx
67984>>>>>>>>>//     OLESkinFramework to SkinFramework
67984>>>>>>>>>//     OLESTDxxx and OLEXPxxxx to STD/XP
67984>>>>>>>>>//     cCom classes to cCJ
67984>>>>>>>>>//     cCJAutomationObject back to cComAutomationObject
67984>>>>>>>>>//     cCJActiveXControl back to cComActiveXControl
67984>>>>>>>>>//     cCJSkinFramework to cCJComSkinFramework
67984>>>>>>>>>//     Use statements as noted below (classes moved to these files)
67984>>>>>>>>>//     Set classlibrary of all cComAutomation objects to Windows (for class doc)
67984>>>>>>>>>
67984>>>>>>>>>// These have been extracted from this class and moved into seperate packages
67984>>>>>>>>>// because other Codejock classes use these.
67984>>>>>>>>>Use cCJColorManager.pkg     // cCJColorManager
67984>>>>>>>>>
67984>>>>>>>>>Define SkinFrameworkApplyOptions for Integer
67984>>>>>>>>>    Define xtpSkinApplyMetrics for 1
67984>>>>>>>>>    Define xtpSkinApplyFrame for 2
67984>>>>>>>>>    Define xtpSkinApplyColors for 4
67984>>>>>>>>>    Define xtpSkinApplyMenus for 8
67984>>>>>>>>>
67984>>>>>>>>>// CLSID: {C0DE1830-28D7-4F2C-87A7-7266367B4655}
67984>>>>>>>>>// Dispatch interface for SkinFramework Control
67984>>>>>>>>>Class cCJ_DSkinFramework is a Mixin
67985>>>>>>>>>
67985>>>>>>>>>    Function ComApplyOptions Returns SkinFrameworkApplyOptions
67987>>>>>>>>>        SkinFrameworkApplyOptions retVal
67987>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to retVal
67988>>>>>>>>>        Function_Return retVal
67989>>>>>>>>>    End_Function
67990>>>>>>>>>
67990>>>>>>>>>    Procedure Set ComApplyOptions SkinFrameworkApplyOptions value
67992>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_I4 to value
67993>>>>>>>>>    End_Procedure
67994>>>>>>>>>
67994>>>>>>>>>    Function ComAutoApplyNewWindows Returns Boolean
67996>>>>>>>>>        Boolean retVal
67996>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to retVal
67997>>>>>>>>>        Function_Return retVal
67998>>>>>>>>>    End_Function
67999>>>>>>>>>
67999>>>>>>>>>    Procedure Set ComAutoApplyNewWindows Boolean value
68001>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 5 OLE_VT_BOOL to value
68002>>>>>>>>>    End_Procedure
68003>>>>>>>>>
68003>>>>>>>>>    Function ComAutoApplyNewThreads Returns Boolean
68005>>>>>>>>>        Boolean retVal
68005>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to retVal
68006>>>>>>>>>        Function_Return retVal
68007>>>>>>>>>    End_Function
68008>>>>>>>>>
68008>>>>>>>>>    Procedure Set ComAutoApplyNewThreads Boolean value
68010>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 10 OLE_VT_BOOL to value
68011>>>>>>>>>    End_Procedure
68012>>>>>>>>>
68012>>>>>>>>>    Function ComLoadSkin String llResourcePath String llIniFileName Returns Boolean
68014>>>>>>>>>        Handle hDispatchDriver
68014>>>>>>>>>        Boolean retVal
68014>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
68015>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
68016>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
68017>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
68018>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_BOOL to retVal
68019>>>>>>>>>        Function_Return retVal
68020>>>>>>>>>    End_Function
68021>>>>>>>>>
68021>>>>>>>>>    Procedure ComApplyWindow OLE_HANDLE llhWnd
68023>>>>>>>>>        Handle hDispatchDriver
68023>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
68024>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
68025>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
68026>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 3 OLE_VT_VOID
68027>>>>>>>>>    End_Procedure
68028>>>>>>>>>
68028>>>>>>>>>    Procedure ComEnableThemeDialogTexture OLE_HANDLE llhWnd Integer llFlags
68030>>>>>>>>>        Handle hDispatchDriver
68030>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
68031>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
68032>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
68033>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llFlags
68034>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 4 OLE_VT_VOID
68035>>>>>>>>>    End_Procedure
68036>>>>>>>>>
68036>>>>>>>>>    Procedure ComRemoveWindow OLE_HANDLE llhWnd
68038>>>>>>>>>        Handle hDispatchDriver
68038>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
68039>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
68040>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
68041>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 6 OLE_VT_VOID
68042>>>>>>>>>    End_Procedure
68043>>>>>>>>>
68043>>>>>>>>>    Procedure ComRemoveAllWindows
68045>>>>>>>>>        Handle hDispatchDriver
68045>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
68046>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 7 OLE_VT_VOID
68047>>>>>>>>>    End_Procedure
68048>>>>>>>>>
68048>>>>>>>>>    Procedure ComAddWindowClass String llClassName String llBaseClassName
68050>>>>>>>>>        Handle hDispatchDriver
68050>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
68051>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
68052>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
68053>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llBaseClassName
68054>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 8 OLE_VT_VOID
68055>>>>>>>>>    End_Procedure
68056>>>>>>>>>
68056>>>>>>>>>    Procedure ComRemoveWindowClass String llClassName
68058>>>>>>>>>        Handle hDispatchDriver
68058>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
68059>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
68060>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llClassName
68061>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 9 OLE_VT_VOID
68062>>>>>>>>>    End_Procedure
68063>>>>>>>>>
68063>>>>>>>>>    Function ComEnumerateSkinDirectory String llPath Boolean llRecursive Returns Variant
68065>>>>>>>>>        Handle hDispatchDriver
68065>>>>>>>>>        Variant retVal
68065>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
68066>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
68067>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
68068>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BOOL llRecursive
68069>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 11 OLE_VT_DISPATCH to retVal
68070>>>>>>>>>        Function_Return retVal
68071>>>>>>>>>    End_Function
68072>>>>>>>>>
68072>>>>>>>>>    Function ComEnumerateSkinFile String llPath Returns Variant
68074>>>>>>>>>        Handle hDispatchDriver
68074>>>>>>>>>        Variant retVal
68074>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
68075>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
68076>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llPath
68077>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 12 OLE_VT_DISPATCH to retVal
68078>>>>>>>>>        Function_Return retVal
68079>>>>>>>>>    End_Function
68080>>>>>>>>>
68080>>>>>>>>>    Function ComGetColor XTPColorManagerColor llIndex Returns OLE_COLOR
68082>>>>>>>>>        Handle hDispatchDriver
68082>>>>>>>>>        OLE_COLOR retVal
68082>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
68083>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
68084>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
68085>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 14 OLE_VT_I4 to retVal
68086>>>>>>>>>        Function_Return retVal
68087>>>>>>>>>    End_Function
68088>>>>>>>>>
68088>>>>>>>>>    Procedure ComExcludeModule String llModuleName
68090>>>>>>>>>        Handle hDispatchDriver
68090>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
68091>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
68092>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llModuleName
68093>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 15 OLE_VT_VOID
68094>>>>>>>>>    End_Procedure
68095>>>>>>>>>
68095>>>>>>>>>    Function ComCreateSchema String llResourcePath String llIniFileName Returns Variant
68097>>>>>>>>>        Handle hDispatchDriver
68097>>>>>>>>>        Variant retVal
68097>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
68098>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
68099>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llResourcePath
68100>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llIniFileName
68101>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 16 OLE_VT_DISPATCH to retVal
68102>>>>>>>>>        Function_Return retVal
68103>>>>>>>>>    End_Function
68104>>>>>>>>>
68104>>>>>>>>>    Procedure ComSetWindowTheme OLE_HANDLE llhWnd Variant llSchema
68106>>>>>>>>>        Handle hDispatchDriver
68106>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
68107>>>>>>>>>        Send PrepareParams to hDispatchDriver 2
68108>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llhWnd
68109>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llSchema
68110>>>>>>>>>        Send InvokeComMethod to hDispatchDriver 17 OLE_VT_VOID
68111>>>>>>>>>    End_Procedure
68112>>>>>>>>>
68112>>>>>>>>>    Procedure ComAboutBox
68114>>>>>>>>>        Handle hDispatchDriver
68114>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
68115>>>>>>>>>        Send InvokeComMethod to hDispatchDriver -552 OLE_VT_VOID
68116>>>>>>>>>    End_Procedure
68117>>>>>>>>>End_Class
68118>>>>>>>>>
68118>>>>>>>>>// CLSID: {C0DE1830-4463-4030-B324-AC6A8075FEC8}
68118>>>>>>>>>// Event interface for SkinFramework Control
68118>>>>>>>>>Class cCJ_DSkinFrameworkEvents is a Mixin
68119>>>>>>>>>
68119>>>>>>>>>    Procedure RegisterComEvents
68121>>>>>>>>>    End_Procedure
68122>>>>>>>>>End_Class
68123>>>>>>>>>
68123>>>>>>>>>// CoClass
68123>>>>>>>>>// ProgID: Codejock.SkinFramework.18.3.0
68123>>>>>>>>>// CLSID: {C0DE1830-2217-42EE-B1B0-82C890431F17}
68123>>>>>>>>>// SkinFramework Control
68123>>>>>>>>>Class cCJComSkinFramework is a cComActiveXControl
68124>>>>>>>>>    Import_Class_Protocol cCJ_DSkinFramework
68125>>>>>>>>>    Import_Class_Protocol cCJ_DSkinFrameworkEvents
68126>>>>>>>>>
68126>>>>>>>>>    Procedure Construct_Object
68128>>>>>>>>>        Forward Send Construct_Object
68130>>>>>>>>>        Set psProgID to "{C0DE1830-2217-42EE-B1B0-82C890431F17}"
68131>>>>>>>>>        Set psEventId to "{C0DE1830-4463-4030-B324-AC6A8075FEC8}"
68132>>>>>>>>>        Set psLicenseKey to ("Skin Framework Control Copyright (c) 1998-2018 Codejock Software"+ Character(13)+ Character(10)+;                             "PRODUCT-ID: Codejock.SkinFramework.ActiveX.v18.3"+ Character(13)+ Character(10)+;                             "VALIDATE-CODE: GGE-OLD-QQR-EJS")
68133>>>>>>>>>        Set peAutoCreate to acAutoCreate
68134>>>>>>>>>    End_Procedure
68135>>>>>>>>>End_Class
68136>>>>>>>>>
68136>>>>>>>>>// CLSID: {C0DE1830-CA9A-4AA9-8601-0AB7F551AA3D}
68136>>>>>>>>>// SkinFramework Global Settings
68136>>>>>>>>>Class cCJISkinFrameworkGlobalSettings is a Mixin
68137>>>>>>>>>
68137>>>>>>>>>    Function ComLicense Returns String
68139>>>>>>>>>        String retVal
68139>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to retVal
68140>>>>>>>>>        Function_Return retVal
68141>>>>>>>>>    End_Function
68142>>>>>>>>>
68142>>>>>>>>>    Procedure Set ComLicense String value
68144>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 101 OLE_VT_BSTR to value
68145>>>>>>>>>    End_Procedure
68146>>>>>>>>>
68146>>>>>>>>>    Function ComTitle Returns String
68148>>>>>>>>>        String retVal
68148>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to retVal
68149>>>>>>>>>        Function_Return retVal
68150>>>>>>>>>    End_Function
68151>>>>>>>>>
68151>>>>>>>>>    Procedure Set ComTitle String value
68153>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 102 OLE_VT_BSTR to value
68154>>>>>>>>>    End_Procedure
68155>>>>>>>>>
68155>>>>>>>>>    Function ComVersion Returns String
68157>>>>>>>>>        Handle hDispatchDriver
68157>>>>>>>>>        String retVal
68157>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
68158>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 104 OLE_VT_BSTR to retVal
68159>>>>>>>>>        Function_Return retVal
68160>>>>>>>>>    End_Function
68161>>>>>>>>>
68161>>>>>>>>>    Function ComUnicode Returns Boolean
68163>>>>>>>>>        Handle hDispatchDriver
68163>>>>>>>>>        Boolean retVal
68163>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
68164>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 105 OLE_VT_BOOL to retVal
68165>>>>>>>>>        Function_Return retVal
68166>>>>>>>>>    End_Function
68167>>>>>>>>>
68167>>>>>>>>>    Function ComOcxPath Returns String
68169>>>>>>>>>        Handle hDispatchDriver
68169>>>>>>>>>        String retVal
68169>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
68170>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 106 OLE_VT_BSTR to retVal
68171>>>>>>>>>        Function_Return retVal
68172>>>>>>>>>    End_Function
68173>>>>>>>>>End_Class
68174>>>>>>>>>
68174>>>>>>>>>// CoClass
68174>>>>>>>>>// ProgID: Codejock.SkinFrameworkGlobalSettings.18.3.0
68174>>>>>>>>>// CLSID: {C0DE1830-F744-4373-B38D-29CE83EF0EE5}
68174>>>>>>>>>// SkinFramework Global Settings
68174>>>>>>>>>Class cCJComSkinFrameworkGlobalSettings is a cComAutomationObject
68175>>>>>>>>>    Import_Class_Protocol cCJISkinFrameworkGlobalSettings
68176>>>>>>>>>
68176>>>>>>>>>    Procedure Construct_Object
68178>>>>>>>>>        Forward Send Construct_Object
68180>>>>>>>>>        Set psProgID to "{C0DE1830-F744-4373-B38D-29CE83EF0EE5}"
68181>>>>>>>>>        Set peAutoCreate to acNoAutoCreate
68182>>>>>>>>>    End_Procedure
68183>>>>>>>>>End_Class
68184>>>>>>>>>
68184>>>>>>>>>// CLSID: {C0DE1830-1038-498E-A936-361F08B4C4AA}
68184>>>>>>>>>Class cCJSkinIniFile is a cComAutomationObject
68185>>>>>>>>>
68185>>>>>>>>>    Function ComColorScheme Returns String
68187>>>>>>>>>        String retVal
68187>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
68188>>>>>>>>>        Function_Return retVal
68189>>>>>>>>>    End_Function
68190>>>>>>>>>
68190>>>>>>>>>    Procedure Set ComColorScheme String value
68192>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
68193>>>>>>>>>    End_Procedure
68194>>>>>>>>>
68194>>>>>>>>>    Function ComFontSize Returns String
68196>>>>>>>>>        String retVal
68196>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
68197>>>>>>>>>        Function_Return retVal
68198>>>>>>>>>    End_Function
68199>>>>>>>>>
68199>>>>>>>>>    Procedure Set ComFontSize String value
68201>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
68202>>>>>>>>>    End_Procedure
68203>>>>>>>>>
68203>>>>>>>>>    Function ComIniFileName Returns String
68205>>>>>>>>>        String retVal
68205>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to retVal
68206>>>>>>>>>        Function_Return retVal
68207>>>>>>>>>    End_Function
68208>>>>>>>>>
68208>>>>>>>>>    Procedure Set ComIniFileName String value
68210>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 3 OLE_VT_BSTR to value
68211>>>>>>>>>    End_Procedure
68212>>>>>>>>>End_Class
68213>>>>>>>>>
68213>>>>>>>>>// CLSID: {C0DE1830-4834-499E-95B4-30E0C3F43A10}
68213>>>>>>>>>Class cCJSkinDescription is a cComAutomationObject
68214>>>>>>>>>
68214>>>>>>>>>    Function ComName Returns String
68216>>>>>>>>>        String retVal
68216>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to retVal
68217>>>>>>>>>        Function_Return retVal
68218>>>>>>>>>    End_Function
68219>>>>>>>>>
68219>>>>>>>>>    Procedure Set ComName String value
68221>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 1 OLE_VT_BSTR to value
68222>>>>>>>>>    End_Procedure
68223>>>>>>>>>
68223>>>>>>>>>    Function ComPath Returns String
68225>>>>>>>>>        String retVal
68225>>>>>>>>>        Get ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to retVal
68226>>>>>>>>>        Function_Return retVal
68227>>>>>>>>>    End_Function
68228>>>>>>>>>
68228>>>>>>>>>    Procedure Set ComPath String value
68230>>>>>>>>>        Set ComProperty of (phDispatchDriver(Self)) 2 OLE_VT_BSTR to value
68231>>>>>>>>>    End_Procedure
68232>>>>>>>>>
68232>>>>>>>>>    Function ComCount Returns Integer
68234>>>>>>>>>        Handle hDispatchDriver
68234>>>>>>>>>        Integer retVal
68234>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
68235>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
68236>>>>>>>>>        Function_Return retVal
68237>>>>>>>>>    End_Function
68238>>>>>>>>>
68238>>>>>>>>>    Function ComIniFile Integer llIndex Returns Variant
68240>>>>>>>>>        Handle hDispatchDriver
68240>>>>>>>>>        Variant retVal
68240>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
68241>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
68242>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
68243>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
68244>>>>>>>>>        Function_Return retVal
68245>>>>>>>>>    End_Function
68246>>>>>>>>>
68246>>>>>>>>>    Function Com_NewEnum Returns Variant
68248>>>>>>>>>        Handle hDispatchDriver
68248>>>>>>>>>        Variant retVal
68248>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
68249>>>>>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
68250>>>>>>>>>        Function_Return retVal
68251>>>>>>>>>    End_Function
68252>>>>>>>>>End_Class
68253>>>>>>>>>
68253>>>>>>>>>// CLSID: {C0DE1830-FB37-4B08-A2B9-F6F8B253D697}
68253>>>>>>>>>Class cCJSkinDescriptions is a cComAutomationObject
68254>>>>>>>>>
68254>>>>>>>>>    Function ComCount Returns Integer
68256>>>>>>>>>        Handle hDispatchDriver
68256>>>>>>>>>        Integer retVal
68256>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
68257>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_I4 to retVal
68258>>>>>>>>>        Function_Return retVal
68259>>>>>>>>>    End_Function
68260>>>>>>>>>
68260>>>>>>>>>    Function ComSkin Integer llIndex Returns Variant
68262>>>>>>>>>        Handle hDispatchDriver
68262>>>>>>>>>        Variant retVal
68262>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
68263>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
68264>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
68265>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
68266>>>>>>>>>        Function_Return retVal
68267>>>>>>>>>    End_Function
68268>>>>>>>>>
68268>>>>>>>>>    Function Com_NewEnum Returns Variant
68270>>>>>>>>>        Handle hDispatchDriver
68270>>>>>>>>>        Variant retVal
68270>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
68271>>>>>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
68272>>>>>>>>>        Function_Return retVal
68273>>>>>>>>>    End_Function
68274>>>>>>>>>End_Class
68275>>>>>>>>>
68275>>>>>>>>>// CLSID: {C0DE1830-C56F-43C0-BCF1-8193B35FE4C4}
68275>>>>>>>>>Class cCJSkinSchema is a cComAutomationObject
68276>>>>>>>>>
68276>>>>>>>>>    Function ComGetColor XTPColorManagerColor llIndex Returns OLE_COLOR
68278>>>>>>>>>        Handle hDispatchDriver
68278>>>>>>>>>        OLE_COLOR retVal
68278>>>>>>>>>        Get phDispatchDriver to hDispatchDriver
68279>>>>>>>>>        Send PrepareParams to hDispatchDriver 1
68280>>>>>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
68281>>>>>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_I4 to retVal
68282>>>>>>>>>        Function_Return retVal
68283>>>>>>>>>    End_Function
68284>>>>>>>>>End_Class
68285>>>>>>>Use cApplication.pkg
68285>>>>>>>
68285>>>>>>>Struct tSkinInformation
68285>>>>>>>    String sName     // description of the skin
68285>>>>>>>    String sSkinfile // file path. Can be relative or full
68285>>>>>>>    String sSkinIni  // section name
68285>>>>>>>End_Struct
68285>>>>>>>
68285>>>>>>>
68285>>>>>>>Class cCJSkinFramework is a cCJComSkinFramework
68286>>>>>>>    
68286>>>>>>>    Procedure Construct_Object
68288>>>>>>>        Forward Send Construct_Object
68290>>>>>>>        
68290>>>>>>>        Property String psSkinFile ""
68291>>>>>>>        Property String psSkinIni ""
68292>>>>>>>        Property Boolean pbLoadPreference False
68293>>>>>>>        
68293>>>>>>>        Set peAutoCreate to acAutoCreate
68294>>>>>>>        
68294>>>>>>>        Move Self to ghoSkinFramework
68295>>>>>>>    End_Procedure
68296>>>>>>>    
68296>>>>>>>    // return the default skin path, which is the programs directory.
68296>>>>>>>    // This requires an application object.
68296>>>>>>>    // If you want to different skin path, override this.
68296>>>>>>>    Function SkinPath Returns String
68298>>>>>>>        String sPath sPaths
68298>>>>>>>        Handle hoWorkspace
68298>>>>>>>        If ghoApplication Begin
68300>>>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
68301>>>>>>>            Get psProgramPath of hoWorkspace to sPaths
68302>>>>>>>            Get PathAtIndex of hoWorkspace sPaths 1 to sPath
68303>>>>>>>        End
68303>>>>>>>>
68303>>>>>>>        Else Begin
68304>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
68305>>>>>>>>
68305>>>>>>>        End
68305>>>>>>>>
68305>>>>>>>        Function_Return sPath
68306>>>>>>>    End_Function
68307>>>>>>>    
68307>>>>>>>    // Returns the Qualified name of psSkinFile. If the file is already qualified it just
68307>>>>>>>    // returns itself. If it is not, it uses SkinPath to get the path.
68307>>>>>>>    Function SkinQFile Returns String
68309>>>>>>>        String sFile sPath sSep
68309>>>>>>>        Boolean bQualified
68309>>>>>>>        Get psSkinFile to sFile
68310>>>>>>>        If not (IsFileNameQualified(sFile)) Begin
68312>>>>>>>            Get SkinPath to sPath
68313>>>>>>>            Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
68314>>>>>>>            Move (sPath - sSep - sFile) to sFile
68315>>>>>>>        End
68315>>>>>>>>
68315>>>>>>>        Function_Return sFile
68316>>>>>>>    End_Function
68317>>>>>>>    
68317>>>>>>>    // defines the default VDF window class mapping.
68317>>>>>>>    Procedure OnAddVDFWindowClasses
68319>>>>>>>        Send ComAddWindowClass "DFlistbox"               "ListBox"
68320>>>>>>>        Send ComAddWindowClass "DFentry"                 "Edit"
68321>>>>>>>        Send ComAddWindowClass "DFtextbox"               "Edit"
68322>>>>>>>        Send ComAddWindowClass "DFRichEditCtrl"          "Edit"
68323>>>>>>>        Send ComAddWindowClass "DFcombobox"              "ComboBox"
68324>>>>>>>        Send ComAddWindowClass "DFformlist"              "Edit"
68325>>>>>>>        Send ComAddWindowClass "DFFormListHeader"        "SysHeader32"
68326>>>>>>>        Send ComAddWindowClass "DFbutton"                "Button"
68327>>>>>>>        Send ComAddWindowClass "HPromptBtn"              "Button"
68328>>>>>>>        Send ComAddWindowClass "Hspinbtn"                "msctls_updown32"
68329>>>>>>>        Send ComAddWindowClass "DFSysTabControl32"       "SysTabControl32"
68330>>>>>>>        Send ComAddWindowClass "DFMDIClient"             "MDIClient"
68331>>>>>>>        Send ComAddWindowClass "DFedit"                  "edit"
68332>>>>>>>        Send ComAddWindowClass "DFlistedit"              "edit"
68333>>>>>>>        Send ComAddWindowClass "DFscrollbar"             "scrollbar"
68334>>>>>>>        Send ComAddWindowClass "DFgroup"                 "Button"
68335>>>>>>>        Send ComAddWindowClass "DFComboGrid"             "ComboBox"
68336>>>>>>>        // External class
68336>>>>>>>        Send ComAddWindowClass "cVdfAnimation"           "SysAnimate32"
68337>>>>>>>        Send ComAddWindowClass "cVdfProgressBar"         "msctls_progress32"
68338>>>>>>>        Send ComAddWindowClass "cVdfStatusBar"           "msctls_statusbar32"
68339>>>>>>>        Send ComAddWindowClass "cVdfToolbar"             "ToolbarWindow32"
68340>>>>>>>        Send ComAddWindowClass "cObsoleteVdfProgressBar" "msctls_progress32"
68341>>>>>>>        Send ComAddWindowClass "cVdfTrackBar"            "msctls_trackbar32"
68342>>>>>>>        Send ComAddWindowClass "cObsoleteBasicStatusBar" "msctls_statusbar32"
68343>>>>>>>        Send ComAddWindowClass "cVdfTreeView"            "SysTreeView32"
68344>>>>>>>    End_Procedure
68345>>>>>>>    
68345>>>>>>>    // Used to support developer designed class mappings (e.g. COM controls)
68345>>>>>>>    Procedure OnAddCustomWindowClasses
68347>>>>>>>    End_Procedure
68348>>>>>>>    
68348>>>>>>>    // called when object is created during end_construct_object.
68348>>>>>>>    Procedure OnCreate
68350>>>>>>>        Integer iOpts
68350>>>>>>>        Boolean bUseWindowsFont
68350>>>>>>>        Forward Send OnCreate
68352>>>>>>>        
68352>>>>>>>        // if we are using the windows fonts we will disable the apply metrics which
68352>>>>>>>        // never really looked good anyway. This test only exists or legacy purposes
68352>>>>>>>        Get pbUseWindowsFont of Desktop to bUseWindowsFont
68353>>>>>>>        If bUseWindowsFont Begin
68355>>>>>>>            Get ComApplyOptions to iOpts
68356>>>>>>>            Set ComApplyOptions to (RemoveBitValue(xtpSkinApplyMetrics, iOpts))
68357>>>>>>>        End
68357>>>>>>>>
68357>>>>>>>        
68357>>>>>>>        // this works around a CJ issue where skins applied to other threads causes an exception upon close down.
68357>>>>>>>        // We saw this with our mssql driver but it could occur elsewhere. This has been reported in the CJ newsgroup
68357>>>>>>>        // and this was the suggested workaround.
68357>>>>>>>        Set ComAutoApplyNewThreads to False
68358>>>>>>>        
68358>>>>>>>        Send OnAddVDFWindowClasses
68359>>>>>>>        Send OnAddCustomWindowClasses
68360>>>>>>>        
68360>>>>>>>        // if preferences are used, it will set psSkinFile and psSkinIni
68360>>>>>>>        If (pbLoadPreference(Self)) Begin
68362>>>>>>>            Send LoadSkinPreference
68363>>>>>>>        End
68363>>>>>>>>
68363>>>>>>>        // if a skin file name exists, we apply the skin.
68363>>>>>>>        If (psSkinFile(Self)<>"") Begin
68365>>>>>>>            Send ApplySkin
68366>>>>>>>        End
68366>>>>>>>>
68366>>>>>>>    End_Procedure
68367>>>>>>>    
68367>>>>>>>    // called by framework as part of application exit.
68367>>>>>>>    Procedure Broadcast_Notify_Exit_Application
68369>>>>>>>        Send Notify_Exit_Application
68370>>>>>>>    End_Procedure
68371>>>>>>>    
68371>>>>>>>    Procedure Notify_Exit_Application
68373>>>>>>>        If (pbLoadPreference(Self)) Begin
68375>>>>>>>            Send SaveSkinPreference
68376>>>>>>>        End
68376>>>>>>>>
68376>>>>>>>    End_Procedure
68377>>>>>>>    
68377>>>>>>>    Procedure NotifyPreApplySkin
68379>>>>>>>        Broadcast Send OnPreApplySkin of Desktop True
68381>>>>>>>    End_Procedure
68382>>>>>>>    
68382>>>>>>>    Procedure NotifyPostApplySkin
68384>>>>>>>        Broadcast Send OnPostApplySkin of Desktop True
68386>>>>>>>    End_Procedure
68387>>>>>>>    
68387>>>>>>>    // returns an array of all skins in the path. If path is "", use the default path.
68387>>>>>>>    // If the default path is used, returns the file names as relative names, else use full path.
68387>>>>>>>    Function EnumerateSkins String sPath Boolean bRecursive Returns tSkinInformation[]
68389>>>>>>>        tSkinInformation[] Skins
68389>>>>>>>        tSkinInformation[] Skins
68390>>>>>>>        String sSkinName sSkinFile sDefaultPath sSep
68390>>>>>>>        Variant vSkinDescriptions vSkinDescription vSkinIniFile
68390>>>>>>>        Handle hSkinDescriptions hSkinDescription hSkinIniFile
68390>>>>>>>        Integer iSkinsCount iSkinFilesCount iNumSkins iNumSkinFiles iArrayItem
68390>>>>>>>        Integer iPos iDfltLen
68390>>>>>>>        Boolean bUseRelativePath
68390>>>>>>>        
68390>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sSep
68391>>>>>>>        
68391>>>>>>>        Get SkinPath to sDefaultPath
68392>>>>>>>        If (sPath="") Begin
68394>>>>>>>            Move sDefaultPath to sPath
68395>>>>>>>        End
68395>>>>>>>>
68395>>>>>>>        Move (Uppercase(sDefaultPath)) to sDefaultPath
68396>>>>>>>        Move (Length(sDefaultPath)) to iDfltLen
68397>>>>>>>        Move (sDefaultPath=Uppercase(sPath)) to bUseRelativePath
68398>>>>>>>        
68398>>>>>>>        Get ComEnumerateSkinDirectory sPath bRecursive to vSkinDescriptions
68399>>>>>>>        If (not(IsNullComObject(vSkinDescriptions))) Begin
68401>>>>>>>            
68401>>>>>>>            Get Create U_cCJSkinDescriptions to hSkinDescriptions
68402>>>>>>>            Get Create U_cCJSkinDescription to hSkinDescription
68403>>>>>>>            Get Create U_cCJSkinIniFile to hSkinIniFile
68404>>>>>>>            
68404>>>>>>>            Set pvComObject of hSkinDescriptions to vSkinDescriptions
68405>>>>>>>            Get ComCount of hSkinDescriptions to iNumSkinFiles
68406>>>>>>>            
68406>>>>>>>            For iSkinFilesCount from 0 to (iNumSkinFiles-1)
68412>>>>>>>>
68412>>>>>>>                Get ComSkin of hSkinDescriptions iSkinFilesCount to vSkinDescription
68413>>>>>>>                Set pvComObject of hSkinDescription to vSkinDescription
68414>>>>>>>                
68414>>>>>>>                Get ComCount of hSkinDescription to iNumSkins
68415>>>>>>>                
68415>>>>>>>                For iSkinsCount from 0 to (iNumSkins-1)
68421>>>>>>>>
68421>>>>>>>                    Get ComIniFile of hSkinDescription iSkinsCount to vSkinIniFile
68422>>>>>>>                    Set pvComObject of hSkinIniFile to vSkinIniFile
68423>>>>>>>                    
68423>>>>>>>                    Get ComName of hSkinDescription to Skins[iArrayItem].sName
68424>>>>>>>                    Get ComPath of hSkinDescription to sSkinFile
68425>>>>>>>                    If bUseRelativePath Begin
68427>>>>>>>                        Move (pos(sDefaultPath,uppercase(sSkinFile))) to iPos
68428>>>>>>>                        If iPos Begin
68430>>>>>>>                            Move (Remove(sSkinFile,iPos,iDfltLen)) to sSkinFile
68431>>>>>>>                            While (Left(sSkinFile,1)=sSep)
68435>>>>>>>                                Move (Remove(sSkinFile,1,1)) to sSkinFile
68436>>>>>>>                            Loop
68437>>>>>>>>
68437>>>>>>>                        End
68437>>>>>>>>
68437>>>>>>>                    End
68437>>>>>>>>
68437>>>>>>>                    Move sSkinFile to Skins[iArrayItem].sSkinfile
68438>>>>>>>                    Get ComIniFileName of hSkinIniFile to Skins[iArrayItem].sSkinIni
68439>>>>>>>                    
68439>>>>>>>                    Increment iArrayItem
68440>>>>>>>                Loop
68441>>>>>>>>
68441>>>>>>>            Loop
68442>>>>>>>>
68442>>>>>>>            
68442>>>>>>>            Send Destroy of hSkinDescriptions
68443>>>>>>>            Send Destroy of hSkinDescription
68444>>>>>>>            Send Destroy of hSkinIniFile
68445>>>>>>>            
68445>>>>>>>        End
68445>>>>>>>>
68445>>>>>>>        Function_Return Skins
68446>>>>>>>    End_Function
68447>>>>>>>    
68447>>>>>>>    // Save the skin preference. This requires an application object.
68447>>>>>>>    // Only do this if the application object allows it.
68447>>>>>>>    // This is called during startup if pbLoadPreference is True
68447>>>>>>>    // Suitable for override
68447>>>>>>>    Procedure SaveSkinPreference
68449>>>>>>>        String sSkin sIni
68449>>>>>>>        If ghoApplication Begin
68451>>>>>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
68453>>>>>>>                Get psSkinFile to sSkin
68454>>>>>>>                Get psSkinIni to sIni
68455>>>>>>>                Send WriteString of ghoApplication "Preferences" "SkinFile" sSkin
68456>>>>>>>                Send WriteString of ghoApplication "Preferences" "SkinIni" sIni
68457>>>>>>>            End
68457>>>>>>>>
68457>>>>>>>        End
68457>>>>>>>>
68457>>>>>>>        Else Begin
68458>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
68459>>>>>>>>
68459>>>>>>>        End
68459>>>>>>>>
68459>>>>>>>    End_Procedure
68460>>>>>>>    
68460>>>>>>>    // Load the skin preference. This requires an application object.
68460>>>>>>>    // Only do this if the application object allows it.
68460>>>>>>>    // This is called during startup if pbLoadPreference is True
68460>>>>>>>    // Suitable for override
68460>>>>>>>    Procedure LoadSkinPreference
68462>>>>>>>        String sSkin sIni
68462>>>>>>>        Boolean bExists
68462>>>>>>>        If ghoApplication Begin
68464>>>>>>>            If (pbPreserveEnvironment(ghoApplication)) Begin
68466>>>>>>>                Get ValueExists of ghoApplication "Preferences" "SkinFile" to bExists
68467>>>>>>>                If bExists Begin
68469>>>>>>>                    Get ReadString of ghoApplication "Preferences" "SkinFile" "" to sSkin
68470>>>>>>>                    Get ReadString of ghoApplication "Preferences" "SkinIni" "" to sIni
68471>>>>>>>                    Set psSkinFile to sSkin
68472>>>>>>>                    Set psSkinIni to sIni
68473>>>>>>>                End
68473>>>>>>>>
68473>>>>>>>            End
68473>>>>>>>>
68473>>>>>>>        End
68473>>>>>>>>
68473>>>>>>>        Else Begin
68474>>>>>>>            Error DFERR_PROGRAM C_$ApplicationObjectNotCreated
68475>>>>>>>>
68475>>>>>>>        End
68475>>>>>>>>
68475>>>>>>>    End_Procedure
68476>>>>>>>    
68476>>>>>>>    // Can be called to apply the current skin.
68476>>>>>>>    Procedure ApplySkin
68478>>>>>>>        Boolean bOk
68478>>>>>>>        String sSkin sIni
68478>>>>>>>        If (IsComObjectCreated(Self)) Begin
68480>>>>>>>            Get SkinQFile to sSkin
68481>>>>>>>            Get psSkinIni to sIni
68482>>>>>>>            
68482>>>>>>>            Send NotifyPreApplySkin
68483>>>>>>>            // when skins are used we don't want to use built in Visual Styles
68483>>>>>>>            Send EnableVisualStyles of Desktop (sSkin="")
68484>>>>>>>            Get ComLoadSkin sSkin sIni to bOK
68485>>>>>>>            If (sSkin<>"" and not(bOk)) Begin
68487>>>>>>>                // if not ok, no skin was appied. Enable visual styles
68487>>>>>>>                Send EnableVisualStyles of Desktop True
68488>>>>>>>            End
68488>>>>>>>>
68488>>>>>>>            Send NotifyPostApplySkin
68489>>>>>>>        End
68489>>>>>>>>
68489>>>>>>>    End_Procedure
68490>>>>>>>    
68490>>>>>>>    
68490>>>>>>>End_Class
68491>>>>>Use cProgressBar.pkg
Including file: cProgressBar.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cProgressBar.pkg)
68491>>>>>>>Use Windows.pkg
68491>>>>>>>Use cWinControl.pkg
Including file: cWinControl.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cWinControl.pkg)
68491>>>>>>>>>Use Windows.pkg
68491>>>>>>>>>
68491>>>>>>>>>// Key State Masks for Mouse Messages
68491>>>>>>>>>
68491>>>>>>>>>Define MK_LBUTTON  for |CI$0001
68491>>>>>>>>>Define MK_RBUTTON  for |CI$0002
68491>>>>>>>>>Define MK_SHIFT    for |CI$0004
68491>>>>>>>>>Define MK_CONTROL  for |CI$0008
68491>>>>>>>>>Define MK_MBUTTON  for |CI$0010
68491>>>>>>>>>Define MK_XBUTTON1 for |CI$0020
68491>>>>>>>>>Define MK_XBUTTON2 for |CI$0040
68491>>>>>>>>>
68491>>>>>>>>>Enum_List // Mouse Key Flags
68491>>>>>>>>>    Define mkLeft    for MK_LBUTTON
68491>>>>>>>>>    Define mkMiddle  for MK_MBUTTON
68491>>>>>>>>>    Define mkRight   for MK_RBUTTON
68491>>>>>>>>>    Define mkX1      for MK_XBUTTON1
68491>>>>>>>>>    Define mkX2      for MK_XBUTTON2
68491>>>>>>>>>    Define mkShift   for MK_SHIFT
68491>>>>>>>>>    Define mkControl for MK_CONTROL
68491>>>>>>>>>End_Enum_List
68491>>>>>>>>>
68491>>>>>>>>>Enum_List // Mouse Buttons. Used in OnMouseXXX messages
68491>>>>>>>>>    Define mbLeft
68491>>>>>>>>>    Define mbMiddle
68491>>>>>>>>>    Define mbRight
68491>>>>>>>>>    Define mbX1
68491>>>>>>>>>    Define mbX2
68491>>>>>>>>>End_Enum_List
68491>>>>>>>>>
68491>>>>>>>>>Class cWinControl is a DfBaseControl
68492>>>>>>>>>    Procedure Construct_Object
68494>>>>>>>>>        Forward Send Construct_Object
68496>>>>>>>>>        Property Integer private_pbEnabled True
68497>>>>>>>>>        Property Integer private_pbVisible True
68498>>>>>>>>>    End_Procedure
68499>>>>>>>>>    
68499>>>>>>>>>    Procedure End_Construct_Object
68501>>>>>>>>>        Forward Send End_Construct_Object
68503>>>>>>>>>        
68503>>>>>>>>>        Set External_Message WM_LBUTTONDOWN   to msg_OnWmLButtonDown
68504>>>>>>>>>        Set External_Message WM_MBUTTONDOWN   to msg_OnWmMButtonDown
68505>>>>>>>>>        Set External_Message WM_RBUTTONDOWN   to msg_OnWmRButtonDown
68506>>>>>>>>>        Set External_Message WM_LBUTTONUP     to msg_OnWmLButtonUp
68507>>>>>>>>>        Set External_Message WM_MBUTTONUP     to msg_OnWmMButtonUp
68508>>>>>>>>>        Set External_Message WM_RBUTTONUP     to msg_OnWmRButtonUp
68509>>>>>>>>>        Set External_Message WM_LBUTTONDBLCLK to msg_OnWmLButtonDblClk
68510>>>>>>>>>        Set External_Message WM_MBUTTONDBLCLK to msg_OnWmMButtonDblClk
68511>>>>>>>>>        Set External_Message WM_RBUTTONDBLCLK to msg_OnWmRButtonDblClk
68512>>>>>>>>>        Set External_Message WM_MOUSEMOVE     to msg_OnWmMouseMove
68513>>>>>>>>>    End_Procedure
68514>>>>>>>>>    
68514>>>>>>>>>    Procedure Notify Longptr wParam Longptr lParam
68516>>>>>>>>>        //Intentionally cancelled
68516>>>>>>>>>    End_Procedure
68517>>>>>>>>>    
68517>>>>>>>>>    Procedure Command Integer wParam Integer lParam
68519>>>>>>>>>        //Intentionally cancelled
68519>>>>>>>>>    End_Procedure
68520>>>>>>>>>    
68520>>>>>>>>>    Procedure DoRecreateWindow
68522>>>>>>>>>        // Recreates the window
68522>>>>>>>>>        If (Window_Handle(Self)) Begin
68524>>>>>>>>>            // attempt to do this without disturbing the focus tree.
68524>>>>>>>>>            Send Page_delete // prior to 8.3 this was Send Page_Object 0
68525>>>>>>>>>            Send Page 1      //                       Send Page_Object 1
68526>>>>>>>>>        End
68526>>>>>>>>>>
68526>>>>>>>>>    End_Procedure
68527>>>>>>>>>    
68527>>>>>>>>>    Procedure DoUpdateWindow
68529>>>>>>>>>        // Forces windows to update the window by bypassing WM_PAINT
68529>>>>>>>>>        Handle hWnd
68529>>>>>>>>>        
68529>>>>>>>>>        Get Window_Handle to hWnd
68530>>>>>>>>>        If hWnd ;            Move (UpdateWindow(hWnd)) to hWnd
68533>>>>>>>>>    End_Procedure
68534>>>>>>>>>    
68534>>>>>>>>>    Procedure Page Integer iState
68536>>>>>>>>>        Set Window_Style to WS_DISABLED (private_pbEnabled(Self) =False)
68537>>>>>>>>>        Set Window_Style to WS_VISIBLE (private_pbVisible(Self))
68538>>>>>>>>>        Forward Send Page iState
68540>>>>>>>>>    End_Procedure
68541>>>>>>>>>    
68541>>>>>>>>>    Procedure OnWmLButtonUp Integer wParam Integer lParam
68543>>>>>>>>>        Integer x y eButton
68543>>>>>>>>>        
68543>>>>>>>>>        Move (Hi(lParam))  to y
68544>>>>>>>>>        Move (Low(lParam)) to x
68545>>>>>>>>>        
68545>>>>>>>>>        Send OnMouseUp mbLeft x y wParam
68546>>>>>>>>>    End_Procedure
68547>>>>>>>>>    
68547>>>>>>>>>    Procedure OnWmMButtonUp Integer wParam Integer lParam
68549>>>>>>>>>        Integer x y eButton
68549>>>>>>>>>        
68549>>>>>>>>>        Move (Hi(lParam))  to y
68550>>>>>>>>>        Move (Low(lParam)) to x
68551>>>>>>>>>        
68551>>>>>>>>>        Send OnMouseUp mbMiddle x y wParam
68552>>>>>>>>>    End_Procedure
68553>>>>>>>>>    
68553>>>>>>>>>    Procedure OnWmRButtonUp Integer wParam Integer lParam
68555>>>>>>>>>        Integer x y eButton
68555>>>>>>>>>        
68555>>>>>>>>>        Move (Hi(lParam))  to y
68556>>>>>>>>>        Move (Low(lParam)) to x
68557>>>>>>>>>        
68557>>>>>>>>>        Send OnMouseUp mbRight x y wParam
68558>>>>>>>>>    End_Procedure
68559>>>>>>>>>    
68559>>>>>>>>>    Procedure OnWmLButtonDown Integer wParam Integer lParam
68561>>>>>>>>>        Integer x y eButton fKeys
68561>>>>>>>>>        
68561>>>>>>>>>        Move (Hi(lParam))  to y
68562>>>>>>>>>        Move (Low(lParam)) to x
68563>>>>>>>>>        
68563>>>>>>>>>        Send OnMouseDown mbLeft x y wParam
68564>>>>>>>>>    End_Procedure
68565>>>>>>>>>    Procedure OnWmMButtonDown Integer wParam Integer lParam
68567>>>>>>>>>        Integer x y eButton
68567>>>>>>>>>        
68567>>>>>>>>>        Move (Hi(lParam))  to y
68568>>>>>>>>>        Move (Low(lParam)) to x
68569>>>>>>>>>        
68569>>>>>>>>>        Send OnMouseDown mbMiddle x y wParam
68570>>>>>>>>>    End_Procedure
68571>>>>>>>>>    Procedure OnWmRButtonDown Integer wParam Integer lParam
68573>>>>>>>>>        Integer x y eButton
68573>>>>>>>>>        
68573>>>>>>>>>        Move (Hi(lParam))  to y
68574>>>>>>>>>        Move (Low(lParam)) to x
68575>>>>>>>>>        
68575>>>>>>>>>        Send OnMouseDown mbRight x y wParam
68576>>>>>>>>>    End_Procedure
68577>>>>>>>>>    
68577>>>>>>>>>    Procedure OnWmLButtonDblClk Integer wParam Integer lParam
68579>>>>>>>>>        Integer x y eButton
68579>>>>>>>>>        
68579>>>>>>>>>        Move (Hi(lParam))  to y
68580>>>>>>>>>        Move (Low(lParam)) to x
68581>>>>>>>>>        
68581>>>>>>>>>        Send OnMouseDoubleClick mbLeft x y wParam
68582>>>>>>>>>    End_Procedure
68583>>>>>>>>>    Procedure OnWmMButtonDblClk Integer wParam Integer lParam
68585>>>>>>>>>        Integer x y eButton
68585>>>>>>>>>        
68585>>>>>>>>>        Move (Hi(lParam))  to y
68586>>>>>>>>>        Move (Low(lParam)) to x
68587>>>>>>>>>        
68587>>>>>>>>>        Send OnMouseDoubleClick mbMiddle x y wParam
68588>>>>>>>>>    End_Procedure
68589>>>>>>>>>    Procedure OnWmRButtonDblClk Integer wParam Integer lParam
68591>>>>>>>>>        Integer x y eButton
68591>>>>>>>>>        
68591>>>>>>>>>        Move (Hi(lParam))  to y
68592>>>>>>>>>        Move (Low(lParam)) to x
68593>>>>>>>>>        
68593>>>>>>>>>        Send OnMouseDoubleClick mbRight x y wParam
68594>>>>>>>>>    End_Procedure
68595>>>>>>>>>    
68595>>>>>>>>>    Procedure OnWmMouseMove Integer wParam Integer lParam
68597>>>>>>>>>        Integer x y eButton
68597>>>>>>>>>        
68597>>>>>>>>>        Move (Hi(lParam))  to y
68598>>>>>>>>>        Move (Low(lParam)) to x
68599>>>>>>>>>        
68599>>>>>>>>>        Send OnMouseMove x y wParam
68600>>>>>>>>>    End_Procedure
68601>>>>>>>>>    
68601>>>>>>>>>    Procedure OnMouseDown Integer eButton Integer x Integer y Integer fKeys
68603>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
68603>>>>>>>>>        //String sButton
68603>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
68603>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
68603>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
68603>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
68603>>>>>>>>>        
68603>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
68603>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
68603>>>>>>>>>        //Showln 'OnMouseDown ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
68603>>>>>>>>>    End_Procedure
68604>>>>>>>>>    
68604>>>>>>>>>    Procedure OnMouseUp Integer eButton Integer x Integer y Integer fKeys
68606>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
68606>>>>>>>>>        //String sButton
68606>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
68606>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
68606>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
68606>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
68606>>>>>>>>>        
68606>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
68606>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
68606>>>>>>>>>        //Showln 'OnMouseUp ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
68606>>>>>>>>>    End_Procedure
68607>>>>>>>>>    
68607>>>>>>>>>    Procedure OnMouseDoubleClick Integer eButton Integer x Integer y Integer fKeys
68609>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
68609>>>>>>>>>        //String sButton
68609>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
68609>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
68609>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
68609>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
68609>>>>>>>>>        
68609>>>>>>>>>        //If (eButton = mbLeft) Move 'Left Button' To sButton
68609>>>>>>>>>        //If (eButton = mbRight) Move 'Right Button' To sButton
68609>>>>>>>>>        //Showln 'OnMouseDblClk ' sButton ' ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
68609>>>>>>>>>    End_Procedure
68610>>>>>>>>>    
68610>>>>>>>>>    Procedure OnMouseMove Integer x Integer y Integer fKeys
68612>>>>>>>>>        //Boolean bShiftKey bControlKey bLeftButton bRightButton
68612>>>>>>>>>        //Move (IsFlagIn(mkShift, fKeys))   To bShiftKey
68612>>>>>>>>>        //Move (IsFlagIn(mkControl, fKeys)) To bControlKey
68612>>>>>>>>>        //Move (IsFlagIn(mkLeft, fKeys))    To bLeftButton
68612>>>>>>>>>        //Move (IsFlagIn(mkRight, fKeys))   To bRightButton
68612>>>>>>>>>        
68612>>>>>>>>>        //Showln 'OnMouseMove ' x ' ' y ' shift=' bShiftKey ' ctrl=' bControlKey  ' left=' bLeftButton ' right=' bRightButton
68612>>>>>>>>>    End_Procedure
68613>>>>>>>>>    
68613>>>>>>>>>    Procedure Set pbEnabled Boolean bEnabled
68615>>>>>>>>>        Handle hWnd
68615>>>>>>>>>        
68615>>>>>>>>>        If (bEnabled <> private_pbEnabled(Self)) Begin
68617>>>>>>>>>            Set private_pbEnabled to bEnabled
68618>>>>>>>>>            Get Window_Handle to hWnd
68619>>>>>>>>>            If hWnd ;                Move (EnableWindow(hWnd, bEnabled)) to hWnd
68622>>>>>>>>>        End
68622>>>>>>>>>>
68622>>>>>>>>>    End_Procedure
68623>>>>>>>>>    Function pbEnabled Returns Boolean
68625>>>>>>>>>        Function_Return (private_pbEnabled(Self))
68626>>>>>>>>>    End_Function
68627>>>>>>>>>    
68627>>>>>>>>>    Procedure Set pbVisible Boolean bVisible
68629>>>>>>>>>        Handle  hWnd
68629>>>>>>>>>        Integer iVoid
68629>>>>>>>>>        
68629>>>>>>>>>        If (bVisible <> private_pbVisible(Self)) Begin
68631>>>>>>>>>            Set private_pbVisible to bVisible
68632>>>>>>>>>            Get Window_Handle to hWnd
68633>>>>>>>>>            If hWnd ;                Move (ShowWindow(hWnd, If (bVisible, SW_SHOWNA, SW_HIDE))) to iVoid
68636>>>>>>>>>        End
68636>>>>>>>>>>
68636>>>>>>>>>    End_Procedure
68637>>>>>>>>>    Function pbVisible Returns Boolean
68639>>>>>>>>>        Function_Return (private_pbVisible(Self))
68640>>>>>>>>>    End_Function
68641>>>>>>>>>    
68641>>>>>>>>>End_Class
68642>>>>>>>Use CommCtrl.pkg
68642>>>>>>>
68642>>>>>>>//{ OverrideProperty=pbEnabled DesignTime=False }
68642>>>>>>>Class cProgressBar is a cWinControl
68643>>>>>>>    
68643>>>>>>>    Procedure Construct_Object
68645>>>>>>>        Forward Send Construct_Object
68647>>>>>>>        Property Integer private_piMinimum
68648>>>>>>>        Property Integer private_piMaximum   100
68649>>>>>>>        Property Integer private_piAdvanceBy 10
68650>>>>>>>        Property Integer private_piPosition
68651>>>>>>>        Property Integer private_pbVertical  False
68652>>>>>>>        Property Integer private_pbSmooth    False
68653>>>>>>>        Property Integer private_piBackColor clDefault
68654>>>>>>>        Property Integer private_piBarColor  clDefault
68655>>>>>>>        
68655>>>>>>>        Send Define_ToolTip_Support_Mixin
68656>>>>>>>        
68656>>>>>>>        Set External_Class_Name 'cVdfProgressBar' to 'msctls_progress32'
68657>>>>>>>        Set Focus_Mode to NonFocusable
68658>>>>>>>        Set Skip_State to True
68659>>>>>>>        Set pbUseFormWindowHandle to False     // Must come after Define_ToolTip_Support_Mixin
68660>>>>>>>    End_Procedure
68661>>>>>>>    
68661>>>>>>>    Import_Class_Protocol ToolTip_Support_Mixin
68662>>>>>>>    
68662>>>>>>>    Procedure Set piMinimum Integer iMin
68664>>>>>>>        Integer iMax
68664>>>>>>>        
68664>>>>>>>        Set private_piMinimum to iMin
68665>>>>>>>        Get private_piMaximum to iMax
68666>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
68667>>>>>>>    End_Procedure
68668>>>>>>>    Function piMinimum Returns Integer
68670>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETRANGE, 1, 0))
68673>>>>>>>        Else;            Function_Return (private_piMinimum(Self))
68675>>>>>>>    End_Function
68676>>>>>>>    
68676>>>>>>>    Procedure Set piMaximum Integer iMax
68678>>>>>>>        Integer iMin
68678>>>>>>>        
68678>>>>>>>        Set private_piMaximum to iMax
68679>>>>>>>        Get private_piMinimum to iMin
68680>>>>>>>        Send Windows_Message PBM_SETRANGE32 iMin iMax
68681>>>>>>>    End_Procedure
68682>>>>>>>    Function piMaximum Returns Integer
68684>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETRANGE, 0, 0))
68687>>>>>>>        Else;            Function_Return (private_piMaximum(Self))
68689>>>>>>>    End_Function
68690>>>>>>>    
68690>>>>>>>    Procedure Set piAdvanceBy Integer iAdvanceBy
68692>>>>>>>        Set private_piAdvanceBy to iAdvanceBy
68693>>>>>>>        Send Windows_Message PBM_SETSTEP iAdvanceBy 0
68694>>>>>>>    End_Procedure
68695>>>>>>>    Function piAdvanceBy Returns Integer
68697>>>>>>>        Function_Return (private_piAdvanceBy(Self))
68698>>>>>>>    End_Function
68699>>>>>>>    
68699>>>>>>>    Procedure Set piPosition Integer iPos
68701>>>>>>>        Set private_piPosition to iPos
68702>>>>>>>        Send Windows_Message PBM_SETPOS iPos 0
68703>>>>>>>    End_Procedure
68704>>>>>>>    
68704>>>>>>>    Function piPosition Returns Integer
68706>>>>>>>        If (Window_Handle(Self));            Function_Return (WindowsMessage(PBM_GETPOS, 0, 0))
68709>>>>>>>        Else;            Function_Return (private_piPosition(Self))
68711>>>>>>>    End_Function
68712>>>>>>>    
68712>>>>>>>    Procedure Set pbVertical Boolean bVertical
68714>>>>>>>        If (private_pbVertical(Self) <> bVertical) Begin
68716>>>>>>>            Set private_pbVertical to bVertical
68717>>>>>>>            Send DoRecreateWindow
68718>>>>>>>        End
68718>>>>>>>>
68718>>>>>>>    End_Procedure
68719>>>>>>>    
68719>>>>>>>    Function pbVertical Returns Boolean
68721>>>>>>>        Function_Return (private_pbVertical(Self))
68722>>>>>>>    End_Function
68723>>>>>>>    
68723>>>>>>>    Procedure Set pbSmooth Boolean bSmooth
68725>>>>>>>        If (private_pbSmooth(Self) <> bSmooth) Begin
68727>>>>>>>            Set private_pbSmooth to bSmooth
68728>>>>>>>            Send DoRecreateWindow
68729>>>>>>>        End
68729>>>>>>>>
68729>>>>>>>    End_Procedure
68730>>>>>>>    Function pbSmooth Returns Boolean
68732>>>>>>>        Function_Return (private_pbSmooth(Self))
68733>>>>>>>    End_Function
68734>>>>>>>    
68734>>>>>>>    Procedure Set piBackColor Integer rgbColor
68736>>>>>>>        Set private_piBackColor to rgbColor
68737>>>>>>>        Send Windows_Message PBM_SETBKCOLOR 0 rgbColor
68738>>>>>>>    End_Procedure
68739>>>>>>>    Function piBackColor Returns Integer
68741>>>>>>>        Function_Return (private_piBackColor(Self))
68742>>>>>>>    End_Function
68743>>>>>>>    
68743>>>>>>>    Procedure Set piBarColor Integer rgbColor
68745>>>>>>>        Set private_piBarColor to rgbColor
68746>>>>>>>        Send Windows_Message PBM_SETBARCOLOR 0 rgbColor
68747>>>>>>>    End_Procedure
68748>>>>>>>    Function piBarColor Returns Integer
68750>>>>>>>        Function_Return (private_piBarColor(Self))
68751>>>>>>>    End_Function
68752>>>>>>>    
68752>>>>>>>    Procedure DoAdvance
68754>>>>>>>        Send Windows_Message PBM_STEPIT 0 0
68755>>>>>>>    End_Procedure
68756>>>>>>>    
68756>>>>>>>    Procedure DoAdvanceBy  Integer iAdvanceBy
68758>>>>>>>        Send Windows_Message PBM_DELTAPOS iAdvanceBy 0
68759>>>>>>>    End_Procedure
68760>>>>>>>    
68760>>>>>>>    Procedure private_DoInitWindow
68762>>>>>>>        Set piBarColor  to (private_piBarColor(Self))
68763>>>>>>>        Set piBackColor to (private_piBackColor(Self))
68764>>>>>>>        Set piAdvanceBy to (private_piAdvanceBy(Self))
68765>>>>>>>        Set piMinimum   to (private_piMinimum(Self))
68766>>>>>>>        Set piMaximum   to (private_piMaximum(Self))
68767>>>>>>>        Set piPosition  to (private_piPosition(Self))
68768>>>>>>>    End_Procedure
68769>>>>>>>    
68769>>>>>>>    Procedure Page_Object Integer iState
68771>>>>>>>        Handle hWnd
68771>>>>>>>        
68771>>>>>>>        Get Window_Handle to hWnd
68772>>>>>>>        If (hWnd=0 and iState) Begin
68774>>>>>>>            Set Window_Style to PBS_VERTICAL (private_pbVertical(Self))
68775>>>>>>>            Set Window_Style to PBS_SMOOTH   (private_pbSmooth(Self))
68776>>>>>>>            Forward Send Page_Object True
68778>>>>>>>        End
68778>>>>>>>>
68778>>>>>>>        Else ;            Forward Send Page_Object iState
68781>>>>>>>        
68781>>>>>>>        // Handle tooltip support....
68781>>>>>>>        If (iState = 0) Begin
68783>>>>>>>            Send RequestDeleteToolTip
68784>>>>>>>        End
68784>>>>>>>>
68784>>>>>>>        Else Begin
68785>>>>>>>            Send RequestAddToolTip
68786>>>>>>>        End
68786>>>>>>>>
68786>>>>>>>    End_Procedure
68787>>>>>>>    
68787>>>>>>>    Procedure Page Integer iState
68789>>>>>>>        Forward Send Page iState
68791>>>>>>>        If (iState =1);            Send private_DoInitWindow
68794>>>>>>>    End_Procedure
68795>>>>>>>    
68795>>>>>>>    // Called by Page_Object. Handles tooltip creation. We use a dedicated
68795>>>>>>>    // method to perform AddToolTip because it is often the case that Page_Object
68795>>>>>>>    // is implemented in a mixin class.
68795>>>>>>>    Procedure RequestAddToolTip
68797>>>>>>>        Send AddToolTip
68798>>>>>>>    End_Procedure
68799>>>>>>>    
68799>>>>>>>    
68799>>>>>>>    // Called by Page_Object. Handles tooltip removal.
68799>>>>>>>    Procedure RequestDeleteToolTip
68801>>>>>>>        Send DeleteToolTip
68802>>>>>>>    End_Procedure
68803>>>>>>>End_Class
68804>>>>>Use Windows.pkg
68804>>>>>Use DUFLanguageConstants.inc
68804>>>>>Use Statpnl.pkg
68804>>>>>
68804>>>>>
68804>>>>>    Global_Variable Handle ghoProgressBar // will contain the ID of the embedded progress bar.
68804>>>>>
68804>>>>>    Global_Variable Handle ghoProgressBarOverall // will contain the ID of the embedded progress bar with overall results
68804>>>>>
68804>>>>>Object Status_Panel is a cProcessStatusPanel
68806>>>>>    Set Size to 152 222
68807>>>>>    Set Border_Style to Border_Dialog
68808>>>>>    Set Icon to "Default.ico"
68809>>>>>    Move Self to ghoStatusPanel // this can be used throughout the applicaton to access this object
68810>>>>>
68810>>>>>    Property Boolean Cancel_Button_Visible_State True
68812>>>>>
68812>>>>>    Procedure Activate
68815>>>>>        Integer iSizeBefore
68815>>>>>        Get GuiSize to iSizeBefore
68816>>>>>        Forward Send Activate
68818>>>>>        Set GuiSize to (Hi(iSizeBefore)) (Low(iSizeBefore))
68819>>>>>    End_Procedure
68820>>>>>
68820>>>>>    Procedure End_Construct_Object
68823>>>>>        Forward Send End_Construct_Object
68825>>>>>        Set Label of oTitleTxt      to ""
68826>>>>>        Set Label of oTableNameTxt  to ""
68827>>>>>        Set Label of oMessageTxt    to ""
68828>>>>>        Set Label of oActionTxt     to ""
68829>>>>>    End_Procedure
68830>>>>>
68830>>>>>    Object oTitleTxt is a TextBox
68832>>>>>        Set Location to 5 21
68833>>>>>        Set Size to 8 179
68834>>>>>        Set Auto_Size_State to False
68835>>>>>        Set Justification_Mode  to jMode_Center
68836>>>>>        Set Label to "This is the Title Text"
68837>>>>>    End_Object
68838>>>>>
68838>>>>>    Object oTableNameTxt is a TextBox
68840>>>>>        Set Size to 19 204
68841>>>>>        Set Location to 18 9
68842>>>>>        Set Auto_Size_State to False
68843>>>>>        Set Justification_Mode to JMode_Left
68844>>>>>        Set Label to "This is the TableName Text"
68845>>>>>    End_Object
68846>>>>>
68846>>>>>    Object oMessageTxt is a TextBox
68848>>>>>        Set Location to 39 9
68849>>>>>        Set Size to 19 204
68850>>>>>        Set Auto_Size_State to False
68851>>>>>        Set Justification_Mode to JMode_Left
68852>>>>>        Set Label to "This is the Message text"
68853>>>>>    End_Object
68854>>>>>
68854>>>>>    Object oActionTxt is a TextBox
68856>>>>>        Set Size to 16 204
68857>>>>>        Set Location to 60 9
68858>>>>>        Set Auto_Size_State to False
68859>>>>>        Set Justification_Mode to JMode_Left
68860>>>>>        Set Label to "This is the Action Text"
68861>>>>>    End_Object
68862>>>>>
68862>>>>>    Object oStopButton is a Button
68864>>>>>        Set Location to 123 82
68865>>>>>        Set Label to C_$Cancel
68866>>>>>
68866>>>>>        Procedure OnClick 
68869>>>>>            Integer iRetval
68869>>>>>            Get YesNo_Box CS_DUF_DoYouWantToExit to iRetval
68870>>>>>            If (iRetval = MBR_Yes) Begin
68872>>>>>                Send Exit_Application
68873>>>>>            End
68873>>>>>>
68873>>>>>        End_Procedure
68874>>>>>
68874>>>>>    End_Object
68875>>>>>
68875>>>>>    Object oPercentage_tb is a TextBox
68877>>>>>        Set Location to 74 196
68878>>>>>        Set Size to 10 25
68879>>>>>//        Set Label to "% Done"
68879>>>>>    End_Object
68880>>>>>
68880>>>>>    Object oCopyRight is a TextBox
68882>>>>>        Set Location to 140 21
68883>>>>>        Set Size to 9 197
68884>>>>>        Set FontPointHeight to 8
68885>>>>>        Set Auto_Size_State to False
68886>>>>>        Set Justification_Mode  to jMode_Center
68887>>>>>        Set Label to "Copyright 2001-2020 RDC Tools International"
68888>>>>>    End_Object
68889>>>>>
68889>>>>>    Object oProgressBar is a cProgressBar
68891>>>>>        Set Size to 10 179
68892>>>>>        Set Location to 83 22
68893>>>>>        Set pbVisible to True // default
68894>>>>>        Move Self to ghoProgressBar // this can be used throughout your application to access the progress bar
68895>>>>>    End_Object
68896>>>>>
68896>>>>>    Procedure Set Progress_Bar_Visible_State Boolean bVisible
68899>>>>>        Set pbVisible of ghoProgressBar to bVisible
68900>>>>>    End_Procedure
68901>>>>>
68901>>>>>    Function Progress_Bar_Visible_State Returns Boolean
68904>>>>>        Boolean bVisible
68904>>>>>        Get pbVisible of ghoProgressBar to bVisible
68905>>>>>        Function_Return (bVisible)
68906>>>>>    End_Function
68907>>>>>
68907>>>>>    Object oProgressBarOverall is a cProgressBar
68909>>>>>        Set Size to 10 179
68910>>>>>        Set Location to 107 22
68911>>>>>        Set pbVisible to True // default
68912>>>>>        Move Self to ghoProgressBarOverall // this can be used throughout your application to access the progress bar
68913>>>>>    End_Object
68914>>>>>
68914>>>>>    Object oOverallProgress_tb is a TextBox
68916>>>>>        Set Size to 10 65
68917>>>>>        Set Location to 95 24
68918>>>>>        Set Label to "Overall Progress"
68919>>>>>    End_Object
68920>>>>>
68920>>>>>    Procedure Set Progress_Bar_Overall_Visible_State Boolean bVisible
68923>>>>>        Set pbVisible of ghoProgressBarOverall to bVisible
68924>>>>>    End_Procedure
68925>>>>>
68925>>>>>    Function Progress_Bar_Overall_Visible_State Returns Boolean
68928>>>>>        Boolean bVisible
68928>>>>>        Get pbVisible of ghoProgressBarOverall to bVisible
68929>>>>>        Function_Return (bVisible)
68930>>>>>    End_Function
68931>>>>>
68931>>>>>    // These messages bind the standard cProcessStatusPanel interface to the actual
68931>>>>>    // objects defined within this instance of the status panel.
68931>>>>>
68931>>>>>    // note: all of the messages that change text should be forwarded
68931>>>>>    // as the forwarded messages allows the panel to paint when in a tight loop
68931>>>>>
68931>>>>>    Procedure Set Message_Text String sText
68934>>>>>        Set Label of oMessageTxt to sText
68935>>>>>        Forward Set Message_Text to sText
68937>>>>>    End_Procedure
68938>>>>>
68938>>>>>    Function Message_Text Returns String
68941>>>>>        Function_Return (Label(oMessageTxt))
68942>>>>>    End_Function
68943>>>>>
68943>>>>>    Procedure Set Action_Text String sText
68946>>>>>        Set Label of oActionTxt to sText
68947>>>>>        Forward Set Action_Text to sText
68949>>>>>    End_Procedure
68950>>>>>
68950>>>>>    Function Action_Text Returns String
68953>>>>>        Function_Return (Label(oActionTxt))
68954>>>>>    End_Function
68955>>>>>
68955>>>>>    Procedure Set Button_Text String sText
68958>>>>>        Set Label of oStopButton to sText
68959>>>>>        Forward Set Button_Text to sText
68961>>>>>    End_Procedure
68962>>>>>
68962>>>>>    Function Button_Text Returns String
68965>>>>>        Function_Return (Label(oStopButton))
68966>>>>>    End_Function
68967>>>>>
68967>>>>>    Procedure Set Title_Text String sText
68970>>>>>        Set Label of oTitleTxt to sText
68971>>>>>        Forward Set Title_Text to sText
68973>>>>>    End_Procedure
68974>>>>>
68974>>>>>    Function Title_Text Returns String
68977>>>>>        Function_Return (Label(oTitleTxt))
68978>>>>>    End_Function
68979>>>>>
68979>>>>>    Procedure Set TableName_Text String sText
68982>>>>>        Set Label of oTableNameTxt to sText
68983>>>>>    End_Procedure
68984>>>>>
68984>>>>>    Function TableName_Text Returns String
68987>>>>>        Function_Return (Label(oTableNameTxt))
68988>>>>>    End_Function
68989>>>>>
68989>>>>>    Procedure Set License_Text String sText
68992>>>>>//        Set Label of oLicense_txt to sText
68992>>>>>    End_Procedure
68993>>>>>
68993>>>>>    // gets called when status panel is activated passing whether a button
68993>>>>>    // should appear
68993>>>>>    Procedure EnableCancelButton Boolean bEnable
68996>>>>>        Boolean bVisible
68996>>>>>        Get Cancel_Button_Visible_State to bVisible
68997>>>>>        If (bEnable = False) Begin
68999>>>>>            Set Visible_State of oStopButton to bVisible
69000>>>>>        End
69000>>>>>>
69000>>>>>        Set Enabled_State of oStopButton to bEnable
69001>>>>>    End_Procedure
69002>>>>>
69002>>>>>    Procedure Reset_StatusPanel
69005>>>>>        Set Allow_Cancel_State of ghoStatusPanel to True
69006>>>>>        Set Cancel_Button_Visible_State of ghoStatusPanel to True
69007>>>>>        Set Progress_Bar_Visible_State  of ghoStatusPanel to True
69008>>>>>        Set Progress_Bar_Overall_Visible_State of ghoProgressBarOverall to False
69009>>>>>    End_Procedure
69010>>>>>
69010>>>>>//    Object oProgressBar is a cProgressBar
69010>>>>>//        Move Self to ghoProgressBar
69010>>>>>//        Set Location to 1 25
69010>>>>>//        Set Size to 9 173
69010>>>>>//        Set piMinimum        to 0
69010>>>>>//        Set piMaximum        to 2000
69010>>>>>//        Set piAdvanceBy      to 100
69010>>>>>//        Set pbSmooth to True
69010>>>>>//
69010>>>>>//        // For some weird reason the application skin makes the coloring of the progressbar
69010>>>>>//        // to malfunction. By telling the CodeJock SkinFramework to skip this object, the
69010>>>>>//        // color will show correctly.
69010>>>>>//        Procedure Page Integer iPageObject
69010>>>>>//            Handle hWin
69010>>>>>//            Forward Send Page iPageObject
69010>>>>>//            If (ghoSkinFramework <> 0) Begin
69010>>>>>//                Get Window_Handle to hWin
69010>>>>>//                Send ComRemoveWindow of ghoSkinFramework hWin
69010>>>>>//            End
69010>>>>>//        End_Procedure
69010>>>>>//    End_Object
69010>>>>>
69010>>>>>End_Object
69011>>>>>
69011>>>Use cDbUpdateHandler.inc // Contains cDbUpdateHandler class constants, structs etc.
Including file: cDbUpdateHandler.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateHandler.inc)
69011>>>>>// Constant declarations, structs etc. for the cDbUdpateHandler class.
69011>>>>>//
69011>>>>>Use VdfBase.pkg
69011>>>>>Use cApplication.pkg
69011>>>>>Use seq_chnl.pkg
69011>>>>>Use vWin32fh.pkg
Including file: vWin32fh.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh\vWin32fh.pkg)
69011>>>>>>>// This code is part of VDF GUIdance
69011>>>>>>>// Visit us @ http://www.vdf-guidance.com
69011>>>>>>>// e-Mail us @ info@vdf-guidance.com
69011>>>>>>>// VDF GUIdance is a mutual project of
69011>>>>>>>// Frank Vandervelpen - Vandervelpen Systems and
69011>>>>>>>// Wil van Antwerpen  - Antwise Solutions
69011>>>>>>>// All software source code should be used <<AS IS>> without any warranty.
69011>>>>>>>//
69011>>>>>>>//
69011>>>>>>>// *** Windows 32bit file handling wrapper class ***
69011>>>>>>>//
69011>>>>>>>
69011>>>>>>>// 05-09-2000 **WvA: Changed namingconvention of all classes and methods to new standard
69011>>>>>>>//                   This may be painfull for some of you, but it was really needed as it was
69011>>>>>>>//                   getting messy. The "vs" -prefix we used before was confusing and could
69011>>>>>>>//                   unintentionally have been interpreted as "Vdf-GUIdance String".
69011>>>>>>>//
69011>>>>>>>// The used naming-convention is:
69011>>>>>>>//     - a prefix of "vWin32_" for every external function declaration
69011>>>>>>>//     - a prefix of the letter "v" for the full API name for the vdf-wrapper function.
69011>>>>>>>//
69011>>>>>>>// By using this we are guarding ourselves for conflicts with variable declarations
69011>>>>>>>// of DataAccess in the future.
69011>>>>>>>// Or at least almost as the letter "v" is now also synonym for variant (duh~!)
69011>>>>>>>//
69011>>>>>>>// mm-dd-yyyy Author Description
69011>>>>>>>//
69011>>>>>>>//                   vSHGetFolderPath added to retrieve the new shell folders
69011>>>>>>>//                   vGetWindowsDirectory
69011>>>>>>>//
69011>>>>>>>//                   vGetTempFileName
69011>>>>>>>//                   vGetTempPath
69011>>>>>>>// 11-17-2001 **WvA: Removed User Interface Error popups such as Error handling.
69011>>>>>>>//                   This is an absolute need for WebApp. We expect you to handle the
69011>>>>>>>//                   error in your application anyways. Changed this for:
69011>>>>>>>//                   vDeleteFile, vCopyFile, vMoveFile and vRenameFile
69011>>>>>>>// 03-02-2002 **WvA: vRemoveDirectory added
69011>>>>>>>// 03-11-2002 **WvA: The parameter lpdword in the external function declaration for
69011>>>>>>>//                   vWin32_SHBrowsForFolder can cause compiler errors.
69011>>>>>>>//                   It is renamed too avoid this.
69011>>>>>>>// 11-11-2002 **WvA: Codecleanup, vcSelectFile_Dialog is now cvSelectFile_Dialog, its
69011>>>>>>>//                   function vSelectedFileName is now just SelectedFileName
69011>>>>>>>//                   Removed the local keyword in the variable declarations
69011>>>>>>>// 10-17-2003 **WvA: Cleaned up function vSelect_File and added code to destroy the dynamically
69011>>>>>>>//                   created file-open dialog
69011>>>>>>>// 02-12-2004 **WvA: Allan Ankerstjeme pointed me into a bug for the vCreateTempFileInPath
69011>>>>>>>//                   in that it didn't exactly return the correct filename of the file created.
69011>>>>>>>//                   This has now been taken care of.
69011>>>>>>>// 02-19-2004 **WvA: Removed all API declarations from the package itself to improve readability
69011>>>>>>>//                   These declarations are now included from the vWin32fh header file.
69011>>>>>>>// 02-19-2004 **WvA: Changed the default way in which the standard file handling works
69011>>>>>>>//                   Before today one could always undo the operation, as of now you cannot as
69011>>>>>>>//                   the default was a silly one using unnecessary resources (mainly diskspace)
69011>>>>>>>//                   Since i don't really expect someone to use that feature it has been removed.
69011>>>>>>>//                   One can however restore to the old way of handling by simply calling the
69011>>>>>>>//                   vWin32fhCompatibilityMode procedure ONE time before accessing any of the
69011>>>>>>>//                   filehandling operations
69011>>>>>>>// 02-19-2004 **WvA: The functions ParseFolderName, ParseFileName and ParseFileExtenstion added
69011>>>>>>>//                   as well as the StringFromRightOfChar function.
69011>>>>>>>// 02-19-2004 **WvA: sfoFormatDisk function added which can use to format a floppydisk
69011>>>>>>>//                   DISABLED now as testing shows that it does not work as advertised...
69011>>>>>>>// 02-20-2004 **WvA: The function vDDE_Error_Handler didn't pass the errornumber on to the DDE_Error_To_String function
69011>>>>>>>//                   Moved the hardcoded strings from vDDE_Error_Handler to define declarations for easier translation later on.
69011>>>>>>>// 09-10-2004 **WvA: Added the ToAnsi function to the fileoperations method so that
69011>>>>>>>//                   extended characters are treated ok too.
69011>>>>>>>//                   Reported by Flemming from
69011>>>>>>>// 12-17-2004 **WvA: Changed vFilePathExists to be global, reported by Peter van Mil
69011>>>>>>>// 12-28-2004 **WvA: WebApp compatibility added by introducing compiler directives
69011>>>>>>>// 03-10-2006 **WvA: Added more CSIDL types to our header file for use with the vSHGetFolderPath function
69011>>>>>>>// 01-02-2007 **WvA: Set NoChangeDir_State on vSelect_File and vSelectSaveFile to True but changed it back due to side effects.
69011>>>>>>>//                   Added vSelectSavefile function to create a file save dialog
69011>>>>>>>//                   Fixed ParseFolderName which was horribly broken (thanks for the reports)
69011>>>>>>>//                   Added vParentPath function to retrieve the parent "node" of a path
69011>>>>>>>// 01-04-2008 **WvA: Fixed vCreateTempFileInPath as the function wasn't working
69011>>>>>>>// 10-04-2009 **WvA: Added vshCreateDirectoryEx from Micheal Mullan, moved filedialogs to cvFileDialogs.pkg
69011>>>>>>>// 01-11-2010 **WvA: Added vWin32_APIFilesize as supplied by Renato Villa, to get the filesize of the specified file. See http://support.dataaccess.com/forums/showthread.php?t=41982
69011>>>>>>>// 10-02-2011 **WvA: Added vCSIDL_SYSTEMX86, courtesy of Ola Eldoy for pointing this out and providing the define statement.
69011>>>>>>>// 20-12-2012 **WvA: Default behavior on copy/move is now to autocreate subfolders, tip by Frank Cheng
69011>>>>>>>// 29-09-2014 **WvA: Added function vFolderFileCount to count the number of files in a folder, add vCSIDL_PROGRAM_FILESx86
69011>>>>>>>// 04-10-2014 **WvA: Added extra checks on vFilePathExists and vFolderExists courtesy of Nils Svedmyr
69011>>>>>>>
69011>>>>>>>Use File_Dlg.pkg      // Contains OpenDialog class definition
69011>>>>>>>Use cvFileDialogs.pkg
Including file: cvFileDialogs.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh\cvFileDialogs.pkg)
69011>>>>>>>>>//***************************************************************************
69011>>>>>>>>>//*
69011>>>>>>>>>//* Class:        cvSaveAsDialog
69011>>>>>>>>>//* Package Name: cvFileDialogs.pkg
69011>>>>>>>>>//*
69011>>>>>>>>>//***************************************************************************
69011>>>>>>>>>
69011>>>>>>>>>Use File_dlg.pkg
69011>>>>>>>>>
69011>>>>>>>>>// *WvA: 13-01-1999 Created
69011>>>>>>>>>// The Class cSelectFile_Dialog is created to support the function Select_File
69011>>>>>>>>>// This function opens the Windows standard file open dialog and returns the selected
69011>>>>>>>>>// file_name.
69011>>>>>>>>>Class cvSelectFile_Dialog is an OpenDialog
69012>>>>>>>>>
69012>>>>>>>>>    Procedure Construct_Object Integer iImage_Id
69014>>>>>>>>>        Forward Send Construct_Object iImage_Id
69016>>>>>>>>>        Set HideReadOnly_State to True
69017>>>>>>>>>    End_Procedure
69018>>>>>>>>>
69018>>>>>>>>>    Function SelectedFileName Returns String
69020>>>>>>>>>        String sFileName
69020>>>>>>>>>        Move "" to sFileName
69021>>>>>>>>>        If (Show_Dialog(Self)) Begin
69023>>>>>>>>>            Move (RTrim(File_Name(Self))) to sFileName
69024>>>>>>>>>        End
69024>>>>>>>>>>
69024>>>>>>>>>        Function_Return sFileName
69025>>>>>>>>>    End_Function
69026>>>>>>>>>End_Class
69027>>>>>>>>>
69027>>>>>>>>>// *WvA: 13-01-1999 Created
69027>>>>>>>>>// This function opens the Windows standard file open dialog and returns the selected
69027>>>>>>>>>// file_name. Returns '' if the user didn't make a selection.
69027>>>>>>>>>// **WvA: 17-10-2003 Cleaned up and added code to destroy the dynamically created
69027>>>>>>>>>//                   file-open dialog
69027>>>>>>>>>Function vSelect_File Global String sSupportedFileTypes String sCaptionText String sInitialFolder Returns String
69029>>>>>>>>>    String sSelectedFile
69029>>>>>>>>>    Integer hoOpenFileDialog
69029>>>>>>>>>
69029>>>>>>>>>    Object oOpenFileDialog is a cvSelectFile_Dialog
69031>>>>>>>>>
69031>>>>>>>>>        Set Dialog_Caption    to sCaptionText
69032>>>>>>>>>        Set Filter_String     to sSupportedFileTypes
69033>>>>>>>>>        Set Initial_Folder    to sInitialFolder
69034>>>>>>>>>
69034>>>>>>>>>        Move Self       to hoOpenFileDialog
69035>>>>>>>>>    End_Object
69036>>>>>>>>>
69036>>>>>>>>>    Get SelectedFileName of hoOpenFileDialog to sSelectedFile
69037>>>>>>>>>    Send Destroy_Object to hoOpenFileDialog
69038>>>>>>>>>    Function_Return sSelectedFile
69039>>>>>>>>>End_Function
69040>>>>>>>>>
69040>>>>>>>>>Class cvSaveAsDialog is a SaveAsDialog
69041>>>>>>>>>
69041>>>>>>>>>    Procedure Construct_Object
69043>>>>>>>>>        Forward Send Construct_Object
69045>>>>>>>>>        Set HideReadOnly_State to True
69046>>>>>>>>>    End_Procedure
69047>>>>>>>>>
69047>>>>>>>>>    Function SelectedFileName Returns String
69049>>>>>>>>>        String sFileName
69049>>>>>>>>>        Move "" to sFileName
69050>>>>>>>>>        If (Show_Dialog(Self)) Begin
69052>>>>>>>>>            Move (RTrim(File_Name(Self))) to sFileName
69053>>>>>>>>>        End
69053>>>>>>>>>>
69053>>>>>>>>>        Function_Return sFileName
69054>>>>>>>>>    End_Function
69055>>>>>>>>>
69055>>>>>>>>>End_Class
69056>>>>>>>>>
69056>>>>>>>>>// Added optional default filename as suggested by Nils
69056>>>>>>>>>Function vSelectSaveFile Global String sSupportedFileTypes String sCaptionText String sInitialFolder String sDefaultFileName Returns String
69058>>>>>>>>>    String sSelectedFile
69058>>>>>>>>>    Integer hoDialog
69058>>>>>>>>>
69058>>>>>>>>>    Move "" to sSelectedFile
69059>>>>>>>>>    Get Create (RefClass(cvSaveAsDialog)) to hoDialog
69060>>>>>>>>>    If (hoDialog) Begin
69062>>>>>>>>>    //Set NoChangeDir_State Of hoDialog To True
69062>>>>>>>>>        Set Dialog_Caption    of hoDialog to sCaptionText
69063>>>>>>>>>        Set Filter_String     of hoDialog to sSupportedFileTypes
69064>>>>>>>>>        Set Initial_Folder    of hoDialog to sInitialFolder
69065>>>>>>>>>        If (Num_Arguments = 4) Begin
69067>>>>>>>>>            Set File_Title        of hoDialog to sDefaultFileName
69068>>>>>>>>>        End
69068>>>>>>>>>>
69068>>>>>>>>>        Get SelectedFileName  of hoDialog to sSelectedFile
69069>>>>>>>>>        Send Destroy of hoDialog
69070>>>>>>>>>    End
69070>>>>>>>>>>
69070>>>>>>>>>    Function_Return sSelectedFile
69071>>>>>>>>>End_Function
69072>>>>>>>Use Seq_chnl.pkg
69072>>>>>>>
69072>>>>>>>Use windows.pkg
69072>>>>>>>Use Dll.pkg
69072>>>>>>>Use vWin32fh.h       // Header file with WinAPI declarations
Including file: vwin32fh.h    (C:\Projects\DF20\DbUpdateFramework\Libraries\vwin32fh\vwin32fh.h)
69072>>>>>>>>>//TH-Header
69072>>>>>>>>>//*****************************************************************************************
69072>>>>>>>>>// Copyright (c)  2004 KURANT Project
69072>>>>>>>>>// All rights reserved.
69072>>>>>>>>>//
69072>>>>>>>>>// $FileName    : G:\Projects\vWin32fh\vWin32fh.h
69072>>>>>>>>>// $ProjectName : Windows 32 bits file handling
69072>>>>>>>>>// $Authors     : Wil van Antwerpen
69072>>>>>>>>>// $Created     : 19.02.2004  19:25
69072>>>>>>>>>// $Type        : BSD (as in do with it whatever you like)
69072>>>>>>>>>//
69072>>>>>>>>>// Contents:
69072>>>>>>>>>//  This file contains the Windows API external function call definitions and
69072>>>>>>>>>//  constants as they are used in the vWin32fh package.
69072>>>>>>>>>//*****************************************************************************************
69072>>>>>>>>>//TH-RevisionStart
69072>>>>>>>>>//TH-RevisionEnd
69072>>>>>>>>>
69072>>>>>>>>>Define CS_DDE_ERR_FILE_NOT_FOUND  For "The specified file was not found.\n"
69072>>>>>>>>>Define CS_DDE_ERR_PATH_NOT_FOUND  For "The specified path was not found.\n"
69072>>>>>>>>>Define CS_DDE_ERR_BAD_FORMAT      For "The .EXE file is invalid.\n"
69072>>>>>>>>>Define CS_DDE_ERR_ACCESSDENIED    For "The operating system denied access to the specified file.\n"
69072>>>>>>>>>Define CS_DDE_ERR_ASSOCINCOMPLETE For "The filename association is incomplete or invalid.\n"
69072>>>>>>>>>Define CS_DDE_ERR_DDEBUSY         For "The DDE transaction could not be completed because other DDE\ntransactions were being processed.\n"
69072>>>>>>>>>Define CS_DDE_ERR_DDEFAIL         For "The DDE transaction failed.\n"
69072>>>>>>>>>Define CS_DDE_ERR_DDETIMEOUT      For "The DDE transaction could not be completed,\nbecause the request timed out.\n"
69072>>>>>>>>>Define CS_DDE_ERR_DLLNOTFOUND     For "The specified dynamic-link library was not found.\n"
69072>>>>>>>>>Define CS_DDE_ERR_NOASSOC         For "There is no application associated with the given filename extension.\n"
69072>>>>>>>>>Define CS_DDE_ERR_OOM             For "There is not enough free memory available to complete the operation.\n"
69072>>>>>>>>>Define CS_DDE_ERR_PNF             For "The specified path was not found.\n"
69072>>>>>>>>>Define CS_DDE_ERR_SHARE           For "A sharing violation occurred.\n"
69072>>>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE1   For "Unknown DDE-error occurred.\nErrornumber"
69072>>>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
69072>>>>>>>>>Define CS_DDE_ERR_HANDL_PAKTC     For "\nPress a key to continue...\n\n"
69072>>>>>>>>>Define CS_DDE_ERR_HANDL_CAPTION   For "a DDE-error occurred"
69072>>>>>>>>>
69072>>>>>>>>>
69072>>>>>>>>>Define vMax_Path     For |CI260
69072>>>>>>>>>Define vMinChar      For |CI$80
69072>>>>>>>>>Define vMaxChar      For |CI$7F
69072>>>>>>>>>Define vMinShort     For |CI$8000
69072>>>>>>>>>Define vMaxShort     For |CI$7FFF
69072>>>>>>>>>Define vMinLong      For |CI$80000000
69072>>>>>>>>>Define vMaxLong      For |CI$7FFFFFFF
69072>>>>>>>>>Define vMaxByte      For |CI$FF
69072>>>>>>>>>Define vMaxWord      For |CI$FFFF
69072>>>>>>>>>Define vMaxDword     For |CI$FFFFFFFF
69072>>>>>>>>>
69072>>>>>>>>>
69072>>>>>>>>>
69072>>>>>>>>>// For FindFirstFile
69072>>>>>>>>>Define vINVALID_HANDLE_VALUE   For |CI-1
69072>>>>>>>>>Define vINVALID_FILE_SIZE      For |CI$FFFFFFFF
69072>>>>>>>>>Define vERROR_NO_MORE_FILES    For |CI18
69072>>>>>>>>>
69072>>>>>>>>>// The defines below can be used to find out what kind of error has occurred if
69072>>>>>>>>>// the API-call ShellExecute is used.
69072>>>>>>>>>Define vERROR_FILE_NOT_FOUND   For |CI0002
69072>>>>>>>>>Define vERROR_PATH_NOT_FOUND   For |CI0003
69072>>>>>>>>>Define vERROR_BAD_FORMAT       For |CI0011
69072>>>>>>>>>Define vSE_ERR_ACCESSDENIED    For |CI0005
69072>>>>>>>>>Define vSE_ERR_ASSOCINCOMPLETE For |CI0027
69072>>>>>>>>>Define vSE_ERR_DDEBUSY         For |CI0030
69072>>>>>>>>>Define vSE_ERR_DDEFAIL         For |CI0029
69072>>>>>>>>>Define vSE_ERR_DDETIMEOUT      For |CI0028
69072>>>>>>>>>Define vSE_ERR_DLLNOTFOUND     For |CI0032
69072>>>>>>>>>Define vSE_ERR_FNF             For |CI0002
69072>>>>>>>>>Define vSE_ERR_NOASSOC         For |CI0031
69072>>>>>>>>>Define vSE_ERR_OOM             For |CI0008
69072>>>>>>>>>Define vSE_ERR_PNF             For |CI0003
69072>>>>>>>>>Define vSE_ERR_SHARE           For |CI0026
69072>>>>>>>>>
69072>>>>>>>>>
69072>>>>>>>>>// C-Structure
69072>>>>>>>>>//typedef struct _browseinfo {
69072>>>>>>>>>//    HWND hwndOwner;
69072>>>>>>>>>//    LPCITEMIDLIST pidlRoot;
69072>>>>>>>>>//    LPSTR pszDisplayName;
69072>>>>>>>>>//    LPCSTR lpszTitle;
69072>>>>>>>>>//    UINT ulFlags;
69072>>>>>>>>>//    BFFCALLBACK lpfn;
69072>>>>>>>>>//    LPARAM lParam;
69072>>>>>>>>>//    int iImage;
69072>>>>>>>>>//} BROWSEINFO, *PBROWSEINFO, *LPBROWSEINFO;
69072>>>>>>>>>
69072>>>>>>>>>//declare C structure struct_browseinfo
69072>>>>>>>>>//as documented in MSDN under Windows Shell API
69072>>>>>>>>>Struct tvBrowseInfo
69072>>>>>>>>>  Handle    hWndOwner
69072>>>>>>>>>  Pointer   pIDLRoot
69072>>>>>>>>>  Pointer   pszDisplayName
69072>>>>>>>>>  Pointer   lpszTitle
69072>>>>>>>>>  dWord     ulFlags
69072>>>>>>>>>  Pointer   lpfnCallback
69072>>>>>>>>>  dWord     lParam
69072>>>>>>>>>  DWord     iImage
69072>>>>>>>>>End_Struct // tvBrowseInfo
69072>>>>>>>>>
69072>>>>>>>>>// Browsing for directory.
69072>>>>>>>>>Define vBIF_RETURNONLYFSDIRS   For |CI$0001  // For finding a folder to start document searching
69072>>>>>>>>>Define vBIF_DONTGOBELOWDOMAIN  For |CI$0002  // For starting the Find Computer
69072>>>>>>>>>Define vBIF_STATUSTEXT         For |CI$0004  // Includes a status area in the dialog box.
69072>>>>>>>>>                                            // The callback function can set the status text by
69072>>>>>>>>>                                            // sending messages to the dialog box.
69072>>>>>>>>>Define vBIF_RETURNFSANCESTORS  For |CI$0008  // Only returns file system ancestors.
69072>>>>>>>>>
69072>>>>>>>>>Define vBIF_BROWSEFORCOMPUTER  For |CI$1000  // Browsing for Computers.
69072>>>>>>>>>Define vBIF_BROWSEFORPRINTER   For |CI$2000  // Browsing for Printers
69072>>>>>>>>>
69072>>>>>>>>>// message from browser
69072>>>>>>>>>//Define BFFM_INITIALIZED        1
69072>>>>>>>>>//Define BFFM_SELCHANGED         2
69072>>>>>>>>>
69072>>>>>>>>>// messages to browser
69072>>>>>>>>>//Define BFFM_SETSTATUSTEXT      (WM_USER + 100)
69072>>>>>>>>>//Define BFFM_ENABLEOK           (WM_USER + 101)
69072>>>>>>>>>//Define BFFM_SETSELECTION       (WM_USER + 102)
69072>>>>>>>>>
69072>>>>>>>>>
69072>>>>>>>>>External_function vWin32_SHBrowseForFolder "SHBrowseForFolder" shell32.dll ;  Pointer lpsBrowseInfo Returns dWord
69073>>>>>>>>>
69073>>>>>>>>>External_function vWin32_SHGetPathFromIDList "SHGetPathFromIDList" shell32.dll ;  Pointer pidList Pointer lpBuffer Returns dWord
69074>>>>>>>>>
69074>>>>>>>>>External_function vWin32_CoTaskMemFree "CoTaskMemFree" ole32.dll Pointer pV Returns Integer
69075>>>>>>>>>
69075>>>>>>>>>
69075>>>>>>>>>
69075>>>>>>>>>
69075>>>>>>>>>Struct tvSecurity_attributes
69075>>>>>>>>>  DWord   nLength
69075>>>>>>>>>  Pointer lpDescriptor
69075>>>>>>>>>  Integer bInheritHandle
69075>>>>>>>>>End_Struct // tvSecurity_attributes
69075>>>>>>>>>
69075>>>>>>>>>//nLength:
69075>>>>>>>>>// Specifies the size, in bytes, of this structure. Set this value to the size of the
69075>>>>>>>>>// SECURITY_ATTRIBUTES structure.
69075>>>>>>>>>// Windows NT: Some functions that use the SECURITY_ATTRIBUTES structure do not verify the
69075>>>>>>>>>// value of the nLength member. However, an application should still set it properly.
69075>>>>>>>>>// That ensures current, future, and cross-platform compatibility.
69075>>>>>>>>>//
69075>>>>>>>>>//lpSecurityDescriptor:
69075>>>>>>>>>// Points to a security descriptor for the object that controls the sharing of it.
69075>>>>>>>>>// If NULL is specified for this member, the object may be assigned the default security
69075>>>>>>>>>// descriptor of the calling process.
69075>>>>>>>>>//
69075>>>>>>>>>//bInheritHandle:
69075>>>>>>>>>// Specifies whether the returned handle is inherited when a new process is created.
69075>>>>>>>>>// If this member is TRUE, the new process inherits the handle.
69075>>>>>>>>>
69075>>>>>>>>>
69075>>>>>>>>>// BOOL CreateDirectory(
69075>>>>>>>>>//    LPCTSTR lpPathName,
69075>>>>>>>>>//    LPSECURITY_ATTRIBUTES lpSecurityAttributes  // pointer to a security descriptor
69075>>>>>>>>>//   );
69075>>>>>>>>>//
69075>>>>>>>>>// lpPathName
69075>>>>>>>>>//  Points to a null-terminated string that specifies the path of the directory
69075>>>>>>>>>//  to be created.
69075>>>>>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
69075>>>>>>>>>//  This limit is related to how the CreateDirectory function parses paths.
69075>>>>>>>>>// lpSecurityAttributes
69075>>>>>>>>>//  Pointer to a SECURITY_ATTRIBUTES structure als called a security descriptor that
69075>>>>>>>>>//  determines whether the returned handle can be inherited by child processes.
69075>>>>>>>>>//  If lpSecurityAttributes is NULL, the handle cannot be inherited.
69075>>>>>>>>>// Returns:
69075>>>>>>>>>//  If the function succeeds, the return value is nonzero.
69075>>>>>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
69075>>>>>>>>>External_function vWin32_CreateDirectory "CreateDirectoryA" kernel32.dll ;  Pointer lpPathName Pointer lpSecurity_Attributes Returns Integer
69076>>>>>>>>>
69076>>>>>>>>>
69076>>>>>>>>>// lpPathName
69076>>>>>>>>>//  Points to a null-terminated string that specifies the path of the directory
69076>>>>>>>>>//  to be removed.
69076>>>>>>>>>//  There is a default string size limit for paths of MAX_PATH characters.
69076>>>>>>>>>// Returns:
69076>>>>>>>>>//  If the function succeeds, the return value is nonzero.
69076>>>>>>>>>//  If the function fails, the return value is zero. To get extended error information, call GetLastError.
69076>>>>>>>>>External_function vWin32_RemoveDirectory "RemoveDirectoryA" kernel32.dll ;  Pointer lpPathName Returns Integer
69077>>>>>>>>>
69077>>>>>>>>>
69077>>>>>>>>>
69077>>>>>>>>>// The ShellExecute function opens or prints a specified file. The file can be an
69077>>>>>>>>>// executable file or a document file.
69077>>>>>>>>>//
69077>>>>>>>>>// Operation can be one of the following:
69077>>>>>>>>>//    "OPEN"  The function opens the file specified by lpFile.
69077>>>>>>>>>//            The file can be an executable file or a document file.
69077>>>>>>>>>//            The file can be a folder to open.
69077>>>>>>>>>//    "PRINT" The function prints the file specified by lpFile.
69077>>>>>>>>>//            The file should be a document file. If the file is an executable file,
69077>>>>>>>>>//            the function opens the file, as if "open" had been specified.
69077>>>>>>>>>//  "EXPLORE" The function explores the folder specified by lpFile.
69077>>>>>>>>>//
69077>>>>>>>>>// Return Values:
69077>>>>>>>>>//
69077>>>>>>>>>// If the function succeeds, the return value is the instance handle of the application that
69077>>>>>>>>>// was run, or the handle of a dynamic data exchange (DDE) server application.
69077>>>>>>>>>// If the function fails, the return value is an error value that is less than or equal to 32.
69077>>>>>>>>>//
69077>>>>>>>>>// The following table lists these error values:
69077>>>>>>>>>// Public Const ERROR_FILE_NOT_FOUND = 2&
69077>>>>>>>>>// Public Const ERROR_PATH_NOT_FOUND = 3&
69077>>>>>>>>>// Public Const ERROR_BAD_FORMAT = 11&
69077>>>>>>>>>// Public Const SE_ERR_ACCESSDENIED = 5
69077>>>>>>>>>// Public Const SE_ERR_ASSOCINCOMPLETE = 27
69077>>>>>>>>>// Public Const SE_ERR_DDEBUSY = 30
69077>>>>>>>>>// Public Const SE_ERR_DDEFAIL = 29
69077>>>>>>>>>// Public Const SE_ERR_DDETIMEOUT = 28
69077>>>>>>>>>// Public Const SE_ERR_DLLNOTFOUND = 32
69077>>>>>>>>>// Public Const SE_ERR_FNF = 2
69077>>>>>>>>>// Public Const SE_ERR_NOASSOC = 31
69077>>>>>>>>>// Public Const SE_ERR_OOM = 8
69077>>>>>>>>>// Public Const SE_ERR_PNF = 3
69077>>>>>>>>>// Public Const SE_ERR_SHARE = 26
69077>>>>>>>>>
69077>>>>>>>>>
69077>>>>>>>>>
69077>>>>>>>>>// Code to open the program that is associated with the selected file.
69077>>>>>>>>>//
69077>>>>>>>>>// External function call used in Procedure DoStartDocument
69077>>>>>>>>>External_function vWin32_ShellExecute "ShellExecuteA" shell32.dll ;  Handle hWnd ;  Pointer lpOperation ;  Pointer lpFile ;  Pointer lpParameters ;  Pointer lpDirectory ;  Dword iShowCmd Returns Handle
69078>>>>>>>>>
69078>>>>>>>>>
69078>>>>>>>>>
69078>>>>>>>>>
69078>>>>>>>>>Define vFO_MOVE                For |CI$0001
69078>>>>>>>>>Define vFO_COPY                For |CI$0002
69078>>>>>>>>>Define vFO_DELETE              For |CI$0003
69078>>>>>>>>>Define vFO_RENAME              For |CI$0004
69078>>>>>>>>>
69078>>>>>>>>>Define vFOF_MULTIDESTFILES     For |CI$0001
69078>>>>>>>>>Define vFOF_CONFIRMMOUSE       For |CI$0002
69078>>>>>>>>>Define vFOF_SILENT             For |CI$0004  // don't create progress/report
69078>>>>>>>>>Define vFOF_RENAMEONCOLLISION  For |CI$0008
69078>>>>>>>>>Define vFOF_NOCONFIRMATION     For |CI$0010  // Don't prompt the user.
69078>>>>>>>>>Define vFOF_WANTMAPPINGHANDLE  For |CI$0020  // Fill in SHFILEOPSTRUCT.hNameMappings
69078>>>>>>>>>                                          // Must be freed using SHFreeNameMappings
69078>>>>>>>>>Define vFOF_ALLOWUNDO          For |CI$0040
69078>>>>>>>>>Define vFOF_FILESONLY          For |CI$0080  // on *.*, do only files
69078>>>>>>>>>Define vFOF_SIMPLEPROGRESS     For |CI$0100  // means don't show names of files
69078>>>>>>>>>Define vFOF_NOCONFIRMMKDIR     For |CI$0200  // don't confirm making any needed dirs
69078>>>>>>>>>
69078>>>>>>>>>Struct tvShFileOpStruct
69078>>>>>>>>>  Handle  hWnd
69078>>>>>>>>>  Integer wFunc
69078>>>>>>>>>  Pointer pFrom
69078>>>>>>>>>  Pointer pTo
69078>>>>>>>>>  Short   fFlags
69078>>>>>>>>>  Short   fAnyOperationsAborted
69078>>>>>>>>>  Pointer hNameMappings
69078>>>>>>>>>  Pointer lpszProgressTitle      // only used if FOF_SIMPLEPROGRESS
69078>>>>>>>>>End_Struct // tvShFileOpStruct
69078>>>>>>>>>
69078>>>>>>>>>// hwnd
69078>>>>>>>>>//   Handle of the dialog box to use to display information about the status of the operation.
69078>>>>>>>>>
69078>>>>>>>>>// wFunc
69078>>>>>>>>>//   Operation to perform. This member can be one of the following values:
69078>>>>>>>>>//     FO_COPY     Copies the files specified by pFrom to the location specified by pTo.
69078>>>>>>>>>//     FO_DELETE   Deletes the files specified by pFrom (pTo is ignored).
69078>>>>>>>>>//     FO_MOVE     Moves the files specified by pFrom to the location specified by pTo.
69078>>>>>>>>>//     FO_RENAME   Renames the files specified by pFrom.
69078>>>>>>>>>
69078>>>>>>>>>// pFrom
69078>>>>>>>>>//   Pointer to a buffer that specifies one or more source file names. Multiple names must
69078>>>>>>>>>//   be null-separated. The list of names must be double null-terminated.
69078>>>>>>>>>
69078>>>>>>>>>// pTo
69078>>>>>>>>>//   Pointer to a buffer that contains the name of the destination file or directory. The
69078>>>>>>>>>//   buffer can contain mutiple destination file names if the fFlags member specifies
69078>>>>>>>>>//   FOF_MULTIDESTFILES. Multiple names must be null-separated. The list of names must be
69078>>>>>>>>>//   double null-terminated.
69078>>>>>>>>>
69078>>>>>>>>>// fAnyOperationsAborted
69078>>>>>>>>>//   Value that receives TRUE if the user aborted any file operations before they
69078>>>>>>>>>//   were completed or FALSE otherwise.
69078>>>>>>>>>
69078>>>>>>>>>
69078>>>>>>>>>// Performs a copy, move, rename, or delete operation on a file system object.
69078>>>>>>>>>// This can be a file or a folder.
69078>>>>>>>>>// With thanks to Andrew S Kaplan
69078>>>>>>>>>External_function vWin32_SHFileOperation "SHFileOperationA" Shell32.dll ;        Pointer lpFileOp Returns Integer
69079>>>>>>>>>
69079>>>>>>>>>
69079>>>>>>>>>// Thanks To Oliver Nelson for posting this code on the newsgroups
69079>>>>>>>>>External_function vWin32_GetWindowsDirectory "GetWindowsDirectoryA" kernel32.dll ;                           Pointer lpBuffer Integer nSize Returns Integer
69080>>>>>>>>>
69080>>>>>>>>>
69080>>>>>>>>>
69080>>>>>>>>>// Courtesy Of Vincent Oorsprong
69080>>>>>>>>>//External_Function vWin32_GetTempFileName "GetTempFileNameA" Kernel32.Dll ;
69080>>>>>>>>>//   Pointer lpPathName ;
69080>>>>>>>>>//   Pointer lpPrefixString ;
69080>>>>>>>>>//   Integer uUnique ;
69080>>>>>>>>>//   Pointer lpTempFileName ;
69080>>>>>>>>>//   Returns Integer
69080>>>>>>>>>// **WvA: 28-04-2005 Changed string parameter type into pointers
69080>>>>>>>>>External_function vWin32_GetTempFileName "GetTempFileNameA" kernel32.dll Pointer lpsPath ;        Pointer lpsPrefix Integer iUnique Pointer pLoad Returns Integer
69081>>>>>>>>>
69081>>>>>>>>>External_function vWin32_GetTempPath "GetTempPathA" Kernel32.Dll ;   Dword nBufferLength ;   Pointer lpBuffer ;   Returns Integer
69082>>>>>>>>>
69082>>>>>>>>>External_function vWin32_DeleteFile "DeleteFileA" Kernel32.Dll ;   Pointer lpFileName ;   Returns Integer
69083>>>>>>>>>
69083>>>>>>>>>// from:
69083>>>>>>>>>// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/shellcc/platform/shell/reference/enums/csidl.asp
69083>>>>>>>>>//
69083>>>>>>>>>Define vCSIDL_FLAG_CREATE       For |CI$8000 // IE5+, use this to create a special folder
69083>>>>>>>>>Define vCSIDL_ADMIN_TOOLS       For |CI$0030 // IE5+, The file system directory that is used to store administrative tools for an individual user
69083>>>>>>>>>Define vCSIDL_ALT_STARTUP       For |CI$001D // The file system directory that corresponds to the user's nonlocalized Startup program group
69083>>>>>>>>>Define vCSIDL_APPDATA           For |CI$001A // Version 4.71. The file system directory that serves as a common repository for application-specific data. A typical path is C:\Documents and Settings\<username>\Application Data
69083>>>>>>>>>Define vCSIDL_BITBUCKET         For |CI$000A // The virtual folder containing the objects in the user's Recycle Bin
69083>>>>>>>>>Define vCSIDL_CDBURN_AREA       For |CI$003B // IE6+ The file system directory acting as a staging area for files waiting to be written to CD. A typical path is C:\Documents and Settings\<username>\Local Settings\Application Data\Microsoft\CD Burning
69083>>>>>>>>>Define vCSIDL_COMMON_ADMINTOOLS For |CI$002F // IE5+ The file system directory containing administrative tools for all users of the computer
69083>>>>>>>>>Define vCSIDL_COMMON_ALTSTARTUP For |CI$001E // The file system directory that corresponds to the nonlocalized Startup program group for all users
69083>>>>>>>>>Define vCSIDL_COMMON_APPDATA    For |CI$0023 // IE5+ The file system directory containing application data for all users. A typical path is C:\Documents and Settings\All Users\Application Data
69083>>>>>>>>>Define vCSIDL_COMMON_DESKTOPDIRECTORY for |CI$0019 // WinNT+ Only, The file system directory that contains files and folders that appear on the desktop for all users. A typical path is C:\Documents and Settings\All Users\Desktop
69083>>>>>>>>>Define vCSIDL_COMMON_DOCUMENTS  For |CI$002E // IE5+ The file system directory that contains documents that are common to all users. A typical paths is C:\Documents and Settings\All Users\Documents
69083>>>>>>>>>Define vCSIDL_COMMON_FAVORITES  For |CI$001F // The file system directory that serves as a common repository for favorite items common to all users
69083>>>>>>>>>Define vCSIDL_COMMON_MUSIC      For |CI$0035 // IE6+ The file system directory that serves as a repository for music files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Music
69083>>>>>>>>>Define vCSIDL_COMMON_PICTURES   For |CI$0036 // The file system directory that serves as a repository for image files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Pictures
69083>>>>>>>>>Define vCSIDL_COMMON_PROGRAMS   For |CI$0017 // WinNT+ The file system directory that contains the directories for the common program groups that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs
69083>>>>>>>>>Define vCSIDL_COMMON_STARTMENU  For |CI$0016 // WinNT+ The file system directory that contains the programs and folders that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu
69083>>>>>>>>>Define vCSIDL_COMMON_STARTUP    For |CI$0018 // WinNT+ The file system directory that contains the programs that appear in the Startup folder for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs\Startup
69083>>>>>>>>>Define vCSIDL_COMMON_TEMPLATES  For |CI$002D // WinNT+ The file system directory that contains the templates that are available to all users. A typical path is C:\Documents and Settings\All Users\Templates
69083>>>>>>>>>Define vCSIDL_COMMON_VIDEO      For |CI$0037 // IE6+ The file system directory that serves as a repository for video files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Videos
69083>>>>>>>>>Define vCSIDL_COMPUTERSNEARME   For |CI$003D // The folder representing other machines in your workgroup
69083>>>>>>>>>Define vCSIDL_CONNECTIONS       For |CI$0031 // The virtual folder representing Network Connections, containing network and dial-up connections
69083>>>>>>>>>Define vCSIDL_CONTROLS          For |CI$0003 // The virtual folder containing icons for the Control Panel applications
69083>>>>>>>>>Define vCSIDL_COOKIES           For |CI$0021 // The file system directory that serves as a common repository for Internet cookies. A typical path is C:\Documents and Settings\username\Cookies
69083>>>>>>>>>Define vCSIDL_DESKTOP           For |CI$0000 // The virtual folder representing the Windows desktop, the root of the namespace
69083>>>>>>>>>Define vCSIDL_DESKTOPDIRECTORY  For |CI$0010 // The file system directory used to physically store file objects on the desktop (not to be confused with the desktop folder itself). A typical path is C:\Documents and Settings\username\Desktop
69083>>>>>>>>>Define vCSIDL_DRIVES            For |CI$0011 // The virtual folder representing My Computer, containing everything on the local computer: storage devices, printers, and Control Panel. The folder may also contain mapped network drives
69083>>>>>>>>>Define vCSIDL_FAVORITES         For |CI$0006 // The file system directory that serves as a common repository for the user's favorite items. A typical path is C:\Documents and Settings\username\Favorites
69083>>>>>>>>>Define vCSIDL_FONTS             For |CI$0014 // A virtual folder containing fonts. A typical path is C:\Windows\Fonts
69083>>>>>>>>>Define vCSIDL_HISTORY           For |CI$0022 // The file system directory that serves as a common repository for Internet history items
69083>>>>>>>>>Define vCSIDL_INTERNET          For |CI$0001 // A virtual folder representing the Internet
69083>>>>>>>>>Define vCSIDL_INTERNET_CACHE    For |CI$0020 // Comctl4.72+, The file system directory that serves as a common repository for temporary Internet files. A typical path is C:\Documents and Settings\username\Local Settings\Temporary Internet Files
69083>>>>>>>>>Define vCSIDL_LOCAL_APPDATA     For |CI$001C // IE5+ The file system directory that serves as a data repository for local (nonroaming) applications. A typical path is C:\Documents and Settings\username\Local Settings\Application Data
69083>>>>>>>>>Define vCSIDL_MYDOCUMENTS       For |CI$000C // IE6+ The virtual folder representing the My Documents desktop item
69083>>>>>>>>>Define vCSIDL_MYMUSIC           For |CI$000D // The file system directory that serves as a common repository for music files. A typical path is C:\Documents and Settings\User\My Documents\My Music
69083>>>>>>>>>Define vCSIDL_MYPICTURES        For |CI$0027 // IE5+ The file system directory that serves as a common repository for image files. A typical path is C:\Documents and Settings\username\My Documents\My Pictures
69083>>>>>>>>>Define vCSIDL_MYVIDEO           For |CI$000E // IE6+ The file system directory that serves as a common repository for video files. A typical path is C:\Documents and Settings\username\My Documents\My Videos
69083>>>>>>>>>Define vCSIDL_NETHOOD           For |CI$0013 // A file system directory containing the link objects that may exist in the My Network Places virtual folder. It is not the same as CSIDL_NETWORK, which represents the network namespace root. A typical path is C:\Documents and Settings\username\NetHood
69083>>>>>>>>>Define vCSIDL_NETWORK           For |CI$0012 // A virtual folder representing Network Neighborhood, the root of the network namespace hierarchy
69083>>>>>>>>>Define vCSIDL_PERSONAL          For |CI$0005 // (Documents folder) IE6 The virtual folder representing the My Documents desktop item.
69083>>>>>>>>>                                             // This is equivalent to CSIDL_MYDOCUMENTS. Previous to Version 6.0. The file system directory used to physically store a user's common repository of documents. A typical path is C:\Documents and Settings\username\My Documents
69083>>>>>>>>>Define vCSIDL_PHOTOALBUMS       For |CI$0045 // Vista+ The virtual folder used to store photo albums, typically username\My Pictures\Photo Albums
69083>>>>>>>>>Define vCSIDL_PLAYLISTS         For |CI$003F // Vista+ The virtual folder used to store play albums, typically username\My Music\Playlists
69083>>>>>>>>>Define vCSIDL_PRINTERS          For |CI$0004 // The virtual folder containing installed printers
69083>>>>>>>>>Define vCSIDL_PRINTHOOD         For |CI$001B // The file system directory that contains the link objects that can exist in the Printers virtual folder. A typical path is C:\Documents and Settings\username\PrintHood
69083>>>>>>>>>Define vCSIDL_PROFILE           For |CI$0028 // IE5+ The user's profile folder. A typical path is C:\Documents and Settings\username
69083>>>>>>>>>Define vCSIDL_PROGRAM_FILES     For |CI$0026 // IE5+ The Program Files folder. A typical path is C:\Program Files
69083>>>>>>>>>Define vCSIDL_PROGRAM_FILESx86  for |CI$002A // The Program Files folder for x86 programs. A typical path is C:\Program Files (x86)
69083>>>>>>>>>Define vCSIDL_PROGRAM_FILES_COMMON For |CI$002B // IE5+, WinNT+ A folder for components that are shared across applications. A typical path is C:\Program Files\Common
69083>>>>>>>>>Define vCSIDL_PROGRAMS          For |CI$0002 // The file system directory that contains the user's program groups (which are themselves file system directories). A typical path is C:\Documents and Settings\username\Start Menu\Programs
69083>>>>>>>>>Define vCSIDL_RECENT            For |CI$0008 // The file system directory that contains shortcuts to the user's most recently used documents. A typical path is C:\Documents and Settings\username\My Recent Documents
69083>>>>>>>>>Define vCSIDL_RESOURCES         For |CI$0038 // undocumented
69083>>>>>>>>>Define vCSIDL_SAMPLE_MUSIC      For |CI$0040 // Vista+, The file system directory that contains sample music. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Music
69083>>>>>>>>>Define vCSIDL_SAMPLE_PLAYLISTS  For |CI$0041 // Vista+, The file system directory that contains sample playlists. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Playlists
69083>>>>>>>>>Define vCSIDL_SAMPLE_PICTURES   For |CI$0042 // Vista+, The file system directory that contains sample pictures. A typical path is C:\Documents and Settings\username\My Documents\My Pictures\Sample Pictures
69083>>>>>>>>>Define vCSIDL_SAMPLE_VIDEOS     For |CI$0043 // Vista+, The file system directory that contains sample videos. A typical path is C:\Documents and Settings\username\My Documents\My Videos\Sample Videos
69083>>>>>>>>>Define vCSIDL_SENDTO            For |CI$0009 // The file system directory that contains Send To menu items. A typical path is C:\Documents and Settings\username\SendTo
69083>>>>>>>>>Define vCSIDL_STARTMENU         For |CI$000B // The file system directory containing Start menu items. A typical path is C:\Documents and Settings\username\Start Menu
69083>>>>>>>>>Define vCSIDL_STARTUP           For |CI$0007 // The file system directory that corresponds to the user's Startup program group. The system starts these programs whenever any user logs onto Windows NT or starts Windows 95. A typical path is C:\Documents and Settings\username\Start Menu\Programs\Startup
69083>>>>>>>>>Define vCSIDL_SYSTEM            For |CI$0025 // The Windows System folder. A typical path is C:\Windows\System32
69083>>>>>>>>>Define vCSIDL_SYSTEMX86         For |CI$0029 //
69083>>>>>>>>>Define vCSIDL_TEMPLATES         For |CI$0015 // The file system directory that serves as a common repository for document templates. A typical path is C:\Documents and Settings\username\Templates
69083>>>>>>>>>Define vCSIDL_WINDOWS           For |CI$0024 // The Windows directory or SYSROOT. This corresponds to the %windir% or %SYSTEMROOT% environment variables. A typical path is C:\Windows
69083>>>>>>>>>
69083>>>>>>>>>
69083>>>>>>>>>//HRESULT SHGetFolderPath(
69083>>>>>>>>>//    HWND hwndOwner,
69083>>>>>>>>>//    int nFolder,
69083>>>>>>>>>//    HANDLE hToken,
69083>>>>>>>>>//    DWORD dwFlags,
69083>>>>>>>>>//    LPTSTR pszPath
69083>>>>>>>>>//);
69083>>>>>>>>>// This function is a superset of SHGetSpecialFolderPath, included with earlier versions of
69083>>>>>>>>>// the shell. It is implemented in a redistributable DLL, SHFolder.dll, that also simulates
69083>>>>>>>>>// many of the new shell folders on older platforms such as Windows 95, Windows 98, and
69083>>>>>>>>>// Windows NT 4.0. This DLL always calls the current platform's version of this function.
69083>>>>>>>>>// If that fails, it will try to simulate the appropriate behavior.
69083>>>>>>>>>//
69083>>>>>>>>>External_function vWin32_SHGetFolderPath "SHGetFolderPathA" SHFolder.Dll ;   Pointer hWnd ;   Integer nFolder ;   Pointer hToken ;   DWord   dwFlags ;   Pointer lpszPath ;   Returns Integer
69084>>>>>>>>>
69084>>>>>>>>>
69084>>>>>>>>>
69084>>>>>>>>>Struct tvWin32FindData
69084>>>>>>>>> Dword            dwFileAttributes
69084>>>>>>>>> Dword            ftCreationLowDateTime
69084>>>>>>>>> Dword            ftCreationHighDateTime
69084>>>>>>>>> dword            ftLastAccessLowDateTime
69084>>>>>>>>> Dword            ftLastAccessHighDateTime
69084>>>>>>>>> Dword            ftLastWriteLowDateTime
69084>>>>>>>>> Dword            ftLastWriteHighDateTime
69084>>>>>>>>> Dword            nFileSizeHigh
69084>>>>>>>>> Dword            nFileSizeLow
69084>>>>>>>>> Dword            dwReserved0
69084>>>>>>>>> Dword            dwReserved1
69084>>>>>>>>> UChar[vMax_Path] cFileName
69084>>>>>>>>> UChar[14]        cAlternateFileName
69084>>>>>>>>>End_Struct
69084>>>>>>>>>
69084>>>>>>>>>// Courtesy Of Vincent Oorsprong
69084>>>>>>>>>// lpFileName      : address of name of file to search for
69084>>>>>>>>>// lpFindFileData  : address of returned information
69084>>>>>>>>>External_function vWin32_FindFirstFile "FindFirstFileA"  Kernel32.dll Pointer lpFileName ;          Pointer lpFindFileData Returns Handle
69085>>>>>>>>>
69085>>>>>>>>>// Courtesy Of Vincent Oorsprong
69085>>>>>>>>>// hFindFile       : handle of search
69085>>>>>>>>>// lpFindFileData  : address of structure for data on found file
69085>>>>>>>>>External_function vWin32_FindNextFile "FindNextFileA" Kernel32.dll Handle hFindFile ;          Pointer lpFindFileData Returns Integer
69086>>>>>>>>>
69086>>>>>>>>>//
69086>>>>>>>>>// Unicode equivalents
69086>>>>>>>>>//
69086>>>>>>>>>// lpFileName      : address of name of file to search for
69086>>>>>>>>>// lpFindFileData  : address of returned information
69086>>>>>>>>>External_function vWin32W_FindFirstFile "FindFirstFileW"  Kernel32.dll Pointer lpFileName ;          Pointer lpFindFileData Returns Handle
69087>>>>>>>>>
69087>>>>>>>>>// hFindFile       : handle of search
69087>>>>>>>>>// lpFindFileData  : address of structure for data on found file
69087>>>>>>>>>External_function vWin32W_FindNextFile "FindNextFileW" Kernel32.dll Handle hFindFile ;          Pointer lpFindFileData Returns Integer
69088>>>>>>>>>
69088>>>>>>>>>
69088>>>>>>>>>// Courtesy Of Vincent Oorsprong
69088>>>>>>>>>//  hFindFile      : file search handle
69088>>>>>>>>>External_function vWin32_FindClose "FindClose" Kernel32.dll Handle hFindFile Returns Integer
69089>>>>>>>>>
69089>>>>>>>>>
69089>>>>>>>>>
69089>>>>>>>>>Struct tvFileTime
69089>>>>>>>>>  DWord dwLowDateTime
69089>>>>>>>>>  DWord dwHighDateTime
69089>>>>>>>>>End_Struct
69089>>>>>>>>>
69089>>>>>>>>>
69089>>>>>>>>>Struct tvSystemTime
69089>>>>>>>>>  UShort wYear
69089>>>>>>>>>  UShort wMonth
69089>>>>>>>>>  UShort wDayOfWeek
69089>>>>>>>>>  UShort wDay
69089>>>>>>>>>  UShort wHour
69089>>>>>>>>>  UShort wMinute
69089>>>>>>>>>  UShort wSecond
69089>>>>>>>>>  UShort wMilliSeconds
69089>>>>>>>>>End_Struct
69089>>>>>>>>>
69089>>>>>>>>>
69089>>>>>>>>>// Courtesy Of Vincent Oorsprong
69089>>>>>>>>>//  lpFileTime     : pointer to file time to convert
69089>>>>>>>>>//  lpSystemTime   : pointer to structure to receive system time
69089>>>>>>>>>External_function vWin32_FileTimeToSystemTime "FileTimeToSystemTime" Kernel32.Dll ;          Pointer lpFileTime Pointer lpsystemTime Returns Integer
69090>>>>>>>>>
69090>>>>>>>>>// Courtesy Of Vincent Oorsprong
69090>>>>>>>>>// This function formats the time in a picture-string passed
69090>>>>>>>>>//
69090>>>>>>>>>// Picture      Meaning
69090>>>>>>>>>//    h         Hours with no leading zero for single-digit hours; 12-hour clock
69090>>>>>>>>>//    hh        Hours with leading zero for single-digit hours; 12-hour clock
69090>>>>>>>>>//    H         Hours with no leading zero for single-digit hours; 24-hour clock
69090>>>>>>>>>//    HH        Hours with leading zero for single-digit hours; 24-hour clock
69090>>>>>>>>>//    m         Minutes with no leading zero for single-digit minutes
69090>>>>>>>>>//    mm        Minutes with leading zero for single-digit minutes
69090>>>>>>>>>//    s         Seconds with no leading zero for single-digit seconds
69090>>>>>>>>>//    ss        Seconds with leading zero for single-digit seconds
69090>>>>>>>>>//    t         One character time marker string, such as A or P
69090>>>>>>>>>//    tt        Multicharacter time marker string, such as AM or PM
69090>>>>>>>>>//
69090>>>>>>>>>// For example, to get the time string  "11:29:40 PM"
69090>>>>>>>>>//    use the following picture string: "hh" : "mm" : "ss tt"
69090>>>>>>>>>
69090>>>>>>>>>External_function vWin32_GetTimeFormat "GetTimeFormatA" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpTimeStr ;  Integer cchTime Returns Integer
69091>>>>>>>>>
69091>>>>>>>>>
69091>>>>>>>>>// Courtesy Of Vincent Oorsprong
69091>>>>>>>>>// This function formats the date in a picture-string passed
69091>>>>>>>>>//
69091>>>>>>>>>// Picture      Meaning
69091>>>>>>>>>//    d         Day of month as digits with no leading zero for single-digit days.
69091>>>>>>>>>//    dd        Day of month as digits with leading zero for single-digit days.
69091>>>>>>>>>//    ddd       Day of week as a three-letter abbreviation. The function uses the
69091>>>>>>>>>//              LOCALE_SABBREVOAYMAME value associated with the specified locale.
69091>>>>>>>>>//    dddd      Day of week as its full name. The function uses the LOCALE_SDAYNAME
69091>>>>>>>>>//              value associated with the specified locale.
69091>>>>>>>>>//    M         Month as digits with no leading zero for single-digit months.
69091>>>>>>>>>//    MM        Month as digits with leading zero for single-digit months.
69091>>>>>>>>>//    MMM       Month as a three-letter abbreviation. The function uses the
69091>>>>>>>>>//              LOCALE_SABBREVMONTHNAME value associated with the specified locale.
69091>>>>>>>>>//    MMMM      Month as its full name. The function uses the LOCALE_SMONTHNAME value
69091>>>>>>>>>//              associated with the specified locale.
69091>>>>>>>>>//    y         Year as last two digits, but with no leading zero for years less than 10.
69091>>>>>>>>>//    yy        Year as last two digits, but with leading zero for years less than 10.
69091>>>>>>>>>//    yyyy      Year represented hy full four digits.
69091>>>>>>>>>//    gg        Period/era string. The function uses the CAL_SERASTRING value associated
69091>>>>>>>>>//              with the specified locale. This element is ignored if the date to be formatted
69091>>>>>>>>>//              does not have an associated era or period string.
69091>>>>>>>>>// For example, to get the date string  "Wed, Aug 31 94"
69091>>>>>>>>>// use the following picture string:    "ddd","MMM dd yy"
69091>>>>>>>>>
69091>>>>>>>>>External_function vWin32_GetDateFormat "GetDateFormatA" Kernel32.Dll ;  Dword LCID Dword dwFlags Pointer lpsSystemTime Pointer lpFormat Pointer lpDateStr ;  Integer cchDate Returns Integer
69092>>>>>>>>>
69092>>>>>>>>>Define LOCALE_NOUSEROVERRIDE    For |CI$80000000  //  do not use user overrides
69092>>>>>>>>>Define TIME_NOMIHUTESORSECONDS  For |CI$00000001  //  do not use minutes or seconds
69092>>>>>>>>>Define TIME_NOSECONDS           For |CI$00000002  //  do not use seconds
69092>>>>>>>>>Define TIME_NOTIMEMARKER        For |CI$00000004  //  do not use time marker
69092>>>>>>>>>Define TIME_FORCE24HOURFORMAT   For |CI$00000008  //  always use 24 hour format
69092>>>>>>>>>
69092>>>>>>>>>//  Date Flags for GetDateFormatW.
69092>>>>>>>>>//
69092>>>>>>>>>Define DATE_SHORTDATE           For |CI$00000001  //  use short date picture
69092>>>>>>>>>Define DATE_LONGDATE            For |CI$00000002  //  use long date picture
69092>>>>>>>>>Define DATE_USE_ALT_CALENDAR    For |CI$00000004  //  use alternate calendar (if any)
69092>>>>>>>>>
69092>>>>>>>>>
69092>>>>>>>>>External_function vWin32_SetLastError "SetLastError" Kernel32.Dll Dword dwLastError Returns Integer
69093>>>>>>>>>
69093>>>>>>>>>
69093>>>>>>>>>// **WvA: 20-02-2004
69093>>>>>>>>>// While i was testing the format capabilities i stumbled over a very
69093>>>>>>>>>// weird problem where it looks like that the integer value gets somehow translated
69093>>>>>>>>>// incorrectly into an unsigned integer.
69093>>>>>>>>>// I don't have the time to dive into this.. so added a workaround (and removed it again)
69093>>>>>>>>>// It does smell a bit fishy though
69093>>>>>>>>>// Tested it with the same results on both VDF7 and VDF9.1
69093>>>>>>>>>
69093>>>>>>>>>Define SHFMT_ID_DEFAULT        For |CI$0000FFFF // The default format ID
69093>>>>>>>>>Define SHFMT_OPT_DEFAULT       For |CI$00000000 // The default "Quick Format" option.
69093>>>>>>>>>Define SHFMT_OPT_FULL          For |CI$00000001 // Deselects the "Quick Format" option, providing a full format instead. This is useful when an unformatted disk is detected.
69093>>>>>>>>>Define SHFMT_OPT_SYSONLY       For |CI$00000002 // Selects the "Create an MS-DOS startup disk" option, creating a system boot disk.
69093>>>>>>>>>
69093>>>>>>>>>// Possible errors that can be returned by the shellformat function
69093>>>>>>>>>Define SHFMT_ERROR             For (|CI$FFFFFFFF+1) // An error occurred during the last format or no drive parameter passed. This does not indicate that the disk is unformatable.
69093>>>>>>>>>Define SHFMT_CANCEL            For (|CI$FFFFFFFE+1) // The last format was canceled.
69093>>>>>>>>>Define SHFMT_NOFORMAT          For (|CI$FFFFFFFD+1) // The drive cannot be formatted.
69093>>>>>>>>>
69093>>>>>>>>>
69093>>>>>>>>> // Courtesy Of Steve Walter,
69093>>>>>>>>> // USA Software, Inc
69093>>>>>>>>> // Format a disk
69093>>>>>>>>> // Called By:  Move (vWin32_ShFormatDrive(hWnd,0,$FFFF,1)) To dwReturn
69093>>>>>>>>>External_function vWin32_ShFormatDrive "SHFormatDrive" shell32.dll Handle hWnd ;         Integer iDrive Integer iFormatID Integer iOptions Returns DWORD
69094>>>>>>>>>
69094>>>>>>>>>// Michael Mullan.  I Wanted to create all the folders in one statement...
69094>>>>>>>>>
69094>>>>>>>>>// SHCreateDirectoryEx
69094>>>>>>>>>
69094>>>>>>>>>//    Note  This function is available through Microsoft Windows XP Service Pack 2 (SP2) and Windows Server 2003.
69094>>>>>>>>>//    It might be altered or unavailable in subsequent versions of Windows.
69094>>>>>>>>>//
69094>>>>>>>>>//    This function creates a file system folder whose fully qualified path is given by pszPath. If one or more
69094>>>>>>>>>//    of the intermediate folders do not exist, they are created as well. SHCreateDirectoryEx also verifies that
69094>>>>>>>>>//    the files are visible. If they are not visible, expect one of the following:
69094>>>>>>>>>//
69094>>>>>>>>>//        * If hwnd is set to a valid window handle, a message box is displayed warning the user that he or she
69094>>>>>>>>>//        might not be able to access the files. If the user chooses not to proceed, the function returns
69094>>>>>>>>>//        ERROR_CANCELLED.
69094>>>>>>>>>//        * If hwnd is set to NULL, no user interface is displayed and the function returns ERROR_CANCELLED.
69094>>>>>>>>>
69094>>>>>>>>>//        Returns ERROR_SUCCESS if successful. If the operation fails, other error codes can be returned,
69094>>>>>>>>>//        including those listed here. For values not specifically listed, see System Error Codes.
69094>>>>>>>>>//      161  ERROR_BAD_PATHNAME                The pszPath parameter was set to a relative path.
69094>>>>>>>>>//      206  ERROR_FILENAME_EXCED_RANGE     The path pointed to by pszPath is too long.
69094>>>>>>>>>//      3    ERROR_PATH_NOT_FOUND            The system cannot find the path pointed to by pszPath. The path may contain an invalid entry.
69094>>>>>>>>>//      80   ERROR_FILE_EXISTS                The directory exists.
69094>>>>>>>>>//      183  ERROR_ALREADY_EXISTS            The directory exists.
69094>>>>>>>>>//      1223 ERROR_CANCELLED                The user canceled the operation.
69094>>>>>>>>>
69094>>>>>>>>>//        int SHCreateDirectoryEx(
69094>>>>>>>>>//            HWND hwnd,
69094>>>>>>>>>//            LPCTSTR pszPath,
69094>>>>>>>>>//            const SECURITY_ATTRIBUTES *psa
69094>>>>>>>>>//        );
69094>>>>>>>>>
69094>>>>>>>>>External_function vWin32_SHCreateDirectoryEx "SHCreateDirectoryExA" shell32.dll Handle hWnd;                  pointer pszPath  Pointer lpSecurity_Attributes Returns Integer
69095>>>>>>>>>
69095>>>>>>>>> External_Function vWin32_PathIsDirectory "PathIsDirectoryA" SHLWAPI.DLL Pointer lpszPath Returns Integer
69096>>>>>>>
69096>>>>>>>
69096>>>>>>>//
69096>>>>>>>// Gets the string from the right of the last sStopChar in sFrom
69096>>>>>>>// If sStopChar has no occurences in the string an empty string is
69096>>>>>>>// returned.
69096>>>>>>>Function StringFromRightOfChar Global String sFrom String sStopChar Returns String
69098>>>>>>>    String  sRetVal
69098>>>>>>>    String  sChar
69098>>>>>>>    Integer iLength
69098>>>>>>>    Integer iPos
69098>>>>>>>    Boolean bStopChar
69098>>>>>>>    Move "" to sRetval
69099>>>>>>>    Move (Length(sFrom)) to iLength
69100>>>>>>>    If ((iLength>0) And (Pos(sStopChar,sFrom) <> 0)) Begin
69102>>>>>>>        Move iLength   to iPos
69103>>>>>>>        Move (False)   to bStopChar
69104>>>>>>>        While Not bStopChar
69108>>>>>>>            Move (Mid(sFrom,1,iPos)) to sChar
69109>>>>>>>            Decrement iPos
69110>>>>>>>            If ((sChar=sStopChar) Or (iPos<1)) Begin
69112>>>>>>>                Move (True) to bStopChar
69113>>>>>>>            End
69113>>>>>>>>
69113>>>>>>>            Else Begin
69114>>>>>>>                Move (sChar+sRetVal) to sRetVal
69115>>>>>>>            End
69115>>>>>>>>
69115>>>>>>>        Loop
69116>>>>>>>>
69116>>>>>>>    End
69116>>>>>>>>
69116>>>>>>>    Function_Return sRetVal
69117>>>>>>>End_Function
69118>>>>>>>
69118>>>>>>>// Pre:  sFileName contains the complete path of the file.
69118>>>>>>>// Post: returns the complete path of the file.
69118>>>>>>>// This function is inspired on function SEQ_ExtractPathFromFileName of Sture Andersen.
69118>>>>>>>Function ParseFolderName Global String sFileName Returns String
69120>>>>>>>    String sFile
69120>>>>>>>    String sFolderName
69120>>>>>>>    String sDirSep // this is "\" for windows, or "/" for unix
69120>>>>>>>
69120>>>>>>>    Move "" to sFolderName
69121>>>>>>>    Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
69122>>>>>>>    If sDirSep In sFileName Begin
69124>>>>>>>        Move (StringFromRightOfChar(sFileName,sDirSep)) to sFile
69125>>>>>>>        Move (Left(sFileName,Length(sFileName)-Length(sFile))) to sFolderName
69126>>>>>>>    End
69126>>>>>>>>
69126>>>>>>>    Else If ":" In sFileName Begin
69129>>>>>>>        Move (StringFromRightOfChar(sFileName,":")) to sFile
69130>>>>>>>        Move (Replace(sFile,sFileName,"")) to sFolderName
69131>>>>>>>    End
69131>>>>>>>>
69131>>>>>>>    Function_Return sFolderName
69132>>>>>>>End_Function
69133>>>>>>>
69133>>>>>>>// Pre:  sFileName contains the complete path of the file.
69133>>>>>>>// post: The returned filename has it's path removed, but will have a extension
69133>>>>>>>Function ParseFileName Global String sFileName Returns String
69135>>>>>>>    String sFolderName
69135>>>>>>>    String sDirSep // this is "\" for windows, or "/" for unix
69135>>>>>>>
69135>>>>>>>    Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep
69136>>>>>>>    Get ParseFolderName sFileName to sFolderName
69137>>>>>>>    If (sFolderName <> "") Begin
69139>>>>>>>        Move (Replace(sFolderName,sFileName,"")) to sFileName
69140>>>>>>>    End
69140>>>>>>>>
69140>>>>>>>    Move (Replace(sDirSep,sFileName,"")) to sFileName
69141>>>>>>>    Function_Return sFilename
69142>>>>>>>End_Function
69143>>>>>>>
69143>>>>>>>// Pre:  sFileName may contain the complete path of the file.
69143>>>>>>>//       or contain multiple dots in the filename, so temp.gif.bak will
69143>>>>>>>//       return "bak" as the extension and not "gif"
69143>>>>>>>// Post: returns the extension only, this extension can be a valid unixlike extension
69143>>>>>>>//       such as "html" or "java"
69143>>>>>>>Function ParseFileExtension Global String sFileName Returns String
69145>>>>>>>    String  sFileExtension
69145>>>>>>>    Get ParseFileName sFileName to sFileName // takes care of corner case with path containing a ".". eg. c:\frank.cheng\hello
69146>>>>>>>    Get StringFromRightOfChar sFileName "." to sFileExtension
69147>>>>>>>    Function_Return sFileExtension
69148>>>>>>>End_Function
69149>>>>>>>
69149>>>>>>>Define CS_DDE_ERR_UNKNOWN_LINE2   For ".\n"
69149>>>>>>>
69149>>>>>>>Function DDE_Error_To_String Integer iErrorID Returns String
69151>>>>>>>    String sMessage
69151>>>>>>>    Case Begin
69151>>>>>>>        Case (iErrorID = vERROR_FILE_NOT_FOUND)
69153>>>>>>>            Move CS_DDE_ERR_FILE_NOT_FOUND to sMessage
69154>>>>>>>            Case Break
69155>>>>>>>        Case (iErrorID = vERROR_PATH_NOT_FOUND)
69158>>>>>>>            Move CS_DDE_ERR_PATH_NOT_FOUND to sMessage
69159>>>>>>>            Case Break
69160>>>>>>>        Case (iErrorID = vERROR_BAD_FORMAT)
69163>>>>>>>            Move CS_DDE_ERR_BAD_FORMAT to sMessage
69164>>>>>>>            Case Break
69165>>>>>>>        Case (iErrorID = vSE_ERR_ACCESSDENIED)
69168>>>>>>>            Move CS_DDE_ERR_ACCESSDENIED to sMessage
69169>>>>>>>            Case Break
69170>>>>>>>        Case (iErrorID = vSE_ERR_ASSOCINCOMPLETE)
69173>>>>>>>            Move CS_DDE_ERR_ASSOCINCOMPLETE to sMessage
69174>>>>>>>            Case Break
69175>>>>>>>        Case (iErrorID = vSE_ERR_DDEBUSY)
69178>>>>>>>            Move CS_DDE_ERR_DDEBUSY to sMessage
69179>>>>>>>            Case Break
69180>>>>>>>        Case (iErrorID = vSE_ERR_DDEFAIL)
69183>>>>>>>            Move CS_DDE_ERR_DDEFAIL to sMessage
69184>>>>>>>            Case Break
69185>>>>>>>        Case (iErrorID = vSE_ERR_DDETIMEOUT)
69188>>>>>>>            Move CS_DDE_ERR_DDETIMEOUT to sMessage
69189>>>>>>>            Case Break
69190>>>>>>>        Case (iErrorID = vSE_ERR_DLLNOTFOUND)
69193>>>>>>>            Move CS_DDE_ERR_DLLNOTFOUND to sMessage
69194>>>>>>>            Case Break
69195>>>>>>>        Case (iErrorID = vSE_ERR_NOASSOC)
69198>>>>>>>            Move CS_DDE_ERR_NOASSOC to sMessage
69199>>>>>>>            Case Break
69200>>>>>>>        Case ((iErrorID = vSE_ERR_OOM) Or (iErrorID = 0))
69203>>>>>>>            Move CS_DDE_ERR_OOM to sMessage
69204>>>>>>>            Case Break
69205>>>>>>>        Case (iErrorID = vSE_ERR_PNF)
69208>>>>>>>            Move CS_DDE_ERR_PNF to sMessage
69209>>>>>>>            Case Break
69210>>>>>>>        Case (iErrorID = vSE_ERR_SHARE)
69213>>>>>>>            Move CS_DDE_ERR_SHARE to sMessage
69214>>>>>>>            Case Break
69215>>>>>>>        Case Else
69215>>>>>>>            Move CS_DDE_ERR_UNKNOWN_LINE1 to sMessage
69216>>>>>>>            Move (sMessage*Trim(iErrorID)*CS_DDE_ERR_UNKNOWN_LINE2) to sMessage
69217>>>>>>>            Case Break
69218>>>>>>>    Case End
69218>>>>>>>    Function_Return sMessage
69219>>>>>>>End_Function
69220>>>>>>>
69220>>>>>>>Procedure vDDE_Error_Handler Integer iErrorID
69222>>>>>>>    String sMessage
69222>>>>>>>    Get DDE_Error_To_String iErrorID to sMessage
69223>>>>>>>    Append sMessage CS_DDE_ERR_HANDL_PAKTC //  "Press a key to continue..."
69224>>>>>>>    Send Stop_Box sMessage CS_DDE_ERR_HANDL_CAPTION
69225>>>>>>>End_Procedure
69226>>>>>>>
69226>>>>>>>// Does the directory exist? - No = false, Yes = True
69226>>>>>>>// This also works with UNC path encoding and wildcards
69226>>>>>>>Function vFolderExists Global String sFolderName Returns Boolean
69228>>>>>>>    Boolean bFolderExists
69228>>>>>>>    Boolean bStop
69228>>>>>>>    String  sFolder sTmp
69228>>>>>>>    Integer iCh
69228>>>>>>>
69228>>>>>>>    // 2013-09-29 NGS Check for empty folder name and convert to ANSI
69228>>>>>>>    Move (ToAnsi(Trim(sFolderName))) to sFolderName
69229>>>>>>>    If (sFolderName = "") Begin
69231>>>>>>>        Function_Return False
69232>>>>>>>    End
69232>>>>>>>>
69232>>>>>>>
69232>>>>>>>    Move True  to bFolderExists
69233>>>>>>>    Move False to bStop
69234>>>>>>>    Move "dir:" to sFolder
69235>>>>>>>    Append sFolder sFolderName
69236>>>>>>>    Get Seq_New_Channel to iCh  // get free channel for input
69237>>>>>>>    Direct_Input channel iCh sFolder
69239>>>>>>>    Repeat
69239>>>>>>>>
69239>>>>>>>        Readln channel iCh sTmp
69241>>>>>>>        Move (SeqEof) to bStop
69242>>>>>>>        If (Trim(sTmp)="") Begin
69244>>>>>>>            Move False to bFolderExists
69245>>>>>>>        End
69245>>>>>>>>
69245>>>>>>>        Else Begin
69246>>>>>>>            Move True to bFolderExists
69247>>>>>>>            Move True to bStop
69248>>>>>>>        End
69248>>>>>>>>
69248>>>>>>>    Until (bStop)
69250>>>>>>>    Close_Input channel iCh
69252>>>>>>>    Send Seq_Release_Channel iCh
69253>>>>>>>    Function_Return bFolderExists
69254>>>>>>>End_Function
69255>>>>>>>
69255>>>>>>>// returns folder name if a folder was selected, otherwise returns ""
69255>>>>>>>Function vSHBrowseForFolder Global String sDialogTitle Returns String
69257>>>>>>>    String sFolder sTitle sPath
69257>>>>>>>    Pointer lpItemIdList
69257>>>>>>>    Integer iFolderSelected iRetval
69257>>>>>>>    tvBrowseInfo BrowseInfo
69257>>>>>>>    tvBrowseInfo BrowseInfo
69257>>>>>>>
69257>>>>>>>    Move "" to sPath
69258>>>>>>>    If (sDialogTitle<>"") Begin
69260>>>>>>>        Move sDialogTitle to sTitle
69261>>>>>>>        // Torben Lund suggested converting the string with toansi. Doing it like that
69261>>>>>>>        // disables showing some commonly used ascii characters like ascii 137 (ë)
69261>>>>>>>        // These chars are correctly shown if no toansi is used.
69261>>>>>>>        // I can imagine that he wanted to path to be ANSI, but as long as it isa just
69261>>>>>>>        // selected it will always be valid.
69261>>>>>>>        Move (AddressOf(sTitle)) to BrowseInfo.lpszTitle
69262>>>>>>>    End
69262>>>>>>>>
69262>>>>>>>
69262>>>>>>>    Move vBIF_RETURNONLYFSDIRS to BrowseInfo.ulFlags
69263>>>>>>>
69263>>>>>>>    // Torben Lund added line below. Move handle of focus object to structure before
69263>>>>>>>    // calling function. Otherwise, the folderdialog will be started as a seperate task.
69263>>>>>>>    Move (window_handle(focus(desktop))) to BrowseInfo.hWndOwner
69264>>>>>>>
69264>>>>>>>    // null 128 chars into var (make space)
69264>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
69265>>>>>>>
69265>>>>>>>    // select folder
69265>>>>>>>    Move (vWin32_SHBrowseForFolder(AddressOf(BrowseInfo))) to lpItemIdList
69266>>>>>>>    // get selected folder name
69266>>>>>>>    Move (vWin32_SHGetPathFromIDList(lpItemIdList, AddressOf(sFolder))) to iFolderSelected
69267>>>>>>>
69267>>>>>>>    // release memory resources that are used by the ItemIdList
69267>>>>>>>    Move (vWin32_CoTaskMemFree(lpItemIdList)) to iRetval
69268>>>>>>>
69268>>>>>>>    If (iFolderSelected<>0) Begin
69270>>>>>>>        Move (CString(sFolder)) to sPath
69271>>>>>>>    End
69271>>>>>>>>
69271>>>>>>>    Function_Return  sPath
69272>>>>>>>End_Function
69273>>>>>>>
69273>>>>>>>// returns 0 if the folder is created.
69273>>>>>>>//         1 if the API-call returned an error.
69273>>>>>>>Function vCreateDirectory Global String sNewFolder Returns Integer
69275>>>>>>>    String  sFolder
69275>>>>>>>    Integer iRetval bFolderCreated
69275>>>>>>>    tvSecurity_attributes SA
69275>>>>>>>    tvSecurity_attributes SA
69275>>>>>>>
69275>>>>>>>    Move False to bFolderCreated
69276>>>>>>>
69276>>>>>>>    // null MAX_PATH chars into var (make space)
69276>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
69277>>>>>>>
69277>>>>>>>    If (sNewFolder <> "") Begin
69279>>>>>>>
69279>>>>>>>        Move (SizeOfType(tvSecurity_attributes)) to SA.nLength
69280>>>>>>>        Move  0  to SA.lpDescriptor
69281>>>>>>>        Move  1  to SA.bInheritHandle
69282>>>>>>>
69282>>>>>>>        //
69282>>>>>>>        Move (sNewFolder+"") to sFolder
69283>>>>>>>        Move (vWin32_CreateDirectory(AddressOf(sFolder), AddressOf(SA))) to bFolderCreated
69284>>>>>>>    End
69284>>>>>>>>
69284>>>>>>>
69284>>>>>>>    If (bFolderCreated=false) Begin
69286>>>>>>>        Move 1 to iRetVal
69287>>>>>>>    End
69287>>>>>>>>
69287>>>>>>>    Function_Return iRetVal
69288>>>>>>>End_Function
69289>>>>>>>
69289>>>>>>>// **WvA: 03-02-2002 Function created.
69289>>>>>>>// With this function one can remove a directory.
69289>>>>>>>// returns 0 if the folder is removed.
69289>>>>>>>//         1 if the API-call returned an error (Use GetLastError API to get the details)
69289>>>>>>>//         2 if the folder did not exist
69289>>>>>>>//         3 if the sFolder parameter passed is equal to ""
69289>>>>>>>Function vRemoveDirectory Global String sFolder Returns Integer
69291>>>>>>>    Boolean bRemoved
69291>>>>>>>    String  sPath
69291>>>>>>>    Integer iRetval
69291>>>>>>>
69291>>>>>>>    Move 0     to iRetVal
69292>>>>>>>    Move False to bRemoved
69293>>>>>>>    Move (Trim(sFolder)) to sFolder
69294>>>>>>>    If (sFolder="") Begin
69296>>>>>>>        Move 3 to iRetVal
69297>>>>>>>    End
69297>>>>>>>>
69297>>>>>>>    If (vFolderExists(sFolder)=False) Begin
69299>>>>>>>        Move 2 to iRetVal
69300>>>>>>>    End
69300>>>>>>>>
69300>>>>>>>    If (iRetVal=0) Begin
69302>>>>>>>    // null MAX_PATH chars into var (make space)
69302>>>>>>>        Move (Repeat(Character(0), vMAX_PATH)) to sPath
69303>>>>>>>        //
69303>>>>>>>        Move (Insert(sFolder,sPath,1)) to sPath
69304>>>>>>>        Move (vWin32_RemoveDirectory(AddressOf(sPath))) to bRemoved
69305>>>>>>>    End
69305>>>>>>>>
69305>>>>>>>
69305>>>>>>>    If (iRetVal=0 And bRemoved=False) Begin
69307>>>>>>>        Move 1 to iRetVal
69308>>>>>>>    End
69308>>>>>>>>
69308>>>>>>>    Function_Return iRetVal
69309>>>>>>>End_Function
69310>>>>>>>
69310>>>>>>>// This function informs the user that he entered a yet unknown folder and
69310>>>>>>>// asks if he/she wants to create the folder (Yes/No)
69310>>>>>>>// Choice: "Yes" - this creates the folder
69310>>>>>>>//                 if successful, the function returns false
69310>>>>>>>//                 else it will be true.
69310>>>>>>>// Choice: "No"  - returns TRUE, This allows the programmer to take action
69310>>>>>>>//                 For example: to stop a save
69310>>>>>>>// Precondition: A foldername must be entered. We do not check for empty paths
69310>>>>>>>// This function returns a non-zero value if the folder isn't created afterwards
69310>>>>>>>Function vVerifyNewFolder Global String sFolderName Returns Integer
69312>>>>>>>    Integer bIsNotValid
69312>>>>>>>    Integer iUsers_Choice
69312>>>>>>>    String  sMessage
69312>>>>>>>
69312>>>>>>>    If (vFolderExists(sFolderName) Eq 0) Begin
69314>>>>>>>        Move "The folder '" to sMessage
69315>>>>>>>        Append sMessage sFolderName
69316>>>>>>>        Append sMessage "' does not yet exist,\n"
69317>>>>>>>        Append sMessage "Do you want to create it now?"
69318>>>>>>>        Get YesNo_Box sMessage "Confirm" MB_DefButton1 to iUsers_Choice
69319>>>>>>>        Case Begin
69319>>>>>>>            Case (iUsers_Choice = MBR_Yes)
69321>>>>>>>                Move (vCreateDirectory(sFolderName)) to bIsNotValid
69322>>>>>>>                If bIsNotValid Begin
69324>>>>>>>                    Move "An error occurred while trying to create folder '" to sMessage
69325>>>>>>>                    Append sMessage sFolderName "'.\n\n"
69327>>>>>>>                    Send Info_Box sMessage "Info"
69328>>>>>>>                End
69328>>>>>>>>
69328>>>>>>>                Case Break
69329>>>>>>>            Case (iUsers_Choice = MBR_No)
69332>>>>>>>                Move dfTrue to bIsNotValid // Cancel the save
69333>>>>>>>                Case Break
69334>>>>>>>        Case End
69334>>>>>>>    End
69334>>>>>>>>
69334>>>>>>>    Function_Return bIsNotValid
69335>>>>>>>End_Function
69336>>>>>>>
69336>>>>>>>// This will perform an operation on a file (e.g. open) with the application
69336>>>>>>>// registered in the Windows Registry to open that type of file (via its extension)
69336>>>>>>>// sOperation would be "OPEN" (it could also be "PRINT" etc).
69336>>>>>>>Procedure vShellExecute Global String sOperation String sDocument String sParameters String sPath
69338>>>>>>>    Handle  hInstance hWnd
69338>>>>>>>    // remove any leading/trailing spaces in the string
69338>>>>>>>    Move (Trim(sDocument)) to sDocument
69339>>>>>>>    Move (Trim(sPath))     to sPath
69340>>>>>>>    // Make the strings readable for windows API, by converting them to null-terminated
69340>>>>>>>    Append sOperation   (Character(0))
69341>>>>>>>    Append sDocument    (Character(0))
69342>>>>>>>    Append sParameters  (Character(0))
69343>>>>>>>    Append sPath        (Character(0))
69344>>>>>>>
69344>>>>>>>    Get Window_Handle to hWnd
69345>>>>>>>    Move (vWin32_ShellExecute (hWnd, AddressOf(sOperation), AddressOf(sDocument), AddressOf(sParameters), AddressOf(sPath), 1)) to hInstance
69346>>>>>>>    If (hInstance <= 32) Begin
69348>>>>>>>        Send vDDE_Error_Handler hInstance
69349>>>>>>>    End
69349>>>>>>>>
69349>>>>>>>End_Procedure
69350>>>>>>>
69350>>>>>>>Class cShellFileOperations is a Array
69351>>>>>>>
69351>>>>>>>    Procedure Construct_Object
69353>>>>>>>        Forward Send Construct_Object
69355>>>>>>>        Property Integer piDeleteFlags        0
69356>>>>>>>        Property Integer piCopyFlags          0
69357>>>>>>>        Property Integer piMoveFlags          0
69358>>>>>>>        Property Integer piRenameFlags        0
69359>>>>>>>
69359>>>>>>>        Set piDeleteFlags to (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
69360>>>>>>>        Set piCopyFlags   to (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR Ior vFOF_NOCONFIRMATION)
69361>>>>>>>        Set piMoveFlags   to (vFOF_SILENT iOr vFOF_NOCONFIRMMKDIR iOr vFOF_NOCONFIRMATION)
69362>>>>>>>        Set piRenameFlags to (vFOF_SILENT Ior vFOF_NOCONFIRMATION)
69363>>>>>>>    End_Procedure
69364>>>>>>>
69364>>>>>>>    // This function uses the shell API to perform a file operation on the
69364>>>>>>>    // files supplied.
69364>>>>>>>    //
69364>>>>>>>    Function FileOperation String sSource String sDestination Integer eOperation Integer iFlags Returns Integer
69366>>>>>>>        Integer  iRetVal
69366>>>>>>>        Integer  iUserAbort
69366>>>>>>>        tvShFileOpStruct FOS
69366>>>>>>>        tvShFileOpStruct FOS
69366>>>>>>>
69366>>>>>>>        Move (ToAnsi(sSource)+Character(0)+Character(0))      to sSource
69367>>>>>>>        Move (ToAnsi(sDestination)+Character(0)+Character(0)) to sDestination
69368>>>>>>>        If (eOperation <> vFO_DELETE) Begin
69370>>>>>>>            Move (AddressOf(sDestination)) to FOS.pTo
69371>>>>>>>        End
69371>>>>>>>>
69371>>>>>>>
69371>>>>>>>        Move eOperation           to FOS.wFunc
69372>>>>>>>        Move (AddressOf(sSource)) to FOS.pFrom
69373>>>>>>>        Move iFlags               to FOS.fFlags
69374>>>>>>>
69374>>>>>>>        Move (vWin32_SHFileOperation(AddressOf(FOS))) to iRetVal
69375>>>>>>>        Move FOS.fAnyOperationsAborted to iUserAbort
69376>>>>>>>        If (iUserAbort <> 0) Begin
69378>>>>>>>            Move 80 to iRetVal  // file Operation Aborted by USER
69379>>>>>>>        End
69379>>>>>>>>
69379>>>>>>>        Function_Return (iRetVal)
69380>>>>>>>    End_Function
69381>>>>>>>
69381>>>>>>>    Function sfoDeleteFile String sFileName Returns Integer
69383>>>>>>>        Integer  iRetVal
69383>>>>>>>        Integer  iFlags
69383>>>>>>>
69383>>>>>>>        Get piDeleteFlags to iFlags
69384>>>>>>>        Get FileOperation sFileName "" vFO_DELETE iFlags to iRetVal
69385>>>>>>>        Function_Return iRetVal
69386>>>>>>>    End_Function
69387>>>>>>>
69387>>>>>>>    Function sfoCopyFile String sSource String sDestination Returns Integer
69389>>>>>>>        Integer  iRetVal
69389>>>>>>>        Integer  iFlags
69389>>>>>>>
69389>>>>>>>        Get piCopyFlags to iFlags
69390>>>>>>>        Get FileOperation sSource sDestination vFO_COPY iFlags to iRetVal
69391>>>>>>>        Function_Return iRetVal
69392>>>>>>>    End_Function
69393>>>>>>>
69393>>>>>>>    Function sfoMoveFile String sSource String sDestination Returns Integer
69395>>>>>>>        Integer  iRetVal
69395>>>>>>>        Integer  iFlags
69395>>>>>>>
69395>>>>>>>        Get piMoveFlags to iFlags
69396>>>>>>>        Get FileOperation sSource sDestination vFO_MOVE iFlags to iRetVal
69397>>>>>>>        Function_Return iRetVal
69398>>>>>>>    End_Function
69399>>>>>>>
69399>>>>>>>    // Rename a file or folder
69399>>>>>>>    // Returns a nonzero value if the operation failed.
69399>>>>>>>    Function sfoRenameFile String sSource String sDestination Returns Integer
69401>>>>>>>        Integer  iRetVal
69401>>>>>>>        Integer  iFlags
69401>>>>>>>
69401>>>>>>>        Get piRenameFlags to iFlags
69402>>>>>>>        Get FileOperation sSource sDestination vFO_RENAME iFlags to iRetVal
69403>>>>>>>        Function_Return iRetVal
69404>>>>>>>    End_Function
69405>>>>>>>
69405>>>>>>>    // Courtesy Of Steve Walter
69405>>>>>>>    // Requires Windows 2000 and up according to msdn but it was
69405>>>>>>>    //  in fact available before that as an unpublished API call
69405>>>>>>>    //  a little google search shows that this was already available
69405>>>>>>>    //  in windows 95 and NT
69405>>>>>>>    //
69405>>>>>>>    // The format is controlled by the dialog interface.
69405>>>>>>>    // That is, the user must click the OK button To actually Begin the format
69405>>>>>>>    // the format cannot be started programmatically.
69405>>>>>>>    // An alternative to this functionality would be to use a controlpanel
69405>>>>>>>    //  http://www.vdf-guidance.com/ContribPage.asp?Page=PKGCLSDFCPLAPP&ContribRecId=93
69405>>>>>>>    //
69405>>>>>>>    // hWnd = The windows handle of the object from which the format Function
69405>>>>>>>    //        is called.
69405>>>>>>>    // To Get this,
69405>>>>>>>    //          use:  Get Window_Handle Of <object>
69405>>>>>>>    //          For instance, in this app, we're going to use the Report_Panel:
69405>>>>>>>    //                  Get Window_Handle Of (Report_Panel(Main(Self))) To hWind
69405>>>>>>>    //
69405>>>>>>>    // sDrive = The drive letter. At this moment only A and B are valid
69405>>>>>>>    //
69405>>>>>>>    // iOptions = Format options.
69405>>>>>>>    //  SHFMT_OPT_DEFAULT = Quick format
69405>>>>>>>    //  SHFMT_OPT_FULL    = Full Format
69405>>>>>>>    //  SHFMT_OPT_SYSONLY = System only
69405>>>>>>>    //  3                 = Full format with system. (unsupported)
69405>>>>>>>    //
69405>>>>>>>    // Return Values:
69405>>>>>>>    //  SHFMT_ERROR    = Error on format or no drive specified.
69405>>>>>>>    //  SHFMT_CANCEL   = Format cancelled by user.
69405>>>>>>>    //  SHFMT_NOFORMAT = Drive is not formatable.
69405>>>>>>>    //
69405>>>>>>>    //
69405>>>>>>>    // *** ATTENTION: This function has been disabled as it doesn't
69405>>>>>>>    //                seem to work, i must have made a silly mistake
69405>>>>>>>    //                somewhere.
69405>>>>>>>    //
69405>>>>>>>    Function sfoFormatDisk String sDrive Integer iOptions Returns DWord
69407>>>>>>>        Handle   hWnd
69407>>>>>>>        Integer  iObj
69407>>>>>>>        DWord    dwReturnVal
69407>>>>>>>        Integer iDrive
69407>>>>>>>
69407>>>>>>>        Function_Return 1 // STOP HERE
69408>>>>>>>
69408>>>>>>>        Move (Trim(sDrive)) to sDrive
69409>>>>>>>        If ( sDrive <> '' ) Begin
69411>>>>>>>            If ( sDrive Contains ':' ) Begin
69413>>>>>>>                Move (Replace(':',sDrive,'')) to sDrive
69414>>>>>>>            End
69414>>>>>>>>
69414>>>>>>>            If (Not( 'AB' Contains sDrive )) Begin
69416>>>>>>>                Function_Return (SHFMT_NOFORMAT)
69417>>>>>>>            End
69417>>>>>>>>
69417>>>>>>>            If ( sDrive = 'A' ) Begin
69419>>>>>>>                Move 0 to iDrive
69420>>>>>>>            End
69420>>>>>>>>
69420>>>>>>>            Else If ( sDrive = 'B' ) Begin
69423>>>>>>>                Move 1 to iDrive
69424>>>>>>>            End
69424>>>>>>>>
69424>>>>>>>            // Window_Handle Of Desktop equals to 0
69424>>>>>>>
69424>>>>>>>            Get focus of desktop to iObj
69425>>>>>>>            If (iObj>desktop) Begin
69427>>>>>>>                Get Container_Handle of iObj to hWnd
69428>>>>>>>            End
69428>>>>>>>>
69428>>>>>>>            While (hWnd=0 And iObj<>Desktop)
69432>>>>>>>                Get Parent of iObj to iObj
69433>>>>>>>                Get Container_Handle of iObj to hWnd
69434>>>>>>>            Loop
69435>>>>>>>>
69435>>>>>>>
69435>>>>>>>            //Showln "hWnd = " hWnd " iDrive " iDrive " iOptions " iOptions
69435>>>>>>>            Move (vWin32_ShFormatDrive(hWnd, iDrive, SHFMT_ID_DEFAULT, iOptions)) to dwReturnVal
69436>>>>>>>        End
69436>>>>>>>>
69436>>>>>>>        Else Begin
69437>>>>>>>            Move (SHFMT_ERROR) to dwReturnVal
69438>>>>>>>        End
69438>>>>>>>>
69438>>>>>>>        Function_Return dwReturnVal
69439>>>>>>>    End_Function
69440>>>>>>>
69440>>>>>>>    //Example:
69440>>>>>>>    // Get sfoFormatDisk 'A' 0 To dReturnVal    // Formats drive A in QuickFormat
69440>>>>>>>    //                                          mode.
69440>>>>>>>
69440>>>>>>>End_Class
69441>>>>>>>
69441>>>>>>>Object oShellFileOperations is a cShellFileOperations
69443>>>>>>>End_Object
69444>>>>>>>
69444>>>>>>>// Restore to the old way of working with the shell file operations.
69444>>>>>>>// or.. to put lay man terms, allow any of the operations vDeleteFile
69444>>>>>>>// vCopyFile/vMoveFile/vRenameFile to have an UNDO
69444>>>>>>>Procedure vWin32fhCompatibilityMode
69446>>>>>>>    Integer hoSFO
69446>>>>>>>    Integer iFlags
69446>>>>>>>
69446>>>>>>>    Move (vFOF_SILENT Ior vFOF_NOCONFIRMATION Ior vFOF_ALLOWUNDO) to iFlags
69447>>>>>>>    Move (oShellFileOperations(Self)) to hoSFO
69448>>>>>>>
69448>>>>>>>    Set piDeleteFlags of hoSFO to iFlags
69449>>>>>>>    Set piCopyFlags   of hoSFO to iFlags
69450>>>>>>>    Set piMoveFlags   of hoSFO to iFlags
69451>>>>>>>    Set piRenameFlags of hoSFO to iFlags
69452>>>>>>>End_Procedure
69453>>>>>>>
69453>>>>>>>// Delete a file or folder
69453>>>>>>>// Returns a nonzero value if the operation failed.
69453>>>>>>>Function vDeleteFile Global String sFileName Returns Integer
69455>>>>>>>    Integer  iRetVal
69455>>>>>>>
69455>>>>>>>    Get sfoDeleteFile of (oShellFileOperations(Self)) sFileName to iRetVal
69456>>>>>>>    Function_Return iRetVal
69457>>>>>>>End_Function
69458>>>>>>>
69458>>>>>>>// Copy a file or folder
69458>>>>>>>// Returns a nonzero value if the operation failed.
69458>>>>>>>Function vCopyFile Global String sSource String sDestination Returns Integer
69460>>>>>>>    Integer  iRetVal
69460>>>>>>>
69460>>>>>>>    Get sfoCopyFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
69461>>>>>>>    Function_Return iRetVal
69462>>>>>>>End_Function
69463>>>>>>>
69463>>>>>>>// Move a file or folder
69463>>>>>>>// Returns a nonzero value if the operation failed.
69463>>>>>>>Function vMoveFile Global String sSource String sDestination Returns Integer
69465>>>>>>>    Integer  iRetVal
69465>>>>>>>
69465>>>>>>>    Get sfoMoveFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
69466>>>>>>>    Function_Return iRetVal
69467>>>>>>>End_Function
69468>>>>>>>
69468>>>>>>>// Rename a file or folder
69468>>>>>>>// Returns a nonzero value if the operation failed.
69468>>>>>>>Function vRenameFile Global String sSource String sDestination Returns Integer
69470>>>>>>>    Integer  iRetVal
69470>>>>>>>
69470>>>>>>>    Get sfoRenameFile of (oShellFileOperations(Self)) sSource sDestination to iRetVal
69471>>>>>>>    Function_Return iRetVal
69472>>>>>>>End_Function
69473>>>>>>>
69473>>>>>>>Function vGetWindowsDirectory Returns String
69475>>>>>>>    String  sDirectory
69475>>>>>>>    Integer iVoid
69475>>>>>>>
69475>>>>>>>    Move (ZeroString(vMAX_PATH)) to sDirectory
69476>>>>>>>    Move (vWin32_GetWindowsDirectory(AddressOf(sDirectory), vMAX_PATH)) to iVoid
69477>>>>>>>    Function_Return (CString(sDirectory))
69478>>>>>>>End_Function
69479>>>>>>>
69479>>>>>>>Function vGetTempPath Returns String
69481>>>>>>>    Integer iRetval
69481>>>>>>>    String  sTempPath
69481>>>>>>>
69481>>>>>>>    Move (ZeroString(vMAX_PATH)) to sTempPath
69482>>>>>>>    Move (vWin32_GetTempPath (vMAX_PATH, AddressOf(sTempPath))) to iRetVal
69483>>>>>>>    Function_Return (Cstring(sTempPath))
69484>>>>>>>End_Function
69485>>>>>>>
69485>>>>>>>// Courtesy of Marco Kuipers
69485>>>>>>>Function vMakeTempFile Returns String
69487>>>>>>>    Integer iRetval
69487>>>>>>>    String  sTempPath
69487>>>>>>>    String  sTempFileName
69487>>>>>>>    String  sPrefixString
69487>>>>>>>
69487>>>>>>>    Get vGetTempPath to sTempPath
69488>>>>>>>    If (sTempPath = "") Begin
69490>>>>>>>        Get vGetWindowsDirectory to sTempPath  // first fallback
69491>>>>>>>        If (sTempPath<>"") Begin
69493>>>>>>>            Move (sTempPath+"\Temp\") to sTempPath
69494>>>>>>>        End
69494>>>>>>>>
69494>>>>>>>    End
69494>>>>>>>>
69494>>>>>>>
69494>>>>>>>    If (sTempPath = "") Begin
69496>>>>>>>    // second fallback we really do not want to get here as to be fair using current folder as temp
69496>>>>>>>    // makes little sense. Leaving this in as it was old behavior.
69496>>>>>>>        Get_Current_Directory to sTempPath
69497>>>>>>>    End
69497>>>>>>>>
69497>>>>>>>
69497>>>>>>>    Move (Trim(sTempPath)+Character(0)) to sTempPath
69498>>>>>>>    If (Length(sTempPath)>(vMax_Path-14)) Begin
69500>>>>>>>        Error DFERR_PROGRAM ("Temporary path"+sTempPath+"is too long, cannot create temporary files.")
69501>>>>>>>>
69501>>>>>>>    End
69501>>>>>>>>
69501>>>>>>>
69501>>>>>>>    Move (ZeroString(vMax_Path)) to sTempFileName
69502>>>>>>>    Move ("tmp"+Character(0)) to sPrefixString // **WvA: 28-04-2005 Added a null
69503>>>>>>>    Move (vWin32_GetTempFileName (AddressOf(sTempPath), AddressOf(sPrefixString), 0, AddressOf(sTempFileName))) to iRetval
69504>>>>>>>    If (iRetval = 0) Begin  // **WvA: 28-04-2005 Changed condition, the api call returns 0 if an error occurs
69506>>>>>>>    //Get ShowLastError to iRetval
69506>>>>>>>        Move "" to sTempFileName
69507>>>>>>>    End
69507>>>>>>>>
69507>>>>>>>
69507>>>>>>>    Function_Return (Cstring(sTempFileName)) // **WvA: 28-04-2005 Cstring added
69508>>>>>>>End_Function
69509>>>>>>>
69509>>>>>>>// This function creates a uniquely named temporary file in folder sPath
69509>>>>>>>// The file created will have a prefix based on the first 3 characters in sPrefix
69509>>>>>>>// Note that you will have to cleanup the tempfile yourself as the function
69509>>>>>>>// does not take care of that.
69509>>>>>>>Function vCreateTempFileInPath String sPath String sPrefix Returns String
69511>>>>>>>    Integer iRetVal
69511>>>>>>>    String sTempFileName
69511>>>>>>>
69511>>>>>>>    Move (ToAnsi(sPath)+Character(0))   to sPath
69512>>>>>>>    Move (ToAnsi(sPrefix)+Character(0)) to sPrefix
69513>>>>>>>    Move (Pad("", vMAX_PATH)) to sTempFileName
69514>>>>>>>
69514>>>>>>>    Move (vWin32_GetTempFileName(AddressOf(sPath), AddressOf(sPrefix), 0, AddressOf(sTempFileName))) to iRetVal
69515>>>>>>>    Move (Trim(Cstring(sTempFileName))) to sTempFileName
69516>>>>>>>    Function_Return sTempFileName
69517>>>>>>>End_Function
69518>>>>>>>
69518>>>>>>>//
69518>>>>>>>// Get a specific shell folder for example to get the desktop folder
69518>>>>>>>// simply call this function and pass it vCSIDL_DESKTOP
69518>>>>>>>//
69518>>>>>>>Function vSHGetFolderPath Integer eFolder Returns String
69520>>>>>>>    String  sFolder
69520>>>>>>>    Integer iVoid
69520>>>>>>>    Handle  hWnd
69520>>>>>>>
69520>>>>>>>    Move (Window_Handle(focus(desktop))) to hWnd
69521>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
69522>>>>>>>    Move (vWin32_SHGetFolderPath(hWnd,eFolder, 0, 0,AddressOf(sFolder))) to iVoid
69523>>>>>>>    Function_Return (CString(sFolder))
69524>>>>>>>End_Function
69525>>>>>>>
69525>>>>>>>// Courtesy Of Vincent Oorsprong
69525>>>>>>>Function vConvertFileDateTime Global DWord dwLowDateTime DWord dwHighDateTime Returns String
69527>>>>>>>    String  sFormattedTime sFormattedDate
69527>>>>>>>    String  sFileDateTime
69527>>>>>>>    Integer iSuccess iLenCcTime iDataLength iLenCcDate
69527>>>>>>>    tvFileTime   FileTime
69527>>>>>>>    tvFileTime   FileTime
69527>>>>>>>    tvSystemTime SystemTime
69527>>>>>>>    tvSystemTime SystemTime
69527>>>>>>>
69527>>>>>>>    Move "" to sFileDateTime
69528>>>>>>>    Move dwLowDateTime  to FileTime.dwLowDateTime
69529>>>>>>>    Move dwHighDateTime to FileTime.dwHighDateTime
69530>>>>>>>
69530>>>>>>>    Move 0 to SystemTime.wYear
69531>>>>>>>
69531>>>>>>>    Move (vWin32_FileTimeToSystemTime (AddressOf(FileTime), AddressOf(SystemTime))) to iSuccess
69532>>>>>>>    If (iSuccess = 1) Begin
69534>>>>>>>        Move (ZeroString(255))        to sFormattedTime
69535>>>>>>>        Move (Length(sFormattedTime)) to iLenCcTime
69536>>>>>>>        Move (vWin32_GetTimeFormat (LOCALE_USER_DEFAULT, 0, AddressOf(SystemTime), 0, AddressOf(sFormattedTime), iLenCcTime)) to iDataLength
69537>>>>>>>        Move (ZeroString(255))        to sFormattedDate
69538>>>>>>>        Move (Length(sFormattedDate)) to iLenCcDate
69539>>>>>>>        Move (vWin32_GetDateFormat (LOCALE_USER_DEFAULT, 0, AddressOf(SystemTime), 0, AddressOf(sFormattedDate), iLenCcDate)) to iDataLength
69540>>>>>>>        Move (Cstring (sFormattedDate)  * Cstring (sFormattedTime)) to sFileDateTime
69541>>>>>>>    End
69541>>>>>>>>
69541>>>>>>>    Function_Return sFileDateTime
69542>>>>>>>End_Function
69543>>>>>>>
69543>>>>>>>// **WvA:
69543>>>>>>>// A windows replacement for the standard function FileExists.
69543>>>>>>>// This version will also return (true) for a file when it is open by an application.
69543>>>>>>>// Note that you can apply normal windows mask-signs in the filename such as * and ?
69543>>>>>>>// Example: Get vFilePathExists "C:\config.sy?"
69543>>>>>>>// This will return true if you have a file matching these conditions. (aka config.sys)
69543>>>>>>>Function vFilePathExists Global String sFilePathMask Returns Integer
69545>>>>>>>    String  sDirSep
69545>>>>>>>    Handle  hFindFile
69545>>>>>>>    Integer iVoid
69545>>>>>>>    tvWin32FindData FindData
69545>>>>>>>    tvWin32FindData FindData
69545>>>>>>>
69545>>>>>>>    Move vINVALID_HANDLE_VALUE to hFindFile
69546>>>>>>>    Move (ToAnsi(Trim(sFilePathMask))) to sFilePathMask
69547>>>>>>>    If (Length(sFilePathMask)>0) Begin
69549>>>>>>>    // 2014-09-29 NGS Remove any trailing dir separators, as they make the function fail.
69549>>>>>>>        Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep
69550>>>>>>>        While (Right(sFilePathMask, 1) = sDirSep)
69554>>>>>>>            Move (Left(sFilePathMask, Length(sFilePathMask) -1)) to sFilePathMask
69555>>>>>>>        Loop
69556>>>>>>>>
69556>>>>>>>
69556>>>>>>>        Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
69557>>>>>>>        Move (vWin32_FindFirstFile (AddressOf(sFilePathMask), AddressOf(FindData))) to hFindFile
69558>>>>>>>        Move (vWin32_FindClose (hFindFile)) to iVoid
69559>>>>>>>    End
69559>>>>>>>>
69559>>>>>>>    Function_Return (hFindFile <> vINVALID_HANDLE_VALUE)
69560>>>>>>>End_Function
69561>>>>>>>
69561>>>>>>>//
69561>>>>>>>// WideChar version of the function, do not use, it's an experiment
69561>>>>>>>//
69561>>>>>>>Function vWFilePathExists Global String sFilePathMask Returns Integer
69563>>>>>>>    Handle  hFindFile
69563>>>>>>>    Integer iVoid
69563>>>>>>>    tvWin32FindData FindData
69563>>>>>>>    tvWin32FindData FindData
69563>>>>>>>
69563>>>>>>>    Move vINVALID_HANDLE_VALUE to hFindFile
69564>>>>>>>
69564>>>>>>>    If (Length(sFilePathMask)>0) Begin
69566>>>>>>>
69566>>>>>>>        Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
69567>>>>>>>        Move (vWin32W_FindFirstFile (AddressOf(sFilePathMask), AddressOf(FindData))) to hFindFile
69568>>>>>>>        Move (vWin32_FindClose (hFindFile)) to iVoid
69569>>>>>>>    End
69569>>>>>>>>
69569>>>>>>>    Function_Return (hFindFile <> vINVALID_HANDLE_VALUE)
69570>>>>>>>End_Function
69571>>>>>>>
69571>>>>>>>// **WvA
69571>>>>>>>// Formats a foldername by first trimming it and after that by sticking a
69571>>>>>>>// directory separator (/\) to the end if it doesn't have one there already.
69571>>>>>>>// The folder may contain a drive letter or UNC encoding.
69571>>>>>>>Function vFolderFormat Global String sFolderName Returns String
69573>>>>>>>    String sDirSep
69573>>>>>>>    Move (sysconf(SYSCONF_DIR_SEPARATOR)) to sDirSep  // normally \ (backslash)
69574>>>>>>>    Move (Trim(sFolderName)) to sFolderName
69575>>>>>>>    If (Right(sFolderName,1)<>sDirSep) Begin
69577>>>>>>>        Move (sFolderName+sDirSep) to sFolderName
69578>>>>>>>    End
69578>>>>>>>>
69578>>>>>>>    Function_Return sFolderName
69579>>>>>>>End_Function
69580>>>>>>>
69580>>>>>>>//
69580>>>>>>>// Returns the amount of files in the folder (if it exists)
69580>>>>>>>// Returns -1 if folder doesn't exist.
69580>>>>>>>// The files "." and ".." are not counted.
69580>>>>>>>//
69580>>>>>>>Function vFolderFileCount Global String sFolderName Returns Integer
69582>>>>>>>    Boolean bFound
69582>>>>>>>    Handle  hFindFile
69582>>>>>>>    Integer iCount  iVoid
69582>>>>>>>    Integer iSuccess
69582>>>>>>>    String  sFileName
69582>>>>>>>    tvWin32FindData FindData
69582>>>>>>>    tvWin32FindData FindData
69582>>>>>>>
69582>>>>>>>    Move -1 to iCount
69583>>>>>>>    Get vFolderFormat sFolderName to sFolderName
69584>>>>>>>    Move (sFolderName+"*") to sFolderName // match any filename in the folder
69585>>>>>>>    Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
69586>>>>>>>    Move (vWin32_FindFirstFile (AddressOf(sFolderName), AddressOf(FindData))) to hFindFile
69587>>>>>>>    Move (hFindFile<>vINVALID_HANDLE_VALUE) to bFound
69588>>>>>>>    If (bFound) Begin
69590>>>>>>>        Move 0 to iCount
69591>>>>>>>    End
69591>>>>>>>>
69591>>>>>>>    While (bFound)
69595>>>>>>>        Increment iCount
69596>>>>>>>        Move (UCharArrayToString(FindData.cFileName)) to sFileName
69597>>>>>>>        If (sFileName="." or sFileName="..") Begin
69599>>>>>>>            Decrement iCount
69600>>>>>>>        End
69600>>>>>>>>
69600>>>>>>>        Move (vWin32_FindNextFile(hFindFile, AddressOf(FindData))) to iSuccess
69601>>>>>>>        Move (iSuccess<>0) to bFound
69602>>>>>>>    Loop
69603>>>>>>>>
69603>>>>>>>    Move (vWin32_FindClose (hFindFile)) to iVoid
69604>>>>>>>    Function_Return iCount
69605>>>>>>>End_Function
69606>>>>>>>
69606>>>>>>>//
69606>>>>>>>// Gets the parent path of the currently supplied path
69606>>>>>>>// Returns "" when we are at the root folder.
69606>>>>>>>//
69606>>>>>>>Function vParentPath Global String sPath Returns String
69608>>>>>>>    String sStrip sDirSep
69608>>>>>>>
69608>>>>>>>    Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
69609>>>>>>>    Move (Trim(sPath)) to sPath
69610>>>>>>>    If (Right(sPath,1) = sDirSep) Begin
69612>>>>>>>        Move (Left(sPath,Length(sPath)-1)) to sPath
69613>>>>>>>    End
69613>>>>>>>>
69613>>>>>>>    If (Pos(sDirSep, sPath)) Begin
69615>>>>>>>        Move (StringFromRightOfChar(sPath, sDirSep)) to sStrip
69616>>>>>>>        Move (Left(sPath,Length(sPath)-Length(sStrip))) to sPath
69617>>>>>>>    End
69617>>>>>>>>
69617>>>>>>>    Else Begin
69618>>>>>>>        Move "" to sPath
69619>>>>>>>    End
69619>>>>>>>>
69619>>>>>>>    Function_Return sPath
69620>>>>>>>End_Function
69621>>>>>>>
69621>>>>>>>// Create the folder, including intermediate directories.
69621>>>>>>>// Don't panic if the folder already exists.
69621>>>>>>>// Michael Mullan June 2009.
69621>>>>>>>Function vshCreateDirectoryEX Global String sNewFolder Returns Integer
69623>>>>>>>    String  sFolder
69623>>>>>>>    Integer iRetval iFolderCreated
69623>>>>>>>    tvSecurity_attributes SA
69623>>>>>>>    tvSecurity_attributes SA
69623>>>>>>>
69623>>>>>>>    Move 0 to iFolderCreated
69624>>>>>>>
69624>>>>>>>    // null MAX_PATH chars into var (make space)
69624>>>>>>>    Move (Repeat(Character(0), vMAX_PATH)) to sFolder
69625>>>>>>>    If (sNewFolder <> "") Begin
69627>>>>>>>
69627>>>>>>>        Move (SizeOfType(tvSecurity_attributes)) to SA.nLength
69628>>>>>>>        Move  0  to SA.lpDescriptor
69629>>>>>>>        Move  1  to SA.bInheritHandle
69630>>>>>>>
69630>>>>>>>        //
69630>>>>>>>        Move (sNewFolder+"") to sFolder
69631>>>>>>>        Move (vWin32_SHCreateDirectoryEx(0,AddressOf(sFolder), AddressOf(SA))) to iFolderCreated
69632>>>>>>>    End
69632>>>>>>>>
69632>>>>>>>
69632>>>>>>>    If (iFolderCreated <> 0) Begin
69634>>>>>>>        Move 1 to iRetVal
69635>>>>>>>        Case Begin
69635>>>>>>>            Case (iFolderCreated = 161)
69637>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_BAD_PATHNAME)")
69638>>>>>>>>
69638>>>>>>>                Case Break
69639>>>>>>>            Case (iFolderCreated = 206)
69642>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_FILENAME_EXCED_RANGE)")
69643>>>>>>>>
69643>>>>>>>                Case Break
69644>>>>>>>            Case (iFolderCreated = 3)
69647>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_PATH_NOT_FOUND)")
69648>>>>>>>>
69648>>>>>>>                Case Break
69649>>>>>>>            Case (iFolderCreated = 80)
69652>>>>>>>                Move 0 to iRetval // "ERROR_FILE_EXISTS"     not really an error
69653>>>>>>>                Case Break
69654>>>>>>>            Case (iFolderCreated = 183)
69657>>>>>>>                Move 0 to iRetval //  "ERROR_ALREADY_EXISTS"     not really an error
69658>>>>>>>                Case Break
69659>>>>>>>            Case (iFolderCreated = 1223)
69662>>>>>>>                Error DFERR_OPERATOR ("Path " + sNewFolder + " is Not Valid (ERROR_CANCELLED)")
69663>>>>>>>>
69663>>>>>>>                Case Break
69664>>>>>>>            Case Else
69664>>>>>>>                Error DFERR_OPERATOR ("Folder Creation Error # " + String(ifoldercreated) + "\n" + sNewFolder + "(FILE_CREATION_ERROR)")
69665>>>>>>>>
69665>>>>>>>        Case End
69665>>>>>>>    End
69665>>>>>>>>
69665>>>>>>>    Function_Return iRetVal
69666>>>>>>>End_Function
69667>>>>>>>
69667>>>>>>>Function vWin32_APIFileSize Global String sFileName Returns Integer
69669>>>>>>>    DWord   dwFileSizeHigh dwFileSizeLow
69669>>>>>>>    Integer iFileSize iVoid
69669>>>>>>>    Handle  hFindFile
69669>>>>>>>    tvWin32FindData FindData
69669>>>>>>>    tvWin32FindData FindData
69669>>>>>>>
69669>>>>>>>    Move (sFileName+"") to sFileName
69670>>>>>>>    Move 0 to FindData.dwReserved0        // initialize the variable so we can get an address from it.
69671>>>>>>>    Move (vWin32_FindFirstFile (AddressOf(sFileName), AddressOf(FindData))) to hFindFile
69672>>>>>>>    If (hFindFile<>vINVALID_HANDLE_VALUE) Begin
69674>>>>>>>        Move FindData.nFileSizeHigh to dwFileSizeHigh
69675>>>>>>>        Move FindData.nFileSizeLow  to dwFileSizeLow
69676>>>>>>>    End
69676>>>>>>>>
69676>>>>>>>    Move (vWin32_FindClose (hFindFile)) to iVoid
69677>>>>>>>    Move ((dwFileSizeHigh * vMaxDword) + dwFileSizeLow) to iFileSize
69678>>>>>>>
69678>>>>>>>    Function_Return iFileSize
69679>>>>>>>End_Function
69680>>>>>>>
69680>>>>>>>//
69680>>>>>>>// Based on code in Peter Crook's Browse folder workspace
69680>>>>>>>// http://support.dataaccess.com/Forums/showthread.php?54383-Browse-for-Folder-package&p=282249#post282249
69680>>>>>>>//
69680>>>>>>>//=============================================================================
69680>>>>>>>// Verifies that a path is a valid directory.
69680>>>>>>>//
69680>>>>>>>// Returns TRUE if the path is a valid directory, or FALSE otherwise.
69680>>>>>>>//
69680>>>>>>>// Parameters:
69680>>>>>>>//      sPath - Address of the path to verify.
69680>>>>>>>//=============================================================================
69680>>>>>>>Function vPathIsDirectory Global String sPath Returns Boolean
69682>>>>>>>    Integer iResult
69682>>>>>>>    Boolean bRetVal
69682>>>>>>>
69682>>>>>>>    Move false to bRetVal
69683>>>>>>>    Move (ToAnsi(sPath) - Character (0)) to sPath
69684>>>>>>>    Move (vWin32_PathIsDirectory (AddressOf (sPath))) to iResult
69685>>>>>>>    If (iResult<>0) Begin
69687>>>>>>>        Move True to bRetVal
69688>>>>>>>    End
69688>>>>>>>>
69688>>>>>>>
69688>>>>>>>    Function_Return bRetVal
69689>>>>>>>End_Function
69690>>>>>>>
69690>>>>>Use DUFLanguageConstants.inc
69690>>>>>
69690>>>>>Define CS_IntFilesTableRootName for "IntFilesTable"
69690>>>>>Define CS_FilelistZipFile       for "FilelistBackupFile.zip"
69690>>>>>Define CS_FilelistBackupFile    for "FilelistBackupFile.cfg"
69690>>>>>
69690>>>>>Struct tDUFIntFile
69690>>>>>    Integer iID
69690>>>>>    String sIntFileName
69690>>>>>    String sIntLineText
69690>>>>>End_Struct
69690>>>>>
69690>>>>>Struct tDbVersionInfo
69690>>>>>    Number nVersionNumber
69690>>>>>    Handle hObject
69690>>>>>End_Struct
69690>>>>>
69690>>>>>Struct tDbUpdateError
69690>>>>>    Number nUpdateVersion
69690>>>>>    Integer iError
69690>>>>>    String  sOrgErrorText
69690>>>>>    String  sErrorText
69690>>>>>    Integer iErrorLine
69690>>>>>    Boolean bError  
69690>>>>>    Handle  hTable 
69690>>>>>    String  sTableRootName
69690>>>>>    Integer iField
69690>>>>>    Boolean bShortFormat
69690>>>>>End_Struct
69690>>>>>
69690>>>>>//  DF_FILE_ALIAS_DEFAULT if no master or alias
69690>>>>>//  DF_FILE_IS_MASTER if master
69690>>>>>//  DF_FILE_IS_ALIAS if alias
69690>>>>>Struct tDbUpdateHandlerMasterAlias
69690>>>>>    Handle hTable
69690>>>>>    Integer iMode
69690>>>>>End_Struct
69690>>>>>
69690>>>>>// Used as a start for error handing. Used by Error_Report_Mode property
69690>>>>>Enumeration_List
69690>>>>>    Define DUF_ERROR_REPORT    // Report Error on screen
69690>>>>>    Define DUF_ERROR_NO_REPORT // Show no Error..
69690>>>>>End_Enumeration_List
69690>>>>>
69690>>>>>    Define DATAFLEX_ID for "DATAFLEX"
69690>>>>>
69690>>>>>// Global handle to a cDatabaseUpdateHandler object that can be used to
69690>>>>>// communicate with the object from anywhere in a program.
69690>>>>>    Global_Variable Handle ghoDbUpdateHandler
69690>>>>>    Move 0 to ghoDbUpdateHandler
69691>>>>>
69691>>>>>// NOTE: If the DbVersion table should _not_ be used and you
69691>>>>>// instead set the "Set Data_File_Field to (RefTable(MyTable)) (RefTable(MyTable.DbUpdateVersion))"
69691>>>>>// in the cDbUpdateHandler object; Add a "Define DUF_Use_DbVersion" to your code,
69691>>>>>// _before_ the "Use cDbUpdateHandler.pkg" line.
69691>>>>>//#IFNDEF DUF_Use_Custom_DbVersion
69691>>>>>//    Declare_Datafile DbVersion
69691>>>>>//#ENDIF
69691>>>Use cDbUpdateLogFile.pkg
Including file: cDbUpdateLogFile.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateLogFile.pkg)
69691>>>>>//****************************************************************************
69691>>>>>// $Module type: Class
69691>>>>>// $Module name: cDbUpdateLogFile
69691>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
69691>>>>>// Web-site    : http://www.rdctools.com
69691>>>>>// Created     : 2016-10-05 @ 18:58 (Military date format: YY-MM-DD)
69691>>>>>//
69691>>>>>// Description : This logic was moved from the cDbUpdateHandler class so that it would
69691>>>>>//               be easier to change to where errors/status messages are written/saved. As it is less likely
69691>>>>>//               that this class is to change; each developer can decide if the errors instead
69691>>>>>//               should be saved to a database table, or something entirely different.
69691>>>>>//               The default is to write the errors to a Ascii-file in the Data folder.
69691>>>>>//
69691>>>>>// $Rev History:
69691>>>>>//    2016-10-05  Module header created
69691>>>>>//****************************************************************************
69691>>>>>Use UI
69691>>>>>Use vWin32fh.pkg
69691>>>>>
69691>>>>>
69691>>>>>    Define CS_DatabaseUpdateFramework for " ***  The Database Update Framework (DUF) ***"
69691>>>>>
69691>>>>>Define CS_SuccessfulUpdate for "The database was updated successfully!"
69691>>>>>
69691>>>>>Class cDbUpdateLogFile is a cObject
69692>>>>>
69692>>>>>    Procedure Construct_Object
69694>>>>>        Forward Send Construct_Object
69696>>>>>
69696>>>>>        // Error handling:
69696>>>>>        Property tDbUpdateError[] paDbUpdateErrorArray
69697>>>>>        Property Integer piChannel -1
69698>>>>>
69698>>>>>        // This property is set by the cDbUpdateHandler object,
69698>>>>>        // when the update process starts.
69698>>>>>        Property DateTime pdtUpdateStart
69699>>>>>
69699>>>>>        // Gets set to False if the log contains data
69699>>>>>        Property Boolean pbEmptyLogFile True
69700>>>>>
69700>>>>>        // Gets set to True after the error log header text
69700>>>>>        // has been written.
69700>>>>>        Property Boolean pbHeaderWritten False
69701>>>>>
69701>>>>>        // If all activities should be logged- not just errors.
69701>>>>>        Property Boolean pbVerboseState False
69702>>>>>
69702>>>>>        // File name for the error log where all errors
69702>>>>>        // after a run is written to (appended).
69702>>>>>        // It is saved in the Data folder.
69702>>>>>        Property String psLogTextFile   "DUFUpdateLog.txt"
69703>>>>>        // If this property is set to "" in object code, the
69703>>>>>        // "shell" command parameter will be used to let Windows decide
69703>>>>>        // with which program to open the logfile.
69703>>>>>        Property String psEditorProgram ""
69704>>>>>
69704>>>>>        Property Boolean pbUseDataTableLog False
69705>>>>>
69705>>>>>        // If true an error will be written to file immediately when
69705>>>>>        // it occurs. This can be handy if a large update generates a lots
69705>>>>>        // of errors and the application crasches before finished, thus
69705>>>>>        // the errors will not be written.
69705>>>>>        Property Boolean pbQuickWrite True
69706>>>>>    End_Procedure
69707>>>>>
69707>>>>>    Procedure End_Construct_Object
69709>>>>>        Forward Send End_Construct_Object
69711>>>>>
69711>>>>>    End_Procedure
69712>>>>>
69712>>>>>    Procedure LogError Number nVersion Integer iError String sErrorText Integer iErrorLine Boolean bError Boolean bShortFormatIn
69714>>>>>        tDbUpdateError[] DbUpdateErrorArray DbUpdateErrorArrayEmpty
69714>>>>>        tDbUpdateError[] DbUpdateErrorArray DbUpdateErrorArrayEmpty
69716>>>>>        Boolean bShortFormat
69716>>>>>        Integer iSize
69716>>>>>        Handle hCurrentTable
69716>>>>>        Integer iCurrentField           
69716>>>>>        String sOrgErrorText sTableRootName
69716>>>>>        
69716>>>>>        Move False to bShortFormat
69717>>>>>        If (num_arguments > 5) Begin
69719>>>>>            Move bShortFormatIn to bShortFormat
69720>>>>>        End
69720>>>>>>
69720>>>>>        // Only do once.
69720>>>>>        If (pbHeaderWritten(Self) = False) Begin
69722>>>>>            Send WriteHeaderData
69723>>>>>            Set pbHeaderWritten to True
69724>>>>>        End
69724>>>>>>
69724>>>>>
69724>>>>>        Get Private.phCurrentTable to hCurrentTable  
69725>>>>>        Get Private.piCurrentField to iCurrentField  
69726>>>>>        If (iError > 0) Begin
69728>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hCurrentTable to sTableRootName
69731>>>>>            Get FetchErrorDescription iError to sOrgErrorText 
69732>>>>>        End
69732>>>>>>
69732>>>>>        Get paDbUpdateErrorArray to DbUpdateErrorArray
69733>>>>>        Move (SizeOfArray(DbUpdateErrorArray)) to iSize
69734>>>>>        Move nVersion       to DbUpdateErrorArray[iSize].nUpdateVersion
69735>>>>>        Move iError         to DbUpdateErrorArray[iSize].iError
69736>>>>>        Move iErrorLine     to DbUpdateErrorArray[iSize].iErrorLine
69737>>>>>        Move True           to DbUpdateErrorArray[iSize].bError  
69738>>>>>        Move sOrgErrorText  to DbUpdateErrorArray[iSize].sOrgErrorText
69739>>>>>        Move sErrorText     to DbUpdateErrorArray[iSize].sErrorText
69740>>>>>        Move hCurrentTable  to DbUpdateErrorArray[iSize].hTable            
69741>>>>>        Move sTableRootName to DbUpdateErrorArray[iSize].sTableRootName
69742>>>>>        Move iCurrentField  to DbUpdateErrorArray[iSize].iField  
69743>>>>>        Move bShortFormat   to DbUpdateErrorArray[iSize].bShortFormat
69744>>>>>
69744>>>>>        If (bError = False) Begin
69746>>>>>            Move False to DbUpdateErrorArray[iSize].bError
69747>>>>>        End
69747>>>>>>
69747>>>>>        Set paDbUpdateErrorArray to DbUpdateErrorArray
69748>>>>>
69748>>>>>        If (pbUseDataTableLog(Self) = True) Begin
69750>>>>>            If (pbQuickWrite(Self) = True) Begin
69752>>>>>                Send OnWriteRow_DataTable
69753>>>>>                // If we are writing error for error flush the
69753>>>>>                // error array when latest error has been written.
69753>>>>>                Set paDbUpdateErrorArray to DbUpdateErrorArrayEmpty
69754>>>>>            End
69754>>>>>>
69754>>>>>            Procedure_Return
69755>>>>>        End
69755>>>>>>
69755>>>>>        Else Begin
69756>>>>>            If (pbQuickWrite(Self) = True) Begin
69758>>>>>                Send WriteErrorLog
69759>>>>>                // Flush the error log array
69759>>>>>                Set paDbUpdateErrorArray to DbUpdateErrorArrayEmpty
69760>>>>>            End
69760>>>>>>
69760>>>>>        End
69760>>>>>>
69760>>>>>    End_Procedure   
69761>>>>>    
69761>>>>>    Function FetchErrorDescription Integer iError Returns String
69763>>>>>        String sErrorText         
69763>>>>>        Move "" to sErrorText
69764>>>>>        If (iError > 0) Begin
69766>>>>>            Move (Error_Text(Desktop, iError)) to sErrorText 
69767>>>>>        End
69767>>>>>>
69767>>>>>        Function_Return sErrorText
69768>>>>>    End_Function
69769>>>>>
69769>>>>>    // Hook procedure for writing header text prior starting the update work to
69769>>>>>    // a database table. This does nothing by default.
69769>>>>>    // Don't forget to Open your "error log table" first (!) as all
69769>>>>>    // tables have been closed at this stage. Put anything
69769>>>>>    // you want to indicate that the update process is just started.
69769>>>>>    Procedure OnWriteHeader_DataTable DateTime dtUpdateStart
69771>>>>>        Delegate Send OnErrorWriteHeader_DataTable dtUpdateStart
69773>>>>>    End_Procedure
69774>>>>>
69774>>>>>    Procedure OnWriteRow_DataTable
69776>>>>>        tDbUpdateError[] DbUpdateErrorArray
69776>>>>>        tDbUpdateError[] DbUpdateErrorArray
69777>>>>>        Get paDbUpdateErrorArray to DbUpdateErrorArray
69778>>>>>        If (SizeOfArray(DbUpdateErrorArray) > 0) Begin
69780>>>>>            Delegate Send OnErrorWriteRow_DataTable DbUpdateErrorArray
69782>>>>>        End
69782>>>>>>
69782>>>>>    End_Procedure
69783>>>>>
69783>>>>>    Function psLogTextFileWithPath Returns String
69785>>>>>        String sPath sFileName sFullFileName
69785>>>>>        
69785>>>>>        Get psDataPathFirstPart to sPath
69786>>>>>        Get psLogTextFile to sFileName
69787>>>>>        Move (sPath + sFileName) to sFullFileName
69788>>>>>        Function_Return sFullFileName
69789>>>>>    End_Function                     
69790>>>>>    
69790>>>>>    Procedure WriteHeaderData
69792>>>>>        String sFileName
69792>>>>>        Integer iCh iSize
69792>>>>>        Boolean bQuickWrite
69792>>>>>        DateTime dtUpdateStart
69792>>>>>
69792>>>>>        Move (CurrentDateTime()) to dtUpdateStart
69793>>>>>        If (pbUseDataTableLog(Self) = True) Begin
69795>>>>>            Send OnWriteHeader_DataTable dtUpdateStart
69796>>>>>            Procedure_Return
69797>>>>>        End
69797>>>>>>
69797>>>>>
69797>>>>>        Get piChannel to iCh
69798>>>>>        If (iCh < 0) Begin
69800>>>>>            Get Seq_New_Channel to iCh
69801>>>>>            If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
69803>>>>>                Error DFERR_PROGRAM "No free channel for writing output!"
69804>>>>>>
69804>>>>>                Procedure_Return
69805>>>>>            End
69805>>>>>>
69805>>>>>            Set piChannel to iCh
69806>>>>>        End
69806>>>>>>
69806>>>>>
69806>>>>>        Get psLogTextFileWithPath to sFileName
69807>>>>>        Get vWin32_APIFileSize sFileName to iSize
69808>>>>>        Get pbQuickWrite to bQuickWrite
69809>>>>>        
69809>>>>>        If (bQuickWrite = True) Begin
69811>>>>>            Append_Output channel iCh sFileName
69813>>>>>                If (bQuickWrite = True) Begin
69815>>>>>                    If (iSize = 0) Begin
69817>>>>>                        Writeln channel iCh CS_DatabaseUpdateFramework
69820>>>>>                        Set pbEmptyLogFile to False
69821>>>>>                    End
69821>>>>>>
69821>>>>>                    Writeln channel iCh
69823>>>>>                    Writeln channel iCh ("Database Update Started:      " + String(dtUpdateStart))
69826>>>>>                End
69826>>>>>>
69826>>>>>            Close_Output channel iCh
69828>>>>>        End
69828>>>>>>
69828>>>>>    End_Procedure
69829>>>>>
69829>>>>>    // Returns the first datapath found in the psDataPath property.
69829>>>>>    // The returned path always ends with a "\"
69829>>>>>    Function psDataPathFirstPart Returns String
69831>>>>>        String sDataPath
69831>>>>>        Integer iCount
69831>>>>>
69831>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
69832>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
69833>>>>>        If (iCount > 1) Begin
69835>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
69836>>>>>        End
69836>>>>>>
69836>>>>>        If (sDataPath <> "") Begin
69838>>>>>            Get vFolderFormat sDataPath to sDataPath
69839>>>>>        End
69839>>>>>>
69839>>>>>
69839>>>>>        Function_Return sDataPath
69840>>>>>    End_Function
69841>>>>>
69841>>>>>    // Called from the cDbUpdateHandler object after all updates have been done.
69841>>>>>    Procedure WriteErrorLog
69843>>>>>        tDbUpdateError[] aDbUpdateErrorArray
69843>>>>>        tDbUpdateError[] aDbUpdateErrorArray
69844>>>>>        String sFileName sErrorNo sVersion sErrorText sText sRootName sOrgErrorText
69844>>>>>        Integer iCount iSize iCh iError iErrorLine iField
69844>>>>>        Boolean bUseDataTable bQuickWrite
69844>>>>>        DateTime dtUpdateStart dtUpdateEnd
69844>>>>>        TimeSpan tsElapsed
69844>>>>>        Number nVersion                                  
69844>>>>>        Handle hTable
69844>>>>>
69844>>>>>        If (pbHeaderWritten(Self) = False) Begin
69846>>>>>            Send WriteHeaderData
69847>>>>>            Set pbHeaderWritten to True
69848>>>>>        End
69848>>>>>>
69848>>>>>
69848>>>>>        Get pbUseDataTableLog to bUseDataTable
69849>>>>>        If (bUseDataTable = True) Begin
69851>>>>>            Send OnWriteRow_DataTable
69852>>>>>            Procedure_Return
69853>>>>>        End
69853>>>>>>
69853>>>>>
69853>>>>>        Get piChannel to iCh
69854>>>>>        If (iCh < 0) Begin
69856>>>>>            Get Seq_New_Channel to iCh
69857>>>>>            If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
69859>>>>>                Error DFERR_PROGRAM "No free channel for writing output!"
69860>>>>>>
69860>>>>>                Procedure_Return
69861>>>>>            End
69861>>>>>>
69861>>>>>            Set piChannel to iCh
69862>>>>>        End
69862>>>>>>
69862>>>>>
69862>>>>>        Get psLogTextFileWithPath to sFileName
69863>>>>>
69863>>>>>        Get paDbUpdateErrorArray to aDbUpdateErrorArray
69864>>>>>        Move (SizeOfArray(aDbUpdateErrorArray)) to iSize
69865>>>>>        Decrement iSize
69866>>>>>
69866>>>>>        Get pdtUpdateStart to dtUpdateStart
69867>>>>>        If (IsNullDateTime(dtUpdateStart) = False) Begin
69869>>>>>            Move (CurrentDateTime()) to dtUpdateEnd
69870>>>>>            Move (dtUpdateEnd - dtUpdateStart) to tsElapsed
69871>>>>>        End
69871>>>>>>
69871>>>>>        Get pbQuickWrite to bQuickWrite
69872>>>>>
69872>>>>>        Append_Output channel iCh sFileName
69874>>>>>        If (bQuickWrite = True and iSize < 0) Begin
69876>>>>>            Writeln channel iCh ("Database Update Finished:  " + String(dtUpdateEnd) * "Time Elapsed:" * String(tsElapsed))
69879>>>>>        End
69879>>>>>>
69879>>>>>        Else If (bQuickWrite = False) Begin
69882>>>>>            Writeln channel iCh
69884>>>>>            Writeln channel iCh ("Database Update Started:" * String(dtUpdateStart) * "and finished at:" * String(dtUpdateEnd) * "Time Elapsed:" * String(tsElapsed))
69887>>>>>        End   
69887>>>>>>
69887>>>>>        If (iSize >= 0) Begin
69889>>>>>            If (aDbUpdateErrorArray[0].bShortFormat = False) Begin
69891>>>>>                Writeln channel iCh "[Err No:] [pnVersionNumber:] [Status Text:]"
69894>>>>>            End
69894>>>>>>
69894>>>>>        End
69894>>>>>>
69894>>>>>
69894>>>>>        For iCount from 0 to iSize  
69900>>>>>>
69900>>>>>            Move aDbUpdateErrorArray[iCount].iError         to iError
69901>>>>>            Move aDbUpdateErrorArray[iCount].nUpdateVersion to nVersion
69902>>>>>            Move aDbUpdateErrorArray[iCount].sErrorText     to sErrorText
69903>>>>>            Move aDbUpdateErrorArray[iCount].iErrorLine     to iErrorLine  
69904>>>>>            Move aDbUpdateErrorArray[iCount].hTable         to hTable
69905>>>>>            Move aDbUpdateErrorArray[iCount].sTableRootName to sRootName
69906>>>>>            Move aDbUpdateErrorArray[iCount].iField         to iField
69907>>>>>            
69907>>>>>            Get PadLeft (String(iError)) 8 to sErrorNo
69908>>>>>            If (aDbUpdateErrorArray[iCount].bError = True) Begin
69910>>>>>                Get PadLeft (String(nVersion)) (27 - Length(sErrorNo)) to sVersion
69911>>>>>                Move (sErrorNo + sVersion + "   " + sErrorText * "[ErrLine:" * String(iErrorLine) + "]" + "    (Table:" * sRootName * String(hTable) + "." + String(iField) + ")") to sText
69912>>>>>            End
69912>>>>>>
69912>>>>>            Else Begin
69913>>>>>                Get PadLeft (String(nVersion)) 27 to sVersion
69914>>>>>                Move (sVersion + "   " + sErrorText) to sText
69915>>>>>            End
69915>>>>>>
69915>>>>>            Writeln channel iCh sText
69918>>>>>            If (aDbUpdateErrorArray[iCount].sOrgErrorText <> "") Begin
69920>>>>>                Move ("   (" + aDbUpdateErrorArray[iCount].sOrgErrorText + ")") to sOrgErrorText
69921>>>>>                Move (ToANSI(sOrgErrorText)) to sOrgErrorText
69922>>>>>                Writeln channel iCh sOrgErrorText
69925>>>>>            End
69925>>>>>>
69925>>>>>            If (sText contains CS_SuccessfulUpdate) Begin
69927>>>>>                Writeln channel iCh
69929>>>>>            End
69929>>>>>>
69929>>>>>        Loop
69930>>>>>>
69930>>>>>        Close_Output channel iCh
69932>>>>>
69932>>>>>        Send Seq_Release_Channel iCh
69933>>>>>        Set piChannel to -1
69934>>>>>
69934>>>>>    End_Procedure
69935>>>>>
69935>>>>>    // The character to pad is optional. If nothing, spaces are used.
69935>>>>>    // Example:
69935>>>>>    // Move (PadLeft(45672,10,"0")) to sString -> "0000045672"
69935>>>>>    //  or:
69935>>>>>    // Move (PadLeft("Test",10)) to sString -> " Test"
69935>>>>>    // Courtesy of Pieter van Dieren. Collected from DAWs' Newsgroups.
69935>>>>>    Function PadLeft String sString Integer iLength String sOptChar Returns String
69937>>>>>        String sChar
69937>>>>>
69937>>>>>        If (Num_Arguments >= 3) Begin
69939>>>>>            Move sOptChar to sChar
69940>>>>>        End
69940>>>>>>
69940>>>>>        Else Begin
69941>>>>>            Move " " to sChar
69942>>>>>        End
69942>>>>>>
69942>>>>>
69942>>>>>        While (Length(sString) < iLength)
69946>>>>>            Move (sChar + sString) to sString
69947>>>>>        Loop
69948>>>>>>
69948>>>>>
69948>>>>>        Function_Return sString
69949>>>>>    End_Function
69950>>>>>
69950>>>>>    Procedure ShowErrorLog
69952>>>>>        String sPath sFileName sEditorProgram
69952>>>>>        Boolean bExists
69952>>>>>
69952>>>>>        Get psLogTextFileWithPath to sFileName
69953>>>>>        Get vFilePathExists sFileName to bExists
69954>>>>>        If (bExists = True) Begin
69956>>>>>            Get psEditorProgram to sEditorProgram
69957>>>>>            If (sEditorProgram <> "") Begin
69959>>>>>                Runprogram Background (psEditorProgram(Self)) (sPath + sFileName)
69960>>>>>            End
69960>>>>>>
69960>>>>>            Else Begin
69961>>>>>                Runprogram Shell Background sFileName
69962>>>>>            End
69962>>>>>>
69962>>>>>        End
69962>>>>>>
69962>>>>>        Else Begin
69963>>>>>            Send Info_Box (CS_DUF_LogFileNotFound + String(sFileName))
69964>>>>>        End
69964>>>>>>
69964>>>>>    End_Procedure
69965>>>>>
69965>>>>>End_Class
69966>>>Use cDbUpdateVersion.pkg
Including file: cDbUpdateVersion.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateVersion.pkg)
69966>>>>>//****************************************************************************
69966>>>>>// $Module type: Class
69966>>>>>// $Module name: cDbUpdateVersion
69966>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
69966>>>>>// Web-site    : http://www.rdctools.com
69966>>>>>// Created     : 2016-09-27 @ 09:33 (Military date format: YY-MM-DD)
69966>>>>>//
69966>>>>>// Description : Child class to cDbUpdateHandler.
69966>>>>>//               Put an object of this class inside the global ghoDbUpdateHandler object.
69966>>>>>//               Set the pnVersionNumber to a version number.
69966>>>>>//               Inside the cDbUpdateVersion object put a "Use MyNewDbUpdatePackage.pkg"
69966>>>>>//               Add one cVersion object for each update of the database to the ghoDbUpdateHandler object.
69966>>>>>//               Place your code in the "OnUpdate" event that alters the database.
69966>>>>>//
69966>>>>>// $Rev History:
69966>>>>>//    2016-09-27  Module header created
69966>>>>>//****************************************************************************
69966>>>>>Use UI
69966>>>>>Use DUFLanguageConstants.inc
69966>>>>>Use cDbUpdateFunctionLibrary.pkg
Including file: cDbUpdateFunctionLibrary.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary.pkg)
69966>>>>>>>
69966>>>>>>>//****************************************************************************
69966>>>>>>>// $Module type: Class
69966>>>>>>>// $Module name: cDbUpdateFunctionLibrary
69966>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
69966>>>>>>>// Web-site    : http://www.rdctools.com
69966>>>>>>>// Created     : 2014-09-05 @ 09:50 (Military date format: YY-MM-DD)
69966>>>>>>>//
69966>>>>>>>// Description : The class consists of a function library for database manipulations, aka make changes to a database.
69966>>>>>>>//               It has top level functions that uses the DataFlex db API, _but_ also specialized
69966>>>>>>>//               functions to make db changes to Sql databases with the DAW & Mertech drivers,
69966>>>>>>>//               with the help of Sql-scripts.
69966>>>>>>>//
69966>>>>>>>// $Rev History:
69966>>>>>>>//    2014-09-05  Module header created
69966>>>>>>>//
69966>>>>>>>//****************************************************************************
69966>>>>>>>Use cApplication.pkg
69966>>>>>>>Use seq_chnl.pkg
69966>>>>>>>Use GlobalFunctionsProcedures.pkg
69966>>>>>>>Use Datadict.pkg                        // Declaration of DF_FILE_SQL_TABLE_NAME
69966>>>>>>>Use Dfcursor.pkg
69966>>>>>>>Use DUFStatusPanel.pkg
69966>>>>>>>Use cDbUpdateFunctionLibrary_Mixin.pkg  // Properties used by the cDbUpdateFunctionLibrary class.
Including file: cDbUpdateFunctionLibrary_Mixin.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary_Mixin.pkg)
69966>>>>>>>>>// *** Mixin Class For the cDbUpdateFunctionLibrary Class ***
69966>>>>>>>>>//
69966>>>>>>>>>// We need to create a mixin class for the library.
69966>>>>>>>>>// Why? Because we import the library to the cDbUpdateVersion class; that imports
69966>>>>>>>>>// all messages (functions & procedures) but all Properties are "lost", aka not imported by
69966>>>>>>>>>// the Import_Class_Protocol command. So we need a way to create our properties somewhere else...
69966>>>>>>>>>// Note: This class should _not_ have a construct_object defined.
69966>>>>>>>>>//
69966>>>>>>>>>Use VdfBase.pkg
69966>>>>>>>>>Use WinUuid.pkg
Including file: WinUuid.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\WinUuid.pkg)
69966>>>>>>>>>>>External_Function WinAPI_UuidCreate "UuidCreate" Rpcrt4.dll Address Uuid Returns Integer
69967>>>>>>>>>>>External_Function WinAPI_UuidToString  "UuidToStringA" Rpcrt4.dll Address aUuid Address lpUUIDString Returns Integer
69968>>>>>>>>>>>External_Function WinAPI_UuidCreateSequential "UuidCreateSequential" Rpcrt4.dll Address aUuid Returns Integer
69969>>>>>>>>>>>External_Function WinAPI_RpcStringFree "RpcStringFreeA" Rpcrt4.dll Address pStr Returns Integer
69970>>>>>>>>>>>
69970>>>>>>>>>>>// Returns a 'random' Universally Unique Identifier string as a 32 digit hex number.
69970>>>>>>>>>>>Function RandomHexUUID Global Returns String
69972>>>>>>>>>>>    Address pUUID pUUIDStr
69972>>>>>>>>>>>    Integer iRetval iOffset iChar
69972>>>>>>>>>>>    String sUUID sKey
69972>>>>>>>>>>>    
69972>>>>>>>>>>>    Move (Alloc(16)) to pUUID
69973>>>>>>>>>>>    
69973>>>>>>>>>>>    Move (WinAPI_UuidCreate (pUUID)) to iRetval
69974>>>>>>>>>>>    
69974>>>>>>>>>>>    If (iRetval = 0) Begin
69976>>>>>>>>>>>        Move 0 to pUUIDStr
69977>>>>>>>>>>>        
69977>>>>>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
69978>>>>>>>>>>>        If (iRetval = 0) Begin
69980>>>>>>>>>>>            Move pUUIDStr to sUUID
69981>>>>>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
69982>>>>>>>>>>>            
69982>>>>>>>>>>>            Move (Uppercase (sUUID)) to sUUID
69983>>>>>>>>>>>        End
69983>>>>>>>>>>>>
69983>>>>>>>>>>>    End
69983>>>>>>>>>>>>
69983>>>>>>>>>>>    
69983>>>>>>>>>>>    Move (Free(pUUID)) to iRetval
69984>>>>>>>>>>>    
69984>>>>>>>>>>>    Function_Return sUUID
69985>>>>>>>>>>>End_Function
69986>>>>>>>>>>>
69986>>>>>>>>>>>
69986>>>>>>>>>>>// Returns a sequential Universally Unique Identifier string as a 32 digit hex number.
69986>>>>>>>>>>>Function SeqHexUUID Global Returns String
69988>>>>>>>>>>>    Address pUUID pUUIDStr
69988>>>>>>>>>>>    Integer iRetval iOffset iChar
69988>>>>>>>>>>>    String sUUID sKey
69988>>>>>>>>>>>    
69988>>>>>>>>>>>    Move (Alloc(16)) to pUUID
69989>>>>>>>>>>>    
69989>>>>>>>>>>>    Move (WinAPI_UuidCreateSequential (pUUID)) to iRetval
69990>>>>>>>>>>>    
69990>>>>>>>>>>>    If (iRetval = 0) Begin
69992>>>>>>>>>>>        Move 0 to pUUIDStr
69993>>>>>>>>>>>        
69993>>>>>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
69994>>>>>>>>>>>        If (iRetval = 0) Begin
69996>>>>>>>>>>>            Move pUUIDStr to sUUID
69997>>>>>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
69998>>>>>>>>>>>            
69998>>>>>>>>>>>            Move (Uppercase (sUUID)) to sUUID
69999>>>>>>>>>>>        End
69999>>>>>>>>>>>>
69999>>>>>>>>>>>    End
69999>>>>>>>>>>>>
69999>>>>>>>>>>>    
69999>>>>>>>>>>>    Move (Free(pUUID)) to iRetval
70000>>>>>>>>>>>    
70000>>>>>>>>>>>    Function_Return sUUID
70001>>>>>>>>>>>End_Function
70002>>>>>>>>>Use cli.pkg
70002>>>>>>>>>Use sql.pkg
70002>>>>>>>>>Use MSSqldrv.pkg
Including file: MSSqldrv.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\MSSqldrv.pkg)
70002>>>>>>>>>>>//     Package that declares MS SQL driver constants and functions.
70002>>>>>>>>>>>//     This package can be used by developers who want to add Data Access
70002>>>>>>>>>>>//     MS SQL Client specific code to a DataFlex application.
70002>>>>>>>>>>>
70002>>>>>>>>>>>Use Cli.pkg
70002>>>>>>>>>>>Use SQL.pkg
70002>>>>>>>>>>>
70002>>>>>>>>>>>//   Driver Indentification
70002>>>>>>>>>>>
70002>>>>>>>>>>>//   Error number constants
70002>>>>>>>>>>>
70002>>>>>>>>>>>
70002>>>>>>>>>>>//   Possible DF_DRIVER_SQLSERVER_CLIENT_VERSION values
70002>>>>>>>>>>>
70002>>>>>>>>>>>
70002>>>>>>>>>>>
70002>>>>>>>>>>>
70002>>>>>>>>>>>
70002>>>>>>>>>>>
70002>>>>>>>>>>>// SQL Server spcific types.
70002>>>>>>>>>>>Define SQL_SS_TIMESTAMPOFFSET   for   (-155) //SQL server datetimeoffset type */
70002>>>>>>>>>>>Define SQL_SS_TIME2             for   (-154) //SQL server time type */
70002>>>>>>>>>>>Define SQL_SS_XML               for   (-152) //SQL server xml type */
70002>>>>>>>>>>>Define SQL_SS_VARIANT           for   (-150) //SQL server variant type */
70002>>>>>>>>>>>
70002>>>>>>>>>>>// SQL Server spcific types.
70002>>>>>>>>>>>Define SQL_TYPE_TIMESTAMP2      for   (-200) //SQL server datetime2 type */
70002>>>>>>>>>>>Define SQL_VARCHARMAX           for   (-201) //SQL server varchar(max) type */
70002>>>>>>>>>>>Define SQL_WVARCHARMAX          for   (-202) //SQL server wvarchar(max) type */
70002>>>>>>>>>>>Define SQL_VARBINARYMAX         for   (-203) //SQL server varbinary(max) type */
70002>>>>>>>>>>>Define SQL_TYPE_MONEY           for   (-204) //SQL server money type */
70002>>>>>>>>>>>Define SQL_TYPE_SMALLMONEY      for   (-205) //SQL server smallmoney type */
70002>>>>>>>>>>>Define SQL_TYPE_SMALLDATETIME   for   (-206) //SQL server smalldatetype type */
70002>>>>>>>>>>>
70002>>>>>>>>>>>
70002>>>>>>>>>>>//   MSSQL_SetConstraint <FileNum> <ConstraintText>
70002>>>>>>>>>>>//
70002>>>>>>>>>>>//     Setup a constraint for a file.
70002>>>>>>>>>>>
70002>>>>>>>>>>>
70002>>>>>>>>>>>Class cMSSQLHandler is a cCLIHandler
70003>>>>>>>>>>>    
70003>>>>>>>>>>>    Procedure Construct_Object
70005>>>>>>>>>>>        Forward Send Construct_Object
70007>>>>>>>>>>>        
70007>>>>>>>>>>>        Set psDriverID to MSSQLDRV_ID
70008>>>>>>>>>>>    End_Procedure
70009>>>>>>>>>>>    
70009>>>>>>>>>>>    
70009>>>>>>>>>>>    
70009>>>>>>>>>>>    //   Extract the list from the out connect string.
70009>>>>>>>>>>>    Function ExtractList String sOutConnStr Integer hoStore Returns Integer
70011>>>>>>>>>>>        String  sItem
70011>>>>>>>>>>>        Integer iStart
70011>>>>>>>>>>>        Integer iEnd
70011>>>>>>>>>>>        
70011>>>>>>>>>>>        If (hoStore = 0) ;            Move Current_object to hoStore
70014>>>>>>>>>>>        
70014>>>>>>>>>>>        Send Delete_Data to hoStore
70015>>>>>>>>>>>        Move (Pos("{", sOutConnStr)) to iStart
70016>>>>>>>>>>>        While (iStart > 0)
70020>>>>>>>>>>>            Move (Right(sOutConnStr, Length(sOutConnStr) - iStart)) to sOutConnStr
70021>>>>>>>>>>>            If (Left(sOutConnStr, 1) = "}") ;                Move 0 to iStart
70024>>>>>>>>>>>            Else Begin
70025>>>>>>>>>>>                Move (Pos(",", sOutConnStr)) to iStart
70026>>>>>>>>>>>                Move (Pos("}", sOutConnStr)) to iEnd
70027>>>>>>>>>>>                If ((iStart = 0) or (iEnd < iStart)) ;                    Move iEnd to iStart
70030>>>>>>>>>>>                
70030>>>>>>>>>>>                If (iStart > 0) ;                    Set Value of hoStore  (Item_Count(Current_Object)) to (Left(sOutConnStr, iStart - 1))
70033>>>>>>>>>>>                
70033>>>>>>>>>>>                If (iStart = iEnd) ;                    Move 0 to iStart
70036>>>>>>>>>>>            End
70036>>>>>>>>>>>>
70036>>>>>>>>>>>        Loop
70037>>>>>>>>>>>>
70037>>>>>>>>>>>        
70037>>>>>>>>>>>        Function_Return (Item_Count(hoStore))
70038>>>>>>>>>>>    End_Function
70039>>>>>>>>>>>    
70039>>>>>>>>>>>    
70039>>>>>>>>>>>    
70039>>>>>>>>>>>    //   Call the driver's browse connect function
70039>>>>>>>>>>>    Function BrowseConnect String sInConnStr Returns String
70041>>>>>>>>>>>        String  sDriver
70041>>>>>>>>>>>        String  sOutConnStr
70041>>>>>>>>>>>        Integer iArg
70041>>>>>>>>>>>        Integer iRetval
70041>>>>>>>>>>>        
70041>>>>>>>>>>>        Get psDriverID to sDriver
70042>>>>>>>>>>>        If (sDriver <> "") Begin
70044>>>>>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
70045>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
70050>>>>>>>>>>>        End
70050>>>>>>>>>>>>
70050>>>>>>>>>>>        
70050>>>>>>>>>>>        Function_Return sOutConnStr
70051>>>>>>>>>>>    End_Function// BrowseConnect
70052>>>>>>>>>>>    
70052>>>>>>>>>>>    
70052>>>>>>>>>>>    Function BrowseConnectLocal String sInConnStr Returns String
70054>>>>>>>>>>>        String  sDriver
70054>>>>>>>>>>>        String  sOutConnStr
70054>>>>>>>>>>>        Integer iArg
70054>>>>>>>>>>>        Integer iRetval
70054>>>>>>>>>>>        
70054>>>>>>>>>>>        Move 1 to iArg // Browses only local
70055>>>>>>>>>>>        
70055>>>>>>>>>>>        Get psDriverID to sDriver
70056>>>>>>>>>>>        If (sDriver <> "") Begin
70058>>>>>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
70059>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
70064>>>>>>>>>>>        End
70064>>>>>>>>>>>>
70064>>>>>>>>>>>        
70064>>>>>>>>>>>        Function_Return sOutConnStr
70065>>>>>>>>>>>    End_Function// BrowseConnect
70066>>>>>>>>>>>    
70066>>>>>>>>>>>    
70066>>>>>>>>>>>    Function EnumerateServersNetworkOrLocal Integer iNetworkLocal  Returns Integer
70068>>>>>>>>>>>        
70068>>>>>>>>>>>        String  sServerList
70068>>>>>>>>>>>        Integer iNumServers
70068>>>>>>>>>>>        Integer iDriver
70068>>>>>>>>>>>        Integer iClientVersion
70068>>>>>>>>>>>        String  sDriver
70068>>>>>>>>>>>        
70068>>>>>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriver
70069>>>>>>>>>>>        
70069>>>>>>>>>>>        If (iDriver) Begin
70071>>>>>>>>>>>            
70071>>>>>>>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
70074>>>>>>>>>>>            
70074>>>>>>>>>>>            Get SqlServerClientDriverName iClientVersion to sDriver
70075>>>>>>>>>>>            
70075>>>>>>>>>>>            Move ("DRIVER={" + sDriver + "};") to sDriver
70076>>>>>>>>>>>            If (iNetworkLocal = 0) Begin
70078>>>>>>>>>>>                Get BrowseConnect sDriver to sServerList
70079>>>>>>>>>>>            End
70079>>>>>>>>>>>>
70079>>>>>>>>>>>            Else Begin
70080>>>>>>>>>>>                Get BrowseConnectLocal sDriver to sServerList
70081>>>>>>>>>>>            End
70081>>>>>>>>>>>>
70081>>>>>>>>>>>            Get ExtractList sServerList Current_object to iNumServers
70082>>>>>>>>>>>        End
70082>>>>>>>>>>>>
70082>>>>>>>>>>>        
70082>>>>>>>>>>>        Function_Return iNumServers
70083>>>>>>>>>>>        
70083>>>>>>>>>>>    End_Function
70084>>>>>>>>>>>    
70084>>>>>>>>>>>    //   Enumerate the available SQL Server database servers
70084>>>>>>>>>>>    //   This function will return all SQL Server instances on the network.
70084>>>>>>>>>>>    //   This may take a long time.
70084>>>>>>>>>>>    //   To enumerate only local SQL Server instances use EnumerateServersLocal
70084>>>>>>>>>>>    Function EnumerateServers Returns Integer
70086>>>>>>>>>>>        
70086>>>>>>>>>>>        Integer iNumServers
70086>>>>>>>>>>>        Integer iNetworkLocal
70086>>>>>>>>>>>        
70086>>>>>>>>>>>        Move 0 to iNetworkLocal // 0 = enumerate network servers
70087>>>>>>>>>>>        
70087>>>>>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
70088>>>>>>>>>>>        
70088>>>>>>>>>>>        Function_Return iNumServers
70089>>>>>>>>>>>        
70089>>>>>>>>>>>    End_Function
70090>>>>>>>>>>>    
70090>>>>>>>>>>>    
70090>>>>>>>>>>>    //   Enumerate the available SQL Server database servers
70090>>>>>>>>>>>    //   This function will return only return SQL Server instance on the local machine
70090>>>>>>>>>>>    //   To enumerate all SQL Server instances in a network use EnumerateServers
70090>>>>>>>>>>>    Function EnumerateServersLocal Returns Integer
70092>>>>>>>>>>>        
70092>>>>>>>>>>>        Integer iNumServers
70092>>>>>>>>>>>        Integer iNetworkLocal
70092>>>>>>>>>>>        
70092>>>>>>>>>>>        Move 1 to iNetworkLocal // 1 = enumerate local servers
70093>>>>>>>>>>>        
70093>>>>>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
70094>>>>>>>>>>>        
70094>>>>>>>>>>>        Function_Return iNumServers
70095>>>>>>>>>>>        
70095>>>>>>>>>>>    End_Function
70096>>>>>>>>>>>    
70096>>>>>>>>>>>    
70096>>>>>>>>>>>    
70096>>>>>>>>>>>    //   Enumerate database in a given server.
70096>>>>>>>>>>>    Function EnumerateDatabases String sServer String sUser String sPassWord Returns Integer
70098>>>>>>>>>>>        Integer hoSQL
70098>>>>>>>>>>>        String  sConnect
70098>>>>>>>>>>>        String  sDatabase
70098>>>>>>>>>>>        Integer hdbc
70098>>>>>>>>>>>        Integer hstmt
70098>>>>>>>>>>>        Integer iFetchResult
70098>>>>>>>>>>>        
70098>>>>>>>>>>>        If (Num_Arguments < 3) ;            Move "" to sPassWord
70101>>>>>>>>>>>        If (Num_Arguments < 2) ;            Move "" to sUser
70104>>>>>>>>>>>        
70104>>>>>>>>>>>        If (sUser <> "") ;            Move ("SERVER=" + Trim(sServer) + ";UID=" + Trim(sUser) + ";PWD=" + Trim(sPassword) + ";") to sConnect
70107>>>>>>>>>>>        Else ;            Move ("SERVER=" + Trim(sServer) + ";Trusted_Connection=yes") to sConnect
70109>>>>>>>>>>>        
70109>>>>>>>>>>>        Object oEnumDBSQLmanager is a cSQLHandleManager
70111>>>>>>>>>>>            Move Current_Object to hoSQL
70112>>>>>>>>>>>        End_Object
70113>>>>>>>>>>>        
70113>>>>>>>>>>>        If (hoSQL <> 0) Begin
70115>>>>>>>>>>>            Get SQLConnect of hoSQL "MSSQLDRV" sConnect to hdbc
70116>>>>>>>>>>>            If (hdbc <> 0) Begin
70118>>>>>>>>>>>                Get SQLOpen of hdbc to hstmt
70119>>>>>>>>>>>                If (hstmt <> 0) Begin
70121>>>>>>>>>>>                    //   We could do a direct select on the sysdatabases table but we use
70121>>>>>>>>>>>                    //   the stored procedure sp_database instead. SQL Server recommends this
70121>>>>>>>>>>>                    //   approach in case meta data might change, the stored procedure will
70121>>>>>>>>>>>                    //   stay the same.
70121>>>>>>>>>>>                    Send SQLSetProcedureName to hstmt "sp_databases"
70122>>>>>>>>>>>                    Send SQLCall to hstmt
70123>>>>>>>>>>>                    Repeat
70123>>>>>>>>>>>>
70123>>>>>>>>>>>                        Get SQLFetch of hstmt to iFetchResult
70124>>>>>>>>>>>                        If (iFetchResult <> 0) Begin
70126>>>>>>>>>>>                            Get SQLColumnValue of hstmt 1 to sDatabase
70127>>>>>>>>>>>                            Set Value  (Item_Count(Current_Object)) to sDatabase
70128>>>>>>>>>>>                        End
70128>>>>>>>>>>>>
70128>>>>>>>>>>>                    Until (iFetchResult = 0)
70130>>>>>>>>>>>                    
70130>>>>>>>>>>>                    Send SQLClose to hstmt
70131>>>>>>>>>>>                End
70131>>>>>>>>>>>>
70131>>>>>>>>>>>                Send SQLDisconnect to hdbc
70132>>>>>>>>>>>            End
70132>>>>>>>>>>>>
70132>>>>>>>>>>>        End
70132>>>>>>>>>>>>
70132>>>>>>>>>>>        Send Destroy_Object to hoSQL
70133>>>>>>>>>>>        
70133>>>>>>>>>>>        Function_Return (Item_Count(Current_Object))
70134>>>>>>>>>>>    End_Function
70135>>>>>>>>>>>    
70135>>>>>>>>>>>    
70135>>>>>>>>>>>    Function SqlServerClientVersionName Integer iClientVersion  Returns String
70137>>>>>>>>>>>        
70137>>>>>>>>>>>        String  sSqlServerClientVersionName
70137>>>>>>>>>>>        
70137>>>>>>>>>>>        
70137>>>>>>>>>>>        Case Begin
70137>>>>>>>>>>>            
70137>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
70139>>>>>>>>>>>                Move SQLSERVER2017CLIENTNAME to sSqlServerClientVersionName
70140>>>>>>>>>>>                Case Break
70141>>>>>>>>>>>                
70141>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
70144>>>>>>>>>>>                Move SQLSERVER2016CLIENTNAME to sSqlServerClientVersionName
70145>>>>>>>>>>>                Case Break
70146>>>>>>>>>>>            
70146>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
70149>>>>>>>>>>>                Move SQLSERVER2014CLIENTNAME to sSqlServerClientVersionName
70150>>>>>>>>>>>                Case Break
70151>>>>>>>>>>>            
70151>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
70154>>>>>>>>>>>                Move SQLSERVER2012CLIENTNAME to sSqlServerClientVersionName
70155>>>>>>>>>>>                Case Break
70156>>>>>>>>>>>            
70156>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
70159>>>>>>>>>>>                Move SQLSERVER2008CLIENTNAME to sSqlServerClientVersionName
70160>>>>>>>>>>>                Case Break
70161>>>>>>>>>>>            
70161>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
70164>>>>>>>>>>>                Move SQLSERVER2005CLIENTNAME to sSqlServerClientVersionName
70165>>>>>>>>>>>                Case Break
70166>>>>>>>>>>>            
70166>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
70169>>>>>>>>>>>                Move SQLSERVER2000CLIENTNAME to sSqlServerClientVersionName
70170>>>>>>>>>>>                Case Break
70171>>>>>>>>>>>            
70171>>>>>>>>>>>            Case Else
70171>>>>>>>>>>>                Move SQLSERVERUNKNOWNCLIENTNAME to sSqlServerClientVersionName
70172>>>>>>>>>>>                
70172>>>>>>>>>>>        Case End
70172>>>>>>>>>>>        
70172>>>>>>>>>>>        
70172>>>>>>>>>>>        Function_Return sSqlServerClientVersionName
70173>>>>>>>>>>>        
70173>>>>>>>>>>>    End_Function
70174>>>>>>>>>>>
70174>>>>>>>>>>>
70174>>>>>>>>>>>    Function SqlServerClientDriverName Integer iClientVersion  Returns String
70176>>>>>>>>>>>        
70176>>>>>>>>>>>        String  sSqlServerClientDriverName
70176>>>>>>>>>>>        
70176>>>>>>>>>>>        Case Begin
70176>>>>>>>>>>>            
70176>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
70178>>>>>>>>>>>                Move SQLSERVER2017DRVRSTR to sSqlServerClientDriverName
70179>>>>>>>>>>>                Case Break
70180>>>>>>>>>>>                
70180>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
70183>>>>>>>>>>>                Move SQLSERVER2016DRVRSTR to sSqlServerClientDriverName
70184>>>>>>>>>>>                Case Break
70185>>>>>>>>>>>            
70185>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
70188>>>>>>>>>>>                Move SQLSERVER2014DRVRSTR to sSqlServerClientDriverName
70189>>>>>>>>>>>                Case Break
70190>>>>>>>>>>>            
70190>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
70193>>>>>>>>>>>                Move SQLSERVER2012DRVRSTR to sSqlServerClientDriverName
70194>>>>>>>>>>>                Case Break
70195>>>>>>>>>>>            
70195>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
70198>>>>>>>>>>>                Move SQLSERVER2008DRVRSTR to sSqlServerClientDriverName
70199>>>>>>>>>>>                Case Break
70200>>>>>>>>>>>            
70200>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
70203>>>>>>>>>>>                Move SQLSERVER2005DRVRSTR to sSqlServerClientDriverName
70204>>>>>>>>>>>                Case Break
70205>>>>>>>>>>>            
70205>>>>>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
70208>>>>>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
70209>>>>>>>>>>>                Case Break
70210>>>>>>>>>>>            
70210>>>>>>>>>>>            Case Else
70210>>>>>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
70211>>>>>>>>>>>                
70211>>>>>>>>>>>        Case End
70211>>>>>>>>>>>        
70211>>>>>>>>>>>        
70211>>>>>>>>>>>        Function_Return sSqlServerClientDriverName
70212>>>>>>>>>>>        
70212>>>>>>>>>>>    End_Function
70213>>>>>>>>>>>    
70213>>>>>>>>>>>    
70213>>>>>>>>>>>End_Class
70214>>>>>>>>>>>
70214>>>>>>>>>>>
70214>>>>>>>>>Use db2_drv.pkg
Including file: db2_drv.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\db2_drv.pkg)
70214>>>>>>>>>>>// DB2_DRV.PKG                                                          
70214>>>>>>>>>>>//   Package that declares DB2 driver constants and functions.          
70214>>>>>>>>>>>//   This package can be used by developers who want to add DB2 driver  
70214>>>>>>>>>>>//   specific code to a DataFlex application.                           
70214>>>>>>>>>>>
70214>>>>>>>>>>>Use Cli.pkg
70214>>>>>>>>>>>
70214>>>>>>>>>>>// Driver attributes
70214>>>>>>>>>>>
70214>>>>>>>>>>>
70214>>>>>>>>>>>// Driver Indentification
70214>>>>>>>>>>>
70214>>>>>>>>>>>// Error number constants
70214>>>>>>>>>>>
70214>>>>>>>>>>>// Call driver function identifiers
70214>>>>>>>>>>>
70214>>>>>>>>>>>// DB2 specific data types
70214>>>>>>>>>>>Define SQL_CLOB           for   (-99)
70214>>>>>>>>>>>Define SQL_BLOB           for   (-98)
70214>>>>>>>>>>>Define SQL_XML            for   (-370)
70214>>>>>>>>>>>// DB2 Graphic types are Unicode types
70214>>>>>>>>>>>Define SQL_GRAPHIC        for   (-95)
70214>>>>>>>>>>>Define SQL_VARGRAPHIC     for   (-96)
70214>>>>>>>>>>>Define SQL_LONGVARGRAPHIC for   (-97)
70214>>>>>>>>>>>Define SQL_DBCLOB         for   (-350)
70214>>>>>>>>>>>
70214>>>>>>>>>>>
70214>>>>>>>>>>>// Extra DB2 commands
70214>>>>>>>>>>>
70214>>>>>>>>>>>
70214>>>>>>>>>>>// DB2_SetConstraint <FileNum> <ConstraintText>                         
70214>>>>>>>>>>>//   Setup a constraint for a file.                                     
70214>>>>>>>>>>>
70214>>>>>>>>>>>
70214>>>>>>>>>>>
70214>>>>>>>>>>>Class cDB2Handler is a cCLIHandler
70215>>>>>>>>>>>    
70215>>>>>>>>>>>    Procedure Construct_Object
70217>>>>>>>>>>>        Forward Send Construct_Object
70219>>>>>>>>>>>        
70219>>>>>>>>>>>        Set psDriverID to DB2_DRV_ID
70220>>>>>>>>>>>    End_Procedure
70221>>>>>>>>>>>    
70221>>>>>>>>>>>    
70221>>>>>>>>>>>    
70221>>>>>>>>>>>    // Reset the datasource list to the beginning
70221>>>>>>>>>>>    Procedure SeedDataSources
70223>>>>>>>>>>>        String  sDriver
70223>>>>>>>>>>>        String  sVoid
70223>>>>>>>>>>>        Integer iRetval
70223>>>>>>>>>>>        
70223>>>>>>>>>>>        Get psDriverID to sDriver
70224>>>>>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid SQL_FETCH_ALL Result iRetval
70231>>>>>>>>>>>    End_Procedure
70232>>>>>>>>>>>    
70232>>>>>>>>>>>    
70232>>>>>>>>>>>    
70232>>>>>>>>>>>    // Call the driver's data sources function
70232>>>>>>>>>>>    Function DataSources Returns String
70234>>>>>>>>>>>        String  sDriver
70234>>>>>>>>>>>        String  sDataSource
70234>>>>>>>>>>>        String  sDescription
70234>>>>>>>>>>>        Integer iLength
70234>>>>>>>>>>>        Integer iRetval
70234>>>>>>>>>>>        
70234>>>>>>>>>>>        Get psDriverID to sDriver
70235>>>>>>>>>>>        If (sDriver <> "") Begin
70237>>>>>>>>>>>            Move 8192 to iLength
70238>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDataSource
70239>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDescription
70240>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
70245>>>>>>>>>>>        End
70245>>>>>>>>>>>>
70245>>>>>>>>>>>        
70245>>>>>>>>>>>        If (sDataSource <> "" or sDescription <> "") ;            Function_Return (sDataSource + "," +  sDescription)
70248>>>>>>>>>>>        Else ;            Function_Return ""
70250>>>>>>>>>>>    End_Function
70251>>>>>>>>>>>    
70251>>>>>>>>>>>End_Class
70252>>>>>>>>>Use odbc_drv.pkg
Including file: odbc_drv.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\odbc_drv.pkg)
70252>>>>>>>>>>>//   Package that declares ODBC driver constants and functions.         
70252>>>>>>>>>>>//   This package can be used by developers who want to add Data Access 
70252>>>>>>>>>>>//   ODBC Client specific code to a DataFlex application.               
70252>>>>>>>>>>>
70252>>>>>>>>>>>Use Cli.pkg
70252>>>>>>>>>>>
70252>>>>>>>>>>>// Driver Indentification
70252>>>>>>>>>>>
70252>>>>>>>>>>>// Error number constants
70252>>>>>>>>>>>
70252>>>>>>>>>>>// Call driver function identifiers
70252>>>>>>>>>>>
70252>>>>>>>>>>>Class cODBCHandler is a cCLIHandler
70253>>>>>>>>>>>    
70253>>>>>>>>>>>    Procedure Construct_Object
70255>>>>>>>>>>>        Forward Send Construct_Object
70257>>>>>>>>>>>        
70257>>>>>>>>>>>        Set psDriverID to ODBC_DRV_ID
70258>>>>>>>>>>>    End_Procedure
70259>>>>>>>>>>>    
70259>>>>>>>>>>>    
70259>>>>>>>>>>>    
70259>>>>>>>>>>>    // Setup the type of data sources returned by the datasources function
70259>>>>>>>>>>>    Procedure Set DataSourceType Integer iNewType
70261>>>>>>>>>>>        String  sDriver
70261>>>>>>>>>>>        String  sVoid
70261>>>>>>>>>>>        Integer iRetval
70261>>>>>>>>>>>        
70261>>>>>>>>>>>        Get psDriverID to sDriver
70262>>>>>>>>>>>        If (sDriver <> "") ;            Call_Driver 0 sDRiver Function CLI_INITDATASOURCES Callback 0 Passing sVoid sVoid iNewType Result iRetval
70269>>>>>>>>>>>    End_Procedure
70270>>>>>>>>>>>    
70270>>>>>>>>>>>    
70270>>>>>>>>>>>    // Call the driver's data sources function
70270>>>>>>>>>>>    Function DataSources Returns String
70272>>>>>>>>>>>        String  sDriver
70272>>>>>>>>>>>        String  sDataSource
70272>>>>>>>>>>>        String  sDescription
70272>>>>>>>>>>>        Integer iLength
70272>>>>>>>>>>>        Integer iRetval
70272>>>>>>>>>>>        
70272>>>>>>>>>>>        Get psDriverID to sDriver
70273>>>>>>>>>>>        If (sDriver <> "") Begin
70275>>>>>>>>>>>            Move 8192 to iLength
70276>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDataSource
70277>>>>>>>>>>>            Move (Repeat(" ", iLength)) to sDescription
70278>>>>>>>>>>>            Call_Driver 0 sDRiver Function CLI_DATASOURCES Callback 0 Passing sDataSource sDescription iLength Result iRetval
70283>>>>>>>>>>>        End
70283>>>>>>>>>>>>
70283>>>>>>>>>>>        
70283>>>>>>>>>>>        If (sDataSource <> "" or sDescription <> "") ;            Function_Return (sDataSource + "," +  sDescription)
70286>>>>>>>>>>>        Else ;            Function_Return ""
70288>>>>>>>>>>>    End_Function
70289>>>>>>>>>>>    
70289>>>>>>>>>>>End_Class
70290>>>>>>>>>>>
70290>>>>>>>>>Use DFBTRDRV.PKG
Including file: DFBTRDRV.PKG    (C:\Program Files (x86)\DataFlex 19.1\Pkg\DFBTRDRV.PKG)
70290>>>>>>>>>>>// $File title : Package for the DataFlex Connectivity Kit for Pervasive.SQL
70290>>>>>>>>>>>// Notice      : This package contains constants and commands, used to call
70290>>>>>>>>>>>//               specific functions in the DFBTRDRV.
70290>>>>>>>>>>>Use Ui
70290>>>>>>>>>>>//
70290>>>>>>>>>>>// Driver Indentification
70290>>>>>>>>>>>//
70290>>>>>>>>>>>
70290>>>>>>>>>>>// Driver attributes
70290>>>>>>>>>>>//
70290>>>>>>>>>>>// Call_Driver functions ID's
70290>>>>>>>>>>>//
70290>>>>>>>>>>>//
70290>>>>>>>>>>>// DFBTRFN_CONVERT_FILE options
70290>>>>>>>>>>>//
70290>>>>>>>>>>>
70290>>>>>>>>>>>//
70290>>>>>>>>>>>// DFBTRFN_SET_OWNER options
70290>>>>>>>>>>>//
70290>>>>>>>>>>>
70290>>>>>>>>>>>//
70290>>>>>>>>>>>// DFBTRFN_SET_TRANSACTION_TYPE options
70290>>>>>>>>>>>//
70290>>>>>>>>>>>
70290>>>>>>>>>>>
70290>>>>>>>>>>>//
70290>>>>>>>>>>>// Command to create all vars which may be needed
70290>>>>>>>>>>>// in other commands.
70290>>>>>>>>>>>//
70290>>>>>>>>>>>
70290>>>>>>>>>>>
70290>>>>>>>>>>>
70290>>>>>>>>>>>//
70290>>>>>>>>>>>// Command to set the owner of a Btrieve file.
70290>>>>>>>>>>>// File must have been opened.
70290>>>>>>>>>>>// Filenumber needs to be passed.
70290>>>>>>>>>>>// To clear set the owner to "".
70290>>>>>>>>>>>// Examples:
70290>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret"
70290>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY CALLBACK MyCallBack
70290>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" ENCRYPT
70290>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY ENCRYPT CALLBACK MyCallBack
70290>>>>>>>>>>>// To clear:
70290>>>>>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to ""
70290>>>>>>>>>>>//
70290>>>>>>>>>>>
70290>>>>>>>>>>>
70290>>>>>>>>>>>
70290>>>>>>>>>>>//
70290>>>>>>>>>>>// Command to parse DFBTR_SET_OWNVER
70290>>>>>>>>>>>// options.
70290>>>>>>>>>>>//
70290>>>>>>>>>>>
70290>>>>>>>>>>>
70290>>>>>>>>>>>
70290>>>>>>>>>>>//
70290>>>>>>>>>>>// Command to parse for Callback
70290>>>>>>>>>>>//
70290>>>>>>>>>>>
70290>>>>>>>>>>>
70290>>>>>>>>>>>
70290>>>>>>>>>>>//
70290>>>>>>>>>>>// Command to clear the owner of a Btrieve file.
70290>>>>>>>>>>>// File must have been opened.
70290>>>>>>>>>>>// Filenumber needs to be passed.
70290>>>>>>>>>>>// Examples:
70290>>>>>>>>>>>//      DFBTR_CLEAR_OWNER MyFileNumber
70290>>>>>>>>>>>//
70290>>>>>>>>>>>
70290>>>>>>>>>>>
70290>>>>>>>>>>>
70290>>>>>>>>>>>//
70290>>>>>>>>>>>// Command to add a owner name to the internal list of ownernames
70290>>>>>>>>>>>// which will be tries when opening files.
70290>>>>>>>>>>>//
70290>>>>>>>>>>>
70290>>>>>>>>>>>
70290>>>>>>>>>>>
70290>>>>>>>>>>>//
70290>>>>>>>>>>>// Command to remove all owners from the internal list of ownernames
70290>>>>>>>>>>>//
70290>>>>>>>>>>>
70290>>>>>>>>>>>
70290>>>>>>>>>>>//
70290>>>>>>>>>>>// Command to set the owner name to be used when opening the DDF files.
70290>>>>>>>>>>>// The DDF owner is required when Pervasive.SQL security is turned on.
70290>>>>>>>>>>>// The DDF owner is equal to the password of the Master user in Pervasive.SQL
70290>>>>>>>>>>>// This command overwrites the DDF_OWNER setting in DFBTRDRV.INT
70290>>>>>>>>>>>//
70290>>>>>>>>>>>
70290>>>>>>>>>>>//
70290>>>>>>>>>>>// Command to change the transaction type.
70290>>>>>>>>>>>// Valid types are:
70290>>>>>>>>>>>//     DFBTRTT_NONE
70290>>>>>>>>>>>//     DFBTRTT_EXCLUSIVE
70290>>>>>>>>>>>//     DFBTRTT_CONCURRENT
70290>>>>>>>>>>>//
70290>>>>>>>>>>>//
70290>>>>>>>>>>>
70290>>>>>>>>>>>
70290>>>>>>>>>>>
70290>>>>>>>>>>>//
70290>>>>>>>>>>>// Command to get the current transaction type.
70290>>>>>>>>>>>//
70290>>>>>>>>>>>
70290>>>>>>>>>>>//
70290>>>>>>>>>>>// Command to set explicit_locking
70290>>>>>>>>>>>//
70290>>>>>>>>>>>
70290>>>>>>>>>>>//
70290>>>>>>>>>>>// Command to get explicit locking
70290>>>>>>>>>>>//
70290>>>>>>>>>>>
70290>>>>>>>>>>>//
70290>>>>>>>>>>>// Command to set detection for incompatible positive signs in numeric fields
70290>>>>>>>>>>>//
70290>>>>>>>>>>>
70290>>>>>>>>>>>//
70290>>>>>>>>>>>// Command to get detection for incompatible positive signs in numeric fields
70290>>>>>>>>>>>//
70290>>>>>>>>>>>
70290>>>>>>>>>>>// Purpose: An instance of this class can be used as a broker object to
70290>>>>>>>>>>>//          call several Dfbtrdrv releated methods.
70290>>>>>>>>>>>
70290>>>>>>>>>>>Class cDFBtrDrvHandler is an Array
70291>>>>>>>>>>>    
70291>>>>>>>>>>>    Procedure Construct_Object Integer iImage
70293>>>>>>>>>>>        Forward Send Construct_object iImage
70295>>>>>>>>>>>        
70295>>>>>>>>>>>        Property String  psDriverID "DFBTRDRV"
70296>>>>>>>>>>>    End_Procedure
70297>>>>>>>>>>>    
70297>>>>>>>>>>>    //  The revsion of a Dfbtrdrv Connectivity Kit
70297>>>>>>>>>>>    //
70297>>>>>>>>>>>    
70297>>>>>>>>>>>    Function CKRevision Returns String
70299>>>>>>>>>>>        String  sDriverID
70299>>>>>>>>>>>        String  sRevision
70299>>>>>>>>>>>        String  sVoid
70299>>>>>>>>>>>        Integer iRetval
70299>>>>>>>>>>>        
70299>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
70299>>>>>>>>>>>        // This error would otherwise be raised when we have an older
70299>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
70299>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
70300>>>>>>>>>>>        Get psDriverID to sDriverID
70301>>>>>>>>>>>        Move (Repeat(" ", 255)) to sRevision
70302>>>>>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
70307>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
70308>>>>>>>>>>>        If (Trim(sRevision) = "") Begin
70310>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
70310>>>>>>>>>>>            Move "0.0.0.0" to sRevision
70311>>>>>>>>>>>        End
70311>>>>>>>>>>>>
70311>>>>>>>>>>>        Function_Return sRevision
70312>>>>>>>>>>>    End_Function
70313>>>>>>>>>>>    
70313>>>>>>>>>>>    Function CkUsesUri Returns Integer
70315>>>>>>>>>>>        String  sDriverID
70315>>>>>>>>>>>        String  sVoid1
70315>>>>>>>>>>>        String  sVoid2
70315>>>>>>>>>>>        Integer iRetval
70315>>>>>>>>>>>        
70315>>>>>>>>>>>        Get psDriverID to sDriverID
70316>>>>>>>>>>>        
70316>>>>>>>>>>>        Move 0 to iRetval
70317>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
70317>>>>>>>>>>>        // This error would otherwise be raised when we have an older
70317>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKUSESURI function
70317>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
70318>>>>>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKUSESURI Callback 0 Passing sVoid1 sVoid2 0 Result iRetval
70323>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
70324>>>>>>>>>>>        
70324>>>>>>>>>>>        Function_Return iRetval
70325>>>>>>>>>>>    End_Function
70326>>>>>>>>>>>    
70326>>>>>>>>>>>    
70326>>>>>>>>>>>    
70326>>>>>>>>>>>    // Extract the Nth part of a a.b.c.d revsion string.
70326>>>>>>>>>>>    //
70326>>>>>>>>>>>    // Returns : The part version number or -1 if there is no such part number.
70326>>>>>>>>>>>    //
70326>>>>>>>>>>>    
70326>>>>>>>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
70328>>>>>>>>>>>        Integer iPartRev
70328>>>>>>>>>>>        Integer iCurrentPart
70328>>>>>>>>>>>        Integer iSeparatorPos
70328>>>>>>>>>>>        
70328>>>>>>>>>>>        If (iPartNum > 4) ;            Function_Return -1
70331>>>>>>>>>>>        
70331>>>>>>>>>>>        Move 0 to iCurrentPart
70332>>>>>>>>>>>        Repeat
70332>>>>>>>>>>>>
70332>>>>>>>>>>>            Move (Pos(".", sRevision)) to iSeparatorPos
70333>>>>>>>>>>>            If (iSeparatorPos > 0) Begin
70335>>>>>>>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) to iPartRev
70336>>>>>>>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) to sRevision
70337>>>>>>>>>>>                Increment iCurrentPart
70338>>>>>>>>>>>            End
70338>>>>>>>>>>>>
70338>>>>>>>>>>>            Else If (sRevision <> "") Begin
70341>>>>>>>>>>>                Move sRevision to iPartRev
70342>>>>>>>>>>>                Move "" to sRevision
70343>>>>>>>>>>>                Increment iCurrentPart
70344>>>>>>>>>>>            End
70344>>>>>>>>>>>>
70344>>>>>>>>>>>            Else ;                Move -1 to iPartRev
70346>>>>>>>>>>>        Until (iCurrentPart >= iPartNum or iPartRev = -1)
70348>>>>>>>>>>>        
70348>>>>>>>>>>>        Function_Return iPartRev
70349>>>>>>>>>>>    End_Function
70350>>>>>>>>>>>    
70350>>>>>>>>>>>    
70350>>>>>>>>>>>    
70350>>>>>>>>>>>    //
70350>>>>>>>>>>>    //  Returns the major revision of the CK
70350>>>>>>>>>>>    //
70350>>>>>>>>>>>    
70350>>>>>>>>>>>    Function CKMajorRevision Returns Integer
70352>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 1, CKRevision(Current_Object)))
70353>>>>>>>>>>>    End_Function
70354>>>>>>>>>>>    
70354>>>>>>>>>>>    
70354>>>>>>>>>>>    
70354>>>>>>>>>>>    //  Returns the minor revision of the CK
70354>>>>>>>>>>>    //
70354>>>>>>>>>>>    
70354>>>>>>>>>>>    Function CKMinorRevision Returns Integer
70356>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 2, CKRevision(Current_Object)))
70357>>>>>>>>>>>    End_Function
70358>>>>>>>>>>>    
70358>>>>>>>>>>>    
70358>>>>>>>>>>>    //  Returns the release revision of the CK
70358>>>>>>>>>>>    //
70358>>>>>>>>>>>    
70358>>>>>>>>>>>    Function CKReleaseRevision Returns Integer
70360>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 3, CKRevision(Current_Object)))
70361>>>>>>>>>>>    End_Function
70362>>>>>>>>>>>    
70362>>>>>>>>>>>    
70362>>>>>>>>>>>    //  Returns the major revision of the CK
70362>>>>>>>>>>>    //
70362>>>>>>>>>>>    
70362>>>>>>>>>>>    Function CKBuildRevision Returns Integer
70364>>>>>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 4, CKRevision(Current_Object)))
70365>>>>>>>>>>>    End_Function
70366>>>>>>>>>>>    
70366>>>>>>>>>>>    
70366>>>>>>>>>>>    //  Determines if the CK conforms to a passed minimal revsion.
70366>>>>>>>>>>>    //
70366>>>>>>>>>>>    
70366>>>>>>>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
70368>>>>>>>>>>>        If (iMajor < CKMajorRevision(Current_object)) ;            Function_Return (True)
70371>>>>>>>>>>>        Else If (iMajor = CKMajorRevision(Current_object)) Begin
70374>>>>>>>>>>>            If (iMinor < CKMinorRevision(Current_object)) ;                Function_Return (True)
70377>>>>>>>>>>>            Else If (iMinor = CKMinorRevision(Current_object)) Begin
70380>>>>>>>>>>>                If (iRelease < CKReleaseRevision(Current_object)) ;                    Function_Return (True)
70383>>>>>>>>>>>                Else If (iRelease = CKReleaseRevision(Current_object) and iBuild <= CKBuildRevision(Current_object)) ;                    Function_Return (True)
70387>>>>>>>>>>>            End
70387>>>>>>>>>>>>
70387>>>>>>>>>>>        End
70387>>>>>>>>>>>>
70387>>>>>>>>>>>        
70387>>>>>>>>>>>        Function_Return (False)
70388>>>>>>>>>>>    End_Function
70389>>>>>>>>>>>    
70389>>>>>>>>>>>    //   Functions to query the Pervasive.SQL version:
70389>>>>>>>>>>>    //       PSQLRequesterVersionInfo    Integer iFileNum Returns String
70389>>>>>>>>>>>    //       PSQLLocalEngineVersionInfo  Integer iFileNum Returns String
70389>>>>>>>>>>>    //       PSQLServerEngineVersionInfo Integer iFileNum Returns String
70389>>>>>>>>>>>    //
70389>>>>>>>>>>>    //   All 3 functions return the version of a Pervasive.SQL component
70389>>>>>>>>>>>    //   in the following format:
70389>>>>>>>>>>>    //       <version>.<revision>.<type>
70389>>>>>>>>>>>    //   possible values for <type>:
70389>>>>>>>>>>>    //       9 for 32-bit Windows workstation/workgroup engine or Linux
70389>>>>>>>>>>>    //         server using Workgroup authentication mode
70389>>>>>>>>>>>    //       C for client cache engine
70389>>>>>>>>>>>    //       D for DOS workstation
70389>>>>>>>>>>>    //       N for client Requester
70389>>>>>>>>>>>    //       S for NetWare server
70389>>>>>>>>>>>    //       T for 32-bit Windows server engine
70389>>>>>>>>>>>    //       U for Linux server using PAM or BTPASSWD authentication
70389>>>>>>>>>>>    //
70389>>>>>>>>>>>    //   example:
70389>>>>>>>>>>>    //       8.50.T
70389>>>>>>>>>>>    //   will be returned for a Pervasive.SQL 8.5 Server Engine running on
70389>>>>>>>>>>>    //   32-bits Windows server.
70389>>>>>>>>>>>    //
70389>>>>>>>>>>>    //   The FileNumber parameter must specify an opened table or 0.
70389>>>>>>>>>>>    //   For PSQLServerEngineVersionInfo the FileNumber can not be 0.
70389>>>>>>>>>>>    //
70389>>>>>>>>>>>    //   If the version information is not available or can not be obtained
70389>>>>>>>>>>>    //   the functions will return "0.0.0"
70389>>>>>>>>>>>    
70389>>>>>>>>>>>    //  Returns the version information of the
70389>>>>>>>>>>>    //           Pervasive.SQL Client requester.
70389>>>>>>>>>>>    
70389>>>>>>>>>>>    Function PSQLRequesterVersionInfo Integer iFileNum Returns String
70391>>>>>>>>>>>        
70391>>>>>>>>>>>        String  sDriverID
70391>>>>>>>>>>>        String  sVersion
70391>>>>>>>>>>>        String  sVoid
70391>>>>>>>>>>>        Integer iRetval
70391>>>>>>>>>>>        
70391>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
70391>>>>>>>>>>>        // This error would otherwise be raised when we have an older
70391>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
70391>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
70392>>>>>>>>>>>        Get psDriverID to sDriverID
70393>>>>>>>>>>>        Move (Repeat(" ", 255)) to sVersion
70394>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLREQUESTERVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
70399>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
70400>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
70402>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
70402>>>>>>>>>>>            Move "0.0.0" to sVersion
70403>>>>>>>>>>>        End
70403>>>>>>>>>>>>
70403>>>>>>>>>>>        Function_Return sVersion
70404>>>>>>>>>>>    End_Function
70405>>>>>>>>>>>    
70405>>>>>>>>>>>    //           Pervasive.SQL Engine
70405>>>>>>>>>>>    
70405>>>>>>>>>>>    Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
70407>>>>>>>>>>>        
70407>>>>>>>>>>>        String  sDriverID
70407>>>>>>>>>>>        String  sVersion
70407>>>>>>>>>>>        String  sVoid
70407>>>>>>>>>>>        Integer iRetval
70407>>>>>>>>>>>        
70407>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
70407>>>>>>>>>>>        // This error would otherwise be raised when we have an older
70407>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
70407>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
70408>>>>>>>>>>>        Get psDriverID to sDriverID
70409>>>>>>>>>>>        Move (Repeat(" ", 255)) to sVersion
70410>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLLOCALENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
70415>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
70416>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
70418>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
70418>>>>>>>>>>>            Move "0.0.0" to sVersion
70419>>>>>>>>>>>        End
70419>>>>>>>>>>>>
70419>>>>>>>>>>>        Function_Return sVersion
70420>>>>>>>>>>>    End_Function
70421>>>>>>>>>>>    
70421>>>>>>>>>>>    //  Returns the version information of the
70421>>>>>>>>>>>    //           Pervasive.SQL Server Engine
70421>>>>>>>>>>>    
70421>>>>>>>>>>>    Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
70423>>>>>>>>>>>        
70423>>>>>>>>>>>        String  sDriverID
70423>>>>>>>>>>>        String  sVersion
70423>>>>>>>>>>>        String  sVoid
70423>>>>>>>>>>>        Integer iRetval
70423>>>>>>>>>>>        
70423>>>>>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
70423>>>>>>>>>>>        // This error would otherwise be raised when we have an older
70423>>>>>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
70423>>>>>>>>>>>        Send Ignore_error to Error_object_Id 20491
70424>>>>>>>>>>>        Get psDriverID to sDriverID
70425>>>>>>>>>>>        Move (Repeat(" ", 255)) to sVersion
70426>>>>>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLSERVERENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
70431>>>>>>>>>>>        Send Trap_Error to Error_object_Id 20491
70432>>>>>>>>>>>        If (Trim(sVersion) = "") Begin
70434>>>>>>>>>>>            // Unable to get the revision. return all zeroes.
70434>>>>>>>>>>>            Move "0.0.0" to sVersion
70435>>>>>>>>>>>        End
70435>>>>>>>>>>>>
70435>>>>>>>>>>>        Function_Return sVersion
70436>>>>>>>>>>>    End_Function
70437>>>>>>>>>>>    
70437>>>>>>>>>>>End_Class
70438>>>>>>>>>>>
70438>>>>>>>>>>>
70438>>>>>>>>>Use cSQLConnectionIniFile.inc
Including file: cSQLConnectionIniFile.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionIniFile.inc)
70438>>>>>>>>>>>//****************************************************************************
70438>>>>>>>>>>>// $Module type: Include file
70438>>>>>>>>>>>// $Module name: cSQLConnectionIniFile.inc
70438>>>>>>>>>>>//
70438>>>>>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International.
70438>>>>>>>>>>>// Copyright (c) 2012 RDC Tools International
70438>>>>>>>>>>>// E-mail      : support@rdctools.com
70438>>>>>>>>>>>// Web-site    : http://www.rdctools.com
70438>>>>>>>>>>>//
70438>>>>>>>>>>>// Created     : 2017-01-18 @ 13:04 (Military date format - Year-Month-Day)
70438>>>>>>>>>>>//
70438>>>>>>>>>>>// Note        : Header file with constant declarations for the cSQLConnectionIniFile class.
70438>>>>>>>>>>>//
70438>>>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
70438>>>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
70438>>>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
70438>>>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
70438>>>>>>>>>>>// in the help folder for more details.
70438>>>>>>>>>>>//
70438>>>>>>>>>>>Use Winkern.pkg
70438>>>>>>>>>>>Use cIniFile.pkg
70438>>>>>>>>>>>    Use cCryptographer.pkg
Including file: cCryptographer.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCryptographer.pkg)
70438>>>>>>>>>>>>>Use VdfBase.pkg
70438>>>>>>>>>>>>>
70438>>>>>>>>>>>>>Use CryptographerConstants.pkg
Including file: CryptographerConstants.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\CryptographerConstants.pkg)
70438>>>>>>>>>>>>>>>//   Author  : Ulbe Stellema
70438>>>>>>>>>>>>>>>// Algorithm classes
70438>>>>>>>>>>>>>>>Define ALG_CLASS_ANY                    for |CI$00000000 // (0)
70438>>>>>>>>>>>>>>>Define ALG_CLASS_SIGNATURE              for |CI$00002000 // (1 << 13)
70438>>>>>>>>>>>>>>>Define ALG_CLASS_MSG_ENCRYPT            for |CI$00004000 // (2 << 13)
70438>>>>>>>>>>>>>>>Define ALG_CLASS_DATA_ENCRYPT           for |CI$00006000 // (3 << 13)
70438>>>>>>>>>>>>>>>Define ALG_CLASS_HASH                   for |CI$00008000 // (4 << 13)
70438>>>>>>>>>>>>>>>Define ALG_CLASS_KEY_EXCHANGE           for |CI$0000A000 // (5 << 13)
70438>>>>>>>>>>>>>>>Define ALG_CLASS_ALL                    for |CI$0000E000 // (7 << 13)
70438>>>>>>>>>>>>>>>
70438>>>>>>>>>>>>>>>// Algorithm types
70438>>>>>>>>>>>>>>>Define ALG_TYPE_ANY                     for |CI$00000000 // (0)
70438>>>>>>>>>>>>>>>Define ALG_TYPE_DSS                     for |CI$00000200 // (1 << 9)
70438>>>>>>>>>>>>>>>Define ALG_TYPE_RSA                     for |CI$00000400 // (2 << 9)
70438>>>>>>>>>>>>>>>Define ALG_TYPE_BLOCK                   for |CI$00000600 // (3 << 9)
70438>>>>>>>>>>>>>>>Define ALG_TYPE_STREAM                  for |CI$00000800 // (4 << 9)
70438>>>>>>>>>>>>>>>Define ALG_TYPE_DH                      for |CI$00000A00 // (5 << 9)
70438>>>>>>>>>>>>>>>Define ALG_TYPE_SECURECHANNEL           for |CI$00000C00 // (6 << 9)
70438>>>>>>>>>>>>>>>
70438>>>>>>>>>>>>>>>// Generic sub-ids
70438>>>>>>>>>>>>>>>Define ALG_SID_ANY                      for |CI$00000000 // (0)
70438>>>>>>>>>>>>>>>
70438>>>>>>>>>>>>>>>// RSA sub-ids
70438>>>>>>>>>>>>>>>Define ALG_SID_RSA_ANY                  for 0
70438>>>>>>>>>>>>>>>Define ALG_SID_RSA_PKCS                 for 1
70438>>>>>>>>>>>>>>>Define ALG_SID_RSA_MSATWORK             for 2
70438>>>>>>>>>>>>>>>Define ALG_SID_RSA_ENTRUST              for 3
70438>>>>>>>>>>>>>>>Define ALG_SID_RSA_PGP                  for 4
70438>>>>>>>>>>>>>>>
70438>>>>>>>>>>>>>>>// DSS sub-ids
70438>>>>>>>>>>>>>>>Define ALG_SID_DSS_ANY                  for 0
70438>>>>>>>>>>>>>>>Define ALG_SID_DSS_PKCS                 for 1
70438>>>>>>>>>>>>>>>Define ALG_SID_DSS_DMS                  for 2
70438>>>>>>>>>>>>>>>
70438>>>>>>>>>>>>>>>// DES sub_ids
70438>>>>>>>>>>>>>>>Define ALG_SID_DES                      for 1
70438>>>>>>>>>>>>>>>Define ALG_SID_3DES                     for 3
70438>>>>>>>>>>>>>>>Define ALG_SID_DESX                     for 4
70438>>>>>>>>>>>>>>>Define ALG_SID_IDEA                     for 5
70438>>>>>>>>>>>>>>>Define ALG_SID_CAST                     for 6
70438>>>>>>>>>>>>>>>Define ALG_SID_SAFERSK64                for 7
70438>>>>>>>>>>>>>>>Define ALG_SID_SAFERSK128               for 8
70438>>>>>>>>>>>>>>>Define ALG_SID_3DES_112                 for 9
70438>>>>>>>>>>>>>>>Define ALG_SID_CYLINK_MEK               for 12
70438>>>>>>>>>>>>>>>Define ALG_SID_RC5                      for 13
70438>>>>>>>>>>>>>>>Define ALG_SID_AES_128                  for 14
70438>>>>>>>>>>>>>>>Define ALG_SID_AES_192                  for 15
70438>>>>>>>>>>>>>>>Define ALG_SID_AES_256                  for 16
70438>>>>>>>>>>>>>>>Define ALG_SID_AES                      for 17
70438>>>>>>>>>>>>>>>
70438>>>>>>>>>>>>>>>// Fortezza sub-ids
70438>>>>>>>>>>>>>>>Define ALG_SID_SKIPJACK                 for 10
70438>>>>>>>>>>>>>>>Define ALG_SID_TEK                      for 11
70438>>>>>>>>>>>>>>>
70438>>>>>>>>>>>>>>>// RC2 sub-ids
70438>>>>>>>>>>>>>>>Define ALG_SID_RC2                      for 2
70438>>>>>>>>>>>>>>>
70438>>>>>>>>>>>>>>>// Stream cipher sub-ids
70438>>>>>>>>>>>>>>>Define ALG_SID_RC4                      for 1
70438>>>>>>>>>>>>>>>Define ALG_SID_SEAL                     for 2
70438>>>>>>>>>>>>>>>
70438>>>>>>>>>>>>>>>// Diffie-Hellman sub-ids
70438>>>>>>>>>>>>>>>Define ALG_SID_DH_SANDF                 for 1
70438>>>>>>>>>>>>>>>Define ALG_SID_DH_EPHEM                 for 2
70438>>>>>>>>>>>>>>>Define ALG_SID_AGREED_KEY_ANY           for 3
70438>>>>>>>>>>>>>>>Define ALG_SID_KEA                      for 4
70438>>>>>>>>>>>>>>>
70438>>>>>>>>>>>>>>>// Hash sub ids
70438>>>>>>>>>>>>>>>Define ALG_SID_MD2                      for 1
70438>>>>>>>>>>>>>>>Define ALG_SID_MD4                      for 2
70438>>>>>>>>>>>>>>>Define ALG_SID_MD5                      for 3
70438>>>>>>>>>>>>>>>Define ALG_SID_SHA                      for 4
70438>>>>>>>>>>>>>>>Define ALG_SID_SHA1                     for 4
70438>>>>>>>>>>>>>>>Define ALG_SID_MAC                      for 5
70438>>>>>>>>>>>>>>>Define ALG_SID_RIPEMD                   for 6
70438>>>>>>>>>>>>>>>Define ALG_SID_RIPEMD160                for 7
70438>>>>>>>>>>>>>>>Define ALG_SID_SSL3SHAMD5               for 8
70438>>>>>>>>>>>>>>>Define ALG_SID_HMAC                     for 9
70438>>>>>>>>>>>>>>>Define ALG_SID_TLS1PRF                  for 10
70438>>>>>>>>>>>>>>>Define ALG_SID_HASH_REPLACE_OWF         for 11
70438>>>>>>>>>>>>>>>Define ALG_SID_SHA_256                  for 12
70438>>>>>>>>>>>>>>>Define ALG_SID_SHA_384                  for 13
70438>>>>>>>>>>>>>>>Define ALG_SID_SHA_512                  for 14
70438>>>>>>>>>>>>>>>
70438>>>>>>>>>>>>>>>// secure channel sub ids
70438>>>>>>>>>>>>>>>Define ALG_SID_SSL3_MASTER              for 1
70438>>>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_MASTER_HASH     for 2
70438>>>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_MAC_KEY         for 3
70438>>>>>>>>>>>>>>>Define ALG_SID_PCT1_MASTER              for 4
70438>>>>>>>>>>>>>>>Define ALG_SID_SSL2_MASTER              for 5
70438>>>>>>>>>>>>>>>Define ALG_SID_TLS1_MASTER              for 6
70438>>>>>>>>>>>>>>>Define ALG_SID_SCHANNEL_ENC_KEY         for 7
70438>>>>>>>>>>>>>>>
70438>>>>>>>>>>>>>>>// algorithm identifier definitions
70438>>>>>>>>>>>>>>>Define CALG_MD2                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD2)
70438>>>>>>>>>>>>>>>Define CALG_MD4                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD4)
70438>>>>>>>>>>>>>>>Define CALG_MD5                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MD5)
70438>>>>>>>>>>>>>>>Define CALG_SHA                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA)
70438>>>>>>>>>>>>>>>Define CALG_SHA1                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA1)
70438>>>>>>>>>>>>>>>Define CALG_MAC                         for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_MAC)
70438>>>>>>>>>>>>>>>Define CALG_RSA_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
70438>>>>>>>>>>>>>>>Define CALG_DSS_SIGN                    for (ALG_CLASS_SIGNATURE ior ALG_TYPE_DSS ior ALG_SID_DSS_ANY)
70438>>>>>>>>>>>>>>>Define CALG_NO_SIGN                     for (ALG_CLASS_SIGNATURE ior ALG_TYPE_ANY ior ALG_SID_ANY)
70438>>>>>>>>>>>>>>>Define CALG_RSA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_RSA ior ALG_SID_RSA_ANY)
70438>>>>>>>>>>>>>>>Define CALG_DES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DES)
70438>>>>>>>>>>>>>>>Define CALG_3DES_112                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES_112)
70438>>>>>>>>>>>>>>>Define CALG_3DES                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_3DES)
70438>>>>>>>>>>>>>>>Define CALG_DESX                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_DESX)
70438>>>>>>>>>>>>>>>Define CALG_RC2                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC2)
70438>>>>>>>>>>>>>>>Define CALG_RC4                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_RC4)
70438>>>>>>>>>>>>>>>Define CALG_SEAL                        for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_STREAM ior ALG_SID_SEAL)
70438>>>>>>>>>>>>>>>Define CALG_DH_SF                       for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_SANDF)
70438>>>>>>>>>>>>>>>Define CALG_DH_EPHEM                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_DH_EPHEM)
70438>>>>>>>>>>>>>>>Define CALG_AGREEDKEY_ANY               for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_AGREED_KEY_ANY)
70438>>>>>>>>>>>>>>>Define CALG_KEA_KEYX                    for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_DH ior ALG_SID_KEA)
70438>>>>>>>>>>>>>>>Define CALG_HUGHES_MD5                  for (ALG_CLASS_KEY_EXCHANGE ior ALG_TYPE_ANY ior ALG_SID_MD5)
70438>>>>>>>>>>>>>>>Define CALG_SKIPJACK                    for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_SKIPJACK)
70438>>>>>>>>>>>>>>>Define CALG_TEK                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_TEK)
70438>>>>>>>>>>>>>>>Define CALG_CYLINK_MEK                  for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_CYLINK_MEK)
70438>>>>>>>>>>>>>>>Define CALG_SSL3_SHAMD5                 for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SSL3SHAMD5)
70438>>>>>>>>>>>>>>>Define CALG_SSL3_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL3_MASTER)
70438>>>>>>>>>>>>>>>Define CALG_SCHANNEL_MASTER_HASH        for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MASTER_HASH)
70438>>>>>>>>>>>>>>>Define CALG_SCHANNEL_MAC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_MAC_KEY)
70438>>>>>>>>>>>>>>>Define CALG_SCHANNEL_ENC_KEY            for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SCHANNEL_ENC_KEY)
70438>>>>>>>>>>>>>>>Define CALG_PCT1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_PCT1_MASTER)
70438>>>>>>>>>>>>>>>Define CALG_SSL2_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_SSL2_MASTER)
70438>>>>>>>>>>>>>>>Define CALG_TLS1_MASTER                 for (ALG_CLASS_MSG_ENCRYPT ior ALG_TYPE_SECURECHANNEL ior ALG_SID_TLS1_MASTER)
70438>>>>>>>>>>>>>>>Define CALG_RC5                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_RC5)
70438>>>>>>>>>>>>>>>Define CALG_HMAC                        for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HMAC)
70438>>>>>>>>>>>>>>>Define CALG_TLS1PRF                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_TLS1PRF)
70438>>>>>>>>>>>>>>>Define CALG_HASH_REPLACE_OWF            for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_HASH_REPLACE_OWF)
70438>>>>>>>>>>>>>>>Define CALG_AES_128                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_128)
70438>>>>>>>>>>>>>>>Define CALG_AES_192                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_192)
70438>>>>>>>>>>>>>>>Define CALG_AES_256                     for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES_256)
70438>>>>>>>>>>>>>>>Define CALG_AES                         for (ALG_CLASS_DATA_ENCRYPT ior ALG_TYPE_BLOCK ior ALG_SID_AES)
70438>>>>>>>>>>>>>>>Define CALG_SHA_256                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_256)
70438>>>>>>>>>>>>>>>Define CALG_SHA_384                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_384)
70438>>>>>>>>>>>>>>>Define CALG_SHA_512                     for (ALG_CLASS_HASH ior ALG_TYPE_ANY ior ALG_SID_SHA_512)
70438>>>>>>>>>>>>>>>
70438>>>>>>>>>>>>>>>// Providers
70438>>>>>>>>>>>>>>>Define MS_DEF_PROV                      for "Microsoft Base Cryptographic Provider v1.0"
70438>>>>>>>>>>>>>>>Define MS_ENHANCED_PROV                 for "Microsoft Enhanced Cryptographic Provider v1.0"
70438>>>>>>>>>>>>>>>Define MS_STRONG_PROV                   for "Microsoft Strong Cryptographic Provider"
70438>>>>>>>>>>>>>>>Define MS_DEF_RSA_SIG_PROV              for "Microsoft RSA Signature Cryptographic Provider"
70438>>>>>>>>>>>>>>>Define MS_DEF_RSA_SCHANNEL_PROV         for "Microsoft RSA SChannel Cryptographic Provider"
70438>>>>>>>>>>>>>>>Define MS_DEF_DSS_PROV                  for "Microsoft Base DSS Cryptographic Provider"
70438>>>>>>>>>>>>>>>Define MS_DEF_DSS_DH_PROV               for "Microsoft Base DSS and Diffie-Hellman Cryptographic Provider"
70438>>>>>>>>>>>>>>>Define MS_ENH_DSS_DH_PROV               for "Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider"
70438>>>>>>>>>>>>>>>Define MS_DEF_DH_SCHANNEL_PROV          for "Microsoft DH SChannel Cryptographic Provider"
70438>>>>>>>>>>>>>>>Define MS_SCARD_PROV                    for "Microsoft Base Smart Card Crypto Provider"
70438>>>>>>>>>>>>>>>Define MS_ENH_RSA_AES_PROV              for "Microsoft Enhanced RSA and AES Cryptographic Provider"
70438>>>>>>>>>>>>>>>
70438>>>>>>>>>>>>>>>// dwFlags definitions for CryptAcquireContext
70438>>>>>>>>>>>>>>>Define CRYPT_VERIFYCONTEXT              for |CI$F0000000
70438>>>>>>>>>>>>>>>Define CRYPT_NEWKEYSET                  for |CI$00000008
70438>>>>>>>>>>>>>>>Define CRYPT_DELETEKEYSET               for |CI$00000010
70438>>>>>>>>>>>>>>>Define CRYPT_MACHINE_KEYSET             for |CI$00000020
70438>>>>>>>>>>>>>>>Define CRYPT_SILENT                     for |CI$00000040
70438>>>>>>>>>>>>>>>
70438>>>>>>>>>>>>>>>// dwFlag definitions for CryptGenKey
70438>>>>>>>>>>>>>>>Define CRYPT_EXPORTABLE                 for |CI$00000001
70438>>>>>>>>>>>>>>>Define CRYPT_USER_PROTECTED             for |CI$00000002
70438>>>>>>>>>>>>>>>Define CRYPT_CREATE_SALT                for |CI$00000004
70438>>>>>>>>>>>>>>>Define CRYPT_UPDATE_KEY                 for |CI$00000008
70438>>>>>>>>>>>>>>>Define CRYPT_NO_SALT                    for |CI$00000010
70438>>>>>>>>>>>>>>>Define CRYPT_PREGEN                     for |CI$00000040
70438>>>>>>>>>>>>>>>Define CRYPT_RECIPIENT                  for |CI$00000010
70438>>>>>>>>>>>>>>>Define CRYPT_INITIATOR                  for |CI$00000040
70438>>>>>>>>>>>>>>>Define CRYPT_ONLINE                     for |CI$00000080
70438>>>>>>>>>>>>>>>Define CRYPT_SF                         for |CI$00000100
70438>>>>>>>>>>>>>>>Define CRYPT_CREATE_IV                  for |CI$00000200
70438>>>>>>>>>>>>>>>Define CRYPT_KEK                        for |CI$00000400
70438>>>>>>>>>>>>>>>Define CRYPT_DATA_KEY                   for |CI$00000800
70438>>>>>>>>>>>>>>>Define CRYPT_VOLATILE                   for |CI$00001000
70438>>>>>>>>>>>>>>>Define CRYPT_SGCKEY                     for |CI$00002000
70438>>>>>>>>>>>>>>>Define CRYPT_ARCHIVABLE                 for |CI$00004000
70438>>>>>>>>>>>>>>>
70438>>>>>>>>>>>>>>>// Provider types
70438>>>>>>>>>>>>>>>Define PROV_RSA_FULL                    for 1
70438>>>>>>>>>>>>>>>Define PROV_RSA_SIG                     for 2
70438>>>>>>>>>>>>>>>Define PROV_DSS                         for 3
70438>>>>>>>>>>>>>>>Define PROV_FORTEZZA                    for 4
70438>>>>>>>>>>>>>>>Define PROV_MS_EXCHANGE                 for 5
70438>>>>>>>>>>>>>>>Define PROV_SSL                         for 6
70438>>>>>>>>>>>>>>>Define PROV_RSA_SCHANNEL                for 12
70438>>>>>>>>>>>>>>>Define PROV_DSS_DH                      for 13
70438>>>>>>>>>>>>>>>Define PROV_EC_ECDSA_SIG                for 14
70438>>>>>>>>>>>>>>>Define PROV_EC_ECNRA_SIG                for 15
70438>>>>>>>>>>>>>>>Define PROV_EC_ECDSA_FULL               for 16
70438>>>>>>>>>>>>>>>Define PROV_EC_ECNRA_FULL               for 17
70438>>>>>>>>>>>>>>>Define PROV_DH_SCHANNEL                 for 18
70438>>>>>>>>>>>>>>>Define PROV_SPYRUS_LYNKS                for 20
70438>>>>>>>>>>>>>>>Define PROV_RNG                         for 21
70438>>>>>>>>>>>>>>>Define PROV_INTEL_SEC                   for 22
70438>>>>>>>>>>>>>>>Define PROV_REPLACE_OWF                 for 23
70438>>>>>>>>>>>>>>>Define PROV_RSA_AES                     for 24
70438>>>>>>>>>>>>>>>
70438>>>>>>>>>>>>>>>// KP_MODE
70438>>>>>>>>>>>>>>>// KP_MODE
70438>>>>>>>>>>>>>>>Define CRYPT_MODE_CBC                   for 1       // Cipher block chaining
70438>>>>>>>>>>>>>>>Define CRYPT_MODE_ECB                   for 2       // Electronic code book
70438>>>>>>>>>>>>>>>Define CRYPT_MODE_OFB                   for 3       // Output feedback mode
70438>>>>>>>>>>>>>>>Define CRYPT_MODE_CFB                   for 4       // Cipher feedback mode
70438>>>>>>>>>>>>>>>Define CRYPT_MODE_CTS                   for 5       // Ciphertext stealing mode
70438>>>>>>>>>>>>>>>Define CRYPT_MODE_CBCI                  for 6       // ANSI CBC Interleaved
70438>>>>>>>>>>>>>>>Define CRYPT_MODE_CFBP                  for 7       // ANSI CFB Pipelined
70438>>>>>>>>>>>>>>>Define CRYPT_MODE_OFBP                  for 8       // ANSI OFB Pipelined
70438>>>>>>>>>>>>>>>Define CRYPT_MODE_CBCOFM                for 9       // ANSI CBC + OF Masking
70438>>>>>>>>>>>>>>>Define CRYPT_MODE_CBCOFMI               for 10      // ANSI CBC + OFM Interleaved
70438>>>>>>>>>>>>>>>
70438>>>>>>>>>>>>>>>// dwParam definitions for CryptGetKeyParam
70438>>>>>>>>>>>>>>>Define KP_IV                            for 1       // Initialization vector
70438>>>>>>>>>>>>>>>Define KP_SALT                          for 2       // Salt value
70438>>>>>>>>>>>>>>>Define KP_PADDING                       for 3       // Padding values
70438>>>>>>>>>>>>>>>Define KP_MODE                          for 4       // Mode of the cipher
70438>>>>>>>>>>>>>>>Define KP_MODE_BITS                     for 5       // Number of bits to feedback
70438>>>>>>>>>>>>>>>Define KP_PERMISSIONS                   for 6       // Key permissions DWORD
70438>>>>>>>>>>>>>>>Define KP_ALGID                         for 7       // Key algorithm
70438>>>>>>>>>>>>>>>Define KP_BLOCKLEN                      for 8       // Block size of the cipher
70438>>>>>>>>>>>>>>>Define KP_KEYLEN                        for 9       // Length of key in bits
70438>>>>>>>>>>>>>>>Define KP_SALT_EX                       for 10      // Length of salt in bytes
70438>>>>>>>>>>>>>>>Define KP_P                             for 11      // DSS/Diffie-Hellman P value
70438>>>>>>>>>>>>>>>Define KP_G                             for 12      // DSS/Diffie-Hellman G value
70438>>>>>>>>>>>>>>>Define KP_Q                             for 13      // DSS Q value
70438>>>>>>>>>>>>>>>Define KP_X                             for 14      // Diffie-Hellman X value
70438>>>>>>>>>>>>>>>Define KP_Y                             for 15      // Y value
70438>>>>>>>>>>>>>>>Define KP_RA                            for 16      // Fortezza RA value
70438>>>>>>>>>>>>>>>Define KP_RB                            for 17      // Fortezza RB value
70438>>>>>>>>>>>>>>>Define KP_INFO                          for 18      // for putting information into an RSA envelope
70438>>>>>>>>>>>>>>>Define KP_EFFECTIVE_KEYLEN              for 19      // setting and getting RC2 effective key length
70438>>>>>>>>>>>>>>>Define KP_SCHANNEL_ALG                  for 20      // for setting the Secure Channel algorithms
70438>>>>>>>>>>>>>>>Define KP_CLIENT_RANDOM                 for 21      // for setting the Secure Channel client random data
70438>>>>>>>>>>>>>>>Define KP_SERVER_RANDOM                 for 22      // for setting the Secure Channel server random data
70438>>>>>>>>>>>>>>>Define KP_RP                            for 23
70438>>>>>>>>>>>>>>>Define KP_PRECOMP_MD5                   for 24
70438>>>>>>>>>>>>>>>Define KP_PRECOMP_SHA                   for 25
70438>>>>>>>>>>>>>>>Define KP_CERTIFICATE                   for 26      // for setting Secure Channel certificate data (PCT1)
70438>>>>>>>>>>>>>>>Define KP_CLEAR_KEY                     for 27      // for setting Secure Channel clear key data (PCT1)
70438>>>>>>>>>>>>>>>Define KP_PUB_EX_LEN                    for 28
70438>>>>>>>>>>>>>>>Define KP_PUB_EX_VAL                    for 29
70438>>>>>>>>>>>>>>>Define KP_KEYVAL                        for 30
70438>>>>>>>>>>>>>>>Define KP_ADMIN_PIN                     for 31
70438>>>>>>>>>>>>>>>Define KP_KEYEXCHANGE_PIN               for 32
70438>>>>>>>>>>>>>>>Define KP_SIGNATURE_PIN                 for 33
70438>>>>>>>>>>>>>>>Define KP_PREHASH                       for 34
70438>>>>>>>>>>>>>>>Define KP_ROUNDS                        for 35
70438>>>>>>>>>>>>>>>Define KP_OAEP_PARAMS                   for 36      // for setting OAEP params on RSA keys
70438>>>>>>>>>>>>>>>Define KP_CMS_KEY_INFO                  for 37
70438>>>>>>>>>>>>>>>Define KP_CMS_DH_KEY_INFO               for 38
70438>>>>>>>>>>>>>>>Define KP_PUB_PARAMS                    for 39      // for setting public parameters
70438>>>>>>>>>>>>>>>Define KP_VERIFY_PARAMS                 for 40      // for verifying DSA and DH parameters
70438>>>>>>>>>>>>>>>Define KP_HIGHEST_VERSION               for 41      // for TLS protocol version setting
70438>>>>>>>>>>>>>>>Define KP_GET_USE_COUNT                 for 42      // for use with PP_CRYPT_COUNT_KEY_USE contexts
70438>>>>>>>>>>>>>>>
70438>>>>>>>>>>>>>>>// dwParam definitions for CryptGetHashParam
70438>>>>>>>>>>>>>>>Define HP_ALGID                         for |CI$0001  // Hash algorithm
70438>>>>>>>>>>>>>>>Define HP_HASHVAL                       for |CI$0002  // Hash value
70438>>>>>>>>>>>>>>>Define HP_HASHSIZE                      for |CI$0004  // Hash value size
70438>>>>>>>>>>>>>>>Define HP_HMAC_INFO                     for |CI$0005  // information for creating an HMA
70438>>>>>>>>>>>>>>>
70438>>>>>>>>>>>>>>>// key BLOB types
70438>>>>>>>>>>>>>>>Define KEYSTATEBLOB                     for |CI$0C
70438>>>>>>>>>>>>>>>Define OPAQUEKEYBLOB                    for |CI$09
70438>>>>>>>>>>>>>>>Define PLAINTEXTKEYBLOB                 for |CI$08
70438>>>>>>>>>>>>>>>Define PRIVATEKEYBLOB                   for |CI$07
70438>>>>>>>>>>>>>>>Define PUBLICKEYBLOB                    for |CI$06
70438>>>>>>>>>>>>>>>Define PUBLICKEYBLOBEX                  for |CI$0A
70438>>>>>>>>>>>>>>>Define SIMPLEBLOB                       for |CI$01
70438>>>>>>>>>>>>>>>Define SYMMETRICWRAPKEYBLOB             for |CI$0B
70438>>>>>>>>>>>>>>>
70438>>>>>>>>>>>>>>>Define CUR_BLOB_VERSION                 for 2
70438>>>>>>>>>>>>>>>
70438>>>>>>>>>>>>>>>//  Structure cryptimportkey
70438>>>>>>>>>>>>>>>Struct PUBLICKEYSTRUC
70438>>>>>>>>>>>>>>>    UChar    bType
70438>>>>>>>>>>>>>>>    UChar    bVersion
70438>>>>>>>>>>>>>>>    UShort   reserved
70438>>>>>>>>>>>>>>>    UInteger aiKeyAlg
70438>>>>>>>>>>>>>>>End_Struct
70438>>>>>>>>>>>>>>>
70438>>>>>>>>>>>>>>>Struct tPLAINTEXTKEYBLOB
70438>>>>>>>>>>>>>>>    PUBLICKEYSTRUC hdr
70438>>>>>>>>>>>>>>>    PUBLICKEYSTRUC hdr
70438>>>>>>>>>>>>>>>    UInteger       dwKeySize
70438>>>>>>>>>>>>>>>//    UChar[]        rgbKeyData
70438>>>>>>>>>>>>>>>End_Struct
70438>>>>>>>>>>>>>>>
70438>>>>>>>>>>>>>>>
70438>>>>>>>>>>>>>>>
70438>>>>>>>>>>>>>>>//  Structure for specifying the inner and outer strings when calculating HMAC hash (use with CryptSetHashParam)
70438>>>>>>>>>>>>>>>Struct HMAC_INFO
70438>>>>>>>>>>>>>>>    UInteger HashAlgid
70438>>>>>>>>>>>>>>>    Pointer pbInnerString
70438>>>>>>>>>>>>>>>    DWord cbInnerString
70438>>>>>>>>>>>>>>>    Pointer pbOuterString
70438>>>>>>>>>>>>>>>    DWord cbOuterString
70438>>>>>>>>>>>>>>>End_Struct
70438>>>>>>>>>>>>>>>
70438>>>>>>>>>>>>>>>
70438>>>>>>>>>>>>>>>External_Function CryptAcquireContext "CryptAcquireContextA" advapi32.dll ;    Pointer phProv ;    Pointer szContainer ;    Pointer szProvider ;    Integer dwProvType ;    Integer dwFlags ;    Returns Boolean
70439>>>>>>>>>>>>>>>
70439>>>>>>>>>>>>>>>External_Function CryptReleaseContext "CryptReleaseContext" advapi32.dll ;    Handle hProv ;    Integer dwFlags ;    Returns Boolean
70440>>>>>>>>>>>>>>>
70440>>>>>>>>>>>>>>>External_Function CryptCreateHash "CryptCreateHash" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hKey ;    Integer dwFlags ;    Pointer phHash ;    Returns Boolean
70441>>>>>>>>>>>>>>>
70441>>>>>>>>>>>>>>>External_Function CryptDestroyHash "CryptDestroyHash" advapi32.dll ;    Handle hHash ;    Returns Boolean
70442>>>>>>>>>>>>>>>
70442>>>>>>>>>>>>>>>External_Function CryptHashData "CryptHashData" advapi32.dll ;    Handle hHash ;    Pointer pbData ;    Integer dwDataLen ;    Integer dwFlags ;    Returns Boolean
70443>>>>>>>>>>>>>>>
70443>>>>>>>>>>>>>>>External_Function CryptDeriveKey "CryptDeriveKey" advapi32.dll ;    Handle hProv ;    Integer Algid ;    Handle hBaseData ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
70444>>>>>>>>>>>>>>>
70444>>>>>>>>>>>>>>>External_Function CryptGetHashParam "CryptGetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    DWord dwFlags ;    Returns Integer
70445>>>>>>>>>>>>>>>
70445>>>>>>>>>>>>>>>External_Function CryptDestroyKey "CryptDestroyKey" advapi32.dll ;    Handle hKey ;    Returns Boolean
70446>>>>>>>>>>>>>>>
70446>>>>>>>>>>>>>>>External_Function CryptImportKey "CryptImportKey" advapi32.dll ;    Handle hProv ;    Pointer pbData ;    Integer dwDataLen ;    Handle hPubKey ;    Integer dwFlags ;    Pointer phKey ;    Returns Boolean
70447>>>>>>>>>>>>>>>
70447>>>>>>>>>>>>>>>External_Function CryptGetKeyParam "CryptGetKeyParam" advapi32.dll ;    Handle hKey ;    Integer dwParam ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwFlags ;    Returns Boolean
70448>>>>>>>>>>>>>>>    
70448>>>>>>>>>>>>>>>External_Function CryptSetKeyParam "CryptSetKeyParam" advapi32.dll ;    Handle   hKey ;    UInteger dwParam ;    Pointer  pbdata ;    UInteger dwFlags ;    Returns  Boolean
70449>>>>>>>>>>>>>>>
70449>>>>>>>>>>>>>>>External_Function CryptEncrypt "CryptEncrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Integer dwBufLen ;    Returns Boolean
70450>>>>>>>>>>>>>>>
70450>>>>>>>>>>>>>>>External_Function CryptDecrypt "CryptDecrypt" advapi32.dll ;    Handle hKey ;    Handle hHash ;    Boolean bFinal ;    Integer dwFlags ;    Pointer pbData ;    Pointer pdwDataLen ;    Returns Boolean
70451>>>>>>>>>>>>>>>
70451>>>>>>>>>>>>>>>External_Function CryptGenRandom "CryptGenRandom" advapi32.dll ;    Handle hProv ;    DWord dwLen ;    Pointer pbBuffer ;    Returns Boolean
70452>>>>>>>>>>>>>>>    
70452>>>>>>>>>>>>>>>External_Function CryptSetHashParam "CryptSetHashParam" advapi32.dll ;    Handle hHash ;    DWord dwParam ;    Pointer pbData ;    Integer dwFlags ;    Returns Boolean
70453>>>>>>>>>>>>>>>    
70453>>>>>>>>>>>>>
70453>>>>>>>>>>>>>Class cCryptographer is a cObject
70454>>>>>>>>>>>>>    
70454>>>>>>>>>>>>>    Procedure Construct_Object
70456>>>>>>>>>>>>>        Forward Send Construct_Object
70458>>>>>>>>>>>>>        
70458>>>>>>>>>>>>>        Property String     psProvider  MS_ENHANCED_PROV
70459>>>>>>>>>>>>>        Property Integer    piProvider  PROV_RSA_FULL
70460>>>>>>>>>>>>>        Property Integer    piCipher    CALG_RC4
70461>>>>>>>>>>>>>        Property Integer    piHash      CALG_MD5
70462>>>>>>>>>>>>>        
70462>>>>>>>>>>>>>        // Private properties
70462>>>>>>>>>>>>>        Property Handle     Private_phProv
70463>>>>>>>>>>>>>    End_Procedure
70464>>>>>>>>>>>>>    
70464>>>>>>>>>>>>>    
70464>>>>>>>>>>>>>    // Acquire key container handle
70464>>>>>>>>>>>>>    Function AcquireContext Returns Handle
70466>>>>>>>>>>>>>        Integer iProvider
70466>>>>>>>>>>>>>        String sProvider
70466>>>>>>>>>>>>>        Handle hProv
70466>>>>>>>>>>>>>        Boolean bOk
70466>>>>>>>>>>>>>        Address addrProv
70466>>>>>>>>>>>>>        
70466>>>>>>>>>>>>>        Move 0 to hProv
70467>>>>>>>>>>>>>        Get piProvider to iProvider
70468>>>>>>>>>>>>>        Get psProvider to sProvider
70469>>>>>>>>>>>>>        
70469>>>>>>>>>>>>>        //  Determine address to be passed as provider
70469>>>>>>>>>>>>>        If (Trim(sProvider) <> "") Begin
70471>>>>>>>>>>>>>            Move (AddressOf(sProvider)) to addrProv
70472>>>>>>>>>>>>>        End
70472>>>>>>>>>>>>>>
70472>>>>>>>>>>>>>        Else Begin
70473>>>>>>>>>>>>>            Move 0 to addrProv
70474>>>>>>>>>>>>>        End
70474>>>>>>>>>>>>>>
70474>>>>>>>>>>>>>        
70474>>>>>>>>>>>>>        //  Acquire Crypto Context
70474>>>>>>>>>>>>>        Move (CryptAcquireContext(AddressOf(hProv),0,addrProv,iProvider,CRYPT_VERIFYCONTEXT)) to bOk
70475>>>>>>>>>>>>>        If (not(bOk) or hProv = 0) Begin
70477>>>>>>>>>>>>>            Move (CryptAcquireContext(AddressOf(hProv),0,addrProv,iProvider,CRYPT_NEWKEYSET ior CRYPT_VERIFYCONTEXT)) to bOk
70478>>>>>>>>>>>>>        End
70478>>>>>>>>>>>>>>
70478>>>>>>>>>>>>>        
70478>>>>>>>>>>>>>        If (not(bOk) or hProv = 0) Begin
70480>>>>>>>>>>>>>            // Fallback to original
70480>>>>>>>>>>>>>            Move (CryptAcquireContext(AddressOf(hProv),0,addrProv,iProvider,0)) to bOk
70481>>>>>>>>>>>>>            
70481>>>>>>>>>>>>>            If (not(bOk) or hProv = 0) Begin
70483>>>>>>>>>>>>>                Move (CryptAcquireContext(AddressOf(hProv),0,addrProv,iProvider,CRYPT_NEWKEYSET)) to bOk
70484>>>>>>>>>>>>>            End
70484>>>>>>>>>>>>>>
70484>>>>>>>>>>>>>        End
70484>>>>>>>>>>>>>>
70484>>>>>>>>>>>>>        Set Private_phProv to hProv
70485>>>>>>>>>>>>>        
70485>>>>>>>>>>>>>        Function_Return hProv
70486>>>>>>>>>>>>>    End_Function
70487>>>>>>>>>>>>>    
70487>>>>>>>>>>>>>    // Releases key container handle
70487>>>>>>>>>>>>>    Function ReleaseContext Handle hProv Returns Boolean
70489>>>>>>>>>>>>>        Function_Return (CryptReleaseContext(hProv,0))
70490>>>>>>>>>>>>>    End_Function
70491>>>>>>>>>>>>>    
70491>>>>>>>>>>>>>    // Creates hash object
70491>>>>>>>>>>>>>    Function CreateHash Handle hProv Returns Handle
70493>>>>>>>>>>>>>        Integer iAlgorithm
70493>>>>>>>>>>>>>        Handle hHash
70493>>>>>>>>>>>>>        Boolean bOk
70493>>>>>>>>>>>>>        
70493>>>>>>>>>>>>>        Move 0 to hHash
70494>>>>>>>>>>>>>        Get piHash to iAlgorithm
70495>>>>>>>>>>>>>        Move (CryptCreateHash(hProv,iAlgorithm,0,0,AddressOf(hHash))) to bOk
70496>>>>>>>>>>>>>        
70496>>>>>>>>>>>>>        Function_Return hHash
70497>>>>>>>>>>>>>    End_Function
70498>>>>>>>>>>>>>    
70498>>>>>>>>>>>>>    // Destroys the hash object
70498>>>>>>>>>>>>>    Function DestroyHash Handle hHash Returns Boolean
70500>>>>>>>>>>>>>        Function_Return (CryptDestroyHash(hHash))
70501>>>>>>>>>>>>>    End_Function
70502>>>>>>>>>>>>>    
70502>>>>>>>>>>>>>    // Adds data to hash object
70502>>>>>>>>>>>>>    Function HashData Handle hHash String sData Returns Boolean
70504>>>>>>>>>>>>>        Function_Return (CryptHashData(hHash,AddressOf(sData),Length(sData),0))
70505>>>>>>>>>>>>>    End_Function
70506>>>>>>>>>>>>>    
70506>>>>>>>>>>>>>    // Generates session key
70506>>>>>>>>>>>>>    Function DeriveKey Handle hProv Handle hHash Returns Handle
70508>>>>>>>>>>>>>        Integer iAlgorithm
70508>>>>>>>>>>>>>        Handle hKey
70508>>>>>>>>>>>>>        Boolean bOk
70508>>>>>>>>>>>>>        
70508>>>>>>>>>>>>>        Move 0 to hKey
70509>>>>>>>>>>>>>        Get piCipher to iAlgorithm
70510>>>>>>>>>>>>>        Move (CryptDeriveKey(hProv,iAlgorithm,hHash,CRYPT_EXPORTABLE,AddressOf(hKey))) to bOk
70511>>>>>>>>>>>>>        
70511>>>>>>>>>>>>>        Function_Return hKey
70512>>>>>>>>>>>>>    End_Function
70513>>>>>>>>>>>>>    
70513>>>>>>>>>>>>>    // Imports a plain text key
70513>>>>>>>>>>>>>    Function ImportPlainTextKey Handle hProv UChar[] ucaKey Returns Handle
70515>>>>>>>>>>>>>        tPLAINTEXTKEYBLOB blobhead
70515>>>>>>>>>>>>>        tPLAINTEXTKEYBLOB blobhead
70515>>>>>>>>>>>>>        Boolean   bSuccess
70515>>>>>>>>>>>>>        Handle    hKey
70515>>>>>>>>>>>>>        Integer   iHeadSize iKeySize
70515>>>>>>>>>>>>>        UChar[]   ucaKeyblob
70516>>>>>>>>>>>>>        Integer iVoid
70516>>>>>>>>>>>>>        
70516>>>>>>>>>>>>>        Move (SizeOfType(tPLAINTEXTKEYBLOB)) to iHeadSize
70517>>>>>>>>>>>>>        Move (SizeOfArray(ucaKey)) to iKeySize
70518>>>>>>>>>>>>>        
70518>>>>>>>>>>>>>        Move PLAINTEXTKEYBLOB to blobhead.hdr.bType
70519>>>>>>>>>>>>>        Move CUR_BLOB_VERSION   to blobhead.hdr.bVersion
70520>>>>>>>>>>>>>        Get piCipher            to blobhead.hdr.aiKeyAlg
70521>>>>>>>>>>>>>        Move iKeySize           to blobhead.dwKeySize
70522>>>>>>>>>>>>>        
70522>>>>>>>>>>>>>        Move (ResizeArray(ucaKeyblob, iHeadSize)) to ucaKeyblob
70523>>>>>>>>>>>>>        Move (CopyMemory(AddressOf(ucaKeyblob), AddressOf(blobhead), iHeadSize)) to iVoid
70524>>>>>>>>>>>>>        Move (AppendArray(ucaKeyblob, ucaKey)) to ucaKeyblob
70525>>>>>>>>>>>>>        
70525>>>>>>>>>>>>>        Move 0 to hKey
70526>>>>>>>>>>>>>        Move (CryptImportKey(hProv, AddressOf(ucaKeyblob), SizeOfArray(ucaKeyblob), 0, 0, AddressOf(hKey))) to bSuccess
70527>>>>>>>>>>>>>        If (not(bSuccess)) Begin
70529>>>>>>>>>>>>>            Move (ShowLastError()) to iVoid
70530>>>>>>>>>>>>>        End
70530>>>>>>>>>>>>>>
70530>>>>>>>>>>>>>        
70530>>>>>>>>>>>>>        Function_Return hKey
70531>>>>>>>>>>>>>    End_Function
70532>>>>>>>>>>>>>    
70532>>>>>>>>>>>>>    // Destroys the key
70532>>>>>>>>>>>>>    Function DestroyKey Handle hKey Returns Boolean
70534>>>>>>>>>>>>>        Function_Return (CryptDestroyKey(hKey))
70535>>>>>>>>>>>>>    End_Function
70536>>>>>>>>>>>>>    
70536>>>>>>>>>>>>>    // Retrieves key data
70536>>>>>>>>>>>>>    Function KeyParameter Handle hKey Integer iQuery Returns Integer
70538>>>>>>>>>>>>>        Integer iBuffer iLen
70538>>>>>>>>>>>>>        Boolean bOk
70538>>>>>>>>>>>>>        
70538>>>>>>>>>>>>>        Move (SizeOfType(Integer)) to iLen
70539>>>>>>>>>>>>>        Move (CryptGetKeyParam(hKey,iQuery,AddressOf(iBuffer),AddressOf(iLen),0)) to bOk
70540>>>>>>>>>>>>>        Function_Return iBuffer
70541>>>>>>>>>>>>>    End_Function
70542>>>>>>>>>>>>>    
70542>>>>>>>>>>>>>    // Retrieves a hash value
70542>>>>>>>>>>>>>    Function HashValue Handle lhHash Returns String
70544>>>>>>>>>>>>>        String  lsHash
70544>>>>>>>>>>>>>        Integer liResult
70544>>>>>>>>>>>>>        DWord   dwDataLen
70544>>>>>>>>>>>>>        
70544>>>>>>>>>>>>>        Move 0 to dwDataLen
70545>>>>>>>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,0,AddressOf(dwDataLen),0)) to liResult
70546>>>>>>>>>>>>>        If (liResult = 0) ;            Function_Return ""
70549>>>>>>>>>>>>>        
70549>>>>>>>>>>>>>        Move (Repeat(Character(0),dwDataLen)) to lsHash
70550>>>>>>>>>>>>>        Move (CryptGetHashParam(lhHash,HP_HASHVAL,AddressOf(lsHash),AddressOf(dwDataLen),0)) to liResult
70551>>>>>>>>>>>>>        If (liResult = 0) ;            Function_Return ""
70554>>>>>>>>>>>>>        
70554>>>>>>>>>>>>>        Function_Return lsHash
70555>>>>>>>>>>>>>    End_Function
70556>>>>>>>>>>>>>
70556>>>>>>>>>>>>>    // Encrypts data
70556>>>>>>>>>>>>>    Function Encrypt String sPassword String sData Returns String
70558>>>>>>>>>>>>>        Handle hProv hHash hKey
70558>>>>>>>>>>>>>        Integer iAlgorithm iDataLen iCipherLen iErr
70558>>>>>>>>>>>>>        Boolean bOk
70558>>>>>>>>>>>>>        
70558>>>>>>>>>>>>>        Get AcquireContext to hProv
70559>>>>>>>>>>>>>        If (hProv) Begin
70561>>>>>>>>>>>>>            Get CreateHash hProv to hHash
70562>>>>>>>>>>>>>            If (hHash) Begin
70564>>>>>>>>>>>>>                Get HashData hHash sPassword to bOk
70565>>>>>>>>>>>>>                If (bOk) Begin
70567>>>>>>>>>>>>>                    Get piCipher to iAlgorithm
70568>>>>>>>>>>>>>                    Get DeriveKey hProv hHash to hKey
70569>>>>>>>>>>>>>                End
70569>>>>>>>>>>>>>>
70569>>>>>>>>>>>>>                Get DestroyHash hHash to bOk
70570>>>>>>>>>>>>>            End
70570>>>>>>>>>>>>>>
70570>>>>>>>>>>>>>            
70570>>>>>>>>>>>>>            If (hKey) Begin
70572>>>>>>>>>>>>>                //  First call to determine resulting data size
70572>>>>>>>>>>>>>                Move (Length(sData)) to iDataLen
70573>>>>>>>>>>>>>                Move (Length(sData)) to iCipherLen
70574>>>>>>>>>>>>>                Move (CryptEncrypt(hKey, 0, True, 0, 0, AddressOf(iCipherLen), iDataLen)) to bOk
70575>>>>>>>>>>>>>                
70575>>>>>>>>>>>>>                //  Reserve space in string
70575>>>>>>>>>>>>>                If (iDataLen < iCipherLen) Begin
70577>>>>>>>>>>>>>                    Move (sData + Repeat(" ", iCipherLen - iDataLen)) to sData
70578>>>>>>>>>>>>>                End
70578>>>>>>>>>>>>>>
70578>>>>>>>>>>>>>                
70578>>>>>>>>>>>>>                //  Call to really decrypt
70578>>>>>>>>>>>>>                Move (CryptEncrypt(hKey,0,True,0,AddressOf(sData),AddressOf(iDataLen),Length(sData))) to bOk
70579>>>>>>>>>>>>>                //If (not(bOk)) Begin
70579>>>>>>>>>>>>>                //Move "" to sData
70579>>>>>>>>>>>>>                //Move (GetLastError()) to iErr
70579>>>>>>>>>>>>>                //End
70579>>>>>>>>>>>>>                
70579>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
70580>>>>>>>>>>>>>            End 
70580>>>>>>>>>>>>>>
70580>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
70581>>>>>>>>>>>>>        End 
70581>>>>>>>>>>>>>>
70581>>>>>>>>>>>>>        Function_Return sData
70582>>>>>>>>>>>>>    End_Function
70583>>>>>>>>>>>>>    
70583>>>>>>>>>>>>>    // Decrypts data
70583>>>>>>>>>>>>>    Function Decrypt String sPassword String sData Returns String
70585>>>>>>>>>>>>>        Handle hProv hHash hKey
70585>>>>>>>>>>>>>        Integer iAlgorithm iDataLen
70585>>>>>>>>>>>>>        Boolean bOk
70585>>>>>>>>>>>>>        
70585>>>>>>>>>>>>>        Get AcquireContext to hProv
70586>>>>>>>>>>>>>        If (hProv) Begin
70588>>>>>>>>>>>>>            Get CreateHash hProv to hHash
70589>>>>>>>>>>>>>            If (hHash) Begin
70591>>>>>>>>>>>>>                Get HashData hHash sPassword to bOk
70592>>>>>>>>>>>>>                If (bOk) Begin
70594>>>>>>>>>>>>>                    Get piCipher to iAlgorithm
70595>>>>>>>>>>>>>                    Get DeriveKey hProv hHash to hKey
70596>>>>>>>>>>>>>                End
70596>>>>>>>>>>>>>>
70596>>>>>>>>>>>>>                Get DestroyHash hHash to bOk
70597>>>>>>>>>>>>>            End
70597>>>>>>>>>>>>>>
70597>>>>>>>>>>>>>            
70597>>>>>>>>>>>>>            If (hKey) Begin
70599>>>>>>>>>>>>>                Move (Length(sData)) to iDataLen
70600>>>>>>>>>>>>>                Move (CryptDecrypt(hKey,0,True,0,AddressOf(sData),AddressOf(iDataLen))) to bOk
70601>>>>>>>>>>>>>                //  Resulting dat can be shorter as the input string, in that case we shorten the result string
70601>>>>>>>>>>>>>                If (Length(sData) > iDataLen) Begin
70603>>>>>>>>>>>>>                    Move (Left(sData, iDataLen)) to sData
70604>>>>>>>>>>>>>                End
70604>>>>>>>>>>>>>>
70604>>>>>>>>>>>>>                
70604>>>>>>>>>>>>>                Get DestroyKey hKey to bOk
70605>>>>>>>>>>>>>            End
70605>>>>>>>>>>>>>>
70605>>>>>>>>>>>>>            Get ReleaseContext hProv to bOk
70606>>>>>>>>>>>>>        End
70606>>>>>>>>>>>>>>
70606>>>>>>>>>>>>>        Function_Return sData
70607>>>>>>>>>>>>>    End_Function
70608>>>>>>>>>>>>>    
70608>>>>>>>>>>>>>    //  Generates random data.
70608>>>>>>>>>>>>>    Function GenerateRandom Integer iBytes Returns UChar[]
70610>>>>>>>>>>>>>        Handle hProv
70610>>>>>>>>>>>>>        UChar[] uaResult
70611>>>>>>>>>>>>>        Boolean bRes
70611>>>>>>>>>>>>>        
70611>>>>>>>>>>>>>        Get AcquireContext to hProv
70612>>>>>>>>>>>>>        
70612>>>>>>>>>>>>>        Move (ResizeArray(uaResult, iBytes)) to uaResult
70613>>>>>>>>>>>>>        Move (CryptGenRandom(hProv, iBytes, AddressOf(uaResult))) to bRes
70614>>>>>>>>>>>>>        
70614>>>>>>>>>>>>>        Get ReleaseContext hProv to bRes
70615>>>>>>>>>>>>>        
70615>>>>>>>>>>>>>        Function_Return uaResult
70616>>>>>>>>>>>>>    End_Function
70617>>>>>>>>>>>>>    
70617>>>>>>>>>>>>>    //  Generates random data and does a base64 encoding to properly present it as a string.
70617>>>>>>>>>>>>>    Function GenerateRandomString Integer iLenght Returns String
70619>>>>>>>>>>>>>        String sResult
70619>>>>>>>>>>>>>        UChar[] aData
70620>>>>>>>>>>>>>        Address pBase64
70620>>>>>>>>>>>>>        Integer iVoid
70620>>>>>>>>>>>>>        
70620>>>>>>>>>>>>>        Get GenerateRandom iLenght to aData
70621>>>>>>>>>>>>>        
70621>>>>>>>>>>>>>        Move (Base64Encode(AddressOf(aData), iLenght)) to pBase64
70622>>>>>>>>>>>>>        Move pBase64 to sResult
70623>>>>>>>>>>>>>        Move (Free(pBase64)) to iVoid
70624>>>>>>>>>>>>>        
70624>>>>>>>>>>>>>        Function_Return (Left(sResult, iLenght))
70625>>>>>>>>>>>>>    End_Function
70626>>>>>>>>>>>>>    
70626>>>>>>>>>>>>>End_Class
70627>>>>>>>>>>>Use Base64Functions.pkg
Including file: Base64Functions.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\Base64Functions.pkg)
70627>>>>>>>>>>>>>//> This package enables base64 encoding and decoding of strings:
70627>>>>>>>>>>>>>//>
70627>>>>>>>>>>>>>//>     Get EncodeString of oBase64Functions sValue to sValue
70627>>>>>>>>>>>>>//>     Get DecodeString of oBase64Functions sValue to sValue
70627>>>>>>>>>>>>>//>
70627>>>>>>>>>>>>>//> Remember to set the "max argument size" if dealing with very large
70627>>>>>>>>>>>>>//> strings.
70627>>>>>>>>>>>>>//>
70627>>>>>>>>>>>>>//> For 17.1 and later the functionality of this package is based on two functions (Base64Encode and
70627>>>>>>>>>>>>>//> Base64Decode) that are built into the runtime.
70627>>>>>>>>>>>>>//>
70627>>>>>>>>>>>>>//> But for versions up to and including 17.0 it's based on the vdfBase64.dll file that was obtained
70627>>>>>>>>>>>>>//> from DAE that have kindly allowed me to distribute it to other DF developers. Programs including
70627>>>>>>>>>>>>>//> this package will give off an error on start-up if vdfBase64.dll is not found in the /bin folder
70627>>>>>>>>>>>>>//> if the VDF runtime. You will find the DLL in the /programs folder of the StureApsPublicLib workspace
70627>>>>>>>>>>>>>
70627>>>>>>>>>>>>>Use VdfBase.pkg
70627>>>>>>>>>>>>>
70627>>>>>>>>>>>>>// Functions in vdfBase64.dll
70627>>>>>>>>>>>>>External_Function xxBase64Encode "vdfbase64Encode" vdfBase64.dll Pointer pBuffer Returns Integer
70628>>>>>>>>>>>>>External_Function xxBase64Decode "vdfbase64Decode" vdfBase64.dll Pointer pBuffer Returns Integer
70629>>>>>>>>>>>>>External_Function xxBase64Free   "vdfbase64Free"   vdfBase64.dll Pointer pBuffer Returns Integer
70630>>>>>>>>>>>>>
70630>>>>>>>>>>>>>// Structure
70630>>>>>>>>>>>>>Struct txxfBase64Buffer
70630>>>>>>>>>>>>>    Pointer pData
70630>>>>>>>>>>>>>    Integer iLength
70630>>>>>>>>>>>>>End_Struct 
70630>>>>>>>>>>>>>
70630>>>>>>>>>>>>>Global_Variable Integer oBase64Functions
70630>>>>>>>>>>>>>
70630>>>>>>>>>>>>>Object _oBase64Functions is a cObject
70632>>>>>>>>>>>>>    Move Self to oBase64Functions
70633>>>>>>>>>>>>>
70633>>>>>>>>>>>>>
70633>>>>>>>>>>>>>    Function EncodeString String sValue Returns String
70636>>>>>>>>>>>>>        Address pBase64
70636>>>>>>>>>>>>>        String sResult
70636>>>>>>>>>>>>>        Integer iVoid
70636>>>>>>>>>>>>>        Move (Base64Encode(AddressOf(sValue), Length(sValue))) to pBase64
70637>>>>>>>>>>>>>        Move pBase64 to sResult
70638>>>>>>>>>>>>>        Move (Free(pBase64)) to iVoid
70639>>>>>>>>>>>>>        Function_Return sResult
70640>>>>>>>>>>>>>    End_Function
70641>>>>>>>>>>>>>
70641>>>>>>>>>>>>>    Function DecodeString String sValue Returns String
70644>>>>>>>>>>>>>        Address pBinary
70644>>>>>>>>>>>>>        String sBinary
70644>>>>>>>>>>>>>        Integer iVoid iLen
70644>>>>>>>>>>>>>        Move (Base64Decode(AddressOf(sValue), &iLen)) to pBinary
70645>>>>>>>>>>>>>        Move (Repeat(Character(0), iLen)) to sBinary
70646>>>>>>>>>>>>>        Move (MemCopy(AddressOf(sBinary), pBinary, iLen)) to iVoid
70647>>>>>>>>>>>>>        Move (Free(pBinary)) to iVoid
70648>>>>>>>>>>>>>        Function_Return sBinary
70649>>>>>>>>>>>>>    End_Function
70650>>>>>>>>>>>>>
70650>>>>>>>>>>>>>End_Object
70651>>>>>>>>>>>Use MSSqldrv.pkg
70651>>>>>>>>>>>Use db2_drv.pkg
70651>>>>>>>>>>>Use odbc_drv.pkg
70651>>>>>>>>>>>Use DFBtrDrv.pkg
70651>>>>>>>>>>>Use vWin32fh.pkg
70651>>>>>>>>>>>
70651>>>>>>>>>>>Use DUFLanguageConstants.inc
70651>>>>>>>>>>>Use MertechDUF.pkg
Including file: MertechDUF.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\MertechDUF.pkg)
70651>>>>>>>>>>>>>//
70651>>>>>>>>>>>>>// Use of Mertech drivers:
70651>>>>>>>>>>>>>// Put the line "Define DUF_Use_Mertech_Drivers in YOUR code prior the "Use" statement for this package if using Mertech drivers!
70651>>>>>>>>>>>>>// And put the line right before the "Use cDbUpdateHandler.pkg" line.
70651>>>>>>>>>>>>>//Define DUF_Use_Mertech_Drivers
70651>>>>>>>>>>>>>//
#REM USE MERTECH.INC
70651>>>>>>>>>>>>>    Use Flex2SQLDUF.pkg
Including file: Flex2SQLDUF.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\Flex2SQLDUF.pkg)
70651>>>>>>>>>>>>>>>//*************************************************************************
70651>>>>>>>>>>>>>>>//*                                                                       *
70651>>>>>>>>>>>>>>>//*  Confidential Trade Secret.                                           *
70651>>>>>>>>>>>>>>>//*  Copyright (c) 1997-2014 Mertech Data Systems Inc, Miami Florida      *
70651>>>>>>>>>>>>>>>//*  All rights reserved.                                                 *
70651>>>>>>>>>>>>>>>//*  DataFlex is a registered trademark of Data Access Corporation.       *
70651>>>>>>>>>>>>>>>//*                                                                       *
70651>>>>>>>>>>>>>>>//*  NOTE: This version of Flex2SQL is specially adapted to be used with  *
70651>>>>>>>>>>>>>>>// * the Database Update Framework (DUF)                                  *
70651>>>>>>>>>>>>>>>// *                                                                      *
70651>>>>>>>>>>>>>>>//*************************************************************************
70651>>>>>>>>>>>>>>>Use mertech.inc
Including file: mertech.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\mertech.inc)
70651>>>>>>>>>>>>>>>>>//*************************************************************************
70651>>>>>>>>>>>>>>>>>//*                                                                       *
70651>>>>>>>>>>>>>>>>>//*  Confidential Trade Secret.                                           *
70651>>>>>>>>>>>>>>>>>//*  Copyright (c) 1997-2014 Mertech Data Systems Inc, Miami Florida      *
70651>>>>>>>>>>>>>>>>>//*  All rights reserved.                                                 *
70651>>>>>>>>>>>>>>>>>//*  DataFlex is a registered trademark of Data Access Corporation.       *
70651>>>>>>>>>>>>>>>>>//*                                                                       *
70651>>>>>>>>>>>>>>>>>//*************************************************************************
70651>>>>>>>>>>>>>>>>>Use UI
70651>>>>>>>>>>>>>>>>>Use SEQ_CHNL.PKG
70651>>>>>>>>>>>>>>>>>
#REM -----------------------------------------------
#REM MERTECH DATA SYSTEMS INC. - MERTECH.COM
#REM MERTECH.INC VERSION 3.3.1.5
#REM -----------------------------------------------
70651>>>>>>>>>>>>>>>>>
70651>>>>>>>>>>>>>>>>>Object oMertechInc_Work is an Array  
70653>>>>>>>>>>>>>>>>>    CompilerWarnings Off
70653>>>>>>>>>>>>>>>>>    Property String psWork Public (Repeat("                                ", 512))
70655>>>>>>>>>>>>>>>>>    CompilerWarnings On
70655>>>>>>>>>>>>>>>>>End_Object
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//=============================================================================
70656>>>>>>>>>>>>>>>>>// #DEFINE's
70656>>>>>>>>>>>>>>>>>//=============================================================================
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//Currently Unsupported Attribute
70656>>>>>>>>>>>>>>>>>Define DF_FILE_PRIMARY_KEY                          For (DF_FILE_RECORD_REREAD+1)
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>// TODO: This is probably deprecated. Investigate.
70656>>>>>>>>>>>>>>>>>Define DF_FILE_NUMBER_INVERSE_KEYS                  For (DF_FILE_RECORD_REREAD+3)
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//=============================================================================
70656>>>>>>>>>>>>>>>>>/// @Name        DF_FILE_SET_MODE
70656>>>>>>>>>>>>>>>>>/// @Description Allows switching between set-oriented and record oriented fetch modes.
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// If DF_FILE_SET_MODE is set to True, the driver will fetch a set of records
70656>>>>>>>>>>>>>>>>>/// for each find. If DF_FILE_SET_MODE is False, the driver will fetch only one
70656>>>>>>>>>>>>>>>>>/// record at a time. This attribute can also be specified in the .INT file during
70656>>>>>>>>>>>>>>>>>/// migration through Flex2SQL. This settings is normally used alongside
70656>>>>>>>>>>>>>>>>>/// DF_FILE_MAX_ROWS to set the number of rows to return and DF_FILE_CACHE_MODE
70656>>>>>>>>>>>>>>>>>/// to turn on local caching.
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Note: Turning off set-mode can have a detrimental impact on performance. Unless
70656>>>>>>>>>>>>>>>>>/// there is a specific reason to do otherwise, this option should be left on.
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Default value: True
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Assumptions
70656>>>>>>>>>>>>>>>>>/// @Status      Public
70656>>>>>>>>>>>>>>>>>/// @Drivers     All
70656>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-15 by Oliver Nelson
70656>>>>>>>>>>>>>>>>>/// @See DF_FILE_MAX_ROWS DF_FILE_CACHE_MODE
70656>>>>>>>>>>>>>>>>>/// @INTOPT OPTIMIZE {FOR_SET | ONE_ROW}
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_SET_MODE of {FileNumber} to {variable}
70656>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_SET_MODE of {FileNumber} to {variable}
70656>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
70656>>>>>>>>>>>>>>>>>/// @Param  variable              Mode for the FileNumber. True for set-mode, False for one-row mode.
70656>>>>>>>>>>>>>>>>>/// @Example
70656>>>>>>>>>>>>>>>>>/// Open Orderhea
70656>>>>>>>>>>>>>>>>>/// Set_Attribute DF_FILE_SET_MODE of Orderhea.File_Number to True
70656>>>>>>>>>>>>>>>>>/// Get_Attribute DF_FILE_SET_MODE of Orderhea.File_Number to boolVar
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>Define DF_FILE_SET_MODE                             For (DF_FILE_RECORD_REREAD+5)
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//=============================================================================
70656>>>>>>>>>>>>>>>>>/// @Name        DF_FILE_DATABASENAME
70656>>>>>>>>>>>>>>>>>/// @Description Returns a string containing the name of the database where the
70656>>>>>>>>>>>>>>>>>/// table referenced by the passed File Number resides. This is a READ ONLY
70656>>>>>>>>>>>>>>>>>/// attribute. Note that because Oracle doesn't support the concept of multiple
70656>>>>>>>>>>>>>>>>>/// databases on one server, this attribute is not valid for Oracle.
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Assumptions
70656>>>>>>>>>>>>>>>>>/// @Status      Public
70656>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex, MySQLFlex, PGFlex
70656>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-15 by Oliver Nelson
70656>>>>>>>>>>>>>>>>>/// @See
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_DATABASENAME of {FileNumber} to {variable}
70656>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
70656>>>>>>>>>>>>>>>>>/// @Param  variable              Name of the Database
70656>>>>>>>>>>>>>>>>>/// @Example
70656>>>>>>>>>>>>>>>>>/// Open Orderhea
70656>>>>>>>>>>>>>>>>>/// Get_Attribute DF_FILE_DATABASENAME of Orderhea.File_Number to strVal
70656>>>>>>>>>>>>>>>>>Define DF_FILE_DATABASENAME                         For (DF_FILE_RECORD_REREAD+6)
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//=============================================================================
70656>>>>>>>>>>>>>>>>>/// @Name        DF_FILE_MAX_ROWS
70656>>>>>>>>>>>>>>>>>/// @Description Controls the maximum number of rows retrieved by a Find GT/LT
70656>>>>>>>>>>>>>>>>>/// operation. The driver will automatically retrieve and cache this many rows
70656>>>>>>>>>>>>>>>>>/// for future find GT/LT operations. Setting this property to a very high
70656>>>>>>>>>>>>>>>>>/// value can be inefficient from a UI perspective but may be advisable for
70656>>>>>>>>>>>>>>>>>/// local processing of rows (such as in a batch process).
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Default value: 10
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Assumptions
70656>>>>>>>>>>>>>>>>>/// @Status      Public
70656>>>>>>>>>>>>>>>>>/// @Drivers     All
70656>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-15 by Oliver Nelson
70656>>>>>>>>>>>>>>>>>/// @See DF_FILE_SET_MODE DF_FILE_CACHE_MODE
70656>>>>>>>>>>>>>>>>>/// @INTOPT MAX_ROWS_TO_QUERY {integer}
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_DATABASENAME of {FileNumber} to {variable}
70656>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
70656>>>>>>>>>>>>>>>>>/// @Param  variable              Attribute Value
70656>>>>>>>>>>>>>>>>>/// @Example
70656>>>>>>>>>>>>>>>>>/// Open Orderhea
70656>>>>>>>>>>>>>>>>>/// Set_Attribute DF_FILE_MAX_ROWS of Orderhea.File_Number to 10
70656>>>>>>>>>>>>>>>>>/// Get_Attribute DF_FILE_MAX_ROWS of Orderhea.File_Number to intVal
70656>>>>>>>>>>>>>>>>>Define DF_FILE_MAX_ROWS                             For (DF_FILE_RECORD_REREAD+7)
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//=============================================================================
70656>>>>>>>>>>>>>>>>>/// @Name        DF_FILE_TABLE_NAME
70656>>>>>>>>>>>>>>>>>/// @Description Use this attribute to set or get the name of the SQL table
70656>>>>>>>>>>>>>>>>>/// corresponding to the specified file number. In a restructure operation
70656>>>>>>>>>>>>>>>>>/// this attribute may be used to permanently change the table that a filelist
70656>>>>>>>>>>>>>>>>>/// entry is pointing to.
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Assumptions
70656>>>>>>>>>>>>>>>>>/// @Status      Public
70656>>>>>>>>>>>>>>>>>/// @Drivers     All
70656>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-15 by Oliver Nelson
70656>>>>>>>>>>>>>>>>>/// @See
70656>>>>>>>>>>>>>>>>>/// @INTOPT DATABASE_NAME {string}
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_TABLE_NAME of {FileNumber} to {variable}
70656>>>>>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_TABLE_NAME of {FileNumber} to {variable}
70656>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
70656>>>>>>>>>>>>>>>>>/// @Param  variable              Name of the SQL Table.
70656>>>>>>>>>>>>>>>>>/// @Example
70656>>>>>>>>>>>>>>>>>/// Open Orderhea
70656>>>>>>>>>>>>>>>>>/// Get_Attribute DF_FILE_TABLE_NAME of Orderhea.File_Number to strVal
70656>>>>>>>>>>>>>>>>>Define DF_FILE_TABLE_NAME                           For (DF_FILE_RECORD_REREAD+8)
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//=============================================================================
70656>>>>>>>>>>>>>>>>>/// @Name        DF_FILE_CACHE_MODE
70656>>>>>>>>>>>>>>>>>/// @Description Activates or deactivates the local cache for set-oriented searches.
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Through the DF_FILE_CACHE_MODE attribute, we can activate or deactivate the
70656>>>>>>>>>>>>>>>>>/// local cache. When the cache is active in a set-oriented search, a fixed
70656>>>>>>>>>>>>>>>>>/// number of records are pre-fetched and kept in the local cache. If a record
70656>>>>>>>>>>>>>>>>>/// is not found in the local cache, a new set is fetched. The number of records
70656>>>>>>>>>>>>>>>>>/// fetched is controlled via the DF_FILE_MAX_ROWS attribute. Set-mode vs. one-row
70656>>>>>>>>>>>>>>>>>/// mode is controlled via the DF_FILE_SET_MODE attribute.
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Note: Turning off the cache can have significant detrimental effects on performance.
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Default value: True
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Assumptions
70656>>>>>>>>>>>>>>>>>/// @Status      Public
70656>>>>>>>>>>>>>>>>>/// @Drivers     All
70656>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-15 by Oliver Nelson
70656>>>>>>>>>>>>>>>>>/// @See         DF_FILE_MAX_ROWS DF_FILE_SET_MODE
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_CACHE_MODE of {FileNumber} to {variable}
70656>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_CACHE_MODE of {FileNumber} to {variable}
70656>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
70656>>>>>>>>>>>>>>>>>/// @Param  variable              Mode for FileNumber. True for active. False for inactive.
70656>>>>>>>>>>>>>>>>>/// @Example
70656>>>>>>>>>>>>>>>>>/// Open Orderhea
70656>>>>>>>>>>>>>>>>>/// Set_Attribute DF_FILE_CACHE_MODE of Orderhea.File_Number to True
70656>>>>>>>>>>>>>>>>>/// Get_Attribute DF_FILE_CACHE_MODE of Orderhea.File_Number to boolVal
70656>>>>>>>>>>>>>>>>>Define DF_FILE_CACHE_MODE                           For (DF_FILE_RECORD_REREAD+9)
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//Currently Unsupported Attribute
70656>>>>>>>>>>>>>>>>>Define DF_FILE_STORAGE_BASE                         For (DF_FILE_RECORD_REREAD+10)
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//=============================================================================
70656>>>>>>>>>>>>>>>>>/// @Name        DF_FILE_STATIC
70656>>>>>>>>>>>>>>>>>/// @Description Activates or deactivates a special table mode where all rows
70656>>>>>>>>>>>>>>>>>/// from the table are loaded into a local cache. When active, all searches are
70656>>>>>>>>>>>>>>>>>/// done in memory and the actual table is not accessed.  The driver does not allow
70656>>>>>>>>>>>>>>>>>/// editing of a table in static mode.  This is a very useful feature especially
70656>>>>>>>>>>>>>>>>>/// when a table contains configuration or static information used in
70656>>>>>>>>>>>>>>>>>/// calculations, (i.e., Tax Rate tables, etc.) By keeping this table locally
70656>>>>>>>>>>>>>>>>>/// in memory, network round trips are saved resulting in significant
70656>>>>>>>>>>>>>>>>>/// performance improvements. This attribute is also useful for batch
70656>>>>>>>>>>>>>>>>>/// processes that make extensive table IO requests for reading static information.
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Note: Because the entire table is loaded into memory, it is inadvisable to use
70656>>>>>>>>>>>>>>>>>/// this on very large tables.
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Default value: False
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Assumptions
70656>>>>>>>>>>>>>>>>>/// @Status      Public
70656>>>>>>>>>>>>>>>>>/// @Drivers     All
70656>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-15 by Oliver Nelson
70656>>>>>>>>>>>>>>>>>/// @See
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_STATIC of {FileNumber} to {variable}
70656>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
70656>>>>>>>>>>>>>>>>>/// @Param  variable              Static Mode for FileNumber. True for static. False for dynamic.
70656>>>>>>>>>>>>>>>>>/// @Example
70656>>>>>>>>>>>>>>>>>/// Open Orderhea
70656>>>>>>>>>>>>>>>>>/// Set_Attribute DF_FILE_STATIC of Orderhea.File_Number to True
70656>>>>>>>>>>>>>>>>>/// Get_Attribute DF_FILE_STATIC of Orderhea.File_Number to boolVal
70656>>>>>>>>>>>>>>>>>Define DF_FILE_STATIC                               For (DF_FILE_RECORD_REREAD+11)
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//=============================================================================
70656>>>>>>>>>>>>>>>>>/// @Name        DF_FILE_SERVER_NAME
70656>>>>>>>>>>>>>>>>>/// @Description Use this attribute to set or get the name of the database server
70656>>>>>>>>>>>>>>>>>/// corresponding to the specified file number. In a restructure operation
70656>>>>>>>>>>>>>>>>>/// this attribute may be used to permanently change the server that a filelist
70656>>>>>>>>>>>>>>>>>/// entry is pointing to.
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Assumptions
70656>>>>>>>>>>>>>>>>>/// @Status      Public
70656>>>>>>>>>>>>>>>>>/// @Drivers     All
70656>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-15 by Oliver Nelson
70656>>>>>>>>>>>>>>>>>/// @See
70656>>>>>>>>>>>>>>>>>/// @INTOPT SERVER_NAME {string}
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_SERVER_NAME of {FileNumber} to {variable}
70656>>>>>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_SERVER_NAME of {FileNumber} to {variable}
70656>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
70656>>>>>>>>>>>>>>>>>/// @Param  variable              Name of the database server.
70656>>>>>>>>>>>>>>>>>/// @Example
70656>>>>>>>>>>>>>>>>>/// Open Orderhea
70656>>>>>>>>>>>>>>>>>/// Set_Attribute DF_FILE_SERVER_NAME of Orderhea.File_Number to "(localdb)\v11.0"
70656>>>>>>>>>>>>>>>>>/// Get_Attribute DF_FILE_SERVER_NAME of Orderhea.File_Number to strVal
70656>>>>>>>>>>>>>>>>>Define DF_FILE_SERVER_NAME                          For (DF_FILE_RECORD_REREAD+12)
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//=============================================================================
70656>>>>>>>>>>>>>>>>>/// @Name        DF_FETCH_FIELD_COUNT
70656>>>>>>>>>>>>>>>>>/// @Description This attribute is used to get the number of fields or columns
70656>>>>>>>>>>>>>>>>>/// in the given table. Note that this is referring to the columns in the SQL
70656>>>>>>>>>>>>>>>>>/// backend and may not necessarily reflect the number of columns in DataFlex.
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// This is a readonly attribute.
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Assumptions
70656>>>>>>>>>>>>>>>>>/// @Status      Public
70656>>>>>>>>>>>>>>>>>/// @Drivers     MsSQLFlex MySQLFlex
70656>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-14 by Aaron Gulack
70656>>>>>>>>>>>>>>>>>/// @See
70656>>>>>>>>>>>>>>>>>/// @INTOPT
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FETCH_FIELD_COUNT of {FileNumber} to {variable}
70656>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
70656>>>>>>>>>>>>>>>>>/// @Param  variable              Name of the Tablespace.
70656>>>>>>>>>>>>>>>>>/// @Example
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>/// Get_Attribute DF_FETCH_FIELD_COUNT of hFile To "INDXS"
70656>>>>>>>>>>>>>>>>>Define DF_FETCH_FIELD_COUNT                         For (DF_FILE_RECORD_REREAD+13)
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//=============================================================================
70656>>>>>>>>>>>>>>>>>/// @Name        DF_FILE_TABLESPACE_NAME
70656>>>>>>>>>>>>>>>>>/// @Description A tablespace is a container of segments (objects that have an
70656>>>>>>>>>>>>>>>>>/// allotted amount of space), i.e. tables and indexes. This attribute is
70656>>>>>>>>>>>>>>>>>/// used to get or set the name of the tablespace being used for the data tables.
70656>>>>>>>>>>>>>>>>>/// To set or get the tablespace name for indexes, use the DF_FILE_INDEXTABLESPACE_NAME
70656>>>>>>>>>>>>>>>>>/// attribute. Setting the tablespace name can only be done during a Structure_Start
70656>>>>>>>>>>>>>>>>>/// (during table creation).  Getting the name, however can be done at
70656>>>>>>>>>>>>>>>>>/// anytime.  Note that when setting the tablespace name, it must be set to an
70656>>>>>>>>>>>>>>>>>/// already existing tablespace, this attribute does not create the tablespace itself.
70656>>>>>>>>>>>>>>>>>/// Even though MYSQL uses tablespaces, this this attribute is only supported
70656>>>>>>>>>>>>>>>>>/// in Oracle and PostgreSQL.
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Assumptions
70656>>>>>>>>>>>>>>>>>/// @Status      Public
70656>>>>>>>>>>>>>>>>>/// @Drivers     ORAFlex PGFlex
70656>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-25 by Aaron Gulack
70656>>>>>>>>>>>>>>>>>/// @See         DF_FILE_INDEXTABLESPACE_NAME
70656>>>>>>>>>>>>>>>>>/// @INTOPT
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_TABLESPACE_NAME of {FileNumber} to {variable}
70656>>>>>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_TABLESPACE_NAME of {FileNumber} to {variable}
70656>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
70656>>>>>>>>>>>>>>>>>/// @Param  variable              Name of the Tablespace.
70656>>>>>>>>>>>>>>>>>/// @Example
70656>>>>>>>>>>>>>>>>>/// Handle hFile
70656>>>>>>>>>>>>>>>>>/// move 0 to hFile
70656>>>>>>>>>>>>>>>>>/// Structure_Start hFile "ORA_DRV"
70656>>>>>>>>>>>>>>>>>///     Set_Attribute DF_FILE_TABLESPACE_NAME      of hFile To "USERS"
70656>>>>>>>>>>>>>>>>>///     Set_Attribute DF_FILE_INDEXTABLESPACE_NAME of hFile To "INDXS"
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>///             // More table creation here
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Structure_End hFile DF_STRUCTEND_OPT_NONE "." 0
70656>>>>>>>>>>>>>>>>>Define DF_FILE_TABLESPACE_NAME                      For (DF_FILE_RECORD_REREAD+14)
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>// TODO: This is probably deprecated. Investigate.
70656>>>>>>>>>>>>>>>>>Define DF_FETCH_FIELDNUMBER                         For (DF_FILE_RECORD_REREAD+15)
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//=============================================================================
70656>>>>>>>>>>>>>>>>>/// @Name        DF_FILE_INDEXTABLESPACE_NAME
70656>>>>>>>>>>>>>>>>>/// @Description This attribute is used to get or set the name of the tablespace
70656>>>>>>>>>>>>>>>>>/// being used for the index segment of a database. For a description of tablespaces,
70656>>>>>>>>>>>>>>>>>/// see the description above for DF_FILE_TABLESPACE_NAME. Similar to the Tablespace
70656>>>>>>>>>>>>>>>>>/// name attribute, setting the index tablespace name can only be done during creation
70656>>>>>>>>>>>>>>>>>/// and must use an already existing tablespace as the variable. This attribute is
70656>>>>>>>>>>>>>>>>>/// only available for Oracle and Postgre.
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Assumptions
70656>>>>>>>>>>>>>>>>>/// @Status      Public
70656>>>>>>>>>>>>>>>>>/// @Drivers     ORAFlex PGFlex
70656>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-25 by Aaron Gulack
70656>>>>>>>>>>>>>>>>>/// @See         DF_FILE_TABLESPACE_NAME
70656>>>>>>>>>>>>>>>>>/// @INTOPT
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_INDEXTABLESPACE_NAME of {File Number} to {variable}
70656>>>>>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_INDEXTABLESPACE_NAME of {File Number} to {variable}
70656>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
70656>>>>>>>>>>>>>>>>>/// @Param  variable              Name of the Tablespace
70656>>>>>>>>>>>>>>>>>/// @Example
70656>>>>>>>>>>>>>>>>>/// Handle hFile
70656>>>>>>>>>>>>>>>>>/// move 0 to hFile
70656>>>>>>>>>>>>>>>>>/// Structure_Start hFile "ORA_DRV"
70656>>>>>>>>>>>>>>>>>///     Set_Attribute DF_FILE_TABLESPACE_NAME      of hFile To "USERS"
70656>>>>>>>>>>>>>>>>>///     Set_Attribute DF_FILE_INDEXTABLESPACE_NAME of hFile To "INDXS"
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>///             // More table creation here
70656>>>>>>>>>>>>>>>>>///             //
70656>>>>>>>>>>>>>>>>>/// Structure_End hFile DF_STRUCTEND_OPT_NONE "." 0
70656>>>>>>>>>>>>>>>>>Define DF_FILE_INDEXTABLESPACE_NAME                 For (DF_FILE_RECORD_REREAD+16)
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//=============================================================================
70656>>>>>>>>>>>>>>>>>/// @Name        DF_FILE_RETRIEVE_RECNUM
70656>>>>>>>>>>>>>>>>>/// @Description When creating records on a table with RECNUM support, the
70656>>>>>>>>>>>>>>>>>/// record number is returned after creation. When this attribute is false, the newly
70656>>>>>>>>>>>>>>>>>/// created record's RECNUM is not returned from the server. This could result in a
70656>>>>>>>>>>>>>>>>>/// slight performance improvement when many records are being created in a loop.
70656>>>>>>>>>>>>>>>>>/// The optimization, however, is negligible.  Having this attribute set to false can
70656>>>>>>>>>>>>>>>>>/// have detrimental effects if used improperly; i.e. DD-based saves or UI-based
70656>>>>>>>>>>>>>>>>>/// operations. Thus, this should almost always be set to true unless there is a
70656>>>>>>>>>>>>>>>>>/// compelling reason to do otherwise.
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Default Value: True
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Assumptions
70656>>>>>>>>>>>>>>>>>/// @Status      Public
70656>>>>>>>>>>>>>>>>>/// @Drivers     All
70656>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-31 by Aaron Gulack
70656>>>>>>>>>>>>>>>>>/// @See
70656>>>>>>>>>>>>>>>>>/// @INTOPT
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_RETRIEVE_RECNUM of {FileNumber} to {variable}
70656>>>>>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_RETRIEVE_RECNUM of {FileNumber} to {variable}
70656>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
70656>>>>>>>>>>>>>>>>>/// @Param  variable              Boolean variable. false to not retrieve record number, true otherwise.
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>/// @Example
70656>>>>>>>>>>>>>>>>>/// open ORDERHEA
70656>>>>>>>>>>>>>>>>>/// Handle  hFile
70656>>>>>>>>>>>>>>>>>/// Boolean bRetrieve
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Set_Attribute DF_FILE_RETRIEVE_RECNUM of hFile to false
70656>>>>>>>>>>>>>>>>>/// Get_Attribute DF_FILE_RETRIEVE_RECNUM of hFile To bRetrieve
70656>>>>>>>>>>>>>>>>>Define DF_FILE_RETRIEVE_RECNUM                      For (DF_FILE_RECORD_REREAD+17)
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//=============================================================================
70656>>>>>>>>>>>>>>>>>/// @Name        DF_FILE_NAME_SPACE
70656>>>>>>>>>>>>>>>>>/// @Description In Postgres, schemas are objects where all the tables,views and indexes
70656>>>>>>>>>>>>>>>>>/// are stored. Separate schemas are used to specify relational data. This attribute is
70656>>>>>>>>>>>>>>>>>/// used to set the name of the schema where a table is created. Schema's do not account
70656>>>>>>>>>>>>>>>>>/// for any physical space but are merely used as theory to explain the order of a database.
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Assumptions
70656>>>>>>>>>>>>>>>>>/// @Status      Public
70656>>>>>>>>>>>>>>>>>/// @Drivers     PGFlex
70656>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-07-25 by Aaron Gulack
70656>>>>>>>>>>>>>>>>>/// @See
70656>>>>>>>>>>>>>>>>>/// @INTOPT
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_NAME_SPACE of {FileNumber} to {variable}
70656>>>>>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_NAME_SPACE of {FileNumber} to {variable}
70656>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
70656>>>>>>>>>>>>>>>>>/// @Param  variable              Name of the Schema
70656>>>>>>>>>>>>>>>>>/// @Example
70656>>>>>>>>>>>>>>>>>/// open ORDERHEA
70656>>>>>>>>>>>>>>>>>/// Handle hFile
70656>>>>>>>>>>>>>>>>>/// String sSchemaName
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Set_Attribute DF_FILE_NAME_SPACE of hFile to "ORDERHEA"
70656>>>>>>>>>>>>>>>>>/// Get_Attribute DF_FILE_NAME_SPACE of hFile To sSchemaName
70656>>>>>>>>>>>>>>>>>Define DF_FILE_NAME_SPACE                           For (DF_FILE_RECORD_REREAD+18)
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>// Currently does not serve any function. May be included in future versions.
70656>>>>>>>>>>>>>>>>>Define DF_FILE_STORAGE_PCTFREE                      For (DF_FILE_RECORD_REREAD+19)
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>// Currently does not serve any function. May be included in future versions.
70656>>>>>>>>>>>>>>>>>Define DF_FILE_STORAGE_PCTUSED                      For (DF_FILE_RECORD_REREAD+21)
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>// Currently does not serve any function. May be included in future versions.
70656>>>>>>>>>>>>>>>>>Define DF_FILE_STORAGE_INITIAL                      For (DF_FILE_RECORD_REREAD+23)
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>// Currently does not serve any function. May be included in future versions.
70656>>>>>>>>>>>>>>>>>Define DF_FILE_STORAGE_NEXT                         For (DF_FILE_RECORD_REREAD+25)
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>// Currently does not serve any function. May be included in future versions.
70656>>>>>>>>>>>>>>>>>Define DF_FILE_ALLOW_NULL                           For (DF_FILE_RECORD_REREAD+27)
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//=============================================================================
70656>>>>>>>>>>>>>>>>>/// @Name        DF_FILE_GET_SERVERNAME_FROM_LOGIN
70656>>>>>>>>>>>>>>>>>/// @Description Use this attribute to specify whether the SERVER_NAME option will
70656>>>>>>>>>>>>>>>>>/// be included in the INT file.  If set to True, the SERVER_NAME option will not
70656>>>>>>>>>>>>>>>>>/// be included in the INT file, if set to false, the SERVER_NAME option will be
70656>>>>>>>>>>>>>>>>>/// included in the INT file. This has two uses. The first is during a Structure_Start
70656>>>>>>>>>>>>>>>>>/// i.e. table creation/modification. The other is when using the OUTPUT_INT_FILE
70656>>>>>>>>>>>>>>>>>/// command. Set this attribute before the OUTPUT_INT_FILE to indicate how the INT
70656>>>>>>>>>>>>>>>>>/// file will be written. This name indicates a backwards logic so take note that
70656>>>>>>>>>>>>>>>>>/// setting it to true will NOT include the SERVER_NAME in the INT file.
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Default Value: False
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Assumptions
70656>>>>>>>>>>>>>>>>>/// @Status      Deprecated
70656>>>>>>>>>>>>>>>>>/// @Drivers     All
70656>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-01 by Aaron Gulack
70656>>>>>>>>>>>>>>>>>/// @See         DF_FILE_SUPPRESS_SERVERNAME_OUTPUT
70656>>>>>>>>>>>>>>>>>/// @INTOPT              SERVER_NAME
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_GET_SERVERNAME_FROM_LOGIN of {FileNumber} to {variable}
70656>>>>>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_GET_SERVERNAME_FROM_LOGIN of {FileNumber} to {variable}
70656>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
70656>>>>>>>>>>>>>>>>>/// @Param  variable              Boolean variable. True to not include, false to include in INT.
70656>>>>>>>>>>>>>>>>>/// @Example
70656>>>>>>>>>>>>>>>>>/// Open Customer
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>///     Set_Attribute DF_FILE_GET_SERVERNAME_FROM_LOGIN of Customer.File_Number to True
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>///     OUTPUT_INT_FILE for Customer.File_Number to "c:\temp\test.int"
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Close Customer
70656>>>>>>>>>>>>>>>>>Define DF_FILE_GET_SERVERNAME_FROM_LOGIN            For (DF_FILE_RECORD_REREAD+29)
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//=============================================================================
70656>>>>>>>>>>>>>>>>>/// @Name        DF_FILE_SUPPRESS_SERVERNAME_OUTPUT
70656>>>>>>>>>>>>>>>>>/// @Description Use this attribute to specify whether the SERVER_NAME option will be included
70656>>>>>>>>>>>>>>>>>/// in the INT file.  If set to True, the server name will not be included in the INT file,
70656>>>>>>>>>>>>>>>>>/// if set to false, the server name will be included in the INT file. This has two uses.
70656>>>>>>>>>>>>>>>>>/// The first is during a Structure_Start i.e. table creation/modification. The other is
70656>>>>>>>>>>>>>>>>>/// when using the OUTPUT_INT_FILE command. Set this attribute before the OUTPUT_INT_FILE
70656>>>>>>>>>>>>>>>>>/// to indicate how the INT file will be written.
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Default Value: False
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Assumptions
70656>>>>>>>>>>>>>>>>>/// @Status      Public
70656>>>>>>>>>>>>>>>>>/// @Drivers     All
70656>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-01 by Aaron Gulack
70656>>>>>>>>>>>>>>>>>/// @See         DF_FILE_SUPPRESS_DATABASENAME_OUTPUT DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT
70656>>>>>>>>>>>>>>>>>/// @INTOPT              SERVER_NAME
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_SUPPRESS_SERVERNAME_OUTPUT of {FileNumber} to {variable}
70656>>>>>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_SUPPRESS_SERVERNAME_OUTPUT of {FileNumber} to {variable}
70656>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
70656>>>>>>>>>>>>>>>>>/// @Param  variable              Boolean variable. True to not include, false to include in INT.
70656>>>>>>>>>>>>>>>>>/// @Example
70656>>>>>>>>>>>>>>>>>/// Open Customer
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>///   Set_Attribute DF_FILE_SUPPRESS_SERVERNAME_OUTPUT of Customer.File_Number to True
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>///   OUTPUT_INT_FILE for Customer.File_Number to "c:\temp\test.int"
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Close Customer
70656>>>>>>>>>>>>>>>>>Define DF_FILE_SUPPRESS_SERVERNAME_OUTPUT                       For DF_FILE_GET_SERVERNAME_FROM_LOGIN
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//=============================================================================
70656>>>>>>>>>>>>>>>>>/// @Name        DF_FILE_GET_DATABASENAME_FROM_LOGIN
70656>>>>>>>>>>>>>>>>>/// @Description Use this attribute to specify whether the DATABASE_NAME option will
70656>>>>>>>>>>>>>>>>>/// be included in the INT file.  If set to True, the DATABASE_NAME option will not
70656>>>>>>>>>>>>>>>>>/// be included in the INT file, if set to false, the DATABASE_NAME option will be
70656>>>>>>>>>>>>>>>>>/// included in the INT file. This has two uses. The first is during a Structure_Start
70656>>>>>>>>>>>>>>>>>/// i.e. table creation/modification. The other is when using the OUTPUT_INT_FILE
70656>>>>>>>>>>>>>>>>>/// command. Set this attribute before the OUTPUT_INT_FILE to indicate how the INT
70656>>>>>>>>>>>>>>>>>/// file will be written. This name indicates a backwards logic so take note that
70656>>>>>>>>>>>>>>>>>/// setting it to true will NOT include the DATABASE_NAME in the INT file.
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Default Value: False
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Assumptions
70656>>>>>>>>>>>>>>>>>/// @Status      Deprecated
70656>>>>>>>>>>>>>>>>>/// @Drivers     PGFlex SQLFlex MySQLFlex
70656>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-01 by Aaron Gulack
70656>>>>>>>>>>>>>>>>>/// @See         DF_FILE_SUPPRESS_DATABASENAME_OUTPUT
70656>>>>>>>>>>>>>>>>>/// @INTOPT              DATABASE_NAME
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_GET_DATABASENAME_FROM_LOGIN of {FileNumber} to {variable}
70656>>>>>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_GET_DATABASENAME_FROM_LOGIN of {FileNumber} to {variable}
70656>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
70656>>>>>>>>>>>>>>>>>/// @Param  variable              Boolean variable. True to not include, false to include in INT.
70656>>>>>>>>>>>>>>>>>/// @Example
70656>>>>>>>>>>>>>>>>>/// Open Customer
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>///     Set_Attribute DF_FILE_GET_DATABASENAME_FROM_LOGIN of Customer.File_Number to True
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>///     OUTPUT_INT_FILE for Customer.File_Number to "c:\temp\test.int"
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Close Customer
70656>>>>>>>>>>>>>>>>>Define DF_FILE_GET_DATABASENAME_FROM_LOGIN          For (DF_FILE_RECORD_REREAD+31)
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//=============================================================================
70656>>>>>>>>>>>>>>>>>/// @Name        DF_FILE_SUPPRESS_DATABASENAME_OUTPUT
70656>>>>>>>>>>>>>>>>>/// @Description Use this attribute to specify whether the DATABASE_NAME option will
70656>>>>>>>>>>>>>>>>>/// be included in the INT file.  If set to True, the DATABASE_NAME option will not
70656>>>>>>>>>>>>>>>>>/// be included in the INT file, if set to false, the DATABASE_NAME option will be
70656>>>>>>>>>>>>>>>>>/// included in the INT file. This has two uses. The first is during a Structure_Start
70656>>>>>>>>>>>>>>>>>/// i.e. table creation/modification. The other is when using the OUTPUT_INT_FILE
70656>>>>>>>>>>>>>>>>>/// command. Set this attribute before the OUTPUT_INT_FILE to indicate how the INT
70656>>>>>>>>>>>>>>>>>/// file will be written. This name indicates a backwards logic so take note that
70656>>>>>>>>>>>>>>>>>/// setting it to true will NOT include the DATABASE_NAME in the INT file.
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Default Value: False
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Assumptions
70656>>>>>>>>>>>>>>>>>/// @Status      Public
70656>>>>>>>>>>>>>>>>>/// @Drivers     PGFlex SQLFlex MySQLFlex
70656>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-01 by Aaron Gulack
70656>>>>>>>>>>>>>>>>>/// @See         DF_FILE_SUPPRESS_SERVERNAME_OUTPUT DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT
70656>>>>>>>>>>>>>>>>>/// @INTOPT              DATABASE_NAME
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_SUPPRESS_DATABASENAME_OUTPUT of {FileNumber} to {variable}
70656>>>>>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_SUPPRESS_DATABASENAME_OUTPUT of {FileNumber} to {variable}
70656>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
70656>>>>>>>>>>>>>>>>>/// @Param  variable              Boolean variable. True to not include, false to include in INT.
70656>>>>>>>>>>>>>>>>>/// @Example
70656>>>>>>>>>>>>>>>>>/// Open Customer
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>///     Set_Attribute DF_FILE_SUPPRESS_DATABASENAME_OUTPUT of Customer.File_Number to True
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>///     OUTPUT_INT_FILE for Customer.File_Number to "c:\temp\test.int"
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Close Customer
70656>>>>>>>>>>>>>>>>>Define DF_FILE_SUPPRESS_DATABASENAME_OUTPUT                     For DF_FILE_GET_DATABASENAME_FROM_LOGIN
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//=============================================================================
70656>>>>>>>>>>>>>>>>>/// @Name        DF_FILE_GET_SCHEMANAME_FROM_LOGIN
70656>>>>>>>>>>>>>>>>>/// @Description Use this attribute to specify whether the SCHEMA_NAME option will
70656>>>>>>>>>>>>>>>>>/// be included in the INT file.  If set to True, the SCHEMA_NAME option will not
70656>>>>>>>>>>>>>>>>>/// be included in the INT file, if set to false, the SCHEMA_NAME option will be
70656>>>>>>>>>>>>>>>>>/// included in the INT file. This has two uses. The first is during a Structure_Start
70656>>>>>>>>>>>>>>>>>/// i.e. table creation/modification. The other is when using the OUTPUT_INT_FILE
70656>>>>>>>>>>>>>>>>>/// command. Set this attribute before the OUTPUT_INT_FILE to indicate how the INT
70656>>>>>>>>>>>>>>>>>/// file will be written. This name indicates a backwards logic so take note that
70656>>>>>>>>>>>>>>>>>/// setting it to true will NOT include the SCHEMA_NAME in the INT file.
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Default Value: False
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Assumptions
70656>>>>>>>>>>>>>>>>>/// @Status      Deprecated
70656>>>>>>>>>>>>>>>>>/// @Drivers     All
70656>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-01 by Aaron Gulack
70656>>>>>>>>>>>>>>>>>/// @See         DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT
70656>>>>>>>>>>>>>>>>>/// @INTOPT              SCHEMA_NAME
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_GET_SCHEMANAME_FROM_LOGIN of {FileNumber} to {variable}
70656>>>>>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_GET_SCHEMANAME_FROM_LOGIN of {FileNumber} to {variable}
70656>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
70656>>>>>>>>>>>>>>>>>/// @Param  variable              Boolean variable. True to not include, false to include in INT.
70656>>>>>>>>>>>>>>>>>/// @Example
70656>>>>>>>>>>>>>>>>>/// Open Customer
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>///     Set_Attribute DF_FILE_GET_SCHEMANAME_FROM_LOGIN of Customer.File_Number to True
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>///     OUTPUT_INT_FILE for Customer.File_Number to "c:\temp\test.int"
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Close Customer
70656>>>>>>>>>>>>>>>>>Define DF_FILE_GET_SCHEMANAME_FROM_LOGIN            For (DF_FILE_RECORD_REREAD+33)
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//=============================================================================
70656>>>>>>>>>>>>>>>>>/// @Name        DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT
70656>>>>>>>>>>>>>>>>>/// @Description Use this attribute to specify whether the SCHEMA_NAME option will
70656>>>>>>>>>>>>>>>>>/// be included in the INT file.  If set to True, the SCHEMA_NAME option will not
70656>>>>>>>>>>>>>>>>>/// be included in the INT file, if set to false, the SCHEMA_NAME option will be
70656>>>>>>>>>>>>>>>>>/// included in the INT file. This has two uses. The first is during a Structure_Start
70656>>>>>>>>>>>>>>>>>/// i.e. table creation/modification. The other is when using the OUTPUT_INT_FILE
70656>>>>>>>>>>>>>>>>>/// command. Set this attribute before the OUTPUT_INT_FILE to indicate how the INT
70656>>>>>>>>>>>>>>>>>/// file will be written. This name indicates a backwards logic so take note that
70656>>>>>>>>>>>>>>>>>/// setting it to true will NOT include the SCHEMA_NAME in the INT file.
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Default Value: False
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Assumptions
70656>>>>>>>>>>>>>>>>>/// @Status      Public
70656>>>>>>>>>>>>>>>>>/// @Drivers     All
70656>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-01 by Aaron Gulack
70656>>>>>>>>>>>>>>>>>/// @See         DF_FILE_SUPPRESS_DATABASENAME_OUTPUT DF_FILE_SUPPRESS_SERVERNAME_OUTPUT
70656>>>>>>>>>>>>>>>>>/// @INTOPT              SCHEMA_NAME
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT of {FileNumber} to {variable}
70656>>>>>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT of {FileNumber} to {variable}
70656>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
70656>>>>>>>>>>>>>>>>>/// @Param  variable              Boolean variable. True to not include, false to include in INT.
70656>>>>>>>>>>>>>>>>>/// @Example
70656>>>>>>>>>>>>>>>>>/// Open Customer
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>///     Set_Attribute DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT of Customer.File_Number to True
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>///     OUTPUT_INT_FILE for Customer.File_Number to "c:\temp\test.int"
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Close Customer
70656>>>>>>>>>>>>>>>>>Define DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT           For DF_FILE_GET_SCHEMANAME_FROM_LOGIN
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//TODO
70656>>>>>>>>>>>>>>>>>Define DF_FILE_PRESERVE_RECNUM                      For 184
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>// Currently Unsupported Attribute
70656>>>>>>>>>>>>>>>>>Define DF_FILE_NATIVE_RECORD_LENGTH                 For 194
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//=============================================================================
70656>>>>>>>>>>>>>>>>>/// @Name        DF_FILE_OEM_TRANSLATION
70656>>>>>>>>>>>>>>>>>/// @Description There are two sets of code pages used in windows, ANSI and
70656>>>>>>>>>>>>>>>>>/// OEM. ANSI is what is commonly used now, but some data still uses the OEM
70656>>>>>>>>>>>>>>>>>/// code pages. When migrating data, this attribute is used to determine whether
70656>>>>>>>>>>>>>>>>>/// the OEM data will be translated to ANSI during the migration. For example,
70656>>>>>>>>>>>>>>>>>/// migrating passwords with special characters may call for different code pages.
70656>>>>>>>>>>>>>>>>>/// Setting this attribute to true will convert the OEM data to ANSI, setting it
70656>>>>>>>>>>>>>>>>>/// to false will not.
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Assumptions
70656>>>>>>>>>>>>>>>>>/// @Status      Public
70656>>>>>>>>>>>>>>>>>/// @Drivers     All
70656>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-15 by Aaron Gulack
70656>>>>>>>>>>>>>>>>>/// @See
70656>>>>>>>>>>>>>>>>>/// @INTOPT
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_OEM_TRANSLATION of {FileNumber} to {variable}
70656>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_OEM_TRANSLATION of {FileNumber} to {variable}
70656>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
70656>>>>>>>>>>>>>>>>>/// @Param  variable              Indicates if OEM data will be converted to ANSI. True converts it, false does not.
70656>>>>>>>>>>>>>>>>>/// @Example
70656>>>>>>>>>>>>>>>>>/// open Customer
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Handle hFile
70656>>>>>>>>>>>>>>>>>/// Boolean bTranslate
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Move Customer.File_Number to hFile
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Structure_Start hFile
70656>>>>>>>>>>>>>>>>>///     Set_Attribute DF_FILE_OEM_TRANSLATION of hFile to True
70656>>>>>>>>>>>>>>>>>///     Get_Attribute DF_FILE_OEM_TRANSLATION of hFile to bTranslate
70656>>>>>>>>>>>>>>>>>/// Structure_End hFile
70656>>>>>>>>>>>>>>>>>Define DF_FILE_OEM_TRANSLATION                      For (DF_FILE_RECORD_REREAD+51)
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//=============================================================================
70656>>>>>>>>>>>>>>>>>/// @Name        DF_FILE_EPOCH_YEAR
70656>>>>>>>>>>>>>>>>>/// @Description When dealing with two-digit years, an epoch year must be used
70656>>>>>>>>>>>>>>>>>/// to determine which century the date is referring to. For example if the
70656>>>>>>>>>>>>>>>>>/// epoch year is set to 30, then any two digit year greater than 30 will be
70656>>>>>>>>>>>>>>>>>/// considered in the 20th Century, anything less than or equal to 30 will be
70656>>>>>>>>>>>>>>>>>/// considered in the 21st Century.  This attribute is used to turn on or off
70656>>>>>>>>>>>>>>>>>/// this feature. To use this feature, set this attribute to whatever the epoch
70656>>>>>>>>>>>>>>>>>/// year is expected to be. To disable this feature, set this attribute to 0
70656>>>>>>>>>>>>>>>>>/// or false. Note that setting this attribute must be done at table creation
70656>>>>>>>>>>>>>>>>>/// or inside of a Structure_Start.
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Assumptions
70656>>>>>>>>>>>>>>>>>/// @Status      Public
70656>>>>>>>>>>>>>>>>>/// @Drivers     All
70656>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-15 by Aaron Gulack
70656>>>>>>>>>>>>>>>>>/// @See
70656>>>>>>>>>>>>>>>>>/// @INTOPT      EPOCH_YEAR
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_EPOCH_YEAR of {FileNumber} to {variable}
70656>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_EPOCH_YEAR of {FileNumber} to {variable}
70656>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
70656>>>>>>>>>>>>>>>>>/// @Param  variable              Indicates what the epoch year is. 0 to disable
70656>>>>>>>>>>>>>>>>>/// @Example
70656>>>>>>>>>>>>>>>>>/// open Customer
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Handle hFile
70656>>>>>>>>>>>>>>>>>/// Boolean bEpoch
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Move Customer.File_Number to hFile
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Structure_Start hFile
70656>>>>>>>>>>>>>>>>>///     Set_Attribute DF_FILE_EPOCH_YEAR of hFile to 30
70656>>>>>>>>>>>>>>>>>///     Get_Attribute DF_FILE_EPOCH_YEAR of hFile to bEpoch
70656>>>>>>>>>>>>>>>>>/// Structure_End hFile
70656>>>>>>>>>>>>>>>>>Define DF_FILE_EPOCH_YEAR                           For (DF_FILE_RECORD_REREAD+53)
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>Define DF_FILE_USE_ROWCOUNT_IN_TRANSACTIONS         For 628
70656>>>>>>>>>>>>>>>>>Define DF_FILE_ICF_STATUS                           For 630
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//=============================================================================
70656>>>>>>>>>>>>>>>>>/// @Name        DF_FILE_LOCK_RECORD_STATUS
70656>>>>>>>>>>>>>>>>>/// @Description Table locking is done during transactions to maintain atomicity.
70656>>>>>>>>>>>>>>>>>/// In DataFlex, this is usually done with the REREAD/UNLOCK commands. This
70656>>>>>>>>>>>>>>>>>/// attribute is used to get the status of a table lock. If a table is currently
70656>>>>>>>>>>>>>>>>>/// in a REREAD, or locked, then the attribute will return true. Otherwise, it
70656>>>>>>>>>>>>>>>>>/// returns false. It is a read-only attribute so no setting can be done.
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Assumptions
70656>>>>>>>>>>>>>>>>>/// @Status      Public
70656>>>>>>>>>>>>>>>>>/// @Drivers     All
70656>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-06 by Aaron Gulack
70656>>>>>>>>>>>>>>>>>/// @See
70656>>>>>>>>>>>>>>>>>/// @INTOPT
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_LOCK_RECORD_STATUS of {FileNumber} to {variable}
70656>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
70656>>>>>>>>>>>>>>>>>/// @Param  variable              Indicates the status of the file lock
70656>>>>>>>>>>>>>>>>>/// @Example
70656>>>>>>>>>>>>>>>>>/// open Customer
70656>>>>>>>>>>>>>>>>>/// Handle hFile
70656>>>>>>>>>>>>>>>>>/// Integer bLocked
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Move Customer.File_Number to hFile
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Get_Attribute DF_FILE_LOCK_RECORD_STATUS of hFile to bLocked
70656>>>>>>>>>>>>>>>>>Define DF_FILE_LOCK_RECORD_STATUS                   For 632
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//=============================================================================
70656>>>>>>>>>>>>>>>>>/// @Name        DF_FILE_CASING
70656>>>>>>>>>>>>>>>>>/// @Description Controls the filename and column name casing.
70656>>>>>>>>>>>>>>>>>/// You can set this to either keep the file case, force to lower case or force
70656>>>>>>>>>>>>>>>>>/// to uppercase.
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Assumptions
70656>>>>>>>>>>>>>>>>>/// @Status      Public
70656>>>>>>>>>>>>>>>>>/// @Drivers     All
70656>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2014-04-28 by Wil van Antwerpen
70656>>>>>>>>>>>>>>>>>/// @See
70656>>>>>>>>>>>>>>>>>/// @INTOPT
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_CASING of {FileNumber} to {FILE_CASING_KEEP|FILE_CASING_LOWER|FILE_CASING_UPPER}
70656>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_CASING of {FileNumber} to {variable}
70656>>>>>>>>>>>>>>>>>/// @Param  FileNumber          Number of the file
70656>>>>>>>>>>>>>>>>>/// @Param  variable              integer set to one of the above values.
70656>>>>>>>>>>>>>>>>>/// @Example
70656>>>>>>>>>>>>>>>>>/// open Customer
70656>>>>>>>>>>>>>>>>>/// Handle hFile
70656>>>>>>>>>>>>>>>>>/// Integer eCasing
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Move Customer.File_Number to hFile
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Structure_Start hFile "ORA_DRV"
70656>>>>>>>>>>>>>>>>>///    Set_Attribute DF_FILE_CASING of hFile to FILE_CASING_KEEP
70656>>>>>>>>>>>>>>>>>/// Structure_End hFile
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Get_Attribute DF_FILE_CASING of hFile to eCasing
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>Define DF_FILE_CASING                               For 634
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>Define DF_FIELD_INVERSE_KEY_NAME                    For (DF_FIELD_NATIVE_LENGTH+1)
70656>>>>>>>>>>>>>>>>>Define DF_FIELD_INVERSE_KEY_TYPE                    For (DF_FIELD_NATIVE_LENGTH+2)
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//TODO
70656>>>>>>>>>>>>>>>>>Define DF_FIELD_TEXT_SEGMENT_NAME                   For (DF_FIELD_NATIVE_LENGTH+3)
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//TODO
70656>>>>>>>>>>>>>>>>>Define DF_FIELD_TEXT_NUM_SEGMENTS                   For (DF_FIELD_NATIVE_LENGTH+4)
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//=============================================================================
70656>>>>>>>>>>>>>>>>>/// @Name        DF_FIELD_DEFAULT_VALUE
70656>>>>>>>>>>>>>>>>>/// @Description Use this attribute to get or set the default value for a given column.
70656>>>>>>>>>>>>>>>>>/// Setting the default value can only be done during a structure_start or during table
70656>>>>>>>>>>>>>>>>>/// creation. If this attribute is not set, it is defaulted to the driver default.
70656>>>>>>>>>>>>>>>>>/// See Mertech.cfg
70656>>>>>>>>>>>>>>>>>/// @Assumptions
70656>>>>>>>>>>>>>>>>>/// @Status      Public
70656>>>>>>>>>>>>>>>>>/// @Drivers     All
70656>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-06 by Aaron Gulack
70656>>>>>>>>>>>>>>>>>/// @See
70656>>>>>>>>>>>>>>>>>/// @INTOPT
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FIELD_DEFAULT_VALUE of {FileNumber} {FieldNumber} to {variable}
70656>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FIELD_DEFAULT_VALUE of {FileNumber} {FieldNumber} to {variable}
70656>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
70656>>>>>>>>>>>>>>>>>/// @Param  FieldNumber           Number of the field
70656>>>>>>>>>>>>>>>>>/// @Param  variable              Variable for the default value of the field
70656>>>>>>>>>>>>>>>>>/// @Example
70656>>>>>>>>>>>>>>>>>/// open Customer
70656>>>>>>>>>>>>>>>>>/// String sDefault
70656>>>>>>>>>>>>>>>>>/// Handle hFile
70656>>>>>>>>>>>>>>>>>/// Integer iColumn
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Move "California" to sDefault
70656>>>>>>>>>>>>>>>>>/// Move Customer.File_Number to hFile
70656>>>>>>>>>>>>>>>>>/// Move 3 to iColumn
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Structure_Start hFile "ORA_DRV"
70656>>>>>>>>>>>>>>>>>///    Set_Attribute DF_FIELD_DEFAULT_VALUE of hFile iColumn to sDefault
70656>>>>>>>>>>>>>>>>>/// Structure_End hFile
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Get_Attribute DF_FIELD_DEFAULT_VALUE of hFile iColumn to sDefault
70656>>>>>>>>>>>>>>>>>Define DF_FIELD_DEFAULT_VALUE                       For (DF_FIELD_NATIVE_LENGTH+5)
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>// Currently Unsupported Attribute
70656>>>>>>>>>>>>>>>>>Define DF_FIELD_TEXT_LENGTH_SEGMENT                 For (DF_FIELD_NATIVE_LENGTH+6)
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//TODO
70656>>>>>>>>>>>>>>>>>//=============================================================================
70656>>>>>>>>>>>>>>>>>/// @Name        DF_FIELD_TIME_ON
70656>>>>>>>>>>>>>>>>>/// @Description Assign a field to retrieve Time Stamp value from a DATETIME
70656>>>>>>>>>>>>>>>>>/// column in a table.
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// This option was implemented because some versions of DataFlex do not support
70656>>>>>>>>>>>>>>>>>/// DATETIME fields normally supported by SQL databases.
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// To use this: Change the type of a date field in your FD to string type,
70656>>>>>>>>>>>>>>>>>/// Set the attribute DF_FIELD_TIME_ON of this field to TRUE and
70656>>>>>>>>>>>>>>>>>/// recompile your program.
70656>>>>>>>>>>>>>>>>>/// @Assumptions
70656>>>>>>>>>>>>>>>>>/// @Status      Public
70656>>>>>>>>>>>>>>>>>/// @Drivers     All
70656>>>>>>>>>>>>>>>>>/// @VersionNote
70656>>>>>>>>>>>>>>>>>/// @See
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FIELD_TIME_ON of <FileNumber|FileName FieldNumber> to DFTRUE | DFFALSE
70656>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
70656>>>>>>>>>>>>>>>>>/// @Param  FileName              Name of the file
70656>>>>>>>>>>>>>>>>>/// @Param  FieldNumber           Number of the field
70656>>>>>>>>>>>>>>>>>/// @Example
70656>>>>>>>>>>>>>>>>>/// #INCLUDE MERTECH.INC
70656>>>>>>>>>>>>>>>>>/// string sDateTime sDatabaseName
70656>>>>>>>>>>>>>>>>>/// open ORDERHEA
70656>>>>>>>>>>>>>>>>>/// Set_Attribute DF_FIELD_TIME_ON of 30 3 to dfTrue
70656>>>>>>>>>>>>>>>>>/// find GE ORDERHEA by recnum
70656>>>>>>>>>>>>>>>>>/// move ORDERHEA.ORDER_DATE to sDateTime
70656>>>>>>>>>>>>>>>>>/// showln "sDateTime: " sDateTime
70656>>>>>>>>>>>>>>>>>Define DF_FIELD_TIME_ON                             For (DF_FIELD_NATIVE_LENGTH+8)
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//=============================================================================
70656>>>>>>>>>>>>>>>>>/// @Name        DF_FIELD_NATIVE_NAME
70656>>>>>>>>>>>>>>>>>/// @Description This attribute is used to get the name of the desired column
70656>>>>>>>>>>>>>>>>>/// on the SQL backend. Currently this attribute is ReadOnly and so setting
70656>>>>>>>>>>>>>>>>>/// or modifying a column name cannot be done using this attribute.  In most
70656>>>>>>>>>>>>>>>>>/// cases, the field name on the SQL backend will be the same as the Dataflex name.
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// This is a ReadOnly attribute.
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Assumptions
70656>>>>>>>>>>>>>>>>>/// @Status      Public
70656>>>>>>>>>>>>>>>>>/// @Drivers     All
70656>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-09 by Aaron Gulack
70656>>>>>>>>>>>>>>>>>/// @See
70656>>>>>>>>>>>>>>>>>/// @INTOPT
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FIELD_NATIVE_NAME of {FileNumber} {FieldNumber} to {variable}
70656>>>>>>>>>>>>>>>>>/// @Param  FileNumber          Number of the file
70656>>>>>>>>>>>>>>>>>/// @Param  FieldNumber                 Number of the Field
70656>>>>>>>>>>>>>>>>>/// @Param  variable                    String containing the name of the field
70656>>>>>>>>>>>>>>>>>/// @Example
70656>>>>>>>>>>>>>>>>>/// Open Customer
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// String sName
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Get_Attribute DF_FIELD_NATIVE_NAME of Customer.File_Number 3 to sName
70656>>>>>>>>>>>>>>>>>Define DF_FIELD_NATIVE_NAME                         For (DF_FIELD_NATIVE_LENGTH+9)
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//=============================================================================
70656>>>>>>>>>>>>>>>>>/// @Name        DF_FIELD_NULL
70656>>>>>>>>>>>>>>>>>/// @Description Use this attribute to get or set whether a column in a table will
70656>>>>>>>>>>>>>>>>>/// allow null values. When set to true, the column accepts null values. Setting
70656>>>>>>>>>>>>>>>>>/// this attribute to false will keep it from accepting null values. Although,
70656>>>>>>>>>>>>>>>>>/// getting the value of this attribute can be done at anytime, setting it must
70656>>>>>>>>>>>>>>>>>/// be done in a Structure_Start or during table creation.
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Assumptions
70656>>>>>>>>>>>>>>>>>/// @Status      Public
70656>>>>>>>>>>>>>>>>>/// @Drivers     All
70656>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-09 by Aaron Gulack
70656>>>>>>>>>>>>>>>>>/// @See
70656>>>>>>>>>>>>>>>>>/// @INTOPT
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FIELD_NULL of {FileNumber} {FieldNumber} to {variable}
70656>>>>>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FIELD_NULL of {FileNumber} {FieldNumber} to {variable}
70656>>>>>>>>>>>>>>>>>/// @Param  FileNumber          Number of the file
70656>>>>>>>>>>>>>>>>>/// @Param  FieldNumber                 Number of the Field
70656>>>>>>>>>>>>>>>>>/// @Param  variable                    Boolean variable
70656>>>>>>>>>>>>>>>>>/// @Example
70656>>>>>>>>>>>>>>>>>/// Open Customer
70656>>>>>>>>>>>>>>>>>/// Handle hFile
70656>>>>>>>>>>>>>>>>>/// Integer iColumn
70656>>>>>>>>>>>>>>>>>/// Boolean bAllowNull
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Move Customer.File_Number to hFile
70656>>>>>>>>>>>>>>>>>/// Move 3 to iColumn
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Structure_Start hFile "ORA_DRV"
70656>>>>>>>>>>>>>>>>>///    Set_Attribute DF_FIELD_NULL of hFile iColumn to True
70656>>>>>>>>>>>>>>>>>/// Structure_End hFile
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Get_Attribute DF_FIELD_NULL of hFile iColumn to bAllowNull
70656>>>>>>>>>>>>>>>>>Define DF_FIELD_NULL                                For (DF_FIELD_NATIVE_LENGTH+10)
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//=============================================================================
70656>>>>>>>>>>>>>>>>>/// @Name        DF_FIELD_NATIVE_TYPE
70656>>>>>>>>>>>>>>>>>/// @Description Use this attribute to get or set the Native type for a specific
70656>>>>>>>>>>>>>>>>>/// field in a table.  The native type refers to the data type of the field on the
70656>>>>>>>>>>>>>>>>>/// SQL backend. Setting this attribute can only be done during table creation or
70656>>>>>>>>>>>>>>>>>/// inside of a Structure_Start. When setting this attribute, it is good practice
70656>>>>>>>>>>>>>>>>>/// to use the constants mentioned below instead of the integers. For a list of
70656>>>>>>>>>>>>>>>>>/// these constants, refer to the sections: "Oracle Data Types", "MySQL Data Types",
70656>>>>>>>>>>>>>>>>>/// "PostgreSQL Data Types", and "SQL Server Data Types" included in this document.
70656>>>>>>>>>>>>>>>>>/// Note that when getting the value for this attribute, an integer will be returned
70656>>>>>>>>>>>>>>>>>/// so these lists of constants can again prove useful.
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Assumptions
70656>>>>>>>>>>>>>>>>>/// @Status      Public
70656>>>>>>>>>>>>>>>>>/// @Drivers     All
70656>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-09 by Aaron Gulack
70656>>>>>>>>>>>>>>>>>/// @See
70656>>>>>>>>>>>>>>>>>/// @INTOPT      FIELD_TYPE
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FIELD_NATIVE_TYPE of {FileNumber} {FieldNumber} to {variable}
70656>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FIELD_NATIVE_TYPE of {FileNumber} {FieldNumber} to {variable}
70656>>>>>>>>>>>>>>>>>/// @Param  FileNumber          Number of the file
70656>>>>>>>>>>>>>>>>>/// @Param  FieldNumber         Number of the field
70656>>>>>>>>>>>>>>>>>/// @Param  variable                    variable for the native data type
70656>>>>>>>>>>>>>>>>>/// @Example
70656>>>>>>>>>>>>>>>>>/// open Customer
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Integer iColumn iType
70656>>>>>>>>>>>>>>>>>/// Handle hFile
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Move Customer.File_Number to hFile
70656>>>>>>>>>>>>>>>>>/// Structure_Start hFile
70656>>>>>>>>>>>>>>>>>///     Set_Attribute DF_FIELD_NATIVE_TYPE of hFile iColumn to "eSQLServer_DATE"
70656>>>>>>>>>>>>>>>>>///     Get_Attribute DF_FIELD_NATIVE_TYPE of hFile iColumn to iType
70656>>>>>>>>>>>>>>>>>///     Structure_End hFile
70656>>>>>>>>>>>>>>>>>Define DF_FIELD_NATIVE_TYPE                         For (DF_FIELD_NATIVE_LENGTH+12)
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>// Currently Unsupported Attribute (readOnly used by DataFlex 18.0 Studio)
70656>>>>>>>>>>>>>>>>>Define DF_FIELD_NATIVE_TYPE_NAME                    For 711
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>// Currently Unsupported Attribute
70656>>>>>>>>>>>>>>>>>Define DF_FIELD_NATIVE_OFFSET                       For (DF_FIELD_NATIVE_LENGTH+14)
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//=============================================================================
70656>>>>>>>>>>>>>>>>>/// @Name        DF_FIELD_AUTO_INCREMENT
70656>>>>>>>>>>>>>>>>>/// @Description Auto incrementing is a technique used in Dataflex usually for
70656>>>>>>>>>>>>>>>>>/// fields that are set as the unique identifier. Instead of generating a value
70656>>>>>>>>>>>>>>>>>/// or manually inserting data into the column, when a field auto increments,
70656>>>>>>>>>>>>>>>>>/// the value of the field increases by one (usually) with each record.  This
70656>>>>>>>>>>>>>>>>>/// field is used to get or set whether the field uses this technique or not.
70656>>>>>>>>>>>>>>>>>/// The attribute, however, can only be set inside of a Structure_Start or during
70656>>>>>>>>>>>>>>>>>/// table creation. Getting the attribute's value can be done at anytime. The
70656>>>>>>>>>>>>>>>>>/// value is stored as a boolean, either true or false.
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Assumptions
70656>>>>>>>>>>>>>>>>>/// @Status      Public
70656>>>>>>>>>>>>>>>>>/// @Drivers     All
70656>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-12 by Aaron Gulack
70656>>>>>>>>>>>>>>>>>/// @See
70656>>>>>>>>>>>>>>>>>/// @INTOPT      FIELD_AUTOINCREMENT_TYPE
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FIELD_AUTO_INCREMENT of {FileNumber} {FieldNumber} to {variable}
70656>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FIELD_AUTO_INCREMENT of {FileNumber} {FieldNumber} to {variable}
70656>>>>>>>>>>>>>>>>>/// @Param  FileNumber          Number of the file
70656>>>>>>>>>>>>>>>>>/// @Param  FieldNumber         Number of the field
70656>>>>>>>>>>>>>>>>>/// @Param  variable                    Boolean variable indicating if the field auto increments.
70656>>>>>>>>>>>>>>>>>/// @Example
70656>>>>>>>>>>>>>>>>>/// open Customer
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Integer iColumn
70656>>>>>>>>>>>>>>>>>/// Boolean bIncrement
70656>>>>>>>>>>>>>>>>>/// Handle hFile
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Move Customer.File_Number to hFile
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Structure_Start hFile
70656>>>>>>>>>>>>>>>>>///     Set_Attribute DF_FIELD_AUTO_INCREMENT of hFile iColumn to True
70656>>>>>>>>>>>>>>>>>///     Get_Attribute DF_FIELD_AUTO_INCREMENT of hFile iColumn to bIncrement
70656>>>>>>>>>>>>>>>>>///     Structure_End hFile
70656>>>>>>>>>>>>>>>>>Define DF_FIELD_AUTO_INCREMENT                      For (DF_FIELD_NATIVE_LENGTH+16)
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//Currently Unsupported Attribute
70656>>>>>>>>>>>>>>>>>Define DF_FIELD_GENERATE_ALWAYS                     For (DF_FIELD_NATIVE_LENGTH+18)
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>// Currently Unsupported Attribute
70656>>>>>>>>>>>>>>>>>Define DF_FIELD_SEND_LONG_DATA                      For 702
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//=============================================================================
70656>>>>>>>>>>>>>>>>>/// @Name        DF_INDEX_NATIVE_CREATED
70656>>>>>>>>>>>>>>>>>/// @Description Use this attribute to verify if the index that maps to the DataFlex
70656>>>>>>>>>>>>>>>>>/// index was created correctly at the SQL backend
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// This is a ReadOnly attribute
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Assumptions
70656>>>>>>>>>>>>>>>>>/// @Status      Public
70656>>>>>>>>>>>>>>>>>/// @Drivers     All
70656>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2014-04-30 by Wil van Antwerpen
70656>>>>>>>>>>>>>>>>>/// @See
70656>>>>>>>>>>>>>>>>>/// @INTOPT
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_INDEX_NATIVE_CREATED of {FileNumber} {IndexNumber} to variable
70656>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
70656>>>>>>>>>>>>>>>>>/// @Param  IndexNumber           Number of the index
70656>>>>>>>>>>>>>>>>>/// @Param  variable              True if created, false if not
70656>>>>>>>>>>>>>>>>>/// @Example
70656>>>>>>>>>>>>>>>>>/// Open Customer
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Handle  hFile
70656>>>>>>>>>>>>>>>>>/// Integer iIndex
70656>>>>>>>>>>>>>>>>>/// Boolean bCreated
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Move Customer.File_Number to hFile
70656>>>>>>>>>>>>>>>>>/// Move 1 To iIndex
70656>>>>>>>>>>>>>>>>>/// Get_Attribute DF_INDEX_NATIVE_CREATED of hFile iIndex to bCreated
70656>>>>>>>>>>>>>>>>>Define DF_INDEX_NATIVE_CREATED                      For (DF_INDEX_KEY_LENGTH+1)
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//=============================================================================
70656>>>>>>>>>>>>>>>>>/// @Name        DF_INDEX_NAME
70656>>>>>>>>>>>>>>>>>/// @Description Use this attribute to get the name of the index on the SQL backend
70656>>>>>>>>>>>>>>>>>/// that maps to the numbered index in Dataflex.  This is because, unlike Dataflex,
70656>>>>>>>>>>>>>>>>>/// all indexes in SQL are stored as names, not numbers. Since this attribute is
70656>>>>>>>>>>>>>>>>>/// currently only a ReadOnly attribute, it can not be used to set or modify a named
70656>>>>>>>>>>>>>>>>>/// index.
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// This is a ReadOnly attribute
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Assumptions
70656>>>>>>>>>>>>>>>>>/// @Status      Public
70656>>>>>>>>>>>>>>>>>/// @Drivers     All
70656>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-09 by Aaron Gulack
70656>>>>>>>>>>>>>>>>>/// @See
70656>>>>>>>>>>>>>>>>>/// @INTOPT
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_INDEX_NAME of {FileNumber} {IndexNumber} to variable
70656>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
70656>>>>>>>>>>>>>>>>>/// @Param  IndexNumber           Number of the index
70656>>>>>>>>>>>>>>>>>/// @Param  variable              Name of the index
70656>>>>>>>>>>>>>>>>>/// @Example
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Integer iFile iIndex iIndexes
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Open Orderhea
70656>>>>>>>>>>>>>>>>>/// Move Orderhea.File_Number to iFile
70656>>>>>>>>>>>>>>>>>/// Get_Attribute DF_FILE_LAST_INDEX_NUMBER of iFile to iIndexes
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// For iIndex From 0 to iIndexes
70656>>>>>>>>>>>>>>>>>///     Get_Attribute DF_INDEX_NAME of iFile iIndex to sIndexName
70656>>>>>>>>>>>>>>>>>///     Showln "Orderhea.Index." iIndex " : " sIndexName
70656>>>>>>>>>>>>>>>>>/// Loop
70656>>>>>>>>>>>>>>>>>Define DF_INDEX_NAME                                For (DF_INDEX_KEY_LENGTH+2)
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//=============================================================================
70656>>>>>>>>>>>>>>>>>/// @Name        DF_PRIMARY_KEY
70656>>>>>>>>>>>>>>>>>/// @Description This attribute is used to get or set the index number
70656>>>>>>>>>>>>>>>>>/// being used for the primary key. Getting the index number can be
70656>>>>>>>>>>>>>>>>>/// done at any time, but setting the index must be during a
70656>>>>>>>>>>>>>>>>>/// Structure_Start or during table creation.
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Assumptions
70656>>>>>>>>>>>>>>>>>/// @Status      Deprecated
70656>>>>>>>>>>>>>>>>>/// @Drivers     All
70656>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-09 by Aaron Gulack
70656>>>>>>>>>>>>>>>>>/// @See                 DF_INDEX_PRIMARY_KEY
70656>>>>>>>>>>>>>>>>>/// @INTOPT
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_PRIMARY_KEY of {FileNumber} to {variable}
70656>>>>>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_PRIMARY_KEY of {FileNumber} to {variable}
70656>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
70656>>>>>>>>>>>>>>>>>/// @Param  variable              Index number being used with primary key
70656>>>>>>>>>>>>>>>>>/// @Example
70656>>>>>>>>>>>>>>>>>/// Open Customer
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Integer iKey
70656>>>>>>>>>>>>>>>>>/// Handle hFile
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Move Customer.File_Number to hFile
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Structure_Start hFile
70656>>>>>>>>>>>>>>>>>///     Set_Attribute DF_PRIMARY_KEY of hFile to 2
70656>>>>>>>>>>>>>>>>>///     Get_Attribute DF_PRIMARY_KEY of hFile to iKey
70656>>>>>>>>>>>>>>>>>/// Structure_End hFile
70656>>>>>>>>>>>>>>>>>Define DF_PRIMARY_KEY                               For (DF_INDEX_KEY_LENGTH+3)
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//=============================================================================
70656>>>>>>>>>>>>>>>>>/// @Name        DF_INDEX_PRIMARY_KEY
70656>>>>>>>>>>>>>>>>>/// @Description This attribute is used to get or set the index number
70656>>>>>>>>>>>>>>>>>/// being used for the primary key. Getting the index number can be
70656>>>>>>>>>>>>>>>>>/// done at any time, but setting the index must be during a
70656>>>>>>>>>>>>>>>>>/// Structure_Start or during table creation.
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Assumptions
70656>>>>>>>>>>>>>>>>>/// @Status      Public
70656>>>>>>>>>>>>>>>>>/// @Drivers     All
70656>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-09 by Aaron Gulack
70656>>>>>>>>>>>>>>>>>/// @See
70656>>>>>>>>>>>>>>>>>/// @INTOPT              PRIMARY_KEY
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_INDEX_PRIMARY_KEY of {FileNumber} to {variable}
70656>>>>>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_INDEX_PRIMARY_KEY of {FileNumber} to {variable}
70656>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
70656>>>>>>>>>>>>>>>>>/// @Param  variable              Index number being used with primary key
70656>>>>>>>>>>>>>>>>>/// @Example
70656>>>>>>>>>>>>>>>>>/// Open Customer
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Integer iKey
70656>>>>>>>>>>>>>>>>>/// Handle hFile
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Move Customer.File_Number to hFile
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Structure_Start hFile
70656>>>>>>>>>>>>>>>>>///     Set_Attribute DF_INDEX_PRIMARY_KEY of hFile to 2
70656>>>>>>>>>>>>>>>>>///     Get_Attribute DF_INDEX_PRIMARY_KEY of hFile to iKey
70656>>>>>>>>>>>>>>>>>/// Structure_End hFile
70656>>>>>>>>>>>>>>>>>Define DF_INDEX_PRIMARY_KEY                         For (DF_INDEX_KEY_LENGTH+3)
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//=============================================================================
70656>>>>>>>>>>>>>>>>>/// @Name        DF_INDEX_STATUS
70656>>>>>>>>>>>>>>>>>/// @Description Oracle has an attribute for indexes called "STATUS" which indicates
70656>>>>>>>>>>>>>>>>>/// whether or not an index is valid for use. This attribute can only be used to get
70656>>>>>>>>>>>>>>>>>/// the value of the "STATUS" property in Oracle. It currently does not support setting
70656>>>>>>>>>>>>>>>>>/// the attribute. The two values for this attribute are "VALID" or "UNUSABLE".
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// This is a ReadOnly attribute
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Assumptions
70656>>>>>>>>>>>>>>>>>/// @Status      Public
70656>>>>>>>>>>>>>>>>>/// @Drivers     ORAFlex
70656>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-09 by Aaron Gulack
70656>>>>>>>>>>>>>>>>>/// @See
70656>>>>>>>>>>>>>>>>>/// @INTOPT
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_INDEX_STATUS of {FileNumber} {IndexNumber} to {variable}
70656>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
70656>>>>>>>>>>>>>>>>>/// @Param  FieldNumber           Number of the index
70656>>>>>>>>>>>>>>>>>/// @Param  variable              String indicating validity
70656>>>>>>>>>>>>>>>>>/// @Example
70656>>>>>>>>>>>>>>>>>/// Open Customer
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// String sIndexStatus
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Get_Attribute DF_INDEX_STATUS of Customer.File_Number 1 to sIndexStatus
70656>>>>>>>>>>>>>>>>>Define DF_INDEX_STATUS                              For (DF_INDEX_KEY_LENGTH+4)
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//Currently Unsupported Attribute
70656>>>>>>>>>>>>>>>>>Define DF_INDEX_STORAGE_PCTFREE                     For (DF_INDEX_KEY_LENGTH+5)
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//=============================================================================
70656>>>>>>>>>>>>>>>>>/// @Name        DF_INDEX_UNIQUE
70656>>>>>>>>>>>>>>>>>/// @Description An index on a column that is unique is considered so if it
70656>>>>>>>>>>>>>>>>>/// does not have two equal values in that column in two different rows. This
70656>>>>>>>>>>>>>>>>>/// attribute is used to find out whether or not the specified index is unique.
70656>>>>>>>>>>>>>>>>>/// If it is, this attribute will return "U" indicating that it is indeed unique.
70656>>>>>>>>>>>>>>>>>/// This is important to note because when getting the value of this attribute,
70656>>>>>>>>>>>>>>>>>/// a string variable must be used. Since this is a ReadOnly attribute, setting
70656>>>>>>>>>>>>>>>>>/// an idex to unique cannot be done with this attribute.
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Assumptions
70656>>>>>>>>>>>>>>>>>/// @Status      Public
70656>>>>>>>>>>>>>>>>>/// @Drivers     All
70656>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-14 by Aaron Gulack
70656>>>>>>>>>>>>>>>>>/// @See
70656>>>>>>>>>>>>>>>>>/// @INTOPT
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_INDEX_UNIQUE of {FileNumber} {IndexNumber} to {variable}
70656>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
70656>>>>>>>>>>>>>>>>>/// @Param  FieldNumber           Number of the index
70656>>>>>>>>>>>>>>>>>/// @Param  variable              String indicating if unique
70656>>>>>>>>>>>>>>>>>/// @Example
70656>>>>>>>>>>>>>>>>>/// Open Customer
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// String sIndexUnique
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Get_Attribute DF_INDEX_UNIQUE of Customer.File_Number 1 to sIndexUnique
70656>>>>>>>>>>>>>>>>>Define DF_INDEX_UNIQUE                              For (DF_INDEX_KEY_LENGTH+6)
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//Currently Unsupported Attribute
70656>>>>>>>>>>>>>>>>>Define DF_INDEX_STORAGE_BASE                        For (DF_INDEX_KEY_LENGTH+7)
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//Currently Unsupported Attribute
70656>>>>>>>>>>>>>>>>>Define DF_INDEX_STORAGE_INITIAL                     For (DF_INDEX_KEY_LENGTH+8)
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//Currently Unsupported Attribute
70656>>>>>>>>>>>>>>>>>Define DF_INDEX_STORAGE_NEXT                        For (DF_INDEX_KEY_LENGTH+10)
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//Currently Unsupported Attribute
70656>>>>>>>>>>>>>>>>>Define DF_INDEX_NATIVE_TYPE                         For (DF_INDEX_KEY_LENGTH+13)
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//TODO
70656>>>>>>>>>>>>>>>>>Define DF_INDEX_TABLESPACE                          For (DF_INDEX_KEY_LENGTH+14)
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//TODO
70656>>>>>>>>>>>>>>>>>Define DF_FIELD_PROGRAMMATIC_DEFAULT                For 701
70656>>>>>>>>>>>>>>>>>Define DF_FIELD_TIME                                For 703
70656>>>>>>>>>>>>>>>>>Define DF_FIELD_IS_NULL                             For 704
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//=============================================================================
70656>>>>>>>>>>>>>>>>>/// @Name        DF_FIELD_IS_LOB
70656>>>>>>>>>>>>>>>>>/// @Description In databases a LOB data type is any type that is considered
70656>>>>>>>>>>>>>>>>>/// a "Large Object" i.e. XML types, Binary types etc.  This attribute is a
70656>>>>>>>>>>>>>>>>>/// ReadOnly attribute used to indicate whether the given field is considered
70656>>>>>>>>>>>>>>>>>/// a LOB data type. Since it is ReadOnly, this attribute cannot set a field
70656>>>>>>>>>>>>>>>>>/// to a LOB data type.
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Assumptions
70656>>>>>>>>>>>>>>>>>/// @Status      Public
70656>>>>>>>>>>>>>>>>>/// @Drivers     All
70656>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-13 by Aaron Gulack
70656>>>>>>>>>>>>>>>>>/// @See
70656>>>>>>>>>>>>>>>>>/// @INTOPT
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FIELD_IS_LOB of {FileNumber} {FieldNumber} to {variable}
70656>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
70656>>>>>>>>>>>>>>>>>/// @Param      FieldNumber                       Number of the field
70656>>>>>>>>>>>>>>>>>/// @Param  variable              Boolean variable indicating if LOB
70656>>>>>>>>>>>>>>>>>/// @Example
70656>>>>>>>>>>>>>>>>>/// Open Customer
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Boolean bIsLOB
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Get_Attribute DF_FIELD_IS_LOB of Customer.File_Number 6 to bIsLOB
70656>>>>>>>>>>>>>>>>>Define DF_FIELD_IS_LOB                              For 706
70656>>>>>>>>>>>>>>>>>Define DF_FIELD_DEFAULT_FUNCTION                    For 707
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//Currently Unsupported Attribute
70656>>>>>>>>>>>>>>>>>Define DF_FIELD_HANDLE_AS_LOB                       For 708
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//TODO
70656>>>>>>>>>>>>>>>>>Define DF_FIELD_PARTIAL_OVERLAP                     For 710
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//=============================================================================
70656>>>>>>>>>>>>>>>>>/// @Name        DF_FILE_NUMBER_SQL_RELATIONS
70656>>>>>>>>>>>>>>>>>/// @Description This attribute is used to get the number of foreign keys
70656>>>>>>>>>>>>>>>>>/// for a given table on the SQL backend. Foreign keys are used to specify
70656>>>>>>>>>>>>>>>>>/// relationships between tables. Since this attribute is ReadOnly, it cannot
70656>>>>>>>>>>>>>>>>>/// be used to set the number of foreign keys in a table.  Note that this
70656>>>>>>>>>>>>>>>>>/// attribute returns only the number of foreign keys, no other information
70656>>>>>>>>>>>>>>>>>/// is provided with this attribute.
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// This is a ReadOnly attribute
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Assumptions
70656>>>>>>>>>>>>>>>>>/// @Status      Public
70656>>>>>>>>>>>>>>>>>/// @Drivers     All
70656>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-13 by Aaron Gulack
70656>>>>>>>>>>>>>>>>>/// @See
70656>>>>>>>>>>>>>>>>>/// @INTOPT
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_NUMBER_SQL_RELATIONS of {FileNumber} to {variable}
70656>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
70656>>>>>>>>>>>>>>>>>/// @Param  variable              Integer variable showing number of relationships
70656>>>>>>>>>>>>>>>>>/// @Example
70656>>>>>>>>>>>>>>>>>/// Open Customer
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Integer iRelations
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Get_Attribute DF_FILE_NUMBER_SQL_RELATIONS of Customer.File_Number to iRelations
70656>>>>>>>>>>>>>>>>>Define DF_FILE_NUMBER_SQL_RELATIONS                 For 626
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//TODO
70656>>>>>>>>>>>>>>>>>Define DF_SQL_RELATION_COLUMN                       For 716
70656>>>>>>>>>>>>>>>>>Define DF_SQL_RELATION_RELATED_SCHEMA               For 717
70656>>>>>>>>>>>>>>>>>Define DF_SQL_RELATION_RELATED_TABLE                For 719
70656>>>>>>>>>>>>>>>>>Define DF_SQL_RELATION_RELATED_COLUMN               For 721
70656>>>>>>>>>>>>>>>>>Define DF_SQL_RELATION_NAME                         For 723
70656>>>>>>>>>>>>>>>>>Define DF_SQL_RELATION_STATUS                       For 724
70656>>>>>>>>>>>>>>>>>Define DF_SQL_RELATION_DELETE_REF_ACTION            For 726
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//Currently Unsupported Attribute
70656>>>>>>>>>>>>>>>>>Define DF_FIELD_OVERLAP_START                       For 728
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//Currently Unsupported Attribute
70656>>>>>>>>>>>>>>>>>Define DF_FIELD_OVERLAP_END                         For 730
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//Currently Unsupported Attribute
70656>>>>>>>>>>>>>>>>>Define DF_FIELD_OVERLAP_OFFSET_START                For 732
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//Currently Unsupported Attribute
70656>>>>>>>>>>>>>>>>>Define DF_FIELD_OVERLAP_OFFSET_END                  For 734
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//=============================================================================
70656>>>>>>>>>>>>>>>>>/// @Name        DF_FILE_RECNUM_TABLE
70656>>>>>>>>>>>>>>>>>/// @Description Dataflex's embedded database, by default, uses a Recnum column
70656>>>>>>>>>>>>>>>>>/// as the unique identifier for a table instead of a primary key. A table can
70656>>>>>>>>>>>>>>>>>/// easily be changed to use another column though and this attribute gets or
70656>>>>>>>>>>>>>>>>>/// sets whether the Recnum is being used for a table. Getting the value of this
70656>>>>>>>>>>>>>>>>>/// attribute can be done at any time for any driver. The setting of this attribute,
70656>>>>>>>>>>>>>>>>>/// however, can only be done in certain situations. Only if an alternative primary
70656>>>>>>>>>>>>>>>>>/// key is set up already can this attribute be set to false and only during a
70656>>>>>>>>>>>>>>>>>/// Structure_Start. Also, the attribute can only be turned off (set to false),
70656>>>>>>>>>>>>>>>>>/// it can not be turned back on (set to True).
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Note: In Postgres, this attribute is a ReadOnly attribute and can not be set.
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Assumptions
70656>>>>>>>>>>>>>>>>>/// @Status      Public (PGFlex ReadOnly)
70656>>>>>>>>>>>>>>>>>/// @Drivers     All
70656>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-12 by Aaron Gulack
70656>>>>>>>>>>>>>>>>>/// @See                 DF_FILE_RECNUM_NAME DF_FILE_PRIMARY_INDEX
70656>>>>>>>>>>>>>>>>>/// @INTOPT
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_RECNUM_TABLE of {FileNumber} to {variable}
70656>>>>>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_RECNUM_TABLE of {FileNumber} to {variable}
70656>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
70656>>>>>>>>>>>>>>>>>/// @Param  variable              Boolean variable indicating if recnum is used
70656>>>>>>>>>>>>>>>>>/// @Example
70656>>>>>>>>>>>>>>>>>/// Open Customer
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Boolean bRecnum
70656>>>>>>>>>>>>>>>>>/// Handle hFile
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Move Customer.File_Number to hFile
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Structure_Start hFile
70656>>>>>>>>>>>>>>>>>///     Set_Attribute DF_FILE_RECNUM_TABLE of Customer.File_Number to False
70656>>>>>>>>>>>>>>>>>///     Get_Attribute DF_FILE_RECNUM_TABLE of Customer.File_Number to bRecnum
70656>>>>>>>>>>>>>>>>>/// Structure_End hFile
70656>>>>>>>>>>>>>>>>>Define DF_FILE_RECNUM_TABLE                         For 1401
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//=============================================================================
70656>>>>>>>>>>>>>>>>>/// @Name        DF_FILE_PRIMARY_INDEX
70656>>>>>>>>>>>>>>>>>/// @Description This attribute gets or sets the index which is used as the
70656>>>>>>>>>>>>>>>>>/// primary key for a table. The variable used for this attribute is an integer
70656>>>>>>>>>>>>>>>>>/// containing the numbered index used. Getting the value of this attribute can
70656>>>>>>>>>>>>>>>>>/// be done at any time, whereas setting can only be done at table creation or
70656>>>>>>>>>>>>>>>>>/// during a Structure_Start. If a RECNUM is used as the unique identifier then
70656>>>>>>>>>>>>>>>>>/// 0 is returned.
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Note: In Postgres this attribute is ReadOnly, so it can only be used to get
70656>>>>>>>>>>>>>>>>>/// the index used as the primary key.
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Assumptions
70656>>>>>>>>>>>>>>>>>/// @Status      Public (PGFlex ReadOnly)
70656>>>>>>>>>>>>>>>>>/// @Drivers     All
70656>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-12 by Aaron Gulack
70656>>>>>>>>>>>>>>>>>/// @See                 DF_FILE_RECNUM_NAME
70656>>>>>>>>>>>>>>>>>/// @INTOPT
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_PRIMARY_INDEX of {FileNumber} to {variable}
70656>>>>>>>>>>>>>>>>>/// @Syntax Set_Attribute DF_FILE_PRIMARY_INDEX of {FileNumber} to {variable}
70656>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
70656>>>>>>>>>>>>>>>>>/// @Param  variable              Boolean variable indicating if a primary key is used
70656>>>>>>>>>>>>>>>>>/// @Example
70656>>>>>>>>>>>>>>>>>/// Open Customer
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Boolean bPrimary
70656>>>>>>>>>>>>>>>>>/// Handle hFile
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Move Customer.File_Number to hFile
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Structure_Start hFile
70656>>>>>>>>>>>>>>>>>///     Set_Attribute DF_FILE_PRIMARY_INDEX of Customer.File_Number to False
70656>>>>>>>>>>>>>>>>>///     Get_Attribute DF_FILE_PRIMARY_INDEX of Customer.File_Number to bPrimary
70656>>>>>>>>>>>>>>>>>/// Structure_End hFile
70656>>>>>>>>>>>>>>>>>Define DF_FILE_PRIMARY_INDEX                        For 1402
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//=============================================================================
70656>>>>>>>>>>>>>>>>>/// @Name        DF_FILE_RECNUM_NAME
70656>>>>>>>>>>>>>>>>>/// @Description This attribute is used to get the name of the Recnum field
70656>>>>>>>>>>>>>>>>>/// in the table, if one exists. It is a ReadOnly attribute so it can only
70656>>>>>>>>>>>>>>>>>/// be used in getting the name of the recnum field to a string variable.
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Assumptions
70656>>>>>>>>>>>>>>>>>/// @Status      Public
70656>>>>>>>>>>>>>>>>>/// @Drivers     All
70656>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-12 by Aaron Gulack
70656>>>>>>>>>>>>>>>>>/// @See                 DF_FILE_RECNUM_TABLE
70656>>>>>>>>>>>>>>>>>/// @INTOPT
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// @Syntax Get_Attribute DF_FILE_RECNUM_NAME of {FileNumber} to {variable}
70656>>>>>>>>>>>>>>>>>/// @Param  FileNumber            Number of the file
70656>>>>>>>>>>>>>>>>>/// @Param  variable              String name of recnum field
70656>>>>>>>>>>>>>>>>>/// @Example
70656>>>>>>>>>>>>>>>>>/// Open Customer
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// String sRecnum
70656>>>>>>>>>>>>>>>>>///
70656>>>>>>>>>>>>>>>>>/// Get_Attribute DF_FILE_RECNUM_NAME of Customer.File_Number to sRecnum
70656>>>>>>>>>>>>>>>>>Define DF_FILE_RECNUM_NAME                          For 1403
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>Define DF_FETCH_ALL                                 For -1
70656>>>>>>>>>>>>>>>>>Define DF_FETCH_TRUE                                For "TRUE"
70656>>>>>>>>>>>>>>>>>Define DF_FETCH_FALSE                               For "FALSE"
70656>>>>>>>>>>>>>>>>>Define DF_BIND_ALL_COLUMNS                          For -1
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>// SQLFlex Lock Type
70656>>>>>>>>>>>>>>>>>Define DF_LOCK_TYPE_PAGE                            For 3
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>// Extended Callback Types
70656>>>>>>>>>>>>>>>>>Define DF_MESSAGE_ERROR                             For 9
70656>>>>>>>>>>>>>>>>>Define DF_MESSAGE_PROGRESS_STATUS                   For 20
70656>>>>>>>>>>>>>>>>>Define DF_MESSAGE_PROGRESS_CONTINUE                 For 21
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//Drivers
70656>>>>>>>>>>>>>>>>>Define ORAFLEX                                      For "ORA_DRV"
70656>>>>>>>>>>>>>>>>>Define SQLFLEX                                      For "SQL_DRV"
70656>>>>>>>>>>>>>>>>>Define MDSDB2                                       For "MDS_DB2"
70656>>>>>>>>>>>>>>>>>Define MDSPgSQL                                     For "MDSPGSQL"
70656>>>>>>>>>>>>>>>>>Define PgFlex                                       For "MDSPGSQL"
70656>>>>>>>>>>>>>>>>>Define MDSMySQL                                     For "MDSMYSQL"
70656>>>>>>>>>>>>>>>>>Define MySQLFlex                                    For "MDSMYSQL"
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>// Delimiter for SQL ID objects
70656>>>>>>>>>>>>>>>>>Define DB2_ID_DELIM                                 For '"'
70656>>>>>>>>>>>>>>>>>Define MYSQL_ID_DELIM                               For "`"
70656>>>>>>>>>>>>>>>>>Define ORACLE_ID_DELIM                              For '"'
70656>>>>>>>>>>>>>>>>>Define PGSQL_ID_DELIM                               For '"'
70656>>>>>>>>>>>>>>>>>Define SQLSERVER_ID_DELIM                           For '"'
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>// dfStructureEnd Option bits
70656>>>>>>>>>>>>>>>>>Define DF_STRUCTEND_OPT_INDEX_ONLY                  For 16    // Internal Use Only
70656>>>>>>>>>>>>>>>>>Define DF_STRUCTEND_OPT_FORCE_INVK                  For 32
70656>>>>>>>>>>>>>>>>>Define DF_STRUCTEND_OPT_OLD_INVK_NAME               For 64
70656>>>>>>>>>>>>>>>>>Define DF_STRUCTEND_OPT_FORCE_NOT_NULL              For 128
70656>>>>>>>>>>>>>>>>>Define DF_STRUCTEND_OPT_CREATE_ROWID_TABLE          For 256
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//Additional Data Types
70656>>>>>>>>>>>>>>>>>Define DF_DATETIME                                  For 7
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//Call_Driver Functions
70656>>>>>>>>>>>>>>>>>Define CALLDRV_LICENSE_ENVIRONMENT_SET              For 0
70656>>>>>>>>>>>>>>>>>Define CALLDRV_ORA_CURRENT_SQL_SERVER               For 6
70656>>>>>>>>>>>>>>>>>Define CALLDRV_SQL_ERROR_MESSAGE                    For 14
70656>>>>>>>>>>>>>>>>>Define CALLDRV_CURRENT_SQL_SERVER                   for 19
70656>>>>>>>>>>>>>>>>>Define CALLDRV_SQL_NEXT_RESULTSET                   for ((22 * (2^16)) + 11)
70656>>>>>>>>>>>>>>>>>Define CALLDRV_BIND_PARAMETER                       for 23
70656>>>>>>>>>>>>>>>>>Define CALLDRV_SQL_MAX_CURSORS                      For 26
70656>>>>>>>>>>>>>>>>>Define CALLDRV_SQLLOADER_FIELDS_TERM                For 30
70656>>>>>>>>>>>>>>>>>Define CALLDRV_CREATE_TABLE_FROM_DAT                For 30
70656>>>>>>>>>>>>>>>>>Define CALLDRV_SQLLOADER_DECIMAL_SEP                For 31
70656>>>>>>>>>>>>>>>>>Define CALLDRV_CONVERT_DAT_FILE                     For 32
70656>>>>>>>>>>>>>>>>>Define CALLDRV_SQLFLEX_MAX_CURSORS                  For 37
70656>>>>>>>>>>>>>>>>>Define CALLDRV_NATIVE_OPTIMIZATION                  For 38
70656>>>>>>>>>>>>>>>>>Define CALLDRV_GET_RETURNED_COLUMNS                 For 39
70656>>>>>>>>>>>>>>>>>Define CALLDRV_GET_RETURNED_ROWS                    For 40
70656>>>>>>>>>>>>>>>>>Define CALLDRV_GET_COLUMN_ATTRIBUTE                 For 41
70656>>>>>>>>>>>>>>>>>Define CALLDRV_START_TXTGEN_AFTER_RECNUM            For 42
70656>>>>>>>>>>>>>>>>>Define CALLDRV_FINISH_TXTGEN_AFTER_RECNUM           For 43
70656>>>>>>>>>>>>>>>>>Define CALLDRV_SET_ISOLATION_LEVEL                  For 44
70656>>>>>>>>>>>>>>>>>Define CALLDRV_GET_SERVER_CFG                       For 45
70656>>>>>>>>>>>>>>>>>Define CALLDRV_SET_SQL_LOCK_TIMEOUT                 For 46
70656>>>>>>>>>>>>>>>>>Define CALLDRV_GET_SQL_LOCK_TIMEOUT                 For 47
70656>>>>>>>>>>>>>>>>>Define CALLDRV_GET_RESULTS                          For 48
70656>>>>>>>>>>>>>>>>>Define CALLDRV_GET_MORE_RESULTS                     For 49
70656>>>>>>>>>>>>>>>>>Define CALLDRV_GET_CURRENT_USER_NAME                For 50
70656>>>>>>>>>>>>>>>>>Define CALLDRV_OPEN_EMBEDDED_CURSOR                 For 51
70656>>>>>>>>>>>>>>>>>Define CALLDRV_CLOSE_EMBEDDED_CURSOR                For 52
70656>>>>>>>>>>>>>>>>>Define CALLDRV_SET_CURRENT_EMBEDDED_CURSOR          For 53
70656>>>>>>>>>>>>>>>>>Define CALLDRV_GET_CURRENT_EMBEDDED_CURSOR          For 54
70656>>>>>>>>>>>>>>>>>Define CALLDRV_SET_MAX_EMBEDDED_CURSOR              For 55
70656>>>>>>>>>>>>>>>>>Define CALLDRV_GET_MAX_EMBEDDED_CURSOR              For 56
70656>>>>>>>>>>>>>>>>>Define CALLDRV_SQL_TRANSACTION                      For 57
70656>>>>>>>>>>>>>>>>>Define CALLDRV_LOCAL_TD_PATH                        For 58
70656>>>>>>>>>>>>>>>>>Define CALLDRV_CREATE_DB                            For 59
70656>>>>>>>>>>>>>>>>>Define CALLDRV_ESCAPE_STRING                        For 60
70656>>>>>>>>>>>>>>>>>Define CALLDRV_SET_PROC_ATTRIBUTE_TYPE              For 61
70656>>>>>>>>>>>>>>>>>Define CALLDRV_SQL_REFRESH_CACHE                    For 62
70656>>>>>>>>>>>>>>>>>Define CALLDRV_GET_SQL_STMT                         For 63
70656>>>>>>>>>>>>>>>>>Define CALLDRV_DIRECT_PATH_LOAD                     For 64
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>Define CALLDRV_READ_LOB                             For 65
70656>>>>>>>>>>>>>>>>>Define CALLDRV_WRITE_LOB                            For 66
70656>>>>>>>>>>>>>>>>>Define CALLDRV_APPEND_LOB                           For 67
70656>>>>>>>>>>>>>>>>>Define CALLDRV_LENGTH_LOB                           For 68
70656>>>>>>>>>>>>>>>>>Define CALLDRV_LOADFROMFILE_LOB                     For 69
70656>>>>>>>>>>>>>>>>>Define CALLDRV_ERASE_LOB                            For 70
70656>>>>>>>>>>>>>>>>>Define CALLDRV_TRUNCATE_LOB                         For 71
70656>>>>>>>>>>>>>>>>>Define CALLDRV_INITIALIZE_SEQUENCE                  For 72
70656>>>>>>>>>>>>>>>>>Define CALLDRV_CLIENT_CFG                           For 73
70656>>>>>>>>>>>>>>>>>Define CALLDRV_END_SAVERECORD                       For 74
70656>>>>>>>>>>>>>>>>>Define CALLDRV_ENABLE_RECONNECT                     For 75
70656>>>>>>>>>>>>>>>>>Define CALLDRV_ENUMERATE_SERVER                     For 76
70656>>>>>>>>>>>>>>>>>Define CALLDRV_USE_ROWCOUNT_IN_TRANSACTIONS         For 77
70656>>>>>>>>>>>>>>>>>Define CALLDRV_USE_DFLEX_DATE_FORMAT                For 78
70656>>>>>>>>>>>>>>>>>Define CALLDRV_FORCE_FIELDS_NOT_NULL                For 79
70656>>>>>>>>>>>>>>>>>Define CALLDRV_ORA_CREATE_TABLE_FROM_DAT            For 80
70656>>>>>>>>>>>>>>>>>Define CALLDRV_MAX_DATA_SIZE                        For 81
70656>>>>>>>>>>>>>>>>>Define CALLDRV_CHUNK_SIZE                           For 82
70656>>>>>>>>>>>>>>>>>Define CALLDRV_GET_DATA_CHUNK                       For 83
70656>>>>>>>>>>>>>>>>>Define CALLDRV_MIRROR_SERVER                        For 84
70656>>>>>>>>>>>>>>>>>Define CALLDRV_COPY_DATA                            For 85
70656>>>>>>>>>>>>>>>>>Define CALLDRV_SET_SQL_CURSOR_TYPE                  For 86
70656>>>>>>>>>>>>>>>>>Define CALLDRV_ICF                                  For 87
70656>>>>>>>>>>>>>>>>>Define CALLDRV_CLEAR_INT_CACHE                      For 88
70656>>>>>>>>>>>>>>>>>Define CALLDRV_GET_CURRENT_USER_PASSWORD            For 89
70656>>>>>>>>>>>>>>>>>Define CALLDRV_FORCE_FIELDS_NULL                    For 90
70656>>>>>>>>>>>>>>>>>Define CALLDRV_TRANSACTIONS_ALLOWED                 For 91
70656>>>>>>>>>>>>>>>>>Define CALLDRV_SQL_ERROR_MESSAGE2                   For 92
70656>>>>>>>>>>>>>>>>>Define CALLDRV_PGSQL_NAME_SPACE                     For 93
70656>>>>>>>>>>>>>>>>>Define CALLDRV_EMBEDDED_SQL_TYPE                    For 94
70656>>>>>>>>>>>>>>>>>Define CALLDRV_CREATE_INVK_FUNCTIONS                For 95
70656>>>>>>>>>>>>>>>>>Define CALLDRV_DEFAULT_FILE_CASING                  For 96
70656>>>>>>>>>>>>>>>>>Define CALLDRV_GLOBAL_SETTING                       For 97
70656>>>>>>>>>>>>>>>>>Define CALLDRV_RESTRUCTURE_SCRIPT                   For 98
70656>>>>>>>>>>>>>>>>>Define CALLDRV_CURRENT_SQL_SERVER_CONNECTION        For 99
70656>>>>>>>>>>>>>>>>>Define CALLDRV_100                                  For 100
70656>>>>>>>>>>>>>>>>>Define CALLDRV_FILE_STRUCT_DYNAMIC_ONLINE           For 101
70656>>>>>>>>>>>>>>>>>Define CALLDRV_SET_FIXED_FILE_RECORDS_USED          For 102
70656>>>>>>>>>>>>>>>>>Define CALLDRV_GET_FIXED_FILE_RECORDS_USED          For 103
70656>>>>>>>>>>>>>>>>>Define CALLDRV_LOB_EX_WRITE                         For 104
70656>>>>>>>>>>>>>>>>>Define CALLDRV_LOB_EX_APPEND                        For 105
70656>>>>>>>>>>>>>>>>>Define CALLDRV_LOB_EX_READ                          For 106
70656>>>>>>>>>>>>>>>>>Define CALLDRV_LOB_EX_GET_LENGTH                    For 107
70656>>>>>>>>>>>>>>>>>Define CALLDRV_LOB_EX_SET_LENGTH                    For 108
70656>>>>>>>>>>>>>>>>>Define CALLDRV_LOB_EX_TEST                          For 109
70656>>>>>>>>>>>>>>>>>Define CALLDRV_LOB_EX_SET_NULL                      For 110
70656>>>>>>>>>>>>>>>>>Define CALLDRV_GET_DATA_CHUNK_EX                    for 111
70656>>>>>>>>>>>>>>>>>Define CALLDRV_PARAM_RETURN_TYPE                    For 112
70656>>>>>>>>>>>>>>>>>Define CALLDRV_CONNECTION_STRING                    for 113
70656>>>>>>>>>>>>>>>>>Define CALLDRV_GET_SQL_CURSOR_TYPE                  for 114
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>// License and environment settings
70656>>>>>>>>>>>>>>>>>Define CALLDRV_DRIVER_REVISION                      For 0
70656>>>>>>>>>>>>>>>>>Define CALLDRV_COMPANY_NAME                         For 1
70656>>>>>>>>>>>>>>>>>Define CALLDRV_SERIAL_NUMBER                        For 2
70656>>>>>>>>>>>>>>>>>Define CALLDRV_LICENSED_USERS                       For 3
70656>>>>>>>>>>>>>>>>>Define CALLDRV_MAJOR_REVISION                       For 4
70656>>>>>>>>>>>>>>>>>Define CALLDRV_VERSION_COMMENTS                     For 5
70656>>>>>>>>>>>>>>>>>Define CALLDRV_OLEDB_OEM_TRANSLATION                For 6
70656>>>>>>>>>>>>>>>>>Define CALLDRV_SET_DB_PORT                          For 7
70656>>>>>>>>>>>>>>>>>Define CALLDRV_GET_DB_PORT                          For 8
70656>>>>>>>>>>>>>>>>>Define CALLDRV_SET_DB_SOCKET                        For 9
70656>>>>>>>>>>>>>>>>>Define CALLDRV_GET_DB_SOCKET                        For 10
70656>>>>>>>>>>>>>>>>>Define CALLDRV_SET_AS_SYSDBA                        For 11
70656>>>>>>>>>>>>>>>>>Define CALLDRV_OEM_TRANSLATION_STATE                For 12
70656>>>>>>>>>>>>>>>>>Define CALLDRV_TIME_TO_LIC_EXPIRATION               For 13
70656>>>>>>>>>>>>>>>>>Define CALLDRV_LICENSE_EXPIRATION_WARN              For 14
70656>>>>>>>>>>>>>>>>>Define CALLDRV_LICENSE_PATH                         For 15
70656>>>>>>>>>>>>>>>>>Define CALLDRV_AUTO_NUMERIC_REMAPPING               For 16
70656>>>>>>>>>>>>>>>>>Define CALLDRV_FORCE_DATE_FORMAT_INIT               For 17
70656>>>>>>>>>>>>>>>>>Define CALLDRV_STATIC_TABLE_OPT                     For 18
70656>>>>>>>>>>>>>>>>>Define CALLDRV_MAX_OBJECT_NAME_LENGTH               For 19
70656>>>>>>>>>>>>>>>>>Define CALLDRV_USE_LAZY_OPEN_MODE                   For 20
70656>>>>>>>>>>>>>>>>>Define CALLDRV_SET_CUSTOM_OEM_TO_ANSI               For 21
70656>>>>>>>>>>>>>>>>>Define CALLDRV_GET_CUSTOM_OEM_TO_ANSI               For 22
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//CALLDRV_ENUMERATE_SERVER_OPTION
70656>>>>>>>>>>>>>>>>>Define CALLDRV_ENUMERATE_SERVER_COUNT               For 0
70656>>>>>>>>>>>>>>>>>Define CALLDRV_ENUMERATE_SERVER_SERVER              For 1
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//CALLDRV_DEFAULT_FILE_CASING
70656>>>>>>>>>>>>>>>>>Define FILE_CASING_UPPER                            For 0
70656>>>>>>>>>>>>>>>>>Define FILE_CASING_LOWER                            For 1
70656>>>>>>>>>>>>>>>>>Define FILE_CASING_KEEP                             For 2
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>// CALLDRV_GLOBAL_SETTING
70656>>>>>>>>>>>>>>>>>Define GLOBAL_SETTING_TABLESPACE_SET                For 0
70656>>>>>>>>>>>>>>>>>Define GLOBAL_SETTING_TABLESPACE_GET                For 1
70656>>>>>>>>>>>>>>>>>Define GLOBAL_SETTING_INDEX_TABLESPACE_SET          For 2
70656>>>>>>>>>>>>>>>>>Define GLOBAL_SETTING_INDEX_TABLESPACE_GET          For 3
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>// CALLDRV_RESTRUCTURE_SCRIPT
70656>>>>>>>>>>>>>>>>>Define CALLDRV_RESTRUCTURE_SCRIPT_ENABLE            For 0
70656>>>>>>>>>>>>>>>>>Define CALLDRV_RESTRUCTURE_SCRIPT_DISABLE           For 1
70656>>>>>>>>>>>>>>>>>Define CALLDRV_RESTRUCTURE_SCRIPT_GET_CHUNK_SQL     For 2
70656>>>>>>>>>>>>>>>>>Define CALLDRV_RESTRUCTURE_SCRIPT_GET_CHUNK_INT     For 3
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>// DF_SQL_RELATION_STATUS attributes
70656>>>>>>>>>>>>>>>>>Define FOREIGN_KEY_NONE                             For -1
70656>>>>>>>>>>>>>>>>>Define FOREIGN_KEY_CREATE                           For  0
70656>>>>>>>>>>>>>>>>>Define FOREIGN_KEY_ENABLE                           For  1
70656>>>>>>>>>>>>>>>>>Define FOREIGN_KEY_DISABLE                          For  2
70656>>>>>>>>>>>>>>>>>Define FOREIGN_KEY_DROP                             For  3
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>// DF_SQL_RELATION_DELETE_REF_ACTION attributes
70656>>>>>>>>>>>>>>>>>Define DELETE_REF_NONE                              For 0
70656>>>>>>>>>>>>>>>>>Define DELETE_REF_CASCADE                           For 1
70656>>>>>>>>>>>>>>>>>Define DELETE_REF_SET_NULL                          For 2
70656>>>>>>>>>>>>>>>>>Define DELETE_REF_SET_DEFAULT                       For 3
70656>>>>>>>>>>>>>>>>>Define DELETE_REF_RESTRICT                          For 4
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//Embedded SQL Cursor Types
70656>>>>>>>>>>>>>>>>>Define CALLDRV_ENUMERATE_CURSOR_TYPE_NONE           For 0
70656>>>>>>>>>>>>>>>>>Define CALLDRV_ENUMERATE_CURSOR_TYPE_CLIENT         For 1
70656>>>>>>>>>>>>>>>>>Define CALLDRV_ENUMERATE_CURSOR_TYPE_SERVER         For 2
70656>>>>>>>>>>>>>>>>>Define CALLDRV_ENUMERATE_CURSOR_TYPE_PARAMETERIZED  For 3
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//Driver Call Direction
70656>>>>>>>>>>>>>>>>>Define CALLDRV_VALUE_GET                            For 0
70656>>>>>>>>>>>>>>>>>Define CALLDRV_VALUE_SET                            For 1
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//Inverse Key types
70656>>>>>>>>>>>>>>>>>Define REGULAR_SEG                                  For -1
70656>>>>>>>>>>>>>>>>>Define INVK_CASE_SEG                                For 0
70656>>>>>>>>>>>>>>>>>Define INVK_DESC_SEG                                For 1
70656>>>>>>>>>>>>>>>>>Define INVK_DESC_AND_CASE_SEG                       For 2
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//DB2 Index Types
70656>>>>>>>>>>>>>>>>>Define REG_INDEX                                    For 0
70656>>>>>>>>>>>>>>>>>Define REV_INDEX                                    For 1
70656>>>>>>>>>>>>>>>>>Define CLUST_INDEX                                  For 2
70656>>>>>>>>>>>>>>>>>Define REV_CLUST_INDEX                              For 3
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//Oracle Procedure Arguments type
70656>>>>>>>>>>>>>>>>>Define IS_NONE                                      For 0
70656>>>>>>>>>>>>>>>>>Define IS_IN                                        For 1
70656>>>>>>>>>>>>>>>>>Define IS_OUT                                       For 2
70656>>>>>>>>>>>>>>>>>Define IS_IN_OUT                                    For 3
70656>>>>>>>>>>>>>>>>>Define IS_RSET                                      For 4
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>// SQL_GET_COL Attributes
70656>>>>>>>>>>>>>>>>>Define SQL_GET_COL_ATTRIB_SIZE                      For 1
70656>>>>>>>>>>>>>>>>>Define SQL_GET_COL_ATTRIB_DECIMALS                  For 2
70656>>>>>>>>>>>>>>>>>Define SQL_GET_COL_ATTRIB_LABEL                     For 3
70656>>>>>>>>>>>>>>>>>Define SQL_GET_COL_ATTRIB_COLUMN_NAME               For 4
70656>>>>>>>>>>>>>>>>>Define SQL_GET_COL_ATTRIB_TABLE_NAME                For 5
70656>>>>>>>>>>>>>>>>>Define SQL_GET_COL_ATTRIB_SQLTYPE                   For 6
70656>>>>>>>>>>>>>>>>>Define SQL_GET_COL_ATTRIB_NULLABLE                  For 7
70656>>>>>>>>>>>>>>>>>Define SQL_GET_COL_ATTRIB_DFTYPE                    For 8
70656>>>>>>>>>>>>>>>>>Define SQL_GET_COL_ATTRIB_DATA_LENGTH               For 9
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>// MySQL Data Types
70656>>>>>>>>>>>>>>>>>Define eMySQL_DECIMAL                               For 0
70656>>>>>>>>>>>>>>>>>Define eMySQL_TINY                                  For 1
70656>>>>>>>>>>>>>>>>>Define eMySQL_SHORT                                 For 2
70656>>>>>>>>>>>>>>>>>Define eMySQL_LONG                                  For 3
70656>>>>>>>>>>>>>>>>>Define eMySQL_FLOAT                                 For 4
70656>>>>>>>>>>>>>>>>>Define eMySQL_DOUBLE                                For 5
70656>>>>>>>>>>>>>>>>>Define eMySQL_NULL                                  For 6
70656>>>>>>>>>>>>>>>>>Define eMySQL_TIMESTAMP                             For 7
70656>>>>>>>>>>>>>>>>>Define eMySQL_LONGLONG                              For 8
70656>>>>>>>>>>>>>>>>>Define eMySQL_INT24                                 For 9
70656>>>>>>>>>>>>>>>>>Define eMySQL_DATE                                  For 10
70656>>>>>>>>>>>>>>>>>Define eMySQL_TIME                                  For 11
70656>>>>>>>>>>>>>>>>>Define eMySQL_DATETIME                              For 12
70656>>>>>>>>>>>>>>>>>Define eMySQL_YEAR                                  For 13
70656>>>>>>>>>>>>>>>>>Define eMySQL_NEWDATE                               For 14
70656>>>>>>>>>>>>>>>>>Define eMySQL_BIT                                   For 16
70656>>>>>>>>>>>>>>>>>Define eMySQL_NEWDECIMAL                            For 246
70656>>>>>>>>>>>>>>>>>Define eMySQL_ENUM                                  For 247
70656>>>>>>>>>>>>>>>>>Define eMySQL_SET                                   For 248
70656>>>>>>>>>>>>>>>>>Define eMySQL_TINY_BLOB                             For 249
70656>>>>>>>>>>>>>>>>>Define eMySQL_MEDIUM_BLOB                           For 250
70656>>>>>>>>>>>>>>>>>Define eMySQL_LONG_BLOB                             For 251
70656>>>>>>>>>>>>>>>>>Define eMySQL_BLOB                                  For 252
70656>>>>>>>>>>>>>>>>>Define eMySQL_VAR_STRING                            For 253
70656>>>>>>>>>>>>>>>>>Define eMySQL_STRING                                For 254
70656>>>>>>>>>>>>>>>>>Define eMySQL_TINY_TEXT                             For -249
70656>>>>>>>>>>>>>>>>>Define eMySQL_MEDIUM_TEXT                           For -250
70656>>>>>>>>>>>>>>>>>Define eMySQL_LONG_TEXT                             For -251
70656>>>>>>>>>>>>>>>>>Define eMySQL_TEXT                                  For -252
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>// Oracle Data Types
70656>>>>>>>>>>>>>>>>>Define eOracle_VARCHAR2                             For   1
70656>>>>>>>>>>>>>>>>>Define eOracle_NUMBER                               For   2
70656>>>>>>>>>>>>>>>>>Define eOracle_INT                                  For   3
70656>>>>>>>>>>>>>>>>>Define eOracle_FLOAT                                For   4
70656>>>>>>>>>>>>>>>>>Define eOracle_STRING                               For   5
70656>>>>>>>>>>>>>>>>>Define eOracle_LONG                                 For   8
70656>>>>>>>>>>>>>>>>>Define eOracle_ROWID                                For  11
70656>>>>>>>>>>>>>>>>>Define eOracle_DATE                                 For  12
70656>>>>>>>>>>>>>>>>>Define eOracle_RAW                                  For  23
70656>>>>>>>>>>>>>>>>>Define eOracle_LONGRAW                              For  24
70656>>>>>>>>>>>>>>>>>Define eOracle_CHAR                                 For  96
70656>>>>>>>>>>>>>>>>>Define eOracle_MSLABEL                              For 106
70656>>>>>>>>>>>>>>>>>Define eOracle_CLOB                                 For 112
70656>>>>>>>>>>>>>>>>>Define eOracle_BLOB                                 For 113
70656>>>>>>>>>>>>>>>>>Define eOracle_TIMESTAMP                            For 187
70656>>>>>>>>>>>>>>>>>Define eOracle_TIMESTAMPTZ                          For 188
70656>>>>>>>>>>>>>>>>>Define eOracle_INTERVALYM                           For 189
70656>>>>>>>>>>>>>>>>>Define eOracle_INTERVALDS                           For 190
70656>>>>>>>>>>>>>>>>>Define eOracle_TIMESTAMPLTZ                         For 232
70656>>>>>>>>>>>>>>>>>Define eOracle_NCHAR                                For 286
70656>>>>>>>>>>>>>>>>>Define eOracle_NVARCHAR2                            For 287
70656>>>>>>>>>>>>>>>>>Define eOracle_NCLOB                                For 288
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>// PostgreSQL Data Types
70656>>>>>>>>>>>>>>>>>Define ePgSQL_CIRCLE                                For  718
70656>>>>>>>>>>>>>>>>>Define ePgSQL_MONEY                                 For  790
70656>>>>>>>>>>>>>>>>>Define ePgSQL_BOOL                                  For   16
70656>>>>>>>>>>>>>>>>>Define ePgSQL_BYTEA                                 For   17
70656>>>>>>>>>>>>>>>>>Define ePgSQL_CHAR                                  For   18
70656>>>>>>>>>>>>>>>>>Define ePgSQL_INT2                                  For   21
70656>>>>>>>>>>>>>>>>>Define ePgSQL_INT4                                  For   23
70656>>>>>>>>>>>>>>>>>Define ePgSQL_REGPROC                               For   24
70656>>>>>>>>>>>>>>>>>Define ePgSQL_REGPROCEDURE                          For 2202
70656>>>>>>>>>>>>>>>>>Define ePgSQL_REGOPER                               For 2203
70656>>>>>>>>>>>>>>>>>Define ePgSQL_REGOPERATOR                           For 2204
70656>>>>>>>>>>>>>>>>>Define ePgSQL_REGCLASS                              For 2205
70656>>>>>>>>>>>>>>>>>Define ePgSQL_REGTYPE                               For 2206
70656>>>>>>>>>>>>>>>>>Define ePgSQL_TEXT                                  For   25
70656>>>>>>>>>>>>>>>>>Define ePgSQL_CITEXT                                For  -25
70656>>>>>>>>>>>>>>>>>Define ePgSQL_OID                                   For   26
70656>>>>>>>>>>>>>>>>>Define ePgSQL_TID                                   For   27
70656>>>>>>>>>>>>>>>>>Define ePgSQL_XID                                   For   28
70656>>>>>>>>>>>>>>>>>Define ePgSQL_CID                                   For   29
70656>>>>>>>>>>>>>>>>>Define ePgSQL_XML                                   For  142
70656>>>>>>>>>>>>>>>>>Define ePgSQL_BPCHAR                                For 1042
70656>>>>>>>>>>>>>>>>>Define ePgSQL_VARCHAR                               For 1043
70656>>>>>>>>>>>>>>>>>Define ePgSQL_INT8                                  For   20
70656>>>>>>>>>>>>>>>>>Define ePgSQL_PATH                                  For  602
70656>>>>>>>>>>>>>>>>>Define ePgSQL_FLOAT4                                For  700
70656>>>>>>>>>>>>>>>>>Define ePgSQL_FLOAT8                                For  701
70656>>>>>>>>>>>>>>>>>Define ePgSQL_ABSTIME                               For  702
70656>>>>>>>>>>>>>>>>>Define ePgSQL_RELTIME                               For  703
70656>>>>>>>>>>>>>>>>>Define ePgSQL_TINTERVAL                             For  704
70656>>>>>>>>>>>>>>>>>Define ePgSQL_POINT                                 For  600
70656>>>>>>>>>>>>>>>>>Define ePgSQL_LINE                                  For  628
70656>>>>>>>>>>>>>>>>>Define ePgSQL_LSEG                                  For  601
70656>>>>>>>>>>>>>>>>>Define ePgSQL_BOX                                   For  603
70656>>>>>>>>>>>>>>>>>Define ePgSQL_POLYGON                               For  604
70656>>>>>>>>>>>>>>>>>Define ePgSQL_ACLITEM                               For 1033
70656>>>>>>>>>>>>>>>>>Define ePgSQL_MACADDR                               For  829
70656>>>>>>>>>>>>>>>>>Define ePgSQL_INET                                  For  869
70656>>>>>>>>>>>>>>>>>Define ePgSQL_CIDR                                  For  650
70656>>>>>>>>>>>>>>>>>Define ePgSQL_TIMESTAMP                             For 1114
70656>>>>>>>>>>>>>>>>>Define ePgSQL_DATE                                  For 1082
70656>>>>>>>>>>>>>>>>>Define ePgSQL_TIME                                  For 1083
70656>>>>>>>>>>>>>>>>>Define ePgSQL_TIMESTAMPTZ                           For 1184
70656>>>>>>>>>>>>>>>>>Define ePgSQL_INTERVAL                              For 1186
70656>>>>>>>>>>>>>>>>>Define ePgSQL_NUMERIC                               For 1700
70656>>>>>>>>>>>>>>>>>Define ePgSQL_TIMETZ                                For 1266
70656>>>>>>>>>>>>>>>>>Define ePgSQL_BIT                                   For 1560
70656>>>>>>>>>>>>>>>>>Define ePgSQL_VARBIT                                For 1562
70656>>>>>>>>>>>>>>>>>Define ePgSQL_UUID                                  For 2950
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>// SQL Server Data Types
70656>>>>>>>>>>>>>>>>>Define eSQLServer_NA                                For    0
70656>>>>>>>>>>>>>>>>>Define eSQLServer_CHAR                              For    1
70656>>>>>>>>>>>>>>>>>Define eSQLServer_NUMERIC                           For    2
70656>>>>>>>>>>>>>>>>>Define eSQLServer_DECIMAL                           For    3
70656>>>>>>>>>>>>>>>>>Define eSQLServer_INT                               For    4
70656>>>>>>>>>>>>>>>>>Define eSQLServer_SMALLINT                          For    5
70656>>>>>>>>>>>>>>>>>Define eSQLServer_FLOAT                             For    6
70656>>>>>>>>>>>>>>>>>Define eSQLServer_REAL                              For    7
70656>>>>>>>>>>>>>>>>>Define eSQLServer_DOUBLE                            For    8
70656>>>>>>>>>>>>>>>>>Define eSQLServer_DATETIME                          For   11
70656>>>>>>>>>>>>>>>>>Define eSQLServer_VARCHAR                           For   12
70656>>>>>>>>>>>>>>>>>Define eSQLServer_DATE                              For   40
70656>>>>>>>>>>>>>>>>>Define eSQLServer_TIME                              For   41
70656>>>>>>>>>>>>>>>>>Define eSQLServer_DATETIME2                         For   42
70656>>>>>>>>>>>>>>>>>Define eSQLServer_DATETIMEOFFSET                    For   43
70656>>>>>>>>>>>>>>>>>Define eSQLServer_SMALLDATETIME                     For   58
70656>>>>>>>>>>>>>>>>>Define eSQLServer_TIMESTAMP                         For   93
70656>>>>>>>>>>>>>>>>>Define eSQLServer_HIERARCHYID                       For  128
70656>>>>>>>>>>>>>>>>>Define eSQLServer_GEOMETRY                          For  129
70656>>>>>>>>>>>>>>>>>Define eSQLServer_GEOGRAPHY                         For  130
70656>>>>>>>>>>>>>>>>>Define eSQLServer_TEXT                              For   -1
70656>>>>>>>>>>>>>>>>>Define eSQLServer_BINARY                            For   -2
70656>>>>>>>>>>>>>>>>>Define eSQLServer_VARBINARY                         For   -3
70656>>>>>>>>>>>>>>>>>Define eSQLServer_IMAGE                             For   -4
70656>>>>>>>>>>>>>>>>>Define eSQLServer_BIGINT                            For   -5
70656>>>>>>>>>>>>>>>>>Define eSQLServer_TINYINT                           For   -6
70656>>>>>>>>>>>>>>>>>Define eSQLServer_BIT                               For   -7
70656>>>>>>>>>>>>>>>>>Define eSQLServer_NCHAR                             For   -8
70656>>>>>>>>>>>>>>>>>Define eSQLServer_NVARCHAR                          For   -9
70656>>>>>>>>>>>>>>>>>Define eSQLServer_NTEXT                             For  -10
70656>>>>>>>>>>>>>>>>>Define eSQLServer_GUID                              For  -11
70656>>>>>>>>>>>>>>>>>Define eSQLServer_VARBINARYMAX                      For  -98
70656>>>>>>>>>>>>>>>>>Define eSQLServer_VARCHARMAX                        For  -99
70656>>>>>>>>>>>>>>>>>Define eSQLServer_NVARCHARMAX                       For -100
70656>>>>>>>>>>>>>>>>>Define eSQLServer_SQLVARIANT                        For -150
70656>>>>>>>>>>>>>>>>>Define eSQLServer_XML                               For -370
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//=============================================================================
70656>>>>>>>>>>>>>>>>>//Error Text
70656>>>>>>>>>>>>>>>>>//==========
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//=============================================================================
70656>>>>>>>>>>>>>>>>>//Define Self if needed
70656>>>>>>>>>>>>>>>>>//=====================
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>//=============================================================================
70656>>>>>>>>>>>>>>>>>//Define varibles we need
70656>>>>>>>>>>>>>>>>>//=======================
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>    Define MertechInc_Variables_Defined
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>    Indicator MertechInc_bThereIsBinding
70656>>>>>>>>>>>>>>>>>
70656>>>>>>>>>>>>>>>>>    Integer MertechInc_FileNumber      //Replaces _SAVEFILENUMBER# and FILENUMBER
70656>>>>>>>>>>>>>>>>>    Integer MertechInc_iArg            //Replaces _LLONG#
70656>>>>>>>>>>>>>>>>>    Integer MertechInc_iCallBack       //Replaces _CALLBACK#
70656>>>>>>>>>>>>>>>>>    Integer MertechInc_iCount          //General loop limit integer
70656>>>>>>>>>>>>>>>>>    Integer MertechInc_iDecSep         //Holds the decimal seperator
70656>>>>>>>>>>>>>>>>>    Integer MertechInc_iFunction       //Replaces _FID#    ??? check is this is need when tidy is complete
70656>>>>>>>>>>>>>>>>>    Integer MertechInc_iLoop           //General loop integer
70656>>>>>>>>>>>>>>>>>    Integer Mertech_iMySQLParam        //Replaces _ALL_PAR_POS#
70656>>>>>>>>>>>>>>>>>    Integer MertechInc_iParamCount     //Replaces _NPAR#
70656>>>>>>>>>>>>>>>>>    Integer MertechInc_iRet            //Replaces _RET#
70656>>>>>>>>>>>>>>>>>    Integer MertechInc_iSaveCount      //Replaces _NPOS#
70656>>>>>>>>>>>>>>>>>    Integer MertechInc_iWork           //General work integer
70656>>>>>>>>>>>>>>>>>    Integer MertechInc_iWork2
70656>>>>>>>>>>>>>>>>>    Integer MertechInc_iWork3
70656>>>>>>>>>>>>>>>>>    Integer MertechInc_SizeCheckDone
70656>>>>>>>>>>>>>>>>>    Integer MertechInc_LastCursorNum
70656>>>>>>>>>>>>>>>>>    Move -2 to MertechInc_LastCursorNum // -1 means default cursor, so we're using -2 no cursor yet
70657>>>>>>>>>>>>>>>>>    Integer MertechInc_DefaultCursorType
70657>>>>>>>>>>>>>>>>>
70657>>>>>>>>>>>>>>>>>    Move CALLDRV_ENUMERATE_CURSOR_TYPE_NONE to MertechInc_DefaultCursorType
70658>>>>>>>>>>>>>>>>>
70658>>>>>>>>>>>>>>>>>    String MertechInc_Blank            //Replaces _BLANK#
70658>>>>>>>>>>>>>>>>>    String MertechInc_DriverName       //Replaces _DRIVERNAME#
70658>>>>>>>>>>>>>>>>>    String MertechInc_sArg1 255        //Replaces _ARG1#
70658>>>>>>>>>>>>>>>>>    String MertechInc_sArg2 255        //Replaces _ARG2#
70658>>>>>>>>>>>>>>>>>    String MertechInc_sWork 255        //General work string
70658>>>>>>>>>>>>>>>>>
70658>>>>>>>>>>>>>>>>>    String MertechInc_CurrentDriver    //Keep the current driver name
70658>>>>>>>>>>>>>>>>>    //Global string are created pre-filled with spaces. We need an empty string
70658>>>>>>>>>>>>>>>>>    Move "" to MertechInc_Blank
70659>>>>>>>>>>>>>>>>>    Move "" to MertechInc_CurrentDriver
70660>>>>>>>>>>>>>>>>>
70660>>>>>>>>>>>>>>>>>
70660>>>>>>>>>>>>>>>>>//=============================================================================
70660>>>>>>>>>>>>>>>>>//Use Obsolete Code
70660>>>>>>>>>>>>>>>>>//=================
70660>>>>>>>>>>>>>>>>>
70660>>>>>>>>>>>>>>>>>
70660>>>>>>>>>>>>>>>>>
70660>>>>>>>>>>>>>>>>>//=============================================================================
70660>>>>>>>>>>>>>>>>>//Comment Block Template
70660>>>>>>>>>>>>>>>>>//======================
70660>>>>>>>>>>>>>>>>>
70660>>>>>>>>>>>>>>>>>/// @Name {Name of the command for indexing} (used for documentation)
70660>>>>>>>>>>>>>>>>>/// @Description {Short Command Description} (used for documentation)
70660>>>>>>>>>>>>>>>>>///     The description can be multiple lines, and contain HTML tags.
70660>>>>>>>>>>>>>>>>>///     The other tokens will have HTML encoded so we can show stuff
70660>>>>>>>>>>>>>>>>>///     like <param1> properly. A blank line will automatically be
70660>>>>>>>>>>>>>>>>>///         translated into a paragraph break in the documentation, so
70660>>>>>>>>>>>>>>>>>///     no need for <br> or <p> tags.
70660>>>>>>>>>>>>>>>>>///
70660>>>>>>>>>>>>>>>>>/// @Assumptions {Assumptions made in order for the command to work}
70660>>>>>>>>>>>>>>>>>/// @Status {Obsolete, Internal, or Public} (used for documentation)
70660>>>>>>>>>>>>>>>>>/// @Drivers {DB2Flex, MySQLFlex, ORAFlex, PgFlex, SQLFlex or All} (used for documentation)
70660>>>>>>>>>>>>>>>>>/// @VersionNote {Date and author of the last revision}
70660>>>>>>>>>>>>>>>>>/// @See {list of related commands}
70660>>>>>>>>>>>>>>>>>///
70660>>>>>>>>>>>>>>>>>/// @Syntax {Syntax of use} (used for documentation)
70660>>>>>>>>>>>>>>>>>/// @Param {Each parameter with a brief description} (used for documentation)
70660>>>>>>>>>>>>>>>>>/// @DBMS {List of supported databases}
70660>>>>>>>>>>>>>>>>>/// @DataFlex {List of supported DataFlex versions}
70660>>>>>>>>>>>>>>>>>/// @Usage {Different uses command can have multiple syntaxes} (used for documentation)
70660>>>>>>>>>>>>>>>>>///
70660>>>>>>>>>>>>>>>>>/// @Example {An example of the command being used} (used for documentation)
70660>>>>>>>>>>>>>>>>>
70660>>>>>>>>>>>>>>>>>//=============================================================================
70660>>>>>>>>>>>>>>>>>/// @Name        DO_GETFILENUMBER_DRIVERNAME
70660>>>>>>>>>>>>>>>>>/// @Description Retrieves the current driver name and or the file number
70660>>>>>>>>>>>>>>>>>/// that will be used by the macro commands.
70660>>>>>>>>>>>>>>>>>///
70660>>>>>>>>>>>>>>>>>/// @Assumptions
70660>>>>>>>>>>>>>>>>>/// @Status      Internal Use Only
70660>>>>>>>>>>>>>>>>>/// @Drivers     All
70660>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-07-14 By Ian Smith
70660>>>>>>>>>>>>>>>>>/// @See
70660>>>>>>>>>>>>>>>>>//Most commands Use DO_GETFILENUMBER_DRIVERNAME so this code was being duplicated
70660>>>>>>>>>>>>>>>>>//all the Time. It has been moved to this method to remove that duplication.
70660>>>>>>>>>>>>>>>>>Procedure MertechInc_Get_Driver_name Global
70662>>>>>>>>>>>>>>>>>    //If we have a file number get its driver, else find first loaded Mertech driver
70662>>>>>>>>>>>>>>>>>    If MertechInc_FileNumber GT 0 ;        Get_Attribute DF_FILE_DRIVER of MertechInc_FileNumber to MertechInc_DriverName
70667>>>>>>>>>>>>>>>>>    Else Begin
70668>>>>>>>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to MertechInc_iCount
70671>>>>>>>>>>>>>>>>>        For MertechInc_iLoop from 1 to MertechInc_iCount
70677>>>>>>>>>>>>>>>>>>
70677>>>>>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of MertechInc_iLoop to MertechInc_DriverName
70680>>>>>>>>>>>>>>>>>            Move (UPPERCASE(MertechInc_DriverName)) to MertechInc_DriverName
70681>>>>>>>>>>>>>>>>>            If (MertechInc_DriverName EQ ORAFLEX  or MertechInc_DriverName EQ SQLFLEX or MertechInc_DriverName EQ MDSDB2 or ;                MertechInc_DriverName EQ MDSPgSQL or MertechInc_DriverName EQ MDSMySQL) Move MertechInc_iCount to MertechInc_iLoop
70684>>>>>>>>>>>>>>>>>            Else Move "" to MertechInc_DriverName
70686>>>>>>>>>>>>>>>>>        Loop
70687>>>>>>>>>>>>>>>>>>
70687>>>>>>>>>>>>>>>>>    End
70687>>>>>>>>>>>>>>>>>>
70687>>>>>>>>>>>>>>>>>
70687>>>>>>>>>>>>>>>>>    //Ensure that we return a valid Mertech driver.
70687>>>>>>>>>>>>>>>>>    If (MertechInc_DriverName NE ORAFLEX  and MertechInc_DriverName NE SQLFLEX  and ;        MertechInc_DriverName NE MDSPgSQL and MertechInc_DriverName NE MDSMySQL) Begin
70689>>>>>>>>>>>>>>>>>
70689>>>>>>>>>>>>>>>>>        //Report invalid driver
70689>>>>>>>>>>>>>>>>>        Error 25100 ("Mertech.inc - Not a Mertech driver. File" * String(MertechInc_FileNumber) * "Driver" * Trim(MertechInc_DriverName) )
70690>>>>>>>>>>>>>>>>>>
70690>>>>>>>>>>>>>>>>>
70690>>>>>>>>>>>>>>>>>        //Set MertechInc_FileNumber to MertechInc_Invalid_Driver so that the commands can
70690>>>>>>>>>>>>>>>>>        //determine if the driver is valid. MertechInc_FileNumber is use instead of
70690>>>>>>>>>>>>>>>>>        //MertechInc_DriverName as integer conparisons are quicker than string conparisons
70690>>>>>>>>>>>>>>>>>        Move MertechInc_Invalid_Driver to MertechInc_FileNumber
70691>>>>>>>>>>>>>>>>>    End
70691>>>>>>>>>>>>>>>>>>
70691>>>>>>>>>>>>>>>>>End_Procedure
70692>>>>>>>>>>>>>>>>>
70692>>>>>>>>>>>>>>>>>
70692>>>>>>>>>>>>>>>>>//=============================================================================
70692>>>>>>>>>>>>>>>>>/// @Name        MertechInc_Pre_Size_String
70692>>>>>>>>>>>>>>>>>/// @Description Returns a string full of spaces.
70692>>>>>>>>>>>>>>>>>///
70692>>>>>>>>>>>>>>>>>/// @Assumptions
70692>>>>>>>>>>>>>>>>>/// @Status      Internal
70692>>>>>>>>>>>>>>>>>/// @Drivers     n/a
70692>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-12-02 By Gandalf Hernandez
70692>>>>>>>>>>>>>>>>>/// @See
70692>>>>>>>>>>>>>>>>>Function MertechInc_Pre_Size_String Global Integer iSize Returns String
70694>>>>>>>>>>>>>>>>>   String sWork
70694>>>>>>>>>>>>>>>>>   Integer iBlocks iRemainder
70694>>>>>>>>>>>>>>>>>
70694>>>>>>>>>>>>>>>>>   If (iSize <= 1) Begin
70696>>>>>>>>>>>>>>>>>      // marcelo 06/28/2000 implemented logic to avoid VDF 7 crashing problems
70696>>>>>>>>>>>>>>>>>          If FMAC_VERSION eq 7 Move 1000 to iSize
70699>>>>>>>>>>>>>>>>>          Else Move 16384 to iSize
70701>>>>>>>>>>>>>>>>>   End
70701>>>>>>>>>>>>>>>>>>
70701>>>>>>>>>>>>>>>>>
70701>>>>>>>>>>>>>>>>>   // Build the string in blocks of 32, to speed things up
70701>>>>>>>>>>>>>>>>>   // If the string is less than 32 bytes, just fill it up regularly
70701>>>>>>>>>>>>>>>>>   Move (iSize / 32) to iBlocks
70702>>>>>>>>>>>>>>>>>   Move (Mod(iSize, 32)) to iRemainder
70703>>>>>>>>>>>>>>>>>
70703>>>>>>>>>>>>>>>>>   If (iBlocks > 0) Begin
70705>>>>>>>>>>>>>>>>>      Move (Repeat("                                ", iBlocks)) to sWork
70706>>>>>>>>>>>>>>>>>      Move (Append (sWork, (Repeat(" ", iRemainder)))) to sWork
70707>>>>>>>>>>>>>>>>>   End
70707>>>>>>>>>>>>>>>>>>
70707>>>>>>>>>>>>>>>>>   Else Move (Repeat(" ", iSize)) to sWork
70709>>>>>>>>>>>>>>>>>
70709>>>>>>>>>>>>>>>>>   Function_Return sWork
70710>>>>>>>>>>>>>>>>>End_Function
70711>>>>>>>>>>>>>>>>>
70711>>>>>>>>>>>>>>>>>//=============================================================================
70711>>>>>>>>>>>>>>>>>/// @Name        MertechInc_Set_DecSep
70711>>>>>>>>>>>>>>>>>/// @Description Saves the current decimal separator and sets the decimal
70711>>>>>>>>>>>>>>>>>/// separator to '.'.
70711>>>>>>>>>>>>>>>>>///
70711>>>>>>>>>>>>>>>>>/// @Assumptions
70711>>>>>>>>>>>>>>>>>/// @Status      Internal
70711>>>>>>>>>>>>>>>>>/// @Drivers     n/a
70711>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-17 By Ian Smith
70711>>>>>>>>>>>>>>>>>Procedure MertechInc_Set_DecSep Global
70713>>>>>>>>>>>>>>>>>    Get_Attribute DF_DECIMAL_SEPARATOR to MertechInc_iDecSep
70716>>>>>>>>>>>>>>>>>    If MertechInc_iDecSep Ne 46 Set_Attribute DF_DECIMAL_SEPARATOR to 46 // (.) WILL BE DECIMAL SEPARATOR
70721>>>>>>>>>>>>>>>>>End_Procedure
70722>>>>>>>>>>>>>>>>>
70722>>>>>>>>>>>>>>>>>//=============================================================================
70722>>>>>>>>>>>>>>>>>/// @Name        MertechInc_Reset_DecSep
70722>>>>>>>>>>>>>>>>>/// @Description Sets the decimal separator to the saved value.
70722>>>>>>>>>>>>>>>>>///
70722>>>>>>>>>>>>>>>>>/// @Status      Internal
70722>>>>>>>>>>>>>>>>>/// @Drivers     n/a
70722>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-17 By Ian Smith
70722>>>>>>>>>>>>>>>>>///
70722>>>>>>>>>>>>>>>>>Procedure MertechInc_Reset_DecSep Global
70724>>>>>>>>>>>>>>>>>    If MertechInc_iDecSep Ne 46 Set_Attribute DF_DECIMAL_SEPARATOR to MertechInc_iDecSep
70729>>>>>>>>>>>>>>>>>End_Procedure
70730>>>>>>>>>>>>>>>>>
70730>>>>>>>>>>>>>>>>>//=============================================================================
70730>>>>>>>>>>>>>>>>>/// @Name        FETCH_FIELD
70730>>>>>>>>>>>>>>>>>/// @Description Selects or de-selects the fields to be fetched during the
70730>>>>>>>>>>>>>>>>>/// next FIND (query).
70730>>>>>>>>>>>>>>>>>///
70730>>>>>>>>>>>>>>>>>/// @Status      Internal
70730>>>>>>>>>>>>>>>>>/// @Drivers     All
70730>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-07-16 By Ian Smith
70730>>>>>>>>>>>>>>>>>///
70730>>>>>>>>>>>>>>>>>/// @Syntax FETCH_FIELD <FileNum> <FieldStart> THRU <FieldEnd> TO DF_FETCH_TRUE
70730>>>>>>>>>>>>>>>>>/// @Param  FileNum    is the File Number
70730>>>>>>>>>>>>>>>>>/// @Param  FieldStart is the Field Name or Number that will start the selection range
70730>>>>>>>>>>>>>>>>>/// @Param  FieldEnd   is the Field Name or Number that will finish the selection range
70730>>>>>>>>>>>>>>>>>///
70730>>>>>>>>>>>>>>>>>/// @Syntax FETCH_FIELD <FileNum> <Field1> TO DF_FETCH_TRUE
70730>>>>>>>>>>>>>>>>>/// @Param  FileNum  is the File Number
70730>>>>>>>>>>>>>>>>>/// @Param  Field1 Fields Name or Number to be selected
70730>>>>>>>>>>>>>>>>>///
70730>>>>>>>>>>>>>>>>>
70730>>>>>>>>>>>>>>>>>//=============================================================================
70730>>>>>>>>>>>>>>>>>/// @Name        SQL_TEXT_MESSAGE
70730>>>>>>>>>>>>>>>>>/// @Description Use this command to manually insert a string into a trace
70730>>>>>>>>>>>>>>>>>/// file. This can be useful for readability within the trace file to log
70730>>>>>>>>>>>>>>>>>/// what is actually happening at certain points.
70730>>>>>>>>>>>>>>>>>///
70730>>>>>>>>>>>>>>>>>/// @Assumptions The text string is less than 80 characters long.
70730>>>>>>>>>>>>>>>>>/// @Status      Public
70730>>>>>>>>>>>>>>>>>/// @Drivers     All
70730>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 20013-08-19 by Aaron Gulack
70730>>>>>>>>>>>>>>>>>/// @See         ENABLE_TRACE_ON DISABLE_TRACE_ON
70730>>>>>>>>>>>>>>>>>///
70730>>>>>>>>>>>>>>>>>/// @Syntax SQL_TEXT_MESSAGE {variable}
70730>>>>>>>>>>>>>>>>>/// @Param  {variable}          The string to insert into the trace file.
70730>>>>>>>>>>>>>>>>>///
70730>>>>>>>>>>>>>>>>>/// @Example
70730>>>>>>>>>>>>>>>>>/// Login "localhost" "mds" "mertech" "ora_drv"
70730>>>>>>>>>>>>>>>>>///
70730>>>>>>>>>>>>>>>>>/// ENABLE_TRACE_ON to "c:\trace.txt" DEBUG_LEVEL
70730>>>>>>>>>>>>>>>>>/// open Customer
70730>>>>>>>>>>>>>>>>>/// SQL_TEXT_MESSAGE "The table has been opened"
70730>>>>>>>>>>>>>>>>>
70730>>>>>>>>>>>>>>>>>//=============================================================================
70730>>>>>>>>>>>>>>>>>/// @Name       SELECT_COLUMNS_FIND
70730>>>>>>>>>>>>>>>>>/// @Description This command is used to fetch only a certain number of fields
70730>>>>>>>>>>>>>>>>>/// while doing a "find". When specifying the field number to start from and
70730>>>>>>>>>>>>>>>>>/// field number to end on, the find will only fetch the given fields from the
70730>>>>>>>>>>>>>>>>>/// record. It is important to always use this command after first deselecting
70730>>>>>>>>>>>>>>>>>/// all columns i.e. setting RESET_FETCH_FIELDS to DF_FETCH_FALSE. Also, after
70730>>>>>>>>>>>>>>>>>/// using this command, all columns need to be reselected i.e. setting
70730>>>>>>>>>>>>>>>>>/// RESET_FETCH_FIELDS to DF_FETCH_TRUE. Note that fields used as a part the
70730>>>>>>>>>>>>>>>>>/// index segment associated with the find will always be fetched regardless.
70730>>>>>>>>>>>>>>>>>///
70730>>>>>>>>>>>>>>>>>/// @Assumptions
70730>>>>>>>>>>>>>>>>>/// @Status      Public
70730>>>>>>>>>>>>>>>>>/// @Drivers     All
70730>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 20014-04-30 by Marcello Yo
70730>>>>>>>>>>>>>>>>>/// @See         RESET_FETCH_FIELDS DISABLE_SELECT_COLUMNS_ERRORS
70730>>>>>>>>>>>>>>>>>///
70730>>>>>>>>>>>>>>>>>/// @Syntax SELECT_COLUMNS_FIND {FileNumber} {fieldStart} THRU {fieldEnd}
70730>>>>>>>>>>>>>>>>>/// @Param  FileNumber          The number of the file
70730>>>>>>>>>>>>>>>>>/// @Param  fieldStart          The field number to start the fetch from
70730>>>>>>>>>>>>>>>>>/// @Param  FieldEnd            The field number to end the fetch at
70730>>>>>>>>>>>>>>>>>///
70730>>>>>>>>>>>>>>>>>/// @Example
70730>>>>>>>>>>>>>>>>>/// Open Customer
70730>>>>>>>>>>>>>>>>>/// RESET_FETCH_FIELDS  CUSTOMER DF_FETCH_FALSE
70730>>>>>>>>>>>>>>>>>/// SELECT_COLUMNS_FIND CUSTOMER CUSTOMER_NUMBER NAME
70730>>>>>>>>>>>>>>>>>/// DISABLE_SELECT_COLUMNS_ERRORS DISABLED
70730>>>>>>>>>>>>>>>>>///
70730>>>>>>>>>>>>>>>>>/// Clear Customer
70730>>>>>>>>>>>>>>>>>/// Repeat
70730>>>>>>>>>>>>>>>>>///    Find Gt Customer by Index.1
70730>>>>>>>>>>>>>>>>>///    If (Found) Showln Customer.Customer_Number '-' Customer.Name
70730>>>>>>>>>>>>>>>>>/// Until (Not(Found))
70730>>>>>>>>>>>>>>>>>///
70730>>>>>>>>>>>>>>>>>/// RESET_FETCH_FIELDS Customer DF_FETCH_TRUE
70730>>>>>>>>>>>>>>>>>
70730>>>>>>>>>>>>>>>>>
70730>>>>>>>>>>>>>>>>>//=============================================================================
70730>>>>>>>>>>>>>>>>>/// @Name        RESET_FETCH_FIELDS
70730>>>>>>>>>>>>>>>>>/// @Description This command is used to specify whether to retrieve all columns
70730>>>>>>>>>>>>>>>>>/// or no columns when performing a find. It is usually used with the command
70730>>>>>>>>>>>>>>>>>/// SELECT_COLUMNS_FIND to reset the column fetching. This command can either be
70730>>>>>>>>>>>>>>>>>/// set to DF_FETCH_TRUE, which will fetch all columns or set to DF_FETCH_FALSE,
70730>>>>>>>>>>>>>>>>>/// which will fetch no columns.
70730>>>>>>>>>>>>>>>>>/// @Assumptions
70730>>>>>>>>>>>>>>>>>/// @Status      Public
70730>>>>>>>>>>>>>>>>>/// @Drivers     All
70730>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2014-04-30 by Marcello Yo
70730>>>>>>>>>>>>>>>>>/// @See         SELECT_COLUMNS_FIND DISABLE_SELECT_COLUMNS_ERRORS
70730>>>>>>>>>>>>>>>>>///
70730>>>>>>>>>>>>>>>>>/// @Syntax RESET_FETCH_FIELDS {FileNumber} {DF_FETCH_TRUE/DF_FETCH_FALSE}
70730>>>>>>>>>>>>>>>>>/// @Param  FileNumber                  The number of the file
70730>>>>>>>>>>>>>>>>>/// @Param  DF_FETCH_TRUE               fetch all columns
70730>>>>>>>>>>>>>>>>>/// @Param  DF_FETCH_FALSE              fetch no columns
70730>>>>>>>>>>>>>>>>>///
70730>>>>>>>>>>>>>>>>>/// @Example
70730>>>>>>>>>>>>>>>>>/// Open Customer
70730>>>>>>>>>>>>>>>>>/// RESET_FETCH_FIELDS  CUSTOMER DF_FETCH_FALSE
70730>>>>>>>>>>>>>>>>>/// SELECT_COLUMNS_FIND CUSTOMER CUSTOMER_NUMBER NAME
70730>>>>>>>>>>>>>>>>>/// DISABLE_SELECT_COLUMNS_ERRORS DISABLED
70730>>>>>>>>>>>>>>>>>///
70730>>>>>>>>>>>>>>>>>/// Clear Customer
70730>>>>>>>>>>>>>>>>>/// Repeat
70730>>>>>>>>>>>>>>>>>///    Find Gt Customer by Index.1
70730>>>>>>>>>>>>>>>>>///    If (Found) Showln Customer.Customer_Number '-' Customer.Name
70730>>>>>>>>>>>>>>>>>/// Until (Not(Found))
70730>>>>>>>>>>>>>>>>>///
70730>>>>>>>>>>>>>>>>>/// RESET_FETCH_FIELDS Customer DF_FETCH_TRUE
70730>>>>>>>>>>>>>>>>>
70730>>>>>>>>>>>>>>>>>//=============================================================================
70730>>>>>>>>>>>>>>>>>/// @Name        SQL_FOR_ONEROW
70730>>>>>>>>>>>>>>>>>/// @Description This command will instruct the driver to fetch one row
70730>>>>>>>>>>>>>>>>>/// per query
70730>>>>>>>>>>>>>>>>>///
70730>>>>>>>>>>>>>>>>>/// @Assumptions
70730>>>>>>>>>>>>>>>>>/// @Status      Deprecated
70730>>>>>>>>>>>>>>>>>/// @Drivers     All
70730>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-19 by Aaron Gulack
70730>>>>>>>>>>>>>>>>>/// @See
70730>>>>>>>>>>>>>>>>>///
70730>>>>>>>>>>>>>>>>>/// @Syntax SQL_FOR_ONEROW {FileNumber}
70730>>>>>>>>>>>>>>>>>/// @Param  FileNumber          The number of the file
70730>>>>>>>>>>>>>>>>>/// @Example
70730>>>>>>>>>>>>>>>>>///     open Customer
70730>>>>>>>>>>>>>>>>>///     SQL_FOR_ONEROW Customer.File_Number
70730>>>>>>>>>>>>>>>>>///     Repeat
70730>>>>>>>>>>>>>>>>>///             find gt Customer by Recnum
70730>>>>>>>>>>>>>>>>>///         If (Found) Begin
70730>>>>>>>>>>>>>>>>>///             showln "Sales name is " Customer.FirstName
70730>>>>>>>>>>>>>>>>>///         end
70730>>>>>>>>>>>>>>>>>///     until (Customer.ID = 10)
70730>>>>>>>>>>>>>>>>>
70730>>>>>>>>>>>>>>>>>//=============================================================================
70730>>>>>>>>>>>>>>>>>/// @Name        SQL_REFRESH_CACHE
70730>>>>>>>>>>>>>>>>>/// @Description For optimization during record retrieval, a set number of
70730>>>>>>>>>>>>>>>>>/// records are stored in a local cache. This command forces a refresh, by
70730>>>>>>>>>>>>>>>>>/// making the next find retrieve the record from the database instead of
70730>>>>>>>>>>>>>>>>>/// the cache.
70730>>>>>>>>>>>>>>>>>///
70730>>>>>>>>>>>>>>>>>/// @Assumptions
70730>>>>>>>>>>>>>>>>>/// @Status      Public
70730>>>>>>>>>>>>>>>>>/// @Drivers     All
70730>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-19 by Aaron Gulack
70730>>>>>>>>>>>>>>>>>/// @See
70730>>>>>>>>>>>>>>>>>///
70730>>>>>>>>>>>>>>>>>/// @Syntax SQL_REFRESH_CACHE OF {FileNumber}
70730>>>>>>>>>>>>>>>>>/// @Param  FileNumber          The number of the file
70730>>>>>>>>>>>>>>>>>/// @Example
70730>>>>>>>>>>>>>>>>>/// Open Customer
70730>>>>>>>>>>>>>>>>>///
70730>>>>>>>>>>>>>>>>>/// Find gt Customer by Index.1
70730>>>>>>>>>>>>>>>>>/// While (Found) Begin
70730>>>>>>>>>>>>>>>>>///     showln "Customer name is " CUSTOMER.CUSTOMER
70730>>>>>>>>>>>>>>>>>/// Loop
70730>>>>>>>>>>>>>>>>>///
70730>>>>>>>>>>>>>>>>>/// SQL_REFRESH_CACHE of CUSTOMER
70730>>>>>>>>>>>>>>>>>
70730>>>>>>>>>>>>>>>>>//=============================================================================
70730>>>>>>>>>>>>>>>>>/// @Name        SQL_FOR_SET
70730>>>>>>>>>>>>>>>>>/// @Description Use this command during LT or GT finds to only fetch a set
70730>>>>>>>>>>>>>>>>>/// number of rows. An option is also available for this command to disable
70730>>>>>>>>>>>>>>>>>/// the local cash by passing NOCACHE at the end of the command call. Note
70730>>>>>>>>>>>>>>>>>/// that if the rowcount is set low, too many round-trips to the server may
70730>>>>>>>>>>>>>>>>>/// result, effecting performance significantly. Also, if the rowcount is set
70730>>>>>>>>>>>>>>>>>/// too high a large number of records can be pre-fetched and end up not being
70730>>>>>>>>>>>>>>>>>/// used by the application. Because of this, the default of 10 rows and a cache
70730>>>>>>>>>>>>>>>>>/// will be adequate for most situations.
70730>>>>>>>>>>>>>>>>>///
70730>>>>>>>>>>>>>>>>>/// @Assumptions
70730>>>>>>>>>>>>>>>>>/// @Status      Public
70730>>>>>>>>>>>>>>>>>/// @Drivers     All
70730>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
70730>>>>>>>>>>>>>>>>>/// @See
70730>>>>>>>>>>>>>>>>>///
70730>>>>>>>>>>>>>>>>>/// @Syntax SQL_FOR_SET {FileNumber} MAXROWS {variable} {CACHE/NOCACHE}
70730>>>>>>>>>>>>>>>>>/// @Param  FileNumber          The number of the file
70730>>>>>>>>>>>>>>>>>/// @Param  variable            The maximum number of rows to retrieve
70730>>>>>>>>>>>>>>>>>/// @Param  CACHE               fetched rows will be kept at the local cache
70730>>>>>>>>>>>>>>>>>/// @Param  NOCACHE             fetched rows will not be kept at the local cache
70730>>>>>>>>>>>>>>>>>/// @Example
70730>>>>>>>>>>>>>>>>>/// Open Customer
70730>>>>>>>>>>>>>>>>>///
70730>>>>>>>>>>>>>>>>>/// SQL_FOR_SET Customer MAXROWS 15 CACHE
70730>>>>>>>>>>>>>>>>>/// find gt Customer by Index.1
70730>>>>>>>>>>>>>>>>>
70730>>>>>>>>>>>>>>>>>//=============================================================================
70730>>>>>>>>>>>>>>>>>/// @Name        SQL_SET
70730>>>>>>>>>>>>>>>>>/// @Description Initializes and sets an initial statement for embedded
70730>>>>>>>>>>>>>>>>>/// sql execution.
70730>>>>>>>>>>>>>>>>>///
70730>>>>>>>>>>>>>>>>>/// @Assumptions Parameter may be more than 255 characters long so redirect to method.
70730>>>>>>>>>>>>>>>>>/// @Status      Deprecated
70730>>>>>>>>>>>>>>>>>/// @Drivers     All
70730>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
70730>>>>>>>>>>>>>>>>>/// @See         SQL_SET_STMT
70730>>>>>>>>>>>>>>>>>///
70730>>>>>>>>>>>>>>>>>/// @Syntax SQL_SET {FileNumber}
70730>>>>>>>>>>>>>>>>>/// @Param  FileNumber          The number of the file
70730>>>>>>>>>>>>>>>>>
70730>>>>>>>>>>>>>>>>>Procedure MertechInc_SQL_SET Global String sStatement
70732>>>>>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function 1 CALLBACK 0 PASSING MertechInc_Blank sStatement 0 RESULT MertechInc_iRet
70737>>>>>>>>>>>>>>>>>End_Procedure
70738>>>>>>>>>>>>>>>>>
70738>>>>>>>>>>>>>>>>>//=============================================================================
70738>>>>>>>>>>>>>>>>>/// @Name        SQL_APPEND
70738>>>>>>>>>>>>>>>>>/// @Description Appends a string value to the current embedded sql statement
70738>>>>>>>>>>>>>>>>>/// already set.
70738>>>>>>>>>>>>>>>>>///
70738>>>>>>>>>>>>>>>>>/// @Assumptions Parameter may be more than 255 characters long so redirect to method.
70738>>>>>>>>>>>>>>>>>/// @Status      Deprecated
70738>>>>>>>>>>>>>>>>>/// @Drivers     All
70738>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
70738>>>>>>>>>>>>>>>>>/// @See                 SQL_APPEND_STMT
70738>>>>>>>>>>>>>>>>>
70738>>>>>>>>>>>>>>>>>Procedure MertechInc_SQL_APPEND Global String sStatement
70740>>>>>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function 2 CALLBACK 0 PASSING MertechInc_Blank sStatement 0 RESULT MertechInc_iRet
70745>>>>>>>>>>>>>>>>>End_Procedure
70746>>>>>>>>>>>>>>>>>
70746>>>>>>>>>>>>>>>>>//=============================================================================
70746>>>>>>>>>>>>>>>>>/// @Name        SQL_EXECUTE
70746>>>>>>>>>>>>>>>>>/// @Description Executes the current embedded SQL statement set and commits
70746>>>>>>>>>>>>>>>>>/// finishing any pending transaction.
70746>>>>>>>>>>>>>>>>>///
70746>>>>>>>>>>>>>>>>>/// @Assumptions
70746>>>>>>>>>>>>>>>>>/// @Status      Deprecated
70746>>>>>>>>>>>>>>>>>/// @Drivers     All
70746>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
70746>>>>>>>>>>>>>>>>>/// @See                 SQL_EXECUTE_STMT
70746>>>>>>>>>>>>>>>>>
70746>>>>>>>>>>>>>>>>>//=============================================================================
70746>>>>>>>>>>>>>>>>>/// @Name        LOCK_TABLE
70746>>>>>>>>>>>>>>>>>/// @Description Locks a table. This is equivalent to locking a DAT file.
70746>>>>>>>>>>>>>>>>>///
70746>>>>>>>>>>>>>>>>>/// @Assumptions
70746>>>>>>>>>>>>>>>>>/// @Status      Deprecated
70746>>>>>>>>>>>>>>>>>/// @Drivers     DB2Flex, and ORAFlex 3.x
70746>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
70746>>>>>>>>>>>>>>>>>/// @See
70746>>>>>>>>>>>>>>>>>///
70746>>>>>>>>>>>>>>>>>/// @Syntax LOCK_TABLE {FileName} {FileName1} {FileName2} {FileName3}...
70746>>>>>>>>>>>>>>>>>/// @Param  FileName            The name of file to be locked. Can be more than one
70746>>>>>>>>>>>>>>>>>
70746>>>>>>>>>>>>>>>>>//=============================================================================
70746>>>>>>>>>>>>>>>>>/// @Name        SQL_CHECK_TABLE
70746>>>>>>>>>>>>>>>>>/// @Description Use this command to verify that a given table exists on the
70746>>>>>>>>>>>>>>>>>/// SQL backend. This command takes three arguments, a string containing the
70746>>>>>>>>>>>>>>>>>/// name of the database, a string containing the name of the user and finally
70746>>>>>>>>>>>>>>>>>/// a string containing the name of the table being checked. If the table exists,
70746>>>>>>>>>>>>>>>>>/// the program proceeds normally. If the table does not exist then the flag
70746>>>>>>>>>>>>>>>>>/// "finderr" is set to true. Note that in order to handle the error a check must
70746>>>>>>>>>>>>>>>>>/// be done on the "finderr" variable.
70746>>>>>>>>>>>>>>>>>///
70746>>>>>>>>>>>>>>>>>/// @Assumptions All three parameters are less than 256 characters long.
70746>>>>>>>>>>>>>>>>>/// @Status      Public
70746>>>>>>>>>>>>>>>>>/// @Drivers     All
70746>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
70746>>>>>>>>>>>>>>>>>/// @See
70746>>>>>>>>>>>>>>>>>///
70746>>>>>>>>>>>>>>>>>/// @Syntax SQL_CHECK_TABLE {database} {username} {table}
70746>>>>>>>>>>>>>>>>>/// @Param  database            Name of the database
70746>>>>>>>>>>>>>>>>>/// @Param  username            Name of the user
70746>>>>>>>>>>>>>>>>>/// @Param  table                       Name of the table being checked
70746>>>>>>>>>>>>>>>>>///
70746>>>>>>>>>>>>>>>>>/// @Example
70746>>>>>>>>>>>>>>>>>/// SQL_CHECK_TABLE "testDB" "user" "Customer"
70746>>>>>>>>>>>>>>>>>/// If (finderr) Begin
70746>>>>>>>>>>>>>>>>>///     Showln "This table does not exist"
70746>>>>>>>>>>>>>>>>>/// End
70746>>>>>>>>>>>>>>>>>
70746>>>>>>>>>>>>>>>>>//=============================================================================
70746>>>>>>>>>>>>>>>>>/// @Name        SET_SQL_CONSTRAINT
70746>>>>>>>>>>>>>>>>>/// @Description This command allows you to put an additional constraint on
70746>>>>>>>>>>>>>>>>>/// your finds, moving filtering to the SQL backend. Using this command can
70746>>>>>>>>>>>>>>>>>/// result in significantly improved performance, since the server network traffic
70746>>>>>>>>>>>>>>>>>/// reduced. Note that the SQL statement passed for this command is added onto
70746>>>>>>>>>>>>>>>>>/// the predefined Database SQL statement so treat it as such. Because of this,
70746>>>>>>>>>>>>>>>>>/// it will almost always begin with "AND" followed by the desired constraint.
70746>>>>>>>>>>>>>>>>>///
70746>>>>>>>>>>>>>>>>>/// @Assumptions Parameter may be more than 255 characters long so redirect to method.
70746>>>>>>>>>>>>>>>>>/// @Status      Public
70746>>>>>>>>>>>>>>>>>/// @Drivers     All
70746>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
70746>>>>>>>>>>>>>>>>>/// @See         SQL_CONSTRAINT GET_SQL_CONSTRAINT DF_FIELD_PROGRAMMATIC_DEFAULT
70746>>>>>>>>>>>>>>>>>///
70746>>>>>>>>>>>>>>>>>/// @Syntax SET_SQL_CONSTRAINT of {file} to {variable}
70746>>>>>>>>>>>>>>>>>/// @Param  file                        Name or Number of the file.
70746>>>>>>>>>>>>>>>>>/// @Param  variable            A SQL expression that constrains the data
70746>>>>>>>>>>>>>>>>>///
70746>>>>>>>>>>>>>>>>>/// @Example
70746>>>>>>>>>>>>>>>>>/// Open Customer
70746>>>>>>>>>>>>>>>>>///
70746>>>>>>>>>>>>>>>>>/// SET_SQL_CONSTRAINT of 1 to (SFormat('AND "%1"."%2" = ' + "'%3'", "Customer", "Status", "Active"))
70746>>>>>>>>>>>>>>>>>///
70746>>>>>>>>>>>>>>>>>/// For_All Customer by Index.1 do
70746>>>>>>>>>>>>>>>>>///     Showln Customer.FirstName
70746>>>>>>>>>>>>>>>>>/// End_For_All
70746>>>>>>>>>>>>>>>>>
70746>>>>>>>>>>>>>>>>>Procedure MertechInc_SET_SQL_CONSTRAINT Global Integer iFunction String sConstraint
70748>>>>>>>>>>>>>>>>>    Call_Driver MertechInc_FileNumber MertechInc_DriverName Function iFunction CALLBACK 0 PASSING sConstraint MertechInc_Blank 0 RESULT MertechInc_iRet
70753>>>>>>>>>>>>>>>>>End_Procedure
70754>>>>>>>>>>>>>>>>>
70754>>>>>>>>>>>>>>>>>Procedure MertechInc_SET_SQL_CONSTRAINT_PROGRAMMATIC Global Integer iFunction
70756>>>>>>>>>>>>>>>>>    Call_Driver MertechInc_FileNumber MertechInc_DriverName Function iFunction CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank 4 RESULT MertechInc_iRet
70761>>>>>>>>>>>>>>>>>End_Procedure
70762>>>>>>>>>>>>>>>>>
70762>>>>>>>>>>>>>>>>>//=============================================================================
70762>>>>>>>>>>>>>>>>>/// @Name        GET_SQL_CONSTRAINT
70762>>>>>>>>>>>>>>>>>/// @Description This command returns the current SQL constraint for the given
70762>>>>>>>>>>>>>>>>>/// table.  If there is no current constraint, then a blank string is returned.
70762>>>>>>>>>>>>>>>>>///
70762>>>>>>>>>>>>>>>>>/// @Assumptions Parameter may be more than 255 characters long so redirect to method.
70762>>>>>>>>>>>>>>>>>/// @Status      Public
70762>>>>>>>>>>>>>>>>>/// @Drivers     All
70762>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
70762>>>>>>>>>>>>>>>>>/// @See         SQL_CONSTRAINT SET_SQL_CONSTRAINT
70762>>>>>>>>>>>>>>>>>///
70762>>>>>>>>>>>>>>>>>/// @Syntax GET_SQL_CONSTRAINT of {File} to {variable}
70762>>>>>>>>>>>>>>>>>/// @Param  File                        Name or number of the file
70762>>>>>>>>>>>>>>>>>/// @Param  variable            The string containing the constraining SQL expression
70762>>>>>>>>>>>>>>>>>///
70762>>>>>>>>>>>>>>>>>/// @Example
70762>>>>>>>>>>>>>>>>>/// Open Customer
70762>>>>>>>>>>>>>>>>>///
70762>>>>>>>>>>>>>>>>>/// String sCon
70762>>>>>>>>>>>>>>>>>///
70762>>>>>>>>>>>>>>>>>/// SET_SQL_CONSTRAINT of Customer to (SFormat('AND "%1"."%2" = ' + "'%3'", "Customer", "Status", "Active"))
70762>>>>>>>>>>>>>>>>>/// GET_SQL_CONSTRAINT of Customer to sCon
70762>>>>>>>>>>>>>>>>>///
70762>>>>>>>>>>>>>>>>>/// For_All Customer by Index.1 do
70762>>>>>>>>>>>>>>>>>///     Showln Customer.FirstName
70762>>>>>>>>>>>>>>>>>///     Showln sCon
70762>>>>>>>>>>>>>>>>>/// End_For_All
70762>>>>>>>>>>>>>>>>>
70762>>>>>>>>>>>>>>>>>Function MertechInc_GET_SQL_CONSTRAINT Global Integer iFunction Returns String
70764>>>>>>>>>>>>>>>>>    String sConstraint
70764>>>>>>>>>>>>>>>>>    Get MertechInc_Pre_Size_String 0 to sConstraint
70765>>>>>>>>>>>>>>>>>
70765>>>>>>>>>>>>>>>>>    Call_Driver MertechInc_FileNumber MertechInc_DriverName Function iFunction CALLBACK 0 PASSING sConstraint MertechInc_Blank 3 RESULT MertechInc_iRet
70770>>>>>>>>>>>>>>>>>    Function_Return sConstraint
70771>>>>>>>>>>>>>>>>>End_Function
70772>>>>>>>>>>>>>>>>>
70772>>>>>>>>>>>>>>>>>//=============================================================================
70772>>>>>>>>>>>>>>>>>/// @Name        SQL_CONSTRAINT
70772>>>>>>>>>>>>>>>>>/// @Description This command is used to toggle on or off the current SQL
70772>>>>>>>>>>>>>>>>>/// constraint that is set for a table. To deactivate the current constraint,
70772>>>>>>>>>>>>>>>>>/// pass the constant DEACTIVATE to this command. to reactivate the constraint,
70772>>>>>>>>>>>>>>>>>/// pass ACTIVATE to this command.
70772>>>>>>>>>>>>>>>>>///
70772>>>>>>>>>>>>>>>>>/// @Status      Public
70772>>>>>>>>>>>>>>>>>/// @Drivers     All
70772>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
70772>>>>>>>>>>>>>>>>>/// @See         SET_SQL_CONSTRAINT GET_SQL_CONSTRAINT
70772>>>>>>>>>>>>>>>>>///
70772>>>>>>>>>>>>>>>>>/// @Syntax SQL_CONSTRAINT of {File} to {Activate|Deactivate}
70772>>>>>>>>>>>>>>>>>/// @Param  File                        Name or Number of the file
70772>>>>>>>>>>>>>>>>>/// @Param  Activate            Activates the constraint
70772>>>>>>>>>>>>>>>>>/// @Param  Deactivate          Deactivates the constraint
70772>>>>>>>>>>>>>>>>>///
70772>>>>>>>>>>>>>>>>>/// @Example
70772>>>>>>>>>>>>>>>>>/// Open Customer
70772>>>>>>>>>>>>>>>>>///
70772>>>>>>>>>>>>>>>>>/// SET_SQL_CONSTRAINT of Customer to (SFormat('AND "%1"."%2" = ' + "'%3'", "Customer", "FirstName", "Aaron"))
70772>>>>>>>>>>>>>>>>>/// SQL_CONSTRAINT of Customer to Deactivate
70772>>>>>>>>>>>>>>>>>///
70772>>>>>>>>>>>>>>>>>/// For_All Customer by Index.1 do
70772>>>>>>>>>>>>>>>>>///     Showln Customer.FirstName
70772>>>>>>>>>>>>>>>>>/// End_For_All
70772>>>>>>>>>>>>>>>>>
70772>>>>>>>>>>>>>>>>>//=============================================================================
70772>>>>>>>>>>>>>>>>>/// @Name        CREATE_TD_FILE
70772>>>>>>>>>>>>>>>>>/// @Description A .TD file is created when the attribute is set to True.
70772>>>>>>>>>>>>>>>>>///
70772>>>>>>>>>>>>>>>>>/// @Assumptions
70772>>>>>>>>>>>>>>>>>/// @Status      Deprecated
70772>>>>>>>>>>>>>>>>>/// @Drivers     All
70772>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-20 by Aaron Gulack
70772>>>>>>>>>>>>>>>>>/// @See
70772>>>>>>>>>>>>>>>>>///
70772>>>>>>>>>>>>>>>>>/// @Syntax CREATE_TD_FILE {variable}
70772>>>>>>>>>>>>>>>>>/// @Param  variable            True to create the .TD file, false doesn't create it.
70772>>>>>>>>>>>>>>>>>
70772>>>>>>>>>>>>>>>>>//=============================================================================
70772>>>>>>>>>>>>>>>>>/// @Name        OPEN_INT
70772>>>>>>>>>>>>>>>>>/// @Description This command is used to replace the OPEN command in DataFlex.
70772>>>>>>>>>>>>>>>>>/// It can be useful when accessing tables that are not in the current filelist.
70772>>>>>>>>>>>>>>>>>/// To access these tables, the INT and FD files must be in the directory. From
70772>>>>>>>>>>>>>>>>>/// there, all that is needed is to open the table using this command under an
70772>>>>>>>>>>>>>>>>>/// alias name. If the command is executed successfully then the table can be
70772>>>>>>>>>>>>>>>>>/// queried normally as if it were a standard table. Note that if the desired
70772>>>>>>>>>>>>>>>>>/// table is already in the filelist or doesn't have an INT file then this
70772>>>>>>>>>>>>>>>>>/// command will act as a normal open command.
70772>>>>>>>>>>>>>>>>>///
70772>>>>>>>>>>>>>>>>>/// @Assumptions
70772>>>>>>>>>>>>>>>>>/// @Status      Public
70772>>>>>>>>>>>>>>>>>/// @Drivers     All
70772>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-21 by Aaron Gulack
70772>>>>>>>>>>>>>>>>>/// @See
70772>>>>>>>>>>>>>>>>>///
70772>>>>>>>>>>>>>>>>>/// @Syntax OPEN_INT {variable} as {aliasName}
70772>>>>>>>>>>>>>>>>>/// @Param  variable            The name of the int file without the extension.
70772>>>>>>>>>>>>>>>>>/// @Param  aliasName           The alias name being used to query this table.
70772>>>>>>>>>>>>>>>>>/// @Example
70772>>>>>>>>>>>>>>>>>/// OPEN_INT "customer" as Customer
70772>>>>>>>>>>>>>>>>>///
70772>>>>>>>>>>>>>>>>>/// For_All Customer by Index.1 do
70772>>>>>>>>>>>>>>>>>///     Showln Customer.FirstName
70772>>>>>>>>>>>>>>>>>/// End_For_All
70772>>>>>>>>>>>>>>>>>
70772>>>>>>>>>>>>>>>>>//=============================================================================
70772>>>>>>>>>>>>>>>>>/// @Name        SET_OPEN_MODE
70772>>>>>>>>>>>>>>>>>/// @Description This command is used to enable an option known as "Lazy Open
70772>>>>>>>>>>>>>>>>>/// Mode". When turned on the table's metadata i.e. table, columns, index
70772>>>>>>>>>>>>>>>>>/// descriptions, is deferred until a field is accessed, even if a OPEN has
70772>>>>>>>>>>>>>>>>>/// already been done. This can significantly improve an application's initial
70772>>>>>>>>>>>>>>>>>/// performance, especially when a large number of files are opened when the
70772>>>>>>>>>>>>>>>>>/// program is launched. By default, tables are set to open normally, but by
70772>>>>>>>>>>>>>>>>>/// passing the constant LAZY_MODE to this command, it can be altered to use
70772>>>>>>>>>>>>>>>>>/// this mode. Note that when this mode is activated, it effects all tables
70772>>>>>>>>>>>>>>>>>/// that are opened. To deactivate this feature, pass the constant "DEFAULT"
70772>>>>>>>>>>>>>>>>>/// to this command at any time. This is the preferred method to activate or
70772>>>>>>>>>>>>>>>>>/// deactive this feature but it can also be set globally in the .INI file.
70772>>>>>>>>>>>>>>>>>///
70772>>>>>>>>>>>>>>>>>/// Default Value: DEFAULT (Off)
70772>>>>>>>>>>>>>>>>>///
70772>>>>>>>>>>>>>>>>>/// @Assumptions
70772>>>>>>>>>>>>>>>>>/// @Status      Public
70772>>>>>>>>>>>>>>>>>/// @Drivers     All
70772>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-21 by Aaron Gulack
70772>>>>>>>>>>>>>>>>>/// @See
70772>>>>>>>>>>>>>>>>>///
70772>>>>>>>>>>>>>>>>>/// @Syntax SET_OPEN_MODE to {DEFAULT/LAZY_MODE}
70772>>>>>>>>>>>>>>>>>/// @Param  DEFAULT                     Used to turn of the lazy mode feature.
70772>>>>>>>>>>>>>>>>>/// @Param  LAZY_MODE           Turns on the lazy mode feature
70772>>>>>>>>>>>>>>>>>///
70772>>>>>>>>>>>>>>>>>/// @Example
70772>>>>>>>>>>>>>>>>>/// SET_OPEN_MODE TO LAZY_MODE
70772>>>>>>>>>>>>>>>>>/// Open "customer.int" as Customer
70772>>>>>>>>>>>>>>>>>/// ...
70772>>>>>>>>>>>>>>>>>/// ...
70772>>>>>>>>>>>>>>>>>/// Find gt Customer by Index.1
70772>>>>>>>>>>>>>>>>>
70772>>>>>>>>>>>>>>>>>//=============================================================================
70772>>>>>>>>>>>>>>>>>/// @Name        SQL_SET_STMT
70772>>>>>>>>>>>>>>>>>/// @Description Use this command to set an SQL statement to be executed on the
70772>>>>>>>>>>>>>>>>>/// desired table. The string passed to this command must be a valid SQL
70772>>>>>>>>>>>>>>>>>/// expression and must be on a table that has already been opened. Note that
70772>>>>>>>>>>>>>>>>>/// when using this command, the SQL_PREPARE_STMT and SQL_EXECUTE_STMT must be
70772>>>>>>>>>>>>>>>>>/// used in addition to carry out the expression. The option to pass the file
70772>>>>>>>>>>>>>>>>>/// name as an extra parameter is used in cases where the data needs to be
70772>>>>>>>>>>>>>>>>>/// fetched directly into the record buffer of the specified file.
70772>>>>>>>>>>>>>>>>>///
70772>>>>>>>>>>>>>>>>>/// @Assumptions Parameter may be more than 255 characters long so redirect to method.
70772>>>>>>>>>>>>>>>>>/// @Status      Public
70772>>>>>>>>>>>>>>>>>/// @Drivers     All
70772>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-21 by Aaron Gulack
70772>>>>>>>>>>>>>>>>>/// @See                 SQL_APPEND_STMT SQL_PREPARE_STMT SQL_EXECUTE_STMT SQL_CANCEL_QUERY_STMT SQL_FETCH_NEXT_ROW SQL_BINDCOLUMNS_STMT
70772>>>>>>>>>>>>>>>>>///
70772>>>>>>>>>>>>>>>>>/// @Syntax SQL_SET_STMT [of {file}] to {variable}
70772>>>>>>>>>>>>>>>>>/// @Param file                         Name or number of the file (optional)
70772>>>>>>>>>>>>>>>>>/// @Param variable                     String containing the SQL statement
70772>>>>>>>>>>>>>>>>>///
70772>>>>>>>>>>>>>>>>>/// @Usage SQL_SET_STMT of Customer to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
70772>>>>>>>>>>>>>>>>>/// @Usage SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
70772>>>>>>>>>>>>>>>>>///
70772>>>>>>>>>>>>>>>>>/// @Example
70772>>>>>>>>>>>>>>>>>/// Open Customer
70772>>>>>>>>>>>>>>>>>///
70772>>>>>>>>>>>>>>>>>/// String sID sFirstName sLastName sDOB
70772>>>>>>>>>>>>>>>>>///
70772>>>>>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
70772>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT
70772>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
70772>>>>>>>>>>>>>>>>>/// While (Found)
70772>>>>>>>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sID sFirstName sLastName sDOB
70772>>>>>>>>>>>>>>>>>///     Showln sID
70772>>>>>>>>>>>>>>>>>///     Showln sFirstName
70772>>>>>>>>>>>>>>>>>///     Showln sLastName
70772>>>>>>>>>>>>>>>>>///     Showln sDOB
70772>>>>>>>>>>>>>>>>>/// Loop
70772>>>>>>>>>>>>>>>>>/// SQL_CANCEL_QUERY_STMT
70772>>>>>>>>>>>>>>>>>
70772>>>>>>>>>>>>>>>>>Procedure MertechInc_SQL_SET_STMT Global String sStatment
70774>>>>>>>>>>>>>>>>>    Call_Driver MertechInc_FileNumber MertechInc_DriverName Function 22 CALLBACK 0 PASSING MertechInc_Blank sStatment 0 RESULT MertechInc_iRet
70779>>>>>>>>>>>>>>>>>End_Procedure
70780>>>>>>>>>>>>>>>>>
70780>>>>>>>>>>>>>>>>>//=============================================================================
70780>>>>>>>>>>>>>>>>>/// @Name        SQL_APPEND_STMT
70780>>>>>>>>>>>>>>>>>/// @Description This command is used to append a command string to the
70780>>>>>>>>>>>>>>>>>/// command buffer initialized by SQL_SET_STMT. SQL_APPEND_STMT was added
70780>>>>>>>>>>>>>>>>>/// so that long SQL expressions could be broken into smaller strings and
70780>>>>>>>>>>>>>>>>>/// appended to a dynamic command buffer, which is then passed to the server.
70780>>>>>>>>>>>>>>>>>/// The SQL_APPEND_STMT will concatenate a string to the command buffer
70780>>>>>>>>>>>>>>>>>/// initialized by the SQL_SET_STMT command. SQL_APPEND_STMT can be called as
70780>>>>>>>>>>>>>>>>>/// many times as necessary to complete the SQL expression. Subsequently, the
70780>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT command executes the completed command.  The option to
70780>>>>>>>>>>>>>>>>>/// pass the file name as an extra parameter is used in cases where the data
70780>>>>>>>>>>>>>>>>>/// needs to be fetched directly into the record buffer of the specified file.
70780>>>>>>>>>>>>>>>>>///
70780>>>>>>>>>>>>>>>>>/// @Assumptions Parameter may be more than 255 characters long so redirect to method.
70780>>>>>>>>>>>>>>>>>/// @Status      Public
70780>>>>>>>>>>>>>>>>>/// @Drivers     All
70780>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-22 by Aaron Gulack
70780>>>>>>>>>>>>>>>>>/// @See                 SQL_SET_STMT SQL_PREPARE_STMT SQL_EXECUTE_STMT SQL_CANCEL_QUERY_STMT SQL_FETCH_NEXT_ROW SQL_BINDCOLUMNS_STMT
70780>>>>>>>>>>>>>>>>>///
70780>>>>>>>>>>>>>>>>>/// @Syntax SQL_APPEND_STMT [of {file}] to {variable}
70780>>>>>>>>>>>>>>>>>/// @Param file                         The name or number of the file (optional)
70780>>>>>>>>>>>>>>>>>/// @Param variable                     The string to be appended to the current SQL expression
70780>>>>>>>>>>>>>>>>>///
70780>>>>>>>>>>>>>>>>>/// @Usage SQL_APPEND_STMT to " CUSTOMER.PHONE_NUMBER, CUSTOMER.FAX_NUMBER"
70780>>>>>>>>>>>>>>>>>/// @Usage SQL_APPEND_STMT of Customer to " CUSTOMER.PHONE_NUMBER, CUSTOMER.FAX_NUMBER"
70780>>>>>>>>>>>>>>>>>///
70780>>>>>>>>>>>>>>>>>/// @Example
70780>>>>>>>>>>>>>>>>>/// Open Customer
70780>>>>>>>>>>>>>>>>>///
70780>>>>>>>>>>>>>>>>>/// String sID sFirstName sLastName sDOB
70780>>>>>>>>>>>>>>>>>///
70780>>>>>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
70780>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT
70780>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
70780>>>>>>>>>>>>>>>>>/// While (Found)
70780>>>>>>>>>>>>>>>>>///     SQL_FETCH_NEXT_ROW into sID sFirstName sLastName sDOB
70780>>>>>>>>>>>>>>>>>///     Showln sID
70780>>>>>>>>>>>>>>>>>///     Showln sFirstName
70780>>>>>>>>>>>>>>>>>///     Showln sLastName
70780>>>>>>>>>>>>>>>>>///     Showln sDOB
70780>>>>>>>>>>>>>>>>>/// Loop
70780>>>>>>>>>>>>>>>>>/// SQL_CANCEL_QUERY_STMT
70780>>>>>>>>>>>>>>>>>
70780>>>>>>>>>>>>>>>>>Procedure MertechInc_SQL_APPEND_STMT Global String sStatement
70782>>>>>>>>>>>>>>>>>    Call_Driver MertechInc_FileNumber MertechInc_DriverName Function 22 CALLBACK 0 PASSING MertechInc_Blank sStatement 1 RESULT MertechInc_iRet
70787>>>>>>>>>>>>>>>>>End_Procedure
70788>>>>>>>>>>>>>>>>>
70788>>>>>>>>>>>>>>>>>//=============================================================================
70788>>>>>>>>>>>>>>>>>/// @Name        APPEND_UPDATE_COLUMN
70788>>>>>>>>>>>>>>>>>/// @Description Append a given string to the existing SQL statement
70788>>>>>>>>>>>>>>>>>/// already set.
70788>>>>>>>>>>>>>>>>>///
70788>>>>>>>>>>>>>>>>>/// @Assumptions Parameter may be more than 255 characters long so redirect to method
70788>>>>>>>>>>>>>>>>>/// @Status      Internal
70788>>>>>>>>>>>>>>>>>/// @Drivers     All
70788>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-23 by Aaron Gulack
70788>>>>>>>>>>>>>>>>>/// @See
70788>>>>>>>>>>>>>>>>>///
70788>>>>>>>>>>>>>>>>>/// @Syntax APPEND_UPDCOL_STMT {variable} for {fileName}.{fieldName} {fields...}
70788>>>>>>>>>>>>>>>>>/// @Param variable                             SQL expression to be appended
70788>>>>>>>>>>>>>>>>>/// @Param fileName                             Name of the file
70788>>>>>>>>>>>>>>>>>/// @Param fieldName                    Name of the field
70788>>>>>>>>>>>>>>>>>/// @Param fields...                    Any additional fields, use the file.field format
70788>>>>>>>>>>>>>>>>>
70788>>>>>>>>>>>>>>>>>Procedure MertechInc_APPEND_UPDATE_COLUMN Global String sStatement
70790>>>>>>>>>>>>>>>>>    Call_Driver MertechInc_FileNumber MertechInc_DriverName Function 22 CALLBACK 0 PASSING MertechInc_Blank sStatement 1 RESULT MertechInc_iRet
70795>>>>>>>>>>>>>>>>>End_Procedure
70796>>>>>>>>>>>>>>>>>
70796>>>>>>>>>>>>>>>>>//=============================================================================
70796>>>>>>>>>>>>>>>>>/// @Name        SQL_APPEND_UPDCOL_STMT
70796>>>>>>>>>>>>>>>>>/// @Description Used to optimize the update process of columns being loaded
70796>>>>>>>>>>>>>>>>>/// with the same value.
70796>>>>>>>>>>>>>>>>>///
70796>>>>>>>>>>>>>>>>>/// @Assumptions
70796>>>>>>>>>>>>>>>>>/// @Status      Deprecated
70796>>>>>>>>>>>>>>>>>/// @Drivers     All
70796>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-23 by Aaron Gulack
70796>>>>>>>>>>>>>>>>>/// @See
70796>>>>>>>>>>>>>>>>>///
70796>>>>>>>>>>>>>>>>>/// @Syntax SQL_APPEND_UPDCOL_STMT [of {file}] Value {variable} for {fileName}.{fieldName} {fields...}
70796>>>>>>>>>>>>>>>>>/// @Param file                         The name or number of the file (optional)
70796>>>>>>>>>>>>>>>>>/// @Param variable                     The value being uploaded
70796>>>>>>>>>>>>>>>>>/// @Param fileName                     The name of the file
70796>>>>>>>>>>>>>>>>>/// @Param fieldName            The name of the field
70796>>>>>>>>>>>>>>>>>/// @Param fields...            Any additional fields, use the file.field format
70796>>>>>>>>>>>>>>>>>///
70796>>>>>>>>>>>>>>>>>/// @Example
70796>>>>>>>>>>>>>>>>>/// Open Customer
70796>>>>>>>>>>>>>>>>>///
70796>>>>>>>>>>>>>>>>>/// SQL_SET_STMT    of Customer to "UPDATE CUSTOMER SET"
70796>>>>>>>>>>>>>>>>>/// SQL_APPEND_STMT of Customer to " ASC11='x', ASC12='y', ASC13='z'"
70796>>>>>>>>>>>>>>>>>///
70796>>>>>>>>>>>>>>>>>/// SQL_APPEND_UPDCOL_STMT of Customer value 0 ;
70796>>>>>>>>>>>>>>>>>///     for Customer.ID Customer.Purchases Customer.Credit ;
70796>>>>>>>>>>>>>>>>>///
70796>>>>>>>>>>>>>>>>>/// SQL_APPEND_STMT of Customer to " WHERE RECNUM=1"
70796>>>>>>>>>>>>>>>>>///
70796>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT of Customer
70796>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT of Customer
70796>>>>>>>>>>>>>>>>>
70796>>>>>>>>>>>>>>>>>//=============================================================================
70796>>>>>>>>>>>>>>>>>/// @Name        SQL_SET_CURSOR_TYPE
70796>>>>>>>>>>>>>>>>>/// @Description Specify the SQL cursor type to be used during the next
70796>>>>>>>>>>>>>>>>>/// embedded SQL statement execution.
70796>>>>>>>>>>>>>>>>>///
70796>>>>>>>>>>>>>>>>>/// @Assumptions
70796>>>>>>>>>>>>>>>>>/// @Status      Internal
70796>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex
70796>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-23 by Aaron Gulack
70796>>>>>>>>>>>>>>>>>/// @See
70796>>>>>>>>>>>>>>>>>///
70796>>>>>>>>>>>>>>>>>/// @Syntax SQL_SET_CURSOR_TYPE to {TYPE_NONE/TYPE_CLIENT/TYPE_SERVER}
70796>>>>>>>>>>>>>>>>>/// @Param TYPE_NONE                    the default cursor type should be used
70796>>>>>>>>>>>>>>>>>/// @Param TYPE_CLIENT                  a client side cursor should be used
70796>>>>>>>>>>>>>>>>>/// @Param TYPE_SERVER                  a server side cursor should be used
70796>>>>>>>>>>>>>>>>>
70796>>>>>>>>>>>>>>>>>//=============================================================================
70796>>>>>>>>>>>>>>>>>/// @Name        CLEAR_INT_CACHE
70796>>>>>>>>>>>>>>>>>/// @Description Clears all memory-cached INT info. This is used in the
70796>>>>>>>>>>>>>>>>>/// test framework to force a "reload" of int info which the framework
70796>>>>>>>>>>>>>>>>>/// modifies for its tests. This is a different cache than the TD files
70796>>>>>>>>>>>>>>>>>/// which are a file based cache of the structure for use at file open.
70796>>>>>>>>>>>>>>>>>///
70796>>>>>>>>>>>>>>>>>/// @Assumptions
70796>>>>>>>>>>>>>>>>>/// @Status      Internal
70796>>>>>>>>>>>>>>>>>/// @Drivers     All
70796>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-23 by Aaron Gulack
70796>>>>>>>>>>>>>>>>>/// @See
70796>>>>>>>>>>>>>>>>>///
70796>>>>>>>>>>>>>>>>>/// @Syntax CLEAR_INT_CACHE
70796>>>>>>>>>>>>>>>>>
70796>>>>>>>>>>>>>>>>>//=============================================================================
70796>>>>>>>>>>>>>>>>>/// @Name        CREATE_INVERSE_KEY_FUNCTIONS
70796>>>>>>>>>>>>>>>>>/// @Description Create SQL Functions to handle Inverse Key columns.
70796>>>>>>>>>>>>>>>>>///
70796>>>>>>>>>>>>>>>>>/// @Assumptions
70796>>>>>>>>>>>>>>>>>/// @Status      Internal
70796>>>>>>>>>>>>>>>>>/// @Drivers     All (v10.1 and above)
70796>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-23 by Aaron Gulack
70796>>>>>>>>>>>>>>>>>/// @See
70796>>>>>>>>>>>>>>>>>///
70796>>>>>>>>>>>>>>>>>/// @Syntax CREATE_INVERSE_KEY_FUNCTIONS
70796>>>>>>>>>>>>>>>>>
70796>>>>>>>>>>>>>>>>>//=============================================================================
70796>>>>>>>>>>>>>>>>>/// @Name        SQL_PREPARE_STMT
70796>>>>>>>>>>>>>>>>>/// @Description Prepares a statement and opens a cursor to be executed by
70796>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT. This command tells the server to parse the SQL statement
70796>>>>>>>>>>>>>>>>>/// created by the respective SQL_SET_STMT and all subsequent SQL_APPEND_STMT
70796>>>>>>>>>>>>>>>>>/// statements and to allocate cursor handles to be used to fetch the data.
70796>>>>>>>>>>>>>>>>>/// A cursor can be thought of as a pointer to a record set. The CURSOR_TYPE
70796>>>>>>>>>>>>>>>>>/// argument is only supported by SQLFlex and by default SQLFLex is using a
70796>>>>>>>>>>>>>>>>>/// TYPE_SERVER cursor type to all embedded SQL. TYPE_CLIENT should be used only
70796>>>>>>>>>>>>>>>>>/// for the statements that are querying LOB columns i.e. TEXT, NVARCHAR(MAX),
70796>>>>>>>>>>>>>>>>>/// VARCHAR(MAX), IMAGE, VARBINARY(MAX), XML. If the cursor type is
70796>>>>>>>>>>>>>>>>>/// TYPE_SERVER and a LOB type column is selected, MS SQL Server will not be
70796>>>>>>>>>>>>>>>>>/// able to get into a transaction, either explicitly or implicitly through a
70796>>>>>>>>>>>>>>>>>/// REREAD, LOCK, SAVERECORD, etc.
70796>>>>>>>>>>>>>>>>>///
70796>>>>>>>>>>>>>>>>>/// @Assumptions
70796>>>>>>>>>>>>>>>>>/// @Status      Public
70796>>>>>>>>>>>>>>>>>/// @Drivers     All
70796>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-23 by Aaron Gulack
70796>>>>>>>>>>>>>>>>>/// @See                 SQL_SET_STMT SQL_APPEND_STMT SQL_EXECUTE_STMT SQL_CANCEL_QUERY_STMT SQL_FETCH_NEXT_ROW SQL_BINDCOLUMNS_STMT
70796>>>>>>>>>>>>>>>>>///
70796>>>>>>>>>>>>>>>>>/// @Syntax SQL_PREPARE_STMT [of {file}] CURSOR_TYPE {TYPE_NONE/TYPE_CLIENT/TYPE_SERVER}
70796>>>>>>>>>>>>>>>>>/// @Param file                         The name or number of the file (optional)
70796>>>>>>>>>>>>>>>>>/// @Param CURSOR_TYPE          Used if the cursor type is being set, do not include otherwise
70796>>>>>>>>>>>>>>>>>/// @Param TYPE_NONE            Default cursor will be used
70796>>>>>>>>>>>>>>>>>/// @Param TYPE_CLIENT          A client side cursor should be used
70796>>>>>>>>>>>>>>>>>/// @Param TYPE_SERVER          A server side cursor should be used (Default)
70796>>>>>>>>>>>>>>>>>///
70796>>>>>>>>>>>>>>>>>/// @Usage SQL_PREPARE_STMT
70796>>>>>>>>>>>>>>>>>/// @Usage SQL_PREPARE_STMT of Customer
70796>>>>>>>>>>>>>>>>>/// @Usage SQL_PREPARE_STMT CURSOR_TYPE TYPE_SERVER
70796>>>>>>>>>>>>>>>>>/// @Usage SQL_PREPARE_STMT of Customer CURSOR_TYPE TYPE_CLIENT
70796>>>>>>>>>>>>>>>>>///
70796>>>>>>>>>>>>>>>>>/// @Example
70796>>>>>>>>>>>>>>>>>/// Open Customer
70796>>>>>>>>>>>>>>>>>///
70796>>>>>>>>>>>>>>>>>/// String sID sFirstName
70796>>>>>>>>>>>>>>>>>///
70796>>>>>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
70796>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT
70796>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
70796>>>>>>>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sID sFirstName
70796>>>>>>>>>>>>>>>>>
70796>>>>>>>>>>>>>>>>>//=============================================================================
70796>>>>>>>>>>>>>>>>>/// @Name        SQL_BIND_COLUMN
70796>>>>>>>>>>>>>>>>>/// @Description Clears all cached INT info. This should be merged with
70796>>>>>>>>>>>>>>>>>/// SQL_BINDCOLUMNS_STMT, but has to remain as a separate command for
70796>>>>>>>>>>>>>>>>>/// compatibility.
70796>>>>>>>>>>>>>>>>>///
70796>>>>>>>>>>>>>>>>>/// @Assumptions
70796>>>>>>>>>>>>>>>>>/// @Status      Internal
70796>>>>>>>>>>>>>>>>>/// @Drivers     All
70796>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-26 by Aaron Gulack
70796>>>>>>>>>>>>>>>>>/// @See
70796>>>>>>>>>>>>>>>>>///
70796>>>>>>>>>>>>>>>>>/// @Syntax SQL_BIND_COLUMN FileNumber FieldNumber | DF_BIND_ALL_COLUMNS
70796>>>>>>>>>>>>>>>>>/// @Param FileNumber                   The number of the file
70796>>>>>>>>>>>>>>>>>/// @Param FieldNumber                  The number of the field
70796>>>>>>>>>>>>>>>>>
70796>>>>>>>>>>>>>>>>>//=============================================================================
70796>>>>>>>>>>>>>>>>>/// @Name        SQL_BINDCOLUMNS_STMT
70796>>>>>>>>>>>>>>>>>/// @Description This command is used to fetch the returned data of a
70796>>>>>>>>>>>>>>>>>/// specified SQL expression into the given field in the record buffer. By
70796>>>>>>>>>>>>>>>>>/// passing any number of fields to this command, the fetched record will then
70796>>>>>>>>>>>>>>>>>/// be put into the subsequent fields in the record buffer. The order of the
70796>>>>>>>>>>>>>>>>>/// fields must be the same as the order of the columns being retrieved from
70796>>>>>>>>>>>>>>>>>/// the SQL expression. SQL_FETCH_NEXT_ROW can then be called to take the data
70796>>>>>>>>>>>>>>>>>/// retrieved from the server and place it into the corresponding fields in the
70796>>>>>>>>>>>>>>>>>/// buffer. Instead of specifying each field, DF_BIND_ALL_COLUMNS can be passed,
70796>>>>>>>>>>>>>>>>>/// which will retrieve every column in the table.
70796>>>>>>>>>>>>>>>>>///
70796>>>>>>>>>>>>>>>>>/// @Assumptions
70796>>>>>>>>>>>>>>>>>/// @Status      Public
70796>>>>>>>>>>>>>>>>>/// @Drivers     All
70796>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-26 by Aaron Gulack
70796>>>>>>>>>>>>>>>>>/// @See                 SQL_SET_STMT SQL_APPEND_STMT SQL_PREPARE_STMT SQL_EXECUTE_STMT SQL_CANCEL_QUERY_STMT SQL_FETCH_NEXT_ROW
70796>>>>>>>>>>>>>>>>>///
70796>>>>>>>>>>>>>>>>>/// @Syntax SQL_BINDCOLUMNS_STMT of {file} to {field/DF_BIND_ALL_COLUMNS}
70796>>>>>>>>>>>>>>>>>///
70796>>>>>>>>>>>>>>>>>/// @Param file                 Name or number of the file
70796>>>>>>>>>>>>>>>>>/// @Param field                        Name or number of the field (can be multiple)
70796>>>>>>>>>>>>>>>>>/// @Param DF_BIND_ALL_COLUMNS  Used instead of the field to retrieve all columns in the file
70796>>>>>>>>>>>>>>>>>///
70796>>>>>>>>>>>>>>>>>/// @Example
70796>>>>>>>>>>>>>>>>>/// Open Customer
70796>>>>>>>>>>>>>>>>>///
70796>>>>>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
70796>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT
70796>>>>>>>>>>>>>>>>>/// SQL_BINDCOLUMNS_STMT of Customer to DF_BIND_ALL_COLUMNS
70796>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT of Customer
70796>>>>>>>>>>>>>>>>>/// While (Found)
70796>>>>>>>>>>>>>>>>>///     SQL_FETCH_NEXT_ROW of Customer
70796>>>>>>>>>>>>>>>>>///     Showln Customer.ID
70796>>>>>>>>>>>>>>>>>///     Showln Customer.FirstName
70796>>>>>>>>>>>>>>>>>///     Showln Customer.LastName
70796>>>>>>>>>>>>>>>>>///     Showln Customer.DOB
70796>>>>>>>>>>>>>>>>>/// Loop
70796>>>>>>>>>>>>>>>>>/// SQL_CANCEL_QUERY_STMT
70796>>>>>>>>>>>>>>>>>
70796>>>>>>>>>>>>>>>>>//=============================================================================
70796>>>>>>>>>>>>>>>>>/// @Name        SQL_EXECUTE_STMT
70796>>>>>>>>>>>>>>>>>/// @Description This command is used to execute the SQL expression created
70796>>>>>>>>>>>>>>>>>/// by the SQL_SET_STMT and any subsequent SQL_APPEND_STMT commands issued
70796>>>>>>>>>>>>>>>>>/// after a SQL_PREPARE_STMT. If the results will be sent to the record
70796>>>>>>>>>>>>>>>>>/// buffer directly, then the file must be specified. An optional parameter
70796>>>>>>>>>>>>>>>>>/// can also be passed, indicating the maximum number of rows to be sent to
70796>>>>>>>>>>>>>>>>>/// the local cache. This is done by adding the constant ROWCOUNT followed
70796>>>>>>>>>>>>>>>>>/// by the maximun number.
70796>>>>>>>>>>>>>>>>>///
70796>>>>>>>>>>>>>>>>>/// @Assumptions
70796>>>>>>>>>>>>>>>>>/// @Status      Public
70796>>>>>>>>>>>>>>>>>/// @Drivers     All
70796>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-26 by Aaron Gulack
70796>>>>>>>>>>>>>>>>>/// @See                 SQL_SET_STMT SQL_APPEND_STMT SQL_PREPARE_STMT SQL_CANCEL_QUERY_STMT SQL_FETCH_NEXT_ROW SQL_BINDCOLUMNS_STMT
70796>>>>>>>>>>>>>>>>>///
70796>>>>>>>>>>>>>>>>>/// @Syntax SQL_EXECUTE_STMT [of {file} ROWCOUNT {variable}]
70796>>>>>>>>>>>>>>>>>/// @Param file                         Name or number of the file (optional)
70796>>>>>>>>>>>>>>>>>/// @Param variable                     Maximum number of rows to send to the local cache (optional)
70796>>>>>>>>>>>>>>>>>///
70796>>>>>>>>>>>>>>>>>/// @Usage SQL_EXECUTE_STMT
70796>>>>>>>>>>>>>>>>>/// @Usage SQL_EXECUTE_STMT of Customer
70796>>>>>>>>>>>>>>>>>/// @Usage SQL_EXECUTE_STMT of Customer ROWCOUNT 10
70796>>>>>>>>>>>>>>>>>///
70796>>>>>>>>>>>>>>>>>/// @Example
70796>>>>>>>>>>>>>>>>>/// Open Customer
70796>>>>>>>>>>>>>>>>>///
70796>>>>>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
70796>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT
70796>>>>>>>>>>>>>>>>>/// SQL_BINDCOLUMNS_STMT of Customer to DF_BIND_ALL_COLUMNS
70796>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT of Customer
70796>>>>>>>>>>>>>>>>>/// While (Found)
70796>>>>>>>>>>>>>>>>>///     SQL_FETCH_NEXT_ROW of Customer
70796>>>>>>>>>>>>>>>>>///     Showln Customer.ID
70796>>>>>>>>>>>>>>>>>///     Showln Customer.FirstName
70796>>>>>>>>>>>>>>>>>///     Showln Customer.LastName
70796>>>>>>>>>>>>>>>>>///     Showln Customer.DOB
70796>>>>>>>>>>>>>>>>>/// Loop
70796>>>>>>>>>>>>>>>>>/// SQL_CANCEL_QUERY_STMT
70796>>>>>>>>>>>>>>>>>
70796>>>>>>>>>>>>>>>>>
70796>>>>>>>>>>>>>>>>>//This alias may be redundant. Is was only called from MertechInc_SQL_FUNCTION_EXECUTE
70796>>>>>>>>>>>>>>>>>//which has been recoded to directly call SQL_EXECUTE_STMT - I.S. 2009-09-19
70796>>>>>>>>>>>>>>>>>Procedure MertechInc_SQL_PROCEDURE_EXECUTE Global
70798>>>>>>>>>>>>>>>>>    SQL_EXECUTE_STMT
70838>>>>>>>>>>>>>>>>>End_Procedure
70839>>>>>>>>>>>>>>>>>
70839>>>>>>>>>>>>>>>>>//=============================================================================
70839>>>>>>>>>>>>>>>>>/// @Name        SQL_START_TRANSACTION_STMT
70839>>>>>>>>>>>>>>>>>/// @Description Transactions in SQL are used to maintain atomicity within
70839>>>>>>>>>>>>>>>>>/// an process. If one procedure in the transaction fails, then they all
70839>>>>>>>>>>>>>>>>>/// will fail. This command is used to start an SQL transaction. Inside of
70839>>>>>>>>>>>>>>>>>/// a transaction, there can be any number of SQL statements, none of which
70839>>>>>>>>>>>>>>>>>/// will be executed until SQL_COMMIT_STMT is called. Note that transactions
70839>>>>>>>>>>>>>>>>>/// are generally only needed when a table is being altered.
70839>>>>>>>>>>>>>>>>>///
70839>>>>>>>>>>>>>>>>>/// @Assumptions
70839>>>>>>>>>>>>>>>>>/// @Status      Public
70839>>>>>>>>>>>>>>>>>/// @Drivers     All
70839>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-26 by Aaron Gulack
70839>>>>>>>>>>>>>>>>>/// @See         SQL_COMMIT_STMT SQL_ROLLBACK_STMT
70839>>>>>>>>>>>>>>>>>///
70839>>>>>>>>>>>>>>>>>/// @Syntax SQL_START_TRANSACTION_STMT
70839>>>>>>>>>>>>>>>>>///
70839>>>>>>>>>>>>>>>>>/// @Example
70839>>>>>>>>>>>>>>>>>/// SQL_START_TRANSACTION_STMT
70839>>>>>>>>>>>>>>>>>/// SQL_SET_STMT to "UPDATE CUSTOMER SET STATUS = 'Inactive'"
70839>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT
70839>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
70839>>>>>>>>>>>>>>>>>/// SQL_COMMIT_STMT
70839>>>>>>>>>>>>>>>>>
70839>>>>>>>>>>>>>>>>>//=============================================================================
70839>>>>>>>>>>>>>>>>>/// @Name        SQL_COMMIT_STMT
70839>>>>>>>>>>>>>>>>>/// @Description Just as the SQL_EXECUTE_STMT is used to execute the SQL
70839>>>>>>>>>>>>>>>>>/// statement in the block, this command is used to commit the transaction
70839>>>>>>>>>>>>>>>>>/// started by SQL_START_TRANSACTION_STMT. When this command is called, any
70839>>>>>>>>>>>>>>>>>/// preceding statements or procedures that are apart of the transaction will
70839>>>>>>>>>>>>>>>>>/// be committed. If one or more of these statements fail, then none of them
70839>>>>>>>>>>>>>>>>>/// will be successful, thus maintaining atomicity.
70839>>>>>>>>>>>>>>>>>///
70839>>>>>>>>>>>>>>>>>/// @Assumptions
70839>>>>>>>>>>>>>>>>>/// @Status      Public
70839>>>>>>>>>>>>>>>>>/// @Drivers     All
70839>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-27 by Aaron Gulack
70839>>>>>>>>>>>>>>>>>/// @See                 SQL_START_TRANSACTION_STMT SQL_ROLLBACK_STMT
70839>>>>>>>>>>>>>>>>>///
70839>>>>>>>>>>>>>>>>>/// @Syntax SQL_COMMIT_STMT
70839>>>>>>>>>>>>>>>>>///
70839>>>>>>>>>>>>>>>>>/// @Example
70839>>>>>>>>>>>>>>>>>/// SQL_START_TRANSACTION_STMT
70839>>>>>>>>>>>>>>>>>/// SQL_SET_STMT to "UPDATE CUSTOMER SET STATUS = 'Inactive'"
70839>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT
70839>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
70839>>>>>>>>>>>>>>>>>/// SQL_COMMIT_STMT
70839>>>>>>>>>>>>>>>>>
70839>>>>>>>>>>>>>>>>>//=============================================================================
70839>>>>>>>>>>>>>>>>>/// @Name        SQL_ROLLBACK_STMT
70839>>>>>>>>>>>>>>>>>/// @Description Rolls back an SQL transaction, any data changes inside the
70839>>>>>>>>>>>>>>>>>/// transaction will not be committed by the server.
70839>>>>>>>>>>>>>>>>>///
70839>>>>>>>>>>>>>>>>>/// @Assumptions
70839>>>>>>>>>>>>>>>>>/// @Status      Public
70839>>>>>>>>>>>>>>>>>/// @Drivers     All
70839>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-27 by Aaron Gulack
70839>>>>>>>>>>>>>>>>>/// @See                 SQL_START_TRANSACTION_STMT SQL_COMMIT_STMT
70839>>>>>>>>>>>>>>>>>///
70839>>>>>>>>>>>>>>>>>/// @Syntax SQL_ROLLBACK_STMT
70839>>>>>>>>>>>>>>>>>///
70839>>>>>>>>>>>>>>>>>/// @Example
70839>>>>>>>>>>>>>>>>>/// SQL_START_TRANSACTION_STMT
70839>>>>>>>>>>>>>>>>>/// SQL_SET_STMT to "DELETE FROM CUSTOMER WHERE ID = 2145"
70839>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT
70839>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
70839>>>>>>>>>>>>>>>>>/// If (Err) Begin
70839>>>>>>>>>>>>>>>>>///             SQL_ERROR_MESSAGE errorString
70839>>>>>>>>>>>>>>>>>///     Showln errorString
70839>>>>>>>>>>>>>>>>>///     SQL_ROLLBACK_STMT
70839>>>>>>>>>>>>>>>>>/// End
70839>>>>>>>>>>>>>>>>>/// Else
70839>>>>>>>>>>>>>>>>>///     Showln "SQL Statement successful - committing"
70839>>>>>>>>>>>>>>>>>///     SQL_COMMIT_STMT
70839>>>>>>>>>>>>>>>>>
70839>>>>>>>>>>>>>>>>>//=============================================================================
70839>>>>>>>>>>>>>>>>>/// @Name        SET_TRANSACTIONS_ALLOWED
70839>>>>>>>>>>>>>>>>>/// @Description This command is used to toggle on or off the ability to
70839>>>>>>>>>>>>>>>>>/// complete transaction to the server. Passing false to this command will
70839>>>>>>>>>>>>>>>>>/// not allow transactions to be made, passing true will allow the transactions.
70839>>>>>>>>>>>>>>>>>///
70839>>>>>>>>>>>>>>>>>/// @Assumptions
70839>>>>>>>>>>>>>>>>>/// @Status      Internal
70839>>>>>>>>>>>>>>>>>/// @Drivers     All
70839>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-27 by Aaron Gulack
70839>>>>>>>>>>>>>>>>>/// @See
70839>>>>>>>>>>>>>>>>>///
70839>>>>>>>>>>>>>>>>>/// @Syntax SET_TRANSACTIONS_ALLOWED of {server} to {variable}
70839>>>>>>>>>>>>>>>>>/// @Param server                               The name of the server being used
70839>>>>>>>>>>>>>>>>>/// @Param variable                     Boolean to enable or disable transactions
70839>>>>>>>>>>>>>>>>>///
70839>>>>>>>>>>>>>>>>>/// @Example
70839>>>>>>>>>>>>>>>>>/// SET_TRANSACTIONS_ALLOWED of "localhost" to True
70839>>>>>>>>>>>>>>>>>
70839>>>>>>>>>>>>>>>>>//=============================================================================
70839>>>>>>>>>>>>>>>>>/// @Name        SQL_FETCH_NEXT_ROW
70839>>>>>>>>>>>>>>>>>/// @Description This command is used to fetch the next row returned by the
70839>>>>>>>>>>>>>>>>>/// associated SQL statement. The SQL statement is created from the
70839>>>>>>>>>>>>>>>>>/// SQL_SET_STMT and executed with the SQL_EXECUTE_STMT. This command can be
70839>>>>>>>>>>>>>>>>>/// used in two ways. If the results are to be attached to variables, then no
70839>>>>>>>>>>>>>>>>>/// file needs to be specified, just the variables for each column in the row.
70839>>>>>>>>>>>>>>>>>/// If the results are to be inserted into the record buffer directly, then the
70839>>>>>>>>>>>>>>>>>/// file must be specified. From there, a SQL_BINDCOLUMNS_STMT can be used to
70839>>>>>>>>>>>>>>>>>/// bind the fetched row to the specific fields in the file. Note that the
70839>>>>>>>>>>>>>>>>>/// columns are fecthed in the order that the SQL statement generates them, so
70839>>>>>>>>>>>>>>>>>/// the variables must follow the same order. The two constants, "found" and
70839>>>>>>>>>>>>>>>>>/// "finderr" are set depending on whether the next row was found.
70839>>>>>>>>>>>>>>>>>///
70839>>>>>>>>>>>>>>>>>/// @Assumptions
70839>>>>>>>>>>>>>>>>>/// @Status      Public
70839>>>>>>>>>>>>>>>>>/// @Drivers     All
70839>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-27 by Aaron Gulack
70839>>>>>>>>>>>>>>>>>/// @See                 SQL_SET_STMT SQL_APPEND_STMT SQL_PREPARE_STMT SQL_EXECUTE_STMT SQL_CANCEL_QUERY_STMT SQL_BINDCOLUMNS_STMT
70839>>>>>>>>>>>>>>>>>///
70839>>>>>>>>>>>>>>>>>/// @Syntax SQL_FETCH_NEXT_ROW [of {file}] into {variable}
70839>>>>>>>>>>>>>>>>>/// @Param  file                                The name or number of the file
70839>>>>>>>>>>>>>>>>>/// @Param  variable                    The variable that the next column in the fetched row will be put into (can be multiple)
70839>>>>>>>>>>>>>>>>>///
70839>>>>>>>>>>>>>>>>>/// @Usage SQL_FETCH_NEXT_ROW of Customer
70839>>>>>>>>>>>>>>>>>/// @Usage SQL_FETCH_NEXT_ROW into sRecnum sID
70839>>>>>>>>>>>>>>>>>///
70839>>>>>>>>>>>>>>>>>/// @Example
70839>>>>>>>>>>>>>>>>>/// String sID sRecnum
70839>>>>>>>>>>>>>>>>>///
70839>>>>>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER ID"
70839>>>>>>>>>>>>>>>>>/// SQL_APPEND_STMT to " BY NAME DESC"
70839>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT
70839>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
70839>>>>>>>>>>>>>>>>>/// While (found)
70839>>>>>>>>>>>>>>>>>///     SQL_FETCH_NEXT_ROW into sRecnum sID
70839>>>>>>>>>>>>>>>>>///     If (found) Begin
70839>>>>>>>>>>>>>>>>>///             Showln sID
70839>>>>>>>>>>>>>>>>>///    End
70839>>>>>>>>>>>>>>>>>/// Loop
70839>>>>>>>>>>>>>>>>>/// SQL_CANCEL_QUERY_STMT
70839>>>>>>>>>>>>>>>>>///
70839>>>>>>>>>>>>>>>>>/// @Example
70839>>>>>>>>>>>>>>>>>/// Open Customer
70839>>>>>>>>>>>>>>>>>///
70839>>>>>>>>>>>>>>>>>/// SQL_SET_STMT of Customer to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
70839>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT of Customer
70839>>>>>>>>>>>>>>>>>/// SQL_BINDCOLUMNS_STMT of Customer to DF_BIND_ALL_COLUMNS
70839>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT of Customer
70839>>>>>>>>>>>>>>>>>/// While (Found)
70839>>>>>>>>>>>>>>>>>///     SQL_FETCH_NEXT_ROW of Customer
70839>>>>>>>>>>>>>>>>>///     Showln Customer.ID
70839>>>>>>>>>>>>>>>>>///     Showln Customer.FirstName
70839>>>>>>>>>>>>>>>>>///             Showln Customer.LastName
70839>>>>>>>>>>>>>>>>>/// Loop
70839>>>>>>>>>>>>>>>>>/// SQL_CANCEL_QUERY_STMT
70839>>>>>>>>>>>>>>>>>
70839>>>>>>>>>>>>>>>>>//=============================================================================
70839>>>>>>>>>>>>>>>>>/// @Name        GET_RESULT_SET
70839>>>>>>>>>>>>>>>>>/// @Description Fetches the next row in the result set returned by a
70839>>>>>>>>>>>>>>>>>/// query or stored procedure.
70839>>>>>>>>>>>>>>>>>///
70839>>>>>>>>>>>>>>>>>/// @Assumptions
70839>>>>>>>>>>>>>>>>>/// @Status      Deprecated
70839>>>>>>>>>>>>>>>>>/// @Drivers     All
70839>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-27 by Aaron Gulack
70839>>>>>>>>>>>>>>>>>/// @See
70839>>>>>>>>>>>>>>>>>///
70839>>>>>>>>>>>>>>>>>/// @Syntax GET_RESULT_SET into {variable}
70839>>>>>>>>>>>>>>>>>/// @Param variable                     The variable receiving the result (can be multiple)
70839>>>>>>>>>>>>>>>>>
70839>>>>>>>>>>>>>>>>>//=============================================================================
70839>>>>>>>>>>>>>>>>>/// @Name        SQL_GET_DATA_CHUNK
70839>>>>>>>>>>>>>>>>>/// @Description This command is used to get a chunk of data from a column
70839>>>>>>>>>>>>>>>>>/// retrieved through an embedded SQL statement. By passing the column number
70839>>>>>>>>>>>>>>>>>/// and the offset number, the chunk will be put into the specified variable.
70839>>>>>>>>>>>>>>>>>/// To specify how big of a chunk to get, use the SQL_SET_CHUNK_SIZE command.
70839>>>>>>>>>>>>>>>>>/// Otherwise the maximum length will be retrieved. An optional variable can
70839>>>>>>>>>>>>>>>>>/// also be passed which will store the length of the chunk. Note that unlike
70839>>>>>>>>>>>>>>>>>/// LOB_READ, this command works for any column type, not just LOB columns.
70839>>>>>>>>>>>>>>>>>///
70839>>>>>>>>>>>>>>>>>/// @Assumptions
70839>>>>>>>>>>>>>>>>>/// @Status      Public
70839>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex
70839>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
70839>>>>>>>>>>>>>>>>>/// @See                 SQL_SET_CHUNK_SIZE SQL_GET_CHUNK_SIZE SQL_SET_MAX_DATA_SIZE SQL_GET_MAX_DATA_SIZE
70839>>>>>>>>>>>>>>>>>///
70839>>>>>>>>>>>>>>>>>/// @Syntax SQL_GET_DATA_CHUNK COLUMN {column} OFFSET {offset} to {variable} {length}
70839>>>>>>>>>>>>>>>>>/// @Param column                               Column number to get chunk from
70839>>>>>>>>>>>>>>>>>/// @Param offset                       Offset to start at for the chunk
70839>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the returned chunk
70839>>>>>>>>>>>>>>>>>/// @Param length                       Variable to hold the chunk length
70839>>>>>>>>>>>>>>>>>///
70839>>>>>>>>>>>>>>>>>/// @Example
70839>>>>>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
70839>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT
70839>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
70839>>>>>>>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sID sBio
70839>>>>>>>>>>>>>>>>>/// If (Found) Begin
70839>>>>>>>>>>>>>>>>>///     SQL_SET_CHUNK_SIZE to 150
70839>>>>>>>>>>>>>>>>>///     SQL_GET_DATA_CHUNK COLUMN 6 OFFSET 1 to sChunk iLength
70839>>>>>>>>>>>>>>>>>///     Showln sChunk
70839>>>>>>>>>>>>>>>>>///     Showln iLength
70839>>>>>>>>>>>>>>>>>/// End
70839>>>>>>>>>>>>>>>>>
70839>>>>>>>>>>>>>>>>>Function MertechInc_SQL_GET_DATA_CHUNK Global Integer iColumn Integer iOffset Returns String
70841>>>>>>>>>>>>>>>>>    Integer iChuck_Size
70841>>>>>>>>>>>>>>>>>    String sChunk
70841>>>>>>>>>>>>>>>>>
70841>>>>>>>>>>>>>>>>>    //Get current Chuck size and pre size string
70841>>>>>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_CHUNK_SIZE CALLBACK 0 PASSING iChuck_Size MertechInc_Blank 1 RESULT MertechInc_iRet
70846>>>>>>>>>>>>>>>>>    Get MertechInc_Pre_Size_String iChuck_Size to sChunk
70847>>>>>>>>>>>>>>>>>
70847>>>>>>>>>>>>>>>>>    //Get data
70847>>>>>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_GET_DATA_CHUNK CALLBACK 0 PASSING iColumn sChunk iOffset RESULT MertechInc_iRet
70852>>>>>>>>>>>>>>>>>
70852>>>>>>>>>>>>>>>>>    //sArg1 (iColumn) contains the number of bytes returned, so move it to
70852>>>>>>>>>>>>>>>>>    //MertechInc_Arg1 to pass the value back
70852>>>>>>>>>>>>>>>>>    Move iColumn to MertechInc_sArg1
70853>>>>>>>>>>>>>>>>>
70853>>>>>>>>>>>>>>>>>    Function_Return sChunk
70854>>>>>>>>>>>>>>>>>End_Function
70855>>>>>>>>>>>>>>>>>
70855>>>>>>>>>>>>>>>>>//=============================================================================
70855>>>>>>>>>>>>>>>>>/// @Name        SQL_SET_CHUNK_SIZE
70855>>>>>>>>>>>>>>>>>/// @Description This command sets the size of the chunk to retrieve when
70855>>>>>>>>>>>>>>>>>/// using SQL_GET_DATA_CHUNK. Whatever number is set here will be the
70855>>>>>>>>>>>>>>>>>/// length of the chunk that is retrieved, as long as it does not exceed
70855>>>>>>>>>>>>>>>>>/// the maximum chunk size.
70855>>>>>>>>>>>>>>>>>///
70855>>>>>>>>>>>>>>>>>/// @Assumptions
70855>>>>>>>>>>>>>>>>>/// @Status      Public
70855>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex
70855>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
70855>>>>>>>>>>>>>>>>>/// @See                 SQL_GET_DATA_CHUNK SQL_GET_CHUNK_SIZE SQL_SET_MAX_DATA_SIZE SQL_GET_MAX_DATA_SIZE
70855>>>>>>>>>>>>>>>>>///
70855>>>>>>>>>>>>>>>>>/// @Syntax SQL_SET_CHUNK_SIZE to {variable}
70855>>>>>>>>>>>>>>>>>/// @Param variable                     Length of chunk to retrive
70855>>>>>>>>>>>>>>>>>///
70855>>>>>>>>>>>>>>>>>/// @Example
70855>>>>>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
70855>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT
70855>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
70855>>>>>>>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sID sBio
70855>>>>>>>>>>>>>>>>>/// If (Found) Begin
70855>>>>>>>>>>>>>>>>>///     SQL_SET_CHUNK_SIZE to 150
70855>>>>>>>>>>>>>>>>>///     SQL_GET_DATA_CHUNK COLUMN 6 OFFSET 1 to sChunk iLength
70855>>>>>>>>>>>>>>>>>///     Showln sChunk
70855>>>>>>>>>>>>>>>>>///     Showln iLength
70855>>>>>>>>>>>>>>>>>/// End
70855>>>>>>>>>>>>>>>>>
70855>>>>>>>>>>>>>>>>>//=============================================================================
70855>>>>>>>>>>>>>>>>>/// @Name        SQL_GET_CHUNK_SIZE
70855>>>>>>>>>>>>>>>>>/// @Description This command gets the size of the chunk being retrieved
70855>>>>>>>>>>>>>>>>>/// from SQL_GET_DATA_CHUNK and puts it into the specified variable.
70855>>>>>>>>>>>>>>>>>///
70855>>>>>>>>>>>>>>>>>/// @Assumptions
70855>>>>>>>>>>>>>>>>>/// @Status      Public
70855>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex
70855>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
70855>>>>>>>>>>>>>>>>>/// @See                 SQL_SET_CHUNK_SIZE SQL_GET_DATA_CHUNK SQL_SET_MAX_DATA_SIZE SQL_GET_MAX_DATA_SIZE
70855>>>>>>>>>>>>>>>>>///
70855>>>>>>>>>>>>>>>>>/// @Syntax SQL_GET_CHUNK_SIZE to {variable}
70855>>>>>>>>>>>>>>>>>/// @Param variable             Variable to hold the chunk size
70855>>>>>>>>>>>>>>>>>///
70855>>>>>>>>>>>>>>>>>/// @Example
70855>>>>>>>>>>>>>>>>>/// SQL_GET_CHUNK_SIZE to iLength
70855>>>>>>>>>>>>>>>>>
70855>>>>>>>>>>>>>>>>>//=============================================================================
70855>>>>>>>>>>>>>>>>>/// @Name        SQL_SET_MAX_DATA_SIZE
70855>>>>>>>>>>>>>>>>>/// @Description This command sets the maximum size for data chunks
70855>>>>>>>>>>>>>>>>>/// retrieved through SQL_GET_DATA_CHUNK. If SQL_SET_CHUNK_SIZE is higher
70855>>>>>>>>>>>>>>>>>/// than the maximum size set with this command, then this will override
70855>>>>>>>>>>>>>>>>>/// it and the chunk will be no longer than the maximum size set here.
70855>>>>>>>>>>>>>>>>>///
70855>>>>>>>>>>>>>>>>>/// @Assumptions
70855>>>>>>>>>>>>>>>>>/// @Status      Public
70855>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex
70855>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
70855>>>>>>>>>>>>>>>>>/// @See                 SQL_SET_CHUNK_SIZE SQL_GET_CHUNK_SIZE SQL_GET_DATA_CHUNK SQL_GET_MAX_DATA_SIZE
70855>>>>>>>>>>>>>>>>>///
70855>>>>>>>>>>>>>>>>>/// @Syntax SQL_SET_MAX_DATA_SIZE to {variable}
70855>>>>>>>>>>>>>>>>>/// @Param variable                     Max length to allow for chunks
70855>>>>>>>>>>>>>>>>>///
70855>>>>>>>>>>>>>>>>>/// @Example
70855>>>>>>>>>>>>>>>>>/// SQL_SET_MAX_DATA_SIZE to 1000
70855>>>>>>>>>>>>>>>>>
70855>>>>>>>>>>>>>>>>>//=============================================================================
70855>>>>>>>>>>>>>>>>>/// @Name        SQL_GET_MAX_DATA_SIZE
70855>>>>>>>>>>>>>>>>>/// @Description This command returns the maximum chunk size allowed
70855>>>>>>>>>>>>>>>>>/// for SQL_GET_DATA_CHUNK.
70855>>>>>>>>>>>>>>>>>///
70855>>>>>>>>>>>>>>>>>/// @Assumptions
70855>>>>>>>>>>>>>>>>>/// @Status      Public
70855>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex
70855>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
70855>>>>>>>>>>>>>>>>>/// @See                 SQL_SET_CHUNK_SIZE SQL_GET_CHUNK_SIZE SQL_GET_DATA_CHUNK SQL_SET_MAX_DATA_SIZE
70855>>>>>>>>>>>>>>>>>///
70855>>>>>>>>>>>>>>>>>/// @Syntax SQL_GET_MAX_DATA_SIZE to {variable}
70855>>>>>>>>>>>>>>>>>/// @Param variable             Variable to hold the maximum chunk size
70855>>>>>>>>>>>>>>>>>///
70855>>>>>>>>>>>>>>>>>/// @Example
70855>>>>>>>>>>>>>>>>>/// SQL_GET_MAX_DATA_SIZE to iLength
70855>>>>>>>>>>>>>>>>>
70855>>>>>>>>>>>>>>>>>//=============================================================================
70855>>>>>>>>>>>>>>>>>/// @Name        SQL_GET_NUM_COLS
70855>>>>>>>>>>>>>>>>>/// @Description This command is used to get the number of columns retrieved
70855>>>>>>>>>>>>>>>>>/// from an SQL expression result set. Since the column number is based on
70855>>>>>>>>>>>>>>>>>/// the result set, this command cannot be used when the results are being
70855>>>>>>>>>>>>>>>>>/// bound to the record buffer.  If this command is used with the record
70855>>>>>>>>>>>>>>>>>/// buffer or if no columns are found, -1 is returned.
70855>>>>>>>>>>>>>>>>>///
70855>>>>>>>>>>>>>>>>>/// @Assumptions
70855>>>>>>>>>>>>>>>>>/// @Status      Public
70855>>>>>>>>>>>>>>>>>/// @Drivers     All
70855>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-28 by Aaron Gulack
70855>>>>>>>>>>>>>>>>>/// @See                 SQL_PREPARE_STMT SQL_EXECUTE_STMT SQL_SET_STMT
70855>>>>>>>>>>>>>>>>>///
70855>>>>>>>>>>>>>>>>>/// @Syntax SQL_GET_NUM_COLS to {variable}
70855>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the number of columns.
70855>>>>>>>>>>>>>>>>>///
70855>>>>>>>>>>>>>>>>>/// @Example
70855>>>>>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE FIRSTNAME = 'Aaron'"
70855>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT
70855>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
70855>>>>>>>>>>>>>>>>>/// GET_RESULT_SET_NUM_COLS to iNumCols
70855>>>>>>>>>>>>>>>>>/// Showln iNumCols
70855>>>>>>>>>>>>>>>>>
70855>>>>>>>>>>>>>>>>>
70855>>>>>>>>>>>>>>>>>//=============================================================================
70855>>>>>>>>>>>>>>>>>/// @Name        GET_RESULT_SET_NUM_COLS
70855>>>>>>>>>>>>>>>>>/// @Description Returns the number of columns in the result set.
70855>>>>>>>>>>>>>>>>>///
70855>>>>>>>>>>>>>>>>>/// @Assumptions
70855>>>>>>>>>>>>>>>>>/// @Status      Deprecated
70855>>>>>>>>>>>>>>>>>/// @Drivers     All
70855>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-28 by Aaron Gulack
70855>>>>>>>>>>>>>>>>>/// @See                 SQL_GET_NUM_COLS
70855>>>>>>>>>>>>>>>>>///
70855>>>>>>>>>>>>>>>>>/// @Syntax GET_RESULT_SET_NUM_COLS to {variable}
70855>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the number of columns
70855>>>>>>>>>>>>>>>>>///
70855>>>>>>>>>>>>>>>>>/// @Example
70855>>>>>>>>>>>>>>>>>/// Integer iNumCols
70855>>>>>>>>>>>>>>>>>///
70855>>>>>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE FIRSTNAME = 'Aaron'"
70855>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT
70855>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
70855>>>>>>>>>>>>>>>>>/// GET_RESULT_SET_NUM_COLS to iNumCols
70855>>>>>>>>>>>>>>>>>/// Showln iNumCols
70855>>>>>>>>>>>>>>>>>
70855>>>>>>>>>>>>>>>>>//=============================================================================
70855>>>>>>>>>>>>>>>>>/// @Name        SQL_GET_NUM_ROWS
70855>>>>>>>>>>>>>>>>>/// @Description This command is used to get the number of rows retrieved
70855>>>>>>>>>>>>>>>>>/// from a result set of an SQL expression. It cannot be used when binding
70855>>>>>>>>>>>>>>>>>/// the result set to the record buffer.
70855>>>>>>>>>>>>>>>>>///
70855>>>>>>>>>>>>>>>>>/// Note: The number of rows may not always be available, depending
70855>>>>>>>>>>>>>>>>>/// on server and cursor types.
70855>>>>>>>>>>>>>>>>>///
70855>>>>>>>>>>>>>>>>>/// @Assumptions
70855>>>>>>>>>>>>>>>>>/// @Status      Public
70855>>>>>>>>>>>>>>>>>/// @Drivers     All
70855>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-30 by Aaron Gulack
70855>>>>>>>>>>>>>>>>>/// @See                 SQL_PREPARE_STMT SQL_EXECUTE_STMT
70855>>>>>>>>>>>>>>>>>///
70855>>>>>>>>>>>>>>>>>/// @Syntax SQL_GET_NUM_ROWS to {variable}
70855>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the number of rows
70855>>>>>>>>>>>>>>>>>///
70855>>>>>>>>>>>>>>>>>/// @Example
70855>>>>>>>>>>>>>>>>>/// Integer iNumRows
70855>>>>>>>>>>>>>>>>>///
70855>>>>>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
70855>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT
70855>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
70855>>>>>>>>>>>>>>>>>/// SQL_GET_NUM_ROWS to iNumRows
70855>>>>>>>>>>>>>>>>>/// Showln iNumRows
70855>>>>>>>>>>>>>>>>>
70855>>>>>>>>>>>>>>>>>
70855>>>>>>>>>>>>>>>>>//=============================================================================
70855>>>>>>>>>>>>>>>>>/// @Name        SQL_GET_COL_NAME
70855>>>>>>>>>>>>>>>>>/// @Description This command is used to retrieve the name of a specified
70855>>>>>>>>>>>>>>>>>/// column within an SQL result set. An optional second variable can be used
70855>>>>>>>>>>>>>>>>>/// to retrieve the size of the specified column. Note that this command
70855>>>>>>>>>>>>>>>>>/// cannot be used when the results are being directly binded to the record
70855>>>>>>>>>>>>>>>>>/// buffer, it can only be used for the results of an SQL statement.
70855>>>>>>>>>>>>>>>>>///
70855>>>>>>>>>>>>>>>>>/// @Assumptions
70855>>>>>>>>>>>>>>>>>/// @Status      Public
70855>>>>>>>>>>>>>>>>>/// @Drivers     All
70855>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-30 by Aaron Gulack
70855>>>>>>>>>>>>>>>>>/// @See                 SQL_GET_NUM_COLS
70855>>>>>>>>>>>>>>>>>///
70855>>>>>>>>>>>>>>>>>/// @Syntax SQL_GET_COL_NAME {columnNumber} to {variable} [{length}]
70855>>>>>>>>>>>>>>>>>/// @Param columnNumber                 The column number being used
70855>>>>>>>>>>>>>>>>>/// @Param variable                             String variable for the column name
70855>>>>>>>>>>>>>>>>>/// @Param length                       Variable to hold the column length (optional)
70855>>>>>>>>>>>>>>>>>///
70855>>>>>>>>>>>>>>>>>/// @Example
70855>>>>>>>>>>>>>>>>>/// Open Customer
70855>>>>>>>>>>>>>>>>>///
70855>>>>>>>>>>>>>>>>>/// String sColumnName
70855>>>>>>>>>>>>>>>>>/// Integer iLength
70855>>>>>>>>>>>>>>>>>///
70855>>>>>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active'"
70855>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT
70855>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
70855>>>>>>>>>>>>>>>>>/// SQL_GET_COL_NAME 1 to sColumnName iLength
70855>>>>>>>>>>>>>>>>>/// showln sColumnName
70855>>>>>>>>>>>>>>>>>/// showln iLength
70855>>>>>>>>>>>>>>>>>
70855>>>>>>>>>>>>>>>>>
70855>>>>>>>>>>>>>>>>>//=============================================================================
70855>>>>>>>>>>>>>>>>>/// @Name        GET_RESULT_SET_COL_NAME
70855>>>>>>>>>>>>>>>>>/// @Description Returns the column name being populated from the result set.
70855>>>>>>>>>>>>>>>>>///
70855>>>>>>>>>>>>>>>>>/// @Assumptions
70855>>>>>>>>>>>>>>>>>/// @Status      Deprecated
70855>>>>>>>>>>>>>>>>>/// @Drivers     All
70855>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-30 by Aaron Gulack
70855>>>>>>>>>>>>>>>>>/// @See                 SQL_GET_COL_NAME
70855>>>>>>>>>>>>>>>>>///
70855>>>>>>>>>>>>>>>>>/// @Syntax GET_RESULT_SET_COL_NAME {columnNumber} to {variable} [{length}]
70855>>>>>>>>>>>>>>>>>/// @Param columnNumber                 The column number being used
70855>>>>>>>>>>>>>>>>>/// @Param variable                             String variable for the column name
70855>>>>>>>>>>>>>>>>>/// @Param length                       Variable receiving the column length (optional)
70855>>>>>>>>>>>>>>>>>
70855>>>>>>>>>>>>>>>>>//=============================================================================
70855>>>>>>>>>>>>>>>>>/// @Name        SQL_GET_COL_ATTRIBUTE
70855>>>>>>>>>>>>>>>>>/// @Description This command is used to get specific column information from
70855>>>>>>>>>>>>>>>>>/// the columns in a result set of an SQL statement. By passing one of the
70855>>>>>>>>>>>>>>>>>/// supported attributes below, the command will return the desired information.
70855>>>>>>>>>>>>>>>>>/// Note that some attributes only work with specific drivers. See the list
70855>>>>>>>>>>>>>>>>>/// below for more information.
70855>>>>>>>>>>>>>>>>>///
70855>>>>>>>>>>>>>>>>>/// Supported attributes are:
70855>>>>>>>>>>>>>>>>>/// <dl>
70855>>>>>>>>>>>>>>>>>/// <dt>SIZE        </dt><dd>The maximum length of the column</dd>
70855>>>>>>>>>>>>>>>>>/// <dt>DATA_LENGTH </dt><dd>Length of data currently in the column</dd>
70855>>>>>>>>>>>>>>>>>/// <dt>DECIMALS    </dt><dd>If numeric, shows number of decimal places</dd>
70855>>>>>>>>>>>>>>>>>/// <dt>LABEL       </dt><dd>Returns the column name in ORAFlex and MySQLFlex</dd>
70855>>>>>>>>>>>>>>>>>/// <dt>COLUMN_NAME </dt><dd>Returns the name of the column</dd>
70855>>>>>>>>>>>>>>>>>/// <dt>TABLE_NAME  </dt><dd>Returns the name of the table (MySQLFlex only)</dd>
70855>>>>>>>>>>>>>>>>>/// <dt>SQLTYPE     </dt><dd>Returns the number representing the SQL data type</dd>
70855>>>>>>>>>>>>>>>>>/// <dt>NULLABLE    </dt><dd>Returns true if null is allowed, false otherwise (doesn't work in PostgreSQL)</dd>
70855>>>>>>>>>>>>>>>>>/// <dt>DFTYPE      </dt><dd>Dataflex type column is mapped to</dd>
70855>>>>>>>>>>>>>>>>>/// </dl>
70855>>>>>>>>>>>>>>>>>///
70855>>>>>>>>>>>>>>>>>/// @Assumptions
70855>>>>>>>>>>>>>>>>>/// @Status      Public
70855>>>>>>>>>>>>>>>>>/// @Drivers     All
70855>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
70855>>>>>>>>>>>>>>>>>/// @See
70855>>>>>>>>>>>>>>>>>///
70855>>>>>>>>>>>>>>>>>/// @Syntax SQL_GET_COL_ATTRIBUTE of {columnNumber} {attribute} to {variable}
70855>>>>>>>>>>>>>>>>>/// @Param columnNumber                 The number of the column that is being examined
70855>>>>>>>>>>>>>>>>>/// @Param attribute                    The attribute being checked (see list)
70855>>>>>>>>>>>>>>>>>/// @Param variable                             Variable to hold the attribute value
70855>>>>>>>>>>>>>>>>>///
70855>>>>>>>>>>>>>>>>>/// @Example
70855>>>>>>>>>>>>>>>>>/// String sFirstName sLastName sColumn1Name sColumn2Name
70855>>>>>>>>>>>>>>>>>///
70855>>>>>>>>>>>>>>>>>/// Open Customer
70855>>>>>>>>>>>>>>>>>///
70855>>>>>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
70855>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT
70855>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
70855>>>>>>>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sFirstName sLastName
70855>>>>>>>>>>>>>>>>>/// If (Found) Begin
70855>>>>>>>>>>>>>>>>>///     SQL_GET_COL_ATTRIBUTE of 1 COLUMN_NAME to sColumn1Name
70855>>>>>>>>>>>>>>>>>///     SQL_GET_COL_ATTRIBUTE of 2 COLUMN_NAME to sColumn2Name
70855>>>>>>>>>>>>>>>>>///     Showln (sColumn1Name + " = " + sFirstName)
70855>>>>>>>>>>>>>>>>>///     Showln (sColumn2Name + " = " + sLastName)
70855>>>>>>>>>>>>>>>>>/// End
70855>>>>>>>>>>>>>>>>>
70855>>>>>>>>>>>>>>>>>//=============================================================================
70855>>>>>>>>>>>>>>>>>/// @Name        DDO_GET_BIND_RSPARAMETERS
70855>>>>>>>>>>>>>>>>>/// @Description Recursively calls DO_GET_BIND_RSPARAMETERS.
70855>>>>>>>>>>>>>>>>>///
70855>>>>>>>>>>>>>>>>>/// @Assumptions
70855>>>>>>>>>>>>>>>>>/// @Status      Internal
70855>>>>>>>>>>>>>>>>>/// @Drivers     All
70855>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-30 by Aaron Gulack
70855>>>>>>>>>>>>>>>>>/// @See
70855>>>>>>>>>>>>>>>>>
70855>>>>>>>>>>>>>>>>>//=============================================================================
70855>>>>>>>>>>>>>>>>>/// @Name        DO_GET_BIND_RSPARAMETERS
70855>>>>>>>>>>>>>>>>>/// @Description Gets bound parameters values for result set call.
70855>>>>>>>>>>>>>>>>>///
70855>>>>>>>>>>>>>>>>>/// @Assumptions
70855>>>>>>>>>>>>>>>>>/// @Status      Internal
70855>>>>>>>>>>>>>>>>>/// @Drivers     All
70855>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-08-30 by Aaron Gulack
70855>>>>>>>>>>>>>>>>>/// @See
70855>>>>>>>>>>>>>>>>>
70855>>>>>>>>>>>>>>>>>Function MertechInc_DO_GET_BIND_RSPARAMETERS Global Integer iWhichParam Returns String
70857>>>>>>>>>>>>>>>>>    String sReturnValue
70857>>>>>>>>>>>>>>>>>
70857>>>>>>>>>>>>>>>>>    Get Value of (oMertechInc_Work(Current_Object)) item iWhichParam to MertechInc_iWork
70858>>>>>>>>>>>>>>>>>    If MertechInc_iWork lt 16384 ;        Move (Repeat("                                ", ((MertechInc_iWork/32)+1))) to sReturnValue
70861>>>>>>>>>>>>>>>>>    Else Get psWork of oMertechInc_Work to sReturnValue
70863>>>>>>>>>>>>>>>>>
70863>>>>>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function 24 CALLBACK 0 PASSING sReturnValue MertechInc_Blank (|CI$10000 * iWhichParam) RESULT MertechInc_iRet
70868>>>>>>>>>>>>>>>>>
70868>>>>>>>>>>>>>>>>>    Function_Return sReturnValue
70869>>>>>>>>>>>>>>>>>End_Function
70870>>>>>>>>>>>>>>>>>
70870>>>>>>>>>>>>>>>>>
70870>>>>>>>>>>>>>>>>>//=============================================================================
70870>>>>>>>>>>>>>>>>>/// @Name        SQL_NEXT_RESULT_SET
70870>>>>>>>>>>>>>>>>>/// @Description This command is used when working with SQL statements that
70870>>>>>>>>>>>>>>>>>/// return multiple result sets. In that scenario, calling this command will
70870>>>>>>>>>>>>>>>>>/// move to the next result set. That set can now be fetched or binded to
70870>>>>>>>>>>>>>>>>>/// columns on a table.
70870>>>>>>>>>>>>>>>>>///
70870>>>>>>>>>>>>>>>>>/// @See
70870>>>>>>>>>>>>>>>>>/// @Status      Public
70870>>>>>>>>>>>>>>>>>/// @Drivers     All
70870>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-02 by Aaron Gulack
70870>>>>>>>>>>>>>>>>>/// @See
70870>>>>>>>>>>>>>>>>>///
70870>>>>>>>>>>>>>>>>>/// @Syntax SQL_NEXT_RESULT_SET [of {file}]
70870>>>>>>>>>>>>>>>>>/// @Param file                 Name or number of the file (optional)
70870>>>>>>>>>>>>>>>>>///
70870>>>>>>>>>>>>>>>>>/// @Example
70870>>>>>>>>>>>>>>>>>/// SQL_SET_STMT to "SP_HELP CUSTOMER"
70870>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT
70870>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
70870>>>>>>>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sTable sOwner sTableType dtCreated
70870>>>>>>>>>>>>>>>>>/// If (Found) Begin
70870>>>>>>>>>>>>>>>>>///     Showln sTable
70870>>>>>>>>>>>>>>>>>///     Showln sOwner
70870>>>>>>>>>>>>>>>>>///     Showln sTableType
70870>>>>>>>>>>>>>>>>>///     Showln dtCreated
70870>>>>>>>>>>>>>>>>>/// End
70870>>>>>>>>>>>>>>>>>/// SQL_NEXT_RESULT_SET
70870>>>>>>>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sColumnName sColumnType sComputed sLength
70870>>>>>>>>>>>>>>>>>/// If (Found) Begin
70870>>>>>>>>>>>>>>>>>///     Showln sColumnName
70870>>>>>>>>>>>>>>>>>///     Showln sColumnType
70870>>>>>>>>>>>>>>>>>///     Showln sComputed
70870>>>>>>>>>>>>>>>>>///     Showln sLength
70870>>>>>>>>>>>>>>>>>/// End
70870>>>>>>>>>>>>>>>>>
70870>>>>>>>>>>>>>>>>>//=============================================================================
70870>>>>>>>>>>>>>>>>>/// @Name        DDO_PASS_ARGUMENTS
70870>>>>>>>>>>>>>>>>>/// @Description Calls DO_PASS_ARGUMENTS until the argument is "BINDING" and
70870>>>>>>>>>>>>>>>>>/// then stops.
70870>>>>>>>>>>>>>>>>>///
70870>>>>>>>>>>>>>>>>>/// @Assumptions
70870>>>>>>>>>>>>>>>>>/// @Status      Internal
70870>>>>>>>>>>>>>>>>>/// @Drivers     All
70870>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
70870>>>>>>>>>>>>>>>>>/// @See
70870>>>>>>>>>>>>>>>>>
70870>>>>>>>>>>>>>>>>>//=============================================================================
70870>>>>>>>>>>>>>>>>>/// @Name        DO_PASS_ARGUMENTS
70870>>>>>>>>>>>>>>>>>/// @Description Builds parameter statements for stored procedures and adds
70870>>>>>>>>>>>>>>>>>/// them to the current query.
70870>>>>>>>>>>>>>>>>>///
70870>>>>>>>>>>>>>>>>>/// @Assumptions
70870>>>>>>>>>>>>>>>>>/// @Status      internal
70870>>>>>>>>>>>>>>>>>/// @Drivers     All
70870>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
70870>>>>>>>>>>>>>>>>>/// @See
70870>>>>>>>>>>>>>>>>>
70870>>>>>>>>>>>>>>>>>//=============================================================================
70870>>>>>>>>>>>>>>>>>/// @Name        DDO_BIND_PARAMETERS
70870>>>>>>>>>>>>>>>>>/// @Description Recursively calls DO_BIND_PARAMETERS until the keyword
70870>>>>>>>>>>>>>>>>>/// "BINDING" is encountered.
70870>>>>>>>>>>>>>>>>>///
70870>>>>>>>>>>>>>>>>>/// @Assumptions
70870>>>>>>>>>>>>>>>>>/// @Status      Internal
70870>>>>>>>>>>>>>>>>>/// @Drivers     All
70870>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
70870>>>>>>>>>>>>>>>>>/// @See
70870>>>>>>>>>>>>>>>>>
70870>>>>>>>>>>>>>>>>>//=============================================================================
70870>>>>>>>>>>>>>>>>>/// @Name        DO_BIND_PARAMETERS
70870>>>>>>>>>>>>>>>>>/// @Description Binds parameters for a stored procedure call.
70870>>>>>>>>>>>>>>>>>///
70870>>>>>>>>>>>>>>>>>/// @Assumptions
70870>>>>>>>>>>>>>>>>>/// @Status      Internal
70870>>>>>>>>>>>>>>>>>/// @Drivers     All
70870>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
70870>>>>>>>>>>>>>>>>>/// @See
70870>>>>>>>>>>>>>>>>>
70870>>>>>>>>>>>>>>>>>Procedure MertechInc_DO_BIND_PARAMETERS Global String sValue String sName Integer iLength
70872>>>>>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_BIND_PARAMETER CALLBACK 0 PASSING sValue sName iLength RESULT MertechInc_iRet
70877>>>>>>>>>>>>>>>>>End_Procedure
70878>>>>>>>>>>>>>>>>>
70878>>>>>>>>>>>>>>>>>//=============================================================================
70878>>>>>>>>>>>>>>>>>/// @Name        DO_BIND_PAR_RET
70878>>>>>>>>>>>>>>>>>/// @Description Binds parameters for a stored procedure call.
70878>>>>>>>>>>>>>>>>>///
70878>>>>>>>>>>>>>>>>>/// @Assumptions
70878>>>>>>>>>>>>>>>>>/// @Status      Internal
70878>>>>>>>>>>>>>>>>>/// @Drivers     OraFlex
70878>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
70878>>>>>>>>>>>>>>>>>/// @See
70878>>>>>>>>>>>>>>>>>
70878>>>>>>>>>>>>>>>>>//=============================================================================
70878>>>>>>>>>>>>>>>>>/// @Name        DDO_GET_BIND_PARAMETERS
70878>>>>>>>>>>>>>>>>>/// @Description Recursively calls DO_GET_BIND_PARAMETERS.
70878>>>>>>>>>>>>>>>>>///
70878>>>>>>>>>>>>>>>>>/// @Assumptions
70878>>>>>>>>>>>>>>>>>/// @Status      Internal
70878>>>>>>>>>>>>>>>>>/// @Drivers     All
70878>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
70878>>>>>>>>>>>>>>>>>/// @See
70878>>>>>>>>>>>>>>>>>
70878>>>>>>>>>>>>>>>>>//=============================================================================
70878>>>>>>>>>>>>>>>>>/// @Name        DO_GET_BIND_PARAMETERS
70878>>>>>>>>>>>>>>>>>/// @Description Gets bound parameter values for a stored procedure call.
70878>>>>>>>>>>>>>>>>>///
70878>>>>>>>>>>>>>>>>>/// @Assumptions
70878>>>>>>>>>>>>>>>>>/// @Status      Internal
70878>>>>>>>>>>>>>>>>>/// @Drivers     All
70878>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
70878>>>>>>>>>>>>>>>>>/// @See
70878>>>>>>>>>>>>>>>>>
70878>>>>>>>>>>>>>>>>>Function MertechInc_DO_GET_BIND_PARAMETERS Global Integer bSQLFlex String sArg1 String sArg2 Integer iArg Returns String
70880>>>>>>>>>>>>>>>>>    String sReturnValue
70880>>>>>>>>>>>>>>>>>    Integer iSize
70880>>>>>>>>>>>>>>>>>
70880>>>>>>>>>>>>>>>>>    if (MertechInc_DriverName = SQLFLEX) ;                move (iArg+1) to iArg
70883>>>>>>>>>>>>>>>>>//        SQL_GET_COL_ATTRIBUTE of iArg DATA_LENGTH to iSize
70883>>>>>>>>>>>>>>>>>
70883>>>>>>>>>>>>>>>>>    Get MertechInc_Pre_Size_String (iSize+1) to sReturnValue
70884>>>>>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function 24 CALLBACK 0 PASSING sReturnValue MertechInc_Blank iArg RESULT MertechInc_iRet
70889>>>>>>>>>>>>>>>>>
70889>>>>>>>>>>>>>>>>>    Function_Return sReturnValue
70890>>>>>>>>>>>>>>>>>End_Function
70891>>>>>>>>>>>>>>>>>
70891>>>>>>>>>>>>>>>>>//=============================================================================
70891>>>>>>>>>>>>>>>>>/// @Name        SQL_GET_OUTPUT_VALUE
70891>>>>>>>>>>>>>>>>>/// @Description This command is used to get the value of a specific
70891>>>>>>>>>>>>>>>>>/// parameter associated with a stored procedure.  Although this
70891>>>>>>>>>>>>>>>>>/// command will work with any parameter, it is mostly used with
70891>>>>>>>>>>>>>>>>>/// IN/OUT or OUT parameters as their value will more often be important
70891>>>>>>>>>>>>>>>>>/// once returned. When multiple values are returned, this command can be
70891>>>>>>>>>>>>>>>>>/// more efficient than other options. Note that the specified parameter
70891>>>>>>>>>>>>>>>>>/// must first be defined using the SQL_SET_PROCEDURE_PARAMETER command
70891>>>>>>>>>>>>>>>>>/// in order to work properly.
70891>>>>>>>>>>>>>>>>>///
70891>>>>>>>>>>>>>>>>>/// @Assumptions
70891>>>>>>>>>>>>>>>>>/// @Status      Deprecated
70891>>>>>>>>>>>>>>>>>/// @Drivers     All
70891>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
70891>>>>>>>>>>>>>>>>>/// @See                 SQL_GET_PROCEDURE_PARAMETER
70891>>>>>>>>>>>>>>>>>///
70891>>>>>>>>>>>>>>>>>/// @Syntax SQL_GET_OUTPUT_VALUE {parameter} to {variable}
70891>>>>>>>>>>>>>>>>>/// @Param parameter            Number of the parameter
70891>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the parameter's value
70891>>>>>>>>>>>>>>>>>///
70891>>>>>>>>>>>>>>>>>/// @Example
70891>>>>>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_NAME "user.getCustomerStatus" NUMPAR 1
70891>>>>>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 1 to sCustomerID IN_OUT
70891>>>>>>>>>>>>>>>>>/// SQL_PROCEDURE_EXECUTE
70891>>>>>>>>>>>>>>>>>/// SQL_GET_OUTPUT_VALUE 1 to sStatus
70891>>>>>>>>>>>>>>>>>///
70891>>>>>>>>>>>>>>>>>/// Showln sStatus
70891>>>>>>>>>>>>>>>>>///
70891>>>>>>>>>>>>>>>>>/// @Example
70891>>>>>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_NAME "user.getCustomerStatus" NUMPAR 2
70891>>>>>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 1 to sCustomerID IN
70891>>>>>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 2 to sStatus OUT
70891>>>>>>>>>>>>>>>>>/// SQL_PROCEDURE_EXECUTE
70891>>>>>>>>>>>>>>>>>/// SQL_GET_OUTPUT_VALUE 2 to sStatus
70891>>>>>>>>>>>>>>>>>///
70891>>>>>>>>>>>>>>>>>/// Showln sStatus
70891>>>>>>>>>>>>>>>>>// OLI:
70891>>>>>>>>>>>>>>>>>// This function is identical in operation to SQL_GET_PROCEDURE_PARAMETER, so just do a replace
70891>>>>>>>>>>>>>>>>>
70891>>>>>>>>>>>>>>>>>//=============================================================================
70891>>>>>>>>>>>>>>>>>/// @Name        SQL_FETCH_COLUMN
70891>>>>>>>>>>>>>>>>>/// @Description This command is used to retrieve a specified column from a
70891>>>>>>>>>>>>>>>>>/// result set of an SQL statement. Note that this command cannot be used to
70891>>>>>>>>>>>>>>>>>/// replace SQL_FETCH_NEXT_ROW but is used in addition to it when only one
70891>>>>>>>>>>>>>>>>>/// column is needed. For most cases, SQL_FETCH_NEXT_ROW can be used alone
70891>>>>>>>>>>>>>>>>>/// to retrieve the columns desired so this should only be used if there is
70891>>>>>>>>>>>>>>>>>/// a specific reason to do so.
70891>>>>>>>>>>>>>>>>>///
70891>>>>>>>>>>>>>>>>>/// @Assumptions
70891>>>>>>>>>>>>>>>>>/// @Status      Public
70891>>>>>>>>>>>>>>>>>/// @Drivers     All
70891>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-05 by Aaron Gulack
70891>>>>>>>>>>>>>>>>>/// @See                 SQL_FETCH_NEXT_ROW
70891>>>>>>>>>>>>>>>>>///
70891>>>>>>>>>>>>>>>>>/// @Syntax SQL_FETCH_COLUMN {columnNumber} into {variable}
70891>>>>>>>>>>>>>>>>>/// @Param columnNumber    Number of the column to fetch
70891>>>>>>>>>>>>>>>>>/// @Param variable        Variable to hold the fetched value
70891>>>>>>>>>>>>>>>>>///
70891>>>>>>>>>>>>>>>>>/// @Example
70891>>>>>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
70891>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT
70891>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
70891>>>>>>>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW
70891>>>>>>>>>>>>>>>>>/// SQL_GET_NUM_COLS to iCols
70891>>>>>>>>>>>>>>>>>/// For fieldIndex from 1 to iCols
70891>>>>>>>>>>>>>>>>>///     SQL_FETCH_COLUMN fieldIndex into sValue
70891>>>>>>>>>>>>>>>>>///     Showln sValue
70891>>>>>>>>>>>>>>>>>/// Loop
70891>>>>>>>>>>>>>>>>>
70891>>>>>>>>>>>>>>>>>Function MertechInc_SQL_FETCH_COLUMN Global String sArg1 String sArg2 Integer iArg Returns String
70893>>>>>>>>>>>>>>>>>    String sReturnValue
70893>>>>>>>>>>>>>>>>>    Integer iSize
70893>>>>>>>>>>>>>>>>>
70893>>>>>>>>>>>>>>>>>    Move 0 to iSize
70894>>>>>>>>>>>>>>>>>        SQL_GET_COL_ATTRIBUTE of iArg DATA_LENGTH to iSize
70935>>>>>>>>>>>>>>>>>>
70935>>>>>>>>>>>>>>>>>
70935>>>>>>>>>>>>>>>>>    Get MertechInc_Pre_Size_String (iSize+1) to sReturnValue
70936>>>>>>>>>>>>>>>>>    Move (|CI$10000 * iArg) to iArg // Shift column number 16 bits to the left
70937>>>>>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function 24 CALLBACK 0 PASSING sReturnValue MertechInc_Blank iArg RESULT MertechInc_iRet
70942>>>>>>>>>>>>>>>>>
70942>>>>>>>>>>>>>>>>>    Function_Return sReturnValue
70943>>>>>>>>>>>>>>>>>End_Function
70944>>>>>>>>>>>>>>>>>
70944>>>>>>>>>>>>>>>>>//=============================================================================
70944>>>>>>>>>>>>>>>>>/// @Name        SET_SCHEMA_NAME
70944>>>>>>>>>>>>>>>>>/// @Description This command is used to set the schema name to be used when
70944>>>>>>>>>>>>>>>>>/// opening tables. Note that this command will override the schema name that
70944>>>>>>>>>>>>>>>>>/// is set in the INT file.  The default schema for the current user is used
70944>>>>>>>>>>>>>>>>>/// when no name is set.
70944>>>>>>>>>>>>>>>>>///
70944>>>>>>>>>>>>>>>>>/// @Assumptions
70944>>>>>>>>>>>>>>>>>/// @Status      Public
70944>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex and ORAFlex
70944>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-24 by Aaron Gulack
70944>>>>>>>>>>>>>>>>>/// @See                 GET_SCHEMA_NAME
70944>>>>>>>>>>>>>>>>>///
70944>>>>>>>>>>>>>>>>>/// @Syntax SET_SCHEMA_NAME to {schema}
70944>>>>>>>>>>>>>>>>>/// @Param variable                     Name of the schema
70944>>>>>>>>>>>>>>>>>///
70944>>>>>>>>>>>>>>>>>/// @Example
70944>>>>>>>>>>>>>>>>>/// SET_SCHEMA_NAME to 'CustomerSchema'
70944>>>>>>>>>>>>>>>>>/// OPEN "CUSTOMER.INT" as CUSTOMER
70944>>>>>>>>>>>>>>>>>/// SET_SCHEMA_NAME to 'SalesSchema'
70944>>>>>>>>>>>>>>>>>/// OPEN "SALESP.INT" as SALESP
70944>>>>>>>>>>>>>>>>>
70944>>>>>>>>>>>>>>>>>//=============================================================================
70944>>>>>>>>>>>>>>>>>/// @Name        GET_SCHEMA_NAME
70944>>>>>>>>>>>>>>>>>/// @Description This command is used to get the name of the schema being
70944>>>>>>>>>>>>>>>>>/// used to open tables.
70944>>>>>>>>>>>>>>>>>///
70944>>>>>>>>>>>>>>>>>/// @Assumptions
70944>>>>>>>>>>>>>>>>>/// @Status      Public
70944>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex and ORAFlex
70944>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-24 by Aaron Gulack
70944>>>>>>>>>>>>>>>>>/// @See                 SET_SCHEMA_NAME
70944>>>>>>>>>>>>>>>>>///
70944>>>>>>>>>>>>>>>>>/// @Syntax GET_SCHEMA_NAME to {variable}
70944>>>>>>>>>>>>>>>>>/// @Param variable                     variable to hold the schema name
70944>>>>>>>>>>>>>>>>>///
70944>>>>>>>>>>>>>>>>>/// @Example
70944>>>>>>>>>>>>>>>>>/// GET_SCHEMA_NAME to sName
70944>>>>>>>>>>>>>>>>>/// Showln sName
70944>>>>>>>>>>>>>>>>>
70944>>>>>>>>>>>>>>>>>//=============================================================================
70944>>>>>>>>>>>>>>>>>/// @Name        CALL_ORACLE_STORED_PROCEDURE
70944>>>>>>>>>>>>>>>>>/// @Description This command is used to call a stored procedure on the SQL
70944>>>>>>>>>>>>>>>>>/// backend. To successfully call a procedure with this command, a string
70944>>>>>>>>>>>>>>>>>/// must be passed containing a valid procedure name. In addition, if the
70944>>>>>>>>>>>>>>>>>/// procedure takes any arguments, they must also be passed using the constant
70944>>>>>>>>>>>>>>>>>/// "passing" along with all of the needed arguments. If the procedure has a
70944>>>>>>>>>>>>>>>>>/// return value, then SQL_GET_FUNCTION_RETURN or SQL_FETCH_NEXT_ROW can be
70944>>>>>>>>>>>>>>>>>/// used to get the value(s). If an error is found then the indicator "Err"
70944>>>>>>>>>>>>>>>>>/// is set to true.
70944>>>>>>>>>>>>>>>>>///
70944>>>>>>>>>>>>>>>>>/// @Assumptions
70944>>>>>>>>>>>>>>>>>/// @Status      Deprecated
70944>>>>>>>>>>>>>>>>>/// @Drivers     ORAFLex
70944>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-25 by Aaron Gulack
70944>>>>>>>>>>>>>>>>>/// @See                 CALL_STORED_PROCEDURE
70944>>>>>>>>>>>>>>>>>///
70944>>>>>>>>>>>>>>>>>/// @Syntax CALL_ORACLE_STORED_PROCEDURE {procedure} Passing {variable}
70944>>>>>>>>>>>>>>>>>/// @Param procedure            Full name of the procedure
70944>>>>>>>>>>>>>>>>>/// @Param variable                     Argument being passed to procedure (can be multiple)
70944>>>>>>>>>>>>>>>>>///
70944>>>>>>>>>>>>>>>>>/// @Example
70944>>>>>>>>>>>>>>>>>/// CALL_ORACLE_STORED_PROCEDURE "sys.sp_addmessage" passing 50003 15 "Please enter a valid date"
70944>>>>>>>>>>>>>>>>>
70944>>>>>>>>>>>>>>>>>//=============================================================================
70944>>>>>>>>>>>>>>>>>/// @Name        SQL_SET_PROCEDURE_NAME
70944>>>>>>>>>>>>>>>>>/// @Description This command is used to set the procedure to be executed.
70944>>>>>>>>>>>>>>>>>/// This is used when the procedure is being split up into multiple lines
70944>>>>>>>>>>>>>>>>>/// as shown below. When using this command, SQL_PROCEDURE_EXECUTE must be
70944>>>>>>>>>>>>>>>>>/// called after all parameters have been set to successfully execute the
70944>>>>>>>>>>>>>>>>>/// procedure. The constant "NUMPAR" is used to indicate how many parameters
70944>>>>>>>>>>>>>>>>>/// will be passed.
70944>>>>>>>>>>>>>>>>>///
70944>>>>>>>>>>>>>>>>>/// @Assumptions The procedure is a valid procedure in the SQL database
70944>>>>>>>>>>>>>>>>>/// @Status      Public
70944>>>>>>>>>>>>>>>>>/// @Drivers     All
70944>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-25 by Aaron Gulack
70944>>>>>>>>>>>>>>>>>/// @See                 SQL_SET_PROCEDURE_PARAMETER SQL_PROCEDURE_EXECUTE
70944>>>>>>>>>>>>>>>>>///
70944>>>>>>>>>>>>>>>>>/// @Syntax SQL_SET_PROCEDURE_NAME {procedure} NUMPAR {variable}
70944>>>>>>>>>>>>>>>>>/// @Param procedure            Full name of the procedure
70944>>>>>>>>>>>>>>>>>/// @Param variable                     Number of parameters to be passed
70944>>>>>>>>>>>>>>>>>///
70944>>>>>>>>>>>>>>>>>/// @Example
70944>>>>>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_NAME "sys.sp_addmessage" NUMPAR 3
70944>>>>>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 1 to 500004 IN
70944>>>>>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 2 to 15 IN
70944>>>>>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 3 to "Please enter a valid Date" IN
70944>>>>>>>>>>>>>>>>>/// SQL_PROCEDURE_EXECUTE
70944>>>>>>>>>>>>>>>>>
70944>>>>>>>>>>>>>>>>>
70944>>>>>>>>>>>>>>>>>Procedure MertechInc_SQL_SET_ORAPROCEDURE_NAME Global String strProcName Integer iNumpar
70946>>>>>>>>>>>>>>>>>    Integer iParam
70946>>>>>>>>>>>>>>>>>
70946>>>>>>>>>>>>>>>>>    Move 0 to MertechInc_iParamCount       //Redundant, but left in incase called
70947>>>>>>>>>>>>>>>>>    INDICATE ERR False              //directly and not via SQL_SET_PROCEDURE_NAME
70948>>>>>>>>>>>>>>>>>    Move ORAFlex to MertechInc_DriverName  //
70949>>>>>>>>>>>>>>>>>
70949>>>>>>>>>>>>>>>>>    SQL_SET_STMT to "BEGIN "
70981>>>>>>>>>>>>>>>>>    SQL_APPEND_STMT to strProcName
71013>>>>>>>>>>>>>>>>>    SQL_APPEND_STMT to "( "
71045>>>>>>>>>>>>>>>>>    For iParam from 1 to iNumpar
71051>>>>>>>>>>>>>>>>>>
71051>>>>>>>>>>>>>>>>>        DO_PASS_ARGUMENTS iParam
71130>>>>>>>>>>>>>>>>>    Loop
71131>>>>>>>>>>>>>>>>>>
71131>>>>>>>>>>>>>>>>>    SQL_APPEND_STMT to  " ); END;"
71163>>>>>>>>>>>>>>>>>    SQL_PREPARE_STMT
71212>>>>>>>>>>>>>>>>> End_Procedure
71213>>>>>>>>>>>>>>>>>
71213>>>>>>>>>>>>>>>>>Procedure MertechInc_SQL_SET_MYPROCEDURE_NAME Global String strProcName Integer iNumpar
71215>>>>>>>>>>>>>>>>>    Integer iParam
71215>>>>>>>>>>>>>>>>>
71215>>>>>>>>>>>>>>>>>    Move 0 to MertechInc_iParamCount           //Redundant, but left in incase called
71216>>>>>>>>>>>>>>>>>    INDICATE ERR False                  //directly and not via SQL_SET_PROCEDURE_NAME
71217>>>>>>>>>>>>>>>>>    Move MySQLFlex to MertechInc_DriverName    //
71218>>>>>>>>>>>>>>>>>
71218>>>>>>>>>>>>>>>>>    SQL_SET_STMT to "CALL "
71250>>>>>>>>>>>>>>>>>    SQL_APPEND_STMT to strProcName
71282>>>>>>>>>>>>>>>>>    SQL_APPEND_STMT to "("
71314>>>>>>>>>>>>>>>>>    For iParam from 1 to iNumpar
71320>>>>>>>>>>>>>>>>>>
71320>>>>>>>>>>>>>>>>>        DO_PASS_ARGUMENTS iParam
71399>>>>>>>>>>>>>>>>>    Loop
71400>>>>>>>>>>>>>>>>>>
71400>>>>>>>>>>>>>>>>>    SQL_APPEND_STMT to ")"
71432>>>>>>>>>>>>>>>>>    SQL_PREPARE_STMT
71481>>>>>>>>>>>>>>>>>End_Procedure
71482>>>>>>>>>>>>>>>>>
71482>>>>>>>>>>>>>>>>>Procedure MertechInc_SQL_SET_MSPROCEDURE_NAME Global String strProcName Integer iNumpar
71484>>>>>>>>>>>>>>>>>    Integer iParam
71484>>>>>>>>>>>>>>>>>    String  sParam
71484>>>>>>>>>>>>>>>>>
71484>>>>>>>>>>>>>>>>>    Move SQLFlex to MertechInc_DriverName
71485>>>>>>>>>>>>>>>>>
71485>>>>>>>>>>>>>>>>>    // This calling syntax is referred to as the "ODBC CALL escape sequence".  This syntax is
71485>>>>>>>>>>>>>>>>>    // advised over the execute command since CALL allows for the retrieval of the return codes
71485>>>>>>>>>>>>>>>>>    // from the call.
71485>>>>>>>>>>>>>>>>>    SQL_SET_STMT to "{? = CALL "
71517>>>>>>>>>>>>>>>>>    SQL_APPEND_STMT to strProcName
71549>>>>>>>>>>>>>>>>>
71549>>>>>>>>>>>>>>>>>    // Note that DO_PASS_ARGUMENTS can add the open paren for us, but only if the keyword "PASSING"
71549>>>>>>>>>>>>>>>>>    // is passed to it first time through.  This is a bit weird, so we ignore that and just add
71549>>>>>>>>>>>>>>>>>    // the open and close parens ourself to make things more clear.
71549>>>>>>>>>>>>>>>>>    If (iNumpar > 0) SQL_APPEND_STMT to " ("
71583>>>>>>>>>>>>>>>>>
71583>>>>>>>>>>>>>>>>>    For iParam from 1 to iNumpar
71589>>>>>>>>>>>>>>>>>>
71589>>>>>>>>>>>>>>>>>        DO_PASS_ARGUMENTS iParam
71668>>>>>>>>>>>>>>>>>    Loop
71669>>>>>>>>>>>>>>>>>>
71669>>>>>>>>>>>>>>>>>
71669>>>>>>>>>>>>>>>>>    If (iNumpar > 0) SQL_APPEND_STMT to ")"
71703>>>>>>>>>>>>>>>>>    SQL_APPEND_STMT to  " };"
71735>>>>>>>>>>>>>>>>>
71735>>>>>>>>>>>>>>>>>    SQL_PREPARE_STMT CURSOR_TYPE TYPE_NONE
71791>>>>>>>>>>>>>>>>>
71791>>>>>>>>>>>>>>>>>    // This bind parameter is for the "{? = " which is technically the first parameter even though
71791>>>>>>>>>>>>>>>>>    // it is the return value.  The driver will bind MertechInc_iWork to it.
71791>>>>>>>>>>>>>>>>>    DO_BIND_PARAMETERS MertechInc_iWork
71814>>>>>>>>>>>>>>>>>End_Procedure
71815>>>>>>>>>>>>>>>>>
71815>>>>>>>>>>>>>>>>>Procedure MertechInc_SQL_SET_PGPROCEDURE_NAME Global String strProcName Integer iNumpar
71817>>>>>>>>>>>>>>>>>    Integer iParam
71817>>>>>>>>>>>>>>>>>    String  sParam
71817>>>>>>>>>>>>>>>>>
71817>>>>>>>>>>>>>>>>>    Move PgFlex to MertechInc_DriverName
71818>>>>>>>>>>>>>>>>>
71818>>>>>>>>>>>>>>>>>    // For Postgres, you can call a function just by passing the function name and
71818>>>>>>>>>>>>>>>>>    // open/close parens
71818>>>>>>>>>>>>>>>>>    SQL_SET_STMT to strProcName
71850>>>>>>>>>>>>>>>>>
71850>>>>>>>>>>>>>>>>>    // Note that DO_PASS_ARGUMENTS can add the open paren for us, but only if the keyword "PASSING"
71850>>>>>>>>>>>>>>>>>    // is passed to it first time through.  This is a bit weird, so we ignore that and just add
71850>>>>>>>>>>>>>>>>>    // the open and close parens ourself to make things more clear.
71850>>>>>>>>>>>>>>>>>    SQL_APPEND_STMT to "( "
71882>>>>>>>>>>>>>>>>>
71882>>>>>>>>>>>>>>>>>    For iParam from 1 to iNumpar
71888>>>>>>>>>>>>>>>>>>
71888>>>>>>>>>>>>>>>>>        DO_PASS_ARGUMENTS iParam
71967>>>>>>>>>>>>>>>>>    Loop
71968>>>>>>>>>>>>>>>>>>
71968>>>>>>>>>>>>>>>>>
71968>>>>>>>>>>>>>>>>>    SQL_APPEND_STMT to ")"
72000>>>>>>>>>>>>>>>>>
72000>>>>>>>>>>>>>>>>>    SQL_PREPARE_STMT
72049>>>>>>>>>>>>>>>>>    // Indicate that a stored function will be executed - Query = 0, Procedure = 1, Function = 2
72049>>>>>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_EMBEDDED_SQL_TYPE CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank 1 RESULT MertechInc_iRet
72054>>>>>>>>>>>>>>>>>End_Procedure
72055>>>>>>>>>>>>>>>>>
72055>>>>>>>>>>>>>>>>>//=============================================================================
72055>>>>>>>>>>>>>>>>>/// @Name        SQL_GET_STMT
72055>>>>>>>>>>>>>>>>>/// @Description This command returns the last embedded SQL statement that
72055>>>>>>>>>>>>>>>>>/// was executed into a string. Optional parameters can be passed to specify
72055>>>>>>>>>>>>>>>>>/// what character to start the string at and also the maximum number of
72055>>>>>>>>>>>>>>>>>/// characters to allow for the string.
72055>>>>>>>>>>>>>>>>>///
72055>>>>>>>>>>>>>>>>>/// @Assumptions
72055>>>>>>>>>>>>>>>>>/// @Status      Public
72055>>>>>>>>>>>>>>>>>/// @Drivers     All
72055>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-24 by Aaron Gulack
72055>>>>>>>>>>>>>>>>>/// @See                 SQL_GET_STATEMENT
72055>>>>>>>>>>>>>>>>>///
72055>>>>>>>>>>>>>>>>>/// @Syntax SQL_GET_STMT to {variable} [{max} {start}]
72055>>>>>>>>>>>>>>>>>/// @Param variable                     SQL statement to be executed
72055>>>>>>>>>>>>>>>>>/// @Param max                          Indicates the maximum number of characters to get (optional)
72055>>>>>>>>>>>>>>>>>/// @Param start                        Indicates what character to start at for the returned string (optional)
72055>>>>>>>>>>>>>>>>>///
72055>>>>>>>>>>>>>>>>>/// @Example
72055>>>>>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
72055>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT
72055>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
72055>>>>>>>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sFirstName sLastName
72055>>>>>>>>>>>>>>>>>/// If (Found) Begin
72055>>>>>>>>>>>>>>>>>///     Showln sFirstName
72055>>>>>>>>>>>>>>>>>///     Showln sLastName
72055>>>>>>>>>>>>>>>>>/// End
72055>>>>>>>>>>>>>>>>>///
72055>>>>>>>>>>>>>>>>>/// SQL_GET_STATEMENT to sValue
72055>>>>>>>>>>>>>>>>>/// Showln sValue
72055>>>>>>>>>>>>>>>>>
72055>>>>>>>>>>>>>>>>>
72055>>>>>>>>>>>>>>>>>Function MertechInc_SQL_GET_STATEMENT Global Integer iLength Integer iStart Returns String
72057>>>>>>>>>>>>>>>>>    String sStatement
72057>>>>>>>>>>>>>>>>>
72057>>>>>>>>>>>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
72083>>>>>>>>>>>>>>>>>>
72083>>>>>>>>>>>>>>>>>
72083>>>>>>>>>>>>>>>>>    If (MertechInc_FileNumber <> -1) Begin
72085>>>>>>>>>>>>>>>>>        Get MertechInc_Pre_Size_String 0 to sStatement
72086>>>>>>>>>>>>>>>>>        Call_Driver 0 MertechInc_DriverName Function CALLDRV_GET_SQL_STMT CALLBACK 0 PASSING sStatement iStart iLength RESULT MertechInc_iRet
72091>>>>>>>>>>>>>>>>>    End
72091>>>>>>>>>>>>>>>>>>
72091>>>>>>>>>>>>>>>>>    Function_Return sStatement
72092>>>>>>>>>>>>>>>>>End_Function
72093>>>>>>>>>>>>>>>>>
72093>>>>>>>>>>>>>>>>>//=============================================================================
72093>>>>>>>>>>>>>>>>>/// @Name        SQL_SET_FUNCTION_NAME
72093>>>>>>>>>>>>>>>>>/// @Description This command is used in the same way as SQL_SET_PROCEDURE_NAME
72093>>>>>>>>>>>>>>>>>/// and SQL_SET_STMT to set the name of the function to be executed. When
72093>>>>>>>>>>>>>>>>>/// calling SQL functions in this fashion, this command must be used along with
72093>>>>>>>>>>>>>>>>>/// SQL_FUNCTION_EXECUTE (to execute the function), SQL_SET_FUNCTION_PARAMETER
72093>>>>>>>>>>>>>>>>>/// (to set the needed parameters) and SQL_GET_FUNCTION_RETURN (to get any
72093>>>>>>>>>>>>>>>>>/// returned value). The number of parameters must be set using the constant,
72093>>>>>>>>>>>>>>>>>/// NUMPAR, followed by the number of parameters. Note that when setting the
72093>>>>>>>>>>>>>>>>>/// name of the function, the user can be specified or, if left blank, the
72093>>>>>>>>>>>>>>>>>/// current user will be inserted before the function name.
72093>>>>>>>>>>>>>>>>>///
72093>>>>>>>>>>>>>>>>>/// @Assumptions
72093>>>>>>>>>>>>>>>>>/// @Status      Public
72093>>>>>>>>>>>>>>>>>/// @Drivers     All
72093>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
72093>>>>>>>>>>>>>>>>>/// @See                 SQL_FUNCTION_EXECUTE SQL_SET_FUNCTION_PARAMETER SQL_GET_FUNCTION_RETURN
72093>>>>>>>>>>>>>>>>>///
72093>>>>>>>>>>>>>>>>>/// @Syntax SQL_SET_FUNCTION_NAME {function} NUMPAR {parameters}
72093>>>>>>>>>>>>>>>>>/// @Param function                     Full name of the function
72093>>>>>>>>>>>>>>>>>/// @Param parameters           Number of parameters to pass
72093>>>>>>>>>>>>>>>>>///
72093>>>>>>>>>>>>>>>>>/// @Example
72093>>>>>>>>>>>>>>>>>/// SQL_SET_FUNCTION_NAME "getCustomerStatus" NUMPAR 1
72093>>>>>>>>>>>>>>>>>/// SQL_SET_FUNCTION_PARAMETER 1 to 'Jones' IN
72093>>>>>>>>>>>>>>>>>/// SQL_FUNCTION_EXECUTE
72093>>>>>>>>>>>>>>>>>/// SQL_GET_FUNCTION_RETURN to dDOB
72093>>>>>>>>>>>>>>>>>/// Showln dDOB
72093>>>>>>>>>>>>>>>>>
72093>>>>>>>>>>>>>>>>>Procedure MertechInc_SQL_SET_ORAFUNCTION_NAME Global String strProcName Integer iNumpar
72095>>>>>>>>>>>>>>>>>    Integer iParam
72095>>>>>>>>>>>>>>>>>
72095>>>>>>>>>>>>>>>>>    SQL_SET_STMT to "BEGIN "
72127>>>>>>>>>>>>>>>>>    SQL_APPEND_STMT to ":PAR_RET := "
72159>>>>>>>>>>>>>>>>>    SQL_APPEND_STMT to strProcName
72191>>>>>>>>>>>>>>>>>    SQL_APPEND_STMT to "( "
72223>>>>>>>>>>>>>>>>>    For iParam from 1 to iNumpar
72229>>>>>>>>>>>>>>>>>>
72229>>>>>>>>>>>>>>>>>        DO_PASS_ARGUMENTS iParam
72308>>>>>>>>>>>>>>>>>    Loop
72309>>>>>>>>>>>>>>>>>>
72309>>>>>>>>>>>>>>>>>    SQL_APPEND_STMT to  " ); END;"
72341>>>>>>>>>>>>>>>>>    SQL_PREPARE_STMT
72390>>>>>>>>>>>>>>>>>
72390>>>>>>>>>>>>>>>>>    Move IS_OUT to MertechInc_iArg
72391>>>>>>>>>>>>>>>>>    Call_Driver 0 ORAFLEX Function CALLDRV_SET_PROC_ATTRIBUTE_TYPE CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank MertechInc_iArg RESULT MertechInc_iRet
72396>>>>>>>>>>>>>>>>>
72396>>>>>>>>>>>>>>>>>    Increment MertechInc_iParamCount
72397>>>>>>>>>>>>>>>>>    Move ":PAR_RET" to MertechInc_sArg2
72398>>>>>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_BIND_PARAMETER CALLBACK 0 PASSING MertechInc_Blank MertechInc_sArg2 16384 RESULT MertechInc_iRet
72403>>>>>>>>>>>>>>>>>End_Procedure
72404>>>>>>>>>>>>>>>>>
72404>>>>>>>>>>>>>>>>>Procedure MertechInc_SQL_SET_MYFUNCTION_NAME Global String strProcName Integer iNumpar
72406>>>>>>>>>>>>>>>>>    Integer iParam
72406>>>>>>>>>>>>>>>>>
72406>>>>>>>>>>>>>>>>>    Move MySQLFlex to MertechInc_DriverName
72407>>>>>>>>>>>>>>>>>
72407>>>>>>>>>>>>>>>>>    SQL_SET_STMT to "SELECT "
72439>>>>>>>>>>>>>>>>>    SQL_APPEND_STMT to strProcName
72471>>>>>>>>>>>>>>>>>    SQL_APPEND_STMT to "("
72503>>>>>>>>>>>>>>>>>    For iParam from 1 to iNumpar
72509>>>>>>>>>>>>>>>>>>
72509>>>>>>>>>>>>>>>>>        DO_PASS_ARGUMENTS iParam
72588>>>>>>>>>>>>>>>>>    Loop
72589>>>>>>>>>>>>>>>>>>
72589>>>>>>>>>>>>>>>>>    SQL_APPEND_STMT to ")"
72621>>>>>>>>>>>>>>>>>    SQL_PREPARE_STMT
72670>>>>>>>>>>>>>>>>>End_Procedure
72671>>>>>>>>>>>>>>>>>
72671>>>>>>>>>>>>>>>>>Procedure MertechInc_SQL_SET_SQLFUNCTION_NAME Global String strProcName Integer iNumpar
72673>>>>>>>>>>>>>>>>>    Integer iParam
72673>>>>>>>>>>>>>>>>>
72673>>>>>>>>>>>>>>>>>    Move SQLFlex to MertechInc_DriverName
72674>>>>>>>>>>>>>>>>>
72674>>>>>>>>>>>>>>>>>    If (not(strProcName contains ".")) Begin
72676>>>>>>>>>>>>>>>>>        String schema
72676>>>>>>>>>>>>>>>>>        GET_SCHEMA_NAME to schema
72722>>>>>>>>>>>>>>>>>        Move (schema + "." + strProcName) to strProcName
72723>>>>>>>>>>>>>>>>>    End
72723>>>>>>>>>>>>>>>>>>
72723>>>>>>>>>>>>>>>>>
72723>>>>>>>>>>>>>>>>>    SQL_SET_STMT    to "SELECT "
72755>>>>>>>>>>>>>>>>>    SQL_APPEND_STMT to strProcName
72787>>>>>>>>>>>>>>>>>    SQL_APPEND_STMT to "("
72819>>>>>>>>>>>>>>>>>End_Procedure
72820>>>>>>>>>>>>>>>>>
72820>>>>>>>>>>>>>>>>>Procedure MertechInc_SQL_SET_PGFUNCTION_NAME Global String strProcName Integer iNumpar
72822>>>>>>>>>>>>>>>>>    Integer iParam
72822>>>>>>>>>>>>>>>>>
72822>>>>>>>>>>>>>>>>>    Move PgFlex to MertechInc_DriverName
72823>>>>>>>>>>>>>>>>>
72823>>>>>>>>>>>>>>>>>    SQL_SET_STMT    to "SELECT "
72855>>>>>>>>>>>>>>>>>    SQL_APPEND_STMT to strProcName
72887>>>>>>>>>>>>>>>>>    SQL_APPEND_STMT to "("
72919>>>>>>>>>>>>>>>>>End_Procedure
72920>>>>>>>>>>>>>>>>>
72920>>>>>>>>>>>>>>>>>//=============================================================================
72920>>>>>>>>>>>>>>>>>/// @Name        SQL_SET_PROCEDURE_PARAMETER
72920>>>>>>>>>>>>>>>>>/// @Description
72920>>>>>>>>>>>>>>>>>/// With this command you can pass one or more parameters to predefined
72920>>>>>>>>>>>>>>>>>/// stored procedures on a MySQL or Oracle server. The SQL_SET_PROCEDURE_PARAMETER
72920>>>>>>>>>>>>>>>>>/// command enables you to add a parameter to a stored procedure which you are
72920>>>>>>>>>>>>>>>>>/// planning to call. You can pass multiple parameters by calling the command
72920>>>>>>>>>>>>>>>>>/// for each parameter.
72920>>>>>>>>>>>>>>>>>///
72920>>>>>>>>>>>>>>>>>/// When passing parameters you'll have to inform the driver which variable
72920>>>>>>>>>>>>>>>>>/// you are passing, starting with 1 from left-to-right in the parameter list.
72920>>>>>>>>>>>>>>>>>///
72920>>>>>>>>>>>>>>>>>/// For each parameter you'll have to indicate if the variable is to be
72920>>>>>>>>>>>>>>>>>/// regarded as input, output or both.
72920>>>>>>>>>>>>>>>>>///
72920>>>>>>>>>>>>>>>>>///@Assumptions
72920>>>>>>>>>>>>>>>>>/// @Status      Public
72920>>>>>>>>>>>>>>>>>/// @Drivers     All
72920>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-27 by Aaron Gulack
72920>>>>>>>>>>>>>>>>>/// @See                 SQL_SET_PROCEDURE_NAME SQL_PROCEDURE_EXECUTE
72920>>>>>>>>>>>>>>>>>///
72920>>>>>>>>>>>>>>>>>/// @Syntax SQL_SET_PROCEDURE_PARAMETER {number} to {variable} {direction}
72920>>>>>>>>>>>>>>>>>/// @Param number                       Index number of the parameter being defined.
72920>>>>>>>>>>>>>>>>>/// @Param variable                     Variable holding the parameter to be passed.
72920>>>>>>>>>>>>>>>>>/// @Param direction            IN, OUT, IN_OUT, RSET, or leave blank
72920>>>>>>>>>>>>>>>>>///
72920>>>>>>>>>>>>>>>>>/// @Example
72920>>>>>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_NAME "sys.sp_addmessage" NUMPAR 3
72920>>>>>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 1 to 500004 IN
72920>>>>>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 2 to 15 IN
72920>>>>>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 3 to "Please enter a valid Date" IN
72920>>>>>>>>>>>>>>>>>/// SQL_PROCEDURE_EXECUTE
72920>>>>>>>>>>>>>>>>>
72920>>>>>>>>>>>>>>>>>
72920>>>>>>>>>>>>>>>>>
72920>>>>>>>>>>>>>>>>>//=============================================================================
72920>>>>>>>>>>>>>>>>>/// @Name        SQL_SET_QUERY_PARAMETER
72920>>>>>>>>>>>>>>>>>/// @Description
72920>>>>>>>>>>>>>>>>>/// Use this command to set the value of the parameters that are defined in your
72920>>>>>>>>>>>>>>>>>/// SQL Query. Each backend uses a different syntax for paramterized queries,
72920>>>>>>>>>>>>>>>>>/// but all have the same goal of removing the risk of SQL Injection attacks.
72920>>>>>>>>>>>>>>>>>/// Oracle and PostgreSQL allow for named parameters which this command supports
72920>>>>>>>>>>>>>>>>>/// by passing the first parameter as a string containing the named parameter
72920>>>>>>>>>>>>>>>>>/// (without the syntactical sugar). For MS-SQL and MySQL only positional
72920>>>>>>>>>>>>>>>>>/// parameters are supported and the first parameter to this command should be an
72920>>>>>>>>>>>>>>>>>/// integer containing the ordinal position of the parameter.
72920>>>>>>>>>>>>>>>>>///
72920>>>>>>>>>>>>>>>>>///
72920>>>>>>>>>>>>>>>>>///@Assumptions
72920>>>>>>>>>>>>>>>>>/// @Status      Public
72920>>>>>>>>>>>>>>>>>/// @Drivers     All
72920>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2018-03-06 by Oliver Nelson
72920>>>>>>>>>>>>>>>>>/// @See         SQL_SET_STMT SQL_EXECUTE_STMT
72920>>>>>>>>>>>>>>>>>///
72920>>>>>>>>>>>>>>>>>/// @Syntax SQL_SET_QUERY_PARAMETER {param} to {variable}
72920>>>>>>>>>>>>>>>>>/// @Param param                     Either a string containing the named parameter or an integer of it's ordinal position.
72920>>>>>>>>>>>>>>>>>/// @Param variable/constant         Variable or constant holding the parameter to be passed.
72920>>>>>>>>>>>>>>>>>///
72920>>>>>>>>>>>>>>>>>/// @Example
72920>>>>>>>>>>>>>>>>>/// SQL_SET_STMT "Select name from Customer where status = ? and city = ?"
72920>>>>>>>>>>>>>>>>>/// SQL_SET_QUERY_PARAMETER 1 to "Y"
72920>>>>>>>>>>>>>>>>>/// SQL_SET_QUERY_PARAMETER 2 to "Fresno"
72920>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
72920>>>>>>>>>>>>>>>>>
72920>>>>>>>>>>>>>>>>>Function MDS_Get_Param_Type Global Variant vVal Returns Integer
72922>>>>>>>>>>>>>>>>>    Local Integer vartype retval
72922>>>>>>>>>>>>>>>>>    Local Variant some_val
72922>>>>>>>>>>>>>>>>>    Move vVal to some_val
72923>>>>>>>>>>>>>>>>>    Move (DeRefW(AddressOf(some_val), 0)) to vartype
72924>>>>>>>>>>>>>>>>>
72924>>>>>>>>>>>>>>>>>    If (vartype = 2) Begin
72926>>>>>>>>>>>>>>>>>        Move ((13 * (2^24)) + 6) to retval
72927>>>>>>>>>>>>>>>>>    End
72927>>>>>>>>>>>>>>>>>>
72927>>>>>>>>>>>>>>>>>    Else If (vartype = 3) Begin
72930>>>>>>>>>>>>>>>>>        Move ((3 * (2^24)) + 11) to retval
72931>>>>>>>>>>>>>>>>>    End
72931>>>>>>>>>>>>>>>>>>
72931>>>>>>>>>>>>>>>>>    Else If (vartype = 4) Begin // OLE_VT_R4
72934>>>>>>>>>>>>>>>>>        Move ((10 * (2^24)) + 11) to retval
72935>>>>>>>>>>>>>>>>>    End
72935>>>>>>>>>>>>>>>>>>
72935>>>>>>>>>>>>>>>>>    Else If (vartype = 5) Begin // OLE_VT_R8
72938>>>>>>>>>>>>>>>>>        Move ((5 * (2^24)) + 26) to retval
72939>>>>>>>>>>>>>>>>>    End
72939>>>>>>>>>>>>>>>>>>
72939>>>>>>>>>>>>>>>>>    Else If (vartype = 6) Begin // OLE_VT_Currency
72942>>>>>>>>>>>>>>>>>        Move ((18 * (2^24)) + 21) to retval
72943>>>>>>>>>>>>>>>>>    End
72943>>>>>>>>>>>>>>>>>>
72943>>>>>>>>>>>>>>>>>    Else If (vartype = 7) Begin // OLE_VT_Date
72946>>>>>>>>>>>>>>>>>        Move ((9 * (2^24)) + 26) to retval
72947>>>>>>>>>>>>>>>>>    End
72947>>>>>>>>>>>>>>>>>>
72947>>>>>>>>>>>>>>>>>    Else If (vartype = 11) Begin // OLE_VT_Bool
72950>>>>>>>>>>>>>>>>>        Move ((16 * (2^24)) + 1) to retval
72951>>>>>>>>>>>>>>>>>    End
72951>>>>>>>>>>>>>>>>>>
72951>>>>>>>>>>>>>>>>>    Else If (vartype = 14) Begin // OLE_VT_Decimal
72954>>>>>>>>>>>>>>>>>        Move ((2 * (2^24)) + 34) to retval
72955>>>>>>>>>>>>>>>>>    End
72955>>>>>>>>>>>>>>>>>>
72955>>>>>>>>>>>>>>>>>    Else If (vartype = 16) Begin // OLE_VT_I1
72958>>>>>>>>>>>>>>>>>        Move ((11 * (2^24)) + 4) to retval
72959>>>>>>>>>>>>>>>>>    End
72959>>>>>>>>>>>>>>>>>>
72959>>>>>>>>>>>>>>>>>    Else If (vartype = 17) Begin // OLE_VT_Ui1
72962>>>>>>>>>>>>>>>>>        Move ((12 * (2^24)) + 3) to retval
72963>>>>>>>>>>>>>>>>>    End
72963>>>>>>>>>>>>>>>>>>
72963>>>>>>>>>>>>>>>>>    Else If (vartype = 18) Begin // OLE_VT_Ui2
72966>>>>>>>>>>>>>>>>>        Move ((14 * (2^24)) + 5) to retval
72967>>>>>>>>>>>>>>>>>    End
72967>>>>>>>>>>>>>>>>>>
72967>>>>>>>>>>>>>>>>>    Else If (vartype = 19) Begin // OLE_VT_Ui4
72970>>>>>>>>>>>>>>>>>        Move ((15 * (2^24)) + 10) to retval
72971>>>>>>>>>>>>>>>>>    End
72971>>>>>>>>>>>>>>>>>>
72971>>>>>>>>>>>>>>>>>    Else If (vartype = 17) Begin // OLE_VT_I8
72974>>>>>>>>>>>>>>>>>        Move ((4 * (2^24)) + 20) to retval
72975>>>>>>>>>>>>>>>>>    End
72975>>>>>>>>>>>>>>>>>>
72975>>>>>>>>>>>>>>>>>
72975>>>>>>>>>>>>>>>>>    Function_Return retval
72976>>>>>>>>>>>>>>>>>End_Function
72977>>>>>>>>>>>>>>>>>
72977>>>>>>>>>>>>>>>>>//=============================================================================
72977>>>>>>>>>>>>>>>>>/// @Name        SQL_GET_PROCEDURE_PARAMETER
72977>>>>>>>>>>>>>>>>>/// @Description This command is used to get the value of a specific
72977>>>>>>>>>>>>>>>>>/// parameter associated with a stored procedure.  Although this
72977>>>>>>>>>>>>>>>>>/// command will work with any parameter, it is mostly be used with
72977>>>>>>>>>>>>>>>>>/// IN/OUT or OUT parameters as their value will more often be important
72977>>>>>>>>>>>>>>>>>/// once returned. When multiple values are returned, this command can be
72977>>>>>>>>>>>>>>>>>/// more efficient than other options. Note that the specified parameter
72977>>>>>>>>>>>>>>>>>/// must first be defined using the SQL_SET_PROCEDURE_PARAMETER command
72977>>>>>>>>>>>>>>>>>/// in order to work properly.
72977>>>>>>>>>>>>>>>>>///
72977>>>>>>>>>>>>>>>>>/// @Assumptions
72977>>>>>>>>>>>>>>>>>/// @Status      Public
72977>>>>>>>>>>>>>>>>>/// @Drivers     All
72977>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
72977>>>>>>>>>>>>>>>>>/// @See                 SQL_SET_PROCEDURE_NAME SQL_SET_PROCEDURE_PARAMETER SQL_PROCEDURE_EXECUTE
72977>>>>>>>>>>>>>>>>>///
72977>>>>>>>>>>>>>>>>>/// @Syntax SQL_GET_PROCEDURE_PARAMETER {parameter} to {variable}
72977>>>>>>>>>>>>>>>>>/// @Param parameter            Number of paramater to return
72977>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the value of the parameter
72977>>>>>>>>>>>>>>>>>///
72977>>>>>>>>>>>>>>>>>/// @Example
72977>>>>>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_NAME "user.getCustomerStatus" NUMPAR 1
72977>>>>>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 1 to sCustomerID IN_OUT
72977>>>>>>>>>>>>>>>>>/// SQL_PROCEDURE_EXECUTE
72977>>>>>>>>>>>>>>>>>/// SQL_GET_PROCEDURE_PARAMETER 1 to sStatus
72977>>>>>>>>>>>>>>>>>///
72977>>>>>>>>>>>>>>>>>/// Showln sStatus
72977>>>>>>>>>>>>>>>>>///
72977>>>>>>>>>>>>>>>>>/// @Example
72977>>>>>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_NAME "user.getCustomerStatus" NUMPAR 2
72977>>>>>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 1 to sCustomerID IN
72977>>>>>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 2 to sStatus OUT
72977>>>>>>>>>>>>>>>>>/// SQL_PROCEDURE_EXECUTE
72977>>>>>>>>>>>>>>>>>/// SQL_GET_PROCEDURE_PARAMETER 2 to sStatus
72977>>>>>>>>>>>>>>>>>///
72977>>>>>>>>>>>>>>>>>/// Showln sStatus
72977>>>>>>>>>>>>>>>>>
72977>>>>>>>>>>>>>>>>>
72977>>>>>>>>>>>>>>>>>
72977>>>>>>>>>>>>>>>>>//=============================================================================
72977>>>>>>>>>>>>>>>>>/// @Name        SQL_GET_FUNCTION_RETURN
72977>>>>>>>>>>>>>>>>>/// @Description This variable is used to get the value returned from a SQL
72977>>>>>>>>>>>>>>>>>/// function call. After the function has been successfully called, this
72977>>>>>>>>>>>>>>>>>/// command takes the returned value and inserts it the given variable.
72977>>>>>>>>>>>>>>>>>///
72977>>>>>>>>>>>>>>>>>/// @Assumptions
72977>>>>>>>>>>>>>>>>>/// @Status      Public
72977>>>>>>>>>>>>>>>>>/// @Drivers     All
72977>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
72977>>>>>>>>>>>>>>>>>/// @See                 SQL_SET_FUNCTION_NAME SQL_SET_FUNCTION_PARAMETER SQL_FUNCTION_EXECUTE
72977>>>>>>>>>>>>>>>>>///
72977>>>>>>>>>>>>>>>>>/// @Syntax SQL_GET_FUNCTION_RETURN to {variable}
72977>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the returned value
72977>>>>>>>>>>>>>>>>>///
72977>>>>>>>>>>>>>>>>>/// @Example
72977>>>>>>>>>>>>>>>>>/// SQL_SET_FUNCTION_NAME "getCustomerStatus" NUMPAR 1
72977>>>>>>>>>>>>>>>>>/// SQL_SET_FUNCTION_PARAMETER 1 to 'Jones' IN
72977>>>>>>>>>>>>>>>>>/// SQL_FUNCTION_EXECUTE
72977>>>>>>>>>>>>>>>>>/// SQL_GET_FUNCTION_RETURN to dDOB
72977>>>>>>>>>>>>>>>>>/// Showln dDOB
72977>>>>>>>>>>>>>>>>>
72977>>>>>>>>>>>>>>>>>//=============================================================================
72977>>>>>>>>>>>>>>>>>/// @Name        SQL_FUNCTION_EXECUTE
72977>>>>>>>>>>>>>>>>>/// @Description This command is used to execute the function statement
72977>>>>>>>>>>>>>>>>>/// that was built by the SQL_SET_FUNCTION_NAME and subsequent
72977>>>>>>>>>>>>>>>>>/// SQL_SET_FUNCTION_PARAMETER commands. This works similarly to the
72977>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT command. Note that executing the function with this
72977>>>>>>>>>>>>>>>>>/// command will not get any returned values but will simply execute the
72977>>>>>>>>>>>>>>>>>/// function.
72977>>>>>>>>>>>>>>>>>///
72977>>>>>>>>>>>>>>>>>/// @Assumptions
72977>>>>>>>>>>>>>>>>>/// @Status      Public
72977>>>>>>>>>>>>>>>>>/// @Drivers     All
72977>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
72977>>>>>>>>>>>>>>>>>/// @See                 SQL_SET_FUNCTION_NAME SQL_SET_FUNCTION_PARAMETER SQL_GET_FUNCTION_RETURN
72977>>>>>>>>>>>>>>>>>///
72977>>>>>>>>>>>>>>>>>/// @Syntax SQL_FUNCTION_EXECUTE
72977>>>>>>>>>>>>>>>>>///
72977>>>>>>>>>>>>>>>>>/// @Example
72977>>>>>>>>>>>>>>>>>/// SQL_SET_FUNCTION_NAME "getCustomerStatus" NUMPAR 1
72977>>>>>>>>>>>>>>>>>/// SQL_SET_FUNCTION_PARAMETER 1 to 'Jones' IN
72977>>>>>>>>>>>>>>>>>/// SQL_FUNCTION_EXECUTE
72977>>>>>>>>>>>>>>>>>/// SQL_GET_FUNCTION_RETURN to dDOB
72977>>>>>>>>>>>>>>>>>/// Showln dDOB
72977>>>>>>>>>>>>>>>>>
72977>>>>>>>>>>>>>>>>>Procedure MertechInc_SQL_FUNCTION_EXECUTE Global String sDriverName
72979>>>>>>>>>>>>>>>>>    Integer iParam
72979>>>>>>>>>>>>>>>>>    String  sParam
72979>>>>>>>>>>>>>>>>>
72979>>>>>>>>>>>>>>>>>    If (sDriverName = SQLFLEX or sDriverName = PgFlex) Begin
72981>>>>>>>>>>>>>>>>>       SQL_APPEND_STMT to ')'
73013>>>>>>>>>>>>>>>>>       SQL_PREPARE_STMT
73062>>>>>>>>>>>>>>>>>    End
73062>>>>>>>>>>>>>>>>>>
73062>>>>>>>>>>>>>>>>>
73062>>>>>>>>>>>>>>>>>    SQL_EXECUTE_STMT
73102>>>>>>>>>>>>>>>>>    If (sDriverName <> ORAFLEX) Begin
73104>>>>>>>>>>>>>>>>>        SQL_FETCH_NEXT_ROW
73154>>>>>>>>>>>>>>>>>    End
73154>>>>>>>>>>>>>>>>>>
73154>>>>>>>>>>>>>>>>>End_Procedure
73155>>>>>>>>>>>>>>>>>
73155>>>>>>>>>>>>>>>>>//=============================================================================
73155>>>>>>>>>>>>>>>>>/// @Name        REEXEC_ORACLE_STORED_PROCEDURE
73155>>>>>>>>>>>>>>>>>/// @Description This command is used to re-execute a stored procedure
73155>>>>>>>>>>>>>>>>>/// when using Oracle. Although it follows the same format as
73155>>>>>>>>>>>>>>>>>/// CALL_STORED_PROCEDURE, it can be useful because it does not need to
73155>>>>>>>>>>>>>>>>>/// prepare the procedure again before executing. This can cause speed
73155>>>>>>>>>>>>>>>>>/// improvements when calling a stored procedure multiple times.
73155>>>>>>>>>>>>>>>>>///
73155>>>>>>>>>>>>>>>>>/// @Assumptions A procedure has already been created through CALL_STORED_PROCEDURE
73155>>>>>>>>>>>>>>>>>/// @Status      Public
73155>>>>>>>>>>>>>>>>>/// @Drivers     ORAFLex
73155>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
73155>>>>>>>>>>>>>>>>>/// @See                 CALL_STORED_PROCEDURE
73155>>>>>>>>>>>>>>>>>///
73155>>>>>>>>>>>>>>>>>/// @Syntax CALL_ORACLE_STORED_PROCEDURE {procedure} Passing {variable}
73155>>>>>>>>>>>>>>>>>/// @Param procedure            Full name of the procedure
73155>>>>>>>>>>>>>>>>>/// @Param variable                     Parameter to pass (optional and can be multiple)
73155>>>>>>>>>>>>>>>>>///
73155>>>>>>>>>>>>>>>>>/// @Example
73155>>>>>>>>>>>>>>>>>/// CALL_STORED_PROCEDURE "user.getCustomerStatus" Passing sCustomerID sStatus
73155>>>>>>>>>>>>>>>>>/// Showln sStatus
73155>>>>>>>>>>>>>>>>>///
73155>>>>>>>>>>>>>>>>>/// Move (sCustomerID + 1) to sCustomerID
73155>>>>>>>>>>>>>>>>>///
73155>>>>>>>>>>>>>>>>>/// REEXEC_ORACLE_STORED_PROCEDURE "user.getCustomerStatus" passing sCustomerID sStatus
73155>>>>>>>>>>>>>>>>>/// Showln sStatus
73155>>>>>>>>>>>>>>>>>
73155>>>>>>>>>>>>>>>>>
73155>>>>>>>>>>>>>>>>>//=============================================================================
73155>>>>>>>>>>>>>>>>>/// @Name        CALL_STORED_FUNCTION
73155>>>>>>>>>>>>>>>>>/// @Description This command is used to execute a function stored in the
73155>>>>>>>>>>>>>>>>>/// SQL backend. This is an alternative to building a function with the
73155>>>>>>>>>>>>>>>>>/// SQL_SET_FUNCTION_NAME, SQL_SET_FUNCTION_PARAMETER and SQL_FUNCTION_EXECUTE
73155>>>>>>>>>>>>>>>>>/// commands. This command builds and executes the function by setting the full
73155>>>>>>>>>>>>>>>>>/// function name, the parameter(s) to pass and the variable to hold the
73155>>>>>>>>>>>>>>>>>/// returned value. Note that this command can only return a single value
73155>>>>>>>>>>>>>>>>>/// so SQL_SET_FUNCTION_PARAMETER and SQL_SET_FUNCTION_NAME must be used when
73155>>>>>>>>>>>>>>>>>/// dealing with multiple return values.
73155>>>>>>>>>>>>>>>>>///
73155>>>>>>>>>>>>>>>>>/// Assumptions
73155>>>>>>>>>>>>>>>>>/// @Status      Public
73155>>>>>>>>>>>>>>>>>/// @Drivers     ORAFLex MySQLFlex PgFlex
73155>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
73155>>>>>>>>>>>>>>>>>/// @See
73155>>>>>>>>>>>>>>>>>///
73155>>>>>>>>>>>>>>>>>/// @Syntax CALL_STORED_FUNCTION {function} Returns {variable} Passing {parameters}
73155>>>>>>>>>>>>>>>>>/// @Param function                     Full name of the function
73155>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the returned value
73155>>>>>>>>>>>>>>>>>/// @Param parameters           Parameter to pass to the function (can be multiple)
73155>>>>>>>>>>>>>>>>>///
73155>>>>>>>>>>>>>>>>>/// @Example
73155>>>>>>>>>>>>>>>>>/// Move 5 to sCustomerID
73155>>>>>>>>>>>>>>>>>/// CALL_STORED_FUNCTION "getCustomerStatus" Returns sStatus Passing sCustomerID
73155>>>>>>>>>>>>>>>>>/// Showln sStatus
73155>>>>>>>>>>>>>>>>>
73155>>>>>>>>>>>>>>>>>//=============================================================================
73155>>>>>>>>>>>>>>>>>/// @Name        OUTPUT_INT_FILE
73155>>>>>>>>>>>>>>>>>/// @Description This command is used to output the int file of an opened
73155>>>>>>>>>>>>>>>>>/// table. If the file to be output to does not exist, it will be created
73155>>>>>>>>>>>>>>>>>/// upon execution of this command. Note that the INT file can be output
73155>>>>>>>>>>>>>>>>>/// into multiple types of files i.e. .doc, .txt, .int.
73155>>>>>>>>>>>>>>>>>///
73155>>>>>>>>>>>>>>>>>/// @Assumptions
73155>>>>>>>>>>>>>>>>>/// @Status      Public
73155>>>>>>>>>>>>>>>>>/// @Drivers     All
73155>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
73155>>>>>>>>>>>>>>>>>/// @See
73155>>>>>>>>>>>>>>>>>///
73155>>>>>>>>>>>>>>>>>/// @Syntax OUTPUT_INT_FILE for {FileNumber} to {variable}
73155>>>>>>>>>>>>>>>>>/// @Param FileNumber           The file number
73155>>>>>>>>>>>>>>>>>/// @Param variable                     Path of the file being output to
73155>>>>>>>>>>>>>>>>>///
73155>>>>>>>>>>>>>>>>>///@Example
73155>>>>>>>>>>>>>>>>>/// OUTPUT_INT_FILE for Customer.File_Number to "C:\Temp\Customer.int"
73155>>>>>>>>>>>>>>>>>
73155>>>>>>>>>>>>>>>>>//=============================================================================
73155>>>>>>>>>>>>>>>>>/// @Name        SQL_ERROR_MESSAGE
73155>>>>>>>>>>>>>>>>>/// @Description This command is used to get an error message
73155>>>>>>>>>>>>>>>>>/// from a given SQL statement. If the given statement is executed with
73155>>>>>>>>>>>>>>>>>/// no errors, the variable specified with this command will be blank.
73155>>>>>>>>>>>>>>>>>/// Otherwise the message will be stored in the given variable. Note that
73155>>>>>>>>>>>>>>>>>/// unless specified, strings have a size limit of 80 characters, so using
73155>>>>>>>>>>>>>>>>>/// a variant can ensure the full message is retrieved.
73155>>>>>>>>>>>>>>>>>///
73155>>>>>>>>>>>>>>>>>/// @Assumptions
73155>>>>>>>>>>>>>>>>>/// @Status      Public
73155>>>>>>>>>>>>>>>>>/// @Drivers     All
73155>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
73155>>>>>>>>>>>>>>>>>/// @See         SQL_ERROR_MESSAGE2
73155>>>>>>>>>>>>>>>>>///
73155>>>>>>>>>>>>>>>>>/// @Syntax SQL_ERROR_MESSAGE {variable}
73155>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the error message
73155>>>>>>>>>>>>>>>>>///
73155>>>>>>>>>>>>>>>>>/// @Example
73155>>>>>>>>>>>>>>>>>/// SQL_ERROR_MESSAGE sError
73155>>>>>>>>>>>>>>>>>
73155>>>>>>>>>>>>>>>>>Function MertechInc_SQL_ERROR_MESSAGE Global Returns String
73157>>>>>>>>>>>>>>>>>    String sMessage
73157>>>>>>>>>>>>>>>>>
73157>>>>>>>>>>>>>>>>>    Get MertechInc_Pre_Size_String 0 to sMessage
73158>>>>>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_SQL_ERROR_MESSAGE CALLBACK 0 PASSING MertechInc_Blank sMessage 0 RESULT MertechInc_iRet
73163>>>>>>>>>>>>>>>>>
73163>>>>>>>>>>>>>>>>>    Function_Return sMessage
73164>>>>>>>>>>>>>>>>>End_Function
73165>>>>>>>>>>>>>>>>>
73165>>>>>>>>>>>>>>>>>//=============================================================================
73165>>>>>>>>>>>>>>>>>/// @Name        SQL_ERROR_MESSAGE2
73165>>>>>>>>>>>>>>>>>/// @Description This command is used to get the last error message used
73165>>>>>>>>>>>>>>>>>/// for the specified server. This can be useful once a transaction has
73165>>>>>>>>>>>>>>>>>/// already been completed and any error messages need to be retrieved.
73165>>>>>>>>>>>>>>>>>///
73165>>>>>>>>>>>>>>>>>/// @Assumptions
73165>>>>>>>>>>>>>>>>>/// @Status      Public
73165>>>>>>>>>>>>>>>>>/// @Drivers     All
73165>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
73165>>>>>>>>>>>>>>>>>/// @See         SQL_ERROR_MESSAGE SQL_ERROR_MESSAGE2
73165>>>>>>>>>>>>>>>>>///
73165>>>>>>>>>>>>>>>>>/// @Syntax SQL_ERROR_MESSAGE2 of {server} to {variable}
73165>>>>>>>>>>>>>>>>>/// @Param server                       Name of the server
73165>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the error message
73165>>>>>>>>>>>>>>>>>///
73165>>>>>>>>>>>>>>>>>/// @Example
73165>>>>>>>>>>>>>>>>>/// SQL_ERROR_MESSAGE2 of "localhost" to sError
73165>>>>>>>>>>>>>>>>>
73165>>>>>>>>>>>>>>>>>Function MertechInc_SQL_ERROR_MESSAGE2 Global String sServer Returns String
73167>>>>>>>>>>>>>>>>>    String sMessage
73167>>>>>>>>>>>>>>>>>
73167>>>>>>>>>>>>>>>>>    Get MertechInc_Pre_Size_String 800 to sMessage
73168>>>>>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_SQL_ERROR_MESSAGE2 CALLBACK 0 PASSING sServer sMessage 0 RESULT MertechInc_iRet
73173>>>>>>>>>>>>>>>>>
73173>>>>>>>>>>>>>>>>>    Function_Return sMessage
73174>>>>>>>>>>>>>>>>>End_Function
73175>>>>>>>>>>>>>>>>>
73175>>>>>>>>>>>>>>>>>//=============================================================================
73175>>>>>>>>>>>>>>>>>/// @Name        MERTECH_WARNING_MESSAGE
73175>>>>>>>>>>>>>>>>>/// @Description When restructuring a table, i.e. Structure_Start, a warning
73175>>>>>>>>>>>>>>>>>/// message will appear to confirm the restructure before it is executed.
73175>>>>>>>>>>>>>>>>>/// This command is used to disable or enable that warning message. All that
73175>>>>>>>>>>>>>>>>>/// is passed is either the constant "Enabled" or "Disabled". By default,
73175>>>>>>>>>>>>>>>>>/// this message is enabled.
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Assumptions
73175>>>>>>>>>>>>>>>>>/// @Status      Public
73175>>>>>>>>>>>>>>>>>/// @Drivers     All
73175>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Syntax MERTECH_WARNING_MESSAGE {Enabled|Disabled}
73175>>>>>>>>>>>>>>>>>/// @Param Enabled                      Enables the restructure warning
73175>>>>>>>>>>>>>>>>>/// @Param Disabled                     Disables the restructure warning
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Example
73175>>>>>>>>>>>>>>>>>/// Move Customer.File_Number to hFile
73175>>>>>>>>>>>>>>>>>/// MERTECH_WARNING_MESSAGE Disabled
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// Structure_Start hFile
73175>>>>>>>>>>>>>>>>>///     Set_Attribute DF_FILE_OEM_TRANSLATION of hFile to True
73175>>>>>>>>>>>>>>>>>/// Structure_End hFile
73175>>>>>>>>>>>>>>>>>
73175>>>>>>>>>>>>>>>>>//=============================================================================
73175>>>>>>>>>>>>>>>>>/// @Name        DISABLE_SELECT_COLUMNS_ERRORS
73175>>>>>>>>>>>>>>>>>/// @Description When using SELECT_COLUMNS_FIND to limit the number of columns
73175>>>>>>>>>>>>>>>>>/// to fetch, the framework might still ask for columns that you do not need.
73175>>>>>>>>>>>>>>>>>/// As a result you'll end up getting runtime errors you do not want to see.
73175>>>>>>>>>>>>>>>>>/// This command gives you the ability to stop reporting errors for querying
73175>>>>>>>>>>>>>>>>>/// for data from columns that are not part of the query.
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// DISABLED_SELECT_COLUMNS_ERRORS DISABLED will disable the errors, use
73175>>>>>>>>>>>>>>>>>/// ENABLED to turn the error messages back on.
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// By default triggering error messages on unknown columns is ENABLED
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Assumptions
73175>>>>>>>>>>>>>>>>>/// @Status      Public
73175>>>>>>>>>>>>>>>>>/// @Drivers     All
73175>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2014-04-28 by Wil van Antwerpen
73175>>>>>>>>>>>>>>>>>/// @See         SELECT_COLUMNS_FIND RESET_FETCH_FIELDS
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Example
73175>>>>>>>>>>>>>>>>>/// Open Customer
73175>>>>>>>>>>>>>>>>>/// RESET_FETCH_FIELDS  CUSTOMER DF_FETCH_FALSE
73175>>>>>>>>>>>>>>>>>/// SELECT_COLUMNS_FIND CUSTOMER CUSTOMER_NUMBER NAME
73175>>>>>>>>>>>>>>>>>/// DISABLE_SELECT_COLUMNS_ERRORS DISABLED
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// Clear Customer
73175>>>>>>>>>>>>>>>>>/// Repeat
73175>>>>>>>>>>>>>>>>>///    Find Gt Customer by Index.1
73175>>>>>>>>>>>>>>>>>///    If (Found) Showln Customer.Customer_Number '-' Customer.Name
73175>>>>>>>>>>>>>>>>>/// Until (Not(Found))
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// RESET_FETCH_FIELDS Customer DF_FETCH_TRUE
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Syntax DISABLE_SELECT_COLUMNS_ERRORS {ENABLED|DISABLED}
73175>>>>>>>>>>>>>>>>>
73175>>>>>>>>>>>>>>>>>//=============================================================================
73175>>>>>>>>>>>>>>>>>/// @Name        SQLFlex_REVISION
73175>>>>>>>>>>>>>>>>>/// @Description This command will put the current version (decimals included)
73175>>>>>>>>>>>>>>>>>/// of the MSSQL driver associated with the current workspace into the
73175>>>>>>>>>>>>>>>>>/// specified variable.
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Assumptions
73175>>>>>>>>>>>>>>>>>/// @Status      Deprecated
73175>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex
73175>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
73175>>>>>>>>>>>>>>>>>/// @See                 GET_DRIVER_REVISION
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Syntax SQLFlex_REVISION {variable}
73175>>>>>>>>>>>>>>>>>/// @Param variable                     String variable to hold the returned version
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Example
73175>>>>>>>>>>>>>>>>>/// SQLFlex_REVISION sVersion
73175>>>>>>>>>>>>>>>>>
73175>>>>>>>>>>>>>>>>>//=============================================================================
73175>>>>>>>>>>>>>>>>>/// @Name        SQLFlex_MAJOR_REVISION
73175>>>>>>>>>>>>>>>>>/// @Description This command will put the major version (no decimals) of
73175>>>>>>>>>>>>>>>>>/// the the MSSQL driver associated with the current workspace into the
73175>>>>>>>>>>>>>>>>>/// specified variable.
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Assumptions
73175>>>>>>>>>>>>>>>>>/// @Status      Deprecated
73175>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex
73175>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
73175>>>>>>>>>>>>>>>>>/// @See                 GET_DRIVER_MAJOR_REVISION
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Syntax SQLFlex_MAJOR_REVISION {variable}
73175>>>>>>>>>>>>>>>>>/// @Param variable                     String variable to hold the returned version
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Example
73175>>>>>>>>>>>>>>>>>/// SQLFlex_MAJOR_REVISION sVersion
73175>>>>>>>>>>>>>>>>>
73175>>>>>>>>>>>>>>>>>//=============================================================================
73175>>>>>>>>>>>>>>>>>/// @Name        LOGGED_USERS
73175>>>>>>>>>>>>>>>>>/// @Description This command returns the number of native users that are
73175>>>>>>>>>>>>>>>>>/// using the driver currently. This number is stored in the variable that
73175>>>>>>>>>>>>>>>>>/// is passed with the command.
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Assumptions
73175>>>>>>>>>>>>>>>>>/// @Status      Public
73175>>>>>>>>>>>>>>>>>/// @Drivers     All
73175>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
73175>>>>>>>>>>>>>>>>>/// @See                 MAXIMUM_NUMBER_OF_USERS
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Syntax LOGGED_USERS {variable}
73175>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the number of users
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Example LOGGED_USERS sUsers
73175>>>>>>>>>>>>>>>>>
73175>>>>>>>>>>>>>>>>>//=============================================================================
73175>>>>>>>>>>>>>>>>>/// @Name        MAXIMUM_NUMBER_OF_USERS
73175>>>>>>>>>>>>>>>>>/// @Description This command returns the maximum number of user allowed by
73175>>>>>>>>>>>>>>>>>/// the current license.
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Assumptions
73175>>>>>>>>>>>>>>>>>/// @Status      Public
73175>>>>>>>>>>>>>>>>>/// @Drivers     All
73175>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
73175>>>>>>>>>>>>>>>>>/// @See                 LOGGED_USERS
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Syntax MAXIMUM_NUMBER_OF_USERS {variable}
73175>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the maximum number of users
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Example
73175>>>>>>>>>>>>>>>>>/// MAXIMUM_NUMBER_OF_USERS sMax
73175>>>>>>>>>>>>>>>>>
73175>>>>>>>>>>>>>>>>> //=============================================================================
73175>>>>>>>>>>>>>>>>>/// @Name        MAXIMUM_NUMBER_OF_SESSIONS
73175>>>>>>>>>>>>>>>>>/// @Description This command returns the maximum number of sessions allowed by
73175>>>>>>>>>>>>>>>>>/// the current license.
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Assumptions
73175>>>>>>>>>>>>>>>>>/// @Status      Public
73175>>>>>>>>>>>>>>>>>/// @Drivers     All
73175>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2015-06-25 by Anton
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Syntax MAXIMUM_NUMBER_OF_SESSIONS {variable}
73175>>>>>>>>>>>>>>>>>/// @Param variable         Variable to hold the maximum number of sessions
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Example
73175>>>>>>>>>>>>>>>>>/// MAXIMUM_NUMBER_OF_SESSIONS sMax
73175>>>>>>>>>>>>>>>>>
73175>>>>>>>>>>>>>>>>>//=============================================================================
73175>>>>>>>>>>>>>>>>>/// @Name        SET_DATABASE_NAME
73175>>>>>>>>>>>>>>>>>/// @Description This command overrides the database set in the INT file
73175>>>>>>>>>>>>>>>>>/// under DATABASE_SPACE_NAME. Any opens or finds will use the database
73175>>>>>>>>>>>>>>>>>/// specified here. This can be used when the database is not stated in
73175>>>>>>>>>>>>>>>>>/// the INT file or if the database needs to be dynamically changed for
73175>>>>>>>>>>>>>>>>>/// a certain query. If the database is not specified with this command
73175>>>>>>>>>>>>>>>>>/// or in the INT file, then the default database for the server will be
73175>>>>>>>>>>>>>>>>>/// used. To set the database to be used for embedded SQL statements,
73175>>>>>>>>>>>>>>>>>/// use SQL_USE_DATABASE.
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Assumptions
73175>>>>>>>>>>>>>>>>>/// @Status      Public
73175>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex, MySQLFlex and PGFlex
73175>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
73175>>>>>>>>>>>>>>>>>/// @See                 GET_DATABASE_NAME SQL_USE_DATABASE
73175>>>>>>>>>>>>>>>>>/// @INTOPT              DATABASE_SPACE_NAME
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Syntax SET_DATABASE_NAME to {database}
73175>>>>>>>>>>>>>>>>>/// @Param database                     Name of the database
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Example
73175>>>>>>>>>>>>>>>>>/// Login "localhost" "user" "pas123" "sql_drv"
73175>>>>>>>>>>>>>>>>>/// SET_DATABASE_NAME to "TestDB"
73175>>>>>>>>>>>>>>>>>/// Open Customer
73175>>>>>>>>>>>>>>>>>
73175>>>>>>>>>>>>>>>>>//=============================================================================
73175>>>>>>>>>>>>>>>>>/// @Name        GET_DATABASE_NAME
73175>>>>>>>>>>>>>>>>>/// @Description This command is used to get the name of the database
73175>>>>>>>>>>>>>>>>>/// currently being used. The name of the database is returned into the
73175>>>>>>>>>>>>>>>>>/// specified string. Even though this command works either way, it is
73175>>>>>>>>>>>>>>>>>/// typically used when the INT file does not contain the DATABASE_SPACE_NAME.
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Assumptions
73175>>>>>>>>>>>>>>>>>/// @Status      Public
73175>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex, MySQLFlex and PgFlex
73175>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
73175>>>>>>>>>>>>>>>>>/// @See SET_DATABASE_NAME SQL_USE_DATABASE
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Syntax GET_DATABASE_NAME to {variable}
73175>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the database name
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Example
73175>>>>>>>>>>>>>>>>>/// GET_DATABASE_NAME to sDbName
73175>>>>>>>>>>>>>>>>>
73175>>>>>>>>>>>>>>>>>//=============================================================================
73175>>>>>>>>>>>>>>>>>/// @Name        GET_NAME_SPACE
73175>>>>>>>>>>>>>>>>>/// @Description This command returns the name space, or schema, being
73175>>>>>>>>>>>>>>>>>/// used with the current application.
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Assumptions
73175>>>>>>>>>>>>>>>>>/// @Status      Public
73175>>>>>>>>>>>>>>>>>/// @Drivers     PgFlex
73175>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
73175>>>>>>>>>>>>>>>>>/// @See                 SET_NAME_SPACE
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Syntax GET_NAME_SPACE to {variable}
73175>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the returned name space.
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Example
73175>>>>>>>>>>>>>>>>>/// GET_NAME_SPACE to sNameSpace
73175>>>>>>>>>>>>>>>>>
73175>>>>>>>>>>>>>>>>>//=============================================================================
73175>>>>>>>>>>>>>>>>>/// @Name        SET_NAME_SPACE
73175>>>>>>>>>>>>>>>>>/// @Description This command sets the name space, or schema, to be used
73175>>>>>>>>>>>>>>>>>/// for the application. In Postgres, schemas are objects where all the
73175>>>>>>>>>>>>>>>>>/// tables,views and indexes are stored. Separate schemas are used to
73175>>>>>>>>>>>>>>>>>/// specify relational data. Note that this command will override the
73175>>>>>>>>>>>>>>>>>/// NAME_SPACE value in the INT file.
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Assumptions
73175>>>>>>>>>>>>>>>>>/// @Status      Public
73175>>>>>>>>>>>>>>>>>/// @Drivers     PgFlex
73175>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-14 By Ian Smith
73175>>>>>>>>>>>>>>>>>/// @See                 GET_NAME_SPACE
73175>>>>>>>>>>>>>>>>>/// @INTOPT              NAME_SPACE
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Syntax SET_NAME_SPACE to {variable}
73175>>>>>>>>>>>>>>>>>/// @Param variable                     Name of the name space
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Example
73175>>>>>>>>>>>>>>>>>/// SET_NAME_SPACE to "public"
73175>>>>>>>>>>>>>>>>>
73175>>>>>>>>>>>>>>>>>//=============================================================================
73175>>>>>>>>>>>>>>>>>/// @Name        SQL_USE_DATABASE
73175>>>>>>>>>>>>>>>>>/// @Description This command is used to specify which database is used
73175>>>>>>>>>>>>>>>>>/// for SQL statements only. Any normal table queries or changes will
73175>>>>>>>>>>>>>>>>>/// still use the default database, this only effects SQL statements.
73175>>>>>>>>>>>>>>>>>/// If none is specified then the default database is used. This can
73175>>>>>>>>>>>>>>>>>/// be useful if a certain SQL statement needs to query data from a
73175>>>>>>>>>>>>>>>>>/// database not currently being used. Note that this only works if
73175>>>>>>>>>>>>>>>>>/// the table name is not fully qualified in the SQl statement, i.e.
73175>>>>>>>>>>>>>>>>>/// "TestDB.Customer".
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Assumptions
73175>>>>>>>>>>>>>>>>>/// @Status      Public
73175>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex MySQLFLex PgSQL
73175>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
73175>>>>>>>>>>>>>>>>>/// @See                 SET_DATABASE_NAME GET_DATABASE_NAME
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Syntax SQL_USE_DATABASE of {server} to {database}
73175>>>>>>>>>>>>>>>>>/// @Param server                       Name of the server (Postgre only)
73175>>>>>>>>>>>>>>>>>/// @Param database                     Name of the database
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Example
73175>>>>>>>>>>>>>>>>>/// SQL_USE_DATABASE "testDB"
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
73175>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT
73175>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
73175>>>>>>>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sID sFirstName sLastName
73175>>>>>>>>>>>>>>>>>/// If (Found) Begin
73175>>>>>>>>>>>>>>>>>///     Showln sFirstName
73175>>>>>>>>>>>>>>>>>///     Showln sLastName
73175>>>>>>>>>>>>>>>>>/// End
73175>>>>>>>>>>>>>>>>>/// SQL_CANCEL_QUERY_STMT
73175>>>>>>>>>>>>>>>>>
73175>>>>>>>>>>>>>>>>>//=============================================================================
73175>>>>>>>>>>>>>>>>>/// @Name        SET_CURRENT_SQL_SERVER
73175>>>>>>>>>>>>>>>>>/// @Description This command is used to set the server to be used when
73175>>>>>>>>>>>>>>>>>/// opening tables. It will override the SERVER_NAME token in the INT file.
73175>>>>>>>>>>>>>>>>>/// If the server is not specified in the INT file or with this command,
73175>>>>>>>>>>>>>>>>>/// then the server used during login will be used. This command is only
73175>>>>>>>>>>>>>>>>>/// needed when connecting to multiple SQL servers. To set the server to
73175>>>>>>>>>>>>>>>>>/// use for embedded SQL statements, use SET_CURRENT_SQL_SERVER_CONNECTION.
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Assumptions
73175>>>>>>>>>>>>>>>>>/// @Status      Public
73175>>>>>>>>>>>>>>>>>/// @Drivers     All
73175>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
73175>>>>>>>>>>>>>>>>>/// @See                 GET_CURRENT_SQL_SERVER  SET_CURRENT_SQL_SERVER_CONNECTION GET_CURRENT_SQL_SERVER_CONNECTION
73175>>>>>>>>>>>>>>>>>/// @INTOPT              SERVER_NAME
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Syntax SET_CURRENT_SQL_SERVER to {server}
73175>>>>>>>>>>>>>>>>>/// @Param server                       Name of the server
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Example
73175>>>>>>>>>>>>>>>>>/// SET_CURRENT_SQL_SERVER to "localhost"
73175>>>>>>>>>>>>>>>>>
73175>>>>>>>>>>>>>>>>>//IGS - removed. CURRENT_SERVER is a property of Validation_List_Mixin so this
73175>>>>>>>>>>>>>>>>>//               replace conflicts with the property SET message.
73175>>>>>>>>>>>>>>>>>//#Replace SET_CURRENT_SERVER SET_CURRENT_SQL_SERVER
73175>>>>>>>>>>>>>>>>>
73175>>>>>>>>>>>>>>>>>//=============================================================================
73175>>>>>>>>>>>>>>>>>/// @Name        GET_CURRENT_SQL_SERVER
73175>>>>>>>>>>>>>>>>>/// @Description This command returns the name of the server to be used
73175>>>>>>>>>>>>>>>>>/// for opening and querying tables.
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Assumptions
73175>>>>>>>>>>>>>>>>>/// @Status      Public
73175>>>>>>>>>>>>>>>>>/// @Drivers     All
73175>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
73175>>>>>>>>>>>>>>>>>/// @See SET_CURRENT_SQL_SERVER SET_CURRENT_SQL_SERVER_CONNECTION GET_CURRENT_SQL_SERVER_CONNECTION
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Syntax GET_CURRENT_SERVER to {variable}
73175>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the server name
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Example
73175>>>>>>>>>>>>>>>>>/// GET_CURRENT_SQL_SERVER to sServer
73175>>>>>>>>>>>>>>>>>
73175>>>>>>>>>>>>>>>>>//IGS - removed. CURRENT_SERVER is a property of Validation_List_Mixin so this
73175>>>>>>>>>>>>>>>>>//               replace conflicts with the property GET message.
73175>>>>>>>>>>>>>>>>>//#Replace GET_CURRENT_SERVER GET_CURRENT_SQL_SERVER
73175>>>>>>>>>>>>>>>>>
73175>>>>>>>>>>>>>>>>>//=============================================================================
73175>>>>>>>>>>>>>>>>>/// @Name        SET_CURRENT_SQL_SERVER_CONNECTION
73175>>>>>>>>>>>>>>>>>/// @Description This command is used to specify which server to use for
73175>>>>>>>>>>>>>>>>>/// embedded SQL statements. By default, the last logged in server will
73175>>>>>>>>>>>>>>>>>/// be used. Note that in addition to setting the server, this command
73175>>>>>>>>>>>>>>>>>/// also sets the driver to be used. This command is only needed when
73175>>>>>>>>>>>>>>>>>/// connecting to multiple servers. To set the server for opening tables,
73175>>>>>>>>>>>>>>>>>/// use SET_CURRENT_SQL_SERVER.
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Assumptions
73175>>>>>>>>>>>>>>>>>/// @Status      Public
73175>>>>>>>>>>>>>>>>>/// @Drivers     All
73175>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
73175>>>>>>>>>>>>>>>>>/// @See                 GET_CURRENT_SQL_SERVER_CONNECTION GET_CURRENT_SQL_SERVER SET_CURRENT_SQL_SERVER
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Syntax SET_CURRENT_SQL_SERVER_CONNECTION of {constant} to {server}
73175>>>>>>>>>>>>>>>>>/// @Param constant                     MYSQLFLEX, ORAFLEX, PGFLEX, or SQLFLEX
73175>>>>>>>>>>>>>>>>>/// @Param server               Name of the server
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Example
73175>>>>>>>>>>>>>>>>>/// SET_CURRENT_SQL_SERVER_CONNECTION of SQLFLEX to "(localdb)\v11.0"
73175>>>>>>>>>>>>>>>>>
73175>>>>>>>>>>>>>>>>>//=============================================================================
73175>>>>>>>>>>>>>>>>>/// @Name        GET_CURRENT_SQL_SERVER_CONNECTION
73175>>>>>>>>>>>>>>>>>/// @Description This command returns the server currently being used for
73175>>>>>>>>>>>>>>>>>/// embedded SQL statements.
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Assumptions
73175>>>>>>>>>>>>>>>>>/// @Status      Public
73175>>>>>>>>>>>>>>>>>/// @Drivers     All
73175>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
73175>>>>>>>>>>>>>>>>>/// @See                 SET_CURRENT_SQL_SERVER_CONNECTION GET_CURRENT_SQL_SERVER SET_CURRENT_SQL_SERVER
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Syntax GET_CURRENT_SQL_SERVER_CONNECTION of {constant} to {variable}
73175>>>>>>>>>>>>>>>>>/// @Param constant                     MYSQLFLEX, ORAFLEX, PGFLEX, or SQLFLEX
73175>>>>>>>>>>>>>>>>>/// @Param variable             Variable to hold the name of the server
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Example
73175>>>>>>>>>>>>>>>>>/// GET_CURRENT_SQL_SERVER_CONNECTION of SQLFLEX to sServer
73175>>>>>>>>>>>>>>>>>
73175>>>>>>>>>>>>>>>>>//=============================================================================
73175>>>>>>>>>>>>>>>>>/// @Name        LOGIN_SQLFLEX
73175>>>>>>>>>>>>>>>>>/// @Description This command allows the user to login with a specified
73175>>>>>>>>>>>>>>>>>/// hostname. The default hostname that is passed is the path of the
73175>>>>>>>>>>>>>>>>>/// executable. Passing a custom hostname can be very useful for tracking
73175>>>>>>>>>>>>>>>>>/// a specific user for different situations. For example, if a company
73175>>>>>>>>>>>>>>>>>/// is using a terminal server and a whole sales team logs in under the
73175>>>>>>>>>>>>>>>>>/// same username and hostname, locating a specific user could otherwise
73175>>>>>>>>>>>>>>>>>/// be difficult. With this command, each user can pass a custom hostname,
73175>>>>>>>>>>>>>>>>>/// easily distinguishing themselves from other users.
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Assumptions
73175>>>>>>>>>>>>>>>>>/// @Status      Public
73175>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex
73175>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
73175>>>>>>>>>>>>>>>>>/// @See
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Syntax LOGIN_SQLFLEX {server} {username} {password} {hostname}
73175>>>>>>>>>>>>>>>>>/// @Param server               Server to use for login
73175>>>>>>>>>>>>>>>>>/// @Param username     Username to use for login
73175>>>>>>>>>>>>>>>>>/// @Param password     Password to use for login
73175>>>>>>>>>>>>>>>>>/// @Param hostname     Hostname to use for login
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Example
73175>>>>>>>>>>>>>>>>>/// LOGIN_SQLFLEX "localhost" "guestUser" "pas123" "WIN-MM7PQS5CP6C"
73175>>>>>>>>>>>>>>>>>
73175>>>>>>>>>>>>>>>>>//=============================================================================
73175>>>>>>>>>>>>>>>>>/// @Name        SQL_CANCEL_QUERY_STMT
73175>>>>>>>>>>>>>>>>>/// @Description This command is used to close any open cursors related to
73175>>>>>>>>>>>>>>>>>/// an SQL_EXECUTE_STMT. This should be used once the SQL statement has
73175>>>>>>>>>>>>>>>>>/// been executed and all rows have been fetched.
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Assumptions
73175>>>>>>>>>>>>>>>>>/// @Status      Public
73175>>>>>>>>>>>>>>>>>/// @Drivers     All
73175>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-03 by Aaron Gulack
73175>>>>>>>>>>>>>>>>>/// @See                 SQL_SET_STMT SQL_EXECUTE_STMT SQL_FETCH_NEXT_ROW SQL_APPEND_STMT SQL_PREPARE_STMT
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Syntax SQL_CANCEL_QUERY_STMT [of {FileName}]
73175>>>>>>>>>>>>>>>>>/// @Param FileName             Name of the file (optional)
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Example
73175>>>>>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
73175>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT
73175>>>>>>>>>>>>>>>>>/// SQL_BINDCOLUMNS_STMT of Customer to DF_BIND_ALL_COLUMNS
73175>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT of Customer
73175>>>>>>>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW of Customer
73175>>>>>>>>>>>>>>>>>/// If (Found) Begin
73175>>>>>>>>>>>>>>>>>///     Showln Customer.FirstName
73175>>>>>>>>>>>>>>>>>///     Showln Customer.LastName
73175>>>>>>>>>>>>>>>>>/// End
73175>>>>>>>>>>>>>>>>>/// SQL_CANCEL_QUERY_STMT of Customer
73175>>>>>>>>>>>>>>>>>
73175>>>>>>>>>>>>>>>>>//=============================================================================
73175>>>>>>>>>>>>>>>>>/// @Name        NATIVE_OPTIMIZATION
73175>>>>>>>>>>>>>>>>>/// @Description Allows user to turn off the use of index hints on the native
73175>>>>>>>>>>>>>>>>>/// server. Setting this command to DEFAULT will cause the server to use the
73175>>>>>>>>>>>>>>>>>/// default settings for hints. Hints are off by default in Microsoft SQL
73175>>>>>>>>>>>>>>>>>/// Server but are on in Oracle. Care should be taken with changing the
73175>>>>>>>>>>>>>>>>>/// default, and should only be used if the diagnostics tool for your server
73175>>>>>>>>>>>>>>>>>/// indicates performance problems with the type of queries that are being
73175>>>>>>>>>>>>>>>>>/// generated. Note that this can be turned off or on for the whole server
73175>>>>>>>>>>>>>>>>>/// or just for a specific table.
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// DEFAULT             - The specified server's default settings
73175>>>>>>>>>>>>>>>>>/// USE_INDEXHINT       - All Index hints will be used
73175>>>>>>>>>>>>>>>>>/// NO_INDEXHINT        - No index hints will be used
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Assumptions
73175>>>>>>>>>>>>>>>>>/// @Status      Public
73175>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex, ORAFlex
73175>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
73175>>>>>>>>>>>>>>>>>/// @See
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Syntax NATIVE_OPTIMIZATION of {scopeLevel} {variable} to {constant}
73175>>>>>>>>>>>>>>>>>/// @Param scopeLevel           TABLE or SERVER. Indicates the scope of the setting
73175>>>>>>>>>>>>>>>>>/// @Param variable                     Either the name of the server or of the table
73175>>>>>>>>>>>>>>>>>/// @Param constant                     DEFAULT, USE_INDEXHINT, or NO_INDEXHINT
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Example
73175>>>>>>>>>>>>>>>>>/// NATIVE_OPTIMIZATION of SERVER "localhost" to USE_INDEXHINT
73175>>>>>>>>>>>>>>>>>
73175>>>>>>>>>>>>>>>>>//=============================================================================
73175>>>>>>>>>>>>>>>>>/// @Name        SET_ISOLATION_LEVEL
73175>>>>>>>>>>>>>>>>>/// @Description This command sets the locking and row versioning behavior
73175>>>>>>>>>>>>>>>>>/// for SQL statements. See the options below for information on the various
73175>>>>>>>>>>>>>>>>>/// effects they can have on transactions.
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// DEFAULT  - The default isolation level for the server (READ_COMMITTED
73175>>>>>>>>>>>>>>>>>/// for MSSQL).
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// READ_COMMITTED - This option is used to prevent dirty reads. A dirty
73175>>>>>>>>>>>>>>>>>/// read is when one transaction reads data from another transaction that
73175>>>>>>>>>>>>>>>>>/// has yet to be committed. If one transaction fails, the other now is
73175>>>>>>>>>>>>>>>>>/// dealing with invalid data. By setting the isolation level to
73175>>>>>>>>>>>>>>>>>/// READ_COMMITTED, dirty reads will be avoided by not allowing transactions
73175>>>>>>>>>>>>>>>>>/// to deal with any other data that has not been committed yet. However,
73175>>>>>>>>>>>>>>>>>/// in between statements within the current transaction, data can be changed
73175>>>>>>>>>>>>>>>>>/// by other transactions. This can result in phantom data or non-repeatable
73175>>>>>>>>>>>>>>>>>/// reads. Note that this can slow down performance speeds but is usually
73175>>>>>>>>>>>>>>>>>/// good practice.
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// READ_UNCOMMITTED - This option is the least restrictive isolation level.
73175>>>>>>>>>>>>>>>>>/// With this option, dirty reads are allowed, thus no exclusive locks are
73175>>>>>>>>>>>>>>>>>/// honored and modified data from one uncommitted transaction can be read
73175>>>>>>>>>>>>>>>>>/// by other transactions.
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// REPEATABLE_READ - This option is similar to the READ_COMMITTED option
73175>>>>>>>>>>>>>>>>>/// in that locks all placed on all transactions and uncommitted data from
73175>>>>>>>>>>>>>>>>>///     other transactions cannot be read, preventing dirty reads. However, unlike
73175>>>>>>>>>>>>>>>>>/// READ_COMMITTED, new rows that are added by other transactions can be read
73175>>>>>>>>>>>>>>>>>/// by the current transaction if it is retried, possibly resulting in phantom
73175>>>>>>>>>>>>>>>>>/// reads. This option should not be used unless there is a specific reason to
73175>>>>>>>>>>>>>>>>>/// do so.
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// SERIALIZABLE - This option is the most restrictive isolation level. With
73175>>>>>>>>>>>>>>>>>/// this option, no interaction is allowed between transactions until they
73175>>>>>>>>>>>>>>>>>/// have been committed. Similar to READ_COMMITTED, no transaction can deal
73175>>>>>>>>>>>>>>>>>/// with any uncommitted data. On top of that though, range locks are placed on
73175>>>>>>>>>>>>>>>>>/// all rows being modified until the current transaction is complete. Because
73175>>>>>>>>>>>>>>>>>/// concurrency is so low with this option, performance speeds can be much lower
73175>>>>>>>>>>>>>>>>>/// and so this should only be used when there is a specific reason to do so.
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Assumptions
73175>>>>>>>>>>>>>>>>>/// @Status      Public
73175>>>>>>>>>>>>>>>>>/// @Drivers     All
73175>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
73175>>>>>>>>>>>>>>>>>/// @See
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Syntax SET_ISOLATION_LEVEL of {server} to {constant}
73175>>>>>>>>>>>>>>>>>/// @Param server                       Name of the server
73175>>>>>>>>>>>>>>>>>/// @Param constant                     DEFAULT, READ_COMMITTED, READ_UNCOMMITTED, REPEATABLE_READ, or SERIALIZABLE
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Example
73175>>>>>>>>>>>>>>>>>/// LOGIN "localhost" "user" "pass123" "SQL_DRV"
73175>>>>>>>>>>>>>>>>>/// SET_ISOLATION_LEVEL of "localhost" to READ_COMMITTED
73175>>>>>>>>>>>>>>>>>
73175>>>>>>>>>>>>>>>>>//=============================================================================
73175>>>>>>>>>>>>>>>>>/// @Name        SET_SESSION_PARAMETER
73175>>>>>>>>>>>>>>>>>/// @Description There are two sets of code pages used in windows, ANSI and
73175>>>>>>>>>>>>>>>>>/// OEM. ANSI is what is commonly used now, but some data still uses the OEM
73175>>>>>>>>>>>>>>>>>/// code pages. When migrating data, this command is used to determine whether
73175>>>>>>>>>>>>>>>>>/// the OEM data will be translated to ANSI during the migration. For example,
73175>>>>>>>>>>>>>>>>>/// migrating passwords with special characters may call for different code
73175>>>>>>>>>>>>>>>>>/// pages. Sending true will convert the OEM data to ANSI, sending false will
73175>>>>>>>>>>>>>>>>>/// not. Both OEM_TO_ANSI and OEM_TRANSLATION_STATE do essentially the same
73175>>>>>>>>>>>>>>>>>/// thing, however since MSSQL has the functionality built in, OEM_TO_ANSI
73175>>>>>>>>>>>>>>>>>/// will use MSSQL's built in translation and thus only works with SQLFlex.
73175>>>>>>>>>>>>>>>>>/// OEM_TRANSLATION_STATE is internal and built into the driver so it works
73175>>>>>>>>>>>>>>>>>/// for all drivers. Note that if using custom entries with
73175>>>>>>>>>>>>>>>>>/// SET_CUSTOM_OEM_TO_ANSI then OEM_TRANSLATION_STATE must be used. Also, if
73175>>>>>>>>>>>>>>>>>/// there are already custom entries set then turning OEM_TRANSLATION_STATE
73175>>>>>>>>>>>>>>>>>/// on will automatically enable those custom translations.
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Assumptions
73175>>>>>>>>>>>>>>>>>/// @Status      Public
73175>>>>>>>>>>>>>>>>>/// @Drivers     All
73175>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
73175>>>>>>>>>>>>>>>>>/// @See                 SET_CUSTOM_OEM_TO_ANSI GET_CUSTOM_OEM_TO_ANSI
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Syntax SET_SESSION_PARAMETER {OEM_TO_ANSI/OEM_TRANSLATION_STATE} to {variable}
73175>>>>>>>>>>>>>>>>>/// @Param variable                     Boolean variable enabling or disabling translation
73175>>>>>>>>>>>>>>>>>///
73175>>>>>>>>>>>>>>>>>/// @Example
73175>>>>>>>>>>>>>>>>>/// SET_SESSION_PARAMETER OEM_TO_ANSI to True
73175>>>>>>>>>>>>>>>>>
73175>>>>>>>>>>>>>>>>>Procedure MertechInc_SET_CUSTOM_OEM_TO_ANSI Global Integer iChar Integer iOem Integer iAnsi
73177>>>>>>>>>>>>>>>>>    Move iChar to MertechInc_sArg1
73178>>>>>>>>>>>>>>>>>    move (String(iOem) + "," + String(iAnsi)) to MertechInc_sArg2
73179>>>>>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_LICENSE_ENVIRONMENT_SET CALLBACK 0 PASSING MertechInc_sArg1 MertechInc_sArg2 CALLDRV_SET_CUSTOM_OEM_TO_ANSI RESULT MertechInc_iRet
73184>>>>>>>>>>>>>>>>>    IF MertechInc_iRet EQ -1 INDICATE ERR TRUE
73187>>>>>>>>>>>>>>>>>End_Procedure
73188>>>>>>>>>>>>>>>>>
73188>>>>>>>>>>>>>>>>>//=============================================================================
73188>>>>>>>>>>>>>>>>>/// @Name        SET_CUSTOM_OEM_TO_ANSI
73188>>>>>>>>>>>>>>>>>/// @Description In very rare situations, a custom OEM to ANSI translation
73188>>>>>>>>>>>>>>>>>/// is needed. When that is the case, this command can be used to create
73188>>>>>>>>>>>>>>>>>/// those custom entries. This is done by passing the character numbered
73188>>>>>>>>>>>>>>>>>/// position, the OEM value and the ANSI value. Note that
73188>>>>>>>>>>>>>>>>>/// OEM_TRANSLATION_STATE must be set to true for these custom entries to
73188>>>>>>>>>>>>>>>>>/// work.
73188>>>>>>>>>>>>>>>>>///
73188>>>>>>>>>>>>>>>>>/// @Assumptions
73188>>>>>>>>>>>>>>>>>/// @Status      Public
73188>>>>>>>>>>>>>>>>>/// @Drivers     All
73188>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
73188>>>>>>>>>>>>>>>>>/// @See                 GET_CUSTOM_OEM_TO_ANSI SET_SESSION_PARAMETER
73188>>>>>>>>>>>>>>>>>///
73188>>>>>>>>>>>>>>>>>/// @Syntax SET_CUSTOM_OEM_TO_ANSI {character} to OEM {value1} ANSI {value2}
73188>>>>>>>>>>>>>>>>>/// @Param character            Numbered position (0-255) of the character
73188>>>>>>>>>>>>>>>>>/// @Param value1                       Character number for the OEM value
73188>>>>>>>>>>>>>>>>>/// @Param value2                       Character number for the ANSI value
73188>>>>>>>>>>>>>>>>>
73188>>>>>>>>>>>>>>>>>Procedure MertechInc_GET_CUSTOM_OEM_TO_ANSI Global Integer iChar Integer iOem Integer iAnsi
73190>>>>>>>>>>>>>>>>>    Move iChar to MertechInc_sArg1
73191>>>>>>>>>>>>>>>>>    Move (Repeat(" ", 255)) to MertechInc_sArg2
73192>>>>>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_LICENSE_ENVIRONMENT_SET CALLBACK 0 PASSING MertechInc_sArg1 MertechInc_sArg2 CALLDRV_GET_CUSTOM_OEM_TO_ANSI RESULT MertechInc_iRet
73197>>>>>>>>>>>>>>>>>    IF MertechInc_iRet EQ -1 INDICATE ERR TRUE
73200>>>>>>>>>>>>>>>>>End_Function
73201>>>>>>>>>>>>>>>>>
73201>>>>>>>>>>>>>>>>>//=============================================================================
73201>>>>>>>>>>>>>>>>>/// @Name        GET_CUSTOM_OEM_TO_ANSI
73201>>>>>>>>>>>>>>>>>/// @Description This command returns the custom OEM and ANSI values
73201>>>>>>>>>>>>>>>>>/// respectively for a given character. If there is no custom translation
73201>>>>>>>>>>>>>>>>>/// for the specified character then no error will be raised, but nothing
73201>>>>>>>>>>>>>>>>>/// will be returned.
73201>>>>>>>>>>>>>>>>>///
73201>>>>>>>>>>>>>>>>>/// @Assumptions There exists a custom translation for the specified character
73201>>>>>>>>>>>>>>>>>/// @Status      Public
73201>>>>>>>>>>>>>>>>>/// @Drivers     All
73201>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
73201>>>>>>>>>>>>>>>>>/// @See
73201>>>>>>>>>>>>>>>>>///
73201>>>>>>>>>>>>>>>>>/// @Syntax SET_CUSTOM_OEM_TO_ANSI {character} to OEM {value1} ANSI {value2}
73201>>>>>>>>>>>>>>>>>/// @Param character            Numbered position (0-255) of the character
73201>>>>>>>>>>>>>>>>>/// @Param value1                       Variable to hold the OEM value
73201>>>>>>>>>>>>>>>>>/// @Param value2                       Variable to hold the ANSI value
73201>>>>>>>>>>>>>>>>>
73201>>>>>>>>>>>>>>>>>//=============================================================================
73201>>>>>>>>>>>>>>>>>/// @Name        SET_AUTOMATIC_NUMERIC_DATATYPE_REMAPPING
73201>>>>>>>>>>>>>>>>>/// @Description This command toggles off and on the automatic numeric
73201>>>>>>>>>>>>>>>>>/// data type remapping built into SQLFlex. When adding or creating
73201>>>>>>>>>>>>>>>>>/// smaller numeric columns during a restructure, SQLFlex will change
73201>>>>>>>>>>>>>>>>>/// the type to a more specific data type i.e. smallint or tinyint since
73201>>>>>>>>>>>>>>>>>/// they are handled more efficiently by the server. Sending false to this
73201>>>>>>>>>>>>>>>>>/// command will force SQl to keep the column as a numeric field, preserving
73201>>>>>>>>>>>>>>>>>/// the length and precision. Passing true will leave the remapping up to the
73201>>>>>>>>>>>>>>>>>/// driver.
73201>>>>>>>>>>>>>>>>>///
73201>>>>>>>>>>>>>>>>>/// @Assumptions
73201>>>>>>>>>>>>>>>>>/// @Status      Public
73201>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex
73201>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
73201>>>>>>>>>>>>>>>>>/// @See
73201>>>>>>>>>>>>>>>>>///
73201>>>>>>>>>>>>>>>>>/// @Syntax SET_AUTOMATIC_NUMERIC_DATATYPE_REMAPPING to {variable}
73201>>>>>>>>>>>>>>>>>/// @Param variable                     Boolean variable enabling or disabling remapping
73201>>>>>>>>>>>>>>>>>///
73201>>>>>>>>>>>>>>>>>/// @Example
73201>>>>>>>>>>>>>>>>>/// Structure_Start hFile
73201>>>>>>>>>>>>>>>>>///
73201>>>>>>>>>>>>>>>>>///     Create_Field hFile
73201>>>>>>>>>>>>>>>>>///
73201>>>>>>>>>>>>>>>>>///     SET_AUTOMATIC_NUMERIC_DATATYPE_REMAPPING to False
73201>>>>>>>>>>>>>>>>>///
73201>>>>>>>>>>>>>>>>>///     Set_Attribute DF_FIELD_NAME   of hFile iColumn to "Transaction_Count"
73201>>>>>>>>>>>>>>>>>///     Set_Attribute DF_FIELD_TYPE   of hFile iColumn to DF_BCD
73201>>>>>>>>>>>>>>>>>///     Set_Attribute DF_FIELD_LENGTH of hFile iColumn to 1
73201>>>>>>>>>>>>>>>>>///
73201>>>>>>>>>>>>>>>>>/// Structure_End hFile
73201>>>>>>>>>>>>>>>>>
73201>>>>>>>>>>>>>>>>>//=============================================================================
73201>>>>>>>>>>>>>>>>>/// @Name        SET_FORCE_DATE_FORMAT_INIT
73201>>>>>>>>>>>>>>>>>/// @Description At times, a stored procedure, function or trigger may
73201>>>>>>>>>>>>>>>>>/// alter the default format for dates. This could cause problems because,
73201>>>>>>>>>>>>>>>>>/// for example, if a trigger on a table does this, then every time a save
73201>>>>>>>>>>>>>>>>>/// takes place on that table, the format for dates will be changed. By
73201>>>>>>>>>>>>>>>>>/// sending true to this command, the date formats will reset to their
73201>>>>>>>>>>>>>>>>>/// default format. Note that this is essentially the same thing as running
73201>>>>>>>>>>>>>>>>>/// the SQL statement: "ALTER SESSION SET NLS_DATE_FORMAT='MM/DD/YYYY'", so
73201>>>>>>>>>>>>>>>>>/// in most situations, that should be used instead of this command.
73201>>>>>>>>>>>>>>>>>///
73201>>>>>>>>>>>>>>>>>/// @Assumptions
73201>>>>>>>>>>>>>>>>>/// @Status      Deprecated
73201>>>>>>>>>>>>>>>>>/// @Drivers     ORAFlex
73201>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
73201>>>>>>>>>>>>>>>>>/// @See
73201>>>>>>>>>>>>>>>>>///
73201>>>>>>>>>>>>>>>>>/// @Syntax SET_FORCE_DATE_FORMAT_INIT to {variable}
73201>>>>>>>>>>>>>>>>>/// @Param variable             Boolean variable enabling or disabling format reset
73201>>>>>>>>>>>>>>>>>
73201>>>>>>>>>>>>>>>>>//=============================================================================
73201>>>>>>>>>>>>>>>>>/// @Name        SET_STATIC_TABLE_OPTIMIZATION
73201>>>>>>>>>>>>>>>>>/// @Description At this time, this command no longer serves any function.
73201>>>>>>>>>>>>>>>>>///
73201>>>>>>>>>>>>>>>>>/// @Assumptions
73201>>>>>>>>>>>>>>>>>/// @Status      Deprecated
73201>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex
73201>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
73201>>>>>>>>>>>>>>>>>/// @See
73201>>>>>>>>>>>>>>>>>///
73201>>>>>>>>>>>>>>>>>/// @Syntax SET_STATIC_TABLE_OPTIMIZATION to {ENABLED/DISABLED}
73201>>>>>>>>>>>>>>>>>
73201>>>>>>>>>>>>>>>>>//=============================================================================
73201>>>>>>>>>>>>>>>>>/// @Name        GET_MAX_OBJECT_NAME_LENGTH
73201>>>>>>>>>>>>>>>>>/// @Description This command returns the maximum length allowed for object
73201>>>>>>>>>>>>>>>>>/// names in the SQl backend. This includes table names, column names,
73201>>>>>>>>>>>>>>>>>/// database names etc. The maximum length in put into the specified variable.
73201>>>>>>>>>>>>>>>>>///
73201>>>>>>>>>>>>>>>>>/// @Assumptions
73201>>>>>>>>>>>>>>>>>/// @Status      Public
73201>>>>>>>>>>>>>>>>>/// @Drivers     All
73201>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
73201>>>>>>>>>>>>>>>>>/// @See
73201>>>>>>>>>>>>>>>>>///
73201>>>>>>>>>>>>>>>>>/// @Syntax GET_MAX_OBJECT_NAME_LENGTH to {variable}
73201>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the maximum length
73201>>>>>>>>>>>>>>>>>///
73201>>>>>>>>>>>>>>>>>/// @Example
73201>>>>>>>>>>>>>>>>>/// GET_MAX_OBJECT_NAME_LENGTH to iMaxLength
73201>>>>>>>>>>>>>>>>>
73201>>>>>>>>>>>>>>>>>//=============================================================================
73201>>>>>>>>>>>>>>>>>/// @Name        SET_SQL_LOCK_TIMEOUT
73201>>>>>>>>>>>>>>>>>/// @Description This command is used to set the number of milliseconds
73201>>>>>>>>>>>>>>>>>/// an SQL statement waits for a database lock to be released before timing
73201>>>>>>>>>>>>>>>>>/// out. Locks are used with transactions to maintain atomicity. If a lock is
73201>>>>>>>>>>>>>>>>>/// not released before the timeout, then the statement will fail and an error
73201>>>>>>>>>>>>>>>>>/// will be raised. By default, the timeout is set to -1, indicating that
73201>>>>>>>>>>>>>>>>>/// statements will wait indefinitely before timing out.
73201>>>>>>>>>>>>>>>>>///
73201>>>>>>>>>>>>>>>>>/// @Assumptions
73201>>>>>>>>>>>>>>>>>/// @Status      Public
73201>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex
73201>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
73201>>>>>>>>>>>>>>>>>/// @See                 GET_SQL_LOCK_TIMEOUT
73201>>>>>>>>>>>>>>>>>///
73201>>>>>>>>>>>>>>>>>/// @Syntax SET_SQL_LOCAL_TIMEOUT of {server} to {variable}
73201>>>>>>>>>>>>>>>>>/// @Param server                       Name of the server
73201>>>>>>>>>>>>>>>>>/// @Param variable                     Number of milliseconds to wait until timeout
73201>>>>>>>>>>>>>>>>>///
73201>>>>>>>>>>>>>>>>>/// @Example
73201>>>>>>>>>>>>>>>>>/// SET_SQL_LOCK_TIMEOUT of "localhost" to 6000
73201>>>>>>>>>>>>>>>>>
73201>>>>>>>>>>>>>>>>>//=============================================================================
73201>>>>>>>>>>>>>>>>>/// @Name        GET_SQL_LOCK_TIMEOUT
73201>>>>>>>>>>>>>>>>>/// @Description This command returns the number of milliseconds an SQL
73201>>>>>>>>>>>>>>>>>/// statement will wait for a database lock to be released. If the lock
73201>>>>>>>>>>>>>>>>>/// is not released before the timeout, then the statement will fail and
73201>>>>>>>>>>>>>>>>>/// an error will be raised. Note that the default value is -1, indicating
73201>>>>>>>>>>>>>>>>>/// that the statement will wait indefinitely.
73201>>>>>>>>>>>>>>>>>///
73201>>>>>>>>>>>>>>>>>/// @Assumptions
73201>>>>>>>>>>>>>>>>>/// @Status      Public
73201>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex
73201>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
73201>>>>>>>>>>>>>>>>>/// @See                 SET_SQL_LOCK_TIMEOUT
73201>>>>>>>>>>>>>>>>>///
73201>>>>>>>>>>>>>>>>>/// @Syntax GET_SQL_LOCAL_TIMEOUT of {server} to {variable}
73201>>>>>>>>>>>>>>>>>/// @Param server                       Name of the server
73201>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the number of milliseconds
73201>>>>>>>>>>>>>>>>>///
73201>>>>>>>>>>>>>>>>>/// @Example
73201>>>>>>>>>>>>>>>>>/// GET_SQL_LOCK_TIMEOUT of "localhost" to iTimeout
73201>>>>>>>>>>>>>>>>>
73201>>>>>>>>>>>>>>>>>//=============================================================================
73201>>>>>>>>>>>>>>>>>/// @Name        DO_GET_SQLSERVER_PARAMETERS
73201>>>>>>>>>>>>>>>>>/// @Description Retrieves stored procedure parameter values.
73201>>>>>>>>>>>>>>>>>///
73201>>>>>>>>>>>>>>>>>/// @Assumptions
73201>>>>>>>>>>>>>>>>>/// @Status      Internal
73201>>>>>>>>>>>>>>>>>/// @Drivers     All
73201>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-18 By Ian Smith
73201>>>>>>>>>>>>>>>>>/// @See
73201>>>>>>>>>>>>>>>>>
73201>>>>>>>>>>>>>>>>>Function MertechInc_DO_GET_SQLSERVER_PARAMETERS Global Integer iParameter Returns String
73203>>>>>>>>>>>>>>>>>    String sValue
73203>>>>>>>>>>>>>>>>>
73203>>>>>>>>>>>>>>>>>    Get MertechInc_Pre_Size_String 0 to sValue //Need to check if Call_Driver needs pre sized strings. Until then assume it does
73204>>>>>>>>>>>>>>>>>    Call_Driver MertechInc_FileNumber MertechInc_DriverName Function 24 CALLBACK 0 PASSING sValue MertechInc_Blank iParameter RESULT MertechInc_iRet
73209>>>>>>>>>>>>>>>>>
73209>>>>>>>>>>>>>>>>>    Function_Return sValue
73210>>>>>>>>>>>>>>>>>End_Function
73211>>>>>>>>>>>>>>>>>
73211>>>>>>>>>>>>>>>>>//=============================================================================
73211>>>>>>>>>>>>>>>>>/// @Name        DO_BIND_SQLSERVER_PARAMETERS
73211>>>>>>>>>>>>>>>>>/// @Description Binds parameters for stored procedure call.
73211>>>>>>>>>>>>>>>>>///
73211>>>>>>>>>>>>>>>>>/// @Assumptions
73211>>>>>>>>>>>>>>>>>/// @Status      Internal
73211>>>>>>>>>>>>>>>>>/// @Drivers     All
73211>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-18 By Ian Smith
73211>>>>>>>>>>>>>>>>>/// @See
73211>>>>>>>>>>>>>>>>>
73211>>>>>>>>>>>>>>>>>Procedure MertechInc_DO_BIND_SQLSERVER_PARAMETERS Global String sDirection String sParameter Integer iSize
73213>>>>>>>>>>>>>>>>>    Call_Driver 0 SQLFLEX Function CALLDRV_BIND_PARAMETER CALLBACK 0 PASSING sDirection sParameter iSize RESULT MertechInc_iRet
73218>>>>>>>>>>>>>>>>>End_Procedure
73219>>>>>>>>>>>>>>>>>
73219>>>>>>>>>>>>>>>>>//=============================================================================
73219>>>>>>>>>>>>>>>>>/// @Name        DO_CHECK_BINDING
73219>>>>>>>>>>>>>>>>>/// @Description Sets MertechInc_bThereIsBinding True if any of the
73219>>>>>>>>>>>>>>>>>/// parameters is the keyword BINDING.
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Assumptions
73219>>>>>>>>>>>>>>>>>/// @Status      Internal
73219>>>>>>>>>>>>>>>>>/// @Drivers     All
73219>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-18 By Ian Smith
73219>>>>>>>>>>>>>>>>>/// @See
73219>>>>>>>>>>>>>>>>>
73219>>>>>>>>>>>>>>>>>//=============================================================================
73219>>>>>>>>>>>>>>>>>/// @Name        DO_FETCH_FIRST_ROW
73219>>>>>>>>>>>>>>>>>/// @Description Recursive - drops first parameter until the first parameter
73219>>>>>>>>>>>>>>>>>/// is BINDING and then calls SQL_FETCH_NEXT_ROW passing remaining parameters.
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Assumptions
73219>>>>>>>>>>>>>>>>>/// @Status      Internal
73219>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex
73219>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-18 By Ian Smith
73219>>>>>>>>>>>>>>>>>/// @See
73219>>>>>>>>>>>>>>>>>
73219>>>>>>>>>>>>>>>>>
73219>>>>>>>>>>>>>>>>>
73219>>>>>>>>>>>>>>>>>
73219>>>>>>>>>>>>>>>>>//=============================================================================
73219>>>>>>>>>>>>>>>>>/// @Name        CALL_STORED_PROCEDURE
73219>>>>>>>>>>>>>>>>>/// @Description This command is used to call a stored procedure on the SQL
73219>>>>>>>>>>>>>>>>>/// backend. To successfully call a procedure with this command, a string
73219>>>>>>>>>>>>>>>>>/// must be passed containing a valid procedure name. In addition, if the
73219>>>>>>>>>>>>>>>>>/// procedure takes any arguments, they must also be passed using the constant
73219>>>>>>>>>>>>>>>>>/// "passing" along with all of the needed arguments. If the procedure has a
73219>>>>>>>>>>>>>>>>>/// return value, then SQL_GET_FUNCTION_RETURN or SQL_FETCH_NEXT_ROW can be
73219>>>>>>>>>>>>>>>>>/// used to get the value(s). If an error is found then the indicator "Err"
73219>>>>>>>>>>>>>>>>>/// is set to true.
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Assumptions
73219>>>>>>>>>>>>>>>>>/// @Status      Public
73219>>>>>>>>>>>>>>>>>/// @Drivers     All
73219>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-09-25 by Aaron Gulack
73219>>>>>>>>>>>>>>>>>/// @See
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Syntax CALL_STORED_PROCEDURE {procedure} Passing {variable}
73219>>>>>>>>>>>>>>>>>/// @Param procedure            Full name of the procedure
73219>>>>>>>>>>>>>>>>>/// @Param variable                     Argument being passed (can be multiple)
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Example
73219>>>>>>>>>>>>>>>>>/// CALL_STORED_PROCEDURE "sys.sp_addmessage" passing 50003 15 "Please enter a valid date"
73219>>>>>>>>>>>>>>>>>
73219>>>>>>>>>>>>>>>>>//=============================================================================
73219>>>>>>>>>>>>>>>>>/// @Name        CALL_SQLSERVER_PROCEDURE
73219>>>>>>>>>>>>>>>>>/// @Description This command is used to call a stored procedure on the SQL
73219>>>>>>>>>>>>>>>>>/// backend. To successfully call a procedure with this command, a string
73219>>>>>>>>>>>>>>>>>/// must be passed containing a valid procedure name. In addition, if the
73219>>>>>>>>>>>>>>>>>/// procedure takes any arguments, they must also be passed using the constant
73219>>>>>>>>>>>>>>>>>/// "passing" along with all of the needed arguments. If the procedure has a
73219>>>>>>>>>>>>>>>>>/// return value, then SQL_GET_FUNCTION_RETURN, SQL_FETCH_NEXT_ROW or
73219>>>>>>>>>>>>>>>>>/// GET_PROCEDURE_RETURN can be used to get the value(s). If an error is found
73219>>>>>>>>>>>>>>>>>/// then the indicator "Err" is set to true.
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Status      Deprecated
73219>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex
73219>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
73219>>>>>>>>>>>>>>>>>/// @See                 CALL_STORED_PROCEDURE
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Syntax CALL_SQLSERVER_PROCEDURE {procedure} Passing {variable}
73219>>>>>>>>>>>>>>>>>/// @Param procedure            Full name of the procedure
73219>>>>>>>>>>>>>>>>>/// @Param variable                     Argument to be passed (can be multiple)
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Example
73219>>>>>>>>>>>>>>>>>/// CALL_SQLSERVER_PROCEDURE "sys.sp_addmessage" passing 50003 15 "Please enter a valid date"
73219>>>>>>>>>>>>>>>>>
73219>>>>>>>>>>>>>>>>>//=============================================================================
73219>>>>>>>>>>>>>>>>>/// @Name        END_CALL_PROCEDURE
73219>>>>>>>>>>>>>>>>>/// @Description This command is used to close any open cursors created
73219>>>>>>>>>>>>>>>>>/// by the respective stored procedure. Cursors are used in MSSQL to make
73219>>>>>>>>>>>>>>>>>/// the results from one procedure temporarily available to other procedures
73219>>>>>>>>>>>>>>>>>/// or triggers. To avoid causing unwanted results, it is good practice to
73219>>>>>>>>>>>>>>>>>/// use this command once a procedure call is completed.
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Assumptions
73219>>>>>>>>>>>>>>>>>/// @Status      Public
73219>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex
73219>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
73219>>>>>>>>>>>>>>>>>/// @See                 CALL_STORED_PROCEDURE
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Syntax END_CALL_PROCEDURE
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Example
73219>>>>>>>>>>>>>>>>>/// CALL_STORED_PROCEDURE "sys.sp_spaceused" Passing "Customer"
73219>>>>>>>>>>>>>>>>>/// GET_PROCEDURE_RETURN to sValue
73219>>>>>>>>>>>>>>>>>/// END_CALL_PROCEDURE
73219>>>>>>>>>>>>>>>>>/// Showln sValue
73219>>>>>>>>>>>>>>>>>
73219>>>>>>>>>>>>>>>>>//=============================================================================
73219>>>>>>>>>>>>>>>>>/// @Name        GET_PROCEDURE_RETURN
73219>>>>>>>>>>>>>>>>>/// @Description This command is used to get a returned value from a stored
73219>>>>>>>>>>>>>>>>>/// procedure using MSSQL. Note that this command can only handle one
73219>>>>>>>>>>>>>>>>>/// returned value and must be used after the procedure has already been
73219>>>>>>>>>>>>>>>>>/// built and executed.
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Assumptions
73219>>>>>>>>>>>>>>>>>/// @Status      Public
73219>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex
73219>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
73219>>>>>>>>>>>>>>>>>/// @See
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Syntax GET_PROCEDURE_RETURN to {variable}
73219>>>>>>>>>>>>>>>>>/// @Param variable             Variable to hold the returned value
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Example
73219>>>>>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_NAME "sys.sp_spaceused" NUMPAR 1
73219>>>>>>>>>>>>>>>>>/// SQL_SET_PROCEDURE_PARAMETER 1 to "Customer" IN
73219>>>>>>>>>>>>>>>>>/// SQL_PROCEDURE_EXECUTE
73219>>>>>>>>>>>>>>>>>/// GET_PROCEDURE_RETURN to sSpaceUsed
73219>>>>>>>>>>>>>>>>>/// Showln sSpaceUsed
73219>>>>>>>>>>>>>>>>>
73219>>>>>>>>>>>>>>>>>//=============================================================================
73219>>>>>>>>>>>>>>>>>/// @Name        SET_MIRROR_SERVER
73219>>>>>>>>>>>>>>>>>/// @Description This command is used to programmatically set the mirror
73219>>>>>>>>>>>>>>>>>/// server for the database. This is to be used along with SQl server
73219>>>>>>>>>>>>>>>>>/// failover mirroring. Note that this simply sets the server and database
73219>>>>>>>>>>>>>>>>>/// to be used for mirroring. All set up for the servers must already be
73219>>>>>>>>>>>>>>>>>/// working properly through SQL Server.
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Assumptions A compatible version of SQL Server is being used
73219>>>>>>>>>>>>>>>>>/// @Status      Public
73219>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex v9.2 and above
73219>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
73219>>>>>>>>>>>>>>>>>/// @See                 GET_MIRROR_SERVER
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Syntax SET_MIRROR_SERVER to {server} {database}
73219>>>>>>>>>>>>>>>>>/// @Param server                       The name of the mirror server
73219>>>>>>>>>>>>>>>>>/// @Param database                     The database acting as a mirror
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Example
73219>>>>>>>>>>>>>>>>>/// SET_MIRROR_SERVER to "(localdb)\v11.0" "MirrorDB"
73219>>>>>>>>>>>>>>>>>
73219>>>>>>>>>>>>>>>>>//=============================================================================
73219>>>>>>>>>>>>>>>>>/// @Name        GET_MIRROR_SERVER
73219>>>>>>>>>>>>>>>>>/// @Description This command is used to get the name of the server
73219>>>>>>>>>>>>>>>>>/// and database being used for failover mirroring. Mirroring must
73219>>>>>>>>>>>>>>>>>/// be properly set up in SQL Server for this command to return the
73219>>>>>>>>>>>>>>>>>/// correct values.
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Assumptions
73219>>>>>>>>>>>>>>>>>/// @Status      Public
73219>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex v9.2 and above
73219>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
73219>>>>>>>>>>>>>>>>>/// @See                 SET_MIRROR_SERVER
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Syntax GET_MIRROR_SERVER to {server} {database}
73219>>>>>>>>>>>>>>>>>/// @Param server                       Variable to hold the name of the mirrored server
73219>>>>>>>>>>>>>>>>>/// @Param database                     Variable to hold the name of the mirrored database
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Example
73219>>>>>>>>>>>>>>>>>/// GET_MIRROR_SERVER to sServer sDatabase
73219>>>>>>>>>>>>>>>>>
73219>>>>>>>>>>>>>>>>>//=============================================================================
73219>>>>>>>>>>>>>>>>>/// @Name        COPY_DATA
73219>>>>>>>>>>>>>>>>>/// @Description This command is used to copy data from a DAT file to an
73219>>>>>>>>>>>>>>>>>/// SQL table. Both the source and the destination files are opened, the
73219>>>>>>>>>>>>>>>>>/// data is copied and then the files are closed. This is usually used
73219>>>>>>>>>>>>>>>>>/// along with CREATE_TABLE_FROM_DAT_FILE, which creates the structure
73219>>>>>>>>>>>>>>>>>/// and then this command will insert the data. If needed, this command
73219>>>>>>>>>>>>>>>>>/// can also work backwards, copying data from an SQL table to a DAT file.
73219>>>>>>>>>>>>>>>>>/// This is an alternative to using the Flex2SQL Migration Tool and can
73219>>>>>>>>>>>>>>>>>/// improve performance when used in the right situations. Note that in
73219>>>>>>>>>>>>>>>>>/// order for this process to work properly the table being copied can not
73219>>>>>>>>>>>>>>>>>/// be opened. Because of this, a manual login must take place, using
73219>>>>>>>>>>>>>>>>>/// something like LOGIN_SQLFLEX or LOGIN. Since this only copies the data,
73219>>>>>>>>>>>>>>>>>/// CREATE_TABLE_FROM_DAT_FILE can be used to create the table structure.
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// Because COPY_DATA requires no user interaction, an optional callback
73219>>>>>>>>>>>>>>>>>/// function can be passed for tracing purposes. By passing the constant
73219>>>>>>>>>>>>>>>>>/// "CALLBACK" followed by the object name, a function can be used to set
73219>>>>>>>>>>>>>>>>>/// up messages for tracking and error handling. Below is more information
73219>>>>>>>>>>>>>>>>>/// regarding this callback object.
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// This function should follow this pattern:
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// Function Callback String sText Integer iStatusID Returns Integer
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// sText - Message corresponding to the current status ID
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// iStatusID - Integer value mapping to the current status constant:
73219>>>>>>>>>>>>>>>>>///                     DF_MESSAGE_PROGRESS_TITLE    Sent when SQLFlex starts the
73219>>>>>>>>>>>>>>>>>///                                                                              process
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>///             DF_MESSAGE_HEADING_1         Sent when SQLFlex is about to
73219>>>>>>>>>>>>>>>>>///                                                                              copy the source data
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>///             DF_MESSAGE_ERROR             Sent when an error occurs
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>///             DF_MESSAGE_PROGRESS_STATUS   Sent each time an additional
73219>>>>>>>>>>>>>>>>>///                                                                              10% of the data is copied
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// NOTE: Returning false each time the function is called will continue
73219>>>>>>>>>>>>>>>>>/// copying process. Returning true will end it.
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// Another optional parameter that can be used is a constrain on the data
73219>>>>>>>>>>>>>>>>>/// being copied. This is done by passing the constant "CONSTRAIN" followed
73219>>>>>>>>>>>>>>>>>/// by an SQL constrain statement. When passing a constrain but not a callback
73219>>>>>>>>>>>>>>>>>/// object, pass 0 for the callback before passsing the constrain.
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Assumptions
73219>>>>>>>>>>>>>>>>>/// @Status      Public
73219>>>>>>>>>>>>>>>>>/// @Drivers     All
73219>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
73219>>>>>>>>>>>>>>>>>/// @See                 CREATE_TABLE_FROM_DAT_FILE CONVERT_DAT_FILE
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Syntax COPY_DATA {from} to {destination} [CALLBACK {function}] [CONSTRAIN {variable}]
73219>>>>>>>>>>>>>>>>>/// @Param from                         Table to copy from.
73219>>>>>>>>>>>>>>>>>/// @Param destination          Table to copy to.
73219>>>>>>>>>>>>>>>>>/// @Param function             Object with callback function (optional)
73219>>>>>>>>>>>>>>>>>/// @Param variable                     SQL contraint to use when copying (optional)
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Example
73219>>>>>>>>>>>>>>>>>/// Object CallBackObj is a Array
73219>>>>>>>>>>>>>>>>>///     Function Callback String sText Integer iLogicalID Returns Integer
73219>>>>>>>>>>>>>>>>>///         If (iLogicalID = DF_MESSAGE_ERROR) Begin
73219>>>>>>>>>>>>>>>>>///             Showln "Error"
73219>>>>>>>>>>>>>>>>>///                             Showln sText
73219>>>>>>>>>>>>>>>>>///                             Function_Return True
73219>>>>>>>>>>>>>>>>>///         End
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>///         Else Showln sText
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>///                     Function_Return False
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>///     End_Function
73219>>>>>>>>>>>>>>>>>/// End_Object
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// Login "localhost" "user" "pass123" "sql_drv"
73219>>>>>>>>>>>>>>>>>/// CREATE_TABLE_FROM_DAT_FILE Customer.File_Number "Customer"
73219>>>>>>>>>>>>>>>>>/// COPY_DATA "Customer" to "sql_drv:Customer" CALLBACK (Callback(Self)) CONSTRAIN "STATUS = 'Active'"
73219>>>>>>>>>>>>>>>>>
73219>>>>>>>>>>>>>>>>>//=============================================================================
73219>>>>>>>>>>>>>>>>>/// @Name        ORAFlex_REVISION
73219>>>>>>>>>>>>>>>>>/// @Description This command will put the current version (decimals included)
73219>>>>>>>>>>>>>>>>>/// of the Oracle driver associated with the current workspace into the specified
73219>>>>>>>>>>>>>>>>>/// variable.
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Assumptions
73219>>>>>>>>>>>>>>>>>/// @Status      Deprecated
73219>>>>>>>>>>>>>>>>>/// @Drivers     ORAFlex
73219>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
73219>>>>>>>>>>>>>>>>>/// @See                 GET_DRIVER_REVISION
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Syntax ORAFlex_REVISION {variable}
73219>>>>>>>>>>>>>>>>>/// @Param variable                     String variable to hold the returned version
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Example
73219>>>>>>>>>>>>>>>>>/// ORAFlex_REVISION sVersion
73219>>>>>>>>>>>>>>>>>
73219>>>>>>>>>>>>>>>>>//=============================================================================
73219>>>>>>>>>>>>>>>>>/// @Name        KEEP_FILES_OPEN
73219>>>>>>>>>>>>>>>>>/// @Description Keep the files, currently in use, open after the server is
73219>>>>>>>>>>>>>>>>>/// logged out. Sometimes an application needs to login to the same server
73219>>>>>>>>>>>>>>>>>/// with a different user id. When logging out, however, the drivers
73219>>>>>>>>>>>>>>>>>/// automatically close all opened files. The overhead of opening these files
73219>>>>>>>>>>>>>>>>>/// should be avoided if the user will work with the same files that were
73219>>>>>>>>>>>>>>>>>/// closed. KEEP_FILES_OPEN keeps all files opened after a user logs out
73219>>>>>>>>>>>>>>>>>/// from the server.
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Status      Deprecated
73219>>>>>>>>>>>>>>>>>/// @Drivers     All
73219>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Syntax KEEP_FILES_OPEN of {server}
73219>>>>>>>>>>>>>>>>>/// @Param server               Name of the server
73219>>>>>>>>>>>>>>>>>
73219>>>>>>>>>>>>>>>>>
73219>>>>>>>>>>>>>>>>>//=============================================================================
73219>>>>>>>>>>>>>>>>>/// @Name        SET_MAX_OPEN_CURSORS
73219>>>>>>>>>>>>>>>>>/// @Description Set the maximum number of cursors you want the driver to use.
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// The driver will recycle the least used cursors if this limit is hit.
73219>>>>>>>>>>>>>>>>>/// The trade off is between increased resources on the server and
73219>>>>>>>>>>>>>>>>>/// re-preparing of cursors.
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// For a program that keeps 40+ files opened at the same time, 255 is a good
73219>>>>>>>>>>>>>>>>>/// number for the open cursors parameter. For programs that open less than
73219>>>>>>>>>>>>>>>>>/// 40 files, any number between 100-255 is sufficient. These numbers can be
73219>>>>>>>>>>>>>>>>>/// changed based on available server resources.
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// On Oracle this value should not exceed the value of open_cursors in
73219>>>>>>>>>>>>>>>>>/// init.ora
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// Note: Only change this setting if you are having performance issues
73219>>>>>>>>>>>>>>>>>/// and the server is indicating you are using up too many cursors or too
73219>>>>>>>>>>>>>>>>>/// much memory. GET_OPENED_CURSORS can be used to check the number of
73219>>>>>>>>>>>>>>>>>/// cursors the server has opened. If this number is hitting the limit,
73219>>>>>>>>>>>>>>>>>/// it is worth increasing the number, as long as the server has enough
73219>>>>>>>>>>>>>>>>>/// resources.
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Assumptions
73219>>>>>>>>>>>>>>>>>/// @Status      Public
73219>>>>>>>>>>>>>>>>>/// @Drivers     All
73219>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
73219>>>>>>>>>>>>>>>>>/// @See         GET_MAX_OPEN_CURSORS GET_OPENED_CURSORS
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Syntax SET_MAX_OPEN_CURSORS of {server} to {variable}
73219>>>>>>>>>>>>>>>>>/// @Param server                       The name of the server
73219>>>>>>>>>>>>>>>>>/// @Param variable                     Maximum number of cursors
73219>>>>>>>>>>>>>>>>>
73219>>>>>>>>>>>>>>>>>//=============================================================================
73219>>>>>>>>>>>>>>>>>/// @Name        GET_MAX_OPEN_CURSORS
73219>>>>>>>>>>>>>>>>>/// @Description This command will return the maximum number of open
73219>>>>>>>>>>>>>>>>>/// cursors allowed by the server.
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Assumptions
73219>>>>>>>>>>>>>>>>>/// @Status      Public
73219>>>>>>>>>>>>>>>>>/// @Drivers     All
73219>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
73219>>>>>>>>>>>>>>>>>/// @See         SET_MAX_OPEN_CURSORS GET_OPENED_CURSORS
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Syntax GET_MAX_OPEN_CURSORS of {server} to {variable}
73219>>>>>>>>>>>>>>>>>/// @Param server                       Name of the server
73219>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the maximum number of open cursors
73219>>>>>>>>>>>>>>>>>
73219>>>>>>>>>>>>>>>>>//=============================================================================
73219>>>>>>>>>>>>>>>>>/// @Name        GET_OPENED_CURSORS
73219>>>>>>>>>>>>>>>>>/// @Description This command returns the number of cursors currently
73219>>>>>>>>>>>>>>>>>/// open on the server.
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Assumptions
73219>>>>>>>>>>>>>>>>>/// @Status      Public
73219>>>>>>>>>>>>>>>>>/// @Drivers     All
73219>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
73219>>>>>>>>>>>>>>>>>/// @See         SET_MAX_OPEN_CURSORS GET_MAX_OPEN_CURSORS
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Syntax GET_MAX_OPEN_CURSORS of {server} to {variable}
73219>>>>>>>>>>>>>>>>>/// @Param server                       Name of the server
73219>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the number of cursors currently open
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>
73219>>>>>>>>>>>>>>>>>//=============================================================================
73219>>>>>>>>>>>>>>>>>/// @Name        ACTIVATE_TIME_STAMP
73219>>>>>>>>>>>>>>>>>/// @Description This command will specify whether or not to show the time
73219>>>>>>>>>>>>>>>>>/// portion of a date field. When set to ON, the time portion will be
73219>>>>>>>>>>>>>>>>>/// included, OFF will just show the date. This is the same as changing
73219>>>>>>>>>>>>>>>>>/// the date format with "ALTER SESSION SET nls_timestamp_format". Note that
73219>>>>>>>>>>>>>>>>>/// this will only take effect if the date is put into a string variable.
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Assumptions
73219>>>>>>>>>>>>>>>>>/// @Status      Deprecated
73219>>>>>>>>>>>>>>>>>/// @Drivers     OraFlex
73219>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
73219>>>>>>>>>>>>>>>>>/// @See
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Syntax ACTIVATE_TIME_STAMP of {server} to {ON/OFF}
73219>>>>>>>>>>>>>>>>>/// @Param server                       Name of the server
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Example
73219>>>>>>>>>>>>>>>>>/// ACTIVATE_TIME_STAMP of "localhost/orcl.localdomain" to OFF
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// SQL_SET_STMT to 'SELECT * from USER."Customer" '
73219>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT
73219>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
73219>>>>>>>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sID sFirstName sLastName sDOB
73219>>>>>>>>>>>>>>>>>/// If (Found) Begin
73219>>>>>>>>>>>>>>>>>///     Showln sDOB
73219>>>>>>>>>>>>>>>>>/// End
73219>>>>>>>>>>>>>>>>>
73219>>>>>>>>>>>>>>>>>//=============================================================================
73219>>>>>>>>>>>>>>>>>/// @Name        CALL_ORACLE_STORED_FUNCTION
73219>>>>>>>>>>>>>>>>>/// @Description This command is used to execute a function stored in Oracle.
73219>>>>>>>>>>>>>>>>>/// This is an alternative to building a function with the SQL_SET_FUNCTION_NAME,
73219>>>>>>>>>>>>>>>>>/// SQL_SET_FUNCTION_PARAMETER and SQL_FUNCTION_EXECUTE commands. This command
73219>>>>>>>>>>>>>>>>>/// builds and executes the function by setting the full function name, the
73219>>>>>>>>>>>>>>>>>/// parameter(s) to pass and the variable to hold the returned value. Note that
73219>>>>>>>>>>>>>>>>>/// this command can only return a single value so SQL_SET_FUNCTION_PARAMETER
73219>>>>>>>>>>>>>>>>>/// and SQL_SET_FUNCTION_NAME must be used when dealing with multiple return
73219>>>>>>>>>>>>>>>>>/// values.
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Status      Deprecated
73219>>>>>>>>>>>>>>>>>/// @Drivers     ORAFLex
73219>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
73219>>>>>>>>>>>>>>>>>/// @See                 CALL_STORED_FUNCTION
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Syntax CALL_ORACLE_STORED_FUNCTION {function} Returns {variable} Passing {argument}
73219>>>>>>>>>>>>>>>>>/// @Param function                     Full name of the function
73219>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the returned value
73219>>>>>>>>>>>>>>>>>/// @Param argument                     Argument to pass (can be multiple)
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Example
73219>>>>>>>>>>>>>>>>>/// CALL_ORACLE_STORED_FUNCTION "user.getCustomerStatus" Returns sStatus passing sCustomerID
73219>>>>>>>>>>>>>>>>>/// Showln sStatus
73219>>>>>>>>>>>>>>>>>
73219>>>>>>>>>>>>>>>>>//=============================================================================
73219>>>>>>>>>>>>>>>>>/// @Name        CALL_PGSQL_STORED_FUNCTION
73219>>>>>>>>>>>>>>>>>/// @Description This command is used to execute a function stored in Oracle.
73219>>>>>>>>>>>>>>>>>/// This is an alternative to building a function with the SQL_SET_FUNCTION_NAME,
73219>>>>>>>>>>>>>>>>>/// SQL_SET_FUNCTION_PARAMETER and SQL_FUNCTION_EXECUTE commands. This command
73219>>>>>>>>>>>>>>>>>/// builds and executes the function by setting the full function name, the
73219>>>>>>>>>>>>>>>>>/// parameter(s) to pass and the variable to hold the returned value. Note that
73219>>>>>>>>>>>>>>>>>/// this command can only return a single value so SQL_SET_FUNCTION_PARAMETER
73219>>>>>>>>>>>>>>>>>/// and SQL_SET_FUNCTION_NAME must be used when dealing with multiple return
73219>>>>>>>>>>>>>>>>>/// values.
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Status      Deprecated
73219>>>>>>>>>>>>>>>>>/// @Drivers     PGFlex
73219>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
73219>>>>>>>>>>>>>>>>>/// @See                 CALL_STORED_FUNCTION
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Syntax CALL_PGSQL_STORED_FUNCTION {function} Returns {variable} Passing {argument}
73219>>>>>>>>>>>>>>>>>/// @Param function                     Full name of the function
73219>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the returned value
73219>>>>>>>>>>>>>>>>>/// @Param argument                     Argument to pass (can be multiple)
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Example
73219>>>>>>>>>>>>>>>>>/// CALL_PGSQL_STORED_FUNCTION "user.getCustomerStatus" Returns sStatus passing sCustomerID
73219>>>>>>>>>>>>>>>>>/// Showln sStatus
73219>>>>>>>>>>>>>>>>>
73219>>>>>>>>>>>>>>>>>//=============================================================================
73219>>>>>>>>>>>>>>>>>/// @Name        MERTECH_LANGUAGE_SUPPORT
73219>>>>>>>>>>>>>>>>>/// @Description Sets the support language for the driver.
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Assumptions
73219>>>>>>>>>>>>>>>>>/// @Status      Internal
73219>>>>>>>>>>>>>>>>>/// @Drivers     ORAFLex
73219>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
73219>>>>>>>>>>>>>>>>>/// @See
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Syntax MERTECH_LANGUAGE_SUPPORT of {server} to {language}
73219>>>>>>>>>>>>>>>>>/// @Param server               The name of the server being used
73219>>>>>>>>>>>>>>>>>/// @Param language             The language to set support to
73219>>>>>>>>>>>>>>>>>
73219>>>>>>>>>>>>>>>>>//=============================================================================
73219>>>>>>>>>>>>>>>>>/// @Name        SQL_SAVE_BUFFER_BEGIN
73219>>>>>>>>>>>>>>>>>/// @Description This command is used to initialize a SAVE_BUFFER
73219>>>>>>>>>>>>>>>>>/// statement. Doing this will allow a specified set of records to be
73219>>>>>>>>>>>>>>>>>/// stored in the buffer before a save takes place. Once the buffer is
73219>>>>>>>>>>>>>>>>>/// filled, it will be saved automatically. This set of commands can be
73219>>>>>>>>>>>>>>>>>/// used to efficiently save a large number of records. Once the buffer
73219>>>>>>>>>>>>>>>>>/// is full, the save occurs automatically and the buffer will be emptied
73219>>>>>>>>>>>>>>>>>/// out. It is good practice to use this method inside of a transaction to
73219>>>>>>>>>>>>>>>>>/// maintain atomicity. Note that these commands should not be used in
73219>>>>>>>>>>>>>>>>>/// conjuction with finds.
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Assumptions
73219>>>>>>>>>>>>>>>>>/// @Status      Public
73219>>>>>>>>>>>>>>>>>/// @Drivers     All
73219>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
73219>>>>>>>>>>>>>>>>>/// @See         SQL_SAVE_BUFFER_END SQL_SAVE_BUFFER
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Syntax SQL_SAVE_BUFFER_BEGIN of {FileName} to {variable}
73219>>>>>>>>>>>>>>>>>/// @Param FileName                     Name of the file
73219>>>>>>>>>>>>>>>>>/// @Param variable                     Number of records to store in the buffer
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Example
73219>>>>>>>>>>>>>>>>>/// Open Customer
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// SQL_SAVE_BUFFER_BEGIN of Transactions to 10
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// For i from 0 to 1000
73219>>>>>>>>>>>>>>>>>///     Move i to Transactions.ID
73219>>>>>>>>>>>>>>>>>///     SQL_SAVE_BUFFER of Transactions
73219>>>>>>>>>>>>>>>>>/// Loop
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// SQL_SAVE_BUFFER_END of Customer
73219>>>>>>>>>>>>>>>>>
73219>>>>>>>>>>>>>>>>>//=============================================================================
73219>>>>>>>>>>>>>>>>>/// @Name        SQL_SAVE_BUFFER
73219>>>>>>>>>>>>>>>>>/// @Description This command is used to send a record to the "Save
73219>>>>>>>>>>>>>>>>>/// Record" buffer. It must be used along with SQL_SAVE_BUFFER_BEGIN
73219>>>>>>>>>>>>>>>>>/// and SQL_SAVE_BUFFER_END. SQL_SAVE_BUFFER_BEGIN sets the number of
73219>>>>>>>>>>>>>>>>>/// records to store in the buffer before a save is done on all the records
73219>>>>>>>>>>>>>>>>>/// at once. Each time a record is created, this command should be called
73219>>>>>>>>>>>>>>>>>/// to insert it into the buffer. Using this set of commands can be useful
73219>>>>>>>>>>>>>>>>>/// to efficiently save a large number of records. Once the buffer is full,
73219>>>>>>>>>>>>>>>>>/// the save occurs automatically and the buffer will be emptied out. It is
73219>>>>>>>>>>>>>>>>>/// good practice to use this method inside of a transaction to maintain
73219>>>>>>>>>>>>>>>>>/// atomicity.
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Assumptions
73219>>>>>>>>>>>>>>>>>/// @Status      Public
73219>>>>>>>>>>>>>>>>>/// @Drivers     All
73219>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
73219>>>>>>>>>>>>>>>>>/// @See                 SQL_SAVE_BUFFER_BEGIN SQL_SAVE_BUFFER_END
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Syntax SQL_SAVE_BUFFER of {FileName}
73219>>>>>>>>>>>>>>>>>/// @Param FileName                     Name of the file
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Example
73219>>>>>>>>>>>>>>>>>/// Open Customer
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// SQL_SAVE_BUFFER_BEGIN of Transactions to 10
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// For i from 0 to 1000
73219>>>>>>>>>>>>>>>>>///     Move i to Transactions.ID
73219>>>>>>>>>>>>>>>>>///     SQL_SAVE_BUFFER of Transactions
73219>>>>>>>>>>>>>>>>>/// Loop
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// SQL_SAVE_BUFFER_END of Customer
73219>>>>>>>>>>>>>>>>>
73219>>>>>>>>>>>>>>>>>//=============================================================================
73219>>>>>>>>>>>>>>>>>/// @Name        SQL_SAVE_BUFFER_END
73219>>>>>>>>>>>>>>>>>/// @Description This command indicates the end of the extended record
73219>>>>>>>>>>>>>>>>>/// buffer and forces a save of any data currently in the buffer.
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Assumptions
73219>>>>>>>>>>>>>>>>>/// @Status      Public
73219>>>>>>>>>>>>>>>>>/// @Drivers     All
73219>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-04 by Aaron Gulack
73219>>>>>>>>>>>>>>>>>/// @See         SQL_SAVE_BUFFER_BEGIN SQL_SAVE_BUFFER
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Syntax SQL_SAVE_BUFFER_END of {FileName}
73219>>>>>>>>>>>>>>>>>/// @Param FileName                     Name of the file
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Example
73219>>>>>>>>>>>>>>>>>/// Open Customer
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// SQL_SAVE_BUFFER_BEGIN of Transactions to 10
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// For i from 0 to 1000
73219>>>>>>>>>>>>>>>>>///     Move i to Transactions.ID
73219>>>>>>>>>>>>>>>>>///     SQL_SAVE_BUFFER of Transactions
73219>>>>>>>>>>>>>>>>>/// Loop
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// SQL_SAVE_BUFFER_END of Customer
73219>>>>>>>>>>>>>>>>>
73219>>>>>>>>>>>>>>>>>//=============================================================================
73219>>>>>>>>>>>>>>>>>/// @Name        SQL_SAVE_SET_ATTRIBUTES
73219>>>>>>>>>>>>>>>>>/// @Description Unknown - Not in help - Not call by any other macros
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Assumptions
73219>>>>>>>>>>>>>>>>>/// @Status      Internal
73219>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex
73219>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-18 By Ian Smith
73219>>>>>>>>>>>>>>>>>/// @See
73219>>>>>>>>>>>>>>>>>
73219>>>>>>>>>>>>>>>>>//=============================================================================
73219>>>>>>>>>>>>>>>>>/// @Name        ENABLE_TRACE_ON
73219>>>>>>>>>>>>>>>>>/// @Description This command enables driver level tracing to the
73219>>>>>>>>>>>>>>>>>/// specified file. Enabling trace on an application and using it
73219>>>>>>>>>>>>>>>>>/// in conjunction with SQL_TEXT_MESSAGE is a good way to study
73219>>>>>>>>>>>>>>>>>/// particular problems you encounter in the driver. SQL_TEXT_MESSAGE
73219>>>>>>>>>>>>>>>>>/// allows you to insert sections of your code into the trace file.
73219>>>>>>>>>>>>>>>>>/// This command can also set the trace to three different levels,
73219>>>>>>>>>>>>>>>>>/// allowing different amounts of information to be logged. Note that
73219>>>>>>>>>>>>>>>>>/// trace files can become very large so it is good practice to only
73219>>>>>>>>>>>>>>>>>/// turn them on when specifically needed.
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Assumptions
73219>>>>>>>>>>>>>>>>>/// @Status      Public
73219>>>>>>>>>>>>>>>>>/// @Drivers     All
73219>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
73219>>>>>>>>>>>>>>>>>/// @See                 DISABLE_TRACE_ON SQL_TEXT_MESSAGE
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Syntax ENABLE_TRACE_ON to {fileName} Debug_Level [{constant}]
73219>>>>>>>>>>>>>>>>>/// @Param fileName                     The path of the file to send the trace to
73219>>>>>>>>>>>>>>>>>/// @Param constant             DETAIL_LEVEL1, DETAIL_LEVEL2, DETAIL_LEVEL3 (optional)
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Example ENABLE_TRACE_ON TO "C:\Temp\trace_file.txt" Debug_Level DETAIL_LEVEL3
73219>>>>>>>>>>>>>>>>>
73219>>>>>>>>>>>>>>>>>//=============================================================================
73219>>>>>>>>>>>>>>>>>/// @Name        DISABLE_TRACE_ON
73219>>>>>>>>>>>>>>>>>/// @Description This command disables the current trace taking
73219>>>>>>>>>>>>>>>>>/// place on a driver.
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Assumptions
73219>>>>>>>>>>>>>>>>>/// @Status      Public
73219>>>>>>>>>>>>>>>>>/// @Drivers     All
73219>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
73219>>>>>>>>>>>>>>>>>/// @See ENABLE_TRACE_ON SQL_TEXT_MESSAGE
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Syntax DISABLE_TRACE_ON
73219>>>>>>>>>>>>>>>>>
73219>>>>>>>>>>>>>>>>>//=============================================================================
73219>>>>>>>>>>>>>>>>>/// @Name        CREATE_TABLE_FROM_DAT_FILE
73219>>>>>>>>>>>>>>>>>/// @Description This command is used to create a SQL table from a .DAT
73219>>>>>>>>>>>>>>>>>/// file. The table being copied must be not be opened in order for this
73219>>>>>>>>>>>>>>>>>/// command to work properly. This is the programmatic equivalent to
73219>>>>>>>>>>>>>>>>>/// using the Flex2SQL Migration Tool. Optional restructuring options
73219>>>>>>>>>>>>>>>>>/// can be specified here (see below) as well as an alternative table
73219>>>>>>>>>>>>>>>>>/// name than the physical name of the .DAT file. Note that this only
73219>>>>>>>>>>>>>>>>>/// creates the  table structure, no data will be copied here. To copy
73219>>>>>>>>>>>>>>>>>/// the data, use COPY_DATA after the table has been created.
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// DF_STRUCTEND_OPT_FORCE_INVK         - Deprecated
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// DF_STRUCTEND_OPT_OLD_INVK_NAME      - Deprecated
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// DF_STRUCTEND_OPT_FORCE_NOT_NULL - forces all fields to be created as NOT NULL.
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Assumptions
73219>>>>>>>>>>>>>>>>>/// @Status      Public
73219>>>>>>>>>>>>>>>>>/// @Drivers     All
73219>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
73219>>>>>>>>>>>>>>>>>/// @See                 COPY_DATA CONVERT_DAT_FILE
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Syntax CREATE_TABLE_FROM_DAT_FILE {FileNumber} [{options} {table}]
73219>>>>>>>>>>>>>>>>>/// @Param FileNumber           Number of the file
73219>>>>>>>>>>>>>>>>>/// @Param options                      DF_STRUCTEND_OPT_FORCE_INVK
73219>>>>>>>>>>>>>>>>>///                                                     DF_STRUCTEND_OPT_OLD_INVK_NAME
73219>>>>>>>>>>>>>>>>>///                                                     DF_STRUCTEND_OPT_FORCE_NOT_NULL (optional)
73219>>>>>>>>>>>>>>>>>/// @Param table            name of table to use instead of physical name (optional)
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Example
73219>>>>>>>>>>>>>>>>>/// Login "localhost" "user" "pass123" "sql_drv"
73219>>>>>>>>>>>>>>>>>/// CREATE_TABLE_FROM_DAT_FILE Customer.File_Number "Customer"
73219>>>>>>>>>>>>>>>>>/// COPY_DATA "Customer" to "sql_drv:Customer" CALLBACK (Callback(Self)) CONSTRAIN "STATUS = 'Active'"
73219>>>>>>>>>>>>>>>>>
73219>>>>>>>>>>>>>>>>>//=============================================================================
73219>>>>>>>>>>>>>>>>>/// @Name        CONVERT_DAT_FILE
73219>>>>>>>>>>>>>>>>>/// @Description This command is the programmatic equivalent to the
73219>>>>>>>>>>>>>>>>>/// Flex2SQL Migration Tool. With this command, a SQL table can be
73219>>>>>>>>>>>>>>>>>/// created from a .DAT table. This combines the COPY_DATA and
73219>>>>>>>>>>>>>>>>>/// CREATE_TABLE_FROM_DAT_FILE, creating the table structure and
73219>>>>>>>>>>>>>>>>>/// copying all the data into the new table with one command. The
73219>>>>>>>>>>>>>>>>>/// table being converted cannot be opened and so a manual login is
73219>>>>>>>>>>>>>>>>>/// needed. Note that to specify the database to copy the table to,
73219>>>>>>>>>>>>>>>>>/// use SET_DATABASE_NAME. Below is a list of the optional restructure
73219>>>>>>>>>>>>>>>>>/// options to use when creating the table.
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// DF_STRUCTEND_OPT_FORCE_INVK         - Deprecated
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// DF_STRUCTEND_OPT_OLD_INVK_NAME      - Deprecated
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// DF_STRUCTEND_OPT_FORCE_NOT_NULL - forces all fields to be created as NOT NULL.
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Assumptions
73219>>>>>>>>>>>>>>>>>/// @Status      Public
73219>>>>>>>>>>>>>>>>>/// @Drivers     All
73219>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
73219>>>>>>>>>>>>>>>>>/// @See                 CREATE_TABLE_FROM_DAT_FILE COPY_DATA
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Syntax CONVERT_DAT_FILE {FileNumber} [{options} {table}]
73219>>>>>>>>>>>>>>>>>/// @Param FileNumber           Number of the file
73219>>>>>>>>>>>>>>>>>/// @Param options                      DF_STRUCTEND_OPT_FORCE_INVK
73219>>>>>>>>>>>>>>>>>///                                                     DF_STRUCTEND_OPT_OLD_INVK_NAME
73219>>>>>>>>>>>>>>>>>///                                                     DF_STRUCTEND_OPT_FORCE_NOT_NULL (optional)
73219>>>>>>>>>>>>>>>>>/// @Param table            Name of table to use instead of physical name (optional)
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Example
73219>>>>>>>>>>>>>>>>>/// Login "localhost" "user" "pass123" "sql_drv"
73219>>>>>>>>>>>>>>>>>/// CONVERT_DAT_FILE Customer.File_Number DF_STRUCTEND_OPT_FORCE_NOT_NULL "Customer"
73219>>>>>>>>>>>>>>>>>
73219>>>>>>>>>>>>>>>>>//=============================================================================
73219>>>>>>>>>>>>>>>>>/// @Name        SET_DEFAULT_FILE_CASING
73219>>>>>>>>>>>>>>>>>/// @Description This command is used to set the file casing standard when
73219>>>>>>>>>>>>>>>>>/// creating or restructuring tables. By default, all table and column names
73219>>>>>>>>>>>>>>>>>/// are created using the specified casing. Passing FILE_CASING_UPPER or
73219>>>>>>>>>>>>>>>>>/// FILE_CASING_LOWER will allow the names to be saved in uppercase or
73219>>>>>>>>>>>>>>>>>/// lowercase respectively. This can be useful for backwards compatibility
73219>>>>>>>>>>>>>>>>>/// where casing was important. Note that the casing standard for a file can
73219>>>>>>>>>>>>>>>>>/// also be changed through mertech.ini. Below is a description of the constants
73219>>>>>>>>>>>>>>>>>/// that can be passed to this command.
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// FILE_CASING_UPPER : All created or edited object names will be converted to uppercase.
73219>>>>>>>>>>>>>>>>>/// FILE_CASING_LOWER : All created or edited object names will be converted to lowercase.
73219>>>>>>>>>>>>>>>>>/// FILE_CASING_KEEP (default) : All created or edited object names will maintain their inputed casing.
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Assumptions
73219>>>>>>>>>>>>>>>>>/// @Status      Public
73219>>>>>>>>>>>>>>>>>/// @Drivers     All
73219>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
73219>>>>>>>>>>>>>>>>>/// @See                 GET_DEFAULT_FILE_CASING
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Syntax SET_DEFAULT_FILE_CASING to {constant}
73219>>>>>>>>>>>>>>>>>/// @Param constant                     FILE_CASING_UPPER, FILE_CASING_LOWER, FILE_CASING_KEEP
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Example
73219>>>>>>>>>>>>>>>>>/// SET_DEFAULT_FILE_CASING to FILE_CASING_UPPER
73219>>>>>>>>>>>>>>>>>
73219>>>>>>>>>>>>>>>>>//=============================================================================
73219>>>>>>>>>>>>>>>>>/// @Name        GET_DEFAULT_FILE_CASING
73219>>>>>>>>>>>>>>>>>/// @Description This command returns the file casing standard used
73219>>>>>>>>>>>>>>>>>/// when creating or restructuring tables. Note that an integer is returned,
73219>>>>>>>>>>>>>>>>>/// mapping to a casing method. Below are the meanings of the possible
73219>>>>>>>>>>>>>>>>>/// returned integers.
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// 0 - FILE_CASING_UPPER : All created or edited object names will be converted to uppercase.
73219>>>>>>>>>>>>>>>>>/// 1 - FILE_CASING_LOWER : All created or edited object names will be converted to lowercase.
73219>>>>>>>>>>>>>>>>>/// 2 - FILE_CASING_KEEP : All created or edited object names will maintain their inputed casing.
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Assumptions
73219>>>>>>>>>>>>>>>>>/// @Status      Public
73219>>>>>>>>>>>>>>>>>/// @Drivers     All
73219>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
73219>>>>>>>>>>>>>>>>>/// @See                 SET_DEFAULT_FILE_CASING
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Syntax GET_DEFAULT_FILE_CASING to {variable}
73219>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the returned casing
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Example
73219>>>>>>>>>>>>>>>>>/// GET_DEFAULT_FILE_CASING TO iCasing
73219>>>>>>>>>>>>>>>>>
73219>>>>>>>>>>>>>>>>>//=============================================================================
73219>>>>>>>>>>>>>>>>>/// @Name        SET_DEFAULT_TABLESPACE
73219>>>>>>>>>>>>>>>>>/// @Description This command sets the default table space to use when
73219>>>>>>>>>>>>>>>>>/// creating tables through Dataflex. A tablespace is a container of
73219>>>>>>>>>>>>>>>>>/// segments (objects that have an allotted amount of space), i.e. tables
73219>>>>>>>>>>>>>>>>>/// and indexes.
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Assumptions
73219>>>>>>>>>>>>>>>>>/// @Status      Public
73219>>>>>>>>>>>>>>>>>/// @Drivers     ORAFlex, PgFlex
73219>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
73219>>>>>>>>>>>>>>>>>/// @See                 GET_DEFAULT_TABLESPACE SET_DEFAULT_INDEX_TABLESPACE GET_DEFAULT_INDEX_TABLESPACE
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Syntax SET_DEFAULT_TABLESPACE to {variable}
73219>>>>>>>>>>>>>>>>>/// @Param variable                     Name of the default table space
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Example
73219>>>>>>>>>>>>>>>>>/// SET_DEFAULT_TABLESPACE to "Users"
73219>>>>>>>>>>>>>>>>>
73219>>>>>>>>>>>>>>>>>//=============================================================================
73219>>>>>>>>>>>>>>>>>/// @Name        GET_DEFAULT_TABLESPACE
73219>>>>>>>>>>>>>>>>>/// @Description This command returns the default table space name for
73219>>>>>>>>>>>>>>>>>/// the current database.
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Assumptions
73219>>>>>>>>>>>>>>>>>/// @Status      Public
73219>>>>>>>>>>>>>>>>>/// @Drivers     ORAFlex, PgFlex
73219>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
73219>>>>>>>>>>>>>>>>>/// @See                 SET_DEFAULT_TABLESPACE SET_DEFAULT_INDEX_TABLESPACE GET_DEFAULT_INDEX_TABLESPACE
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Syntax GET_DEFAULT_TABLESPACE to {variable}
73219>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the default table space name.
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Example
73219>>>>>>>>>>>>>>>>>/// GET_DEFAULT_TABLESPACE to sTableSpace
73219>>>>>>>>>>>>>>>>>
73219>>>>>>>>>>>>>>>>>//=============================================================================
73219>>>>>>>>>>>>>>>>>/// @Name        SET_DEFAULT_INDEX_TABLESPACE
73219>>>>>>>>>>>>>>>>>/// @Description This command sets the default table space for indexes
73219>>>>>>>>>>>>>>>>>/// when creating tables through the DataFlex API. A tablespace is a
73219>>>>>>>>>>>>>>>>>/// container of segments (objects that have an allotted amount of space),
73219>>>>>>>>>>>>>>>>>/// i.e. tables and indexes.
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Assumptions
73219>>>>>>>>>>>>>>>>>/// @Status      Public
73219>>>>>>>>>>>>>>>>>/// @Drivers     ORAFlex, PgFlex
73219>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09-2013 by Aaron Gulack
73219>>>>>>>>>>>>>>>>>/// @See                 SET_DEFAULT_TABLESPACE GET_DEFAULT_TABLESPACE GET_DEFAULT_INDEX_TABLESPACE
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Syntax SET_DEFAULT_INDEX_TABLESPACE to {variable}
73219>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the default index table space name.
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Example
73219>>>>>>>>>>>>>>>>>/// SET_DEFAULT_INDEX_TABLESPACE to "Users"
73219>>>>>>>>>>>>>>>>>
73219>>>>>>>>>>>>>>>>>//=============================================================================
73219>>>>>>>>>>>>>>>>>/// @Name        GET_DEFAULT_INDEX_TABLESPACE
73219>>>>>>>>>>>>>>>>>/// @Description This command returns the default table space name for
73219>>>>>>>>>>>>>>>>>/// indexes in the current database.
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Assumptions
73219>>>>>>>>>>>>>>>>>/// @Status      Public
73219>>>>>>>>>>>>>>>>>/// @Drivers     ORAFlex, PgFlex
73219>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
73219>>>>>>>>>>>>>>>>>/// @See                 SET_DEFAULT_TABLESPACE GET_DEFAULT_TABLESPACE SET_DEFAULT_INDEX_TABLESPACE
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Syntax GET_DEFAULT_INDEX_TABLESPACE to {variable}
73219>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the default index table space name.
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Example
73219>>>>>>>>>>>>>>>>>/// GET_DEFAULT_INDEX_TABLESPACE to sTableSpace
73219>>>>>>>>>>>>>>>>>
73219>>>>>>>>>>>>>>>>>//=============================================================================
73219>>>>>>>>>>>>>>>>>/// @Name        ENABLE_SCRIPTING
73219>>>>>>>>>>>>>>>>>/// @Description Scripting is used for testing and preparation. This
73219>>>>>>>>>>>>>>>>>/// command allows structural changes to be compiled and tested without
73219>>>>>>>>>>>>>>>>>/// actually making any of the changes. Any table restructuring done
73219>>>>>>>>>>>>>>>>>/// between this command and DISABLE_SCRIPTING will not actually be
73219>>>>>>>>>>>>>>>>>/// committed but will instead create a mock INT file. The script and
73219>>>>>>>>>>>>>>>>>/// INT file can then be retrieved and examined for testing purposes.
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Assumptions
73219>>>>>>>>>>>>>>>>>/// @Status      Public
73219>>>>>>>>>>>>>>>>>/// @Drivers     All
73219>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
73219>>>>>>>>>>>>>>>>>/// @See                 DISABLE_SCRIPTING GET_SQL_SCRIPT_CHUNK GET_INT_CHUNK
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Syntax ENABLE_SCRIPTING
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Example
73219>>>>>>>>>>>>>>>>>/// ENABLE_SCRIPTING
73219>>>>>>>>>>>>>>>>>///     //Table restructuring would go here
73219>>>>>>>>>>>>>>>>>/// DISABLE_SCRIPTING
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// GET_SQL_SCRIPT_CHUNK OFFSET 0 to sChunk sLength
73219>>>>>>>>>>>>>>>>>/// Showln sChunk
73219>>>>>>>>>>>>>>>>>
73219>>>>>>>>>>>>>>>>>//=============================================================================
73219>>>>>>>>>>>>>>>>>/// @Name        DISABLE_SCRIPTING
73219>>>>>>>>>>>>>>>>>/// @Description This command ends any scripting started by ENABLE_SCRIPTING.
73219>>>>>>>>>>>>>>>>>/// The mock INT file and script can then be retrieved and examined.
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Assumptions
73219>>>>>>>>>>>>>>>>>/// @Status      Public
73219>>>>>>>>>>>>>>>>>/// @Drivers     All
73219>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2010-12-13 By Marcelo Nachbar
73219>>>>>>>>>>>>>>>>>/// @See                 ENABLE_SCRIPTING  GET_SQL_SCRIPT_CHUNK GET_INT_CHUNK
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Syntax DISABLE_SCRIPTING
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// @Example
73219>>>>>>>>>>>>>>>>>/// ENABLE_SCRIPTING
73219>>>>>>>>>>>>>>>>>///     //Table restructuring would go here
73219>>>>>>>>>>>>>>>>>/// DISABLE_SCRIPTING
73219>>>>>>>>>>>>>>>>>///
73219>>>>>>>>>>>>>>>>>/// GET_SQL_SCRIPT_CHUNK OFFSET 0 to sChunk sLength
73219>>>>>>>>>>>>>>>>>/// Showln sChunk
73219>>>>>>>>>>>>>>>>>
73219>>>>>>>>>>>>>>>>>Function MertechInc_GET_RESTRUCTURE_SCRIPT Global Integer iLong Integer iOffset Returns String
73221>>>>>>>>>>>>>>>>>    Integer iChuck_Size
73221>>>>>>>>>>>>>>>>>    String sChunk
73221>>>>>>>>>>>>>>>>>
73221>>>>>>>>>>>>>>>>>    //Get current Chuck size and pre size string
73221>>>>>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_CHUNK_SIZE CALLBACK 0 PASSING iChuck_Size MertechInc_Blank 1 RESULT MertechInc_iRet
73226>>>>>>>>>>>>>>>>>    Get MertechInc_Pre_Size_String iChuck_Size to sChunk
73227>>>>>>>>>>>>>>>>>
73227>>>>>>>>>>>>>>>>>    //Get data
73227>>>>>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_RESTRUCTURE_SCRIPT CALLBACK 0 PASSING sChunk iOffset iLong RESULT MertechInc_iRet
73232>>>>>>>>>>>>>>>>>
73232>>>>>>>>>>>>>>>>>    // Replace insert a CR before any LF character
73232>>>>>>>>>>>>>>>>>    Move (Replaces(Character(10), sChunk, Character(13)+Character(10))) to sChunk
73233>>>>>>>>>>>>>>>>>
73233>>>>>>>>>>>>>>>>>    Function_Return sChunk
73234>>>>>>>>>>>>>>>>>End_Function
73235>>>>>>>>>>>>>>>>>
73235>>>>>>>>>>>>>>>>>
73235>>>>>>>>>>>>>>>>>//=============================================================================
73235>>>>>>>>>>>>>>>>>/// @Name        GET_SQL_SCRIPT_CHUNK
73235>>>>>>>>>>>>>>>>>/// @Description This command returns a chunk of the script generated
73235>>>>>>>>>>>>>>>>>/// from the restructuring done inside of ENABLE_SCRIPTING and
73235>>>>>>>>>>>>>>>>>/// DISABLE_SCRIPTING. Since some scripts can be very large, the script
73235>>>>>>>>>>>>>>>>>/// can be looped through, grabbing chunks at a time.
73235>>>>>>>>>>>>>>>>>///
73235>>>>>>>>>>>>>>>>>/// @Assumptions
73235>>>>>>>>>>>>>>>>>/// @Status      Public
73235>>>>>>>>>>>>>>>>>/// @Drivers     All
73235>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
73235>>>>>>>>>>>>>>>>>/// @See                 ENABLE_SCRIPTING DISABLE_SCRIPTING GET_INT_CHUNK
73235>>>>>>>>>>>>>>>>>///
73235>>>>>>>>>>>>>>>>>/// @Syntax GET_SQL_SCRIPT_CHUNK OFFSET {offset} to {variable} [{length}]
73235>>>>>>>>>>>>>>>>>/// @Param offset                       Specifies the offset to start at for the chunk
73235>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the chunk
73235>>>>>>>>>>>>>>>>>/// @Param length                       Length of chunk returned (optional)
73235>>>>>>>>>>>>>>>>>///
73235>>>>>>>>>>>>>>>>>/// @Example
73235>>>>>>>>>>>>>>>>>/// ENABLE_SCRIPTING
73235>>>>>>>>>>>>>>>>>///     //Table restructuring would go here
73235>>>>>>>>>>>>>>>>>/// DISABLE_SCRIPTING
73235>>>>>>>>>>>>>>>>>///
73235>>>>>>>>>>>>>>>>>/// GET_SQL_SCRIPT_CHUNK OFFSET 0 to sChunk sLength
73235>>>>>>>>>>>>>>>>>/// Showln sChunk
73235>>>>>>>>>>>>>>>>>
73235>>>>>>>>>>>>>>>>>//=============================================================================
73235>>>>>>>>>>>>>>>>>/// @Name        GET_INT_CHUNK
73235>>>>>>>>>>>>>>>>>/// @Description This command returns a chunk of the INT file generated
73235>>>>>>>>>>>>>>>>>/// from the restructuring done inside of ENABLE_SCRIPTING and
73235>>>>>>>>>>>>>>>>>/// DISABLE_SCRIPTING. Since some INT files can be very large, the file
73235>>>>>>>>>>>>>>>>>/// can be looped through, grabbing chunks at a time.
73235>>>>>>>>>>>>>>>>>///
73235>>>>>>>>>>>>>>>>>/// @Assumptions
73235>>>>>>>>>>>>>>>>>/// @Status      Public
73235>>>>>>>>>>>>>>>>>/// @Drivers     All
73235>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
73235>>>>>>>>>>>>>>>>>/// @See                 ENABLE_SCRIPTING DISABLE_SCRIPTING GET_SQL_SCRIPT_CHUNK
73235>>>>>>>>>>>>>>>>>///
73235>>>>>>>>>>>>>>>>>/// @Syntax GET_INT_CHUNK OFFSET {offset} to {variable} [{length}]
73235>>>>>>>>>>>>>>>>>/// @Param offset                       Specifies the offset to start at for the chunk
73235>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the chunk
73235>>>>>>>>>>>>>>>>>/// @Param length                       Length of chunk returned (optional)
73235>>>>>>>>>>>>>>>>>///
73235>>>>>>>>>>>>>>>>>/// @Example
73235>>>>>>>>>>>>>>>>>/// ENABLE_SCRIPTING
73235>>>>>>>>>>>>>>>>>///     //Table restructuring would go here
73235>>>>>>>>>>>>>>>>>/// DISABLE_SCRIPTING
73235>>>>>>>>>>>>>>>>>///
73235>>>>>>>>>>>>>>>>>/// GET_INT_CHUNK OFFSET 0 to sChunk sLength
73235>>>>>>>>>>>>>>>>>/// Showln sChunk
73235>>>>>>>>>>>>>>>>>
73235>>>>>>>>>>>>>>>>>//=============================================================================
73235>>>>>>>>>>>>>>>>>/// @Name        REPORT_STMT
73235>>>>>>>>>>>>>>>>>/// @Description This command is an alternative to DataFlex's "Report"
73235>>>>>>>>>>>>>>>>>/// command. This allows embedded SQL to be used to fetch data instead of
73235>>>>>>>>>>>>>>>>>/// standard table queries.. All of the finds, for example, normally found
73235>>>>>>>>>>>>>>>>>/// in "Report" are replaced by SQL_FETCH_NEXT_ROW.
73235>>>>>>>>>>>>>>>>>///
73235>>>>>>>>>>>>>>>>>/// @Assumptions
73235>>>>>>>>>>>>>>>>>/// @Status      Public
73235>>>>>>>>>>>>>>>>>/// @Drivers     n/a
73235>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
73235>>>>>>>>>>>>>>>>>/// @See
73235>>>>>>>>>>>>>>>>>///
73235>>>>>>>>>>>>>>>>>/// @Syntax See DataFlex / Visual DataFlex documentation
73235>>>>>>>>>>>>>>>>>///
73235>>>>>>>>>>>>>>>>>/// @Example
73235>>>>>>>>>>>>>>>>>/// /Header
73235>>>>>>>>>>>>>>>>>/// __/__/____                                                        Page ___.
73235>>>>>>>>>>>>>>>>>///                 MERTECH DATA SYSTEMS, INC. - NOT FOR RESALE
73235>>>>>>>>>>>>>>>>>///
73235>>>>>>>>>>>>>>>>>/// ID   NAME
73235>>>>>>>>>>>>>>>>>///
73235>>>>>>>>>>>>>>>>>/// /Body
73235>>>>>>>>>>>>>>>>>/// ____ _________________________
73235>>>>>>>>>>>>>>>>>/// /Total
73235>>>>>>>>>>>>>>>>>/// Records printed = _______.
73235>>>>>>>>>>>>>>>>>/// /*
73235>>>>>>>>>>>>>>>>>///
73235>>>>>>>>>>>>>>>>>///
73235>>>>>>>>>>>>>>>>>/// OPEN SALESP
73235>>>>>>>>>>>>>>>>>/// direct_output "con:"
73235>>>>>>>>>>>>>>>>>/// // Write the complete SELECT statement to retrieve the expected records from your REPORT
73235>>>>>>>>>>>>>>>>>/// // Must include the expression to qualify the required records and specify the order by as well
73235>>>>>>>>>>>>>>>>>///
73235>>>>>>>>>>>>>>>>>/// sql_set_stmt of salesp to "select recnum, id, name from SALESP where recnum > 5 order by id"
73235>>>>>>>>>>>>>>>>>/// sql_prepare_stmt of salesp
73235>>>>>>>>>>>>>>>>>/// sql_bindcolumns_stmt of salesp to salesp.recnum salesp.id salesp.name
73235>>>>>>>>>>>>>>>>>/// sql_execute_stmt of salesp
73235>>>>>>>>>>>>>>>>>///
73235>>>>>>>>>>>>>>>>>/// Report_stmt SALESP By Index.1
73235>>>>>>>>>>>>>>>>>///
73235>>>>>>>>>>>>>>>>>/// Section Header
73235>>>>>>>>>>>>>>>>>///     Sysdate Header.1
73235>>>>>>>>>>>>>>>>>///     Move PageCount to Header.2
73235>>>>>>>>>>>>>>>>>///     output header
73235>>>>>>>>>>>>>>>>>///
73235>>>>>>>>>>>>>>>>>/// Section Body
73235>>>>>>>>>>>>>>>>>///     Print Salesp.id   to Body.1
73235>>>>>>>>>>>>>>>>>///     Print Salesp.name to Body.2
73235>>>>>>>>>>>>>>>>>///     output body
73235>>>>>>>>>>>>>>>>>/// Section Total
73235>>>>>>>>>>>>>>>>>///
73235>>>>>>>>>>>>>>>>>/// Return
73235>>>>>>>>>>>>>>>>>/// ReportEnd
73235>>>>>>>>>>>>>>>>>
73235>>>>>>>>>>>>>>>>>//=============================================================================
73235>>>>>>>>>>>>>>>>>/// @Name        GET_SERVER_CFG
73235>>>>>>>>>>>>>>>>>/// @Description This command, when passed a valid server name, returns
73235>>>>>>>>>>>>>>>>>/// the a value for the specified attribute. See the list below for an
73235>>>>>>>>>>>>>>>>>/// explanation of each attribute.
73235>>>>>>>>>>>>>>>>>///
73235>>>>>>>>>>>>>>>>>/// SERVER_REVISION    Returns the major version, to the left of the decimal, of the server
73235>>>>>>>>>>>>>>>>>/// SUPPORT_DESC       Returns 1 if Server supports descending index segments
73235>>>>>>>>>>>>>>>>>/// SUPPORT_CASE       Returns 1 if Server supports case insensitive index segments
73235>>>>>>>>>>>>>>>>>/// SERVER_VERSION     Returns the full version of the server
73235>>>>>>>>>>>>>>>>>/// SERVER_ENCODING    Returns the Server Encoding
73235>>>>>>>>>>>>>>>>>/// CONNECTION_ACTIVE  Returns 1 if the connection to the server is active
73235>>>>>>>>>>>>>>>>>/// CITEXT_SUPPORT     Returns 1 if Server supports citext, a PostgreSQL data type
73235>>>>>>>>>>>>>>>>>///
73235>>>>>>>>>>>>>>>>>/// @Assumptions
73235>>>>>>>>>>>>>>>>>/// @Status      Internal
73235>>>>>>>>>>>>>>>>>/// @Drivers     All
73235>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
73235>>>>>>>>>>>>>>>>>/// @See
73235>>>>>>>>>>>>>>>>>///
73235>>>>>>>>>>>>>>>>>/// @Syntax GET_SERVER_CFG {constant} of {server} to {variable}
73235>>>>>>>>>>>>>>>>>/// @Param constant                     SERVER_REVISION,SERVER_MIN_REVISION,SUPPORT_DESC,SUPPORT_CASE,SERVER_VERSION,SERVER_ENCODING,CONNECTION_ACTIVE
73235>>>>>>>>>>>>>>>>>/// @Param server                       Name of the server being checked
73235>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the returned value
73235>>>>>>>>>>>>>>>>>///
73235>>>>>>>>>>>>>>>>>/// @Example
73235>>>>>>>>>>>>>>>>>/// GET_SERVER_CFG SERVER_VERSION of "localhost" to sVersion
73235>>>>>>>>>>>>>>>>>
73235>>>>>>>>>>>>>>>>>Function MertechInc_GET_SERVER_CFG Global String sServer Integer iAttribute Returns String
73237>>>>>>>>>>>>>>>>>    String sReturnValue
73237>>>>>>>>>>>>>>>>>
73237>>>>>>>>>>>>>>>>>    Get MertechInc_Pre_Size_String 512 to sReturnValue
73238>>>>>>>>>>>>>>>>>
73238>>>>>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_GET_SERVER_CFG CALLBACK 0 PASSING sServer sReturnValue iAttribute RESULT MertechInc_iRet
73243>>>>>>>>>>>>>>>>>
73243>>>>>>>>>>>>>>>>>    //If iAttribute = SERVER_VERSION or SERVER_ENCODING then return sReturnValue
73243>>>>>>>>>>>>>>>>>    //else we need to return MertechInc_iRet
73243>>>>>>>>>>>>>>>>>    If ((iAttribute = 4) or (iAttribute = 5)) Function_Return sReturnValue
73246>>>>>>>>>>>>>>>>>    Else                                      Function_Return MertechInc_iRet
73248>>>>>>>>>>>>>>>>>End_Function
73249>>>>>>>>>>>>>>>>>
73249>>>>>>>>>>>>>>>>>//=============================================================================
73249>>>>>>>>>>>>>>>>>/// @Name        GET_CONNECTION_STATUS
73249>>>>>>>>>>>>>>>>>/// @Description Retrieve the connection status for the specified server.
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// @Assumptions
73249>>>>>>>>>>>>>>>>>/// @Status      Internal
73249>>>>>>>>>>>>>>>>>/// @Drivers     All
73249>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-09-25 By Ian Smith
73249>>>>>>>>>>>>>>>>>/// @See
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// @Syntax GET_CONNECTION_STATUS of <serverName> [<databaseName>] to <variable>
73249>>>>>>>>>>>>>>>>>/// @Param serverName    Server Name
73249>>>>>>>>>>>>>>>>>/// @Param databaseName  Database Name
73249>>>>>>>>>>>>>>>>>/// @Param variable      DFTRUE means connection is active
73249>>>>>>>>>>>>>>>>>
73249>>>>>>>>>>>>>>>>>//=============================================================================
73249>>>>>>>>>>>>>>>>>/// @Name        GET_CLIENT_CFG
73249>>>>>>>>>>>>>>>>>/// @Description Returns the client character encoding (or encoding ID) information.
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// @Assumptions
73249>>>>>>>>>>>>>>>>>/// @Status      Internal
73249>>>>>>>>>>>>>>>>>/// @Drivers     MySQLFlex and PgFlex
73249>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-09-25 By Ian Smith
73249>>>>>>>>>>>>>>>>>/// @See
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// @Syntax GET_CLIENT_CFG [ENCODING | ENCODING_ID] of <Server> [<MySQL_Database>] to <Var>
73249>>>>>>>>>>>>>>>>>/// @Param Server           Server name to get encoding of
73249>>>>>>>>>>>>>>>>>/// @Param MySQL_Database   Database if   is the File Name
73249>>>>>>>>>>>>>>>>>/// @Param Var              Variable to hold returned value
73249>>>>>>>>>>>>>>>>>
73249>>>>>>>>>>>>>>>>>//=============================================================================
73249>>>>>>>>>>>>>>>>>/// @Name        SET_CLIENT_CFG
73249>>>>>>>>>>>>>>>>>/// @Description Returns the client character encoding (or encoding ID) information.
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// @Assumptions
73249>>>>>>>>>>>>>>>>>/// @Status      Internal
73249>>>>>>>>>>>>>>>>>/// @Drivers     MySQLFlex and PgFlex
73249>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-09-25 By Ian Smith
73249>>>>>>>>>>>>>>>>>/// @See
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// @Syntax SET_CLIENT_CFG [ENCODING | UNIQUE_CHECKS] of <Server> [<MySQL_Database>] to <Value>
73249>>>>>>>>>>>>>>>>>/// @Param Server           Server name to get encoding of
73249>>>>>>>>>>>>>>>>>/// @Param MySQL_Database   Database if   is the File Name
73249>>>>>>>>>>>>>>>>>/// @Param Value            Value to set
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// @Comment ENCODING - Set the Client Encoding
73249>>>>>>>>>>>>>>>>>/// @Comment UNIQUE_CHECKS {DFTRUE/DFFALSE} - enable/disable uniqueness checks for secondary indexes in InnoDB tables
73249>>>>>>>>>>>>>>>>>
73249>>>>>>>>>>>>>>>>>//=============================================================================
73249>>>>>>>>>>>>>>>>>/// @Name        CALL_DB2_PROCEDURE
73249>>>>>>>>>>>>>>>>>/// @Description Executes a DB2 Server stored procedure.
73249>>>>>>>>>>>>>>>>>/// @Status      Public
73249>>>>>>>>>>>>>>>>>/// @Drivers     DB2Flex
73249>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-19 By Ian Smith
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// @Syntax CALL_DB2_PROCEDURE <OWNER> <STORED_PROC> {PASSING <ARG1> {. <ARGn>}}
73249>>>>>>>>>>>>>>>>>/// @Param Owner        Name of the Procedure's Owner.
73249>>>>>>>>>>>>>>>>>/// @Param Stored_Proc  Full name of the stored procedure being called.
73249>>>>>>>>>>>>>>>>>/// @Param Arg1..Argn   Arguments passed to the procedure.
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>
73249>>>>>>>>>>>>>>>>>//=============================================================================
73249>>>>>>>>>>>>>>>>>/// @Name        GET_RESULTS
73249>>>>>>>>>>>>>>>>>/// @Description Returns the initial result set.
73249>>>>>>>>>>>>>>>>>/// @Status      Public
73249>>>>>>>>>>>>>>>>>/// @Drivers     DB2Flex
73249>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-19 By Ian Smith
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// @Syntax GET_RESULTS
73249>>>>>>>>>>>>>>>>>
73249>>>>>>>>>>>>>>>>>//=============================================================================
73249>>>>>>>>>>>>>>>>>/// @Name        GET_MORE_RESULTS
73249>>>>>>>>>>>>>>>>>/// @Description Returns remaining values not retrieved with GET_RESULT.
73249>>>>>>>>>>>>>>>>>/// @Status      Public
73249>>>>>>>>>>>>>>>>>/// @Drivers     DB2Flex
73249>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-19 By Ian Smith
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// @Syntax GET_MORE_RESULTS
73249>>>>>>>>>>>>>>>>>
73249>>>>>>>>>>>>>>>>>//=============================================================================
73249>>>>>>>>>>>>>>>>>/// @Name        GET_CURRENT_USER_NAME
73249>>>>>>>>>>>>>>>>>/// @Description This command is used to get the name of the user currently
73249>>>>>>>>>>>>>>>>>/// logged into the server.
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// @Assumptions
73249>>>>>>>>>>>>>>>>>/// @Status      Public
73249>>>>>>>>>>>>>>>>>/// @Drivers     All
73249>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
73249>>>>>>>>>>>>>>>>>/// @See                 GET_CURRENT_USER_PASSWORD
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// @Syntax GET_CURRENT_USER_NAME of {server} to {variable}
73249>>>>>>>>>>>>>>>>>/// @Param server               The name of the server the user is in
73249>>>>>>>>>>>>>>>>>/// @Param variable             Variable to hold the username
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// @Example
73249>>>>>>>>>>>>>>>>>/// GET_CURRENT_USER_NAME of "localhost" to sUserName
73249>>>>>>>>>>>>>>>>>
73249>>>>>>>>>>>>>>>>>//=============================================================================
73249>>>>>>>>>>>>>>>>>/// @Name        GET_CURRENT_USER_PASSWORD
73249>>>>>>>>>>>>>>>>>/// @Description This command is used to get the password associated with
73249>>>>>>>>>>>>>>>>>/// the user currently logged into the server.
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// @Assumptions
73249>>>>>>>>>>>>>>>>>/// @Status      Public
73249>>>>>>>>>>>>>>>>>/// @Drivers     All
73249>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
73249>>>>>>>>>>>>>>>>>/// @See                 GET_CURRENT_USER_NAME
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// @Syntax GET_CURRENT_USER_PASSWORD of {server} to {variable}
73249>>>>>>>>>>>>>>>>>/// @Param server               The name of the server the user is in
73249>>>>>>>>>>>>>>>>>/// @Param variable             Variable to hold the password
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// @Example
73249>>>>>>>>>>>>>>>>>/// GET_CURRENT_USER_PASSWORD of "localhost" to sPassword
73249>>>>>>>>>>>>>>>>>
73249>>>>>>>>>>>>>>>>>//=============================================================================
73249>>>>>>>>>>>>>>>>>/// @Name        CREATE_DB2_DATABASE
73249>>>>>>>>>>>>>>>>>/// @Description Creates a DB2 database with the same DataFlex collating sequence.
73249>>>>>>>>>>>>>>>>>/// @Status      Public
73249>>>>>>>>>>>>>>>>>/// @Drivers     All
73249>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-12 By Ian Smith
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// @Syntax CREATE_DB2_DATABASE <DB Name> <DB Alias> <Code Set> <Territory> [<Path> <Node Name> <User ID><Password>]
73249>>>>>>>>>>>>>>>>>/// @Param DB Name     Name of the database being created
73249>>>>>>>>>>>>>>>>>/// @Param DB Alias    Alias Name applied to the database being created
73249>>>>>>>>>>>>>>>>>/// @Param Code Set    Code Set used by the database being created
73249>>>>>>>>>>>>>>>>>/// @Param Territory   Territory associated to the database being created
73249>>>>>>>>>>>>>>>>>/// @Param Path        Location of the database                                    - Optional
73249>>>>>>>>>>>>>>>>>/// @Param Node Name   Name of the machine (node) where the database is to reside  - Optional
73249>>>>>>>>>>>>>>>>>/// @Param User ID     User ID owning the database                                 - Optional
73249>>>>>>>>>>>>>>>>>/// @Param Password    Password of the User owning the database                    - Optional
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>
73249>>>>>>>>>>>>>>>>>//=============================================================================
73249>>>>>>>>>>>>>>>>>/// @Name        SQL_OPEN_CURSOR_STMT
73249>>>>>>>>>>>>>>>>>/// @Description This command is used to create a new SQl Cursor. Once
73249>>>>>>>>>>>>>>>>>/// created, SQL_SET_CURRENT_CURSOR_STMT can be called to specify which
73249>>>>>>>>>>>>>>>>>/// cursor is to be used for a given SQL statement. Creating multiple
73249>>>>>>>>>>>>>>>>>/// cursors using this command allows multiple SQL statements to be
73249>>>>>>>>>>>>>>>>>/// opened at once. Optionally a different server can be specified for each
73249>>>>>>>>>>>>>>>>>/// cursor by passing the server name to this command as well. If no
73249>>>>>>>>>>>>>>>>>/// server is specified, the current server will be used. Note that it
73249>>>>>>>>>>>>>>>>>/// is important to close all cursors at the end using SQL_CLOSE_CURSOR_STMT.
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// @Assumptions
73249>>>>>>>>>>>>>>>>>/// @Status      Public
73249>>>>>>>>>>>>>>>>>/// @Drivers     All
73249>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
73249>>>>>>>>>>>>>>>>>/// @See                 SQL_CLOSE_CURSOR_STMT SQL_SET_CURRENT_CURSOR_STMT SQL_GET_CURRENT_CURSOR_STMT
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// @Syntax SQL_OPEN_CURSOR_STMT [of {server}] to {variable}
73249>>>>>>>>>>>>>>>>>/// @Param server                       Name of the server (optional)
73249>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the returned cursor handle
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// @Example
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// Integer iCursor1 iCursor2 iCustomer
73249>>>>>>>>>>>>>>>>>/// String  sName
73249>>>>>>>>>>>>>>>>>/// Number  nOrderTotal
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// SQL_OPEN_CURSOR_STMT to iCursor1
73249>>>>>>>>>>>>>>>>>/// SQL_SET_STMT         to "SELECT CUSTOMER_NUMBER,NAME FROM CUSTOMER "
73249>>>>>>>>>>>>>>>>>/// SQL_APPEND_STMT      to "ORDER BY NAME "
73249>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT
73249>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
73249>>>>>>>>>>>>>>>>>/// Repeat
73249>>>>>>>>>>>>>>>>>///     SQL_SET_CURRENT_CURSOR_STMT TO iCursor1
73249>>>>>>>>>>>>>>>>>///     SQL_FETCH_NEXT_ROW INTO iCustomer sName
73249>>>>>>>>>>>>>>>>>///     If (Found) Begin
73249>>>>>>>>>>>>>>>>>///        SQL_OPEN_CURSOR_STMT to iCursor2
73249>>>>>>>>>>>>>>>>>///        SQL_SET_STMT         to "SELECT SUM(ORDER_TOTAL) FROM ORDERHEA "
73249>>>>>>>>>>>>>>>>>///        SQL_APPEND_STMT      to ("WHERE CUSTOMER_NUMBER = " + Trim(iCustomer))
73249>>>>>>>>>>>>>>>>>///        SQL_PREPARE_STMT
73249>>>>>>>>>>>>>>>>>///        SQL_EXECUTE_STMT
73249>>>>>>>>>>>>>>>>>///        SQL_FETCH_NEXT_ROW INTO nOrderTotal
73249>>>>>>>>>>>>>>>>>///        If (Found and nOrderTotal > 0) Begin
73249>>>>>>>>>>>>>>>>>///            Showln "Customer : " iCustomer "-" sName " - Total: " nOrderTotal
73249>>>>>>>>>>>>>>>>>///        End
73249>>>>>>>>>>>>>>>>>///        SQL_CLOSE_CURSOR_STMT to Cursor2
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>///        Indicate Found True
73249>>>>>>>>>>>>>>>>>///     End
73249>>>>>>>>>>>>>>>>>/// Until (Not(Found))
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// SQL_CLOSE_CURSOR_STMT to Cursor1
73249>>>>>>>>>>>>>>>>>
73249>>>>>>>>>>>>>>>>>//=============================================================================
73249>>>>>>>>>>>>>>>>>/// @Name        SQL_CLOSE_CURSOR_STMT
73249>>>>>>>>>>>>>>>>>/// @Description This command closes the specified cursor that was created
73249>>>>>>>>>>>>>>>>>/// from SQL_OPEN_CURSOR_STMT. It is good practice to close all cursors
73249>>>>>>>>>>>>>>>>>/// once the statements associated with them are complete.
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// @Assumptions
73249>>>>>>>>>>>>>>>>>/// @Status      Public
73249>>>>>>>>>>>>>>>>>/// @Drivers     All
73249>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
73249>>>>>>>>>>>>>>>>>/// @See                 SQL_OPEN_CURSOR_STMT SQL_SET_CURRENT_CURSOR_STMT SQL_GET_CURRENT_CURSOR_STMT
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// @Syntax SQL_CLOSE_CURSOR_STMT [of {server}] to {variable}
73249>>>>>>>>>>>>>>>>>/// @Param server                       Name of the server (optional)
73249>>>>>>>>>>>>>>>>>/// @Param variable                     Cursor handle to close
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// @Example
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// SQL_OPEN_CURSOR_STMT to hCursor1
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
73249>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT
73249>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// SQL_OPEN_CURSOR_STMT to hCursor2
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Inactive' "
73249>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT
73249>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// Repeat
73249>>>>>>>>>>>>>>>>>///     SQL_SET_CURRENT_CURSOR_STMT to hCursor1
73249>>>>>>>>>>>>>>>>>///     SQL_FETCH_NEXT_ROW INTO  sID sFirstName sLastName
73249>>>>>>>>>>>>>>>>>///     If (Found) Begin
73249>>>>>>>>>>>>>>>>>///        Showln "Active : " sID "- " sFirstName sLastName
73249>>>>>>>>>>>>>>>>>///     End
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>///     SQL_SET_CURRENT_CURSOR_STMT to hCursor2
73249>>>>>>>>>>>>>>>>>///     SQL_FETCH_NEXT_ROW into sId sFirstName sLastName
73249>>>>>>>>>>>>>>>>>///     If (Found) Begin
73249>>>>>>>>>>>>>>>>>///         Showln "Inactive : " sID "- " sFirstName sLastName
73249>>>>>>>>>>>>>>>>>///     End
73249>>>>>>>>>>>>>>>>>/// Until (FindErr)
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// SQL_CLOSE_CURSOR_STMT to hCursor1
73249>>>>>>>>>>>>>>>>>/// SQL_CLOSE_CURSOR_STMT to hCursor2
73249>>>>>>>>>>>>>>>>>
73249>>>>>>>>>>>>>>>>>//=============================================================================
73249>>>>>>>>>>>>>>>>>/// @Name        SQL_SET_CURRENT_CURSOR_STMT
73249>>>>>>>>>>>>>>>>>/// @Description This command is used to open a cursor to be used for an
73249>>>>>>>>>>>>>>>>>/// SQl statement. The cursor must be created using the SQL_OPEN_CURSOR_STMT,
73249>>>>>>>>>>>>>>>>>/// but once it has been created, this command can easily switch between
73249>>>>>>>>>>>>>>>>>/// cursors as desired. Optionally a different server can be specified for each
73249>>>>>>>>>>>>>>>>>/// cursor by passing the server name to this command as well. If no
73249>>>>>>>>>>>>>>>>>/// server is specified, the current server will be used. Note that it
73249>>>>>>>>>>>>>>>>>/// is important to close all cursors at the end using SQL_CLOSE_CURSOR_STMT.
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// @Assumptions
73249>>>>>>>>>>>>>>>>>/// @Status      Public
73249>>>>>>>>>>>>>>>>>/// @Drivers     All
73249>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
73249>>>>>>>>>>>>>>>>>/// @See                 SQL_OPEN_CURSOR_STMT SQL_CLOSE_CURSOR_STMT SQL_GET_CURRENT_CURSOR_STMT
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// @Syntax SQL_SET_CURRENT_CURSOR_STMT [of {server}] to {variable}
73249>>>>>>>>>>>>>>>>>/// @Param server                       Name of the server (optional)
73249>>>>>>>>>>>>>>>>>/// @Param variable                     Cursor handle to use
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// @Example
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// SQL_OPEN_CURSOR_STMT to hCursor1
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
73249>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT
73249>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// SQL_OPEN_CURSOR_STMT to hCursor2
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Inactive' "
73249>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT
73249>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// Repeat
73249>>>>>>>>>>>>>>>>>///     SQL_SET_CURRENT_CURSOR_STMT to hCursor1
73249>>>>>>>>>>>>>>>>>///     SQL_FETCH_NEXT_ROW INTO  sID sFirstName sLastName
73249>>>>>>>>>>>>>>>>>///     If (Found) Begin
73249>>>>>>>>>>>>>>>>>///        Showln "Active : " sID "- " sFirstName sLastName
73249>>>>>>>>>>>>>>>>>///     End
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>///     SQL_SET_CURRENT_CURSOR_STMT to hCursor2
73249>>>>>>>>>>>>>>>>>///     SQL_FETCH_NEXT_ROW into sId sFirstName sLastName
73249>>>>>>>>>>>>>>>>>///     If (Found) Begin
73249>>>>>>>>>>>>>>>>>///         Showln "Inactive : " sID "- " sFirstName sLastName
73249>>>>>>>>>>>>>>>>>///     End
73249>>>>>>>>>>>>>>>>>/// Until (FindErr)
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// SQL_CLOSE_CURSOR_STMT to hCursor1
73249>>>>>>>>>>>>>>>>>/// SQL_CLOSE_CURSOR_STMT to hCursor2
73249>>>>>>>>>>>>>>>>>
73249>>>>>>>>>>>>>>>>>//=============================================================================
73249>>>>>>>>>>>>>>>>>/// @Name        SQL_GET_CURRENT_CURSOR_STMT
73249>>>>>>>>>>>>>>>>>/// @Description This command returns the current active cursor being
73249>>>>>>>>>>>>>>>>>/// used. The cursor is returned to the specified variable.
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// @Assumptions
73249>>>>>>>>>>>>>>>>>/// @Status      Public
73249>>>>>>>>>>>>>>>>>/// @Drivers     All
73249>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
73249>>>>>>>>>>>>>>>>>/// @See SQL_OPEN_CURSOR_STMT SQL_CLOSE_CURSOR_STMT SQL_SET_CURRENT_CURSOR_STMT
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// @Syntax SQL_GET_CURRENT_CURSOR_STMT [of {server}] to {variable}
73249>>>>>>>>>>>>>>>>>/// @Param server                       Name of the server (optional)
73249>>>>>>>>>>>>>>>>>/// @Param variable         Variable to hold the current cursor handle
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// @Example
73249>>>>>>>>>>>>>>>>>/// SQL_GET_CURRENT_CURSOR_STMT to hCursor
73249>>>>>>>>>>>>>>>>>
73249>>>>>>>>>>>>>>>>>//=============================================================================
73249>>>>>>>>>>>>>>>>>/// @Name        SQL_SET_MAX_CURSORS_STMT
73249>>>>>>>>>>>>>>>>>/// @Description Sets the maximum number of simultaneous cursors allowed.
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// @Assumptions
73249>>>>>>>>>>>>>>>>>/// @Status      Deprecated
73249>>>>>>>>>>>>>>>>>/// @Drivers     All
73249>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
73249>>>>>>>>>>>>>>>>>/// @See
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// @Syntax SQL_SET_MAX_CURSORS_STMT [of {server}] to {variable}
73249>>>>>>>>>>>>>>>>>/// @Param server                       Name of the server (optional)
73249>>>>>>>>>>>>>>>>>/// @Param variable                     Maximum number of cursors allowed
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// @Example
73249>>>>>>>>>>>>>>>>>/// SQL_SET_MAX_CURSORS_STMT to 50
73249>>>>>>>>>>>>>>>>>
73249>>>>>>>>>>>>>>>>>//=============================================================================
73249>>>>>>>>>>>>>>>>>/// @Name        SQL_GET_MAX_CURSORS_STMT
73249>>>>>>>>>>>>>>>>>/// @Description Retrieves the maximum number of cursors allowed.
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// @Assumptions
73249>>>>>>>>>>>>>>>>>/// @Status      Deprecated
73249>>>>>>>>>>>>>>>>>/// @Drivers     All
73249>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
73249>>>>>>>>>>>>>>>>>/// @See
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// @Syntax SQL_GET_MAX_CURSORS_STMT [of {server}] to {variable}
73249>>>>>>>>>>>>>>>>>/// @Param server                       Name of the server (optional)
73249>>>>>>>>>>>>>>>>>/// @Param variable                     Maximum number of cursors allowed
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// @Example
73249>>>>>>>>>>>>>>>>>/// SQL_GET_MAX_CURSORS_STMT to iCursors
73249>>>>>>>>>>>>>>>>>
73249>>>>>>>>>>>>>>>>>//=============================================================================
73249>>>>>>>>>>>>>>>>>/// @Name        SQL_SET_LOCAL_TD_PATH
73249>>>>>>>>>>>>>>>>>/// @Description Sets the directory where the driver will find the LOCAL TD files.
73249>>>>>>>>>>>>>>>>>/// @Status      Deprecated
73249>>>>>>>>>>>>>>>>>/// @Drivers     All
73249>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-19 By Ian Smith
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// @Syntax SQL_SET_LOCAL_TD_PATH TO <DirectoryPath|Variable>
73249>>>>>>>>>>>>>>>>>/// @Param DirectoryPath   Directory path were the TD files are to be located.
73249>>>>>>>>>>>>>>>>>
73249>>>>>>>>>>>>>>>>>//=============================================================================
73249>>>>>>>>>>>>>>>>>/// @Name        SQL_GET_LOCAL_TD_PATH
73249>>>>>>>>>>>>>>>>>/// @Description Gets the directory where the driver is looking for the LOCAL TD files.
73249>>>>>>>>>>>>>>>>>/// @Status      Deprecated
73249>>>>>>>>>>>>>>>>>/// @Drivers     All
73249>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-08-19 By Ian Smith
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// @Syntax SQL_SET_LOCAL_TD_PATH TO <DirectoryPath|Variable>
73249>>>>>>>>>>>>>>>>>/// @Param DirectoryPath   Directory path were the driver is looking
73249>>>>>>>>>>>>>>>>>
73249>>>>>>>>>>>>>>>>>//=============================================================================
73249>>>>>>>>>>>>>>>>>/// @Name        GET_DRIVER_REVISION
73249>>>>>>>>>>>>>>>>>/// @Description This command will put the current version (decimals included)
73249>>>>>>>>>>>>>>>>>/// of the driver associated with the current workspace into the specified
73249>>>>>>>>>>>>>>>>>/// variable.
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// @Assumptions
73249>>>>>>>>>>>>>>>>>/// @Status      Public
73249>>>>>>>>>>>>>>>>>/// @Drivers     All
73249>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
73249>>>>>>>>>>>>>>>>>/// @See                 GET_DRIVER_MAJOR_REVISION
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// @Syntax GET_DRIVER_REVISION to {variable}
73249>>>>>>>>>>>>>>>>>/// @Param variable                     String variable to hold the returned version
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// @Example
73249>>>>>>>>>>>>>>>>>/// GET_DRIVER_REVISION to sVersion
73249>>>>>>>>>>>>>>>>>
73249>>>>>>>>>>>>>>>>>//=============================================================================
73249>>>>>>>>>>>>>>>>>/// @Name        GET_DRIVER_MAJOR_REVISION
73249>>>>>>>>>>>>>>>>>/// @Description This command will put the current version (no decimals)
73249>>>>>>>>>>>>>>>>>/// of the driver associated with the current workspace into the specified
73249>>>>>>>>>>>>>>>>>/// variable.
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// @Assumptions
73249>>>>>>>>>>>>>>>>>/// @Status      Public
73249>>>>>>>>>>>>>>>>>/// @Drivers     All
73249>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
73249>>>>>>>>>>>>>>>>>/// @See                 GET_DRIVER_REVISION
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// @Syntax GET_DRIVER_MAJOR_REVISION to {variable}
73249>>>>>>>>>>>>>>>>>/// @Param variable                     String variable to hold the returned version
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// @Example
73249>>>>>>>>>>>>>>>>>/// GET_DRIVER_MAJOR_REVISION to sVersion
73249>>>>>>>>>>>>>>>>>
73249>>>>>>>>>>>>>>>>>//=============================================================================
73249>>>>>>>>>>>>>>>>>/// @Name        GET_DRIVER_LICENSE_EXPIRATION_TIME
73249>>>>>>>>>>>>>>>>>/// @Description This command is used to find out how long until a
73249>>>>>>>>>>>>>>>>>/// specific temporary license for a driver expires. If 0 is returned,
73249>>>>>>>>>>>>>>>>>/// then the license is not a temporary license. If -1 is returned, then
73249>>>>>>>>>>>>>>>>>/// the license has already expired. Otherwise, the number returned
73249>>>>>>>>>>>>>>>>>/// is the number of days until the license will expire.
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// @Assumptions
73249>>>>>>>>>>>>>>>>>/// @Status      Public
73249>>>>>>>>>>>>>>>>>/// @Drivers     All
73249>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 Aaron Gulack
73249>>>>>>>>>>>>>>>>>/// @See                 GET_DRIVER_LICENSE_PATH SET_DRIVER_LICENSE_EXPIRATION_WARNING
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// @Syntax GET_DRIVER_LICENSE_EXPIRATION_TIME to {variable}
73249>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the days until expiration
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// @Example
73249>>>>>>>>>>>>>>>>>/// GET_DRIVER_LICENSE_EXPIRATION_TIME to iExpire
73249>>>>>>>>>>>>>>>>>/// Showln iExpire
73249>>>>>>>>>>>>>>>>>
73249>>>>>>>>>>>>>>>>>//=============================================================================
73249>>>>>>>>>>>>>>>>>/// @Name        SET_DRIVER_LICENSE_EXPIRATION_WARNING
73249>>>>>>>>>>>>>>>>>/// @Description This command is used to set a custom warning message to
73249>>>>>>>>>>>>>>>>>/// be displayed when a temporary license for a driver is close to expiring.
73249>>>>>>>>>>>>>>>>>/// Note that since the license evaluation is done during Login and before
73249>>>>>>>>>>>>>>>>>/// any open calls, this command should be called before either of those.
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// @Assumptions
73249>>>>>>>>>>>>>>>>>/// @Status      Public
73249>>>>>>>>>>>>>>>>>/// @Drivers     All
73249>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
73249>>>>>>>>>>>>>>>>>/// @See                 GET_DRIVER_LICENSE_PATH GET_DRIVER_LICENSE_EXPIRATION_TIME
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// @Syntax SET_DRIVER_LICENSE_EXPIRATION_WARNING to {variable}
73249>>>>>>>>>>>>>>>>>/// @Param variable                     New warning message for expiring license
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// @Example
73249>>>>>>>>>>>>>>>>>/// SET_DRIVER_LICENSE_EXPIRATION_WARNING to "Your license is about to expire."
73249>>>>>>>>>>>>>>>>>/// Login "localhost" "" "" "sql_drv"
73249>>>>>>>>>>>>>>>>>
73249>>>>>>>>>>>>>>>>>//=============================================================================
73249>>>>>>>>>>>>>>>>>/// @Name        GET_DRIVER_LICENSE_PATH
73249>>>>>>>>>>>>>>>>>/// @Description This command will return the current path of the license
73249>>>>>>>>>>>>>>>>>/// associated with the driver.
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// @Assumptions
73249>>>>>>>>>>>>>>>>>/// @Status      Internal
73249>>>>>>>>>>>>>>>>>/// @Drivers     All
73249>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-01 by Aaron Gulack
73249>>>>>>>>>>>>>>>>>/// @See                 SET_DRIVER_LICENSE_EXPIRATION_WARNING GET_DRIVER_LICENSE_EXPIRATION_TIME
73249>>>>>>>>>>>>>>>>>///
73249>>>>>>>>>>>>>>>>>/// @Syntax GET_DRIVER_LICENSE_PATH to {variable}
73249>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the path of the license
73249>>>>>>>>>>>>>>>>>
73249>>>>>>>>>>>>>>>>>Function MertechInc_GET_DRIVER_LICENSE_PATH Global Returns String
73251>>>>>>>>>>>>>>>>>    String sReturnValue
73251>>>>>>>>>>>>>>>>>
73251>>>>>>>>>>>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
73277>>>>>>>>>>>>>>>>>>
73277>>>>>>>>>>>>>>>>>    If (MertechInc_FileNumber <> -1) Begin
73279>>>>>>>>>>>>>>>>>        Get MertechInc_Pre_Size_String 4096 to sReturnValue
73280>>>>>>>>>>>>>>>>>        Call_Driver 0 MertechInc_DriverName Function CALLDRV_LICENSE_ENVIRONMENT_SET CALLBACK 0 PASSING sReturnValue MertechInc_Blank CALLDRV_LICENSE_PATH RESULT MertechInc_iRet
73285>>>>>>>>>>>>>>>>>        If MertechInc_iRet EQ -1 INDICATE ERR True
73288>>>>>>>>>>>>>>>>>    End
73288>>>>>>>>>>>>>>>>>>
73288>>>>>>>>>>>>>>>>>
73288>>>>>>>>>>>>>>>>>    Function_Return sReturnValue
73289>>>>>>>>>>>>>>>>>End_Function
73290>>>>>>>>>>>>>>>>>
73290>>>>>>>>>>>>>>>>>//=============================================================================
73290>>>>>>>>>>>>>>>>>/// @Name        SET_DATABASE_PORT
73290>>>>>>>>>>>>>>>>>/// @Description This command is used to dynamically change the port
73290>>>>>>>>>>>>>>>>>/// number to use for all TCP/IP connections to the server. Note that
73290>>>>>>>>>>>>>>>>>/// the port is used for the current session only.
73290>>>>>>>>>>>>>>>>>///
73290>>>>>>>>>>>>>>>>>/// @Assumptions The port is valid and available
73290>>>>>>>>>>>>>>>>>/// @Status      Public
73290>>>>>>>>>>>>>>>>>/// @Drivers     MySQLFlex PgFlex
73290>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
73290>>>>>>>>>>>>>>>>>/// @See                 GET_DATABASE_PORT
73290>>>>>>>>>>>>>>>>>///
73290>>>>>>>>>>>>>>>>>/// @Syntax SET_DATABASE_PORT of {constant} to {variable}
73290>>>>>>>>>>>>>>>>>/// @Param constant                     MYSQL or PGSQL
73290>>>>>>>>>>>>>>>>>/// @Param variable                     Port number to use to connect to server
73290>>>>>>>>>>>>>>>>>///
73290>>>>>>>>>>>>>>>>>/// @Example
73290>>>>>>>>>>>>>>>>>/// GET_DATABASE_PORT of MYSQL to 1433
73290>>>>>>>>>>>>>>>>>
73290>>>>>>>>>>>>>>>>>//=============================================================================
73290>>>>>>>>>>>>>>>>>/// @Name        GET_DATABASE_PORT
73290>>>>>>>>>>>>>>>>>/// @Description This command returns the TCP/IP port used to connect
73290>>>>>>>>>>>>>>>>>/// to the server.
73290>>>>>>>>>>>>>>>>>///
73290>>>>>>>>>>>>>>>>>/// @Assumptions
73290>>>>>>>>>>>>>>>>>/// @Status      Public
73290>>>>>>>>>>>>>>>>>/// @Drivers     MySQLFlex PgFlex
73290>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
73290>>>>>>>>>>>>>>>>>/// @See                 SET_DATABASE_PORT
73290>>>>>>>>>>>>>>>>>///
73290>>>>>>>>>>>>>>>>>/// @Syntax GET_DATABASE_PORT of {MYSQL/PGSQL} to {variable}
73290>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the TCP/IP port number
73290>>>>>>>>>>>>>>>>>///
73290>>>>>>>>>>>>>>>>>/// @Example
73290>>>>>>>>>>>>>>>>>/// GET_DATABASE_PORT of MYSQL to iPort
73290>>>>>>>>>>>>>>>>>
73290>>>>>>>>>>>>>>>>>//=============================================================================
73290>>>>>>>>>>>>>>>>>/// @Name        GET_SERIAL_NUMBER
73290>>>>>>>>>>>>>>>>>/// @Description This command returns the serial number associated with
73290>>>>>>>>>>>>>>>>>/// the current driver's license.
73290>>>>>>>>>>>>>>>>>///
73290>>>>>>>>>>>>>>>>>/// @Assumptions
73290>>>>>>>>>>>>>>>>>/// @Status      Public
73290>>>>>>>>>>>>>>>>>/// @Drivers     All
73290>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
73290>>>>>>>>>>>>>>>>>/// @See
73290>>>>>>>>>>>>>>>>>///
73290>>>>>>>>>>>>>>>>>/// @Syntax GET_SERIAL_NUMBER to {variable}
73290>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the driver's serial number
73290>>>>>>>>>>>>>>>>>///
73290>>>>>>>>>>>>>>>>>/// @Example
73290>>>>>>>>>>>>>>>>>/// GET_SERIAL_NUMBER to iSerial
73290>>>>>>>>>>>>>>>>>
73290>>>>>>>>>>>>>>>>>//=============================================================================
73290>>>>>>>>>>>>>>>>>/// @Name        SET_DATABASE_SOCKET
73290>>>>>>>>>>>>>>>>>/// @Description This command is used to set the socket used to connect
73290>>>>>>>>>>>>>>>>>/// to the server when running an application under Linux/Unix.
73290>>>>>>>>>>>>>>>>>///
73290>>>>>>>>>>>>>>>>>/// @Assumptions
73290>>>>>>>>>>>>>>>>>/// @Status      Public
73290>>>>>>>>>>>>>>>>>/// @Drivers     MySQLFlex
73290>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
73290>>>>>>>>>>>>>>>>>/// @See                 GET_DATABASE_SOCKET
73290>>>>>>>>>>>>>>>>>///
73290>>>>>>>>>>>>>>>>>/// @Syntax SET_DATABASE_SOCKET of MYSQL to {variable}
73290>>>>>>>>>>>>>>>>>/// @Param variable                     Full name of the socket
73290>>>>>>>>>>>>>>>>>
73290>>>>>>>>>>>>>>>>>//=============================================================================
73290>>>>>>>>>>>>>>>>>/// @Name        GET_DATABASE_SOCKET
73290>>>>>>>>>>>>>>>>>/// @Description This command returns the name of the socket used to
73290>>>>>>>>>>>>>>>>>/// connect to the server when running an application under Linux/Unix.
73290>>>>>>>>>>>>>>>>>///
73290>>>>>>>>>>>>>>>>>/// @Assumptions
73290>>>>>>>>>>>>>>>>>/// @Status      Public
73290>>>>>>>>>>>>>>>>>/// @Drivers     MySQLFlex
73290>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
73290>>>>>>>>>>>>>>>>>/// @See                 SET_DATABASE_SOCKET
73290>>>>>>>>>>>>>>>>>///
73290>>>>>>>>>>>>>>>>>/// @Syntax SET_DATABASE_SOCKET of MYSQL to {variable}
73290>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the full socket name
73290>>>>>>>>>>>>>>>>>
73290>>>>>>>>>>>>>>>>>//=============================================================================
73290>>>>>>>>>>>>>>>>>/// @Name        SET_AUTHENTICATION_MODE
73290>>>>>>>>>>>>>>>>>/// @Description This command is used to control what mode the user logs
73290>>>>>>>>>>>>>>>>>/// in as. When DEFAULT is passed, the user will be logged in with the
73290>>>>>>>>>>>>>>>>>/// default privileges given to it. When SYSDBA is passed, the user will
73290>>>>>>>>>>>>>>>>>/// be logged in with the roles assigned to the sysdba user, most likely
73290>>>>>>>>>>>>>>>>>/// full control over the database.
73290>>>>>>>>>>>>>>>>>///
73290>>>>>>>>>>>>>>>>>/// @Assumptions
73290>>>>>>>>>>>>>>>>>/// @Status      Public
73290>>>>>>>>>>>>>>>>>/// @Drivers     OraFlex
73290>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-07 by Aaron Gulack
73290>>>>>>>>>>>>>>>>>/// @See
73290>>>>>>>>>>>>>>>>>///
73290>>>>>>>>>>>>>>>>>/// @Syntax SET_AUTHENTICATION_MODE of Oracle to {SYSDBA/DEFAULT}
73290>>>>>>>>>>>>>>>>>///
73290>>>>>>>>>>>>>>>>>/// @Example
73290>>>>>>>>>>>>>>>>>/// SET_AUTHENTICATION_MODE of Oracle to DEFAULT
73290>>>>>>>>>>>>>>>>>
73290>>>>>>>>>>>>>>>>>//=============================================================================
73290>>>>>>>>>>>>>>>>>/// @Name        SQL_ESCAPE_STRING
73290>>>>>>>>>>>>>>>>>/// @Description This command is used to properly escape strings before
73290>>>>>>>>>>>>>>>>>/// they are used in embedded SQL statements. This can be extremely
73290>>>>>>>>>>>>>>>>>/// important when you do not have full control of the strings being passed
73290>>>>>>>>>>>>>>>>>/// to the SQL statement as this will ensure that the strings are properly
73290>>>>>>>>>>>>>>>>>/// quoted.
73290>>>>>>>>>>>>>>>>>///
73290>>>>>>>>>>>>>>>>>/// @Assumptions
73290>>>>>>>>>>>>>>>>>/// @Status      Public
73290>>>>>>>>>>>>>>>>>/// @Drivers     All
73290>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
73290>>>>>>>>>>>>>>>>>/// @See
73290>>>>>>>>>>>>>>>>>///
73290>>>>>>>>>>>>>>>>>/// @Syntax SQL_ESCAPE_STRING of {string} to {variable}
73290>>>>>>>>>>>>>>>>>/// @Param string               The string to be escaped.
73290>>>>>>>>>>>>>>>>>/// @Param variable     Variable to hold the newly escaped string
73290>>>>>>>>>>>>>>>>>///
73290>>>>>>>>>>>>>>>>>/// @Example
73290>>>>>>>>>>>>>>>>>/// SQL_ESCAPE_STRING of "They said to me, 'hello'." to sEscaped
73290>>>>>>>>>>>>>>>>>
73290>>>>>>>>>>>>>>>>>Function SQLESCAPESTRING Global String sData Returns String
73292>>>>>>>>>>>>>>>>>    String sReturnData
73292>>>>>>>>>>>>>>>>>
73292>>>>>>>>>>>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
73318>>>>>>>>>>>>>>>>>>
73318>>>>>>>>>>>>>>>>>
73318>>>>>>>>>>>>>>>>>    If (MertechInc_FileNumber <> -1) Begin
73320>>>>>>>>>>>>>>>>>        Get MertechInc_Pre_Size_String 0 to sReturnData
73321>>>>>>>>>>>>>>>>>        Call_Driver 0 MertechInc_DriverName Function CALLDRV_ESCAPE_STRING CALLBACK 0 PASSING sData sReturnData 0 RESULT MertechInc_iRet
73326>>>>>>>>>>>>>>>>>    End
73326>>>>>>>>>>>>>>>>>>
73326>>>>>>>>>>>>>>>>>
73326>>>>>>>>>>>>>>>>>    Function_Return sReturnData
73327>>>>>>>>>>>>>>>>>End_Function
73328>>>>>>>>>>>>>>>>>
73328>>>>>>>>>>>>>>>>>//=============================================================================
73328>>>>>>>>>>>>>>>>>/// @Name        DIRECT_PATH_LOAD
73328>>>>>>>>>>>>>>>>>/// @Description
73328>>>>>>>>>>>>>>>>>///
73328>>>>>>>>>>>>>>>>>/// @Assumptions
73328>>>>>>>>>>>>>>>>>/// @Status      Internal
73328>>>>>>>>>>>>>>>>>/// @Drivers     OraFlex
73328>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-09-21 By Ian Smith
73328>>>>>>>>>>>>>>>>>/// @See
73328>>>>>>>>>>>>>>>>>
73328>>>>>>>>>>>>>>>>>//=============================================================================
73328>>>>>>>>>>>>>>>>>/// @Name        SQL_INITIALIZE_SEQUENCE
73328>>>>>>>>>>>>>>>>>/// @Description This command is used to initialize all auto increment
73328>>>>>>>>>>>>>>>>>/// columns, or sequences in Oracle, of the specified table to be the
73328>>>>>>>>>>>>>>>>>/// highest number plus one. This is useful when inserting a large amount
73328>>>>>>>>>>>>>>>>>/// of records in the table and the sequence is not being updated because
73328>>>>>>>>>>>>>>>>>/// the auto incremented column is being manually filled.
73328>>>>>>>>>>>>>>>>>///
73328>>>>>>>>>>>>>>>>>/// @Assumptions
73328>>>>>>>>>>>>>>>>>/// @Status      Public
73328>>>>>>>>>>>>>>>>>/// @Drivers     OraFlex PgFlex
73328>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
73328>>>>>>>>>>>>>>>>>/// @See
73328>>>>>>>>>>>>>>>>>///
73328>>>>>>>>>>>>>>>>>/// SQL_INITIALIZE_SEQUENCE of {FileNumber}
73328>>>>>>>>>>>>>>>>>/// @Param FileNumber                   The file number
73328>>>>>>>>>>>>>>>>>
73328>>>>>>>>>>>>>>>>>//=============================================================================
73328>>>>>>>>>>>>>>>>>/// @Name        LOB_APPEND
73328>>>>>>>>>>>>>>>>>/// @Description This command is used to append data to an existing LOB
73328>>>>>>>>>>>>>>>>>/// column in the database. When called, the data corresponding field
73328>>>>>>>>>>>>>>>>>/// in the buffer is appended to the respective column in the database.
73328>>>>>>>>>>>>>>>>>/// This can be very useful when saving data that exceeds VDF size limits
73328>>>>>>>>>>>>>>>>>/// but falls within the limits of the SQL database. Note that this command
73328>>>>>>>>>>>>>>>>>/// must write to a file that is active and locked. Also the save is handled
73328>>>>>>>>>>>>>>>>>/// within the command so no extra calls are needed to save the changes made.
73328>>>>>>>>>>>>>>>>>///
73328>>>>>>>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
73328>>>>>>>>>>>>>>>>>/// @Status      Deprecated
73328>>>>>>>>>>>>>>>>>/// @Drivers     All
73328>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
73328>>>>>>>>>>>>>>>>>/// @See                 SQL_LOB_ADD_CHUNK
73328>>>>>>>>>>>>>>>>>///
73328>>>>>>>>>>>>>>>>>/// @Syntax LOB_APPEND of {FileName} {FieldNumber}
73328>>>>>>>>>>>>>>>>>/// @Param FileName                     Name of the file containing the LOB column
73328>>>>>>>>>>>>>>>>>/// @Param FieldNumber          Number of the field being appended to
73328>>>>>>>>>>>>>>>>>///
73328>>>>>>>>>>>>>>>>>/// @Example
73328>>>>>>>>>>>>>>>>>/// Clear Customer
73328>>>>>>>>>>>>>>>>>/// Find Gt Customer By Index.1
73328>>>>>>>>>>>>>>>>>///
73328>>>>>>>>>>>>>>>>>/// Direct_Input 'C:\Mertech.xml'
73328>>>>>>>>>>>>>>>>>/// Lock
73328>>>>>>>>>>>>>>>>>///    Find Eq Customer by Recnum
73328>>>>>>>>>>>>>>>>>///
73328>>>>>>>>>>>>>>>>>///    Read_Block Customer.Comments 16384
73328>>>>>>>>>>>>>>>>>///    SQL_LOB_WRITE of Customer 13 // Customer.Comments
73328>>>>>>>>>>>>>>>>>///    Repeat
73328>>>>>>>>>>>>>>>>>///        Read_Block Customer.Comments 16384
73328>>>>>>>>>>>>>>>>>///        SQL_LOB_APPEND of Customer 13 // Customer.Comments
73328>>>>>>>>>>>>>>>>>///    Until (SeqEOF)
73328>>>>>>>>>>>>>>>>>/// Unlock
73328>>>>>>>>>>>>>>>>>///
73328>>>>>>>>>>>>>>>>>/// Close_Input
73328>>>>>>>>>>>>>>>>>/// Find Eq Customer By Recnum
73328>>>>>>>>>>>>>>>>>/// SQL_LOB_LENGTH of Customer 13 to iLength
73328>>>>>>>>>>>>>>>>>/// Showln 'Length: ' iLength
73328>>>>>>>>>>>>>>>>>
73328>>>>>>>>>>>>>>>>>
73328>>>>>>>>>>>>>>>>>//=============================================================================
73328>>>>>>>>>>>>>>>>>/// @Name        LOB_LENGTH
73328>>>>>>>>>>>>>>>>>/// @Description This command returns the length of the data in the
73328>>>>>>>>>>>>>>>>>/// specified column. This command must be used after a proper FIND to
73328>>>>>>>>>>>>>>>>>/// ensure that a valid record is in the buffer. This can be a useful
73328>>>>>>>>>>>>>>>>>/// command for checking if uploaded data exceeds size limits.
73328>>>>>>>>>>>>>>>>>///
73328>>>>>>>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
73328>>>>>>>>>>>>>>>>>/// @Status      Deprecated
73328>>>>>>>>>>>>>>>>>/// @Drivers     All
73328>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
73328>>>>>>>>>>>>>>>>>/// @See                 SQL_GET_LOB_LENGTH
73328>>>>>>>>>>>>>>>>>///
73328>>>>>>>>>>>>>>>>>/// @Syntax LOB_LENGTH of {FileName} {FieldNumber} to {variable}
73328>>>>>>>>>>>>>>>>>/// @Param FileName                     Name of the file
73328>>>>>>>>>>>>>>>>>/// @Param FieldNumber          Number of the LOB field
73328>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the length
73328>>>>>>>>>>>>>>>>>///
73328>>>>>>>>>>>>>>>>>/// @Example
73328>>>>>>>>>>>>>>>>>/// Clear Customer
73328>>>>>>>>>>>>>>>>>/// Find Gt Customer By Index.1
73328>>>>>>>>>>>>>>>>>/// SQL_LOB_LENGTH of Customer 13 to iLength
73328>>>>>>>>>>>>>>>>>/// Showln 'Length: ' iLength
73328>>>>>>>>>>>>>>>>>
73328>>>>>>>>>>>>>>>>>
73328>>>>>>>>>>>>>>>>>//=============================================================================
73328>>>>>>>>>>>>>>>>>/// @Name        LOB_READ
73328>>>>>>>>>>>>>>>>>/// @Description This command reads a chunk of data from a specified LOB
73328>>>>>>>>>>>>>>>>>/// column, moving it into its corresponding field buffer. Because the
73328>>>>>>>>>>>>>>>>>/// chunk will be moved into the field buffer, it can only be as large as
73328>>>>>>>>>>>>>>>>>/// the buffer allows. To account for this, the constants FIRST or NEXT
73328>>>>>>>>>>>>>>>>>/// are passed as well indicating whether to grab the first chunk for
73328>>>>>>>>>>>>>>>>>/// the buffer or the next. Each chunk grabbed will be as large as allowed.
73328>>>>>>>>>>>>>>>>>/// All these things considered, when reading data larger than the field
73328>>>>>>>>>>>>>>>>>/// buffer, it is good practice to perform the read in a loop, adding the
73328>>>>>>>>>>>>>>>>>/// length each time. Another optional parameter that can be passed is a
73328>>>>>>>>>>>>>>>>>/// variable that will store the length of the chunk. Note that a LOB read
73328>>>>>>>>>>>>>>>>>/// must be done after a successful find on the record.
73328>>>>>>>>>>>>>>>>>///
73328>>>>>>>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
73328>>>>>>>>>>>>>>>>>/// @Status      Deprecated
73328>>>>>>>>>>>>>>>>>/// @Drivers     All
73328>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
73328>>>>>>>>>>>>>>>>>/// @See                 SQL_GET_LOB SQL_GET_LOB_CHUNK
73328>>>>>>>>>>>>>>>>>///
73328>>>>>>>>>>>>>>>>>/// @Syntax LOB_READ of {FileName} {FieldNumber} {FIRST/NEXT} [{length}]
73328>>>>>>>>>>>>>>>>>/// @Param FileName                     Name of the file containing the LOB field
73328>>>>>>>>>>>>>>>>>/// @Param FieldNumber          Number of the field being read from
73328>>>>>>>>>>>>>>>>>/// @Param FIRST                        Reads the first chunk of data
73328>>>>>>>>>>>>>>>>>/// @Param NEXT                         Reads the next chuck of data (if larger than buffer limit)
73328>>>>>>>>>>>>>>>>>/// @Param length                       Variable to hold the chunk length (optional)
73328>>>>>>>>>>>>>>>>>///
73328>>>>>>>>>>>>>>>>>/// @Example
73328>>>>>>>>>>>>>>>>>/// Direct_Output ('binary:Mertech.pdf')
73328>>>>>>>>>>>>>>>>>///
73328>>>>>>>>>>>>>>>>>/// Clear customer
73328>>>>>>>>>>>>>>>>>/// Find Gt customer by Index.1
73328>>>>>>>>>>>>>>>>>/// SQL_LOB_LENGTH of customer 13 to liLength
73328>>>>>>>>>>>>>>>>>///
73328>>>>>>>>>>>>>>>>>/// While (liLength > 0)
73328>>>>>>>>>>>>>>>>>///     Write customer.comments
73328>>>>>>>>>>>>>>>>>///     SQL_LOB_READ of customer 13 Next liLength
73328>>>>>>>>>>>>>>>>>/// Loop
73328>>>>>>>>>>>>>>>>>///
73328>>>>>>>>>>>>>>>>>/// Close_Output
73328>>>>>>>>>>>>>>>>>
73328>>>>>>>>>>>>>>>>>
73328>>>>>>>>>>>>>>>>>//=============================================================================
73328>>>>>>>>>>>>>>>>>/// @Name        LOB_WRITE
73328>>>>>>>>>>>>>>>>>/// @Description This command is used to write data to a LOB column.
73328>>>>>>>>>>>>>>>>>/// By passing the file name and field number of the LOB column, this
73328>>>>>>>>>>>>>>>>>/// command will take the current value of the respective field in
73328>>>>>>>>>>>>>>>>>/// the field buffer, write it to the database and save it. Any data
73328>>>>>>>>>>>>>>>>>/// currently in that field will be overridden by the data from the
73328>>>>>>>>>>>>>>>>>/// buffer. Note that this command must write to a file that is active
73328>>>>>>>>>>>>>>>>>/// and locked. Also this command handles the save so no extra calls
73328>>>>>>>>>>>>>>>>>/// are needed to save the changes.
73328>>>>>>>>>>>>>>>>>///
73328>>>>>>>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
73328>>>>>>>>>>>>>>>>>/// @Status      Deprecated
73328>>>>>>>>>>>>>>>>>/// @Drivers     All
73328>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
73328>>>>>>>>>>>>>>>>>/// @See                 SQL_SET_LOB SQL_ADD_LOB_CHUNK
73328>>>>>>>>>>>>>>>>>///
73328>>>>>>>>>>>>>>>>>/// @Syntax LOB_WRITE of {FileName} {FieldNumber}
73328>>>>>>>>>>>>>>>>>/// @Param FileName                     Name of the file containing the LOB field
73328>>>>>>>>>>>>>>>>>/// @Param FieldNumber          Number of the field being written to
73328>>>>>>>>>>>>>>>>>///
73328>>>>>>>>>>>>>>>>>/// @Example
73328>>>>>>>>>>>>>>>>>/// Clear Customer
73328>>>>>>>>>>>>>>>>>/// Find Gt Customer By Index.1
73328>>>>>>>>>>>>>>>>>///
73328>>>>>>>>>>>>>>>>>/// Direct_Input 'C:\Mertech.xml'
73328>>>>>>>>>>>>>>>>>/// Lock
73328>>>>>>>>>>>>>>>>>///    Find Eq Customer by Recnum
73328>>>>>>>>>>>>>>>>>///
73328>>>>>>>>>>>>>>>>>///    Read_Block Customer.Comments 16384
73328>>>>>>>>>>>>>>>>>///    SQL_LOB_WRITE of Customer 13 // Customer.Comments
73328>>>>>>>>>>>>>>>>>///    Repeat
73328>>>>>>>>>>>>>>>>>///        Read_Block Customer.Comments 16384
73328>>>>>>>>>>>>>>>>>///        SQL_LOB_APPEND of Customer 13 // Customer.Comments
73328>>>>>>>>>>>>>>>>>///    Until (SeqEOF)
73328>>>>>>>>>>>>>>>>>/// Unlock
73328>>>>>>>>>>>>>>>>>/// Close_Input
73328>>>>>>>>>>>>>>>>>///
73328>>>>>>>>>>>>>>>>>/// Find Eq Customer By Recnum
73328>>>>>>>>>>>>>>>>>/// SQL_LOB_LENGTH of Customer 13 to iLength
73328>>>>>>>>>>>>>>>>>/// Showln 'Length: ' iLength
73328>>>>>>>>>>>>>>>>>
73328>>>>>>>>>>>>>>>>>
73328>>>>>>>>>>>>>>>>>//=============================================================================
73328>>>>>>>>>>>>>>>>>/// @Name        LOB_LOADFROMFILE
73328>>>>>>>>>>>>>>>>>/// @Description This command loads an external file into a specified LOB
73328>>>>>>>>>>>>>>>>>/// column. After specifying the file name and field number, the path and
73328>>>>>>>>>>>>>>>>>/// file must then be passed respectively. When using Oracle, instead of
73328>>>>>>>>>>>>>>>>>/// passing the directory, a directory alias must be passed. This alias
73328>>>>>>>>>>>>>>>>>/// can be created using a "CREATE DIRECTORY" statement in SQL. For more
73328>>>>>>>>>>>>>>>>>/// information on setting this directory alias, see the Oracle help.
73328>>>>>>>>>>>>>>>>>/// For other servers, the file must be a local file available to the
73328>>>>>>>>>>>>>>>>>/// application that is calling the command. Note that this command must
73328>>>>>>>>>>>>>>>>>/// write to a file that is active and locked. Also this command handles
73328>>>>>>>>>>>>>>>>>/// the save so no extra calls are needed to save the changes.
73328>>>>>>>>>>>>>>>>>///
73328>>>>>>>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
73328>>>>>>>>>>>>>>>>>/// @Status      Deprecated
73328>>>>>>>>>>>>>>>>>/// @Drivers     All
73328>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
73328>>>>>>>>>>>>>>>>>/// @See                 LOB_APPEND LOB_LENGTH LOB_WRITE LOB_READ LOB_ERASE LOB_TRUNCATE FLUSH_LOB_BUFFER
73328>>>>>>>>>>>>>>>>>///
73328>>>>>>>>>>>>>>>>>/// @Syntax LOB_LOADFROMFILE of {FileName} {FieldNumber} From {path} {file}
73328>>>>>>>>>>>>>>>>>/// @Param FileName                     Name of the file containing the LOB column
73328>>>>>>>>>>>>>>>>>/// @Param FieldNumber          Number of the LOB column being used
73328>>>>>>>>>>>>>>>>>/// @Param path                         The path of the file, excluding the file name
73328>>>>>>>>>>>>>>>>>/// @Param file                         The name of the file, including the extension
73328>>>>>>>>>>>>>>>>>///
73328>>>>>>>>>>>>>>>>>/// @Example
73328>>>>>>>>>>>>>>>>>/// Clear Customer
73328>>>>>>>>>>>>>>>>>/// Find Gt Customer By Index.1
73328>>>>>>>>>>>>>>>>>/// Lock
73328>>>>>>>>>>>>>>>>>///    Find Eq Customer by Recnum
73328>>>>>>>>>>>>>>>>>///    LOB_TRUNCATE OF customel 13 to 0 // Customer.Comments
73328>>>>>>>>>>>>>>>>>///    Saverecord Customer
73328>>>>>>>>>>>>>>>>>///    // Directory name is case sensitive.
73328>>>>>>>>>>>>>>>>>///    // Make sure the name case matches
73328>>>>>>>>>>>>>>>>>///    LOB_LOADFROMFILE OF customel 13 FROM "C:\Mertech\FilesToLoad" "Mertech.XML"
73328>>>>>>>>>>>>>>>>>/// Unlock
73328>>>>>>>>>>>>>>>>>
73328>>>>>>>>>>>>>>>>>
73328>>>>>>>>>>>>>>>>>//=============================================================================
73328>>>>>>>>>>>>>>>>>/// @Name        LOB_ERASE
73328>>>>>>>>>>>>>>>>>/// @Description This command is used to erase a portion of data from a
73328>>>>>>>>>>>>>>>>>/// LOB column. For text fields, the portion of data to be erased is
73328>>>>>>>>>>>>>>>>>/// replaced with white space, and in binary fields, with 0X0. To erase
73328>>>>>>>>>>>>>>>>>/// a portion of the data, pass the length to erase as well as the number
73328>>>>>>>>>>>>>>>>>/// to offset from. For this command to work properly, it must be done
73328>>>>>>>>>>>>>>>>>/// after a valid find. Note that the save is handled inside this command
73328>>>>>>>>>>>>>>>>>/// so no extra commands are needed to save the changes.
73328>>>>>>>>>>>>>>>>>///
73328>>>>>>>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
73328>>>>>>>>>>>>>>>>>/// @Status      Deprecated
73328>>>>>>>>>>>>>>>>>/// @Drivers     All
73328>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
73328>>>>>>>>>>>>>>>>>/// @See LOB_APPEND LOB_LENGTH LOB_WRITE LOB_READ LOB_LOADFROMFILE LOB_ERASE LOB_TRUNCATE FLUSH_LOB_BUFFER
73328>>>>>>>>>>>>>>>>>///
73328>>>>>>>>>>>>>>>>>/// @Syntax LOB_ERASE OF {FileName} {FieldNumber} {length} {offset}
73328>>>>>>>>>>>>>>>>>/// @Param FileName                     Name of the file containing the LOB column
73328>>>>>>>>>>>>>>>>>/// @Param FieldNumber          Number of the LOB column being erased
73328>>>>>>>>>>>>>>>>>/// @Param Length                       Length of chunk to erase from column
73328>>>>>>>>>>>>>>>>>/// @Param offset                       Starting position for erase
73328>>>>>>>>>>>>>>>>>///
73328>>>>>>>>>>>>>>>>>/// @Example
73328>>>>>>>>>>>>>>>>>/// Clear customer
73328>>>>>>>>>>>>>>>>>/// Find Gt customer by Recnum
73328>>>>>>>>>>>>>>>>>/// Lock
73328>>>>>>>>>>>>>>>>>/// Find Eq customer by Recnum
73328>>>>>>>>>>>>>>>>>/// LOB_LENGTH OF customer 13 to liTotalLength
73328>>>>>>>>>>>>>>>>>/// LOB_ERASE  OF customer 13    liTotalLength 1
73328>>>>>>>>>>>>>>>>>/// Unlock
73328>>>>>>>>>>>>>>>>>
73328>>>>>>>>>>>>>>>>>
73328>>>>>>>>>>>>>>>>>//=============================================================================
73328>>>>>>>>>>>>>>>>>/// @Name        LOB_TRUNCATE
73328>>>>>>>>>>>>>>>>>/// @Description This command is used to trim a LOB column down to a
73328>>>>>>>>>>>>>>>>>/// specified length. By passing the table name and column number, the
73328>>>>>>>>>>>>>>>>>/// value in the column can then be trimmed down the specified length.
73328>>>>>>>>>>>>>>>>>/// This can be a useful command for clearing out a column before entering
73328>>>>>>>>>>>>>>>>>/// new data into it. Note that this command must write to a file that is active
73328>>>>>>>>>>>>>>>>>/// and locked. Also this command handles the save so no extra calls
73328>>>>>>>>>>>>>>>>>/// are needed to save the changes. This command can be used to clear out a field before adding new data
73328>>>>>>>>>>>>>>>>>///
73328>>>>>>>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
73328>>>>>>>>>>>>>>>>>/// @Status      Deprecated
73328>>>>>>>>>>>>>>>>>/// @Drivers     All
73328>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
73328>>>>>>>>>>>>>>>>>/// @See                 LOB_APPEND LOB_LENGTH LOB_WRITE LOB_READ LOB_LOADFROMFILE LOB_ERASE FLUSH_LOB_BUFFER
73328>>>>>>>>>>>>>>>>>///
73328>>>>>>>>>>>>>>>>>/// @Syntax LOB_TRUNCATE of {FileName} {FieldNumber} to {variable}
73328>>>>>>>>>>>>>>>>>/// @Param FileName                     Name of the file
73328>>>>>>>>>>>>>>>>>/// @Param FieldNumber          The field number
73328>>>>>>>>>>>>>>>>>/// @Param length                       New length to truncate to
73328>>>>>>>>>>>>>>>>>///
73328>>>>>>>>>>>>>>>>>/// @Example
73328>>>>>>>>>>>>>>>>>/// Clear Customer
73328>>>>>>>>>>>>>>>>>/// Find Gt Customer By Index.1
73328>>>>>>>>>>>>>>>>>/// Lock
73328>>>>>>>>>>>>>>>>>///    Find Eq Customer by Recnum
73328>>>>>>>>>>>>>>>>>///    SQL_LOB_TRUNCATE of Customer 13 to 0 // Customer.Comments
73328>>>>>>>>>>>>>>>>>///    Saverecord Customer
73328>>>>>>>>>>>>>>>>>/// Unlock
73328>>>>>>>>>>>>>>>>>
73328>>>>>>>>>>>>>>>>>
73328>>>>>>>>>>>>>>>>>//=============================================================================
73328>>>>>>>>>>>>>>>>>/// @Name        FLUSH_LOB_BUFFER
73328>>>>>>>>>>>>>>>>>/// @Description This command currently serves no function.
73328>>>>>>>>>>>>>>>>>///
73328>>>>>>>>>>>>>>>>>/// @Assumptions
73328>>>>>>>>>>>>>>>>>/// @Status      Deprecated
73328>>>>>>>>>>>>>>>>>/// @Drivers     MySQLFlex
73328>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
73328>>>>>>>>>>>>>>>>>/// @See
73328>>>>>>>>>>>>>>>>>///
73328>>>>>>>>>>>>>>>>>/// @Syntax FLUSH_LOB_BUFFER of {FileName}
73328>>>>>>>>>>>>>>>>>/// @Param FileName                     Name of the file
73328>>>>>>>>>>>>>>>>>
73328>>>>>>>>>>>>>>>>>
73328>>>>>>>>>>>>>>>>>//=============================================================================
73328>>>>>>>>>>>>>>>>>/// @Name        SQL_ENABLE_RECONNECT
73328>>>>>>>>>>>>>>>>>/// @Description Allow MySql Driver to auto reconnect after a time-out.
73328>>>>>>>>>>>>>>>>>///
73328>>>>>>>>>>>>>>>>>/// Driver auto-reconnect feature handles the issue where MySQL
73328>>>>>>>>>>>>>>>>>/// will kick off a user after inactivity.
73328>>>>>>>>>>>>>>>>>///
73328>>>>>>>>>>>>>>>>>/// @Status      Deprecated
73328>>>>>>>>>>>>>>>>>/// @Drivers     MySQL
73328>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-09-11 By Ian Smith
73328>>>>>>>>>>>>>>>>>///
73328>>>>>>>>>>>>>>>>>/// @Syntax SQL_ENABLE_RECONNECT of <ServerName> to dftrue/dffalse
73328>>>>>>>>>>>>>>>>>/// @Param ServerName  Server Name.
73328>>>>>>>>>>>>>>>>>///
73328>>>>>>>>>>>>>>>>>/// @Usage SQL_ENABLE_RECONNECT Of sServerID To dftrue
73328>>>>>>>>>>>>>>>>>
73328>>>>>>>>>>>>>>>>>//=============================================================================
73328>>>>>>>>>>>>>>>>>/// @Name        CALL_MYSQL_STORED_PROCEDURE
73328>>>>>>>>>>>>>>>>>/// @Description This command is used to call a stored procedure on the SQL
73328>>>>>>>>>>>>>>>>>/// backend. To successfully call a procedure with this command, a string
73328>>>>>>>>>>>>>>>>>/// must be passed containing a valid procedure name. In addition, if the
73328>>>>>>>>>>>>>>>>>/// procedure takes any arguments, they must also be passed using the constant
73328>>>>>>>>>>>>>>>>>/// "passing" along with all of the needed arguments. If the procedure has a
73328>>>>>>>>>>>>>>>>>/// return value, then SQL_GET_FUNCTION_RETURN or SQL_FETCH_NEXT_ROW can be
73328>>>>>>>>>>>>>>>>>/// used to get the value(s). If an error is found then the indicator "Err"
73328>>>>>>>>>>>>>>>>>/// is set to true.
73328>>>>>>>>>>>>>>>>>///
73328>>>>>>>>>>>>>>>>>/// @Assumptions
73328>>>>>>>>>>>>>>>>>/// @Status      Deprecated
73328>>>>>>>>>>>>>>>>>/// @Drivers     MySQLFlex
73328>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
73328>>>>>>>>>>>>>>>>>/// @See                 CALL_STORED_PROCEDURE
73328>>>>>>>>>>>>>>>>>///
73328>>>>>>>>>>>>>>>>>/// @Syntax CALL_MYSQL_STORED_PROCEDURE {procedure} Passing {argument}
73328>>>>>>>>>>>>>>>>>/// @Param procedure            Full name of the procedure
73328>>>>>>>>>>>>>>>>>/// @Param argument                     Argument to pass (can be multiple)
73328>>>>>>>>>>>>>>>>>///
73328>>>>>>>>>>>>>>>>>/// @Example
73328>>>>>>>>>>>>>>>>>/// CALL_MYSQL_STORED_PROCEDURE "getCustomerStatus" passing sCustomerID sStatus
73328>>>>>>>>>>>>>>>>>/// SQL_GET_PROCEDURE_PARAMETER 2 to sStatus
73328>>>>>>>>>>>>>>>>>/// Showln sStatus
73328>>>>>>>>>>>>>>>>>
73328>>>>>>>>>>>>>>>>>//=============================================================================
73328>>>>>>>>>>>>>>>>>/// @Name        CALL_MYSQL_STORED_FUNCTION
73328>>>>>>>>>>>>>>>>>/// @Description This command is used to execute a function stored in MySQL.
73328>>>>>>>>>>>>>>>>>/// This is an alternative to building a function with the SQL_SET_FUNCTION_NAME,
73328>>>>>>>>>>>>>>>>>/// SQL_SET_FUNCTION_PARAMETER and SQL_FUNCTION_EXECUTE commands. This command
73328>>>>>>>>>>>>>>>>>/// builds and executes the function by setting the full function name, the
73328>>>>>>>>>>>>>>>>>/// parameter(s) to pass and the variable to hold the returned value. Note that
73328>>>>>>>>>>>>>>>>>/// this command can only return a single value so SQL_SET_FUNCTION_PARAMETER
73328>>>>>>>>>>>>>>>>>/// and SQL_SET_FUNCTION_NAME must be used when dealing with multiple return
73328>>>>>>>>>>>>>>>>>/// values.
73328>>>>>>>>>>>>>>>>>///
73328>>>>>>>>>>>>>>>>>/// @Status      Deprecated
73328>>>>>>>>>>>>>>>>>/// @Drivers     MySQLFlex
73328>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
73328>>>>>>>>>>>>>>>>>/// @See                 CALL_STORED_FUNCTION
73328>>>>>>>>>>>>>>>>>///
73328>>>>>>>>>>>>>>>>>/// @Syntax CALL_MYSQL_STORED_FUNCTION {function} Returns {variable} Passing {argument}
73328>>>>>>>>>>>>>>>>>/// @Param function                     Full name of the function
73328>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the returned value
73328>>>>>>>>>>>>>>>>>/// @Param argument                     Argument to pass (can be multiple)
73328>>>>>>>>>>>>>>>>>///
73328>>>>>>>>>>>>>>>>>/// @Example
73328>>>>>>>>>>>>>>>>>/// CALL_MYSQL_STORED_FUNCTION "getCustomerStatus" Returns sStatus passing sCustomerID
73328>>>>>>>>>>>>>>>>>/// Showln sStatus
73328>>>>>>>>>>>>>>>>>
73328>>>>>>>>>>>>>>>>>//=============================================================================
73328>>>>>>>>>>>>>>>>>/// @Name        DO_SET_ALL_FUNCTION_PARAMETERS
73328>>>>>>>>>>>>>>>>>/// @Description Sets the parameters for a MySQL stored function call.
73328>>>>>>>>>>>>>>>>>///
73328>>>>>>>>>>>>>>>>>/// @Assumptions
73328>>>>>>>>>>>>>>>>>/// @Status      Internal
73328>>>>>>>>>>>>>>>>>/// @Drivers     MySQLFlex
73328>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-09-21 By Ian Smith
73328>>>>>>>>>>>>>>>>>/// @See
73328>>>>>>>>>>>>>>>>>///
73328>>>>>>>>>>>>>>>>>/// @Syntax DO_SET_ALL_FUNCTION_PARAMETERS [sParam1 [sParam2 . sParamn]]
73328>>>>>>>>>>>>>>>>>/// @Param sParam1.n    Parameters for the stored function
73328>>>>>>>>>>>>>>>>>
73328>>>>>>>>>>>>>>>>>//=============================================================================
73328>>>>>>>>>>>>>>>>>/// @Name        GET_NO_AVAILABLE_SQLSERVERS
73328>>>>>>>>>>>>>>>>>/// @Description This command is used to get the number of available MSSQL
73328>>>>>>>>>>>>>>>>>/// servers detected in the network. When used with GET_SQLSERVER_NAME,
73328>>>>>>>>>>>>>>>>>/// all the available server names can be easily retrieved.
73328>>>>>>>>>>>>>>>>>///
73328>>>>>>>>>>>>>>>>>/// @Assumptions SQL Server Browser Service is started and firewall is configured properly
73328>>>>>>>>>>>>>>>>>/// @Status      Public
73328>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex
73328>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
73328>>>>>>>>>>>>>>>>>/// @See                 GET_SQLSERVER_NAME
73328>>>>>>>>>>>>>>>>>///
73328>>>>>>>>>>>>>>>>>/// @Syntax GET_NO_AVAILABLE_SQLSERVERS to {variable}
73328>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold number of servers
73328>>>>>>>>>>>>>>>>>///
73328>>>>>>>>>>>>>>>>>/// @Example
73328>>>>>>>>>>>>>>>>>/// GET_NO_AVAILABLE_SQLSERVERS to iServers
73328>>>>>>>>>>>>>>>>>///
73328>>>>>>>>>>>>>>>>>/// While (i <= iServers)
73328>>>>>>>>>>>>>>>>>///     GET_SQLSERVER_NAME i to sServer
73328>>>>>>>>>>>>>>>>>///     Showln sServer
73328>>>>>>>>>>>>>>>>>///     Increment i
73328>>>>>>>>>>>>>>>>>/// Loop
73328>>>>>>>>>>>>>>>>>
73328>>>>>>>>>>>>>>>>>Function SQL_AVAILABLE_SQL_SERVERS Global Returns Integer
73330>>>>>>>>>>>>>>>>>    Call_Driver 0 SQLFLEX Function CALLDRV_ENUMERATE_SERVER CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank CALLDRV_ENUMERATE_SERVER_COUNT RESULT MertechInc_iRet
73335>>>>>>>>>>>>>>>>>
73335>>>>>>>>>>>>>>>>>    Function_Return MertechInc_iRet
73336>>>>>>>>>>>>>>>>>End_Function
73337>>>>>>>>>>>>>>>>>
73337>>>>>>>>>>>>>>>>>
73337>>>>>>>>>>>>>>>>>//=============================================================================
73337>>>>>>>>>>>>>>>>>/// @Name        GET_SQLSERVER_NAME
73337>>>>>>>>>>>>>>>>>/// @Description This command returns the name of the server based on the
73337>>>>>>>>>>>>>>>>>/// specified index number. The number of servers can be retrieved from
73337>>>>>>>>>>>>>>>>>/// GET_NO_AVAILABLE_SQLSERVERS and the names can be indexed from that
73337>>>>>>>>>>>>>>>>>/// number.
73337>>>>>>>>>>>>>>>>>///
73337>>>>>>>>>>>>>>>>>/// @Assumptions SQL Server Browser Service is started and firewall is configured properly
73337>>>>>>>>>>>>>>>>>/// @Status      Public
73337>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex
73337>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
73337>>>>>>>>>>>>>>>>>/// @See                 GET_NO_AVAILABLE_SQLSERVERS
73337>>>>>>>>>>>>>>>>>///
73337>>>>>>>>>>>>>>>>>/// @Syntax SQL_AVAILABLE_SQL_SERVER_NAME {index} to {variable}
73337>>>>>>>>>>>>>>>>>/// @Param index                The numbered index name to retrieve
73337>>>>>>>>>>>>>>>>>/// @Param variable             Variable to hold the server name
73337>>>>>>>>>>>>>>>>>///
73337>>>>>>>>>>>>>>>>>/// @Example
73337>>>>>>>>>>>>>>>>>/// GET_NO_AVAILABLE_SQLSERVERS to iServers
73337>>>>>>>>>>>>>>>>>///
73337>>>>>>>>>>>>>>>>>/// While (i <= iServers)
73337>>>>>>>>>>>>>>>>>///     GET_SQLSERVER_NAME i to sServer
73337>>>>>>>>>>>>>>>>>///     Showln sServer
73337>>>>>>>>>>>>>>>>>///     Increment i
73337>>>>>>>>>>>>>>>>>/// Loop
73337>>>>>>>>>>>>>>>>>
73337>>>>>>>>>>>>>>>>>Function SQL_AVAILABLE_SQL_SERVER_NAME Global Integer iIndex Returns String
73339>>>>>>>>>>>>>>>>>    String sName
73339>>>>>>>>>>>>>>>>>
73339>>>>>>>>>>>>>>>>>    Get MertechInc_Pre_Size_String 80 to sName
73340>>>>>>>>>>>>>>>>>    Call_Driver 0 SQLFLEX Function CALLDRV_ENUMERATE_SERVER CALLBACK 0 PASSING sName iIndex CALLDRV_ENUMERATE_SERVER_SERVER RESULT MertechInc_iRet
73345>>>>>>>>>>>>>>>>>
73345>>>>>>>>>>>>>>>>>    Function_Return sName
73346>>>>>>>>>>>>>>>>>End_Function
73347>>>>>>>>>>>>>>>>>
73347>>>>>>>>>>>>>>>>>
73347>>>>>>>>>>>>>>>>>//=============================================================================
73347>>>>>>>>>>>>>>>>>/// @Name        SET_USE_ROWCOUNT_IN_TRANSACTION
73347>>>>>>>>>>>>>>>>>/// @Description Turn on / off Row_Count for specified server.
73347>>>>>>>>>>>>>>>>>/// @Status      Deprecated
73347>>>>>>>>>>>>>>>>>/// @Drivers     All
73347>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-09-21 By Ian Smith
73347>>>>>>>>>>>>>>>>>///
73347>>>>>>>>>>>>>>>>>/// @Syntax SET_USE_ROWCOUNT_IN_TRANSACTION OF <Server> To <State>
73347>>>>>>>>>>>>>>>>>/// @Param Server      Name of server to turn On / Off Row_Count
73347>>>>>>>>>>>>>>>>>/// @Param State       TRUE = turn on Row_Count  FALSE = turn off Row_Count
73347>>>>>>>>>>>>>>>>>///
73347>>>>>>>>>>>>>>>>>/// @Comment This SHOULD ALWAYS BE TURNED ON
73347>>>>>>>>>>>>>>>>>
73347>>>>>>>>>>>>>>>>>Procedure Set SQL_USE_ROWCOUNT_IN_TRANSACTIONS Global String sServer Integer iState
73349>>>>>>>>>>>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
73375>>>>>>>>>>>>>>>>>>
73375>>>>>>>>>>>>>>>>>
73375>>>>>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_USE_ROWCOUNT_IN_TRANSACTIONS CALLBACK 0 PASSING sServer iState CALLDRV_VALUE_SET RESULT MertechInc_iRet
73380>>>>>>>>>>>>>>>>>    If MertechInc_iRet EQ -1 INDICATE ERR True
73383>>>>>>>>>>>>>>>>>End_Procedure
73384>>>>>>>>>>>>>>>>>
73384>>>>>>>>>>>>>>>>>//IGS - commented out by a.n. Other
73384>>>>>>>>>>>>>>>>>//#REPLACE UseRowCountInTransactions SQL_USE_ROWCOUNT_IN_TRANSACTIONS
73384>>>>>>>>>>>>>>>>>
73384>>>>>>>>>>>>>>>>>//=============================================================================
73384>>>>>>>>>>>>>>>>>/// @Name        GET_USE_ROWCOUNT_IN_TRANSACTION
73384>>>>>>>>>>>>>>>>>/// @Description Gets the Row_Count setting for specified server.
73384>>>>>>>>>>>>>>>>>/// @Status      Deprecated
73384>>>>>>>>>>>>>>>>>/// @Drivers     All
73384>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2009-09-21 By Ian Smith
73384>>>>>>>>>>>>>>>>>///
73384>>>>>>>>>>>>>>>>>/// @Syntax GET_USE_ROWCOUNT_IN_TRANSACTION OF <Server> To <State>
73384>>>>>>>>>>>>>>>>>/// @Param Server      Name of server to get Row_Count state of
73384>>>>>>>>>>>>>>>>>/// @Param State       Variable to hold returned value
73384>>>>>>>>>>>>>>>>>
73384>>>>>>>>>>>>>>>>>Function SQL_USE_ROWCOUNT_IN_TRANSACTIONS Global String sServer Returns Integer
73386>>>>>>>>>>>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
73412>>>>>>>>>>>>>>>>>>
73412>>>>>>>>>>>>>>>>>
73412>>>>>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_USE_ROWCOUNT_IN_TRANSACTIONS CALLBACK 0 PASSING sServer MertechInc_Blank CALLDRV_VALUE_GET RESULT MertechInc_iRet
73417>>>>>>>>>>>>>>>>>
73417>>>>>>>>>>>>>>>>>    Function_Return MertechInc_iRet
73418>>>>>>>>>>>>>>>>>End_Function
73419>>>>>>>>>>>>>>>>>
73419>>>>>>>>>>>>>>>>>
73419>>>>>>>>>>>>>>>>>//=============================================================================
73419>>>>>>>>>>>>>>>>>/// @Name        SQL_SET_DATE_FORMAT
73419>>>>>>>>>>>>>>>>>/// @Description This command controls the date format of data returned
73419>>>>>>>>>>>>>>>>>/// through embedded SQL. If set to DATAFLEX, then the dates will be
73419>>>>>>>>>>>>>>>>>/// returned in whatever format is set in DF_DATE_FORMAT. When set to
73419>>>>>>>>>>>>>>>>>/// NATIVE, this command will force dates to return dates in the format
73419>>>>>>>>>>>>>>>>>/// specified on the SQL server. Note that in order for the variables to
73419>>>>>>>>>>>>>>>>>/// be in the right form, they need to be string variables.
73419>>>>>>>>>>>>>>>>>///
73419>>>>>>>>>>>>>>>>>/// @Assumptions
73419>>>>>>>>>>>>>>>>>/// @Status      Public
73419>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex
73419>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-02 by Aaron Gulack
73419>>>>>>>>>>>>>>>>>/// @See
73419>>>>>>>>>>>>>>>>>///
73419>>>>>>>>>>>>>>>>>/// @Syntax SQL_SET_DATE_FORMAT to {DATAFLEX/NATIVE}
73419>>>>>>>>>>>>>>>>>///
73419>>>>>>>>>>>>>>>>>/// @Example
73419>>>>>>>>>>>>>>>>>/// SQL_SET_DATE_FORMAT to NATIVE
73419>>>>>>>>>>>>>>>>>
73419>>>>>>>>>>>>>>>>>Procedure Set SQL_USE_DATAFLEX_DATEFORMAT Global Integer iState
73421>>>>>>>>>>>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
73447>>>>>>>>>>>>>>>>>>
73447>>>>>>>>>>>>>>>>>
73447>>>>>>>>>>>>>>>>>    If MertechInc_DriverName eq SQLFlex Begin
73449>>>>>>>>>>>>>>>>>        Call_Driver 0 MertechInc_DriverName Function CALLDRV_USE_DFLEX_DATE_FORMAT CALLBACK 0 PASSING iState MertechInc_Blank CALLDRV_VALUE_SET RESULT MertechInc_iRet
73454>>>>>>>>>>>>>>>>>        IF MertechInc_iRet EQ -1 INDICATE ERR TRUE
73457>>>>>>>>>>>>>>>>>    End
73457>>>>>>>>>>>>>>>>>>
73457>>>>>>>>>>>>>>>>>End_Procedure
73458>>>>>>>>>>>>>>>>>
73458>>>>>>>>>>>>>>>>>Function SQL_USE_DATAFLEX_DATEFORMAT Global Returns Integer
73460>>>>>>>>>>>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
73486>>>>>>>>>>>>>>>>>>
73486>>>>>>>>>>>>>>>>>
73486>>>>>>>>>>>>>>>>>    If MertechInc_DriverName eq SQLFlex Begin
73488>>>>>>>>>>>>>>>>>        CALL_DRIVER 0 MertechInc_DriverName FUNCTION CALLDRV_USE_DFLEX_DATE_FORMAT CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank CALLDRV_VALUE_GET RESULT MertechInc_iRet
73493>>>>>>>>>>>>>>>>>    End
73493>>>>>>>>>>>>>>>>>>
73493>>>>>>>>>>>>>>>>>    Else Move DFFALSE to MertechInc_iRet
73495>>>>>>>>>>>>>>>>>
73495>>>>>>>>>>>>>>>>>    function_return MertechInc_iRet
73496>>>>>>>>>>>>>>>>>End_Function
73497>>>>>>>>>>>>>>>>>
73497>>>>>>>>>>>>>>>>>
73497>>>>>>>>>>>>>>>>>//=============================================================================
73497>>>>>>>>>>>>>>>>>/// @Name        SET_FIELDS_NOT_NULL
73497>>>>>>>>>>>>>>>>>/// @Description This command is used to specify how to handle blank
73497>>>>>>>>>>>>>>>>>/// and zero values on the SQL backend. Since blank or zero values can
73497>>>>>>>>>>>>>>>>>/// often be stored as null in the server database, this command allows
73497>>>>>>>>>>>>>>>>>/// that to be altered if needed. When set to true, a value will be
73497>>>>>>>>>>>>>>>>>/// inserted into blank records to keep them from being null. See the
73497>>>>>>>>>>>>>>>>>/// list below for what value will be stored instead of null. If set to
73497>>>>>>>>>>>>>>>>>/// false, values will be stored normally in the database. Note that this
73497>>>>>>>>>>>>>>>>>/// command effects all data types.
73497>>>>>>>>>>>>>>>>>///
73497>>>>>>>>>>>>>>>>>/// DF_ASCII and DF_TEXT -              ' ' (one blank space)
73497>>>>>>>>>>>>>>>>>///
73497>>>>>>>>>>>>>>>>>/// DF_BCD -                                    0 (zero)
73497>>>>>>>>>>>>>>>>>///
73497>>>>>>>>>>>>>>>>>/// DF_DATe and DF_DATETIME -   00/00/0000 for MYSQL
73497>>>>>>>>>>>>>>>>>///                                                             01/01/0001 for Oracle MSSQL, and Postgre
73497>>>>>>>>>>>>>>>>>///                                                             01/01/1753 for MSSQL Datetimes
73497>>>>>>>>>>>>>>>>>///
73497>>>>>>>>>>>>>>>>>/// DF_BINARY -                                 0X0
73497>>>>>>>>>>>>>>>>>///
73497>>>>>>>>>>>>>>>>>/// @Assumptions
73497>>>>>>>>>>>>>>>>>/// @Status      Public
73497>>>>>>>>>>>>>>>>>/// @Drivers     All
73497>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
73497>>>>>>>>>>>>>>>>>/// @See                 SET_FIELDS_NULL GET_FIELDS_NULL
73497>>>>>>>>>>>>>>>>>///
73497>>>>>>>>>>>>>>>>>/// @Syntax SET_FIELDS_NOT_NULL to {variable}
73497>>>>>>>>>>>>>>>>>/// @Param variable             Boolean variable to indicate how to handle null values
73497>>>>>>>>>>>>>>>>>///
73497>>>>>>>>>>>>>>>>>
73497>>>>>>>>>>>>>>>>>Procedure Set SQL_FORCE_FIELDS_NOT_NULL Global Integer iState
73499>>>>>>>>>>>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
73525>>>>>>>>>>>>>>>>>>
73525>>>>>>>>>>>>>>>>>
73525>>>>>>>>>>>>>>>>>    If (MertechInc_FileNumber <> -1) Begin
73527>>>>>>>>>>>>>>>>>        Call_Driver 0 MertechInc_DriverName Function CALLDRV_FORCE_FIELDS_NOT_NULL CALLBACK 0 PASSING iState MertechInc_Blank CALLDRV_VALUE_SET RESULT MertechInc_iRet
73532>>>>>>>>>>>>>>>>>        If MertechInc_iRet EQ -1 INDICATE ERR True
73535>>>>>>>>>>>>>>>>>    End
73535>>>>>>>>>>>>>>>>>>
73535>>>>>>>>>>>>>>>>>End_Procedure
73536>>>>>>>>>>>>>>>>>
73536>>>>>>>>>>>>>>>>>
73536>>>>>>>>>>>>>>>>>
73536>>>>>>>>>>>>>>>>>
73536>>>>>>>>>>>>>>>>>Function SQL_FORCE_FIELDS_NOT_NULL Global Returns Integer
73538>>>>>>>>>>>>>>>>>    DO_GETFILENUMBER_DRIVERNAME 0
73564>>>>>>>>>>>>>>>>>>
73564>>>>>>>>>>>>>>>>>
73564>>>>>>>>>>>>>>>>>    If (MertechInc_FileNumber <> -1) Begin
73566>>>>>>>>>>>>>>>>>        Call_Driver 0 MertechInc_DriverName Function CALLDRV_FORCE_FIELDS_NOT_NULL CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank CALLDRV_VALUE_GET RESULT MertechInc_iRet
73571>>>>>>>>>>>>>>>>>    End
73571>>>>>>>>>>>>>>>>>>
73571>>>>>>>>>>>>>>>>>    Else Move DFFALSE to MertechInc_iRet
73573>>>>>>>>>>>>>>>>>
73573>>>>>>>>>>>>>>>>>    Function_Return MertechInc_iRet
73574>>>>>>>>>>>>>>>>>End_Function
73575>>>>>>>>>>>>>>>>>
73575>>>>>>>>>>>>>>>>>
73575>>>>>>>>>>>>>>>>>//=============================================================================
73575>>>>>>>>>>>>>>>>>/// @Name        SET_FIELDS_NULL
73575>>>>>>>>>>>>>>>>>/// @Description This command is used to specify how to store blank or zero
73575>>>>>>>>>>>>>>>>>/// values in the database. Since database can sometimes store these value,
73575>>>>>>>>>>>>>>>>>/// i.e. '' or 0, as null, using this command can be useful in managing that.
73575>>>>>>>>>>>>>>>>>/// When set to true, any value in a column of the given type considered blank
73575>>>>>>>>>>>>>>>>>/// or 0 will be stored as null in the database. Setting it to false will cause
73575>>>>>>>>>>>>>>>>>/// the server to save as it normally would. Note that this command is used to
73575>>>>>>>>>>>>>>>>>/// set specific data types only, it can not effect all types at once. Below is
73575>>>>>>>>>>>>>>>>>/// a list of value that would be considered blank/zero values.
73575>>>>>>>>>>>>>>>>>///
73575>>>>>>>>>>>>>>>>>/// DF_ASCII and DF_TEXT -              ' ' (one blank space)
73575>>>>>>>>>>>>>>>>>///
73575>>>>>>>>>>>>>>>>>/// DF_BCD -                                    0 (zero)
73575>>>>>>>>>>>>>>>>>///
73575>>>>>>>>>>>>>>>>>/// DF_DATe and DF_DATETIME -   00/00/0000 for MYSQL
73575>>>>>>>>>>>>>>>>>///                                                             01/01/0001 for Oracle MSSQL, and Postgre
73575>>>>>>>>>>>>>>>>>///                                                             01/01/1753 for MSSQL Datetimes
73575>>>>>>>>>>>>>>>>>///
73575>>>>>>>>>>>>>>>>>/// DF_BINARY -                                 0X0
73575>>>>>>>>>>>>>>>>>///
73575>>>>>>>>>>>>>>>>>/// @Assumptions
73575>>>>>>>>>>>>>>>>>/// @Status      Public
73575>>>>>>>>>>>>>>>>>/// @Drivers     All
73575>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
73575>>>>>>>>>>>>>>>>>/// @See                 GET_FIELDS_NULL SET_FIELDS_NOT_NULL
73575>>>>>>>>>>>>>>>>>///
73575>>>>>>>>>>>>>>>>>/// @Syntax SET_FIELDS_NULL {datatype} to {variable}
73575>>>>>>>>>>>>>>>>>/// @Param datatype                     DF_ASCII, DF_BCD, or DF_DATE
73575>>>>>>>>>>>>>>>>>/// @Param variable             Boolean to indicate how to handle blank data
73575>>>>>>>>>>>>>>>>>
73575>>>>>>>>>>>>>>>>>
73575>>>>>>>>>>>>>>>>>//=============================================================================
73575>>>>>>>>>>>>>>>>>/// @Name        GET_FIELDS_NULL
73575>>>>>>>>>>>>>>>>>/// @Description This command will return the value of SET_FIELDS_NULL for
73575>>>>>>>>>>>>>>>>>/// the specified data type.
73575>>>>>>>>>>>>>>>>>///
73575>>>>>>>>>>>>>>>>>/// @Assumptions
73575>>>>>>>>>>>>>>>>>/// @Status      Public
73575>>>>>>>>>>>>>>>>>/// @Drivers     All
73575>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-08 by Aaron Gulack
73575>>>>>>>>>>>>>>>>>/// @See                 SET_FIELDS_NULL SET_FIELDS_NOT_NULL
73575>>>>>>>>>>>>>>>>>///
73575>>>>>>>>>>>>>>>>>/// @Syntax GET_FIELDS_NULL {datatype} to {variable}
73575>>>>>>>>>>>>>>>>>/// @Param datatype                     DF_ASCII, DF_BCD, or DF_DATE
73575>>>>>>>>>>>>>>>>>/// @Param variable             Variable to hold the value of SET_FIELDS_NULL
73575>>>>>>>>>>>>>>>>>
73575>>>>>>>>>>>>>>>>>
73575>>>>>>>>>>>>>>>>>//=============================================================================
73575>>>>>>>>>>>>>>>>>/// @Name        STRUCTURE_START_DYNAMIC
73575>>>>>>>>>>>>>>>>>/// @Description This command is used when scripting structural changes.
73575>>>>>>>>>>>>>>>>>/// It is the same as using ENABLE_SCRIPTING and Structure_Start separately.
73575>>>>>>>>>>>>>>>>>/// It allows structural changes to be compiled and tested without
73575>>>>>>>>>>>>>>>>>/// actually making any of the changes. Any table restructuring done
73575>>>>>>>>>>>>>>>>>/// between this command and STRUCTURE_END_DYNAMIC will not actually be
73575>>>>>>>>>>>>>>>>>/// committed but will instead create a mock INT file. The script and
73575>>>>>>>>>>>>>>>>>/// INT file can then be retrieved and examined for testing purposes.
73575>>>>>>>>>>>>>>>>>///
73575>>>>>>>>>>>>>>>>>/// @Assumptions
73575>>>>>>>>>>>>>>>>>/// @Status      Deprecated
73575>>>>>>>>>>>>>>>>>/// @Drivers     All
73575>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
73575>>>>>>>>>>>>>>>>>/// @See                 ENABLE_SCRIPTING DISABLE_SCRIPTING
73575>>>>>>>>>>>>>>>>>///
73575>>>>>>>>>>>>>>>>>/// @Syntax STRUCTURE_START_DYNAMIC of {FileNumber}
73575>>>>>>>>>>>>>>>>>/// @Param FileNumber                   The number of the file
73575>>>>>>>>>>>>>>>>>
73575>>>>>>>>>>>>>>>>>//=============================================================================
73575>>>>>>>>>>>>>>>>>/// @Name        STRUCTURE_END_DYNAMIC
73575>>>>>>>>>>>>>>>>>/// @Description This command ends the scripting started by
73575>>>>>>>>>>>>>>>>>/// STRUCTURE_START_DYNAMIC. It is the same as calling Structure_End
73575>>>>>>>>>>>>>>>>>/// and DISABLE_SCRIPTING separately.
73575>>>>>>>>>>>>>>>>>///
73575>>>>>>>>>>>>>>>>>/// @Assumptions
73575>>>>>>>>>>>>>>>>>/// @Status      Deprecated
73575>>>>>>>>>>>>>>>>>/// @Drivers     All
73575>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
73575>>>>>>>>>>>>>>>>>/// @See                 ENABLE_SCRIPTING DISABLE_SCRIPTING
73575>>>>>>>>>>>>>>>>>///
73575>>>>>>>>>>>>>>>>>/// @Syntax STRUCTURE_START_DYNAMIC of {FileNumber}
73575>>>>>>>>>>>>>>>>>/// @Param FileNumber                   The number of the file
73575>>>>>>>>>>>>>>>>>
73575>>>>>>>>>>>>>>>>>//=============================================================================
73575>>>>>>>>>>>>>>>>>/// @Name        SQLSERVER_ATTACH_DB
73575>>>>>>>>>>>>>>>>>/// @Description Attachs an MS SQL mdf to the current server instance. If
73575>>>>>>>>>>>>>>>>>/// the passed database is already attached, no error is generated.
73575>>>>>>>>>>>>>>>>>///
73575>>>>>>>>>>>>>>>>>/// The SQLSERVER_ATTACH_DB command is intended for use with our new support
73575>>>>>>>>>>>>>>>>>/// of Microsoft LocalDB's.  When using LocalDB's a common use case might be
73575>>>>>>>>>>>>>>>>>/// to attach to a customer DB, do some work on it, and then detach this DB
73575>>>>>>>>>>>>>>>>>/// and attach to a different DB.  This was possible using stored procedures,
73575>>>>>>>>>>>>>>>>>/// but the code had some complexities that a developer need not worry about.
73575>>>>>>>>>>>>>>>>>/// When you attach a database, you must pass the database name, along with
73575>>>>>>>>>>>>>>>>>/// the path to an MDF file which contains the database.  Any associated LDF's
73575>>>>>>>>>>>>>>>>>/// (log files) and NDF's (secondary data files) must be in the same folder.
73575>>>>>>>>>>>>>>>>>///
73575>>>>>>>>>>>>>>>>>/// If you call SQLSERVER_ATTACH_DB on a database that is already attached,
73575>>>>>>>>>>>>>>>>>/// no error will be generated.  After you call SQLSERVER_ATTACH_DB, you
73575>>>>>>>>>>>>>>>>>/// should call SET_DATABASE_NAME if you wish to make the attached database
73575>>>>>>>>>>>>>>>>>/// the currently selected database.
73575>>>>>>>>>>>>>>>>>///
73575>>>>>>>>>>>>>>>>>/// SQLSERVER_ATTACH_DB will work on all supported version of SQL server.
73575>>>>>>>>>>>>>>>>>///
73575>>>>>>>>>>>>>>>>>/// @Assumptions
73575>>>>>>>>>>>>>>>>>/// @Status      Public
73575>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex
73575>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 Aaron Gulack
73575>>>>>>>>>>>>>>>>>/// @See
73575>>>>>>>>>>>>>>>>>///
73575>>>>>>>>>>>>>>>>>/// @Syntax SQLSERVER_ATTACH_DB {database} on {filePath}
73575>>>>>>>>>>>>>>>>>/// @Param database                     Name of the database
73575>>>>>>>>>>>>>>>>>/// @Param filePath                     Path of the MDF file
73575>>>>>>>>>>>>>>>>>///
73575>>>>>>>>>>>>>>>>>/// @Example
73575>>>>>>>>>>>>>>>>>/// SQLSERVER_ATTACH_DB "MTSample" ON "C:\Mertech\Data\SampleDb.mdf"
73575>>>>>>>>>>>>>>>>>
73575>>>>>>>>>>>>>>>>>//=============================================================================
73575>>>>>>>>>>>>>>>>>/// @Name        SQLSERVER_DETACH_DB
73575>>>>>>>>>>>>>>>>>/// @Description The SQLSERVER_DETACH_DB command is intended for use with our
73575>>>>>>>>>>>>>>>>>/// new support of Microsoft LocalDB's.  When using LocalDB's a common use
73575>>>>>>>>>>>>>>>>>/// case might be to attach to a customer DB, do some work on it, and then
73575>>>>>>>>>>>>>>>>>/// detach this DB and attach to a different DB.  This was possible using
73575>>>>>>>>>>>>>>>>>/// stored procedures, but the code had some complexities that a developer
73575>>>>>>>>>>>>>>>>>/// need not worry about.  A detach can only be done if the database passed
73575>>>>>>>>>>>>>>>>>/// has no open connections.  As part of the detach process, the command
73575>>>>>>>>>>>>>>>>>/// closes ALL open files (even those not associated with this database or
73575>>>>>>>>>>>>>>>>>/// driver).
73575>>>>>>>>>>>>>>>>>///
73575>>>>>>>>>>>>>>>>>/// NOTE: SQLSERVER_DETACH_DB will often fail to execute if you are testing
73575>>>>>>>>>>>>>>>>>/// your application from the studio.  This is because the studio itself
73575>>>>>>>>>>>>>>>>>/// normally has open connections to the database.  If you test your
73575>>>>>>>>>>>>>>>>>/// application outside of the studio and the studio is closed (and any
73575>>>>>>>>>>>>>>>>>/// other application or tools that access this database are closed) you
73575>>>>>>>>>>>>>>>>>/// can successfully detach the database.
73575>>>>>>>>>>>>>>>>>///
73575>>>>>>>>>>>>>>>>>/// @Assumptions
73575>>>>>>>>>>>>>>>>>/// @Status      Public
73575>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex
73575>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
73575>>>>>>>>>>>>>>>>>/// @See
73575>>>>>>>>>>>>>>>>>///
73575>>>>>>>>>>>>>>>>>/// @Syntax SQLSERVER_DETACH_DB {database}
73575>>>>>>>>>>>>>>>>>/// @Param database                     Name of the database
73575>>>>>>>>>>>>>>>>>///
73575>>>>>>>>>>>>>>>>>/// @Example
73575>>>>>>>>>>>>>>>>>/// SQLSERVER_DETACH_DB "TestDB"
73575>>>>>>>>>>>>>>>>>
73575>>>>>>>>>>>>>>>>>//=============================================================================
73575>>>>>>>>>>>>>>>>>/// @Name        SET_FIXED_FILE_RECORDS_USED
73575>>>>>>>>>>>>>>>>>/// @Description This command is used to set DF_FILE_RECORDS_USED to a
73575>>>>>>>>>>>>>>>>>/// fixed value. This can be useful because doing a SELECT COUNT(*) is
73575>>>>>>>>>>>>>>>>>/// a very expensive process to the server. Many applications do counts
73575>>>>>>>>>>>>>>>>>/// often and using this command can help cut down the server traffic.
73575>>>>>>>>>>>>>>>>>/// Sometimes when counts are used, an exact number is not necessary so
73575>>>>>>>>>>>>>>>>>/// a fixed value, updated occasionally can be used. By setting this
73575>>>>>>>>>>>>>>>>>/// command to 0 or greater, the value of DF_FILE_RECORDS_USED will be
73575>>>>>>>>>>>>>>>>>/// set to that specified value and the internal SELECT COUNT(*) will be
73575>>>>>>>>>>>>>>>>>/// suppressed. If this command is set to something less that zero,
73575>>>>>>>>>>>>>>>>>/// DF_FILE_RECORDS_USED will be dynamically calculated whenever it is
73575>>>>>>>>>>>>>>>>>/// called.
73575>>>>>>>>>>>>>>>>>///
73575>>>>>>>>>>>>>>>>>/// The default value for this command is -1
73575>>>>>>>>>>>>>>>>>///
73575>>>>>>>>>>>>>>>>>/// @Assumptions
73575>>>>>>>>>>>>>>>>>/// @Status              Public
73575>>>>>>>>>>>>>>>>>/// @Drivers     All
73575>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
73575>>>>>>>>>>>>>>>>>/// @See                 GET_FIXED_FILE_RECORDS_USED SUPPRESS_SELECT_COUNT UNSUPPRESS_SELECT_COUNT
73575>>>>>>>>>>>>>>>>>///
73575>>>>>>>>>>>>>>>>>/// @Syntax SET_FIXED_FILE_RECORDS_USED to {variable}
73575>>>>>>>>>>>>>>>>>/// @Param variable                     Fixed value for DF_FILE_RECORDS_USED
73575>>>>>>>>>>>>>>>>>///
73575>>>>>>>>>>>>>>>>>/// @Example
73575>>>>>>>>>>>>>>>>>/// SET_FIXED_FILE_RECORDS_USED to 10000
73575>>>>>>>>>>>>>>>>>
73575>>>>>>>>>>>>>>>>>//=============================================================================
73575>>>>>>>>>>>>>>>>>/// @Name        GET_FIXED_FILE_RECORDS_USED
73575>>>>>>>>>>>>>>>>>/// @Description This command returns the value of DF_FILE_RECORDS_USED
73575>>>>>>>>>>>>>>>>>/// if it has been set to a fixed value by SET_FIXED_FILE_RECORDS_USED.
73575>>>>>>>>>>>>>>>>>/// If anything greater than or equal to 0 is returned then that is the
73575>>>>>>>>>>>>>>>>>/// fixed value returned by any SELECT COUNT(*) statements, internal or
73575>>>>>>>>>>>>>>>>>/// not. If something less than zero is returned, then DF_FILE_RECORDS_USED
73575>>>>>>>>>>>>>>>>>/// returns a dynamic count whenever it is called.
73575>>>>>>>>>>>>>>>>>///
73575>>>>>>>>>>>>>>>>>/// By default the value of this is -1
73575>>>>>>>>>>>>>>>>>///
73575>>>>>>>>>>>>>>>>>/// @Assumptions
73575>>>>>>>>>>>>>>>>>/// @Status              Public
73575>>>>>>>>>>>>>>>>>/// @Drivers     All
73575>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
73575>>>>>>>>>>>>>>>>>/// @See                 SET_FIXED_FILE_RECORDS_USED SUPPRESS_SELECT_COUNT UNSUPPRESS_SELECT_COUNT
73575>>>>>>>>>>>>>>>>>///
73575>>>>>>>>>>>>>>>>>/// @Syntax GET_FILE_RECORDS_USED to {variable}
73575>>>>>>>>>>>>>>>>>/// @Param variable                     Variable to hold the fixed value
73575>>>>>>>>>>>>>>>>>///
73575>>>>>>>>>>>>>>>>>/// @Example
73575>>>>>>>>>>>>>>>>>/// GET_FIXED_FILE_RECORDS_USED to iRecords
73575>>>>>>>>>>>>>>>>>
73575>>>>>>>>>>>>>>>>>//=============================================================================
73575>>>>>>>>>>>>>>>>>/// @Name        SUPPRESS_SELECT_COUNT
73575>>>>>>>>>>>>>>>>>/// @Description This command sets the value of DF_FILE_RECORDS_USED to
73575>>>>>>>>>>>>>>>>>/// a fixed value of zero. That way anytime a SELECT COUNT(*) is done,
73575>>>>>>>>>>>>>>>>>/// zero is returned, cutting down on server traffic. This is the same
73575>>>>>>>>>>>>>>>>>/// as setting SET_FIXED_FILE_RECORDS_USED to 0.
73575>>>>>>>>>>>>>>>>>///
73575>>>>>>>>>>>>>>>>>/// @Assumptions
73575>>>>>>>>>>>>>>>>>/// @Status      Public
73575>>>>>>>>>>>>>>>>>/// @Drivers     All
73575>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
73575>>>>>>>>>>>>>>>>>/// @See                 UNSUPPRESS_SELECT_COUNT SET_FIXED_FILE_RECORDS_USED GET_FIXED_FILE_RECORDS_USED
73575>>>>>>>>>>>>>>>>>///
73575>>>>>>>>>>>>>>>>>/// @Syntax SUPPRESS_SELECT_COUNT
73575>>>>>>>>>>>>>>>>>
73575>>>>>>>>>>>>>>>>>//=============================================================================
73575>>>>>>>>>>>>>>>>>/// @Name        UNSUPPRESS_SELECT_COUNT
73575>>>>>>>>>>>>>>>>>/// @Description This command resets the value of DF_FILE_RECORDS_USED to
73575>>>>>>>>>>>>>>>>>/// -1. That way anytime a SELECT COUNT(*) is done, it returns the actual
73575>>>>>>>>>>>>>>>>>/// count of records. This is the same as setting SET_FIXED_FILE_RECORDS_USED
73575>>>>>>>>>>>>>>>>>/// to -1.
73575>>>>>>>>>>>>>>>>>///
73575>>>>>>>>>>>>>>>>>/// @Assumptions
73575>>>>>>>>>>>>>>>>>/// @Status      Public
73575>>>>>>>>>>>>>>>>>/// @Drivers     All
73575>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2013-10-09 by Aaron Gulack
73575>>>>>>>>>>>>>>>>>/// @See                 SUPPRESS_SELECT_COUNT SET_FIXED_FILE_RECORDS_USED GET_FIXED_FILE_RECORDS_USED
73575>>>>>>>>>>>>>>>>>///
73575>>>>>>>>>>>>>>>>>/// @Syntax UNSUPPRESS_SELECT_COUNT
73575>>>>>>>>>>>>>>>>>
73575>>>>>>>>>>>>>>>>>//=============================================================================
73575>>>>>>>>>>>>>>>>>/// @Name        SET_CONNECTION_OPTION
73575>>>>>>>>>>>>>>>>>/// @Description This command sets options that are used for the next login call.
73575>>>>>>>>>>>>>>>>>/// Because of this, it should be used after calling load_driver but before
73575>>>>>>>>>>>>>>>>>/// calling Login in most cases. Only options that are not used internally by
73575>>>>>>>>>>>>>>>>>/// the driver can be set using this command. Connection options that CANNOT be
73575>>>>>>>>>>>>>>>>>/// set: Database, Server, FailoverPartner, MarsConn, uid, pwd, Trusted_Connection,
73575>>>>>>>>>>>>>>>>>/// wsid, app, AutoTranslate, Timeout.
73575>>>>>>>>>>>>>>>>>///
73575>>>>>>>>>>>>>>>>>/// @Assumptions
73575>>>>>>>>>>>>>>>>>/// @Status      Public
73575>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex
73575>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2018-03-06 by Oliver Nelson
73575>>>>>>>>>>>>>>>>>/// @See         Get_Connection_Option, Clear_Connection_Option
73575>>>>>>>>>>>>>>>>>///
73575>>>>>>>>>>>>>>>>>/// @Syntax SET_CONNECTION_OPTION {option} to {value}
73575>>>>>>>>>>>>>>>>>/// @Param option         The connection option to set
73575>>>>>>>>>>>>>>>>>/// @Param value          The value to set the connection option to.
73575>>>>>>>>>>>>>>>>>///
73575>>>>>>>>>>>>>>>>>/// @Example
73575>>>>>>>>>>>>>>>>>/// LOAD_DRIVER "SQL_DRV"
73575>>>>>>>>>>>>>>>>>/// SET_CONNECTION_OPTION "ApplicationIntent" to "ReadOnly"
73575>>>>>>>>>>>>>>>>>/// LOGIN "localhost/sqlexpress01" "" "" "sql_drv"
73575>>>>>>>>>>>>>>>>>
73575>>>>>>>>>>>>>>>>>//=============================================================================
73575>>>>>>>>>>>>>>>>>/// @Name        GET_CONNECTION_OPTION
73575>>>>>>>>>>>>>>>>>/// @Description This command gets the value of a connection option that was set
73575>>>>>>>>>>>>>>>>>/// using SET_CONNECTION_OPTION. Only options that are not used internally by
73575>>>>>>>>>>>>>>>>>/// the driver can be retrieved using this command. Connection options that CANNOT be
73575>>>>>>>>>>>>>>>>>/// retrieved: Database, Server, FailoverPartner, MarsConn, uid, pwd,
73575>>>>>>>>>>>>>>>>>/// Trusted_Connection, wsid, app, AutoTranslate, Timeout.
73575>>>>>>>>>>>>>>>>>///
73575>>>>>>>>>>>>>>>>>/// @Assumptions
73575>>>>>>>>>>>>>>>>>/// @Status      Public
73575>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex
73575>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2018-03-06 by Oliver Nelson
73575>>>>>>>>>>>>>>>>>/// @See         Set_Connection_Option, Clear_Connection_Option
73575>>>>>>>>>>>>>>>>>///
73575>>>>>>>>>>>>>>>>>/// @Syntax GET_CONNECTION_OPTION {option} to {variable}
73575>>>>>>>>>>>>>>>>>/// @Param option         The connection option to get
73575>>>>>>>>>>>>>>>>>/// @Param value          A variable to hold the retrieved value of the connection option.
73575>>>>>>>>>>>>>>>>>///
73575>>>>>>>>>>>>>>>>>/// @Example
73575>>>>>>>>>>>>>>>>>/// GET_CONNECTION_OPTION "ApplicationIntent" to sVal
73575>>>>>>>>>>>>>>>>>
73575>>>>>>>>>>>>>>>>>//=============================================================================
73575>>>>>>>>>>>>>>>>>/// @Name        CLEAR_CONNECTION_OPTION
73575>>>>>>>>>>>>>>>>>/// @Description This command will clear any or all connections options that
73575>>>>>>>>>>>>>>>>>/// were set using SET_CONNECTION_OPTION. Passing the keyword ALL will remove
73575>>>>>>>>>>>>>>>>>/// all custom set connection options while passing a string value will clear
73575>>>>>>>>>>>>>>>>>/// just that option passed for the next login call. Connection options that
73575>>>>>>>>>>>>>>>>>/// CANNOT be cleared: Database, Server, FailoverPartner, MarsConn, uid, pwd,
73575>>>>>>>>>>>>>>>>>/// Trusted_Connection, wsid, app, AutoTranslate, Timeout.
73575>>>>>>>>>>>>>>>>>///
73575>>>>>>>>>>>>>>>>>/// @Assumptions
73575>>>>>>>>>>>>>>>>>/// @Status      Public
73575>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex
73575>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2018-03-06 by Oliver Nelson
73575>>>>>>>>>>>>>>>>>/// @See         Set_Connection_Option, Get_Connection_Option
73575>>>>>>>>>>>>>>>>>///
73575>>>>>>>>>>>>>>>>>/// @Syntax CLEAR_CONNECTION_OPTION ALL | {option}
73575>>>>>>>>>>>>>>>>>/// @Param option         The connection option to clear
73575>>>>>>>>>>>>>>>>>///
73575>>>>>>>>>>>>>>>>>/// @Example
73575>>>>>>>>>>>>>>>>>/// CLEAR_CONNECTION_OPTION "ApplicationIntent"
73575>>>>>>>>>>>>>>>>>
73575>>>>>>>>>>>>>>>>>
73575>>>>>>>>>>>>>>>>>///
73575>>>>>>>>>>>>>>>>>// Private:
73575>>>>>>>>>>>>>>>>>// Get the filenumber of a file.field parameter
73575>>>>>>>>>>>>>>>>>//
73575>>>>>>>>>>>>>>>>>
73575>>>>>>>>>>>>>>>>>///
73575>>>>>>>>>>>>>>>>>// Private:
73575>>>>>>>>>>>>>>>>>// Get the fieldnumber of a file.field parameter
73575>>>>>>>>>>>>>>>>>//
73575>>>>>>>>>>>>>>>>>
73575>>>>>>>>>>>>>>>>>
73575>>>>>>>>>>>>>>>>>
73575>>>>>>>>>>>>>>>>>
73575>>>>>>>>>>>>>>>>>//
73575>>>>>>>>>>>>>>>>>// Minimum required DataFlex version for new LOB support below is VDF 4
73575>>>>>>>>>>>>>>>>>//
73575>>>>>>>>>>>>>>>>>
73575>>>>>>>>>>>>>>>>>TYPE tMertechLOB_Args
73575>>>>>>>>>>>>>>>>>    FIELD tMertechLOB_Args.cbSize       AS WORD          // always the size of the structure (verification + versioning)
73575>>>>>>>>>>>>>>>>>    FIELD tMertechLOB_Args.nField       AS DWORD         // always the field number
73575>>>>>>>>>>>>>>>>>    FIELD tMertechLOB_Args.pszData      AS POINTER
73575>>>>>>>>>>>>>>>>>    FIELD tMertechLOB_Args.nSize        AS DWORD
73575>>>>>>>>>>>>>>>>>    FIELD tMertechLOB_Args.nOffset      AS POINTER
73575>>>>>>>>>>>>>>>>>END_TYPE
73575>>>>>>>>>>>>>>>>>
73575>>>>>>>>>>>>>>>>>//=============================================================================
73575>>>>>>>>>>>>>>>>>/// @Name        SQL_GET_DATA_CHUNK_EX
73575>>>>>>>>>>>>>>>>>/// @Description This command is used to get a chunk of data from a column
73575>>>>>>>>>>>>>>>>>/// retrieved through an embedded SQL statement. By passing the column number
73575>>>>>>>>>>>>>>>>>/// and the offset number, the chunk will be put into the specified variable.
73575>>>>>>>>>>>>>>>>>/// To specify how big of a chunk to get, use the SQL_SET_CHUNK_SIZE command.
73575>>>>>>>>>>>>>>>>>/// Otherwise the maximum length will be retrieved. An optional variable can
73575>>>>>>>>>>>>>>>>>/// also be passed which will store the length of the chunk. Note that unlike
73575>>>>>>>>>>>>>>>>>/// LOB_READ, this command works for any column type, not just LOB columns.
73575>>>>>>>>>>>>>>>>>///
73575>>>>>>>>>>>>>>>>>/// @Assumptions
73575>>>>>>>>>>>>>>>>>/// @Status      Public
73575>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex
73575>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2016-04-27 by Oliver Nelson
73575>>>>>>>>>>>>>>>>>/// @See         SQL_SET_CHUNK_SIZE SQL_GET_CHUNK_SIZE SQL_SET_MAX_DATA_SIZE SQL_GET_MAX_DATA_SIZE SQL_GET_COLUMN_DATA_SIZE
73575>>>>>>>>>>>>>>>>>///
73575>>>>>>>>>>>>>>>>>/// @Syntax SQL_GET_DATA_CHUNK COLUMN {column} OFFSET {offset} to {variable} {length}
73575>>>>>>>>>>>>>>>>>/// @Param column               Column number to get chunk from
73575>>>>>>>>>>>>>>>>>/// @Param offset               Offset to start at for the chunk
73575>>>>>>>>>>>>>>>>>/// @Param variable             Variable to hold the returned chunk
73575>>>>>>>>>>>>>>>>>/// @Param length               Variable to hold the size of the returned chunk
73575>>>>>>>>>>>>>>>>>///
73575>>>>>>>>>>>>>>>>>/// @Example
73575>>>>>>>>>>>>>>>>>/// SQL_SET_MAX_DATA_SIZE to |CI$4000000 //(64MB)
73575>>>>>>>>>>>>>>>>>/// move |CI$80000 to iChunkSize // 512KB
73575>>>>>>>>>>>>>>>>>/// SQL_SET_CHUNK_SIZE to iChunkSize
73575>>>>>>>>>>>>>>>>>///
73575>>>>>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
73575>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT
73575>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
73575>>>>>>>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sID sBio
73575>>>>>>>>>>>>>>>>>/// If (Found) Begin
73575>>>>>>>>>>>>>>>>>///     SQL_GET_COLUMN_DATA_SIZE COLUMN 6 to iDataSize
73575>>>>>>>>>>>>>>>>>///
73575>>>>>>>>>>>>>>>>>///     Repeat
73575>>>>>>>>>>>>>>>>>///         SQL_GET_DATA_CHUNK COLUMN 6 OFFSET iProgress to sChunk
73575>>>>>>>>>>>>>>>>>///         ADD iChunkSize to iProgress
73575>>>>>>>>>>>>>>>>>///         write sChunk
73575>>>>>>>>>>>>>>>>>///     until (iProgress >= iDataSize)
73575>>>>>>>>>>>>>>>>>///
73575>>>>>>>>>>>>>>>>>/// End
73575>>>>>>>>>>>>>>>>>
73575>>>>>>>>>>>>>>>>>
73575>>>>>>>>>>>>>>>>>Function MertechInc_SQL_GET_DATA_CHUNK_EX Global Integer iColumn Integer iOffset Returns String
73577>>>>>>>>>>>>>>>>>    Local String sLOB_Args
73577>>>>>>>>>>>>>>>>>    Local String sData
73577>>>>>>>>>>>>>>>>>    Local Integer iSize
73577>>>>>>>>>>>>>>>>>
73577>>>>>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_CHUNK_SIZE CALLBACK 0 PASSING iSize MertechInc_Blank 1 RESULT MertechInc_iRet
73582>>>>>>>>>>>>>>>>>
73582>>>>>>>>>>>>>>>>>    Move "" to sData
73583>>>>>>>>>>>>>>>>>    ZeroType tMertechLOB_Args to sLOB_Args
73584>>>>>>>>>>>>>>>>>    // First move the size of the structure to the Structure
73584>>>>>>>>>>>>>>>>>    Put tMertechLOB_Args_size  to sLOB_Args at tMertechLOB_Args.cbSize
73585>>>>>>>>>>>>>>>>>    Put iColumn                to sLOB_Args at tMertechLOB_Args.nField
73586>>>>>>>>>>>>>>>>>    Put iOffset                to sLOB_Args at tMertechLOB_Args.nOffset
73587>>>>>>>>>>>>>>>>>    Put iSize                  to sLOB_Args at tMertechLOB_Args.nSize
73588>>>>>>>>>>>>>>>>>
73588>>>>>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_GET_DATA_CHUNK_EX CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank (addressof(sLOB_Args)) RESULT MertechInc_iRet
73593>>>>>>>>>>>>>>>>>    GetBuff from sLOB_Args at tMertechLOB_Args.nSize to iSize
73594>>>>>>>>>>>>>>>>>
73594>>>>>>>>>>>>>>>>>    If iSize GT 0 Begin
73596>>>>>>>>>>>>>>>>>        Move (Repeat(Character(0), iSize)) to sData
73597>>>>>>>>>>>>>>>>>        Put (AddressOf(sData)) to sLOB_Args at tMertechLOB_Args.pszData
73598>>>>>>>>>>>>>>>>>        Put iSize              to sLOB_Args at tMertechLOB_Args.nSize
73599>>>>>>>>>>>>>>>>>        Put iOffset            to sLOB_Args at tMertechLOB_Args.nOffset
73600>>>>>>>>>>>>>>>>>        Call_Driver 0 MertechInc_DriverName Function CALLDRV_GET_DATA_CHUNK_EX CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank (addressof(sLOB_Args)) RESULT MertechInc_iRet
73605>>>>>>>>>>>>>>>>>        GetBuff from sLOB_Args at tMertechLOB_Args.nSize to iSize
73606>>>>>>>>>>>>>>>>>    End
73606>>>>>>>>>>>>>>>>>>
73606>>>>>>>>>>>>>>>>>    Else Begin
73607>>>>>>>>>>>>>>>>>        Move "" to sData
73608>>>>>>>>>>>>>>>>>    End
73608>>>>>>>>>>>>>>>>>>
73608>>>>>>>>>>>>>>>>>    Function_Return sData
73609>>>>>>>>>>>>>>>>>End_Function // MertechInc_SQL_GET_DATA_CHUNK_EX
73610>>>>>>>>>>>>>>>>>
73610>>>>>>>>>>>>>>>>>//=============================================================================
73610>>>>>>>>>>>>>>>>>/// @Name        SQL_GET_COLUMN_DATA_SIZE
73610>>>>>>>>>>>>>>>>>/// @Description This command is used to get the size of the data in a column
73610>>>>>>>>>>>>>>>>>/// retrieved through an embedded SQL statement. By passing the column number
73610>>>>>>>>>>>>>>>>>/// the size of the data in the column will be put into the specified variable.
73610>>>>>>>>>>>>>>>>>/// The size returned will be the smaller of the actual size of the data or
73610>>>>>>>>>>>>>>>>>/// the SQL_SET_MAX_DATA_SIZE setting. So for instance, if the data stored in
73610>>>>>>>>>>>>>>>>>/// a column is 64MB, but the SQL_SET_MAX_DATA_SIZE is set to 16MB, then this
73610>>>>>>>>>>>>>>>>>/// command will return 16MB. Note that you may need to use Set_Argument_Size
73610>>>>>>>>>>>>>>>>>/// to allow for a large chunk size because the default maximum string size
73610>>>>>>>>>>>>>>>>>/// in most modern dataflex versions is only 64KB.
73610>>>>>>>>>>>>>>>>>///
73610>>>>>>>>>>>>>>>>>/// @Assumptions
73610>>>>>>>>>>>>>>>>>/// @Status      Public
73610>>>>>>>>>>>>>>>>>/// @Drivers     SQLFlex
73610>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2016-04-27 Oliver Nelson
73610>>>>>>>>>>>>>>>>>/// @See         SQL_SET_CHUNK_SIZE SQL_GET_CHUNK_SIZE SQL_GET_DATA_CHUNK_EX SQL_SET_MAX_DATA_SIZE
73610>>>>>>>>>>>>>>>>>///
73610>>>>>>>>>>>>>>>>>/// @Syntax SQL_GET_COLUMN_DATA_SIZE COLUMN {column} to {variable}
73610>>>>>>>>>>>>>>>>>/// @Param column               Column number to get chunk from
73610>>>>>>>>>>>>>>>>>/// @Param variable             Variable to hold the returned data size
73610>>>>>>>>>>>>>>>>>///
73610>>>>>>>>>>>>>>>>>/// @Example
73610>>>>>>>>>>>>>>>>>/// SQL_SET_MAX_DATA_SIZE to |CI$4000000 //(64MB)
73610>>>>>>>>>>>>>>>>>/// move |CI$80000 to iChunkSize // 512KB
73610>>>>>>>>>>>>>>>>>/// SQL_SET_CHUNK_SIZE to iChunkSize
73610>>>>>>>>>>>>>>>>>///
73610>>>>>>>>>>>>>>>>>/// SQL_SET_STMT to "SELECT * FROM CUSTOMER WHERE STATUS = 'Active' "
73610>>>>>>>>>>>>>>>>>/// SQL_PREPARE_STMT
73610>>>>>>>>>>>>>>>>>/// SQL_EXECUTE_STMT
73610>>>>>>>>>>>>>>>>>/// SQL_FETCH_NEXT_ROW into sID sBio
73610>>>>>>>>>>>>>>>>>/// If (Found) Begin
73610>>>>>>>>>>>>>>>>>///     SQL_GET_COLUMN_DATA_SIZE COLUMN 6 to iDataSize
73610>>>>>>>>>>>>>>>>>///
73610>>>>>>>>>>>>>>>>>///     Repeat
73610>>>>>>>>>>>>>>>>>///         SQL_GET_DATA_CHUNK COLUMN 6 OFFSET iProgress to sChunk
73610>>>>>>>>>>>>>>>>>///         ADD iChunkSize to iProgress
73610>>>>>>>>>>>>>>>>>///         write sChunk
73610>>>>>>>>>>>>>>>>>///     until (iProgress >= iDataSize)
73610>>>>>>>>>>>>>>>>>///
73610>>>>>>>>>>>>>>>>>/// End
73610>>>>>>>>>>>>>>>>>
73610>>>>>>>>>>>>>>>>>
73610>>>>>>>>>>>>>>>>>Function MertechInc_SQL_GET_COLUMN_DATA_SIZE Global Integer iColumn Returns Integer
73612>>>>>>>>>>>>>>>>>    Local String sLOB_Args
73612>>>>>>>>>>>>>>>>>    Local String sData
73612>>>>>>>>>>>>>>>>>    Local Integer iSize
73612>>>>>>>>>>>>>>>>>
73612>>>>>>>>>>>>>>>>>    ZeroType tMertechLOB_Args to sLOB_Args
73613>>>>>>>>>>>>>>>>>    // First move the size of the structure to the Structure
73613>>>>>>>>>>>>>>>>>    Put tMertechLOB_Args_size  to sLOB_Args at tMertechLOB_Args.cbSize
73614>>>>>>>>>>>>>>>>>    Put iColumn                to sLOB_Args at tMertechLOB_Args.nField
73615>>>>>>>>>>>>>>>>>    Put 0                      to sLOB_Args at tMertechLOB_Args.nOffset
73616>>>>>>>>>>>>>>>>>    Put |CI$7FFFFFFF           to sLOB_Args at tMertechLOB_Args.nSize
73617>>>>>>>>>>>>>>>>>
73617>>>>>>>>>>>>>>>>>    Call_Driver 0 MertechInc_DriverName Function CALLDRV_GET_DATA_CHUNK_EX CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank (addressof(sLOB_Args)) RESULT MertechInc_iRet
73622>>>>>>>>>>>>>>>>>    GetBuff from sLOB_Args at tMertechLOB_Args.nSize to iSize
73623>>>>>>>>>>>>>>>>>
73623>>>>>>>>>>>>>>>>>    Function_Return iSize
73624>>>>>>>>>>>>>>>>>End_Function // MertechInc_SQL_GET_COLUMN_DATA_SIZE
73625>>>>>>>>>>>>>>>>>
73625>>>>>>>>>>>>>>>>>//=============================================================================
73625>>>>>>>>>>>>>>>>>/// @Name        SQL_SET_LOB
73625>>>>>>>>>>>>>>>>>/// @Description This command replaces whatever is currently in a LOB Field
73625>>>>>>>>>>>>>>>>>/// with the data passed. It writes to a client side buffer. It can be used
73625>>>>>>>>>>>>>>>>>/// to Write an arbitrary amount of data into a LOB.
73625>>>>>>>>>>>>>>>>>/// If passed an empty String, it will remove all the contents of the LOB.
73625>>>>>>>>>>>>>>>>>/// If you wish to Set a LOB back to NULL, please use the SQL_SET_LOB_NULL
73625>>>>>>>>>>>>>>>>>/// command.
73625>>>>>>>>>>>>>>>>>/// NOTE: Unlike the previous call LOB_WRITE, this call does not
73625>>>>>>>>>>>>>>>>>/// perform the Save. This must be done separately.
73625>>>>>>>>>>>>>>>>>///
73625>>>>>>>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
73625>>>>>>>>>>>>>>>>>/// @Status      Public
73625>>>>>>>>>>>>>>>>>/// @Drivers     All
73625>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2014-07-10 by Aaron Gulack
73625>>>>>>>>>>>>>>>>>/// @See                 SQL_ADD_LOB_CHUNK SQL_GET_LOB SQL_GET_LOB_CHUNK SQL_GET_LOB_LENGTH SQL_LOB_TRUNCATE
73625>>>>>>>>>>>>>>>>>///
73625>>>>>>>>>>>>>>>>>/// @Syntax             SQL_SET_LOB {FileName.FieldName} to {variable}
73625>>>>>>>>>>>>>>>>>/// @Param              FileName                The name of the file containing the LOB field
73625>>>>>>>>>>>>>>>>>/// @Param              FieldName               The name of the LOB field being set
73625>>>>>>>>>>>>>>>>>/// @Param              variable                The variable to use to set the field's value
73625>>>>>>>>>>>>>>>>>///
73625>>>>>>>>>>>>>>>>>/// @Example
73625>>>>>>>>>>>>>>>>>/// Set_Argument_Size 262144
73625>>>>>>>>>>>>>>>>>/// String sLine
73625>>>>>>>>>>>>>>>>>///
73625>>>>>>>>>>>>>>>>>/// Clear Customer
73625>>>>>>>>>>>>>>>>>///    Move iID to Customer.ID
73625>>>>>>>>>>>>>>>>>/// Find Eq Customer by Index.1
73625>>>>>>>>>>>>>>>>>/// If (Found) Begin
73625>>>>>>>>>>>>>>>>>///    Direct_Input "C:\bigFile.xml"
73625>>>>>>>>>>>>>>>>>///    Reread Customer
73625>>>>>>>>>>>>>>>>>///       SQL_SET_LOB Customer.Comments to ""
73625>>>>>>>>>>>>>>>>>///       Read_Block sLine 262144
73625>>>>>>>>>>>>>>>>>///       SQL_SET_LOB Customer.Comments to sLine
73625>>>>>>>>>>>>>>>>>///       While (not(SeqEof))
73625>>>>>>>>>>>>>>>>>///          Read_Block sLine 262144
73625>>>>>>>>>>>>>>>>>///          SQL_ADD_LOB_CHUNK Customer.Comments to sLine
73625>>>>>>>>>>>>>>>>>///       Loop
73625>>>>>>>>>>>>>>>>>///    Saverecord Customer
73625>>>>>>>>>>>>>>>>>///    Unlock
73625>>>>>>>>>>>>>>>>>///    Close_Input
73625>>>>>>>>>>>>>>>>>/// End
73625>>>>>>>>>>>>>>>>>
73625>>>>>>>>>>>>>>>>>Procedure MertechInc_SQL_SET_LOB Global String sDriver Integer iFile Integer iField String sData
73627>>>>>>>>>>>>>>>>>    String sLOB_Args       // can drop local command if minimum vdf version is 6
73627>>>>>>>>>>>>>>>>>
73627>>>>>>>>>>>>>>>>>    ZeroType tMertechLOB_Args to sLOB_Args
73628>>>>>>>>>>>>>>>>>    // First move the size of the structure to the Structure
73628>>>>>>>>>>>>>>>>>    Put tMertechLOB_Args_size to sLOB_Args at tMertechLOB_Args.cbSize
73629>>>>>>>>>>>>>>>>>    Put iField                to sLOB_Args at tMertechLOB_Args.nField
73630>>>>>>>>>>>>>>>>>    Put (AddressOf(sData))    to sLOB_Args at tMertechLOB_Args.pszData
73631>>>>>>>>>>>>>>>>>    Put (length(sData))       to sLOB_Args at tMertechLOB_Args.nSize
73632>>>>>>>>>>>>>>>>>
73632>>>>>>>>>>>>>>>>>    Call_Driver iFile sDriver Function CALLDRV_LOB_EX_WRITE CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank (addressof(sLOB_Args)) RESULT MertechInc_iRet
73637>>>>>>>>>>>>>>>>>End_Procedure // MertechInc_SQL_SET_LOB
73638>>>>>>>>>>>>>>>>>
73638>>>>>>>>>>>>>>>>>//=============================================================================
73638>>>>>>>>>>>>>>>>>/// @Name        SQL_ADD_LOB_CHUNK
73638>>>>>>>>>>>>>>>>>/// @Description This command is used to add additional chunks to the buffer
73638>>>>>>>>>>>>>>>>>/// before saving the record. After SQL_SET_LOB has been called
73638>>>>>>>>>>>>>>>>>/// SQL_ADD_LOB_CHUNK can be called as many times as needed to add additional
73638>>>>>>>>>>>>>>>>>/// chunks of data before a save. It can also be called independent of
73638>>>>>>>>>>>>>>>>>/// SQL_SET_LOB to append data to an existing LOB column.
73638>>>>>>>>>>>>>>>>>/// NOTE: Unlike the previous call LOB_APPEND, this call does not perform
73638>>>>>>>>>>>>>>>>>/// the save. This must be done separately.
73638>>>>>>>>>>>>>>>>>///
73638>>>>>>>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
73638>>>>>>>>>>>>>>>>>/// @Status      Public
73638>>>>>>>>>>>>>>>>>/// @Drivers     All
73638>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2014-07-10 by Aaron Gulack
73638>>>>>>>>>>>>>>>>>/// @See                 SQL_SET_LOB SQL_GET_LOB SQL_GET_LOB_CHUNK SQL_GET_LOB_LENGTH SQL_LOB_TRUNCATE
73638>>>>>>>>>>>>>>>>>///
73638>>>>>>>>>>>>>>>>>/// @Syntax             SQL_ADD_LOB_CHUNK {FileName.FieldName} to {variable}
73638>>>>>>>>>>>>>>>>>/// @Param              FileName                The name of the file containing the LOB field
73638>>>>>>>>>>>>>>>>>/// @Param              FieldName               The name of the LOB field being set
73638>>>>>>>>>>>>>>>>>/// @Param              variable                The variable to add as the LOB chunk
73638>>>>>>>>>>>>>>>>>///
73638>>>>>>>>>>>>>>>>>/// @Example
73638>>>>>>>>>>>>>>>>>/// Set_Argument_Size 262144
73638>>>>>>>>>>>>>>>>>/// String sLine
73638>>>>>>>>>>>>>>>>>///
73638>>>>>>>>>>>>>>>>>/// Clear Customer
73638>>>>>>>>>>>>>>>>>///    Move iID to Customer.ID
73638>>>>>>>>>>>>>>>>>/// Find Eq Customer by Index.1
73638>>>>>>>>>>>>>>>>>/// If (Found) Begin
73638>>>>>>>>>>>>>>>>>///    Direct_Input "C:\bigFile.xml"
73638>>>>>>>>>>>>>>>>>///    Reread Customer
73638>>>>>>>>>>>>>>>>>///       SQL_SET_LOB Customer.Comments to ""
73638>>>>>>>>>>>>>>>>>///       Read_Block sLine 262144
73638>>>>>>>>>>>>>>>>>///       SQL_SET_LOB Customer.Comments to sLine
73638>>>>>>>>>>>>>>>>>///       While (not(SeqEof))
73638>>>>>>>>>>>>>>>>>///          Read_Block sLine 262144
73638>>>>>>>>>>>>>>>>>///          SQL_ADD_LOB_CHUNK Customer.Comments to sLine
73638>>>>>>>>>>>>>>>>>///       Loop
73638>>>>>>>>>>>>>>>>>///    Saverecord Customer
73638>>>>>>>>>>>>>>>>>///    Unlock
73638>>>>>>>>>>>>>>>>>///    Close_Input
73638>>>>>>>>>>>>>>>>>/// End
73638>>>>>>>>>>>>>>>>>
73638>>>>>>>>>>>>>>>>>Procedure MertechInc_SQL_ADD_LOB_CHUNK Global String sDriver Integer iFile Integer iField String sData
73640>>>>>>>>>>>>>>>>>    String sLOB_Args
73640>>>>>>>>>>>>>>>>>
73640>>>>>>>>>>>>>>>>>    ZeroType tMertechLOB_Args to sLOB_Args
73641>>>>>>>>>>>>>>>>>    // First move the size of the structure to the Structure
73641>>>>>>>>>>>>>>>>>    Put tMertechLOB_Args_size to sLOB_Args at tMertechLOB_Args.cbSize
73642>>>>>>>>>>>>>>>>>    Put iField                to sLOB_Args at tMertechLOB_Args.nField
73643>>>>>>>>>>>>>>>>>    Put (AddressOf(sData))    to sLOB_Args at tMertechLOB_Args.pszData
73644>>>>>>>>>>>>>>>>>    Put (length(sData))       to sLOB_Args at tMertechLOB_Args.nSize
73645>>>>>>>>>>>>>>>>>
73645>>>>>>>>>>>>>>>>>    Call_Driver iFile sDriver Function CALLDRV_LOB_EX_APPEND CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank (addressof(sLOB_Args)) RESULT MertechInc_iRet
73650>>>>>>>>>>>>>>>>>end_procedure // MertechInc_SQL_ADD_LOB_CHUNK
73651>>>>>>>>>>>>>>>>>
73651>>>>>>>>>>>>>>>>>//=============================================================================
73651>>>>>>>>>>>>>>>>>/// @Name        SQL_GET_LOB
73651>>>>>>>>>>>>>>>>>/// @Description This command is used for getting the value of a specified LOB
73651>>>>>>>>>>>>>>>>>/// field. Two optional parameters can be passed specifying the offset and
73651>>>>>>>>>>>>>>>>>/// length of the chunk to get. Passing these parameters essentially makes this
73651>>>>>>>>>>>>>>>>>/// call the same as SQL_GET_LOB_CHUNK.
73651>>>>>>>>>>>>>>>>>/// Depending on the situation, the two calls can be interchanged for improved
73651>>>>>>>>>>>>>>>>>/// code readability. Excluding these additional parameters will get the whole
73651>>>>>>>>>>>>>>>>>/// field value within DataFlex variable size limits.
73651>>>>>>>>>>>>>>>>>///
73651>>>>>>>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
73651>>>>>>>>>>>>>>>>>/// @Status      Public
73651>>>>>>>>>>>>>>>>>/// @Drivers     All
73651>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2014-07-10 by Aaron Gulack
73651>>>>>>>>>>>>>>>>>/// @See                 SQL_SET_LOB SQL_ADD_LOB_CHUNK SQL_GET_LOB_CHUNK SQL_GET_LOB_LENGTH SQL_LOB_TRUNCATE
73651>>>>>>>>>>>>>>>>>///
73651>>>>>>>>>>>>>>>>>/// @Syntax     SQL_GET_LOB {FileName.FieldName} TO {variable} [ OFFSET {offset} LENGTH {length} ]
73651>>>>>>>>>>>>>>>>>/// @Param              FileName                        The name of the file that contains the specified LOB field
73651>>>>>>>>>>>>>>>>>/// @Param              FieldName                       The name of the LOB field
73651>>>>>>>>>>>>>>>>>/// @Param              variable                        The variable to hold the LOB value
73651>>>>>>>>>>>>>>>>>/// @Param              offset                          Integer amount to offset when getting the LOB value (optional)
73651>>>>>>>>>>>>>>>>>/// @Param              length                          Length of value to get from the LOB field (optional)
73651>>>>>>>>>>>>>>>>>///
73651>>>>>>>>>>>>>>>>>/// @Example
73651>>>>>>>>>>>>>>>>>/// Set_Argument_Size 262144
73651>>>>>>>>>>>>>>>>>/// String sResult
73651>>>>>>>>>>>>>>>>>///
73651>>>>>>>>>>>>>>>>>/// Move 262144 to iChunkSize
73651>>>>>>>>>>>>>>>>>/// Move 0      to iChunk
73651>>>>>>>>>>>>>>>>>///
73651>>>>>>>>>>>>>>>>>/// Clear Customer
73651>>>>>>>>>>>>>>>>>///    Move iID to Customer.ID
73651>>>>>>>>>>>>>>>>>/// Find Eq Customer by Index.1
73651>>>>>>>>>>>>>>>>>/// If (Found) Begin
73651>>>>>>>>>>>>>>>>>///    Direct_Output ('Binary:' + sDestFileName)
73651>>>>>>>>>>>>>>>>>///    SQL_GET_LOB_LENGTH Customer.Comments to iLength
73651>>>>>>>>>>>>>>>>>///    While (iChunk*iChunkSize < iLength)
73651>>>>>>>>>>>>>>>>>///       SQL_GET_LOB Customer.Comments to sResult OFFSET (iChunk*iChunkSize) LENGTH iChunkSize
73651>>>>>>>>>>>>>>>>>///       Write sResult
73651>>>>>>>>>>>>>>>>>///       Increment iChunk
73651>>>>>>>>>>>>>>>>>///    Loop
73651>>>>>>>>>>>>>>>>>///    Close_Output
73651>>>>>>>>>>>>>>>>>/// End
73651>>>>>>>>>>>>>>>>>
73651>>>>>>>>>>>>>>>>>
73651>>>>>>>>>>>>>>>>>Function MertechInc_SQL_GET_LOB Global String sDriver Integer iFile Integer iField Integer iOffset Integer iLength Returns String
73653>>>>>>>>>>>>>>>>>    String sLOB_Args
73653>>>>>>>>>>>>>>>>>    String sData
73653>>>>>>>>>>>>>>>>>    DWord  nSize
73653>>>>>>>>>>>>>>>>>
73653>>>>>>>>>>>>>>>>>    Move "" To sData
73654>>>>>>>>>>>>>>>>>    ZeroType tMertechLOB_Args to sLOB_Args
73655>>>>>>>>>>>>>>>>>    // First move the size of the structure to the Structure
73655>>>>>>>>>>>>>>>>>    Put tMertechLOB_Args_size to sLOB_Args at tMertechLOB_Args.cbSize
73656>>>>>>>>>>>>>>>>>    Put iField                to sLOB_Args at tMertechLOB_Args.nField
73657>>>>>>>>>>>>>>>>>
73657>>>>>>>>>>>>>>>>>    Call_Driver iFile sDriver Function CALLDRV_LOB_EX_GET_LENGTH CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank (addressof(sLOB_Args)) RESULT MertechInc_iRet
73662>>>>>>>>>>>>>>>>>
73662>>>>>>>>>>>>>>>>>    GetBuff from sLOB_Args at tMertechLOB_Args.nSize to nSize
73663>>>>>>>>>>>>>>>>>    If (nSize > 0) Begin
73665>>>>>>>>>>>>>>>>>      If (iOffset=0 and iLength=0) Begin
73667>>>>>>>>>>>>>>>>>        move (Repeat(Character(0), nSize)) to sData
73668>>>>>>>>>>>>>>>>>            //Send Assert (AddressOf(sData) <> 0) ("AddressOf(sData) is NULL") DFTrue
73668>>>>>>>>>>>>>>>>>        Put (AddressOf(sData)) to sLOB_Args at tMertechLOB_Args.pszData
73669>>>>>>>>>>>>>>>>>      End
73669>>>>>>>>>>>>>>>>>>
73669>>>>>>>>>>>>>>>>>      Else Begin
73670>>>>>>>>>>>>>>>>>        move (Repeat(Character(0), iLength)) to sData
73671>>>>>>>>>>>>>>>>>        Put (AddressOf(sData)) to sLOB_Args at tMertechLOB_Args.pszData
73672>>>>>>>>>>>>>>>>>        Put iLength            to sLOB_Args at tMertechLOB_Args.nSize
73673>>>>>>>>>>>>>>>>>        Put iOffset            to sLOB_Args at tMertechLOB_Args.nOffset
73674>>>>>>>>>>>>>>>>>      End
73674>>>>>>>>>>>>>>>>>>
73674>>>>>>>>>>>>>>>>>      Call_Driver iFile sDriver Function CALLDRV_LOB_EX_READ CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank (addressof(sLOB_Args)) RESULT MertechInc_iRet
73679>>>>>>>>>>>>>>>>>    End
73679>>>>>>>>>>>>>>>>>>
73679>>>>>>>>>>>>>>>>>    Else Begin
73680>>>>>>>>>>>>>>>>>        Move "" to sData
73681>>>>>>>>>>>>>>>>>    End
73681>>>>>>>>>>>>>>>>>>
73681>>>>>>>>>>>>>>>>>    Function_Return sData
73682>>>>>>>>>>>>>>>>>End_Function // MertechInc_SQL_GET_LOB
73683>>>>>>>>>>>>>>>>>
73683>>>>>>>>>>>>>>>>>//=============================================================================
73683>>>>>>>>>>>>>>>>>/// @Name        SQL_GET_LOB_CHUNK
73683>>>>>>>>>>>>>>>>>/// @Description This command is used for getting a chunk of data from a specified
73683>>>>>>>>>>>>>>>>>/// LOB field. The difference between this command and SQL_GET_LOB is only that
73683>>>>>>>>>>>>>>>>>/// the parameters OFFSET and LENGTH are not optional when using this command.
73683>>>>>>>>>>>>>>>>>/// You may consider using this command to retrieve small portions of a very
73683>>>>>>>>>>>>>>>>>/// large BLOB so as to reduce memory usage.
73683>>>>>>>>>>>>>>>>>///
73683>>>>>>>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
73683>>>>>>>>>>>>>>>>>/// @Status      Public
73683>>>>>>>>>>>>>>>>>/// @Drivers     All
73683>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2014-07-10 by Aaron Gulack
73683>>>>>>>>>>>>>>>>>/// @See                 SQL_SET_LOB SQL_ADD_LOB_CHUNK SQL_GET_LOB SQL_GET_LOB_LENGTH SQL_LOB_TRUNCATE
73683>>>>>>>>>>>>>>>>>///
73683>>>>>>>>>>>>>>>>>/// @Syntax     SQL_GET_LOB_CHUNK {FileName.FieldName} TO {variable} OFFSET {offset} LENGTH {length}
73683>>>>>>>>>>>>>>>>>/// @Param              FileName                        The name of the file that contains the specified LOB field
73683>>>>>>>>>>>>>>>>>/// @Param              FieldName                       The name of the LOB field
73683>>>>>>>>>>>>>>>>>/// @Param              variable                        The variable to hold the LOB chunk
73683>>>>>>>>>>>>>>>>>/// @Param              offset                          Integer amount to offset when getting the LOB chunk
73683>>>>>>>>>>>>>>>>>/// @Param              length                          Length of chunk to get from the LOB field
73683>>>>>>>>>>>>>>>>>///
73683>>>>>>>>>>>>>>>>>/// @Example
73683>>>>>>>>>>>>>>>>>/// Set_Argument_Size 262144
73683>>>>>>>>>>>>>>>>>/// String sResult
73683>>>>>>>>>>>>>>>>>///
73683>>>>>>>>>>>>>>>>>/// Move 262144 to iChunkSize
73683>>>>>>>>>>>>>>>>>/// Move 0      to iChunk
73683>>>>>>>>>>>>>>>>>///
73683>>>>>>>>>>>>>>>>>/// Clear Customer
73683>>>>>>>>>>>>>>>>>///    Move iID to Customer.ID
73683>>>>>>>>>>>>>>>>>/// Find Eq Customer by Index.1
73683>>>>>>>>>>>>>>>>>/// If (Found) Begin
73683>>>>>>>>>>>>>>>>>///    SQL_GET_LOB_LENGTH Customer.Comments to iLength
73683>>>>>>>>>>>>>>>>>///    While (iChunk*iChunkSize < iLength)
73683>>>>>>>>>>>>>>>>>///       SQL_GET_LOB_CHUNK Customer.Comments to sResult OFFSET (iChunk*iChunkSize) LENGTH iChunkSize
73683>>>>>>>>>>>>>>>>>///       // Do something with the LOB data
73683>>>>>>>>>>>>>>>>>///       Increment iChunk
73683>>>>>>>>>>>>>>>>>///    Loop
73683>>>>>>>>>>>>>>>>>/// End
73683>>>>>>>>>>>>>>>>>
73683>>>>>>>>>>>>>>>>>//=============================================================================
73683>>>>>>>>>>>>>>>>>/// @Name        SQL_GET_LOB_LENGTH
73683>>>>>>>>>>>>>>>>>/// @Description This command is used to get the length of a specified LOB field.
73683>>>>>>>>>>>>>>>>>/// It is useful, for example, in determining the number of iterations to
73683>>>>>>>>>>>>>>>>>/// perform while reading from a LOB field using chunking.
73683>>>>>>>>>>>>>>>>>///
73683>>>>>>>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
73683>>>>>>>>>>>>>>>>>/// @Status      Public
73683>>>>>>>>>>>>>>>>>/// @Drivers     All
73683>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2014-07-10 by Aaron Gulack
73683>>>>>>>>>>>>>>>>>/// @See                 SQL_SET_LOB SQL_ADD_LOB_CHUNK SQL_GET_LOB SQL_GET_LOB_CHUNK SQL_LOB_TRUNCATE
73683>>>>>>>>>>>>>>>>>///
73683>>>>>>>>>>>>>>>>>/// @Syntax             SQL_GET_LOB_LENGTH {FileName.FieldName} to {variable}
73683>>>>>>>>>>>>>>>>>/// @Param              FileName                        The name of the file containing the LOB field
73683>>>>>>>>>>>>>>>>>/// @Param              FieldName                       The name of the specified LOB field
73683>>>>>>>>>>>>>>>>>/// @Param              variable                        The variable to hold the length of the field
73683>>>>>>>>>>>>>>>>>///
73683>>>>>>>>>>>>>>>>>/// @Example
73683>>>>>>>>>>>>>>>>>/// Set_Argument_Size 262144
73683>>>>>>>>>>>>>>>>>/// String sResult
73683>>>>>>>>>>>>>>>>>///
73683>>>>>>>>>>>>>>>>>/// Move 16384 to iChunkSize
73683>>>>>>>>>>>>>>>>>/// Move 0     to iChunk
73683>>>>>>>>>>>>>>>>>///
73683>>>>>>>>>>>>>>>>>/// Clear Customer
73683>>>>>>>>>>>>>>>>>///    Move iID to Customer.ID
73683>>>>>>>>>>>>>>>>>/// Find Eq Customer by Index.1
73683>>>>>>>>>>>>>>>>>/// If (Found) Begin
73683>>>>>>>>>>>>>>>>>///    SQL_GET_LOB_LENGTH Customer.Comments to iLength
73683>>>>>>>>>>>>>>>>>///    While (iChunk*iChunkSize < iLength)
73683>>>>>>>>>>>>>>>>>///       SQL_GET_LOB Customer.Comments to sResult OFFSET (iChunk*iChunkSize) LENGTH iChunkSize
73683>>>>>>>>>>>>>>>>>///       // Do something with the LOB data
73683>>>>>>>>>>>>>>>>>///       Increment iChunk
73683>>>>>>>>>>>>>>>>>///    Loop
73683>>>>>>>>>>>>>>>>>/// End
73683>>>>>>>>>>>>>>>>>
73683>>>>>>>>>>>>>>>>>
73683>>>>>>>>>>>>>>>>>Function MertechInc_SQL_GET_LOB_LENGTH Global String sDriver Integer iFile Integer iField Returns Integer
73685>>>>>>>>>>>>>>>>>    String sLOB_Args
73685>>>>>>>>>>>>>>>>>    DWord  nSize
73685>>>>>>>>>>>>>>>>>
73685>>>>>>>>>>>>>>>>>    ZeroType tMertechLOB_Args to sLOB_Args
73686>>>>>>>>>>>>>>>>>    // First move the size of the structure to the Structure
73686>>>>>>>>>>>>>>>>>    Put tMertechLOB_Args_size to sLOB_Args at tMertechLOB_Args.cbSize
73687>>>>>>>>>>>>>>>>>    Put iField                to sLOB_Args at tMertechLOB_Args.nField
73688>>>>>>>>>>>>>>>>>
73688>>>>>>>>>>>>>>>>>    Call_Driver iFile sDriver Function CALLDRV_LOB_EX_GET_LENGTH CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank (addressof(sLOB_Args)) RESULT MertechInc_iRet
73693>>>>>>>>>>>>>>>>>
73693>>>>>>>>>>>>>>>>>    GetBuff from sLOB_Args at tMertechLOB_Args.nSize to nSize
73694>>>>>>>>>>>>>>>>>    Function_Return nSize
73695>>>>>>>>>>>>>>>>>End_Function // MertechInc_SQL_GET_LOB_LENGTH
73696>>>>>>>>>>>>>>>>>
73696>>>>>>>>>>>>>>>>>//=============================================================================
73696>>>>>>>>>>>>>>>>>/// @Name        SQL_SET_LOB_NULL
73696>>>>>>>>>>>>>>>>>/// @Description This command is used to set a LOB column to null. Often
73696>>>>>>>>>>>>>>>>>/// LOB columns should either contain data or be null. A "blank" LOB column
73696>>>>>>>>>>>>>>>>>/// often doesn't appear empty in other environments, so settings it back to
73696>>>>>>>>>>>>>>>>>/// null is best.
73696>>>>>>>>>>>>>>>>>///
73696>>>>>>>>>>>>>>>>>/// @Assumptions The field being used is a LOB field
73696>>>>>>>>>>>>>>>>>/// @Status      Public
73696>>>>>>>>>>>>>>>>>/// @Drivers     All
73696>>>>>>>>>>>>>>>>>/// @VersionNote Last Revised: 2014-07-10 by Aaron Gulack
73696>>>>>>>>>>>>>>>>>/// @See                 SQL_SET_LOB SQL_ADD_LOB_CHUNK SQL_GET_LOB SQL_GET_LOB_CHUNK SQL_LOB_TRUNCATE
73696>>>>>>>>>>>>>>>>>///
73696>>>>>>>>>>>>>>>>>/// @Syntax             SQL_SET_LOB_NULL    {FileName.FieldName}
73696>>>>>>>>>>>>>>>>>/// @Param              FileName                        The name of the file containing the LOB field
73696>>>>>>>>>>>>>>>>>/// @Param              FieldName                       The name of the specified LOB field
73696>>>>>>>>>>>>>>>>>///
73696>>>>>>>>>>>>>>>>>/// @Example
73696>>>>>>>>>>>>>>>>>////
73696>>>>>>>>>>>>>>>>>/// Clear Customer
73696>>>>>>>>>>>>>>>>>/// Move iID to Customer.ID
73696>>>>>>>>>>>>>>>>>/// Find Eq Customer by Index.1
73696>>>>>>>>>>>>>>>>>/// If (Found) Begin
73696>>>>>>>>>>>>>>>>>///    Reread Customer
73696>>>>>>>>>>>>>>>>>///        SQL_SET_LOB_NULL Customer.Comments
73696>>>>>>>>>>>>>>>>>///        Saverecord Customer
73696>>>>>>>>>>>>>>>>>///    Unlock
73696>>>>>>>>>>>>>>>>>/// End
73696>>>>>>>>>>>>>>>>>
73696>>>>>>>>>>>>>>>>>
73696>>>>>>>>>>>>>>>>>Procedure MertechInc_SQL_SET_LOB_NULL Global String sDriver Integer iFile Integer iField
73698>>>>>>>>>>>>>>>>>    String sLOB_Args
73698>>>>>>>>>>>>>>>>>
73698>>>>>>>>>>>>>>>>>    ZeroType tMertechLOB_Args to sLOB_Args
73699>>>>>>>>>>>>>>>>>    // First move the size of the structure to the Structure
73699>>>>>>>>>>>>>>>>>    Put tMertechLOB_Args_size to sLOB_Args at tMertechLOB_Args.cbSize
73700>>>>>>>>>>>>>>>>>    Put iField                to sLOB_Args at tMertechLOB_Args.nField
73701>>>>>>>>>>>>>>>>>
73701>>>>>>>>>>>>>>>>>    Call_Driver iFile sDriver Function CALLDRV_LOB_EX_SET_NULL CALLBACK 0 PASSING MertechInc_Blank MertechInc_Blank (addressof(sLOB_Args)) RESULT MertechInc_iRet
73706>>>>>>>>>>>>>>>>>End_Procedure // MertechInc_SQL_SET_LOB_NULL
73707>>>>>>>>>>>>>>>>>
73707>>>>>>>>>>>>>>>>>
#REM ***********************************************
#REM MERTECH DATA SYSTEMS INC. - MERTECH.COM
#REM END OF MERTECH.INC
#REM ***********************************************
73707>>>>>>>>>>>>>>>>>//=============================================================================
73707>>>>>>>>>>>>>>>>>// End of Mertech.inc
73707>>>>>>>>>>>>>>>>>//=============================================================================
73707>>>>>>>>>>>>>>>Use cli.pkg
73707>>>>>>>>>>>>>>>Use ParseKeyWord.pkg
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
73707>>>>>>>>>>>>>>>>>    Define CS_SQLConnectionIDText       for "DFConnectionId"
73707>>>>>>>>>>>>>>>>>
73707>>>>>>>>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
73709>>>>>>>>>>>>>>>>>    Integer iStart iEnd
73709>>>>>>>>>>>>>>>>>    String sRetval
73709>>>>>>>>>>>>>>>>>
73709>>>>>>>>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
73710>>>>>>>>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
73711>>>>>>>>>>>>>>>>>    If (iStart = 0) Begin
73713>>>>>>>>>>>>>>>>>        Function_Return ""
73714>>>>>>>>>>>>>>>>>    End
73714>>>>>>>>>>>>>>>>>>
73714>>>>>>>>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
73715>>>>>>>>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
73716>>>>>>>>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
73718>>>>>>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
73719>>>>>>>>>>>>>>>>>    End
73719>>>>>>>>>>>>>>>>>>
73719>>>>>>>>>>>>>>>>>    Else Begin
73720>>>>>>>>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
73721>>>>>>>>>>>>>>>>>    End
73721>>>>>>>>>>>>>>>>>>
73721>>>>>>>>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
73723>>>>>>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
73724>>>>>>>>>>>>>>>>>        Decrement iEnd
73725>>>>>>>>>>>>>>>>>    End
73725>>>>>>>>>>>>>>>>>>
73725>>>>>>>>>>>>>>>>>    If (iEnd <> 0) Begin
73727>>>>>>>>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
73728>>>>>>>>>>>>>>>>>    End
73728>>>>>>>>>>>>>>>>>>
73728>>>>>>>>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
73729>>>>>>>>>>>>>>>>>
73729>>>>>>>>>>>>>>>>>    Function_Return (Trim(sRetval))
73730>>>>>>>>>>>>>>>>>End_Function
73731>>>>>>>>>>>>>>>>>
73731>>>>>>>>>>>>>>>
#REM -----------------------------------------------
#REM MERTECH DATA SYSTEMS INC. - WWW.MERTECHDATA.COM
#REM MERTECH.INC VERSION 1.0.3 FOR DATAFLEX UPDATE FRAMEWORK
#REM -----------------------------------------------
73731>>>>>>>>>>>>>>>
73731>>>>>>>>>>>>>>>Struct tCLIHandleMap
73731>>>>>>>>>>>>>>>    Integer iHdbc
73731>>>>>>>>>>>>>>>    String sDriver
73731>>>>>>>>>>>>>>>    String sConnect
73731>>>>>>>>>>>>>>>End_Struct
73731>>>>>>>>>>>>>>>
73731>>>>>>>>>>>>>>>Struct tColumnMap
73731>>>>>>>>>>>>>>>    Integer iFileNum
73731>>>>>>>>>>>>>>>    Variant[] vResultColumn
73731>>>>>>>>>>>>>>>End_Struct
73731>>>>>>>>>>>>>>>
73731>>>>>>>>>>>>>>>//*** Embedded SQL statement attribute constants
73731>>>>>>>>>>>>>>>Define SQLSTMTATTRIB_COLUMNCOUNT    for 1
73731>>>>>>>>>>>>>>>Define SQLSTMTATTRIB_ROWCOUNT       for 2
73731>>>>>>>>>>>>>>>Define SQLSTMTATTRIB_ROWCOUNT_TYPE  for 3
73731>>>>>>>>>>>>>>>Define SQLSTMTATTRIB_NUMMESSAGES    for 4
73731>>>>>>>>>>>>>>>
73731>>>>>>>>>>>>>>>//*** Embedded SQL column attribute constants
73731>>>>>>>>>>>>>>>Define SQLCOLATTRIB_SIZE           for 1
73731>>>>>>>>>>>>>>>Define SQLCOLATTRIB_LENGTH         for 1
73731>>>>>>>>>>>>>>>Define SQLCOLATTRIB_PRECISION      for 2
73731>>>>>>>>>>>>>>>Define SQLCOLATTRIB_LABEL          for 3
73731>>>>>>>>>>>>>>>Define SQLCOLATTRIB_BASECOLUMNNAME for 4
73731>>>>>>>>>>>>>>>Define SQLCOLATTRIB_BASETABLENAME  for 5
73731>>>>>>>>>>>>>>>Define SQLCOLATTRIB_SQLTYPE        for 6
73731>>>>>>>>>>>>>>>Define SQLCOLATTRIB_NULLABLE       for 7
73731>>>>>>>>>>>>>>>Define SQLCOLATTRIB_DFTYPE         for 8
73731>>>>>>>>>>>>>>>
73731>>>>>>>>>>>>>>>//*** Enforced DAC SQL.PKG Compatibility
73731>>>>>>>>>>>>>>>Define SQL_DAC_HIGH_COMPATABILITY for 1
73731>>>>>>>>>>>>>>>Define SQL_DAC_NORMAL_COMPATIBILITY  for 0
73731>>>>>>>>>>>>>>>
73731>>>>>>>>>>>>>>>Global_Variable Integer giSQLCompatibilityMode
73731>>>>>>>>>>>>>>>Move SQL_DAC_NORMAL_COMPATIBILITY to giSQLCompatibilityMode
73732>>>>>>>>>>>>>>>
73732>>>>>>>>>>>>>>>//*** Global object handle for the manager
73732>>>>>>>>>>>>>>>Global_Variable Handle _embsqlghoSQLHandleMngr
73732>>>>>>>>>>>>>>>Register_Function CompareMaps tCLIHandleMap map1 tCLIHandleMap map2 Returns Integer
73732>>>>>>>>>>>>>>>
73732>>>>>>>>>>>>>>>Class cSQLStatementDUF is a cObject
73733>>>>>>>>>>>>>>>    Procedure Construct_Object
73735>>>>>>>>>>>>>>>        Forward Send Construct_Object
73737>>>>>>>>>>>>>>>
73737>>>>>>>>>>>>>>>        Property Integer phCLIHandle      0
73738>>>>>>>>>>>>>>>        Property Integer piLastColumn     0
73739>>>>>>>>>>>>>>>        Property Integer piLastArgument   0
73740>>>>>>>>>>>>>>>        Property Integer piBindFile       0
73741>>>>>>>>>>>>>>>        Property Integer piCursorNum      0
73742>>>>>>>>>>>>>>>        Property Boolean pisBeforeFetch   True
73743>>>>>>>>>>>>>>>        Property Integer piParameterCount 0
73744>>>>>>>>>>>>>>>
73744>>>>>>>>>>>>>>>        Property Integer piDataChunkOffset 0
73745>>>>>>>>>>>>>>>        Property String psProcName ""
73746>>>>>>>>>>>>>>>        Property String psSchemaName ""
73747>>>>>>>>>>>>>>>        Property Variant[] pvParams
73748>>>>>>>>>>>>>>>        Property tColumnMap ptColumnMap
73749>>>>>>>>>>>>>>>    End_Procedure
73750>>>>>>>>>>>>>>>
73750>>>>>>>>>>>>>>>    Function SQLDateToDFDate String sSQLDate Returns String
73752>>>>>>>>>>>>>>>        Integer hoCLIHandler
73752>>>>>>>>>>>>>>>        Date dDFDate
73752>>>>>>>>>>>>>>>
73752>>>>>>>>>>>>>>>        //*** Create a CLI handler object
73752>>>>>>>>>>>>>>>        Object oSQLDFCLIHandler is a cCLIHandler
73754>>>>>>>>>>>>>>>            Move Current_Object to hoCLIHandler
73755>>>>>>>>>>>>>>>        End_Object
73756>>>>>>>>>>>>>>>
73756>>>>>>>>>>>>>>>        //*** Convert the date
73756>>>>>>>>>>>>>>>        Get CLISQLDateToDFDate of hoCLIHandler (psDRiverID(Current_Object)) sSQLDate to dDFDate
73757>>>>>>>>>>>>>>>
73757>>>>>>>>>>>>>>>        //*** Destroy the object
73757>>>>>>>>>>>>>>>        Send Destroy_Object to hoCLIHandler
73758>>>>>>>>>>>>>>>
73758>>>>>>>>>>>>>>>        Function_Return dDFDate
73759>>>>>>>>>>>>>>>    End_Function
73760>>>>>>>>>>>>>>>
73760>>>>>>>>>>>>>>>    Function DFDateToSQLDate for cSQLStatementDUF Date dDFDate Returns String
73762>>>>>>>>>>>>>>>        Integer hoCLIHandler
73762>>>>>>>>>>>>>>>        String sSQLDate
73762>>>>>>>>>>>>>>>
73762>>>>>>>>>>>>>>>        //*** Create a CLI handler object
73762>>>>>>>>>>>>>>>        Object oDFSQLCLIHandler is a cCLIHandler
73764>>>>>>>>>>>>>>>            Move Current_Object to hoCLIHandler
73765>>>>>>>>>>>>>>>        End_Object
73766>>>>>>>>>>>>>>>
73766>>>>>>>>>>>>>>>        //*** Convert the date
73766>>>>>>>>>>>>>>>        Get CLIDFDateToSQLDate of hoCLIHandler (psDRiverID(Current_Object)) dDFDate to sSQLDate
73767>>>>>>>>>>>>>>>
73767>>>>>>>>>>>>>>>        //*** Destroy the object
73767>>>>>>>>>>>>>>>        Send Destroy_Object to hoCLIHandler
73768>>>>>>>>>>>>>>>
73768>>>>>>>>>>>>>>>        Function_Return sSQLDate
73769>>>>>>>>>>>>>>>    End_Function
73770>>>>>>>>>>>>>>>
73770>>>>>>>>>>>>>>>    Function IsProcedure String sFunctionName Returns Boolean
73772>>>>>>>>>>>>>>>        String sRoutineType
73772>>>>>>>>>>>>>>>
73772>>>>>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
73810>>>>>>>>>>>>>>>>
73810>>>>>>>>>>>>>>>
73810>>>>>>>>>>>>>>>        Case Begin
73810>>>>>>>>>>>>>>>            Case (MertechInc_DriverName = SQLFLEX)
73812>>>>>>>>>>>>>>>                sql_set_stmt to (SFormat("select type from master.sys.sysobjects where name = '%1' union all select type from sys.sysobjects where name = '%1'", sFunctionName))
73844>>>>>>>>>>>>>>>                sql_prepare_stmt
73893>>>>>>>>>>>>>>>                sql_execute_stmt
73933>>>>>>>>>>>>>>>
73933>>>>>>>>>>>>>>>                sql_fetch_next_row into sRoutineType
74108>>>>>>>>>>>>>>>                If (sRoutineType = "P") Begin
74110>>>>>>>>>>>>>>>                    Move "PROCEDURE" to sRoutineType
74111>>>>>>>>>>>>>>>                End
74111>>>>>>>>>>>>>>>>
74111>>>>>>>>>>>>>>>                Else Begin
74112>>>>>>>>>>>>>>>                    Move "FUNCTION" to sRoutineType
74113>>>>>>>>>>>>>>>                End
74113>>>>>>>>>>>>>>>>
74113>>>>>>>>>>>>>>>                Case Break
74114>>>>>>>>>>>>>>>            Case (MertechInc_DriverName = MySQLFlex)
74117>>>>>>>>>>>>>>>                sql_set_stmt to (SFormat("select routine_type from information_schema.routines where routine_name = '%1'", sFunctionName))
74149>>>>>>>>>>>>>>>                sql_prepare_stmt
74198>>>>>>>>>>>>>>>                sql_execute_stmt
74238>>>>>>>>>>>>>>>                sql_fetch_next_row into sRoutineType
74413>>>>>>>>>>>>>>>
74413>>>>>>>>>>>>>>>                Case Break
74414>>>>>>>>>>>>>>>            Case (MertechInc_DriverName = ORAFLEX)
74417>>>>>>>>>>>>>>>                sql_set_stmt  to (SFormat("SELECT object_type from all_objects where object_name = '%1'", sFunctionName))
74449>>>>>>>>>>>>>>>                sql_prepare_stmt
74498>>>>>>>>>>>>>>>                sql_execute_stmt
74538>>>>>>>>>>>>>>>                sql_fetch_next_row into sRoutineType
74713>>>>>>>>>>>>>>>
74713>>>>>>>>>>>>>>>                Case Break
74714>>>>>>>>>>>>>>>            Case (MertechInc_DriverName = PgFlex)
74717>>>>>>>>>>>>>>>                // Postgres doesn't differentiate between procedures and functions, so treat everything as procedures
74717>>>>>>>>>>>>>>>                // because that is better tested.
74717>>>>>>>>>>>>>>>                Move "PROCEDURE" to sRoutineType
74718>>>>>>>>>>>>>>>                Case Break
74719>>>>>>>>>>>>>>>        Case End
74719>>>>>>>>>>>>>>>
74719>>>>>>>>>>>>>>>        Function_Return (sRoutineType = "PROCEDURE")
74720>>>>>>>>>>>>>>>    End_Function
74721>>>>>>>>>>>>>>>
74721>>>>>>>>>>>>>>>    Function ProcParams String sFunctionName Returns Variant[]
74723>>>>>>>>>>>>>>>        Variant[] vFuncParams
74724>>>>>>>>>>>>>>>        Integer i iParamType
74724>>>>>>>>>>>>>>>
74724>>>>>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
74762>>>>>>>>>>>>>>>>
74762>>>>>>>>>>>>>>>
74762>>>>>>>>>>>>>>>        Case Begin
74762>>>>>>>>>>>>>>>            Case (MertechInc_DriverName = SQLFLEX)
74764>>>>>>>>>>>>>>>                sql_set_stmt to (SFormat("sys.sp_procedure_params_managed @procedure_name = '%1'", sFunctionName))
74796>>>>>>>>>>>>>>>                sql_prepare_stmt
74845>>>>>>>>>>>>>>>                sql_execute_stmt
74885>>>>>>>>>>>>>>>
74885>>>>>>>>>>>>>>>                Repeat
74885>>>>>>>>>>>>>>>>
74885>>>>>>>>>>>>>>>                    sql_fetch_next_row
74935>>>>>>>>>>>>>>>                    If (Found) Begin
74937>>>>>>>>>>>>>>>                        sql_fetch_column 6 into iParamType
74966>>>>>>>>>>>>>>>
74966>>>>>>>>>>>>>>>                        If (iParamType = 1) Begin
74968>>>>>>>>>>>>>>>                            Move "IN" to vFuncParams[i]
74969>>>>>>>>>>>>>>>                        End
74969>>>>>>>>>>>>>>>>
74969>>>>>>>>>>>>>>>                        If (iParamType = 2) Begin
74971>>>>>>>>>>>>>>>                            Move "INOUT" to vFuncParams[i]
74972>>>>>>>>>>>>>>>                        End
74972>>>>>>>>>>>>>>>>
74972>>>>>>>>>>>>>>>                        If (iParamType = 3) Begin
74974>>>>>>>>>>>>>>>                            Move "OUT" to vFuncParams[i]
74975>>>>>>>>>>>>>>>                        End
74975>>>>>>>>>>>>>>>>
74975>>>>>>>>>>>>>>>                        If (iParamType <> 4) Begin
74977>>>>>>>>>>>>>>>                            Increment i
74978>>>>>>>>>>>>>>>                        End
74978>>>>>>>>>>>>>>>>
74978>>>>>>>>>>>>>>>                    End
74978>>>>>>>>>>>>>>>>
74978>>>>>>>>>>>>>>>                Until (not(Found))
74980>>>>>>>>>>>>>>>
74980>>>>>>>>>>>>>>>                Function_Return vFuncParams
74981>>>>>>>>>>>>>>>
74981>>>>>>>>>>>>>>>                Case Break
74982>>>>>>>>>>>>>>>            Case (MertechInc_DriverName = MySQLFlex)
74985>>>>>>>>>>>>>>>                sql_set_stmt to (SFormat("select parameter_mode from INFORMATION_SCHEMA.PARAMETERS where SPECIFIC_NAME = '%1' order by ordinal_position", sFunctionName))
75017>>>>>>>>>>>>>>>                sql_prepare_stmt
75066>>>>>>>>>>>>>>>                sql_execute_stmt
75106>>>>>>>>>>>>>>>
75106>>>>>>>>>>>>>>>                Case Break
75107>>>>>>>>>>>>>>>            Case (MertechInc_DriverName = ORAFLEX)
75110>>>>>>>>>>>>>>>                sql_set_stmt to    "SELECT all_arguments.in_out as parameter_mode "
75142>>>>>>>>>>>>>>>                sql_append_stmt to "FROM all_objects inner join all_arguments on all_objects.object_id = all_arguments.object_id "
75174>>>>>>>>>>>>>>>                sql_append_stmt to (SFormat("WHERE all_objects.object_name = '%1' order by all_arguments.position", sFunctionName))
75206>>>>>>>>>>>>>>>                sql_prepare_stmt
75255>>>>>>>>>>>>>>>                sql_execute_stmt
75295>>>>>>>>>>>>>>>
75295>>>>>>>>>>>>>>>                Case Break
75296>>>>>>>>>>>>>>>            Case (MertechInc_DriverName = PgFlex)
75299>>>>>>>>>>>>>>>                sql_set_stmt    to "select information_schema.parameters.parameter_mode "
75331>>>>>>>>>>>>>>>                sql_append_stmt to "from information_schema.routines inner join information_schema.parameters "
75363>>>>>>>>>>>>>>>                sql_append_stmt to "on information_schema.routines.specific_name=information_schema.parameters.specific_name "
75395>>>>>>>>>>>>>>>                sql_append_stmt to (SFormat("where information_schema.routines.routine_name = '%1' ", sFunctionName))
75427>>>>>>>>>>>>>>>                sql_append_stmt to "order by information_schema.parameters.ordinal_position"
75459>>>>>>>>>>>>>>>                sql_prepare_stmt
75508>>>>>>>>>>>>>>>                sql_execute_stmt
75548>>>>>>>>>>>>>>>
75548>>>>>>>>>>>>>>>                Case Break
75549>>>>>>>>>>>>>>>        Case End
75549>>>>>>>>>>>>>>>
75549>>>>>>>>>>>>>>>        Repeat
75549>>>>>>>>>>>>>>>>
75549>>>>>>>>>>>>>>>            sql_fetch_next_row into vFuncParams[i]
75724>>>>>>>>>>>>>>>            Increment i
75725>>>>>>>>>>>>>>>        Until (not(Found))
75727>>>>>>>>>>>>>>>
75727>>>>>>>>>>>>>>>        Function_Return vFuncParams
75728>>>>>>>>>>>>>>>    End_Function
75729>>>>>>>>>>>>>>>
75729>>>>>>>>>>>>>>>    Procedure Set StoreHandleInfo Handle hConn
75731>>>>>>>>>>>>>>>        Set phCLIHandle to hConn
75732>>>>>>>>>>>>>>>    End_Procedure
75733>>>>>>>>>>>>>>>
75733>>>>>>>>>>>>>>>    Procedure FreeHandle
75735>>>>>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
75773>>>>>>>>>>>>>>>>
75773>>>>>>>>>>>>>>>
75773>>>>>>>>>>>>>>>                                 Case Begin
75773>>>>>>>>>>>>>>>            Case (MertechInc_DriverName = SQLFLEX)
75775>>>>>>>>>>>>>>>                                END_CALL_PROCEDURE
75780>>>>>>>>>>>>>>>                Case Break
75781>>>>>>>>>>>>>>>            Case (MertechInc_DriverName = MySQLFlex)
75784>>>>>>>>>>>>>>>                Case Break
75785>>>>>>>>>>>>>>>            Case (MertechInc_DriverName = ORAFLEX)
75788>>>>>>>>>>>>>>>                Case Break
75789>>>>>>>>>>>>>>>            Case (MertechInc_DriverName = PgFlex)
75792>>>>>>>>>>>>>>>                Case Break
75793>>>>>>>>>>>>>>>        Case End
75793>>>>>>>>>>>>>>>
75793>>>>>>>>>>>>>>>        SQL_CLOSE_CURSOR_STMT to (piCursorNum(Self))
75831>>>>>>>>>>>>>>>>
75831>>>>>>>>>>>>>>>        Send Destroy_Object
75832>>>>>>>>>>>>>>>    End_Procedure
75833>>>>>>>>>>>>>>>
75833>>>>>>>>>>>>>>>    Procedure SQLClose
75835>>>>>>>>>>>>>>>        Send FreeHandle
75836>>>>>>>>>>>>>>>    End_Procedure
75837>>>>>>>>>>>>>>>
75837>>>>>>>>>>>>>>>    Procedure HandleError Integer ihstmt Integer ihdbc String sDrvrId String sOriginMsg
75839>>>>>>>>>>>>>>>        Integer iErrHandle
75839>>>>>>>>>>>>>>>        Integer iErrNum
75839>>>>>>>>>>>>>>>        String  sLocationInfo
75839>>>>>>>>>>>>>>>
75839>>>>>>>>>>>>>>>        //*** Get the DataFlex statement identifier
75839>>>>>>>>>>>>>>>        Move Current_object to iErrHandle
75840>>>>>>>>>>>>>>>
75840>>>>>>>>>>>>>>>        //*** Determine error number
75840>>>>>>>>>>>>>>>        If (ihstmt = 0) ;            Move CLIERR_SQLINVALID_CLI_STMT_HANDLE to iErrNum
75843>>>>>>>>>>>>>>>        Else If (ihdbc = 0) ;            Move CLIERR_SQLINVALID_CLI_CONN_HANDLE to iErrNum
75847>>>>>>>>>>>>>>>        Else If (sDrvrId = "") ;            Move CLIERR_SQLINVALID_DRIVER_ID to iErrNum
75851>>>>>>>>>>>>>>>        Else ;            Move CLIERR_SQL_ERROR to iErrNum
75853>>>>>>>>>>>>>>>
75853>>>>>>>>>>>>>>>        //*** Create location information
75853>>>>>>>>>>>>>>>        Move "[" to sLocationInfo
75854>>>>>>>>>>>>>>>        If (sOriginMsg <> "") Begin
75856>>>>>>>>>>>>>>>            Move (Append(sLocationInfo, sOriginMsg)) to sLocationInfo
75857>>>>>>>>>>>>>>>            Move (Append(sLocationInfo, ", "))       to sLocationInfo
75858>>>>>>>>>>>>>>>        End
75858>>>>>>>>>>>>>>>>
75858>>>>>>>>>>>>>>>        Move (Append(sLocationInfo, "DataFlex hstmt = ")) to sLocationInfo
75859>>>>>>>>>>>>>>>        Move (Append(sLocationInfo, iErrHandle))          to sLocationInfo
75860>>>>>>>>>>>>>>>        Move (Append(sLocationInfo, "]"))                 to sLocationInfo
75861>>>>>>>>>>>>>>>
75861>>>>>>>>>>>>>>>        //*** Generate the error
75861>>>>>>>>>>>>>>>        Error iErrNum sLocationInfo
75862>>>>>>>>>>>>>>>>
75862>>>>>>>>>>>>>>>    End_Procedure
75863>>>>>>>>>>>>>>>
75863>>>>>>>>>>>>>>>    Procedure StmtError Integer iErrNum String sErrText String sOriginMsg
75865>>>>>>>>>>>>>>>        Integer iErrHandle
75865>>>>>>>>>>>>>>>        String  sLocationInfo
75865>>>>>>>>>>>>>>>
75865>>>>>>>>>>>>>>>        //*** Get the DataFlex statement identifier
75865>>>>>>>>>>>>>>>        Move Current_object to iErrHandle
75866>>>>>>>>>>>>>>>
75866>>>>>>>>>>>>>>>        //*** Create location information
75866>>>>>>>>>>>>>>>        Move "[" to sLocationInfo
75867>>>>>>>>>>>>>>>        If (sOriginMsg <> "") Begin
75869>>>>>>>>>>>>>>>            Move (Append(sLocationInfo, sOriginMsg)) to sLocationInfo
75870>>>>>>>>>>>>>>>            Move (Append(sLocationInfo, ", "))       to sLocationInfo
75871>>>>>>>>>>>>>>>        End
75871>>>>>>>>>>>>>>>>
75871>>>>>>>>>>>>>>>        If (sErrtext <> "") Begin
75873>>>>>>>>>>>>>>>            Move (Append(sLocationInfo, sErrtext)) to sLocationInfo
75874>>>>>>>>>>>>>>>            Move (Append(sLocationInfo, ", "))     to sLocationInfo
75875>>>>>>>>>>>>>>>        End
75875>>>>>>>>>>>>>>>>
75875>>>>>>>>>>>>>>>        Move (Append(sLocationInfo, "DataFlex hstmt = ")) to sLocationInfo
75876>>>>>>>>>>>>>>>        Move (Append(sLocationInfo, iErrHandle))          to sLocationInfo
75877>>>>>>>>>>>>>>>        Move (Append(sLocationInfo, "]"))                 to sLocationInfo
75878>>>>>>>>>>>>>>>
75878>>>>>>>>>>>>>>>        //*** Generate the error
75878>>>>>>>>>>>>>>>        Error iErrNum sLocationInfo
75879>>>>>>>>>>>>>>>>
75879>>>>>>>>>>>>>>>    End_Procedure
75880>>>>>>>>>>>>>>>
75880>>>>>>>>>>>>>>>    Procedure SQLIllegalAttribute String sErrText String sOriginMsg
75882>>>>>>>>>>>>>>>        Integer bReport
75882>>>>>>>>>>>>>>>
75882>>>>>>>>>>>>>>>        Get_Attribute DF_REPORT_UNSUPPORTED_ATTRIBUTES to bReport
75885>>>>>>>>>>>>>>>        If (bReport) ;            Send StmtError CLIERR_SQLINVALID_ATTRIBUTE sErrtext sOriginMsg
75888>>>>>>>>>>>>>>>    End_Procedure
75889>>>>>>>>>>>>>>>
75889>>>>>>>>>>>>>>>    Function SQLColumnValue Integer iCol Returns String
75891>>>>>>>>>>>>>>>        String sResult
75891>>>>>>>>>>>>>>>        Integer iCols
75891>>>>>>>>>>>>>>>        Integer iOrgDateFmt
75891>>>>>>>>>>>>>>>        Integer iOrgDateSep
75891>>>>>>>>>>>>>>>        String sType
75891>>>>>>>>>>>>>>>
75891>>>>>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
75929>>>>>>>>>>>>>>>>
75929>>>>>>>>>>>>>>>
75929>>>>>>>>>>>>>>>        SQL_GET_NUM_COLS to iCols
75963>>>>>>>>>>>>>>>>
75963>>>>>>>>>>>>>>>        If (iCol <= iCols) Begin
75965>>>>>>>>>>>>>>>            //DAC SQL Driver currently uses military format for the SQL getting of dates.
75965>>>>>>>>>>>>>>>            If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
75967>>>>>>>>>>>>>>>                Get_Attribute DF_DATE_FORMAT to iOrgDateFmt
75970>>>>>>>>>>>>>>>                Get_Attribute DF_DATE_SEPARATOR to iOrgDateSep
75973>>>>>>>>>>>>>>>                Set_Attribute DF_DATE_FORMAT to DF_DATE_MILITARY
75976>>>>>>>>>>>>>>>                Set_Attribute DF_DATE_SEPARATOR to (Ascii('-'))
75979>>>>>>>>>>>>>>>            End
75979>>>>>>>>>>>>>>>>
75979>>>>>>>>>>>>>>>
75979>>>>>>>>>>>>>>>            //DAC SQL Driver cannot directly get TEXT fields into a result.
75979>>>>>>>>>>>>>>>            If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
75981>>>>>>>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol DFTYPE to sType
76022>>>>>>>>>>>>>>>>
76022>>>>>>>>>>>>>>>                If (sType=5) Begin
76024>>>>>>>>>>>>>>>                    Move "" to sResult
76025>>>>>>>>>>>>>>>                End
76025>>>>>>>>>>>>>>>>
76025>>>>>>>>>>>>>>>                Else Begin
76026>>>>>>>>>>>>>>>                    SQL_FETCH_COLUMN iCol into sResult
76055>>>>>>>>>>>>>>>                End
76055>>>>>>>>>>>>>>>>
76055>>>>>>>>>>>>>>>            End
76055>>>>>>>>>>>>>>>>
76055>>>>>>>>>>>>>>>            Else Begin
76056>>>>>>>>>>>>>>>               SQL_FETCH_COLUMN iCol into sResult
76085>>>>>>>>>>>>>>>            End
76085>>>>>>>>>>>>>>>>
76085>>>>>>>>>>>>>>>
76085>>>>>>>>>>>>>>>            If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
76087>>>>>>>>>>>>>>>                Set_Attribute DF_DATE_FORMAT to iOrgDateFmt
76090>>>>>>>>>>>>>>>                Set_Attribute DF_DATE_SEPARATOR to iOrgDateSep
76093>>>>>>>>>>>>>>>            End
76093>>>>>>>>>>>>>>>>
76093>>>>>>>>>>>>>>>
76093>>>>>>>>>>>>>>>            Function_Return sResult
76094>>>>>>>>>>>>>>>        End
76094>>>>>>>>>>>>>>>>
76094>>>>>>>>>>>>>>>        Else Begin
76095>>>>>>>>>>>>>>>            Send HandleError (phCLIHandle(Self)) (phCLIHandle(Parent(Self))) (psDriverID(Self)) "SQLColumnValue"
76096>>>>>>>>>>>>>>>        End
76096>>>>>>>>>>>>>>>>
76096>>>>>>>>>>>>>>>        Function_Return ""
76097>>>>>>>>>>>>>>>    End_Function
76098>>>>>>>>>>>>>>>
76098>>>>>>>>>>>>>>>    Function SQLNextColumn Returns String
76100>>>>>>>>>>>>>>>        Integer iCol
76100>>>>>>>>>>>>>>>        String  sResult
76100>>>>>>>>>>>>>>>
76100>>>>>>>>>>>>>>>        Get piLastColumn to iCol
76101>>>>>>>>>>>>>>>        Increment iCol
76102>>>>>>>>>>>>>>>        Get SQLColumnValue iCol to sResult
76103>>>>>>>>>>>>>>>        Set piLastColumn to iCol
76104>>>>>>>>>>>>>>>
76104>>>>>>>>>>>>>>>        Function_Return sResult
76105>>>>>>>>>>>>>>>    End_Function
76106>>>>>>>>>>>>>>>
76106>>>>>>>>>>>>>>>    Procedure SQLPrepare String sStatement
76108>>>>>>>>>>>>>>>        tColumnMap tColumnMap
76108>>>>>>>>>>>>>>>        tColumnMap tColumnMap
76108>>>>>>>>>>>>>>>        Set ptColumnMap to tColumnMap
76109>>>>>>>>>>>>>>>        Set pisBeforeFetch to True
76110>>>>>>>>>>>>>>>
76110>>>>>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
76148>>>>>>>>>>>>>>>>
76148>>>>>>>>>>>>>>>        SQL_SET_STMT to sStatement
76180>>>>>>>>>>>>>>>
76180>>>>>>>>>>>>>>>        SQL_PREPARE_STMT
76229>>>>>>>>>>>>>>>    End_Procedure
76230>>>>>>>>>>>>>>>
76230>>>>>>>>>>>>>>>    Procedure SQLExecute
76232>>>>>>>>>>>>>>>        SQL_EXECUTE_STMT
76272>>>>>>>>>>>>>>>    End_Procedure
76273>>>>>>>>>>>>>>>
76273>>>>>>>>>>>>>>>    Procedure SQLExecDirect String sStatement
76275>>>>>>>>>>>>>>>        tColumnMap tColumnMap
76275>>>>>>>>>>>>>>>        tColumnMap tColumnMap
76275>>>>>>>>>>>>>>>        Set ptColumnMap to tColumnMap
76276>>>>>>>>>>>>>>>        Set pisBeforeFetch to True
76277>>>>>>>>>>>>>>>
76277>>>>>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
76315>>>>>>>>>>>>>>>>
76315>>>>>>>>>>>>>>>
76315>>>>>>>>>>>>>>>        SQL_SET_STMT to sStatement
76347>>>>>>>>>>>>>>>        SQL_PREPARE_STMT
76396>>>>>>>>>>>>>>>        SQL_EXECUTE_STMT
76436>>>>>>>>>>>>>>>    End_Procedure
76437>>>>>>>>>>>>>>>
76437>>>>>>>>>>>>>>>    Function SQLFetch Returns Integer
76439>>>>>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
76477>>>>>>>>>>>>>>>>
76477>>>>>>>>>>>>>>>        Set pisBeforeFetch to False
76478>>>>>>>>>>>>>>>
76478>>>>>>>>>>>>>>>        SQL_FETCH_NEXT_ROW
76528>>>>>>>>>>>>>>>        Function_Return (Found)
76529>>>>>>>>>>>>>>>    End_Function
76530>>>>>>>>>>>>>>>
76530>>>>>>>>>>>>>>>    Procedure SQLBindFile Integer iFileNum
76532>>>>>>>>>>>>>>>        tColumnMap tColumnMap
76532>>>>>>>>>>>>>>>        tColumnMap tColumnMap
76532>>>>>>>>>>>>>>>        String[] sBindFileColumns
76533>>>>>>>>>>>>>>>        Integer iColCnt i iDateFormat iResultColumnType iBindFileColumnType
76533>>>>>>>>>>>>>>>        String sColumnName
76533>>>>>>>>>>>>>>>        Variant vFieldValue
76533>>>>>>>>>>>>>>>        Boolean isRecnumTable
76533>>>>>>>>>>>>>>>
76533>>>>>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
76571>>>>>>>>>>>>>>>>
76571>>>>>>>>>>>>>>>
76571>>>>>>>>>>>>>>>        Get_Attribute DF_FILE_RECNUM_TABLE of iFileNum to isRecnumTable
76574>>>>>>>>>>>>>>>        Get ptColumnMap to tColumnMap
76575>>>>>>>>>>>>>>>
76575>>>>>>>>>>>>>>>        If (tColumnMap.iFileNum <> iFileNum) Begin
76577>>>>>>>>>>>>>>>            Move iFileNum to tColumnMap.iFileNum
76578>>>>>>>>>>>>>>>
76578>>>>>>>>>>>>>>>            // First we build an array of the column names (in order) from the file buffer to bind to
76578>>>>>>>>>>>>>>>            Get_Attribute DF_FILE_NUMBER_FIELDS of iFileNum to iColCnt
76581>>>>>>>>>>>>>>>            For i from 0 to iColCnt
76587>>>>>>>>>>>>>>>>
76587>>>>>>>>>>>>>>>                If (isRecnumTable) Begin
76589>>>>>>>>>>>>>>>                    Get_Attribute DF_FIELD_NAME of iFileNum i to sColumnName
76592>>>>>>>>>>>>>>>                End
76592>>>>>>>>>>>>>>>>
76592>>>>>>>>>>>>>>>                Else Begin
76593>>>>>>>>>>>>>>>                    Move "" to sColumnName
76594>>>>>>>>>>>>>>>                End
76594>>>>>>>>>>>>>>>>
76594>>>>>>>>>>>>>>>
76594>>>>>>>>>>>>>>>                Move (Uppercase(sColumnName)) to sBindFileColumns[i]
76595>>>>>>>>>>>>>>>            Loop
76596>>>>>>>>>>>>>>>>
76596>>>>>>>>>>>>>>>
76596>>>>>>>>>>>>>>>            // Next we iterate over the columns in the resultset.  Any column names that match we
76596>>>>>>>>>>>>>>>            // set its match location into an array that maps each resultset column to its matching
76596>>>>>>>>>>>>>>>            // column number in the file buffer.  If there is no match, we set that resultset
76596>>>>>>>>>>>>>>>            // column mappped column to -1.
76596>>>>>>>>>>>>>>>            //
76596>>>>>>>>>>>>>>>            // Since Arrays are zero based and columns are numbered from 1, when we actually map
76596>>>>>>>>>>>>>>>            // to set the value, we need to add 1 to array indexer to get the proper resultset
76596>>>>>>>>>>>>>>>            // column AND we need to add 1 to the mapped-to column since it was loaded into a zero
76596>>>>>>>>>>>>>>>            // based array also.  (Ex: vResultColumn[0] = 2 means column 1 from the resultset maps
76596>>>>>>>>>>>>>>>            // to Column 3 of the file buffer)
76596>>>>>>>>>>>>>>>
76596>>>>>>>>>>>>>>>            SQL_GET_NUM_COLS to iColCnt
76630>>>>>>>>>>>>>>>>
76630>>>>>>>>>>>>>>>            For i from 1 to iColCnt
76636>>>>>>>>>>>>>>>>
76636>>>>>>>>>>>>>>>                SQL_GET_COL_NAME i to sColumnName
76676>>>>>>>>>>>>>>>>
76676>>>>>>>>>>>>>>>                // Because SearchArray returns -1 if there isn't a match, we don't need to do
76676>>>>>>>>>>>>>>>                // anything to make an "unmapped column" have a value of -1.
76676>>>>>>>>>>>>>>>                Move (SearchArray(Uppercase(sColumnName), sBindFileColumns)) to tColumnMap.vResultColumn[i-1]
76677>>>>>>>>>>>>>>>
76677>>>>>>>>>>>>>>>                // If the types don't match between the columns, then "unmap" the column.  This
76677>>>>>>>>>>>>>>>                // should only occur when you're not mapping to the same file as the resultset.
76677>>>>>>>>>>>>>>>                // In this case, sql.pkg silently does nothing, so we need to duplicate this instead
76677>>>>>>>>>>>>>>>                // of generating an error.  If the mapping is to a string, then any type can be
76677>>>>>>>>>>>>>>>                // converted to a string so its okay.
76677>>>>>>>>>>>>>>>                If (tColumnMap.vResultColumn[i-1] <> -1) Begin
76679>>>>>>>>>>>>>>>                    SQL_GET_COL_ATTRIBUTE of i DFTYPE to iResultColumnType
76720>>>>>>>>>>>>>>>>
76720>>>>>>>>>>>>>>>                    Get_Attribute DF_FIELD_TYPE of iFileNum (tColumnMap.vResultColumn[i-1]) to iBindFileColumnType
76723>>>>>>>>>>>>>>>
76723>>>>>>>>>>>>>>>                    // If the conversion is to string (even if the resultset column is something
76723>>>>>>>>>>>>>>>                    // else) its ok, so Break out of the If block before we muck things up.
76723>>>>>>>>>>>>>>>                    If (iBindFileColumnType = DF_ASCII) Break
76726>>>>>>>>>>>>>>>
76726>>>>>>>>>>>>>>>                    // Otherwise, break the mapping
76726>>>>>>>>>>>>>>>                    If (iResultColumnType <> iBindFileColumnType) Begin
76728>>>>>>>>>>>>>>>                        Move -1 to tColumnMap.vResultColumn[i-1]
76729>>>>>>>>>>>>>>>                    End
76729>>>>>>>>>>>>>>>>
76729>>>>>>>>>>>>>>>                End
76729>>>>>>>>>>>>>>>>
76729>>>>>>>>>>>>>>>            Loop
76730>>>>>>>>>>>>>>>>
76730>>>>>>>>>>>>>>>
76730>>>>>>>>>>>>>>>            Set ptColumnMap to tColumnMap
76731>>>>>>>>>>>>>>>        End
76731>>>>>>>>>>>>>>>>
76731>>>>>>>>>>>>>>>
76731>>>>>>>>>>>>>>>        Get SQL_USE_DATAFLEX_DATEFORMAT to iDateFormat
76732>>>>>>>>>>>>>>>        Set SQL_USE_DATAFLEX_DATEFORMAT to True
76733>>>>>>>>>>>>>>>        Clear iFileNum
76734>>>>>>>>>>>>>>>        For i from 0 to (SizeOfArray(tColumnMap.vResultColumn)-1)
76740>>>>>>>>>>>>>>>>
76740>>>>>>>>>>>>>>>            If (tColumnMap.vResultColumn[i] > -1) Begin
76742>>>>>>>>>>>>>>>                SQL_FETCH_COLUMN (i+1) into vFieldValue
76771>>>>>>>>>>>>>>>                Set_Field_Value iFileNum (tColumnMap.vResultColumn[i]) to vFieldValue
76774>>>>>>>>>>>>>>>            End
76774>>>>>>>>>>>>>>>>
76774>>>>>>>>>>>>>>>        Loop
76775>>>>>>>>>>>>>>>>
76775>>>>>>>>>>>>>>>        Set_Attribute DF_FILE_STATUS of iFileNum to DF_FILE_ACTIVE
76778>>>>>>>>>>>>>>>        Set SQL_USE_DATAFLEX_DATEFORMAT to iDateFormat
76779>>>>>>>>>>>>>>>    End_Procedure
76780>>>>>>>>>>>>>>>
76780>>>>>>>>>>>>>>>    Function SQLGetData Integer iCol Integer iLen Returns String
76782>>>>>>>>>>>>>>>        String data
76782>>>>>>>>>>>>>>>        Integer retlen
76782>>>>>>>>>>>>>>>
76782>>>>>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
76820>>>>>>>>>>>>>>>>
76820>>>>>>>>>>>>>>>
76820>>>>>>>>>>>>>>>        SQL_SET_CHUNK_SIZE to iLen
76861>>>>>>>>>>>>>>>>
76861>>>>>>>>>>>>>>>        SQL_GET_DATA_CHUNK COLUMN iCol OFFSET (piDataChunkOffset(Self)) to data retlen
76895>>>>>>>>>>>>>>>>
76895>>>>>>>>>>>>>>>        Set piDataChunkOffset to (piDataChunkOffset(Self)+retlen)
76896>>>>>>>>>>>>>>>
76896>>>>>>>>>>>>>>>        Function_Return data
76897>>>>>>>>>>>>>>>    End_Function
76898>>>>>>>>>>>>>>>
76898>>>>>>>>>>>>>>>    Function SQLColumnMap String sColname Returns Integer
76900>>>>>>>>>>>>>>>        Integer iNumColumns i iIndex
76900>>>>>>>>>>>>>>>        String[] cols
76901>>>>>>>>>>>>>>>
76901>>>>>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
76939>>>>>>>>>>>>>>>>
76939>>>>>>>>>>>>>>>
76939>>>>>>>>>>>>>>>        Get SQLStmtAttribute SQLSTMTATTRIB_COLUMNCOUNT to iNumColumns
76940>>>>>>>>>>>>>>>
76940>>>>>>>>>>>>>>>        For i from 1 to iNumColumns
76946>>>>>>>>>>>>>>>>
76946>>>>>>>>>>>>>>>            SQL_GET_COL_NAME i to cols[i-1]
76986>>>>>>>>>>>>>>>>
76986>>>>>>>>>>>>>>>            Move (trim(Uppercase(cols[i-1]))) to cols[i-1]
76987>>>>>>>>>>>>>>>        Loop
76988>>>>>>>>>>>>>>>>
76988>>>>>>>>>>>>>>>
76988>>>>>>>>>>>>>>>        Move (trim(Uppercase(sColname))) to sColname
76989>>>>>>>>>>>>>>>        Move (SearchArray(sColname, cols)) to iIndex
76990>>>>>>>>>>>>>>>        Function_Return (iIndex+1)  // even if searcharray returns -1 (not found) this expects 0 for not found, so it's ok
76991>>>>>>>>>>>>>>>    End_Function
76992>>>>>>>>>>>>>>>
76992>>>>>>>>>>>>>>>    Function SQLStmtAttribute Integer iAttribId Returns String
76994>>>>>>>>>>>>>>>        Integer iCnt
76994>>>>>>>>>>>>>>>
76994>>>>>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
77032>>>>>>>>>>>>>>>>
77032>>>>>>>>>>>>>>>
77032>>>>>>>>>>>>>>>        Case Begin
77032>>>>>>>>>>>>>>>            Case (iAttribId = SQLSTMTATTRIB_COLUMNCOUNT)
77034>>>>>>>>>>>>>>>                SQL_GET_NUM_COLS to iCnt
77068>>>>>>>>>>>>>>>>
77068>>>>>>>>>>>>>>>                Function_Return iCnt
77069>>>>>>>>>>>>>>>                Case Break
77070>>>>>>>>>>>>>>>            Case (iAttribId = SQLSTMTATTRIB_ROWCOUNT)
77073>>>>>>>>>>>>>>>                SQL_GET_NUM_ROWS to iCnt
77107>>>>>>>>>>>>>>>>
77107>>>>>>>>>>>>>>>
77107>>>>>>>>>>>>>>>                //DAC Driver doesn't know the rowcount before the first fetch.
77107>>>>>>>>>>>>>>>                If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
77109>>>>>>>>>>>>>>>                    If (pisBeforeFetch(Self)) Begin
77111>>>>>>>>>>>>>>>                        Function_Return -1
77112>>>>>>>>>>>>>>>                    End
77112>>>>>>>>>>>>>>>>
77112>>>>>>>>>>>>>>>                End
77112>>>>>>>>>>>>>>>>
77112>>>>>>>>>>>>>>>
77112>>>>>>>>>>>>>>>                Function_Return iCnt
77113>>>>>>>>>>>>>>>                Case Break
77114>>>>>>>>>>>>>>>            Case (iAttribId = SQLSTMTATTRIB_ROWCOUNT_TYPE)
77117>>>>>>>>>>>>>>>                // TODO: Need something to indicate the quality of the SQL_GET_NUM_ROWS, or fake till I make it
77117>>>>>>>>>>>>>>>                Case Break
77118>>>>>>>>>>>>>>>            Case (iAttribId = SQLSTMTATTRIB_NUMMESSAGES)
77121>>>>>>>>>>>>>>>                Function_Return -1
77122>>>>>>>>>>>>>>>                // TODO: Are the messages returned in SQLGetMessage from the driver, or from the underlying connection?
77122>>>>>>>>>>>>>>>                Case Break
77123>>>>>>>>>>>>>>>            Case Else
77123>>>>>>>>>>>>>>>        Case End
77123>>>>>>>>>>>>>>>
77123>>>>>>>>>>>>>>>        Function_Return ""
77124>>>>>>>>>>>>>>>    End_Function
77125>>>>>>>>>>>>>>>
77125>>>>>>>>>>>>>>>    Function SQLColAttribute Integer iCol Integer iAttribId Returns String
77127>>>>>>>>>>>>>>>        String sValue
77127>>>>>>>>>>>>>>>        Integer iSQLType
77127>>>>>>>>>>>>>>>        Integer iDFType
77127>>>>>>>>>>>>>>>
77127>>>>>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
77165>>>>>>>>>>>>>>>>
77165>>>>>>>>>>>>>>>        SQL_GET_COL_ATTRIBUTE of iCol SQLTYPE to iSQLType
77206>>>>>>>>>>>>>>>>
77206>>>>>>>>>>>>>>>        SQL_GET_COL_ATTRIBUTE of iCol DFTYPE to iDFType
77247>>>>>>>>>>>>>>>>
77247>>>>>>>>>>>>>>>
77247>>>>>>>>>>>>>>>        Case Begin
77247>>>>>>>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_SIZE)
77249>>>>>>>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol SIZE to sValue
77290>>>>>>>>>>>>>>>>
77290>>>>>>>>>>>>>>>
77290>>>>>>>>>>>>>>>                //DAC Driver uses different values.
77290>>>>>>>>>>>>>>>                If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
77292>>>>>>>>>>>>>>>                    If (iSQLType=12) Begin
77294>>>>>>>>>>>>>>>                        Move (Integer(sValue-1)) to sValue
77295>>>>>>>>>>>>>>>                    End
77295>>>>>>>>>>>>>>>>
77295>>>>>>>>>>>>>>>                    If (iDFType=5) Begin
77297>>>>>>>>>>>>>>>                        Move "0" to sValue
77298>>>>>>>>>>>>>>>                    End
77298>>>>>>>>>>>>>>>>
77298>>>>>>>>>>>>>>>                    If (iSQLType=40) Begin
77300>>>>>>>>>>>>>>>                        Move "10" to sValue
77301>>>>>>>>>>>>>>>                    End
77301>>>>>>>>>>>>>>>>
77301>>>>>>>>>>>>>>>                End
77301>>>>>>>>>>>>>>>>
77301>>>>>>>>>>>>>>>
77301>>>>>>>>>>>>>>>                Case Break
77302>>>>>>>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_PRECISION)
77305>>>>>>>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol DECIMALS to sValue
77346>>>>>>>>>>>>>>>>
77346>>>>>>>>>>>>>>>                Case Break
77347>>>>>>>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_LABEL)
77350>>>>>>>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol COLUMN_NAME to sValue
77391>>>>>>>>>>>>>>>>
77391>>>>>>>>>>>>>>>                Case Break
77392>>>>>>>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_BASECOLUMNNAME)
77395>>>>>>>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol COLUMN_NAME to sValue
77436>>>>>>>>>>>>>>>>
77436>>>>>>>>>>>>>>>
77436>>>>>>>>>>>>>>>                //DAC Driver doesn't use Base Column Name.
77436>>>>>>>>>>>>>>>                If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
77438>>>>>>>>>>>>>>>                    Move "" to sValue
77439>>>>>>>>>>>>>>>                End
77439>>>>>>>>>>>>>>>>
77439>>>>>>>>>>>>>>>
77439>>>>>>>>>>>>>>>                Case Break
77440>>>>>>>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_BASETABLENAME)
77443>>>>>>>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol TABLE_NAME to sValue
77484>>>>>>>>>>>>>>>>
77484>>>>>>>>>>>>>>>                Case Break
77485>>>>>>>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_SQLTYPE)
77488>>>>>>>>>>>>>>>                Move iSQLType to sValue
77489>>>>>>>>>>>>>>>
77489>>>>>>>>>>>>>>>                //DAC Driver uses different values.
77489>>>>>>>>>>>>>>>                If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
77491>>>>>>>>>>>>>>>                    If (iSQLType=2) Begin
77493>>>>>>>>>>>>>>>                        Move "3" to sValue
77494>>>>>>>>>>>>>>>                    End
77494>>>>>>>>>>>>>>>>
77494>>>>>>>>>>>>>>>                    If (iSQLType=-99) Begin
77496>>>>>>>>>>>>>>>                        Move "12" to sValue
77497>>>>>>>>>>>>>>>                    End
77497>>>>>>>>>>>>>>>>
77497>>>>>>>>>>>>>>>                    If (iSQLType=40) Begin
77499>>>>>>>>>>>>>>>                        Move "91" to sValue
77500>>>>>>>>>>>>>>>                    End
77500>>>>>>>>>>>>>>>>
77500>>>>>>>>>>>>>>>                End
77500>>>>>>>>>>>>>>>>
77500>>>>>>>>>>>>>>>
77500>>>>>>>>>>>>>>>                Case Break
77501>>>>>>>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_NULLABLE)
77504>>>>>>>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol NULLABLE to sValue
77545>>>>>>>>>>>>>>>>
77545>>>>>>>>>>>>>>>                Case Break
77546>>>>>>>>>>>>>>>            Case (iAttribId = SQLCOLATTRIB_DFTYPE)
77549>>>>>>>>>>>>>>>                SQL_GET_COL_ATTRIBUTE of iCol DFTYPE to sValue
77590>>>>>>>>>>>>>>>>
77590>>>>>>>>>>>>>>>
77590>>>>>>>>>>>>>>>                //DAC Driver uses different values.
77590>>>>>>>>>>>>>>>                If (giSQLCompatibilityMode=SQL_DAC_HIGH_COMPATABILITY) Begin
77592>>>>>>>>>>>>>>>                    If (iDFType = 5) Begin
77594>>>>>>>>>>>>>>>                        Move "0" to sValue
77595>>>>>>>>>>>>>>>                    End
77595>>>>>>>>>>>>>>>>
77595>>>>>>>>>>>>>>>                End
77595>>>>>>>>>>>>>>>>
77595>>>>>>>>>>>>>>>                Case Break
77596>>>>>>>>>>>>>>>        Case End
77596>>>>>>>>>>>>>>>
77596>>>>>>>>>>>>>>>        Function_Return sValue
77597>>>>>>>>>>>>>>>    End_Function
77598>>>>>>>>>>>>>>>
77598>>>>>>>>>>>>>>>    Procedure SQLSetProcedureName String sProcName String sSchemaArg
77600>>>>>>>>>>>>>>>        Set psProcName to sProcName
77601>>>>>>>>>>>>>>>        If (Num_Arguments >= 2) ;            Set psSchemaName to sSchemaArg
77604>>>>>>>>>>>>>>>        Else ;            Set psSchemaName to ""
77606>>>>>>>>>>>>>>>    End_Procedure
77607>>>>>>>>>>>>>>>
77607>>>>>>>>>>>>>>>    Procedure SQLSetNextArgument String sArgument
77609>>>>>>>>>>>>>>>        Integer iArgnum
77609>>>>>>>>>>>>>>>
77609>>>>>>>>>>>>>>>        Get piLastArgument to iArgnum
77610>>>>>>>>>>>>>>>        Increment iArgnum
77611>>>>>>>>>>>>>>>        Send SQLSetArgument iArgnum sArgument
77612>>>>>>>>>>>>>>>        Set piLastArgument to iArgnum
77613>>>>>>>>>>>>>>>    End_Procedure
77614>>>>>>>>>>>>>>>
77614>>>>>>>>>>>>>>>    Procedure SQLSetArgument Integer iArgnum String sArgument
77616>>>>>>>>>>>>>>>        Variant[] vParams
77617>>>>>>>>>>>>>>>
77617>>>>>>>>>>>>>>>        Get pvParams to vParams
77618>>>>>>>>>>>>>>>        Move sArgument to vParams[iArgnum-1]
77619>>>>>>>>>>>>>>>        Set pvParams to vParams
77620>>>>>>>>>>>>>>>
77620>>>>>>>>>>>>>>>    End_Procedure
77621>>>>>>>>>>>>>>>
77621>>>>>>>>>>>>>>>    Procedure SQLCall
77623>>>>>>>>>>>>>>>        Variant[] vParams
77624>>>>>>>>>>>>>>>        Variant[] vParamOpts
77625>>>>>>>>>>>>>>>        Integer i
77625>>>>>>>>>>>>>>>        Integer iMax
77625>>>>>>>>>>>>>>>        Integer iParamsIn
77625>>>>>>>>>>>>>>>        String sParameter
77625>>>>>>>>>>>>>>>        Boolean bIsProcedure
77625>>>>>>>>>>>>>>>
77625>>>>>>>>>>>>>>>        SQL_SET_CURRENT_CURSOR_STMT to (piCursorNum(Self))
77663>>>>>>>>>>>>>>>>
77663>>>>>>>>>>>>>>>
77663>>>>>>>>>>>>>>>        Get pvParams to vParams
77664>>>>>>>>>>>>>>>
77664>>>>>>>>>>>>>>>        // First, we need to figure out if this is a procedure or a function. Then if
77664>>>>>>>>>>>>>>>        // it's a procedure, "analyze" it to figure out which parameters are IN,
77664>>>>>>>>>>>>>>>        // OUT, or IN_OUT.  Then we adjust how we call SQL_SET_PROCEDURE_PARAMETER
77664>>>>>>>>>>>>>>>        // so that after the call you can retrieve the value.
77664>>>>>>>>>>>>>>>
77664>>>>>>>>>>>>>>>        Get IsProcedure (psProcName(Self)) to bIsProcedure
77665>>>>>>>>>>>>>>>
77665>>>>>>>>>>>>>>>        If (bIsProcedure) Begin
77667>>>>>>>>>>>>>>>            Get ProcParams (psProcName(Self)) to vParamOpts
77668>>>>>>>>>>>>>>>
77668>>>>>>>>>>>>>>>            Move (sizeOfArray(vParamOpts)) to iMax
77669>>>>>>>>>>>>>>>            Move (SizeOfArray(vParams)) to iParamsIn
77670>>>>>>>>>>>>>>>            Set piParameterCount to iMax
77671>>>>>>>>>>>>>>>
77671>>>>>>>>>>>>>>>            SQL_SET_PROCEDURE_NAME (psProcName(Self)) NUMPAR iMax
77715>>>>>>>>>>>>>>>            For i from 1 to iMax
77721>>>>>>>>>>>>>>>>
77721>>>>>>>>>>>>>>>                If ( (i-1) >= iParamsIn) Begin
77723>>>>>>>>>>>>>>>                    Move "" to sParameter
77724>>>>>>>>>>>>>>>                End
77724>>>>>>>>>>>>>>>>
77724>>>>>>>>>>>>>>>                Else Begin
77725>>>>>>>>>>>>>>>                    Move vParams[i-1] to sParameter
77726>>>>>>>>>>>>>>>                End
77726>>>>>>>>>>>>>>>>
77726>>>>>>>>>>>>>>>
77726>>>>>>>>>>>>>>>                Case Begin
77726>>>>>>>>>>>>>>>                    Case (vParamOpts[i-1] = "IN")
77728>>>>>>>>>>>>>>>                        SQL_SET_PROCEDURE_PARAMETER i to sParameter IN
77765>>>>>>>>>>>>>>>>
77765>>>>>>>>>>>>>>>                        Case Break
77766>>>>>>>>>>>>>>>                    Case (vParamOpts[i-1] = "OUT")
77769>>>>>>>>>>>>>>>                        SQL_SET_PROCEDURE_PARAMETER i to sParameter OUT
77806>>>>>>>>>>>>>>>>
77806>>>>>>>>>>>>>>>                        Case Break
77807>>>>>>>>>>>>>>>                    Case (vParamOpts[i-1] = "IN/OUT" or vParamOpts[i-1] = "INOUT")
77810>>>>>>>>>>>>>>>                        SQL_SET_PROCEDURE_PARAMETER i to sParameter IN_OUT
77847>>>>>>>>>>>>>>>>
77847>>>>>>>>>>>>>>>                        Case Break
77848>>>>>>>>>>>>>>>                Case End
77848>>>>>>>>>>>>>>>            Loop
77849>>>>>>>>>>>>>>>>
77849>>>>>>>>>>>>>>>
77849>>>>>>>>>>>>>>>            SQL_PROCEDURE_EXECUTE
77889>>>>>>>>>>>>>>>        End
77889>>>>>>>>>>>>>>>>
77889>>>>>>>>>>>>>>>        Else Begin
77890>>>>>>>>>>>>>>>            SQL_SET_FUNCTION_NAME (psProcName(Self)) NUMPAR (SizeOfArray(vParams))
77938>>>>>>>>>>>>>>>            For i from 1 to (SizeOfArray(vParams))
77944>>>>>>>>>>>>>>>>
77944>>>>>>>>>>>>>>>                SQL_SET_FUNCTION_PARAMETER i to vParams[i-1]
78113>>>>>>>>>>>>>>>>
78113>>>>>>>>>>>>>>>            Loop
78114>>>>>>>>>>>>>>>>
78114>>>>>>>>>>>>>>>
78114>>>>>>>>>>>>>>>            SQL_FUNCTION_EXECUTE
78115>>>>>>>>>>>>>>>        End
78115>>>>>>>>>>>>>>>>
78115>>>>>>>>>>>>>>>    End_Procedure
78116>>>>>>>>>>>>>>>
78116>>>>>>>>>>>>>>>    Function SQLGetNextArgument Returns String
78118>>>>>>>>>>>>>>>        Integer iArgnum
78118>>>>>>>>>>>>>>>        String  sResult
78118>>>>>>>>>>>>>>>
78118>>>>>>>>>>>>>>>        Get piLastArgument to iArgnum
78119>>>>>>>>>>>>>>>        Increment iArgnum
78120>>>>>>>>>>>>>>>        Get SQLGetArgument iArgnum to sResult
78121>>>>>>>>>>>>>>>        Set piLastArgument to iArgnum
78122>>>>>>>>>>>>>>>
78122>>>>>>>>>>>>>>>        Function_Return sResult
78123>>>>>>>>>>>>>>>    End_Function
78124>>>>>>>>>>>>>>>
78124>>>>>>>>>>>>>>>    Function SQLGetArgument Integer iArgnum Returns String
78126>>>>>>>>>>>>>>>        String retval
78126>>>>>>>>>>>>>>>
78126>>>>>>>>>>>>>>>        If ( (piParameterCount(Self)) < iArgnum) Begin
78128>>>>>>>>>>>>>>>            Function_Return ""
78129>>>>>>>>>>>>>>>        End
78129>>>>>>>>>>>>>>>>
78129>>>>>>>>>>>>>>>        SQL_GET_PROCEDURE_PARAMETER iArgnum to retval
78185>>>>>>>>>>>>>>>>
78185>>>>>>>>>>>>>>>
78185>>>>>>>>>>>>>>>        Function_Return retval
78186>>>>>>>>>>>>>>>    End_Function
78187>>>>>>>>>>>>>>>
78187>>>>>>>>>>>>>>>    Function SQLReturnValue Returns String
78189>>>>>>>>>>>>>>>        String retval
78189>>>>>>>>>>>>>>>
78189>>>>>>>>>>>>>>>        SQL_GET_FUNCTION_RETURN to retval
78277>>>>>>>>>>>>>>>        Function_Return retval
78278>>>>>>>>>>>>>>>    End_Function
78279>>>>>>>>>>>>>>>
78279>>>>>>>>>>>>>>>    Function SQLNextResultSet Returns Integer
78281>>>>>>>>>>>>>>>        SQL_NEXT_RESULT_SET
78317>>>>>>>>>>>>>>>
78317>>>>>>>>>>>>>>>        Function_Return (Found)
78318>>>>>>>>>>>>>>>    End_Function
78319>>>>>>>>>>>>>>>
78319>>>>>>>>>>>>>>>    Function SQLGetMessage Integer iMessageNum Returns String
78321>>>>>>>>>>>>>>>        // TODO
78321>>>>>>>>>>>>>>>        Function_Return ""
78322>>>>>>>>>>>>>>>    End_Function
78323>>>>>>>>>>>>>>>
78323>>>>>>>>>>>>>>>    Procedure SQLFetchActivatesBuffer Integer iFileNum Integer bState
78325>>>>>>>>>>>>>>>        // TODO
78325>>>>>>>>>>>>>>>    End_Procedure
78326>>>>>>>>>>>>>>>
78326>>>>>>>>>>>>>>>End_Class
78327>>>>>>>>>>>>>>>
78327>>>>>>>>>>>>>>>Class cSQLConnectionDUF is a cObject
78328>>>>>>>>>>>>>>>    Procedure Construct_Object
78330>>>>>>>>>>>>>>>        Forward Send Construct_Object
78332>>>>>>>>>>>>>>>
78332>>>>>>>>>>>>>>>        Property Handle phCLIHandle 0
78333>>>>>>>>>>>>>>>        Property String psDriverID MertechInc_DriverName
78334>>>>>>>>>>>>>>>        Property Integer piBindFile 0
78335>>>>>>>>>>>>>>>        Property String psUsername ""
78336>>>>>>>>>>>>>>>        Property String psPassword ""
78337>>>>>>>>>>>>>>>
78337>>>>>>>>>>>>>>>        Property String psCurrentDatabase ""
78338>>>>>>>>>>>>>>>
78338>>>>>>>>>>>>>>>        Property tCLIHandleMap ptCLIHandleMap
78339>>>>>>>>>>>>>>>    End_Procedure
78340>>>>>>>>>>>>>>>
78340>>>>>>>>>>>>>>>    Procedure StoreHandleInfo Handle hCLIHandle String sDrvrId Handle iParentHandle
78342>>>>>>>>>>>>>>>        Set phCLIHandle      to hCLIHandle
78343>>>>>>>>>>>>>>>        Set psDriverID       to sDrvrId
78344>>>>>>>>>>>>>>>    End_Procedure
78345>>>>>>>>>>>>>>>
78345>>>>>>>>>>>>>>>    Procedure FreeHandle
78347>>>>>>>>>>>>>>>        Send Destroy
78348>>>>>>>>>>>>>>>    End_Procedure
78349>>>>>>>>>>>>>>>
78349>>>>>>>>>>>>>>>    Procedure Set SQLDatabase String sDatabase
78351>>>>>>>>>>>>>>>        tCLIHandleMap conn
78351>>>>>>>>>>>>>>>        tCLIHandleMap conn
78351>>>>>>>>>>>>>>>
78351>>>>>>>>>>>>>>>        Get ptCLIHandleMap to conn
78352>>>>>>>>>>>>>>>        Set psCurrentDatabase to sDatabase
78353>>>>>>>>>>>>>>>        SQL_USE_DATABASE of conn.sConnect to sDatabase
78391>>>>>>>>>>>>>>>>
78391>>>>>>>>>>>>>>>    End_Procedure
78392>>>>>>>>>>>>>>>
78392>>>>>>>>>>>>>>>    Function SQLConnect String sDriver String sConnect Returns Handle
78394>>>>>>>>>>>>>>>        tCLIHandleMap[] maps
78394>>>>>>>>>>>>>>>        tCLIHandleMap[] maps
78395>>>>>>>>>>>>>>>        tCLIHandleMap conn
78395>>>>>>>>>>>>>>>        tCLIHandleMap conn
78395>>>>>>>>>>>>>>>
78395>>>>>>>>>>>>>>>        Get ptCLIHandleMaps to maps
78396>>>>>>>>>>>>>>>        Move sDriver to conn.sDriver
78397>>>>>>>>>>>>>>>        Move sConnect to conn.sConnect
78398>>>>>>>>>>>>>>>
78398>>>>>>>>>>>>>>>        If (SizeOfArray(maps) > 0) Begin
78400>>>>>>>>>>>>>>>            Move (maps[(SizeOfArray(maps)-1)].iHdbc+1) to conn.iHdbc
78401>>>>>>>>>>>>>>>        End
78401>>>>>>>>>>>>>>>>
78401>>>>>>>>>>>>>>>        Else Begin
78402>>>>>>>>>>>>>>>            Move 1 to conn.iHdbc
78403>>>>>>>>>>>>>>>        End
78403>>>>>>>>>>>>>>>>
78403>>>>>>>>>>>>>>>
78403>>>>>>>>>>>>>>>        Set CurrentConnection to sDriver sConnect
78404>>>>>>>>>>>>>>>        If (not(Err)) Begin
78406>>>>>>>>>>>>>>>            Move conn to maps[(SizeOfArray(maps))]
78407>>>>>>>>>>>>>>>            Set ptCLIHandleMaps to maps
78408>>>>>>>>>>>>>>>            Set ptCLIHandleMap to conn
78409>>>>>>>>>>>>>>>        End
78409>>>>>>>>>>>>>>>>
78409>>>>>>>>>>>>>>>
78409>>>>>>>>>>>>>>>        Function_Return Self
78410>>>>>>>>>>>>>>>    End_Function
78411>>>>>>>>>>>>>>>
78411>>>>>>>>>>>>>>>    Function SQLFileConnect Integer iFileNum Returns Integer
78413>>>>>>>>>>>>>>>        Boolean bIsOpen
78413>>>>>>>>>>>>>>>        String sDriver sServer
78413>>>>>>>>>>>>>>>        tCLIHandleMap[] maps
78413>>>>>>>>>>>>>>>        tCLIHandleMap[] maps
78414>>>>>>>>>>>>>>>        tCLIHandleMap conn
78414>>>>>>>>>>>>>>>        tCLIHandleMap conn
78414>>>>>>>>>>>>>>>
78414>>>>>>>>>>>>>>>        Get_Attribute DF_FILE_OPENED of iFileNum to bIsOpen
78417>>>>>>>>>>>>>>>        If (bIsOpen) Begin
78419>>>>>>>>>>>>>>>            //*** Fill the driver id, assume longest is 255 characters
78419>>>>>>>>>>>>>>>            Move (Repeat(' ', 255)) to sDriver
78420>>>>>>>>>>>>>>>            Move (Repeat(' ', 255)) to sServer
78421>>>>>>>>>>>>>>>            Get_Attribute DF_FILE_DRIVER of iFileNum to sDriver
78424>>>>>>>>>>>>>>>            Get_Attribute DF_FILE_SERVER_NAME of iFileNum to sServer
78427>>>>>>>>>>>>>>>
78427>>>>>>>>>>>>>>>            Indicate Err False
78428>>>>>>>>>>>>>>>
78428>>>>>>>>>>>>>>>            Get ptCLIHandleMaps to maps
78429>>>>>>>>>>>>>>>            Move sDriver to conn.sDriver
78430>>>>>>>>>>>>>>>            Move sServer to conn.sConnect
78431>>>>>>>>>>>>>>>
78431>>>>>>>>>>>>>>>            If (SizeOfArray(maps) > 0) Begin
78433>>>>>>>>>>>>>>>                Move (maps[(SizeOfArray(maps)-1)].iHdbc+1) to conn.iHdbc
78434>>>>>>>>>>>>>>>            End
78434>>>>>>>>>>>>>>>>
78434>>>>>>>>>>>>>>>            Else Begin
78435>>>>>>>>>>>>>>>                Move 1 to conn.iHdbc
78436>>>>>>>>>>>>>>>            End
78436>>>>>>>>>>>>>>>>
78436>>>>>>>>>>>>>>>
78436>>>>>>>>>>>>>>>            Set CurrentConnection to sDriver sServer
78437>>>>>>>>>>>>>>>            If (not(Err)) Begin
78439>>>>>>>>>>>>>>>                Move conn to maps[(SizeOfArray(maps))]
78440>>>>>>>>>>>>>>>                Set ptCLIHandleMaps to maps
78441>>>>>>>>>>>>>>>                Set ptCLIHandleMap to conn
78442>>>>>>>>>>>>>>>            End
78442>>>>>>>>>>>>>>>>
78442>>>>>>>>>>>>>>>
78442>>>>>>>>>>>>>>>            Send StoreHandleInfo conn.iHdbc conn.sDriver
78443>>>>>>>>>>>>>>>            Set piBindFile to iFileNum
78444>>>>>>>>>>>>>>>        End
78444>>>>>>>>>>>>>>>>
78444>>>>>>>>>>>>>>>        Else Begin
78445>>>>>>>>>>>>>>>            Error 4099 "File Not Open"
78446>>>>>>>>>>>>>>>>
78446>>>>>>>>>>>>>>>        End
78446>>>>>>>>>>>>>>>>
78446>>>>>>>>>>>>>>>
78446>>>>>>>>>>>>>>>        //*** Return success status
78446>>>>>>>>>>>>>>>        Function_Return (not(Err))
78447>>>>>>>>>>>>>>>    End_Function
78448>>>>>>>>>>>>>>>
78448>>>>>>>>>>>>>>>    Procedure SQLDisconnect
78450>>>>>>>>>>>>>>>        tCLIHandleMap map
78450>>>>>>>>>>>>>>>        tCLIHandleMap map
78450>>>>>>>>>>>>>>>        tCLIHandleMap[] maps
78450>>>>>>>>>>>>>>>        tCLIHandleMap[] maps
78451>>>>>>>>>>>>>>>        Integer iFound
78451>>>>>>>>>>>>>>>
78451>>>>>>>>>>>>>>>        Get ptCLIHandleMap to map
78452>>>>>>>>>>>>>>>        Get ptCLIHandleMaps to maps
78453>>>>>>>>>>>>>>>
78453>>>>>>>>>>>>>>>        Move (SearchArray(map, maps, Parent(Self), RefFunc(CompareMaps))) to iFound
78454>>>>>>>>>>>>>>>        If (iFound > -1) Begin
78456>>>>>>>>>>>>>>>            Send FreeHandle
78457>>>>>>>>>>>>>>>        End
78457>>>>>>>>>>>>>>>>
78457>>>>>>>>>>>>>>>    End_Procedure
78458>>>>>>>>>>>>>>>
78458>>>>>>>>>>>>>>>    Function CreateHandle Returns Integer
78460>>>>>>>>>>>>>>>        Handle hSQL
78460>>>>>>>>>>>>>>>        Integer iCursor
78460>>>>>>>>>>>>>>>
78460>>>>>>>>>>>>>>>        Get Create (RefClass(cSQLStatementDUF)) to hSQL
78461>>>>>>>>>>>>>>>
78461>>>>>>>>>>>>>>>        Set piBindFile of hSQL to (piBindFile(Current_object))
78462>>>>>>>>>>>>>>>
78462>>>>>>>>>>>>>>>        SQL_OPEN_CURSOR_STMT to iCursor
78500>>>>>>>>>>>>>>>>
78500>>>>>>>>>>>>>>>        Set piCursorNum of hSQL to iCursor
78501>>>>>>>>>>>>>>>
78501>>>>>>>>>>>>>>>        Function_Return hSQL
78502>>>>>>>>>>>>>>>    End_Function
78503>>>>>>>>>>>>>>>
78503>>>>>>>>>>>>>>>    Function SQLOpen Returns Integer
78505>>>>>>>>>>>>>>>        Handle hDFHandle
78505>>>>>>>>>>>>>>>
78505>>>>>>>>>>>>>>>        Get CreateHandle to hDFHandle
78506>>>>>>>>>>>>>>>
78506>>>>>>>>>>>>>>>        Send StoreHandleInfo to hDFHandle Self (psDriverID(Self))
78507>>>>>>>>>>>>>>>
78507>>>>>>>>>>>>>>>        Function_Return hDFHandle
78508>>>>>>>>>>>>>>>    End_Function
78509>>>>>>>>>>>>>>>
78509>>>>>>>>>>>>>>>    Function DriverIndex String sDriver Returns Integer
78511>>>>>>>>>>>>>>>        String sCurrentDriver
78511>>>>>>>>>>>>>>>        Integer iDriver
78511>>>>>>>>>>>>>>>        Integer iNumDrivers
78511>>>>>>>>>>>>>>>
78511>>>>>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumDrivers
78514>>>>>>>>>>>>>>>        For iDriver from 1 to iNumDrivers
78520>>>>>>>>>>>>>>>>
78520>>>>>>>>>>>>>>>          Get_Attribute DF_DRIVER_NAME of iDriver to sCurrentDriver
78523>>>>>>>>>>>>>>>          If (Uppercase(sDriver) = Uppercase(sCurrentDriver)) ;              Function_Return iDriver
78526>>>>>>>>>>>>>>>        Loop
78527>>>>>>>>>>>>>>>>
78527>>>>>>>>>>>>>>>        Function_Return 0
78528>>>>>>>>>>>>>>>    End_Function
78529>>>>>>>>>>>>>>>
78529>>>>>>>>>>>>>>>    Function FirstServerForDriverNo Integer iDriver Returns String
78531>>>>>>>>>>>>>>>        String sServer
78531>>>>>>>>>>>>>>>        Integer iNumServers
78531>>>>>>>>>>>>>>>        Integer iServer
78531>>>>>>>>>>>>>>>
78531>>>>>>>>>>>>>>>        If (iDriver <> 0) Begin
78533>>>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iNumServers
78536>>>>>>>>>>>>>>>            If (iNumServers<>0) Begin
78538>>>>>>>>>>>>>>>                Move 1 to iServer
78539>>>>>>>>>>>>>>>                Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iServer to sServer
78542>>>>>>>>>>>>>>>            End
78542>>>>>>>>>>>>>>>>
78542>>>>>>>>>>>>>>>        End
78542>>>>>>>>>>>>>>>>
78542>>>>>>>>>>>>>>>
78542>>>>>>>>>>>>>>>        Function_Return sServer
78543>>>>>>>>>>>>>>>    End_Function
78544>>>>>>>>>>>>>>>
78544>>>>>>>>>>>>>>>    Procedure Set CurrentConnection String sDriver String sServer
78546>>>>>>>>>>>>>>>        Integer iDriver
78546>>>>>>>>>>>>>>>        String sUsername
78546>>>>>>>>>>>>>>>        String sPassword
78546>>>>>>>>>>>>>>>
78546>>>>>>>>>>>>>>>        If (sDriver="") Begin
78548>>>>>>>>>>>>>>>            DO_GETFILENUMBER_DRIVERNAME 0
78574>>>>>>>>>>>>>>>>
78574>>>>>>>>>>>>>>>            Move MertechInc_DriverName to sDriver
78575>>>>>>>>>>>>>>>        End
78575>>>>>>>>>>>>>>>>
78575>>>>>>>>>>>>>>>
78575>>>>>>>>>>>>>>>        If ("MDSMYSQL|ORA_DRV|MDSPGSQL|SQL_DRV|MDS_DB2" contains Uppercase(Trim(sDriver))) Begin
78577>>>>>>>>>>>>>>>            Move (Uppercase(Trim(sDriver))) to MertechInc_DriverName
78578>>>>>>>>>>>>>>>
78578>>>>>>>>>>>>>>>            If (Trim(sDriver) <> "") Begin
78580>>>>>>>>>>>>>>>                Move (Uppercase(Trim(sDriver))) to MertechInc_CurrentDriver
78581>>>>>>>>>>>>>>>            End
78581>>>>>>>>>>>>>>>>
78581>>>>>>>>>>>>>>>            Else Begin
78582>>>>>>>>>>>>>>>                Move "" to MertechInc_CurrentDriver
78583>>>>>>>>>>>>>>>            End
78583>>>>>>>>>>>>>>>>
78583>>>>>>>>>>>>>>>
78583>>>>>>>>>>>>>>>            Get psUsername to sUsername
78584>>>>>>>>>>>>>>>            Get psPassword to sPassword
78585>>>>>>>>>>>>>>>
78585>>>>>>>>>>>>>>>            Get DriverIndex MertechInc_CurrentDriver to iDriver
78586>>>>>>>>>>>>>>>
78586>>>>>>>>>>>>>>>            If (sServer   = "") Begin
78588>>>>>>>>>>>>>>>                Get FirstServerForDriverNo iDriver to sServer
78589>>>>>>>>>>>>>>>            End
78589>>>>>>>>>>>>>>>>
78589>>>>>>>>>>>>>>>            If (sUsername = "") Begin
78591>>>>>>>>>>>>>>>                Get_Current_User_Name of sServer to sUsername
78630>>>>>>>>>>>>>>>>
78630>>>>>>>>>>>>>>>            End
78630>>>>>>>>>>>>>>>>
78630>>>>>>>>>>>>>>>            If (sPassword = "") Begin
78632>>>>>>>>>>>>>>>                Get_Current_User_Password of sServer to sPassword
78671>>>>>>>>>>>>>>>>
78671>>>>>>>>>>>>>>>            End
78671>>>>>>>>>>>>>>>>
78671>>>>>>>>>>>>>>>
78671>>>>>>>>>>>>>>>            Move False to Err
78672>>>>>>>>>>>>>>>            Send Ignore_Error of Error_Object_Id 25000
78673>>>>>>>>>>>>>>>            Login sServer sUsername sPassword sDriver
78675>>>>>>>>>>>>>>>            Send Trap_Error of Error_Object_Id 25000
78676>>>>>>>>>>>>>>>
78676>>>>>>>>>>>>>>>            If (Err = False) Begin
78678>>>>>>>>>>>>>>>                Call_Driver 0 MertechInc_DriverName Function CALLDRV_CURRENT_SQL_SERVER_CONNECTION CALLBACK 0 PASSING sServer MertechInc_Blank 0 RESULT MertechInc_iRet
78683>>>>>>>>>>>>>>>            End
78683>>>>>>>>>>>>>>>>
78683>>>>>>>>>>>>>>>            Else Begin
78684>>>>>>>>>>>>>>>                Procedure_Return
78685>>>>>>>>>>>>>>>            End
78685>>>>>>>>>>>>>>>>
78685>>>>>>>>>>>>>>>
78685>>>>>>>>>>>>>>>            If (MertechInc_iRet = -1) Begin
78687>>>>>>>>>>>>>>>                Move True to Err
78688>>>>>>>>>>>>>>>            End
78688>>>>>>>>>>>>>>>>
78688>>>>>>>>>>>>>>>        End
78688>>>>>>>>>>>>>>>>
78688>>>>>>>>>>>>>>>        Else Begin
78689>>>>>>>>>>>>>>>            Error 4099 "Invalid Driver"
78690>>>>>>>>>>>>>>>>
78690>>>>>>>>>>>>>>>        End
78690>>>>>>>>>>>>>>>>
78690>>>>>>>>>>>>>>>
78690>>>>>>>>>>>>>>>    End_Procedure
78691>>>>>>>>>>>>>>>
78691>>>>>>>>>>>>>>>End_Class
78692>>>>>>>>>>>>>>>
78692>>>>>>>>>>>>>>>Class cSQLHandleManagerDUF is a cObject
78693>>>>>>>>>>>>>>>
78693>>>>>>>>>>>>>>>    Procedure Construct_Object
78695>>>>>>>>>>>>>>>        Forward Send Construct_Object
78697>>>>>>>>>>>>>>>
78697>>>>>>>>>>>>>>>        Property String  psDefaultDriver     ""
78698>>>>>>>>>>>>>>>        Property String  psDefaultConnection ""
78699>>>>>>>>>>>>>>>        Property tCLIHandleMap[] ptCLIHandleMaps
78700>>>>>>>>>>>>>>>    End_Procedure
78701>>>>>>>>>>>>>>>
78701>>>>>>>>>>>>>>>    Function CompareMaps tCLIHandleMap map1 tCLIHandleMap map2 Returns Integer
78703>>>>>>>>>>>>>>>        If ((map1.iHdbc = map2.iHdbc) and (map1.sConnect = map2.sConnect) and (map1.sDriver = map2.sDriver)) Begin
78705>>>>>>>>>>>>>>>            Function_Return (EQ)
78706>>>>>>>>>>>>>>>        End
78706>>>>>>>>>>>>>>>>
78706>>>>>>>>>>>>>>>        Function_Return (GT)
78707>>>>>>>>>>>>>>>    End_Function
78708>>>>>>>>>>>>>>>
78708>>>>>>>>>>>>>>>    Function CreateHandle Returns Handle
78710>>>>>>>>>>>>>>>        Handle hSQL
78710>>>>>>>>>>>>>>>
78710>>>>>>>>>>>>>>>        Get Create (RefClass(cSQLConnectionDUF)) to hSQL
78711>>>>>>>>>>>>>>>        Function_Return hSQL
78712>>>>>>>>>>>>>>>    End_Function
78713>>>>>>>>>>>>>>>
78713>>>>>>>>>>>>>>>    Procedure SQLSetConnect String sDriver String sConnect
78715>>>>>>>>>>>>>>>        Set psDefaultDriver to sDriver
78716>>>>>>>>>>>>>>>        Set psDefaultConnection to sConnect
78717>>>>>>>>>>>>>>>    End_Procedure
78718>>>>>>>>>>>>>>>
78718>>>>>>>>>>>>>>>    Function SQLConnect String sDriver String sConnect String sUID String sPWD Returns Handle
78720>>>>>>>>>>>>>>>        Handle hSql
78720>>>>>>>>>>>>>>>        Boolean bOK
78720>>>>>>>>>>>>>>>        String sServer sUsername sPassword
78720>>>>>>>>>>>>>>>
78720>>>>>>>>>>>>>>>        Get CreateHandle to hSql
78721>>>>>>>>>>>>>>>
78721>>>>>>>>>>>>>>>        If (sDriver = "" and sConnect = "") Begin
78723>>>>>>>>>>>>>>>            Get psDefaultDriver to sDriver
78724>>>>>>>>>>>>>>>            Get psDefaultConnection to sConnect
78725>>>>>>>>>>>>>>>        End
78725>>>>>>>>>>>>>>>>
78725>>>>>>>>>>>>>>>
78725>>>>>>>>>>>>>>>        If (num_arguments = 2) Begin
78727>>>>>>>>>>>>>>>            Get ParseKeyWord sConnect "SERVER"  to sServer
78728>>>>>>>>>>>>>>>            If (sServer = "") Begin
78730>>>>>>>>>>>>>>>                Get ParseKeyWord sConnect "DSN" to sServer
78731>>>>>>>>>>>>>>>            End
78731>>>>>>>>>>>>>>>>
78731>>>>>>>>>>>>>>>            Get ParseKeyWord sConnect "UID"     to sUsername
78732>>>>>>>>>>>>>>>            Get ParseKeyWord sConnect "PWD"     to sPassword
78733>>>>>>>>>>>>>>>        End
78733>>>>>>>>>>>>>>>>
78733>>>>>>>>>>>>>>>        Else Begin
78734>>>>>>>>>>>>>>>            Move sUID                           to sUsername
78735>>>>>>>>>>>>>>>            Move sPWD                           to sPassword
78736>>>>>>>>>>>>>>>        End
78736>>>>>>>>>>>>>>>>
78736>>>>>>>>>>>>>>>
78736>>>>>>>>>>>>>>>        Set psUsername of hSql to sUsername
78737>>>>>>>>>>>>>>>        Set psPassword of hSql to sPassword
78738>>>>>>>>>>>>>>>
78738>>>>>>>>>>>>>>>        Get SQLConnect of hSql sDriver sServer to bOK
78739>>>>>>>>>>>>>>>        If (not(bOK)) Begin
78741>>>>>>>>>>>>>>>            Send FreeHandle of hSQL
78742>>>>>>>>>>>>>>>            Function_Return 0
78743>>>>>>>>>>>>>>>        End
78743>>>>>>>>>>>>>>>>
78743>>>>>>>>>>>>>>>
78743>>>>>>>>>>>>>>>        Function_Return hSql
78744>>>>>>>>>>>>>>>    End_Function
78745>>>>>>>>>>>>>>>
78745>>>>>>>>>>>>>>>    Function SQLFileConnect Integer iFileNum Returns Integer
78747>>>>>>>>>>>>>>>        Handle hSql
78747>>>>>>>>>>>>>>>        Boolean bOK
78747>>>>>>>>>>>>>>>
78747>>>>>>>>>>>>>>>        //*** Allocate a new handle
78747>>>>>>>>>>>>>>>        Get CreateHandle to hSql
78748>>>>>>>>>>>>>>>        Get SQLFileConnect of hSql iFileNum to bOK
78749>>>>>>>>>>>>>>>
78749>>>>>>>>>>>>>>>        //*** If failure, kill the handle and return a 0 handle
78749>>>>>>>>>>>>>>>        If (not(bOK)) Begin
78751>>>>>>>>>>>>>>>            Send FreeHandle of hSql
78752>>>>>>>>>>>>>>>            Function_Return 0
78753>>>>>>>>>>>>>>>        End
78753>>>>>>>>>>>>>>>>
78753>>>>>>>>>>>>>>>
78753>>>>>>>>>>>>>>>        Function_Return hSql
78754>>>>>>>>>>>>>>>    End_Function
78755>>>>>>>>>>>>>>>
78755>>>>>>>>>>>>>>>End_Class
78756>>>>>>>>>>>>>>>
78756>>>>>>>>>>>>>>>
78756>>>>>>>>>>>>>>>Function CreateSQLmanager for cDesktop Returns Integer
78758>>>>>>>>>>>>>>>    Handle hSqlManager
78758>>>>>>>>>>>>>>>
78758>>>>>>>>>>>>>>>    Get Create (RefClass(cSQLHandleManagerDUF)) to hSqlManager
78759>>>>>>>>>>>>>>>    Function_Return hSqlManager
78760>>>>>>>>>>>>>>>End_Function
78761>>>>>>>>>>>>>>>
78761>>>>>>>>>>>>>>>
78761>>>>>>>>>>>>>>>
78761>>>>>>>>>>>>>>>
78761>>>>>>>>>>>>>>>Get CreateSQLManager of Desktop to _embsqlghoSQLHandleMngr
78762>>>>>>>>>>>>>>>
78762>>>>>>>>>>>>>    Use Mertech.inc
78762>>>>>>>>>>>>>
78762>>>>>>>>>>>>>Use cDbUpdateFunctionLibrary.inc
Including file: cDbUpdateFunctionLibrary.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateFunctionLibrary.inc)
78762>>>>>>>>>>>>>>>Use DUFLanguageConstants.inc
78762>>>>>>>>>>>>>>>
78762>>>>>>>>>>>>>>>Register_Function paSQLQueryMessages Returns String[]
78762>>>>>>>>>>>>>>>Register_Procedure Set paSQLQueryMessages String[] aSQLQueryMessages
78762>>>>>>>>>>>>>>>
78762>>>>>>>>>>>>>>>
78762>>>>>>>>>>>>>>>
78762>>>>>>>>>>>>>>>    Define CS_OEM_Txt for "OEM"
78762>>>>>>>>>>>>>>>
78762>>>>>>>>>>>>>>>    Define CS_ANSI_Txt for "ANSI"
78762>>>>>>>>>>>>>>>
78762>>>>>>>>>>>>>>>    Define CS_DFCONNID for "DFCONNID"
78762>>>>>>>>>>>>>>>
78762>>>>>>>>>>>>>>>    Define CS_SERVER for "SERVER"
78762>>>>>>>>>>>>>>>
78762>>>>>>>>>>>>>>>    Define CS_SERVER_NAME for "SERVER_NAME"
78762>>>>>>>>>>>>>>>
78762>>>>>>>>>>>>>>>    Define CS_DRIVER_NAME for "DRIVER_NAME"
78762>>>>>>>>>>>>>>>
78762>>>>>>>>>>>>>>>    Define CS_DATABASE_NAME for "DATABASE_NAME"
78762>>>>>>>>>>>>>>>
78762>>>>>>>>>>>>>>>    Define CS_SCHEMA_NAME for "SCHEMA_NAME"
78762>>>>>>>>>>>>>>>
78762>>>>>>>>>>>>>>>    Define CS_TABLE_CHARACTER_FORMAT for "TABLE_CHARACTER_FORMAT"
78762>>>>>>>>>>>>>>>
78762>>>>>>>>>>>>>>>    Define CS_USE_DUMMY_ZERO_DATE for "USE_DUMMY_ZERO_DATE"
78762>>>>>>>>>>>>>>>
78762>>>>>>>>>>>>>>>    Define CS_SYSTEM_FILE for "SYSTEM_FILE"
78762>>>>>>>>>>>>>>>
78762>>>>>>>>>>>>>>>    Define CS_RECNUM_TABLE for "RECNUM_TABLE"
78762>>>>>>>>>>>>>>>
78762>>>>>>>>>>>>>>>    Define CS_PRIMARY_INDEX for "PRIMARY_INDEX"
78762>>>>>>>>>>>>>>>
78762>>>>>>>>>>>>>>>    Define CS_INDEX_NUMBER for "INDEX_NUMBER"
78762>>>>>>>>>>>>>>>
78762>>>>>>>>>>>>>>>    Define CS_INDEX_NAME for "INDEX_NAME"
78762>>>>>>>>>>>>>>>
78762>>>>>>>>>>>>>>>    Define CS_DUFLowestAllowedDateValue for "01/01/1753"
78762>>>>>>>>>>>>>>>    Define CS_DUFLowestSQLDateValue     for "1753-01-01"
78762>>>>>>>>>>>>>>>
78762>>>>>>>>>>>>>>>    Define CS_DUFBackupDataFolder for "BackupData"
78762>>>>>>>>>>>>>>>
78762>>>>>>>>>>>>>>>// Global handle to a cDatabaseUpdateHandler object
78762>>>>>>>>>>>>>>>
78762>>>>>>>>>>>>>>>    Global_Variable Handle ghoDbUpdateFunctionLibrary  
78762>>>>>>>>>>>>>>>    Move 0 to ghoDbUpdateFunctionLibrary
78763>>>>>>>>>>>>>>>
78763>>>>>>>>>>>>>>>Struct tSQLScriptArray
78763>>>>>>>>>>>>>>>    Boolean bError
78763>>>>>>>>>>>>>>>    Boolean bArgumentSizeChanged
78763>>>>>>>>>>>>>>>    Integer iOrgArgumentSize
78763>>>>>>>>>>>>>>>    String[] sSQLScriptArray
78763>>>>>>>>>>>>>>>End_Struct
78763>>>>>>>>>>>>>>>
78763>>>>>>>>>>>>>>>Struct tSqlErrorArray
78763>>>>>>>>>>>>>>>    String[]  sSqlErrorArray
78763>>>>>>>>>>>>>>>    String[]  sSqlStatementArray
78763>>>>>>>>>>>>>>>    Integer[] iSqlErrorArray
78763>>>>>>>>>>>>>>>End_Struct
78763>>>>>>>>>>>>>>>
78763>>>>>>>>>>>>>>>Struct tSqlColumnNew
78763>>>>>>>>>>>>>>>    String  sBaseColumnName
78763>>>>>>>>>>>>>>>    String  sBaseTableName
78763>>>>>>>>>>>>>>>    String  sLabel
78763>>>>>>>>>>>>>>>    Integer iSqlType
78763>>>>>>>>>>>>>>>    Integer iSize
78763>>>>>>>>>>>>>>>    Integer iPrecision
78763>>>>>>>>>>>>>>>    Integer iDFType
78763>>>>>>>>>>>>>>>    Integer iDFNativeType
78763>>>>>>>>>>>>>>>End_Struct
78763>>>>>>>>>>>>>>>
78763>>>>>>>>>>>>>>>Struct tColumnType
78763>>>>>>>>>>>>>>>    String  sSQLType
78763>>>>>>>>>>>>>>>    Integer iSQLType
78763>>>>>>>>>>>>>>>    Boolean bCanEditSize
78763>>>>>>>>>>>>>>>    Integer iDefaultSize
78763>>>>>>>>>>>>>>>    Integer iMinSize
78763>>>>>>>>>>>>>>>    Number  nMaxSize
78763>>>>>>>>>>>>>>>    String  sDataFlexType
78763>>>>>>>>>>>>>>>    Integer iDataFlexType
78763>>>>>>>>>>>>>>>    Boolean bNativeDataType
78763>>>>>>>>>>>>>>>    String  sPrecision
78763>>>>>>>>>>>>>>>End_Struct
78763>>>>>>>>>>>>>>>
78763>>>>>>>>>>>>>>>// Used to store/retreive SQL keywords in a struct array.
78763>>>>>>>>>>>>>>>// Various SQL back-ends can have slightly different
78763>>>>>>>>>>>>>>>// keywords.
78763>>>>>>>>>>>>>>>Struct tSQLKeyWords
78763>>>>>>>>>>>>>>>    Integer iSQLWord
78763>>>>>>>>>>>>>>>    Integer iSQLDbType
78763>>>>>>>>>>>>>>>    String  sSQLPhrase // Can be more than one word.
78763>>>>>>>>>>>>>>>End_Struct
78763>>>>>>>>>>>>>>>
78763>>>>>>>>>>>>>>>Struct tSQLRelation
78763>>>>>>>>>>>>>>>    Integer iFileNumber
78763>>>>>>>>>>>>>>>    Integer iFieldNumber
78763>>>>>>>>>>>>>>>    String  sFileName
78763>>>>>>>>>>>>>>>    String  sFieldName
78763>>>>>>>>>>>>>>>End_Struct
78763>>>>>>>>>>>>>>>
78763>>>>>>>>>>>>>>>Struct tSQLLoggedInUser
78763>>>>>>>>>>>>>>>    String sUser
78763>>>>>>>>>>>>>>>    String sProgram
78763>>>>>>>>>>>>>>>End_Struct
78763>>>>>>>>>>>>>>>
78763>>>>>>>>>>>>>>>// Used as a start for error handing. Used by Error_Report_Mode property
78763>>>>>>>>>>>>>>>
78763>>>>>>>>>>>>>>>// We need to re-define the standard constants because several driver constants
78763>>>>>>>>>>>>>>>// have the same value and we need to be able to distinguish which data type to use when
78763>>>>>>>>>>>>>>>// SQL Back-ends (iSQLDbType in the tSQLKeywords struct).
78763>>>>>>>>>>>>>>>// They can have slightly different SQL keywords.
78763>>>>>>>>>>>>>>>// Note: If a new type is added to the list,
78763>>>>>>>>>>>>>>>//       the struct array xxx must be adjusted
78763>>>>>>>>>>>>>>>//       so that it is filled with all SQL
78763>>>>>>>>>>>>>>>//       keywords for that new type.
78763>>>>>>>>>>>>>>>Enum_List
78763>>>>>>>>>>>>>>>    Define EN_DbTypeDataFlex   for 0
78763>>>>>>>>>>>>>>>    Define EN_DbTypeMSSQL      for 1
78763>>>>>>>>>>>>>>>    Define EN_DbTypeMySQL      for 2
78763>>>>>>>>>>>>>>>    Define EN_DbTypeOracle     for 3
78763>>>>>>>>>>>>>>>    Define EN_DbTypeDB2        for 4
78763>>>>>>>>>>>>>>>    Define EN_DbTypePostgre    for 5
78763>>>>>>>>>>>>>>>    Define EN_DbTypePervasive  for 6
78763>>>>>>>>>>>>>>>//    Define EN_DbTypeMSSQL
78763>>>>>>>>>>>>>>>//    Define EN_DbTypeMySQL
78763>>>>>>>>>>>>>>>//    Define EN_DbTypeOracle
78763>>>>>>>>>>>>>>>//    Define EN_DbTypeDB2
78763>>>>>>>>>>>>>>>//    Define EN_DbTypePostgre
78763>>>>>>>>>>>>>>>//    Define EN_DbTypeDataFlex // Embedded database.
78763>>>>>>>>>>>>>>>End_Enum_List
78763>>>>>>>>>>>>>>>
78763>>>>>>>>>>>>>>>// We need to have our "own" constants for the standard DataFlex data types.
78763>>>>>>>>>>>>>>>// These can be used with SQL functions such as e.g. SQLColumnAdd, instead
78763>>>>>>>>>>>>>>>// of using one of the driver specific integer constants such as e.g. "SQL_VARCHAR".
78763>>>>>>>>>>>>>>>Define CS_DbTypeMSSQL       for "Microsoft SQL Server"
78763>>>>>>>>>>>>>>>Define CS_DbTypeMySQL       for "MySQL"
78763>>>>>>>>>>>>>>>Define CS_DbTypeOracle      for "Oracle"
78763>>>>>>>>>>>>>>>Define CS_DbTypeDB2         for "IBM DB2"
78763>>>>>>>>>>>>>>>Define CS_DbTypePostgre     for "PostgreSQL"
78763>>>>>>>>>>>>>>>Define CS_DbTypeDataFlex    for "DataFlex Embedded"
78763>>>>>>>>>>>>>>>
78763>>>>>>>>>>>>>>>// We need to re-define the standard constants because several driver constants
78763>>>>>>>>>>>>>>>// have the same value and we need to be able to distinguish which data type to use when
78763>>>>>>>>>>>>>>>// e.g. creating a column with embedded SQL (ESQL).
78763>>>>>>>>>>>>>>>Enum_List
78763>>>>>>>>>>>>>>>    Define DF_ASCII_DUF     for -1500 // All of these are DF_xxx constant values - 1500
78763>>>>>>>>>>>>>>>    Define DF_BCD_DUF       for -1499
78763>>>>>>>>>>>>>>>    Define DF_DATE_DUF      for -1498
78763>>>>>>>>>>>>>>>    Define DF_TEXT_DUF      for -1495
78763>>>>>>>>>>>>>>>    Define DF_BINARY_DUF    for -1494
78763>>>>>>>>>>>>>>>    Define DF_DATETIME_DUF  for -1493
78763>>>>>>>>>>>>>>>End_Enum_List
78763>>>>>>>>>>>>>>>
78763>>>>>>>>>>>>>>>    Define SQL_TEXT for (DF_TEXT + 1024)
78763>>>>>>>>>>>>>>>
78763>>>>>>>>>>>>>>>Define SQL_CHARBIT          for (DF_BINARY + 1024)
78763>>>>>>>>>>>>>>>Define SQL_LONGVARCHARBIT   for (DF_BINARY + 1025)
78763>>>>>>>>>>>>>>>Define SQL_VARCHARBIT       for (DF_BINARY + 1026)
78763>>>>>>>>>>>>>>>
78763>>>>>>>>>>>>>>>// These are not defined pre DF 18:
78763>>>>>>>>>>>>>>>
78763>>>>>>>>>>>>>>>Struct tSQLIntTableInfo
78763>>>>>>>>>>>>>>>    String sDriverName
78763>>>>>>>>>>>>>>>    String sServerName
78763>>>>>>>>>>>>>>>    String sDatabaseName
78763>>>>>>>>>>>>>>>    String sSchemaName
78763>>>>>>>>>>>>>>>    Boolean bRecnumTable
78763>>>>>>>>>>>>>>>    Integer iPrimaryIndex
78763>>>>>>>>>>>>>>>    Integer iGenerateRecordIdMethod  // RIM_NONE, RIM_IDENTITY_COLUMN,  RIM_DISPENSER_TABLE, RIM_EXTERNAL
78763>>>>>>>>>>>>>>>    String sTableCharacterFormat
78763>>>>>>>>>>>>>>>    Boolean bUseDummyZeroDate
78763>>>>>>>>>>>>>>>    Integer iFileDummyUpdateColumn // Init value to -1 if not exists (value can be in range 1 - number of columns)
78763>>>>>>>>>>>>>>>    Integer iFileBlockSize         // Init value to -1 if not exists
78763>>>>>>>>>>>>>>>    Integer iFileMaxRowsFetched    // Init value to -1 if not exists
78763>>>>>>>>>>>>>>>    Integer iFileGetRidAfterCreate // Init value to -1. But is boolean!
78763>>>>>>>>>>>>>>>    Integer iFileJitBinding        // Init value to -1. But is boolean!
78763>>>>>>>>>>>>>>>    String sRefindAfterSave        // Yes or No (how to handle?)
78763>>>>>>>>>>>>>>>    String sSystemFile             // Yes or No (how to handle?)
78763>>>>>>>>>>>>>>>    String sFileIndexTablespace
78763>>>>>>>>>>>>>>>    String sFileLongTablespace
78763>>>>>>>>>>>>>>>    String sTableTablespace
78763>>>>>>>>>>>>>>>End_Struct
78763>>>>>>>>>>>>>>>
78763>>>>>>>>>>>>>>>Struct tSQLIntColumnInfo
78763>>>>>>>>>>>>>>>    Integer iFieldNumber
78763>>>>>>>>>>>>>>>    Integer iFieldIndex
78763>>>>>>>>>>>>>>>    Integer iFieldRelatedFile
78763>>>>>>>>>>>>>>>    Integer iFieldRelatedField
78763>>>>>>>>>>>>>>>    Integer iIndexNumber
78763>>>>>>>>>>>>>>>    Integer iIndexNumberSegments
78763>>>>>>>>>>>>>>>    Integer iIndexSegmentField1
78763>>>>>>>>>>>>>>>    Integer iIndexSegmentField2
78763>>>>>>>>>>>>>>>    Integer iIndexSegmentFieldn
78763>>>>>>>>>>>>>>>    String  sIndexName
78763>>>>>>>>>>>>>>>End_Struct
78763>>>>>>>>>>>>>>>
78763>>>>>>>>>>>>>>>Struct tAPIColumn
78763>>>>>>>>>>>>>>>    Integer iFieldNumber
78763>>>>>>>>>>>>>>>    String  sFieldName
78763>>>>>>>>>>>>>>>    Integer iType
78763>>>>>>>>>>>>>>>    String  sType
78763>>>>>>>>>>>>>>>    Integer iLength
78763>>>>>>>>>>>>>>>    Integer iPrecision
78763>>>>>>>>>>>>>>>    Integer iOptions
78763>>>>>>>>>>>>>>>    Boolean bIsSQLType
78763>>>>>>>>>>>>>>>    Boolean bAllowNULL
78763>>>>>>>>>>>>>>>    String  sDefaultValue
78763>>>>>>>>>>>>>>>    Boolean bShouldChange
78763>>>>>>>>>>>>>>>    Boolean bCancel
78763>>>>>>>>>>>>>>>    Boolean bError
78763>>>>>>>>>>>>>>>End_Struct
78763>>>>>>>>>>>>>>>
78763>>>>>>>>>>>>>>>Struct tAPIColumnCompare
78763>>>>>>>>>>>>>>>    Integer iFieldNumber
78763>>>>>>>>>>>>>>>    // FROM database:
78763>>>>>>>>>>>>>>>    Boolean bExistsFrom
78763>>>>>>>>>>>>>>>    String  sFieldNameFrom
78763>>>>>>>>>>>>>>>    Integer iTypeFrom
78763>>>>>>>>>>>>>>>    String  sTypeFrom
78763>>>>>>>>>>>>>>>    Integer iLengthFrom
78763>>>>>>>>>>>>>>>    Integer iPrecisionFrom
78763>>>>>>>>>>>>>>>    Integer iOptionsFrom
78763>>>>>>>>>>>>>>>    Boolean bIsSQLTypeFrom
78763>>>>>>>>>>>>>>>    Boolean bAllowNULLFrom
78763>>>>>>>>>>>>>>>    String  sDefaultValueFrom
78763>>>>>>>>>>>>>>>    Boolean bShouldChangeFrom
78763>>>>>>>>>>>>>>>    Boolean bCancelFrom
78763>>>>>>>>>>>>>>>    Boolean bErrorFrom
78763>>>>>>>>>>>>>>>    // TO database:
78763>>>>>>>>>>>>>>>    Boolean bExistsTo
78763>>>>>>>>>>>>>>>    Integer iFieldNumberTo
78763>>>>>>>>>>>>>>>    String  sFieldNameTo
78763>>>>>>>>>>>>>>>    Integer iTypeTo
78763>>>>>>>>>>>>>>>    String  sTypeTo
78763>>>>>>>>>>>>>>>    Integer iLengthTo
78763>>>>>>>>>>>>>>>    Integer iPrecisionTo
78763>>>>>>>>>>>>>>>    Integer iOptionsTo
78763>>>>>>>>>>>>>>>    Boolean bIsSQLTypeTo
78763>>>>>>>>>>>>>>>    Boolean bAllowNULLTo
78763>>>>>>>>>>>>>>>    String  sDefaultValueTo
78763>>>>>>>>>>>>>>>    Boolean bShouldChangeTo
78763>>>>>>>>>>>>>>>    Boolean bCancelTo
78763>>>>>>>>>>>>>>>    Boolean bErrorTo
78763>>>>>>>>>>>>>>>End_Struct
78763>>>>>>>>>>>>>>>
78763>>>>>>>>>>>>>>>Struct tAPIRelation
78763>>>>>>>>>>>>>>>    Handle  hTableFrom
78763>>>>>>>>>>>>>>>    Integer iColumnFrom
78763>>>>>>>>>>>>>>>    Handle  hTableTo
78763>>>>>>>>>>>>>>>    Integer iColumnTo
78763>>>>>>>>>>>>>>>    String  sLogicalNameFrom
78763>>>>>>>>>>>>>>>    String  sLogicalNameTo
78763>>>>>>>>>>>>>>>    String  sFieldNameFrom
78763>>>>>>>>>>>>>>>    String  sFieldNameTo
78763>>>>>>>>>>>>>>>    Boolean bShouldChange
78763>>>>>>>>>>>>>>>    Boolean bCancel
78763>>>>>>>>>>>>>>>    Boolean bError
78763>>>>>>>>>>>>>>>End_Struct
78763>>>>>>>>>>>>>>>
78763>>>>>>>>>>>>>>>Struct tAPIRelationCompare
78763>>>>>>>>>>>>>>>    // Common:
78763>>>>>>>>>>>>>>>    Handle  hTableFrom
78763>>>>>>>>>>>>>>>    Integer iColumnFrom
78763>>>>>>>>>>>>>>>    Handle  hTableTo
78763>>>>>>>>>>>>>>>    Integer iColumnTo
78763>>>>>>>>>>>>>>>    // FROM database:
78763>>>>>>>>>>>>>>>    Boolean bExistsFrom
78763>>>>>>>>>>>>>>>    String  sLogicalNameFrom_From
78763>>>>>>>>>>>>>>>    String  sLogicalNameTo_From
78763>>>>>>>>>>>>>>>    String  sFieldNameFrom_From
78763>>>>>>>>>>>>>>>    String  sFieldNameTo_From
78763>>>>>>>>>>>>>>>    Boolean bShouldChange_From
78763>>>>>>>>>>>>>>>    Boolean bCancel_From
78763>>>>>>>>>>>>>>>    Boolean bError_From
78763>>>>>>>>>>>>>>>    // TO database:
78763>>>>>>>>>>>>>>>    Boolean bExistsTo
78763>>>>>>>>>>>>>>>    String  sLogicalNameFrom_To
78763>>>>>>>>>>>>>>>    String  sLogicalNameTo_To
78763>>>>>>>>>>>>>>>    String  sFieldNameFrom_To
78763>>>>>>>>>>>>>>>    String  sFieldNameTo_To
78763>>>>>>>>>>>>>>>    Boolean bShouldChange_To
78763>>>>>>>>>>>>>>>    Boolean bCancel_To
78763>>>>>>>>>>>>>>>    Boolean bError_To
78763>>>>>>>>>>>>>>>End_Struct
78763>>>>>>>>>>>>>>>
78763>>>>>>>>>>>>>>>Struct tAPIIndexSegment
78763>>>>>>>>>>>>>>>    Integer iFieldNumber
78763>>>>>>>>>>>>>>>    String  sFieldName
78763>>>>>>>>>>>>>>>    Boolean bUppercase
78763>>>>>>>>>>>>>>>    Boolean bAscending
78763>>>>>>>>>>>>>>>    Boolean bShouldChange
78763>>>>>>>>>>>>>>>    Boolean bCancel
78763>>>>>>>>>>>>>>>    Boolean bError
78763>>>>>>>>>>>>>>>End_Struct
78763>>>>>>>>>>>>>>>
78763>>>>>>>>>>>>>>>Struct tAPIIndex
78763>>>>>>>>>>>>>>>    Integer iIndexNumber
78763>>>>>>>>>>>>>>>    Integer iPrimaryIndex
78763>>>>>>>>>>>>>>>    String  sSQLIndexName
78763>>>>>>>>>>>>>>>    Integer iSQLIndexType
78763>>>>>>>>>>>>>>>    Boolean bIsSQLClustered
78763>>>>>>>>>>>>>>>    Boolean bIsSQLPrimaryKey
78763>>>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArray
78763>>>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArray
78763>>>>>>>>>>>>>>>    Boolean bShouldChange
78763>>>>>>>>>>>>>>>    Boolean bCancel
78763>>>>>>>>>>>>>>>    Boolean bError
78763>>>>>>>>>>>>>>>End_Struct
78763>>>>>>>>>>>>>>>
78763>>>>>>>>>>>>>>>Struct tAPIIndexCompare
78763>>>>>>>>>>>>>>>    // Common:
78763>>>>>>>>>>>>>>>    Integer iIndexNumber
78763>>>>>>>>>>>>>>>    // FROM database:
78763>>>>>>>>>>>>>>>    Boolean bExistsFrom
78763>>>>>>>>>>>>>>>    Integer iPrimaryIndexFrom
78763>>>>>>>>>>>>>>>    String  sSQLIndexNameFrom
78763>>>>>>>>>>>>>>>    Integer iSQLIndexTypeFrom
78763>>>>>>>>>>>>>>>    Boolean bIsSQLClusteredFrom
78763>>>>>>>>>>>>>>>    Boolean bIsSQLPrimaryKeyFrom
78763>>>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayFrom
78763>>>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayFrom
78763>>>>>>>>>>>>>>>    Boolean bShouldChangeFrom
78763>>>>>>>>>>>>>>>    Boolean bCancelFrom
78763>>>>>>>>>>>>>>>    Boolean bErrorFrom
78763>>>>>>>>>>>>>>>    // TO database:
78763>>>>>>>>>>>>>>>    Boolean bExistsTo
78763>>>>>>>>>>>>>>>    Integer iPrimaryIndexTo
78763>>>>>>>>>>>>>>>    String  sSQLIndexNameTo
78763>>>>>>>>>>>>>>>    Integer iSQLIndexTypeTo
78763>>>>>>>>>>>>>>>    Boolean bIsSQLClusteredTo
78763>>>>>>>>>>>>>>>    Boolean bIsSQLPrimaryKeyTo
78763>>>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayTo
78763>>>>>>>>>>>>>>>    tAPIIndexSegment[] IndexSegmentArrayTo
78763>>>>>>>>>>>>>>>    Boolean bShouldChangeTo
78763>>>>>>>>>>>>>>>    Boolean bCancelTo
78763>>>>>>>>>>>>>>>    Boolean bErrorTo
78763>>>>>>>>>>>>>>>End_Struct
78763>>>>>>>>>>>>>>>
78763>>>>>>>>>>>>>>>Struct tAPITableNameInfo
78763>>>>>>>>>>>>>>>    Integer iTableNumber
78763>>>>>>>>>>>>>>>    String  sRootName
78763>>>>>>>>>>>>>>>    String  sLogicalName
78763>>>>>>>>>>>>>>>    String  sDisplayName
78763>>>>>>>>>>>>>>>    String  sDriverID
78763>>>>>>>>>>>>>>>    Boolean bIsAlias
78763>>>>>>>>>>>>>>>    Boolean bIsSQL
78763>>>>>>>>>>>>>>>    Boolean bIsSystemFile
78763>>>>>>>>>>>>>>>    Boolean bShouldChange
78763>>>>>>>>>>>>>>>    Boolean bCancel
78763>>>>>>>>>>>>>>>    Boolean bError
78763>>>>>>>>>>>>>>>End_Struct
78763>>>>>>>>>>>>>>>
78763>>>>>>>>>>>>>>>Struct tAPITableNameInfoCompare
78763>>>>>>>>>>>>>>>    Integer iTableNumber
78763>>>>>>>>>>>>>>>    // FROM
78763>>>>>>>>>>>>>>>    Boolean bExistsFrom
78763>>>>>>>>>>>>>>>    String  sRootNameFrom
78763>>>>>>>>>>>>>>>    String  sLogicalNameFrom
78763>>>>>>>>>>>>>>>    String  sDisplayNameFrom
78763>>>>>>>>>>>>>>>    String  sDriverIDFrom
78763>>>>>>>>>>>>>>>    Boolean bIsAliasFrom
78763>>>>>>>>>>>>>>>    Boolean bIsSQLFrom
78763>>>>>>>>>>>>>>>    Boolean bIsSystemFileFrom
78763>>>>>>>>>>>>>>>    // TO database:
78763>>>>>>>>>>>>>>>    Boolean bExistsTo
78763>>>>>>>>>>>>>>>    String  sRootNameTo
78763>>>>>>>>>>>>>>>    String  sLogicalNameTo
78763>>>>>>>>>>>>>>>    String  sDisplayNameTo
78763>>>>>>>>>>>>>>>    String  sDriverIDTo
78763>>>>>>>>>>>>>>>    Boolean bIsAliasTo
78763>>>>>>>>>>>>>>>    Boolean bIsSQLTo
78763>>>>>>>>>>>>>>>    Boolean bIsSystemFileTo // *** Implement!
78763>>>>>>>>>>>>>>>    Boolean bShouldChange
78763>>>>>>>>>>>>>>>    Boolean bCancel
78763>>>>>>>>>>>>>>>    Boolean bError
78763>>>>>>>>>>>>>>>End_Struct
78763>>>>>>>>>>>>>>>
78763>>>>>>>>>>>>>>>Struct tAPITable
78763>>>>>>>>>>>>>>>    Handle hTable
78763>>>>>>>>>>>>>>>    Boolean bFromTable
78763>>>>>>>>>>>>>>>    Boolean bToTable
78763>>>>>>>>>>>>>>>    tAPITableNameInfo ApiTableInfo
78763>>>>>>>>>>>>>>>    tAPITableNameInfo ApiTableInfo
78763>>>>>>>>>>>>>>>    tAPIColumn[]      aApiColumns
78763>>>>>>>>>>>>>>>    tAPIColumn[]      aApiColumns
78763>>>>>>>>>>>>>>>    tAPIIndex[]       aApiIndexes
78763>>>>>>>>>>>>>>>    tAPIIndex[]       aApiIndexes
78763>>>>>>>>>>>>>>>    tAPIRelation[]    aApiRelations
78763>>>>>>>>>>>>>>>    tAPIRelation[]    aApiRelations
78763>>>>>>>>>>>>>>>    Boolean bShouldChange
78763>>>>>>>>>>>>>>>    Boolean bCancel
78763>>>>>>>>>>>>>>>    Boolean bError
78763>>>>>>>>>>>>>>>End_Struct
78763>>>>>>>>>>>>>>>
78763>>>>>>>>>>>>>>>Struct tAPITableCompare
78763>>>>>>>>>>>>>>>    Handle hTable
78763>>>>>>>>>>>>>>>    // FROM database:
78763>>>>>>>>>>>>>>>    Boolean bExistsFrom
78763>>>>>>>>>>>>>>>    // TO database:
78763>>>>>>>>>>>>>>>    Boolean bExistsTo
78763>>>>>>>>>>>>>>>    // Both:
78763>>>>>>>>>>>>>>>    tAPITableNameInfoCompare APITableNameInfoCompare
78763>>>>>>>>>>>>>>>    tAPITableNameInfoCompare APITableNameInfoCompare
78763>>>>>>>>>>>>>>>    tAPIColumnCompare[]     aAPIColumnsCompare
78763>>>>>>>>>>>>>>>    tAPIColumnCompare[]     aAPIColumnsCompare
78763>>>>>>>>>>>>>>>    tAPIIndexCompare[]      aAPIIndexesCompare
78763>>>>>>>>>>>>>>>    tAPIIndexCompare[]      aAPIIndexesCompare
78763>>>>>>>>>>>>>>>    tAPIRelationCompare[]   aAPIRelationsCompare
78763>>>>>>>>>>>>>>>    tAPIRelationCompare[]   aAPIRelationsCompare
78763>>>>>>>>>>>>>>>    Boolean bShouldChange   // Not implemented yet (!)
78763>>>>>>>>>>>>>>>    Boolean bCancel         // User cancel
78763>>>>>>>>>>>>>>>    Boolean bError          // Error occured while collecting data
78763>>>>>>>>>>>>>>>End_Struct
78763>>>>>>>>>>>>>>>
78763>>>>>>>>>>>>>>>Struct tAPITableBooleans
78763>>>>>>>>>>>>>>>    Boolean bApiTableUpdateAuto
78763>>>>>>>>>>>>>>>    Boolean bCompareDate_DateTime
78763>>>>>>>>>>>>>>>    Boolean bCompareIndexAscending
78763>>>>>>>>>>>>>>>    Boolean bCompareIndexUppercase
78763>>>>>>>>>>>>>>>    Boolean bCompareFilelistUppercase
78763>>>>>>>>>>>>>>>End_Struct
78763>>>>>>>>>>>>>>>
78763>>>>>>>>>>>>>>>Define C_tAPIColumn_None for 0
78763>>>>>>>>>>>>>>>Define C_tAPIColumn_Identity for 1
78763>>>>>>>>>>>>>>>
78763>>>>>>>>>>>>>>>// SQL Key-Word Constants:  CI_SQLSelect CI_SQLName CI_SQLFrom  CI_SQLSys
78763>>>>>>>>>>>>>>>// Used by the _SqlFindKeyWord function to return a proper keyword depending on the backend SQL,
78763>>>>>>>>>>>>>>>// i.e. one of the EN_DbTypeXXX members from the Enum_list above.
78763>>>>>>>>>>>>>>>// E.g. the CI_SQLAlterTable is only defined once, but the _SqlFindKeyWord function can return
78763>>>>>>>>>>>>>>>// different wording content depending on the EN_xxx value also passed to the function.
78763>>>>>>>>>>>>>>>Enum_List
78763>>>>>>>>>>>>>>>    Define CI_SQLAlterDatabase         //for "ALTER DATABASE"
78763>>>>>>>>>>>>>>>    Define CI_SQLSingle_User           //for "SINGLE_USER"
78763>>>>>>>>>>>>>>>    Define CI_SQLMulti_User            //for "USER_USER"
78763>>>>>>>>>>>>>>>    Define CI_SQLRollback              //for "ROLLBACK"
78763>>>>>>>>>>>>>>>    Define CI_SQLIMMEDIATE             //for "IMMEDIATE"
78763>>>>>>>>>>>>>>>    Define CI_SQLAlterTable            //for "ALTER TABLE"
78763>>>>>>>>>>>>>>>    Define CI_SQLAlterColumn           //for "ALTER COLUMN"
78763>>>>>>>>>>>>>>>    Define CI_SQLRenameColumn          //for "RENAME COLUMN"
78763>>>>>>>>>>>>>>>    Define CI_SQLColumn                //for "COLUMN"
78763>>>>>>>>>>>>>>>    Define CI_SQLSelect                //for "SELECT"
78763>>>>>>>>>>>>>>>    Define CI_SQLWhere                 //for "WHERE"
78763>>>>>>>>>>>>>>>    Define CI_SQLInfoSchema            //for "INFORMATION_SCHEMA.COLUMNS"
78763>>>>>>>>>>>>>>>    Define CI_SQLTable_Name            //for "TABLE_NAME"
78763>>>>>>>>>>>>>>>    Define CI_SQLTable                 //for "TABLE"
78763>>>>>>>>>>>>>>>    Define CI_SQLSys                   //for "SYS"
78763>>>>>>>>>>>>>>>    Define CI_SQLSp_Help               //for "SP_HELP"
78763>>>>>>>>>>>>>>>    Define CI_SQLFrom                  //for "FROM"
78763>>>>>>>>>>>>>>>    Define CI_SQLAdd                   //for "ADD"
78763>>>>>>>>>>>>>>>    Define CI_SQLDropColumn            //for "DROP"
78763>>>>>>>>>>>>>>>    Define CI_SQLCreateDatabase        //for "CREATE DATABASE"
78763>>>>>>>>>>>>>>>    Define CI_SQLDatabaseCollation     //for "COLLATE"
78763>>>>>>>>>>>>>>>    Define CI_SQLCreateTable           //for "CREATE TABLE"
78763>>>>>>>>>>>>>>>    Define CI_SQLDropTable             //for "DROP TABLE"
78763>>>>>>>>>>>>>>>    Define CI_SQLCreateView            //for "CREATE VIEW"
78763>>>>>>>>>>>>>>>    Define CI_SQLRenameTable           //for "RENAME TABLE"
78763>>>>>>>>>>>>>>>//    Define CI_SQLSelectFromWhereName   //for "SELECT name from [master].[dbo].[sysdatabases] where name"
78763>>>>>>>>>>>>>>>    Define CI_SQLDropView              //for "DROP VIEW"
78763>>>>>>>>>>>>>>>    Define CI_SQLSetNoCountOn          //for "SET NOCOUNT ON"
78763>>>>>>>>>>>>>>>    Define CI_SQLTo                    //for "TO"
78763>>>>>>>>>>>>>>>    Define CI_SQLGO                    //for "GO"
78763>>>>>>>>>>>>>>>    Define CI_SQLUse                   //for "USE"
78763>>>>>>>>>>>>>>>    Define CI_SQLDBO                   //for "DBO"
78763>>>>>>>>>>>>>>>
78763>>>>>>>>>>>>>>>    Define CI_SQLName                  //for "NAME"
78763>>>>>>>>>>>>>>>    Define CI_SQLMaster                //for "MASTER"
78763>>>>>>>>>>>>>>>    Define CI_SQLDatabases             //for "DATABASES"
78763>>>>>>>>>>>>>>>    Define CI_SQLSysIndexes            //for "SYS.INDEXES"
78763>>>>>>>>>>>>>>>    Define CI_SQLObjectID              //for "OBJECT_ID"
78763>>>>>>>>>>>>>>>    Define CI_SQLID                    //for "ID"
78763>>>>>>>>>>>>>>>    Define CI_SQLAND                   //for "AND"
78763>>>>>>>>>>>>>>>    Define CI_SQLUpdate                //for "UPDATE"
78763>>>>>>>>>>>>>>>    Define CI_SQLSet                   //for "SET"
78763>>>>>>>>>>>>>>>    Define CI_SQLWith                  //for "WITH"
78763>>>>>>>>>>>>>>>    Define CI_SQLNotNull               //for "NOT NULL"
78763>>>>>>>>>>>>>>>    Define CI_SQL_SAFE_UPDATES         //for "SQL_SAFE_UPDATES"  
78763>>>>>>>>>>>>>>>    Define CI_SQLDescription          //for "SELECT name, description from sys.fn_helpcollations()" (Enumerates all collates)
78763>>>>>>>>>>>>>>>End_Enum_List
78763>>>>>>>>>>>>>>>
78763>>>>>>>>>>>>>>>
78763>>>>>>>>>>>
78763>>>>>>>>>>>// This needs to be after Mertech drivers are defined.
78763>>>>>>>>>>>//Use cDbUpdateFunctionLibrary_Mixin.pkg
78763>>>>>>>>>>>
78763>>>>>>>>>>>
78763>>>>>>>>>>>// Create a new PSQL identifier for the Btrieve driver.
78763>>>>>>>>>>>    Define PSQLDRV_ID for "DFBTRDRV"
78763>>>>>>>>>>>
78763>>>>>>>>>>>
78763>>>>>>>>>>>
78763>>>>>>>>>>>
78763>>>>>>>>>>>
78763>>>>>>>>>>>
78763>>>>>>>>>>>// SQL Back-ends (iSQLDbType in the tSQLKeywords struct).
78763>>>>>>>>>>>// They can have slightly different SQL keywords.
78763>>>>>>>>>>>// Note: If a new type is added to the list,
78763>>>>>>>>>>>//       the struct array xxx must be adjusted
78763>>>>>>>>>>>//       so that it is filled with all SQL
78763>>>>>>>>>>>//       keywords for that new type.
78763>>>>>>>>>>>Enum_List  
78763>>>>>>>>>>>End_Enum_List
78763>>>>>>>>>>>
78763>>>>>>>>>>>// We need to have our "own" constants for the standard DataFlex data types.
78763>>>>>>>>>>>// These can be used with SQL functions such as e.g. SQLColumnAdd, instead
78763>>>>>>>>>>>// of using one of the driver specific integer constants such as e.g. "SQL_VARCHAR".
78763>>>>>>>>>>>Define CS_DbTypeDataFlex    for "DataFlex Embedded"
78763>>>>>>>>>>>Define CS_DbTypeMSSQL       for "Microsoft SQL Server"
78763>>>>>>>>>>>Define CS_DbTypeMySQL       for "MySQL"
78763>>>>>>>>>>>Define CS_DbTypeOracle      for "Oracle"
78763>>>>>>>>>>>Define CS_DbTypeDB2         for "IBM DB2"
78763>>>>>>>>>>>Define CS_DbTypePostgre     for "PostgreSQL"
78763>>>>>>>>>>>Define CS_DbTypePervasive   for "Pervasive.SQL (Btrieve)"
78763>>>>>>>>>>>
78763>>>>>>>>>>>
78763>>>>>>>>>>>// SQLConnection.ini constants:
78763>>>>>>>>>>>Define CS_SQLIniFileName                for "SQLConnections.ini"
78763>>>>>>>>>>>Define CS_SQLDF19IniFileName            for "DFConnId.ini"
78763>>>>>>>>>>>Define CS_SQLIniConnectionSection       for "SQL Connections" // Obsolete!
78763>>>>>>>>>>>Define CS_SQLIniSectionName             for "Connection"
78763>>>>>>>>>>>Define CS_SQLODBCIniSectionName         for "ODBC"
78763>>>>>>>>>>>
78763>>>>>>>>>>>// DF 19 ini-file settings:
78763>>>>>>>>>>>Define CS_SQLIniConnectionIdKeyword     for "Id"
78763>>>>>>>>>>>Define CS_SQLIniDriverKeyword           for "Driver"
78763>>>>>>>>>>>Define CS_SQLIniConnectionKeyWord       for "Connection"
78763>>>>>>>>>>>Define CS_SQLIniUIDKeyword              for "UID"
78763>>>>>>>>>>>Define CS_SQLIniPWDKeyword              for "PWD"
78763>>>>>>>>>>>Define CS_SQLIniDFPWDKeyword            for "DFPWD"
78763>>>>>>>>>>>Define CS_SQLIniServerKeyword           for "SERVER"
78763>>>>>>>>>>>Define CS_SQLIniDSNKeyword              for "DSN"
78763>>>>>>>>>>>Define CS_SQLIniFileDSNKeyword          for "FILEDSN"
78763>>>>>>>>>>>Define CS_SQLIniDatabaseKeyword         for "DATABASE"
78763>>>>>>>>>>>Define CS_SQLIniTrustedKeyword          for "Trusted_Connection" 
78763>>>>>>>>>>>Define CS_SQLIniDisabledKeyword         for "Disabled"
78763>>>>>>>>>>>
78763>>>>>>>>>>>// Database Update Framework extended settings:
78763>>>>>>>>>>>Define CS_SQLIniDbTypeKeyword           for "DbType"
78763>>>>>>>>>>>Define CS_SQLIniSchemaKeyword           for "Schema"
78763>>>>>>>>>>>Define CS_SQLIniBaseTableSpaceKeyword   for "Base Table Space"
78763>>>>>>>>>>>Define CS_SQLIniLongTableSpaceKeyword   for "Long Table Space"
78763>>>>>>>>>>>Define CS_SQLIniIndexTableSpaceKeyword  for "Index Table Space"
78763>>>>>>>>>>>Define CS_SQLIniSilentLoginKeyword      for "Silent Login"
78763>>>>>>>>>>>Define CS_SQLIniDisabledKeyword         for "Disabled"      // For compatability with DF19.
78763>>>>>>>>>>>
78763>>>>>>>>>>>Define CS_SQLIniConnectionPWD           for "PWD"
78763>>>>>>>>>>>Define CS_SQLIniConnectionYes           for "Yes"
78763>>>>>>>>>>>Define CS_SQLIniConnectionNo            for "No"
78763>>>>>>>>>>>
78763>>>>>>>>>>>Struct tSQLConnection
78763>>>>>>>>>>>    Boolean bEnabled                // 1. There can only be one active/enabled connection at a time.
78763>>>>>>>>>>>    String sConnectionID            // 2. The name of the connection ID.
78763>>>>>>>>>>>    Integer iDbType                 // 3. Database type; "MS-SQL Server", "DB2", "Oracle", "MySQL", "PostgreSQL"
78763>>>>>>>>>>>    String sDriverID                // 4. Name of the driver. E.g. MSSQLDRV, DB2_DRV, ODBC_DRV or PSQLDRV_ID.
78763>>>>>>>>>>>    String sServer                  // 5. SQL Server/DSN/ODBC source name. (In DF19 this is the "sString" member of the tConnection struct.)
78763>>>>>>>>>>>    String sDatabase                // 6. SQL Database
78763>>>>>>>>>>>    String sConnectionString        // 7. Full connection string as is needed by e.g. the login command.
78763>>>>>>>>>>>    Boolean bTrusted                // 8. Trusted connection (then is UID & PWD not used)
78763>>>>>>>>>>>    String sUserID                  // 9. User ID
78763>>>>>>>>>>>    String sPassword                // 10. Password
78763>>>>>>>>>>>    String sSchema                  // 11. DB2 (and perhaps ODBC specific)
78763>>>>>>>>>>>    String sBaseTableSpace          // 12. DB2 specific
78763>>>>>>>>>>>    String sLongTableSpace          // 13. DB2 specific
78763>>>>>>>>>>>    String sIndexTableSpace         // 14. DB2 specific
78763>>>>>>>>>>>    Boolean bSilentLogin            // 15. True=Silent login. (i.e. don't show Database login dialog if database login to fails). Same as driver "Options" parameter.
78763>>>>>>>>>>>    Boolean bError                  // 16. Set to true on error.
78763>>>>>>>>>>>    Boolean bDAWConnection          // 17. True if a DFConnId.ini file (from DAW) has been used instead of a DUF SQLConnections.ini file.
78763>>>>>>>>>>>//    Boolean bDisabled               // 17. For compatability with DF19 Managed Connections only. Not used by DUF (Database Update Framework).
78763>>>>>>>>>>>//    Integer iDriverIndex            // 18. For compatability with DF19 Managed Connections only. Not used by DUF (Database Update Framework).
78763>>>>>>>>>>>End_Struct
78763>>>>>>>>>Use cDbUpdateFunctionLibrary.inc
78763>>>>>>>>>
78763>>>>>>>>>Class cDbUpdateFunctionLibrary_Mixin is a Mixin
78764>>>>>>>>>    Procedure CreateDbUpdateLibraryProperties
78766>>>>>>>>>        Handle hoSQLManagerMT
78766>>>>>>>>>
78766>>>>>>>>>        Property String private.psUseDatabase ""
78767>>>>>>>>>
78767>>>>>>>>>        // These are used by the Error routine to show the Table# & Field# if something goes wrong:
78767>>>>>>>>>        Property Handle  private.phCurrentTable 0
78768>>>>>>>>>        Property Integer private.piCurrentField 0
78769>>>>>>>>>
78769>>>>>>>>>        Property Handle phoCLIHandler      (Create(Self,RefClass(cCLIHandler)))
78770>>>>>>>>>        Property Handle phoSQLManager      (Create(Self,RefClass(cSQLHandleManager)))
78771>>>>>>>>>
78771>>>>>>>>>        Property Handle phoSQLManagerMT
78772>>>>>>>>>            Move (Create(Self,RefClass(cSQLHandleManagerDUF))) to hoSQLManagerMT
78773>>>>>>>>>            Set phoSQLManagerMT to hoSQLManagerMT
78774>>>>>>>>>
78774>>>>>>>>>        Property Handle phoMSSQLHandler    (Create(Self,RefClass(cMSSQLHandler)))
78775>>>>>>>>>        Property Handle phoDB2SQLHandler   (Create(Self,RefClass(cDB2Handler)))
78776>>>>>>>>>        Property Handle phoODBCSQLHandler  (Create(Self,RefClass(cODBCHandler)))
78777>>>>>>>>>        Property Handle phoSQLConnectionHandler 0
78778>>>>>>>>>        Property tSQLKeyWords[] paSQLKeywordArray
78779>>>>>>>>>
78779>>>>>>>>>        Property Boolean pbHandleQueryErrors True
78780>>>>>>>>>
78780>>>>>>>>>        Property tSqlColumnNew[] paQueryColumns
78781>>>>>>>>>        Property String[] paSQLFetchResults
78782>>>>>>>>>
78782>>>>>>>>>        // Error handling
78782>>>>>>>>>        Property Integer Error_Report_Mode DUF_ERROR_REPORT
78783>>>>>>>>>        Property Boolean pbSqlError False
78784>>>>>>>>>        Property tSqlErrorArray paSqlErrorArray
78785>>>>>>>>>        Property Boolean pbProcessingError False
78786>>>>>>>>>
78786>>>>>>>>>        // Statistics on query
78786>>>>>>>>>        Property TimeSpan ptsTotalQueryTime
78787>>>>>>>>>        Property TimeSpan ptsQueryExec
78788>>>>>>>>>        Property TimeSpan ptsFetchResults
78789>>>>>>>>>        Property Integer piColumns 0
78790>>>>>>>>>        Property Integer piRows 0
78791>>>>>>>>>        Property Integer piRowType 0
78792>>>>>>>>>        Property String[] paQueryMessages
78793>>>>>>>>>        Property String psSQLStatementString
78794>>>>>>>>>
78794>>>>>>>>>        Property Integer[] paTableConvertExceptions
78795>>>>>>>>>
78795>>>>>>>>>        Property Integer[] paTableDateCorrectionExceptions
78796>>>>>>>>>
78796>>>>>>>>>        // Number of SQL statements (chunks) to be executed when executing a really big
78796>>>>>>>>>        // SQL file that has been compiled into the program. It is way faster to divide
78796>>>>>>>>>        // the statements in smaller chunks than to execute them all at the same time.
78796>>>>>>>>>        Property Integer piChunkMax 500
78797>>>>>>>>>
78797>>>>>>>>>        // Fill the paSQLKeywordArray array with values;
78797>>>>>>>>>        Send SetupSQLKeywordArray
78798>>>>>>>>>        Move Self to ghoDbUpdateFunctionLibrary
78799>>>>>>>>>    End_Procedure
78800>>>>>>>>>
78800>>>>>>>>>    // Custom array find function. It compares both the iSQLWord & iSQLDbType params.
78800>>>>>>>>>    Function CompareFindSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
78802>>>>>>>>>        If (SQLKeywords1.iSQLWord = SQLKeywords2.iSQLWord and SQLKeywords1.iSQLDbType = SQLKeywords2.iSQLDbType) Begin
78804>>>>>>>>>            Function_Return (EQ)
78805>>>>>>>>>        End
78805>>>>>>>>>>
78805>>>>>>>>>        Function_Return (GT)
78806>>>>>>>>>    End_Function
78807>>>>>>>>>
78807>>>>>>>>>    // Custom array sort function. It compares both the iSQLWord & iSQLDbType params.
78807>>>>>>>>>    Function CompareSortSQLKeyWords tSQLKeyWords SQLKeywords1 tSQLKeyWords SQLKeywords2 Returns Integer
78809>>>>>>>>>        If (SQLKeywords1.iSQLWord   < SQLKeywords2.iSQLWord) ;            Function_Return (LT)
78812>>>>>>>>>        If (SQLKeywords1.iSQLWord   > SQLKeywords2.iSQLWord) ;            Function_Return (GT)
78815>>>>>>>>>        If (SQLKeywords1.iSQLDbType < SQLKeywords2.iSQLDbType) ;            Function_Return (LT)
78818>>>>>>>>>        If (SQLKeywords1.iSQLDbType > SQLKeywords2.iSQLDbType) ;            Function_Return (GT)
78821>>>>>>>>>
78821>>>>>>>>>        Function_Return (EQ)
78822>>>>>>>>>    End_Function
78823>>>>>>>>>
78823>>>>>>>>>    Procedure Add_Element Integer iSQLKeywordConstant Integer iEN_dbType String sSQLKeyword
78825>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
78825>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray
78826>>>>>>>>>        Integer iSize
78826>>>>>>>>>
78826>>>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
78827>>>>>>>>>        Move (SizeOfArray(SQLKeywordArray)) to iSize
78828>>>>>>>>>        Move iSQLKeywordConstant to SQLKeywordArray[iSize].iSQLWord
78829>>>>>>>>>        Move iEN_dbType          to SQLKeywordArray[iSize].iSQLDbType
78830>>>>>>>>>        Move sSQLKeyword         to SQLKeywordArray[iSize].sSQLPhrase
78831>>>>>>>>>
78831>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArray
78832>>>>>>>>>    End_Procedure
78833>>>>>>>>>
78833>>>>>>>>>    // Creates a struct array with all SQL keywords
78833>>>>>>>>>    // for all EN_xxx SQL back-ends. Various back-ends can
78833>>>>>>>>>    // have slightly different wording.
78833>>>>>>>>>    // If a new EN_dbTypexxx type is added; additions
78833>>>>>>>>>    // needs to be done for every keyword group below.
78833>>>>>>>>>    Procedure SetupSQLKeywordArray
78835>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
78835>>>>>>>>>        tSQLKeyWords[] SQLKeywordArray SQLKeywordArraySorted
78837>>>>>>>>>
78837>>>>>>>>>        // This should only be called once; but in case it is
78837>>>>>>>>>        // we delete the array first.
78837>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArray
78838>>>>>>>>>
78838>>>>>>>>>        // ToDo: *** Not all SQL Key-words has been checked for other backends than MS-SQL ***
78838>>>>>>>>>        //
78838>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeMSSQL    "ALTER DATABASE"
78839>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeMySQL    "ALTER DATABASE"
78840>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeOracle   "ALTER DATABASE"
78841>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypeDB2      "ALTER DATABASE"
78842>>>>>>>>>        Send Add_Element CI_SQLAlterDatabase EN_dbTypePostgre  "ALTER DATABASE"
78843>>>>>>>>>
78843>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeMSSQL    "SINGLE_USER"
78844>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeMySQL    "SINGLE_USER"
78845>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeOracle   "SINGLE_USER"
78846>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypeDB2      "SINGLE_USER"
78847>>>>>>>>>        Send Add_Element CI_SQLSingle_User   EN_dbTypePostgre  "SINGLE_USER"
78848>>>>>>>>>
78848>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeMSSQL    "MULTI_USER"
78849>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeMySQL    "MULTI_USER"
78850>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeOracle   "MULTI_USER"
78851>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypeDB2      "MULTI_USER"
78852>>>>>>>>>        Send Add_Element CI_SQLMulti_User    EN_dbTypePostgre  "MULTI_USER"
78853>>>>>>>>>
78853>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeMSSQL    "ROLLBACK"
78854>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeMySQL    "ROLLBACK"
78855>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeOracle   "ROLLBACK"
78856>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypeDB2      "ROLLBACK"
78857>>>>>>>>>        Send Add_Element CI_SQLRollback      EN_dbTypePostgre  "ROLLBACK"
78858>>>>>>>>>
78858>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeMSSQL    "IMMEDIATE"
78859>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeMySQL    "IMMEDIATE"
78860>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeOracle   "IMMEDIATE"
78861>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypeDB2      "IMMEDIATE"
78862>>>>>>>>>        Send Add_Element CI_SQLImmediate     EN_dbTypePostgre  "IMMEDIATE"
78863>>>>>>>>>
78863>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMSSQL    "ALTER TABLE"
78864>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeMySQL    "ALTER TABLE"
78865>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeOracle   "ALTER TABLE"
78866>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypeDB2      "ALTER TABLE"
78867>>>>>>>>>        Send Add_Element CI_SQLAlterTable EN_dbTypePostgre  "ALTER TABLE"
78868>>>>>>>>>
78868>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMSSQL           "ADD"
78869>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeMySQL           "ADD"
78870>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeOracle          "ADD"
78871>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypeDB2             "ADD"
78872>>>>>>>>>        Send Add_Element CI_SQLAdd EN_dbTypePostgre         "ADD"
78873>>>>>>>>>
78873>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMSSQL        "UPDATE"
78874>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeMySQL        "UPDATE"
78875>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeOracle       "UPDATE"
78876>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypeDB2          "UPDATE"
78877>>>>>>>>>        Send Add_Element CI_SQLUpdate EN_dbTypePostgre      "UPDATE"
78878>>>>>>>>>
78878>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMSSQL       "NOT NULL"
78879>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeMySQL       "NOT NULL"
78880>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeOracle      "" // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
78881>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypeDB2         "DEFAULT NOT NULL"
78882>>>>>>>>>        Send Add_Element CI_SQLNotNull EN_dbTypePostgre     "NOT NULL"
78883>>>>>>>>>
78883>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_DbTypeMSSQL   ""
78884>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeMySQL   "SQL_SAFE_UPDATES"
78885>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeOracle  ""
78886>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypeDB2     ""
78887>>>>>>>>>        Send Add_Element CI_SQL_SAFE_UPDATES EN_dbTypePostgre ""
78888>>>>>>>>>
78888>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMSSQL           "SET"
78889>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeMySQL           "SET"
78890>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeOracle          "SET"
78891>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypeDB2             "SET"
78892>>>>>>>>>        Send Add_Element CI_SQLSet EN_dbTypePostgre         "SET"
78893>>>>>>>>>
78893>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeMSSQL          "WITH"
78894>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeMySQL          "WITH"
78895>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeOracle         "WITH"
78896>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypeDB2            "WITH"
78897>>>>>>>>>        Send Add_Element CI_SQLWith EN_dbTypePostgre        "WITH"
78898>>>>>>>>>
78898>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMSSQL    "CREATE DATABASE"
78899>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeMySQL    "CREATE DATABASE"
78900>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeOracle   "CREATE DATABASE"
78901>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypeDB2      "CREATE DATABASE"
78902>>>>>>>>>        Send Add_Element CI_SQLCreateDatabase EN_dbTypePostgre  "CREATE DATABASE"
78903>>>>>>>>>
78903>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeMSSQL    "COLLATE"
78904>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeMySQL    "COLLATE"
78905>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeOracle   "COLLATE"
78906>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypeDB2      "COLLATE"
78907>>>>>>>>>        Send Add_Element CI_SQLDatabaseCollation EN_dbTypePostgre  "COLLATE"
78908>>>>>>>>>
78908>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMSSQL    "CREATE VIEW"
78909>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeMySQL    "CREATE VIEW"
78910>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeOracle   "CREATE VIEW"
78911>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypeDB2      "CREATE VIEW"
78912>>>>>>>>>        Send Add_Element CI_SQLCreateView EN_dbTypePostgre  "CREATE VIEW"
78913>>>>>>>>>
78913>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMSSQL      "DROP VIEW"
78914>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeMySQL      "DROP VIEW"
78915>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeOracle     "DROP VIEW"
78916>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypeDB2        "DROP VIEW"
78917>>>>>>>>>        Send Add_Element CI_SQLDropView EN_dbTypePostgre    "DROP VIEW"
78918>>>>>>>>>
78918>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMSSQL   "CREATE TABLE"
78919>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeMySQL   "CREATE TABLE"
78920>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeOracle  "CREATE TABLE"
78921>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypeDB2     "CREATE TABLE"
78922>>>>>>>>>        Send Add_Element CI_SQLCreateTable EN_dbTypePostgre "CREATE TABLE"
78923>>>>>>>>>
78923>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMSSQL     "DROP TABLE"
78924>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeMySQL     "DROP TABLE"
78925>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeOracle    "DROP TABLE"
78926>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypeDB2       "DROP TABLE"
78927>>>>>>>>>        Send Add_Element CI_SQLDropTable EN_dbTypePostgre   "DROP TABLE"
78928>>>>>>>>>
78928>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMSSQL   "EXEC sp_rename"
78929>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeMySQL   "RENAME TABLE"
78930>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeOracle  "RENAME TABLE"
78931>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypeDB2     "RENAME TABLE"
78932>>>>>>>>>        Send Add_Element CI_SQLRenameTable EN_dbTypePostgre "RENAME TO"
78933>>>>>>>>>
78933>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMSSQL    "DROP COLUMN"
78934>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeMySQL    "DROP COLUMN"
78935>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeOracle   "DROP COLUMN"
78936>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypeDB2      "DROP COLUMN"
78937>>>>>>>>>        Send Add_Element CI_SQLDropColumn EN_dbTypePostgre  "DROP COLUMN"
78938>>>>>>>>>
78938>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMSSQL        "COLUMN"
78939>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeMySQL        "COLUMN"
78940>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeOracle       "COLUMN"
78941>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypeDB2          "COLUMN"
78942>>>>>>>>>        Send Add_Element CI_SQLColumn EN_dbTypePostgre      "COLUMN"
78943>>>>>>>>>
78943>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMSSQL   "ALTER COLUMN"
78944>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeMySQL   "MODIFY"
78945>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeOracle  "MODIFY"
78946>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypeDB2     "ALTER COLUMN"
78947>>>>>>>>>        Send Add_Element CI_SQLAlterColumn EN_dbTypePostgre "ALTER COLUMN"
78948>>>>>>>>>
78948>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMSSQL   "EXEC sp_RENAME"
78949>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeMySQL   "CHANGE"
78950>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeOracle  "RENAME COLUMN"
78951>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypeDB2     "RENAME COLUMN"
78952>>>>>>>>>        Send Add_Element CI_SQLRenameColumn EN_dbTypePostgre "RENAME COLUMN"
78953>>>>>>>>>
78953>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMSSQL        "SELECT"
78954>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeMySQL        "SELECT"
78955>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeOracle       "SELECT"
78956>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypeDB2          "SELECT"
78957>>>>>>>>>        Send Add_Element CI_SQLSelect EN_dbTypePostgre      "SELECT"
78958>>>>>>>>>
78958>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMSSQL         "WHERE"
78959>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeMySQL         "WHERE"
78960>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeOracle        "WHERE"
78961>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypeDB2           "WHERE"
78962>>>>>>>>>        Send Add_Element CI_SQLWhere EN_dbTypePostgre       "WHERE"
78963>>>>>>>>>
78963>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMSSQL          "FROM"
78964>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeMySQL          "FROM"
78965>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeOracle         "FROM"
78966>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypeDB2            "FROM"
78967>>>>>>>>>        Send Add_Element CI_SQLFrom EN_dbTypePostgre        "FROM"
78968>>>>>>>>>
78968>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMSSQL    "INFORMATION_SCHEMA.COLUMNS"
78969>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeMySQL    "INFORMATION_SCHEMA.COLUMNS"
78970>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeOracle   "INFORMATION_SCHEMA.COLUMNS"
78971>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypeDB2      "INFORMATION_SCHEMA.COLUMNS"
78972>>>>>>>>>        Send Add_Element CI_SQLInfoSchema EN_dbTypePostgre  "INFORMATION_SCHEMA.COLUMNS"
78973>>>>>>>>>
78973>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMSSQL    "TABLE_NAME"
78974>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeMySQL    "TABLE_NAME"
78975>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeOracle   "TABLE_NAME"
78976>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypeDB2      "TABLE_NAME"
78977>>>>>>>>>        Send Add_Element CI_SQLTable_Name EN_dbTypePostgre  "TABLE_NAME"
78978>>>>>>>>>
78978>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMSSQL         "TABLE"
78979>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeMySQL         "TABLE"
78980>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeOracle        "TABLE"
78981>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypeDB2           "TABLE"
78982>>>>>>>>>        Send Add_Element CI_SQLTable EN_dbTypePostgre       "TABLE"
78983>>>>>>>>>
78983>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMSSQL           "SYS"
78984>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeMySQL           "SYS"
78985>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeOracle          "SYS"
78986>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypeDB2             "SYS"
78987>>>>>>>>>        Send Add_Element CI_SQLSys EN_dbTypePostgre         "SYS"
78988>>>>>>>>>
78988>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMSSQL       "SP_HELP"
78989>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeMySQL       "SP_HELP"
78990>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeOracle      "SP_HELP"
78991>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypeDB2         "SP_HELP"
78992>>>>>>>>>        Send Add_Element CI_SQLSp_Help EN_dbTypePostgre     "SP_HELP"
78993>>>>>>>>>
78993>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMSSQL      "SET NOCOUNT ON"
78994>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeMySQL      "SET NOCOUNT ON"
78995>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeOracle     "SET NOCOUNT ON"
78996>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypeDB2        "SET NOCOUNT ON"
78997>>>>>>>>>        Send Add_Element CI_SQLSetNoCountOn EN_dbTypePostgre    "SET NOCOUNT ON"
78998>>>>>>>>>
78998>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMSSQL            "TO"
78999>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeMySQL            "TO"
79000>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeOracle           "TO"
79001>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypeDB2              "TO"
79002>>>>>>>>>        Send Add_Element CI_SQLTo EN_dbTypePostgre          "TO"
79003>>>>>>>>>
79003>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMSSQL            "GO"
79004>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeMySQL            "GO"
79005>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeOracle           "GO"
79006>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypeDB2              "GO"
79007>>>>>>>>>        Send Add_Element CI_SQLGO EN_dbTypePostgre          "GO"
79008>>>>>>>>>
79008>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMSSQL           "USE"
79009>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeMySQL           "USE"
79010>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeOracle          "USE"
79011>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypeDB2             "USE"
79012>>>>>>>>>        Send Add_Element CI_SQLUse EN_dbTypePostgre         "USE"
79013>>>>>>>>>
79013>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMSSQL           "dbo"
79014>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeMySQL           "dbo"
79015>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeOracle          "dbo"
79016>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypeDB2             "dbo"
79017>>>>>>>>>        Send Add_Element CI_SQLDBO EN_dbTypePostgre         "dbo"
79018>>>>>>>>>
79018>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMSSQL        "MASTER"
79019>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeMySQL        "MASTER"
79020>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeOracle       "MASTER"
79021>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypeDB2          "MASTER"
79022>>>>>>>>>        Send Add_Element CI_SQLMaster EN_dbTypePostgre      "MASTER"
79023>>>>>>>>>
79023>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeMSSQL          "NAME"
79024>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeMySQL          "NAME"
79025>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeOracle         "NAME"
79026>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypeDB2            "NAME"
79027>>>>>>>>>        Send Add_Element CI_SQLName EN_dbTypePostgre        "NAME"
79028>>>>>>>>>
79028>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMSSQL     "DATABASES"
79029>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeMySQL     "DATABASES"
79030>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeOracle    "DATABASES"
79031>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypeDB2       "DATABASES"
79032>>>>>>>>>        Send Add_Element CI_SQLDatabases EN_dbTypePostgre   "DATABASES"
79033>>>>>>>>>
79033>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMSSQL    "SYS.INDEXES"
79034>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeMySQL    "SYS.INDEXES"
79035>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeOracle   "SYS.INDEXES"
79036>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypeDB2      "SYS.INDEXES"
79037>>>>>>>>>        Send Add_Element CI_SQLSysIndexes EN_dbTypePostgre  "SYS.INDEXES"
79038>>>>>>>>>
79038>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMSSQL      "OBJECT_ID"
79039>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeMySQL      "OBJECT_ID"
79040>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeOracle     "OBJECT_ID"
79041>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypeDB2        "OBJECT_ID"
79042>>>>>>>>>        Send Add_Element CI_SQLObjectID EN_dbTypePostgre    "OBJECT_ID"
79043>>>>>>>>>
79043>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeMSSQL            "ID"
79044>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeMySQL            "ID"
79045>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeOracle           "ID"
79046>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypeDB2              "ID"
79047>>>>>>>>>        Send Add_Element CI_SQLID EN_dbTypePostgre          "ID"
79048>>>>>>>>>
79048>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMSSQL           "AND"
79049>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeMySQL           "AND"
79050>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeOracle          "AND"
79051>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypeDB2             "AND"
79052>>>>>>>>>        Send Add_Element CI_SQLAND EN_dbTypePostgre         "AND"
79053>>>>>>>>>
79053>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeMSSQL   "DESCRIPTION"
79054>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeMySQL   "DESCRIPTION"
79055>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeOracle  "DESCRIPTION"
79056>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypeDB2     "DESCRIPTION"
79057>>>>>>>>>        Send Add_Element CI_SQLDescription EN_dbTypePostgre "DESCRIPTION"
79058>>>>>>>>>
79058>>>>>>>>>        // In case we didn't put the above in order (and we don't need to); we sort the struct array.
79058>>>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
79059>>>>>>>>>        Move (SortArray(SQLKeywordArray, Self, (RefFunc(CompareSortSQLKeyWords)))) to SQLKeywordArraySorted
79060>>>>>>>>>        Set paSQLKeywordArray to SQLKeywordArraySorted
79061>>>>>>>>>
79061>>>>>>>>>    End_Procedure
79062>>>>>>>>>
79062>>>>>>>>>End_Class
79063>>>>>>>Use cSQLConnectionHandler.pkg
Including file: cSQLConnectionHandler.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionHandler.pkg)
79063>>>>>>>>>//****************************************************************************
79063>>>>>>>>>// $Module type: Class
79063>>>>>>>>>// $Module name: cSQLConnectionHandler.pkg
79063>>>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
79063>>>>>>>>>// Web-site    : http://www.rdctools.com
79063>>>>>>>>>// Created     : 2015-08-11 @ 16:02 (Military date format: YY-MM-DD)
79063>>>>>>>>>//
79063>>>>>>>>>// Description : A handler class for using CLI connection ID's to login to a database server.
79063>>>>>>>>>//
79063>>>>>>>>>// $Rev History:
79063>>>>>>>>>//    2015-08-11  Module header created
79063>>>>>>>>>//    2016-09-26  Changed name of the objecthandle from ghoCreateConnectionID to ghoSQLConnectionHandler.
79063>>>>>>>>>//                Added a new structure for passing connection data back & forth.
79063>>>>>>>>>//                Added better error handling.
79063>>>>>>>>>//                Added a decompose message for the connection string.
79063>>>>>>>>>//    2017-01-09  Added support for Mertech drivers
79063>>>>>>>>>//                Big overhaul to comply better with "Managed Connections" (DF 19)
79063>>>>>>>>>//                These changes make the class compatible with DFConnId.ini (can read/write DAW connection ini-files)
79063>>>>>>>>>//    2017-02-12  Reworked the whole connection property interface.
79063>>>>>>>>>//                Now there is one struct property that is the at cencter of a connection.
79063>>>>>>>>>//****************************************************************************
79063>>>>>>>>>Use cli.pkg
79063>>>>>>>>>Use MSSqldrv.pkg
79063>>>>>>>>>Use db2_drv.pkg
79063>>>>>>>>>Use odbc_drv.pkg
79063>>>>>>>>>Use cSQLConnectionIniFile.pkg
Including file: cSQLConnectionIniFile.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLConnectionIniFile.pkg)
79063>>>>>>>>>>>//****************************************************************************
79063>>>>>>>>>>>// $Module type: Class
79063>>>>>>>>>>>// $Module name: cSQLConnectionIniFile.pkg
79063>>>>>>>>>>>//
79063>>>>>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International.
79063>>>>>>>>>>>// Copyright (c) 2012 RDC Tools International
79063>>>>>>>>>>>// E-mail      : support@rdctools.com
79063>>>>>>>>>>>// Web-site    : http://www.rdctools.com
79063>>>>>>>>>>>//
79063>>>>>>>>>>>// Created     : 2012-09-20 @ 18:04 (Military date format - Year-Month-Day)
79063>>>>>>>>>>>//
79063>>>>>>>>>>>// Note        : The file must be USEd after declaration of the ghoApplication object, as it uses
79063>>>>>>>>>>>//               properties of that object.
79063>>>>>>>>>>>//
79063>>>>>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
79063>>>>>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
79063>>>>>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
79063>>>>>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
79063>>>>>>>>>>>// in the help folder for more details.
79063>>>>>>>>>>>//
79063>>>>>>>>>>>Use cSQLConnectionIniFile.inc
79063>>>>>>>>>>>Use cDbUpdateDatabaseDriver.pkg
Including file: cDbUpdateDatabaseDriver.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateDatabaseDriver.pkg)
79063>>>>>>>>>>>>>Use cSQLConnectionIniFile.inc
79063>>>>>>>>>>>>>
79063>>>>>>>>>>>>>Class cDbUpdateGenericDatabaseDriver is a cObject
79064>>>>>>>>>>>>>    Procedure Construct_Object
79066>>>>>>>>>>>>>        Forward Send Construct_Object
79068>>>>>>>>>>>>>        Property String psDriverID DATAFLEX_ID
79069>>>>>>>>>>>>>    End_Procedure
79070>>>>>>>>>>>>>
79070>>>>>>>>>>>>>    Function ServerKeyword String sServer Returns String
79072>>>>>>>>>>>>>        String sRetval
79072>>>>>>>>>>>>>        If (Uppercase(sServer) contains ("." + CS_SQLIniDSNKeyword)) Begin
79074>>>>>>>>>>>>>            Move CS_SQLIniFileDSNKeyword to sRetval    
79075>>>>>>>>>>>>>        End                                        
79075>>>>>>>>>>>>>>
79075>>>>>>>>>>>>>        Else Begin
79076>>>>>>>>>>>>>            Move CS_SQLIniDSNKeyword to sRetval
79077>>>>>>>>>>>>>        End
79077>>>>>>>>>>>>>>
79077>>>>>>>>>>>>>            
79077>>>>>>>>>>>>>        Function_Return sRetval
79078>>>>>>>>>>>>>    End_Function
79079>>>>>>>>>>>>>
79079>>>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
79081>>>>>>>>>>>>>        String sConnect sServerKeyWord sDriverID
79081>>>>>>>>>>>>>
79081>>>>>>>>>>>>>        Get psDriverID to sDriverID
79082>>>>>>>>>>>>>        Get ServerKeyword sServer to sServerKeyWord
79083>>>>>>>>>>>>>        Move (sConnect + sServerKeyWord + "=" + sServer) to sConnect
79084>>>>>>>>>>>>>        If (sServerKeyWord = CS_SQLIniDSNKeyword or sServerKeyWord = CS_SQLIniFileDSNKeyword) Begin
79086>>>>>>>>>>>>>            Move "" to sDatabase
79087>>>>>>>>>>>>>        End
79087>>>>>>>>>>>>>>
79087>>>>>>>>>>>>>        
79087>>>>>>>>>>>>>        // 2019-10-20 I think this was plain wrong for the DAW ODBC_DRV driver. At least it didn't work for login to an MS-SQL db.
79087>>>>>>>>>>>>>//        If (bTrusted = False and (sDriverID = ODBC_DRV_ID and sServerKeyWord = CS_SQLIniDSNKeyword)) Begin
79087>>>>>>>>>>>>>//            Function_Return sConnect
79087>>>>>>>>>>>>>//        End
79087>>>>>>>>>>>>>
79087>>>>>>>>>>>>>        If (sDatabase <> "") Begin
79089>>>>>>>>>>>>>            Move (sConnect + ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
79090>>>>>>>>>>>>>        End
79090>>>>>>>>>>>>>>
79090>>>>>>>>>>>>>        If (bTrusted = True) Begin
79092>>>>>>>>>>>>>            Move (sConnect + ";" + CS_SQLIniTrustedKeyword + "=Yes") to sConnect
79093>>>>>>>>>>>>>        End
79093>>>>>>>>>>>>>>
79093>>>>>>>>>>>>>        Else Begin
79094>>>>>>>>>>>>>            Move (sConnect + ";" + CS_SQLIniUIDKeyword + "=" + sUserID + ";" + CS_SQLIniPWDKeyword + "=" + sPassword) to sConnect
79095>>>>>>>>>>>>>        End
79095>>>>>>>>>>>>>>
79095>>>>>>>>>>>>>        Function_Return sConnect
79096>>>>>>>>>>>>>    End_Function
79097>>>>>>>>>>>>>
79097>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
79099>>>>>>>>>>>>>        Boolean bLoginSuccessful
79099>>>>>>>>>>>>>        String sDriverID
79099>>>>>>>>>>>>>
79099>>>>>>>>>>>>>        Get psDriverID to sDriverID
79100>>>>>>>>>>>>>        If (sDriverID = DATAFLEX_ID or sDriverID = "") Begin
79102>>>>>>>>>>>>>            Function_Return True
79103>>>>>>>>>>>>>        End
79103>>>>>>>>>>>>>>
79103>>>>>>>>>>>>>        Move 0 to LastErr  // Do NOT use the Err flag, it will be set true by the login command although it is successful.
79104>>>>>>>>>>>>>        If (bTrusted = False and sDatabase <> "") Begin
79106>>>>>>>>>>>>>            Move (SFormat("SERVER=%1;DATABASE=%2", sServer, sDatabase)) to sServer
79107>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID  
79109>>>>>>>>>>>>>        End
79109>>>>>>>>>>>>>>
79109>>>>>>>>>>>>>        Else Begin
79110>>>>>>>>>>>>>            Login sConnectionString "" "" sDriverID
79112>>>>>>>>>>>>>        End
79112>>>>>>>>>>>>>>
79112>>>>>>>>>>>>>        Move (LastErr = 0) to bLoginSuccessful
79113>>>>>>>>>>>>>        Function_Return bLoginSuccessful
79114>>>>>>>>>>>>>    End_Function
79115>>>>>>>>>>>>>End_Class
79116>>>>>>>>>>>>>
79116>>>>>>>>>>>>>Class cDbUpdateMSSQLDriver is a cDbUpdateGenericDatabaseDriver
79117>>>>>>>>>>>>>    Function ServerKeyword String sServer Returns String
79119>>>>>>>>>>>>>        Function_Return CS_SQLIniServerKeyword
79120>>>>>>>>>>>>>    End_Function
79121>>>>>>>>>>>>>End_Class
79122>>>>>>>>>>>>>
79122>>>>>>>>>>>>>Class cDbUpdateODBCDriver is a cDbUpdateGenericDatabaseDriver
79123>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
79125>>>>>>>>>>>>>        Boolean bLoginSuccessful
79125>>>>>>>>>>>>>        String sDriverID
79125>>>>>>>>>>>>>
79125>>>>>>>>>>>>>        Get psDriverID to sDriverID
79126>>>>>>>>>>>>>        Move (Trim(sDriverID)) to sDriverID
79127>>>>>>>>>>>>>        If (sDriverID = DATAFLEX_ID or sDriverID = "") Begin
79129>>>>>>>>>>>>>            Function_Return True
79130>>>>>>>>>>>>>        End
79130>>>>>>>>>>>>>>
79130>>>>>>>>>>>>>        Move 0 to LastErr  // Do NOT use the Err flag, it will be set true by the login command although it is successful.
79131>>>>>>>>>>>>>        If (bTrusted = False) Begin
79133>>>>>>>>>>>>>            If (Uppercase(sServer) contains ("." + String(CS_SQLIniDSNKeyword))) Begin
79135>>>>>>>>>>>>>                Move (CS_SQLIniFileDSNKeyword + "=" + sServer) to sServer
79136>>>>>>>>>>>>>            End
79136>>>>>>>>>>>>>>
79136>>>>>>>>>>>>>            Else If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
79139>>>>>>>>>>>>>                Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
79140>>>>>>>>>>>>>            End
79140>>>>>>>>>>>>>>
79140>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID  
79142>>>>>>>>>>>>>        End
79142>>>>>>>>>>>>>>
79142>>>>>>>>>>>>>        Else Begin
79143>>>>>>>>>>>>>            Login sConnectionString "" "" sDriverID
79145>>>>>>>>>>>>>        End
79145>>>>>>>>>>>>>>
79145>>>>>>>>>>>>>        Move (LastErr = 0) to bLoginSuccessful
79146>>>>>>>>>>>>>
79146>>>>>>>>>>>>>        Function_Return bLoginSuccessful
79147>>>>>>>>>>>>>    End_Function
79148>>>>>>>>>>>>>End_Class
79149>>>>>>>>>>>>>
79149>>>>>>>>>>>>>Class cDbUpdateDB2Driver is a cDbUpdateGenericDatabaseDriver
79150>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
79152>>>>>>>>>>>>>        Boolean bLoginSuccessful
79152>>>>>>>>>>>>>        String sDriverID
79152>>>>>>>>>>>>>
79152>>>>>>>>>>>>>        Move False to Err
79153>>>>>>>>>>>>>        Get psDriverID to sDriverID
79154>>>>>>>>>>>>>        If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
79156>>>>>>>>>>>>>            Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
79157>>>>>>>>>>>>>        End
79157>>>>>>>>>>>>>>
79157>>>>>>>>>>>>>        Login sServer sUserId sPassword sDriverID
79159>>>>>>>>>>>>>
79159>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
79160>>>>>>>>>>>>>        Function_Return bLoginSuccessful
79161>>>>>>>>>>>>>    End_Function
79162>>>>>>>>>>>>>End_Class
79163>>>>>>>>>>>>>
79163>>>>>>>>>>>>>Class cDbUpdatePSQLDriver is a cDbUpdateGenericDatabaseDriver
79164>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
79166>>>>>>>>>>>>>        Boolean bLoginSuccessful
79166>>>>>>>>>>>>>        String sDriverID
79166>>>>>>>>>>>>>
79166>>>>>>>>>>>>>        Move False to Err
79167>>>>>>>>>>>>>        Get psDriverID to sDriverID
79168>>>>>>>>>>>>>//        If (not(Uppercase(sServer) contains CS_SQLIniDSNKeyword)) Begin
79168>>>>>>>>>>>>>//            Move (CS_SQLIniDSNKeyword + "=" + sServer) to sServer
79168>>>>>>>>>>>>>//        End
79168>>>>>>>>>>>>>        Login sServer sUserId sPassword sDriverID
79170>>>>>>>>>>>>>
79170>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
79171>>>>>>>>>>>>>        Function_Return bLoginSuccessful
79172>>>>>>>>>>>>>    End_Function
79173>>>>>>>>>>>>>End_Class
79174>>>>>>>>>>>>>
79174>>>>>>>>>>>>>Class cDbUpdateDataFlexDriver is a cDbUpdateGenericDatabaseDriver
79175>>>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
79177>>>>>>>>>>>>>        Function_Return ""
79178>>>>>>>>>>>>>    End_Function
79179>>>>>>>>>>>>>End_Class
79180>>>>>>>>>>>>>
79180>>>>>>>>>>>>>Class cDbUpdateSQLFLEXDriver is a cDbUpdateGenericDatabaseDriver
79181>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
79183>>>>>>>>>>>>>        Boolean bLoginSuccessful
79183>>>>>>>>>>>>>        String sDriverID
79183>>>>>>>>>>>>>
79183>>>>>>>>>>>>>        Get psDriverID to sDriverID
79184>>>>>>>>>>>>>        //For the Mertech driver, using the Err indicator is the sanctioned way
79184>>>>>>>>>>>>>        Move False to Err
79185>>>>>>>>>>>>>        If (bTrusted = False) Begin
79187>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID
79189>>>>>>>>>>>>>        End
79189>>>>>>>>>>>>>>
79189>>>>>>>>>>>>>        Else Begin
79190>>>>>>>>>>>>>            Login sServer "" "" sDriverID
79192>>>>>>>>>>>>>        End
79192>>>>>>>>>>>>>>
79192>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
79193>>>>>>>>>>>>>
79193>>>>>>>>>>>>>        Function_Return bLoginSuccessful
79194>>>>>>>>>>>>>    End_Function
79195>>>>>>>>>>>>>End_Class
79196>>>>>>>>>>>>>
79196>>>>>>>>>>>>>Class cDbUpdateORAFLEXDriver is a cDbUpdateGenericDatabaseDriver
79197>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
79199>>>>>>>>>>>>>        Boolean bLoginSuccessful
79199>>>>>>>>>>>>>        String sDriverID
79199>>>>>>>>>>>>>        Integer iPos
79199>>>>>>>>>>>>>
79199>>>>>>>>>>>>>        Get psDriverID to sDriverID
79200>>>>>>>>>>>>>        Move (Pos("/", sServer)) to iPos
79201>>>>>>>>>>>>>        If (iPos = 0) Begin
79203>>>>>>>>>>>>>            If (sDatabase <> "") Begin
79205>>>>>>>>>>>>>                Move (sServer + "/" + sDatabase) to sServer
79206>>>>>>>>>>>>>            End
79206>>>>>>>>>>>>>>
79206>>>>>>>>>>>>>        End
79206>>>>>>>>>>>>>>
79206>>>>>>>>>>>>>        // For the Mertech driver, using the Err indicator is the sanctioned way
79206>>>>>>>>>>>>>        Move False to Err
79207>>>>>>>>>>>>>        // For Oracle I don't believe "Trusted" doesn't exist.
79207>>>>>>>>>>>>>        Login sServer sUserId sPassword sDriverID
79209>>>>>>>>>>>>>
79209>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
79210>>>>>>>>>>>>>        Function_Return bLoginSuccessful
79211>>>>>>>>>>>>>    End_Function
79212>>>>>>>>>>>>>End_Class
79213>>>>>>>>>>>>>
79213>>>>>>>>>>>>>Class cDbUpdateMDSMySQLDriver is a cDbUpdateGenericDatabaseDriver
79214>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
79216>>>>>>>>>>>>>        Boolean bLoginSuccessful
79216>>>>>>>>>>>>>        String sDriverID
79216>>>>>>>>>>>>>
79216>>>>>>>>>>>>>        Get psDriverID to sDriverID
79217>>>>>>>>>>>>>        // For the Mertech driver, using the Err indicator is the sanctioned way
79217>>>>>>>>>>>>>        Move False to Err
79218>>>>>>>>>>>>>        If (bTrusted = False) Begin
79220>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID
79222>>>>>>>>>>>>>        End
79222>>>>>>>>>>>>>>
79222>>>>>>>>>>>>>        Else Begin
79223>>>>>>>>>>>>>            Login sServer "" "" sDriverID
79225>>>>>>>>>>>>>        End
79225>>>>>>>>>>>>>>
79225>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
79226>>>>>>>>>>>>>        Function_Return bLoginSuccessful
79227>>>>>>>>>>>>>    End_Function
79228>>>>>>>>>>>>>End_Class
79229>>>>>>>>>>>>>
79229>>>>>>>>>>>>>Class cDbUpdateMDSPgSQLDriver is a cDbUpdateGenericDatabaseDriver
79230>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
79232>>>>>>>>>>>>>        Boolean bLoginSuccessful
79232>>>>>>>>>>>>>        String sDriverID
79232>>>>>>>>>>>>>
79232>>>>>>>>>>>>>        Get psDriverID to sDriverID
79233>>>>>>>>>>>>>        // For the Mertech driver, using the Err indicator is the sanctioned way
79233>>>>>>>>>>>>>        Move False to Err
79234>>>>>>>>>>>>>        If (bTrusted = False) Begin
79236>>>>>>>>>>>>>            Login sServer sUserId sPassword sDriverID
79238>>>>>>>>>>>>>        End
79238>>>>>>>>>>>>>>
79238>>>>>>>>>>>>>        Else Begin
79239>>>>>>>>>>>>>            Login sServer "" "" sDriverID
79241>>>>>>>>>>>>>        End
79241>>>>>>>>>>>>>>
79241>>>>>>>>>>>>>        Move (not(Err)) to bLoginSuccessful
79242>>>>>>>>>>>>>        Function_Return bLoginSuccessful
79243>>>>>>>>>>>>>    End_Function
79244>>>>>>>>>>>>>End_Class
79245>>>>>>>>>>>>>
79245>>>>>>>>>>>>>Class cDbUpdateDatabaseDriver is a cObject
79246>>>>>>>>>>>>>    Procedure Construct_Object
79248>>>>>>>>>>>>>        Forward Send Construct_Object
79250>>>>>>>>>>>>>        Property String psDriverID DATAFLEX_ID
79251>>>>>>>>>>>>>        Property Handle phoDriverSpecificObject
79252>>>>>>>>>>>>>    End_Procedure
79253>>>>>>>>>>>>>
79253>>>>>>>>>>>>>    Function CreateDriver Returns Handle
79255>>>>>>>>>>>>>        String sDriverID
79255>>>>>>>>>>>>>        Handle hoDriver hcDriverClass
79255>>>>>>>>>>>>>
79255>>>>>>>>>>>>>        Get psDriverID to sDriverID
79256>>>>>>>>>>>>>        Case Begin
79256>>>>>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
79258>>>>>>>>>>>>>                Move (RefClass(cDbUpdateMSSQLDriver))    to hcDriverClass
79259>>>>>>>>>>>>>                Case Break
79260>>>>>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
79263>>>>>>>>>>>>>                Move (RefClass(cDbUpdateODBCDriver))     to hcDriverClass
79264>>>>>>>>>>>>>                Case Break
79265>>>>>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
79268>>>>>>>>>>>>>                Move (RefClass(cDbUpdateDB2Driver))      to hcDriverClass
79269>>>>>>>>>>>>>                Case Break               
79270>>>>>>>>>>>>>//            Case (sDriverID = DFBTRDRV_ID)
79270>>>>>>>>>>>>>//                Move (RefClass(cDbUpdateDatabaseDriver)) to hcDriverClass
79270>>>>>>>>>>>>>//                Case Break
79270>>>>>>>>>>>>>            Case (sDriverID = SQLFLEX)
79273>>>>>>>>>>>>>                Move (RefClass(cDbUpdateSQLFLEXDriver))  to hcDriverClass
79274>>>>>>>>>>>>>                Case Break
79275>>>>>>>>>>>>>            Case (sDriverID = ORAFLEX)
79278>>>>>>>>>>>>>                Move (RefClass(cDbUpdateORAFLEXDriver))  to hcDriverClass
79279>>>>>>>>>>>>>                Case Break
79280>>>>>>>>>>>>>            Case (sDriverID = MDSPgSQL)
79283>>>>>>>>>>>>>                Move (RefClass(cDbUpdateMDSPgSQLDriver)) to hcDriverClass
79284>>>>>>>>>>>>>                Case Break
79285>>>>>>>>>>>>>            Case (sDriverID = MDSMySQL)
79288>>>>>>>>>>>>>                Move (RefClass(cDbUpdateMDSMySQLDriver)) to hcDriverClass
79289>>>>>>>>>>>>>                Case Break
79290>>>>>>>>>>>>>            // DATAFLEX_ID = Default driver
79290>>>>>>>>>>>>>            Case Else
79290>>>>>>>>>>>>>                Move (RefClass(cDbUpdateDataFlexDriver)) to hcDriverClass
79291>>>>>>>>>>>>>                Move DATAFLEX_ID to sDriverID
79292>>>>>>>>>>>>>        Case End
79292>>>>>>>>>>>>>
79292>>>>>>>>>>>>>        Get Create hcDriverClass to hoDriver
79293>>>>>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
79294>>>>>>>>>>>>>        Set phoDriverSpecificObject to hoDriver
79295>>>>>>>>>>>>>
79295>>>>>>>>>>>>>        Function_Return hoDriver
79296>>>>>>>>>>>>>    End_Function
79297>>>>>>>>>>>>>
79297>>>>>>>>>>>>>    Procedure DestroyDriver
79299>>>>>>>>>>>>>        If (phoDriverSpecificObject(Self)) Begin
79301>>>>>>>>>>>>>            Send Destroy of (phoDriverSpecificObject(Self))
79302>>>>>>>>>>>>>        End
79302>>>>>>>>>>>>>>
79302>>>>>>>>>>>>>    End_Procedure
79303>>>>>>>>>>>>>
79303>>>>>>>>>>>>>    Function ConstructConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
79305>>>>>>>>>>>>>        String sConnect
79305>>>>>>>>>>>>>        Handle hoDriver
79305>>>>>>>>>>>>>
79305>>>>>>>>>>>>>        Get CreateDriver to hoDriver
79306>>>>>>>>>>>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
79307>>>>>>>>>>>>>        Send DestroyDriver
79308>>>>>>>>>>>>>        Function_Return sConnect
79309>>>>>>>>>>>>>    End_Function
79310>>>>>>>>>>>>>
79310>>>>>>>>>>>>>    Function DbLogin String sConnectionString String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns Boolean
79312>>>>>>>>>>>>>        Boolean bLoginSuccessful
79312>>>>>>>>>>>>>        Handle hoDriver
79312>>>>>>>>>>>>>
79312>>>>>>>>>>>>>        Get CreateDriver to hoDriver
79313>>>>>>>>>>>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
79314>>>>>>>>>>>>>        Send DestroyDriver
79315>>>>>>>>>>>>>        Function_Return bLoginSuccessful
79316>>>>>>>>>>>>>    End_Function
79317>>>>>>>>>>>>>
79317>>>>>>>>>>>>>End_Class
79318>>>>>>>>>>>
79318>>>>>>>>>>>    Use cLoginEncryption.pkg
Including file: cLoginEncryption.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cLoginEncryption.pkg)
79318>>>>>>>>>>>>>Use cCryptographer.pkg
79318>>>>>>>>>>>>>
79318>>>>>>>>>>>>>Class cLoginEncryption is a cObject
79319>>>>>>>>>>>>>    
79319>>>>>>>>>>>>>    Procedure Construct_Object
79321>>>>>>>>>>>>>        Forward Send Construct_Object
79323>>>>>>>>>>>>>        // this must be set to a multi (40ish) character random key
79323>>>>>>>>>>>>>        Property String psEncryptPassword ""
79324>>>>>>>>>>>>>        
79324>>>>>>>>>>>>>        Object oDataCrypter is a cCryptographer
79326>>>>>>>>>>>>>            Set piHash to CALG_SHA_256
79327>>>>>>>>>>>>>            Set piCipher to CALG_AES_256
79328>>>>>>>>>>>>>            Set psProvider to "" //  Not providing a specific provider gives the default provider for the provider type
79329>>>>>>>>>>>>>            Set piProvider to PROV_RSA_AES
79330>>>>>>>>>>>>>        End_Object
79331>>>>>>>>>>>>>    End_Procedure
79332>>>>>>>>>>>>>    
79332>>>>>>>>>>>>>    // This can be augmented to return a password encryption key using any
79332>>>>>>>>>>>>>    // hidden mechanism desired.
79332>>>>>>>>>>>>>    Function GetEncryptionPassword Returns String
79334>>>>>>>>>>>>>        String sPassword
79334>>>>>>>>>>>>>        Get psEncryptPassword to sPassword
79335>>>>>>>>>>>>>        Function_Return sPassword
79336>>>>>>>>>>>>>    End_Function
79337>>>>>>>>>>>>>    
79337>>>>>>>>>>>>>    // Encrypts a string into an unreadable hash that can later be decrypted using DecryptKey.
79337>>>>>>>>>>>>>    //
79337>>>>>>>>>>>>>    // Params:
79337>>>>>>>>>>>>>    //   sPlainText     String to encrypt.
79337>>>>>>>>>>>>>    // Returns:
79337>>>>>>>>>>>>>    //   Base64 encoded hash.
79337>>>>>>>>>>>>>    Function EncryptPassword String sPlainText Returns String
79339>>>>>>>>>>>>>        String sEncryptPassword sBinary sBase64
79339>>>>>>>>>>>>>        Address pBase64
79339>>>>>>>>>>>>>        Integer iVoid
79339>>>>>>>>>>>>>        
79339>>>>>>>>>>>>>        //  Encrypt Key
79339>>>>>>>>>>>>>        Get GetEncryptionPassword to sEncryptPassword
79340>>>>>>>>>>>>>        If (sEncryptPassword = "") Begin
79342>>>>>>>>>>>>>            Error DFERR_PROGRAM "No encryption password set"
79343>>>>>>>>>>>>>>
79343>>>>>>>>>>>>>        End
79343>>>>>>>>>>>>>>
79343>>>>>>>>>>>>>        
79343>>>>>>>>>>>>>        Get Encrypt of oDataCrypter sEncryptPassword sPlainText to sBinary
79344>>>>>>>>>>>>>        
79344>>>>>>>>>>>>>        If (sPlainText = sBinary or sBinary = "") Begin
79346>>>>>>>>>>>>>            Error DFERR_PROGRAM "Unable to encrypt database login password"
79347>>>>>>>>>>>>>>
79347>>>>>>>>>>>>>            Function_Return ""
79348>>>>>>>>>>>>>        End
79348>>>>>>>>>>>>>>
79348>>>>>>>>>>>>>        
79348>>>>>>>>>>>>>        //  Encode binary hash to Base64
79348>>>>>>>>>>>>>        Move (Base64Encode(AddressOf(sBinary), Length(sBinary))) to pBase64
79349>>>>>>>>>>>>>        Move pBase64 to sBase64
79350>>>>>>>>>>>>>        Move (Free(pBase64)) to iVoid
79351>>>>>>>>>>>>>        
79351>>>>>>>>>>>>>        Function_Return sBase64
79352>>>>>>>>>>>>>    End_Function
79353>>>>>>>>>>>>>    
79353>>>>>>>>>>>>>    
79353>>>>>>>>>>>>>    // Decrypts the unreadable hash generated by EncryptKey into a readable string.
79353>>>>>>>>>>>>>    //
79353>>>>>>>>>>>>>    // Params:
79353>>>>>>>>>>>>>    //   sBase64EncryptedPassword       Base64 Encrypted password
79353>>>>>>>>>>>>>    // Returns:
79353>>>>>>>>>>>>>    //   Readable plain text password
79353>>>>>>>>>>>>>    Function DecryptPassword String sBase64EncryptedPassword Returns String
79355>>>>>>>>>>>>>        String sEncryptPassword sPlainText sBinary
79355>>>>>>>>>>>>>        Boolean bIsHex
79355>>>>>>>>>>>>>        Integer iLen iVoid
79355>>>>>>>>>>>>>        Address pBinary
79355>>>>>>>>>>>>>        
79355>>>>>>>>>>>>>        If (sBase64EncryptedPassword <> "") Begin
79357>>>>>>>>>>>>>            //  Decode from Base64
79357>>>>>>>>>>>>>            Move (Base64Decode(AddressOf(sBase64EncryptedPassword), &iLen)) to pBinary
79358>>>>>>>>>>>>>            
79358>>>>>>>>>>>>>            Move (Repeat(Character(0), iLen)) to sBinary
79359>>>>>>>>>>>>>            Move (CopyMemory(AddressOf(sBinary), pBinary, iLen)) to iVoid
79360>>>>>>>>>>>>>            
79360>>>>>>>>>>>>>            Move (Free(pBinary)) to iVoid
79361>>>>>>>>>>>>>            
79361>>>>>>>>>>>>>            //  Encrypted binary hash to string
79361>>>>>>>>>>>>>            Get GetEncryptionPassword to sEncryptPassword
79362>>>>>>>>>>>>>            Get Decrypt of oDataCrypter sEncryptPassword sBinary to sPlainText
79363>>>>>>>>>>>>>        End
79363>>>>>>>>>>>>>>
79363>>>>>>>>>>>>>        
79363>>>>>>>>>>>>>        Function_Return sPlainText
79364>>>>>>>>>>>>>    End_Function
79365>>>>>>>>>>>>>End_Class
79366>>>>>>>>>>>
79366>>>>>>>>>>>Class cSQLConnectionIniFile is a cIniFile
79367>>>>>>>>>>>    Procedure Construct_Object
79369>>>>>>>>>>>        Forward Send Construct_Object
79371>>>>>>>>>>>
79371>>>>>>>>>>>        Property String Private_psIniFilePath
79372>>>>>>>>>>>        Property String Private_psIniFileName CS_SQLIniFileName
79373>>>>>>>>>>>        Property String psIniSectionName (CS_SQLIniSectionName + "1")
79374>>>>>>>>>>>
79374>>>>>>>>>>>        Property Boolean pbDFConnId False
79375>>>>>>>>>>>
79375>>>>>>>>>>>        // *** You really want to change this value! ***
79375>>>>>>>>>>>        // It is used when encrypting/decrypting passwords.
79375>>>>>>>>>>>        Property String psHashString "zx!2139(LI0+?ips7433"
79376>>>>>>>>>>>
79376>>>>>>>>>>>    End_Procedure
79377>>>>>>>>>>>
79377>>>>>>>>>>>    Procedure End_Construct_Object
79379>>>>>>>>>>>        Forward Send End_Construct_Object
79381>>>>>>>>>>>    End_Procedure
79382>>>>>>>>>>>
79382>>>>>>>>>>>    Procedure Set psIniFilePath String sPath
79384>>>>>>>>>>>        String sIniFile
79384>>>>>>>>>>>        Get vFolderFormat sPath to sPath
79385>>>>>>>>>>>        Set private_psIniFilePath to sPath
79386>>>>>>>>>>>        Get psIniFileName to sIniFile
79387>>>>>>>>>>>        Set psFileName to (sPath + sIniFile)
79388>>>>>>>>>>>    End_Procedure
79389>>>>>>>>>>>
79389>>>>>>>>>>>    Function psIniFilePath Returns String
79391>>>>>>>>>>>        Function_Return (private_psIniFilePath(Self))
79392>>>>>>>>>>>    End_Function
79393>>>>>>>>>>>
79393>>>>>>>>>>>    Procedure Set psIniFileName String sFileName
79395>>>>>>>>>>>        String sPath
79395>>>>>>>>>>>        Get psIniFilePath to sPath
79396>>>>>>>>>>>        Set psFileName to (sPath + sFileName)
79397>>>>>>>>>>>        Set private_psIniFileName to sFileName
79398>>>>>>>>>>>    End_Procedure
79399>>>>>>>>>>>
79399>>>>>>>>>>>    Function psIniFileName Returns String
79401>>>>>>>>>>>        Function_Return (private_psIniFileName(Self))
79402>>>>>>>>>>>    End_Function
79403>>>>>>>>>>>
79403>>>>>>>>>>>    // *** Generalized messages to Get & Set values of the ini file.
79403>>>>>>>>>>>    // Sets a value in the program's ini file (write)
79403>>>>>>>>>>>    // Pass a section name, the value name parameter and the value itself to be written.
79403>>>>>>>>>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
79405>>>>>>>>>>>        String sIniFile sPath
79405>>>>>>>>>>>
79405>>>>>>>>>>>        Get psIniFilePath to sPath
79406>>>>>>>>>>>        Get psIniFileName to sIniFile
79407>>>>>>>>>>>        Move (sPath + sIniFile) to sIniFile
79408>>>>>>>>>>>        Set psFileName to sIniFile
79409>>>>>>>>>>>        Send WriteString sSection sValueName sValue
79410>>>>>>>>>>>    End_Procedure
79411>>>>>>>>>>>
79411>>>>>>>>>>>    // Get a value from program's ini-file (read)
79411>>>>>>>>>>>    // Pass a section name and the name of the value parameter & a default value.
79411>>>>>>>>>>>    // Returns the value
79411>>>>>>>>>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
79413>>>>>>>>>>>        String sValue sIniFile sPath
79413>>>>>>>>>>>
79413>>>>>>>>>>>        Get psIniFilePath to sPath
79414>>>>>>>>>>>        Get psIniFileName to sIniFile
79415>>>>>>>>>>>        Move (sPath + sIniFile) to sIniFile
79416>>>>>>>>>>>        Set psFileName to sIniFile
79417>>>>>>>>>>>        Get ReadString sSection sValueName sDefaultValue to sValue
79418>>>>>>>>>>>
79418>>>>>>>>>>>        Function_Return sValue
79419>>>>>>>>>>>    End_Function
79420>>>>>>>>>>>
79420>>>>>>>>>>>    // Sort function that first sorts on bEnabled & then on the connection string.
79420>>>>>>>>>>>    Function SortActiveFirst tSQLConnection SQLConnectionRow1 tSQLConnection SQLConnectionRow2 Returns Integer
79422>>>>>>>>>>>        If (SQLConnectionRow1.bEnabled > SQLConnectionRow2.bEnabled) ;            Function_Return (LT)
79425>>>>>>>>>>>        If (SQLConnectionRow1.bEnabled < SQLConnectionRow2.bEnabled) ;            Function_Return (GT)
79428>>>>>>>>>>>
79428>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionID < SQLConnectionRow2.sConnectionID) ;            Function_Return (LT)
79431>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionID > SQLConnectionRow2.sConnectionID) ;            Function_Return (GT)
79434>>>>>>>>>>>
79434>>>>>>>>>>>        If (SQLConnectionRow1.iDbType < SQLConnectionRow2.iDbType) ;            Function_Return (LT)
79437>>>>>>>>>>>        If (SQLConnectionRow1.iDbType > SQLConnectionRow2.iDbType) ;            Function_Return (GT)
79440>>>>>>>>>>>
79440>>>>>>>>>>>        If (SQLConnectionRow1.sServer < SQLConnectionRow2.sServer) ;            Function_Return (LT)
79443>>>>>>>>>>>        If (SQLConnectionRow1.sServer > SQLConnectionRow2.sServer) ;            Function_Return (GT)
79446>>>>>>>>>>>
79446>>>>>>>>>>>        If (SQLConnectionRow1.sDatabase < SQLConnectionRow2.sDatabase) ;            Function_Return (LT)
79449>>>>>>>>>>>        If (SQLConnectionRow1.sDatabase > SQLConnectionRow2.sDatabase) ;            Function_Return (GT)
79452>>>>>>>>>>>
79452>>>>>>>>>>>        If (SQLConnectionRow1.sDriverID < SQLConnectionRow2.sDriverID) ;            Function_Return (LT)
79455>>>>>>>>>>>        If (SQLConnectionRow1.sDriverID > SQLConnectionRow2.sDriverID) ;            Function_Return (GT)
79458>>>>>>>>>>>
79458>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionString < SQLConnectionRow2.sConnectionString) ;            Function_Return (LT)
79461>>>>>>>>>>>        If (SQLConnectionRow1.sConnectionString > SQLConnectionRow2.sConnectionString) ;            Function_Return (GT)
79464>>>>>>>>>>>
79464>>>>>>>>>>>        Function_Return (EQ)
79465>>>>>>>>>>>    End_Function
79466>>>>>>>>>>>
79466>>>>>>>>>>>    Function SQLIniFileNumberOfConnections Returns Integer
79468>>>>>>>>>>>        Handle hoSections
79468>>>>>>>>>>>        Integer iItems
79468>>>>>>>>>>>
79468>>>>>>>>>>>        Send ReadSections hoSections
79469>>>>>>>>>>>        Move (Item_Count(hoSections)) to iItems
79470>>>>>>>>>>>        Function_Return iItems
79471>>>>>>>>>>>    End_Function
79472>>>>>>>>>>>
79472>>>>>>>>>>>    // The normal connection string looks something like this;
79472>>>>>>>>>>>    // "SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
79472>>>>>>>>>>>    // ...but the full connection string looks like this;
79472>>>>>>>>>>>    // "DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0"
79472>>>>>>>>>>>//    Function SQLIniFileAddConnection String sFullConnectionString Returns Boolean
79472>>>>>>>>>>>//        String sSection
79472>>>>>>>>>>>//        Integer iCount
79472>>>>>>>>>>>//
79472>>>>>>>>>>>//        Move False to Err
79472>>>>>>>>>>>//        Get psIniSectionName to sSection
79472>>>>>>>>>>>//        Get SQLIniFileNumberOfConnections to iCount
79472>>>>>>>>>>>//        Increment iCount
79472>>>>>>>>>>>//        Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to sFullConnectionString
79472>>>>>>>>>>>//
79472>>>>>>>>>>>//        Function_Return (Err = False)
79472>>>>>>>>>>>//    End_Function
79472>>>>>>>>>>>
79472>>>>>>>>>>>    Function SQLIniFileDeleteAllConnections Returns Boolean
79474>>>>>>>>>>>        Integer iCount
79474>>>>>>>>>>>        Boolean bExists
79474>>>>>>>>>>>        String sSection
79474>>>>>>>>>>>
79474>>>>>>>>>>>        Move False to Err
79475>>>>>>>>>>>        Move 1 to iCount
79476>>>>>>>>>>>        Get psIniSectionName to sSection
79477>>>>>>>>>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
79478>>>>>>>>>>>        While (bExists = True)
79482>>>>>>>>>>>            Send DeleteSection (CS_SQLIniSectionName + String(iCount))
79483>>>>>>>>>>>            Increment iCount
79484>>>>>>>>>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
79485>>>>>>>>>>>        Loop
79486>>>>>>>>>>>>
79486>>>>>>>>>>>        Function_Return (Err = False)
79487>>>>>>>>>>>    End_Function
79488>>>>>>>>>>>
79488>>>>>>>>>>>    Function SQLIniFileDeleteConnection Integer iItem Returns Boolean
79490>>>>>>>>>>>        Integer iCount
79490>>>>>>>>>>>        String sSection
79490>>>>>>>>>>>        Boolean bExists
79490>>>>>>>>>>>
79490>>>>>>>>>>>        Move False to Err
79491>>>>>>>>>>>        Move 1 to iCount
79492>>>>>>>>>>>        Get psIniSectionName to sSection
79493>>>>>>>>>>>        Get KeyExists sSection CS_SQLIniConnectionIdKeyword to bExists
79494>>>>>>>>>>>        While (bExists = True)
79498>>>>>>>>>>>            If (iCount = iItem) Begin
79500>>>>>>>>>>>                Send DeleteSection sSection
79501>>>>>>>>>>>//                Set IniFileValue sSection (CS_SQLIniSectionName + String(iCount)) to ""
79501>>>>>>>>>>>                Move 9999 to iCount // Just some ridiculously high number to get out of the loop as we're done.
79502>>>>>>>>>>>            End
79502>>>>>>>>>>>>
79502>>>>>>>>>>>            Increment iCount
79503>>>>>>>>>>>            Get KeyExists sSection (CS_SQLIniSectionName + String(iCount)) to bExists
79504>>>>>>>>>>>        Loop
79505>>>>>>>>>>>>
79505>>>>>>>>>>>
79505>>>>>>>>>>>        Function_Return (Err = False)
79506>>>>>>>>>>>    End_Function
79507>>>>>>>>>>>
79507>>>>>>>>>>>    // Returns all connection details for the passed Connection ID as a tSQLConnection
79507>>>>>>>>>>>    // If it fails the returned struct member SQLConnection.bError = True.
79507>>>>>>>>>>>    Function SQLIniFileConnectionID String sConnectionID Returns tSQLConnection
79509>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
79509>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
79510>>>>>>>>>>>        tSQLConnection   SQLConnection
79510>>>>>>>>>>>        tSQLConnection   SQLConnection
79510>>>>>>>>>>>        Integer iIndex
79510>>>>>>>>>>>
79510>>>>>>>>>>>        Get SQLIniFileConnectionIDIndex sConnectionID to iIndex
79511>>>>>>>>>>>        If (iIndex = -1) Begin
79513>>>>>>>>>>>            Move True to SQLConnection.bError
79514>>>>>>>>>>>            Function_Return SQLConnection
79515>>>>>>>>>>>        End
79515>>>>>>>>>>>>
79515>>>>>>>>>>>
79515>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
79516>>>>>>>>>>>        Move SQLConnectionsArray[iIndex -1] to SQLConnection
79517>>>>>>>>>>>
79517>>>>>>>>>>>        Function_Return SQLConnection
79518>>>>>>>>>>>    End_Function
79519>>>>>>>>>>>
79519>>>>>>>>>>>    // Returns -1 if the passed connection ID was not found, else the item number.
79519>>>>>>>>>>>    Function SQLIniFileConnectionIDIndex String sConnectionID Returns Integer
79521>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
79521>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
79522>>>>>>>>>>>        Integer iRetval iCount iSize
79522>>>>>>>>>>>        String sValue
79522>>>>>>>>>>>        Boolean bExists
79522>>>>>>>>>>>
79522>>>>>>>>>>>        Move -1 to iRetval
79523>>>>>>>>>>>
79523>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
79524>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
79525>>>>>>>>>>>        Decrement iSize
79526>>>>>>>>>>>        For iCount from 0 to iSize
79532>>>>>>>>>>>>
79532>>>>>>>>>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
79533>>>>>>>>>>>            Move (Uppercase(sValue) = Uppercase(sConnectionID)) to bExists
79534>>>>>>>>>>>            If (bExists) Begin
79536>>>>>>>>>>>                Move (iCount + 1) to iRetval // The [ConnectionX] keys are one-based (starts at 1) but the loop starts at zero.
79537>>>>>>>>>>>                Move iSize to iCount         // We're done!
79538>>>>>>>>>>>            End
79538>>>>>>>>>>>>
79538>>>>>>>>>>>        Loop
79539>>>>>>>>>>>>
79539>>>>>>>>>>>
79539>>>>>>>>>>>        Function_Return iRetval
79540>>>>>>>>>>>    End_Function
79541>>>>>>>>>>>
79541>>>>>>>>>>>    // Checks if the passed sConnectionID exists more than once in the passed struct array.
79541>>>>>>>>>>>    // Used to check that ConnectionID's are unique.
79541>>>>>>>>>>>    Function IsConnectionIDDuplicate String sConnectionID Returns Boolean
79543>>>>>>>>>>>        Integer iCount iSize iItems
79543>>>>>>>>>>>        String sValue
79543>>>>>>>>>>>        Boolean bExists
79543>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
79543>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
79544>>>>>>>>>>>
79544>>>>>>>>>>>        Move 0 to iItems
79545>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
79546>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
79547>>>>>>>>>>>        Decrement iSize
79548>>>>>>>>>>>        For iCount from 0 to iSize
79554>>>>>>>>>>>>
79554>>>>>>>>>>>            Move SQLConnectionsArray[iCount].sConnectionID to sValue
79555>>>>>>>>>>>            Move (sValue = sConnectionID) to bExists
79556>>>>>>>>>>>            If (bExists) Begin
79558>>>>>>>>>>>                Increment iItems
79559>>>>>>>>>>>            End
79559>>>>>>>>>>>>
79559>>>>>>>>>>>        Loop
79560>>>>>>>>>>>>
79560>>>>>>>>>>>
79560>>>>>>>>>>>        Function_Return (iItems > 1)
79561>>>>>>>>>>>    End_Function
79562>>>>>>>>>>>
79562>>>>>>>>>>>    // To update the SQLConnections.ini file with a new default Connection ID.
79562>>>>>>>>>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
79564>>>>>>>>>>>        Boolean bOK
79564>>>>>>>>>>>        Integer iSize iCount
79564>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
79564>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
79565>>>>>>>>>>>        tSQLConnection SQLConnection
79565>>>>>>>>>>>        tSQLConnection SQLConnection
79565>>>>>>>>>>>        String sConnectionString
79565>>>>>>>>>>>
79565>>>>>>>>>>>        Move False to Err
79566>>>>>>>>>>>        Get psConnectionString to sConnectionString
79567>>>>>>>>>>>
79567>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
79568>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
79569>>>>>>>>>>>        Decrement iSize
79570>>>>>>>>>>>        // Set all current connection to inactive.
79570>>>>>>>>>>>        For iCount from 0 to iSize
79576>>>>>>>>>>>>
79576>>>>>>>>>>>            Move False to SQLConnectionsArray[iCount].bEnabled
79577>>>>>>>>>>>        Loop
79578>>>>>>>>>>>>
79578>>>>>>>>>>>
79578>>>>>>>>>>>        Get SQLIniFileConnectionID sConnectionID to SQLConnection
79579>>>>>>>>>>>        Move True              to SQLConnection.bEnabled
79580>>>>>>>>>>>        Move sConnectionString to SQLConnection.sConnectionString
79581>>>>>>>>>>>        Move (InsertInArray(SQLConnectionsArray, 0, SQLConnection)) to SQLConnectionsArray
79582>>>>>>>>>>>        Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
79583>>>>>>>>>>>
79583>>>>>>>>>>>        Function_Return (bOK = True)
79584>>>>>>>>>>>    End_Function
79585>>>>>>>>>>>
79585>>>>>>>>>>>    // Used for updating an existing connection with new data.
79585>>>>>>>>>>>    // Returns True if successful.
79585>>>>>>>>>>>    Function SQLIniFileUpdateConnection tSQLConnection SQLConnection Returns Boolean
79587>>>>>>>>>>>        Boolean bOK
79587>>>>>>>>>>>        Integer iItem iSize iCount
79587>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
79587>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
79588>>>>>>>>>>>
79588>>>>>>>>>>>        Move False to Err
79589>>>>>>>>>>>        Move -1 to iItem
79590>>>>>>>>>>>        Get SQLIniFileReadConnections to SQLConnectionsArray
79591>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
79592>>>>>>>>>>>        Decrement iSize
79593>>>>>>>>>>>        // Set all current connection to inactive.
79593>>>>>>>>>>>        For iCount from 0 to iSize
79599>>>>>>>>>>>>
79599>>>>>>>>>>>            Move False to SQLConnectionsArray[iCount].bEnabled
79600>>>>>>>>>>>            If (SQLConnectionsArray[iCount].sConnectionID = SQLConnection.sConnectionID) Begin
79602>>>>>>>>>>>                Move iCount to iItem
79603>>>>>>>>>>>            End
79603>>>>>>>>>>>>
79603>>>>>>>>>>>        Loop
79604>>>>>>>>>>>>
79604>>>>>>>>>>>
79604>>>>>>>>>>>        If (iItem <> -1) Begin
79606>>>>>>>>>>>            Move True to SQLConnection.bEnabled
79607>>>>>>>>>>>            Move SQLConnection to SQLConnectionsArray[iItem]
79608>>>>>>>>>>>            Get SQLIniFileWriteConnections SQLConnectionsArray to bOK
79609>>>>>>>>>>>        End
79609>>>>>>>>>>>>
79609>>>>>>>>>>>
79609>>>>>>>>>>>        Function_Return (bOK = True)
79610>>>>>>>>>>>    End_Function
79611>>>>>>>>>>>
79611>>>>>>>>>>>    Function SQLIniFileReadConnections Returns tSQLConnection[]
79613>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
79613>>>>>>>>>>>        tSQLConnection[] SQLConnectionsArray
79614>>>>>>>>>>>        String sSection sValue
79614>>>>>>>>>>>        Integer iCount
79614>>>>>>>>>>>        Boolean bExists
79614>>>>>>>>>>>
79614>>>>>>>>>>>        Get psIniSectionName to sSection
79615>>>>>>>>>>>        Get SectionExists sSection to bExists
79616>>>>>>>>>>>        If (bExists = False) Begin
79618>>>>>>>>>>>            Function_Return SQLConnectionsArray
79619>>>>>>>>>>>        End
79619>>>>>>>>>>>>
79619>>>>>>>>>>>        Get SectionExists CS_SQLIniConnectionSection to bExists
79620>>>>>>>>>>>        If (bExists = True) Begin
79622>>>>>>>>>>>            Error DFERR_PROGRAM "Sorry, the format for the SQLConnections.ini file has been changed and this file has the old format that is no longer valid and thus cannot be read. You need to re-enter your connection(s)."
79623>>>>>>>>>>>>
79623>>>>>>>>>>>        End
79623>>>>>>>>>>>>
79623>>>>>>>>>>>
79623>>>>>>>>>>>        Move 1 to iCount // The section name "[ConnectionXX]" starts with "1"
79624>>>>>>>>>>>        Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
79625>>>>>>>>>>>
79625>>>>>>>>>>>        While (bExists = True)                 
79629>>>>>>>>>>>            // 2018-07-14 Change to allow disabling all connections in test environment.
79629>>>>>>>>>>>            // We always put the enabled/active connection at the top
79629>>>>>>>>>>>//            Move (iCount = 1) to bEnabled
79629>>>>>>>>>>>//            Move bEnabled to SQLConnectionsArray[iCount].bEnabled
79629>>>>>>>>>>>
79629>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionIdKeyword ""        to SQLConnectionsArray[iCount].sConnectionID
79630>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDriverKeyword       ""        to SQLConnectionsArray[iCount].sDriverID
79631>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDisabledKeyword     ""        to sValue
79632>>>>>>>>>>>            Move (If(Uppercase(sValue) = "YES", False, True))                                               to SQLConnectionsArray[iCount].bEnabled
79633>>>>>>>>>>>
79633>>>>>>>>>>>            // The iDbType might be missing from the ini-file. This is e.g. the case when a DAW Managed Connection "DFConnId.ini" file is read.
79633>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDbTypeKeyword       "99"      to sValue
79634>>>>>>>>>>>            If (sValue = "99") Begin
79636>>>>>>>>>>>                Get SqlUtilDbTypeFromDriver SQLConnectionsArray[iCount].sDriverID to sValue
79637>>>>>>>>>>>            End
79637>>>>>>>>>>>>
79637>>>>>>>>>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].iDbType
79638>>>>>>>>>>>
79638>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniConnectionKeyWord   ""        to SQLConnectionsArray[iCount].sConnectionString
79639>>>>>>>>>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnectionsArray[iCount].sServer
79640>>>>>>>>>>>            If (SQLConnectionsArray[iCount].sServer = "") Begin
79642>>>>>>>>>>>                Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniFileDSNKeyword +"=") to SQLConnectionsArray[iCount].sServer
79643>>>>>>>>>>>            End
79643>>>>>>>>>>>>
79643>>>>>>>>>>>            If (SQLConnectionsArray[iCount].sServer = "") Begin
79645>>>>>>>>>>>                Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDSNKeyword +"=")   to SQLConnectionsArray[iCount].sServer
79646>>>>>>>>>>>            End
79646>>>>>>>>>>>>
79646>>>>>>>>>>>
79646>>>>>>>>>>>            Get ParseKeyWord SQLConnectionsArray[iCount].sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnectionsArray[iCount].sDatabase
79647>>>>>>>>>>>
79647>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniTrustedKeyword      ""        to sValue
79648>>>>>>>>>>>            Move (If(Uppercase(sValue) = "YES", True, False))                                               to SQLConnectionsArray[iCount].bTrusted
79649>>>>>>>>>>>
79649>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniUIDKeyword          ""        to SQLConnectionsArray[iCount].sUserID
79650>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniDFPWDKeyword        ""        to sValue
79651>>>>>>>>>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
79653>>>>>>>>>>>                Get DecryptPassword sValue to sValue
79654>>>>>>>>>>>            End
79654>>>>>>>>>>>>
79654>>>>>>>>>>>            Move sValue                                                                                     to SQLConnectionsArray[iCount].sPassword
79655>>>>>>>>>>>
79655>>>>>>>>>>>            // Here we reconstruct the connection string to be complete with all params;
79655>>>>>>>>>>>            Get ConstructConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                          SQLConnectionsArray[iCount].bTrusted SQLConnectionsArray[iCount].sUserID SQLConnectionsArray[iCount].sPassword ;                                          to SQLConnectionsArray[iCount].sConnectionString
79656>>>>>>>>>>>
79656>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSchemaKeyword          ""     to SQLConnectionsArray[iCount].sSchema
79657>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniBaseTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sBaseTableSpace
79658>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniLongTableSpaceKeyword  ""     to SQLConnectionsArray[iCount].sLongTableSpace
79659>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniIndexTableSpaceKeyword ""     to SQLConnectionsArray[iCount].sIndexTableSpace
79660>>>>>>>>>>>            Get IniFileValue (CS_SQLIniSectionName + String(iCount)) CS_SQLIniSilentLoginKeyword     ""     to sValue
79661>>>>>>>>>>>            Move (If(Uppercase(sValue) = "YES", True, False))                                               to SQLConnectionsArray[iCount].bSilentLogin
79662>>>>>>>>>>>
79662>>>>>>>>>>>            Increment iCount
79663>>>>>>>>>>>            Get SectionExists (CS_SQLIniSectionName + String(iCount)) to bExists
79664>>>>>>>>>>>        Loop
79665>>>>>>>>>>>>
79665>>>>>>>>>>>
79665>>>>>>>>>>>        // Lastly, we remove the very first array item as it is empty (we started at 1 because that is the first [Connection#])
79665>>>>>>>>>>>        If (SizeOfArray(SQLConnectionsArray) > 0) Begin
79667>>>>>>>>>>>            Move (RemoveFromArray(SQLConnectionsArray, 0)) to SQLConnectionsArray
79668>>>>>>>>>>>        End
79668>>>>>>>>>>>>
79668>>>>>>>>>>>
79668>>>>>>>>>>>        Function_Return SQLConnectionsArray
79669>>>>>>>>>>>    End_Function
79670>>>>>>>>>>>
79670>>>>>>>>>>>    Function SQLIniFileWriteConnections tSQLConnection[] SQLConnectionsArray Returns Boolean
79672>>>>>>>>>>>        Integer iCount iSize
79672>>>>>>>>>>>        Boolean bOK
79672>>>>>>>>>>>        String sSection sValue
79672>>>>>>>>>>>
79672>>>>>>>>>>>        // First we need to _remove_ all current connections from the ini-file.
79672>>>>>>>>>>>        Move 0 to iCount
79673>>>>>>>>>>>        Get SQLIniFileDeleteAllConnections to bOK
79674>>>>>>>>>>>        If (bOK = False) Begin
79676>>>>>>>>>>>            Function_Return False
79677>>>>>>>>>>>        End
79677>>>>>>>>>>>>
79677>>>>>>>>>>>
79677>>>>>>>>>>>        Move False to Err
79678>>>>>>>>>>>        Get psIniSectionName to sSection
79679>>>>>>>>>>>        // Sorting will make sure we have the active connection record as the first connection item in the ini-file.
79679>>>>>>>>>>>        Move (SortArray(SQLConnectionsArray, Self, (RefFunc(SortActiveFirst)))) to SQLConnectionsArray
79680>>>>>>>>>>>        Move (SizeOfArray(SQLConnectionsArray)) to iSize
79681>>>>>>>>>>>        Decrement iSize
79682>>>>>>>>>>>
79682>>>>>>>>>>>        For iCount from 0 to iSize
79688>>>>>>>>>>>>
79688>>>>>>>>>>>            // DF 19 compatible settings:
79688>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionIdKeyword   to SQLConnectionsArray[iCount].sConnectionID
79689>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDriverKeyword         to SQLConnectionsArray[iCount].sDriverID
79690>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDisabledKeyword       to (If(SQLConnectionsArray[iCount].bEnabled = 0, "Yes", "No"))
79691>>>>>>>>>>>            
79691>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniUIDKeyword            to SQLConnectionsArray[iCount].sUserID
79692>>>>>>>>>>>
79692>>>>>>>>>>>            Move SQLConnectionsArray[iCount].sPassword to sValue
79693>>>>>>>>>>>            If (pbDFConnId(Self) = False and sValue <> "") Begin
79695>>>>>>>>>>>                Get EncryptPassword sValue to sValue
79696>>>>>>>>>>>            End
79696>>>>>>>>>>>>
79696>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDFPWDKeyword          to sValue
79697>>>>>>>>>>>
79697>>>>>>>>>>>            If (SQLConnectionsArray[iCount].bTrusted = True) Begin
79699>>>>>>>>>>>                Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniTrustedKeyword    to CS_SQLIniConnectionYes
79700>>>>>>>>>>>            End
79700>>>>>>>>>>>>
79700>>>>>>>>>>>
79700>>>>>>>>>>>            Get ConstructShortConnectionString SQLConnectionsArray[iCount].sDriverID SQLConnectionsArray[iCount].sServer SQLConnectionsArray[iCount].sDatabase ;                                            to SQLConnectionsArray[iCount].sConnectionString
79701>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniConnectionKeyWord     to SQLConnectionsArray[iCount].sConnectionString
79702>>>>>>>>>>>
79702>>>>>>>>>>>            // The Database Update Framework extended settings:
79702>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniDbTypeKeyword          to SQLConnectionsArray[iCount].iDbType
79703>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSchemaKeyword          to SQLConnectionsArray[iCount].sSchema
79704>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniBaseTableSpaceKeyword  to SQLConnectionsArray[iCount].sBaseTableSpace
79705>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniLongTableSpaceKeyword  to SQLConnectionsArray[iCount].sLongTableSpace
79706>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniIndexTableSpaceKeyword to SQLConnectionsArray[iCount].sIndexTableSpace
79707>>>>>>>>>>>            Set IniFileValue (CS_SQLIniSectionName + String(iCount + 1)) CS_SQLIniSilentLoginKeyword     to (If(SQLConnectionsArray[iCount].bSilentLogin = 1, "Yes", "No"))
79708>>>>>>>>>>>        Loop
79709>>>>>>>>>>>>
79709>>>>>>>>>>>
79709>>>>>>>>>>>        Function_Return (bOK and Err = False)
79710>>>>>>>>>>>    End_Function
79711>>>>>>>>>>>
79711>>>>>>>>>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
79711>>>>>>>>>>>    //
79711>>>>>>>>>>>    // SQL utility function that returns a database type (string) constant
79711>>>>>>>>>>>    // corresponding to the passed iDbType.
79711>>>>>>>>>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
79713>>>>>>>>>>>        String sRetval
79713>>>>>>>>>>>        If (iDbType = EN_dbTypeMSSQL) Begin
79715>>>>>>>>>>>            Move CS_dbTypeMSSQL to sRetval
79716>>>>>>>>>>>        End
79716>>>>>>>>>>>>
79716>>>>>>>>>>>        If (iDbType = EN_dbTypeMySQL) Begin
79718>>>>>>>>>>>            Move CS_dbTypeMySQL to sRetval
79719>>>>>>>>>>>        End
79719>>>>>>>>>>>>
79719>>>>>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
79721>>>>>>>>>>>            Move CS_dbTypeOracle to sRetval
79722>>>>>>>>>>>        End
79722>>>>>>>>>>>>
79722>>>>>>>>>>>        If (iDbType = EN_dbTypeDB2) Begin
79724>>>>>>>>>>>            Move CS_dbTypeDB2 to sRetval
79725>>>>>>>>>>>        End
79725>>>>>>>>>>>>
79725>>>>>>>>>>>        If (iDbType = EN_dbTypePostgre) Begin
79727>>>>>>>>>>>            Move CS_dbTypePostgre to sRetval
79728>>>>>>>>>>>        End
79728>>>>>>>>>>>>
79728>>>>>>>>>>>        If (iDbType = EN_DbTypePervasive) Begin
79730>>>>>>>>>>>            Move CS_DbTypePervasive to sRetval
79731>>>>>>>>>>>        End
79731>>>>>>>>>>>>
79731>>>>>>>>>>>        Function_Return sRetval
79732>>>>>>>>>>>    End_Function
79733>>>>>>>>>>>
79733>>>>>>>>>>>    // SQL utility function that returns a database type constant (integer)
79733>>>>>>>>>>>    // corresponding to the passed sDbType string constant.
79733>>>>>>>>>>>    Function SqlUtilDbTypeToInteger String sDbType  Returns Integer
79735>>>>>>>>>>>        Integer iRetval
79735>>>>>>>>>>>        If (sDbType = CS_dbTypeMSSQL) Begin
79737>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
79738>>>>>>>>>>>        End
79738>>>>>>>>>>>>
79738>>>>>>>>>>>        If (sDbType = CS_dbTypeMySQL) Begin
79740>>>>>>>>>>>            Move EN_dbTypeMySQL to iRetval
79741>>>>>>>>>>>        End
79741>>>>>>>>>>>>
79741>>>>>>>>>>>        If (sDbType = CS_dbTypeOracle) Begin
79743>>>>>>>>>>>            Move EN_dbTypeOracle to iRetval
79744>>>>>>>>>>>        End
79744>>>>>>>>>>>>
79744>>>>>>>>>>>        If (sDbType = CS_dbTypeDB2) Begin
79746>>>>>>>>>>>            Move EN_dbTypeDB2 to iRetval
79747>>>>>>>>>>>        End
79747>>>>>>>>>>>>
79747>>>>>>>>>>>        If (sDbType = CS_dbTypePostgre) Begin
79749>>>>>>>>>>>            Move EN_dbTypePostgre to iRetval
79750>>>>>>>>>>>        End
79750>>>>>>>>>>>>
79750>>>>>>>>>>>        If (sDbType = CS_DbTypePervasive) Begin
79752>>>>>>>>>>>            Move EN_DbTypePervasive to iRetval
79753>>>>>>>>>>>        End
79753>>>>>>>>>>>>
79753>>>>>>>>>>>        Function_Return iRetval
79754>>>>>>>>>>>    End_Function
79755>>>>>>>>>>>
79755>>>>>>>>>>>    // Pass an integer DbType and function returns the database type integer as a string value.
79755>>>>>>>>>>>    // Used e.g. when reading a connection ini-file to display the database type in
79755>>>>>>>>>>>    // the SQL Connection program's grid.
79755>>>>>>>>>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
79757>>>>>>>>>>>        String sRetval
79757>>>>>>>>>>>        If (iDbType = EN_dbTypeMSSQL) Begin
79759>>>>>>>>>>>            Move "EN_dbTypeMSSQL" to sRetval
79760>>>>>>>>>>>        End
79760>>>>>>>>>>>>
79760>>>>>>>>>>>        If (iDbType = EN_dbTypeMySQL) Begin
79762>>>>>>>>>>>            Move "EN_dbTypeMySQL" to sRetval
79763>>>>>>>>>>>        End
79763>>>>>>>>>>>>
79763>>>>>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
79765>>>>>>>>>>>            Move "EN_dbTypeOracle" to sRetval
79766>>>>>>>>>>>        End
79766>>>>>>>>>>>>
79766>>>>>>>>>>>        If (iDbType = EN_dbTypeDB2) Begin
79768>>>>>>>>>>>            Move "EN_dbTypeDB2" to sRetval
79769>>>>>>>>>>>        End
79769>>>>>>>>>>>>
79769>>>>>>>>>>>        If (iDbType = EN_dbTypePostgre) Begin
79771>>>>>>>>>>>            Move "EN_dbTypePostgre" to sRetval
79772>>>>>>>>>>>        End
79772>>>>>>>>>>>>
79772>>>>>>>>>>>        If (iDbType = EN_DbTypePervasive) Begin
79774>>>>>>>>>>>            Move "EN_dbTypePervasive" to sRetval
79775>>>>>>>>>>>        End
79775>>>>>>>>>>>>
79775>>>>>>>>>>>        Function_Return sRetval
79776>>>>>>>>>>>    End_Function
79777>>>>>>>>>>>
79777>>>>>>>>>>>    // Pass a driver id and the function will return
79777>>>>>>>>>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
79777>>>>>>>>>>>    // quite work and always returns "MS SQL Server"
79777>>>>>>>>>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
79779>>>>>>>>>>>        Integer iRetval
79779>>>>>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
79781>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
79782>>>>>>>>>>>        End
79782>>>>>>>>>>>>
79782>>>>>>>>>>>        If (sDriverID = SQLFLEX) Begin
79784>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
79785>>>>>>>>>>>        End
79785>>>>>>>>>>>>
79785>>>>>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
79787>>>>>>>>>>>            Move EN_dbTypeMSSQL to iRetval
79788>>>>>>>>>>>        End
79788>>>>>>>>>>>>
79788>>>>>>>>>>>        If (sDriverID = MDSMySQL) Begin
79790>>>>>>>>>>>            Move EN_dbTypeMySQL to iRetval
79791>>>>>>>>>>>        End
79791>>>>>>>>>>>>
79791>>>>>>>>>>>        If (sDriverID = ORAFLEX) Begin
79793>>>>>>>>>>>            Move EN_dbTypeOracle to iRetval
79794>>>>>>>>>>>        End
79794>>>>>>>>>>>>
79794>>>>>>>>>>>        If (sDriverID = DB2_DRV_ID) Begin
79796>>>>>>>>>>>            Move EN_dbTypeDB2 to iRetval
79797>>>>>>>>>>>        End
79797>>>>>>>>>>>>
79797>>>>>>>>>>>        If (sDriverID = MDSPgSQL) Begin
79799>>>>>>>>>>>            Move EN_dbTypePostgre to iRetval
79800>>>>>>>>>>>        End
79800>>>>>>>>>>>>
79800>>>>>>>>>>>        If (sDriverID = DFBTRDRV_ID) Begin
79802>>>>>>>>>>>            Move EN_DbTypePervasive to iRetval
79803>>>>>>>>>>>        End
79803>>>>>>>>>>>>
79803>>>>>>>>>>>        Function_Return iRetval
79804>>>>>>>>>>>    End_Function
79805>>>>>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
79805>>>>>>>>>>>>
79805>>>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
79807>>>>>>>>>>>>    Integer iStart iEnd
79807>>>>>>>>>>>>    String sRetval
79807>>>>>>>>>>>>
79807>>>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
79808>>>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
79809>>>>>>>>>>>>    If (iStart = 0) Begin
79811>>>>>>>>>>>>        Function_Return ""
79812>>>>>>>>>>>>    End
79812>>>>>>>>>>>>>
79812>>>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
79813>>>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
79814>>>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
79816>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
79817>>>>>>>>>>>>    End
79817>>>>>>>>>>>>>
79817>>>>>>>>>>>>    Else Begin
79818>>>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
79819>>>>>>>>>>>>    End
79819>>>>>>>>>>>>>
79819>>>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
79821>>>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
79822>>>>>>>>>>>>        Decrement iEnd
79823>>>>>>>>>>>>    End
79823>>>>>>>>>>>>>
79823>>>>>>>>>>>>    If (iEnd <> 0) Begin
79825>>>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
79826>>>>>>>>>>>>    End
79826>>>>>>>>>>>>>
79826>>>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
79827>>>>>>>>>>>>
79827>>>>>>>>>>>>    Function_Return (Trim(sRetval))
79828>>>>>>>>>>>>End_Function
79829>>>>>>>>>>>>
79829>>>>>>>>>>>>
79829>>>>>>>>>>>
79829>>>>>>>>>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
79831>>>>>>>>>>>        String sConnect
79831>>>>>>>>>>>        Handle hoDriver
79831>>>>>>>>>>>
79831>>>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
79832>>>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
79833>>>>>>>>>>>        Get ConstructConnectionString of hoDriver sServer sDatabase bTrusted sUserID sPassword to sConnect
79834>>>>>>>>>>>        Send Destroy of hoDriver
79835>>>>>>>>>>>
79835>>>>>>>>>>>        Function_Return sConnect
79836>>>>>>>>>>>    End_Function
79837>>>>>>>>>>>
79837>>>>>>>>>>>    // Short connection string used when writing to ini-file. This is to be compatible with DF19 DFConnId.ini files that uses this short format.
79837>>>>>>>>>>>    Function ConstructShortConnectionString String sDriverID String sServer String sDatabase Returns String
79839>>>>>>>>>>>        String sConnect
79839>>>>>>>>>>>
79839>>>>>>>>>>>        Case Begin
79839>>>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID or sDriverID = SQLFLEX)
79841>>>>>>>>>>>                Move (sConnect * CS_SQLIniServerKeyword + "=" + sServer) to sConnect
79842>>>>>>>>>>>                If (sDatabase <> "") Begin
79844>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
79845>>>>>>>>>>>                End
79845>>>>>>>>>>>>
79845>>>>>>>>>>>                Case Break
79846>>>>>>>>>>>
79846>>>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
79849>>>>>>>>>>>                If (Uppercase(sServer) contains ".DSN") Begin
79851>>>>>>>>>>>                    Move (CS_SQLIniFileDSNKeyword + "=" + sServer) to sConnect
79852>>>>>>>>>>>                End
79852>>>>>>>>>>>>
79852>>>>>>>>>>>                Else If (not(Uppercase(sServer) contains "DSN")) Begin
79855>>>>>>>>>>>                    Move (CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
79856>>>>>>>>>>>                End
79856>>>>>>>>>>>>
79856>>>>>>>>>>>
79856>>>>>>>>>>>                If (sDatabase <> "") Begin
79858>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
79859>>>>>>>>>>>                End
79859>>>>>>>>>>>>
79859>>>>>>>>>>>                Case Break
79860>>>>>>>>>>>
79860>>>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
79863>>>>>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
79864>>>>>>>>>>>                If (sDatabase <> "") Begin
79866>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
79867>>>>>>>>>>>                End
79867>>>>>>>>>>>>
79867>>>>>>>>>>>                Case Break
79868>>>>>>>>>>>
79868>>>>>>>>>>>            Case (sDriverID = ORAFLEX)
79871>>>>>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
79872>>>>>>>>>>>                If (sDatabase <> "") Begin
79874>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
79875>>>>>>>>>>>                End
79875>>>>>>>>>>>>
79875>>>>>>>>>>>                Case Break
79876>>>>>>>>>>>
79876>>>>>>>>>>>            Case (sDriverID = MDSPgSQL)
79879>>>>>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
79880>>>>>>>>>>>                If (sDatabase <> "") Begin
79882>>>>>>>>>>>                    Move (sConnect * ";" + CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
79883>>>>>>>>>>>                End
79883>>>>>>>>>>>>
79883>>>>>>>>>>>                Case Break
79884>>>>>>>>>>>
79884>>>>>>>>>>>            Case (sDriverID = MDSMySQL)
79887>>>>>>>>>>>                Move (sConnect * CS_SQLIniDSNKeyword + "=" + sServer) to sConnect
79888>>>>>>>>>>>                If (sDatabase <> "") Begin
79890>>>>>>>>>>>                    Move (sConnect * ";" +CS_SQLIniDatabaseKeyword + "=" + sDatabase) to sConnect
79891>>>>>>>>>>>                End
79891>>>>>>>>>>>>
79891>>>>>>>>>>>                Case Break
79892>>>>>>>>>>>
79892>>>>>>>>>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
79895>>>>>>>>>>>                Break
79896>>>>>>>>>>>
79896>>>>>>>>>>>            Case Else
79896>>>>>>>>>>>                Move "" to sConnect
79897>>>>>>>>>>>        Case End
79897>>>>>>>>>>>
79897>>>>>>>>>>>        Function_Return sConnect
79898>>>>>>>>>>>    End_Function
79899>>>>>>>>>>>
79899>>>>>>>>>>>    // Use Base64
79899>>>>>>>>>>>    Function EncryptPassword String sPassword Returns String
79901>>>>>>>>>>>        String sRetval
79901>>>>>>>>>>>        Handle hoLoginEncryption
79901>>>>>>>>>>>
79901>>>>>>>>>>>        Get Create (RefClass(cLoginEncryption)) to hoLoginEncryption
79902>>>>>>>>>>>        Set psEncryptPassword of hoLoginEncryption to (psHashString(Self))
79903>>>>>>>>>>>        Get EncryptPassword of hoLoginEncryption sPassword to sRetval
79904>>>>>>>>>>>        Send Destroy of hoLoginEncryption
79905>>>>>>>>>>>          
79905>>>>>>>>>>>        Function_Return sRetval
79906>>>>>>>>>>>    End_Function
79907>>>>>>>>>>>
79907>>>>>>>>>>>    Function DecryptPassword String sPassword Returns String
79909>>>>>>>>>>>        String sRetval
79909>>>>>>>>>>>        Handle hoLoginEncryption
79909>>>>>>>>>>>
79909>>>>>>>>>>>        Get Create (RefClass(cLoginEncryption)) to hoLoginEncryption
79910>>>>>>>>>>>        Set psEncryptPassword of hoLoginEncryption to (psHashString(Self))
79911>>>>>>>>>>>        Get DecryptPassword of hoLoginEncryption sPassword to sRetval
79912>>>>>>>>>>>        Send Destroy of hoLoginEncryption
79913>>>>>>>>>>>
79913>>>>>>>>>>>        Function_Return sRetval
79914>>>>>>>>>>>    End_Function
79915>>>>>>>>>>>
79915>>>>>>>>>>>    // Returns the full path of the Application (no trailing "\")
79915>>>>>>>>>>>    Function ApplicationPath Returns String
79917>>>>>>>>>>>        String sApplicationFileName sPath
79917>>>>>>>>>>>        Integer iNumChars iRetval
79917>>>>>>>>>>>
79917>>>>>>>>>>>        Move (Repeat(Character(0), 1024))    to sApplicationFileName
79918>>>>>>>>>>>        Move (GetModuleFileName(0, AddressOf(sApplicationFileName), 1024)) to iNumChars
79919>>>>>>>>>>>        Move (CString(sApplicationFileName)) to sApplicationFileName
79920>>>>>>>>>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to iRetval
79921>>>>>>>>>>>        Move (CString(sApplicationFileName)) to sPath
79922>>>>>>>>>>>
79922>>>>>>>>>>>        Function_Return sPath
79923>>>>>>>>>>>    End_Function
79924>>>>>>>>>>>
79924>>>>>>>>>>>    // Pass a filename including the extension. The return value
79924>>>>>>>>>>>    // will be the path of of the first found "sSearchFileName in the workspace.
79924>>>>>>>>>>>    // If not found in the workspace it will be search "globally" by the Get_File_Path command.
79924>>>>>>>>>>>    Function SearchLocallyThenGloballyForFile String sSearchFileName Returns String
79926>>>>>>>>>>>        Boolean bExists
79926>>>>>>>>>>>        Handle hoPaths hoIniFile
79926>>>>>>>>>>>        String[] asWorkSpaceFiles
79927>>>>>>>>>>>        String sProgramsPath sSection sFileName sRelativePath sRelativePaths sPath sDirSep sProgramsDir
79927>>>>>>>>>>>        Integer iSize iCount iPath iNoOfPaths iCountPath
79927>>>>>>>>>>>        
79927>>>>>>>>>>>        Get psIniFilePath to sProgramsPath
79928>>>>>>>>>>>        Get vFolderFormat sProgramsPath to sProgramsPath 
79929>>>>>>>>>>>        Move (Lowercase(sSearchFileName)) to sSearchFileName
79930>>>>>>>>>>>        Get vFilePathExists (sProgramsPath + sSearchFileName) to bExists   
79931>>>>>>>>>>>        If (bExists = True) Begin
79933>>>>>>>>>>>            Function_Return sProgramsPath
79934>>>>>>>>>>>        End                      
79934>>>>>>>>>>>>
79934>>>>>>>>>>>    
79934>>>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
79935>>>>>>>>>>>        If (Right(sProgramsPath, 1) ="\") Begin
79937>>>>>>>>>>>            Move (Left(sProgramsPath, Length(sProgramsPath) -1)) to sProgramsPath        
79938>>>>>>>>>>>        End                                              
79938>>>>>>>>>>>>
79938>>>>>>>>>>>        Get StringFromRightOfChar sProgramsPath sDirSep to sProgramsDir
79939>>>>>>>>>>>        
79939>>>>>>>>>>>        Move False to bExists
79940>>>>>>>>>>>        Get Create (RefClass(Array)) to hoPaths
79941>>>>>>>>>>>        Get WorkspaceIniFiles sProgramsPath to asWorkspaceFiles
79942>>>>>>>>>>>        Move (SizeOfArray(asWorkspaceFiles)) to iSize
79943>>>>>>>>>>>        Decrement iSize       
79944>>>>>>>>>>>        
79944>>>>>>>>>>>        For iCount from 0 to iSize
79950>>>>>>>>>>>>
79950>>>>>>>>>>>            Move asWorkspaceFiles[iCount] to sFileName
79951>>>>>>>>>>>            Get Create (Refclass(cIniFile)) to hoIniFile
79952>>>>>>>>>>>            Set psFileName of hoIniFile to sFileName
79953>>>>>>>>>>>            Send ReadSection of hoIniFile "Workspace" hoPaths
79954>>>>>>>>>>>            For iPath from 0 to (Item_Count(hoPaths) -1)
79960>>>>>>>>>>>>
79960>>>>>>>>>>>                Get Value of hoPaths iPath to sSection    
79961>>>>>>>>>>>                Get ReadString of hoIniFile "Workspace" sSection "" to sRelativePath 
79962>>>>>>>>>>>                // Check if there are more than one path specified;
79962>>>>>>>>>>>                Get CountOfPaths of (phoWorkspace(ghoApplication)) sRelativePath to iNoOfPaths
79963>>>>>>>>>>>                If (iNoOfPaths > 1) Begin         
79965>>>>>>>>>>>                    Move sRelativePath to sRelativePaths
79966>>>>>>>>>>>                    For iCountPath from 1 to iNoOfPaths
79972>>>>>>>>>>>>
79972>>>>>>>>>>>                        Get PathAtIndex of (phoWorkspace(ghoApplication)) sRelativePaths iCountPath to sRelativePath
79973>>>>>>>>>>>                        Get FullPathNames of (phoWorkspace(ghoApplication)) sRelativePath to sPath   
79974>>>>>>>>>>>                        Move (Replace((sDirSep + sProgramsDir + sDirSep), sPath, sDirSep)) to sPath
79975>>>>>>>>>>>                        Get vFolderFormat sPath to sPath
79976>>>>>>>>>>>                        Get vFilePathExists (sPath + sSearchFileName) to bExists
79977>>>>>>>>>>>                        If (bExists = True) Begin
79979>>>>>>>>>>>                            Move iNoOfPaths to iCountPath
79980>>>>>>>>>>>                            Move (Item_Count(hoPaths)) to iPath // We're done.
79981>>>>>>>>>>>                            Move iSize to iCount
79982>>>>>>>>>>>                        End                                                    
79982>>>>>>>>>>>>
79982>>>>>>>>>>>                    Loop
79983>>>>>>>>>>>>
79983>>>>>>>>>>>                End
79983>>>>>>>>>>>>
79983>>>>>>>>>>>                Else Begin
79984>>>>>>>>>>>                    Get FullPathNames of (phoWorkspace(ghoApplication)) sRelativePath to sPath   
79985>>>>>>>>>>>                    Move (Replace((sDirSep + sProgramsDir + sDirSep), sPath, sDirSep)) to sPath
79986>>>>>>>>>>>                    Get vFolderFormat sPath to sPath
79987>>>>>>>>>>>                    Get vFilePathExists (sPath + sSearchFileName) to bExists
79988>>>>>>>>>>>                    If (bExists = True) Begin
79990>>>>>>>>>>>                        Move (Item_Count(hoPaths)) to iPath // We're done.
79991>>>>>>>>>>>                        Move iSize to iCount
79992>>>>>>>>>>>                    End                                                    
79992>>>>>>>>>>>>
79992>>>>>>>>>>>                End
79992>>>>>>>>>>>>
79992>>>>>>>>>>>            Loop
79993>>>>>>>>>>>>
79993>>>>>>>>>>>            If (bExists = False) Begin
79995>>>>>>>>>>>                Move "" to sPath    
79996>>>>>>>>>>>            End
79996>>>>>>>>>>>>
79996>>>>>>>>>>>            Send Destroy of hoIniFile          
79997>>>>>>>>>>>        Loop        
79998>>>>>>>>>>>>
79998>>>>>>>>>>>        Send Destroy of hoPaths
79999>>>>>>>>>>>        
79999>>>>>>>>>>>        // Then not found in workspace, look for the file in DFSysPath;
79999>>>>>>>>>>>        If (sPath = "") Begin
80001>>>>>>>>>>>            Get_File_Path sSearchFileName to sFileName   
80002>>>>>>>>>>>            Get ParseFolderName sFileName to sPath
80003>>>>>>>>>>>        End                  
80003>>>>>>>>>>>>
80003>>>>>>>>>>>        
80003>>>>>>>>>>>        Function_Return sPath    
80004>>>>>>>>>>>    End_Function
80005>>>>>>>>>>>    
80005>>>>>>>>>>>    // Pass the path to the workspace Programs folder - returns a string array
80005>>>>>>>>>>>    // with one or more .ws file names.
80005>>>>>>>>>>>    // First checks if there is a .sws file - and if so reads the name of the
80005>>>>>>>>>>>    // workspace file (.ws) and returns it as a string array.
80005>>>>>>>>>>>    // If _no_ .sws file is found, enumerates the passed sProgramsPath variable
80005>>>>>>>>>>>    Function WorkspaceIniFiles String sProgramsPath Returns String[]
80007>>>>>>>>>>>        String[] asSWSFiles asWorkspaceFiles   
80009>>>>>>>>>>>        String sFile sHomePath sDirSep
80009>>>>>>>>>>>        Integer iCh iSize
80009>>>>>>>>>>>        Boolean bExists      
80009>>>>>>>>>>>        Handle hoIniFile 
80009>>>>>>>>>>>        
80009>>>>>>>>>>>        Move (ResizeArray(asSWSFiles, 0)) to asSWSFiles
80010>>>>>>>>>>>        Move (ResizeArray(asWorkspaceFiles, 0)) to asWorkspaceFiles
80011>>>>>>>>>>>        If (Right(sProgramsPath, 1) ="\") Begin
80013>>>>>>>>>>>            Move (Left(sProgramsPath, Length(sProgramsPath) -1)) to sProgramsPath        
80014>>>>>>>>>>>        End                                              
80014>>>>>>>>>>>>
80014>>>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
80015>>>>>>>>>>>        Get StringFromRightOfChar sProgramsPath sDirSep to sHomePath
80016>>>>>>>>>>>        Move (Replace(sHomePath, sProgramsPath, "")) to sHomePath
80017>>>>>>>>>>>        Get vFolderFormat sHomePath to sHomePath 
80018>>>>>>>>>>>        
80018>>>>>>>>>>>        // First check if theres an .sws file. If there is we will open it and
80018>>>>>>>>>>>        // read the name of the .ws file name.
80018>>>>>>>>>>>        File_Exist (sHomePath + "*.sws") bExists
80019>>>>>>>>>>>        If (bExists = True) Begin
80021>>>>>>>>>>>            Get Seq_Open_input_Channel ("dir:" + sHomePath + "*.sws") to iCh
80022>>>>>>>>>>>            If (iCh < 0) Begin
80024>>>>>>>>>>>                Function_Return asSWSFiles
80025>>>>>>>>>>>            End                                 
80025>>>>>>>>>>>>
80025>>>>>>>>>>>            
80025>>>>>>>>>>>            Repeat
80025>>>>>>>>>>>>
80025>>>>>>>>>>>                Readln channel iCh sFile
80027>>>>>>>>>>>                If (Trim(sFile) <> "") Begin
80029>>>>>>>>>>>                    Move sFile to asSWSFiles[SizeOfArray(asSWSFiles)]
80030>>>>>>>>>>>                End
80030>>>>>>>>>>>>
80030>>>>>>>>>>>            Until (SeqEof = True)
80032>>>>>>>>>>>            Send Seq_Close_Channel iCh    
80033>>>>>>>>>>>            
80033>>>>>>>>>>>            Move (SizeOfArray(asSWSFiles)) to iSize
80034>>>>>>>>>>>            If (iSize <> 0) Begin
80036>>>>>>>>>>>                Get Create (RefClass(cIniFile)) to hoIniFile  
80037>>>>>>>>>>>                // Use the file with that is last as it might have the DataFlex version in it,
80037>>>>>>>>>>>                // and thus is the latest one and it is more likely it is accurate (?)...
80037>>>>>>>>>>>                Move asSWSFiles[SizeOfArray(asSWSFiles) -1] to sFile
80038>>>>>>>>>>>                Set psFileName of hoIniFile to (sHomePath + sFile)
80039>>>>>>>>>>>                Get ReadString of hoIniFile "WorkspacePaths" "ConfigFile" "" to sFile
80040>>>>>>>>>>>                If (sFile <> "") Begin
80042>>>>>>>>>>>                    Move (Replace(".", sFile, sHomePath)) to sFile
80043>>>>>>>>>>>                    Move (Replace((sDirSep + String(sDirSep)), sFile, sDirSep)) to sFile
80044>>>>>>>>>>>                    File_Exist sFile bExists
80045>>>>>>>>>>>                    If (bExists = True) Begin
80047>>>>>>>>>>>                        Move sFile to asWorkspaceFiles[0] 
80048>>>>>>>>>>>                    End
80048>>>>>>>>>>>>
80048>>>>>>>>>>>                End
80048>>>>>>>>>>>>
80048>>>>>>>>>>>                Send Destroy of hoIniFile
80049>>>>>>>>>>>            End
80049>>>>>>>>>>>>
80049>>>>>>>>>>>        End
80049>>>>>>>>>>>>
80049>>>>>>>>>>>        
80049>>>>>>>>>>>        // If no .sws file exists, enumerate the .ws files from the Programs folder:    
80049>>>>>>>>>>>        If (SizeOfArray(asWorkspaceFiles) = 0) Begin
80051>>>>>>>>>>>            Get vFolderFormat sProgramsPath to sProgramsPath 
80052>>>>>>>>>>>            File_Exist (sProgramsPath + "*.ws") bExists
80053>>>>>>>>>>>            If (bExists = False) Begin
80055>>>>>>>>>>>                Function_Return asWorkspaceFiles
80056>>>>>>>>>>>            End
80056>>>>>>>>>>>>
80056>>>>>>>>>>>        
80056>>>>>>>>>>>            Get Seq_Open_input_Channel ("dir:" + sProgramsPath + "*.ws") to iCh
80057>>>>>>>>>>>            If (iCh < 0) Begin
80059>>>>>>>>>>>                Function_Return asWorkspaceFiles
80060>>>>>>>>>>>            End                                 
80060>>>>>>>>>>>>
80060>>>>>>>>>>>            
80060>>>>>>>>>>>            Repeat
80060>>>>>>>>>>>>
80060>>>>>>>>>>>                Readln channel iCh sFile
80062>>>>>>>>>>>                If (Trim(sFile) <> "") Begin
80064>>>>>>>>>>>                    Move sFile to asWorkspaceFiles[SizeOfArray(asWorkspaceFiles)]
80065>>>>>>>>>>>                End
80065>>>>>>>>>>>>
80065>>>>>>>>>>>            Until (SeqEof = True)
80067>>>>>>>>>>>            Send Seq_Close_Channel iCh
80068>>>>>>>>>>>        End
80068>>>>>>>>>>>>
80068>>>>>>>>>>>        
80068>>>>>>>>>>>        Function_Return asWorkspaceFiles
80069>>>>>>>>>>>    End_Function
80070>>>>>>>>>>>
80070>>>>>>>>>>>End_Class
80071>>>>>>>>>Use cDbUpdateDatabaseDriver.pkg
80071>>>>>>>>>Use vWin32fh.pkg
80071>>>>>>>>>
80071>>>>>>>>>// The cConnection class is the new SQL connections class for DF 19.
80071>>>>>>>>>// If an object of the cConnection class hasn't been instantiated we use a "dummy" class in its place.
80071>>>>>>>>>
80071>>>>>>>>>// We're making references to this object handle so we need it defined
80071>>>>>>>>>// here as well as for the cDbUpdateHandler class
80071>>>>>>>>>
80071>>>>>>>>>    Global_Variable Handle ghoSQLConnectionHandler
80071>>>>>>>>>    Move 0 to ghoSQLConnectionHandler
80072>>>>>>>>>
80072>>>>>>>>>Class cSQLConnectionHandler is a cObject
80073>>>>>>>>>
80073>>>>>>>>>    Procedure Construct_Object
80075>>>>>>>>>        Forward Send Construct_Object
80077>>>>>>>>>        Move Self to ghoSQLConnectionHandler
80078>>>>>>>>>
80078>>>>>>>>>        Property Handle phoSQLConnectionIniFile (Create(Self,RefClass(cSQLConnectionIniFile)))
80079>>>>>>>>>
80079>>>>>>>>>        // These properties are used by the cDbUpdateVersion and cDbUpdateFunctionLibrary classes,
80079>>>>>>>>>        // but put here so they can be set/get in both class objects. Those classes has "relay"
80079>>>>>>>>>        // methods to this class.
80079>>>>>>>>>        Property Boolean pbUseConnectionID True
80080>>>>>>>>>        Property Boolean pbToANSI          True
80081>>>>>>>>>        Property Boolean pbRecnum          True
80082>>>>>>>>>        Property Boolean pbCopyData        True
80083>>>>>>>>>        Property Boolean pbApiTableUpdateAuto    False
80084>>>>>>>>>        Property Boolean pbCompareDate_DateTime  False
80085>>>>>>>>>        Property Boolean pbCompareIndexAscending False
80086>>>>>>>>>        Property Boolean pbCompareIndexUppercase False
80087>>>>>>>>>
80087>>>>>>>>>        // Driver default value settings:
80087>>>>>>>>>        // Note: When the object is created the corresponding values
80087>>>>>>>>>        // from the driver .int files are read.
80087>>>>>>>>>        // Sample: Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of {driverNumber} to {StringVariable}
80087>>>>>>>>>        Property String psDriverDefaultValueASCII    ""
80088>>>>>>>>>        Property String psDriverDefaultValueBinary   ""
80089>>>>>>>>>        Property String psDriverDefaultValueDate     ""
80090>>>>>>>>>        Property String psDriverDefaultValueDateTime ""
80091>>>>>>>>>        Property String psDriverDefaultValueNumeric  ""
80092>>>>>>>>>        Property String psDriverDefaultValueText     ""
80093>>>>>>>>>
80093>>>>>>>>>        // Driver "nullability" settings:
80093>>>>>>>>>        // Note: When the object is created the corresponding values
80093>>>>>>>>>        // from the driver .int files are read.
80093>>>>>>>>>        // Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII of {driverNumber} to {BooleanVariable}
80093>>>>>>>>>        Property Boolean pbDriverDefaultNullableASCII    False
80094>>>>>>>>>        Property Boolean pbDriverDefaultNullableBinary   False
80095>>>>>>>>>        Property Boolean pbDriverDefaultNullableDate     False
80096>>>>>>>>>        Property Boolean pbDriverDefaultNullableDateTime False
80097>>>>>>>>>        Property Boolean pbDriverDefaultNullableNumeric  False
80098>>>>>>>>>        Property Boolean pbDriverDefaultNullableText     False
80099>>>>>>>>>
80099>>>>>>>>>        // *** This is the central point of connection data for the Database Update Framework ***
80099>>>>>>>>>        //     It is private because the get/set version also updates the DAW/Mertech
80099>>>>>>>>>        //     driver interfaces.
80099>>>>>>>>>        //     There are also procedure/function pairs to set/get individual data members
80099>>>>>>>>>        //     of the struct they are all routed throu this struct property.
80099>>>>>>>>>        Property tSQLConnection Private.pSQLConnection
80100>>>>>>>>>
80100>>>>>>>>>    End_Procedure
80101>>>>>>>>>
80101>>>>>>>>>    Procedure End_Construct_Object
80103>>>>>>>>>        tSQLConnection SQLConnection
80103>>>>>>>>>        tSQLConnection SQLConnection
80103>>>>>>>>>
80103>>>>>>>>>        Forward Send End_Construct_Object
80105>>>>>>>>>
80105>>>>>>>>>        // Now is the time to read and apply SQL connection settings.
80105>>>>>>>>>        Get SetupSQLConnection True True to SQLConnection
80106>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
80107>>>>>>>>>    End_Procedure
80108>>>>>>>>>
80108>>>>>>>>>    // *** Properties ***
80108>>>>>>>>>    // All connection related "properties" (get/set pairs) are really done by changing the
80108>>>>>>>>>    // private.pSQLConnection struct connection property. These "properties" are
80108>>>>>>>>>    // merely here for conveniance.
80108>>>>>>>>>    //
80108>>>>>>>>>    // The pSQLConnection get/set are here so we have a "central hub"
80108>>>>>>>>>    // where we update data to/from the DAW & Mertech driver interfaces and this framework.
80108>>>>>>>>>    // This struct property contains all the connection data.
80108>>>>>>>>>    //
80108>>>>>>>>>    Procedure Set pSQLConnection tSQLConnection SQLConnection
80110>>>>>>>>>        Boolean bOK
80110>>>>>>>>>
80110>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
80111>>>>>>>>>
80111>>>>>>>>>        // When starting a program we might not have a connection id yet:
80111>>>>>>>>>        If (SQLConnection.sDriverID = DATAFLEX_ID) Begin
80113>>>>>>>>>//        If (SQLConnection.sConnectionID = "" or SQLConnection.sDriverID = DATAFLEX_ID) Begin
80113>>>>>>>>>            Procedure_Return
80114>>>>>>>>>        End
80114>>>>>>>>>>
80114>>>>>>>>>
80114>>>>>>>>>        // If a DAW DFConnId.ini file was read instead of the DUF SQLConnections.ini file we should by now
80114>>>>>>>>>        // be logged in already and don't want to do it again.
80114>>>>>>>>>        If (SQLConnection.bDAWConnection = False) Begin
80116>>>>>>>>>            // After we have set the class property we need to tell the DAW/Mertech
80116>>>>>>>>>            // driver interfaces about the change & make a new login.
80116>>>>>>>>>            Get SQLLogin SQLConnection to bOK
80117>>>>>>>>>            If (bOK = False) Begin
80119>>>>>>>>>                Error DFERR_PROGRAM "Login error."
80120>>>>>>>>>>
80120>>>>>>>>>            End
80120>>>>>>>>>>
80120>>>>>>>>>        End
80120>>>>>>>>>>
80120>>>>>>>>>
80120>>>>>>>>>        // Now is the time to setup our driver default values by reading the driver .int file:
80120>>>>>>>>>        Send SetupDriverDefaults SQLConnection.sDriverID
80121>>>>>>>>>
80121>>>>>>>>>    End_Procedure
80122>>>>>>>>>
80122>>>>>>>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
80122>>>>>>>>>    // attempt to load the driver.
80122>>>>>>>>>    // Returns true if the passed driver is SQL based.
80122>>>>>>>>>    Function IsSQLDriver String sDriverID Returns Boolean
80124>>>>>>>>>        Boolean bOK
80124>>>>>>>>>
80124>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
80125>>>>>>>>>        If (bOK = False) Begin
80127>>>>>>>>>            Get IsMertechDriver sDriverID to bOK
80128>>>>>>>>>        End
80128>>>>>>>>>>
80128>>>>>>>>>
80128>>>>>>>>>        Function_Return bOK
80129>>>>>>>>>    End_Function
80130>>>>>>>>>
80130>>>>>>>>>    // Reads the driver .int file and sets class properties of the cDbUpdateFunctionLibrary accordingly.
80130>>>>>>>>>    Procedure SetupDriverDefaults String sDriverID
80132>>>>>>>>>        String sAttributeValue
80132>>>>>>>>>        Integer iDriverID
80132>>>>>>>>>        Boolean bNULL bSQLDriver bIsMertechDriver
80132>>>>>>>>>
80132>>>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
80133>>>>>>>>>        If (bSQLDriver = False) Begin
80135>>>>>>>>>            Procedure_Return
80136>>>>>>>>>        End                                      
80136>>>>>>>>>>
80136>>>>>>>>>        Get IsMertechDriver sDriverID to bIsMertechDriver
80137>>>>>>>>>        If (bIsMertechDriver = True) Begin
80139>>>>>>>>>            Procedure_Return
80140>>>>>>>>>        End
80140>>>>>>>>>>
80140>>>>>>>>>        
80140>>>>>>>>>        Get DriverIndex sDriverID to iDriverID
80141>>>>>>>>>
80141>>>>>>>>>        // Driver default values for various data types:
80141>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_ASCII of iDriverID      to sAttributeValue
80144>>>>>>>>>        Set psDriverDefaultValueASCII                                   to sAttributeValue
80145>>>>>>>>>
80145>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_BINARY of iDriverID     to sAttributeValue
80148>>>>>>>>>        Set psDriverDefaultValueBinary                                  to sAttributeValue
80149>>>>>>>>>
80149>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATE of iDriverID       to sAttributeValue
80152>>>>>>>>>        Set psDriverDefaultValueDate                                    to sAttributeValue
80153>>>>>>>>>
80153>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_DATETIME of iDriverID   to sAttributeValue
80156>>>>>>>>>        Set psDriverDefaultValueDateTime                                to sAttributeValue
80157>>>>>>>>>
80157>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_NUMERIC of iDriverID    to sAttributeValue
80160>>>>>>>>>        Set psDriverDefaultValueNumeric                                 to sAttributeValue
80161>>>>>>>>>
80161>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_DEFAULT_TEXT of iDriverID       to sAttributeValue
80164>>>>>>>>>        Set psDriverDefaultValueText                                    to sAttributeValue
80165>>>>>>>>>
80165>>>>>>>>>        // The default setting for the "nullability" of newly created ASCII columns.
80165>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_ASCII      of iDriverID to bNULL
80168>>>>>>>>>        Set pbDriverDefaultNullableASCII to bNULL
80169>>>>>>>>>
80169>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_BINARY     of iDriverID to bNULL
80172>>>>>>>>>        Set pbDriverDefaultNullableBinary to bNULL
80173>>>>>>>>>
80173>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATE       of iDriverID to bNULL
80176>>>>>>>>>        Set pbDriverDefaultNullableDate to bNULL
80177>>>>>>>>>
80177>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_DATETIME   of iDriverID to bNULL
80180>>>>>>>>>        Set pbDriverDefaultNullableDateTime to bNULL
80181>>>>>>>>>
80181>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_NUMERIC    of iDriverID to bNULL
80184>>>>>>>>>        Set pbDriverDefaultNullableNumeric to bNULL
80185>>>>>>>>>
80185>>>>>>>>>        Get_Attribute DF_DRIVER_DEFAULT_NULLABLE_TEXT       of iDriverID to bNULL
80188>>>>>>>>>        Set pbDriverDefaultNullableText to bNULL
80189>>>>>>>>>
80189>>>>>>>>>    End_Procedure
80190>>>>>>>>>
80190>>>>>>>>>    Function SQLLogin tSQLConnection SQLConnection Returns Boolean
80192>>>>>>>>>        Boolean bOK bIsDaw bIsMertech
80192>>>>>>>>>        String sConnectionString
80192>>>>>>>>>        Handle hoErrorObj hoDriver hoIniFile
80192>>>>>>>>>        Integer iDriverID
80192>>>>>>>>>
80192>>>>>>>>>        Move False to bOK
80193>>>>>>>>>        Get IsDAWSQLDriver SQLConnection.sDriverID to bIsDaw
80194>>>>>>>>>        If (bIsDaw = False) Begin
80196>>>>>>>>>            Get IsMertechDriver SQLConnection.sDriverID to bIsMertech
80197>>>>>>>>>            If (bIsMertech = False) Begin
80199>>>>>>>>>                Function_Return False
80200>>>>>>>>>            End
80200>>>>>>>>>>
80200>>>>>>>>>        End
80200>>>>>>>>>>
80200>>>>>>>>>
80200>>>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
80201>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to sConnectionString
80202>>>>>>>>>        Get DriverIndex SQLConnection.sDriverID to iDriverID
80203>>>>>>>>>        If (iDriverID = 0) Begin
80205>>>>>>>>>            Move hoErrorObj to Error_Object_Id
80206>>>>>>>>>            Function_Return False
80207>>>>>>>>>        End
80207>>>>>>>>>>
80207>>>>>>>>>
80207>>>>>>>>>        // There's a bug in Mertech drivers creating "an Exception error" in the debugger (probably will crash an application too.)
80207>>>>>>>>>        If (bIsMertech = False) Begin
80209>>>>>>>>>            Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriverID to SQLConnection.bSilentLogin
80212>>>>>>>>>        End
80212>>>>>>>>>>
80212>>>>>>>>>
80212>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
80213>>>>>>>>>        Set psDriverID of hoDriver to SQLConnection.sDriverID
80214>>>>>>>>>        Get DbLogin    of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
80215>>>>>>>>>        Send Destroy   of hoDriver
80216>>>>>>>>>
80216>>>>>>>>>        Function_Return bOK
80217>>>>>>>>>    End_Function
80218>>>>>>>>>
80218>>>>>>>>>    Function pSQLConnection Returns tSQLConnection
80220>>>>>>>>>        tSQLConnection SQLConnection
80220>>>>>>>>>        tSQLConnection SQLConnection
80220>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
80221>>>>>>>>>        Function_Return SQLConnection
80222>>>>>>>>>    End_Function
80223>>>>>>>>>
80223>>>>>>>>>    Procedure Set psConnectionID String sValue
80225>>>>>>>>>        tSQLConnection SQLConnection
80225>>>>>>>>>        tSQLConnection SQLConnection
80225>>>>>>>>>
80225>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
80226>>>>>>>>>        If (SQLConnection.sConnectionID = "") Begin
80228>>>>>>>>>            Move sValue to SQLConnection.sConnectionID
80229>>>>>>>>>        End
80229>>>>>>>>>>
80229>>>>>>>>>
80229>>>>>>>>>        // Else we might want to change the current connection ID
80229>>>>>>>>>        Else If (SQLConnection.sConnectionID <> "" and SQLConnection.sConnectionID <> sValue) Begin
80232>>>>>>>>>            Move False to Err
80233>>>>>>>>>            Logout SQLConnection.sDriverID
80234>>>>>>>>>            // This will also make a login to the new server.
80234>>>>>>>>>            Get SQLIniFileConnectionID of (phoSQLConnectionIniFile(Self)) sValue to SQLConnection
80235>>>>>>>>>        End
80235>>>>>>>>>>
80235>>>>>>>>>        Set pSQLConnection to SQLConnection
80236>>>>>>>>>    End_Procedure
80237>>>>>>>>>
80237>>>>>>>>>    Function psConnectionID Returns String
80239>>>>>>>>>        tSQLConnection SQLConnection
80239>>>>>>>>>        tSQLConnection SQLConnection
80239>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
80240>>>>>>>>>        Function_Return SQLConnection.sConnectionID
80241>>>>>>>>>    End_Function
80242>>>>>>>>>
80242>>>>>>>>>    // Note: If the psDriverID + other connection properties are to be changed,
80242>>>>>>>>>    //       the psDriverID *must* be the first property that is changed!
80242>>>>>>>>>    //       Otherwise errors might be raised by the driver when e.g. the format
80242>>>>>>>>>    //       for a connection string has the wrong format for that driver.
80242>>>>>>>>>    Procedure Set psDriverID String sValue
80244>>>>>>>>>        tSQLConnection SQLConnection
80244>>>>>>>>>        tSQLConnection SQLConnection
80244>>>>>>>>>        Get pSQLConnection to SQLConnection
80245>>>>>>>>>        Move sValue        to SQLConnection.sDriverID
80246>>>>>>>>>        Set pSQLConnection to SQLConnection
80247>>>>>>>>>        If (sValue <> DATAFLEX_ID) Begin
80249>>>>>>>>>            Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
80250>>>>>>>>>        End
80250>>>>>>>>>>
80250>>>>>>>>>    End_Procedure
80251>>>>>>>>>
80251>>>>>>>>>    Function psDriverID Returns String
80253>>>>>>>>>        tSQLConnection SQLConnection
80253>>>>>>>>>        tSQLConnection SQLConnection
80253>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
80254>>>>>>>>>        If (SQLConnection.sDriverID = "") Begin
80256>>>>>>>>>            Move DATAFLEX_ID to SQLConnection.sDriverID // Default is the DataFlex driver.
80257>>>>>>>>>        End
80257>>>>>>>>>>
80257>>>>>>>>>        Function_Return SQLConnection.sDriverID
80258>>>>>>>>>    End_Function
80259>>>>>>>>>
80259>>>>>>>>>    Procedure Set psConnectionString String sValue
80261>>>>>>>>>        tSQLConnection SQLConnection
80261>>>>>>>>>        tSQLConnection SQLConnection
80261>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
80262>>>>>>>>>        Move sValue        to SQLConnection.sConnectionString
80263>>>>>>>>>        Set pSQLConnection to SQLConnection
80264>>>>>>>>>    End_Procedure
80265>>>>>>>>>
80265>>>>>>>>>    Function psConnectionString Returns String
80267>>>>>>>>>        tSQLConnection SQLConnection
80267>>>>>>>>>        tSQLConnection SQLConnection
80267>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
80268>>>>>>>>>        Function_Return SQLConnection.sConnectionString
80269>>>>>>>>>    End_Function
80270>>>>>>>>>
80270>>>>>>>>>    Procedure Set psServer String sValue
80272>>>>>>>>>        tSQLConnection SQLConnection
80272>>>>>>>>>        tSQLConnection SQLConnection
80272>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
80273>>>>>>>>>        Move sValue        to SQLConnection.sServer
80274>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
80275>>>>>>>>>        Set pSQLConnection to SQLConnection
80276>>>>>>>>>    End_Procedure
80277>>>>>>>>>
80277>>>>>>>>>    Function psServer Returns String
80279>>>>>>>>>        tSQLConnection SQLConnection
80279>>>>>>>>>        tSQLConnection SQLConnection
80279>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
80280>>>>>>>>>        Function_Return SQLConnection.sServer
80281>>>>>>>>>    End_Function
80282>>>>>>>>>
80282>>>>>>>>>    Procedure Set psDatabase String sValue
80284>>>>>>>>>        tSQLConnection SQLConnection
80284>>>>>>>>>        tSQLConnection SQLConnection
80284>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
80285>>>>>>>>>        Move sValue        to SQLConnection.sDatabase
80286>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
80287>>>>>>>>>        Set pSQLConnection to SQLConnection
80288>>>>>>>>>    End_Procedure
80289>>>>>>>>>
80289>>>>>>>>>    Function psDatabase Returns String
80291>>>>>>>>>        tSQLConnection SQLConnection
80291>>>>>>>>>        tSQLConnection SQLConnection
80291>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
80292>>>>>>>>>        Function_Return SQLConnection.sDatabase
80293>>>>>>>>>    End_Function
80294>>>>>>>>>
80294>>>>>>>>>    Procedure Set psUserID String sValue
80296>>>>>>>>>        tSQLConnection SQLConnection
80296>>>>>>>>>        tSQLConnection SQLConnection
80296>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
80297>>>>>>>>>        Move sValue        to SQLConnection.sUserID
80298>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
80299>>>>>>>>>        Set pSQLConnection to SQLConnection
80300>>>>>>>>>    End_Procedure
80301>>>>>>>>>
80301>>>>>>>>>    Function psUserID Returns String
80303>>>>>>>>>        tSQLConnection SQLConnection
80303>>>>>>>>>        tSQLConnection SQLConnection
80303>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
80304>>>>>>>>>        Function_Return SQLConnection.sUserID
80305>>>>>>>>>    End_Function
80306>>>>>>>>>
80306>>>>>>>>>    // This is the uncrypted password
80306>>>>>>>>>    Procedure Set psPassword String sValue
80308>>>>>>>>>        tSQLConnection SQLConnection
80308>>>>>>>>>        tSQLConnection SQLConnection
80308>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
80309>>>>>>>>>        Move sValue        to SQLConnection.sPassword
80310>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
80311>>>>>>>>>        Set pSQLConnection to SQLConnection
80312>>>>>>>>>    End_Procedure
80313>>>>>>>>>
80313>>>>>>>>>    Function psPassword Returns String
80315>>>>>>>>>        tSQLConnection SQLConnection
80315>>>>>>>>>        tSQLConnection SQLConnection
80315>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
80316>>>>>>>>>        Function_Return SQLConnection.sPassword
80317>>>>>>>>>    End_Function
80318>>>>>>>>>
80318>>>>>>>>>    Procedure Set pbTrusted Boolean bValue
80320>>>>>>>>>        tSQLConnection SQLConnection
80320>>>>>>>>>        tSQLConnection SQLConnection
80320>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
80321>>>>>>>>>        Move bValue        to SQLConnection.bTrusted
80322>>>>>>>>>        Get ConstructConnectionString SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
80323>>>>>>>>>        Set pSQLConnection to SQLConnection
80324>>>>>>>>>    End_Procedure
80325>>>>>>>>>
80325>>>>>>>>>    Function pbTrusted Returns Boolean
80327>>>>>>>>>        tSQLConnection SQLConnection
80327>>>>>>>>>        tSQLConnection SQLConnection
80327>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
80328>>>>>>>>>        Function_Return SQLConnection.bTrusted
80329>>>>>>>>>    End_Function
80330>>>>>>>>>
80330>>>>>>>>>    // *** All of these properties are special to the Database Update Framework ***
80330>>>>>>>>>    //     Thus they are not propagated to the DAW/Mertech classes and that is why
80330>>>>>>>>>    //     the Private.pSQLConnection property is set instead of the going throu
80330>>>>>>>>>    //     the central pSQLConnection "hub".
80330>>>>>>>>>    Procedure Set pbSilentLogin Boolean bValue
80332>>>>>>>>>        tSQLConnection SQLConnection
80332>>>>>>>>>        tSQLConnection SQLConnection
80332>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
80333>>>>>>>>>        Move bValue to SQLConnection.bTrusted
80334>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
80335>>>>>>>>>    End_Procedure
80336>>>>>>>>>
80336>>>>>>>>>    Function pbSilentLogin Returns Boolean
80338>>>>>>>>>        tSQLConnection SQLConnection
80338>>>>>>>>>        tSQLConnection SQLConnection
80338>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
80339>>>>>>>>>        Function_Return SQLConnection.bSilentLogin
80340>>>>>>>>>    End_Function
80341>>>>>>>>>
80341>>>>>>>>>    Procedure Set piDbType Integer iValue
80343>>>>>>>>>        tSQLConnection SQLConnection
80343>>>>>>>>>        tSQLConnection SQLConnection
80343>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
80344>>>>>>>>>        Move iValue to SQLConnection.iDbType
80345>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
80346>>>>>>>>>    End_Procedure
80347>>>>>>>>>
80347>>>>>>>>>    Function piDbType Returns Integer
80349>>>>>>>>>        tSQLConnection SQLConnection
80349>>>>>>>>>        tSQLConnection SQLConnection
80349>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
80350>>>>>>>>>        Function_Return SQLConnection.iDbType
80351>>>>>>>>>    End_Function
80352>>>>>>>>>
80352>>>>>>>>>    Procedure Set psBaseTableSpace String sValue
80354>>>>>>>>>        tSQLConnection SQLConnection
80354>>>>>>>>>        tSQLConnection SQLConnection
80354>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
80355>>>>>>>>>        Move sValue to SQLConnection.sBaseTableSpace
80356>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
80357>>>>>>>>>    End_Procedure
80358>>>>>>>>>
80358>>>>>>>>>    Function psBaseTableSpace Returns String
80360>>>>>>>>>        tSQLConnection SQLConnection
80360>>>>>>>>>        tSQLConnection SQLConnection
80360>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
80361>>>>>>>>>        Function_Return SQLConnection.sBaseTableSpace
80362>>>>>>>>>    End_Function
80363>>>>>>>>>
80363>>>>>>>>>    Procedure Set psIndexTableSpace String sValue
80365>>>>>>>>>        tSQLConnection SQLConnection
80365>>>>>>>>>        tSQLConnection SQLConnection
80365>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
80366>>>>>>>>>        Move sValue to SQLConnection.sIndexTableSpace
80367>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
80368>>>>>>>>>    End_Procedure
80369>>>>>>>>>
80369>>>>>>>>>    Function psIndexTableSpace Returns String
80371>>>>>>>>>        tSQLConnection SQLConnection
80371>>>>>>>>>        tSQLConnection SQLConnection
80371>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
80372>>>>>>>>>        Function_Return SQLConnection.sIndexTableSpace
80373>>>>>>>>>    End_Function
80374>>>>>>>>>
80374>>>>>>>>>    Procedure Set psLongTableSpace String sValue
80376>>>>>>>>>        tSQLConnection SQLConnection
80376>>>>>>>>>        tSQLConnection SQLConnection
80376>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
80377>>>>>>>>>        Move sValue to SQLConnection.sLongTableSpace
80378>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
80379>>>>>>>>>    End_Procedure
80380>>>>>>>>>
80380>>>>>>>>>    Function psLongTableSpace Returns String
80382>>>>>>>>>        tSQLConnection SQLConnection
80382>>>>>>>>>        tSQLConnection SQLConnection
80382>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
80383>>>>>>>>>        Function_Return SQLConnection.sLongTableSpace
80384>>>>>>>>>    End_Function
80385>>>>>>>>>
80385>>>>>>>>>    Procedure Set psSchema String sValue
80387>>>>>>>>>        tSQLConnection SQLConnection
80387>>>>>>>>>        tSQLConnection SQLConnection
80387>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
80388>>>>>>>>>        Move sValue to SQLConnection.sSchema
80389>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
80390>>>>>>>>>    End_Procedure
80391>>>>>>>>>
80391>>>>>>>>>    Function psSchema Returns String
80393>>>>>>>>>        tSQLConnection SQLConnection
80393>>>>>>>>>        tSQLConnection SQLConnection
80393>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
80394>>>>>>>>>        Function_Return SQLConnection.sSchema
80395>>>>>>>>>    End_Function
80396>>>>>>>>>
80396>>>>>>>>>    Procedure Set pbEnabled Boolean bValue
80398>>>>>>>>>        tSQLConnection SQLConnection
80398>>>>>>>>>        tSQLConnection SQLConnection
80398>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
80399>>>>>>>>>        Move bValue to SQLConnection.bEnabled
80400>>>>>>>>>        Set Private.pSQLConnection to SQLConnection
80401>>>>>>>>>    End_Procedure
80402>>>>>>>>>
80402>>>>>>>>>    Function pbEnabled Returns Boolean
80404>>>>>>>>>        tSQLConnection SQLConnection
80404>>>>>>>>>        tSQLConnection SQLConnection
80404>>>>>>>>>        Get Private.pSQLConnection to SQLConnection
80405>>>>>>>>>        Function_Return SQLConnection.bEnabled
80406>>>>>>>>>    End_Function
80407>>>>>>>>>
80407>>>>>>>>>
80407>>>>>>>>>    // ************************************
80407>>>>>>>>>    Function SetupSQLConnection Boolean bReadDFConnSettings Boolean bReadSQLConnections Returns tSQLConnection
80409>>>>>>>>>        tSQLConnection SQLConnection
80409>>>>>>>>>        tSQLConnection SQLConnection
80409>>>>>>>>>
80409>>>>>>>>>        // If this object was created by the cDbUpdateHandler class we will
80409>>>>>>>>>        // deferr reading SQL connection values until later.
80409>>>>>>>>>        If (bReadDFConnSettings = True) Begin
80411>>>>>>>>>            // This is the new SQL login logic for DF 19 and up; "Managed Connections"
80411>>>>>>>>>            If (ghoConnection > 0) Begin
80413>>>>>>>>>                Get ReadcConnections to SQLConnection
80414>>>>>>>>>            End
80414>>>>>>>>>>
80414>>>>>>>>>
80414>>>>>>>>>            // In addition to the above; there might be other values set even if a cConnection
80414>>>>>>>>>            // object is used.
80414>>>>>>>>>            If (bReadSQLConnections = True) Begin
80416>>>>>>>>>                Get ReadSQLConnectionsIniSettings to SQLConnection
80417>>>>>>>>>            End
80417>>>>>>>>>>
80417>>>>>>>>>        End
80417>>>>>>>>>>
80417>>>>>>>>>
80417>>>>>>>>>        Function_Return SQLConnection
80418>>>>>>>>>    End_Function
80419>>>>>>>>>
80419>>>>>>>>>    // This is for the new cConnection class used by DF 19 and up (only).
80419>>>>>>>>>    Function ReadcConnections Returns tSQLConnection
80421>>>>>>>>>        tConnection Connection
80421>>>>>>>>>        tConnection Connection
80421>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
80421>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
80421>>>>>>>>>        Integer iRetval iDbType
80421>>>>>>>>>        Boolean bOK bConnected
80421>>>>>>>>>        String sConnectionID
80421>>>>>>>>>
80421>>>>>>>>>            tConnection[] Connections
80421>>>>>>>>>            tConnection[] Connections
80422>>>>>>>>>            // - If the DF 19 cConnection class has been used in the cApplication object
80422>>>>>>>>>            // - and there are multiple connection id's defined for the same driver. This is
80422>>>>>>>>>            //   because otherwise we can't possibly know which connection id to use... So
80422>>>>>>>>>            //   we then generate an error and abort the program...
80422>>>>>>>>>            Get IsSinglecConnection (&sConnectionID) to bOK
80423>>>>>>>>>            If (bOK = False) Begin
80425>>>>>>>>>                Error DFERR_PROGRAM ("Programming error. The psConnectionID must be set in the cDbUpdateVersion object when a cConnect object is used in the cApplication object, and there are multiple connections defined. Program will now exit!")
80426>>>>>>>>>>
80426>>>>>>>>>                Abort
80427>>>>>>>>>>
80427>>>>>>>>>            End
80427>>>>>>>>>>
80427>>>>>>>>>            If (sConnectionID = "") Begin
80429>>>>>>>>>                Get ConnectionIDs of ghoConnection to Connections
80430>>>>>>>>>                If (SizeOfArray(Connections) > 0) Begin
80432>>>>>>>>>                    Move Connections[0].sId to sConnectionID
80433>>>>>>>>>                End
80433>>>>>>>>>>
80433>>>>>>>>>            End
80433>>>>>>>>>>
80433>>>>>>>>>
80433>>>>>>>>>            Move 0 to iRetval
80434>>>>>>>>>            // DAW DF19 connection info:
80434>>>>>>>>>            // We first check that the connection is OK:
80434>>>>>>>>>            Get ConnectionIdIndex of ghoConnection sConnectionID to iRetval
80435>>>>>>>>>            // It might happen that no connection has been setup although the object exists, in case we do nothing.
80435>>>>>>>>>            If (iRetval = -1) Begin
80437>>>>>>>>>                Function_Return SQLConnectionEmpty
80438>>>>>>>>>            End
80438>>>>>>>>>>
80438>>>>>>>>>
80438>>>>>>>>>            If (sConnectionID <> "") Begin
80440>>>>>>>>>                Get ConnectionIdInfo of ghoConnection sConnectionID to Connection
80441>>>>>>>>>            End
80441>>>>>>>>>>
80441>>>>>>>>>            If (Connection.sId = "") Begin
80443>>>>>>>>>                Move True to SQLConnectionEmpty.bError
80444>>>>>>>>>                Function_Return SQLConnectionEmpty
80445>>>>>>>>>            End
80445>>>>>>>>>>
80445>>>>>>>>>
80445>>>>>>>>>            // DUF connection info struct property:
80445>>>>>>>>>            Get Private.pSQLConnection                       to SQLConnection
80446>>>>>>>>>
80446>>>>>>>>>            Move Connection.sId to sConnectionID
80447>>>>>>>>>            Get IsConnectionIdLoggedIn of ghoConnection sConnectionID to bConnected
80448>>>>>>>>>
80448>>>>>>>>>            If (bConnected = False) Begin
80450>>>>>>>>>                Get LoginConnectionId of ghoConnection sConnectionID to iRetval
80451>>>>>>>>>                If (iRetval <> 0) Begin
80453>>>>>>>>>                    Send UserError CS_DUF_CannotLoginToServer
80454>>>>>>>>>                    Send Exit_Application
80455>>>>>>>>>                End
80455>>>>>>>>>>
80455>>>>>>>>>                Move True                                   to SQLConnection.bDAWConnection
80456>>>>>>>>>                // We need to get the DAW connection info again as it might have
80456>>>>>>>>>                // been changed in the DAW db login dialog.
80456>>>>>>>>>                Get ConnectionIdInfo of ghoConnection sConnectionID to Connection
80457>>>>>>>>>            End
80457>>>>>>>>>>
80457>>>>>>>>>
80457>>>>>>>>>            Move True                                        to SQLConnection.bEnabled
80458>>>>>>>>>            Move Connection.bTrustedConnection               to SQLConnection.bTrusted
80459>>>>>>>>>
80459>>>>>>>>>            // Not used in DUF:
80459>>>>>>>>>            // Move Connection.iDriverIndex                    to SQLConnection.iDriverIndex
80459>>>>>>>>>
80459>>>>>>>>>            Move (If(Connection.iOptions = 0, False, True))  to SQLConnection.bSilentLogin
80460>>>>>>>>>            Move Connection.sConnectionString                to SQLConnection.sConnectionString
80461>>>>>>>>>            Move Connection.sDriver                          to SQLConnection.sDriverID
80462>>>>>>>>>            Move Connection.sId                              to SQLConnection.sConnectionID
80463>>>>>>>>>            Move Connection.sUID                             to SQLConnection.sUserID
80464>>>>>>>>>            Move Connection.sPWD                             to SQLConnection.sPassword
80465>>>>>>>>>
80465>>>>>>>>>            // Not used in DUF:
80465>>>>>>>>>            // Move Connection.sSection to SQLConnection.xxx
80465>>>>>>>>>
80465>>>>>>>>>            // The rest of the properties of the SQLConnection struct should have been
80465>>>>>>>>>            // setup in the cDbUpdateHandler object, and we should be able to reach them through delegation:
80465>>>>>>>>>            If (Connection.sDriver <> ODBC_DRV_ID) Begin
80467>>>>>>>>>                Get ParseKeyWord Connection.sString (CS_SQLIniServerKeyword + "=")       to SQLConnection.sServer
80468>>>>>>>>>            End
80468>>>>>>>>>>
80468>>>>>>>>>            If (Connection.sDriver = ODBC_DRV_ID) Begin
80470>>>>>>>>>                Get ParseKeyWord Connection.sString (CS_SQLIniDSNKeyword + "=")          to SQLConnection.sServer
80471>>>>>>>>>                If (SQLConnection.sServer = "") Begin
80473>>>>>>>>>                    Get ParseKeyWord Connection.sString (CS_SQLIniFileDSNKeyword  + "=") to SQLConnection.sServer
80474>>>>>>>>>                End
80474>>>>>>>>>>
80474>>>>>>>>>            End
80474>>>>>>>>>>
80474>>>>>>>>>
80474>>>>>>>>>            Get ParseKeyWord Connection.sString (CS_SQLIniDatabaseKeyword  + "=")        to SQLConnection.sDatabase
80475>>>>>>>>>
80475>>>>>>>>>            // The DbType is a bit special. If the piDbType has _not_ been setup in object code we try to derave
80475>>>>>>>>>            // the value from the driver id:
80475>>>>>>>>>            Get SqlUtilDbTypeFromDriver of (phoSQLConnectionIniFile(Self)) Connection.sDriver to SQLConnection.iDbType
80476>>>>>>>>>            // ...but in case it has been explicitly set in the object we use that value.
80476>>>>>>>>>            Get piDbType                                     to iDbType
80477>>>>>>>>>            If (iDbType <> SQLConnection.iDbType) Begin
80479>>>>>>>>>                Move iDbType to SQLConnection.iDbType
80480>>>>>>>>>            End
80480>>>>>>>>>>
80480>>>>>>>>>            Get psBaseTableSpace                             to SQLConnection.sBaseTableSpace
80481>>>>>>>>>            Get psLongTableSpace                             to SQLConnection.sLongTableSpace
80482>>>>>>>>>            Get psIndexTableSpace                            to SQLConnection.sIndexTableSpace
80483>>>>>>>>>            Get psSchema                                     to SQLConnection.sSchema
80484>>>>>>>>>
80484>>>>>>>>>            // We finally set the struct property to the newly fetched values.
80484>>>>>>>>>            Set pSQLConnection to SQLConnection
80485>>>>>>>>>
80485>>>>>>>>>        Function_Return SQLConnection
80486>>>>>>>>>    End_Function
80487>>>>>>>>>
80487>>>>>>>>>    // Returns True if the psConnectionID has been set in the cDbUpateHandler object,
80487>>>>>>>>>    // or the DAW cConnect array of registered connection only contains one active/enabled
80487>>>>>>>>>    // connection id for a particular driver.
80487>>>>>>>>>    // So either the psConnectionID or the psDriverID can have been set in the cDbUpdateHandler
80487>>>>>>>>>    // object. We can then match a connection id from the DAW cConnect class array.
80487>>>>>>>>>    // Returns False if there are multiple connections that are enabled or the psConnectionID has
80487>>>>>>>>>    // been set in the cDbUpdateHandler object but it cannot be found amongst the registered
80487>>>>>>>>>    // connections of the DAW cConnect class.
80487>>>>>>>>>    Function IsSinglecConnection String ByRef sConnectionID Returns Boolean
80489>>>>>>>>>        tConnection[] ConnIdArray
80489>>>>>>>>>        tConnection[] ConnIdArray
80490>>>>>>>>>        Integer iCount iSize iConnectionIDCounter
80490>>>>>>>>>        Boolean bEnabled bFound
80490>>>>>>>>>        String sConnectionID2 sDriverID sDriverConn
80490>>>>>>>>>
80490>>>>>>>>>        Move False to bFound
80491>>>>>>>>>        If (ghoConnection > 0) Begin
80493>>>>>>>>>
80493>>>>>>>>>            // The property of the cDbUpdateHandler container object
80493>>>>>>>>>            Get psDriverID to sDriverID
80494>>>>>>>>>
80494>>>>>>>>>            Move 0 to iConnectionIDCounter
80495>>>>>>>>>            // This is the the DAW cConnect array with all registered connection id's.
80495>>>>>>>>>                Get ConnectionIDs of ghoConnection to ConnIdArray
80496>>>>>>>>>            Move (SizeOfArray(ConnIdArray)) to iSize
80497>>>>>>>>>            Decrement iSize
80498>>>>>>>>>            For iCount from 0 to iSize
80504>>>>>>>>>>
80504>>>>>>>>>                Move ConnIdArray[iCount].sDriver to sDriverConn
80505>>>>>>>>>                Move ConnIdArray[iCount].sId to sConnectionID2
80506>>>>>>>>>                Move (ConnIdArray[iCount].bDisabled = False) to bEnabled
80507>>>>>>>>>                // If no psConnectionID specified in the cDbUpdateHandler, we check if there is a driver
80507>>>>>>>>>                // connection in the DAW cConnect object _and_ that there is only one!
80507>>>>>>>>>                If (sConnectionID = "") Begin
80509>>>>>>>>>                    Move (sDriverID = sDriverConn and bEnabled = True) to bFound
80510>>>>>>>>>                End
80510>>>>>>>>>>
80510>>>>>>>>>                Else Begin
80511>>>>>>>>>                    If (Uppercase(sConnectionID) = Uppercase(sConnectionID2)) Begin
80513>>>>>>>>>                        Move iSize to iCount // Then we've found what we were looking for and we're out of here...
80514>>>>>>>>>                    End
80514>>>>>>>>>>
80514>>>>>>>>>                End
80514>>>>>>>>>>
80514>>>>>>>>>
80514>>>>>>>>>                If (bFound = True) Begin
80516>>>>>>>>>                    Increment iConnectionIDCounter
80517>>>>>>>>>                End
80517>>>>>>>>>>
80517>>>>>>>>>            Loop
80518>>>>>>>>>>
80518>>>>>>>>>            Move (iConnectionIDCounter <= 1 and sDriverConn <> "" and sConnectionID2 <> "") to bFound
80519>>>>>>>>>            If (bFound = True) Begin
80521>>>>>>>>>                Move sConnectionID2 to sConnectionID
80522>>>>>>>>>            End
80522>>>>>>>>>>
80522>>>>>>>>>        End
80522>>>>>>>>>>
80522>>>>>>>>>
80522>>>>>>>>>        // Special case; a cConnection object has been setup in the cApplication,
80522>>>>>>>>>        // but no DFConn.ini record has been created.
80522>>>>>>>>>        If (iSize = -1) Begin
80524>>>>>>>>>            Move True to bFound
80525>>>>>>>>>        End
80525>>>>>>>>>>
80525>>>>>>>>>
80525>>>>>>>>>        Function_Return bFound
80526>>>>>>>>>    End_Function
80527>>>>>>>>>
80527>>>>>>>>>    // Send on object creation to read the default connection string settings, and
80527>>>>>>>>>    // create a connection to the server.
80527>>>>>>>>>    Function ReadSQLConnectionsIniSettings Returns tSQLConnection
80529>>>>>>>>>        String sPath sFileName
80529>>>>>>>>>        Boolean bExists bActive
80529>>>>>>>>>        tSQLConnection[] SQLConnectionArray
80529>>>>>>>>>        tSQLConnection[] SQLConnectionArray
80530>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
80530>>>>>>>>>        tSQLConnection SQLConnection SQLConnectionEmpty
80530>>>>>>>>>        Handle hoIniFile
80530>>>>>>>>>        Integer iSize iCount iRetval
80530>>>>>>>>>
80530>>>>>>>>>        Get psIniFilePath to sPath
80531>>>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
80532>>>>>>>>>        If (sPath = "") Begin
80534>>>>>>>>>            Get ApplicationPath of hoIniFile to sPath
80535>>>>>>>>>            Set psIniFilePath   of hoIniFile to sPath
80536>>>>>>>>>        End
80536>>>>>>>>>>
80536>>>>>>>>>        Get vFolderFormat sPath to sPath
80537>>>>>>>>>        Get psIniFileName to sFileName
80538>>>>>>>>>        Get vFilePathExists (sPath + sFileName) to bExists
80539>>>>>>>>>
80539>>>>>>>>>        Get SQLIniFileReadConnections of hoIniFile to SQLConnectionArray
80540>>>>>>>>>        Move (SizeOfArray(SQLConnectionArray)) to iSize
80541>>>>>>>>>        If (iSize = 0) Begin
80543>>>>>>>>>            // This may have been set by the "ReadcConnections" function,
80543>>>>>>>>>            // if a cConnection object has been setup for DataFlex 19 or later
80543>>>>>>>>>            // in the cApplication object.
80543>>>>>>>>>            Get pSQLConnection to SQLConnection
80544>>>>>>>>>            If (SQLConnection.sConnectionID = "") Begin
80546>>>>>>>>>                Function_Return SQLConnectionEmpty
80547>>>>>>>>>            End
80547>>>>>>>>>>
80547>>>>>>>>>            Move SQLConnection to SQLConnectionArray[0] 
80548>>>>>>>>>            Move 1 to iSize
80549>>>>>>>>>        End
80549>>>>>>>>>>
80549>>>>>>>>>
80549>>>>>>>>>        Move False to bActive
80550>>>>>>>>>        // The first connection should be the one that is active, but all connections might have been disabled.
80550>>>>>>>>>        Decrement iSize
80551>>>>>>>>>        For iCount from 0 to iSize
80557>>>>>>>>>>
80557>>>>>>>>>            Move SQLConnectionArray[iCount] to SQLConnection
80558>>>>>>>>>            If (SQLConnection.bEnabled = True) Begin
80560>>>>>>>>>                Move True to bActive
80561>>>>>>>>>                Move iSize to iCount // We've found the enabled item, so we're out of here.
80562>>>>>>>>>            End
80562>>>>>>>>>>
80562>>>>>>>>>        Loop
80563>>>>>>>>>>
80563>>>>>>>>>
80563>>>>>>>>>        // In case all connections have been disabled, we're out of here.
80563>>>>>>>>>        If (bActive = False) Begin
80565>>>>>>>>>            Function_Return SQLConnectionEmpty
80566>>>>>>>>>        End
80566>>>>>>>>>>
80566>>>>>>>>>
80566>>>>>>>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID ;             SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted ;             SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bSilentLogin False
80567>>>>>>>>>
80567>>>>>>>>>        Set pSQLConnection to SQLConnection
80568>>>>>>>>>        Get AutoSetConnectionID to iRetval
80569>>>>>>>>>
80569>>>>>>>>>        Function_Return SQLConnection
80570>>>>>>>>>    End_Function
80571>>>>>>>>>
80571>>>>>>>>>    Procedure Set psIniFilePath String sPath
80573>>>>>>>>>        Set psIniFilePath of (phoSQLConnectionIniFile(Self)) to sPath
80574>>>>>>>>>    End_Procedure
80575>>>>>>>>>
80575>>>>>>>>>    Function psIniFilePath Returns String
80577>>>>>>>>>        String sRetval
80577>>>>>>>>>        Get psIniFilePath of (phoSQLConnectionIniFile(Self)) to sRetval
80578>>>>>>>>>        Function_Return sRetval
80579>>>>>>>>>    End_Function
80580>>>>>>>>>
80580>>>>>>>>>    Procedure Set psIniFileName String sFileName
80582>>>>>>>>>        Set psIniFileName of (phoSQLConnectionIniFile(Self)) to sFileName
80583>>>>>>>>>    End_Procedure
80584>>>>>>>>>
80584>>>>>>>>>    Function psIniFileName Returns String
80586>>>>>>>>>        String sRetval
80586>>>>>>>>>        Get psIniFileName of (phoSQLConnectionIniFile(Self)) to sRetval
80587>>>>>>>>>        Function_Return sRetval
80588>>>>>>>>>    End_Function
80589>>>>>>>>>
80589>>>>>>>>>    Procedure Set psIniSectionName String sSection
80591>>>>>>>>>        Set psIniSectionName of (phoSQLConnectionIniFile(Self)) to sSection
80592>>>>>>>>>    End_Procedure
80593>>>>>>>>>
80593>>>>>>>>>    Function psIniSectionName Returns String
80595>>>>>>>>>        String sRetval
80595>>>>>>>>>        Get psIniSectionName of (phoSQLConnectionIniFile(Self)) to sRetval
80596>>>>>>>>>        Function_Return sRetval
80597>>>>>>>>>    End_Function
80598>>>>>>>>>
80598>>>>>>>>>    Procedure Set IniFileValue String sSection String sValueName String sValue
80600>>>>>>>>>        Handle ho
80600>>>>>>>>>        Get phoSQLConnectionIniFile to ho
80601>>>>>>>>>        Set IniFileValue of ho to sSection sValueName sValue
80602>>>>>>>>>    End_Procedure
80603>>>>>>>>>
80603>>>>>>>>>    Function IniFileValue String sSection String sValueName String sDefaultValue Returns String
80605>>>>>>>>>        Handle ho
80605>>>>>>>>>        String sRetval
80605>>>>>>>>>        Get phoSQLConnectionIniFile to ho
80606>>>>>>>>>        Get IniFileValue of ho sSection sValueName sDefaultValue to sRetval
80607>>>>>>>>>        Function_Return sRetval
80608>>>>>>>>>    End_Function
80609>>>>>>>>>
80609>>>>>>>>>    Function SectionExists String sSection Returns Boolean
80611>>>>>>>>>        Handle ho
80611>>>>>>>>>        Boolean bRetval
80611>>>>>>>>>        Get phoSQLConnectionIniFile to ho
80612>>>>>>>>>        Get SectionExists of ho sSection to bRetval
80613>>>>>>>>>        Function_Return bRetval
80614>>>>>>>>>    End_Function
80615>>>>>>>>>
80615>>>>>>>>>    Function KeyExists String sSection String sKey Returns Boolean
80617>>>>>>>>>        Handle ho
80617>>>>>>>>>        Boolean bRetval
80617>>>>>>>>>        Get phoSQLConnectionIniFile to ho
80618>>>>>>>>>        Get KeyExists of ho sSection sKey to bRetval
80619>>>>>>>>>        Function_Return bRetval
80620>>>>>>>>>    End_Function
80621>>>>>>>>>
80621>>>>>>>>>    Function EncryptPassword String sPassword Returns String
80623>>>>>>>>>        Handle ho
80623>>>>>>>>>        String sRetval
80623>>>>>>>>>        Get phoSQLConnectionIniFile to ho
80624>>>>>>>>>        Get EncryptPassword of ho sPassword to sRetval
80625>>>>>>>>>        Function_Return sRetval
80626>>>>>>>>>    End_Function
80627>>>>>>>>>
80627>>>>>>>>>    Function DecryptPassword String sPassword Returns String
80629>>>>>>>>>        Handle ho
80629>>>>>>>>>        String sRetval
80629>>>>>>>>>        Get phoSQLConnectionIniFile to ho
80630>>>>>>>>>        Get DecryptPassword of ho sPassword to sRetval
80631>>>>>>>>>        Function_Return sRetval
80632>>>>>>>>>    End_Function
80633>>>>>>>>>
80633>>>>>>>>>    // *** Main Connection Message ***
80633>>>>>>>>>    Procedure CreateSQLConnection String sDriverID String sConnectionID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Boolean bSilent Boolean bExitProgram
80635>>>>>>>>>        Handle hoDriver
80635>>>>>>>>>        String sConnectionString sError
80635>>>>>>>>>        Boolean bLoginSuccessful
80635>>>>>>>>>
80635>>>>>>>>>        Get ConstructConnectionString sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnectionString
80636>>>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
80637>>>>>>>>>        Set psDriverID of hoDriver to sDriverID
80638>>>>>>>>>        Get DbLogin of hoDriver sConnectionString sServer sDatabase bTrusted sUserID sPassword to bLoginSuccessful
80639>>>>>>>>>        If (bLoginSuccessful = False) Begin
80641>>>>>>>>>            Error DFERR_PROGRAM (CS_DUF_CannotLoginToServer * CS_DUF_ErrorText * String(sError) + "\nConnectionID = " * sConnectionID + "\nConnection String = " * sConnectionString)   
80642>>>>>>>>>>
80642>>>>>>>>>            If (bExitProgram = True) Begin
80644>>>>>>>>>                Send Exit_Application
80645>>>>>>>>>            End
80645>>>>>>>>>>
80645>>>>>>>>>        End
80645>>>>>>>>>>
80645>>>>>>>>>        Send Destroy of hoDriver
80646>>>>>>>>>    End_Procedure
80647>>>>>>>>>
80647>>>>>>>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
80649>>>>>>>>>        Integer iRetval
80649>>>>>>>>>        Handle hoCLI
80649>>>>>>>>>        String sDriverID
80649>>>>>>>>>
80649>>>>>>>>>        Get psDriverID to sDriverID
80650>>>>>>>>>        Get Create (Refclass(cCLIHandler)) to hoCLI
80651>>>>>>>>>        If (hoCLI <> 0) Begin
80653>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
80654>>>>>>>>>            Get RedirectConnection of hoCLI sOldConnection sNewConnection to iRetval
80655>>>>>>>>>            Send Destroy of hoCLI
80656>>>>>>>>>        End
80656>>>>>>>>>>
80656>>>>>>>>>
80656>>>>>>>>>        Function_Return iRetval
80657>>>>>>>>>    End_Function
80658>>>>>>>>>
80658>>>>>>>>>    Procedure CreateConnParamsFromConnectionString String sDriverID String sConnectionString
80660>>>>>>>>>        tSQLConnection SQLConnection
80660>>>>>>>>>        tSQLConnection SQLConnection
80660>>>>>>>>>
80660>>>>>>>>>        Set psDriverID to sDriverID
80661>>>>>>>>>        Get DeComposeConnectionString sDriverID sConnectionString to SQLConnection
80662>>>>>>>>>        Send CreateSQLConnection SQLConnection.sDriverID SQLConnection.sConnectionID SQLConnection.sServer;                                 SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted False
80663>>>>>>>>>    End_Procedure
80664>>>>>>>>>
80664>>>>>>>>>    // This is needed when e.g. the connection id we have specified in the program code
80664>>>>>>>>>    // also exists in e.g. the MSSQLDRV.ini file (can either be local in the Data folder
80664>>>>>>>>>    // or the one in the DataFlex Bin folder.)
80664>>>>>>>>>    // We then need to delete the current one before creating a new one.
80664>>>>>>>>>    // This is because the parameters may differ between the program code and the
80664>>>>>>>>>    // MSSQLDRV.ini file in a deployed environment. Also DataFlex will generate an error
80664>>>>>>>>>    // when one tries to create a Connection ID that already exists.
80664>>>>>>>>>    Procedure RemoveExistingConnectionID String sDriverID String sConnectionID
80666>>>>>>>>>        Integer iResult iDriver iNumConn iConn
80666>>>>>>>>>        Handle hoCLI
80666>>>>>>>>>        String sID
80666>>>>>>>>>
80666>>>>>>>>>        If (sDriverID = "" or sConnectionID = "") Begin
80668>>>>>>>>>            Procedure_Return
80669>>>>>>>>>        End
80669>>>>>>>>>>
80669>>>>>>>>>
80669>>>>>>>>>        Move 0 to iResult
80670>>>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
80671>>>>>>>>>        If (hoCLI <> 0) Begin
80673>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
80674>>>>>>>>>            Get DriverIndex sDriverID to iDriver
80675>>>>>>>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
80678>>>>>>>>>            Decrement iNumConn
80679>>>>>>>>>            For iConn from 0 to iNumConn
80685>>>>>>>>>>
80685>>>>>>>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
80688>>>>>>>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
80690>>>>>>>>>                    Get DeleteConnectionID of hoCLI sConnectionID -1 to iResult
80691>>>>>>>>>                End
80691>>>>>>>>>>
80691>>>>>>>>>            Loop
80692>>>>>>>>>>
80692>>>>>>>>>            Send Destroy of hoCLI
80693>>>>>>>>>        End
80693>>>>>>>>>>
80693>>>>>>>>>
80693>>>>>>>>>    End_Procedure
80694>>>>>>>>>
80694>>>>>>>>>    Function ExistingConnectionSettings String sDriverID String sConnectionID Returns tSQLConnection
80696>>>>>>>>>        Integer iResult iDriver iNumConn iConn
80696>>>>>>>>>        Handle hoCLI
80696>>>>>>>>>        String sID sConnectionString sVal sDatabase
80696>>>>>>>>>        tSQLConnection SQLConnection
80696>>>>>>>>>        tSQLConnection SQLConnection
80696>>>>>>>>>        Boolean bTrusted
80696>>>>>>>>>
80696>>>>>>>>>        Move 0 to iResult
80697>>>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
80698>>>>>>>>>        If (hoCLI <> 0) Begin
80700>>>>>>>>>            Set psDriverID of hoCLI to sDriverID
80701>>>>>>>>>            Get DriverIndex sDriverID to iDriver
80702>>>>>>>>>            Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
80705>>>>>>>>>            Decrement iNumConn
80706>>>>>>>>>            For iConn from 0 to iNumConn
80712>>>>>>>>>>
80712>>>>>>>>>                Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn to sID
80715>>>>>>>>>                If (Uppercase(sID) = Uppercase(sConnectionID)) Begin
80717>>>>>>>>>                    Move sDriverID                                                      to SQLConnection.sDriverID      // For completeness only...
80718>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iConn              to SQLConnection.sConnectionID  // For completeness only...
80721>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iConn       to sConnectionString
80724>>>>>>>>>                    Move sConnectionString                                              to SQLConnection.sConnectionString
80725>>>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_OPTIONS of iDriver iConn      to SQLConnection.bSilentLogin
80728>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to SQLConnection.sServer
80729>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to SQLConnection.sDatabase
80730>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to SQLConnection.sUserID
80731>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to SQLConnection.sPassword
80732>>>>>>>>>
80732>>>>>>>>>                    Case Begin
80732>>>>>>>>>                        Case (sDriverID = MSSQLDRV_ID)
80734>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=") to sVal
80735>>>>>>>>>                            Move (If(Uppercase(sVal) = Uppercase(CS_SQLIniConnectionYes), True, False)) to bTrusted
80736>>>>>>>>>                            Move bTrusted                                               to SQLConnection.bTrusted
80737>>>>>>>>>                            Case Break
80738>>>>>>>>>                        Case (sDriverID = DB2_DRV_ID)
80741>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
80742>>>>>>>>>                            Case Break
80743>>>>>>>>>                        Case (sDriverID = ODBC_DRV_ID)
80746>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
80747>>>>>>>>>                            If (SQLConnection.sServer = "") Begin
80749>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniFileDSNKeyword  + "=") to SQLConnection.sServer
80750>>>>>>>>>                            End
80750>>>>>>>>>>
80750>>>>>>>>>                            Case Break
80751>>>>>>>>>                        Case (sDriverID = SQLFLEX)
80754>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
80755>>>>>>>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)    to sConnectionString
80756>>>>>>>>>                            If (SQLConnection.bTrusted = True) Begin
80758>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
80759>>>>>>>>>                            End
80759>>>>>>>>>>
80759>>>>>>>>>                            Else Begin
80760>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
80761>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
80762>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
80763>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
80764>>>>>>>>>                            End
80764>>>>>>>>>>
80764>>>>>>>>>                            Move sConnectionString                                         to SQLConnection.sConnectionString
80765>>>>>>>>>                            Case Break
80766>>>>>>>>>                        Case (sDriverID = MDSMySQL)
80769>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
80770>>>>>>>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)    to sConnectionString
80771>>>>>>>>>                            If (SQLConnection.bTrusted = True) Begin
80773>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
80774>>>>>>>>>                            End
80774>>>>>>>>>>
80774>>>>>>>>>                            Else Begin
80775>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
80776>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
80777>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
80778>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
80779>>>>>>>>>                            End
80779>>>>>>>>>>
80779>>>>>>>>>                            Move sConnectionString                                         to SQLConnection.sConnectionString
80780>>>>>>>>>                            Case Break
80781>>>>>>>>>                        Case (sDriverID = MDSPgSQL)
80784>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=") to SQLConnection.sServer
80785>>>>>>>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)    to sConnectionString
80786>>>>>>>>>                            If (SQLConnection.bTrusted = True) Begin
80788>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
80789>>>>>>>>>                            End
80789>>>>>>>>>>
80789>>>>>>>>>                            Else Begin
80790>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
80791>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
80792>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
80793>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
80794>>>>>>>>>                            End
80794>>>>>>>>>>
80794>>>>>>>>>                            Move sConnectionString                                                to SQLConnection.sConnectionString
80795>>>>>>>>>                            Case Break
80796>>>>>>>>>
80796>>>>>>>>>                        Case (sDriverID = ORAFLEX)
80799>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to SQLConnection.sServer
80800>>>>>>>>>                            Move (CS_SQLIniServerKeyword + "=" + SQLConnection.sServer)         to sConnectionString
80801>>>>>>>>>                            Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
80802>>>>>>>>>                            If (sDatabase <> "" and (not(SQLConnection.sServer contains "/"))) Begin
80804>>>>>>>>>                                Move (SQLConnection.sServer + "/" + sDatabase)                  to SQLConnection.sServer
80805>>>>>>>>>                            End
80805>>>>>>>>>>
80805>>>>>>>>>                            If (SQLConnection.bTrusted = True) Begin
80807>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniTrustedKeyword + "=" + CS_SQLIniConnectionYes) to sConnectionString
80808>>>>>>>>>                            End
80808>>>>>>>>>>
80808>>>>>>>>>                            Else Begin
80809>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")    to sVal
80810>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniUIDKeyword + "=" + sVal) to sConnectionString
80811>>>>>>>>>                                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")    to sVal
80812>>>>>>>>>                                Move (sConnectionString + ";" + CS_SQLIniPWDKeyword + "=" + sVal) to sConnectionString
80813>>>>>>>>>                            End
80813>>>>>>>>>>
80813>>>>>>>>>                            Move sConnectionString                                         to SQLConnection.sConnectionString
80814>>>>>>>>>                            Case Break
80815>>>>>>>>>                        Case Else
80815>>>>>>>>>                            Error ("Wrong driver ID passed:" * sDriverID)
80816>>>>>>>>>>
80816>>>>>>>>>                            Case Break
80817>>>>>>>>>                    Case End
80817>>>>>>>>>                End
80817>>>>>>>>>>
80817>>>>>>>>>            Loop
80818>>>>>>>>>>
80818>>>>>>>>>            Send Destroy of hoCLI
80819>>>>>>>>>        End
80819>>>>>>>>>>
80819>>>>>>>>>
80819>>>>>>>>>        Function_Return SQLConnection
80820>>>>>>>>>    End_Function
80821>>>>>>>>>
80821>>>>>>>>>    Function DriverIndex String sDriverID Returns Integer
80823>>>>>>>>>        String  sCurrentDriver
80823>>>>>>>>>        Integer iNumberOfDrivers iDriver iCount
80823>>>>>>>>>
80823>>>>>>>>>        Move 0 to iDriver
80824>>>>>>>>>        Move 0 to iCount
80825>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
80828>>>>>>>>>        For iCount from 1 to iNumberOfDrivers
80834>>>>>>>>>>
80834>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
80837>>>>>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
80839>>>>>>>>>                Function_Return iCount
80840>>>>>>>>>            End
80840>>>>>>>>>>
80840>>>>>>>>>        Loop
80841>>>>>>>>>>
80841>>>>>>>>>
80841>>>>>>>>>        // If driver not previously loaded; attempt to do so now.
80841>>>>>>>>>        If (iDriver = 0) Begin
80843>>>>>>>>>            Move 0 to LastErr
80844>>>>>>>>>            Load_Driver sDriverID
80845>>>>>>>>>            // If driver could not be loaded.
80845>>>>>>>>>            If (LastErr = DFERR_CANT_LOAD_DLL) Begin
80847>>>>>>>>>                Move -1 to iCount
80848>>>>>>>>>            End
80848>>>>>>>>>>
80848>>>>>>>>>        End
80848>>>>>>>>>>
80848>>>>>>>>>        Function_Return iCount
80849>>>>>>>>>    End_Function
80850>>>>>>>>>
80850>>>>>>>>>    // This will update connection settings of the cCLIHandler object with that passed struct values.
80850>>>>>>>>>    Procedure UpdateConnectionString tSQLConnection SQLConnection
80852>>>>>>>>>        String sDriverID sConnectionID sServer sDatabase sUserID sPassword
80852>>>>>>>>>        Boolean bTrusted bSilent
80852>>>>>>>>>        Integer iRetval
80852>>>>>>>>>
80852>>>>>>>>>        Move SQLConnection.sDriverID     to sDriverID
80853>>>>>>>>>        Move SQLConnection.sConnectionID to sConnectionID
80854>>>>>>>>>        Move SQLConnection.sServer       to sServer
80855>>>>>>>>>        Move SQLConnection.sDatabase     to sDatabase
80856>>>>>>>>>        Move SQLConnection.bTrusted      to bTrusted
80857>>>>>>>>>        Move SQLConnection.sUserID       to sUserID
80858>>>>>>>>>        Move SQLConnection.sPassword     to sPassword
80859>>>>>>>>>        Move SQLConnection.bSilentLogin  to bSilent
80860>>>>>>>>>
80860>>>>>>>>>        Send CreateSQLConnection sDriverID sConnectionID sServer sDatabase bTrusted sUserID sPassword bSilent False
80861>>>>>>>>>        // Note that this message will first delete the current ConnectionID if it exists; which is needed by the cCLIHandler logic.
80861>>>>>>>>>        Get AutoSetConnectionID to iRetval
80862>>>>>>>>>    End_Procedure
80863>>>>>>>>>
80863>>>>>>>>>    // Called when the object is constructed.
80863>>>>>>>>>    // It will check the psDriverID for a ConnectionID and save it
80863>>>>>>>>>    // as psConnectionID property. It is later used whenever a login to
80863>>>>>>>>>    // the database is needed.
80863>>>>>>>>>    Function AutoSetConnectionID Returns Boolean
80865>>>>>>>>>        String sConnectionID sDriverID sConnectionString
80865>>>>>>>>>        Integer iDriver iRetval
80865>>>>>>>>>        Handle hoCLI
80865>>>>>>>>>        Boolean bOK bSilent bMertechDriver
80865>>>>>>>>>
80865>>>>>>>>>        Get pbSilentLogin      to bSilent
80866>>>>>>>>>        Get psConnectionID     to sConnectionID
80867>>>>>>>>>        Get psConnectionString to sConnectionString
80868>>>>>>>>>        // Get the driver Connection ID string & set the psConnectionString property.
80868>>>>>>>>>        Get psDriverID to sDriverID
80869>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
80870>>>>>>>>>        If (bOK = False) Begin
80872>>>>>>>>>            Function_Return False
80873>>>>>>>>>        End
80873>>>>>>>>>>
80873>>>>>>>>>
80873>>>>>>>>>        // Mertech drivers can't use connection ID's.
80873>>>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
80874>>>>>>>>>        If (bMertechDriver = True) Begin
80876>>>>>>>>>            // This ensures that the correct Server & Database attributes are set both for
80876>>>>>>>>>            // embedded SQL calls and "normal" database commands like e.g. "Open".
80876>>>>>>>>>            Get _MertechSQLManagerHandle to hoCLI
80877>>>>>>>>>            Function_Return (hoCLI <> 0)
80878>>>>>>>>>        End
80878>>>>>>>>>>
80878>>>>>>>>>
80878>>>>>>>>>        Get DriverIndex sDriverID          to iDriver
80879>>>>>>>>>        // If driver not loaded; load it.
80879>>>>>>>>>        If (iDriver = 0) Begin
80881>>>>>>>>>            Load_Driver sDriverID
80882>>>>>>>>>            Get DriverIndex sDriverID      to iDriver
80883>>>>>>>>>        End
80883>>>>>>>>>>
80883>>>>>>>>>        // This shouldn't be possible; unless the driver.dll file is missing or something...
80883>>>>>>>>>        If (iDriver = 0) Begin
80885>>>>>>>>>            Error DFERR_PROGRAM ("The database driver could not be loaded! Connection to database failed." * sDriverID)
80886>>>>>>>>>>
80886>>>>>>>>>            Function_Return False
80887>>>>>>>>>        End           
80887>>>>>>>>>>
80887>>>>>>>>>        Set_Attribute DF_DRIVER_LOGIN_ON_OPEN of iDriver to True
80890>>>>>>>>>        
80890>>>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLI
80891>>>>>>>>>        Set psDriverID of hoCLI            to sDriverID
80892>>>>>>>>>        // Delete the connection first; in case it exists
80892>>>>>>>>>        Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
80893>>>>>>>>>        Get CreateConnectionID of hoCLI sConnectionID sConnectionString bSilent to iRetval 
80894>>>>>>>>>        Send Destroy of hoCLI
80895>>>>>>>>>
80895>>>>>>>>>        Function_Return (iRetval = 0)
80896>>>>>>>>>    End_Function
80897>>>>>>>>>
80897>>>>>>>>>    // Returns the handle of the Mertech SQL handler.
80897>>>>>>>>>    // It also ensures that the correct Server & Database attributes are set both for
80897>>>>>>>>>    // embedded SQL calls and "normal" database commands like e.g. "Open".
80897>>>>>>>>>    // Note: This does _not_ return a proper CLI handler handle as it is not in this class.
80897>>>>>>>>>    //       So the return value is of no use! But we don't need the handle for this class.
80897>>>>>>>>>    Function _MertechSQLManagerHandle Returns Handle
80899>>>>>>>>>        Handle hoSQLHandler
80899>>>>>>>>>        String sDriverID sServer sDatabase
80899>>>>>>>>>
80899>>>>>>>>>        Move 0 to hoSQLHandler
80900>>>>>>>>>        Get psDriverID to sDriverID
80901>>>>>>>>>        Get psServer   to sServer
80902>>>>>>>>>        Get psDatabase to sDatabase
80903>>>>>>>>>        // This command is used to set the server to be used when opening tables
80903>>>>>>>>>        SET_CURRENT_SQL_SERVER to sServer
80946>>>>>>>>>>
80946>>>>>>>>>        // This command is used to specify which server to use for embedded SQL statements,
80946>>>>>>>>>        // but it has been constructed rather studidly as only constants and not variables
80946>>>>>>>>>        // are allowed...
80946>>>>>>>>>        If (sDriverID = MDSPgSQL) Begin
80948>>>>>>>>>            SET_CURRENT_SQL_SERVER_CONNECTION of MDSPgSQL to sServer
80964>>>>>>>>>        End
80964>>>>>>>>>>
80964>>>>>>>>>        If (sDriverID = MDSMySQL) Begin
80966>>>>>>>>>            SET_CURRENT_SQL_SERVER_CONNECTION of MDSMySQL to sServer
80982>>>>>>>>>        End
80982>>>>>>>>>>
80982>>>>>>>>>        If (sDriverID = ORAFLEX) Begin
80984>>>>>>>>>            SET_CURRENT_SQL_SERVER_CONNECTION of ORAFLEX to sServer
81000>>>>>>>>>        End
81000>>>>>>>>>>
81000>>>>>>>>>        If (sDriverID = SQLFLEX) Begin
81002>>>>>>>>>            SET_CURRENT_SQL_SERVER_CONNECTION of SQLFLEX to sServer
81018>>>>>>>>>        End
81018>>>>>>>>>>
81018>>>>>>>>>
81018>>>>>>>>>        // This command is used to specify which database is used for embedded SQL statements.
81018>>>>>>>>>        SQL_USE_DATABASE sDatabase
81056>>>>>>>>>>
81056>>>>>>>>>        SET_DATABASE_NAME to sDatabase
81094>>>>>>>>>>
81094>>>>>>>>>
81094>>>>>>>>>        // Can't have this here because the property is defined for the cDbUpdateFunctionLibrary class,
81094>>>>>>>>>        // which object may or may not have been created at this point. So don't use the return
81094>>>>>>>>>        // value for this function!
81094>>>>>>>>>        //Get phoSQLManagerMT to hoSQLHandler
81094>>>>>>>>>
81094>>>>>>>>>        Function_Return hoSQLHandler
81095>>>>>>>>>    End_Function
81096>>>>>>>>>
81096>>>>>>>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
81098>>>>>>>>>        Boolean bOK bMertechDriver
81098>>>>>>>>>
81098>>>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
81099>>>>>>>>>
81099>>>>>>>>>        If (bOK = False) Begin
81101>>>>>>>>>            Get IsMertechDriver sDriverID to bOK
81102>>>>>>>>>        End
81102>>>>>>>>>>
81102>>>>>>>>>
81102>>>>>>>>>        If (bOK = False) Begin
81104>>>>>>>>>            Get IsMertechDriver sDriverID to bMertechDriver
81105>>>>>>>>>            If (bMertechDriver = True) Begin
81107>>>>>>>>>                Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV_ID, DB2_DRV_ID, ODBC_DRV_ID, SQLFLEX, ORAFLEX, MDSPgSQL or MDSMYSQL"
81108>>>>>>>>>>
81108>>>>>>>>>            End
81108>>>>>>>>>>
81108>>>>>>>>>            Else Begin
81109>>>>>>>>>                Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV_ID, DB2_DRV_ID or ODBC_DRV_ID"
81110>>>>>>>>>>
81110>>>>>>>>>            End
81110>>>>>>>>>>
81110>>>>>>>>>            Function_Return False
81111>>>>>>>>>        End
81111>>>>>>>>>>
81111>>>>>>>>>
81111>>>>>>>>>        Function_Return True
81112>>>>>>>>>    End_Function
81113>>>>>>>>>
81113>>>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
81115>>>>>>>>>        Boolean bOK
81115>>>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID or sDriverID = DFBTRDRV_ID) to bOK
81116>>>>>>>>>        Function_Return bOK
81117>>>>>>>>>    End_Function
81118>>>>>>>>>
81118>>>>>>>>>    Function IsMertechDriver String sDriverID Returns Boolean
81120>>>>>>>>>        Boolean bOK
81120>>>>>>>>>        Move False to bOK
81121>>>>>>>>>//        #IFDEF DUF_Use_Mertech_Drivers
81121>>>>>>>>>            Move (sDriverID = SQLFLEX or sDriverID = ORAFLEX or sDriverID = MDSPgSQL or sDriverID = MDSMYSQL) to bOK
81122>>>>>>>>>//        #ENDIF
81122>>>>>>>>>        Function_Return bOK
81123>>>>>>>>>    End_Function
81124>>>>>>>>>
81124>>>>>>>>>    Function ConstructConnectionString String sDriverID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Returns String
81126>>>>>>>>>        Handle hoIniFile
81126>>>>>>>>>        String sConnect
81126>>>>>>>>>
81126>>>>>>>>>        Get phoSQLConnectionIniFile to hoIniFile
81127>>>>>>>>>        Get ConstructConnectionString of hoIniFile sDriverID sServer sDatabase bTrusted sUserID sPassword to sConnect
81128>>>>>>>>>
81128>>>>>>>>>        Function_Return sConnect
81129>>>>>>>>>    End_Function
81130>>>>>>>>>
81130>>>>>>>>>    // Sample sConnString: "SERVER=(local)\SQLEXPRESS;UID=dbuser;PWD=secret;DATABASE=OrderEntry;, 0"
81130>>>>>>>>>    // Pass a complete driver connection string
81130>>>>>>>>>    // Returns the following as a struct:
81130>>>>>>>>>    //   sServer, sDatabase, sUser, sPassword & True if Trusted_Connection is used.
81130>>>>>>>>>    // Finally also returns a boolean TRUE if trusted_connection=yes, else false is returned.
81130>>>>>>>>>    //
81130>>>>>>>>>    Function DeComposeConnectionString String sDriverID String sConnectionString Returns tSQLConnection
81132>>>>>>>>>        tSQLConnection SQLConnection
81132>>>>>>>>>        tSQLConnection SQLConnection
81132>>>>>>>>>        String sValue sConnectionID sServer sDatabase sUserID sPassword
81132>>>>>>>>>        Boolean bTrusted bSilent bOK
81132>>>>>>>>>        Integer iPos
81132>>>>>>>>>
81132>>>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
81133>>>>>>>>>        If (bOK = False) Begin
81135>>>>>>>>>            Function_Return SQLConnection
81136>>>>>>>>>        End
81136>>>>>>>>>>
81136>>>>>>>>>
81136>>>>>>>>>        Move False to bTrusted
81137>>>>>>>>>        Move False to bSilent
81138>>>>>>>>>
81138>>>>>>>>>        Case Begin
81138>>>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
81140>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to sServer
81141>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
81142>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
81143>>>>>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
81144>>>>>>>>>                If (bTrusted = False) Begin
81146>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
81147>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
81148>>>>>>>>>                End
81148>>>>>>>>>>
81148>>>>>>>>>                Case Break
81149>>>>>>>>>
81149>>>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
81152>>>>>>>>>                If (uppercase(sConnectionString) contains ("." + CS_SQLIniDSNKeyword)) Begin
81154>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniFileDSNKeyword + "=")  to sServer
81155>>>>>>>>>                End
81155>>>>>>>>>>
81155>>>>>>>>>                Else Begin
81156>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
81157>>>>>>>>>                End
81157>>>>>>>>>>
81157>>>>>>>>>
81157>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
81158>>>>>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
81159>>>>>>>>>                If (bTrusted = False) Begin
81161>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
81162>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
81163>>>>>>>>>                End
81163>>>>>>>>>>
81163>>>>>>>>>                Case Break
81164>>>>>>>>>
81164>>>>>>>>>            Case (sDriverID = DB2_DRV_ID)
81167>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
81168>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
81169>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
81170>>>>>>>>>                Case Break
81171>>>>>>>>>
81171>>>>>>>>>            Case (sDriverID = SQLFLEX)
81174>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniServerKeyword + "=")   to sServer
81175>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniTrustedKeyword + "=")  to sValue
81176>>>>>>>>>                Move (If(Uppercase(sValue) = "YES", True, False))                   to bTrusted
81177>>>>>>>>>                If (bTrusted = False) Begin
81179>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")  to sUserID
81180>>>>>>>>>                    Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")  to sPassword
81181>>>>>>>>>                End
81181>>>>>>>>>>
81181>>>>>>>>>                Case Break
81182>>>>>>>>>
81182>>>>>>>>>            Case (sDriverID = ORAFLEX)
81185>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
81186>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
81187>>>>>>>>>                If (sDatabase <> "" and (not(sServer contains "/"))) Begin
81189>>>>>>>>>                    Move (sServer + "/" + sDatabase)                                to sServer
81190>>>>>>>>>                End
81190>>>>>>>>>>
81190>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
81191>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
81192>>>>>>>>>                Case Break
81193>>>>>>>>>
81193>>>>>>>>>            Case (sDriverID = MDSPgSQL)
81196>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
81197>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
81198>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
81199>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
81200>>>>>>>>>                Case Break
81201>>>>>>>>>
81201>>>>>>>>>            Case (sDriverID = MDSMySQL)
81204>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDSNKeyword + "=")      to sServer
81205>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniDatabaseKeyword + "=") to sDatabase
81206>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniUIDKeyword + "=")      to sUserID
81207>>>>>>>>>                Get ParseKeyWord sConnectionString (CS_SQLIniPWDKeyword + "=")      to sPassword
81208>>>>>>>>>                Case Break
81209>>>>>>>>>
81209>>>>>>>>>            Case (sDriverID = DATAFLEX_ID)    // Dummy stub.
81212>>>>>>>>>                Break
81213>>>>>>>>>        Case End
81213>>>>>>>>>
81213>>>>>>>>>        Get ParseKeyWord sConnectionString (Uppercase(CS_SQLConnectionIDText))  to sConnectionID
81214>>>>>>>>>
81214>>>>>>>>>        // bSilent?
81214>>>>>>>>>        Move (Pos(",0", sConnectionString))                                     to iPos
81215>>>>>>>>>        If (iPos = 0) Begin
81217>>>>>>>>>            Move (Pos(",1", sConnectionString))                                 to iPos
81218>>>>>>>>>        End
81218>>>>>>>>>>
81218>>>>>>>>>        If (iPos = 0) Begin
81220>>>>>>>>>            Move "0"                                                            to sValue
81221>>>>>>>>>        End
81221>>>>>>>>>>
81221>>>>>>>>>        Else Begin
81222>>>>>>>>>            Move (Mid(sConnectionString, 1, (iPos +1)))                         to sValue
81223>>>>>>>>>        End
81223>>>>>>>>>>
81223>>>>>>>>>        Move (If(sValue = 1, True, False))                                      to bSilent
81224>>>>>>>>>
81224>>>>>>>>>        Move (Trim(sDriverID))                                                  to SQLConnection.sDriverID
81225>>>>>>>>>        Move (Trim(sConnectionID))                                              to SQLConnection.sConnectionID
81226>>>>>>>>>        Move (Trim(sConnectionString))                                          to SQLConnection.sConnectionString
81227>>>>>>>>>        Move (Trim(sServer))                                                    to SQLConnection.sServer
81228>>>>>>>>>        Move (Trim(sDatabase))                                                  to SQLConnection.sDatabase
81229>>>>>>>>>        Move bTrusted                                                           to SQLConnection.bTrusted
81230>>>>>>>>>        Move (Trim(sUserID))                                                    to SQLConnection.sUserID
81231>>>>>>>>>        Move (Trim(sPassword))                                                  to SQLConnection.sPassword
81232>>>>>>>>>        Move bSilent                                                            to SQLConnection.bSilentLogin
81233>>>>>>>>>
81233>>>>>>>>>        Function_Return SQLConnection
81234>>>>>>>>>    End_Function
81235>>>>>>>>>
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
81235>>>>>>>>>>
81235>>>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
81237>>>>>>>>>>    Integer iStart iEnd
81237>>>>>>>>>>    String sRetval
81237>>>>>>>>>>
81237>>>>>>>>>>    Move (Trim(sConnect)) to sConnect
81238>>>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
81239>>>>>>>>>>    If (iStart = 0) Begin
81241>>>>>>>>>>        Function_Return ""
81242>>>>>>>>>>    End
81242>>>>>>>>>>>
81242>>>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
81243>>>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
81244>>>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
81246>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
81247>>>>>>>>>>    End
81247>>>>>>>>>>>
81247>>>>>>>>>>    Else Begin
81248>>>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
81249>>>>>>>>>>    End
81249>>>>>>>>>>>
81249>>>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
81251>>>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
81252>>>>>>>>>>        Decrement iEnd
81253>>>>>>>>>>    End
81253>>>>>>>>>>>
81253>>>>>>>>>>    If (iEnd <> 0) Begin
81255>>>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
81256>>>>>>>>>>    End
81256>>>>>>>>>>>
81256>>>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
81257>>>>>>>>>>
81257>>>>>>>>>>    Function_Return (Trim(sRetval))
81258>>>>>>>>>>End_Function
81259>>>>>>>>>>
81259>>>>>>>>>>
81259>>>>>>>>>
81259>>>>>>>>>    // To update the SQLSettings.ini file with updated connection data (SQLConnection struct data).
81259>>>>>>>>>    Function SQLIniFileSetDefaultConnection String sConnectionID Returns Boolean
81261>>>>>>>>>        Handle ho
81261>>>>>>>>>        Integer iIndex
81261>>>>>>>>>        Boolean bRetval bOK
81261>>>>>>>>>        tSQLConnection SQLConnection
81261>>>>>>>>>        tSQLConnection SQLConnection
81261>>>>>>>>>
81261>>>>>>>>>        Get pSQLConnection to SQLConnection
81262>>>>>>>>>        Get phoSQLConnectionIniFile to ho
81263>>>>>>>>>        Get SQLIniFileConnectionIDIndex of ho sConnectionID to iIndex
81264>>>>>>>>>        If (iIndex = -1) Begin
81266>>>>>>>>>            Function_Return False
81267>>>>>>>>>        End
81267>>>>>>>>>>
81267>>>>>>>>>
81267>>>>>>>>>        Get SQLIniFileUpdateConnection of ho SQLConnection to bRetval
81268>>>>>>>>>        Send UpdateConnectionString SQLConnection
81269>>>>>>>>>        If (ghoConnection > 0) Begin
81271>>>>>>>>>            Get ConnectionIdIndex of ghoConnection SQLConnection.sConnectionID to iIndex
81272>>>>>>>>>            If (iIndex <> -1) Begin
81274>>>>>>>>>                Get RedirectConnectionId of ghoConnection SQLConnection.sConnectionID (SQLConnection.sServer + ";" + CS_SQLIniDatabaseKeyword + "=" + SQLConnection.sDatabase) SQLConnection.sUserID SQLConnection.sPassword SQLConnection.bTrusted True to bOK
81275>>>>>>>>>            End
81275>>>>>>>>>>
81275>>>>>>>>>        End
81275>>>>>>>>>>
81275>>>>>>>>>
81275>>>>>>>>>        Function_Return bRetval
81276>>>>>>>>>    End_Function
81277>>>>>>>>>
81277>>>>>>>>>End_Class
81278>>>>>>>Use vWin32fh.pkg
81278>>>>>>>Use Dfabout.pkg
Including file: DfAbout.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\DFAbout\DfAbout.pkg)
81278>>>>>>>>>
81278>>>>>>>>>Use LanguageText.pkg
81278>>>>>>>>>Use Windows.pkg
81278>>>>>>>>>Use Dfclient.pkg
81278>>>>>>>>>Use DFbitmap.pkg
81278>>>>>>>>>Use GlobalFunctionsProcedures.pkg
81278>>>>>>>>>Use cRichEdit.pkg
Including file: cRichEdit.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cRichEdit.pkg)
81278>>>>>>>>>>>Use Windows.pkg
81278>>>>>>>>>>>Use cEdit_Mixin.pkg
81278>>>>>>>>>>>
81278>>>>>>>>>>>// constants used for RichEdit Properties
81278>>>>>>>>>>>// peAlignment
81278>>>>>>>>>>>Enum_List
81278>>>>>>>>>>>    Define alLeft   for 1
81278>>>>>>>>>>>    Define alRight  for 2
81278>>>>>>>>>>>    Define alCenter for 3
81278>>>>>>>>>>>End_Enum_List
81278>>>>>>>>>>>
81278>>>>>>>>>>>// peBullets
81278>>>>>>>>>>>Enum_List
81278>>>>>>>>>>>    Define buNone
81278>>>>>>>>>>>    Define buBullets
81278>>>>>>>>>>>    Define buArabicNumbers
81278>>>>>>>>>>>    Define buLowerLetters
81278>>>>>>>>>>>    Define buUpperLetters
81278>>>>>>>>>>>    Define buLowerRomans
81278>>>>>>>>>>>    Define buUpperRomans
81278>>>>>>>>>>>End_Enum_List
81278>>>>>>>>>>>
81278>>>>>>>>>>>// peBulletStyle
81278>>>>>>>>>>>Enum_List
81278>>>>>>>>>>>    Define busRightParen   for 0
81278>>>>>>>>>>>    Define busEncloseParen for 256
81278>>>>>>>>>>>    Define busPeriod       for 512
81278>>>>>>>>>>>    Define busNumberOnly   for 768
81278>>>>>>>>>>>    Define busNoDisplay    for 1024
81278>>>>>>>>>>>End_Enum_List
81278>>>>>>>>>>>
81278>>>>>>>>>>>// peLineSpacingType
81278>>>>>>>>>>>Enum_List
81278>>>>>>>>>>>    Define lstSingle
81278>>>>>>>>>>>    Define lstSingleAndOneHalf
81278>>>>>>>>>>>    Define lstDouble
81278>>>>>>>>>>>End_Enum_List
81278>>>>>>>>>>>
81278>>>>>>>>>>>Class cRichEdit is a DFBaseRichEdit
81279>>>>>>>>>>>    
81279>>>>>>>>>>>    Procedure Construct_Object
81281>>>>>>>>>>>        Forward Send Construct_Object
81283>>>>>>>>>>>        Send Define_cEdit_Mixin
81284>>>>>>>>>>>        
81284>>>>>>>>>>>        On_Key Key_Ctrl+Key_B Send ToggleBold
81285>>>>>>>>>>>        On_Key Key_Ctrl+Key_I Send ToggleItalics
81286>>>>>>>>>>>        On_Key Key_Ctrl+Key_U Send ToggleUnderline
81287>>>>>>>>>>>        
81287>>>>>>>>>>>    End_Procedure
81288>>>>>>>>>>>    
81288>>>>>>>>>>>    Import_Class_Protocol cEdit_Mixin
81289>>>>>>>>>>>    
81289>>>>>>>>>>>    Procedure ToggleBold
81291>>>>>>>>>>>        Set pbBold to (not(pbBold(Self)))
81292>>>>>>>>>>>    End_Procedure
81293>>>>>>>>>>>    
81293>>>>>>>>>>>    Procedure ToggleItalics
81295>>>>>>>>>>>        Set pbItalics to (not(pbItalics(Self)))
81296>>>>>>>>>>>    End_Procedure
81297>>>>>>>>>>>    
81297>>>>>>>>>>>    Procedure ToggleUnderline
81299>>>>>>>>>>>        Set pbUnderLine to (not(pbUnderLine(Self)))
81300>>>>>>>>>>>    End_Procedure
81301>>>>>>>>>>>    
81301>>>>>>>>>>>End_Class
81302>>>>>>>>>>>
81302>>>>>>>>>>>
81302>>>>>>>>>Use cTextEdit.pkg
81302>>>>>>>>>Use cRichEdit.pkg
81302>>>>>>>>>Use gFormatNumbers.pkg
Including file: gFormatNumbers.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\gFormatNumbers.pkg)
81302>>>>>>>>>>>Use cFormatter.pkg
Including file: cFormatter.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cFormatter.pkg)
81302>>>>>>>>>>>>>Use VDFBase.pkg
81302>>>>>>>>>>>>>
81302>>>>>>>>>>>>>Class cFormatter is an cObject
81303>>>>>>>>>>>>>    
81303>>>>>>>>>>>>>    Procedure Construct_object
81305>>>>>>>>>>>>>        Integer iCh
81305>>>>>>>>>>>>>        Forward Send construct_object
81307>>>>>>>>>>>>>        Property String  psCurrencySymbol
81308>>>>>>>>>>>>>        Set psCurrencySymbol to (Default_Currency_Symbol())
81309>>>>>>>>>>>>>        
81309>>>>>>>>>>>>>        Property String  psLeft
81310>>>>>>>>>>>>>        Property String  psright
81311>>>>>>>>>>>>>        Property Integer pbThousandsSep
81312>>>>>>>>>>>>>        Property Integer piPoints
81313>>>>>>>>>>>>>        
81313>>>>>>>>>>>>>        Property String  psCurPosLeft
81314>>>>>>>>>>>>>        Property String  psCurPosright
81315>>>>>>>>>>>>>        Property Integer pbCurPosThousandsSep
81316>>>>>>>>>>>>>        Property Integer piCurPosPoints
81317>>>>>>>>>>>>>        
81317>>>>>>>>>>>>>        Property String  psCurNegLeft
81318>>>>>>>>>>>>>        Property String  psCurNegright
81319>>>>>>>>>>>>>        Property Integer pbCurNegThousandsSep
81320>>>>>>>>>>>>>        Property Integer piCurNegPoints
81321>>>>>>>>>>>>>        
81321>>>>>>>>>>>>>        Property String  psNumPosLeft
81322>>>>>>>>>>>>>        Property String  psNumPosright
81323>>>>>>>>>>>>>        Property Integer pbNumPosThousandsSep
81324>>>>>>>>>>>>>        Property Integer piNumPosPoints
81325>>>>>>>>>>>>>        
81325>>>>>>>>>>>>>        Property String  psNumNegLeft
81326>>>>>>>>>>>>>        Property String  psNumNegright
81327>>>>>>>>>>>>>        Property Integer pbNumNegThousandsSep
81328>>>>>>>>>>>>>        Property Integer piNumNegPoints
81329>>>>>>>>>>>>>        
81329>>>>>>>>>>>>>        Send SetFormat "$,#.##;($,#.##)" True  // currency
81330>>>>>>>>>>>>>        Send SetFormat  ",#.*"           False // numeric
81331>>>>>>>>>>>>>        
81331>>>>>>>>>>>>>    End_Procedure
81332>>>>>>>>>>>>>    
81332>>>>>>>>>>>>>    // internal
81332>>>>>>>>>>>>>    // parse passed format string and set temporary properties with result
81332>>>>>>>>>>>>>    Procedure ParseFormat String sFmt
81334>>>>>>>>>>>>>        
81334>>>>>>>>>>>>>        String sLeft sRight sDigit
81334>>>>>>>>>>>>>        Integer bSep iPos i iDigits
81334>>>>>>>>>>>>>        
81334>>>>>>>>>>>>>        // replace any literals. A "/" followed by anything.
81334>>>>>>>>>>>>>        // some literals are special. $ . , / #
81334>>>>>>>>>>>>>        Move (Replaces("/$",sFmt,Character(1)))    to sFmt
81335>>>>>>>>>>>>>        Move (Replaces("/.",sFmt,Character(2)))    to sFmt
81336>>>>>>>>>>>>>        Move (Replaces("/,",sFmt,Character(3)))    to sFmt
81337>>>>>>>>>>>>>        Move (Replaces("/"+"/",sFmt,Character(4))) to sFmt
81338>>>>>>>>>>>>>        Move (Replaces("/#",sFmt,Character(5)))    to sFmt
81339>>>>>>>>>>>>>        Move (Character(9)) to sDigit
81340>>>>>>>>>>>>>        Move (Replaces("#",sFmt,sDigit))           to sFmt
81341>>>>>>>>>>>>>        Move (Replaces("/",sFmt,""))               to sFmt // replace all others
81342>>>>>>>>>>>>>        
81342>>>>>>>>>>>>>        Move (Pos(",",sFmt))                 to bSep // if we have any , we use thousand seps
81343>>>>>>>>>>>>>        If bSep ;            Move (Replaces(",",sFmt,"")) to sFmt // remove all ,
81346>>>>>>>>>>>>>        
81346>>>>>>>>>>>>>        Move (Replaces("$",sFmt,psCurrencySymbol(Self))) to sFmt // replace any $ with currency symbol
81347>>>>>>>>>>>>>        
81347>>>>>>>>>>>>>        Move (Pos(".",sFmt)) to iPos                 // position of decimal
81348>>>>>>>>>>>>>        
81348>>>>>>>>>>>>>        // Move all the special literals back into place before parsing
81348>>>>>>>>>>>>>        Move (Replaces(Character(1),sFmt,"$")) to sFmt
81349>>>>>>>>>>>>>        Move (Replaces(Character(2),sFmt,".")) to sFmt
81350>>>>>>>>>>>>>        Move (Replaces(Character(3),sFmt,",")) to sFmt
81351>>>>>>>>>>>>>        Move (Replaces(Character(4),sFmt,"/")) to sFmt
81352>>>>>>>>>>>>>        Move (Replaces(Character(5),sFmt,"#")) to sFmt
81353>>>>>>>>>>>>>        
81353>>>>>>>>>>>>>        If (iPos>0) Begin                      // if we have a decimanl point
81355>>>>>>>>>>>>>            Move 1 to i                        // look for first non # to right and count the #s
81356>>>>>>>>>>>>>            If (mid(sFmt,1,iPos+i)="*") Begin  // the "*" is special. It means as many as you want
81358>>>>>>>>>>>>>                Move -2 to iDigits
81359>>>>>>>>>>>>>                Increment i
81360>>>>>>>>>>>>>            End
81360>>>>>>>>>>>>>>
81360>>>>>>>>>>>>>            While (mid(sFmt,1,iPos+i)=sDigit)
81364>>>>>>>>>>>>>                Increment i
81365>>>>>>>>>>>>>            Loop
81366>>>>>>>>>>>>>>
81366>>>>>>>>>>>>>            Move (Mid(sFmt,255,iPos+i)) to sRight // everything to the right of the last # is format stuff
81367>>>>>>>>>>>>>            If (iDigits=0) ;                Move (i-1) to iDigits
81370>>>>>>>>>>>>>            //
81370>>>>>>>>>>>>>            Move 1 to i                           // find the first non-# to the left of the point
81371>>>>>>>>>>>>>            While (mid(sFmt,1,iPos-i)=sDigit)     // everything to the left is format stuff
81375>>>>>>>>>>>>>                Increment i
81376>>>>>>>>>>>>>            Loop
81377>>>>>>>>>>>>>>
81377>>>>>>>>>>>>>            Move (left(sFmt,iPos-i)) to sLeft
81378>>>>>>>>>>>>>        End
81378>>>>>>>>>>>>>>
81378>>>>>>>>>>>>>        Else Begin                             // we have no decinal
81379>>>>>>>>>>>>>            Move 0 to iDigits                  // so points is none
81380>>>>>>>>>>>>>            Move (Pos(sDigit,sFmt)) to iPos    // find first #.
81381>>>>>>>>>>>>>            If (iPos=0) Begin                  // if none, entire string is left format stuff..wierd!
81383>>>>>>>>>>>>>                Move sFmt to sLeft
81384>>>>>>>>>>>>>                Move ""   to sRight
81385>>>>>>>>>>>>>            End
81385>>>>>>>>>>>>>>
81385>>>>>>>>>>>>>            Else Begin
81386>>>>>>>>>>>>>                Move (left(sFmt,iPos-1)) to sLeft // all char to left of first # is left format stuff
81387>>>>>>>>>>>>>                Move 1 to i
81388>>>>>>>>>>>>>                While (mid(sFmt,1,iPos+i)=sDigit) // find last #, all char to right is right format
81392>>>>>>>>>>>>>                    Increment i
81393>>>>>>>>>>>>>                Loop
81394>>>>>>>>>>>>>>
81394>>>>>>>>>>>>>                Move (Mid(sFmt,255,i+iPos)) to sRight
81395>>>>>>>>>>>>>            End
81395>>>>>>>>>>>>>>
81395>>>>>>>>>>>>>        End
81395>>>>>>>>>>>>>>
81395>>>>>>>>>>>>>        // set temporary format properties and exit
81395>>>>>>>>>>>>>        Set pbThousandsSep to bSep
81396>>>>>>>>>>>>>        Set psLeft         to sLeft
81397>>>>>>>>>>>>>        Set psRight        to sRight
81398>>>>>>>>>>>>>        Set piPoints       to iDigits
81399>>>>>>>>>>>>>    End_Procedure
81400>>>>>>>>>>>>>    
81400>>>>>>>>>>>>>    // Public: Sets a format string. Pass full format for Positve and negative in sFmt. Pass
81400>>>>>>>>>>>>>    //         bCurrency true is this is a currency format, false if a numeric format
81400>>>>>>>>>>>>>    //
81400>>>>>>>>>>>>>    //  e.g. Send SetFormat "$,#.##;($,#.##)" True
81400>>>>>>>>>>>>>    Procedure SetFormat String sFmt Integer bCurrency
81402>>>>>>>>>>>>>        String sPos sNeg
81402>>>>>>>>>>>>>        Integer iPos
81402>>>>>>>>>>>>>        
81402>>>>>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
81403>>>>>>>>>>>>>        If iPos Begin
81405>>>>>>>>>>>>>            Move (left(sFmt,iPos-1))    to sPos
81406>>>>>>>>>>>>>            Move (mid(sFmt,255,iPos+1)) to sNeg
81407>>>>>>>>>>>>>        End
81407>>>>>>>>>>>>>>
81407>>>>>>>>>>>>>        Else Begin
81408>>>>>>>>>>>>>            Move sFmt         to sPos
81409>>>>>>>>>>>>>            Move ("-" + sFmt) to sNeg
81410>>>>>>>>>>>>>        End
81410>>>>>>>>>>>>>>
81410>>>>>>>>>>>>>        Send ParseFormat sPos
81411>>>>>>>>>>>>>        If bCurrency Begin
81413>>>>>>>>>>>>>            Set pbCurPosThousandsSep to (pbThousandsSep(Self))
81414>>>>>>>>>>>>>            Set psCurPosLeft         to (psLeft(Self))
81415>>>>>>>>>>>>>            Set psCurPosRight        to (psRight(Self))
81416>>>>>>>>>>>>>            Set piCurPosPoints       to (piPoints(Self))
81417>>>>>>>>>>>>>        End
81417>>>>>>>>>>>>>>
81417>>>>>>>>>>>>>        Else Begin
81418>>>>>>>>>>>>>            Set pbNumPosThousandsSep to (pbThousandsSep(Self))
81419>>>>>>>>>>>>>            Set psNumPosLeft         to (psLeft(Self))
81420>>>>>>>>>>>>>            Set psNumPosRight        to (psRight(Self))
81421>>>>>>>>>>>>>            Set piNumPosPoints       to (piPoints(Self))
81422>>>>>>>>>>>>>        End
81422>>>>>>>>>>>>>>
81422>>>>>>>>>>>>>        
81422>>>>>>>>>>>>>        Send ParseFormat sNeg
81423>>>>>>>>>>>>>        If bCurrency Begin
81425>>>>>>>>>>>>>            Set pbCurNegThousandsSep to (pbThousandsSep(Self))
81426>>>>>>>>>>>>>            Set psCurNegLeft         to (psLeft(Self))
81427>>>>>>>>>>>>>            Set psCurNegRight        to (psRight(Self))
81428>>>>>>>>>>>>>            Set piCurNegPoints       to (piPoints(Self))
81429>>>>>>>>>>>>>        End
81429>>>>>>>>>>>>>>
81429>>>>>>>>>>>>>        Else Begin
81430>>>>>>>>>>>>>            Set pbNumNegThousandsSep to (pbThousandsSep(Self))
81431>>>>>>>>>>>>>            Set psNumNegLeft         to (psLeft(Self))
81432>>>>>>>>>>>>>            Set psNumNegRight        to (psRight(Self))
81433>>>>>>>>>>>>>            Set piNumNegPoints       to (piPoints(Self))
81434>>>>>>>>>>>>>        End
81434>>>>>>>>>>>>>>
81434>>>>>>>>>>>>>    End_Procedure
81435>>>>>>>>>>>>>    
81435>>>>>>>>>>>>>    // low level formatting. Pass parameters
81435>>>>>>>>>>>>>    Function Format_Num Number nNumber Integer iPoints Integer bSep ;            String sPrefix String sSuffix Returns String
81437>>>>>>>>>>>>>        String  sLeft sRight sNumber sSep sDec
81437>>>>>>>>>>>>>        Integer bIsNegative iDec iLen iCh
81437>>>>>>>>>>>>>        
81437>>>>>>>>>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iCh
81440>>>>>>>>>>>>>        Move (Character(iCh)) to sDec
81441>>>>>>>>>>>>>        
81441>>>>>>>>>>>>>        Move (abs(nNumber)) to sNumber
81442>>>>>>>>>>>>>        Move (Pos(sDec,sNumber)) to iDec
81443>>>>>>>>>>>>>        Move (If(iDec=0, sNumber, left(sNumber,iDec-1))) to sLeft
81444>>>>>>>>>>>>>        Move (If(iDec=0, "", mid(sNumber,255,iDec+1)))   to sRight
81445>>>>>>>>>>>>>        // format for decimal separator
81445>>>>>>>>>>>>>        If (iPoints>=0) ; // if -2, leave it alone, it should not be -1            Move (left(sRight+Repeat("0",iPoints),iPoints)) to sRight
81448>>>>>>>>>>>>>        
81448>>>>>>>>>>>>>        // format for thousand sep.
81448>>>>>>>>>>>>>        If bSep Begin
81450>>>>>>>>>>>>>            Get_Attribute DF_THOUSANDS_SEPARATOR to iCh
81453>>>>>>>>>>>>>            Move (Character(iCh)) to sSep
81454>>>>>>>>>>>>>            Move (Length(sLeft)) to iLen
81455>>>>>>>>>>>>>            While (iLen>3)
81459>>>>>>>>>>>>>                Move (insert(sSep,sLeft,iLen-2)) to sLeft
81460>>>>>>>>>>>>>                Move (iLen-3) to iLen
81461>>>>>>>>>>>>>            Loop
81462>>>>>>>>>>>>>>
81462>>>>>>>>>>>>>        End
81462>>>>>>>>>>>>>>
81462>>>>>>>>>>>>>        // if decimal points or -2 (allow anything) and there are points to show
81462>>>>>>>>>>>>>        If (iPoints>0 or (iPoints=-2 and sRight<>"")) ;            Move (sLeft + sDec + sright) to sLeft
81465>>>>>>>>>>>>>        Function_Return (sPrefix + sLeft+ sSuffix)
81466>>>>>>>>>>>>>    End_Function
81467>>>>>>>>>>>>>    
81467>>>>>>>>>>>>>    // Public: Format for currency
81467>>>>>>>>>>>>>    Function FormatCur Number nNumber Integer iPoints Returns String
81469>>>>>>>>>>>>>        String  sLeft sRight
81469>>>>>>>>>>>>>        Integer bSep
81469>>>>>>>>>>>>>        If (nNumber<0) Begin
81471>>>>>>>>>>>>>            Get pbCurNegThousandsSep to bSep
81472>>>>>>>>>>>>>            Get psCurNegLeft         to sLeft
81473>>>>>>>>>>>>>            Get psCurNegRight        to sRight
81474>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piCurNegPoints       to iPoints
81477>>>>>>>>>>>>>        End
81477>>>>>>>>>>>>>>
81477>>>>>>>>>>>>>        Else Begin
81478>>>>>>>>>>>>>            Get pbCurPosThousandsSep to bSep
81479>>>>>>>>>>>>>            Get psCurPosLeft         to sLeft
81480>>>>>>>>>>>>>            Get psCurPosRight        to sRight
81481>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piCurPosPoints       to iPoints
81484>>>>>>>>>>>>>        End
81484>>>>>>>>>>>>>>
81484>>>>>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
81485>>>>>>>>>>>>>    End_Function
81486>>>>>>>>>>>>>    
81486>>>>>>>>>>>>>    // Public: Format for numeric
81486>>>>>>>>>>>>>    Function FormatNum Number nNumber Integer iPoints Returns String
81488>>>>>>>>>>>>>        String  sLeft sRight
81488>>>>>>>>>>>>>        Integer bSep
81488>>>>>>>>>>>>>        If (nNumber<0) Begin
81490>>>>>>>>>>>>>            Get pbNumNegThousandsSep to bSep
81491>>>>>>>>>>>>>            Get psNumNegLeft         to sLeft
81492>>>>>>>>>>>>>            Get psNumNegRight        to sRight
81493>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piNumNegPoints       to iPoints
81496>>>>>>>>>>>>>        End
81496>>>>>>>>>>>>>>
81496>>>>>>>>>>>>>        Else Begin
81497>>>>>>>>>>>>>            Get pbNumPosThousandsSep to bSep
81498>>>>>>>>>>>>>            Get psNumPosLeft         to sLeft
81499>>>>>>>>>>>>>            Get psNumPosRight        to sRight
81500>>>>>>>>>>>>>            If (iPoints=-1) ;                Get piNumPosPoints       to iPoints
81503>>>>>>>>>>>>>        End
81503>>>>>>>>>>>>>>
81503>>>>>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
81504>>>>>>>>>>>>>    End_Function
81505>>>>>>>>>>>>>    
81505>>>>>>>>>>>>>    
81505>>>>>>>>>>>>>    // Public: Format passing format string
81505>>>>>>>>>>>>>    Function FormatVal Number nNumber String sFmt Returns String
81507>>>>>>>>>>>>>        Integer iPos bIsNeg
81507>>>>>>>>>>>>>        String  sLeft sRight
81507>>>>>>>>>>>>>        Integer iPoints bSep
81507>>>>>>>>>>>>>        Move (nNumber<0) to bIsNeg
81508>>>>>>>>>>>>>        Move (Pos(";",sFmt)) to iPos
81509>>>>>>>>>>>>>        Case Begin
81509>>>>>>>>>>>>>            Case (iPos and not(bIsNeg)) ;                Move (left(sFmt,iPos-1))    to sFmt
81512>>>>>>>>>>>>>            Case (iPos and bIsNeg) ;                Move (mid(sFmt,255,iPos+1)) to sFmt
81516>>>>>>>>>>>>>            Case (not(iPos) and not(bIsNeg)) ;                Move sFmt                   to sFmt
81520>>>>>>>>>>>>>            Case Else ;                Move ("-" + sFmt)           to sFmt
81522>>>>>>>>>>>>>        Case End
81522>>>>>>>>>>>>>        Send ParseFormat sFmt
81523>>>>>>>>>>>>>        Get pbThousandsSep to bSep
81524>>>>>>>>>>>>>        Get psLeft         to sLeft
81525>>>>>>>>>>>>>        Get psRight        to sRight
81526>>>>>>>>>>>>>        Get piPoints       to iPoints
81527>>>>>>>>>>>>>        Function_Return (Format_Num(Self, nNumber,iPoints,bSep,sLeft,sRight))
81528>>>>>>>>>>>>>    End_Function
81529>>>>>>>>>>>>>    
81529>>>>>>>>>>>>>End_Class
81530>>>>>>>>>>>
81530>>>>>>>>>>>Global_Variable Handle ghoFormatter
81530>>>>>>>>>>>Get Create of desktop U_cFormatter to ghoFormatter
81531>>>>>>>>>>>
81531>>>>>>>>>>>Function FormatNumber Global Number nNum Integer iPoints Returns String
81533>>>>>>>>>>>    Function_Return (FormatNum(ghoFormatter, nNum,iPoints))
81534>>>>>>>>>>>End_Function
81535>>>>>>>>>>>
81535>>>>>>>>>>>Function FormatCurrency Global Number nNum Integer iPoints Returns String
81537>>>>>>>>>>>    Function_Return (FormatCur(ghoFormatter, nNum,iPoints))
81538>>>>>>>>>>>End_Function
81539>>>>>>>>>>>
81539>>>>>>>>>>>Function FormatValue Global Number nNum String sFmt Returns String
81541>>>>>>>>>>>    Function_Return (FormatVal(ghoFormatter, nNum,sFmt))
81542>>>>>>>>>>>End_Function
81543>>>>>>>>>>>
81543>>>>>>>>>>>Procedure SetCurrencyFormat Global String sFmt
81545>>>>>>>>>>>    Send SetFormat of ghoFormatter sFmt True
81546>>>>>>>>>>>End_Procedure
81547>>>>>>>>>>>
81547>>>>>>>>>>>Procedure SetNumberFormat Global String sFmt
81549>>>>>>>>>>>    Send SetFormat of ghoFormatter sFmt False
81550>>>>>>>>>>>End_Procedure
81551>>>>>>>>>>>
81551>>>>>>>>>>>
81551>>>>>>>>>Use tWinStructs.pkg
81551>>>>>>>>>
81551>>>>>>>>>Use cli.pkg
81551>>>>>>>>>Use DFBTRDRV.PKG
81551>>>>>>>>>Use MSSqldrv.pkg
81551>>>>>>>>>Use db2_drv.pkg
81551>>>>>>>>>Use odbc_drv.pkg
81551>>>>>>>>>Use seq_chnl.pkg
81551>>>>>>>>>
81551>>>>>>>>>Register_Function phoWorkspace Returns Handle
81551>>>>>>>>>Register_Function Help_filename Returns String
81551>>>>>>>>>Register_Function GetHelpFile Returns String
81551>>>>>>>>>Register_Function pbEnterKeyAsTabKey Returns Boolean
81551>>>>>>>>>
81551>>>>>>>>>// Use of Mertech drivers:
81551>>>>>>>>>// Ad the line "Define DUF_Use_Mertech_Drivers" prior "Use" of this package to your source code if using Mertech drivers!
81551>>>>>>>>>    Use mertech.inc
81551>>>>>>>>>
81551>>>>>>>>>
81551>>>>>>>>>
81551>>>>>>>>>
81551>>>>>>>>>
81551>>>>>>>>>// *** Constant Declarations: ***
81551>>>>>>>>>//
81551>>>>>>>>>
81551>>>>>>>>>
81551>>>>>>>>>
81551>>>>>>>>>
81551>>>>>>>>>
81551>>>>>>>>>
81551>>>>>>>>>// 2016-12-12, Samuel:  Added section for Portuguese
81551>>>>>>>>>
81551>>>>>>>>>
81551>>>>>>>>>
81551>>>>>>>>>
81551>>>>>>>>>
81551>>>>>>>>>
81551>>>>>>>>>
81551>>>>>>>>>
81551>>>>>>>>>
81551>>>>>>>>>// System icon menu constants. If the upper left hand
81551>>>>>>>>>// icon in dialogs is clicked, shadow all menu items except Move & Close.
81551>>>>>>>>>    Define SC_RESTORE  for |CI$F120
81551>>>>>>>>>    Define SC_MOVE     for |CI$F010
81551>>>>>>>>>    Define SC_SIZE     for |CI$F000
81551>>>>>>>>>    Define SC_MINIMIZE for |CI$F020
81551>>>>>>>>>    Define SC_MAXIMIZE for |CI$F030
81551>>>>>>>>>    Define SC_CLOSE    for |CI$F060
81551>>>>>>>>>    Define SC_KEYMENU  for |CI$F100
81551>>>>>>>>>    Define SC_NEXTWINDOW for |CI$F040
81551>>>>>>>>>    Define SC_PREVWINDOW for |CI$F050
81551>>>>>>>>>
81551>>>>>>>>>Define CS_SignProgram        for "signtool.exe"
81551>>>>>>>>>Define CS_TempCertBatchFile  for "certinfo.bat"
81551>>>>>>>>>Define CS_VerifyCredentials  for "verify"
81551>>>>>>>>>Define CS_VerifyFileParam    for "/a"
81551>>>>>>>>>Define CS_DefAuthVerPolicy   for "/pa"
81551>>>>>>>>>Define SEE_MASK_NOCLOSEPROCESS for 64 //(0x00000040)
81551>>>>>>>>>
81551>>>>>>>>>// *** Struct Declarations: ***
81551>>>>>>>>>
81551>>>>>>>>>Struct AboutSHELLEXECUTEINFO
81551>>>>>>>>>    DWord   cbSize
81551>>>>>>>>>    Integer fMask
81551>>>>>>>>>    Handle  hwnd
81551>>>>>>>>>    Pointer lpVerb
81551>>>>>>>>>    Pointer lpFile
81551>>>>>>>>>    Pointer lpParameters
81551>>>>>>>>>    Pointer lpDirectory
81551>>>>>>>>>    Integer nShow
81551>>>>>>>>>    Pointer hInstApp
81551>>>>>>>>>    Pointer lpIDList
81551>>>>>>>>>    Pointer lpClass
81551>>>>>>>>>    Handle  hkeyClass
81551>>>>>>>>>    DWord   dwHotKey
81551>>>>>>>>>    Handle  hIconMonitor // Union
81551>>>>>>>>>    //Handle  hMonitor     // Union
81551>>>>>>>>>    Handle  hProcess
81551>>>>>>>>>End_Struct
81551>>>>>>>>>
81551>>>>>>>>>
81551>>>>>>>>>// OBSOLETE STRUCTURE AND WINDOWS API CALL. KEPT FOR BACKWARDS COMPATIBILITY
81551>>>>>>>>>//Type MEMORYSTATUS
81551>>>>>>>>>//   Field MEMORYSTATUS.dwLength         as DWord // sizeof(MEMORYSTATUS)
81551>>>>>>>>>//   Field MEMORYSTATUS.dwMemoryLoad     as DWord // percent Of memory in use
81551>>>>>>>>>//   Field MEMORYSTATUS.dwTotalPhys      as DWord // bytes Of physical memory
81551>>>>>>>>>//   Field MEMORYSTATUS.dwAvailPhys      as DWord // free physical memory bytes
81551>>>>>>>>>//   Field MEMORYSTATUS.dwTotalPageFile  as DWord // bytes Of paging file
81551>>>>>>>>>//   Field MEMORYSTATUS.dwAvailPageFile  as DWord // free bytes Of paging file
81551>>>>>>>>>//   Field MEMORYSTATUS.dwTotalVirtual   as DWord // user bytes Of address space
81551>>>>>>>>>//   Field MEMORYSTATUS.dwAvailVirtual   as DWord // free user bytes
81551>>>>>>>>>//End_Type
81551>>>>>>>>>
81551>>>>>>>>>// *** External Function calls: ***
81551>>>>>>>>>//
81551>>>>>>>>>    External_Function GetSystemMenu "GetSystemMenu" User32.dll Handle hWnd Boolean bRevert Returns Handle
81552>>>>>>>>>
81552>>>>>>>>>    External_Function GetRemoveMenu "RemoveMenu" user32.dll Handle hWnd UInteger uPosition UInteger uFlags Returns Handle
81553>>>>>>>>>
81553>>>>>>>>>
81553>>>>>>>>>    External_Function WNetGetUser "WNetGetUserA" MPR.DLL Pointer lpName Pointer lpUser_Name Pointer lpLength Returns DWord
81554>>>>>>>>>
81554>>>>>>>>>    External_Function GlobalMemoryStatus "GlobalMemoryStatus" Kernel32.Dll Pointer lpsMemoryStatus Returns Integer
81555>>>>>>>>>
81555>>>>>>>>>    External_Function GlobalMemoryStatusEx "GlobalMemoryStatusEx" Kernel32.Dll Pointer lpMemoryStatus Returns Integer
81556>>>>>>>>>
81556>>>>>>>>>External_Function AboutShellExecuteEx "ShellExecuteEx" Shell32.dll Pointer pExecInfo Returns Integer
81557>>>>>>>>>
81557>>>>>>>>>External_Function AboutWaitForSingleObject "WaitForSingleObject" Kernel32.dll ;  Handle hHandle ;  DWord dwMilliseconds ;  Returns DWord
81558>>>>>>>>>
81558>>>>>>>>>External_Function AboutCloseHandle "CloseHandle" Kernel32.dll Handle hHandle Returns Integer
81559>>>>>>>>>
81559>>>>>>>>>// *** Global/Desktop Function Declarations: ***
81559>>>>>>>>>
81559>>>>>>>>>Function ComputerName Desktop Returns String
81561>>>>>>>>>    String sName
81561>>>>>>>>>    Get_Environment "COMPUTERNAME" to sName
81562>>>>>>>>>>
81562>>>>>>>>>    Function_Return sName
81563>>>>>>>>>End_Function
81564>>>>>>>>>
81564>>>>>>>>>Function Network_User_Name Desktop Returns String
81566>>>>>>>>>    String sName
81566>>>>>>>>>    Get_Environment "USERNAME" to sName
81567>>>>>>>>>>
81567>>>>>>>>>    Function_Return sName
81568>>>>>>>>>End_Function
81569>>>>>>>>>
81569>>>>>>>>>Function SQLClientVersion Desktop String sDriverID Integer iClient Returns String
81571>>>>>>>>>    String sClient sDriver sClientDriver
81571>>>>>>>>>    Integer iNumberOfDrivers iDriver iCount iClientVersion
81571>>>>>>>>>    Handle hoMsqlDrv
81571>>>>>>>>>
81571>>>>>>>>>    Move 0 to iDriver
81572>>>>>>>>>    Move "" to sClient
81573>>>>>>>>>    Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
81576>>>>>>>>>    For iCount from 1 to iNumberOfDrivers
81582>>>>>>>>>>
81582>>>>>>>>>        Get_Attribute DF_DRIVER_NAME of iCount to sDriver
81585>>>>>>>>>        If (Uppercase(sDriver) = Uppercase(sDriverID)) Begin
81587>>>>>>>>>            Move iCount to iDriver
81588>>>>>>>>>            Move iNumberOfDrivers to iCount // We're done.
81589>>>>>>>>>        End
81589>>>>>>>>>>
81589>>>>>>>>>    Loop
81590>>>>>>>>>>
81590>>>>>>>>>
81590>>>>>>>>>    // This info is (at current) only available for the MS SQL driver:
81590>>>>>>>>>    If (sDriverID = MSSQLDRV_ID) Begin
81592>>>>>>>>>        Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
81595>>>>>>>>>        Get Create (RefClass(cMSSQLHandler)) to hoMsqlDrv
81596>>>>>>>>>        Get SqlServerClientVersionName of hoMsqlDrv iClientVersion to sClientDriver
81597>>>>>>>>>        Send Destroy of hoMsqlDrv
81598>>>>>>>>>        Move (SFormat("MSSQLDRV Client Version: %1", sClientDriver)) to sClient
81599>>>>>>>>>    End
81599>>>>>>>>>>
81599>>>>>>>>>
81599>>>>>>>>>    Function_Return sClient
81600>>>>>>>>>End_Function
81601>>>>>>>>>
81601>>>>>>>>>// *** Class Declarations: ***
81601>>>>>>>>>//
81601>>>>>>>>>Class cBitmapContainerDFLink is a BitmapContainer
81602>>>>>>>>>    Procedure Mouse_Click Integer iWindowNumber Integer iPosition
81604>>>>>>>>>        Send Mouse_Up iWindowNumber iPosition
81605>>>>>>>>>    End_Procedure
81606>>>>>>>>>    Procedure Mouse_Up Integer iWindowNumber Integer iPosition
81608>>>>>>>>>        Forward Send Mouse_Up iWindowNumber iPosition
81610>>>>>>>>>        Send Show_HomePage "http://www.dataaccess.com/"
81611>>>>>>>>>    End_Procedure
81612>>>>>>>>>End_Class
81613>>>>>>>>>
81613>>>>>>>>>Class cCopyEditorContentButton is a Button
81614>>>>>>>>>    Procedure Construct_Object
81616>>>>>>>>>        Forward Send Construct_Object
81618>>>>>>>>>        Property Handle phoEditorHandle
81619>>>>>>>>>        Set psToolTip to C_$DescCopy
81620>>>>>>>>>    End_Procedure
81621>>>>>>>>>
81621>>>>>>>>>    Procedure CopyToWindowsClipboard
81623>>>>>>>>>        Handle hoEditor
81623>>>>>>>>>        Boolean bCanCopy
81623>>>>>>>>>        Address aEditorAddress
81623>>>>>>>>>
81623>>>>>>>>>        Get phoEditorHandle to hoEditor
81624>>>>>>>>>        Send Select_All of hoEditor
81625>>>>>>>>>        Get CanCopy of hoEditor to bCanCopy
81626>>>>>>>>>        If (bCanCopy = True) Begin
81628>>>>>>>>>            Get paValue of hoEditor to aEditorAddress
81629>>>>>>>>>            Send Copy   of hoEditor
81630>>>>>>>>>            // Remove the selection after text is copied to the clipboard.
81630>>>>>>>>>            Send Beginning_of_Data of hoEditor
81631>>>>>>>>>            Send Info_Box C_$CopyToClipboard_Text
81632>>>>>>>>>        End
81632>>>>>>>>>>
81632>>>>>>>>>    End_Procedure
81633>>>>>>>>>End_Class
81634>>>>>>>>>
81634>>>>>>>>>Class SysinfoDisplay is a cTextEdit
81635>>>>>>>>>    Procedure Construct_Object
81637>>>>>>>>>        Forward Send Construct_Object
81639>>>>>>>>>
81639>>>>>>>>>        Set Size to 100 245
81640>>>>>>>>>        Set Location to 6 6
81641>>>>>>>>>        Set Border_Style to Border_None
81642>>>>>>>>>        Set Read_Only_State to True
81643>>>>>>>>>        Set pbWrap to True
81644>>>>>>>>>        Set peAnchors to anAll
81645>>>>>>>>>    End_Procedure
81646>>>>>>>>>
81646>>>>>>>>>    // Augmented class message to adjust certain text strings that are wrong...
81646>>>>>>>>>
81646>>>>>>>>>    Procedure AppendTextLn String sText
81648>>>>>>>>>        String sWorkspaceWSFile
81648>>>>>>>>>
81648>>>>>>>>>        // Only works for English:
81648>>>>>>>>>        If (ghoApplication > 0) Begin
81650>>>>>>>>>            If (sText contains "Workspace Name") Begin
81652>>>>>>>>>                Move "Workspace Config Filename:" to sText
81653>>>>>>>>>                Get psWorkspaceWSFile of (phoWorkspace(ghoApplication)) to sWorkspaceWSFile
81654>>>>>>>>>                Move (sText * sWorkspaceWSFile) to sText
81655>>>>>>>>>            End
81655>>>>>>>>>>
81655>>>>>>>>>        End
81655>>>>>>>>>>
81655>>>>>>>>>        Send AppendText sText
81656>>>>>>>>>        Send AppendText (character(10))
81657>>>>>>>>>    End_Procedure
81658>>>>>>>>>
81658>>>>>>>>>    //    This method will show the name Of the current directory in the system
81658>>>>>>>>>    //    information box
81658>>>>>>>>>    Procedure Show_Current_Directory
81660>>>>>>>>>        String sDir
81660>>>>>>>>>
81660>>>>>>>>>        Get_Current_Directory To sDir
81661>>>>>>>>>
81661>>>>>>>>>        Send AppendTextLn (SFormat (C_$CurrentDirectory, sDir))
81662>>>>>>>>>    End_Procedure
81663>>>>>>>>>
81663>>>>>>>>>    Procedure Show_Windows_Directory
81665>>>>>>>>>        String sWindir
81665>>>>>>>>>
81665>>>>>>>>>        Get_Windows_Directory To sWindir
81666>>>>>>>>>
81666>>>>>>>>>        Send AppendTextLn (SFormat (C_$WindowsDirectory, sWindir))
81667>>>>>>>>>    End_Procedure
81668>>>>>>>>>
81668>>>>>>>>>    Procedure Show_Current_User
81670>>>>>>>>>        Send AppendTextLn (SFormat (C_$Computer_Name, ComputerName (Self)))
81671>>>>>>>>>        Send AppendTextLn (SFormat (C_$NetworkUserName, Network_User_Name (Self)))
81672>>>>>>>>>    End_Procedure
81673>>>>>>>>>
81673>>>>>>>>>    Procedure Show_Number_Format
81675>>>>>>>>>        Integer iFormat
81675>>>>>>>>>        String sFormatText
81675>>>>>>>>>
81675>>>>>>>>>        Get_Attribute DF_THOUSANDS_SEPARATOR to iFormat
81678>>>>>>>>>        Move (Character (iFormat)) To sFormatText
81679>>>>>>>>>        Send AppendTextLn (SFormat (C_$ThousandsSeparator, sFormatText, iFormat))
81680>>>>>>>>>
81680>>>>>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iFormat
81683>>>>>>>>>        Move (Character (iFormat)) to sFormatText
81684>>>>>>>>>        Send AppendTextLn (SFormat (C_$DecimalSeparator, sFormatText))
81685>>>>>>>>>    End_Procedure
81686>>>>>>>>>
81686>>>>>>>>>    Procedure Show_Filelist_Name
81688>>>>>>>>>        String sFilename
81688>>>>>>>>>
81688>>>>>>>>>        Get_Attribute DF_FILELIST_NAME to sFilename
81691>>>>>>>>>
81691>>>>>>>>>        Send AppendTextLn (SFormat (C_$CurrentFilelist, sFilename))
81692>>>>>>>>>    End_Procedure
81693>>>>>>>>>
81693>>>>>>>>>    Procedure Show_Lock_Delay
81695>>>>>>>>>        Integer iLockdelay
81695>>>>>>>>>
81695>>>>>>>>>        Get_Attribute DF_LOCK_DELAY to iLockdelay
81698>>>>>>>>>
81698>>>>>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingDelay, iLockDelay))
81699>>>>>>>>>    End_Procedure
81700>>>>>>>>>
81700>>>>>>>>>    Procedure Show_Lock_Timeout
81702>>>>>>>>>        Integer iLockTimeout
81702>>>>>>>>>
81702>>>>>>>>>        Get_Attribute DF_LOCK_TIMEOUT to iLockTimeout
81705>>>>>>>>>
81705>>>>>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingTimeout, iLockTimeOut))
81706>>>>>>>>>    End_Procedure
81707>>>>>>>>>
81707>>>>>>>>>    Procedure Show_Screen_Size
81709>>>>>>>>>        Integer iYscreensize iXscreensize
81709>>>>>>>>>
81709>>>>>>>>>        Move (GetSystemMetrics (SM_CXSCREEN)) To iXscreensize
81710>>>>>>>>>        Move (GetSystemMetrics (SM_CYSCREEN)) To iYscreensize
81711>>>>>>>>>
81711>>>>>>>>>        Send AppendTextLn (SFormat (C_$VideoResolution, iXscreensize, iYscreensize))
81712>>>>>>>>>    End_Procedure
81713>>>>>>>>>
81713>>>>>>>>>    Procedure Show_Page_Size
81715>>>>>>>>>        Send AppendTextLn (SFormat (C_$PageEndFormFeed, Pageend, Pagefeed))
81716>>>>>>>>>    End_procedure
81717>>>>>>>>>
81717>>>>>>>>>    Procedure Show_Date
81719>>>>>>>>>        Date dToday
81719>>>>>>>>>
81719>>>>>>>>>        Move (CurrentDateTime()) to dToday
81720>>>>>>>>>
81720>>>>>>>>>        Send AppendTextLn (SFormat (C_$CurrentSystemDate, String (dToday)))
81721>>>>>>>>>    End_procedure
81722>>>>>>>>>
81722>>>>>>>>>    Procedure Show_Date_Format
81724>>>>>>>>>        Integer iDateFormat
81724>>>>>>>>>        String sDateFormat
81724>>>>>>>>>
81724>>>>>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
81727>>>>>>>>>        Case Begin
81727>>>>>>>>>            Case (iDateFormat = DF_DATE_USA)
81729>>>>>>>>>                Move C_$USA To sDateFormat
81730>>>>>>>>>                Case Break
81731>>>>>>>>>            Case (iDateFormat = DF_DATE_EUROPEAN)
81734>>>>>>>>>                Move C_$European To sDateFormat
81735>>>>>>>>>                Case Break
81736>>>>>>>>>            Case (iDateFormat = DF_DATE_MILITARY)
81739>>>>>>>>>                Move C_$Military To sDateFormat
81740>>>>>>>>>                Case Break
81741>>>>>>>>>            Case Else
81741>>>>>>>>>                Move C_$UnknownDateType To sDateFormat
81742>>>>>>>>>                Case Break
81743>>>>>>>>>        Case End
81743>>>>>>>>>
81743>>>>>>>>>        Send AppendTextLn (SFormat (C_$DateFormat, sDateformat))
81744>>>>>>>>>    End_Procedure
81745>>>>>>>>>
81745>>>>>>>>>    // 2013-08-14 NGS
81745>>>>>>>>>    // Unformatted numeric values shown doesn't look good. These looks much better.
81745>>>>>>>>>    Procedure Show_Systemresources
81747>>>>>>>>>        tWinMemoryStatusEx MemoryStatusInfo
81747>>>>>>>>>        tWinMemoryStatusEx MemoryStatusInfo
81747>>>>>>>>>        Integer iRetval
81747>>>>>>>>>        Number nValue
81747>>>>>>>>>        String sValue
81747>>>>>>>>>
81747>>>>>>>>>        Move (SizeOfType (tWinMemoryStatusEx)) to MemoryStatusInfo.dwLength
81748>>>>>>>>>        Move (GlobalMemoryStatusEx (AddressOf (MemoryStatusInfo))) to iRetval
81749>>>>>>>>>        If (iRetval = 0) Begin
81751>>>>>>>>>            Move (ShowLastError ()) to iRetval
81752>>>>>>>>>            Procedure_Return
81753>>>>>>>>>        End
81753>>>>>>>>>>
81753>>>>>>>>>
81753>>>>>>>>>        Send AppendTextLn ""
81754>>>>>>>>>        Move MemoryStatusInfo.ullTotalPhys to nValue
81755>>>>>>>>>
81755>>>>>>>>>        // Show memory in Gigabytes:
81755>>>>>>>>>        Move (nValue/1024/1024/1024) to nValue
81756>>>>>>>>>        Move (Round(nValue)) to nValue
81757>>>>>>>>>        Get FormatNumber nValue 2 to sValue
81758>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailableMemory, (sValue * "GB")))
81759>>>>>>>>>        Send AppendTextLn (SFormat (C_$MemoryUtilization, String(MemoryStatusInfo.dwMemoryLoad) * "%"))
81760>>>>>>>>>
81760>>>>>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, Real (MemoryStatusInfo.ullAvailPhys) / Real (MemoryStatusInfo.ullTotalPhys) * 100.0))
81760>>>>>>>>>        Move (Real(MemoryStatusInfo.ullAvailPhys) / Real(MemoryStatusInfo.ullTotalPhys) * 100.0) to nValue
81761>>>>>>>>>        Move (Round(nValue)) to nValue
81762>>>>>>>>>        Get FormatNumber nValue 0 to sValue
81763>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, (sValue * "%")))
81764>>>>>>>>>
81764>>>>>>>>>//        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, Real (MemoryStatusInfo.ullAvailPageFile) / Real (MemoryStatusInfo.ullTotalPageFile) * 100.0))
81764>>>>>>>>>        Move (Real(MemoryStatusInfo.ullAvailPageFile) / Real(MemoryStatusInfo.ullTotalPageFile) * 100.0) to nValue
81765>>>>>>>>>        Move (Round(nValue)) to nValue
81766>>>>>>>>>        Get FormatNumber nValue 0 to sValue
81767>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, (sValue * "%")))
81768>>>>>>>>>
81768>>>>>>>>>//        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, Real (MemoryStatusInfo.ullAvailVirtual) / Real (MemoryStatusInfo.ullTotalVirtual) * 100.0))
81768>>>>>>>>>        Move (Real(MemoryStatusInfo.ullAvailVirtual) / Real(MemoryStatusInfo.ullTotalVirtual) * 100.0) to nValue
81769>>>>>>>>>        Move (Round(nValue)) to nValue
81770>>>>>>>>>        Get FormatNumber nValue 0 to sValue
81771>>>>>>>>>        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, (sValue * "%")))
81772>>>>>>>>>
81772>>>>>>>>>        // Add an empty row after the memory information:
81772>>>>>>>>>        Send AppendTextLn ""
81773>>>>>>>>>    End_Procedure
81774>>>>>>>>>
81774>>>>>>>>>    Procedure Show_Registration
81776>>>>>>>>>        String sRegName
81776>>>>>>>>>        Integer iSN iUsersMax iUserCount
81776>>>>>>>>>
81776>>>>>>>>>        Registration sRegName iSN
81777>>>>>>>>>>
81777>>>>>>>>>        Get_Licensed_Max_Users to iUsersMax
81778>>>>>>>>>        Get_Current_User_Count to iUserCount
81779>>>>>>>>>
81779>>>>>>>>>        Send AppendTextLn (SFormat (C_$Serial, iSN))
81780>>>>>>>>>        Send AppendTextLn (SFormat (C_$RegName, sRegName))
81781>>>>>>>>>        Send AppendTextLn (SFormat (C_$Current_User_Count, iUserCount))
81782>>>>>>>>>        Send AppendTextLn (SFormat (C_$Max_Licensed_User_Count, iUsersMax))
81783>>>>>>>>>    End_Procedure
81784>>>>>>>>>
81784>>>>>>>>>    //****************************************************************************
81784>>>>>>>>>    // If workspaces are used, we will send the message EnumerateWorkspaceData
81784>>>>>>>>>    // To the workspace object passing the an object and message To send back
81784>>>>>>>>>    // To this object. It is expected that the workspace object will send this
81784>>>>>>>>>    // message for every line Of information it wants displayed (passing the
81784>>>>>>>>>    // information To be displayed
81784>>>>>>>>>    //****************************************************************************
81784>>>>>>>>>    Register_Procedure EnumerateWorkspaceData Integer hObjId Integer hmMessId
81784>>>>>>>>>
81784>>>>>>>>>    Procedure Show_ServicePack
81786>>>>>>>>>        String sKey sVersion sDataFlex
81786>>>>>>>>>        Handle hoRegistry
81786>>>>>>>>>        Boolean bExists bOpened
81786>>>>>>>>>
81786>>>>>>>>>        Move "DataFlex"        to sDataFlex
81787>>>>>>>>>
81787>>>>>>>>>        Get Create (RefClass(cRegistry)) to hoRegistry
81788>>>>>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
81789>>>>>>>>>        Set pfAccessRights of hoRegistry to KEY_READ
81790>>>>>>>>>        Get KeyExists of hoRegistry "SOFTWARE\Wow6432Node" to bExists
81791>>>>>>>>>
81791>>>>>>>>>        If (bExists) Begin
81793>>>>>>>>>            Move ("SOFTWARE\Wow6432Node\Data Access Worldwide\" + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
81794>>>>>>>>>        End
81794>>>>>>>>>>
81794>>>>>>>>>        Else Begin
81795>>>>>>>>>            Move ("SOFTWARE\Data Access Worldwide\"             + sDataFlex + "\" + SysConf (SYSCONF_DATAFLEX_REV)) to sKey
81796>>>>>>>>>        End
81796>>>>>>>>>>
81796>>>>>>>>>        Get KeyExists of hoRegistry sKey to bExists
81797>>>>>>>>>        If (bExists) Begin
81799>>>>>>>>>            Get OpenKey of hoRegistry sKey to bOpened
81800>>>>>>>>>            If (bOpened) Begin
81802>>>>>>>>>                Get ValueExists of hoRegistry "CurrentVersionDescription" to bExists
81803>>>>>>>>>                If (bExists) Begin
81805>>>>>>>>>                    Get ReadString of hoRegistry "CurrentVersionDescription" to sVersion
81806>>>>>>>>>                End
81806>>>>>>>>>>
81806>>>>>>>>>                Send CloseKey of hoRegistry
81807>>>>>>>>>            End
81807>>>>>>>>>>
81807>>>>>>>>>        End
81807>>>>>>>>>>
81807>>>>>>>>>        Send Destroy of hoRegistry
81808>>>>>>>>>
81808>>>>>>>>>        If (sVersion <> "") Begin
81810>>>>>>>>>           Send AppendTextLn sVersion
81811>>>>>>>>>           Send AppendTextLn ""
81812>>>>>>>>>        End
81812>>>>>>>>>>
81812>>>>>>>>>    End_Procedure
81813>>>>>>>>>
81813>>>>>>>>>    Procedure Show_WorkspaceInformation
81815>>>>>>>>>        Integer hoWorkspace
81815>>>>>>>>>
81815>>>>>>>>>        If (ghoApplication <> 0) Begin
81817>>>>>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
81818>>>>>>>>>            If (hoWorkspace <> 0) Begin
81820>>>>>>>>>                Send EnumerateWorkspaceData of hoWorkspace Self msg_AppendTextLn
81821>>>>>>>>>            End
81821>>>>>>>>>>
81821>>>>>>>>>        End
81821>>>>>>>>>>
81821>>>>>>>>>    End_Procedure
81822>>>>>>>>>
81822>>>>>>>>>    //****************************************************************************
81822>>>>>>>>>    // If connection ids are used, we will send the message EnumerateConnections
81822>>>>>>>>>    // to the connection manager object passing the an object and message to send
81822>>>>>>>>>    // back to this object. It is expected that the connection manager object will
81822>>>>>>>>>    // send this message for every line Of information it wants displayed (passing
81822>>>>>>>>>    // the information To be displayed
81822>>>>>>>>>    //****************************************************************************
81822>>>>>>>>>    Register_Procedure EnumerateConnections Integer hObjId Integer hmMessId
81822>>>>>>>>>
81822>>>>>>>>>    Procedure Show_ConnectionIdInformation
81824>>>>>>>>>        If (ghoConnection > 0) Begin
81826>>>>>>>>>            Send EnumerateConnections of ghoConnection Self (RefProc(AppendTextLn))
81827>>>>>>>>>            Send AppendTextLn ""
81828>>>>>>>>>        End
81828>>>>>>>>>>
81828>>>>>>>>>    End_Procedure
81829>>>>>>>>>
81829>>>>>>>>>    Function VersionStr Integer iVer Integer iRev Integer iBld Returns String
81831>>>>>>>>>        Function_Return (String (iVer) - "." - String (iRev) - "." - String (iBld))
81832>>>>>>>>>    End_Function
81833>>>>>>>>>
81833>>>>>>>>>    Procedure Show_Versions
81835>>>>>>>>>        Integer iVersion iRevision iBuild
81835>>>>>>>>>
81835>>>>>>>>>        Version_information iVersion iRevision iBuild
81837>>>>>>>>>
81837>>>>>>>>>        Send AppendTextLn (SFormat (C_$RuntimeVersion, VersionStr(self,iVersion,iRevision,iBuild) ))
81838>>>>>>>>>        Send AppendTextLn (SFormat (C_$PackageVersion, VersionStr(self,PKG_VERSION, PKG_REVISION, PKG_BUILD) ))
81839>>>>>>>>>        Send AppendTextLn (SFormat (C_$FMACVersion, VersionStr(self,FMAC_VERSION, FMAC_REVISION, FMAC_BUILD) ))
81840>>>>>>>>>        Send AppendTextLn "This is a 32-bit exe file"
81841>>>>>>>>>    End_Procedure
81842>>>>>>>>>
81842>>>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
81844>>>>>>>>>        Boolean bOK
81844>>>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) to bOK
81845>>>>>>>>>        Function_Return bOK
81846>>>>>>>>>    End_Function
81847>>>>>>>>>
81847>>>>>>>>>    Function IsMertechDriver String sDriverID Returns Boolean
81849>>>>>>>>>        Boolean bOK
81849>>>>>>>>>        Move (sDriverID = SQLFLEX or sDriverID = ORAFLEX or sDriverID = MDSPgSQL or sDriverID = MySQLFlex) to bOK
81850>>>>>>>>>        Function_Return bOK
81851>>>>>>>>>    End_Function
81852>>>>>>>>>
81852>>>>>>>>>    //***
81852>>>>>>>>>    //*** BW
81852>>>>>>>>>    //*** Procedure: Show_Drivers
81852>>>>>>>>>    //*** Purpose  : Show loaded database drivers
81852>>>>>>>>>    //***
81852>>>>>>>>>
81852>>>>>>>>>    Procedure Show_Drivers
81854>>>>>>>>>        String sDriverID sVersion sClient sValue
81854>>>>>>>>>        Integer iNumberOfDrivers iDriver iClient iUsersMax iSerialNo iNumServers iCount
81854>>>>>>>>>        Handle hoCLIHandler hoBtrvHandler
81854>>>>>>>>>        Boolean bStudioLicense bIsDAWDriver bIsMertechDriver
81854>>>>>>>>>
81854>>>>>>>>>        Move False to bStudioLicense
81855>>>>>>>>>
81855>>>>>>>>>        Get Create (RefClass(cCLIHandler))      to hoCLIHandler
81856>>>>>>>>>        Get Create (RefClass(cDFBtrDrvHandler)) to hoBtrvHandler
81857>>>>>>>>>
81857>>>>>>>>>        // For testing purposes:
81857>>>>>>>>>//        Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
81857>>>>>>>>>//        Load_Driver MSSQLDRV_ID
81857>>>>>>>>>//        Load_Driver ODBC_DRV_ID
81857>>>>>>>>>//        Load_Driver DB2_DRV_ID
81857>>>>>>>>>//        Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
81857>>>>>>>>>//
81857>>>>>>>>>//        #IFDEF DUF_Use_Mertech_Drivers
81857>>>>>>>>>//            Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
81857>>>>>>>>>//            Load_Driver SQLFLEX
81857>>>>>>>>>//            Load_Driver MDSPgSQL
81857>>>>>>>>>//            Load_Driver MDSMySQL
81857>>>>>>>>>//            Load_Driver ORAFLEX
81857>>>>>>>>>//            Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
81857>>>>>>>>>//        #ENDIF
81857>>>>>>>>>        Move False to Err
81858>>>>>>>>>
81858>>>>>>>>>        // Loop through all loaded drivers.
81858>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
81861>>>>>>>>>        If (iNumberOfDrivers > 1) Begin
81863>>>>>>>>>            Send AppendTextLn ""
81864>>>>>>>>>        End
81864>>>>>>>>>>
81864>>>>>>>>>        For iDriver from 1 to iNumberOfDrivers
81870>>>>>>>>>>
81870>>>>>>>>>            // For some weird reason it can happen that - when using Mertech drivers - that the driver index
81870>>>>>>>>>            // was increased in the CLI array, but it has no value. In that case a "Bad parameter..." error
81870>>>>>>>>>            // would be thrown, so we safeguard from that here.
81870>>>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
81871>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iDriver to sDriverID
81874>>>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
81875>>>>>>>>>            Get IsDAWSQLDriver  sDriverID to bIsDAWDriver
81876>>>>>>>>>            Get IsMertechDriver sDriverID to bIsMertechDriver
81877>>>>>>>>>
81877>>>>>>>>>            If (sDriverID = DFBTRDRV_ID or bIsDAWDriver = True or bIsMertechDriver = True) Begin
81879>>>>>>>>>
81879>>>>>>>>>                // Pervasive/Btrieve database
81879>>>>>>>>>                If (sDriverID = DFBTRDRV_ID) Begin
81881>>>>>>>>>                    Get CKRevision of hoBtrvHandler to sVersion
81882>>>>>>>>>                    Get PSQLLocalEngineVersionInfo of hoBtrvHandler 0 to sClient
81883>>>>>>>>>                    If (sClient <> "0.0.0") Begin
81885>>>>>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Local_Engine_Version, sClient))
81886>>>>>>>>>                    End
81886>>>>>>>>>>
81886>>>>>>>>>                    Get PSQLServerEngineVersionInfo of hoBtrvHandler 0 to sClient
81887>>>>>>>>>                    If (sClient <> "0.0.0") Begin
81889>>>>>>>>>                        Send AppendTextLn (SFormat (C_$Pervasive_Server_Engine_Version, sClient))
81890>>>>>>>>>                    End
81890>>>>>>>>>>
81890>>>>>>>>>                End
81890>>>>>>>>>>
81890>>>>>>>>>
81890>>>>>>>>>                Else Begin
81891>>>>>>>>>                    Set psDriverID of hoCLIHandler to sDriverID
81892>>>>>>>>>                    Move 0 to iNumServers
81893>>>>>>>>>                    If (sDriverID <> DATAFLEX_ID) Begin
81895>>>>>>>>>                        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iNumServers
81898>>>>>>>>>                    End
81898>>>>>>>>>>
81898>>>>>>>>>
81898>>>>>>>>>                    If (bIsDAWDriver = True) Begin
81900>>>>>>>>>                        If (sDriverID = MSSQLDRV_ID) Begin
81902>>>>>>>>>                            Get SQLClientVersion sDriverID iClient to sClient
81903>>>>>>>>>                        End
81903>>>>>>>>>>
81903>>>>>>>>>                        Get CKRevision of hoCLIHandler to sVersion
81904>>>>>>>>>                    End
81904>>>>>>>>>>
81904>>>>>>>>>
81904>>>>>>>>>                    If (bIsMertechDriver = True) Begin
81906>>>>>>>>>                        GET_DRIVER_REVISION to sVersion
81943>>>>>>>>>>
81943>>>>>>>>>                    End
81943>>>>>>>>>>
81943>>>>>>>>>
81943>>>>>>>>>                    // If the serialnumber is = 0, it means that the
81943>>>>>>>>>                    // Studio licens is in use and there is no
81943>>>>>>>>>                    // number of max users defined because the driver is
81943>>>>>>>>>                    // relying on the info from the VDF license.
81943>>>>>>>>>                    If (bStudioLicense = False) Begin
81945>>>>>>>>>                        Get SerialNumber of hoCLIHandler to iSerialNo
81946>>>>>>>>>                        Move (iSerialNo = 0) to bStudioLicense
81947>>>>>>>>>                    End
81947>>>>>>>>>>
81947>>>>>>>>>                End
81947>>>>>>>>>>
81947>>>>>>>>>                Send AppendTextLn (SFormat (C_$DatabaseDriver, (sDriverID * "-" * (C_$Version + ": " + sVersion))))
81948>>>>>>>>>                If (sClient <> "" and sDriverID = MSSQLDRV_ID) Begin
81950>>>>>>>>>                    Send AppendTextLn (C_$SQL_Client_Text * sClient)
81951>>>>>>>>>                End
81951>>>>>>>>>>
81951>>>>>>>>>                If (iNumServers <> 0) Begin
81953>>>>>>>>>                    For iCount from 1 to iNumServers
81959>>>>>>>>>>
81959>>>>>>>>>                        Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
81962>>>>>>>>>                        If (not(sValue contains ";PWD=")) Begin
81964>>>>>>>>>                            Send AppendTextLn ("    " + C_$SQLServerText * sValue)
81965>>>>>>>>>                        End
81965>>>>>>>>>>
81965>>>>>>>>>                    Loop
81966>>>>>>>>>>
81966>>>>>>>>>                End
81966>>>>>>>>>>
81966>>>>>>>>>            End
81966>>>>>>>>>>
81966>>>>>>>>>        Loop
81967>>>>>>>>>>
81967>>>>>>>>>
81967>>>>>>>>>        Send AppendTextLn ""
81968>>>>>>>>>        If (bStudioLicense = False) Begin
81970>>>>>>>>>            Get MaxUsers of hoCLIHandler to iUsersMax
81971>>>>>>>>>            Send AppendTextLn (SFormat (C_$Max_DbDriver_Licensed_User_Count, iUsersMax))
81972>>>>>>>>>        End
81972>>>>>>>>>>
81972>>>>>>>>>        Else Begin
81973>>>>>>>>>            Send AppendTextLn C_$DF_Studio_License_Text
81974>>>>>>>>>        End
81974>>>>>>>>>>
81974>>>>>>>>>        Send Destroy of hoCLIHandler
81975>>>>>>>>>        Send Destroy of hoBtrvHandler
81976>>>>>>>>>    End_Procedure
81977>>>>>>>>>
81977>>>>>>>>>    Procedure Show_HelpFile
81979>>>>>>>>>        String sHelpFile
81979>>>>>>>>>        Integer eHelpType
81979>>>>>>>>>
81979>>>>>>>>>        If (ghoApplication <> 0) Begin
81981>>>>>>>>>            Get peHelpType Of ghoApplication To eHelpType
81982>>>>>>>>>            If (eHelpType = htHtmlHelp and ghoHtmlHelp) Begin
81984>>>>>>>>>                Get GetHelpFile Of ghoHtmlHelp To sHelpFile
81985>>>>>>>>>            End
81985>>>>>>>>>>
81985>>>>>>>>>            Else If (eHelpType = htWinHelp and Help_object_id) Begin
81988>>>>>>>>>                Get Help_filename Of Help_object_id To sHelpFile
81989>>>>>>>>>            End
81989>>>>>>>>>>
81989>>>>>>>>>            Else Begin
81990>>>>>>>>>                Move C_$ThereIsNoHelpfileDefined To sHelpFile
81991>>>>>>>>>            End
81991>>>>>>>>>>
81991>>>>>>>>>
81991>>>>>>>>>            Send AppendTextLn (SFormat (C_$HelpFile, sHelpFile))
81992>>>>>>>>>        End
81992>>>>>>>>>>
81992>>>>>>>>>    End_Procedure
81993>>>>>>>>>
81993>>>>>>>>>    Procedure Show_EnterAsTab
81995>>>>>>>>>        Boolean bEnterKeyAsTabKey
81995>>>>>>>>>        String sText
81995>>>>>>>>>
81995>>>>>>>>>        If (ghoApplication <> 0) Begin
81997>>>>>>>>>            Get pbEnterKeyAsTabKey Of ghoApplication To bEnterKeyAsTabKey
81998>>>>>>>>>            If (bEnterKeyAsTabKey) Begin
82000>>>>>>>>>                Move "True" To sText
82001>>>>>>>>>            End
82001>>>>>>>>>>
82001>>>>>>>>>            Else Begin
82002>>>>>>>>>                Move "False" To sText
82003>>>>>>>>>            End
82003>>>>>>>>>>
82003>>>>>>>>>            Send AppendTextLn (SFormat (C_$EnterKeyNavForward, sText))
82004>>>>>>>>>        End
82004>>>>>>>>>>
82004>>>>>>>>>    End_Procedure
82005>>>>>>>>>
82005>>>>>>>>>    //    During activation we will remove the old information and add the newly
82005>>>>>>>>>    //    found systeminformation
82005>>>>>>>>>    Procedure Add_Focus Integer hoRoot
82007>>>>>>>>>        Forward Send Add_Focus hoRoot
82009>>>>>>>>>
82009>>>>>>>>>        Send Delete_Data
82010>>>>>>>>>
82010>>>>>>>>>        Set Changed_State To False
82011>>>>>>>>>        Set Read_Only_State To True
82012>>>>>>>>>
82012>>>>>>>>>        Send Show_Registration
82013>>>>>>>>>        Send Show_Drivers
82014>>>>>>>>>        Send Show_ServicePack
82015>>>>>>>>>        Send Show_Versions
82016>>>>>>>>>        Send AppendTextLn ""
82017>>>>>>>>>
82017>>>>>>>>>        If (ghoApplication <> 0) Begin
82019>>>>>>>>>            Send Show_WorkSpaceInformation
82020>>>>>>>>>            Send Show_HelpFile
82021>>>>>>>>>            Send AppendTextLn ""
82022>>>>>>>>>        End
82022>>>>>>>>>>
82022>>>>>>>>>        Else Begin
82023>>>>>>>>>            Send AppendTextLn ""
82024>>>>>>>>>        End
82024>>>>>>>>>>
82024>>>>>>>>>
82024>>>>>>>>>        If (ghoConnection <> 0) Begin
82026>>>>>>>>>            Send Show_ConnectionIdInformation
82027>>>>>>>>>        End
82027>>>>>>>>>>
82027>>>>>>>>>
82027>>>>>>>>>        Send Show_Current_User
82028>>>>>>>>>        Send Show_Windows_Directory
82029>>>>>>>>>        Send Show_Current_Directory
82030>>>>>>>>>
82030>>>>>>>>>        // This is already shown in the workspace details,
82030>>>>>>>>>        // unless no workspace object is present:
82030>>>>>>>>>        If (ghoApplication = 0) Begin
82032>>>>>>>>>            Send Show_Filelist_Name
82033>>>>>>>>>        End
82033>>>>>>>>>>
82033>>>>>>>>>
82033>>>>>>>>>        If (ghoApplication <> 0) Begin
82035>>>>>>>>>            Send AppendTextLn ""
82036>>>>>>>>>            Send Show_EnterAsTab
82037>>>>>>>>>        End
82037>>>>>>>>>>
82037>>>>>>>>>
82037>>>>>>>>>        Send Show_Screen_Size
82038>>>>>>>>>        Send Show_Page_Size
82039>>>>>>>>>        Send Show_Number_Format
82040>>>>>>>>>        Send Show_Date_Format
82041>>>>>>>>>        Send Show_Lock_Delay
82042>>>>>>>>>        Send Show_Lock_Timeout
82043>>>>>>>>>        Send Show_Date
82044>>>>>>>>>        Send Show_Systemresources
82045>>>>>>>>>        Send Beginning_of_Data
82046>>>>>>>>>
82046>>>>>>>>>        Set Icon to 'default.ico'
82047>>>>>>>>>    End_Procedure
82048>>>>>>>>>End_Class
82049>>>>>>>>>
82049>>>>>>>>>Class SysInfoDialog is a ModalPanel
82050>>>>>>>>>    Procedure Construct_Object
82052>>>>>>>>>        Forward Send Construct_Object
82054>>>>>>>>>
82054>>>>>>>>>        Set Label to C_$SystemInformation
82055>>>>>>>>>        Set Size to 140 267
82056>>>>>>>>>        Set Locate_Mode to CENTER_ON_PARENT
82057>>>>>>>>>        Set Border_Style to Border_Thick
82058>>>>>>>>>        Set Sysmenu_Icon to False
82059>>>>>>>>>
82059>>>>>>>>>        // "+1" will make the panel to paint correctly.
82059>>>>>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)) +1)
82060>>>>>>>>>
82060>>>>>>>>>        // 2014-09-14 NGS
82060>>>>>>>>>        // Added a container object around the cTexteditor
82060>>>>>>>>>        // object to get a border around the text.
82060>>>>>>>>>        Object oSysinfoDisplayContainer is a Container3d
82062>>>>>>>>>            Set Location to 2 4
82063>>>>>>>>>            Set Size to 110 255
82064>>>>>>>>>            Set Border_Style to Border_ClientEdge
82065>>>>>>>>>            Set Color to clWhite
82066>>>>>>>>>            Set peAnchors to anAll
82067>>>>>>>>>
82067>>>>>>>>>            Object oSysinfoDisplay is a SysInfoDisplay
82069>>>>>>>>>            End_Object
82070>>>>>>>>>
82070>>>>>>>>>        End_Object
82071>>>>>>>>>
82071>>>>>>>>>        Object oCloseButton is a Button
82073>>>>>>>>>            Set Label to C_$Close
82074>>>>>>>>>            Set Location to 120 210
82075>>>>>>>>>            Set Message item 0 to msg_Close_Panel
82076>>>>>>>>>            Set Default_State To True
82077>>>>>>>>>            // In case someone likes to make the AboutDialog's Border_Style to thick,
82077>>>>>>>>>            // and changes its peAnchors, we might as well prepare this object
82077>>>>>>>>>            // for that situation.
82077>>>>>>>>>            Set peAnchors to anBottomRight
82078>>>>>>>>>        End_Object
82079>>>>>>>>>
82079>>>>>>>>>        Object oCopyButton is a cCopyEditorContentButton
82081>>>>>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
82082>>>>>>>>>            Set Size to 14 50
82083>>>>>>>>>            Set Location to 120 158
82084>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
82084>>>>>>>>>            // we might as well prepare the object for it.
82084>>>>>>>>>            Set peAnchors to anBottomRight
82085>>>>>>>>>            Set phoEditorHandle to (oSysinfoDisplay(Self))
82086>>>>>>>>>        End_Object
82087>>>>>>>>>
82087>>>>>>>>>        On_Key kCancel Send Close_Panel
82088>>>>>>>>>    End_Procedure
82089>>>>>>>>>
82089>>>>>>>>>    Procedure Page Integer iPageObject
82091>>>>>>>>>        Handle hMenu
82091>>>>>>>>>        Integer iPrevState
82091>>>>>>>>>
82091>>>>>>>>>        Forward Send Page iPageObject
82093>>>>>>>>>
82093>>>>>>>>>        // Ok, this seems to have been fixed in VDF 17.1!
82093>>>>>>>>>        //
82093>>>>>>>>>    End_Procedure
82094>>>>>>>>>
82094>>>>>>>>>End_Class
82095>>>>>>>>>
82095>>>>>>>>>Class cAboutEdit is an cRichEdit
82096>>>>>>>>>    Procedure Construct_Object
82098>>>>>>>>>        Forward Send Construct_Object
82100>>>>>>>>>
82100>>>>>>>>>        Property String psContentText
82101>>>>>>>>>
82101>>>>>>>>>        Set Size to 77 153
82102>>>>>>>>>        Set Location to 8 60
82103>>>>>>>>>        Set Read_Only_State to True
82104>>>>>>>>>        Set Skip_State to True
82105>>>>>>>>>        // Font size is calculated in "Twips", which are 1/1440 of an inch,
82105>>>>>>>>>        // or 1/20 of a printer's point.
82105>>>>>>>>>        Set piRightMargin to (0.1 * 1440)
82106>>>>>>>>>        Set Border_Style  to Border_None
82107>>>>>>>>>    End_Procedure
82108>>>>>>>>>
82108>>>>>>>>>    // Adds a line of text to the edit object
82108>>>>>>>>>    Procedure Add_Line String sText
82110>>>>>>>>>        String sContentText
82110>>>>>>>>>        Get psContentText to sContentText
82111>>>>>>>>>        Move (sContentText + String(sText)) to sContentText
82112>>>>>>>>>        Set psContentText to sContentText
82113>>>>>>>>>    End_Procedure
82114>>>>>>>>>
82114>>>>>>>>>    // Compared to Add_Line above, this adds an extra empty line after the passed value.
82114>>>>>>>>>    // Note that we use a property psContentText and add to it,
82114>>>>>>>>>    // because the object isn't paged yet when we add these
82114>>>>>>>>>    // values and the COM edit object needs to be paged
82114>>>>>>>>>    // for the text to become visible. See Also: Procedure Page below.
82114>>>>>>>>>    Procedure Add_LineLn String sText
82116>>>>>>>>>        String sContentText sCR
82116>>>>>>>>>
82116>>>>>>>>>        Move (Character(10) + String(Character(13))) to sCR
82117>>>>>>>>>        Get psContentText to sContentText
82118>>>>>>>>>        Move (sContentText + String(sText) + sCR) to sContentText
82119>>>>>>>>>        Set psContentText to sContentText
82120>>>>>>>>>    End_Procedure
82121>>>>>>>>>
82121>>>>>>>>>    Procedure OnLinkClicked Integer iPositionStart Integer iPositionEnd
82123>>>>>>>>>        String sLinkText
82123>>>>>>>>>        Get TextRange iPositionStart iPositionEnd to sLinkText
82124>>>>>>>>>        Send Show_HomePage sLinkText
82125>>>>>>>>>    End_Procedure
82126>>>>>>>>>
82126>>>>>>>>>    Procedure Page Integer iPageObject
82128>>>>>>>>>        String sContentText
82128>>>>>>>>>
82128>>>>>>>>>        Forward Send Page iPageObject
82130>>>>>>>>>        Get psContentText to sContentText
82131>>>>>>>>>        Send AppendText sContentText
82132>>>>>>>>>        send Beginning_of_Data
82133>>>>>>>>>    End_Procedure
82134>>>>>>>>>
82134>>>>>>>>>End_Class
82135>>>>>>>>>
82135>>>>>>>>>Class AboutDialog is a ModalPanel
82136>>>>>>>>>    Procedure Construct_Object
82138>>>>>>>>>
82138>>>>>>>>>        Forward Send Construct_Object
82140>>>>>>>>>
82140>>>>>>>>>        Set Label to C_$About
82141>>>>>>>>>        Set Size to 118 230
82142>>>>>>>>>        Set Locate_Mode to CENTER_ON_PARENT
82143>>>>>>>>>        Set Border_Style to Border_Thick
82144>>>>>>>>>        Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
82145>>>>>>>>>
82145>>>>>>>>>        Object oSysInfoDialog is a SysInfoDialog
82147>>>>>>>>>        End_Object
82148>>>>>>>>>
82148>>>>>>>>>        Object oBox is a Container3d
82150>>>>>>>>>            Set Border_Style to Border_Normal
82151>>>>>>>>>            Set Size to 90 220
82152>>>>>>>>>            Set Location to 4 5
82153>>>>>>>>>            Set Color to clWhite
82154>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
82154>>>>>>>>>            // we might as well prepare the object for it.
82154>>>>>>>>>            Set peAnchors to anAll
82155>>>>>>>>>
82155>>>>>>>>>            Object oAboutGraphic is a BitmapContainer
82157>>>>>>>>>                Set Border_Style To Border_None
82158>>>>>>>>>                Set Bitmap_Style to Bitmap_Center
82159>>>>>>>>>                Set Color to clWhite
82160>>>>>>>>>                Set Size to 45 50
82161>>>>>>>>>                Set Location to 0 3
82162>>>>>>>>>            End_Object
82163>>>>>>>>>
82163>>>>>>>>>            Object oPoweredByDFGraphic is a cBitmapContainerDFLink
82165>>>>>>>>>                Set Border_Style to Border_None
82166>>>>>>>>>                Set Bitmap_Style to Bitmap_Center
82167>>>>>>>>>                Set Color to clWhite
82168>>>>>>>>>                Set Size to 30 55
82169>>>>>>>>>                Set Location to 50 3
82170>>>>>>>>>            End_Object
82171>>>>>>>>>
82171>>>>>>>>>            Object oInfoList_Editor is an cAboutEdit
82173>>>>>>>>>                // In case someone wants to set the AboutDialog's Border_Style to thick,
82173>>>>>>>>>                // we might as well prepare the object for it.
82173>>>>>>>>>                Set peAnchors to anAll
82174>>>>>>>>>            End_Object
82175>>>>>>>>>
82175>>>>>>>>>            // These objects are here for backwards compatability only.
82175>>>>>>>>>            // They are not used.
82175>>>>>>>>>            Object oProductName is a TextBox
82177>>>>>>>>>                Set Label To C_$ProductName
82178>>>>>>>>>                Set Size To 10 45
82179>>>>>>>>>                Set Location To 8 53
82180>>>>>>>>>                Set Visible_State to False
82181>>>>>>>>>                Set Focus_Mode to NonFocusable
82182>>>>>>>>>            End_Object
82183>>>>>>>>>
82183>>>>>>>>>            Object oVersion is a TextBox
82185>>>>>>>>>                Set Label To C_$Version
82186>>>>>>>>>                Set Size To 10 25
82187>>>>>>>>>                Set Location To 21 53
82188>>>>>>>>>                Set Visible_State to False
82189>>>>>>>>>                Set Focus_Mode to NonFocusable
82190>>>>>>>>>            End_Object
82191>>>>>>>>>
82191>>>>>>>>>            Object oCopyright is a TextBox
82193>>>>>>>>>                Set Label To C_$Copyright
82194>>>>>>>>>                Set Size To 10 31
82195>>>>>>>>>                Set Location To 34 53
82196>>>>>>>>>                Set Visible_State to False
82197>>>>>>>>>                Set Focus_Mode to NonFocusable
82198>>>>>>>>>            End_Object
82199>>>>>>>>>
82199>>>>>>>>>            Object oAuthor is a TextBox
82201>>>>>>>>>                Set Label To C_$Author
82202>>>>>>>>>                Set Size To 10 22
82203>>>>>>>>>                Set Location To 46 53
82204>>>>>>>>>                Set Visible_State to False
82205>>>>>>>>>                Set Focus_Mode to NonFocusable
82206>>>>>>>>>            End_Object
82207>>>>>>>>>
82207>>>>>>>>>        End_Object
82208>>>>>>>>>
82208>>>>>>>>>        Object oOKButton is a Button
82210>>>>>>>>>            On_Item C_$Close Send Close_Panel
82211>>>>>>>>>            Set Location to 98 176
82212>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
82212>>>>>>>>>            // we might as well prepare the object for it.
82212>>>>>>>>>            Set peAnchors to anBottomRight
82213>>>>>>>>>        End_Object
82214>>>>>>>>>
82214>>>>>>>>>        Object oSysInfoButton is a Button
82216>>>>>>>>>            On_Item C_$SystemInfo Send Show_Sysinfo
82217>>>>>>>>>            Set Location to 98 123
82218>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
82218>>>>>>>>>            // we might as well prepare the object for it.
82218>>>>>>>>>            Set peAnchors to anBottomRight
82219>>>>>>>>>        End_Object
82220>>>>>>>>>
82220>>>>>>>>>        Object oCopyButton is a cCopyEditorContentButton
82222>>>>>>>>>            On_Item C_$Copy Send CopyToWindowsClipboard
82223>>>>>>>>>            Set Size to 14 50
82224>>>>>>>>>            Set Location to 98 70
82225>>>>>>>>>            // In case someone wants to set the AboutDialog's Border_Style to thick,
82225>>>>>>>>>            // we might as well prepare the object for it.
82225>>>>>>>>>            Set peAnchors to anBottomRight
82226>>>>>>>>>            Set phoEditorHandle to (oInfoList_Editor(Self))
82227>>>>>>>>>        End_Object
82228>>>>>>>>>
82228>>>>>>>>>        On_Key Kcancel Send KeyAction of oOKButton
82229>>>>>>>>>        Set Logo   to "DacAbout.bmp"  // Square bitmaps of 80x80 work best
82230>>>>>>>>>        Set LogoDF to "DF32.bmp"
82231>>>>>>>>>//        Set LogoVDF to "PoweredByOrange.bmp"
82231>>>>>>>>>    End_Procedure
82232>>>>>>>>>
82232>>>>>>>>>    Procedure Page Integer iPageObject
82234>>>>>>>>>        Handle hMenu
82234>>>>>>>>>        Integer iPrevState
82234>>>>>>>>>
82234>>>>>>>>>        Forward Send Page iPageObject
82236>>>>>>>>>        // Due to a bug in the ModalPanel class, we need to set the icon here:
82236>>>>>>>>>        Set Icon to "Default.ico"
82237>>>>>>>>>
82237>>>>>>>>>        // Shadow upper left corner menu items: (icon menu items)
82237>>>>>>>>>        Move (GetSystemMenu(Window_Handle(Self), False)) to hMenu
82238>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_RESTORE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
82239>>>>>>>>>        // The "Move" menu command may come in handy to have.
82239>>>>>>>>>        // Move (EnableMenuItem(hMenu, SC_MOVE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
82239>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_SIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
82240>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_MINIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
82241>>>>>>>>>        Move (EnableMenuItem(hMenu, SC_MAXIMIZE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
82242>>>>>>>>>        // The "Close" menu command may be good to have.
82242>>>>>>>>>        // Move (EnableMenuItem(hMenu, SC_CLOSE, MF_BYCOMMAND ior MF_GRAYED)) to iPrevState
82242>>>>>>>>>    End_Procedure
82243>>>>>>>>>
82243>>>>>>>>>    Procedure Set ProductName String sText
82245>>>>>>>>>        Set Value of oProductName to sText
82246>>>>>>>>>    End_Procedure
82247>>>>>>>>>
82247>>>>>>>>>    Procedure Set Copyright String sText
82249>>>>>>>>>        Set Value of oCopyright to sText
82250>>>>>>>>>    End_Procedure
82251>>>>>>>>>
82251>>>>>>>>>    Procedure Set Author String sText
82253>>>>>>>>>        Set Value of oAuthor to sText
82254>>>>>>>>>    End_Procedure
82255>>>>>>>>>
82255>>>>>>>>>    Procedure Set Version String sVersion
82257>>>>>>>>>        Handle hoVersionInfo
82257>>>>>>>>>        Boolean bIncluded
82257>>>>>>>>>        Integer iMajor iMinor iRelease iBuild
82257>>>>>>>>>        Date dCompileDate
82257>>>>>>>>>        String sCertInfo
82257>>>>>>>>>
82257>>>>>>>>>        If (sVersion = "") Begin
82259>>>>>>>>>            // This automatically shows the program version of the program, if available.
82259>>>>>>>>>            // It will be displayed as the second item in the edit object.
82259>>>>>>>>>            If (ghoApplication <> 0) Begin
82261>>>>>>>>>                Get phoVersionInfo of ghoApplication to hoVersionInfo
82262>>>>>>>>>                If (hoVersionInfo <> 0) Begin
82264>>>>>>>>>                    Get pbIncluded of hoVersionInfo to bIncluded
82265>>>>>>>>>                    If (bIncluded) Begin
82267>>>>>>>>>                        Get piVersionMajor of hoVersionInfo to iMajor
82268>>>>>>>>>                        Get piVersionMinor of hoVersionInfo to iMinor
82269>>>>>>>>>                        Get piVersionRelease of hoVersionInfo to iRelease
82270>>>>>>>>>                        Get piVersionBuild of hoVersionInfo to iBuild
82271>>>>>>>>>                        Move (SFormat (C_$VERSION + ": %1.%2.%3.%4", iMajor, iMinor, iRelease, iBuild)) to sVersion
82272>>>>>>>>>                    End
82272>>>>>>>>>>
82272>>>>>>>>>                End
82272>>>>>>>>>>
82272>>>>>>>>>            End
82272>>>>>>>>>>
82272>>>>>>>>>        End
82272>>>>>>>>>>
82272>>>>>>>>>
82272>>>>>>>>>        // Display the compiled date as the next row in the edit object, after the program version.
82272>>>>>>>>>        Get GetCompileDate to dCompileDate
82273>>>>>>>>>        If (sVersion <> "") Begin
82275>>>>>>>>>            Send Add_Lineln (sVersion + (Character(13)) + C_$Compile_Date * String(dCompileDate))
82276>>>>>>>>>        End
82276>>>>>>>>>>
82276>>>>>>>>>
82276>>>>>>>>>        Get IsProgramDigitallySigned to sCertInfo
82277>>>>>>>>>        If (sCertInfo <> "-1") Begin
82279>>>>>>>>>            If (sCertInfo <> "") Begin
82281>>>>>>>>>                Send Add_LineLn sCertInfo
82282>>>>>>>>>            End
82282>>>>>>>>>>
82282>>>>>>>>>            Else Begin
82283>>>>>>>>>                Send Add_LineLn "The program has NOT been digitally signed, or there is a problem with the digical certificate."
82284>>>>>>>>>            End
82284>>>>>>>>>>
82284>>>>>>>>>        End
82284>>>>>>>>>>
82284>>>>>>>>>    End_Procedure
82285>>>>>>>>>
82285>>>>>>>>>    Function IsDate Desktop String sDate Returns Boolean
82287>>>>>>>>>        Boolean bIsDate
82287>>>>>>>>>        String sGoodCharacters sChar
82287>>>>>>>>>        Integer iCount iLength
82287>>>>>>>>>
82287>>>>>>>>>        Move True to bIsDate
82288>>>>>>>>>        Move "0123456789-/" to sGoodCharacters
82289>>>>>>>>>        Move (Length(sDate)) to iLength
82290>>>>>>>>>        For iCount from 1 to iLength
82296>>>>>>>>>>
82296>>>>>>>>>            Move (Left(sDate, 1)) to sChar
82297>>>>>>>>>            Move (Mid(sDate, 12, 2)) to sDate
82298>>>>>>>>>            Move (sGoodCharacters contains sChar) to bIsDate
82299>>>>>>>>>            If (bIsDate = False) Begin
82301>>>>>>>>>                Move iLength to iCount
82302>>>>>>>>>            End
82302>>>>>>>>>>
82302>>>>>>>>>        Loop
82303>>>>>>>>>>
82303>>>>>>>>>        Function_Return bIsDate
82304>>>>>>>>>    End_Function
82305>>>>>>>>>
82305>>>>>>>>>    Function GetCompileDate Returns Date
82307>>>>>>>>>        Date dCompileDate
82307>>>>>>>>>        String sAppFilename sProgram sData sCompileDate
82307>>>>>>>>>        Integer iChannel iPos iDateFormat iCount iSize
82307>>>>>>>>>        Boolean bIsValid
82307>>>>>>>>>
82307>>>>>>>>>        Move 0 to dCompileDate
82308>>>>>>>>>        // Get full path to the current running executable
82308>>>>>>>>>        Get GetApplicationFileName of ghoApplication to sAppFilename
82309>>>>>>>>>        Get GetApplicationName     of ghoApplication to sProgram
82310>>>>>>>>>
82310>>>>>>>>>        //Read the current file  up to where the data we're interesting in is (this was hand calced and so could vary)
82310>>>>>>>>>        Get Seq_Open_Input_Channel ("binary:" * sAppFilename) to iChannel
82311>>>>>>>>>
82311>>>>>>>>>        Get_Argument_Size to iSize
82312>>>>>>>>>        Set_Argument_Size 15000000
82313>>>>>>>>>>
82313>>>>>>>>>        Read_Block channel iChannel sData 15000000   // This must be big enough to reach the compile date location
82315>>>>>>>>>        Move (Pos(sProgram,sData)) to iPos
82316>>>>>>>>>        If (iPos > 0) Begin
82318>>>>>>>>>            // The compile date is 10 characters long and starts 3 characters after the program name
82318>>>>>>>>>            Move (Mid(sData, 10, iPos + Length(sProgram) + 3)) to sCompileDate  // In US format
82319>>>>>>>>>
82319>>>>>>>>>            // If the current date format is non US, we need to temporary
82319>>>>>>>>>            // change the format and then move the string to the date variable.
82319>>>>>>>>>            Get_Attribute DF_DATE_FORMAT to iDateFormat
82322>>>>>>>>>            Set_Attribute DF_DATE_FORMAT to DF_DATE_USA
82325>>>>>>>>>            Move (Date(sCompileDate))    to dCompileDate
82326>>>>>>>>>            Set_Attribute DF_DATE_FORMAT to iDateFormat // Reset date format
82329>>>>>>>>>        End
82329>>>>>>>>>>
82329>>>>>>>>>//        Else Begin
82329>>>>>>>>>//            Error DFERR_PROGRAM "Compile Date location in .exe not found"
82329>>>>>>>>>//        End
82329>>>>>>>>>
82329>>>>>>>>>        Send Seq_Close_Channel iChannel
82330>>>>>>>>>        Set_Argument_Size iSize
82331>>>>>>>>>>
82331>>>>>>>>>//        Read_Block channel iChannel sData (8 * 1024)    // First 8K is .exe header skip it
82331>>>>>>>>>//        Read_Block channel iChannel sData 75            // The compile information we're interested in
82331>>>>>>>>>
82331>>>>>>>>>        // The data is padded with Character(0)s. Strip them out
82331>>>>>>>>>//        Move (CString(sData)) to sData
82331>>>>>>>>>
82331>>>>>>>>>        // The compile date is after the first ", ", so string parsing is required
82331>>>>>>>>>//        Move (Pos(", ", sData)) to iPos
82331>>>>>>>>>//        Move (Mid(sData, 10, (iPos + 2) ))  to sCompileDate // In US format
82331>>>>>>>>>        // If the current date format is non US, we need to temporary
82331>>>>>>>>>        // change the format and then move the string to the date variable.
82331>>>>>>>>>//        Get_Attribute DF_DATE_FORMAT        to iDateFormat
82331>>>>>>>>>//        Set_Attribute DF_DATE_FORMAT        to DF_DATE_USA
82331>>>>>>>>>//
82331>>>>>>>>>//        // Note the build in IsDateValid can return the wrong result
82331>>>>>>>>>//        // when controls characters are part of the sCompileDate.
82331>>>>>>>>>//        Get IsDate sCompileDate))           to bIsValid
82331>>>>>>>>>//        If (bIsValid = True) Begin
82331>>>>>>>>>//            Move (Date(sCompileDate))       to dCompileDate
82331>>>>>>>>>//        End
82331>>>>>>>>>//
82331>>>>>>>>>//        // As of DataFlex 19.1 the header has changed; and so has the compile date location.
82331>>>>>>>>>//        // It seems to me that the position for the compilation date can vary. So we read line-by-line
82331>>>>>>>>>//        // until we encounter the program name that appears just in front of the compile date.
82331>>>>>>>>>//        // Although I'm not sure about if/how the position varies, the below seems to work just fine.
82331>>>>>>>>>//        If (dCompileDate = 0) Begin
82331>>>>>>>>>//            Move "" to sCompileDate
82331>>>>>>>>>//            Move 30000 to iSize
82331>>>>>>>>>//            For iCount from 1 to iSize
82331>>>>>>>>>//                Readln channel iChannel sData
82331>>>>>>>>>//                Move (Pos(sProgram, sData)) to iPos
82331>>>>>>>>>//                If (iPos <> 0) Begin
82331>>>>>>>>>//                    Move (Mid(sData, 10, (iPos + (Length(sProgram) + 2)))) to sCompileDate
82331>>>>>>>>>//                    Move (Trim(sCompileDate)) to sCompileDate
82331>>>>>>>>>//                    Move iSize to iCount // We're out of here.
82331>>>>>>>>>//                End
82331>>>>>>>>>//            Loop
82331>>>>>>>>>//            If (Left(sCompileDate, 1) = "0") Begin
82331>>>>>>>>>//                Move ("1" + String(sCompileDate)) to sCompileDate
82331>>>>>>>>>//            End
82331>>>>>>>>>//            Get IsDate sCompileDate)) to bIsValid
82331>>>>>>>>>//            If (bIsValid = True) Begin
82331>>>>>>>>>//                Move (Date(sCompileDate)) to dCompileDate
82331>>>>>>>>>//            End
82331>>>>>>>>>//        End
82331>>>>>>>>>//        Send Seq_Close_Channel iChannel
82331>>>>>>>>>//        Set_Attribute DF_DATE_FORMAT to iDateFormat // Reset date format
82331>>>>>>>>>
82331>>>>>>>>>        Function_Return dCompileDate
82332>>>>>>>>>    End_Function
82333>>>>>>>>>
82333>>>>>>>>>    // A variant of the ShellExecute Win API, but it waits until the process that is started
82333>>>>>>>>>    // (the passed program), has been finished
82333>>>>>>>>>    // The DOS box does also _not_ flash briefly.
82333>>>>>>>>>    Procedure RunProgramWait String sProgram String sParameter
82335>>>>>>>>>        Handle hProcess
82335>>>>>>>>>        Integer iVoid
82335>>>>>>>>>        AboutSHELLEXECUTEINFO sInfo
82335>>>>>>>>>        AboutSHELLEXECUTEINFO sInfo
82335>>>>>>>>>
82335>>>>>>>>>        Move (SizeOfType(AboutSHELLEXECUTEINFO)) to sInfo.cbSize
82336>>>>>>>>>
82336>>>>>>>>>        Move SEE_MASK_NOCLOSEPROCESS to sInfo.fMask
82337>>>>>>>>>        Move SW_SHOW                 to sInfo.nShow
82338>>>>>>>>>
82338>>>>>>>>>        Move (AddressOf(sProgram))   to sInfo.lpFile
82339>>>>>>>>>        Move (AddressOf(sParameter)) to sInfo.lpParameters
82340>>>>>>>>>        // This will "hide" the DOS box from showing (no flasing box):
82340>>>>>>>>>        Move 0                       to sInfo.nShow
82341>>>>>>>>>
82341>>>>>>>>>        Move (AboutShellExecuteEx(AddressOf(sInfo))) to iVoid
82342>>>>>>>>>        Move sInfo.hProcess to hProcess
82343>>>>>>>>>        If (hProcess) Begin
82345>>>>>>>>>            Move (AboutWaitForSingleObject(hProcess, -1)) to iVoid
82346>>>>>>>>>            Move (AboutCloseHandle(hProcess)) to iVoid
82347>>>>>>>>>        End
82347>>>>>>>>>>
82347>>>>>>>>>    End_Procedure
82348>>>>>>>>>
82348>>>>>>>>>    Function AddFolderDelimiter String sPath Returns String
82350>>>>>>>>>        String sDirSep
82350>>>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
82351>>>>>>>>>        Move (Trim(sPath)) to sPath
82352>>>>>>>>>        If (Right(sPath, 1) <> sDirSep) Begin
82354>>>>>>>>>            Move (sPath + sDirSep) to sPath
82355>>>>>>>>>        End
82355>>>>>>>>>>
82355>>>>>>>>>        Function_Return sPath
82356>>>>>>>>>    End_Function
82357>>>>>>>>>
82357>>>>>>>>>    // Returns an empty string if the current program is not digitally signed,
82357>>>>>>>>>    // or there is a problem with the certificate.
82357>>>>>>>>>    // Note: A copy of the Microsoft signtool.exe program must reside in the Programs folder,
82357>>>>>>>>>    //       else nothing is shown in the About object. (Size 355 KB)
82357>>>>>>>>>    Function IsProgramDigitallySigned Returns String
82359>>>>>>>>>        Boolean bExists
82359>>>>>>>>>        String sPath sProgram sParams sRetval
82359>>>>>>>>>        Integer iCh
82359>>>>>>>>>
82359>>>>>>>>>        Move "" to sRetval
82360>>>>>>>>>        Get psProgramPath of (phoWorkspace(ghoApplication)) to sPath
82361>>>>>>>>>        Get AddFolderDelimiter sPath to sPath
82362>>>>>>>>>        File_Exist (sPath + CS_SignProgram) bExists
82363>>>>>>>>>        If (bExists = False) Begin
82365>>>>>>>>>            Function_Return "-1"
82366>>>>>>>>>        End
82366>>>>>>>>>>
82366>>>>>>>>>
82366>>>>>>>>>        Get GetApplicationFileName of ghoApplication to sProgram
82367>>>>>>>>>        Move (CS_VerifyCredentials * CS_DefAuthVerPolicy) to sParams
82368>>>>>>>>>        Move (sParams * '"' + sProgram + '"') to sParams
82369>>>>>>>>>        Move (sParams * String("| clip"))    to sParams
82370>>>>>>>>>        Get Seq_New_Channel to iCh
82371>>>>>>>>>        Direct_Output channel iCh (sPath + CS_TempCertBatchFile)
82373>>>>>>>>>            Writeln channel iCh ('"' + sPath + CS_SignProgram + '"' * sParams)
82376>>>>>>>>>        Close_Output channel iCh
82378>>>>>>>>>        // New ShellExecute based message that waits for the passed process to end.
82378>>>>>>>>>        Send RunProgramWait (sPath + CS_TempCertBatchFile) ""
82379>>>>>>>>>        Direct_Input channel iCh "CLIPBOARD:"
82381>>>>>>>>>            Readln channel iCh sRetval
82383>>>>>>>>>            Readln channel iCh sRetval
82385>>>>>>>>>            Readln channel iCh sRetval
82387>>>>>>>>>            Readln channel iCh sRetval
82389>>>>>>>>>        Close_Input channel iCh
82391>>>>>>>>>        Send Seq_Release_Channel iCh
82392>>>>>>>>>        If (Lowercase(sRetval) contains "authenticode") Begin
82394>>>>>>>>>            Move "This program has been digitally signed and the certificate is valid." to sRetval
82395>>>>>>>>>        End
82395>>>>>>>>>>
82395>>>>>>>>>        Else Begin
82396>>>>>>>>>            Move "" to sRetval
82397>>>>>>>>>        End
82397>>>>>>>>>>
82397>>>>>>>>>//        Get DeleteFile (sPath + CS_TempCertBatchFile) to iRetval
82397>>>>>>>>>        EraseFile (sPath + CS_TempCertBatchFile)
82398>>>>>>>>>>
82398>>>>>>>>>        Function_Return sRetval
82399>>>>>>>>>    End_Function
82400>>>>>>>>>
82400>>>>>>>>>    Procedure Add_LineLn String sValue
82402>>>>>>>>>        Send Add_LineLn of oInfoList_Editor sValue
82403>>>>>>>>>    End_Procedure
82404>>>>>>>>>
82404>>>>>>>>>    Procedure Add_Line String sValue
82406>>>>>>>>>        Send Add_Line of oInfoList_Editor sValue
82407>>>>>>>>>    End_Procedure
82408>>>>>>>>>
82408>>>>>>>>>    Procedure Set Logo string sLogo
82410>>>>>>>>>        // Square bitmaps of 80x80 work best
82410>>>>>>>>>        Set Bitmap of oAboutGraphic to sLogo
82411>>>>>>>>>    End_Procedure
82412>>>>>>>>>
82412>>>>>>>>>    Procedure Set LogoDF String sLogo
82414>>>>>>>>>        Set Bitmap of oPoweredByDFGraphic to sLogo
82415>>>>>>>>>    End_Procedure
82416>>>>>>>>>
82416>>>>>>>>>    Procedure Show_Sysinfo
82418>>>>>>>>>        Send Popup_Modal of oSysinfoDialog
82419>>>>>>>>>    End_Procedure
82420>>>>>>>>>
82420>>>>>>>>>    Procedure Show_HomePage String sWebpage
82422>>>>>>>>>        Handle hWnd
82422>>>>>>>>>        Get Window_Handle to hWnd
82423>>>>>>>>>        Runprogram Shell Background (Trim(sWebpage))
82424>>>>>>>>>    End_Procedure
82425>>>>>>>>>
82425>>>>>>>>>End_Class
82426>>>>>>>
82426>>>>>>>// Martin Moleman on SQL Server and DateTime2 (Don't use DataTime any longer !)
82426>>>>>>>// One remark about your change: I would not change to datetime2(7) (7 decimals) but to
82426>>>>>>>// datetime2(3) (3 decimals = milliseconds) or If you don't need the milliseconds datetime2(0).
82426>>>>>>>// The reason is that the DataFlex DateTime type only allows 3 decimals. When using 7
82426>>>>>>>// decimals you may Get truncation that again may cause problems with finding.
82426>>>>>>>//
82426>>>>>>>// Important! The conversion from DateTime to Date or datetime2 will also convert all dummy zero Date values from 1753-01-01 to 0001-01-01.
82426>>>>>>>// This is important to realize. The conversion will actually change the data in the database (done by the driver)
82426>>>>>>>
82426>>>>>>>
82426>>>>>>>// DF_DATABASE_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA
82426>>>>>>>// Determines for all DataFlex data types, which SQL native types willbe used when creating new columns.
82426>>>>>>>// Set_Attribute DF_DATABASE_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA of {driverNumber} {databaseHandle} ;
82426>>>>>>>// to {MAP_DF_TO_SQL_TYPE_SQL2000|MAP_DF_TO_SQL_TYPE_SQL2005|MAP_DF_TO_SQL_TYPE_SQL2008|MAP_DF_TO_SQL_TYPE_SQL2012}
82426>>>>>>>//
82426>>>>>>>
82426>>>>>>>Class cDbUpdateFunctionLibrary is a cObject
82427>>>>>>>    Import_Class_Protocol cDbUpdateFunctionLibrary_Mixin
Including file: ParseKeyWord.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ParseKeyWord.pkg)
82428>>>>>>>>
82428>>>>>>>>Function ParseKeyWord String sConnect String sKeyWord Returns String
82430>>>>>>>>    Integer iStart iEnd
82430>>>>>>>>    String sRetval
82430>>>>>>>>
82430>>>>>>>>    Move (Trim(sConnect)) to sConnect
82431>>>>>>>>    Move (Pos(Uppercase(sKeyWord), Uppercase(sConnect)))  to iStart
82432>>>>>>>>    If (iStart = 0) Begin
82434>>>>>>>>        Function_Return ""
82435>>>>>>>>    End
82435>>>>>>>>>
82435>>>>>>>>    Move (Left(sConnect, (iStart -1 + Length(sKeyWord)))) to sRetval
82436>>>>>>>>    Move (Replace(sRetval, sConnect, "")) to sRetval
82437>>>>>>>>    If (sKeyWord = Uppercase(CS_SQLConnectionIDText)) Begin
82439>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
82440>>>>>>>>    End
82440>>>>>>>>>
82440>>>>>>>>    Else Begin
82441>>>>>>>>        Move (Pos(";", sRetval))          to iEnd
82442>>>>>>>>    End
82442>>>>>>>>>
82442>>>>>>>>    If (iEnd = 0 and (sRetval contains ",")) Begin
82444>>>>>>>>        Move (Pos(",", sRetval))          to iEnd
82445>>>>>>>>        Decrement iEnd
82446>>>>>>>>    End
82446>>>>>>>>>
82446>>>>>>>>    If (iEnd <> 0) Begin
82448>>>>>>>>        Move (Left(sRetval, (iEnd -1)))   to sRetval
82449>>>>>>>>    End
82449>>>>>>>>>
82449>>>>>>>>    Move (Replace("=", sRetval, ""))      to sRetval
82450>>>>>>>>
82450>>>>>>>>    Function_Return (Trim(sRetval))
82451>>>>>>>>End_Function
82452>>>>>>>>
82452>>>>>>>>
82452>>>>>>>
82452>>>>>>>    Procedure Construct_Object
82454>>>>>>>        Handle ho
82454>>>>>>>        Forward Send Construct_Object
82456>>>>>>>
82456>>>>>>>        Move Self to ghoDbUpdateFunctionLibrary
82457>>>>>>>
82457>>>>>>>        Send CreateDbUpdateLibraryProperties
82458>>>>>>>        // If no ghoSQLConnectionHandler object has been created prior to this object,
82458>>>>>>>        // we will create one as it is used for all ConnectionID, ConnectionString
82458>>>>>>>        // etc settings.
82458>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
82460>>>>>>>            Get Create (RefClass(cSQLConnectionHandler)) to ho
82461>>>>>>>            Set phoSQLConnectionHandler to ho
82462>>>>>>>        End   
82462>>>>>>>>
82462>>>>>>>        
82462>>>>>>>        Property String private.psCollation "Latin1_General_CS_AS"
82463>>>>>>>
82463>>>>>>>    End_Procedure
82464>>>>>>>
82464>>>>>>>    Procedure End_Construct_Object
82466>>>>>>>        Forward Send End_Construct_Object
82468>>>>>>>    End_Procedure
82469>>>>>>>
82469>>>>>>>    // *** SQL Messages for making changes to the SQL back-end ***
82469>>>>>>>    //
82469>>>>>>>    // * Dummy function for the Studio's Code Explorer *
82469>>>>>>>    Function SQL_DATABASE_FUNCTIONS Returns Boolean
82471>>>>>>>        Function_Return False
82472>>>>>>>    End_Function
82473>>>>>>>
82473>>>>>>>    // Function for creating a new *Database*.
82473>>>>>>>    // Note: This is for creating SQL DATABASES - not tables!
82473>>>>>>>    // Returns True if successful.
82473>>>>>>>    // ToDo: Currently only works for MS-SQL...
82473>>>>>>>    Function SqlDatabaseCreate String sDriverID String sDatabase Boolean bUpdateConnectionString Boolean bPermanantly Returns Boolean
82475>>>>>>>        String sSQL sSQL1 sConnectionID sConnectionString
82475>>>>>>>        String sCreateDatabaseKeyWord sSelectFromWhereName sCollation sCollateKeyWord
82475>>>>>>>        Handle hConnection hStmt hoSQLManager
82475>>>>>>>        Integer iFetchResult iDbType
82475>>>>>>>        Boolean bOK bMertechDriver bExists
82475>>>>>>>
82475>>>>>>>        Get piDbType to iDbType
82476>>>>>>>//        If (iDbType <> EN_DbTypeMSSQL and sDriverID <> MDSMySQL and sDriverID <> MDSDB2 and sDriverID <> ODBC_DRV_ID) Begin
82476>>>>>>>        If (iDbType <> EN_DbTypeMSSQL and iDbType <> EN_DbTypeDB2 and iDbType <> EN_DbTypeMySQL and iDbType <> EN_DbTypePostgre) Begin
82478>>>>>>>            Error DFERR_PROGRAM "Sorry, the SqlDatabaseCreate function is currently only supported for MS-SQL, MySQL & PostGre and DB2 with Mertech drivers"
82479>>>>>>>>
82479>>>>>>>            Function_Return False
82480>>>>>>>        End
82480>>>>>>>>
82480>>>>>>>
82480>>>>>>>        Get SqlUtilCheckIfDatabaseExists sDatabase to bExists
82481>>>>>>>        If (bExists = True) Begin
82483>>>>>>>            Function_Return True
82484>>>>>>>        End
82484>>>>>>>>
82484>>>>>>>
82484>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
82485>>>>>>>        If (bMertechDriver = False) Begin
82487>>>>>>>            Get phoSQLManager to hoSQLManager
82488>>>>>>>        End
82488>>>>>>>>
82488>>>>>>>        Else Begin
82489>>>>>>>            Get _MertechSQLManagerHandle to hoSQLManager
82490>>>>>>>        End
82490>>>>>>>>
82490>>>>>>>
82490>>>>>>>        Get psConnectionID     to sConnectionID
82491>>>>>>>        Get psConnectionString to sConnectionString
82492>>>>>>>        Move 0 to LastErr
82493>>>>>>>
82493>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
82495>>>>>>>            // If an ODBC data source (DSN) we cannot pass the UID & PWD; so strip them from the connection string.
82495>>>>>>>            // ToDo: 2018-08-11 I think this is wrong and the uid & pw should be there.
82495>>>>>>>//            If (Uppercase(sConnectionString) contains CS_SQLIniDSNKeyword) Begin
82495>>>>>>>//                Move (Pos(";", sConnectionString)) to iPos
82495>>>>>>>//                If (iPos > 0) Begin
82495>>>>>>>//                    Move (Left(sConnectionString, (iPos - 1))) to sConnectionString
82495>>>>>>>//                    Move (Trim(sConnectionString)) to sConnectionString
82495>>>>>>>//                End
82495>>>>>>>//            End
82495>>>>>>>        End
82495>>>>>>>>
82495>>>>>>>
82495>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
82496>>>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
82497>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
82498>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
82500>>>>>>>            Error DFERR_PROGRAM (CS_DUF_LoginToDbServerFailed + "\n" + sConnectionString)
82501>>>>>>>>
82501>>>>>>>            Function_Return False
82502>>>>>>>        End
82502>>>>>>>>
82502>>>>>>>
82502>>>>>>>        Get SqlOpen of hConnection to hStmt
82503>>>>>>>
82503>>>>>>>        If (hStmt = 0) Begin
82505>>>>>>>            Send SqlDisconnect of hoSQLManager
82506>>>>>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
82507>>>>>>>>
82507>>>>>>>            Function_Return False
82508>>>>>>>        End
82508>>>>>>>>
82508>>>>>>>
82508>>>>>>>        Get psCollation to sCollation
82509>>>>>>>
82509>>>>>>>        Case Begin
82509>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
82511>>>>>>>                Get _SqlFindKeyWord CI_SQLCreateDatabase to sCreateDatabaseKeyWord
82512>>>>>>>                Get _SqlSelectFromWhereName to sSelectFromWhereName
82513>>>>>>>                Move (sSelectFromWhereName + "='" + sDatabase + "'") to sSQL
82514>>>>>>>
82514>>>>>>>                // Check if database exists
82514>>>>>>>                Send SqlExecDirect of hStmt sSQL
82515>>>>>>>                Get SqlFetch of hStmt to iFetchResult
82516>>>>>>>                Send SqlClose of hStmt
82517>>>>>>>                Send SqlDisconnect of hConnection
82518>>>>>>>                // If database already exists we're out of here!
82518>>>>>>>                // Note that we return True as this is not an error.
82518>>>>>>>                If (iFetchResult > 0) Begin
82520>>>>>>>                    Function_Return True
82521>>>>>>>                End
82521>>>>>>>>
82521>>>>>>>                // Database doesn't exist, create it.
82521>>>>>>>                If (iFetchResult = 0) Begin
82523>>>>>>>                    Move (sCreateDatabaseKeyWord + " [" + sDatabase + "]") to sSQL1
82524>>>>>>>                    Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
82525>>>>>>>                    If (sCollation <> "") Begin
82527>>>>>>>                        Get _SqlFindKeyWord CI_SQLDatabaseCollation to sCollateKeyWord
82528>>>>>>>                        Move (sSQL1 * String(sCollateKeyWord) * String(sCollation)) to sSQL1
82529>>>>>>>                    End
82529>>>>>>>>
82529>>>>>>>                    Send SqlUtilExecuteQuery sSQL1 sDriverID
82530>>>>>>>                    Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
82531>>>>>>>                    If (LastErr = CLIERR_GENERAL_ERROR) Begin
82533>>>>>>>                        Function_Return False
82534>>>>>>>                    End
82534>>>>>>>>
82534>>>>>>>                    // We need to wait a short time for Sql to finish, especially Windows to write the new file to disk.
82534>>>>>>>                    Sleep 1
82535>>>>>>>                    Send SqlUtilExecuteQuery sSQL sDriverID
82536>>>>>>>                End
82536>>>>>>>>
82536>>>>>>>                Case Break
82537>>>>>>>
82537>>>>>>>            Case (sDriverID = MDSPgSQL)
82540>>>>>>>                SQLIncludeScriptFile ..\Scripts\CreatePostgreSQLDatabase.sql as CreatePostgreSQLDatabase.sql
82540>>>>>>>                Get _SqlUtilCreatePostGreSQLDatabaseByScript "CreatePostgreSQLDatabase.sql" sDatabase to bOK
82541>>>>>>>                Case Break
82542>>>>>>>
82542>>>>>>>            Case (sDriverID = MDSMySQL or (iDbType = EN_DbTypeMySQL and sDriverID = ODBC_DRV_ID))
82545>>>>>>>                // ToDo: How should this be set/checked?
82545>>>>>>>//                If (Lowercase(Left(sCollation, 3)) <> "utf") Begin
82545>>>>>>>//                    Set psCollation to "utf8"
82545>>>>>>>//                End
82545>>>>>>>                SQLIncludeScriptFile ..\Scripts\CreateMySQLDatabase.sql as CreateMySQLDatabase.sql
82545>>>>>>>                Get _SqlUtilCreateMySQLDatabaseByScript "CreateMySQLDatabase.sql" sDatabase to bOK
82546>>>>>>>                Case Break
82547>>>>>>>
82547>>>>>>>            Case (sDriverID = MDSDB2)
82550>>>>>>>                        CompilerWarnings Off
82550>>>>>>>                        CREATE_DB2_DATABASE sDatabase "" sCollation ""
82582>>>>>>>                        CompilerWarnings Off
82582>>>>>>>                Case Break
82583>>>>>>>
82583>>>>>>>            Case Else
82583>>>>>>>                Error DFERR_PROGRAM "Unsupported database type"
82584>>>>>>>>
82584>>>>>>>        Case End
82584>>>>>>>
82584>>>>>>>        If (Err = False) Begin
82586>>>>>>>            Send LogError ("The Database:" * String(sDatabase) * "was created successfully for driver:" * String(sDriverID)) False
82587>>>>>>>        End
82587>>>>>>>>
82587>>>>>>>        // If used in e.g. the cDbUpdateHandler we want to change the login database name to
82587>>>>>>>        // the one we just created.
82587>>>>>>>        If (bUpdateConnectionString = True and Err = False) Begin
82589>>>>>>>            Set psDatabase to sDatabase
82590>>>>>>>            //...and perhaps also the SQLConnections.ini file setting.
82590>>>>>>>            If (bPermanantly = True) Begin
82592>>>>>>>                If (ghoSQLConnectionHandler <> 0) Begin
82594>>>>>>>                    Get SQLIniFileSetDefaultConnection of ghoSQLConnectionHandler sConnectionID to bOK
82595>>>>>>>                End
82595>>>>>>>>
82595>>>>>>>            End
82595>>>>>>>>
82595>>>>>>>        End
82595>>>>>>>>
82595>>>>>>>
82595>>>>>>>        Function_Return (Err = False)
82596>>>>>>>    End_Function
82597>>>>>>>
82597>>>>>>>    // Backs up an SQL database to a folder of choice. If no path is passed the SQL default backup folder
82597>>>>>>>    // will be used.
82597>>>>>>>    Function SqlDatabaseBackupToDisk String sDatabase String sBackupName String sPath Boolean bShowProg Returns Boolean
82599>>>>>>>        Boolean bOK bExists bShowProgress bErr
82599>>>>>>>        String sStatement sDriverID
82599>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
82599>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
82599>>>>>>>        Integer iDbType
82599>>>>>>>
82599>>>>>>>        If (sDatabase = "") Begin
82601>>>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
82602>>>>>>>>
82602>>>>>>>            Function_Return False
82603>>>>>>>        End
82603>>>>>>>>
82603>>>>>>>        If (sBackupName = "") Begin
82605>>>>>>>            Error DFERR_PROGRAM "The database backup name was not passed as a parameter to the 'SqlUtilBackupDatabaseToDisk' function"
82606>>>>>>>>
82606>>>>>>>            Function_Return False
82607>>>>>>>        End
82607>>>>>>>>
82607>>>>>>>
82607>>>>>>>        // Create backup-folder if it doesn't exist
82607>>>>>>>        Get vFolderExists sPath to bExists
82608>>>>>>>        If (bExists = False) Begin
82610>>>>>>>            Get vCreateDirectory sPath to bErr
82611>>>>>>>            If (bErr = True) Begin
82613>>>>>>>                Error DFERR_PROGRAM ("Could not create database backup folder:" * sPath)
82614>>>>>>>>
82614>>>>>>>                Function_Return False
82615>>>>>>>            End
82615>>>>>>>>
82615>>>>>>>        End
82615>>>>>>>>
82615>>>>>>>        // Make sure the path ends with a back-slash
82615>>>>>>>        If (sPath <> "") Begin
82617>>>>>>>            Get vFolderFormat sPath to sPath
82618>>>>>>>        End
82618>>>>>>>>
82618>>>>>>>
82618>>>>>>>        Get psDriverID to sDriverID
82619>>>>>>>        Get piDbType   to iDbType
82620>>>>>>>        If (num_arguments > 3) Begin
82622>>>>>>>            Move bShowProg to bShowProgress
82623>>>>>>>        End
82623>>>>>>>>
82623>>>>>>>
82623>>>>>>>        Case Begin
82623>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
82625>>>>>>>                SQLIncludeScriptFile ..\Scripts\BackupMSSQLDatabase.sql as BackupMSSQLDatabase.sql
82625>>>>>>>                SQLIncludeScriptFile ..\Scripts\GetPercentageBackupCompletionMSSQL.sql as GetPercentageBackupCompletionMSSQL.sql
82625>>>>>>>                Get SqlUtilReadResource of ghoDbUpdateFunctionLibrary "BackupMSSQLDatabase.sql" sDriverID False to SQLScriptArray
82626>>>>>>>                Get SqlUtilReadResource of ghoDbUpdateFunctionLibrary "GetPercentageBackupCompletionMSSQL.sql" sDriverID False to SQLScriptArrayPercentReady
82627>>>>>>>
82627>>>>>>>                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
82628>>>>>>>                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase))   to sStatement
82629>>>>>>>                Move (Replaces("BACKUP_PATH_XXX",   sStatement, sPath))       to sStatement
82630>>>>>>>                Move (Replaces("BACKUP_NAME_XXX",   sStatement, sBackupName)) to sStatement
82631>>>>>>>                Move sStatement to SQLScriptArray.sSQLScriptArray[0]
82632>>>>>>>                Get SqlUtilExecuteEmbeddedScript of ghoDbUpdateFunctionLibrary SQLScriptArray sDriverID False "" bShowProgress to bOK
82633>>>>>>>                Case Break
82634>>>>>>>            Case Else
82634>>>>>>>                Send Info_Box ("The SqlUtilBackupDatabaseToDisk function is currently not implemented for the driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and add a little ESQL code snippet to make it work for that driver! Thanks for helping out.")
82635>>>>>>>        Case End
82635>>>>>>>
82635>>>>>>>        Function_Return bOK
82636>>>>>>>    End_Function
82637>>>>>>>
82637>>>>>>>    Function SqlDatabaseCollationQuery String sDatabase Boolean bSilent Returns String
82639>>>>>>>//        Boolean bOK bExists
82639>>>>>>>        String sStatement sDriverID sRetval //sPrevious
82639>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
82639>>>>>>>        tSQLScriptArray SQLScriptArray SQLScriptArrayPercentReady
82639>>>>>>>        Integer iDbType iRows iFetchResult //iColumn
82639>>>>>>>        Handle hoSQLHandler hoSQLConnect hstmt
82639>>>>>>>        tSQLConnection SQLConnection
82639>>>>>>>        tSQLConnection SQLConnection
82639>>>>>>>
82639>>>>>>>        If (sDatabase = "") Begin
82641>>>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlUtilDatabaseCollation' function"
82642>>>>>>>>
82642>>>>>>>            Function_Return ""
82643>>>>>>>        End
82643>>>>>>>>
82643>>>>>>>
82643>>>>>>>        Move "" to sRetval
82644>>>>>>>        Get psDriverID to sDriverID
82645>>>>>>>        Get piDbType   to iDbType
82646>>>>>>>
82646>>>>>>>        Case Begin
82646>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
82648>>>>>>>                SQLIncludeScriptFile ..\Scripts\QueryMSSQLCollation.sql as QueryMSSQLCollation.sql
82648>>>>>>>                Get SqlUtilReadResource of ghoDbUpdateFunctionLibrary "QueryMSSQLCollation.sql" sDriverID False to SQLScriptArray
82649>>>>>>>
82649>>>>>>>                Move SQLScriptArray.sSQLScriptArray[0] to sStatement
82650>>>>>>>                Move (Replaces("DATABASE_NAME_XXX", sStatement, sDatabase)) to sStatement
82651>>>>>>>                Get phoSQLManager to hoSQLHandler
82652>>>>>>>
82652>>>>>>>                If (hoSQLHandler <> 0) Begin
82654>>>>>>>                    Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
82655>>>>>>>                    Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
82656>>>>>>>
82656>>>>>>>                    If (hoSQLConnect <> 0) Begin
82658>>>>>>>                        Get SQLOpen of hoSQLConnect to hstmt
82659>>>>>>>                        If (hstmt <> 0) Begin
82661>>>>>>>                            Send SqlExecDirect of hstmt sStatement
82662>>>>>>>                            Get SqlStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
82663>>>>>>>                            Get SQLFetch of hstmt to iFetchResult
82664>>>>>>>                            If (iFetchResult <> 0) Begin
82666>>>>>>>                                Get SQLColumnValue of hstmt 2 to sRetval // Column 1 = Database Name, 2 = Collation Name.
82667>>>>>>>                            End
82667>>>>>>>>
82667>>>>>>>                            Send SQLClose of hstmt
82668>>>>>>>                        End
82668>>>>>>>>
82668>>>>>>>                        Send SQLDisconnect of hoSQLConnect
82669>>>>>>>                    End
82669>>>>>>>>
82669>>>>>>>                End
82669>>>>>>>>
82669>>>>>>>                Case Break
82670>>>>>>>            Case Else
82670>>>>>>>                If (bSilent = False) Begin
82672>>>>>>>                    Send Info_Box ("The SqlDatabaseCollationQuery function is currently not implemented for this driver:" * sDriverID + ". It would be great if you could spend a couple of minutes and create a little SQL code snippet and send it to RDC Tools to make this routine work for this driver! Thanks for helping out.")
82673>>>>>>>                End
82673>>>>>>>>
82673>>>>>>>        Case End
82673>>>>>>>
82673>>>>>>>        Function_Return sRetval
82674>>>>>>>    End_Function
82675>>>>>>>
82675>>>>>>>    Function SqlDatabaseCollationChange String sDatabase String sSQLCollation Returns Boolean
82677>>>>>>>        Boolean bMertechDriver // bOK bExists 
82677>>>>>>>        String sDriverID sSQL sConnectionID sConnectionString sSet sWith // sSQL1 
82677>>>>>>>        String sAlterDatabaseKeyWord sCollateKeyWord sSQLCollationCheck sSingle_User sMulti_User sRollback sImmediate
82677>>>>>>>        Handle hConnection hStmt hoSQLManager
82677>>>>>>>        Integer iDbType // iFetchResult
82677>>>>>>>
82677>>>>>>>        If (sDatabase = "") Begin
82679>>>>>>>            Error DFERR_PROGRAM "The database name was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
82680>>>>>>>>
82680>>>>>>>            Function_Return False
82681>>>>>>>        End
82681>>>>>>>>
82681>>>>>>>
82681>>>>>>>        If (sSQLCollation = "") Begin
82683>>>>>>>            Error DFERR_PROGRAM "The SQL Collation name was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
82684>>>>>>>>
82684>>>>>>>            Function_Return False
82685>>>>>>>        End
82685>>>>>>>>
82685>>>>>>>
82685>>>>>>>        Get psDriverID to sDriverID
82686>>>>>>>        Get piDbType   to iDbType
82687>>>>>>>
82687>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
82688>>>>>>>        If (bMertechDriver = False) Begin
82690>>>>>>>            Get phoSQLManager to hoSQLManager
82691>>>>>>>        End
82691>>>>>>>>
82691>>>>>>>        Else Begin
82692>>>>>>>            Get _MertechSQLManagerHandle to hoSQLManager
82693>>>>>>>        End
82693>>>>>>>>
82693>>>>>>>
82693>>>>>>>        Get psConnectionID     to sConnectionID
82694>>>>>>>        Get psConnectionString to sConnectionString
82695>>>>>>>        Move 0 to LastErr
82696>>>>>>>
82696>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
82697>>>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hConnection
82698>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
82699>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
82701>>>>>>>            Error DFERR_PROGRAM ("Login failed to the database server. The following connect string was used:\n" + sConnectionString)
82702>>>>>>>>
82702>>>>>>>            Function_Return False
82703>>>>>>>        End
82703>>>>>>>>
82703>>>>>>>
82703>>>>>>>        Get SqlOpen of hConnection to hStmt
82704>>>>>>>
82704>>>>>>>        If (hStmt = 0) Begin
82706>>>>>>>            Send SqlDisconnect of hoSQLManager
82707>>>>>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
82708>>>>>>>>
82708>>>>>>>            Function_Return False
82709>>>>>>>        End
82709>>>>>>>>
82709>>>>>>>
82709>>>>>>>        // Check if collation already exists
82709>>>>>>>        Get SqlDatabaseCollationQuery sDatabase False to sSQLCollationCheck
82710>>>>>>>        // If the current collate is the same as the new; do nothing.
82710>>>>>>>        If (sSQLCollation = sSQLCollationCheck) Begin
82712>>>>>>>            Function_Return True
82713>>>>>>>        End
82713>>>>>>>>
82713>>>>>>>
82713>>>>>>>        Get _SqlFindKeyWord CI_SQLSet               to sSet
82714>>>>>>>        Get _SqlFindKeyWord CI_SQLWith              to sWith
82715>>>>>>>        Get _SqlFindKeyWord CI_SQLSingle_User       to sSingle_User
82716>>>>>>>        Get _SqlFindKeyWord CI_SQLMulti_User        to sMulti_User
82717>>>>>>>        Get _SqlFindKeyWord CI_SQLRollback          to sRollback
82718>>>>>>>        Get _SqlFindKeyWord CI_SQLIMMEDIATE         to sImmediate
82719>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterDatabase     to sAlterDatabaseKeyWord
82720>>>>>>>        Get _SqlFindKeyWord CI_SQLDatabaseCollation to sCollateKeyWord
82721>>>>>>>
82721>>>>>>>        // MS-SQL Syntax:
82721>>>>>>>        // ALTER DATABASE [database] SET SINGLE_USER WITH ROLLBACK IMMEDIATE;
82721>>>>>>>        // ALTER DATABASE [database] COLLATE SQL_1xCompat_CP850_CI_AS;
82721>>>>>>>        // ALTER DATABASE [database] SET MULTI_USER;
82721>>>>>>>        Move (              sAlterDatabaseKeyWord  * String(sDatabase) * String(sSet) * String(sSingle_User) * String(sWith) * String(sRollback) * String(sImmediate)) to sSQL
82722>>>>>>>        Move (sSQL * String(sAlterDatabaseKeyWord) * String(sDatabase) * String(sCollateKeyWord) * String(sSQLCollation)) to sSQL
82723>>>>>>>        Move (sSQL * String(sAlterDatabaseKeyWord) * String(sDatabase) * String(sSet) * String(sMulti_User)) to sSQL
82724>>>>>>>//        Move (sAlterDatabaseKeyWord * String(sDatabase) * String(sCollateKeyWord) * String(sSQLCollation)) to sSQL
82724>>>>>>>
82724>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
82725>>>>>>>        Send SqlUtilExecuteQuery sSQL sDriverID False
82726>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
82727>>>>>>>        If (LastErr = CLIERR_GENERAL_ERROR) Begin
82729>>>>>>>           Function_Return False
82730>>>>>>>        End
82730>>>>>>>>
82730>>>>>>>
82730>>>>>>>        Function_Return (Err = False)
82731>>>>>>>    End_Function
82732>>>>>>>
82732>>>>>>>
82732>>>>>>>    // * Dummy function for the Studio's Code Explorer *
82732>>>>>>>    Function SQL_TABLE_FUNCTIONS Returns Boolean
82734>>>>>>>        Function_Return False
82735>>>>>>>    End_Function
82736>>>>>>>
82736>>>>>>>    // Converts from SQL to Embedded (DataFlex .dat files).
82736>>>>>>>    // To convert from SQL -> SQL (e.g. from Oracle - > MS SQL)
82736>>>>>>>    //   first use SQLTableConvertToEmbedded in one cDbUpdateVersion object,
82736>>>>>>>    //   and then use the ApiTableConvertToSQL method in a second cDbUpdateVersion object.
82736>>>>>>>    // Note: To convert an embedded table to SQL use ApiTableConvertToSQL.
82736>>>>>>>    Function SqlTableConvertToEmbedded Handle hTable Boolean bCpyDat Returns Boolean
82738>>>>>>>        Handle hToTable
82738>>>>>>>        Boolean bOK bExists bOpened bMertechDriver bCopyData
82738>>>>>>>        String sDriverID sPhysicalName sRootName sDisplayName
82738>>>>>>>        tSQLConnection SQLConnection
82738>>>>>>>        tSQLConnection SQLConnection
82738>>>>>>>        Integer iPos iMaxRecords
82738>>>>>>>
82738>>>>>>>        Get psDriverID to sDriverID
82739>>>>>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
82740>>>>>>>        If (bExists = False) Begin
82742>>>>>>>            Function_Return False
82743>>>>>>>        End
82743>>>>>>>>
82743>>>>>>>
82743>>>>>>>        If (num_arguments > 1) Begin
82745>>>>>>>            Move bCpyDat to bCopyData
82746>>>>>>>        End
82746>>>>>>>>
82746>>>>>>>        Else Begin
82747>>>>>>>            Move False to bCopyData
82748>>>>>>>        End
82748>>>>>>>>
82748>>>>>>>
82748>>>>>>>        Open hTable
82750>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
82753>>>>>>>        If (bOpened = False) Begin
82755>>>>>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
82756>>>>>>>>
82756>>>>>>>            Function_Return False
82757>>>>>>>        End
82757>>>>>>>>
82757>>>>>>>        Move 0 to hToTable
82758>>>>>>>
82758>>>>>>>        Move 16711679 to iMaxRecords
82759>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
82762>>>>>>>        Move (Pos(".", sDisplayName)) to iPos
82763>>>>>>>        If (iPos > 0) Begin
82765>>>>>>>            Move (Mid(sDisplayName, 200, (iPos +1))) to sDisplayName
82766>>>>>>>        End
82766>>>>>>>>
82766>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
82769>>>>>>>        Get _TableNameOnly sRootName                 to sRootName
82770>>>>>>>        Move (sRootName + ".dat")                    to sPhysicalName
82771>>>>>>>
82771>>>>>>>        If (ghoProgressBar <> 0) Begin
82773>>>>>>>            Send DoAdvance of ghoProgressBar
82774>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Converting to Embedded - Table:" * String(sRootName) * "Number:" * String(hTable))
82775>>>>>>>        End
82775>>>>>>>>
82775>>>>>>>
82775>>>>>>>        Move False to Err
82776>>>>>>>
82776>>>>>>>        Structure_Start hToTable DATAFLEX_ID
82777>>>>>>>            Structure_Copy hTable to hToTable
82778>>>>>>>
82778>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
82781>>>>>>>            Set_Attribute DF_FILE_REUSE_DELETED of hToTable to DF_FILE_DELETED_REUSE
82784>>>>>>>            Set_Attribute DF_FILE_MULTIUSER     of hToTable to DF_FILE_USER_MULTI
82787>>>>>>>            Set_Attribute DF_FILE_TRANSACTION   of hToTable to DF_FILE_TRANSACTION_CLIENT_ATOMIC
82790>>>>>>>            Set_Attribute DF_FILE_MAX_RECORDS   of hToTable to iMaxRecords
82793>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
82794>>>>>>>
82794>>>>>>>        Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
82796>>>>>>>
82796>>>>>>>        Set Action_Text of ghoStatusPanel to ""
82797>>>>>>>        Move (not(Err)) to bOK
82798>>>>>>>        If (bOK = True and bCopyData = True) Begin
82800>>>>>>>            Get ApiTableCopyData hTable sPhysicalName sRootName DATAFLEX_ID to bOK
82801>>>>>>>        End
82801>>>>>>>>
82801>>>>>>>
82801>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
82802>>>>>>>        If (bMertechDriver = True) Begin
82804>>>>>>>            Open hTable
82806>>>>>>>        End
82806>>>>>>>>
82806>>>>>>>
82806>>>>>>>        // This must be after copying data...
82806>>>>>>>        If (Err = False) Begin
82808>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
82811>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
82814>>>>>>>        End
82814>>>>>>>>
82814>>>>>>>        Move (not(Err)) to bOK
82815>>>>>>>
82815>>>>>>>        Function_Return (bOK = True)
82816>>>>>>>    End_Function
82817>>>>>>>
82817>>>>>>>    Function AddFolderDelimiter String sPath Returns String
82819>>>>>>>        String sDirSep
82819>>>>>>>        Move (SysConf(SYSCONF_DIR_SEPARATOR)) to sDirSep
82820>>>>>>>        Move (Trim(sPath)) to sPath
82821>>>>>>>        If (Right(sPath, 1) <> sDirSep) Begin
82823>>>>>>>            Move (sPath + sDirSep) to sPath
82824>>>>>>>        End
82824>>>>>>>>
82824>>>>>>>        Function_Return sPath
82825>>>>>>>    End_Function
82826>>>>>>>
82826>>>>>>>    // Creates an SQL Table at the SQL end by its filelist number;
82826>>>>>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
82826>>>>>>>    Function SqlTableCreate Integer hTable Returns Boolean
82828>>>>>>>        String sTableName sSQLString sPath sCreateTable sDriverID
82828>>>>>>>        Integer iDbType
82828>>>>>>>        Boolean bExists
82828>>>>>>>
82828>>>>>>>        Get psDriverID to sDriverID
82829>>>>>>>        Get UtilTableHandleToString hTable to sTableName
82830>>>>>>>        Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
82831>>>>>>>        If (bExists = True) Begin
82833>>>>>>>            Function_Return False
82834>>>>>>>        End
82834>>>>>>>>
82834>>>>>>>
82834>>>>>>>        Get psDataPathFirstPart to sPath
82835>>>>>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
82836>>>>>>>
82836>>>>>>>        Get piDbType to iDbType
82837>>>>>>>        Get _SqlProperTableName sTableName to sTableName
82838>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
82839>>>>>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
82840>>>>>>>
82840>>>>>>>        Move False to Err
82841>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
82842>>>>>>>
82842>>>>>>>        Function_Return (Err = False)
82843>>>>>>>    End_Function
82844>>>>>>>
82844>>>>>>>    // Same as SqlTableCreate but creates an SQL Table at the SQL end by a table name;
82844>>>>>>>    // Also creates a 'DUMMY' column because SQL doesn't like to create a table with no columns!
82844>>>>>>>    Function SqlTableCreateByTableName String sTableName  Returns Boolean
82846>>>>>>>        String sSQLString sPath sCreateTable sDriverID
82846>>>>>>>        Integer iDbType
82846>>>>>>>        Boolean bExists
82846>>>>>>>
82846>>>>>>>        Get psDriverID to sDriverID
82847>>>>>>>        Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
82848>>>>>>>        If (bExists = True) Begin
82850>>>>>>>            Function_Return False
82851>>>>>>>        End
82851>>>>>>>>
82851>>>>>>>
82851>>>>>>>        Get psDataPathFirstPart to sPath
82852>>>>>>>        Get vFilePathExists (sPath + String(sTableName) + ".int") to bExists
82853>>>>>>>        If (bExists = True) Begin
82855>>>>>>>            // ToDo: What should we do if an .int file already exists?
82855>>>>>>>        End
82855>>>>>>>>
82855>>>>>>>
82855>>>>>>>        Get piDbType to iDbType
82856>>>>>>>        Get _SqlProperTableName sTableName to sTableName
82857>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateTable iDbType to sCreateTable
82858>>>>>>>        Move (sCreateTable * String(sTableName) * "(Dummy Decimal(2,0))") to sSQLString
82859>>>>>>>
82859>>>>>>>        Move False to Err
82860>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
82861>>>>>>>
82861>>>>>>>        Function_Return (Err = False)
82862>>>>>>>    End_Function
82863>>>>>>>    
82863>>>>>>>    // ToDo: 2019-09-23 This needs to be finilized 
82863>>>>>>>    // It resets SQL constraints after a Structure_End, if necessary.
82863>>>>>>>    Function SqlTableRecreateConstraints Handle hTable Returns Boolean
82865>>>>>>>        Boolean bOK                                                            
82865>>>>>>>        String sStatement
82865>>>>>>>        Move "ALTER TABLE [dbo].[THREADS] ADD  DEFAULT ((0)) FOR [SEGMENTS]" to sStatement
82866>>>>>>>        Function_Return bOK
82867>>>>>>>    End_Function
82868>>>>>>>    
82868>>>>>>>    // First deletes the data cache file and then drops the passed SQL table.
82868>>>>>>>    // Note: The table needs to exist in filelist.cfg, and it must be possible to open it,
82868>>>>>>>    //       else try using the SqlTableRemoveByTableName message.
82868>>>>>>>    Function SqlTableRemove Handle hTable Returns Boolean
82870>>>>>>>        String sSQLString sPath sDropTable sTableName sDriverID
82870>>>>>>>        Integer iRetval iDbType
82870>>>>>>>        Boolean bExists bMertechDriver bOK
82870>>>>>>>
82870>>>>>>>        Get psDriverID to sDriverID
82871>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
82872>>>>>>>        Get UtilTableHandleToString hTable to sTableName
82873>>>>>>>        Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
82874>>>>>>>        If (bExists = False) Begin
82876>>>>>>>            Function_Return False
82877>>>>>>>        End
82877>>>>>>>>
82877>>>>>>>
82877>>>>>>>        Get psDataPathFirstPart to sPath
82878>>>>>>>        Get UtilDeleteCacheFile sTableName to iRetval
82879>>>>>>>
82879>>>>>>>        Get piDbType to iDbType
82880>>>>>>>        Get _SqlProperTableName sTableName to sTableName
82881>>>>>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
82882>>>>>>>        Move (sDropTable * String(sTableName)) to sSQLString
82883>>>>>>>
82883>>>>>>>        Move False to Err
82884>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
82885>>>>>>>
82885>>>>>>>        // We also need to remove the cache-file since the table has been changed
82885>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
82886>>>>>>>
82886>>>>>>>        Function_Return (Err = False)
82887>>>>>>>    End_Function
82888>>>>>>>
82888>>>>>>>    // First deletes the data cache file and then drops the passed data table.
82888>>>>>>>    Function SqlTableRemoveByTableName String sTableName Returns Boolean
82890>>>>>>>        String sSQLString sPath sDropTable sVal sSchema sDriverID
82890>>>>>>>        Integer iRetval iDbType
82890>>>>>>>        Boolean bMertechDriver bOK
82890>>>>>>>
82890>>>>>>>        Get psDriverID to sDriverID
82891>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
82892>>>>>>>        Get psDataPathFirstPart to sPath
82893>>>>>>>        Get UtilDeleteCacheFile sTableName to iRetval
82894>>>>>>>
82894>>>>>>>        Get piDbType to iDbType
82895>>>>>>>        Get _SqlFindKeyWord CI_SQLDropTable iDbType to sDropTable
82896>>>>>>>        Get psSchema to sSchema
82897>>>>>>>        If (sSchema = "") Begin
82899>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
82900>>>>>>>        End
82900>>>>>>>>
82900>>>>>>>        Move (Uppercase(sTableName)) to sVal
82901>>>>>>>        If (not(sVal contains (sSchema + "."))) Begin
82903>>>>>>>            Move (Lowercase(sSchema) + "." + sTableName) to sTableName
82904>>>>>>>        End
82904>>>>>>>>
82904>>>>>>>        Move (sDropTable * String(sTableName)) to sSQLString
82905>>>>>>>
82905>>>>>>>        Move False to Err
82906>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
82907>>>>>>>
82907>>>>>>>        // We also need to remove the cache-file since the table has been changed
82907>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
82908>>>>>>>
82908>>>>>>>        Function_Return (Err = False)
82909>>>>>>>    End_Function
82910>>>>>>>
82910>>>>>>>    // *** Sql View Messages ***
82910>>>>>>>
82910>>>>>>>    // First deletes the data cache file and then drops the passed Sql data view.
82910>>>>>>>    Function SqlViewRemove String sDataView Returns Boolean
82912>>>>>>>        String sDriverID sSQLString sDropViewKeyWord
82912>>>>>>>        Integer iRetval
82912>>>>>>>        Boolean bMertechDriver bOK
82912>>>>>>>
82912>>>>>>>        Get psDriverID to sDriverID
82913>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
82914>>>>>>>        Get UtilDeleteCacheFile sDataView to iRetval
82915>>>>>>>
82915>>>>>>>        Get _SqlFindKeyWord CI_SQLDropView to sDropViewKeyWord
82916>>>>>>>        Move (sDropViewKeyWord * String(sDataView)) to sSQLString
82917>>>>>>>        Set psSQLStatementString to sSQLString
82918>>>>>>>
82918>>>>>>>        // As we don't check if the view exist or not, it might happen
82918>>>>>>>        // that it doesn't and that would through an error, so guard for that eventuality (just ignore it).
82918>>>>>>>        Move False to Err
82919>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
82920>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
82921>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
82922>>>>>>>        Move 0 to LastErr
82923>>>>>>>
82923>>>>>>>        // We also need to remove the cache-file since the table has been changed
82923>>>>>>>        Get UtilDeleteCacheFile sDataView to bOK
82924>>>>>>>
82924>>>>>>>        Function_Return (Err = False)
82925>>>>>>>    End_Function
82926>>>>>>>
82926>>>>>>>    Function SqlTableRename Handle hTable String sCurrentTableName String sNewtTableName Returns Boolean
82928>>>>>>>        Boolean bOK
82928>>>>>>>        Integer iDbType
82928>>>>>>>        String sDriverID sAlterTable sRenameTable sSQLTo sSQLString
82928>>>>>>>
82928>>>>>>>        Get psDriverID to sDriverID
82929>>>>>>>        Get piDbType   to iDbType
82930>>>>>>>
82930>>>>>>>        Case Begin
82930>>>>>>>            Case (iDbType = EN_DbTypeDB2)
82932>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
82933>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
82934>>>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
82935>>>>>>>            Break
82936>>>>>>>
82936>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
82939>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
82940>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
82941>>>>>>>                Move (sRenameTable * "'" - sCurrentTableName - "', '" - String(sNewtTableName) - "'") to sSQLString
82942>>>>>>>            Break
82943>>>>>>>
82943>>>>>>>            Case (iDbType = EN_DbTypeOracle)
82946>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
82947>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
82948>>>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
82949>>>>>>>            Break
82950>>>>>>>
82950>>>>>>>            Case (iDbType = EN_DbTypePostgre)
82953>>>>>>>                Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
82954>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
82955>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
82956>>>>>>>                Move (sAlterTable * sCurrentTableName * sRenameTable * sSQLTo * String(sNewtTableName)) to sSQLString
82957>>>>>>>            Break
82958>>>>>>>
82958>>>>>>>            Case (iDbType = EN_DbTypeMySQL)
82961>>>>>>>                Get _SqlFindKeyWord CI_SQLRenameTable to sRenameTable
82962>>>>>>>                Get _SqlFindKeyWord CI_SQLTo          to sSQLTo
82963>>>>>>>                Move (Replaces("-", sNewtTableName, "_")) to sNewtTableName
82964>>>>>>>                Move (sRenameTable * sCurrentTableName * sSQLTo * String(sNewtTableName)) to sSQLString
82965>>>>>>>            Break
82966>>>>>>>        Case End
82966>>>>>>>
82966>>>>>>>        Move False to Err
82967>>>>>>>        Send SqlUtilExecuteQuery sSQLString sDriverID
82968>>>>>>>        Move (Err = False) to bOK
82969>>>>>>>
82969>>>>>>>        Function_Return bOK
82970>>>>>>>    End_Function
82971>>>>>>>
82971>>>>>>>    // * Dummy function for the Studio's Code Explorer *
82971>>>>>>>    Function SQL_COLUMN_FUNCTIONS Returns Boolean
82973>>>>>>>        Function_Return False
82974>>>>>>>    End_Function
82975>>>>>>>
82975>>>>>>>    // Sample: Get SqlColumnAdd MyTable.File_Number "NewColumnName" True "InitValue" DF_ASCII_DUF 35
82975>>>>>>>    Function SqlColumnAdd Integer hTable String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
82977>>>>>>>        Integer iLength iDecimals
82977>>>>>>>        String sColumnValue
82977>>>>>>>        String sTableName sDriverID
82977>>>>>>>        Boolean bOK bInitializeValue
82977>>>>>>>
82977>>>>>>>        Get psDriverID to sDriverID
82978>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
82979>>>>>>>        If (bOK = False) Begin
82981>>>>>>>            Function_Return False
82982>>>>>>>        End
82982>>>>>>>>
82982>>>>>>>
82982>>>>>>>        Get UtilTableHandleToString hTable to sTableName
82983>>>>>>>        If (sTableName = "") Begin
82985>>>>>>>            Function_Return False
82986>>>>>>>        End
82986>>>>>>>>
82986>>>>>>>
82986>>>>>>>        If (num_arguments > 3) Begin
82988>>>>>>>            Move iLen     to iLength
82989>>>>>>>            Move iDec     to iDecimals
82990>>>>>>>            Move bInitVal to bInitializeValue
82991>>>>>>>            Move sColVal  to sColumnValue
82992>>>>>>>        End
82992>>>>>>>>
82992>>>>>>>
82992>>>>>>>        Get SqlColumnAddByTableName sTableName sColumnName iDataType iLen iDecimals bInitializeValue sColumnValue to bOK
82993>>>>>>>
82993>>>>>>>        Function_Return (bOK = True)
82994>>>>>>>    End_Function
82995>>>>>>>
82995>>>>>>>    // Sample: Get SqlColumnAddByTableName "MyTable" "NewColumnName" DF_ASCII_DUF 35 0 True "InitValue"
82995>>>>>>>    Function SqlColumnAddByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Boolean bInitVal String sColVal Returns Boolean
82997>>>>>>>        Integer iDbType iLength iDecimals iDriver
82997>>>>>>>        String sStmt sAlterTable sAddColumn sVal sDataType sLengthAndDecimals sColumnValue
82997>>>>>>>        String sDriverID sNotNull
82997>>>>>>>        Boolean bOK bInitializeValue bRetval bFixed bDriverIgnoreErrorState bIsMertechDriver
82997>>>>>>>        Handle hTable
82997>>>>>>>
82997>>>>>>>        Get psDriverID to sDriverID
82998>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
82999>>>>>>>        If (bOK = False) Begin
83001>>>>>>>            Function_Return True
83002>>>>>>>        End
83002>>>>>>>>
83002>>>>>>>
83002>>>>>>>        Get UtilTableNameToHandle sTableName to hTable
83003>>>>>>>        If (hTable = 0) Begin
83005>>>>>>>            Get NextFreeFilelistSlot to hTable
83006>>>>>>>        End
83006>>>>>>>>
83006>>>>>>>
83006>>>>>>>        Get piDbType to iDbType
83007>>>>>>>        // If a field/column already exists; we just ignore the request to not add unneccesary errors to the log.
83007>>>>>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
83008>>>>>>>        If (Uppercase(sVal) = Uppercase(sColumnName)) Begin
83010>>>>>>>            Function_Return True
83011>>>>>>>        End
83011>>>>>>>>
83011>>>>>>>
83011>>>>>>>        Get DriverIndex sDriverID to iDriver
83012>>>>>>>        Get IsMertechDriver sDriverID to bIsMertechDriver
83013>>>>>>>        If (bIsMertechDriver = False) Begin
83015>>>>>>>            Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
83018>>>>>>>            Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
83021>>>>>>>        End
83021>>>>>>>>
83021>>>>>>>
83021>>>>>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
83022>>>>>>>        If (num_arguments > 3) Begin
83024>>>>>>>            Move iLen     to iLength
83025>>>>>>>            Move iDec     to iDecimals
83026>>>>>>>            Move bInitVal to bInitializeValue
83027>>>>>>>            Move sColVal  to sColumnValue
83028>>>>>>>        End
83028>>>>>>>>
83028>>>>>>>
83028>>>>>>>        Get _SqlProperTableName sTableName   to sTableName
83029>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
83030>>>>>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
83031>>>>>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
83032>>>>>>>
83032>>>>>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
83033>>>>>>>        If (bFixed = False) Begin
83035>>>>>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
83036>>>>>>>        End
83036>>>>>>>>
83036>>>>>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
83037>>>>>>>
83037>>>>>>>        Move False to Err
83038>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
83039>>>>>>>
83039>>>>>>>        If (bInitializeValue = True and Err = False) Begin
83041>>>>>>>            Get SQLColumnUpdateValue hTable sColumnName sColumnValue to bRetval
83042>>>>>>>        End
83042>>>>>>>>
83042>>>>>>>
83042>>>>>>>        If (Err = False) Begin
83044>>>>>>>            Get SqlUtilAdjustAuxFiles hTable sTableName sColumnName to bOK
83045>>>>>>>        End
83045>>>>>>>>
83045>>>>>>>
83045>>>>>>>        Move (not(Err)) to bRetval
83046>>>>>>>
83046>>>>>>>        // We also need to remove the cache-file since the table has been changed
83046>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
83047>>>>>>>        If (bIsMertechDriver = False) Begin
83049>>>>>>>            Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
83052>>>>>>>        End
83052>>>>>>>>
83052>>>>>>>        Function_Return bRetval
83053>>>>>>>    End_Function
83054>>>>>>>
83054>>>>>>>    // To update all current rows for a table column with a common value.
83054>>>>>>>    Function SqlColumnUpdateValue Handle hTable String sColumnName String sColumnValue Returns Boolean
83056>>>>>>>        String sDriverID sTableName sUpdate sSet sNoCountOn sSqlSafe_Updates sStmt
83056>>>>>>>        Boolean bRetval bSQLDriver
83056>>>>>>>        Integer iCurrErr iDbType
83056>>>>>>>
83056>>>>>>>        Move False to bRetval
83057>>>>>>>        Get piDbType to iDbType
83058>>>>>>>        Get psDriverID to sDriverID
83059>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
83060>>>>>>>        If (bSQLDriver = False) Begin
83062>>>>>>>            Function_Return bRetval
83063>>>>>>>        End
83063>>>>>>>>
83063>>>>>>>        Get UtilTableHandleToString hTable to sTableName
83064>>>>>>>
83064>>>>>>>        Move Err to iCurrErr
83065>>>>>>>        Move False to Err
83066>>>>>>>        Get _SqlFindKeyWord CI_SQLUpdate       to sUpdate
83067>>>>>>>        Get _SqlFindKeyWord CI_SQLSet          to sSet
83068>>>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountOn
83069>>>>>>>        If (sDriverID = MDSMySQL) Begin
83071>>>>>>>            Get _SqlFindKeyWord CI_SQL_SAFE_UPDATES to sSqlSafe_Updates
83072>>>>>>>            Move (sSet * sSqlSafe_Updates + "=0;" * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'" * sSet * sSqlSafe_Updates + "=1") to sStmt
83073>>>>>>>        End
83073>>>>>>>>
83073>>>>>>>        // If MySQL and DAW's ODBC driver is used we need to do it slightly different.
83073>>>>>>>        If (iDbType = EN_DbTypeMySQL) Begin
83075>>>>>>>            Get _SqlFindKeyWord CI_SQL_SAFE_UPDATES to sSqlSafe_Updates
83076>>>>>>>            Move (sSet * sSqlSafe_Updates + "=0;" * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'") to sStmt
83077>>>>>>>        End
83077>>>>>>>>
83077>>>>>>>        Else Begin
83078>>>>>>>            Move (sNoCountOn * sUpdate * sTableName * sSet * sColumnName + "='" + sColumnValue + "'") to sStmt
83079>>>>>>>        End
83079>>>>>>>>
83079>>>>>>>
83079>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
83080>>>>>>>        Move (Err = False) to bRetval
83081>>>>>>>        Move iCurrErr to Err
83082>>>>>>>
83082>>>>>>>        Function_Return bRetval
83083>>>>>>>    End_Function
83084>>>>>>>
83084>>>>>>>    // The fourth & fifth arguments are optional, depending on the iDataType
83084>>>>>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
83084>>>>>>>    Function SqlColumnChange Handle hTable String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
83086>>>>>>>        String sDriverID sTableName
83086>>>>>>>        Boolean bOK
83086>>>>>>>
83086>>>>>>>        Get psDriverID to sDriverID
83087>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
83088>>>>>>>        If (bOK = False) Begin
83090>>>>>>>            Function_Return False
83091>>>>>>>        End
83091>>>>>>>>
83091>>>>>>>
83091>>>>>>>        Get UtilTableHandleToString hTable to sTableName
83092>>>>>>>        Get SqlColumnChangeByTableName sTableName sColumnName iDataType iLen iDec to bOK
83093>>>>>>>
83093>>>>>>>        Function_Return (Err = False)
83094>>>>>>>    End_Function
83095>>>>>>>
83095>>>>>>>    // Same as SqlColumnChange but instead of passing a filelist number; pass the table name as a string.
83095>>>>>>>    // The fourth & fifth arguments are optional, depending on the iDataType
83095>>>>>>>    // passed. For e.g. a DF_ASCII the iLen must be passed.                     // Optional: // Optional:
83095>>>>>>>    Function SqlColumnChangeByTableName String sTableName String sColumnName Integer iDataType Integer iLen Integer iDec Returns Boolean
83097>>>>>>>        Integer iDbType iLength iDecimals
83097>>>>>>>        String sDriverID sStmt sAlterTable sAlterColumn sDataType sLengthAndDecimals sNotNull
83097>>>>>>>        Boolean bExists bOK bFixed
83097>>>>>>>        Handle hTable
83097>>>>>>>
83097>>>>>>>        Get psDriverID to sDriverID
83098>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
83099>>>>>>>        If (bOK = False) Begin
83101>>>>>>>            Function_Return False
83102>>>>>>>        End
83102>>>>>>>>
83102>>>>>>>
83102>>>>>>>        Get UtilTableNameToHandle sTableName to hTable
83103>>>>>>>        If (hTable = 0) Begin
83105>>>>>>>            Get NextFreeFilelistSlot to hTable
83106>>>>>>>        End
83106>>>>>>>>
83106>>>>>>>        Get SQLUtilColumnExists sTableName sColumnName to bExists
83107>>>>>>>        If (bExists = False) Begin
83109>>>>>>>            Function_Return False
83110>>>>>>>        End
83110>>>>>>>>
83110>>>>>>>
83110>>>>>>>        If (num_arguments > 3) Begin
83112>>>>>>>            Move iLen to iLength
83113>>>>>>>        End
83113>>>>>>>>
83113>>>>>>>        If (num_arguments > 4) Begin
83115>>>>>>>            Move iDec to iDecimals
83116>>>>>>>        End
83116>>>>>>>>
83116>>>>>>>
83116>>>>>>>        Get piDbType to iDbType
83117>>>>>>>        Get UtilColumnTypeToString sDriverID iDbType iDataType to sDataType
83118>>>>>>>
83118>>>>>>>        Move False to Err
83119>>>>>>>        Get _SqlProperTableName sTableName    to sTableName
83120>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
83121>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterColumn to sAlterColumn
83122>>>>>>>        Get SQLUtilDefaultNullValue sDriverID iDbType iDataType to sNotNull
83123>>>>>>>
83123>>>>>>>        Get UtilColumnTypeFixed sDriverID iDbType iDataType to bFixed
83124>>>>>>>        If (bFixed = False) Begin
83126>>>>>>>            Get _SqlFormatLengthAndDecimalAsString iLength iDecimals to sLengthAndDecimals
83127>>>>>>>        End
83127>>>>>>>>
83127>>>>>>>
83127>>>>>>>        Move (sAlterTable * sTableName * sAlterColumn * sColumnName * sDataType + sLengthAndDecimals * sNotNull) to sStmt
83128>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
83129>>>>>>>
83129>>>>>>>        // We also need to remove the cache-file since the table has been changed
83129>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
83130>>>>>>>
83130>>>>>>>        Function_Return (Err = False)
83131>>>>>>>    End_Function
83132>>>>>>>
83132>>>>>>>    Function SqlColumnDefaultValue Handle hTable Integer iColumn String sValue Returns Boolean
83134>>>>>>>        Boolean bOK bErr bIsSQLDriver
83134>>>>>>>        String sDriverID
83134>>>>>>>        Integer iDataType
83134>>>>>>>
83134>>>>>>>        Get psDriverID to sDriverID
83135>>>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
83136>>>>>>>        If (bIsSQLDriver = False) Begin
83138>>>>>>>            Function_Return False
83139>>>>>>>        End
83139>>>>>>>>
83139>>>>>>>
83139>>>>>>>        Move Err to bErr
83140>>>>>>>        Move False to bErr
83141>>>>>>>
83141>>>>>>>        // There seems to be a problem with the ODBC_DRV driver that sometimes
83141>>>>>>>        // inserts randomly character(10) and spaces, so we correct from that here:
83141>>>>>>>        Move (Replaces(Character(10), Trim(sValue), "")) to sValue
83142>>>>>>>        Get_Attribute DF_FIELD_TYPE of hTable iColumn to iDataType
83145>>>>>>>        If (iDataType = DF_BCD and Left(sValue, 1 <> "[")) Begin
83147>>>>>>>            Move ("[" + String(sValue) + "]") to sValue
83148>>>>>>>        End
83148>>>>>>>>
83148>>>>>>>
83148>>>>>>>        Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sValue
83151>>>>>>>        Move (not(Err)) to bOK
83152>>>>>>>        Move bErr to Err
83153>>>>>>>
83153>>>>>>>        Function_Return bOK
83154>>>>>>>    End_Function
83155>>>>>>>
83155>>>>>>>    Function SqlColumnNullable Handle hTable Integer iColumn Boolean bNullable Returns Boolean
83157>>>>>>>        Boolean bOK bErr bCurrentState bOpen bIsSQLDriver
83157>>>>>>>        String sDriverID
83157>>>>>>>
83157>>>>>>>        Get psDriverID to sDriverID
83158>>>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
83159>>>>>>>        If (bIsSQLDriver = False) Begin
83161>>>>>>>            Function_Return False
83162>>>>>>>        End
83162>>>>>>>>
83162>>>>>>>
83162>>>>>>>        Move Err to bErr
83163>>>>>>>        Move False to bErr
83164>>>>>>>        Get_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bCurrentState
83167>>>>>>>        If (bNullable = bCurrentState) Begin
83169>>>>>>>            Function_Return True
83170>>>>>>>        End
83170>>>>>>>>
83170>>>>>>>
83170>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
83173>>>>>>>        If (bOpen = False) Begin
83175>>>>>>>            Get AutoConnectionIDLogin to bOK
83176>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
83177>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
83178>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
83179>>>>>>>            Open hTable
83181>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
83182>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
83183>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
83184>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
83187>>>>>>>        End
83187>>>>>>>>
83187>>>>>>>        If (bOpen = True) Begin
83189>>>>>>>            Structure_Start hTable sDriverID
83190>>>>>>>                Set_Attribute DF_FIELD_NULL_ALLOWED of hTable iColumn to bNullable
83193>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
83194>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
83196>>>>>>>            Set Action_Text of ghoStatusPanel to ""
83197>>>>>>>        End
83197>>>>>>>>
83197>>>>>>>
83197>>>>>>>        Move (not(Err)) to bOK
83198>>>>>>>        Move bErr to Err
83199>>>>>>>
83199>>>>>>>        Function_Return bOK
83200>>>>>>>    End_Function
83201>>>>>>>
83201>>>>>>>    // Drop column by its table handle
83201>>>>>>>    Function SqlColumnRemove Handle hTable String sColumnName Returns Boolean
83203>>>>>>>        String sDriverID sTableName
83203>>>>>>>        Boolean bOK
83203>>>>>>>
83203>>>>>>>        Get psDriverID to sDriverID
83204>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
83205>>>>>>>        If (bOK = False) Begin
83207>>>>>>>            Function_Return False
83208>>>>>>>        End
83208>>>>>>>>
83208>>>>>>>
83208>>>>>>>        Get UtilTableHandleToString hTable to sTableName
83209>>>>>>>        If (sTableName = "") Begin
83211>>>>>>>            Function_Return False
83212>>>>>>>        End
83212>>>>>>>>
83212>>>>>>>
83212>>>>>>>        Get SqlColumnRemoveByTableName sTableName sColumnName to bOK
83213>>>>>>>
83213>>>>>>>        Function_Return (bOK = True)
83214>>>>>>>    End_Function
83215>>>>>>>
83215>>>>>>>    // Drop column by its table name as a string.
83215>>>>>>>    Function SqlColumnRemoveByTableName String sTableName String sColumnName Returns Boolean
83217>>>>>>>        Integer iDbType iDriver
83217>>>>>>>        String sDriverID sStmt sAlterTable sDropColumn
83217>>>>>>>        Boolean bExists bOK bRetval bDriverIgnoreErrorState
83217>>>>>>>        Handle hTable
83217>>>>>>>
83217>>>>>>>        Get psDriverID to sDriverID
83218>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
83219>>>>>>>        If (bOK = False) Begin
83221>>>>>>>            Function_Return False
83222>>>>>>>        End
83222>>>>>>>>
83222>>>>>>>
83222>>>>>>>        Get DriverIndex sDriverID to iDriver
83223>>>>>>>        Get_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
83226>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to True
83229>>>>>>>
83229>>>>>>>        Get UtilTableNameToHandle sTableName to hTable
83230>>>>>>>        If (hTable <> 0) Begin
83232>>>>>>>            Get SQLUtilColumnExists sTableName sColumnName to bExists
83233>>>>>>>            If (bExists = False) Begin
83235>>>>>>>                Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
83238>>>>>>>                Function_Return False
83239>>>>>>>            End
83239>>>>>>>>
83239>>>>>>>        End
83239>>>>>>>>
83239>>>>>>>
83239>>>>>>>        Get piDbType to iDbType
83240>>>>>>>        If (iDbType = EN_DbTypeMSSQL) Begin
83242>>>>>>>            Get _SqlUtilRemoveTableColumnMSSQL sTableName sColumnName to bOK
83243>>>>>>>            Get UtilDeleteCacheFile sTableName to bOK
83244>>>>>>>            Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
83247>>>>>>>            Function_Return bOK
83248>>>>>>>        End
83248>>>>>>>>
83248>>>>>>>
83248>>>>>>>        Move False to Err
83249>>>>>>>        Get _SqlProperTableName sTableName    to sTableName
83250>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable  to sAlterTable
83251>>>>>>>        Get _SqlFindKeyWord CI_SQLDropColumn  to sDropColumn
83252>>>>>>>
83252>>>>>>>        Move (sAlterTable * sTableName * sDropColumn * sColumnName) to sStmt
83253>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
83254>>>>>>>        Move (not(Err)) to bRetval
83255>>>>>>>
83255>>>>>>>        // We also need to remove the cache-file since the table has been changed
83255>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
83256>>>>>>>        Set_Attribute DF_DRIVER_IGNORE_WARNINGS of iDriver to bDriverIgnoreErrorState
83259>>>>>>>
83259>>>>>>>        Function_Return bRetval
83260>>>>>>>    End_Function
83261>>>>>>>
83261>>>>>>>    // Rename a field/column by table handle (filelist number)
83261>>>>>>>    Function SqlColumnRename Integer hTable String sColumnName String sNewColumnName Returns Boolean
83263>>>>>>>        String sDriverID sTableName
83263>>>>>>>        Boolean bOK
83263>>>>>>>
83263>>>>>>>        Get psDriverID to sDriverID
83264>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
83265>>>>>>>        If (bOK = False) Begin
83267>>>>>>>            Function_Return False
83268>>>>>>>        End
83268>>>>>>>>
83268>>>>>>>
83268>>>>>>>        Get UtilTableHandleToString hTable to sTableName
83269>>>>>>>        Get SqlColumnRenameByTableName sTableName sColumnName sNewColumnName to bOK
83270>>>>>>>
83270>>>>>>>        Function_Return (Err = False)
83271>>>>>>>    End_Function
83272>>>>>>>
83272>>>>>>>    // Rename a field/column by table name.
83272>>>>>>>    Function SqlColumnRenameByTableName String sTableName String sColumnName String sNewColumnName Returns Boolean
83274>>>>>>>        Integer iDbType iDataType
83274>>>>>>>        String sDriverID sStmt sAlterTable sRenameColumn sVal sColumnKeyWord sOrgTableName sDatabase sDataType
83274>>>>>>>        Boolean bOK bRetval
83274>>>>>>>        Handle hTable
83274>>>>>>>
83274>>>>>>>        Move sTableName to sOrgTableName
83275>>>>>>>        Get psDriverID to sDriverID
83276>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
83277>>>>>>>        If (bOK = False) Begin
83279>>>>>>>            Function_Return False
83280>>>>>>>        End
83280>>>>>>>>
83280>>>>>>>
83280>>>>>>>        Get _SqlFindColumnName sTableName sColumnName to sVal
83281>>>>>>>        If (sVal = "") Begin
83283>>>>>>>            Function_Return False
83284>>>>>>>        End
83284>>>>>>>>
83284>>>>>>>
83284>>>>>>>        Get piDbType to iDbType
83285>>>>>>>        Get _SqlFindKeyWord CI_SQLColumn       to sColumnKeyWord
83286>>>>>>>        Get _SqlProperTableName sTableName     to sTableName
83287>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable   to sAlterTable
83288>>>>>>>        Get _SqlFindKeyWord CI_SQLRenameColumn to sRenameColumn
83289>>>>>>>
83289>>>>>>>        Case Begin
83289>>>>>>>            Case (iDbType = EN_dbTypeMSSQL)
83291>>>>>>>                Move (sRenameColumn * "'" + sTableName + "." + sColumnName + "'," * "'" + sNewColumnName + "'," * "'" + sColumnKeyWord + "'") to sStmt
83292>>>>>>>                Case Break
83293>>>>>>>            // Alter table "SYS"."Customer" rename column "Comments" to "NewColumnName"
83293>>>>>>>            Case (iDbType = EN_dbTypeOracle)
83296>>>>>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
83297>>>>>>>                Case Break
83298>>>>>>>            // ALTER TABLE Schema.TableName RENAME COLUMN "deptnumb" TO "deptnum"
83298>>>>>>>            Case (iDbType = EN_dbTypeDB2)
83301>>>>>>>                Move (sAlterTable *  sTableName * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
83302>>>>>>>                Case Break
83303>>>>>>>            // ALTER TABLE "Customer" RENAME COLUMN "Comments" TO "NewColumnName"
83303>>>>>>>            Case (iDbType = EN_dbTypePostgre)
83306>>>>>>>                Move sOrgTableName to sTableName
83307>>>>>>>                Move (sAlterTable * '"' + sTableName + '"' * sRenameColumn * '"' + sColumnName + '"' * "TO" * '"' + sNewColumnName + '"') to sStmt
83308>>>>>>>                Case Break
83309>>>>>>>            Case (iDbType = EN_dbTypeMySQL)
83312>>>>>>>                // ALTER TABLE orderentry.customer CHANGE Comments NewColumnName text // Note: The last token is the column type!
83312>>>>>>>                Move sOrgTableName to sTableName
83313>>>>>>>                Get psDatabase to sDatabase
83314>>>>>>>                Get UtilTableNameToHandle sTableName to hTable
83315>>>>>>>                If (hTable = 0) Begin
83317>>>>>>>                    Get UtilTableOpen hTable sTableName DF_SHARE to bOK
83318>>>>>>>                    If (bOK = False) Begin
83320>>>>>>>                        Function_Return False
83321>>>>>>>                    End
83321>>>>>>>>
83321>>>>>>>                    Get NextFreeFilelistSlot to hTable
83322>>>>>>>                End
83322>>>>>>>>
83322>>>>>>>                Else Begin
83323>>>>>>>                    Open hTable
83325>>>>>>>                End
83325>>>>>>>>
83325>>>>>>>                Get SQLColumnType sDriverID hTable sTableName sColumnName to iDataType
83326>>>>>>>                Get UtilColumnTypeToString sDriverID iDbType iDataType    to sDataType
83327>>>>>>>                Move (sAlterTable * sDatabase + "." + sTableName * sRenameColumn * sColumnName * sNewColumnName * sDataType) to sStmt
83328>>>>>>>                Case Break
83329>>>>>>>            Case Else
83329>>>>>>>                Move (sAlterTable * "'" + sTableName + "'" * sRenameColumn * "'" + sTableName + "." + sColumnName + "'" * "TO" * "'" + sNewColumnName + "'") to sStmt
83330>>>>>>>        Case End
83330>>>>>>>
83330>>>>>>>        Move False to Err
83331>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
83332>>>>>>>        Move (Err = False) to bRetval
83333>>>>>>>        // We also need to remove the cache-file since the table has been changed
83333>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
83334>>>>>>>
83334>>>>>>>        Function_Return bRetval
83335>>>>>>>    End_Function
83336>>>>>>>
83336>>>>>>>    Function SqlColumnType String sDriverID Handle hTable String sTableName String sColumnName Returns Integer
83338>>>>>>>        Handle hoSQLHandler hSQLConnect hStmt
83338>>>>>>>        Boolean bMertechDriver
83338>>>>>>>        Integer iNumCols iCount iDataType
83338>>>>>>>        String sValue
83338>>>>>>>
83338>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
83339>>>>>>>        If (bMertechDriver = False) Begin
83341>>>>>>>            Get phoSQLManager to hoSQLHandler
83342>>>>>>>        End
83342>>>>>>>>
83342>>>>>>>        Else Begin
83343>>>>>>>            Get _MertechSQLManagerHandle to hoSQLHandler
83344>>>>>>>        End
83344>>>>>>>>
83344>>>>>>>
83344>>>>>>>        Get SQLFileConnect of hoSQLHandler hTable to hSQLConnect
83345>>>>>>>        If (hSQLConnect <> 0) Begin
83347>>>>>>>            Get SQLOpen of hSQLConnect to hStmt
83348>>>>>>>            If (hStmt <> 0) Begin
83350>>>>>>>                Send SQLExecDirect of hStmt ("select * from" * sTableName)
83351>>>>>>>
83351>>>>>>>                Get SQLStmtAttribute of hStmt SQLSTMTATTRIB_COLUMNCOUNT to iNumCols
83352>>>>>>>                For iCount from 1 to iNumCols
83358>>>>>>>>
83358>>>>>>>                    Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_LABEL to sValue
83359>>>>>>>                    If (Lowercase(sValue) = Lowercase(sColumnName)) Begin
83361>>>>>>>                        Get SQLColAttribute of hStmt iCount SQLCOLATTRIB_SQLTYPE to iDataType
83362>>>>>>>                        Move iNumCols to iCount // We're out of here
83363>>>>>>>                    End
83363>>>>>>>>
83363>>>>>>>                Loop
83364>>>>>>>>
83364>>>>>>>
83364>>>>>>>                Send SQLClose of hStmt
83365>>>>>>>            End
83365>>>>>>>>
83365>>>>>>>            Send SQLDisconnect of hSQLConnect
83366>>>>>>>        End
83366>>>>>>>>
83366>>>>>>>
83366>>>>>>>        Function_Return iDataType
83367>>>>>>>    End_Function
83368>>>>>>>
83368>>>>>>>    // * Dummy function for the Studio's Code Explorer *
83368>>>>>>>    Function SQL_EXECUTE_FUNCTIONS Returns Boolean
83370>>>>>>>        Function_Return False
83371>>>>>>>    End_Function
83372>>>>>>>
83372>>>>>>>    Procedure SqlUtilExecuteQuery String sStmt String sDriverID Boolean bShowProgr
83374>>>>>>>        String sMessage // sConnectionString
83374>>>>>>>        Handle hoSqlHandler hoSQLConnect hoStmt hoError
83374>>>>>>>        Integer i iMsgs iFetchResult iRowType iRows iErr iMessage iLastErr
83374>>>>>>>        String[] sMsg aSQLQueryMessages aSQLFetchResults
83377>>>>>>>        DateTime dtQueryExecStart dtQueryExecEnd dtFetchStart dtFetchEnd
83377>>>>>>>        TimeSpan tsQuery tsFetch
83377>>>>>>>        tSqlErrorArray aSqlErrorArray
83377>>>>>>>        tSqlErrorArray aSqlErrorArray
83377>>>>>>>        Boolean bOK bMertechDriver bShowProgress
83377>>>>>>>        tSQLConnection SQLConnection
83377>>>>>>>        tSQLConnection SQLConnection
83377>>>>>>>
83377>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
83378>>>>>>>        If (bOK = False) Begin
83380>>>>>>>            Procedure_Return
83381>>>>>>>        End
83381>>>>>>>>
83381>>>>>>>
83381>>>>>>>        If (num_arguments > 2) Begin
83383>>>>>>>            Move bShowProgr to bShowProgress
83384>>>>>>>        End
83384>>>>>>>>
83384>>>>>>>
83384>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
83385>>>>>>>
83385>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
83386>>>>>>>        If (bMertechDriver = True) Begin
83388>>>>>>>            Get _MertechSQLConnect sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
83389>>>>>>>        End
83389>>>>>>>>
83389>>>>>>>        If (bMertechDriver = False) Begin
83391>>>>>>>            Get phoSQLManager to hoSqlHandler
83392>>>>>>>            Send SqlSetConnect of hoSqlHandler sDriverID SQLConnection.sConnectionString
83393>>>>>>>            Get SqlConnect     of hoSqlHandler "" "" to hoSQLConnect
83394>>>>>>>        End
83394>>>>>>>>
83394>>>>>>>
83394>>>>>>>        If (hoSQLConnect <> 0) Begin
83396>>>>>>>            Get SqlOpen of hoSQLConnect to hoStmt
83397>>>>>>>            If (hoStmt <> 0) Begin
83399>>>>>>>                // record starting date/time stamp
83399>>>>>>>                Move (CurrentDateTime()) to dtQueryExecStart
83400>>>>>>>                // turn on error handling if enabled
83400>>>>>>>                If (pbHandleQueryErrors(Self)) Begin
83402>>>>>>>                    Set pbSqlError to False
83403>>>>>>>                    Set paSqlErrorArray to aSqlErrorArray
83404>>>>>>>                    Move Error_Object_Id to hoError
83405>>>>>>>                    If (ghoDbUpdateHandler <> 0) Begin
83407>>>>>>>                        Move ghoDbUpdateHandler to Error_Object_Id
83408>>>>>>>                    End
83408>>>>>>>>
83408>>>>>>>                    Else Begin
83409>>>>>>>                        Move Self to Error_Object_Id
83410>>>>>>>                    End
83410>>>>>>>>
83410>>>>>>>                End
83410>>>>>>>>
83410>>>>>>>
83410>>>>>>>                // Before we execute the statement; save it so we can display the faulty statement in the error log.
83410>>>>>>>                Set psSQLStatementString to sStmt
83411>>>>>>>                Send Cursor_Wait of Cursor_Control
83412>>>>>>>                Send SqlExecDirect of hoStmt sStmt
83413>>>>>>>                Send Cursor_Ready of Cursor_Control
83414>>>>>>>
83414>>>>>>>                If (pbHandleQueryErrors(Self)) Begin
83416>>>>>>>                    Move hoError to Error_Object_Id
83417>>>>>>>                End
83417>>>>>>>>
83417>>>>>>>
83417>>>>>>>                Move 0 to iMsgs
83418>>>>>>>                // ToDo: There seems to be some issues with this code and Mertech drivers that makes
83418>>>>>>>                // the debugger crash in some cases like an error in the ESQL statement; so we exclude it for now.
83418>>>>>>>                If (bMertechDriver = False) Begin
83420>>>>>>>                    Move Err to iErr
83421>>>>>>>                    Move LastErr to iLastErr
83422>>>>>>>                    Get SqlStmtAttribute of hoStmt SQLSTMTATTRIB_NUMMESSAGES   to iMsgs
83423>>>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT      to iRows
83424>>>>>>>                    Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
83425>>>>>>>                    Send _SqlColumnInfo hoStmt
83426>>>>>>>                    Send Ignore_Error of Error_Object_Id 12289
83427>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_NO_REPORT
83428>>>>>>>                    Repeat
83428>>>>>>>>
83428>>>>>>>                        Get SqlFetch of hoStmt to iFetchResult
83429>>>>>>>                        If (iFetchResult <> 0) Begin
83431>>>>>>>                            Get SQLColumnValue of hoStmt 1 to aSQLFetchResults[SizeOfArray(aSQLFetchResults)]
83432>>>>>>>                        End
83432>>>>>>>>
83432>>>>>>>                    Until (iFetchResult = 0)
83434>>>>>>>                    Send Trap_Error of Error_Object_Id 12289
83435>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
83436>>>>>>>                    Move iErr to Err
83437>>>>>>>                    Move iLastErr to LastErr
83438>>>>>>>                    Set paSQLFetchResults to aSQLFetchResults
83439>>>>>>>                End
83439>>>>>>>>
83439>>>>>>>
83439>>>>>>>                Set piRows    to iRows
83440>>>>>>>                Set piRowType to iRowType
83441>>>>>>>                Move (CurrentDateTime()) to dtQueryExecEnd
83442>>>>>>>                Move (CurrentDateTime()) to dtFetchStart
83443>>>>>>>
83443>>>>>>>                If (iMsgs <> 0) Begin
83445>>>>>>>                    If (ghoDbUpdateHandler > 0) Begin
83447>>>>>>>                        Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
83448>>>>>>>                    End
83448>>>>>>>>
83448>>>>>>>                    For i from 1 to iMsgs
83454>>>>>>>>
83454>>>>>>>                        Get SqlGetMessage of hoStmt i to sMessage
83455>>>>>>>                        Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
83456>>>>>>>                        If (bShowProgress = True) Begin
83458>>>>>>>                            If (Active_State(ghoStatusPanel)) Begin
83460>>>>>>>                                Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
83461>>>>>>>                            End
83461>>>>>>>>
83461>>>>>>>                            Else Begin
83462>>>>>>>                                Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]",iMessage,sMessage))
83464>>>>>>>                            End
83464>>>>>>>>
83464>>>>>>>                        End
83464>>>>>>>>
83464>>>>>>>                        Move sMessage to sMsg[SizeOfArray(sMsg)]
83465>>>>>>>                        Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
83466>>>>>>>                    Loop
83467>>>>>>>>
83467>>>>>>>                    If (ghoDbUpdateHandler > 0) Begin
83469>>>>>>>                        Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
83470>>>>>>>                    End
83470>>>>>>>>
83470>>>>>>>                    Set paQueryMessages to sMsg
83471>>>>>>>                End
83471>>>>>>>>
83471>>>>>>>                Else Begin
83472>>>>>>>                    If (bShowProgress = True) Begin
83474>>>>>>>                        Get paSqlErrorArray to aSqlErrorArray
83475>>>>>>>                        If (SizeOfArray(aSqlErrorArray.iSqlErrorArray)) Begin
83477>>>>>>>                            Move (SizeOfArray(aSqlErrorArray.iSqlErrorArray)) to iMsgs
83478>>>>>>>                            Decrement iMsgs
83479>>>>>>>                            For i from 0 to iMsgs
83485>>>>>>>>
83485>>>>>>>                                Showln "Embedded SQL Statement: " aSqlErrorArray.sSqlStatementArray[i]
83488>>>>>>>                                Showln "SQL Error Message     : " aSqlErrorArray.sSqlErrorArray[i]
83491>>>>>>>                            Loop
83492>>>>>>>>
83492>>>>>>>                        End
83492>>>>>>>>
83492>>>>>>>                    End
83492>>>>>>>>
83492>>>>>>>                End
83492>>>>>>>>
83492>>>>>>>                Move (CurrentDateTime()) to dtFetchEnd
83493>>>>>>>            End
83493>>>>>>>>
83493>>>>>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
83494>>>>>>>            Move (dtFetchStart - dtFetchEnd) to tsFetch
83495>>>>>>>            Set ptsQueryExec to tsQuery
83496>>>>>>>            Set ptsFetchResults to tsFetch
83497>>>>>>>            Send SqlClose of hoStmt
83498>>>>>>>        End
83498>>>>>>>>
83498>>>>>>>
83498>>>>>>>        Send SqlDisconnect of hoSQLConnect
83499>>>>>>>    End_Procedure
83500>>>>>>>
83500>>>>>>>    // *** Main message for executing an SQL script that has been compiled into the program as a resource ***
83500>>>>>>>    // Use the SQLIncludeScriptFile command to include an SQL script into the program.
83500>>>>>>>    // Returns False if no error occured.
83500>>>>>>>    Function SqlUtilExecuteResource String sMemFileName String sDriverID Boolean bCreateScriptFile Boolean bShowProgr Returns Boolean
83502>>>>>>>        Boolean bOK bShowProgress
83502>>>>>>>        tSQLScriptArray SQLScriptArray
83502>>>>>>>        tSQLScriptArray SQLScriptArray
83502>>>>>>>        DateTime dtTotalQueryStart dtTotalQueryEnd
83502>>>>>>>        TimeSpan tsTotalTime
83502>>>>>>>
83502>>>>>>>        Move (CurrentDateTime()) to dtTotalQueryStart
83503>>>>>>>        Get SqlUtilReadResource sMemFileName to SQLScriptArray
83504>>>>>>>        If (SQLScriptArray.bError = True) Begin
83506>>>>>>>            Function_Return False
83507>>>>>>>        End
83507>>>>>>>>
83507>>>>>>>
83507>>>>>>>        If (num_arguments > 3) Begin
83509>>>>>>>            Move bShowProgr to bShowProgress
83510>>>>>>>        End
83510>>>>>>>>
83510>>>>>>>
83510>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
83511>>>>>>>        Get SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID bCreateScriptFile sMemFileName bShowProgress to bOK
83512>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
83513>>>>>>>
83513>>>>>>>        If (SQLScriptArray.bArgumentSizeChanged = True) Begin
83515>>>>>>>            Set_Argument_Size SQLScriptArray.iOrgArgumentSize
83516>>>>>>>>
83516>>>>>>>        End
83516>>>>>>>>
83516>>>>>>>        Move (CurrentDateTime()) to dtTotalQueryEnd
83517>>>>>>>        Move (dtTotalQueryEnd - dtTotalQueryStart) to tsTotalTime
83518>>>>>>>        Set ptsTotalQueryTime to tsTotalTime
83519>>>>>>>
83519>>>>>>>        Function_Return bOK
83520>>>>>>>    End_Function
83521>>>>>>>
83521>>>>>>>    // Reads a SQL script file that has been compiled into the .exe program as a resource.
83521>>>>>>>    // Pass: The memory resource reference and a boolean True if you want to create the file on disk (in the Home folder).
83521>>>>>>>    // Returns: A tSQLScriptArray Struct with the Sql script as an uChar Array will be returned along with the a bError boolean.
83521>>>>>>>    Function SqlUtilReadResource String sMemFileName Returns tSQLScriptArray
83523>>>>>>>        Integer iChannel iArgumentSize iCount
83523>>>>>>>        Number nByteCount
83523>>>>>>>        String sSQLScript
83523>>>>>>>        tSQLScriptArray SqlScriptArray
83523>>>>>>>        tSQLScriptArray SqlScriptArray
83523>>>>>>>        UChar[] uCharData
83524>>>>>>>
83524>>>>>>>        Move False to Err
83525>>>>>>>        Get Seq_New_Channel to iChannel
83526>>>>>>>        If (iChannel = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
83528>>>>>>>            Error DFERR_PROGRAM 'No channel available...'
83529>>>>>>>>
83529>>>>>>>            Move True to SqlScriptArray.bError
83530>>>>>>>            Function_Return SqlScriptArray
83531>>>>>>>        End
83531>>>>>>>>
83531>>>>>>>
83531>>>>>>>        // First decide the size of the script
83531>>>>>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
83533>>>>>>>        Read_Block channel iChannel uCharData -1 // -1 means that all data should be read.
83535>>>>>>>        Close_Input channel iChannel
83537>>>>>>>
83537>>>>>>>        Move (SizeOfArray(uCharData)) to nByteCount
83538>>>>>>>        If (nByteCount  < 1) Begin
83540>>>>>>>            Send Seq_Release_Channel iChannel
83541>>>>>>>            Move True to SqlScriptArray.bError
83542>>>>>>>            Function_Return SqlScriptArray
83543>>>>>>>        End
83543>>>>>>>>
83543>>>>>>>
83543>>>>>>>        // If necessary change the string argument_size
83543>>>>>>>        Get_Argument_Size to iArgumentSize
83544>>>>>>>        If (nByteCount >= iArgumentSize) Begin
83546>>>>>>>            Move (nByteCount + 2048) to nByteCount
83547>>>>>>>            Set_Argument_Size nByteCount // Set new argument size just a bit higher than "needed" for overhead margin.
83548>>>>>>>>
83548>>>>>>>            Move True          to SqlScriptArray.bArgumentSizeChanged
83549>>>>>>>            Move iArgumentSize to SqlScriptArray.iOrgArgumentSize
83550>>>>>>>        End
83550>>>>>>>>
83550>>>>>>>        Else Begin
83551>>>>>>>            Move False to SqlScriptArray.bArgumentSizeChanged
83552>>>>>>>        End
83552>>>>>>>>
83552>>>>>>>        // Read the script file from memory line-by-line
83552>>>>>>>        Direct_Input channel iChannel ("Resource: " + sMemFileName)
83554>>>>>>>            Move 0 to iCount
83555>>>>>>>            Repeat
83555>>>>>>>>
83555>>>>>>>                Readln channel iChannel sSQLScript
83557>>>>>>>                Move sSQLScript to SqlScriptArray.sSQLScriptArray[iCount]
83558>>>>>>>                Increment iCount
83559>>>>>>>            Until (SeqEof = True)
83561>>>>>>>        Close_Input channel iChannel
83563>>>>>>>        Send Seq_Release_Channel iChannel
83564>>>>>>>
83564>>>>>>>        // Finally "sanitize" the script by removing all comments.
83564>>>>>>>        Get _SqlUtilSanitizeScript SqlScriptArray to SqlScriptArray
83565>>>>>>>
83565>>>>>>>        Function_Return SqlScriptArray
83566>>>>>>>    End_Function
83567>>>>>>>
83567>>>>>>>    Function SqlUtilExecuteEmbeddedScript tSQLScriptArray SQLScriptArray String sDriverID Boolean bCreateScriptFile String sMemFileName Boolean bShowProgr Returns Boolean
83569>>>>>>>        String sSQLVal sStmt sCR sGOKeyWord sNoCountKeyWord sMessage sExportFile
83569>>>>>>>        Handle hoSql hoSQLConnect hoStmt hoError
83569>>>>>>>        Integer i iMsgs iRows iRowType iCount iChunkCounter iChunkMax iOut iNextSet iMessage iPos
83569>>>>>>>        String[] sMsg aSQLQueryMessages
83571>>>>>>>        DateTime dtQueryExecStart dtQueryExecEnd
83571>>>>>>>        TimeSpan tsQuery
83571>>>>>>>        tSqlErrorArray aSqlErrorArray
83571>>>>>>>        tSqlErrorArray aSqlErrorArray
83571>>>>>>>        tSQLConnection SQLConnection
83571>>>>>>>        tSQLConnection SQLConnection
83571>>>>>>>        Boolean bMertechDriver bShowProgress
83571>>>>>>>
83571>>>>>>>        If (num_arguments > 4) Begin
83573>>>>>>>            Move bShowProgr to bShowProgress
83574>>>>>>>        End
83574>>>>>>>>
83574>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
83575>>>>>>>        If (bMertechDriver = False) Begin
83577>>>>>>>            Get phoSQLManager to hoSql
83578>>>>>>>        End
83578>>>>>>>>
83578>>>>>>>        Else Begin
83579>>>>>>>            Get _MertechSQLManagerHandle to hoSql
83580>>>>>>>        End
83580>>>>>>>>
83580>>>>>>>
83580>>>>>>>        Get _SqlFindKeyWord CI_SQLGO to sGOKeyWord
83581>>>>>>>        // There seems to be a problem to pass strings when their value gets really big, aka
83581>>>>>>>        // above the argument_size level. It isn't clear when these problems starts but sooner
83581>>>>>>>        // or later SqlExecDirect stops working correctly with no error messages!
83581>>>>>>>        // To guard from this we set a max number of lines (iChunkMax) that can be processed
83581>>>>>>>        // at a time. Testing with the Create Chinook Database script; 500 seems like a number that works fine.
83581>>>>>>>        // A bonus of this is that it turns out that it is actually faster to run in chunks!
83581>>>>>>>        Get piChunkMax to iChunkMax
83582>>>>>>>        Move 0 to iChunkCounter
83583>>>>>>>        Move "" to sStmt
83584>>>>>>>
83584>>>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
83585>>>>>>>        Move (Character(13) + Character(10)) to sCR
83586>>>>>>>
83586>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
83587>>>>>>>
83587>>>>>>>        If (bMertechDriver = True) Begin
83589>>>>>>>            Get _MertechSQLConnect sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
83590>>>>>>>        End
83590>>>>>>>>
83590>>>>>>>        If (bMertechDriver = False) Begin
83592>>>>>>>            Get phoSQLManager  to hoSQL
83593>>>>>>>            If (sDriverID = ODBC_DRV_ID) Begin
83595>>>>>>>                If (Uppercase(SQLConnection.sConnectionString) contains CS_SQLIniDSNKeyword) Begin
83597>>>>>>>                    Move (Pos(";", SQLConnection.sConnectionString)) to iPos
83598>>>>>>>                    If (iPos > 0) Begin
83600>>>>>>>                        Move (Left(SQLConnection.sConnectionString, (iPos - 1))) to SQLConnection.sConnectionString
83601>>>>>>>                        Move (Trim(SQLConnection.sConnectionString)) to SQLConnection.sConnectionString
83602>>>>>>>                    End
83602>>>>>>>>
83602>>>>>>>                End
83602>>>>>>>>
83602>>>>>>>            End
83602>>>>>>>>
83602>>>>>>>            Send SqlSetConnect of hoSQL sDriverID SQLConnection.sConnectionString
83603>>>>>>>            Get SqlConnect     of hoSQL "" "" to hoSQLConnect
83604>>>>>>>        End
83604>>>>>>>>
83604>>>>>>>
83604>>>>>>>        If (hoSQLConnect <> 0) Begin
83606>>>>>>>            Move False to Err
83607>>>>>>>            Get SqlOpen of hoSQLConnect to hoStmt
83608>>>>>>>            If (hoStmt <> 0) Begin
83610>>>>>>>
83610>>>>>>>                // If the embedded resource should be written as a script file to disk:
83610>>>>>>>                If (bCreateScriptFile = True) Begin
83612>>>>>>>                    Get psHome of (phoWorkspace(ghoApplication)) to sExportFile
83613>>>>>>>                    Get vFolderFormat sExportFile to sExportFile
83614>>>>>>>                    Move (sExportFile + sMemFileName) to sExportFile
83615>>>>>>>                    Get Seq_New_Channel to iOut
83616>>>>>>>                    If (iOut <> DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
83618>>>>>>>                        Direct_Output channel iOut sExportFile
83620>>>>>>>                    End
83620>>>>>>>>
83620>>>>>>>                End
83620>>>>>>>>
83620>>>>>>>
83620>>>>>>>                // Record starting date/time stamp
83620>>>>>>>                Move (CurrentDateTime()) to dtQueryExecStart
83621>>>>>>>                // Turn on error handling if enabled
83621>>>>>>>                If (pbHandleQueryErrors(Self)) Begin
83623>>>>>>>                    Set pbSqlError to False
83624>>>>>>>                    Set paSqlErrorArray to aSqlErrorArray
83625>>>>>>>                    Move Error_Object_Id to hoError
83626>>>>>>>                    Move Self to Error_Object_Id
83627>>>>>>>                End
83627>>>>>>>>
83627>>>>>>>
83627>>>>>>>                Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iRows
83628>>>>>>>                Decrement iRows
83629>>>>>>>                If (sDriverID = MSSQLDRV_ID) Begin
83631>>>>>>>                    Move (sNoCountKeyWord + sCR) to sStmt
83632>>>>>>>                End
83632>>>>>>>>
83632>>>>>>>
83632>>>>>>>                For iCount from 0 to iRows
83638>>>>>>>>
83638>>>>>>>                    Move (SQLScriptArray.sSQLScriptArray[iCount]) to sSQLVal
83639>>>>>>>
83639>>>>>>>                    If (Uppercase(sSQLVal) <> sGOKeyWord) Begin
83641>>>>>>>                        If (sSQLVal <> "") Begin
83643>>>>>>>                            Move (sSQLVal + sCR) to sSQLVal
83644>>>>>>>                        End
83644>>>>>>>>
83644>>>>>>>                        Move (Append(sStmt, (sSQLVal))) to sStmt
83645>>>>>>>                    End
83645>>>>>>>>
83645>>>>>>>
83645>>>>>>>                    // - Each time we encounter a "GO" statement we execute it,
83645>>>>>>>                    // or if at the very end of the script.
83645>>>>>>>                    If (Uppercase(sSQLVal) = sGOKeyWord or iChunkCounter >= iChunkMax or iCount = iRows) Begin
83647>>>>>>>
83647>>>>>>>                        // - It turns out it can be at least 10 times faster to execute SQL statements in chunks,
83647>>>>>>>                        // instead of all in one go.
83647>>>>>>>                        Send SqlExecDirect of hoStmt sStmt
83648>>>>>>>
83648>>>>>>>                        If (bCreateScriptFile = True) Begin
83650>>>>>>>                            Write channel iOut sStmt
83652>>>>>>>                        End
83652>>>>>>>>
83652>>>>>>>                        Move "" to sStmt
83653>>>>>>>                        Move 0 to iChunkCounter
83654>>>>>>>                    End
83654>>>>>>>>
83654>>>>>>>                    Increment iChunkCounter
83655>>>>>>>                Loop
83656>>>>>>>>
83656>>>>>>>
83656>>>>>>>                // ToDo: This sometimes generates a GPF with Mertech drivers;
83656>>>>>>>                //       so not used for now.
83656>>>>>>>                If (bMertechDriver = False) Begin
83658>>>>>>>                    Repeat
83658>>>>>>>>
83658>>>>>>>                        If (pbHandleQueryErrors(Self)) Begin
83660>>>>>>>                            Move hoError to Error_Object_Id
83661>>>>>>>                        End
83661>>>>>>>>
83661>>>>>>>                        Move (CurrentDateTime()) to dtQueryExecEnd
83662>>>>>>>
83662>>>>>>>                        Send _SqlColumnInfo hoStmt
83663>>>>>>>                        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT to iRows
83664>>>>>>>                        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_ROWCOUNT_TYPE to iRowType
83665>>>>>>>                        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_NUMMESSAGES to iMsgs
83666>>>>>>>                        Set piRows    to iRows
83667>>>>>>>                        Set piRowType to iRowType
83668>>>>>>>
83668>>>>>>>                        If (iMsgs <> 0) Begin
83670>>>>>>>                            If (ghoDbUpdateHandler > 0) Begin
83672>>>>>>>                                Get paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
83673>>>>>>>                            End
83673>>>>>>>>
83673>>>>>>>                            For i from 1 to iMsgs
83679>>>>>>>>
83679>>>>>>>                                Get SqlGetMessage of hoStmt i to sMessage
83680>>>>>>>                                Get RemoveComponentIdentifier of hoStmt sMessage to sMessage
83681>>>>>>>                                If (bShowProgress = True) Begin
83683>>>>>>>                                    If (Active_State(ghoStatusPanel)) Begin
83685>>>>>>>                                        Send Update_StatusPanel of ghoStatusPanel (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
83686>>>>>>>                                    End
83686>>>>>>>>
83686>>>>>>>                                    Else Begin
83687>>>>>>>                                        Showln (Sformat("  SQLGetMessage iMessage %1 returned [%2]", iMessage, sMessage))
83689>>>>>>>                                    End
83689>>>>>>>>
83689>>>>>>>                                End
83689>>>>>>>>
83689>>>>>>>                                Move sMessage to sMsg[SizeOfArray(sMsg)]
83690>>>>>>>                                Move sMessage to aSQLQueryMessages[SizeOfArray(aSQLQueryMessages)]
83691>>>>>>>                            Loop
83692>>>>>>>>
83692>>>>>>>
83692>>>>>>>
83692>>>>>>>                            If (ghoDbUpdateHandler > 0) Begin
83694>>>>>>>                                Set paSQLQueryMessages of ghoDbUpdateHandler to aSQLQueryMessages
83695>>>>>>>                            End
83695>>>>>>>>
83695>>>>>>>                            Set paQueryMessages to sMsg
83696>>>>>>>                        End
83696>>>>>>>>
83696>>>>>>>
83696>>>>>>>                        Get SQLNextResultSet of hoStmt to iNextSet
83697>>>>>>>                    Until (iNextSet = 0)
83699>>>>>>>                End
83699>>>>>>>>
83699>>>>>>>                Move (CurrentDateTime()) to dtQueryExecEnd
83700>>>>>>>            End
83700>>>>>>>>
83700>>>>>>>
83700>>>>>>>            Move (dtQueryExecEnd - dtQueryExecStart) to tsQuery
83701>>>>>>>            Set ptsQueryExec to tsQuery
83702>>>>>>>            Send SqlClose of hoStmt
83703>>>>>>>
83703>>>>>>>            If (bCreateScriptFile = True) Begin
83705>>>>>>>                Close_Output channel iOut
83707>>>>>>>                Send Seq_Release_Channel iOut
83708>>>>>>>            End
83708>>>>>>>>
83708>>>>>>>        End
83708>>>>>>>>
83708>>>>>>>        Send SqlDisconnect of hoSQLConnect
83709>>>>>>>
83709>>>>>>>        Function_Return (hoSQLConnect <> 0 and Err = False)
83710>>>>>>>    End_Function
83711>>>>>>>
83711>>>>>>>    // * Dummy function for the Studio's Code Explorer *
83711>>>>>>>    Function SQL_UTILITY_FUNCTIONS Returns Boolean
83713>>>>>>>        Function_Return False
83714>>>>>>>    End_Function
83715>>>>>>>
83715>>>>>>>    // Does three things with auxilirary files;
83715>>>>>>>    // 1) Deletes the cache file in the first Data folder of the psDataPath property as the table at the SQL end has been changed.
83715>>>>>>>    // 2) Adds the sColumnName to the TableName.tag file in the first Data folder of the psDataPath property
83715>>>>>>>    // 3) Creates a new TableName.fd file if the DdSrc folder is available (if this is a development environment)
83715>>>>>>>    Function SqlUtilAdjustAuxFiles Handle hTable String sTableName String sColumnName Returns Boolean
83717>>>>>>>        String sDataPath sDDSrcPath sDriverID
83717>>>>>>>        Boolean bOK bExists bMertechDriver
83717>>>>>>>        Integer iCount iCh iPos
83717>>>>>>>
83717>>>>>>>        // If table name equals e.g. "dbo.MyTable" we need to remove the prefix.
83717>>>>>>>        If (sTableName contains ".") Begin
83719>>>>>>>            Move (Pos(".", sTableName)) to iPos
83720>>>>>>>            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
83721>>>>>>>        End
83721>>>>>>>>
83721>>>>>>>
83721>>>>>>>        Get psDriverID to sDriverID
83722>>>>>>>        Get psDataPathFirstPart to sDataPath
83723>>>>>>>        Get vFolderExists sDataPath to bOK
83724>>>>>>>        If (bOK = False) Begin
83726>>>>>>>            Error DFERR_PROGRAM "Function SqlUtilAdjustAuxFiles; psDataPath not found!"
83727>>>>>>>>
83727>>>>>>>            Function_Return False
83728>>>>>>>        End
83728>>>>>>>>
83728>>>>>>>
83728>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
83729>>>>>>>        // First delete the cache file:
83729>>>>>>>        Get UtilDeleteCacheFile sTableName to bOK
83730>>>>>>>
83730>>>>>>>        Get Seq_New_Channel to iCh
83731>>>>>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
83733>>>>>>>            Function_Return False
83734>>>>>>>        End
83734>>>>>>>>
83734>>>>>>>
83734>>>>>>>        Get vFilePathExists (sDataPath + sTableName + ".tag") to bExists
83735>>>>>>>        If (bExists = False) Begin
83737>>>>>>>            Function_Return False
83738>>>>>>>        End
83738>>>>>>>>
83738>>>>>>>
83738>>>>>>>        Get SqlUtilUpdateIntFile hTable to bOK
83739>>>>>>>        // Add the new column name to the .tag filen (if it doesn't exist):
83739>>>>>>>        Get UtilUpdateTAGFile (sDataPath + sTableName + ".tag") sColumnName to bOK
83740>>>>>>>
83740>>>>>>>        // If in development environment; output new .fd file:
83740>>>>>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
83741>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
83742>>>>>>>        If (iCount > 1) Begin
83744>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
83745>>>>>>>        End
83745>>>>>>>>
83745>>>>>>>        Get vFolderExists sDDSrcPath to bExists
83746>>>>>>>        If (bExists = True) Begin
83748>>>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
83749>>>>>>>            Move False to Err
83750>>>>>>>            Get AutoConnectionIDLogin to bOK
83751>>>>>>>            If (hTable <> 0) Begin
83753>>>>>>>                Open hTable
83755>>>>>>>            End
83755>>>>>>>>
83755>>>>>>>            Else Begin
83756>>>>>>>                Get UtilTableOpen hTable sTableName DF_SHARE to bOK
83757>>>>>>>            End
83757>>>>>>>>
83757>>>>>>>
83757>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOK
83760>>>>>>>            If (bOK = True) Begin
83762>>>>>>>                Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
83764>>>>>>>            End
83764>>>>>>>>
83764>>>>>>>            If (Err = True) Begin
83766>>>>>>>                Move False to bOK
83767>>>>>>>            End
83767>>>>>>>>
83767>>>>>>>        End
83767>>>>>>>>
83767>>>>>>>
83767>>>>>>>        Function_Return (bOK = True)
83768>>>>>>>    End_Function
83769>>>>>>>
83769>>>>>>>    Function UtilUpdateTAGFile String sFullTAGFileName String sColumnName Returns Boolean
83771>>>>>>>        Integer iChIn iChOut // iCount
83771>>>>>>>        Boolean bExists
83771>>>>>>>        String sExistingColumn
83771>>>>>>>
83771>>>>>>>        Move False to bExists
83772>>>>>>>        Get Seq_New_Channel to iChIn
83773>>>>>>>        Get Seq_New_Channel to iChOut
83774>>>>>>>        If (iChIn = DF_SEQ_CHANNEL_NOT_AVAILABLE or iChOut = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
83776>>>>>>>            Function_Return True
83777>>>>>>>        End
83777>>>>>>>>
83777>>>>>>>
83777>>>>>>>        Move False to Err
83778>>>>>>>        // The following line should also use the channel attribute. (Thank you, Hans van de Laar)
83778>>>>>>>        Direct_Input channel iChIn ("'" + sFullTAGFileName + "'")
83780>>>>>>>        While (not(SeqEof))
83784>>>>>>>            Readln channel iChIn sExistingColumn
83786>>>>>>>            If (Uppercase(sExistingColumn) = Uppercase(sColumnName)) Begin
83788>>>>>>>                Move True to bExists
83789>>>>>>>            End
83789>>>>>>>>
83789>>>>>>>            If (Trim(sExistingColumn) = "") Begin
83791>>>>>>>                Move True to SeqEof
83792>>>>>>>            End
83792>>>>>>>>
83792>>>>>>>        Loop
83793>>>>>>>>
83793>>>>>>>        Close_Input channel iChIn
83795>>>>>>>        Send Seq_Release_Channel iChIn
83796>>>>>>>
83796>>>>>>>        If (bExists = False) Begin
83798>>>>>>>            Append_Output channel iChOut sFullTAGFileName
83800>>>>>>>            Writeln channel iChOut sColumnName
83803>>>>>>>            Close_Output channel iChOut
83805>>>>>>>            Send Seq_Release_Channel iChOut
83806>>>>>>>        End
83806>>>>>>>>
83806>>>>>>>
83806>>>>>>>        Function_Return (Err = False)
83807>>>>>>>    End_Function
83808>>>>>>>
83808>>>>>>>    // Message for changing .int files to use connection ID's
83808>>>>>>>    //
83808>>>>>>>    // Changes all ".int" files for the passed sDataPath to use a sConnectionID,
83808>>>>>>>    // OR changes an existing connection id to a new id.
83808>>>>>>>    // Pass the full path to the data folder and the name of the connection id (string value).
83808>>>>>>>    // Pass a True for the bShowResult parameter to show work in progress (showln's).
83808>>>>>>>    Procedure SqlUtilChangeIntFilesToConnectionIDs String sDataPath String sConnectionID Boolean bShowResult
83810>>>>>>>        String sFileName sDriverID sDriverFile sConnectionString
83810>>>>>>>        String[] sFilesData
83811>>>>>>>        Boolean bOK bCancel
83811>>>>>>>        Integer iSize iCount
83811>>>>>>>
83811>>>>>>>        Get SqlUtilEnumerateIntFiles sDataPath to sFilesData
83812>>>>>>>        Move (SizeOfArray(sFilesData))    to iSize
83813>>>>>>>        If (iSize = 0) Begin
83815>>>>>>>            If (ghoStatusPanel <> 0) Begin
83817>>>>>>>                If (Active_State(ghoStatusPanel)) Begin
83819>>>>>>>                    Send Stop_StatusPanel of ghoStatusPanel
83820>>>>>>>                End
83820>>>>>>>>
83820>>>>>>>            End
83820>>>>>>>>
83820>>>>>>>            Send Info_Box CS_DUF_NoIntFilesFound
83821>>>>>>>            Procedure_Return
83822>>>>>>>        End
83822>>>>>>>>
83822>>>>>>>
83822>>>>>>>        Move (Trim(sConnectionID)) to sConnectionID
83823>>>>>>>        Get vFolderFormat sDataPath to sDataPath
83824>>>>>>>        Decrement iSize
83825>>>>>>>        For iCount from 0 to iSize
83831>>>>>>>>
83831>>>>>>>            Move sFilesData[iCount] to sFileName
83832>>>>>>>            // This makes sure that we also can change an existing connection id to something new:
83832>>>>>>>            Get UtilChangeSourceCodeLine (sDataPath + sFileName) CS_SERVER_NAME (CS_SERVER_NAME * CS_DFCONNID + "=" + sConnectionID) bShowResult to bOK
83833>>>>>>>            If (ghoStatusPanel <> 0) Begin
83835>>>>>>>                If (Active_State(ghoStatusPanel)) Begin
83837>>>>>>>                    Get Check_StatusPanel of ghoStatusPanel to bCancel
83838>>>>>>>                    If (bCancel = True) Begin
83840>>>>>>>                        Send Deactivate of ghoStatusPanel
83841>>>>>>>                        Procedure_Return
83842>>>>>>>                    End
83842>>>>>>>>
83842>>>>>>>                End
83842>>>>>>>>
83842>>>>>>>            End
83842>>>>>>>>
83842>>>>>>>        Loop
83843>>>>>>>>
83843>>>>>>>
83843>>>>>>>        Get psDriverID to sDriverID
83844>>>>>>>
83844>>>>>>>         // Finally also change the driver file e.g. MSSQLDRV.int file in the Data folder in case it has a "DFconnectionID xxxxID,SERVER..."
83844>>>>>>>        Move "" to sFileName
83845>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
83847>>>>>>>            Move "MSSQLDrv.int" to sFileName
83848>>>>>>>        End
83848>>>>>>>>
83848>>>>>>>        If (sDriverID = DB2_DRV_ID) Begin
83850>>>>>>>            Move "DB2_Drv.int" to sFileName
83851>>>>>>>        End
83851>>>>>>>>
83851>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
83853>>>>>>>            Move "ODBC_Drv.int" to sFileName
83854>>>>>>>        End
83854>>>>>>>>
83854>>>>>>>        If (sFileName <> "") Begin
83856>>>>>>>            Move "" to sDriverFile
83857>>>>>>>            Get_File_Path sFileName to sDriverFile
83858>>>>>>>            If (sDriverFile <> "") Begin
83860>>>>>>>                Get psConnectionString to sConnectionString
83861>>>>>>>                Get UtilChangeSourceCodeLine sDriverFile CS_SQLConnectionIDText (CS_SQLConnectionIDText * String(sConnectionID) + "," * String(sConnectionString) * String(",0")) bShowResult to bOK
83862>>>>>>>            End
83862>>>>>>>>
83862>>>>>>>        End
83862>>>>>>>>
83862>>>>>>>    End_Procedure
83863>>>>>>>
83863>>>>>>>    // Checks if the database exists in SQL. Returns = True if it does.
83863>>>>>>>    Function SqlUtilCheckIfDatabaseExists String sDatabase Returns Boolean
83865>>>>>>>        String[] sDatabaseArray
83866>>>>>>>        String sVal sServer sDriverID
83866>>>>>>>        Integer iCount iSize iPos
83866>>>>>>>        Boolean bExists
83866>>>>>>>        tSQLConnection SQLConnection
83866>>>>>>>        tSQLConnection SQLConnection
83866>>>>>>>
83866>>>>>>>        Move False to bExists
83867>>>>>>>        Get psDriverID to sDriverID
83868>>>>>>>        // DB2 doesn't have a "Database" name, so we always return True.
83868>>>>>>>        If (sDriverID = DB2_DRV_ID) Begin
83870>>>>>>>            Function_Return bExists
83871>>>>>>>        End
83871>>>>>>>>
83871>>>>>>>
83871>>>>>>>        Get SqlUtilEnumerateDatabases sDriverID to sDatabaseArray
83872>>>>>>>        If (SizeOfArray(sDatabaseArray) = 0) Begin
83874>>>>>>>            Function_Return False
83875>>>>>>>        End
83875>>>>>>>>
83875>>>>>>>
83875>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
83876>>>>>>>        Move SQLConnection.sServer to sServer
83877>>>>>>>
83877>>>>>>>        // Special code to handle a FILEDSN that also can contain "/"
83877>>>>>>>        If (Uppercase(sServer) contains ("." + CS_SQLIniDSNKeyword)) Begin
83879>>>>>>>            Move sDatabaseArray[0] to sVal  // Dummy!
83880>>>>>>>        End
83880>>>>>>>>
83880>>>>>>>        Else If (sServer contains "/") Begin
83883>>>>>>>            Move (Pos("/", sServer)) to iPos
83884>>>>>>>            Move (Mid(sServer, 999, (iPos +1))) to sDatabase
83885>>>>>>>        End
83885>>>>>>>>
83885>>>>>>>
83885>>>>>>>        Move (SizeOfArray(sDatabaseArray)) to iSize
83886>>>>>>>        Decrement iSize
83887>>>>>>>        For iCount from 0 to iSize
83893>>>>>>>>
83893>>>>>>>            Move sDatabaseArray[iCount] to sVal
83894>>>>>>>            If (Uppercase(sVal) = Uppercase(sDatabase)) Begin
83896>>>>>>>                Move True to bExists
83897>>>>>>>                If (bExists = True) Begin
83899>>>>>>>                    Move iSize to iCount // We're done.
83900>>>>>>>                End
83900>>>>>>>>
83900>>>>>>>            End
83900>>>>>>>>
83900>>>>>>>        Loop
83901>>>>>>>>
83901>>>>>>>
83901>>>>>>>        Function_Return bExists
83902>>>>>>>    End_Function
83903>>>>>>>
83903>>>>>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
83903>>>>>>>    Function SqlUtilCheckIfTableHandleExists Handle hTable String sDriverID Returns Boolean
83905>>>>>>>        String sDatabase sSchema sTableName sVal
83905>>>>>>>        Boolean bExists
83905>>>>>>>        String[] sTablesArray
83906>>>>>>>        Integer iSize iCount
83906>>>>>>>
83906>>>>>>>        Move False to bExists
83907>>>>>>>        Get UtilTableHandleToString hTable to sTableName
83908>>>>>>>        Get psDatabase to sDatabase
83909>>>>>>>        Get psSchema   to sSchema
83910>>>>>>>        Get SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
83911>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
83912>>>>>>>        Decrement iSize
83913>>>>>>>        For iCount from 0 to iSize
83919>>>>>>>>
83919>>>>>>>            Move sTablesArray[iCount] to sVal
83920>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
83922>>>>>>>                Move True to bExists
83923>>>>>>>                Move iSize to iCount // We're done!
83924>>>>>>>            End
83924>>>>>>>>
83924>>>>>>>        Loop
83925>>>>>>>>
83925>>>>>>>
83925>>>>>>>        Function_Return bExists
83926>>>>>>>    End_Function
83927>>>>>>>
83927>>>>>>>    // Checks if a table exists as an SQL table. Returns = True if it does.
83927>>>>>>>    Function SqlUtilCheckIfTableNameExists String sTableName String sDriverID Returns Boolean
83929>>>>>>>        String sDatabase sSchema sVal
83929>>>>>>>        Boolean bExists
83929>>>>>>>        String[] sTablesArray
83930>>>>>>>        Integer iSize iCount
83930>>>>>>>
83930>>>>>>>        Move False to bExists
83931>>>>>>>        Get psDatabase to sDatabase
83932>>>>>>>        Get psSchema   to sSchema
83933>>>>>>>        Get SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
83934>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
83935>>>>>>>        Decrement iSize
83936>>>>>>>        For iCount from 0 to iSize
83942>>>>>>>>
83942>>>>>>>            Move sTablesArray[iCount] to sVal
83943>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
83945>>>>>>>                Move True to bExists
83946>>>>>>>                Move iSize to iCount // We're done!
83947>>>>>>>            End
83947>>>>>>>>
83947>>>>>>>        Loop
83948>>>>>>>>
83948>>>>>>>
83948>>>>>>>        Function_Return bExists
83949>>>>>>>    End_Function
83950>>>>>>>
83950>>>>>>>    Function SqlUtilCheckIfTableNameSpelling String sDriverID String sDatabase String sTableName String sSchema Returns String
83952>>>>>>>        String sVal sTableSpelledCorrectly
83952>>>>>>>        Boolean bExists
83952>>>>>>>        String[] sTablesArray
83953>>>>>>>        Integer iSize iCount
83953>>>>>>>
83953>>>>>>>        Move False to bExists
83954>>>>>>>        Move sTableName to sTableSpelledCorrectly
83955>>>>>>>        Get SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
83956>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
83957>>>>>>>        Decrement iSize
83958>>>>>>>        For iCount from 0 to iSize
83964>>>>>>>>
83964>>>>>>>            Move sTablesArray[iCount] to sVal
83965>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
83967>>>>>>>                Move sVal to sTableSpelledCorrectly
83968>>>>>>>                Move iSize to iCount // We're done!
83969>>>>>>>            End
83969>>>>>>>>
83969>>>>>>>        Loop
83970>>>>>>>>
83970>>>>>>>
83970>>>>>>>        Function_Return sTableSpelledCorrectly
83971>>>>>>>    End_Function
83972>>>>>>>
83972>>>>>>>    // ToDo: This index name function needs to be finished...
83972>>>>>>>    Function SqlUtilCheckIfIndexNameExists Handle hTable String sIndexName Returns Boolean
83974>>>>>>>        String sSchema sTableName sDriverID
83974>>>>>>>        Boolean bExists
83974>>>>>>>
83974>>>>>>>        Get psDriverID to sDriverID
83975>>>>>>>        Get psSchema to sSchema
83976>>>>>>>        Get UtilTableHandleToString hTable to sTableName
83977>>>>>>>
83977>>>>>>>        Function_Return bExists
83978>>>>>>>    End_Function
83979>>>>>>>
83979>>>>>>>    // Checks if a column/field name exists in a SQL table definition
83979>>>>>>>    // Returns True if it does
83979>>>>>>>    // Sample:
83979>>>>>>>    //   Get SQLUtilColumnExists "MySQLTable" "MyColumnName" to bExists
83979>>>>>>>    Function SqlUtilColumnExists String sTableName String sFieldName Returns Boolean
83981>>>>>>>        Integer iNumColumns iColumn
83981>>>>>>>        String sColumn sDriverID
83981>>>>>>>        String[] sColumnsArray
83982>>>>>>>        Boolean bExists bOK
83982>>>>>>>
83982>>>>>>>        Move False to bExists
83983>>>>>>>        Get AutoConnectionIDLogin to bOK
83984>>>>>>>        Get psDriverID to sDriverID
83985>>>>>>>
83985>>>>>>>        Get SqlUtilEnumerateColumns sDriverID sTableName to sColumnsArray
83986>>>>>>>        Move (SizeOfArray(sColumnsArray)) to iNumColumns
83987>>>>>>>        Decrement iNumColumns
83988>>>>>>>        For iColumn from 0 to iNumColumns
83994>>>>>>>>
83994>>>>>>>            Move sColumnsArray[iColumn] to sColumn
83995>>>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
83997>>>>>>>                Move True to bExists
83998>>>>>>>                Move iNumColumns to iColumn // We're out of here
83999>>>>>>>            End
83999>>>>>>>>
83999>>>>>>>        Loop
84000>>>>>>>>
84000>>>>>>>
84000>>>>>>>        Function_Return bExists
84001>>>>>>>    End_Function
84002>>>>>>>
84002>>>>>>>    Function SqlUtilConvertColumnTypesToSQL2008 Handle hTable Returns Boolean
84004>>>>>>>        Integer iNumColumns iColumn iDFType iNativeType
84004>>>>>>>        Boolean bOpened bOK
84004>>>>>>>        String sColumnName sNativeTypeName
84004>>>>>>>
84004>>>>>>>        Get AutoConnectionIDLogin to bOK
84005>>>>>>>        Get OpenTableExclusive hTable to bOK
84006>>>>>>>        If (bOK = False) Begin
84008>>>>>>>            Function_Return False
84009>>>>>>>        End
84009>>>>>>>>
84009>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
84012>>>>>>>        If (bOpened = False) Begin
84014>>>>>>>            Error DFERR_PROGRAM ("Function SQLUtilConvertColumnTypesToSQL2008; Could not open table" * String(hTable))
84015>>>>>>>>
84015>>>>>>>            Function_Return False
84016>>>>>>>        End
84016>>>>>>>>
84016>>>>>>>
84016>>>>>>>        Move False to Err
84017>>>>>>>
84017>>>>>>>        Structure_Start hTable
84018>>>>>>>            Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
84021>>>>>>>
84021>>>>>>>            For iColumn from 1 to iNumColumns
84027>>>>>>>>
84027>>>>>>>                Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iDfType
84030>>>>>>>                Get_Attribute DF_FIELD_NAME             of hTable iColumn to sColumnName
84033>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iNativeType
84036>>>>>>>                Get_Attribute DF_FIELD_NATIVE_TYPE_Name of hTable iColumn to sNativeTypeName
84039>>>>>>>
84039>>>>>>>                Case Begin
84039>>>>>>>                    Case (iDFType = DF_DATE)
84041>>>>>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
84043>>>>>>>                            // Convert datetime to date
84043>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_DATE
84046>>>>>>>                        End
84046>>>>>>>>
84046>>>>>>>                        Case Break
84047>>>>>>>                    Case (iDFType = DF_DATETIME)
84050>>>>>>>                        If (iNativeType = SQL_TYPE_TIMESTAMP) Begin
84052>>>>>>>                            // Convert datetime to datetime2
84052>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_TYPE_TIMESTAMP2
84055>>>>>>>                        End
84055>>>>>>>>
84055>>>>>>>                        Case Break
84056>>>>>>>                    Case (iDFType = DF_ASCII)
84059>>>>>>>                        If (iNativeType = SQL_CHAR) Begin
84061>>>>>>>                            // Convert char to varchar
84061>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
84064>>>>>>>                        End
84064>>>>>>>>
84064>>>>>>>                        Case Break
84065>>>>>>>                    Case (iDFType = DF_TEXT)
84068>>>>>>>                        If (iNativeType = SQL_LONGVARCHAR) Begin
84070>>>>>>>                            // Convert text to varchar(max)
84070>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARCHAR
84073>>>>>>>                        End
84073>>>>>>>>
84073>>>>>>>                        Case Break
84074>>>>>>>                    Case (iDFType = DF_BINARY)
84077>>>>>>>                        If (iNativeType = SQL_LONGVARBINARY) Begin
84079>>>>>>>                            // Convert image to varbinary(max)
84079>>>>>>>                            Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to SQL_VARBINARY
84082>>>>>>>                        End
84082>>>>>>>>
84082>>>>>>>                        Case Break
84083>>>>>>>                Case End
84083>>>>>>>            Loop
84084>>>>>>>>
84084>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
84085>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
84087>>>>>>>
84087>>>>>>>        Set Action_Text of ghoStatusPanel to ""
84088>>>>>>>        Function_Return (Err = False)
84089>>>>>>>    End_Function
84090>>>>>>>
84090>>>>>>>
84090>>>>>>>    // Will create an SQL table with the passed sTableName & sColumnName as Numeric 4.2 to keep
84090>>>>>>>    // the DbUpdateVersion database revision in.
84090>>>>>>>    // Also pass the file number of the current (embedded?) table number used in development.
84090>>>>>>>    // It will first create the SQL Table & column, then create the .int file and change Filelist.cfg
84090>>>>>>>    Function SqlUtilCreateDbVersionTable Handle hTable String sColumnName String sDriverID Returns Boolean
84092>>>>>>>        Boolean bOK bOpened
84092>>>>>>>        String sTableName sDataType sAlterTable sAddColumn sLengthAndDecimals sStmt
84092>>>>>>>
84092>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
84095>>>>>>>        Get _TableNameOnly sTableName to sTableName
84096>>>>>>>        If (sTableName = "") Begin
84098>>>>>>>            Function_Return False
84099>>>>>>>        End
84099>>>>>>>>
84099>>>>>>>
84099>>>>>>>        // This just creates the table and a "dummy" column.
84099>>>>>>>        Get SqlTableCreate hTable sDriverID to bOK
84100>>>>>>>        If (bOK = False) Begin
84102>>>>>>>            Function_Return False
84103>>>>>>>        End
84103>>>>>>>>
84103>>>>>>>
84103>>>>>>>        Close hTable
84104>>>>>>>        Move False to Err
84105>>>>>>>
84105>>>>>>>        Get _SqlFindKeyWord CI_SQLAlterTable to sAlterTable
84106>>>>>>>        Get _SqlFindKeyWord CI_SQLAdd        to sAddColumn
84107>>>>>>>        Move "Decimal" to sDataType
84108>>>>>>>        Get _SqlFormatLengthAndDecimalAsString 4 2 to sLengthAndDecimals
84109>>>>>>>
84109>>>>>>>        // Adds the "sColumnName" passed to the function
84109>>>>>>>        Move (sAlterTable * sTableName * sAddColumn * sColumnName * sDataType + sLengthAndDecimals) to sStmt
84110>>>>>>>        Send SqlUtilExecuteQuery sStmt sDriverID
84111>>>>>>>
84111>>>>>>>        // Now we can delete the dummy column:
84111>>>>>>>        Get SqlColumnRemoveByTableName sTableName "Dummy" to bOK
84112>>>>>>>
84112>>>>>>>        // Finally, we attach to the newly created table.
84112>>>>>>>        If (Err = False) Begin
84114>>>>>>>            Get ApiTableAttachToSQL hTable True to bOK
84115>>>>>>>        End
84115>>>>>>>>
84115>>>>>>>        Open hTable
84117>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
84120>>>>>>>
84120>>>>>>>        Function_Return (Err = False and bOK = True and bOpened = True)
84121>>>>>>>    End_Function
84122>>>>>>>
84122>>>>>>>    // The table must already exist in the filelist for this function to work.
84122>>>>>>>    // It creates a rudimentary .int file in the first Data folder of the psDataPath property.
84122>>>>>>>    Function SqlUtilCreateIntFile Handle hTable String sDriverID String sConnectionID Boolean bAnsi Boolean bSysFile Returns Boolean
84124>>>>>>>        Boolean bOK bExists bUseConnectionID bMertech
84124>>>>>>>        String sDataPath sRootName sLogicalName sPhysicalFileName sConnectionString sDatabaseName sSchemaName sANSI_OEM
84124>>>>>>>        String[] sIndexArray
84125>>>>>>>        Integer iCount iCh iSize
84125>>>>>>>
84125>>>>>>>        Move (Trim(sConnectionID) <> "") to bUseConnectionID
84126>>>>>>>        Get psConnectionString to sConnectionString
84127>>>>>>>
84127>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
84128>>>>>>>        If (bANSI = False) Begin
84130>>>>>>>            Move CS_OEM_Txt to sANSI_OEM
84131>>>>>>>        End
84131>>>>>>>>
84131>>>>>>>
84131>>>>>>>        Get psDataPathFirstPart to sDataPath
84132>>>>>>>        Get vFolderExists sDataPath to bOK
84133>>>>>>>        If (bOK = False) Begin
84135>>>>>>>            Error DFERR_PROGRAM "Function SqlUtilCreateIntFile; psDataPath not found!"
84136>>>>>>>>
84136>>>>>>>            Function_Return False
84137>>>>>>>        End
84137>>>>>>>>
84137>>>>>>>        Get vFolderFormat sDataPath to sDataPath
84138>>>>>>>
84138>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
84141>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
84144>>>>>>>        Get _TableNameOnly sRootName to sDatabaseName
84145>>>>>>>        Move sLogicalName  to sPhysicalFileName
84146>>>>>>>        Move (sPhysicalFileName + ".int") to sPhysicalFileName
84147>>>>>>>
84147>>>>>>>        Get IsMertechDriver sDriverID to bMertech
84148>>>>>>>        If (bMertech = True) Begin
84150>>>>>>>            // This should not be called here. Instead it is called by the SqlUtilUpdateIntFile!
84150>>>>>>>            // Else it will create an error in the error log (although it won't do anything...)
84150>>>>>>>            // Get _MertechSqlUtilCreateIntFile hTable sLogicalName sDataPath sPhysicalFileName to bOK
84150>>>>>>>            Function_Return (bOK = True)
84151>>>>>>>        End
84151>>>>>>>>
84151>>>>>>>
84151>>>>>>>        Get psSchema hTable to sSchemaName
84152>>>>>>>        If (sSchemaName = "") Begin
84154>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchemaName
84155>>>>>>>        End
84155>>>>>>>>
84155>>>>>>>
84155>>>>>>>        // If the .int file already exists; we rename it to "FileName" + ".bak"
84155>>>>>>>        Get vFilePathExists (sDataPath + sPhysicalFileName) to bExists
84156>>>>>>>        If (bExists = True) Begin
84158>>>>>>>            Get vRenameFile (sDataPath + sPhysicalFileName) (sDataPath + sPhysicalFileName + ".bak") to bOK
84159>>>>>>>        End
84159>>>>>>>>
84159>>>>>>>
84159>>>>>>>        Get UtilDeleteCacheFile sRootName to bOK
84160>>>>>>>        Get SqlUtilEnumerateIndexes sRootName sDriverID to sIndexArray
84161>>>>>>>
84161>>>>>>>        Get Seq_Open_Output_Channel (sDataPath + sPhysicalFileName) to iCh
84162>>>>>>>            Writeln channel iCh CS_DRIVER_NAME     " " sDriverID
84167>>>>>>>            If (bUseConnectionID = True) Begin
84169>>>>>>>                Writeln channel iCh CS_SERVER_NAME " " CS_DFCONNID "=" sConnectionID
84176>>>>>>>            End
84176>>>>>>>>
84176>>>>>>>            Else Begin
84177>>>>>>>                Writeln channel iCh CS_SERVER_NAME " " CS_SERVER "=" sConnectionString
84184>>>>>>>            End
84184>>>>>>>>
84184>>>>>>>            Writeln channel iCh CS_DATABASE_NAME          " " sDatabaseName
84189>>>>>>>            Writeln channel iCh CS_SCHEMA_NAME            " " (Lowercase(sSchemaName))
84194>>>>>>>            // There seems to be a new order how these are set from DF19.
84194>>>>>>>            If (bSysFile = True) Begin
84196>>>>>>>                Writeln channel iCh CS_RECNUM_TABLE       " " "NO"
84201>>>>>>>            End
84201>>>>>>>>
84201>>>>>>>            Writeln channel iCh CS_TABLE_CHARACTER_FORMAT " " sANSI_OEM
84206>>>>>>>            Writeln channel iCh CS_USE_DUMMY_ZERO_DATE    " " "YES" // ToDo: We maybe need to paramerize this setting?
84211>>>>>>>            If (bSysFile = True) Begin
84213>>>>>>>                Writeln channel iCh CS_SYSTEM_FILE        " " "YES"
84218>>>>>>>            End
84218>>>>>>>>
84218>>>>>>>
84218>>>>>>>            If (bSysFile = False) Begin
84220>>>>>>>                Move (SizeOfArray(sIndexArray)) to iSize
84221>>>>>>>                Move (SortArray(sIndexArray)) to sIndexArray
84222>>>>>>>                If (iSize > 0) Begin
84224>>>>>>>                    Writeln channel iCh (CS_PRIMARY_INDEX * String("0"))
84227>>>>>>>                    Writeln channel iCh // Just an empty line
84229>>>>>>>                End
84229>>>>>>>>
84229>>>>>>>                Decrement iSize
84230>>>>>>>                For iCount from 0 to iSize
84236>>>>>>>>
84236>>>>>>>                    Writeln channel iCh (CS_INDEX_NUMBER * String(iCount))
84239>>>>>>>                    Writeln channel iCh (CS_INDEX_NAME   * String(sIndexArray[iCount]))
84242>>>>>>>                    Writeln channel iCh
84244>>>>>>>                Loop
84245>>>>>>>>
84245>>>>>>>            End
84245>>>>>>>>
84245>>>>>>>        Send Seq_Close_Channel iCh
84246>>>>>>>
84246>>>>>>>        // Wait a sec for Windows to finish writing the file:
84246>>>>>>>        Sleep 1
84247>>>>>>>
84247>>>>>>>        Function_Return (bOK = True)
84248>>>>>>>    End_Function
84249>>>>>>>
84249>>>>>>>    // Returns a handle to the SQL server associated with the passed driver ID.
84249>>>>>>>    // Pass e.g. the psServer property to determine the current connection server.
84249>>>>>>>    // Returns a handle to the database connection, or a zero (0) if it fails.
84249>>>>>>>    // This handle can be used to obtain attributes about the server, such as default
84249>>>>>>>    // column types.
84249>>>>>>>    Function SqlUtilDatabaseHandle String sDriverID String sServer Returns Handle
84251>>>>>>>        Handle hDatabase
84251>>>>>>>        Integer iDriver iServers iCount
84251>>>>>>>        String sValue
84251>>>>>>>
84251>>>>>>>        If (sServer = "") Begin
84253>>>>>>>            Function_Return 0
84254>>>>>>>        End
84254>>>>>>>>
84254>>>>>>>
84254>>>>>>>        Get DriverIndex sDriverID to iDriver
84255>>>>>>>        If (iDriver = 0) Begin
84257>>>>>>>            Function_Return 0
84258>>>>>>>        End
84258>>>>>>>>
84258>>>>>>>
84258>>>>>>>        Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriver to iServers
84261>>>>>>>        For iCount from 1 to iServers
84267>>>>>>>>
84267>>>>>>>            Get_Attribute DF_DRIVER_SERVER_NAME of iDriver iCount to sValue
84270>>>>>>>            If (Uppercase(sValue) contains Uppercase(sServer)) Begin
84272>>>>>>>                Get_Attribute DF_DATABASE_ID of iDriver iCount to hDatabase
84275>>>>>>>            End
84275>>>>>>>>
84275>>>>>>>        Loop
84276>>>>>>>>
84276>>>>>>>
84276>>>>>>>        Function_Return hDatabase
84277>>>>>>>    End_Function
84278>>>>>>>
84278>>>>>>>//    Function UtilIsFilelistEntryDriverBased Integer hTable String sDriverID Returns Boolean
84278>>>>>>>//        String sRootName
84278>>>>>>>//        Boolean bOK
84278>>>>>>>//
84278>>>>>>>//        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84278>>>>>>>//        Move (sRootName contains sDriverID) to bOK
84278>>>>>>>//
84278>>>>>>>//        Function_Return bOK
84278>>>>>>>//    End_Function
84278>>>>>>>
84278>>>>>>>//    Function UtilFilelistAddDriverInfo Integer hTable Returns Boolean
84278>>>>>>>//        String sDriverID sRootName sDisplayName sSchema sVal
84278>>>>>>>//        Integer iDbType
84278>>>>>>>//        Boolean bOK
84278>>>>>>>//
84278>>>>>>>//        Get UtilIsFilelistEntryDriverBased to bOK
84278>>>>>>>//        If (bOK = True) Begin
84278>>>>>>>//            Function_Return False
84278>>>>>>>//        End
84278>>>>>>>//
84278>>>>>>>//        Get psDriverID to sDriverID
84278>>>>>>>//        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
84278>>>>>>>//        Move (sDriverID + ":" + sRootName)           to sRootName
84278>>>>>>>//        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
84278>>>>>>>//
84278>>>>>>>//        Get psDriverID to sDriverID
84278>>>>>>>//        Get piDbType   to iDbType
84278>>>>>>>//        Get psSchema   to sSchema
84278>>>>>>>//        If (sSchema = "") Begin
84278>>>>>>>//            Get _SqlFindKeyWord CI_SQLDBO to sSchema
84278>>>>>>>//        End
84278>>>>>>>//
84278>>>>>>>//        Move (Uppercase(sDisplayName)) to sVal
84278>>>>>>>//        If (not(sVal contains (sSchema + "."))) Begin
84278>>>>>>>//            If (iDbType = EN_dbTypeDB2) Begin
84278>>>>>>>//                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
84278>>>>>>>//            End
84278>>>>>>>//            Else Begin
84278>>>>>>>//                Move (sSchema + "." + sDisplayName) to sDisplayName
84278>>>>>>>//            End
84278>>>>>>>//        End
84278>>>>>>>//
84278>>>>>>>//        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
84278>>>>>>>//        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
84278>>>>>>>//
84278>>>>>>>//        Function_Return True
84278>>>>>>>//    End_Function
84278>>>>>>>
84278>>>>>>>    // Removes all driver identifications (e.g. "MSSQLDRV:MyTable")
84278>>>>>>>    // from the passed filelist.
84278>>>>>>>    // Returns the number of tables affected.
84278>>>>>>>    Function SqlUtilFilelistRemoveDriverInfo String sFilelist Returns Integer
84280>>>>>>>        String sCurrentFileList sRootName sDisplayName sLogicalName sVal
84280>>>>>>>        Integer iRetval
84280>>>>>>>        Handle hTable
84280>>>>>>>
84280>>>>>>>        // We first save the current filelist as the passed filelist name
84280>>>>>>>        // may come from another workspace, to restore it when we're ready.
84280>>>>>>>        Get_Attribute DF_FILELIST_NAME to sCurrentFileList
84283>>>>>>>        Set_Attribute DF_FILELIST_NAME to sFilelist
84286>>>>>>>        Move 0 to hTable
84287>>>>>>>        Move 0 to iRetval
84288>>>>>>>
84288>>>>>>>        Repeat
84288>>>>>>>>
84288>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
84291>>>>>>>            If (hTable <> 0) Begin
84293>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
84296>>>>>>>                Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
84299>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
84302>>>>>>>                Move (Uppercase(sRootName)) to sVal
84303>>>>>>>                If (sVal contains MSSQLDRV_ID or sVal contains DB2_DRV_ID or sVal contains ODBC_DRV_ID) Begin
84305>>>>>>>                    // Prefixes:
84305>>>>>>>                    Move (Replace((MSSQLDRV_ID + ":"), sRootName, "")) to sRootName
84306>>>>>>>                    Move (Replace((DB2_DRV_ID  + ":"), sRootName, "")) to sRootName
84307>>>>>>>                    Move (Replace((ODBC_DRV_ID + ":"), sRootName, "")) to sRootName
84308>>>>>>>                    // Suffixes:
84308>>>>>>>                    Move (Replace(("." + MSSQLDRV_ID), sRootName, "")) to sRootName
84309>>>>>>>                    Move (Replace(("." + DB2_DRV_ID),  sRootName, "")) to sRootName
84310>>>>>>>                    Move (Replace(("." + ODBC_DRV_ID), sRootName, "")) to sRootName
84311>>>>>>>
84311>>>>>>>                    // Change Filelist entry:
84311>>>>>>>                    Set_Attribute DF_FILE_ROOT_NAME of hTable          to sRootName
84314>>>>>>>
84314>>>>>>>                    Move (Lowercase(sDisplayName)) to sVal
84315>>>>>>>                    If (sVal contains "dbo.") Begin
84317>>>>>>>                        Move (Replace("dbo.", sDisplayName, ""))       to sDisplayName
84318>>>>>>>
84318>>>>>>>                        // Change Filelist entry:
84318>>>>>>>                        Set_Attribute DF_FILE_DISPLAY_NAME of hTable   to sDisplayName
84321>>>>>>>                    End
84321>>>>>>>>
84321>>>>>>>                    Increment iRetval
84322>>>>>>>                End
84322>>>>>>>>
84322>>>>>>>            End
84322>>>>>>>>
84322>>>>>>>        Until (hTable = 0)
84324>>>>>>>
84324>>>>>>>        Set_Attribute DF_FILELIST_NAME to sCurrentFileList
84327>>>>>>>
84327>>>>>>>        Function_Return iRetval
84328>>>>>>>    End_Function
84329>>>>>>>
84329>>>>>>>    // To open all Sql based tables in Filelist.cfg
84329>>>>>>>    Procedure SqlUtilOpenAllTables
84331>>>>>>>        Handle hTable
84331>>>>>>>        String sRoot sDriverID
84331>>>>>>>        Boolean bOK
84331>>>>>>>
84331>>>>>>>        Move 0 to hTable
84332>>>>>>>        Move "" to sDriverID
84333>>>>>>>        Get AutoConnectionIDLogin to bOK
84334>>>>>>>
84334>>>>>>>        Repeat
84334>>>>>>>>
84334>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
84337>>>>>>>            If (hTable > 0) Begin
84339>>>>>>>                Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
84342>>>>>>>                If (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID) Begin
84344>>>>>>>                    Get_Attribute DF_FILE_ROOT_NAME of hTable to sRoot
84347>>>>>>>                    If (Uppercase(sRoot) contains ".INT" or Uppercase(sRoot) contains MSSQLDRV_ID or Uppercase(sRoot) contains DB2_DRV_ID or Uppercase(sRoot) contains ODBC_DRV_ID) Begin
84349>>>>>>>                        Open hTable
84351>>>>>>>                    End
84351>>>>>>>>
84351>>>>>>>                End
84351>>>>>>>>
84351>>>>>>>            End
84351>>>>>>>>
84351>>>>>>>
84351>>>>>>>        Until (hTable = 0)
84353>>>>>>>    End_Procedure
84354>>>>>>>
84354>>>>>>>//    Function SqlUtilSchemaName Handle hTable Returns String
84354>>>>>>>//        String sRetval sDriverID
84354>>>>>>>//        String sTableName
84354>>>>>>>//        Integer iDbType iIndex
84354>>>>>>>//        Boolean bOK
84354>>>>>>>//
84354>>>>>>>//        Get psDriverID to sDriverID
84354>>>>>>>//        Get _SqlCheckCurrentDriver sDriverID to bOK
84354>>>>>>>//        If (hTable = 0 or bOK = False) Begin
84354>>>>>>>//            Function_Return ""
84354>>>>>>>//        End
84354>>>>>>>//
84354>>>>>>>//        Move False to Err
84354>>>>>>>//        Get UtilTableHandleToString hTable to sTableName
84354>>>>>>>//        Get piDbType to iDbType
84354>>>>>>>//        Get _SqlUtilEnumerateTableIndex sTableName sDriverID to iIndex
84354>>>>>>>//        If (iIndex = -1) Begin
84354>>>>>>>//            Function_Return ""
84354>>>>>>>//        End
84354>>>>>>>//
84354>>>>>>>//        Function_Return sRetval
84354>>>>>>>//    End_Function
84354>>>>>>>
84354>>>>>>>    // Checks if the passed Table;
84354>>>>>>>    // 1) Already has a Filelist entry that points to SQL and
84354>>>>>>>    // 2) It has an .int file.
84354>>>>>>>    // If both is True it should already be connected to SQL
84354>>>>>>>    Function SqlUtilTableIsAttached String sDriverID Handle hTable Returns Boolean
84356>>>>>>>        Boolean bExists bRootName
84356>>>>>>>        String sRootName sDataPath
84356>>>>>>>
84356>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84359>>>>>>>        Move (sRootName contains sDriverID) to bRootName
84360>>>>>>>
84360>>>>>>>        Get psDataPathFirstPart to sDataPath
84361>>>>>>>        Get vFolderExists sDataPath to bExists
84362>>>>>>>        If (bExists = False) Begin
84364>>>>>>>            // If the path doesn't exist it cannot have an .int file and we're done, although it shouldn't happen.
84364>>>>>>>            Function_Return False
84365>>>>>>>        End
84365>>>>>>>>
84365>>>>>>>
84365>>>>>>>        Get vFolderFormat sDataPath to sDataPath
84366>>>>>>>        Get _TableNameOnly sRootName to sRootName
84367>>>>>>>        Get vFilePathExists (sDataPath + sRootName + ".int") to bExists
84368>>>>>>>
84368>>>>>>>        Function_Return (bRootName = True and bExists = True)
84369>>>>>>>    End_Function
84370>>>>>>>
84370>>>>>>>    Function SqlUtilTableIsViewType String sDriverID Handle hTable Returns Boolean
84372>>>>>>>        Boolean bViewTableType bOpen bOK
84372>>>>>>>        Integer iTableCount iNumTables
84372>>>>>>>        String sTableName sOwner sTableType sEnumTableName sEnumSchemaName
84372>>>>>>>        Handle hoCliHandler
84372>>>>>>>        tSQLConnection SQLConnection
84372>>>>>>>        tSQLConnection SQLConnection
84372>>>>>>>
84372>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
84375>>>>>>>        If (bOpen = False) Begin
84377>>>>>>>            Get AutoConnectionIDLogin to bOK
84378>>>>>>>            Open hTable
84380>>>>>>>        End
84380>>>>>>>>
84380>>>>>>>
84380>>>>>>>        Get pSQLConnection to SQLConnection
84381>>>>>>>        Get phoCLIHandler to hoCliHandler
84382>>>>>>>        Set psDriverID of hoCliHandler to sDriverID
84383>>>>>>>
84383>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
84386>>>>>>>        Get _TableNameOnly sTableName to sTableName
84387>>>>>>>        Get_Attribute DF_FILE_OWNER     of hTable to sOwner
84390>>>>>>>        Get EnumerateTables of hoCliHandler SQLConnection.sConnectionString to iNumTables
84391>>>>>>>
84391>>>>>>>        For iTableCount from 1 to iNumTables
84397>>>>>>>>
84397>>>>>>>            Get TableName  of hoCliHandler iTableCount to sEnumTableName
84398>>>>>>>            Get SchemaName of hoCliHandler iTableCount to sEnumSchemaName
84399>>>>>>>            If ((Uppercase(sEnumTableName)  = Uppercase(sTableName)) and (Uppercase(sEnumSchemaName) = Uppercase(sOwner))) Begin
84401>>>>>>>                Get TableType of hoCliHandler iTableCount to sTableType
84402>>>>>>>                Move iNumTables to iTableCount // We're done.
84403>>>>>>>            End
84403>>>>>>>>
84403>>>>>>>        Loop
84404>>>>>>>>
84404>>>>>>>
84404>>>>>>>        Move (sTableType = "VIEW") to bViewTableType
84405>>>>>>>        If (bOpen = False) Begin
84407>>>>>>>            Close hTable
84408>>>>>>>        End
84408>>>>>>>>
84408>>>>>>>
84408>>>>>>>        Function_Return bViewTableType
84409>>>>>>>    End_Function
84410>>>>>>>
84410>>>>>>>    // *** DbType conversion routines - Converts between string/integer and driver ID values ***
84410>>>>>>>    //
84410>>>>>>>    // SQL utility function that returns a database type (string) constant
84410>>>>>>>    // corresponding to the passed iDbType.
84410>>>>>>>    Function SqlUtilDbTypeToString Integer iDbType Returns String
84412>>>>>>>        String sRetval
84412>>>>>>>        Get SqlUtilDbTypeToString of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
84413>>>>>>>        Function_Return sRetval
84414>>>>>>>    End_Function
84415>>>>>>>
84415>>>>>>>    // SQL utility function that returns a database type constant (integer)
84415>>>>>>>    // corresponding to the passed sDbType string constant.
84415>>>>>>>    Function SqlUtilDbTypeToInteger String sDbType Returns Integer
84417>>>>>>>        Integer iRetval
84417>>>>>>>        Get SqlUtilDbTypeToInteger of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDbType to iRetval
84418>>>>>>>        Function_Return iRetval
84419>>>>>>>    End_Function
84420>>>>>>>
84420>>>>>>>    // Pass an integer DbType and function returns the database type integer as a string value.
84420>>>>>>>    // Used e.g. when reading a connection ini-file to display the database type in
84420>>>>>>>    // the SQL Connection program's grid.
84420>>>>>>>    Function SqlUtilDbTypeIntegerToStringConstant Integer iDbType Returns String
84422>>>>>>>        String sRetval
84422>>>>>>>        Get SqlUtilDbTypeIntegerToStringConstant of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) iDbType to sRetval
84423>>>>>>>        Function_Return sRetval
84424>>>>>>>    End_Function
84425>>>>>>>
84425>>>>>>>    // Pass a driver name as a string and the function will return
84425>>>>>>>    // a dbType as an integer. Obviously for the ODBC_DRV this doesn't
84425>>>>>>>    // quite work and always returns "MS SQL Server"
84425>>>>>>>    Function SqlUtilDbTypeFromDriver String sDriverID Returns Integer
84427>>>>>>>        Integer iRetval
84427>>>>>>>        Get SqlUtilDbTypeFromDriver of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDriverID to iRetval
84428>>>>>>>        Function_Return iRetval
84429>>>>>>>    End_Function
84430>>>>>>>
84430>>>>>>>    // Returns a temp table name that consists of the RootName, an underscore and as much of a GUID
84430>>>>>>>    // that "fits" in the max allowed length for table names.
84430>>>>>>>    // Max number of characters allowed for table names;
84430>>>>>>>    // IBM DB2      = 128
84430>>>>>>>    // MS-SQL       = 128
84430>>>>>>>    // Oracle       = 128 (Version 12.2 and later. 30 characters for earlier versions)
84430>>>>>>>    // MySQL        = 64
84430>>>>>>>    // PostgreSQL   = 64
84430>>>>>>>    Function SqlUtilGUIDTempTableName String sRootName Returns String
84432>>>>>>>        String sGUIDName
84432>>>>>>>        Integer iDbType iLength
84432>>>>>>>
84432>>>>>>>        Get piDbType to iDbType
84433>>>>>>>        Move (RandomHexUUID()) to sGUIDName
84434>>>>>>>        Move (sRootName + "_" + sGUIDName) to sGUIDName
84435>>>>>>>        Move (Length(sGUIDName)) to iLength
84436>>>>>>>
84436>>>>>>>        Case Begin
84436>>>>>>>            Case (iDbType = EN_DbTypeDB2)
84438>>>>>>>            If (iLength > 128) Begin
84440>>>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
84441>>>>>>>            End
84441>>>>>>>>
84441>>>>>>>            Case Break
84442>>>>>>>
84442>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
84445>>>>>>>            If (iLength > 128) Begin
84447>>>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
84448>>>>>>>            End
84448>>>>>>>>
84448>>>>>>>            Case Break
84449>>>>>>>
84449>>>>>>>            Case (iDbType = EN_DbTypeOracle) // Note: We assume an Oracle version of 12.2 or later.
84452>>>>>>>            If (iLength > 128) Begin
84454>>>>>>>                Move (Left(sGUIDName, 128)) to sGUIDName
84455>>>>>>>            End
84455>>>>>>>>
84455>>>>>>>            Case Break
84456>>>>>>>
84456>>>>>>>            Case (iDbType = EN_DbTypeMySQL)
84459>>>>>>>            If (iLength > 64) Begin
84461>>>>>>>                Move (Left(sGUIDName, 64)) to sGUIDName
84462>>>>>>>            End
84462>>>>>>>>
84462>>>>>>>            Case Break
84463>>>>>>>
84463>>>>>>>            Case (iDbType = EN_DbTypePostgre)
84466>>>>>>>            If (iLength > 64) Begin
84468>>>>>>>                Move (Left(sGUIDName, 64)) to sGUIDName
84469>>>>>>>            End
84469>>>>>>>>
84469>>>>>>>        Case End
84469>>>>>>>
84469>>>>>>>        Function_Return sGUIDName
84470>>>>>>>    End_Function
84471>>>>>>>
84471>>>>>>>    // Reads a resource that has been embedded by the compiler and writes it to disk.
84471>>>>>>>    // Pass the memory resource file reference and the filename to be created,
84471>>>>>>>    // including full path.
84471>>>>>>>    Procedure SqlUtilCreateFileFromMemory String sMemFileName String sFileName
84473>>>>>>>        String sText
84473>>>>>>>        Integer iCh iSize iArgSize
84473>>>>>>>
84473>>>>>>>        Move ("Resource:" + sMemFileName) to sMemFileName
84474>>>>>>>        Get Seq_Open_Input_Channel sMemFileName to iCh
84475>>>>>>>        Get_Channel_Size iCh to iSize
84476>>>>>>>        Get_Argument_Size to iArgSize
84477>>>>>>>        If (iSize > iArgSize) Begin
84479>>>>>>>            Set_Argument_Size iSize
84480>>>>>>>>
84480>>>>>>>        End
84480>>>>>>>>
84480>>>>>>>        Read_Block channel iCh sText iSize
84482>>>>>>>        Send Seq_Close_Channel iCh
84483>>>>>>>
84483>>>>>>>        Get Seq_Open_Output_Channel sFileName to iCh
84484>>>>>>>            Write channel iCh sText
84486>>>>>>>        Send Seq_Close_Channel iCh
84487>>>>>>>
84487>>>>>>>        If (iSize <> iArgSize) Begin
84489>>>>>>>            Set_Argument_Size iArgSize
84490>>>>>>>>
84490>>>>>>>        End
84490>>>>>>>>
84490>>>>>>>        // Wait for file to be written to disk.
84490>>>>>>>        Sleep 2
84491>>>>>>>    End_Procedure
84492>>>>>>>
84492>>>>>>>    Function SqlUtilDefaultNullValue String sDriverID Integer iDbType Integer iDataType Returns String
84494>>>>>>>        String sNotNull sRetval sDefaultValue
84494>>>>>>>        Boolean bOK
84494>>>>>>>
84494>>>>>>>        Get IsSQLDriver sDriverID to bOK
84495>>>>>>>        If (bOK = False) Begin
84497>>>>>>>            Function_Return ""
84498>>>>>>>        End
84498>>>>>>>>
84498>>>>>>>
84498>>>>>>>        Get UtilDataTypeDefaultValue sDriverID iDbType iDataType to sDefaultValue
84499>>>>>>>        Get _SqlFindKeyWord CI_SQLNotNull to sNotNull
84500>>>>>>>
84500>>>>>>>        Case Begin
84500>>>>>>>            Case (iDbType = EN_dbTypeMSSQL)
84502>>>>>>>                Move ("DEFAULT" * String(sDefaultValue) * String(sNotNull)) to sRetval
84503>>>>>>>                Case Break
84504>>>>>>>            Case (iDbType = EN_dbTypeMySQL)
84507>>>>>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
84508>>>>>>>                Case Break
84509>>>>>>>            Case (iDbType = EN_dbTypePostgre)
84512>>>>>>>                Move (String(sNotNull) * "DEFAULT" * String(sDefaultValue)) to sRetval
84513>>>>>>>                Case Break
84514>>>>>>>            Case (iDbType = EN_dbTypeDB2)
84517>>>>>>>                Move (String(sNotNull))                                     to sRetval
84518>>>>>>>                Case Break
84519>>>>>>>
84519>>>>>>>            // Seems like Oracle can't handle setting a new column to 'NOT NULL' if the table exists with data(!)
84519>>>>>>>            // ToDo: We need to look deeper into how Oracle handles NULL
84519>>>>>>>            Case (iDbType = EN_dbTypeOracle)
84522>>>>>>>                Move  ""                                                    to sRetval
84523>>>>>>>                Case Break
84524>>>>>>>
84524>>>>>>>            Case Else
84524>>>>>>>                Move  ""                                                    to sRetval
84525>>>>>>>        Case End
84525>>>>>>>
84525>>>>>>>        Function_Return sRetval
84526>>>>>>>    End_Function
84527>>>>>>>
84527>>>>>>>    Function SqlUtilUpdateIntFile Integer hTable Returns Boolean
84529>>>>>>>        String sOrgFormat sNewFormat sRootName sDatabaseName sPhysicalFileName sDriverID sDataPath
84529>>>>>>>        Boolean bOpened bOK bMertech
84529>>>>>>>
84529>>>>>>>        // For some reason this .int file update screws up of CodeMast & CodeType .int files
84529>>>>>>>        // which makes the program unable to run because they can't be opened.
84529>>>>>>>        // ToDo: This needs further investigation but for now we just skip CodeMast & CodeType .int files update...
84529>>>>>>>        // Also note that there is another helper function "UtilTableCreateCodeMastCodeTypeIntFiles" to create
84529>>>>>>>        // proper .int files for the two tables.
84529>>>>>>>        If (Uppercase(sDatabaseName) = "CODETYPE" or Uppercase(sDatabaseName) = "CODEMAST") Begin
84531>>>>>>>            Function_Return True
84532>>>>>>>        End
84532>>>>>>>>
84532>>>>>>>
84532>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84535>>>>>>>        Get _TableNameOnly sRootName to sDatabaseName
84536>>>>>>>        Move CS_OEM_Txt  to sOrgFormat
84537>>>>>>>        Move CS_ANSI_Txt to sNewFormat
84538>>>>>>>        Get AutoConnectionIDLogin to bOK
84539>>>>>>>
84539>>>>>>>        // It seems this can be called to quickly; causing a 13001 error "Cannot open cache file for write"
84539>>>>>>>        Sleep 1
84540>>>>>>>
84540>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
84543>>>>>>>        If (bOpened = False) Begin
84545>>>>>>>            Open hTable
84547>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpened
84550>>>>>>>        End
84550>>>>>>>>
84550>>>>>>>        If (bOpened = False) Begin
84552>>>>>>>            Function_Return False
84553>>>>>>>        End
84553>>>>>>>>
84553>>>>>>>
84553>>>>>>>        Get psDriverID to sDriverID
84554>>>>>>>        Get IsMertechDriver sDriverID to bMertech
84555>>>>>>>        If (bMertech = True) Begin
84557>>>>>>>            Get psDataPathFirstPart to sDataPath
84558>>>>>>>            Get vFolderExists sDataPath to bOK
84559>>>>>>>            If (bOK = False) Begin
84561>>>>>>>                Error DFERR_PROGRAM "Function SqlUtilUpdateIntFile; psDataPath not found!"
84562>>>>>>>>
84562>>>>>>>                Function_Return False
84563>>>>>>>            End
84563>>>>>>>>
84563>>>>>>>            Get vFolderFormat sDataPath to sDataPath
84564>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
84567>>>>>>>            Get _TableNameOnly sRootName to sDatabaseName
84568>>>>>>>            Move sDatabaseName to sPhysicalFileName
84569>>>>>>>            Move (sPhysicalFileName + ".int") to sPhysicalFileName
84570>>>>>>>            Get _MertechSqlUtilCreateIntFile hTable sDatabaseName sDataPath sPhysicalFileName to bOK
84571>>>>>>>            Function_Return (bOK = True)
84572>>>>>>>        End
84572>>>>>>>>
84572>>>>>>>
84572>>>>>>>        Move False to Err
84573>>>>>>>        Get_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
84576>>>>>>>        Move (Uppercase(sOrgFormat)) to sOrgFormat
84577>>>>>>>        // Lets swap the OEM/ANSI format, just to make a change in Structure_Start below (and back),
84577>>>>>>>        // to "touch" the table so the driver feels there has been a change and updates the .int file.
84577>>>>>>>        Move (If(sOrgFormat = CS_OEM_Txt, CS_ANSI_Txt, CS_OEM_Txt)) to sNewFormat
84578>>>>>>>
84578>>>>>>>        Move False to Err
84579>>>>>>>
84579>>>>>>>        If (hTable > 0) Begin
84581>>>>>>>            Structure_Start hTable
84582>>>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
84585>>>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
84588>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
84590>>>>>>>        End
84590>>>>>>>>
84590>>>>>>>        Else Begin
84591>>>>>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sNewFormat
84594>>>>>>>            Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of hTable to sOrgFormat
84597>>>>>>>        End
84597>>>>>>>>
84597>>>>>>>        Function_Return (Err = False)
84598>>>>>>>    End_Function
84599>>>>>>>
84599>>>>>>>    Function SqlProcedureArrayMertech String sStmt String sArgument Returns String[]
84601>>>>>>>        String[] sReturnArray
84602>>>>>>>        String sValue // sUserID sPassword
84602>>>>>>>        Handle hoSQLHandler hoSQLConnect hStmt
84602>>>>>>>        Integer iFetchResult iRetval
84602>>>>>>>        tSQLConnection SQLConnection
84602>>>>>>>        tSQLConnection SQLConnection
84602>>>>>>>
84602>>>>>>>        Get _MertechSQLManagerHandle to hoSQLHandler
84603>>>>>>>        If (hoSQLHandler <> 0) Begin
84605>>>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
84606>>>>>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
84607>>>>>>>            If (hoSQLConnect <> 0) Begin
84609>>>>>>>                Get SQLOpen of hoSQLConnect to hStmt
84610>>>>>>>                If (hStmt <> 0) Begin
84612>>>>>>>                    Send SQLSetProcedureName of hStmt sStmt
84613>>>>>>>                    If (sArgument <> "") Begin
84615>>>>>>>                        Send SqlSetArgument  of hStmt 1 sArgument
84616>>>>>>>                    End
84616>>>>>>>>
84616>>>>>>>                    Send SQLCall of hStmt
84617>>>>>>>
84617>>>>>>>                    Get SqlReturnValue       of hStmt to iRetval
84618>>>>>>>                    If (iRetval = 0) Begin
84620>>>>>>>                        Repeat
84620>>>>>>>>
84620>>>>>>>                            Get SQLFetch of hStmt to iFetchResult
84621>>>>>>>                            If (iFetchResult <> 0) Begin
84623>>>>>>>                                Get SQLColumnValue of hStmt 1 to sValue
84624>>>>>>>                                Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
84625>>>>>>>                            End
84625>>>>>>>>
84625>>>>>>>                        Until (iFetchResult = 0)
84627>>>>>>>                        Send SQLClose of hStmt
84628>>>>>>>                    End
84628>>>>>>>>
84628>>>>>>>                End
84628>>>>>>>>
84628>>>>>>>                Send SQLDisconnect of hoSQLConnect
84629>>>>>>>            End
84629>>>>>>>>
84629>>>>>>>        End
84629>>>>>>>>
84629>>>>>>>
84629>>>>>>>        Function_Return sReturnArray
84630>>>>>>>    End_Function
84631>>>>>>>
84631>>>>>>>    // * Dummy function for the Studio's Code Explorer *
84631>>>>>>>    Function SQL_ENUMERATION_FUNCTIONS Returns Boolean
84633>>>>>>>        Function_Return False
84634>>>>>>>    End_Function
84635>>>>>>>
84635>>>>>>>    // Enumerate SQL Servers.
84635>>>>>>>    // Pass a driver id. Returns a string array.
84635>>>>>>>    // The iDataSourceType (iDatSrcType) parameter is optional and is for the ODBC driver only.
84635>>>>>>>    // Note: Returns servers for MSSQLDRV; else data-sources on the machine.
84635>>>>>>>    Function SqlUtilEnumerateServers String sDriverID Integer iDatSrcType Returns String[]
84637>>>>>>>        String[] sReturnArray
84638>>>>>>>        Handle hoSQLHandler
84638>>>>>>>        String sServer
84638>>>>>>>        Integer iCount iNumItems iDataSourceType
84638>>>>>>>
84638>>>>>>>        If (num_arguments > 1) Begin
84640>>>>>>>            Move iDatSrcType to iDataSourceType
84641>>>>>>>        End
84641>>>>>>>>
84641>>>>>>>
84641>>>>>>>        Case Begin
84641>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
84643>>>>>>>                Get phoMSSQLHandler to hoSQLHandler
84644>>>>>>>                Get EnumerateServers of hoSQLHandler to iNumItems
84645>>>>>>>                For iCount from 0 to (iNumItems - 1)
84651>>>>>>>>
84651>>>>>>>                    Get String_Value of hoSQLHandler iCount to sServer
84652>>>>>>>                    Move (Trim(sServer)) to sReturnArray[iCount]
84653>>>>>>>                Loop
84654>>>>>>>>
84654>>>>>>>                Case Break
84655>>>>>>>
84655>>>>>>>            Case (sDriverID = DB2_DRV_ID)
84658>>>>>>>                Get phoDB2SQLHandler to hoSQLHandler
84659>>>>>>>                Send SeedDataSources of hoSQLHandler
84660>>>>>>>                Move 0 to iCount
84661>>>>>>>                Repeat
84661>>>>>>>>
84661>>>>>>>                    Get DataSources of hoSQLHandler to sServer
84662>>>>>>>                    If (sServer <> "") Begin
84664>>>>>>>                        Move (Replace(",", sServer, "")) to sServer
84665>>>>>>>                        Move sServer to sReturnArray[iCount]
84666>>>>>>>                    End
84666>>>>>>>>
84666>>>>>>>                    Increment iCount
84667>>>>>>>                Until (sServer = "")
84669>>>>>>>                Case Break
84670>>>>>>>
84670>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
84673>>>>>>>                Get phoODBCSQLHandler to hoSQLHandler
84674>>>>>>>                Set DataSourceType of hoSQLHandler to iDataSourceType
84675>>>>>>>                Move 0 to iCount
84676>>>>>>>                Repeat
84676>>>>>>>>
84676>>>>>>>                    Get DataSources of hoSQLHandler to sServer
84677>>>>>>>                    If (sServer <> "") Begin
84679>>>>>>>                        Move (Replace(",", sServer, ", ")) to sServer
84680>>>>>>>                        Move sServer to sReturnArray[iCount]
84681>>>>>>>                    End
84681>>>>>>>>
84681>>>>>>>                    Increment iCount
84682>>>>>>>                Until (sServer = "")
84684>>>>>>>                Case Break
84685>>>>>>>
84685>>>>>>>            Case (sDriverID = SQLFLEX)
84688>>>>>>>                Get _MertechEnumerateSQLFlexServers to sReturnArray
84689>>>>>>>                Case Break
84690>>>>>>>
84690>>>>>>>            Case (sDriverID = ORAFLEX)
84693>>>>>>>                Get _MertechEnumerateORAFLEXServers to sReturnArray
84694>>>>>>>                Case Break
84695>>>>>>>
84695>>>>>>>            // There appearantly is no way to enumerate servers for this backend.
84695>>>>>>>            Case (sDriverID = MDSPgSQL)
84698>>>>>>>                Move "localhost" to sReturnArray[0]
84699>>>>>>>                Case Break
84700>>>>>>>
84700>>>>>>>            // There appearantly is no way to enumerate servers for this backend.
84700>>>>>>>            Case (sDriverID = MDSMySQL)
84703>>>>>>>                Move "localhost" to sReturnArray[0]
84704>>>>>>>                Case Break
84705>>>>>>>
84705>>>>>>>            Case Else
84705>>>>>>>                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateServers function"
84706>>>>>>>>
84706>>>>>>>        Case End
84706>>>>>>>
84706>>>>>>>        Function_Return sReturnArray
84707>>>>>>>    End_Function
84708>>>>>>>
84708>>>>>>>    // Returns all databases as a string array for the passed driver id.
84708>>>>>>>    Function SqlUtilEnumerateDatabases String sDriverID Returns String[]
84710>>>>>>>        String[] sReturnArray
84711>>>>>>>        String sServer sVal
84711>>>>>>>        tSQLIntTableInfo[] sReturnStructArray
84711>>>>>>>        tSQLIntTableInfo[] sReturnStructArray
84712>>>>>>>        tSQLConnection SQLConnection
84712>>>>>>>        tSQLConnection SQLConnection
84712>>>>>>>        Boolean bOK
84712>>>>>>>        Integer iCount iSize
84712>>>>>>>
84712>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84713>>>>>>>        If (bOK = False) Begin
84715>>>>>>>            Function_Return sReturnArray
84716>>>>>>>        End
84716>>>>>>>>
84716>>>>>>>
84716>>>>>>>        Case Begin
84716>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
84718>>>>>>>                Get _SqlDatabasesArrayMSSQL to sReturnArray
84719>>>>>>>                Case Break
84720>>>>>>>            Case (sDriverID = DB2_DRV_ID)
84723>>>>>>>                Get _SqlDatabasesArrayDB2 to sReturnArray
84724>>>>>>>                Case Break
84725>>>>>>>
84725>>>>>>>            // This is needed to be able to check if a database exists or not.
84725>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
84728>>>>>>>                Get _SqlDatabasesArrayODBC to sReturnStructArray
84729>>>>>>>                If (SizeOfArray(sReturnStructArray)) Begin
84731>>>>>>>                    If (SizeOfArray(sReturnStructArray) = 1 and sReturnStructArray[0].sServerName = "") Begin
84733>>>>>>>                        // If a FILEDSN: (can only be one database name)
84733>>>>>>>                        Move sReturnStructArray[0].sDatabaseName to sReturnArray[0]
84734>>>>>>>                    End
84734>>>>>>>>
84734>>>>>>>                    Else Begin
84735>>>>>>>                        // Else the DSN's were read from the registry.
84735>>>>>>>                        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
84736>>>>>>>                        Move SQLConnection.sServer to sServer
84737>>>>>>>                        Move (SizeOfArray(sReturnStructArray)) to iSize
84738>>>>>>>                        Decrement iSize
84739>>>>>>>                        for iCount from 0 to iSize
84745>>>>>>>>
84745>>>>>>>                            Move (sReturnStructArray[iCount].sServerName) to sVal
84746>>>>>>>                            If (Uppercase(sServer) = Uppercase(sVal)) Begin
84748>>>>>>>                                Move sReturnStructArray[iCount].sDatabaseName to sReturnArray[0]
84749>>>>>>>                                Move iSize to iCount // We're done.
84750>>>>>>>                            End
84750>>>>>>>>
84750>>>>>>>                        Loop
84751>>>>>>>>
84751>>>>>>>                    End
84751>>>>>>>>
84751>>>>>>>                End
84751>>>>>>>>
84751>>>>>>>                Case Break
84752>>>>>>>
84752>>>>>>>            Case (sDriverID = SQLFLEX)
84755>>>>>>>                Get SqlProcedureArrayMertech "sp_databases" "" to sReturnArray
84756>>>>>>>                Case Break
84757>>>>>>>
84757>>>>>>>            Case (sDriverID = MDSPgSQL)
84760>>>>>>>                Get SqlEnumerateEsqlMertech "SELECT datname FROM pg_database" to sReturnArray
84761>>>>>>>                Case Break
84762>>>>>>>
84762>>>>>>>            Case (sDriverID = MDSMySQL)
84765>>>>>>>                Get SqlEnumerateEsqlMertech "show databases" to sReturnArray
84766>>>>>>>                Case Break
84767>>>>>>>
84767>>>>>>>            Case (sDriverID = ORAFLEX)
84770>>>>>>>                Get SqlEnumerateEsqlMertech "SELECT NAME FROM v$database" to sReturnArray
84771>>>>>>>                Case Break
84772>>>>>>>
84772>>>>>>>            Case Else
84772>>>>>>>//                Error DFERR_PROGRAM "Unsupported DriverID passed to SqlUtilEnumerateDatabases function"
84772>>>>>>>        Case End
84772>>>>>>>
84772>>>>>>>        Function_Return sReturnArray
84773>>>>>>>    End_Function
84774>>>>>>>
84774>>>>>>>    // Returns all table spaces as a string array for the passed driver id.
84774>>>>>>>    Function SqlUtilEnumerateTableSpaces String sDriverID Returns String[]
84776>>>>>>>        String[] sReturnArray
84777>>>>>>>        Boolean bOK
84777>>>>>>>
84777>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84778>>>>>>>        If (bOK = False) Begin
84780>>>>>>>            Function_Return sReturnArray
84781>>>>>>>        End
84781>>>>>>>>
84781>>>>>>>
84781>>>>>>>        Case Begin
84781>>>>>>>            Case (sDriverID = DB2_DRV_ID)
84783>>>>>>>                Get SqlEnumerateEsqlDAW "select tablespace_name from dba_tablespaces" 1 to sReturnArray
84784>>>>>>>                Case Break
84785>>>>>>>
84785>>>>>>>            Case (sDriverID = MDSPgSQL)
84788>>>>>>>                Get SqlEnumerateEsqlMertech "SELECT spcname FROM pg_tablespace" 1 to sReturnArray
84789>>>>>>>                Case Break
84790>>>>>>>
84790>>>>>>>            Case (sDriverID = ORAFLEX)
84793>>>>>>>                Get SqlEnumerateEsqlMertech "SELECT TABLESPACE_NAME FROM USER_TABLESPACES" 1 to sReturnArray
84794>>>>>>>                Case Break
84795>>>>>>>
84795>>>>>>>            Case Else
84795>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateTableSpaces function."
84796>>>>>>>>
84796>>>>>>>                Case Break
84797>>>>>>>        Case End
84797>>>>>>>
84797>>>>>>>        Function_Return sReturnArray
84798>>>>>>>    End_Function
84799>>>>>>>
84799>>>>>>>    // Returns all schemas as a string array for the passed driver id.
84799>>>>>>>    Function SqlUtilEnumerateSchemas String sDriverID Returns String[]
84801>>>>>>>        String[] sReturnArray
84802>>>>>>>        Boolean bOK
84802>>>>>>>
84802>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84803>>>>>>>        If (bOK = False) Begin
84805>>>>>>>            Function_Return sReturnArray
84806>>>>>>>        End
84806>>>>>>>>
84806>>>>>>>
84806>>>>>>>        Case Begin
84806>>>>>>>            Case (sDriverID = DB2_DRV_ID)
84808>>>>>>>                Get SqlEnumerateEsqlDAW "select schemaname from syscat.schemata" 1 to sReturnArray
84809>>>>>>>                Case Break
84810>>>>>>>
84810>>>>>>>            Case (sDriverID = MDSPgSQL)
84813>>>>>>>                Get SqlEnumerateEsqlMertech "select schema_name from information_schema.schemata" 1 to sReturnArray
84814>>>>>>>                Case Break
84815>>>>>>>
84815>>>>>>>            Case (sDriverID = ORAFLEX)
84818>>>>>>>                Get SqlEnumerateEsqlMertech "SELECT username from dba_users WHERE default_tablespace not in ('SYSTEM','SYSAUX')" 1 to sReturnArray
84819>>>>>>>                Case Break
84820>>>>>>>
84820>>>>>>>            Case Else
84820>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateSchemas function."
84821>>>>>>>>
84821>>>>>>>                Case Break
84822>>>>>>>        Case End
84822>>>>>>>
84822>>>>>>>        Function_Return sReturnArray
84823>>>>>>>    End_Function
84824>>>>>>>
84824>>>>>>>    // Returns a string array with all tables for the current database.
84824>>>>>>>    Function SqlUtilEnumerateTables String sDriverID String sDatabase String sSchema Returns String[]
84826>>>>>>>        String[] sReturnArray sArray
84828>>>>>>>        String sConnectionString sSelect
84828>>>>>>>        Integer iSize iCount iDbType
84828>>>>>>>        Boolean bOK
84828>>>>>>>
84828>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
84830>>>>>>>            Function_Return sArray
84831>>>>>>>        End
84831>>>>>>>>
84831>>>>>>>
84831>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84832>>>>>>>        If (bOK = False) Begin
84834>>>>>>>            Function_Return sReturnArray
84835>>>>>>>        End
84835>>>>>>>>
84835>>>>>>>        If (sSchema = "") Begin
84837>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
84838>>>>>>>        End
84838>>>>>>>>
84838>>>>>>>
84838>>>>>>>        Get psConnectionString to sConnectionString
84839>>>>>>>
84839>>>>>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
84839>>>>>>>        // the dbType.
84839>>>>>>>        Get piDbType to iDbType
84840>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
84842>>>>>>>            If (iDbType = EN_DbTypeMySQL) Begin
84844>>>>>>>                Move MDSMySQL to sDriverID
84845>>>>>>>            End
84845>>>>>>>>
84845>>>>>>>            If (iDbType = EN_DbTypeMSSQL) Begin
84847>>>>>>>                Move MSSQLDRV_ID to sDriverID
84848>>>>>>>            End
84848>>>>>>>>
84848>>>>>>>            If (iDbType = EN_DbTypeDB2) Begin
84850>>>>>>>                Move DB2_DRV_ID to sDriverID
84851>>>>>>>            End
84851>>>>>>>>
84851>>>>>>>            If (iDbType = EN_DbTypePostgre) Begin
84853>>>>>>>                Move MDSPgSQL to sDriverID
84854>>>>>>>            End
84854>>>>>>>>
84854>>>>>>>        End
84854>>>>>>>>
84854>>>>>>>
84854>>>>>>>        Case Begin
84854>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
84856>>>>>>>                Get _SqlTableArrayDAW to sReturnArray
84857>>>>>>>                Case Break
84858>>>>>>>
84858>>>>>>>            Case (sDriverID = DB2_DRV_ID)
84861>>>>>>>                Get _SqlTableArrayDAW to sReturnArray
84862>>>>>>>                Case Break
84863>>>>>>>
84863>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
84866>>>>>>>                Get _SqlTableArrayDAW to sReturnArray
84867>>>>>>>                Case Break
84868>>>>>>>
84868>>>>>>>            Case (sDriverID = SQLFLEX)
84871>>>>>>>                Move ("SELECT TABLE_NAME FROM" * sDatabase + ".INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE != 'VIEW'") to sSelect
84872>>>>>>>                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
84873>>>>>>>                Case Break
84874>>>>>>>
84874>>>>>>>            Case (sDriverID = MDSMySQL)
84877>>>>>>>                Move ("SELECT TABLE_NAME from INFORMATION_SCHEMA.TABLES where TABLE_SCHEMA = '" + sDatabase + "' and TABLE_TYPE = 'BASE TABLE' order by TABLE_NAME") to sSelect
84878>>>>>>>                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
84879>>>>>>>                Case Break
84880>>>>>>>
84880>>>>>>>            Case (sDriverID = MDSPgSQL)
84883>>>>>>>                Move "select tablename, schemaname from pg_catalog.pg_tables order by tablename"  to sSelect
84884>>>>>>>                Get SqlEnumerateEsqlMertech sSelect "" to sReturnArray
84885>>>>>>>                Case Break
84886>>>>>>>
84886>>>>>>>            Case (sDriverID = ORAFLEX)
84889>>>>>>>                Move "SELECT table_name from user_tables" to sSelect
84890>>>>>>>                Get SqlEnumerateEsqlMertech sSelect to sArray
84891>>>>>>>                Move (SizeOfArray(sArray)) to iSize
84892>>>>>>>                Decrement iSize
84893>>>>>>>                For iCount from 0 to iSize
84899>>>>>>>>
84899>>>>>>>                    If (not(sArray[iCount] contains "$")) Begin
84901>>>>>>>                        Move sArray[iCount] to sReturnArray[SizeOfArray(sReturnArray)]
84902>>>>>>>                    End
84902>>>>>>>>
84902>>>>>>>                Loop
84903>>>>>>>>
84903>>>>>>>                Case Break
84904>>>>>>>
84904>>>>>>>            Case Else
84904>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateTables function."
84905>>>>>>>>
84905>>>>>>>                Case Break
84906>>>>>>>        Case End
84906>>>>>>>
84906>>>>>>>        Function_Return sReturnArray
84907>>>>>>>    End_Function
84908>>>>>>>
84908>>>>>>>    // Returns a string array with all table columns/fields for the passed table handle and driver id.
84908>>>>>>>    Function SqlUtilEnumerateColumns String sDriverID String sTableName Returns String[]
84910>>>>>>>        String[] sReturnArray
84911>>>>>>>        String sConnectionString sSelect sSchema
84911>>>>>>>        Boolean bOK
84911>>>>>>>        Integer iDbType
84911>>>>>>>
84911>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84912>>>>>>>        If (bOK = False) Begin
84914>>>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
84915>>>>>>>>
84915>>>>>>>            Function_Return sReturnArray
84916>>>>>>>        End
84916>>>>>>>>
84916>>>>>>>
84916>>>>>>>        Get psConnectionString to sConnectionString
84917>>>>>>>        Get psSchema to sSchema
84918>>>>>>>
84918>>>>>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
84918>>>>>>>        // the dbType.
84918>>>>>>>        Get piDbType to iDbType
84919>>>>>>>
84919>>>>>>>        Case Begin
84919>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
84921>>>>>>>                If (iDbType = EN_DbTypeMySQL) Begin
84923>>>>>>>                    Move ("SHOW COLUMNS FROM" * sTableName) to sSelect
84924>>>>>>>                End
84924>>>>>>>>
84924>>>>>>>                If (iDbType = EN_DbTypePostgre) Begin
84926>>>>>>>                    Move ("select column_name, data_type, character_maximum_length from INFORMATION_SCHEMA.COLUMNS where table_name = '" +sTableName + "'") to sSelect
84927>>>>>>>                End
84927>>>>>>>>
84927>>>>>>>                If (iDbType = EN_DbTypeMSSQL) Begin
84929>>>>>>>                    Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
84930>>>>>>>                End
84930>>>>>>>>
84930>>>>>>>
84930>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
84931>>>>>>>                Case Break
84932>>>>>>>
84932>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
84935>>>>>>>                Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
84936>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
84937>>>>>>>                Case Break
84938>>>>>>>
84938>>>>>>>            Case (sDriverID = DB2_DRV_ID)
84941>>>>>>>                Move ("SELECT colname from syscat.columns WHERE tabschema = '" + sSchema + "'" * "AND tabname = '" + sTableName + "'") to sSelect
84942>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sReturnArray
84943>>>>>>>                Case Break
84944>>>>>>>
84944>>>>>>>            Case (sDriverID = SQLFLEX)
84947>>>>>>>                Move ("select name from sys.columns where [object_id] = object_id('dbo." + sTableName + "')") to sSelect
84948>>>>>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
84949>>>>>>>                Case Break
84950>>>>>>>
84950>>>>>>>            Case (sDriverID = MDSMySQL)
84953>>>>>>>                Move ("SHOW COLUMNS FROM" * sTableName) to sSelect
84954>>>>>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
84955>>>>>>>                Case Break
84956>>>>>>>
84956>>>>>>>            Case (sDriverID = MDSPgSQL)
84959>>>>>>>                Move ("select column_name, data_type, character_maximum_length from INFORMATION_SCHEMA.COLUMNS where table_name = '" +sTableName + "'") to sSelect
84960>>>>>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
84961>>>>>>>                Case Break
84962>>>>>>>
84962>>>>>>>            Case (sDriverID = ORAFLEX)
84965>>>>>>>                Move ("SELECT column_name from user_tab_cols WHERE table_name = '" + sTableName + "'") to sSelect
84966>>>>>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sReturnArray
84967>>>>>>>                Case Break
84968>>>>>>>
84968>>>>>>>            Case Else
84968>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateColumns function."
84969>>>>>>>>
84969>>>>>>>                Case Break
84970>>>>>>>        Case End
84970>>>>>>>
84970>>>>>>>        Function_Return sReturnArray
84971>>>>>>>    End_Function
84972>>>>>>>
84972>>>>>>>
84972>>>>>>>    // Returns a string array with all table indexes for the passed table handle and driver id.
84972>>>>>>>    Function SqlUtilEnumerateIndexes String sTableName String sDriverID Returns String[]
84974>>>>>>>        String[] sReturnArray sReturnArray2
84976>>>>>>>        String sConnectionString sSelect sSchema
84976>>>>>>>        Boolean bOK
84976>>>>>>>        Integer iCount iSize
84976>>>>>>>
84976>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
84977>>>>>>>        If (bOK = False) Begin
84979>>>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
84980>>>>>>>>
84980>>>>>>>            Function_Return sReturnArray
84981>>>>>>>        End
84981>>>>>>>>
84981>>>>>>>
84981>>>>>>>        Get psConnectionString to sConnectionString
84982>>>>>>>        Get psSchema to sSchema
84983>>>>>>>
84983>>>>>>>        Case Begin
84983>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
84985>>>>>>>                Move ("select * from sys.indexes where object_id = (select object_id from sys.objects where name = '" + sTableName + "')") to sSelect
84986>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
84987>>>>>>>                Case Break
84988>>>>>>>
84988>>>>>>>            Case (sDriverID = DB2_DRV_ID)
84991>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
84992>>>>>>>>
84992>>>>>>>//                Move () to sSelect
84992>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
84992>>>>>>>                Case Break
84993>>>>>>>
84993>>>>>>>            Case (sDriverID = SQLFLEX)
84996>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
84997>>>>>>>>
84997>>>>>>>//                Move () to sSelect
84997>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
84997>>>>>>>                Case Break
84998>>>>>>>
84998>>>>>>>            Case (sDriverID = MDSMySQL)
85001>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
85002>>>>>>>>
85002>>>>>>>//                Move () to sSelect
85002>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
85002>>>>>>>                Case Break
85003>>>>>>>
85003>>>>>>>            Case (sDriverID = MDSPgSQL)
85006>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
85007>>>>>>>>
85007>>>>>>>//                Move () to sSelect
85007>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
85007>>>>>>>                Case Break
85008>>>>>>>
85008>>>>>>>            Case (sDriverID = ORAFLEX)
85011>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
85012>>>>>>>>
85012>>>>>>>//                Move () to sSelect
85012>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
85012>>>>>>>                Case Break
85013>>>>>>>
85013>>>>>>>            Case Else
85013>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to SqlUtilEnumerateIndexes function."
85014>>>>>>>>
85014>>>>>>>                Case Break
85015>>>>>>>        Case End
85015>>>>>>>
85015>>>>>>>        Move (SizeOfArray(sReturnArray)) to iSize
85016>>>>>>>        Decrement iSize
85017>>>>>>>        For iCount from 0 to iSize
85023>>>>>>>>
85023>>>>>>>            If (Trim(sReturnArray[iCount]) <> "") Begin
85025>>>>>>>                Move sReturnArray[iCount] to sReturnArray2[SizeOfArray(sReturnArray2)]
85026>>>>>>>            End
85026>>>>>>>>
85026>>>>>>>        Loop
85027>>>>>>>>
85027>>>>>>>
85027>>>>>>>        Function_Return sReturnArray2
85028>>>>>>>    End_Function
85029>>>>>>>
85029>>>>>>>    // Returns a string array with all table names the passed table handle has relation ships with.
85029>>>>>>>    // The format of the array is "TableName.FieldName"
85029>>>>>>>    Function SqlUtilEnumerateRelations String sTableName String sDriverID Returns tSQLRelation[]
85031>>>>>>>        String[] sFileNameArray sFieldNameArray
85033>>>>>>>        tSQLRelation[] sRelationsArray
85033>>>>>>>        tSQLRelation[] sRelationsArray
85034>>>>>>>        String sConnectionString sSelect sSchema sFileName sFieldName
85034>>>>>>>        Boolean bOK
85034>>>>>>>        Integer iCount iSize iLength
85034>>>>>>>
85034>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85035>>>>>>>        If (bOK = False) Begin
85037>>>>>>>            Error DFERR_PROGRAM ("Unsupported driver. A list of table columns could not be retrieved for:" * sDriverID + ".")
85038>>>>>>>>
85038>>>>>>>            Function_Return sRelationsArray
85039>>>>>>>        End
85039>>>>>>>>
85039>>>>>>>
85039>>>>>>>        Get psConnectionString to sConnectionString
85040>>>>>>>        Get psSchema to sSchema
85041>>>>>>>
85041>>>>>>>        Case Begin
85041>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
85043>>>>>>>                Move ("SELECT object_name(parent_object_id), object_name(referenced_object_id), name from sys.foreign_keys WHERE parent_object_id = object_id( '" + sTableName + "')") to sSelect
85044>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 2 to sFileNameArray
85045>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
85046>>>>>>>                Case Break
85047>>>>>>>
85047>>>>>>>            Case (sDriverID = DB2_DRV_ID)
85050>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
85051>>>>>>>>
85051>>>>>>>//                Move () to sSelect
85051>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 2 to sReturnArray
85051>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
85051>>>>>>>                Case Break
85052>>>>>>>
85052>>>>>>>            Case (sDriverID = SQLFLEX)
85055>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
85056>>>>>>>>
85056>>>>>>>//                Move () to sSelect
85056>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
85056>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
85056>>>>>>>                Case Break
85057>>>>>>>
85057>>>>>>>            Case (sDriverID = MDSMySQL)
85060>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
85061>>>>>>>>
85061>>>>>>>//                Move () to sSelect
85061>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
85061>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
85061>>>>>>>                Case Break
85062>>>>>>>
85062>>>>>>>            Case (sDriverID = MDSPgSQL)
85065>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
85066>>>>>>>>
85066>>>>>>>//                Move () to sSelect
85066>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect 2 to sReturnArray
85066>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
85066>>>>>>>                Case Break
85067>>>>>>>
85067>>>>>>>            Case (sDriverID = ORAFLEX)
85070>>>>>>>                Error "Not implemented yet! The select statement has not been finalized."
85071>>>>>>>>
85071>>>>>>>//                Move () to sSelect
85071>>>>>>>//                Get SqlEnumerateEsqlMertech sSelect to sReturnArray
85071>>>>>>>//                Get SqlEnumerateEsqlDAW sSelect 3 to sFieldNameArray
85071>>>>>>>                Case Break
85072>>>>>>>
85072>>>>>>>            Case Else
85072>>>>>>>                Error DFERR_PROGRAM "Unsupported driver passed to the SqlUtilEnumerateRelations function."
85073>>>>>>>>
85073>>>>>>>                Case Break
85074>>>>>>>        Case End
85074>>>>>>>
85074>>>>>>>        Move (Length(sTableName)) to iLength
85075>>>>>>>        Move (iLength + 4)        to iLength // The related to field key has the format "FK_TableName + FieldName"
85076>>>>>>>        Move (SizeOfArray(sFileNameArray)) to iSize
85077>>>>>>>        Decrement iSize
85078>>>>>>>        For iCount from 0 to iSize
85084>>>>>>>>
85084>>>>>>>            If (Trim(sFileNameArray[iCount]) <> "") Begin
85086>>>>>>>                Move sFileNameArray[iCount]         to sFileName
85087>>>>>>>                Move sFieldNameArray[iCount]        to sFieldName
85088>>>>>>>                Move (Mid(sFieldName, 99, iLength)) to sFieldName
85089>>>>>>>                Move sFileName  to sRelationsArray[iCount].sFileName
85090>>>>>>>                Move sFieldName to sRelationsArray[iCount].sFieldName
85091>>>>>>>            End
85091>>>>>>>>
85091>>>>>>>        Loop
85092>>>>>>>>
85092>>>>>>>
85092>>>>>>>        Function_Return sRelationsArray
85093>>>>>>>    End_Function
85094>>>>>>>
85094>>>>>>>    Function SqlUtilEnumerateLoggedInUsers String sDriverID String sDatabase Returns tSQLLoggedInUser[]
85096>>>>>>>        tSQLLoggedInUser[] SQLLoggedInUser
85096>>>>>>>        tSQLLoggedInUser[] SQLLoggedInUser
85097>>>>>>>        String[] sUsers sPrograms
85099>>>>>>>        String sSelect
85099>>>>>>>        Integer iSize iCount
85099>>>>>>>
85099>>>>>>>        Case Begin
85099>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
85101>>>>>>>                Move ("SELECT RTRIM(SP.nt_username) AS Inlog, RTRIM(SP.program_name) as Programma from master.dbo.sysprocesses SP INNER JOIN master.dbo.sysdatabases SD ON SP.dbid = SD.dbid WHERE (SP.nt_username <> '') and (SP.nt_username <> 'SYSTEM') and (SD.name = '" ;                + sDatabase + "') ORDER by Inlog") to sSelect
85102>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 1 to sUsers
85103>>>>>>>                Get SqlEnumerateEsqlDAW sSelect 2 to sPrograms
85104>>>>>>>                Case Break
85105>>>>>>>            Case (sDriverID = SQLFLEX)
85108>>>>>>>                Move ("SELECT RTRIM(SP.nt_username) AS Inlog, RTRIM(SP.program_name) as Programma from master.dbo.sysprocesses SP INNER JOIN master.dbo.sysdatabases SD ON SP.dbid = SD.dbid WHERE (SP.nt_username <> '') and (SP.nt_username <> 'SYSTEM') and (SD.name = '" ;                + sDatabase + "') ORDER by Inlog") to sSelect
85109>>>>>>>                Get SqlEnumerateEsqlMertech sSelect 1 to sUsers
85110>>>>>>>                Get SqlEnumerateEsqlMertech sSelect 2 to sPrograms
85111>>>>>>>                Case Break
85112>>>>>>>            Case Else
85112>>>>>>>                Error DFERR_PROGRAM ("Not implemented yet for this driver (" + sDriverID + ")")
85113>>>>>>>>
85113>>>>>>>        Case End
85113>>>>>>>
85113>>>>>>>        Move (SizeOfArray(sUsers)) to iSize
85114>>>>>>>        Decrement iSize
85115>>>>>>>        For iCount from 0 to iSize
85121>>>>>>>>
85121>>>>>>>            Move sUsers[iCount]    to SQLLoggedInUser[iCount].sUser
85122>>>>>>>            Move sPrograms[iCount] to SQLLoggedInUser[iCount].sProgram
85123>>>>>>>        Loop
85124>>>>>>>>
85124>>>>>>>
85124>>>>>>>        Function_Return SQLLoggedInUser
85125>>>>>>>    End_Function
85126>>>>>>>
85126>>>>>>>    // Returns an array with all ".int" files for the passed sDataPath, _except_ for the driver .int files;
85126>>>>>>>    // "MSSQLDRV.int", "DB2_DRV.int" & "ODBC_DRV.int".
85126>>>>>>>    Function SqlUtilEnumerateIntFiles String sDataPath Returns String[]
85128>>>>>>>        String[] sFilesData
85129>>>>>>>        Boolean bExists
85129>>>>>>>        Integer iCh
85129>>>>>>>        String sFileName sExt
85129>>>>>>>
85129>>>>>>>        Get vFolderExists sDataPath to bExists
85130>>>>>>>        If (bExists = True) Begin
85132>>>>>>>            Move (ToANSI(Trim(sDataPath))) to sDataPath
85133>>>>>>>            Move ("dir:" + sDataPath)      to sDataPath
85134>>>>>>>            Get Seq_New_Channel to iCh  // get free channel for input
85135>>>>>>>            Direct_Input channel iCh sDataPath
85137>>>>>>>                Repeat
85137>>>>>>>>
85137>>>>>>>                    Readln channel iCh sFileName
85139>>>>>>>                    Get ParseFileExtension sFileName to sExt
85140>>>>>>>                    If (Uppercase(sExt) = "INT") Begin
85142>>>>>>>                        If (not(Uppercase(sFileName) contains "MSSQLDRV" and Uppercase(sFileName) contains "DB2_DRV" and Uppercase(sFileName) contains "ODBC_DRV")) Begin
85144>>>>>>>                            Move sFileName to sFilesData[SizeOfArray(sFilesData)]
85145>>>>>>>                        End
85145>>>>>>>>
85145>>>>>>>                    End
85145>>>>>>>>
85145>>>>>>>                Until (SeqEof = True)
85147>>>>>>>            Close_Input channel iCh
85149>>>>>>>            Send Seq_Release_Channel iCh
85150>>>>>>>        End
85150>>>>>>>>
85150>>>>>>>        Function_Return sFilesData
85151>>>>>>>    End_Function
85152>>>>>>>
85152>>>>>>>    // Only done for MSSQLDRV_ID so far...
85152>>>>>>>    Function SqlEnumerateDatabaseCollations String sDriverID Returns String[]
85154>>>>>>>        Boolean bMertechDriver
85154>>>>>>>        String sSQL sConnectionID sConnectionString sSelect sName sPre
85154>>>>>>>        String sDescription sFrom sSys sValue sPrevious
85154>>>>>>>        Handle hStmt hoSQLManager hoSQLConnect
85154>>>>>>>        Integer iFetchResult iRows iColumn iPos
85154>>>>>>>        tSQLConnection SQLConnection
85154>>>>>>>        tSQLConnection SQLConnection
85154>>>>>>>        String[] asCollations
85155>>>>>>>        
85155>>>>>>>        If (sDriverID = "") Begin
85157>>>>>>>            Error DFERR_PROGRAM "The database driver ID was not passed as a parameter to the 'SqlDatabaseCollationChange' function"
85158>>>>>>>>
85158>>>>>>>            Function_Return asCollations
85159>>>>>>>        End
85159>>>>>>>>
85159>>>>>>>
85159>>>>>>>        // Only done for MSSQLDRV_ID so far...
85159>>>>>>>        If (sDriverID <> MSSQLDRV_ID) Begin
85161>>>>>>>            Function_Return asCollations
85162>>>>>>>        End                 
85162>>>>>>>>
85162>>>>>>>
85162>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
85163>>>>>>>        If (bMertechDriver = False) Begin
85165>>>>>>>            Get phoSQLManager to hoSQLManager
85166>>>>>>>        End
85166>>>>>>>>
85166>>>>>>>        Else Begin
85167>>>>>>>            Get _MertechSQLManagerHandle to hoSQLManager
85168>>>>>>>        End
85168>>>>>>>>
85168>>>>>>>
85168>>>>>>>        Get psConnectionID     to sConnectionID
85169>>>>>>>        Get psConnectionString to sConnectionString
85170>>>>>>>        Move 0 to LastErr
85171>>>>>>>
85171>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
85172>>>>>>>        Get SqlConnect of hoSQLManager sDriverID sConnectionString to hoSQLConnect
85173>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
85174>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
85176>>>>>>>            Error DFERR_PROGRAM ("Login failed to the database server. The following connect string was used:\n" + sConnectionString)
85177>>>>>>>>
85177>>>>>>>            Function_Return asCollations
85178>>>>>>>        End
85178>>>>>>>>
85178>>>>>>>
85178>>>>>>>        Get SqlOpen of hoSQLConnect to hStmt
85179>>>>>>>
85179>>>>>>>        If (hStmt = 0) Begin
85181>>>>>>>            Send SqlDisconnect of hoSQLManager
85182>>>>>>>            Error DFERR_PROGRAM CS_DUF_ConnectError
85183>>>>>>>>
85183>>>>>>>            Function_Return asCollations
85184>>>>>>>        End
85184>>>>>>>>
85184>>>>>>>
85184>>>>>>>        Get _SqlFindKeyWord CI_SQLSelect      to sSelect
85185>>>>>>>        Get _SqlFindKeyWord CI_SQLName        to sName
85186>>>>>>>        Get _SqlFindKeyWord CI_SQLDescription to sDescription
85187>>>>>>>        Get _SqlFindKeyWord CI_SQLFrom        to sFrom
85188>>>>>>>        Get _SqlFindKeyWord CI_SQLSys         to sSys
85189>>>>>>>
85189>>>>>>>        // MS-SQL Syntax:  
85189>>>>>>>        // SELECT name, description
85189>>>>>>>        //   from sys.fn_helpcollations();
85189>>>>>>>        Move (sSelect  * String(sName) * String(",") * String(sDescription) * String(sFrom) * String(sSys) * String(".fn_helpcollations();")) to sSQL
85190>>>>>>>
85190>>>>>>>        Move 1 to iColumn
85191>>>>>>>        Send SqlExecDirect of hStmt sSQL
85192>>>>>>>        Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_ROWCOUNT to iRows
85193>>>>>>>        Repeat
85193>>>>>>>>
85193>>>>>>>            Get SQLFetch of hStmt to iFetchResult
85194>>>>>>>            If (iFetchResult <> 0) Begin
85196>>>>>>>                Get SQLColumnValue of hStmt iColumn to sValue 
85197>>>>>>>                If (sValue <> sPrevious) Begin         
85199>>>>>>>                    // We need to skip all collations starting with "SQL" because they
85199>>>>>>>                    // are obsolete and for pre-SQL Server 2000.
85199>>>>>>>                    Move (Pos("SQL", Uppercase(sValue))) to iPos
85200>>>>>>>                    If (iPos <> 1) Begin
85202>>>>>>>                        Move (Trim(sValue)) to asCollations[SizeOfArray(asCollations)
85203>>>>>>>                    End
85203>>>>>>>>
85203>>>>>>>                End
85203>>>>>>>>
85203>>>>>>>                Move sValue to sPrevious
85204>>>>>>>            End
85204>>>>>>>>
85204>>>>>>>        Until (iFetchResult = 0)
85206>>>>>>>        Send SQLClose of hStmt
85207>>>>>>>        Send SQLDisconnect of hoSQLConnect
85208>>>>>>>
85208>>>>>>>        Function_Return asCollations
85209>>>>>>>    End_Function
85210>>>>>>>
85210>>>>>>>    // To enumerate SQL database resources with ESQL and return the result as a string array,
85210>>>>>>>    // for DAW drivers.
85210>>>>>>>    // Returns: A string array.
85210>>>>>>>    Function SqlEnumerateEsqlDAW String sStmt Integer iColumn Returns String[]
85212>>>>>>>        String[] sReturnArray
85213>>>>>>>        String sValue sPrevious
85213>>>>>>>        Handle hoSQLHandler hoSQLConnect hstmt
85213>>>>>>>        Integer iFetchResult iRows
85213>>>>>>>        tSQLConnection SQLConnection
85213>>>>>>>        tSQLConnection SQLConnection
85213>>>>>>>
85213>>>>>>>        Get phoSQLManager to hoSQLHandler
85214>>>>>>>
85214>>>>>>>        If (hoSQLHandler <> 0) Begin
85216>>>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
85217>>>>>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
85218>>>>>>>
85218>>>>>>>            If (hoSQLConnect <> 0) Begin
85220>>>>>>>                Get SQLOpen of hoSQLConnect to hstmt
85221>>>>>>>                If (hstmt <> 0) Begin
85223>>>>>>>                    Send SqlExecDirect of hstmt sStmt
85224>>>>>>>                    Get SqlStmtAttribute of hstmt SqlSTMTATTRIB_ROWCOUNT to iRows
85225>>>>>>>                    Repeat
85225>>>>>>>>
85225>>>>>>>                        Get SQLFetch of hstmt to iFetchResult
85226>>>>>>>                        If (iFetchResult <> 0) Begin
85228>>>>>>>                            Get SQLColumnValue of hstmt iColumn to sValue
85229>>>>>>>                            If (sValue <> sPrevious) Begin
85231>>>>>>>                                Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
85232>>>>>>>                            End
85232>>>>>>>>
85232>>>>>>>                            Move sValue to sPrevious
85233>>>>>>>                        End
85233>>>>>>>>
85233>>>>>>>                    Until (iFetchResult = 0)
85235>>>>>>>                    Send SQLClose of hstmt
85236>>>>>>>                End
85236>>>>>>>>
85236>>>>>>>                Send SQLDisconnect of hoSQLConnect
85237>>>>>>>            End
85237>>>>>>>>
85237>>>>>>>        End
85237>>>>>>>>
85237>>>>>>>
85237>>>>>>>        Function_Return sReturnArray
85238>>>>>>>    End_Function
85239>>>>>>>
85239>>>>>>>    // To enumerate SQL database resources with ESQL and return the result as a string array,
85239>>>>>>>    // for Mertech drivers.
85239>>>>>>>    // Returns: A string array.
85239>>>>>>>    Function SqlEnumerateEsqlMertech String sStmt Returns String[]
85241>>>>>>>        String[] sReturnArray
85242>>>>>>>        String sValue
85242>>>>>>>        Handle hoSQLHandler hoSQLConnect hStmt
85242>>>>>>>        Integer iFetchResult iRows
85242>>>>>>>        tSQLConnection SQLConnection
85242>>>>>>>        tSQLConnection SQLConnection
85242>>>>>>>
85242>>>>>>>        Get _MertechSQLManagerHandle to hoSQLHandler
85243>>>>>>>
85243>>>>>>>        If (hoSQLHandler <> 0) Begin
85245>>>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
85246>>>>>>>            Get SQLConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to hoSQLConnect
85247>>>>>>>
85247>>>>>>>            If (hoSQLConnect <> 0) Begin
85249>>>>>>>                Get SQLOpen of hoSQLConnect to hStmt
85250>>>>>>>                If (hStmt <> 0) Begin
85252>>>>>>>                    Send SqlExecDirect of hStmt sStmt
85253>>>>>>>                    Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_ROWCOUNT to iRows
85254>>>>>>>                    Repeat
85254>>>>>>>>
85254>>>>>>>                        Get SQLFetch of hStmt to iFetchResult
85255>>>>>>>                        If (iFetchResult <> 0) Begin
85257>>>>>>>                            Get SQLColumnValue of hStmt 1 to sValue
85258>>>>>>>                            Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)
85259>>>>>>>                        End
85259>>>>>>>>
85259>>>>>>>                    Until (iFetchResult = 0)
85261>>>>>>>                    Send SQLClose of hStmt
85262>>>>>>>                End
85262>>>>>>>>
85262>>>>>>>                Send SQLDisconnect of hoSQLConnect
85263>>>>>>>            End
85263>>>>>>>>
85263>>>>>>>        End
85263>>>>>>>>
85263>>>>>>>
85263>>>>>>>        Function_Return sReturnArray
85264>>>>>>>    End_Function
85265>>>>>>>
85265>>>>>>>    // * Dummy function for the Studio's Code Explorer *
85265>>>>>>>    Function PRIVATE_SQL_SUB_FUNCTIONS Returns Boolean
85267>>>>>>>        Function_Return False
85268>>>>>>>    End_Function
85269>>>>>>>
85269>>>>>>>    // Returns the index for the passed sTableName
85269>>>>>>>    // Returns >= 0 if successful. It is e.g. needed to get the SchemaName for a table.
85269>>>>>>>    Function _SqlUtilEnumerateTableIndex String sTableName String sDriverID Returns Integer
85271>>>>>>>        Integer iIndex iSize iCount
85271>>>>>>>        String[] sTablesArray
85272>>>>>>>        String sDatabase sSchema sVal sConnectionString
85272>>>>>>>
85272>>>>>>>        Move -1 to iIndex
85273>>>>>>>        Get psConnectionString to sConnectionString
85274>>>>>>>        Get psDatabase to sDatabase
85275>>>>>>>        Get psSchema   to sSchema
85276>>>>>>>        Get SqlUtilEnumerateTables sDriverID sDatabase sSchema to sTablesArray
85277>>>>>>>        Move (SizeOfArray(sTablesArray)) to iSize
85278>>>>>>>        Decrement iSize
85279>>>>>>>        For iCount from 0 to iSize
85285>>>>>>>>
85285>>>>>>>            Move sTablesArray[iCount] to sVal
85286>>>>>>>            If (Uppercase(sVal) = Uppercase(sTableName)) Begin
85288>>>>>>>                Move iCount to iIndex // We found it!
85289>>>>>>>                Move iSize to iCount  // End the loop
85290>>>>>>>            End
85290>>>>>>>>
85290>>>>>>>        Loop
85291>>>>>>>>
85291>>>>>>>
85291>>>>>>>        Function_Return iIndex
85292>>>>>>>    End_Function
85293>>>>>>>
85293>>>>>>>    // Helper function that builds a string like;
85293>>>>>>>    // "SELECT name from [Master].[sys].[databases] where name"
85293>>>>>>>    Function _SqlSelectFromWhereName Returns String
85295>>>>>>>        String sRetval sSelect sName sFrom sMaster sSys sDatabases sWhere sDBO
85295>>>>>>>
85295>>>>>>>        Get _SqlFindKeyWord CI_SQLSelect       to sSelect
85296>>>>>>>        Get _SqlFindKeyWord CI_SQLName         to sName
85297>>>>>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBO
85298>>>>>>>        Get _SqlFindKeyWord CI_SQLFrom         to sFrom
85299>>>>>>>        Get _SqlFindKeyWord CI_SQLMaster       to sMaster
85300>>>>>>>        Get _SqlFindKeyWord CI_SQLSys          to sSys
85301>>>>>>>        Get _SqlFindKeyWord CI_SQLDatabases    to sDatabases
85302>>>>>>>        Get _SqlFindKeyWord CI_SQLWhere        to sWhere
85303>>>>>>>        Move (sSelect * sName * sFrom * "[" + sMaster + "].[" + sDBO + "].[" + sSys + sDatabases + "]" * sWhere * sName) to sRetval
85304>>>>>>>        Function_Return sRetval
85305>>>>>>>    End_Function
85306>>>>>>>
85306>>>>>>>    // Helper function to create a SQL statement like;
85306>>>>>>>    // "SELECT * FROM SYS.INDEXES WHERE NAME = MyIndexName AND OBJECT_ID = OBJECT_ID([MySchmaName].[MyTableName])"
85306>>>>>>>    // Used for checking if an index exists.
85306>>>>>>>    Function _SqlQueryIfIndexExists String sSchemaName String sTableName String sIndexName Returns String
85308>>>>>>>        String sRetval sSelect sFrom sSysIndexes sWhere sObjectID sAnd sName
85308>>>>>>>
85308>>>>>>>        Get _SqlFindKeyWord CI_SQLSelect to sSelect
85309>>>>>>>        Get _SqlFindKeyWord CI_SQLFrom to sFrom
85310>>>>>>>        Get _SqlFindKeyWord CI_SQLSysIndexes to sSysIndexes
85311>>>>>>>        Get _SqlFindKeyWord CI_SQLWhere to sWhere
85312>>>>>>>        Get _SqlFindKeyWord CI_SQLObjectID to sObjectID
85313>>>>>>>        Get _SqlFindKeyWord CI_SQLAND to sAnd
85314>>>>>>>        Get _SqlFindKeyWord CI_SQLName to sName
85315>>>>>>>
85315>>>>>>>        Move (sSelect * String("*") * sFrom * sSysIndexes * sWhere * sName * "=" * sIndexName * sAnd * sObjectID * "=([" + sSchemaName + "].[" + sTableName + "])") to sRetval
85316>>>>>>>
85316>>>>>>>        Function_Return sRetval
85317>>>>>>>    End_Function
85318>>>>>>>
85318>>>>>>>    // Formats a columns iLenght & iDecimal parameters as SQL expects them in a string.
85318>>>>>>>    // E.g. (4,2), where 4 is the iLength and 2 the iDecimals param.
85318>>>>>>>    Function _SqlFormatLengthAndDecimalAsString Integer iLength Integer iDecimals Returns String
85320>>>>>>>        String sRetval
85320>>>>>>>        If (iLength <> 0) Begin
85322>>>>>>>            Move ("(" + String(iLength)) to sRetval
85323>>>>>>>            If (iDecimals <> 0) Begin
85325>>>>>>>                Move (sRetval + "," + String(iDecimals)) to sRetval
85326>>>>>>>            End
85326>>>>>>>>
85326>>>>>>>            Move (sRetval + ")") to sRetval
85327>>>>>>>        End
85327>>>>>>>>
85327>>>>>>>        Function_Return sRetval
85328>>>>>>>    End_Function
85329>>>>>>>
85329>>>>>>>    Procedure _SqlColumnInfo Handle hoStmt
85331>>>>>>>        Integer i iCols iItem
85331>>>>>>>        tSqlColumnNew[] aQueryColumns
85331>>>>>>>        tSqlColumnNew[] aQueryColumns
85332>>>>>>>
85332>>>>>>>        Get SqlStmtAttribute of hoStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
85333>>>>>>>        For i from 1 to iCols
85339>>>>>>>>
85339>>>>>>>            Move (SizeOfArray(aQueryColumns)) to iItem
85340>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASECOLUMNNAME to aQueryColumns[iItem].sBaseColumnName
85341>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_BASETABLENAME  to aQueryColumns[iItem].sBaseTableName
85342>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_LABEL          to aQueryColumns[iItem].sLabel
85343>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SQLTYPE        to aQueryColumns[iItem].iSqlType
85344>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_DFTYPE         to aQueryColumns[iItem].iDFType
85345>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_SIZE           to aQueryColumns[iItem].iSize
85346>>>>>>>            Get SqlColAttribute of hoStmt i SqlCOLATTRIB_PRECISION      to aQueryColumns[iItem].iPrecision
85347>>>>>>>        Loop
85348>>>>>>>>
85348>>>>>>>        Set piColumns to iCols
85349>>>>>>>        Set paQueryColumns to aQueryColumns
85350>>>>>>>    End_Procedure
85351>>>>>>>
85351>>>>>>>    // Checks that the passed sDriverID is defined.
85351>>>>>>>    // Also checks if the driver has been loaded; else it gets loaded.
85351>>>>>>>    Function _SqlCheckCurrentDriver String sDriverID Returns Boolean
85353>>>>>>>        Boolean bOK
85353>>>>>>>        Integer iDriver
85353>>>>>>>
85353>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
85355>>>>>>>            Function_Return False
85356>>>>>>>        End
85356>>>>>>>>
85356>>>>>>>
85356>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
85357>>>>>>>
85357>>>>>>>        If (bOK = False) Begin
85359>>>>>>>            Get IsMertechDriver sDriverID to bOK
85360>>>>>>>        End
85360>>>>>>>>
85360>>>>>>>
85360>>>>>>>        If (bOK = False) Begin
85362>>>>>>>            Error DFERR_PROGRAM "Driver needs to be one of MSSQLDRV, DB2_DRV, ODBC_DRV, SQLFLEX, ORAFLEX, MDSPgSQL or MDSMySQL"
85363>>>>>>>>
85363>>>>>>>            Function_Return False
85364>>>>>>>        End
85364>>>>>>>>
85364>>>>>>>
85364>>>>>>>        Get DriverIndex sDriverID to iDriver
85365>>>>>>>        If (iDriver = 0) Begin
85367>>>>>>>            Load_Driver sDriverID
85368>>>>>>>        End
85368>>>>>>>>
85368>>>>>>>
85368>>>>>>>        Function_Return True
85369>>>>>>>    End_Function
85370>>>>>>>
85370>>>>>>>    // Checks that the length parameter has been passed correctly.
85370>>>>>>>    // This is only of concern for certain SQL data types.
85370>>>>>>>    Function _SqlCheckLengthParamForDataType Integer iDataType Integer iLen Returns Boolean
85372>>>>>>>        Integer iLength
85372>>>>>>>        Boolean bOK bCheckTypeLength
85372>>>>>>>
85372>>>>>>>        If (num_arguments > 1) Begin
85374>>>>>>>            Move iLen to iLength
85375>>>>>>>        End
85375>>>>>>>>
85375>>>>>>>        Move (iDataType = SQL_DECIMAL   or iDataType = SQL_NUMERIC or iDataType = SQL_FLOAT   or iDataType = SQL_INTEGER or;              iDataType = SQL_VARBINARY or iDataType = SQL_BINARY  or iDataType = SQL_VARCHAR or iDataType = SQL_CHAR or;              iDataType = SQL_BIGINT    or iDataType = SQL_REAL) to bCheckTypeLength
85376>>>>>>>
85376>>>>>>>        If (bCheckTypeLength = True) Begin
85378>>>>>>>            Move (iLength > 0) to bOK
85379>>>>>>>        End
85379>>>>>>>>
85379>>>>>>>
85379>>>>>>>        Function_Return (bOK = True)
85380>>>>>>>    End_Function
85381>>>>>>>
85381>>>>>>>    Function _SqlProperTableName String sTableName Returns String
85383>>>>>>>        String sVal sSchema sDriverID
85383>>>>>>>        Integer iDbType
85383>>>>>>>
85383>>>>>>>        If (Trim(sTableName) = "") Begin
85385>>>>>>>            Function_Return ""
85386>>>>>>>        End
85386>>>>>>>>
85386>>>>>>>
85386>>>>>>>        Get psDriverID to sDriverID
85387>>>>>>>        Get piDbType   to iDbType
85388>>>>>>>        If (iDbType = EN_dbTypeOracle) Begin
85390>>>>>>>            Get psUserID to sSchema
85391>>>>>>>            // Not sure about this uppercasing but it seems like Oracle wants that?
85391>>>>>>>            Move (Uppercase(sSchema)) to sSchema
85392>>>>>>>            Move ('"' + sSchema + '"."' + sTableName + '"') to sTableName
85393>>>>>>>            Function_Return sTableName
85394>>>>>>>        End
85394>>>>>>>>
85394>>>>>>>        If (iDbType = EN_DbTypeMySQL) Begin
85396>>>>>>>            Get psDatabase to sVal
85397>>>>>>>            Move (sVal + "." + sTableName) to sTableName
85398>>>>>>>            Function_Return sTableName
85399>>>>>>>        End
85399>>>>>>>>
85399>>>>>>>        If (iDbType = EN_DbTypePostgre) Begin
85401>>>>>>>            Move ('"' + sTableName + '"') to sTableName
85402>>>>>>>            Function_Return sTableName
85403>>>>>>>        End
85403>>>>>>>>
85403>>>>>>>
85403>>>>>>>        Get psSchema to sSchema
85404>>>>>>>        If (sSchema = "") Begin
85406>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
85407>>>>>>>        End
85407>>>>>>>>
85407>>>>>>>
85407>>>>>>>        Move (Uppercase(sTableName)) to sVal
85408>>>>>>>        If (not(sVal contains (sSchema + "."))) Begin
85410>>>>>>>            If (iDbType = EN_dbTypeDB2) Begin
85412>>>>>>>                Move (Lowercase(sSchema) + "." + sTableName) to sTableName
85413>>>>>>>            End
85413>>>>>>>>
85413>>>>>>>            Else Begin
85414>>>>>>>                Move (sSchema + "." + sTableName) to sTableName
85415>>>>>>>            End
85415>>>>>>>>
85415>>>>>>>        End
85415>>>>>>>>
85415>>>>>>>
85415>>>>>>>        Function_Return sTableName
85416>>>>>>>    End_Function
85417>>>>>>>
85417>>>>>>>    // SQL column names can be case-sensitive. This function is used to check that
85417>>>>>>>    // the passed sFieldName has the correct spelling.
85417>>>>>>>    // Used with Embedded SQL statement calls.
85417>>>>>>>    // If the spelling or fieldname doesn't exist, the return value is "" (blank).
85417>>>>>>>    Function _SqlFindColumnName String sTableName String sColumnName Returns String
85419>>>>>>>        String sRetval sValue sDriverID
85419>>>>>>>        String[] sColumnNamesArray
85420>>>>>>>        Integer iCount iColumns
85420>>>>>>>
85420>>>>>>>        Move "" to sRetval
85421>>>>>>>        Get psDriverID to sDriverID
85422>>>>>>>        Get SqlUtilEnumerateColumns sDriverID sTableName to sColumnNamesArray
85423>>>>>>>        Move (SizeOfArray(sColumnNamesArray)) to iColumns
85424>>>>>>>        Decrement iColumns
85425>>>>>>>
85425>>>>>>>        For iCount from 0 to iColumns
85431>>>>>>>>
85431>>>>>>>            Move sColumnNamesArray[iCount] to sValue
85432>>>>>>>            If (Uppercase(sColumnName) = Uppercase(sValue)) Begin
85434>>>>>>>                Move sValue to sRetval
85435>>>>>>>                Move iColumns to iCount // We're done.
85436>>>>>>>            End
85436>>>>>>>>
85436>>>>>>>        Loop
85437>>>>>>>>
85437>>>>>>>
85437>>>>>>>        Function_Return sRetval
85438>>>>>>>    End_Function
85439>>>>>>>
85439>>>>>>>    Function _SqlDatabasesArrayMSSQL Returns String[]
85441>>>>>>>        String[] sReturnArray
85442>>>>>>>        Handle hoSQLHandler
85442>>>>>>>        Integer iCount iSize iItem
85442>>>>>>>        String sServer
85442>>>>>>>        tSQLConnection SQLConnection
85442>>>>>>>        tSQLConnection SQLConnection
85442>>>>>>>
85442>>>>>>>        Get phoMSSQLHandler to hoSQLHandler
85443>>>>>>>        Send Delete_Data    of hoSQLHandler
85444>>>>>>>        Get pSQLConnection  of ghoSQLConnectionHandler to SQLConnection
85445>>>>>>>
85445>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
85446>>>>>>>        Get EnumerateDatabases of hoSQLHandler SQLConnection.sServer SQLConnection.sUserID SQLConnection.sPassword to iSize
85447>>>>>>>        Decrement iSize
85448>>>>>>>
85448>>>>>>>        For iCount from 0 to iSize
85454>>>>>>>>
85454>>>>>>>            Get String_Value of hoSQLHandler iCount to sServer
85455>>>>>>>            Move (Trim(sServer)) to sReturnArray[iItem]
85456>>>>>>>            Increment iItem
85457>>>>>>>        Loop
85458>>>>>>>>
85458>>>>>>>
85458>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
85459>>>>>>>
85459>>>>>>>        Function_Return sReturnArray
85460>>>>>>>    End_Function
85461>>>>>>>
85461>>>>>>>    Function _SqlTableArrayDAW Returns String[]
85463>>>>>>>        String[] sReturnArray
85464>>>>>>>        String sTable sTableType sSchema sDefSchema sComment sTableKeyWord sSysKeyWord sConnectionString
85464>>>>>>>        Handle hoSQLHandler
85464>>>>>>>        Integer iCount iSize iItem iPos
85464>>>>>>>        Boolean bOK
85464>>>>>>>        tSQLConnection SQLConnection
85464>>>>>>>        tSQLConnection SQLConnection
85464>>>>>>>
85464>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
85465>>>>>>>        If (SQLConnection.sConnectionString = "") Begin
85467>>>>>>>            Function_Return sReturnArray
85468>>>>>>>        End
85468>>>>>>>>
85468>>>>>>>
85468>>>>>>>        Move SQLConnection.sSchema      to sDefSchema
85469>>>>>>>        Move (Uppercase(sDefSchema))    to sDefSchema
85470>>>>>>>        Get _SqlFindKeyWord CI_SQLTable to sTableKeyWord
85471>>>>>>>        Get _SqlFindKeyWord CI_SQLSys   to sSysKeyWord
85472>>>>>>>
85472>>>>>>>        Get phoCLIHandler to hoSQLHandler
85473>>>>>>>        Set psDriverID    of hoSQLHandler to SQLConnection.sDriverID
85474>>>>>>>        Send Delete_Data  of hoSQLHandler
85475>>>>>>>
85475>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
85476>>>>>>>        Move SQLConnection.sConnectionString to sConnectionString
85477>>>>>>>        // 2020-03-14 This was not correct when testing a MS-SQL ODBC driver connection from CMOS.
85477>>>>>>>//        If (SQLConnection.sDriverID = ODBC_DRV_ID) Begin
85477>>>>>>>//            If (Uppercase(sConnectionString) contains CS_SQLIniDSNKeyword) Begin
85477>>>>>>>//                Move (Pos(";", sConnectionString)) to iPos
85477>>>>>>>//                If (iPos > 0) Begin
85477>>>>>>>//                    Move (Left(sConnectionString, (iPos - 1))) to sConnectionString
85477>>>>>>>//                    Move (Trim(sConnectionString)) to sConnectionString
85477>>>>>>>//                End
85477>>>>>>>//            End
85477>>>>>>>//        End
85477>>>>>>>
85477>>>>>>>        Get EnumerateTables of hoSQLHandler sConnectionString to iSize
85478>>>>>>>        Move False to Err
85479>>>>>>>        Move 0 to iItem
85480>>>>>>>
85480>>>>>>>        // Note that the enumeration starts from table no 1. (not zero)
85480>>>>>>>        for iCount from 1 to iSize
85486>>>>>>>>
85486>>>>>>>            Get TableName    of hoSQLHandler iCount to sTable
85487>>>>>>>            Get TableType    of hoSQLHandler iCount to sTableType
85488>>>>>>>            Get SchemaName   of hoSQLHandler iCount to sSchema
85489>>>>>>>            If (sSchema = "") Begin
85491>>>>>>>                Get _SqlFindKeyWord CI_SQLDBO to sSchema
85492>>>>>>>            End
85492>>>>>>>>
85492>>>>>>>            Get TableComment of hoSQLHandler iCount to sComment
85493>>>>>>>            Move (Trim(sTable)) to sTable
85494>>>>>>>            If (SQLConnection.sDriverID = DB2_DRV_ID) Begin
85496>>>>>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) = sDefSchema) to bOK
85497>>>>>>>            End
85497>>>>>>>>
85497>>>>>>>            Else Begin
85498>>>>>>>                Move (sTable <> "" and Uppercase(sTableType) = sTableKeyWord and Uppercase(sSchema) <> sSysKeyWord and Uppercase(sSchema) <> "SYSTOOLS") to bOK
85499>>>>>>>            End
85499>>>>>>>>
85499>>>>>>>            If (bOK = True) Begin
85501>>>>>>>                Move sTable to sReturnArray[iItem]
85502>>>>>>>                Increment iItem
85503>>>>>>>            End
85503>>>>>>>>
85503>>>>>>>        Loop
85504>>>>>>>>
85504>>>>>>>
85504>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
85505>>>>>>>
85505>>>>>>>        Function_Return sReturnArray
85506>>>>>>>    End_Function
85507>>>>>>>
85507>>>>>>>    Function _SqlProcedureArrayDAW String sStmt String sArgument Returns String[]
85509>>>>>>>        String[] sReturnArray
85510>>>>>>>        String sValue
85510>>>>>>>        Handle hoSQLHandler hoSQLConnect hStmt
85510>>>>>>>        Integer iRetval iCols iFetchResult
85510>>>>>>>        tSQLConnection SQLConnection
85510>>>>>>>        tSQLConnection SQLConnection
85510>>>>>>>
85510>>>>>>>        Get phoSQLManager to hoSQLHandler
85511>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
85512>>>>>>>        Get SqlConnect of hoSQLHandler SQLConnection.sDriverID SQLConnection.sConnectionString to hoSQLConnect
85513>>>>>>>
85513>>>>>>>        If (hoSQLConnect <> 0) Begin
85515>>>>>>>            Get SqlOpen of hoSQLConnect to hStmt
85516>>>>>>>            If (hStmt <> 0) Begin
85518>>>>>>>                Send SqlSetProcedurename of hStmt sStmt
85519>>>>>>>                If (sArgument <> "") Begin
85521>>>>>>>                    Send SqlSetArgument  of hStmt 1 sArgument
85522>>>>>>>                End
85522>>>>>>>>
85522>>>>>>>
85522>>>>>>>                Send SqlCall             of hStmt
85523>>>>>>>                Get SqlReturnValue       of hStmt to iRetval
85524>>>>>>>                If (iRetval = 0) Begin
85526>>>>>>>                    Repeat
85526>>>>>>>>
85526>>>>>>>                        Get SqlStmtAttribute of hStmt SqlSTMTATTRIB_COLUMNCOUNT to iCols
85527>>>>>>>                        If (iCols > 0) Begin
85529>>>>>>>                            Repeat
85529>>>>>>>>
85529>>>>>>>                                Get SqlFetch of hStmt to iFetchResult
85530>>>>>>>                                If (iFetchResult <> 0) Begin
85532>>>>>>>                                    Get SqlColumnValue of hStmt 1 to sValue
85533>>>>>>>                                    Move (Trim(sValue)) to sReturnArray[SizeOfArray(sReturnArray)]
85534>>>>>>>                                End
85534>>>>>>>>
85534>>>>>>>                            Until (iFetchResult = 0)
85536>>>>>>>                        End
85536>>>>>>>>
85536>>>>>>>                        Get SqlNextResultSet of hStmt to iRetval
85537>>>>>>>                    Until (iRetval = 0)
85539>>>>>>>                    Send SqlClose of hStmt
85540>>>>>>>                End
85540>>>>>>>>
85540>>>>>>>            End
85540>>>>>>>>
85540>>>>>>>            Send SqlDisconnect of hoSQLConnect
85541>>>>>>>        End
85541>>>>>>>>
85541>>>>>>>        Function_Return sReturnArray
85542>>>>>>>    End_Function
85543>>>>>>>
85543>>>>>>>    Function _SqlDatabasesArrayDB2 Returns String[]
85545>>>>>>>        String[] sReturnArray
85546>>>>>>>        String sDataSource
85546>>>>>>>        Handle hoSQLHandler
85546>>>>>>>        Integer iItem
85546>>>>>>>
85546>>>>>>>        Get phoDB2SQLHandler to hoSQLHandler
85547>>>>>>>        Send SeedDataSources of hoSQLHandler
85548>>>>>>>
85548>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
85549>>>>>>>
85549>>>>>>>        Repeat
85549>>>>>>>>
85549>>>>>>>            Get DataSources of hoSQLHandler to sDataSource
85550>>>>>>>            Move (Replaces(",", sDataSource, "")) to sDataSource
85551>>>>>>>            Move (Trim(sDataSource)) to sReturnArray[iItem]
85552>>>>>>>            Increment iItem
85553>>>>>>>        Until (sDataSource = "")
85555>>>>>>>
85555>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
85556>>>>>>>
85556>>>>>>>        Function_Return sReturnArray
85557>>>>>>>    End_Function
85558>>>>>>>
85558>>>>>>>    Function _SqlDatabaseSourcesArrayODBC Returns String[]
85560>>>>>>>        String[] sReturnArray
85561>>>>>>>        String sDataSource
85561>>>>>>>        Handle hoSQLHandler
85561>>>>>>>        Integer iItem
85561>>>>>>>
85561>>>>>>>        Get phoODBCSQLHandler to hoSQLHandler
85562>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
85563>>>>>>>
85563>>>>>>>        Send SeedDataSources of hoSQLHandler
85564>>>>>>>
85564>>>>>>>        Repeat
85564>>>>>>>>
85564>>>>>>>            Get DataSources of hoSQLHandler to sDataSource
85565>>>>>>>            If (Trim(sDataSource) <> "" and not(sDataSource contains "*.")) Begin
85567>>>>>>>                Move (Trim(sDataSource)) to sReturnArray[iItem]
85568>>>>>>>                Increment iItem
85569>>>>>>>            End
85569>>>>>>>>
85569>>>>>>>        Until (sDataSource = "")
85571>>>>>>>
85571>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
85572>>>>>>>
85572>>>>>>>        Function_Return sReturnArray
85573>>>>>>>    End_Function
85574>>>>>>>
85574>>>>>>>    Function _SqlDatabasesArrayODBC Returns tSQLIntTableInfo[]
85576>>>>>>>        String[] sDataSources
85577>>>>>>>        tSQLConnection SQLConnection
85577>>>>>>>        tSQLConnection SQLConnection
85577>>>>>>>        tSQLIntTableInfo[] sReturnArray
85577>>>>>>>        tSQLIntTableInfo[] sReturnArray
85578>>>>>>>        Integer iDataSources iCount iItem
85578>>>>>>>        String sConnection sServer sDatabase sKey sSubKey
85578>>>>>>>        Handle hoIniFile hoRegistry hoODBCDataSources
85578>>>>>>>        Boolean bExists bKeyOpened
85578>>>>>>>
85578>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
85579>>>>>>>        Move SQLConnection.sConnectionString to sConnection
85580>>>>>>>        Move SQLConnection.sServer           to sServer
85581>>>>>>>
85581>>>>>>>        // FileDSN - read DATABASE name from DSN ini-file
85581>>>>>>>        If (Uppercase(sServer) contains ("." + String(CS_SQLIniDSNKeyword))) Begin
85583>>>>>>>            Get Create (RefClass(cIniFile)) to hoIniFile
85584>>>>>>>            Set psFileName of hoIniFile to sServer
85585>>>>>>>            Get ReadString of hoIniFile CS_SQLODBCIniSectionName CS_SQLIniDatabaseKeyword "" to sDatabase
85586>>>>>>>            Move sDatabase to sReturnArray[0].sDatabaseName
85587>>>>>>>            Send Destroy of hoIniFile
85588>>>>>>>        End
85588>>>>>>>>
85588>>>>>>>
85588>>>>>>>        // DSN - read DATABASE name from the registry
85588>>>>>>>        Else Begin
85589>>>>>>>            Get Create (RefClass(cRegistry)) to hoRegistry
85590>>>>>>>
85590>>>>>>>            // We start with checking the "System DNS" area in the registry as it is the
85590>>>>>>>            // most probably place the info is kept that we're after.
85590>>>>>>>            Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
85591>>>>>>>            Set pfAccessRights of hoRegistry to Key_Read
85592>>>>>>>            Get KeyExists of hoRegistry "SOFTWARE\Wow6432Node" to bExists
85593>>>>>>>            If (bExists = True) Begin
85595>>>>>>>                Move "SOFTWARE\Wow6432Node\ODBC\ODBC.INI" to sKey
85596>>>>>>>            End
85596>>>>>>>>
85596>>>>>>>            Else Begin
85597>>>>>>>                Move "SOFTWARE\ODBC\ODBC.INI" to sKey
85598>>>>>>>            End
85598>>>>>>>>
85598>>>>>>>
85598>>>>>>>            Get KeyExists of hoRegistry sKey to bExists
85599>>>>>>>            If (bExists) Begin
85601>>>>>>>                Get OpenKey of hoRegistry sKey to bKeyOpened
85602>>>>>>>                If (bKeyOpened) Begin
85604>>>>>>>                    Get Create (RefClass(Array)) to hoODBCDataSources
85605>>>>>>>                    Get GetSubkeys of hoRegistry hoODBCDataSources to iDataSources
85606>>>>>>>                    If (iDataSources > 0) Begin
85608>>>>>>>                        Move (ResizeArray(sDataSources, iDataSources)) to sDataSources
85609>>>>>>>                        Decrement iDataSources
85610>>>>>>>                        for iCount from 0 to iDataSources
85616>>>>>>>>
85616>>>>>>>                            Get Value of hoODBCDataSources iCount to sDataSources[iCount]
85617>>>>>>>                        Loop
85618>>>>>>>>
85618>>>>>>>                        Move 0 to iItem
85619>>>>>>>                        for iCount from 0 to iDataSources
85625>>>>>>>>
85625>>>>>>>                            Move sDataSources[iCount] to sSubKey
85626>>>>>>>                            Get OpenKey of hoRegistry (sKey + "\" + String(sSubKey)) to bKeyOpened
85627>>>>>>>                            If (bKeyOpened = True) Begin
85629>>>>>>>                                Get ValueExists of hoRegistry CS_SQLIniDatabaseKeyword to bExists
85630>>>>>>>                                If (bExists = True) Begin
85632>>>>>>>                                    Move sSubKey to sReturnArray[iItem].sServerName
85633>>>>>>>                                    Get ReadString of hoRegistry CS_SQLIniDatabaseKeyword to sReturnArray[iItem].sDatabaseName
85634>>>>>>>                                    Increment iItem
85635>>>>>>>                                End
85635>>>>>>>>
85635>>>>>>>                            End
85635>>>>>>>>
85635>>>>>>>                        Loop
85636>>>>>>>>
85636>>>>>>>                    End
85636>>>>>>>>
85636>>>>>>>                    Send CloseKey of hoRegistry
85637>>>>>>>                    Send Destroy of hoODBCDataSources
85638>>>>>>>                End
85638>>>>>>>>
85638>>>>>>>            End
85638>>>>>>>>
85638>>>>>>>
85638>>>>>>>            // We then check the "User DNS" area in the registry.
85638>>>>>>>            Set phRootKey of hoRegistry to HKEY_CURRENT_USER
85639>>>>>>>            Set pfAccessRights of hoRegistry to Key_Read
85640>>>>>>>            Move "SOFTWARE\ODBC\ODBC.INI" to sKey
85641>>>>>>>            Get KeyExists of hoRegistry sKey to bExists
85642>>>>>>>
85642>>>>>>>            If (bExists) Begin
85644>>>>>>>                Get OpenKey of hoRegistry sKey to bKeyOpened
85645>>>>>>>                If (bKeyOpened) Begin
85647>>>>>>>                    Get Create (RefClass(Array)) to hoODBCDataSources
85648>>>>>>>                    Get GetSubkeys of hoRegistry hoODBCDataSources to iDataSources
85649>>>>>>>                    If (iDataSources > 0) Begin
85651>>>>>>>                        Move (ResizeArray(sDataSources, iDataSources)) to sDataSources
85652>>>>>>>                        Decrement iDataSources
85653>>>>>>>                        for iCount from 0 to iDataSources
85659>>>>>>>>
85659>>>>>>>                            Get Value of hoODBCDataSources iCount to sDataSources[iCount]
85660>>>>>>>                        Loop
85661>>>>>>>>
85661>>>>>>>                        for iCount from 0 to iDataSources
85667>>>>>>>>
85667>>>>>>>                            Move sDataSources[iCount] to sSubKey
85668>>>>>>>                            Get OpenKey of hoRegistry (sKey + "\" + String(sSubKey)) to bKeyOpened
85669>>>>>>>                            If (bKeyOpened = True) Begin
85671>>>>>>>                                Get ValueExists of hoRegistry CS_SQLIniDatabaseKeyword to bExists
85672>>>>>>>                                If (bExists = True) Begin
85674>>>>>>>                                    Move sSubKey to sReturnArray[iItem].sServerName
85675>>>>>>>                                    Get ReadString of hoRegistry CS_SQLIniDatabaseKeyword to sReturnArray[iItem].sDatabaseName
85676>>>>>>>                                    Increment iItem
85677>>>>>>>                                End
85677>>>>>>>>
85677>>>>>>>                            End
85677>>>>>>>>
85677>>>>>>>                        Loop
85678>>>>>>>>
85678>>>>>>>                    End
85678>>>>>>>>
85678>>>>>>>                    Send CloseKey of hoRegistry
85679>>>>>>>                    Send Destroy of hoODBCDataSources
85680>>>>>>>                End
85680>>>>>>>>
85680>>>>>>>            End
85680>>>>>>>>
85680>>>>>>>
85680>>>>>>>            Send Destroy of hoRegistry
85681>>>>>>>        End
85681>>>>>>>>
85681>>>>>>>
85681>>>>>>>        Function_Return sReturnArray
85682>>>>>>>    End_Function
85683>>>>>>>
85683>>>>>>>    // We might have a split Sql script where the info about which database to use is
85683>>>>>>>    // put on top of the Sql script, we then need to save it to be able to retrieve it later and
85683>>>>>>>    // insert it for scriplets to come after the first one.
85683>>>>>>>    Function _SqlFormatStatement String sStmt Returns String
85685>>>>>>>        String sUseDatabase sTmp sUseKeyWord sCreateViewKeyWord sDBOKeyWord sNoCountKeyWord sDriverID
85685>>>>>>>        Integer iStart iEnd iDbType
85685>>>>>>>        Boolean bOK
85685>>>>>>>
85685>>>>>>>        Get piDbType to iDbType
85686>>>>>>>        Get psDriverID to sDriverID
85687>>>>>>>        Get _SqlFindKeyWord CI_SQLUse          to sUseKeyWord
85688>>>>>>>        Get _SqlFindKeyWord CI_SQLSetNoCountOn to sNoCountKeyWord
85689>>>>>>>        Get _SqlFindKeyWord CI_SQLCreateView   to sCreateViewKeyWord
85690>>>>>>>        Get _SqlFindKeyWord CI_SQLDBO          to sDBOKeyWord
85691>>>>>>>        Move (Replaces(" ", sStmt, "")) to sTmp
85692>>>>>>>        If (Uppercase(sTmp) contains (sUseKeyWord +"[")) Begin
85694>>>>>>>            Move (Pos("[", (Uppercase(sTmp)))) to iStart
85695>>>>>>>            Move (Pos("]", sTmp)) to iEnd
85696>>>>>>>            Move (Mid(sTmp, (iEnd -iStart +1), iStart)) to sUseDatabase
85697>>>>>>>            Move (sUseKeyWord * sUseDatabase + " ") to sUseDatabase
85698>>>>>>>            Set Private.psUseDatabase to sUseDatabase
85699>>>>>>>        End
85699>>>>>>>>
85699>>>>>>>        Else Begin
85700>>>>>>>            Move (Uppercase(sStmt)) to sTmp
85701>>>>>>>
85701>>>>>>>            // A "Create View" statement _must_ be the very first words in a Sql statement.
85701>>>>>>>            If (not(sTmp contains sCreateViewKeyWord)) Begin
85703>>>>>>>                Get Private.psUseDatabase to sUseDatabase
85704>>>>>>>                Move (Insert(sUseDatabase, sStmt, 1)) to sStmt
85705>>>>>>>            End
85705>>>>>>>>
85705>>>>>>>
85705>>>>>>>            // This is a bit special to place here but was done so because it was easier that way.
85705>>>>>>>            // We will get an error when trying to create a view if it already exists.
85705>>>>>>>            // So to avoid such errors; we first remove it & then recreate it.
85705>>>>>>>            Else If (sTmp contains sCreateViewKeyWord) Begin
85708>>>>>>>                // Make sure we only have one space between statements/words.
85708>>>>>>>                Move (Replaces("  ", sTmp, " ")) to sTmp
85709>>>>>>>                Move (Replace(sCreateViewKeyWord, sTmp, "")) to sTmp
85710>>>>>>>                Move (Trim(sTmp)) to sTmp
85711>>>>>>>                Move (Pos(" ", sTmp)) to iEnd
85712>>>>>>>                Move (Left(sTmp, iEnd)) to sTmp
85713>>>>>>>                If ((not(sTmp contains ("[" + sDBOKeyWord + "]."))) and (not(sTmp contains (sDBOKeyWord + ".")))) Begin
85715>>>>>>>                    Move (sDBOKeyWord + "." + Trim(sTmp)) to sTmp
85716>>>>>>>                End
85716>>>>>>>>
85716>>>>>>>                Move (Trim(sTmp)) to sTmp
85717>>>>>>>                // Remove data view as it already exists!
85717>>>>>>>                Get SqlViewRemove sDriverID sTmp to bOK
85718>>>>>>>            End
85718>>>>>>>>
85718>>>>>>>        End
85718>>>>>>>>
85718>>>>>>>
85718>>>>>>>        Function_Return sStmt
85719>>>>>>>    End_Function
85720>>>>>>>
85720>>>>>>>    // Returns the proper Sql language key word(s) for the passed SQL key-word constant
85720>>>>>>>    Function _SqlFindKeyWord Integer iSQLKeywordConstant Returns String
85722>>>>>>>        String sRetval
85722>>>>>>>        Integer iDbType iIndex
85722>>>>>>>        tSQLKeyWords[] SQLKeywordArray
85722>>>>>>>        tSQLKeyWords[] SQLKeywordArray
85723>>>>>>>        tSQLKeyWords   SQLKeyWords
85723>>>>>>>        tSQLKeyWords   SQLKeyWords
85723>>>>>>>
85723>>>>>>>        // Sql back-end type. E.g. MS-SQL, MySQL, Oracle, DB2...
85723>>>>>>>        Move "" to sRetval
85724>>>>>>>        Get piDbType to iDbType
85725>>>>>>>        Move iDbType             to SQLKeyWords.iSQLDbType
85726>>>>>>>        Move iSQLKeywordConstant to SQLKeyWords.iSQLWord
85727>>>>>>>
85727>>>>>>>        Get paSQLKeywordArray to SQLKeywordArray
85728>>>>>>>        Move (SearchArray(SQLKeyWords, SQLKeywordArray, Self, RefFunc(CompareFindSQLKeyWords))) to iIndex
85729>>>>>>>        If (iIndex >= 0) Begin
85731>>>>>>>            Move SQLKeywordArray[iIndex].sSQLPhrase to sRetval
85732>>>>>>>        End
85732>>>>>>>>
85732>>>>>>>
85732>>>>>>>        Function_Return sRetval
85733>>>>>>>    End_Function
85734>>>>>>>
85734>>>>>>>    // Function will "clean/sanitize" the script by removing all comments and blank lines.
85734>>>>>>>    Function _SqlUtilSanitizeScript tSQLScriptArray SqlScriptArray Returns tSQLScriptArray[]
85736>>>>>>>        String[] sSQLScriptArray
85737>>>>>>>        String sText sLine sTmp sCommentStart sCommentEnd sDashComment
85737>>>>>>>        Integer iSize iCount
85737>>>>>>>        Boolean bCommentStart bCommentEnd bDashComment
85737>>>>>>>
85737>>>>>>>        Move False to bCommentStart
85738>>>>>>>        Move False to bCommentEnd
85739>>>>>>>        Move False to bDashComment
85740>>>>>>>        Move "/*"  to sCommentStart   // These are the standard comment start & stop tokens...
85741>>>>>>>        Move "*/"  to sCommentEnd
85742>>>>>>>        Move "--"  to sDashComment    // ...but a comment can also start with two dashes "--".
85743>>>>>>>
85743>>>>>>>        Move (SizeOfArray(SqlScriptArray.sSQLScriptArray)) to iSize
85744>>>>>>>        Decrement iSize
85745>>>>>>>        Move "" to sText
85746>>>>>>>
85746>>>>>>>        For iCount from 0 to iSize
85752>>>>>>>>
85752>>>>>>>            Move SqlScriptArray.sSQLScriptArray[iCount] to sLine
85753>>>>>>>            Move (Trim(sLine)) to sTmp
85754>>>>>>>            If (sTmp <> "") Begin
85756>>>>>>>                Move (Left(sTmp, 2) = sDashComment) to bDashComment
85757>>>>>>>                If (bCommentStart = False) Begin
85759>>>>>>>                    Move (Left(sTmp, 2) = sCommentStart) to bCommentStart
85760>>>>>>>                    If (bCommentStart = False) Begin
85762>>>>>>>                    End
85762>>>>>>>>
85762>>>>>>>                End
85762>>>>>>>>
85762>>>>>>>                Move (sTmp contains sCommentEnd) to bCommentEnd
85763>>>>>>>                If (bCommentEnd = True) Begin
85765>>>>>>>                    Move False to bCommentStart
85766>>>>>>>                End
85766>>>>>>>>
85766>>>>>>>                If (bDashComment = False and bCommentStart = False and bCommentEnd = False) Begin
85768>>>>>>>                    Move sLine to sSQLScriptArray[SizeOfArray(sSQLScriptArray)]
85769>>>>>>>                End
85769>>>>>>>>
85769>>>>>>>            End
85769>>>>>>>>
85769>>>>>>>        Loop
85770>>>>>>>>
85770>>>>>>>
85770>>>>>>>        // Update the retval struct array:
85770>>>>>>>        Move sSQLScriptArray to SqlScriptArray.sSQLScriptArray
85771>>>>>>>        Function_Return SqlScriptArray
85772>>>>>>>    End_Function
85773>>>>>>>
85773>>>>>>>
85773>>>>>>>    // *** Database API Functions: ***
85773>>>>>>>    // Instead of using Sql Scripts (ESQL), we can opt to use the DataFlex Database API's to
85773>>>>>>>    // make changes/updates to the database.
85773>>>>>>>
85773>>>>>>>    // * Dummy function for the Studio's Code Explorer *
85773>>>>>>>    Function API_TABLE_FUNCTIONS Returns Boolean
85775>>>>>>>        Function_Return False
85776>>>>>>>    End_Function
85777>>>>>>>
85777>>>>>>>    // This might not do what you think - Here's what it does:
85777>>>>>>>    // It checks that the passed hTable TableName in filelist.cfg is exactly the same as at the SQL back-end.
85777>>>>>>>    // If that is True; it creates an .int file for it and changes Filelist.cfg to point
85777>>>>>>>    // to the SQL table.
85777>>>>>>>    // Typical usage for this function is when an entry exists in the Filelist for a table and the table
85777>>>>>>>    // already exists in SQL.
85777>>>>>>>    // This is a bit fiddly as the DF_FILE_PHYSICAL_NAME attribute can only be set inside a
85777>>>>>>>    // Structure_Start ... Structure_End operation when creating a NEW table. Thus it cannot be set when
85777>>>>>>>    // restructuring an existing table.
85777>>>>>>>    Function ApiTableAttachToSql Handle hTable Boolean bUseConnID Returns Boolean
85779>>>>>>>        Boolean bExists bOpened bOK bSystemFile bMertechDriver bUseConnectionID bIsAlias
85779>>>>>>>        String sDriverID sConnectionID sConnectionString sDisplayName sRootName sLogicalName sPhysicalName sSchema
85779>>>>>>>        Handle hToTable
85779>>>>>>>
85779>>>>>>>        Move True to bUseConnectionID
85780>>>>>>>        If (num_arguments > 1) Begin
85782>>>>>>>            Move bUseConnID to bUseConnectionID
85783>>>>>>>        End
85783>>>>>>>>
85783>>>>>>>
85783>>>>>>>        Get psDriverID to sDriverID
85784>>>>>>>        // If the table doesn't exist on the SQL back-end we do nothing.
85784>>>>>>>        Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
85785>>>>>>>        If (bExists = False) Begin
85787>>>>>>>            Function_Return False
85788>>>>>>>        End
85788>>>>>>>>
85788>>>>>>>
85788>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias
85789>>>>>>>
85789>>>>>>>        Get _SqlCheckCurrentDriver sDriverID to bOK
85790>>>>>>>        If (bOK = False) Begin
85792>>>>>>>            Function_Return False
85793>>>>>>>        End
85793>>>>>>>>
85793>>>>>>>
85793>>>>>>>        // Then we need to check that the function hasn't been called before; which in case
85793>>>>>>>        // we do nothing
85793>>>>>>>        Get SQLUtilTableIsAttached sDriverID hTable to bExists
85794>>>>>>>        If (bExists = True) Begin
85796>>>>>>>            Function_Return False
85797>>>>>>>        End
85797>>>>>>>>
85797>>>>>>>
85797>>>>>>>        Get psConnectionID     to sConnectionID
85798>>>>>>>        Get psConnectionString to sConnectionString
85799>>>>>>>        If (sConnectionID = "" or sConnectionString = "") Begin
85801>>>>>>>            Error DFERR_PROGRAM ("An SQL connection has NOT been setup correctly. Could not attach table:" * String(hTable) * "to SQL")
85802>>>>>>>>
85802>>>>>>>            Function_Return False
85803>>>>>>>        End
85803>>>>>>>>
85803>>>>>>>
85803>>>>>>>        Set Private.phCurrentTable to hTable
85804>>>>>>>        Get psSchema to sSchema
85805>>>>>>>        If (sSchema = "") Begin
85807>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
85808>>>>>>>        End
85808>>>>>>>>
85808>>>>>>>
85808>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
85809>>>>>>>
85809>>>>>>>        // Mertech drivers don't use connection id's, so if the passed bUseConnectionID = True that
85809>>>>>>>        // was a programmer's error and we adjust for it here.
85809>>>>>>>        If (bMertechDriver = True) Begin
85811>>>>>>>            Move False to bUseConnectionID
85812>>>>>>>        End
85812>>>>>>>>
85812>>>>>>>
85812>>>>>>>        // If we should use a connection id we need to check it exists;
85812>>>>>>>        // else we create it before attempting creating the table
85812>>>>>>>        If (bUseConnectionID = True) Begin
85814>>>>>>>            Get AutoConnectionIDLogin to bOK
85815>>>>>>>            If (bOk = False) Begin
85817>>>>>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
85818>>>>>>>>
85818>>>>>>>                Function_Return False
85819>>>>>>>            End
85819>>>>>>>>
85819>>>>>>>        End
85819>>>>>>>>
85819>>>>>>>
85819>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
85822>>>>>>>        Get _TableNameOnly sRootName to sRootName
85823>>>>>>>        If (sRootName = "") Begin
85825>>>>>>>            Function_Return False
85826>>>>>>>        End
85826>>>>>>>>
85826>>>>>>>        Move (sRootName + ".int")                    to sPhysicalName
85827>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
85830>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
85833>>>>>>>
85833>>>>>>>        // The Studio no longer adds the schema to the DISPLAY_NAME, so commented out.
85833>>>>>>>        //
85833>>>>>>>        // We don't want to change the display name if it starts with an ampersand ("@"),
85833>>>>>>>        // because then the table should not be visible to users.
85833>>>>>>>//        Move (Pos("@", sDisplayName)) to iPos
85833>>>>>>>//        If (iPos <> 1) Begin
85833>>>>>>>//            If (sDisplayName contains ".") Begin
85833>>>>>>>//                Move (Pos(".", sDisplayName)) to iPos
85833>>>>>>>//                Move (Mid(sDisplayName, 200 ,(iPos + 1))) to sDisplayName
85833>>>>>>>//                Move (sSchema + "." + sDisplayName)       to sDisplayName
85833>>>>>>>//            End
85833>>>>>>>//            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
85833>>>>>>>//                Move (Lowercase(sSchema) + "." + sDisplayName) to sDisplayName
85833>>>>>>>//            End
85833>>>>>>>//        End
85833>>>>>>>
85833>>>>>>>        If (bIsAlias = False) Begin
85835>>>>>>>            Get OpenTableExclusive hTable to bOpened
85836>>>>>>>            If (bOpened = False) Begin
85838>>>>>>>                Error DFERR_PROGRAM ("Function ApiTableAttachToSQL - Could not open table number:" * String(hTable) * sLogicalName)
85839>>>>>>>>
85839>>>>>>>                Function_Return False
85840>>>>>>>            End
85840>>>>>>>>
85840>>>>>>>        End
85840>>>>>>>>
85840>>>>>>>
85840>>>>>>>        If (ghoProgressBar <> 0) Begin
85842>>>>>>>            Send DoAdvance of ghoProgressBar
85843>>>>>>>            Set Message_Text of ghoStatusPanel to ""
85844>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Attaching to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable) * "to SQL")
85845>>>>>>>        End
85845>>>>>>>>
85845>>>>>>>        // Note: The hToTable will get changed by the Structure_xxx command...
85845>>>>>>>        Move hTable to hToTable
85846>>>>>>>        Move False to Err
85847>>>>>>>
85847>>>>>>>        // We now create a stub .int file and after Structure_end and also change the Filelist.cfg,
85847>>>>>>>        // then we do a pseudo .int file change with the "SqlUtilUpdateIntFile" function. After that we have
85847>>>>>>>        // a proper and updated .int file.
85847>>>>>>>        Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bSystemFile
85850>>>>>>>        Get SqlUtilCreateIntFile hTable sDriverID sConnectionID True bSystemFile to bOK
85851>>>>>>>
85851>>>>>>>        If (bIsAlias = False) Begin
85853>>>>>>>            Structure_Start hToTable sDriverID
85854>>>>>>>                Set Private.phCurrentTable to hTable
85855>>>>>>>                If (bUseConnectionID = True) Begin
85857>>>>>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to (CS_DFCONNID + "=" + sConnectionID)
85860>>>>>>>                End
85860>>>>>>>>
85860>>>>>>>                Else Begin
85861>>>>>>>                    Set_Attribute DF_FILE_LOGIN     of hToTable to sConnectionString
85864>>>>>>>                End
85864>>>>>>>>
85864>>>>>>>                Set_Attribute DF_FILE_OWNER         of hToTable to (Lowercase(sSchema))
85867>>>>>>>                // For unknown reason the above sometimes triggers an error and it doesn't help to try to trap the error; so we cheat...
85867>>>>>>>                Move False to Err
85868>>>>>>>                Move 0 to LastErr
85869>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
85870>>>>>>>            Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
85872>>>>>>>            Set Action_Text of ghoStatusPanel to ""
85873>>>>>>>        End
85873>>>>>>>>
85873>>>>>>>
85873>>>>>>>        Move (not(Err)) to bOK
85874>>>>>>>        If (bOK = True) Begin
85876>>>>>>>            // The attributes set above will always trigger an error
85876>>>>>>>            // We also adjust the Filelist entries
85876>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of hTable to (sDriverID + ":" + sRootName)
85879>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
85882>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
85885>>>>>>>
85885>>>>>>>            // This updates the .int file to make it up-to-date with the SQL back-end.
85885>>>>>>>            Get SqlUtilUpdateIntFile hTable to bOK
85886>>>>>>>        End
85886>>>>>>>>
85886>>>>>>>
85886>>>>>>>        Function_Return (bOK = True)
85887>>>>>>>    End_Function
85888>>>>>>>
85888>>>>>>>    // Sample usage:
85888>>>>>>>    //    Get ApiTableChangeAttribute SysInfo.File_Number DF_FILE_IS_SYSTEM_FILE True to bOK
85888>>>>>>>    //    Get ApiTableChangeAttribute OrderHea.File_Number DF_FILE_REUSE_DELETED DF_FILE_DELETED_NOREUSE to bOK
85888>>>>>>>    Function ApiTableChangeAttribute Handle hTable Integer iAttribute Integer iValue Returns Boolean
85890>>>>>>>        Boolean bOK bIsSQLTable
85890>>>>>>>
85890>>>>>>>        Get AutoConnectionIDLogin to bOK
85891>>>>>>>        Move False to Err
85892>>>>>>>        Get OpenTableExclusive hTable to bOK
85893>>>>>>>        If (bOK = False) Begin
85895>>>>>>>            Function_Return False
85896>>>>>>>        End
85896>>>>>>>>
85896>>>>>>>
85896>>>>>>>        // ToDo: Add to all table change functions!
85896>>>>>>>            Get UtilTableIsSQL hTable to bIsSQLTable
85897>>>>>>>            If (bIsSQLTable = True) Begin
85899>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
85902>>>>>>>            End
85902>>>>>>>>
85902>>>>>>>
85902>>>>>>>        Set Private.phCurrentTable to hTable
85903>>>>>>>        Structure_Start hTable
85904>>>>>>>            Set_Attribute iAttribute of hTable to iValue
85907>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
85908>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
85910>>>>>>>
85910>>>>>>>        Set Action_Text of ghoStatusPanel to ""
85911>>>>>>>        Function_Return (Err = False)
85912>>>>>>>    End_Function
85913>>>>>>>
85913>>>>>>>    Function ApiTableMoveFileListEntry String sRootName String sLogicalName String sDisplayName Handle hFromSlot Handle hToSlot String sDriverID Returns Boolean
85915>>>>>>>        Boolean bOK
85915>>>>>>>        
85915>>>>>>>        Get ApiTableChangeFileListSlot sRootName sLogicalName sDisplayName hToSlot sDriverID to bOK
85916>>>>>>>        If (bOK = True) Begin
85918>>>>>>>            Get ApiTableChangeFileListSlot "" "" "" hFromSlot sDriverID to bOK
85919>>>>>>>        End
85919>>>>>>>>
85919>>>>>>>        
85919>>>>>>>        Function_Return (bOK = True)
85920>>>>>>>    End_Function
85921>>>>>>>    
85921>>>>>>>    // To use a filelist slot for the passed FileName, TableName & DisplayName,
85921>>>>>>>    // or to change the filelist slot names.
85921>>>>>>>    Function ApiTableChangeFileListSlot String sRootName String sLogicalName String sDisplayName Handle hTable String sDriverID Returns Boolean
85923>>>>>>>        String sFileListName
85923>>>>>>>        
85923>>>>>>>        Move False to Err
85924>>>>>>>
85924>>>>>>>        If (ghoProgressBar <> 0) Begin
85926>>>>>>>            Send DoAdvance of ghoProgressBar
85927>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Changing Filelist slot for Table:" * String(sLogicalName) * "Number:" * String(hTable))
85928>>>>>>>        End
85928>>>>>>>>
85928>>>>>>>        // If all strings are empty it means that we should remove this entry from filelist.
85928>>>>>>>        If (sRootName = "" and sLogicalName = "" and sDisplayName = "") Begin
85930>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
85933>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
85936>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
85939>>>>>>>            Function_Return (Err = False) // And we're done.
85940>>>>>>>        End
85940>>>>>>>>
85940>>>>>>>
85940>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
85942>>>>>>>//            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
85942>>>>>>>            Move (sDriverID + ":" + sRootName) to sRootName
85943>>>>>>>        End
85943>>>>>>>>
85943>>>>>>>//        Else Begin
85943>>>>>>>//            Set_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
85943>>>>>>>//        End
85943>>>>>>>//
85943>>>>>>>//        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
85943>>>>>>>//        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
85943>>>>>>>
85943>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
85946>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
85949>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
85952>>>>>>>        
85952>>>>>>>        Function_Return (Err = False)
85953>>>>>>>    End_Function
85954>>>>>>>
85954>>>>>>>    Function ApiTableChangeRecordLength Handle hTable Integer iRecordLength Returns Boolean
85956>>>>>>>        Boolean bOK
85956>>>>>>>
85956>>>>>>>        Get AutoConnectionIDLogin to bOK
85957>>>>>>>        Move False to Err
85958>>>>>>>        Get OpenTableExclusive hTable to bOK
85959>>>>>>>        If (bOK = False) Begin
85961>>>>>>>            Function_Return False
85962>>>>>>>        End
85962>>>>>>>>
85962>>>>>>>
85962>>>>>>>        Set Private.phCurrentTable to hTable
85963>>>>>>>        Structure_Start hTable
85964>>>>>>>            Set_Attribute DF_FILE_RECORD_LENGTH of hTable to iRecordLength
85967>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
85968>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
85970>>>>>>>
85970>>>>>>>        Set Action_Text of ghoStatusPanel to ""
85971>>>>>>>        Function_Return (Err = False)
85972>>>>>>>    End_Function
85973>>>>>>>
85973>>>>>>>    Function ApiTableChangeRelation Handle hTable Handle hToTable Integer iFromField Integer iToField Returns Boolean
85975>>>>>>>        Boolean bOK bIsSQLTable
85975>>>>>>>
85975>>>>>>>        Move False to Err
85976>>>>>>>        Get AutoConnectionIDLogin to bOK
85977>>>>>>>        Open hToTable
85979>>>>>>>        Get OpenTableExclusive hTable to bOK
85980>>>>>>>        If (bOK = False) Begin
85982>>>>>>>            Function_Return False
85983>>>>>>>        End
85983>>>>>>>>
85983>>>>>>>
85983>>>>>>>            Get UtilTableIsSQL hTable to bIsSQLTable
85984>>>>>>>            If (bIsSQLTable = True) Begin
85986>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
85989>>>>>>>            End
85989>>>>>>>>
85989>>>>>>>
85989>>>>>>>        Set Private.phCurrentTable to hTable
85990>>>>>>>        Structure_Start hTable
85991>>>>>>>            Set_Attribute DF_FIELD_RELATED_FILE  of hTable iFromField to hToTable
85994>>>>>>>            Set_Attribute DF_FIELD_RELATED_FIELD of hTable iFromField to iToField
85997>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
85998>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86000>>>>>>>
86000>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86001>>>>>>>        Function_Return (Err = False)
86002>>>>>>>    End_Function
86003>>>>>>>
86003>>>>>>>    Procedure ApiTableConvertAllAddException Integer hTable
86005>>>>>>>        Integer[] aTableConvertExceptions
86006>>>>>>>        Get paTableConvertExceptions to aTableConvertExceptions
86007>>>>>>>        Move hTable to aTableConvertExceptions[SizeOfArray(aTableConvertExceptions)]
86008>>>>>>>        Set paTableConvertExceptions to aTableConvertExceptions
86009>>>>>>>    End_Procedure
86010>>>>>>>
86010>>>>>>>    Procedure ApiTableDateCorrectionAddException Integer hTable
86012>>>>>>>        Integer[] aTableDateCorrectionExceptions
86013>>>>>>>        Get paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
86014>>>>>>>        Move hTable to aTableDateCorrectionExceptions[SizeOfArray(aTableDateCorrectionExceptions)]
86015>>>>>>>        Set paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
86016>>>>>>>    End_Procedure
86017>>>>>>>
86017>>>>>>>    Procedure ApiTableConvertALLToSql
86019>>>>>>>        Integer[] iTablesArray
86020>>>>>>>        Integer iSize iCount
86020>>>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
86020>>>>>>>        String sDriverID
86020>>>>>>>
86020>>>>>>>        Get psDriverID to sDriverID
86021>>>>>>>        Get pbUseConnectionID to bUseConnectionID
86022>>>>>>>        Get pbToANSI          to bToANSI
86023>>>>>>>        Get pbRecnum          to bRecnum
86024>>>>>>>        Get pbCopyData        to bCopyData
86025>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
86027>>>>>>>            Get pbContinueOnError to bContinueOnError
86028>>>>>>>        End
86028>>>>>>>>
86028>>>>>>>
86028>>>>>>>        Get _AllTablesToConvert to iTablesArray
86029>>>>>>>        Move (SizeOfArray(iTablesArray)) to iSize
86030>>>>>>>        Set pbVisible   of ghoProgressBarOverall to True
86031>>>>>>>        Set piPosition  of ghoProgressBarOverall to 0
86032>>>>>>>        Set piAdvanceBy of ghoProgressBarOverall to 1
86033>>>>>>>        Set piMaximum   of ghoProgressBarOverall to iSize
86034>>>>>>>
86034>>>>>>>        Decrement iSize
86035>>>>>>>        For iCount from 0 to iSize
86041>>>>>>>>
86041>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount
86042>>>>>>>            Get ApiTableConvertToSQL_Ex iTablesArray[iCount] sDriverID bUseConnectionID bToANSI bRecnum bCopyData to bOK
86043>>>>>>>            // Probably the right logic here is to just continue trying to convert every table even
86043>>>>>>>            // if there was an error converting one table...
86043>>>>>>>            //If (bContinueOnError = False and bOK = False) Break
86043>>>>>>>        Loop
86044>>>>>>>>
86044>>>>>>>
86044>>>>>>>    End_Procedure
86045>>>>>>>
86045>>>>>>>    Procedure ApiTableAttachALLToSql
86047>>>>>>>        Integer[] iTablesArray
86048>>>>>>>        Integer iSize iCount
86048>>>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK bContinueOnError
86048>>>>>>>        String sDriverID
86048>>>>>>>
86048>>>>>>>        Get psDriverID to sDriverID
86049>>>>>>>        Get pbUseConnectionID to bUseConnectionID
86050>>>>>>>        Get pbToANSI          to bToANSI
86051>>>>>>>        Get pbRecnum          to bRecnum
86052>>>>>>>        Get pbCopyData        to bCopyData
86053>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
86055>>>>>>>            Get pbContinueOnError to bContinueOnError
86056>>>>>>>        End
86056>>>>>>>>
86056>>>>>>>
86056>>>>>>>        Get _AllTablesToConvert to iTablesArray
86057>>>>>>>        Move (SizeOfArray(iTablesArray)) to iSize
86058>>>>>>>        Decrement iSize
86059>>>>>>>        For iCount from 0 to iSize
86065>>>>>>>>
86065>>>>>>>            Get ApiTableAttachToSQL iTablesArray[iCount] bUseConnectionID to bOK
86066>>>>>>>        Loop
86067>>>>>>>>
86067>>>>>>>
86067>>>>>>>    End_Procedure
86068>>>>>>>
86068>>>>>>>    // Subfunction to the ApiTableUpdate function (et al)
86068>>>>>>>    Function _UtilTableCheckChangeFilelistNames tAPITableNameInfo APITableNameInfoFrom Boolean bIsSQLTableTo Returns Boolean
86070>>>>>>>        Handle hTable
86070>>>>>>>        String sConnectionID
86070>>>>>>>        Boolean bTableExists bSameTableNames bANSI bOK
86070>>>>>>>
86070>>>>>>>        Get ApiTableFilelistNamesCompare True APITableNameInfoFrom to bSameTableNames
86071>>>>>>>        If (bSameTableNames = True) Begin
86073>>>>>>>            Function_Return True
86074>>>>>>>        End
86074>>>>>>>>
86074>>>>>>>
86074>>>>>>>        Move True to bOK
86075>>>>>>>        Move APITableNameInfoFrom.iTableNumber  to hTable
86076>>>>>>>        Set Private.phCurrentTable              to hTable
86077>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME         of hTable to APITableNameInfoFrom.sRootName
86080>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME      of hTable to APITableNameInfoFrom.sLogicalName
86083>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME      of hTable to APITableNameInfoFrom.sDisplayName
86086>>>>>>>
86086>>>>>>>        If (APITableNameInfoFrom.bIsSQL = True) Begin
86088>>>>>>>            Get psConnectionID to sConnectionID
86089>>>>>>>            Get UtilTableExists hTable to bTableExists
86090>>>>>>>            If (bTableExists = True) Begin
86092>>>>>>>                Get SqlUtilUpdateIntFile hTable to bOK
86093>>>>>>>            End
86093>>>>>>>>
86093>>>>>>>            Else Begin
86094>>>>>>>                Get pbToANSI to bANSI
86095>>>>>>>                Get SqlUtilCreateIntFile hTable APITableNameInfoFrom.sDriverID sConnectionID bANSI False to bOK
86096>>>>>>>            End
86096>>>>>>>>
86096>>>>>>>        End
86096>>>>>>>>
86096>>>>>>>
86096>>>>>>>        Function_Return bOK
86097>>>>>>>    End_Function
86098>>>>>>>
86098>>>>>>>    Function ApiTableConvertToSql_Ex Handle hTable String sDriverID Boolean bUseConnectionID Boolean bToAnsi Boolean bRecnum Boolean bCopyData Returns Boolean
86100>>>>>>>        Handle hToTable hoLogFile
86100>>>>>>>        Boolean bOK bExists bOpened bMertechDriver bDAWDriver bContinueOnError bIsAlias
86100>>>>>>>        String sPhysicalName sRootName sLogicalName sDisplayName sConnectionID sConnectionString
86100>>>>>>>        String sANSI_OEM sSchema sBaseTableSpace sLongTableSpace sIndexTableSpace sDatabase sGUIDName sWarning
86100>>>>>>>        tSQLConnection SQLConnection
86100>>>>>>>        tSQLConnection SQLConnection
86100>>>>>>>
86100>>>>>>>        Get UtilTableExists hTable to bExists
86101>>>>>>>        If (bExists = False) Begin
86103>>>>>>>            Set Private.phCurrentTable to hTable
86104>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end.(Or Filelist.cfg contains a driver but the table doesn't exists on the SQL back-end)"
86105>>>>>>>>
86105>>>>>>>            Function_Return False
86106>>>>>>>        End
86106>>>>>>>>
86106>>>>>>>
86106>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias
86107>>>>>>>        // If this is an Alias file there is nothing to convert to SQL.
86107>>>>>>>        // Instead we change the Filelist.cfg by adding the driver id to the rootname and create an .int file
86107>>>>>>>        If (bIsAlias = True) Begin
86109>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
86112>>>>>>>            If (sDriverID <> DATAFLEX_ID and not(sRootName contains ":")) Begin
86114>>>>>>>                Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
86117>>>>>>>                Get psConnectionID to sConnectionID
86118>>>>>>>                Get SqlUtilCreateIntFile hTable sDriverID sConnectionID True False to bOK
86119>>>>>>>            End
86119>>>>>>>>
86119>>>>>>>            Function_Return True
86120>>>>>>>        End
86120>>>>>>>>
86120>>>>>>>
86120>>>>>>>        Set Private.phCurrentTable to hTable
86121>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
86124>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
86127>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
86130>>>>>>>
86130>>>>>>>        If (ghoProgressBar <> 0) Begin
86132>>>>>>>            Send DoAdvance of ghoProgressBar
86133>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * "Number:" * String(hTable) * String(sLogicalName))
86134>>>>>>>            Set Message_Text   of ghoStatusPanel to ""
86135>>>>>>>            Set Action_Text    of ghoStatusPanel to ""
86136>>>>>>>        End
86136>>>>>>>>
86136>>>>>>>
86136>>>>>>>        // Marco Kuipers suggestion;
86136>>>>>>>        // If Filelist.cfg points to an embedded .dat table and the table already exists as
86136>>>>>>>        // an SQL table; Instead of creating the table in SQL, attach it to the existing
86136>>>>>>>        // SQL table.
86136>>>>>>>        Get UtilTableIsSQL hTable to bOK
86137>>>>>>>        If (bOK = False) Begin
86139>>>>>>>            Get SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
86140>>>>>>>            If (bExists = True) Begin
86142>>>>>>>//                Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
86142>>>>>>>//                Get SqlTableRename hTable sLogicalName sGUIDName to bOK
86142>>>>>>>                Get phoLogFile to hoLogFile
86143>>>>>>>                If (hoLogFile <> 0) Begin          
86145>>>>>>>                    Move ("WARNING! Function: ApiTableConvertToSQL_Ex. The table" * sLogicalName * "pointed to an embedded table in Filelist.cfg that already existed as an SQL table! The table was NOT converted to SQL but instead ATTACHED to the existing SQL table.") to sWarning
86146>>>>>>>//                    Move ("WARNING! Function: ApiTableConvertToSQL_Ex. The table" * sLogicalName * "pointed to an embedded table in Filelist.cfg that already existed as an SQL table! The existing SQL table was renamed to:" * String(sGUIDName) * "and then converted again.") to sWarning
86146>>>>>>>                    Send LogError sWarning False
86147>>>>>>>                End
86147>>>>>>>>
86147>>>>>>>                Else Begin
86148>>>>>>>                    Error DFERR_PROGRAM sWarning
86149>>>>>>>>
86149>>>>>>>                End                                                       
86149>>>>>>>>
86149>>>>>>>                Get ApiTableAttachToSql hTable bUseConnectionID to bOK
86150>>>>>>>                Function_Return bOK // We're done (We have attached to an existing SQL table instead of converting it.
86151>>>>>>>            End
86151>>>>>>>>
86151>>>>>>>        End
86151>>>>>>>>
86151>>>>>>>
86151>>>>>>>        // Does the rootname contain a driver?
86151>>>>>>>        If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
86153>>>>>>>            // Does the table already exist as an SQL table?
86153>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
86154>>>>>>>            // It can happen that the table is missing from Filelist.cfg but still
86154>>>>>>>            // exist on the SQL side, in case we want to search for the table by its name.
86154>>>>>>>            If (bExists = False) Begin
86156>>>>>>>                Get SqlUtilCheckIfTableNameExists sLogicalName sDriverID to bExists
86157>>>>>>>            End
86157>>>>>>>>
86157>>>>>>>            If (bExists = True) Begin
86159>>>>>>>                Set TableName_Text of ghoStatusPanel to ""
86160>>>>>>>                Function_Return False
86161>>>>>>>            End
86161>>>>>>>>
86161>>>>>>>        End
86161>>>>>>>>
86161>>>>>>>        Move (If(bToAnsi = True, CS_ANSI_Txt, CS_OEM_Txt)) to sANSI_OEM
86162>>>>>>>
86162>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWDriver
86163>>>>>>>        // Mertech drivers don't use Connection ID's; so if bUseConnectionID was
86163>>>>>>>        // passed as True, we adjust for that here.
86163>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
86164>>>>>>>        If (bMertechDriver = True and bUseConnectionID = True) Begin
86166>>>>>>>            Move False to bUseConnectionID
86167>>>>>>>        End
86167>>>>>>>>
86167>>>>>>>
86167>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
86168>>>>>>>        Move SQLConnection.sSchema           to sSchema
86169>>>>>>>        If (sSchema = "") Begin
86171>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO    to sSchema
86172>>>>>>>            Move (Lowercase(sSchema))        to sSchema
86173>>>>>>>        End
86173>>>>>>>>
86173>>>>>>>
86173>>>>>>>        If (sDriverID = ORAFLEX) Begin
86175>>>>>>>            Move SQLConnection.sUserID       to sSchema
86176>>>>>>>        End
86176>>>>>>>>
86176>>>>>>>
86176>>>>>>>        Move SQLConnection.sDatabase         to sDatabase
86177>>>>>>>        Move SQLConnection.sConnectionID     to sConnectionID
86178>>>>>>>        Move SQLConnection.sConnectionString to sConnectionString
86179>>>>>>>        If (sConnectionID = "" or sConnectionString = "") Begin
86181>>>>>>>            Error DFERR_PROGRAM ("The SQL connection info has NOT been setup. Could not convert table:" * String(hTable) * "to SQL")
86182>>>>>>>>
86182>>>>>>>            Function_Return False
86183>>>>>>>        End
86183>>>>>>>>
86183>>>>>>>
86183>>>>>>>        Get AutoConnectionIDLogin to bOK
86184>>>>>>>        Open hTable
86186>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
86189>>>>>>>        If (bOpened = False) Begin
86191>>>>>>>            Error DFERR_PROGRAM ("Could not open table number:" * String(hTable))
86192>>>>>>>>
86192>>>>>>>            Function_Return False
86193>>>>>>>        End
86193>>>>>>>>
86193>>>>>>>
86193>>>>>>>        If (ghoProgressBar <> 0) Begin
86195>>>>>>>            Send DoAdvance of ghoProgressBar
86196>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Converting to SQL - Table:" * String(sLogicalName) * "Number:" * String(hTable))
86197>>>>>>>        End
86197>>>>>>>>
86197>>>>>>>
86197>>>>>>>        Move 0 to hToTable
86198>>>>>>>        Get _TableNameOnly sRootName                 to sRootName
86199>>>>>>>        Move (sRootName + ".int")                    to sPhysicalName
86200>>>>>>>
86200>>>>>>>        Case Begin
86200>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
86202>>>>>>>                Case Break
86203>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
86206>>>>>>>                Case Break
86207>>>>>>>            Case (sDriverID = DB2_DRV_ID)
86210>>>>>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
86211>>>>>>>                Move SQLConnection.sLongTableSpace  to sLongTableSpace
86212>>>>>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
86213>>>>>>>                Case Break
86214>>>>>>>            Case (sDriverID = ORAFLEX)
86217>>>>>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
86218>>>>>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
86219>>>>>>>                Case Break
86220>>>>>>>            Case (sDriverID = MDSMySQL)
86223>>>>>>>                Case Break
86224>>>>>>>            Case (sDriverID = MDSPgSQL)
86227>>>>>>>                Move SQLConnection.sBaseTableSpace  to sBaseTableSpace
86228>>>>>>>                Move SQLConnection.sIndexTableSpace to sIndexTableSpace
86229>>>>>>>                Case Break
86230>>>>>>>            Case (sDriverID = DATAFLEX_ID)
86233>>>>>>>                Case Break
86234>>>>>>>            Case Else
86234>>>>>>>                Error DFERR_PROGRAM "Wrong database driver passed to the 'ApiTableConvertToSQL_Ex' function."
86235>>>>>>>>
86235>>>>>>>                Case Break
86236>>>>>>>        Case End
86236>>>>>>>
86236>>>>>>>        Move False to Err
86237>>>>>>>
86237>>>>>>>        If (bMertechDriver = True) Begin
86239>>>>>>>            // Note: This function also sets the Err flag.
86239>>>>>>>            Get _MertechApiTableConvertToSQL hTable sRootName sDatabase sDriverID sBaseTableSpace sIndexTableSpace bToAnsi bCopyData to bOK
86240>>>>>>>        End
86240>>>>>>>>
86240>>>>>>>
86240>>>>>>>        If (bMertechDriver = False) Begin
86242>>>>>>>            Structure_Start hToTable sDriverID
86243>>>>>>>                Structure_Copy hTable to hToTable
86244>>>>>>>                Set_Attribute DF_FILE_PHYSICAL_NAME of hToTable to sPhysicalName
86247>>>>>>>
86247>>>>>>>                If (sDriverID <> DATAFLEX_ID) Begin
86249>>>>>>>                    If (bUseConnectionID = True) Begin
86251>>>>>>>                        Set_Attribute DF_FILE_LOGIN of hToTable to (CS_DFCONNID + "=" + sConnectionID)
86254>>>>>>>                    End
86254>>>>>>>>
86254>>>>>>>                    Else Begin
86255>>>>>>>                        Set_Attribute DF_FILE_LOGIN of hToTable to sConnectionString
86258>>>>>>>                    End
86258>>>>>>>>
86258>>>>>>>
86258>>>>>>>                    Set_Attribute DF_FILE_RECNUM_TABLE of hToTable to bRecnum
86261>>>>>>>
86261>>>>>>>                    If (sSchema <> "") Begin
86263>>>>>>>                        Set_Attribute DF_FILE_OWNER of hToTable to sSchema
86266>>>>>>>                    End
86266>>>>>>>>
86266>>>>>>>
86266>>>>>>>                    If (sDriverID = DB2_DRV_ID) Begin
86268>>>>>>>                        If (sLongTableSpace <> "") Begin
86270>>>>>>>                            Set_Attribute DF_FILE_LONG_TABLESPACE  of hToTable to sLongTableSpace
86273>>>>>>>                        End
86273>>>>>>>>
86273>>>>>>>                        If (sBaseTableSpace <> "") Begin
86275>>>>>>>                            Set_Attribute DF_FILE_TABLE_TABLESPACE of hToTable to sBaseTableSpace
86278>>>>>>>                        End
86278>>>>>>>>
86278>>>>>>>                        If (sIndexTableSpace <> "") Begin
86280>>>>>>>                            Set_Attribute DF_FILE_INDEX_TABLESPACE of hToTable to sIndexTableSpace
86283>>>>>>>                        End
86283>>>>>>>>
86283>>>>>>>                    End
86283>>>>>>>>
86283>>>>>>>                End
86283>>>>>>>>
86283>>>>>>>
86283>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
86284>>>>>>>            Structure_End hToTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86286>>>>>>>            Set Action_Text of ghoStatusPanel to ""
86287>>>>>>>        End
86287>>>>>>>>
86287>>>>>>>
86287>>>>>>>        Move (not(Err)) to bOK
86288>>>>>>>
86288>>>>>>>        If (bOK = True and bCopyData = True) Begin
86290>>>>>>>            If (bMertechDriver = False) Begin
86292>>>>>>>                Get ApiTableCopyData hTable sPhysicalName sRootName sDriverID to bOK
86293>>>>>>>            End
86293>>>>>>>>
86293>>>>>>>            Else Begin
86294>>>>>>>                Get _MertechCopyDataToSQL hTable sRootName sDriverID to bOK
86295>>>>>>>            End
86295>>>>>>>>
86295>>>>>>>
86295>>>>>>>            If (ghoDbUpdateHandler > 0) Begin
86297>>>>>>>                Get pbContinueOnError to bContinueOnError
86298>>>>>>>            End
86298>>>>>>>>
86298>>>>>>>            // If the data copy failed we will keep the newly created SQL table but
86298>>>>>>>            // rename it by adding a GUID to the end of the table name
86298>>>>>>>            // - or as much as "fit" because different SQL back-ends have
86298>>>>>>>            // different rules how long a table name can be.
86298>>>>>>>            // The new table will probably contain data but something went
86298>>>>>>>            // wrong while converting the data from embedded to SQL.
86298>>>>>>>            If (bOK = False and bContinueOnError = False) Begin
86300>>>>>>>                Get SQLUtilGUIDTempTableName sLogicalName to sGUIDName
86301>>>>>>>                Get SqlTableRename hTable sLogicalName sGUIDName to bOK
86302>>>>>>>                Error DFERR_PROGRAM ("Copying of" * sLogicalName * " data failed due to bad data. Either duplicate records and/or bad e.g Date/DateTime data. The SQL table was renamed to:" * String(sGUIDName) * "and its Filelist.cfg entry was NOT changed.")
86303>>>>>>>>
86303>>>>>>>            End
86303>>>>>>>>
86303>>>>>>>        End
86303>>>>>>>>
86303>>>>>>>
86303>>>>>>>        // This must be after copying data...
86303>>>>>>>        If (Err = False) Begin
86305>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME of hTable to (sDriverID + ":" + sRootName)
86308>>>>>>>            // It seems the Studio does not do this any more, so commented out.
86308>>>>>>>            // We also adjust the display name by prefixing it by the schema name;
86308>>>>>>>            //            If (not(Lowercase(sDisplayName) contains Lowercase(sSchema + "."))) Begin
86308>>>>>>>            //                // The max length for the display_name is 31 characters...
86308>>>>>>>            //                If (Length(sSchema + "." + sDisplayName) < 31) Begin
86308>>>>>>>            //                    Set_Attribute DF_FILE_DISPLAY_NAME of hTable to (Lowercase(sSchema) + "." + sDisplayName)
86308>>>>>>>            //                End
86308>>>>>>>            //            End
86308>>>>>>>        End
86308>>>>>>>>
86308>>>>>>>
86308>>>>>>>        Close hTable
86309>>>>>>>        Move (not(Err)) to bOK
86310>>>>>>>        Function_Return bOK
86311>>>>>>>    End_Function
86312>>>>>>>
86312>>>>>>>    // Calls a driver function directly to copy data from one table to another (table structures needs to be the same).
86312>>>>>>>    // It will first drop all indicies, copy the data and then recreate indicies.
86312>>>>>>>    // An error log file with the sRootname + ".err" will be created in the Data folder.
86312>>>>>>>    Function ApiTableCopyData Integer hFromTable String sPhysicalName String sRootName String sDriverID Returns Boolean
86314>>>>>>>        Boolean bOpened bOK
86314>>>>>>>        Integer hToTable iIndex iRetval iVoid iOrgFreq
86314>>>>>>>        String sErrorFile sEmpty sPath
86314>>>>>>>
86314>>>>>>>        Get_Attribute DF_FILE_NEXT_EMPTY of 0 to hToTable
86317>>>>>>>        Get AutoConnectionIDLogin to bOK
86318>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
86320>>>>>>>            Send IncreaseSortBufferSize
86321>>>>>>>//            Send SetAllIndexesToBatch hToTable
86321>>>>>>>        End
86321>>>>>>>>
86321>>>>>>>
86321>>>>>>>        Move False to Err
86322>>>>>>>        Open sPhysicalName as hToTable
86324>>>>>>>        Get_Attribute DF_FILE_OPENED of hToTable to bOpened
86327>>>>>>>        If (bOpened = False) Begin
86329>>>>>>>            Function_Return False
86330>>>>>>>        End
86330>>>>>>>>
86330>>>>>>>
86330>>>>>>>        If (ghoStatusPanel <> 0) Begin
86332>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Copying Data for Table:" * sRootName * "Number:" * String(hFromTable))
86333>>>>>>>            Set piMinimum of ghoProgressBar to 0
86334>>>>>>>            Set piMaximum of ghoProgressBar to 100 // 100%
86335>>>>>>>        End
86335>>>>>>>>
86335>>>>>>>
86335>>>>>>>        Move "" to sEmpty
86336>>>>>>>        Move False to Err
86337>>>>>>>        Move True to bOK
86338>>>>>>>        Set Private.phCurrentTable to hToTable
86339>>>>>>>
86339>>>>>>>        // No need to get the record identifier
86339>>>>>>>        Set_Attribute DF_FILE_GET_RID_AFTER_CREATE of hToTable to False
86342>>>>>>>        Get_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
86345>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
86347>>>>>>>            // Remove all indices to speed up copying of data:
86347>>>>>>>            Call_Driver hToTable sDriverID Function CLI_DROPINDICES Callback ghoDbUpdateHandler Passing sEmpty sEmpty iVoid Result iRetval
86352>>>>>>>            If (iRetval <> 0) Begin       
86354>>>>>>>                Error DFERR_PROGRAM ("Failed dropping indices for table Number:" * String(hToTable) * "Name:" * String(sRootName))
86355>>>>>>>>
86355>>>>>>>                Close hToTable
86356>>>>>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
86359>>>>>>>                Function_Return False
86360>>>>>>>            End
86360>>>>>>>>
86360>>>>>>>        End
86360>>>>>>>>
86360>>>>>>>
86360>>>>>>>        Move (sRootName + ".err") to sErrorFile
86361>>>>>>>        Move 0 to iIndex
86362>>>>>>>        Move False to Err
86363>>>>>>>
86363>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
86365>>>>>>>            Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to 10
86368>>>>>>>            Call_Driver hToTable sDriverID Function CLI_BCP CallBack ghoDbUpdateHandler Passing iIndex sEmpty hFromTable Result iRetval
86373>>>>>>>            If (iRetval <> 0) Begin
86375>>>>>>>                Error DFERR_PROGRAM ("Failed copying data for table Number:" * String(hToTable) * "Name:" * String(sRootName))
86376>>>>>>>>
86376>>>>>>>                Close hToTable
86377>>>>>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
86380>>>>>>>                Function_Return False
86381>>>>>>>            End
86381>>>>>>>>
86381>>>>>>>        End
86381>>>>>>>>
86381>>>>>>>        Else Begin
86382>>>>>>>            Copy_Records hFromTable to hToTable using 0 Callback ghoDbUpdateHandler
86385>>>>>>>        End
86385>>>>>>>>
86385>>>>>>>
86385>>>>>>>        If (Err = False) Begin
86387>>>>>>>            Get psHome of (phoWorkspace(ghoApplication)) to sPath
86388>>>>>>>            Get vDeleteFile (sPath + sErrorFile) to iRetval
86389>>>>>>>        End
86389>>>>>>>>
86389>>>>>>>
86389>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
86391>>>>>>>            // Recreate indices:
86391>>>>>>>            Call_Driver hToTable sDriverID Function CLI_CREATEINDICES Callback ghoDbUpdateHandler Passing sEmpty sEmpty iVoid Result iRetval
86396>>>>>>>            If (iRetval <> 0) Begin
86398>>>>>>>                Error DFERR_PROGRAM ("Failed creating indices for table Number:" * String(hToTable) * "Name:" * String(sRootName))
86399>>>>>>>>
86399>>>>>>>                Close hToTable
86400>>>>>>>                Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
86403>>>>>>>                Function_Return False
86404>>>>>>>            End
86404>>>>>>>>
86404>>>>>>>        End
86404>>>>>>>>
86404>>>>>>>
86404>>>>>>>        Close hToTable
86405>>>>>>>        Set_Attribute DF_RUNTIME_PROGRESS_FREQUENCY to iOrgFreq
86408>>>>>>>
86408>>>>>>>        If (bOK = True) Begin
86410>>>>>>>            Move (not(Err)) to bOK
86411>>>>>>>        End
86411>>>>>>>>
86411>>>>>>>
86411>>>>>>>        If (ghoStatusPanel <> 0) Begin
86413>>>>>>>            Set TableName_Text of ghoStatusPanel to ""
86414>>>>>>>            Set Message_Text   of ghoStatusPanel to ""
86415>>>>>>>            Set Action_Text    of ghoStatusPanel to ""
86416>>>>>>>        End
86416>>>>>>>>
86416>>>>>>>
86416>>>>>>>        Function_Return (bOK = True)
86417>>>>>>>    End_Function
86418>>>>>>>
86418>>>>>>>    // The bANSI parameter's default value = True, meaning a table in ANSI format will be created.
86418>>>>>>>    // i.e. DF_FILE_TABLE_CHARACTER_FORMAT {"OEM"|"ANSI"}
86418>>>>>>>    Function ApiTableCreate Handle hTable String sRootName String sDisplayName String sLogicalName Boolean bUseConnectionID Boolean bANSI Boolean bRecnum tAPIColumn[] aColumnIn Returns Boolean
86420>>>>>>>        Handle hFile
86420>>>>>>>        String sConnectionID sPhysicalFile sANSI_OEM sVal sSchema sOriginalDriverID sDriverID sTableName
86420>>>>>>>        Integer iIdentityType iDataType iDbType iCount iSize
86420>>>>>>>        Boolean bOk bExists bSqlDriver bMertechDriver bDeleteDummy bExistsInFilelist bSysFile
86420>>>>>>>        tSQLConnection SQLConnection
86420>>>>>>>        tSQLConnection SQLConnection
86420>>>>>>>        tAPIColumn[] aColumns
86420>>>>>>>        tAPIColumn[] aColumns
86421>>>>>>>        tColumnType ColumnType
86421>>>>>>>        tColumnType ColumnType
86421>>>>>>>
86421>>>>>>>        // First check if the passed filenumber already exists; in case we do nothing
86421>>>>>>>        Get UtilTableExists hTable to bOk
86422>>>>>>>        If (bOk = True) Begin
86424>>>>>>>            Function_Return False
86425>>>>>>>        End
86425>>>>>>>>
86425>>>>>>>
86425>>>>>>>        Set Private.phCurrentTable to hTable
86426>>>>>>>        Move sLogicalName to sTableName
86427>>>>>>>        If (ghoProgressBar <> 0) Begin
86429>>>>>>>            Send DoAdvance of ghoProgressBar
86430>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Creating Table:" * String(sTableName) * "Number:" * String(hTable) * String(sLogicalName))
86431>>>>>>>        End
86431>>>>>>>>
86431>>>>>>>
86431>>>>>>>        Get UtilTableLogicalNameIsInUse sTableName to bExistsInFilelist
86432>>>>>>>        Get psDriverID to sDriverID
86433>>>>>>>        Get IsSQLDriver sDriverID to bSqlDriver
86434>>>>>>>        Get piDbType to iDbType
86435>>>>>>>
86435>>>>>>>        // If no columns passed in, we need to create a "dummy" column
86435>>>>>>>        Move False to bDeleteDummy
86436>>>>>>>        If (Num_Arguments = 8) Begin
86438>>>>>>>            Move aColumnIn to aColumns
86439>>>>>>>        End
86439>>>>>>>>
86439>>>>>>>        If ((SizeOfArray(aColumns)) = 0) Begin
86441>>>>>>>            Get UtilDFDataTypeToSqlTypeMapping sDriverID iDbType DF_BCD to ColumnType
86442>>>>>>>            Move ColumnType.iSQLType to iDataType
86443>>>>>>>            If (bRecnum = False) Begin
86445>>>>>>>                Move C_tAPIColumn_Identity to iIdentityType
86446>>>>>>>            End
86446>>>>>>>>
86446>>>>>>>            Else Begin
86447>>>>>>>                Move C_tAPIColumn_None     to iIdentityType
86448>>>>>>>            End
86448>>>>>>>>
86448>>>>>>>            Get _AppendAPIColumn aColumns "temp" iDataType 10 0 iIdentityType to aColumns
86449>>>>>>>            Move True to bDeleteDummy
86450>>>>>>>        End
86450>>>>>>>>
86450>>>>>>>
86450>>>>>>>        // If columns have been passed as an array we need to check if an identity column
86450>>>>>>>        // has been specified (aColumns[iCounter].iOptions = C_tAPIColumn_Identity), and
86450>>>>>>>        // if so auto-set the bRecnum to FALSE. This is because else there would be
86450>>>>>>>        // two identity columns and SQL doesn't like that and throws an error.
86450>>>>>>>        If (bRecnum = True and (SizeOfArray(aColumns)) <> 0) Begin
86452>>>>>>>            Move (SizeOfArray(aColumns)) to iSize
86453>>>>>>>            Decrement iSize
86454>>>>>>>            for iCount from 0 to iSize
86460>>>>>>>>
86460>>>>>>>                If (aColumns[iCount].iOptions = C_tAPIColumn_Identity) Begin
86462>>>>>>>                    Move False to bRecnum
86463>>>>>>>                    Move iSize to iCount
86464>>>>>>>                End
86464>>>>>>>>
86464>>>>>>>            Loop
86465>>>>>>>>
86465>>>>>>>        End
86465>>>>>>>>
86465>>>>>>>
86465>>>>>>>        // If this is a SQL based driver we also check if the table exists
86465>>>>>>>        // in the SQL back end; in case we do nothing.
86465>>>>>>>        If (bSqlDriver = True) Begin
86467>>>>>>>            // Get all connection properties
86467>>>>>>>            Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
86468>>>>>>>            Move SQLConnection.sSchema to sSchema
86469>>>>>>>            If (sSchema = "") Begin
86471>>>>>>>                Get _SqlFindKeyWord CI_SQLDBO to sSchema
86472>>>>>>>            End
86472>>>>>>>>
86472>>>>>>>
86472>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverID to bExists
86473>>>>>>>            // It can happen that the table is missing from Filelist.cfg but still
86473>>>>>>>            // exist on the SQL side, in case we want to search for the table by its name.
86473>>>>>>>            If (bExists = False) Begin
86475>>>>>>>                Get SqlUtilCheckIfTableNameExists sTableName sDriverID to bExists
86476>>>>>>>            End
86476>>>>>>>>
86476>>>>>>>            // If the table exists on the SQL back-end but not in Filelist.cfg,
86476>>>>>>>            // we will just add it to Filelist.cfg
86476>>>>>>>            If (bExists = True) Begin
86478>>>>>>>                If (bExistsInFilelist = False) Begin
86480>>>>>>>                    If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
86482>>>>>>>                        Move (sDriverID + ":" + sRootName) to sRootName
86483>>>>>>>                    End
86483>>>>>>>>
86483>>>>>>>                    Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
86486>>>>>>>                    Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
86489>>>>>>>                    Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
86492>>>>>>>                    Move False to bSysFile
86493>>>>>>>                    Get SqlUtilCreateIntFile hTable sDriverID SQLConnection.sConnectionID bANSI bSysFile to bOK
86494>>>>>>>                End
86494>>>>>>>>
86494>>>>>>>                Function_Return False
86495>>>>>>>            End
86495>>>>>>>>
86495>>>>>>>        End
86495>>>>>>>>
86495>>>>>>>
86495>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
86496>>>>>>>        If (num_arguments > 6) Begin
86498>>>>>>>            If (bANSI = False) Begin
86500>>>>>>>                Move CS_OEM_Txt to sANSI_OEM
86501>>>>>>>            End
86501>>>>>>>>
86501>>>>>>>        End
86501>>>>>>>>
86501>>>>>>>
86501>>>>>>>        // Mertech drivers don't use connection id's, so if the passed bUseConnectionID = True that
86501>>>>>>>        // is a programmer's error and we auto-correct for it here.
86501>>>>>>>        // This is also a bit messy. If a Mertech driver is used and we want to create a new table,
86501>>>>>>>        // we first need to create it as embedded (DataFlex) and then convert it to SQL (!)
86501>>>>>>>        // So we set the driver ID temporarily to "DataFlex" to get the table created as embedded and later
86501>>>>>>>        // set it back and use a Mertech function to convert it to SQL.
86501>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
86502>>>>>>>        If (bMertechDriver = True) Begin
86504>>>>>>>            If (bUseConnectionID = True) Begin
86506>>>>>>>                Move False to bUseConnectionID
86507>>>>>>>            End
86507>>>>>>>>
86507>>>>>>>            Move sDriverID to sOriginalDriverID
86508>>>>>>>            Move DATAFLEX_ID to sDriverID
86509>>>>>>>        End
86509>>>>>>>>
86509>>>>>>>
86509>>>>>>>        Move False to Err
86510>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
86512>>>>>>>            Move sRootName to sPhysicalFile
86513>>>>>>>        End
86513>>>>>>>>
86513>>>>>>>
86513>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
86515>>>>>>>            Move SQLConnection.sConnectionID to sConnectionID
86516>>>>>>>
86516>>>>>>>            // If DAW driver and we should use a connection id we need to
86516>>>>>>>            // check if the connection ID exists; else we create it before attempting creating the table
86516>>>>>>>            If (bMertechDriver = False and bUseConnectionID = True) Begin
86518>>>>>>>                Get IsConnectionID sConnectionID sDriverID to bExists
86519>>>>>>>                If (bExists = False) Begin
86521>>>>>>>                    Get AutoSetConnectionID sConnectionID to bOk
86522>>>>>>>                    If (bOk = False) Begin
86524>>>>>>>                        Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be created.")
86525>>>>>>>>
86525>>>>>>>                        Function_Return False
86526>>>>>>>                    End
86526>>>>>>>>
86526>>>>>>>                End
86526>>>>>>>>
86526>>>>>>>            End
86526>>>>>>>>
86526>>>>>>>
86526>>>>>>>            If (sDriverID <> DATAFLEX_ID and (Uppercase(sRootName) contains sDriverID)) Begin
86528>>>>>>>                Move (sTableName + ".int") to sPhysicalFile
86529>>>>>>>            End
86529>>>>>>>>
86529>>>>>>>            Else Begin
86530>>>>>>>                Move (sRootName + ".int") to sPhysicalFile
86531>>>>>>>            End
86531>>>>>>>>
86531>>>>>>>            Move (Uppercase(sDisplayName)) to sVal
86532>>>>>>>//            If (not(sVal contains (sSchema + "."))) Begin
86532>>>>>>>//                Move (Lowercase(sSchema) + "." + sTableName) to sDisplayName
86532>>>>>>>//            End
86532>>>>>>>        End
86532>>>>>>>>
86532>>>>>>>        Move False to Err
86533>>>>>>>        Move 0 to hFile
86534>>>>>>>
86534>>>>>>>        Structure_Start hFile sDriverID
86535>>>>>>>            If (sDriverID <> DATAFLEX_ID) Begin
86537>>>>>>>                If (bUseConnectionID = True) Begin
86539>>>>>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to (CS_DFCONNID + "=" + sConnectionID)
86542>>>>>>>                End
86542>>>>>>>>
86542>>>>>>>                Else Begin
86543>>>>>>>                    Set_Attribute DF_FILE_LOGIN                of hFile to SQLConnection.sConnectionString
86546>>>>>>>                End
86546>>>>>>>>
86546>>>>>>>                Set_Attribute DF_FILE_TABLE_NAME               of hFile to sTableName
86549>>>>>>>                Set_Attribute DF_FILE_USE_DUMMY_ZERO_DATE      of hFile to True
86552>>>>>>>                Set_Attribute DF_FILE_TABLE_CHARACTER_FORMAT   of hFile to sANSI_OEM
86555>>>>>>>                Set_Attribute DF_FILE_RECNUM_TABLE             of hFile to bRecnum
86558>>>>>>>
86558>>>>>>>                If (sSchema <> "") Begin
86560>>>>>>>                    Set_Attribute DF_FILE_OWNER                of hFile to sSchema
86563>>>>>>>                End
86563>>>>>>>>
86563>>>>>>>
86563>>>>>>>                If (sDriverID = DB2_DRV_ID) Begin
86565>>>>>>>                    If (SQLConnection.sLongTableSpace <> "") Begin
86567>>>>>>>                        Set_Attribute DF_FILE_LONG_TABLESPACE  of hFile to SQLConnection.sLongTableSpace
86570>>>>>>>                    End
86570>>>>>>>>
86570>>>>>>>                End
86570>>>>>>>>
86570>>>>>>>                If (sDriverID = DB2_DRV_ID or sDriverID = ORAFLEX or sDriverID = MDSPgSQL) Begin
86572>>>>>>>                    If (SQLConnection.sBaseTableSpace <> "") Begin
86574>>>>>>>                        Set_Attribute DF_FILE_TABLE_TABLESPACE of hFile to SQLConnection.sBaseTableSpace
86577>>>>>>>                    End
86577>>>>>>>>
86577>>>>>>>                    If (SQLConnection.sIndexTableSpace <> "") Begin
86579>>>>>>>                        Set_Attribute DF_FILE_INDEX_TABLESPACE of hFile to SQLConnection.sIndexTableSpace
86582>>>>>>>                    End
86582>>>>>>>>
86582>>>>>>>                End
86582>>>>>>>>
86582>>>>>>>            End
86582>>>>>>>>
86582>>>>>>>
86582>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hFile to sPhysicalFile
86585>>>>>>>            Get ApiColumnsAddToTable hFile aColumns True to bOk
86586>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86587>>>>>>>        Structure_End hFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86589>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86590>>>>>>>
86590>>>>>>>        // If Mertech driver we convert the newly created embedded table (DataFlex) to SQL
86590>>>>>>>        If (bMertechDriver = True) Begin
86592>>>>>>>            Move sOriginalDriverID to sDriverID
86593>>>>>>>            If (not(sVal contains (sSchema + "."))) Begin
86595>>>>>>>                Move (Lowercase(sSchema) + "." + sTableName) to sDisplayName
86596>>>>>>>            End
86596>>>>>>>>
86596>>>>>>>            // Note: This function also sets the Err flag.
86596>>>>>>>            //Get _MertechApiTableConvertToSQL hTable sRootName SQLConnection.sDatabase sDriverID SQLConnection.sBaseTableSpace SQLConnection.sIndexTableSpace False to bOK
86596>>>>>>>        End
86596>>>>>>>>
86596>>>>>>>
86596>>>>>>>        Move (not(Err)) to bOK
86597>>>>>>>        If (bOk = True) Begin
86599>>>>>>>            If (sDriverID <> DATAFLEX_ID and not(Uppercase(sRootName) contains sDriverID)) Begin
86601>>>>>>>                Move (sDriverID + ":" + sRootName) to sRootName
86602>>>>>>>            End
86602>>>>>>>>
86602>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
86605>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
86608>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
86611>>>>>>>
86611>>>>>>>            // Lastly we remove the temporary column we created above, if all went well.
86611>>>>>>>            If (bDeleteDummy) Begin
86613>>>>>>>                Get ApiColumnRemove hTable "temp" to bOk
86614>>>>>>>            End
86614>>>>>>>>
86614>>>>>>>        End
86614>>>>>>>>
86614>>>>>>>
86614>>>>>>>        Set TableName_Text of ghoStatusPanel to ""
86615>>>>>>>        Close hTable
86616>>>>>>>        Function_Return (bOK = True)
86617>>>>>>>    End_Function
86618>>>>>>>
86618>>>>>>>    Function ApiTableCreateAlias String sFileName String sDisplayName String sAliasName Integer iFilelistSlot Returns Boolean
86620>>>>>>>        Move False to Err
86621>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of iFilelistSlot to sFileName
86624>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of iFilelistSlot to sDisplayName
86627>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of iFilelistSlot to sAliasName
86630>>>>>>>
86630>>>>>>>        Function_Return (Err = False)
86631>>>>>>>    End_Function
86632>>>>>>>
86632>>>>>>>    // ToDo: Needs to be revised
86632>>>>>>>    Procedure ApiTableCreateFromDEF String sPath String sFileName String sTableName String sDisplayName Integer iFilelistSlot
86634>>>>>>>        Handle hTable
86634>>>>>>>        String sDEFName sDataPath
86634>>>>>>>        Boolean bExists
86634>>>>>>>
86634>>>>>>>        // Do nothing if MSSQL Driver.
86634>>>>>>>//        Get IsMSSQLDriver to bExists
86634>>>>>>>//        If (bExists = True) Begin
86634>>>>>>>//            Procedure_Return
86634>>>>>>>//        End
86634>>>>>>>
86634>>>>>>>        Get psDataPathFirstPart to sDataPath
86635>>>>>>>        Get vFilePathExists (sDataPath + sFileName + ".dat") to bExists
86636>>>>>>>        If (bExists = True) Begin
86638>>>>>>>            // We also needs to check if it is an Alias file, in case the sFileName.dat exists, but it may
86638>>>>>>>            // still be missing from the filelist and needs to be added.
86638>>>>>>>            Get UtilTableNumberIsInUse iFilelistSlot to bExists
86639>>>>>>>            If (bExists = True) Begin
86641>>>>>>>                Procedure_Return
86642>>>>>>>            End
86642>>>>>>>>
86642>>>>>>>            // Do _not_ use the DEF file if an alias, it will overwrite the base table data.
86642>>>>>>>            Else Begin
86643>>>>>>>                Set_Attribute DF_FILE_ROOT_NAME    of iFilelistSlot to sFileName
86646>>>>>>>                Set_Attribute DF_FILE_LOGICAL_NAME of iFilelistSlot to sTableName
86649>>>>>>>                Set_Attribute DF_FILE_DISPLAY_NAME of iFilelistSlot to sDisplayName
86652>>>>>>>                Procedure_Return
86653>>>>>>>            End
86653>>>>>>>>
86653>>>>>>>        End
86653>>>>>>>>
86653>>>>>>>
86653>>>>>>>        Move (sPath + sFileName + ".def") to sDEFName
86654>>>>>>>        Move 0 to hTable
86655>>>>>>>        Move False to Err
86656>>>>>>>
86656>>>>>>>        Structure_Start hTable DATAFLEX_ID
86657>>>>>>>            Load_Def sDEFName Onto hTable
86658>>>>>>>            Set_Attribute DF_FILE_PHYSICAL_NAME of hTable to sFileName
86661>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86662>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86664>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86665>>>>>>>
86665>>>>>>>        Move iFilelistSlot to hTable
86666>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME    of hTable to sFileName
86669>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
86672>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to sDisplayName
86675>>>>>>>
86675>>>>>>>    End_Procedure
86676>>>>>>>
86676>>>>>>>    Function ApiTableMoveToFileSlot Integer iFromFileSlot Integer iToFileSlot String sDriverID Returns Boolean
86678>>>>>>>        Boolean bTmp bErr bOK
86678>>>>>>>        String sTableName sDisplayName sFileName
86678>>>>>>>
86678>>>>>>>        // We preserve the value of the Err flag, by saving its current state and resetting it before end of function.
86678>>>>>>>        Move Err to bTmp
86679>>>>>>>        Move False to Err
86680>>>>>>>
86680>>>>>>>        Get AutoConnectionIDLogin to bOK
86681>>>>>>>        // First get the info for the current filelist slot:
86681>>>>>>>        Open iFromFileSlot
86683>>>>>>>        Get_Attribute DF_FILE_OPENED of iFromFileSlot to bOK
86686>>>>>>>        If (bOK = True) Begin
86688>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to sFileName
86691>>>>>>>            Get_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to sTableName
86694>>>>>>>            Get_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to sDisplayName
86697>>>>>>>
86697>>>>>>>            //...then move it.
86697>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of iToFileSlot to sFileName
86700>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iToFileSlot to sTableName
86703>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iToFileSlot to sDisplayName
86706>>>>>>>
86706>>>>>>>            //...and finally remove the old filelist values.
86706>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of iFromFileSlot to ""
86709>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of iFromFileSlot to ""
86712>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of iFromFileSlot to ""
86715>>>>>>>        End
86715>>>>>>>>
86715>>>>>>>        Close iFromFileSlot
86716>>>>>>>
86716>>>>>>>        Move Err to bErr
86717>>>>>>>        Move bTmp to Err
86718>>>>>>>        Function_Return (bErr = False)
86719>>>>>>>    End_Function
86720>>>>>>>
86720>>>>>>>    Function ApiTableRelate Handle hTableFrom Handle hTableTo Integer iColumnFrom Integer iColumnTo Returns Boolean
86722>>>>>>>        Handle hTable
86722>>>>>>>        Boolean bOK
86722>>>>>>>        String sDriverID
86722>>>>>>>
86722>>>>>>>        Get UtilTableExists hTableFrom to bOK
86723>>>>>>>        If (bOK = False) Begin
86725>>>>>>>            Set Private.phCurrentTable to hTableFrom
86726>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
86727>>>>>>>>
86727>>>>>>>            Function_Return False
86728>>>>>>>        End
86728>>>>>>>>
86728>>>>>>>
86728>>>>>>>        Get UtilTableExists hTableTo to bOK
86729>>>>>>>        If (bOK = False) Begin
86731>>>>>>>            Set Private.phCurrentTable to hTableTo
86732>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
86733>>>>>>>>
86733>>>>>>>            Function_Return False
86734>>>>>>>        End
86734>>>>>>>>
86734>>>>>>>
86734>>>>>>>        Get AutoConnectionIDLogin to bOK
86735>>>>>>>        Get UtilTableOpen hTableFrom "" DF_EXCLUSIVE to bOK
86736>>>>>>>        If (bOK = False) Begin
86738>>>>>>>            Function_Return False
86739>>>>>>>        End
86739>>>>>>>>
86739>>>>>>>
86739>>>>>>>        Move False to Err
86740>>>>>>>        Open hTableTo
86742>>>>>>>
86742>>>>>>>        Move hTableFrom to hTable
86743>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
86746>>>>>>>        Set Private.phCurrentTable to hTable
86747>>>>>>>
86747>>>>>>>        Structure_Start hTable sDriverID
86748>>>>>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumnFrom to hTableTo
86751>>>>>>>            If (iColumnTo <> 0) Begin
86753>>>>>>>                Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumnFrom to iColumnTo
86756>>>>>>>            End
86756>>>>>>>>
86756>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86757>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86759>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86760>>>>>>>
86760>>>>>>>        If (hTableTo > 0) Begin
86762>>>>>>>            Close hTableTo
86763>>>>>>>        End
86763>>>>>>>>
86763>>>>>>>
86763>>>>>>>        Function_Return (Err = False)
86764>>>>>>>    End_Function
86765>>>>>>>
86765>>>>>>>    // Removes the passed table name completely from disk, filelist (& Sql Server if an Sql-driver)
86765>>>>>>>    Function ApiTableRemove Handle hTable Returns Boolean
86767>>>>>>>        String sTableName sDriverID
86767>>>>>>>        Boolean bOk
86767>>>>>>>        String sDataPath
86767>>>>>>>
86767>>>>>>>        Get AutoConnectionIDLogin to bOK
86768>>>>>>>        Move False to Err
86769>>>>>>>        Get psDriverID to sDriverID
86770>>>>>>>        Get UtilTableHandleToString hTable sDriverID to sTableName
86771>>>>>>>        If (sTableName = "") Begin
86773>>>>>>>            Function_Return False
86774>>>>>>>        End
86774>>>>>>>>
86774>>>>>>>
86774>>>>>>>        Set Private.phCurrentTable to hTable
86775>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
86776>>>>>>>        Delete_db sTableName
86777>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_DELETE_FILE
86778>>>>>>>
86778>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
86780>>>>>>>//            Get SqlTableRemoveByTableName sTableName to bOk  // We don't have to do this because the database is already removed by 'delete_db' above
86780>>>>>>>            Get psDataPathFirstPart to sDataPath
86781>>>>>>>            Get vDeleteFile (sDataPath + sTableName + ".int") to bOk
86782>>>>>>>        End
86782>>>>>>>>
86782>>>>>>>        // Also remove table from filelist.cfg in case the physical file didn't exist.
86782>>>>>>>        If (hTable <> 0) Begin
86784>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME     of hTable to ""
86787>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to ""
86790>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to ""
86793>>>>>>>        End
86793>>>>>>>>
86793>>>>>>>
86793>>>>>>>        Close hTable
86794>>>>>>>        Function_Return (hTable <> 0)
86795>>>>>>>    End_Function
86796>>>>>>>
86796>>>>>>>    Function ApiTableRemoveRelation Handle hTableFrom Integer iColumn Returns Boolean
86798>>>>>>>        Handle hTable
86798>>>>>>>        Boolean bOK
86798>>>>>>>
86798>>>>>>>        Get AutoConnectionIDLogin to bOK
86799>>>>>>>        Move False to Err
86800>>>>>>>        Open hTableFrom Mode DF_EXCLUSIVE
86802>>>>>>>        Move hTableFrom to hTable
86803>>>>>>>
86803>>>>>>>        Structure_Start hTable
86804>>>>>>>            Set_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to 0
86807>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
86808>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
86810>>>>>>>        Set Action_Text of ghoStatusPanel to ""
86811>>>>>>>
86811>>>>>>>        Close hTableFrom
86812>>>>>>>        Function_Return (Err = False)
86813>>>>>>>    End_Function
86814>>>>>>>
86814>>>>>>>    Function ApiTableRename Handle hTable String sRootName String sDisplayName String sLogicalName Returns Boolean
86816>>>>>>>        String sPhysicalName sRootNameTo sLogicalNameTo sDataPath sDriverID sSchema sPhysicalNameTo
86816>>>>>>>        Boolean bOK bExists bOpened
86816>>>>>>>        tAPITableNameInfo APITableNameInfo
86816>>>>>>>        tAPITableNameInfo APITableNameInfo
86816>>>>>>>
86816>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
86819>>>>>>>        If (bOpened = False) Begin
86821>>>>>>>            Get OpenTableExclusive hTable to bOpened
86822>>>>>>>            If (bOpened = False) Begin
86824>>>>>>>                Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
86825>>>>>>>                Function_Return False
86826>>>>>>>            End
86826>>>>>>>>
86826>>>>>>>        End
86826>>>>>>>>
86826>>>>>>>
86826>>>>>>>        Set Private.phCurrentTable to hTable
86827>>>>>>>        Move hTable         to APITableNameInfo.iTableNumber
86828>>>>>>>        Move sRootName      to APITableNameInfo.sRootName
86829>>>>>>>        Move sLogicalName   to APITableNameInfo.sLogicalName
86830>>>>>>>        Move sDisplayName   to APITableNameInfo.sDisplayName
86831>>>>>>>        Get ApiTableFilelistNamesCompare True APITableNameInfo to bExists
86832>>>>>>>        If (bExists = True) Begin
86834>>>>>>>            Function_Return True
86835>>>>>>>        End
86835>>>>>>>>
86835>>>>>>>
86835>>>>>>>        Set Private.phCurrentTable to hTable
86836>>>>>>>        Move False to Err
86837>>>>>>>        Get psDataPathFirstPart to sDataPath
86838>>>>>>>        Get_Attribute DF_FILE_PHYSICAL_NAME of hTable to sPhysicalName
86841>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo
86844>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo
86847>>>>>>>
86847>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
86850>>>>>>>        Close hTable
86851>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin
86853>>>>>>>            Get vFilePathExists (sDataPath + sRootNameTo + ".dat") to bExists
86854>>>>>>>            If (bExists = True) Begin
86856>>>>>>>                If (Uppercase(sRootName) <> Uppercase(sRootNameTo)) Begin
86858>>>>>>>                    Copy_db (sDataPath + sRootNameTo) to (sDataPath + sRootName)
86861>>>>>>>                    // We need a short break here before attempting to delete the physical old files or Windows
86861>>>>>>>                    // might report "File in use..." and the deletion will fail.
86861>>>>>>>                    Sleep 2
86862>>>>>>>                    Get vDeleteFile (sDataPath + sRootNameTo + ".*") to bOK
86863>>>>>>>                End
86863>>>>>>>>
86863>>>>>>>            End
86863>>>>>>>>
86863>>>>>>>        End
86863>>>>>>>>
86863>>>>>>>
86863>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
86865>>>>>>>            If (not(sPhysicalName contains ".")) Begin
86867>>>>>>>                Move (sPhysicalName + String(".int")) to sPhysicalName
86868>>>>>>>            End
86868>>>>>>>>
86868>>>>>>>
86868>>>>>>>            // Change the table name in the .int file to the new table new:
86868>>>>>>>            Get UtilChangeSourceCodeLine (sDataPath + sPhysicalName) (CS_DATABASE_NAME * String(sLogicalNameTo)) (CS_DATABASE_NAME * String(sLogicalName)) False to bOK
86869>>>>>>>            If (bOK = False) Begin
86871>>>>>>>                Function_Return False
86872>>>>>>>            End
86872>>>>>>>>
86872>>>>>>>
86872>>>>>>>            // Change table name at the SQL side:
86872>>>>>>>            Get psSchema to sSchema
86873>>>>>>>            Get SqlTableRename hTable sLogicalNameTo sLogicalName to bOK
86874>>>>>>>
86874>>>>>>>            Get _TableNameOnly sRootName to sPhysicalNameTo
86875>>>>>>>            // Remove cache file and Rename the physical file names:
86875>>>>>>>            Get vDeleteFile (sDataPath + sPhysicalNameTo + ".cch")                                  to bOK
86876>>>>>>>            Get vRenameFile (sDataPath + sPhysicalName)            (sDataPath + sRootName + ".int") to bOK
86877>>>>>>>            Get vRenameFile (sDataPath + sPhysicalNameTo + ".tag") (sDataPath + sRootName + ".tag") to bOK
86878>>>>>>>            Move (sDriverID + ":" + sRootName) to sRootName
86879>>>>>>>
86879>>>>>>>            // The Studio no longer adds the schema to the DISPLAY_NAME, so commented out.
86879>>>>>>>//            If (not(sDisplayName contains ".")) Begin
86879>>>>>>>//                Move (sSchema + "." + sDisplayName) to sDisplayName
86879>>>>>>>//            End
86879>>>>>>>        End
86879>>>>>>>>
86879>>>>>>>
86879>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME     of hTable to sRootName
86882>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
86885>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
86888>>>>>>>
86888>>>>>>>        Function_Return (Err = False)
86889>>>>>>>    End_Function
86890>>>>>>>
86890>>>>>>>    Function ApiTableRenameAlias Integer hTable String sDisplayName String sLogicalName Returns Boolean
86892>>>>>>>        Move False to Err
86893>>>>>>>        Set Private.phCurrentTable to hTable
86894>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayName
86897>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
86900>>>>>>>
86900>>>>>>>        Function_Return (Err = False)
86901>>>>>>>    End_Function
86902>>>>>>>
86902>>>>>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
86902>>>>>>>    // Note that it first removes any driver prefixes in the rootname.
86902>>>>>>>    Function ApiTableFilelistNamesCompare Boolean bCompareFilelistUppercase tAPITableNameInfo APITableInfo Returns Boolean
86904>>>>>>>        String sRootNameFrom sRootNameTo sDisplayNameTo sLogicalNameTo
86904>>>>>>>        Handle hTable
86904>>>>>>>        Boolean bIsSame
86904>>>>>>>
86904>>>>>>>        Move APITableInfo.iTableNumber      to hTable
86905>>>>>>>        Get _TableNameOnly APITableInfo.sRootName     to sRootNameFrom
86906>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME     of hTable to sRootNameTo
86909>>>>>>>        Get _TableNoPrefix sRootNameTo                to sRootNameTo
86910>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalNameTo
86913>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME  of hTable to sDisplayNameTo
86916>>>>>>>        Get _TableNoPrefix sDisplayNameTo             to sDisplayNameTo
86917>>>>>>>
86917>>>>>>>        If (bCompareFilelistUppercase = True) Begin
86919>>>>>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(APITableInfo.sLogicalName) = Uppercase(sLogicalNameTo) and ;                  Uppercase(APITableInfo.sDisplayName) = Uppercase(sDisplayNameTo)) to bIsSame
86920>>>>>>>        End
86920>>>>>>>>
86920>>>>>>>        Else Begin
86921>>>>>>>            Move (sRootNameFrom = sRootNameTo and APITableInfo.sLogicalName = sLogicalNameTo and APITableInfo.sDisplayName = sDisplayNameTo) to bIsSame
86922>>>>>>>        End
86922>>>>>>>>
86922>>>>>>>
86922>>>>>>>        Function_Return bIsSame
86923>>>>>>>    End_Function
86924>>>>>>>
86924>>>>>>>    // Note: This table update function does _not_ convert an embedded table to SQL. Use function ApiTableConvertToSQL first for that.
86924>>>>>>>    Function ApiTableUpdate tAPITableNameInfo APITableNameInfoFrom tAPIColumn[] aColumnsFrom tAPIIndex[] aIndexesFrom tAPIRelation[] aRelationsFrom Returns Boolean
86926>>>>>>>        Handle hTable
86926>>>>>>>        String sTableName
86926>>>>>>>        String sDriverIDFrom sDriverIDTo
86926>>>>>>>        Integer iDbType
86926>>>>>>>        Boolean bOk bMertechDriver bOpened bApiTableUpdateAuto
86926>>>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase bTableExists
86926>>>>>>>        Boolean bIsSame bFilelistError bIsAliasFrom bIsSQLTableFrom bIsSQLTableTo
86926>>>>>>>        tSQLConnection SQLConnection
86926>>>>>>>        tSQLConnection SQLConnection
86926>>>>>>>        tAPITable      APITableFrom APITableTo
86926>>>>>>>        tAPITable      APITableFrom APITableTo
86926>>>>>>>        tColumnType    ColumnType
86926>>>>>>>        tColumnType    ColumnType
86926>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
86926>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
86927>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
86927>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
86928>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
86928>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
86929>>>>>>>
86929>>>>>>>        // We don't allow changes to the framework's DbVersion table.
86929>>>>>>>        If (Lowercase(sTableName) = "dbversion") Begin
86931>>>>>>>            Function_Return False
86932>>>>>>>        End
86932>>>>>>>>
86932>>>>>>>
86932>>>>>>>        Move APITableNameInfoFrom.sDriverID     to sDriverIDFrom
86933>>>>>>>        Get piDbType                            to iDbType
86934>>>>>>>        Get pbRecnum                            to bRecnum
86935>>>>>>>        Get pbToANSI                            to bToANSI
86936>>>>>>>        Get pbCopyData                          to bCopyData
86937>>>>>>>        Get pbApiTableUpdateAuto                to bApiTableUpdateAuto
86938>>>>>>>        Get pbCompareDate_DateTime              to bCompareDate_DateTime
86939>>>>>>>        Get pbCompareIndexAscending             to bCompareIndexAscending
86940>>>>>>>        Get pbCompareIndexUppercase             to bCompareIndexUppercase
86941>>>>>>>        Get IsMertechDriver sDriverIDFrom       to bMertechDriver
86942>>>>>>>        Get pbUseConnectionID                   to bUseConnectionID
86943>>>>>>>        If (bMertechDriver = True and bUseConnectionID = True) Begin
86945>>>>>>>            Move False                          to bUseConnectionID
86946>>>>>>>        End
86946>>>>>>>>
86946>>>>>>>
86946>>>>>>>        Move APITableNameInfoFrom.iTableNumber  to hTable
86947>>>>>>>        Set Private.phCurrentTable              to hTable
86948>>>>>>>        Get UtilTableExists  hTable             to bTableExists
86949>>>>>>>
86949>>>>>>>        If (ghoProgressBar <> 0) Begin
86951>>>>>>>            Send DoAdvance of ghoProgressBar
86952>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Checking Table:" * "Number:" * String(hTable) * String(APITableNameInfoFrom.sLogicalName))
86953>>>>>>>            Set Message_Text   of ghoStatusPanel to ""
86954>>>>>>>            Set Action_Text    of ghoStatusPanel to ""
86955>>>>>>>        End
86955>>>>>>>>
86955>>>>>>>
86955>>>>>>>        Move APITableNameInfoFrom.bIsAlias      to bIsAliasFrom
86956>>>>>>>        Move APITableNameInfoFrom.bIsSQL        to bIsSQLTableFrom
86957>>>>>>>        Get UtilTableIsSQL hTable               to bIsSQLTableTo
86958>>>>>>>        Get UtilDriverFromTableNumber hTable    to sDriverIDTo
86959>>>>>>>        Move True                               to APITableFrom.bFromTable
86960>>>>>>>        Move hTable                             to APITableFrom.hTable
86961>>>>>>>        Move APITableNameInfoFrom               to APITableFrom.ApiTableInfo
86962>>>>>>>        Move aColumnsFrom                       to APITableFrom.aApiColumns
86963>>>>>>>        Move aIndexesFrom                       to APITableFrom.aApiIndexes
86964>>>>>>>        Move aRelationsFrom                     to APITableFrom.aApiRelations
86965>>>>>>>
86965>>>>>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
86967>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverIDFrom to bOk
86968>>>>>>>            If (bOk = True) Begin
86970>>>>>>>                Get ApiTableAttachToSql hTable True to bOk
86971>>>>>>>                Function_Return bOk
86972>>>>>>>            End 
86972>>>>>>>>
86972>>>>>>>        End
86972>>>>>>>>
86972>>>>>>>
86972>>>>>>>        If (bTableExists = True) Begin
86974>>>>>>>            If (bIsSQLTableTo = True) Begin
86976>>>>>>>                Get UtilDeleteCacheFile APITableFrom.ApiTableInfo.sLogicalName to bOk
86977>>>>>>>            End
86977>>>>>>>>
86977>>>>>>>
86977>>>>>>>            Get OpenTableExclusive hTable to bOpened
86978>>>>>>>            If (bOpened = False) Begin
86980>>>>>>>                Send UserError DFERR_PROGRAM ("Could not open table number:" * String(hTable) * "Table could not be updated.")
86981>>>>>>>                Function_Return False
86982>>>>>>>            End
86982>>>>>>>>
86982>>>>>>>            Get UtilTableStructFill hTable False                                                        to APITableTo
86983>>>>>>>            Get UtilColumnCombineFromAndToArrays   APITableFrom.aApiColumns   APITableTo.aApiColumns    to aAPIColumnCompare
86984>>>>>>>            Get UtilIndexCombineFromAndToArrays    APITableFrom.aApiIndexes   APITableTo.aApiIndexes    to aAPIIndexCompare
86985>>>>>>>            Get UtilRelationCombineFromAndToArrays APITableFrom.aApiRelations APITableTo.aApiRelations  to aAPIRelationCompare
86986>>>>>>>        End
86986>>>>>>>>
86986>>>>>>>
86986>>>>>>>        Move False to Err
86987>>>>>>>        Case Begin
86987>>>>>>>            // Alias table:
86987>>>>>>>            Case (bIsAliasFrom = True)
86989>>>>>>>                Get _UtilTableCheckChangeFilelistNames APITableNameInfoFrom to bOk
86990>>>>>>>                Case Break
86991>>>>>>>
86991>>>>>>>            // New Table:
86991>>>>>>>            Case (bTableExists = False)
86994>>>>>>>                Get ApiTableCreate      hTable APITableNameInfoFrom.sRootName APITableNameInfoFrom.sDisplayName APITableNameInfoFrom.sLogicalName bUseConnectionID bToANSI bRecnum aColumnsFrom to bOk
86995>>>>>>>                //LR 20191112 Begin: Make file a system file if bIsSystemFile = True
86995>>>>>>>                If (APITableNameInfoFrom.bIsSystemFile) Begin
86997>>>>>>>                    Get ApiTableChangeAttribute of ghoDbUpdateFunctionLibrary hTable DF_FILE_IS_SYSTEM_FILE True to bOK
86998>>>>>>>                End                                                                 
86998>>>>>>>>
86998>>>>>>>                Get UtilIndexesUpdate   hTable bIsSQLTableFrom bIsSQLTableTo APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
86999>>>>>>>                Get UtilRelationsUpdate hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
87000>>>>>>>                Case Break
87001>>>>>>>
87001>>>>>>>            // Update table:
87001>>>>>>>            Case (bTableExists = True)
87004>>>>>>>                Get UtilTableCompare APITableFrom APITableTo False (&bFilelistError) to bIsSame
87005>>>>>>>                If (bIsSame = True) Begin
87007>>>>>>>                    Case Break
87008>>>>>>>                End
87008>>>>>>>>
87008>>>>>>>                If (bFilelistError = True) Begin
87010>>>>>>>                    Get ApiTableRename hTable APITableNameInfoFrom.sRootName APITableNameInfoFrom.sDisplayName APITableNameInfoFrom.sLogicalName to bOk
87011>>>>>>>                    If (bOk = False) Begin
87013>>>>>>>                        Case Break
87014>>>>>>>                    End
87014>>>>>>>>
87014>>>>>>>                End
87014>>>>>>>>
87014>>>>>>>
87014>>>>>>>                If (ghoProgressBar <> 0) Begin
87016>>>>>>>                    Send DoAdvance of ghoProgressBar
87017>>>>>>>                    Set TableName_Text of ghoStatusPanel to ("Updating Table:" * "Number:" * String(hTable) * String(APITableNameInfoFrom.sLogicalName))
87018>>>>>>>                End
87018>>>>>>>>
87018>>>>>>>
87018>>>>>>>                // Columns:
87018>>>>>>>                Move True to bOk
87019>>>>>>>                Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom bIsSQLTableTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
87020>>>>>>>                If (bIsSame = False) Begin
87022>>>>>>>                    Get ApiColumnsUpdate sDriverIDFrom hTable bIsSQLTableFrom APITableFrom.aApiColumns APITableTo.aApiColumns bCompareDate_DateTime to bOk
87023>>>>>>>                End
87023>>>>>>>>
87023>>>>>>>                If (bOk = False) Begin
87025>>>>>>>                    Case Break
87026>>>>>>>                End
87026>>>>>>>>
87026>>>>>>>
87026>>>>>>>                // Indexes:
87026>>>>>>>                Get UtilIndexesCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare bCompareIndexUppercase bCompareIndexAscending to bIsSame
87027>>>>>>>                If (bIsSame = False) Begin
87029>>>>>>>                    Get UtilIndexesUpdate hTable bIsSQLTableFrom bIsSQLTableTo APITableFrom.aApiIndexes APITableTo.aApiIndexes bCompareIndexUppercase bCompareIndexAscending  to bOk
87030>>>>>>>                End
87030>>>>>>>>
87030>>>>>>>
87030>>>>>>>                // Relations:
87030>>>>>>>                Get UtilRelationsCompare hTable aAPIRelationCompare to bIsSame
87031>>>>>>>                If (bIsSame = False) Begin
87033>>>>>>>                    Get UtilRelationsUpdate hTable APITableFrom.aApiRelations APITableTo.aApiRelations to bOk
87034>>>>>>>                    If (bOk = False) Begin
87036>>>>>>>                        Case Break
87037>>>>>>>                    End
87037>>>>>>>>
87037>>>>>>>                End
87037>>>>>>>>
87037>>>>>>>
87037>>>>>>>                Case Break
87038>>>>>>>
87038>>>>>>>            Case Else
87038>>>>>>>                Error DFERR_PROGRAM "Unknown Case structure exit in Function ApiTableUpdate"
87039>>>>>>>>
87039>>>>>>>                Move False to bOk
87040>>>>>>>        Case End
87040>>>>>>>        
87040>>>>>>>        // Note: If the from table was SQL; we should either connect to an existing SQL to table,
87040>>>>>>>        // or convert an embedded table to SQL
87040>>>>>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
87042>>>>>>>            Get SqlUtilCheckIfTableHandleExists hTable sDriverIDFrom to bOk
87043>>>>>>>            If (bOk = False) Begin
87045>>>>>>>                Get ApiTableConvertToSql_Ex hTable sDriverIDFrom bUseConnectionID bToANSI bRecnum bCopyData to bOK
87046>>>>>>>            End
87046>>>>>>>>
87046>>>>>>>        End
87046>>>>>>>>
87046>>>>>>>        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
87049>>>>>>>            Get SqlTableConvertToEmbedded hTable True to bOk
87050>>>>>>>        End
87050>>>>>>>>
87050>>>>>>>        
87050>>>>>>>        // Filelist Names:
87050>>>>>>>        Get _UtilTableCheckChangeFilelistNames APITableNameInfoFrom to bOk
87051>>>>>>>        Close hTable
87052>>>>>>>        Set TableName_Text of ghoStatusPanel to ""
87053>>>>>>>
87053>>>>>>>        Function_Return (bOK = True)
87054>>>>>>>    End_Function
87055>>>>>>>
87055>>>>>>>    // * Dummy function for the Studio's Code Explorer *
87055>>>>>>>    Function API_COLUMN_FUNCTIONS Returns Boolean
87057>>>>>>>        Function_Return False
87058>>>>>>>    End_Function
87059>>>>>>>
87059>>>>>>>    // Adds a column name to the passed table number.
87059>>>>>>>    Function ApiColumnAdd Handle hTable String sFieldName Integer iType Integer iLength Integer iPrec Boolean bInitVal String sColVal Returns Boolean
87061>>>>>>>        Integer iColumn iCount iFile iPrecision iLastErr
87061>>>>>>>        Boolean bExists bOK bInitializeValue bRetval bMertechDriver
87061>>>>>>>        String sDataPath sDdSrcPath sTableName sColumnValue sDriverID
87061>>>>>>>
87061>>>>>>>        Get UtilColumnExists hTable sFieldName to bExists
87062>>>>>>>        If (bExists = True) Begin
87064>>>>>>>            Function_Return False
87065>>>>>>>        End
87065>>>>>>>>
87065>>>>>>>
87065>>>>>>>        Move False to Err
87066>>>>>>>        If (num_arguments > 4) Begin
87068>>>>>>>            Move iPrec to iPrecision
87069>>>>>>>        End
87069>>>>>>>>
87069>>>>>>>        If (num_arguments > 6) Begin
87071>>>>>>>            Move bInitVal to bInitializeValue
87072>>>>>>>            Move sColVal  to sColumnValue
87073>>>>>>>        End
87073>>>>>>>>
87073>>>>>>>        If (iType < -1490) Begin
87075>>>>>>>            Move (iType + 1500) to iType
87076>>>>>>>        End
87076>>>>>>>>
87076>>>>>>>
87076>>>>>>>        Move hTable to iFile
87077>>>>>>>        Get psDriverID to sDriverID
87078>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
87079>>>>>>>        Get AutoConnectionIDLogin to bOK
87080>>>>>>>        Move False to Err
87081>>>>>>>        Move LastErr to iLastErr
87082>>>>>>>        Get OpenTableExclusive iFile to bOK
87083>>>>>>>//        Open iFile Mode DF_EXCLUSIVE
87083>>>>>>>        Set Private.phCurrentTable to hTable
87084>>>>>>>            MERTECH_WARNING_MESSAGE Disabled
87117>>>>>>>>
87117>>>>>>>        Structure_Start iFile sDriverID
87118>>>>>>>            Move 0 to iColumn
87119>>>>>>>            Set Private.piCurrentField to iColumn
87120>>>>>>>            Create_Field hTable At iColumn
87121>>>>>>>            Set_Attribute DF_FIELD_NAME      of iFile iColumn to sFieldName
87124>>>>>>>            If (bMertechDriver = True) Begin
87126>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87127>>>>>>>                Send Ignore_Error of Error_Object_Id DFERR_BAD_ATTRIBUTE_VALUE
87128>>>>>>>            End
87128>>>>>>>>
87128>>>>>>>            Set_Attribute DF_FIELD_TYPE      of iFile iColumn to iType
87131>>>>>>>            If (bMertechDriver = True) Begin
87133>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
87134>>>>>>>                Send Trap_Error of Error_Object_Id DFERR_BAD_ATTRIBUTE_VALUE
87135>>>>>>>                Move False to Err
87136>>>>>>>                Move iLastErr to LastErr
87137>>>>>>>            End
87137>>>>>>>>
87137>>>>>>>            Set_Attribute DF_FIELD_LENGTH    of iFile iColumn to (iLength + iPrecision)
87140>>>>>>>            Set_Attribute DF_FIELD_PRECISION of iFile iColumn to iPrecision
87143>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87144>>>>>>>        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87146>>>>>>>            MERTECH_WARNING_MESSAGE Enabled
87179>>>>>>>>
87179>>>>>>>
87179>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87180>>>>>>>
87180>>>>>>>        // If in development environment; create .fd file:
87180>>>>>>>        Open hTable
87182>>>>>>>        Get psDdSrcPath  of (phoWorkspace(ghoApplication)) to sDDSrcPath
87183>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
87184>>>>>>>        If (iCount > 1) Begin
87186>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
87187>>>>>>>        End
87187>>>>>>>>
87187>>>>>>>        Get vFolderExists sDDSrcPath to bExists
87188>>>>>>>        If (bExists = True) Begin
87190>>>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
87191>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
87194>>>>>>>            Get _TableNameOnly sTableName to sTableName
87195>>>>>>>            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
87197>>>>>>>        End
87197>>>>>>>>
87197>>>>>>>        If (sDriverID = DATAFLEX_ID) Begin  // We only want a tag if DataFlex embedded db
87199>>>>>>>            Get psDataPath  of (phoWorkspace(ghoApplication)) to sDataPath
87200>>>>>>>            Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
87201>>>>>>>            If (iCount > 1) Begin
87203>>>>>>>                Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
87204>>>>>>>            End
87204>>>>>>>>
87204>>>>>>>            Get vFolderFormat sDataPath to sDataPath
87205>>>>>>>            // Add the new column name to the .tag filen (if it doesn't exist):
87205>>>>>>>            // The following line should not be necexxary for the DataFlex driver. (Thank you, Hans van de Laar)
87205>>>>>>>            //Get UtilUpdateTAGFile (sDataPath + sTableName + ".tag") sFieldName to bOK
87205>>>>>>>        End
87205>>>>>>>>
87205>>>>>>>        // Check for a default value
87205>>>>>>>        If (bInitializeValue = True and sColumnValue <> "" and Err = False) Begin
87207>>>>>>>            Get ApiColumnUpdateValue hTable sFieldName sColumnValue to bRetval
87208>>>>>>>        End
87208>>>>>>>>
87208>>>>>>>        Close hTable
87209>>>>>>>
87209>>>>>>>        Function_Return (Err = False)
87210>>>>>>>    End_Function
87211>>>>>>>
87211>>>>>>>    // Adds a column name to the passed table number.
87211>>>>>>>    Function ApiColumnInsert String sDriverIDFrom Handle hTable Integer iColumn String sFieldName Integer iType Integer iLength Integer iPrec Boolean bIsSQLType Returns Boolean
87213>>>>>>>        Integer iCount iFile iPrecision iNumberOfFields iDbType
87213>>>>>>>        Boolean bExists bOK bIsDateType bIsSQLTypeTo
87213>>>>>>>        String sDdSrcPath sTableName
87213>>>>>>>
87213>>>>>>>        Get UtilColumnExists hTable sFieldName to bExists
87214>>>>>>>        Move False to Err
87215>>>>>>>        If (bExists = True) Begin
87217>>>>>>>            Function_Return False
87218>>>>>>>        End
87218>>>>>>>>
87218>>>>>>>        If (num_arguments > 4) Begin
87220>>>>>>>            Move iPrec to iPrecision
87221>>>>>>>        End
87221>>>>>>>>
87221>>>>>>>        If (iType < -1490) Begin
87223>>>>>>>            Move (iType + 1500) to iType
87224>>>>>>>        End
87224>>>>>>>>
87224>>>>>>>
87224>>>>>>>        Get AutoConnectionIDLogin to bOK
87225>>>>>>>        Move False to Err
87226>>>>>>>        Get UtilTableIsSql hTable to bIsSQLTypeTo
87227>>>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
87227>>>>>>>        // data types between Embedded and SQL, else we can't compare the data types. 
87227>>>>>>>        Get piDbType to iDbType
87228>>>>>>>        If (bIsSQLTypeTo = False) Begin
87230>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iType iLength to iType
87231>>>>>>>            If (iType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
87233>>>>>>>                Move DF_DATE to iType
87234>>>>>>>            End
87234>>>>>>>>
87234>>>>>>>        End
87234>>>>>>>>
87234>>>>>>>
87234>>>>>>>        // Structure_start will change the value of hTable...
87234>>>>>>>        Move hTable to iFile
87235>>>>>>>        Get OpenTableExclusive iFile to bOK
87236>>>>>>>        If (bOK = False) Begin
87238>>>>>>>            Function_Return False
87239>>>>>>>        End
87239>>>>>>>>
87239>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iNumberOfFields
87242>>>>>>>
87242>>>>>>>        // If the passed column number is higher than the current number of fields
87242>>>>>>>        // in the table, this means we should _not_ insert a field but rather add
87242>>>>>>>        // a new field to the end:
87242>>>>>>>        If (iColumn > iNumberOfFields) Begin
87244>>>>>>>            Move 0 to iColumn
87245>>>>>>>        End
87245>>>>>>>>
87245>>>>>>>
87245>>>>>>>        Set Private.phCurrentTable to hTable
87246>>>>>>>        Set Private.piCurrentField to iColumn
87247>>>>>>>
87247>>>>>>>        Structure_Start iFile
87248>>>>>>>            Create_Field iFile At iColumn
87249>>>>>>>            Set_Attribute DF_FIELD_NAME            of iFile iColumn to sFieldName
87252>>>>>>>            If (bIsSQLTypeTo = False) Begin
87254>>>>>>>                Set_Attribute DF_FIELD_TYPE        of iFile iColumn to iType
87257>>>>>>>            End
87257>>>>>>>>
87257>>>>>>>            Else Begin
87258>>>>>>>                Set_Attribute DF_FIELD_NATIVE_TYPE of iFile iColumn to iType
87261>>>>>>>            End
87261>>>>>>>>
87261>>>>>>>            Get UtilColumnIsDateType iType bIsSQLTypeTo to bIsDateType
87262>>>>>>>            If (bIsDateType = False) Begin
87264>>>>>>>                Set_Attribute DF_FIELD_LENGTH       of iFile iColumn to (iLength + iPrecision)
87267>>>>>>>                Set_Attribute DF_FIELD_PRECISION    of iFile iColumn to iPrecision
87270>>>>>>>            End
87270>>>>>>>>
87270>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87271>>>>>>>        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87273>>>>>>>
87273>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87274>>>>>>>        // If in development environment; create .fd file:
87274>>>>>>>        Open hTable
87276>>>>>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
87277>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
87278>>>>>>>        If (iCount > 1) Begin
87280>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
87281>>>>>>>        End
87281>>>>>>>>
87281>>>>>>>        Get vFolderExists sDDSrcPath to bExists
87282>>>>>>>        If (bExists = True) Begin
87284>>>>>>>            Get vFolderFormat sDDSrcPath to sDDSrcPath
87285>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
87288>>>>>>>            Get _TableNameOnly sTableName to sTableName
87289>>>>>>>            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
87291>>>>>>>        End
87291>>>>>>>>
87291>>>>>>>
87291>>>>>>>        // Check for a default value
87291>>>>>>>        Close hTable
87292>>>>>>>
87292>>>>>>>        Function_Return (Err = False)
87293>>>>>>>    End_Function
87294>>>>>>>
87294>>>>>>>//    Function ApiColumnAddMultiple Handle hTable tAPIColumn[] aColumns Returns Boolean
87294>>>>>>>//        Integer iColumn iCount iFile
87294>>>>>>>//        Boolean bExists bOK
87294>>>>>>>//        String sDdSrcPath sTableName
87294>>>>>>>//
87294>>>>>>>//        Get AutoConnectionIDLogin to bOK
87294>>>>>>>//        Move False to Err
87294>>>>>>>//
87294>>>>>>>//        // Structure_start will change the value of hTable...
87294>>>>>>>//        Move hTable to iFile
87294>>>>>>>//        Open iFile Mode DF_EXCLUSIVE
87294>>>>>>>//
87294>>>>>>>//        Structure_Start iFile
87294>>>>>>>//            Send ApiColumnsAddToTable iFile aColumns False
87294>>>>>>>//        Structure_End iFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87294>>>>>>>//
87294>>>>>>>//        // If in development environment; create .fd file:
87294>>>>>>>//        Open hTable
87294>>>>>>>//        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
87294>>>>>>>//        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDDSrcPath to iCount
87294>>>>>>>//        If (iCount > 1) Begin
87294>>>>>>>//            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDDSrcPath 1 to sDDSrcPath
87294>>>>>>>//        End
87294>>>>>>>//        Get vFolderExists sDDSrcPath to bExists
87294>>>>>>>//        If (bExists = True) Begin
87294>>>>>>>//            Get vFolderFormat sDDSrcPath to sDDSrcPath
87294>>>>>>>//            Get_Attribute DF_FILE_ROOT_NAME of hTable to sTableName
87294>>>>>>>//            Get _TableNameOnly sTableName to sTableName
87294>>>>>>>//            Output_Aux_File DF_AUX_FILE_FD for hTable to (sDDSrcPath + sTableName + ".fd")
87294>>>>>>>//        End
87294>>>>>>>//        Close hTable
87294>>>>>>>//
87294>>>>>>>//        Function_Return (Err = False)
87294>>>>>>>//    End_Function
87294>>>>>>>
87294>>>>>>>    // To update all records for a table column with a fixed value.
87294>>>>>>>    Function ApiColumnUpdateValue Handle hTable String sFieldName String sColumnValue Returns Boolean
87296>>>>>>>        Integer iRecs iCurrErr iField iRecord
87296>>>>>>>        Boolean bRetval bOpen
87296>>>>>>>
87296>>>>>>>        Move 0 to iRecs
87297>>>>>>>        Move False to bRetval
87298>>>>>>>        Move Err to iCurrErr
87299>>>>>>>        Move False to Err
87300>>>>>>>
87300>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
87303>>>>>>>        If (bOpen = False) Begin
87305>>>>>>>            Open hTable
87307>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
87310>>>>>>>            If (bOpen = False) Begin
87312>>>>>>>                Function_Return bRetval
87313>>>>>>>            End
87313>>>>>>>>
87313>>>>>>>        End
87313>>>>>>>>
87313>>>>>>>
87313>>>>>>>        Field_Map hTable sFieldName to iField
87315>>>>>>>        If (iField <> 0) Begin
87317>>>>>>>            Set Private.phCurrentTable to hTable
87318>>>>>>>            Set Private.piCurrentField to iField
87319>>>>>>>            Clear hTable
87320>>>>>>>            Repeat
87320>>>>>>>>
87320>>>>>>>                Vfind hTable 0 GT
87322>>>>>>>                If (Found) Begin
87324>>>>>>>                    If (ghoStatusPanel <> 0) Begin
87326>>>>>>>                        Get_Field_Value hTable 0 to iRecord
87329>>>>>>>                        Send Update_StatusPanel of ghoStatusPanel (CS_DUF_UpdateVersion * String(iRecord))
87330>>>>>>>                    End
87330>>>>>>>>
87330>>>>>>>                    Reread hTable
87334>>>>>>>                        Set_Field_Value hTable iField to sColumnValue
87337>>>>>>>                        SaveRecord hTable
87338>>>>>>>                    Unlock
87339>>>>>>>>
87339>>>>>>>                End
87339>>>>>>>>
87339>>>>>>>           Until (not(Found))
87341>>>>>>>        End
87341>>>>>>>>
87341>>>>>>>
87341>>>>>>>        Move (Err = False) to bRetval
87342>>>>>>>        Move iCurrErr to Err
87343>>>>>>>
87343>>>>>>>        Function_Return bRetval
87344>>>>>>>    End_Function
87345>>>>>>>
87345>>>>>>>    // Note: This can only be used from within a Structure_Start/End construct.
87345>>>>>>>    Function ApiColumnsAddToTable Handle hTable tAPIColumn[] aColumns Boolean bCreating Returns Boolean
87347>>>>>>>        Integer iCount iSize iColumn iType iDataFlexType iIndex iDbType
87347>>>>>>>        Boolean bFieldExists bNativeType bIsSQLDriver bIsDAWSqlDriver bIsSqlTable bRecnumTable bIsOpen bIsDateType
87347>>>>>>>        String sFieldName sDriverID sTableName sDefaultValue
87347>>>>>>>
87347>>>>>>>//        Set Private.phCurrentTable to hTable
87347>>>>>>>        Get psDriverID to sDriverID
87348>>>>>>>        Get piDbType to iDbType
87349>>>>>>>        Get UtilTableHandleToString hTable to sTableName
87350>>>>>>>        Get IsSQLDriver    sDriverID to bIsSQLDriver
87351>>>>>>>        Get IsDAWSQLDriver sDriverID to bIsDAWSqlDriver
87352>>>>>>>        Get UtilTableIsSQL hTable to bIsSqlTable
87353>>>>>>>        If (bIsSqlTable = False and bCreating = True and bIsSQLDriver = True) Begin
87355>>>>>>>            Move True to bIsSqlTable
87356>>>>>>>        End
87356>>>>>>>>
87356>>>>>>>        Move False to bIsOpen
87357>>>>>>>        If (hTable > 0) Begin
87359>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
87362>>>>>>>        End
87362>>>>>>>>
87362>>>>>>>        If (bIsOpen = True) Begin
87364>>>>>>>            Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
87367>>>>>>>        End
87367>>>>>>>>
87367>>>>>>>        Else Begin
87368>>>>>>>            Get pbRecnum to bRecnumTable
87369>>>>>>>        End
87369>>>>>>>>
87369>>>>>>>
87369>>>>>>>        Move False to Err
87370>>>>>>>        Move (SizeOfArray(aColumns)) to iSize
87371>>>>>>>        Decrement iSize
87372>>>>>>>        for iCount from 0 to iSize
87378>>>>>>>>
87378>>>>>>>            Move aColumns[iCount].sFieldName to sFieldName
87379>>>>>>>            If (hTable > 0) Begin
87381>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87382>>>>>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87383>>>>>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn to sFieldName
87386>>>>>>>                Move (Trim(sFieldName) <> "") to bFieldExists
87387>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
87388>>>>>>>                Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87389>>>>>>>            End
87389>>>>>>>>
87389>>>>>>>            Else Begin
87390>>>>>>>                Move False to bFieldExists
87391>>>>>>>            End
87391>>>>>>>>
87391>>>>>>>
87391>>>>>>>            If (bFieldExists = False) Begin
87393>>>>>>>                Move 0 to iColumn
87394>>>>>>>                Create_Field hTable At iColumn
87395>>>>>>>            End
87395>>>>>>>>
87395>>>>>>>            Else Begin
87396>>>>>>>                Move iCount to iColumn
87397>>>>>>>            End
87397>>>>>>>>
87397>>>>>>>
87397>>>>>>>            Set Private.piCurrentField to iColumn
87398>>>>>>>
87398>>>>>>>            Move                                        iColumn to aColumns[iCount].iFieldNumber
87399>>>>>>>            Set_Attribute DF_FIELD_NAME       of hTable iColumn to aColumns[iCount].sFieldName
87402>>>>>>>
87402>>>>>>>            Move aColumns[iCount].iType to iType
87403>>>>>>>            Move (not(iType < -1490)) to bNativeType
87404>>>>>>>            If (iType < -1490) Begin
87406>>>>>>>                Move (iType + 1500) to iType
87407>>>>>>>            End
87407>>>>>>>>
87407>>>>>>>
87407>>>>>>>            If (bIsSqlTable = True) Begin
87409>>>>>>>                If (aColumns[iCount].bIsSQLType = True) Begin
87411>>>>>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iDataFlexType
87412>>>>>>>                    Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iDataFlexType
87415>>>>>>>                    Set_Attribute DF_FIELD_NATIVE_TYPE   of hTable iColumn to iType
87418>>>>>>>                    Set_Attribute DF_FIELD_NULL_ALLOWED  of hTable iColumn to aColumns[iCount].bAllowNULL
87421>>>>>>>
87421>>>>>>>                    Move aColumns[iCount].sDefaultValue                    to sDefaultValue
87422>>>>>>>                    If (iDataFlexType = DF_BCD and Left(String(sDefaultValue), 1) <> "[") Begin
87424>>>>>>>                        Move ("[" + String(sDefaultValue) + "]") to sDefaultValue
87425>>>>>>>                    End
87425>>>>>>>>
87425>>>>>>>                    Set_Attribute DF_FIELD_DEFAULT_VALUE of hTable iColumn to sDefaultValue
87428>>>>>>>
87428>>>>>>>                End
87428>>>>>>>>
87428>>>>>>>                Else Begin
87429>>>>>>>                    Set_Attribute DF_FIELD_TYPE        of hTable iColumn to iType
87432>>>>>>>                End
87432>>>>>>>>
87432>>>>>>>            End
87432>>>>>>>>
87432>>>>>>>            Else Begin
87433>>>>>>>                If (bCreating = False) Begin
87435>>>>>>>                    Get UtilSQLColumnTypeToDataFlexType sDriverID iDbType iType aColumns[iCount].iLength to iType
87436>>>>>>>                    If (iType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
87438>>>>>>>                        Move DF_DATE to iType
87439>>>>>>>                    End
87439>>>>>>>>
87439>>>>>>>                End
87439>>>>>>>>
87439>>>>>>>                Set_Attribute DF_FIELD_TYPE of hTable iColumn to iType
87442>>>>>>>            End
87442>>>>>>>>
87442>>>>>>>
87442>>>>>>>            Get UtilColumnIsDateType iType bIsSqlTable to bIsDateType
87443>>>>>>>            If (bIsDateType = False) Begin
87445>>>>>>>                Set_Attribute DF_FIELD_LENGTH     of hTable iColumn to aColumns[iCount].iLength
87448>>>>>>>                Set_Attribute DF_FIELD_PRECISION  of hTable iColumn to aColumns[iCount].iPrecision
87451>>>>>>>            End
87451>>>>>>>>
87451>>>>>>>
87451>>>>>>>            If (aColumns[iCount].iOptions iand C_tAPIColumn_Identity) Begin
87453>>>>>>>                Move 0 to iIndex
87454>>>>>>>                Create_Index hTable at iIndex
87455>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to 1
87458>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD   of hTable iIndex 1 to iColumn
87461>>>>>>>                Set_Attribute DF_FILE_PRIMARY_INDEX    of hTable iIndex to 1
87464>>>>>>>
87464>>>>>>>                // If we have an identity table - we must create a primary_key table.
87464>>>>>>>                If (bIsSqlTable = True) Begin
87466>>>>>>>                End
87466>>>>>>>>
87466>>>>>>>            End
87466>>>>>>>>
87466>>>>>>>        Loop
87467>>>>>>>>
87467>>>>>>>
87467>>>>>>>        Function_Return (Err = False)
87468>>>>>>>    End_Function
87469>>>>>>>
87469>>>>>>>    // Changes a field type, length and precision for the passed table number and field name
87469>>>>>>>    Function ApiColumnChange Handle hTable String sFieldNameFrom Integer iTypeFrom Integer iLengthFrom Integer iPrec Returns Boolean
87471>>>>>>>        Integer iColumn iPrecFrom iTypeTo iLengthTo iPrecTo
87471>>>>>>>        Boolean bOK bIsSqlTable
87471>>>>>>>        String sFieldNameTo
87471>>>>>>>
87471>>>>>>>        If (num_arguments > 4) Begin
87473>>>>>>>            Move iPrec to iPrecFrom
87474>>>>>>>        End
87474>>>>>>>>
87474>>>>>>>        If (iTypeFrom < -1490) Begin
87476>>>>>>>            Move (iTypeFrom + 1500) to iTypeFrom
87477>>>>>>>        End
87477>>>>>>>>
87477>>>>>>>
87477>>>>>>>        Get AutoConnectionIDLogin to bOK
87478>>>>>>>        Move False to Err
87479>>>>>>>        Get OpenTableExclusive hTable to bOK
87480>>>>>>>        If (bOK = False) Begin
87482>>>>>>>            Function_Return False
87483>>>>>>>        End
87483>>>>>>>>
87483>>>>>>>
87483>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87484>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87485>>>>>>>        Field_Map hTable sFieldNameFrom to iColumn
87487>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
87488>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87489>>>>>>>        If (Err = True) Begin
87491>>>>>>>            Function_Return False
87492>>>>>>>        End
87492>>>>>>>>
87492>>>>>>>
87492>>>>>>>        Get_Attribute DF_FIELD_NAME                  of hTable iColumn to sFieldNameTo
87495>>>>>>>        Get UtilTableIsSQL hTable to bIsSqlTable
87496>>>>>>>        If (bIsSqlTable = False) Begin
87498>>>>>>>            Get_Attribute DF_FIELD_TYPE              of hTable iColumn to iTypeTo
87501>>>>>>>        End
87501>>>>>>>>
87501>>>>>>>        Else Begin
87502>>>>>>>            Get_Attribute DF_FIELD_NATIVE_TYPE       of hTable iColumn to iTypeTo
87505>>>>>>>        End
87505>>>>>>>>
87505>>>>>>>        // Let the driver decide the other values;
87505>>>>>>>        Get_Attribute DF_FIELD_LENGTH                of hTable iColumn to iLengthTo
87508>>>>>>>        Get_Attribute DF_FIELD_PRECISION             of hTable iColumn to iPrecTo
87511>>>>>>>
87511>>>>>>>        If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo) Begin
87513>>>>>>>            Function_Return False
87514>>>>>>>        End
87514>>>>>>>>
87514>>>>>>>
87514>>>>>>>        Set Private.phCurrentTable to hTable
87515>>>>>>>        Set Private.piCurrentField to iColumn
87516>>>>>>>
87516>>>>>>>        Structure_Start hTable
87517>>>>>>>            Set_Attribute DF_FIELD_NAME              of hTable iColumn to sFieldNameFrom
87520>>>>>>>//            If (bIsSqlTable = False) Begin
87520>>>>>>>                Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iTypeFrom
87523>>>>>>>//            End
87523>>>>>>>//            Else Begin
87523>>>>>>>//                Set_Attribute DF_FIELD_TYPE          of hTable iColumn to iTypeFrom
87523>>>>>>>//                Set_Attribute DF_FIELD_NATIVE_TYPE   of hTable iColumn to iTypeFrom
87523>>>>>>>//            End
87523>>>>>>>            Set_Attribute DF_FIELD_LENGTH            of hTable iColumn to (iLengthFrom + iPrecFrom)
87526>>>>>>>            Set_Attribute DF_FIELD_PRECISION         of hTable iColumn to iPrecFrom
87529>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87530>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87532>>>>>>>
87532>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87533>>>>>>>        Function_Return (Err = False)
87534>>>>>>>    End_Function
87535>>>>>>>
87535>>>>>>>    // Changes a field type, length and precision for the passed table number and field name
87535>>>>>>>    Function ApiColumnChangeByColumnNumber String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo String sFieldNameFrom Integer iColumn Integer iTypeFrom Integer iLengthFrom Integer iPrec Integer iOpt Returns Boolean
87537>>>>>>>        Integer iPrecFrom iTypeTo iLengthTo iPrecTo iDbType iOptionFrom iOptionTo iDataFlexType iIndex
87537>>>>>>>        Boolean bOK bCompareDate_DateTime bSkip bRecnumTable bIsSameDataType
87537>>>>>>>        String sFieldNameTo sDriverIDTo
87537>>>>>>>        tColumnType ColumnType
87537>>>>>>>        tColumnType ColumnType
87537>>>>>>>
87537>>>>>>>        Get pbCompareDate_DateTime to bCompareDate_DateTime
87538>>>>>>>        Get piDbType to iDbType
87539>>>>>>>        If (num_arguments > 4) Begin
87541>>>>>>>            Move iPrec to iPrecFrom
87542>>>>>>>            Move iOpt  to iOptionFrom
87543>>>>>>>        End
87543>>>>>>>>
87543>>>>>>>        If (iTypeFrom < -1490) Begin
87545>>>>>>>            Move (iTypeFrom + 1500) to iTypeFrom
87546>>>>>>>        End
87546>>>>>>>>
87546>>>>>>>
87546>>>>>>>        Get AutoConnectionIDLogin to bOK
87547>>>>>>>        Move False to Err
87548>>>>>>>        Close hTable
87549>>>>>>>        Get OpenTableExclusive hTable to bOK
87550>>>>>>>        If (bOK = False) Begin
87552>>>>>>>            Function_Return False
87553>>>>>>>        End
87553>>>>>>>>
87553>>>>>>>
87553>>>>>>>        Get_Attribute DF_FILE_DRIVER                of hTable         to sDriverIDTo
87556>>>>>>>        Get_Attribute DF_FILE_RECNUM_TABLE          of hTable         to bRecnumTable
87559>>>>>>>        Get UtilSQLColumnTypeToDataFlexType sDriverIDTo iDbType iTypeTo iLengthTo to iDataFlexType
87560>>>>>>>        If (iDataFlexType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
87562>>>>>>>            Move DF_DATE to iDataFlexType
87563>>>>>>>        End
87563>>>>>>>>
87563>>>>>>>        Get_Attribute DF_FIELD_NAME                 of hTable iColumn to sFieldNameTo
87566>>>>>>>
87566>>>>>>>        If (bIsSQLTableTo = True) Begin
87568>>>>>>>            Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iTypeTo
87571>>>>>>>        End
87571>>>>>>>>
87571>>>>>>>        Else Begin
87572>>>>>>>            Get_Attribute DF_FIELD_TYPE             of hTable iColumn to iTypeTo
87575>>>>>>>        End
87575>>>>>>>>
87575>>>>>>>
87575>>>>>>>        Get_Attribute DF_FIELD_LENGTH               of hTable iColumn to iLengthTo
87578>>>>>>>        Get_Attribute DF_FIELD_PRECISION            of hTable iColumn to iPrecTo
87581>>>>>>>            Get_Attribute DF_FIELD_IS_IDENTITY      of hTable iColumn to iOptionTo
87584>>>>>>>
87584>>>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
87584>>>>>>>        // data types between Embedded and SQL, else we can't compare the data types.
87584>>>>>>>        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
87586>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iTypeTo
87587>>>>>>>            If (iTypeTo = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
87589>>>>>>>                Move DF_DATE to iTypeTo  
87590>>>>>>>            End
87590>>>>>>>>
87590>>>>>>>        End
87590>>>>>>>>
87590>>>>>>>        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
87593>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDTo   iDbType iTypeTo   iLengthTo   to iTypeFrom
87594>>>>>>>        End
87594>>>>>>>>
87594>>>>>>>        Move (iTypeFrom = iTypeTo) to bIsSameDataType
87595>>>>>>>
87595>>>>>>>        If (bCompareDate_DateTime = False) Begin
87597>>>>>>>            Move ((iTypeFrom = SQL_TYPE_DATE or iTypeFrom = SQL_TYPE_TIME or iTypeFrom = SQL_TYPE_TIMESTAMP) and (iTypeTo = SQL_TYPE_DATE or iTypeTo = SQL_TYPE_TIME or iTypeTo = SQL_TYPE_TIMESTAMP)) to bSkip
87598>>>>>>>            If (bSkip = True) Begin
87600>>>>>>>                If (sFieldNameFrom = sFieldNameTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
87602>>>>>>>                    Function_Return True
87603>>>>>>>                End
87603>>>>>>>>
87603>>>>>>>            End
87603>>>>>>>>
87603>>>>>>>        End
87603>>>>>>>>
87603>>>>>>>        Else If (sFieldNameFrom = sFieldNameTo and iTypeFrom = iTypeTo and iLengthFrom = iLengthTo and iPrecFrom = iPrecTo and iOptionFrom = iOptionTo) Begin
87606>>>>>>>            Function_Return True
87607>>>>>>>        End
87607>>>>>>>>
87607>>>>>>>
87607>>>>>>>        Set Private.phCurrentTable to hTable
87608>>>>>>>        Set Private.piCurrentField to iColumn
87609>>>>>>>
87609>>>>>>>        Structure_Start hTable
87610>>>>>>>            If (sFieldNameFrom <> sFieldNameTo) Begin
87612>>>>>>>                Set_Attribute DF_FIELD_NAME             of hTable iColumn to sFieldNameFrom
87615>>>>>>>            End
87615>>>>>>>>
87615>>>>>>>
87615>>>>>>>            If (bIsSameDataType = False) Begin
87617>>>>>>>                Set_Attribute DF_FIELD_TYPE             of hTable iColumn to iDataFlexType
87620>>>>>>>                If (bIsSQLTableTo = True) Begin
87622>>>>>>>                    Set_Attribute DF_FIELD_NATIVE_TYPE  of hTable iColumn to iTypeFrom
87625>>>>>>>                End
87625>>>>>>>>
87625>>>>>>>            End
87625>>>>>>>>
87625>>>>>>>
87625>>>>>>>            If (iLengthFrom <> iLengthTo) Begin
87627>>>>>>>                Set_Attribute DF_FIELD_LENGTH           of hTable iColumn to iLengthFrom
87630>>>>>>>            End
87630>>>>>>>>
87630>>>>>>>            If (iPrecFrom <> iPrecTo) Begin
87632>>>>>>>                Set_Attribute DF_FIELD_PRECISION        of hTable iColumn to iPrecFrom
87635>>>>>>>            End
87635>>>>>>>>
87635>>>>>>>
87635>>>>>>>            If (bIsSQLTableTo = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
87637>>>>>>>                // Can't set a recnum table to "DF_FIELD_IS_IDENTITY"
87637>>>>>>>                If (bRecnumTable = True) Begin
87639>>>>>>>                    Set_Attribute DF_FILE_RECNUM_TABLE  of hTable to False
87642>>>>>>>                End
87642>>>>>>>>
87642>>>>>>>
87642>>>>>>>                // We might need to create an index here.
87642>>>>>>>                // To be able to set the DF_FIELD_IS_IDENTITY the index must already exist, but it might not at this stage.
87642>>>>>>>                // This should probably fix that problem and if an adjustment is needed, it will get done with the normal
87642>>>>>>>                // index update checking logic.
87642>>>>>>>                Get_Attribute DF_FIELD_INDEX               of hTable iColumn to iIndex
87645>>>>>>>                If (iIndex = 0 and Uppercase(sFieldNameTo) <> "RECNUM") Begin
87647>>>>>>>                    Create_Index hTable At iIndex
87648>>>>>>>                    Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex   to 1
87651>>>>>>>                End
87651>>>>>>>>
87651>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD       of hTable iIndex 1 to iColumn
87654>>>>>>>                Set_Attribute DF_FILE_PRIMARY_INDEX        of hTable          to iIndex
87657>>>>>>>                    Set_Attribute DF_FIELD_IS_IDENTITY     of hTable iColumn  to True
87660>>>>>>>                If (bIsSQLTableTo = True) Begin
87662>>>>>>>                    Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex   to True
87665>>>>>>>                End
87665>>>>>>>>
87665>>>>>>>            End
87665>>>>>>>>
87665>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87666>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87668>>>>>>>
87668>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87669>>>>>>>        Function_Return (Err = False)
87670>>>>>>>    End_Function
87671>>>>>>>
87671>>>>>>>    Function ApiColumnChangeMainIndex Handle hTable Integer iIndex Integer iColumn Returns Boolean
87673>>>>>>>        Boolean bOK
87673>>>>>>>
87673>>>>>>>        Get AutoConnectionIDLogin to bOK
87674>>>>>>>        Move False to Err
87675>>>>>>>        Get OpenTableExclusive hTable to bOK
87676>>>>>>>        If (bOK = False) Begin
87678>>>>>>>            Function_Return False
87679>>>>>>>        End
87679>>>>>>>>
87679>>>>>>>
87679>>>>>>>        Structure_Start hTable
87680>>>>>>>            Set_Attribute DF_FIELD_INDEX of hTable iColumn to iIndex
87683>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87684>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87686>>>>>>>
87686>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87687>>>>>>>        Function_Return (Err = False)
87688>>>>>>>    End_Function
87689>>>>>>>
87689>>>>>>>    // To move an existing field to another position in a table.
87689>>>>>>>    Function ApiColumnMove Handle hTable Integer iOld Integer iNew Boolean bIsSQLType Integer iLength Integer iPrecision Returns Boolean
87691>>>>>>>        String sColumn sDriverID
87691>>>>>>>        Integer iType
87691>>>>>>>        Boolean bOK bIsDate
87691>>>>>>>
87691>>>>>>>        Close hTable
87692>>>>>>>        Get AutoConnectionIDLogin to bOK
87693>>>>>>>        Get OpenTableExclusive hTable to bOK
87694>>>>>>>        If (bOK = False) Begin
87696>>>>>>>            Function_Return False
87697>>>>>>>        End
87697>>>>>>>>
87697>>>>>>>
87697>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
87700>>>>>>>        If (sDriverID = DFBTRDRV_ID) Begin
87702>>>>>>>            Error DFERR_PROGRAM "Function 'ColumnMove' is not supported for the Pervasive database."
87703>>>>>>>>
87703>>>>>>>            Function_Return False
87704>>>>>>>        End
87704>>>>>>>>
87704>>>>>>>
87704>>>>>>>        Get_Attribute DF_FIELD_NAME of hTable iOld to sColumn
87707>>>>>>>        Get_Attribute DF_FIELD_TYPE of hTable iOld to iType
87710>>>>>>>        Get UtilColumnIsDateType iType bIsSQLType  to bIsDate
87711>>>>>>>
87711>>>>>>>        Set Private.phCurrentTable to hTable
87712>>>>>>>        Set Private.piCurrentField to iOld
87713>>>>>>>
87713>>>>>>>//        If (bIsDate = False) Begin
87713>>>>>>>//            Get_Attribute DF_FIELD_LENGTH    of hTable iOld to iLength
87713>>>>>>>//            Get_Attribute DF_FIELD_PRECISION of hTable iOld to iPrecision
87713>>>>>>>//        End
87713>>>>>>>//        Else Begin
87713>>>>>>>//            Move 6 to iLength
87713>>>>>>>//            Move 0 to iPrecision
87713>>>>>>>//        End
87713>>>>>>>
87713>>>>>>>        Move False to Err
87714>>>>>>>
87714>>>>>>>        Structure_Start hTable
87715>>>>>>>            Delete_Field hTable iOld
87716>>>>>>>            Create_Field hTable At iNew
87717>>>>>>>            Set_Attribute DF_FIELD_OLD_NUMBER of hTable iNew to iOld
87720>>>>>>>
87720>>>>>>>            Set_Attribute DF_FIELD_NAME of hTable iNew to sColumn
87723>>>>>>>            If (bIsSQLType = False) Begin
87725>>>>>>>                Set_Attribute DF_FIELD_TYPE of hTable iNew to iType
87728>>>>>>>            End
87728>>>>>>>>
87728>>>>>>>            Else Begin
87729>>>>>>>                Set_Attribute DF_FIELD_TYPE of hTable iNew to iType
87732>>>>>>>//                Set_Attribute DF_FIELD_NATIVE_TYPE of hTable iNew to iSQLType
87732>>>>>>>            End
87732>>>>>>>>
87732>>>>>>>
87732>>>>>>>            If (bIsDate = False) Begin
87734>>>>>>>                Set_Attribute DF_FIELD_LENGTH    of hTable iNew to iLength
87737>>>>>>>                Set_Attribute DF_FIELD_PRECISION of hTable iNew to iPrecision
87740>>>>>>>            End
87740>>>>>>>>
87740>>>>>>>
87740>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
87741>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87743>>>>>>>
87743>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87744>>>>>>>        Function_Return (Err = False)
87745>>>>>>>    End_Function
87746>>>>>>>
87746>>>>>>>    // Deletes a column name for the passed table number (and column number).
87746>>>>>>>    Function ApiColumnRemove Handle hTable String sFieldName Returns Boolean
87748>>>>>>>        Integer iColumn
87748>>>>>>>        Boolean bOK
87748>>>>>>>
87748>>>>>>>        Get AutoConnectionIDLogin to bOK
87749>>>>>>>        Move False to Err
87750>>>>>>>        Close hTable
87751>>>>>>>        Get OpenTableExclusive hTable to bOK
87752>>>>>>>        If (bOK = False) Begin
87754>>>>>>>            Function_Return False
87755>>>>>>>        End
87755>>>>>>>>
87755>>>>>>>
87755>>>>>>>        If (not(Err)) Begin
87757>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87758>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87759>>>>>>>            Field_Map hTable sFieldName to iColumn
87761>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
87762>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87763>>>>>>>            If (iColumn = 0) Begin
87765>>>>>>>                Move 0 to LastErr
87766>>>>>>>                Function_Return False
87767>>>>>>>            End
87767>>>>>>>>
87767>>>>>>>            Move False to Err
87768>>>>>>>
87768>>>>>>>            Set Private.phCurrentTable to hTable
87769>>>>>>>            Set Private.piCurrentField to iColumn
87770>>>>>>>
87770>>>>>>>            Structure_Start hTable
87771>>>>>>>                Delete_Field hTable iColumn
87772>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
87773>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87775>>>>>>>            Set Action_Text of ghoStatusPanel to ""
87776>>>>>>>        End
87776>>>>>>>>
87776>>>>>>>        Else Begin
87777>>>>>>>            Error DFERR_PROGRAM ("The table number:" * String(hTable) * "could not be opened exclusiv. This indicates the table is in use!")
87778>>>>>>>>
87778>>>>>>>        End
87778>>>>>>>>
87778>>>>>>>
87778>>>>>>>        Function_Return (Err = False)
87779>>>>>>>    End_Function
87780>>>>>>>
87780>>>>>>>    // Renames a field for the passed table number & old field name & new field name
87780>>>>>>>    // Returns True if no errors occured.
87780>>>>>>>    // Sample usage:
87780>>>>>>>    //   Get ColumnRename Quote.File_Number "ID#" "ID" to bOK
87780>>>>>>>    Function ApiColumnRename Integer hTable String sOldFieldName String sNewFieldName Returns Boolean
87782>>>>>>>        Integer iField
87782>>>>>>>        Boolean bOK bExists bIsOpen
87782>>>>>>>
87782>>>>>>>        Get UtilColumnExists hTable sNewFieldName to bExists
87783>>>>>>>        If (bExists = True) Begin
87785>>>>>>>            Function_Return False
87786>>>>>>>        End
87786>>>>>>>>
87786>>>>>>>
87786>>>>>>>        // Note: The Field_Map command does _not_ work if the table has been
87786>>>>>>>        //       opened exclusively, so we first open it in normal mode.
87786>>>>>>>        Close hTable
87787>>>>>>>        Open hTable
87789>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
87792>>>>>>>        If (bIsOpen = False) Begin
87794>>>>>>>            Function_Return False
87795>>>>>>>        End
87795>>>>>>>>
87795>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87796>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87797>>>>>>>        Field_Map hTable sOldFieldName to iField
87799>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87800>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
87801>>>>>>>
87801>>>>>>>        Get AutoConnectionIDLogin to bOK
87802>>>>>>>        Get OpenTableExclusive hTable to bOK
87803>>>>>>>        If (bOK = False) Begin
87805>>>>>>>            Function_Return False
87806>>>>>>>        End
87806>>>>>>>>
87806>>>>>>>
87806>>>>>>>        Move False to Err
87807>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
87808>>>>>>>        Set Private.phCurrentTable to hTable
87809>>>>>>>        Set Private.piCurrentField to iField
87810>>>>>>>
87810>>>>>>>        If (iField > 0) Begin
87812>>>>>>>            Structure_Start hTable
87813>>>>>>>                Set_Attribute DF_FIELD_NAME of hTable iField to sNewFieldName
87816>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
87817>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
87819>>>>>>>        End
87819>>>>>>>>
87819>>>>>>>        Else Begin
87820>>>>>>>            Move 0 to LastErr
87821>>>>>>>            Move False to Err
87822>>>>>>>        End
87822>>>>>>>>
87822>>>>>>>
87822>>>>>>>        Set Action_Text of ghoStatusPanel to ""
87823>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_DUPLICATE_FIELDNAME
87824>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
87825>>>>>>>
87825>>>>>>>        Function_Return (Err = False)
87826>>>>>>>    End_Function
87827>>>>>>>
87827>>>>>>>    Function UtilColumnsCheckForInserts Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
87829>>>>>>>        tAPIColumnCompare[] aAPIColumnsToInsert
87829>>>>>>>        tAPIColumnCompare[] aAPIColumnsToInsert
87830>>>>>>>        Integer iSize iCount iItem iFieldTo iNumberOfFieldsTo iColumnNumber
87830>>>>>>>        Boolean bRenameField
87830>>>>>>>
87830>>>>>>>        Open hTable
87832>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87833>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87834>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
87835>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumberOfFieldsTo
87838>>>>>>>        Move (iSize max iNumberOfFieldsTo) to iSize
87839>>>>>>>        Decrement iSize
87840>>>>>>>        for iCount from 0 to iSize
87846>>>>>>>>
87846>>>>>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
87848>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87849>>>>>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87850>>>>>>>
87850>>>>>>>                Field_Map hTable aAPIColumnCompare[iCount].sFieldNameFrom to iFieldTo
87852>>>>>>>                If (aAPIColumnCompare[iCount].bExistsFrom = True and iFieldTo = 0) Begin
87854>>>>>>>                    Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iColumnNumber
87855>>>>>>>                    Get UtilColumnShouldBeRenamed aAPIColumnCompare[iCount]      to bRenameField
87856>>>>>>>                    If (iColumnNumber = -1 and bRenameField = False) Begin
87858>>>>>>>                        Move aAPIColumnCompare[iCount].iFieldNumber     to aAPIColumnsToInsert[iItem].iFieldNumber
87859>>>>>>>                        Move aAPIColumnCompare[iCount].sFieldNameFrom   to aAPIColumnsToInsert[iItem].sFieldNameFrom
87860>>>>>>>                        Move aAPIColumnCompare[iCount].iTypeFrom        to aAPIColumnsToInsert[iItem].iTypeFrom
87861>>>>>>>                        Move aAPIColumnCompare[iCount].sTypeFrom        to aAPIColumnsToInsert[iItem].sTypeFrom
87862>>>>>>>                        Move aAPIColumnCompare[iCount].iLengthFrom      to aAPIColumnsToInsert[iItem].iLengthFrom
87863>>>>>>>                        Move aAPIColumnCompare[iCount].iPrecisionFrom   to aAPIColumnsToInsert[iItem].iPrecisionFrom
87864>>>>>>>                        Move aAPIColumnCompare[iCount].bIsSQLTypeFrom   to aAPIColumnsToInsert[iItem].bIsSQLTypeFrom
87865>>>>>>>                        Move aAPIColumnCompare[iCount].bIsSQLTypeTo     to aAPIColumnsToInsert[iItem].bIsSQLTypeTo
87866>>>>>>>                        Move True                                       to aAPIColumnsToInsert[iItem].bExistsFrom
87867>>>>>>>                        Move False                                      to aAPIColumnsToInsert[iItem].bExistsTo
87868>>>>>>>                        Increment iItem
87869>>>>>>>                    End
87869>>>>>>>>
87869>>>>>>>                End
87869>>>>>>>>
87869>>>>>>>            End
87869>>>>>>>>
87869>>>>>>>        Loop
87870>>>>>>>>
87870>>>>>>>
87870>>>>>>>        Move False to Err
87871>>>>>>>        Move 0 to LastErr
87872>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
87873>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_CANT_FIND_FIELD
87874>>>>>>>        Function_Return aAPIColumnsToInsert
87875>>>>>>>    End_Function
87876>>>>>>>
87876>>>>>>>    Function UtilColumnsInsert String sDriverIDFrom Handle hTable tAPIColumnCompare[] aAPIColumnsToInsert Returns Boolean
87878>>>>>>>        Integer iSize iCount
87878>>>>>>>        Boolean bOK
87878>>>>>>>        tAPIColumn[] aColumnsTo
87878>>>>>>>        tAPIColumn[] aColumnsTo
87879>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
87879>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
87880>>>>>>>
87880>>>>>>>        Move (SizeOfArray(aAPIColumnsToInsert)) to iSize
87881>>>>>>>        If (iSize = 0) Begin
87883>>>>>>>            Function_Return True
87884>>>>>>>        End
87884>>>>>>>>
87884>>>>>>>
87884>>>>>>>        Move False to Err
87885>>>>>>>        Decrement iSize
87886>>>>>>>        for iCount from 0 to iSize
87892>>>>>>>>
87892>>>>>>>            Get ApiColumnInsert sDriverIDFrom hTable aAPIColumnsToInsert[iCount].iFieldNumber aAPIColumnsToInsert[iCount].sFieldNameFrom aAPIColumnsToInsert[iCount].iTypeFrom aAPIColumnsToInsert[iCount].iLengthFrom aAPIColumnsToInsert[iCount].iPrecisionFrom aAPIColumnsToInsert[iCount].bIsSQLTypeFrom to bOK
87893>>>>>>>        Loop
87894>>>>>>>>
87894>>>>>>>
87894>>>>>>>        Function_Return bOK
87895>>>>>>>    End_Function
87896>>>>>>>
87896>>>>>>>    // Returns a struct array with fields that has the same names but different field numbers.
87896>>>>>>>    Function UtilColumnsCheckForMoves Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
87898>>>>>>>        tAPIColumnCompare[] aAPIColumnsToMove
87898>>>>>>>        tAPIColumnCompare[] aAPIColumnsToMove
87899>>>>>>>        Integer iSize iCount iItem iShouldMove
87899>>>>>>>
87899>>>>>>>        Move 0 to iItem
87900>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
87901>>>>>>>        Decrement iSize
87902>>>>>>>        for iCount from 0 to iSize
87908>>>>>>>>
87908>>>>>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
87910>>>>>>>                Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iShouldMove
87911>>>>>>>                If (iShouldMove <> -1) Begin
87913>>>>>>>                    Move aAPIColumnCompare[iCount] to aAPIColumnsToMove[iItem]
87914>>>>>>>                    Move iShouldMove               to aAPIColumnsToMove[iItem].iFieldNumberTo
87915>>>>>>>                    Move aAPIColumnCompare[iShouldMove - 1].sFieldNameTo to aAPIColumnsToMove[iItem].sFieldNameTo
87916>>>>>>>                    Increment iItem
87917>>>>>>>                End
87917>>>>>>>>
87917>>>>>>>            End
87917>>>>>>>>
87917>>>>>>>        Loop
87918>>>>>>>>
87918>>>>>>>
87918>>>>>>>        Move False to Err
87919>>>>>>>        Move 0 to LastErr
87920>>>>>>>        Function_Return aAPIColumnsToMove
87921>>>>>>>    End_Function
87922>>>>>>>
87922>>>>>>>    Function UtilColumnsMove Handle hTable tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo tAPIColumnCompare[] aAPIColumnsToMove Returns Boolean
87924>>>>>>>        Integer iSize iCount
87924>>>>>>>        Boolean bOK
87924>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
87924>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
87925>>>>>>>
87925>>>>>>>        Move (SizeOfArray(aAPIColumnsToMove)) to iSize
87926>>>>>>>        If (iSize = 0) Begin
87928>>>>>>>            Function_Return True
87929>>>>>>>        End
87929>>>>>>>>
87929>>>>>>>
87929>>>>>>>        Move False to Err
87930>>>>>>>        Decrement iSize
87931>>>>>>>        for iCount from 0 to iSize
87937>>>>>>>>
87937>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87938>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
87939>>>>>>>            If (aAPIColumnsToMove[iCount].bExistsFrom = True and aAPIColumnsToMove[iCount].bExistsTo = True) Begin
87941>>>>>>>                Get ApiColumnMove hTable aAPIColumnsToMove[iCount].iFieldNumberTo aAPIColumnsToMove[iCount].iFieldNumber aAPIColumnsToMove[iCount].bIsSQLTypeFrom aAPIColumnsToMove[iCount].iLengthFrom aAPIColumnsToMove[iCount].iPrecisionFrom to bOK
87942>>>>>>>                Get UtilColumnsStructFill hTable to aColumnsTo
87943>>>>>>>                Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
87944>>>>>>>                Get UtilColumnsCheckForMoves hTable aAPIColumnCompare to aAPIColumnsToMove
87945>>>>>>>                If (SizeOfArray(aAPIColumnsToMove)) Begin
87947>>>>>>>                    Move (SizeOfArray(aAPIColumnsToMove)) to iSize
87948>>>>>>>                    Decrement iSize
87949>>>>>>>                    Move 0 to iCount
87950>>>>>>>                End
87950>>>>>>>>
87950>>>>>>>            End
87950>>>>>>>>
87950>>>>>>>        Loop
87951>>>>>>>>
87951>>>>>>>
87951>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
87952>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
87953>>>>>>>        If (LastErr = DFERR_ARRAY_INDEX_OUT_OF_BOUNDS) Begin
87955>>>>>>>            Move 0 to LastErr
87956>>>>>>>        End
87956>>>>>>>>
87956>>>>>>>        Function_Return bOK
87957>>>>>>>    End_Function
87958>>>>>>>
87958>>>>>>>    // Checks if the "FROM" and "TO" database field is the same _except_ for the field name.
87958>>>>>>>    // We then assume this field should be renamed.
87958>>>>>>>//    Function UtilColumCheckRename Handle hTable tAPIColumnCompare aAPIColumnCompare Returns Boolean
87958>>>>>>>//        Boolean bDifferentFieldNames bShouldBeRenamed
87958>>>>>>>//
87958>>>>>>>//        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
87958>>>>>>>//        Move (Uppercase(aAPIColumnCompare.sFieldNameFrom) <> Uppercase(aAPIColumnCompare.sFieldNameTo)) to bDifferentFieldNames
87958>>>>>>>//
87958>>>>>>>//        If (bDifferentFieldNames = True) Begin
87958>>>>>>>//            Move (aAPIColumnCompare.iFieldNumber = aAPIColumnCompare.iFieldNumberTo) to bShouldBeRenamed
87958>>>>>>>//            If (bShouldBeRenamed = False) Begin
87958>>>>>>>//                Set Error_Report_Mode to DUF_ERROR_REPORT
87958>>>>>>>//                Function_Return False
87958>>>>>>>//            End
87958>>>>>>>//
87958>>>>>>>//            Move (aAPIColumnCompare.iTypeFrom = aAPIColumnCompare.iTypeTo) to bShouldBeRenamed
87958>>>>>>>//            If (bShouldBeRenamed = False) Begin
87958>>>>>>>//                Set Error_Report_Mode to DUF_ERROR_REPORT
87958>>>>>>>//                Function_Return False
87958>>>>>>>//            End
87958>>>>>>>//
87958>>>>>>>//            Move (aAPIColumnCompare.iLengthFrom = aAPIColumnCompare.iLengthTo) to bShouldBeRenamed
87958>>>>>>>//            If (bShouldBeRenamed = False) Begin
87958>>>>>>>//                Set Error_Report_Mode to DUF_ERROR_REPORT
87958>>>>>>>//                Function_Return False
87958>>>>>>>//            End
87958>>>>>>>//
87958>>>>>>>//            Move (aAPIColumnCompare.iPrecisionFrom = aAPIColumnCompare.iPrecisionTo) to bShouldBeRenamed
87958>>>>>>>//            If (bShouldBeRenamed = False) Begin
87958>>>>>>>//                Set Error_Report_Mode to DUF_ERROR_REPORT
87958>>>>>>>//                Function_Return False
87958>>>>>>>//            End
87958>>>>>>>//        End
87958>>>>>>>//
87958>>>>>>>//        Set Error_Report_Mode to DUF_ERROR_REPORT
87958>>>>>>>//        Function_Return True
87958>>>>>>>//    End_Function
87958>>>>>>>
87958>>>>>>>    // Takes a tAPIColumnCompare struct as parameter and returns True if;
87958>>>>>>>    // - Field Numbers, Data Types, Lengths and Precisions are all equal.
87958>>>>>>>    // - The "FROM" field name is <> "TO" field name
87958>>>>>>>//    // - The "FROM" field name also exists in the "TO" table; or the "TO" is part
87958>>>>>>>//    //   of the "FROM" field name. E.g. "FROM" = LATEST_REPL_COST_DATE, "TO" = Latest_Repl_Cos would results in a TRUE.
87958>>>>>>>    Function UtilColumnShouldBeRenamed tAPIColumnCompare aAPIColumnCompare Returns Boolean
87960>>>>>>>        Boolean bShouldRename
87960>>>>>>>        String sFieldNameFrom sFieldNameTo
87960>>>>>>>
87960>>>>>>>        Move (Uppercase(aAPIColumnCompare.sFieldNameFrom)) to sFieldNameFrom
87961>>>>>>>        Move (Uppercase(aAPIColumnCompare.sFieldNameTo))   to sFieldNameTo
87962>>>>>>>        If (sFieldNameFrom = sFieldNameTo) Begin
87964>>>>>>>            Function_Return False
87965>>>>>>>        End
87965>>>>>>>>
87965>>>>>>>
87965>>>>>>>        Move (aAPIColumnCompare.bExistsFrom    = aAPIColumnCompare.bExistsTo      and ;              aAPIColumnCompare.iFieldNumber   = aAPIColumnCompare.iFieldNumberTo and ;              aAPIColumnCompare.iTypeFrom      = aAPIColumnCompare.iTypeTo        and ;              aAPIColumnCompare.iLengthFrom    = aAPIColumnCompare.iLengthTo      and ;              aAPIColumnCompare.iPrecisionFrom = aAPIColumnCompare.iPrecisionTo   and ;              aAPIColumnCompare.iOptionsFrom   = aAPIColumnCompare.iOptionsTo) to bShouldRename
87966>>>>>>>//        If (bShouldRename = False) Begin
87966>>>>>>>//            Function_Return False
87966>>>>>>>//        End
87966>>>>>>>//
87966>>>>>>>//        If (sFieldNameFrom contains sFieldNameTo) Begin
87966>>>>>>>//            Function_Return True
87966>>>>>>>//        End
87966>>>>>>>
87966>>>>>>>        Function_Return bShouldRename
87967>>>>>>>    End_Function
87968>>>>>>>
87968>>>>>>>    // Returns -1 if the passed iColumn number doesn't exist with the same name in the aAPIColumnCompare struct array.
87968>>>>>>>    // Else it returns the column/field number of the field that exists in another position.
87968>>>>>>>    Function UtilColumnExistsWithOtherNumber tAPIColumnCompare[] aAPIColumnCompare Integer iColumn Returns Integer
87970>>>>>>>        Integer iCount iSize iRetval
87970>>>>>>>        String sFieldNameFrom
87970>>>>>>>
87970>>>>>>>        Move -1 to iRetval
87971>>>>>>>        If (aAPIColumnCompare[iColumn].bExistsFrom = False or aAPIColumnCompare[iColumn].bExistsTo = False) Begin
87973>>>>>>>            Function_Return iRetval
87974>>>>>>>        End
87974>>>>>>>>
87974>>>>>>>
87974>>>>>>>        Move (Uppercase(aAPIColumnCompare[iColumn].sFieldNameFrom)) to sFieldNameFrom
87975>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
87976>>>>>>>        Decrement iSize
87977>>>>>>>        for iCount from 0 to iSize
87983>>>>>>>>
87983>>>>>>>            // We're only interested in fields other than the passed field/column number:
87983>>>>>>>            If (iCount <> iColumn) Begin
87985>>>>>>>                If (Uppercase(aAPIColumnCompare[iCount].sFieldNameTo) = sFieldNameFrom) Begin
87987>>>>>>>                    Move (iCount + 1) to iRetval
87988>>>>>>>                End
87988>>>>>>>>
87988>>>>>>>            End
87988>>>>>>>>
87988>>>>>>>        Loop
87989>>>>>>>>
87989>>>>>>>
87989>>>>>>>        Move 0 to LastErr
87990>>>>>>>        Function_Return iRetval
87991>>>>>>>    End_Function
87992>>>>>>>
87992>>>>>>>    Function UtilColumnsCheckForRenames Handle hTable tAPIColumnCompare[] aAPIColumnCompare Returns tAPIColumnCompare[]
87994>>>>>>>        tAPIColumnCompare[] aAPIColumnsToRename
87994>>>>>>>        tAPIColumnCompare[] aAPIColumnsToRename
87995>>>>>>>        Integer iSize iCount iItem iFieldTo iShouldMove
87995>>>>>>>        Boolean bRenameField
87995>>>>>>>
87995>>>>>>>        Open hTable
87997>>>>>>>        Move 0 to iItem
87998>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
87999>>>>>>>        Decrement iSize
88000>>>>>>>        for iCount from 0 to iSize
88006>>>>>>>>
88006>>>>>>>            If (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) <> Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) Begin
88008>>>>>>>                // Check if the field exists in another position (other field number)
88008>>>>>>>                Get UtilColumnExistsWithOtherNumber aAPIColumnCompare iCount to iShouldMove
88009>>>>>>>                Get UtilColumnShouldBeRenamed aAPIColumnCompare[iCount] to bRenameField
88010>>>>>>>                If (aAPIColumnCompare[iCount].bExistsFrom = True and iShouldMove = -1 and bRenameField = True) Begin
88012>>>>>>>                    Move aAPIColumnCompare[iCount].iFieldNumber     to aAPIColumnsToRename[iItem].iFieldNumber
88013>>>>>>>                    Move iFieldTo                                   to aAPIColumnsToRename[iItem].iFieldNumberTo
88014>>>>>>>                    Move aAPIColumnCompare[iCount].sFieldNameFrom   to aAPIColumnsToRename[iItem].sFieldNameFrom
88015>>>>>>>                    Move aAPIColumnCompare[iCount].sFieldNameTo     to aAPIColumnsToRename[iItem].sFieldNameTo
88016>>>>>>>                    Increment iItem
88017>>>>>>>                End
88017>>>>>>>>
88017>>>>>>>            End
88017>>>>>>>>
88017>>>>>>>        Loop
88018>>>>>>>>
88018>>>>>>>
88018>>>>>>>        Move False to Err
88019>>>>>>>        Move 0 to LastErr
88020>>>>>>>        Function_Return aAPIColumnsToRename
88021>>>>>>>    End_Function
88022>>>>>>>
88022>>>>>>>    Function UtilColumnsRename Handle hTable tAPIColumnCompare[] aAPIColumnsToRename Returns Boolean
88024>>>>>>>        Integer iSize iCount
88024>>>>>>>        Boolean bOK
88024>>>>>>>        tAPIColumn[] aColumnsTo
88024>>>>>>>        tAPIColumn[] aColumnsTo
88025>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
88025>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
88026>>>>>>>
88026>>>>>>>        Move (SizeOfArray(aAPIColumnsToRename)) to iSize
88027>>>>>>>        If (iSize = 0) Begin
88029>>>>>>>            Function_Return True
88030>>>>>>>        End
88030>>>>>>>>
88030>>>>>>>
88030>>>>>>>        Move False to Err
88031>>>>>>>        Decrement iSize
88032>>>>>>>        For iCount from 0 to iSize
88038>>>>>>>>
88038>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88039>>>>>>>            Get ApiColumnRename hTable aAPIColumnsToRename[iCount].sFieldNameTo aAPIColumnsToRename[iCount].sFieldNameFrom to bOK
88040>>>>>>>        Loop
88041>>>>>>>>
88041>>>>>>>
88041>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88042>>>>>>>        Function_Return bOK
88043>>>>>>>    End_Function
88044>>>>>>>
88044>>>>>>>    Function UtilColumnIsDateType Integer iType Boolean bIsSQLTableTo Returns Boolean
88046>>>>>>>        Boolean bDateType
88046>>>>>>>
88046>>>>>>>        If (bIsSQLTableTo = True) Begin
88048>>>>>>>            Move (iType = SQL_TYPE_DATE or iType = SQL_TYPE_TIMESTAMP or iType = SQL_TYPE_TIMESTAMP2) to bDateType
88049>>>>>>>        End
88049>>>>>>>>
88049>>>>>>>        Else Begin
88050>>>>>>>            Move (iType = DF_DATE or iType = DF_DATETIME) to bDateType
88051>>>>>>>        End
88051>>>>>>>>
88051>>>>>>>
88051>>>>>>>        Function_Return bDateType
88052>>>>>>>    End_Function
88053>>>>>>>
88053>>>>>>>    Function ApiColumnsUpdate String sDriverIDFrom Handle hTable Boolean bIsSQLTableFrom tAPIColumn[] aColumnsFrom tAPIColumn[] aColumnsTo Boolean bCompareDate_DateTime Returns Boolean
88055>>>>>>>        Integer iCount iColumns iColumn iTypeFrom iTypeTo iDataFlexType iIndex iLengthFrom iLengthTo iPrecisionFrom iPrecisionTo iOptionFrom iOptionTo iDbType
88055>>>>>>>        Integer iCount2 iColumn2
88055>>>>>>>        Handle hFile
88055>>>>>>>        Boolean bFieldExistsFrom bFieldExistsTo bIsSQLDriver bIsSame bOK bSkip
88055>>>>>>>        Boolean bRecnum bIsSQLTableTo bRecnumTable bIsOpen bSkipTypeChange bIsDateType
88055>>>>>>>        String sFieldNameFrom sFieldNameTo sDriverIDTo sDefaultValue
88055>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare aApiInsertColumns aAPIMoveColumns aAPIRenameColumns aAPIRemoveColumns
88055>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare aApiInsertColumns aAPIMoveColumns aAPIRenameColumns aAPIRemoveColumns
88060>>>>>>>        tColumnType ColumnType
88060>>>>>>>        tColumnType ColumnType
88060>>>>>>>
88060>>>>>>>        Move False to Err
88061>>>>>>>        Close hTable
88062>>>>>>>        Get OpenTableExclusive hTable to bIsOpen
88063>>>>>>>        If (bIsOpen = False) Begin
88065>>>>>>>            Error DFERR_PROGRAM ("Function 'ApiColumnsUpdate'. Can't open table number:" * String(hTable))
88066>>>>>>>>
88066>>>>>>>            Function_Return False
88067>>>>>>>        End 
88067>>>>>>>>
88067>>>>>>>        
88067>>>>>>>        Get piDbType to iDbType
88068>>>>>>>        Get_Attribute DF_FILE_RECNUM_TABLE of hTable to bRecnumTable
88071>>>>>>>        Move bIsSQLTableFrom to bIsSQLDriver
88072>>>>>>>        Get UtilTableIsSQL hTable to bIsSQLTableTo
88073>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverIDTo
88076>>>>>>>
88076>>>>>>>        Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88077>>>>>>>
88077>>>>>>>        // Before we start to change the table we need to do three things;
88077>>>>>>>        // 1) Insert any new fields
88077>>>>>>>        Get UtilColumnsCheckForInserts hTable aAPIColumnCompare to aApiInsertColumns
88078>>>>>>>        If (SizeOfArray(aApiInsertColumns)) Begin
88080>>>>>>>            Get UtilColumnsInsert sDriverIDFrom hTable aApiInsertColumns to bOK
88081>>>>>>>            If (bOK = False) Begin
88083>>>>>>>                Function_Return False
88084>>>>>>>            End
88084>>>>>>>>
88084>>>>>>>            // Update info with changes made.
88084>>>>>>>            Get UtilColumnsStructFill hTable to aColumnsTo
88085>>>>>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88086>>>>>>>        End
88086>>>>>>>>
88086>>>>>>>
88086>>>>>>>        // 2) Move fields with same names
88086>>>>>>>        Get UtilColumnsCheckForMoves hTable aAPIColumnCompare to aAPIMoveColumns
88087>>>>>>>        If (SizeOfArray(aAPIMoveColumns)) Begin
88089>>>>>>>            Get UtilColumnsMove hTable aColumnsFrom aColumnsTo aAPIMoveColumns to bOK
88090>>>>>>>            If (bOK = False) Begin
88092>>>>>>>                Function_Return False
88093>>>>>>>            End
88093>>>>>>>>
88093>>>>>>>            Get UtilColumnsStructFill hTable to aColumnsTo
88094>>>>>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88095>>>>>>>        End
88095>>>>>>>>
88095>>>>>>>        
88095>>>>>>>        // 3) Rename fields
88095>>>>>>>        Get UtilColumnsCheckForRenames hTable aAPIColumnCompare to aAPIRenameColumns
88096>>>>>>>        If (SizeOfArray(aAPIRenameColumns)) Begin
88098>>>>>>>            Get UtilColumnsRename hTable aAPIRenameColumns to bOK
88099>>>>>>>            If (bOK = False) Begin
88101>>>>>>>                Function_Return False
88102>>>>>>>            End
88102>>>>>>>>
88102>>>>>>>            Get UtilColumnsStructFill hTable to aColumnsTo
88103>>>>>>>            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88104>>>>>>>        End
88104>>>>>>>>
88104>>>>>>>
88104>>>>>>>        // 4) Remove fields if more fields currently exists compared to the new table definition.
88104>>>>>>>//        Get utilColumnsCheckForRemoves hTable aAPIColumnCompare to aAPIRemoveColumns
88104>>>>>>>//        If (SizeOfArray(aAPIRemoveColumns)) Begin
88104>>>>>>>//            Get UtilColumnsRemove hTable aAPIRemoveColumns to bOK
88104>>>>>>>//            If (bOK = False) Begin
88104>>>>>>>//                Function_Return False
88104>>>>>>>//            End
88104>>>>>>>//            Get UtilColumnsStructFill hTable to aColumnsTo
88104>>>>>>>//            Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88104>>>>>>>//        End
88104>>>>>>>
88104>>>>>>>        // If any of the fields were changed by "Insert", "Rename" or "Move", we need to compare the fields again:
88104>>>>>>>        If (SizeOfArray(aApiInsertColumns) or SizeOfArray(aAPIRenameColumns) or SizeOfArray(aAPIMoveColumns)) Begin
88106>>>>>>>            Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom bIsSQLTableTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
88107>>>>>>>            If (bIsSame = True) Begin
88109>>>>>>>                Function_Return True
88110>>>>>>>            End
88110>>>>>>>>
88110>>>>>>>        End
88110>>>>>>>>
88110>>>>>>>
88110>>>>>>>        // We can now continue to make standard field changes:
88110>>>>>>>        Get OpenTableExclusive hTable to bIsOpen
88111>>>>>>>        Set Private.phCurrentTable to hTable
88112>>>>>>>        Move hTable to hFile
88113>>>>>>>        Structure_Start hFile sDriverIDTo
88114>>>>>>>
88114>>>>>>>            Move (SizeOfArray(aAPIColumnCompare)) to iColumns
88115>>>>>>>            Decrement iColumns
88116>>>>>>>            for iCount from 0 to iColumns
88122>>>>>>>>
88122>>>>>>>                Send DoAdvance of ghoProgressBar
88123>>>>>>>
88123>>>>>>>                Move aAPIColumnCompare[iCount].iFieldNumber to iColumn
88124>>>>>>>                Set Private.piCurrentField                  to iColumn
88125>>>>>>>                Get UtilColumnCompare sDriverIDFrom sDriverIDTo bIsSQLTableFrom aAPIColumnCompare[iCount].bIsSQLTypeTo aAPIColumnCompare[iCount] bCompareDate_DateTime to bIsSame
88126>>>>>>>                If (bIsSame = False) Begin
88128>>>>>>>
88128>>>>>>>                    Move aAPIColumnCompare[iCount].bExistsFrom          to bFieldExistsFrom
88129>>>>>>>                    If (bFieldExistsFrom = True) Begin
88131>>>>>>>                        Move aAPIColumnCompare[iCount].bExistsTo        to bFieldExistsTo
88132>>>>>>>                        Move aAPIColumnCompare[iCount].sFieldNameFrom   to sFieldNameFrom
88133>>>>>>>                        Move aAPIColumnCompare[iCount].iLengthFrom      to iLengthFrom
88134>>>>>>>                        Move aAPIColumnCompare[iCount].iPrecisionFrom   to iPrecisionFrom
88135>>>>>>>                        Move aAPIColumnCompare[iCount].iOptionsFrom     to iOptionFrom
88136>>>>>>>
88136>>>>>>>                        Move aAPIColumnCompare[iCount].iTypeFrom        to iTypeFrom
88137>>>>>>>                        Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iDataFlexType
88138>>>>>>>                        If (iTypeFrom < -1490) Begin
88140>>>>>>>                            Move (iTypeFrom + 1500)                     to iTypeFrom
88141>>>>>>>                        End
88141>>>>>>>>
88141>>>>>>>
88141>>>>>>>                        // If one of the two tables are SQL and the other Embedded we need to "translate"
88141>>>>>>>                        // data types between Embedded and SQL, else we can't compare the data types.
88141>>>>>>>                        If (bIsSQLTableFrom = True and bIsSQLTableTo = False) Begin
88143>>>>>>>                            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iTypeFrom iLengthFrom to iTypeFrom
88144>>>>>>>                            If (iTypeFrom = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
88146>>>>>>>                                Move DF_DATE to iTypeFrom
88147>>>>>>>                            End
88147>>>>>>>>
88147>>>>>>>                        End
88147>>>>>>>>
88147>>>>>>>                        Else If (bIsSQLTableFrom = False and bIsSQLTableTo = True) Begin
88150>>>>>>>                            Get UtilSqlColumnTypeToDataFlexType sDriverIDTo   iDbType iTypeTo   iLengthTo   to iTypeTo
88151>>>>>>>                        End
88151>>>>>>>>
88151>>>>>>>
88151>>>>>>>                        Move aAPIColumnCompare[iCount].sFieldNameTo to sFieldNameTo
88152>>>>>>>                        Move aAPIColumnCompare[iCount].iLengthTo    to iLengthTo
88153>>>>>>>                        Move aAPIColumnCompare[iCount].iPrecisionTo to iPrecisionTo
88154>>>>>>>                        Move aAPIColumnCompare[iCount].iOptionsTo   to iOptionTo
88155>>>>>>>                        Move aAPIColumnCompare[iCount].iTypeTo      to iTypeTo
88156>>>>>>>
88156>>>>>>>                        Move False to bSkipTypeChange
88157>>>>>>>                        If (bCompareDate_DateTime = False) Begin
88159>>>>>>>                            Move ((iTypeFrom = SQL_TYPE_DATE or iTypeFrom = SQL_TYPE_TIME or iTypeFrom = SQL_TYPE_TIMESTAMP) and (iTypeTo = SQL_TYPE_DATE or iTypeTo = SQL_TYPE_TIME or iTypeTo = SQL_TYPE_TIMESTAMP)) to bSkipTypeChange
88160>>>>>>>                        End
88160>>>>>>>>
88160>>>>>>>
88160>>>>>>>                        If (bFieldExistsTo = False) Begin
88162>>>>>>>                            Move 0 to iColumn
88163>>>>>>>                            Create_Field hFile At iColumn
88164>>>>>>>                            Set Private.piCurrentField to iColumn
88165>>>>>>>                        End
88165>>>>>>>>
88165>>>>>>>
88165>>>>>>>                        If (sFieldNameFrom <> sFieldNameTo) Begin
88167>>>>>>>                            Set_Attribute DF_FIELD_NAME of hFile iColumn to sFieldNameFrom
88170>>>>>>>                        End
88170>>>>>>>>
88170>>>>>>>
88170>>>>>>>                        If (bIsSQLTableFrom = True and bIsSQLTableTo = True and aAPIColumnCompare[iCount].iOptionsFrom <> C_tAPIColumn_Identity) Begin
88172>>>>>>>                            Set_Attribute DF_FIELD_NULL_ALLOWED  of hFile iColumn to aAPIColumnCompare[iCount].bAllowNULLFrom
88175>>>>>>>                            Move aAPIColumnCompare[iCount].sDefaultValueFrom to sDefaultValue
88176>>>>>>>                            If (iDataFlexType = DF_BCD and Left(String(sDefaultValue), 1) <> "[") Begin
88178>>>>>>>                                Move ("[" + String(sDefaultValue) + "]") to sDefaultValue
88179>>>>>>>                            End
88179>>>>>>>>
88179>>>>>>>                            Set_Attribute DF_FIELD_DEFAULT_VALUE of hFile iColumn to sDefaultValue
88182>>>>>>>                        End
88182>>>>>>>>
88182>>>>>>>
88182>>>>>>>                        If (bSkipTypeChange = False) Begin
88184>>>>>>>                            If (iTypeFrom <> iTypeTo) Begin
88186>>>>>>>                                If (bIsSQLTableTo = True) Begin
88188>>>>>>>                                    Set_Attribute DF_FIELD_NATIVE_TYPE of hFile iColumn to iTypeFrom
88191>>>>>>>                                End
88191>>>>>>>>
88191>>>>>>>                                Else Begin                                                   
88192>>>>>>>                                    If (iDataFlexType = DF_DATETIME) Begin // DateTime cannot be used by the embedded database.
88194>>>>>>>                                        Move DF_DATE to iDataFlexType  // Date
88195>>>>>>>                                    End
88195>>>>>>>>
88195>>>>>>>                                    Set_Attribute DF_FIELD_TYPE of hFile iColumn to iDataFlexType
88198>>>>>>>                                End
88198>>>>>>>>
88198>>>>>>>                            End
88198>>>>>>>>
88198>>>>>>>                        End
88198>>>>>>>>
88198>>>>>>>
88198>>>>>>>                        Get UtilColumnIsDateType iTypeFrom bIsSQLTableTo to bIsDateType
88199>>>>>>>                        // We can't set the length or precision for Date type columns (they are fixed).
88199>>>>>>>                        If (bIsDateType = False) Begin
88201>>>>>>>                            If (iLengthFrom <> iLengthTo) Begin
88203>>>>>>>                                Set_Attribute DF_FIELD_LENGTH of hFile iColumn to iLengthFrom
88206>>>>>>>                            End
88206>>>>>>>>
88206>>>>>>>                            If (iPrecisionFrom <> iPrecisionTo) Begin
88208>>>>>>>                                Set_Attribute DF_FIELD_PRECISION of hFile iColumn to iPrecisionFrom
88211>>>>>>>                            End
88211>>>>>>>>
88211>>>>>>>                        End
88211>>>>>>>>
88211>>>>>>>
88211>>>>>>>                        If (bIsSQLTableTo = True and iOptionFrom =  C_tAPIColumn_Identity and iOptionTo <> C_tAPIColumn_Identity) Begin
88213>>>>>>>                            // Can't set a recnum table to "DF_FIELD_IS_IDENTITY"
88213>>>>>>>                            If (bRecnumTable = True) Begin
88215>>>>>>>                                Set_Attribute DF_FILE_RECNUM_TABLE of hTable to False
88218>>>>>>>                            End
88218>>>>>>>>
88218>>>>>>>
88218>>>>>>>                            // We might need to create an index here.
88218>>>>>>>                            // To be able to set the DF_FIELD_IS_IDENTITY the index must already exist, but it might not at this stage.
88218>>>>>>>                            // This should probably fix that problem and if an adjustment is needed, it will get done with the normal
88218>>>>>>>                            // index update checking logic.
88218>>>>>>>                            Get_Attribute DF_FIELD_INDEX           of hFile iColumn to iIndex
88221>>>>>>>                            If (iIndex = 0 and Uppercase(sFieldNameTo) <> "RECNUM") Begin
88223>>>>>>>                                Create_Index hFile at iIndex
88224>>>>>>>                                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hFile iIndex to 1
88227>>>>>>>                            End
88227>>>>>>>>
88227>>>>>>>
88227>>>>>>>                            Set_Attribute DF_INDEX_SEGMENT_FIELD   of hFile iIndex 1 to iColumn
88230>>>>>>>                            Set_Attribute DF_FILE_PRIMARY_INDEX    of hFile          to iIndex
88233>>>>>>>                                // Note: The order of these two are crucial!
88233>>>>>>>                                Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hFile iIndex to True
88236>>>>>>>                                Set_Attribute DF_FIELD_IS_IDENTITY of hFile iColumn    to True
88239>>>>>>>                        End
88239>>>>>>>>
88239>>>>>>>                    End
88239>>>>>>>>
88239>>>>>>>                    Else Begin
88240>>>>>>>                        Delete_Field hFile iColumn
88241>>>>>>>                        Move (RemoveFromArray(aColumnsTo, iCount)) to aColumnsTo
88242>>>>>>>                        Move (SizeOfArray(aColumnsTo)) to iCount2
88243>>>>>>>                        Decrement iCount2
88244>>>>>>>                        // We need to adjust FieldNumbers in the array with one, as we just deleted a field,
88244>>>>>>>                        // starting with the array number we just deleted the field for.
88244>>>>>>>                        for iColumn2 from iCount to iCount2
88250>>>>>>>>
88250>>>>>>>                            Move (aColumnsTo[iColumn2].iFieldNumber - 1) to aColumnsTo[iColumn2].iFieldNumber
88251>>>>>>>                        Loop
88252>>>>>>>>
88252>>>>>>>                        Decrement iCount
88253>>>>>>>                        Get UtilColumnCombineFromAndToArrays aColumnsFrom aColumnsTo to aAPIColumnCompare
88254>>>>>>>                        Move (SizeOfArray(aAPIColumnCompare)) to iColumns
88255>>>>>>>                        If (SizeOfArray(aColumnsFrom) = SizeOfArray(aColumnsTo)) Begin
88257>>>>>>>                            Move iColumns to iCount 
88258>>>>>>>                        End
88258>>>>>>>>
88258>>>>>>>                    End
88258>>>>>>>>
88258>>>>>>>                End
88258>>>>>>>>
88258>>>>>>>            Loop
88259>>>>>>>>
88259>>>>>>>
88259>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88260>>>>>>>        Structure_End hFile DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88262>>>>>>>
88262>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88263>>>>>>>        Function_Return (Err = False)
88264>>>>>>>    End_Function
88265>>>>>>>
88265>>>>>>>    // * Dummy function for the Studio's Code Explorer *
88265>>>>>>>    Function API_INDEX_FUNCTIONS Returns Boolean
88267>>>>>>>        Function_Return False
88268>>>>>>>    End_Function
88269>>>>>>>
88269>>>>>>>    // Get ApiIndexCreate Customers.File_Number 1 2 0 1 -1 -1 -1 -1 -1 -1 -1 -1 to bOK
88269>>>>>>>    // Note: the "-1" can be left out as this function is overloaded to make it easier to call.
88269>>>>>>>    // Note: This doesn't set Descending attributes - Use function IndexChangeDirection to do that.
88269>>>>>>>    Function ApiIndexCreate Handle hTable Integer iIndex Integer iSegments Integer iSgmnt1 Integer iSgmnt2 Integer iSgmnt3 Integer iSgmnt4 Integer iSgmnt5 Integer iSgmnt6 Integer iSgmnt7 Integer iSgmnt8 Integer iSgmnt9 Integer iSgmnt10 Returns Boolean
88271>>>>>>>        Integer iTableNo iSegment1 iSegment2 iSegment3 iSegment4 iSegment5 iSegment6 iSegment7 iSegment8 iSegment9 iSegment10  iIndexSegments
88271>>>>>>>        String sDriverID
88271>>>>>>>        Boolean bOK bExists bIsMertechDriver bIsSQLTable
88271>>>>>>>
88271>>>>>>>        Get AutoConnectionIDLogin to bOK
88272>>>>>>>        Get OpenTableExclusive hTable to bOK
88273>>>>>>>        If (bOK = False) Begin
88275>>>>>>>            Function_Return False
88276>>>>>>>        End
88276>>>>>>>>
88276>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88279>>>>>>>
88279>>>>>>>            Get UtilTableIsSQL hTable to bIsSQLTable
88280>>>>>>>            If (bIsSQLTable = True) Begin
88282>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88285>>>>>>>            End
88285>>>>>>>>
88285>>>>>>>
88285>>>>>>>            Get IsMertechDriver sDriverID to bIsMertechDriver
88286>>>>>>>            If (bIsMertechDriver = True) Begin
88288>>>>>>>                Get_Attribute DF_INDEX_NATIVE_CREATED of hTable iIndex to bExists
88291>>>>>>>            End
88291>>>>>>>>
88291>>>>>>>            Else Begin
88292>>>>>>>                Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iIndexSegments
88295>>>>>>>                Move (iIndexSegments > 0) to bExists
88296>>>>>>>            End
88296>>>>>>>>
88296>>>>>>>        If (bExists = True) Begin
88298>>>>>>>            Function_Return True
88299>>>>>>>        End
88299>>>>>>>>
88299>>>>>>>
88299>>>>>>>        Move -1 to iSegment1
88300>>>>>>>        Move -1 to iSegment2
88301>>>>>>>        Move -1 to iSegment3
88302>>>>>>>        Move -1 to iSegment4
88303>>>>>>>        Move -1 to iSegment5
88304>>>>>>>        Move -1 to iSegment6
88305>>>>>>>        Move -1 to iSegment7
88306>>>>>>>        Move -1 to iSegment8
88307>>>>>>>        Move -1 to iSegment9
88308>>>>>>>        Move -1 to iSegment10
88309>>>>>>>
88309>>>>>>>        If (num_arguments > 3) Begin
88311>>>>>>>            Move iSgmnt1 to iSegment1
88312>>>>>>>        End
88312>>>>>>>>
88312>>>>>>>        If (num_arguments > 4) Begin
88314>>>>>>>            Move iSgmnt2 to iSegment2
88315>>>>>>>        End
88315>>>>>>>>
88315>>>>>>>        If (num_arguments > 5) Begin
88317>>>>>>>            Move iSgmnt3 to iSegment3
88318>>>>>>>        End
88318>>>>>>>>
88318>>>>>>>        If (num_arguments > 6) Begin
88320>>>>>>>            Move iSgmnt4 to iSegment4
88321>>>>>>>        End
88321>>>>>>>>
88321>>>>>>>        If (num_arguments > 7) Begin
88323>>>>>>>            Move iSgmnt5 to iSegment5
88324>>>>>>>        End
88324>>>>>>>>
88324>>>>>>>        If (num_arguments > 8) Begin
88326>>>>>>>            Move iSgmnt6 to iSegment6
88327>>>>>>>        End
88327>>>>>>>>
88327>>>>>>>        If (num_arguments > 9) Begin
88329>>>>>>>            Move iSgmnt7 to iSegment7
88330>>>>>>>        End
88330>>>>>>>>
88330>>>>>>>        If (num_arguments > 10) Begin
88332>>>>>>>            Move iSgmnt8 to iSegment8
88333>>>>>>>        End
88333>>>>>>>>
88333>>>>>>>        If (num_arguments > 11) Begin
88335>>>>>>>            Move iSgmnt9 to iSegment9
88336>>>>>>>        End
88336>>>>>>>>
88336>>>>>>>        If (num_arguments > 12) Begin
88338>>>>>>>            Move iSgmnt10 to iSegment10
88339>>>>>>>        End
88339>>>>>>>>
88339>>>>>>>
88339>>>>>>>        Move False to Err
88340>>>>>>>        Move hTable to iTableNo
88341>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88342>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
88343>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_NON_FATAL_RESTRUCTURE_ERROR
88344>>>>>>>
88344>>>>>>>        // We start by deleting the index, if it exists.
88344>>>>>>>        If (bExists = True) Begin
88346>>>>>>>            Structure_Start hTable sDriverID
88347>>>>>>>                Delete_Index iTableNo iIndex
88348>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
88349>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88351>>>>>>>        End
88351>>>>>>>>
88351>>>>>>>
88351>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
88352>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
88353>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_NON_FATAL_RESTRUCTURE_ERROR
88354>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88355>>>>>>>        Move False to Err
88356>>>>>>>        Move 0 to LastErr
88357>>>>>>>
88357>>>>>>>        // Need to re-open if index deleted.
88357>>>>>>>        Move iTableNo to hTable
88358>>>>>>>        Get OpenTableExclusive hTable to bOK
88359>>>>>>>        If (bOK = False) Begin
88361>>>>>>>            Function_Return False
88362>>>>>>>        End
88362>>>>>>>>
88362>>>>>>>
88362>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88363>>>>>>>        Structure_Start hTable sDriverID
88364>>>>>>>            Create_Index hTable At iIndex
88365>>>>>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iSegments
88368>>>>>>>
88368>>>>>>>            If (iSgmnt1 <> -1) Begin
88370>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 1 to iSegment1
88373>>>>>>>            End
88373>>>>>>>>
88373>>>>>>>            If (iSegment2 <> -1) Begin
88375>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 2 to iSegment2
88378>>>>>>>            End
88378>>>>>>>>
88378>>>>>>>            If (iSegment3 <> -1) Begin
88380>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 3 to iSegment3
88383>>>>>>>            End
88383>>>>>>>>
88383>>>>>>>            If (iSegment4 <> -1) Begin
88385>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 4 to iSegment4
88388>>>>>>>            End
88388>>>>>>>>
88388>>>>>>>            If (iSegment5 <> -1) Begin
88390>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 5 to iSegment5
88393>>>>>>>            End
88393>>>>>>>>
88393>>>>>>>            If (iSegment6 <> -1) Begin
88395>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 6 to iSegment6
88398>>>>>>>            End
88398>>>>>>>>
88398>>>>>>>            If (iSegment7 <> -1) Begin
88400>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 7 to iSegment7
88403>>>>>>>            End
88403>>>>>>>>
88403>>>>>>>            If (iSegment8 <> -1) Begin
88405>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 8 to iSegment8
88408>>>>>>>            End
88408>>>>>>>>
88408>>>>>>>            If (iSegment9 <> -1) Begin
88410>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 9 to iSegment9
88413>>>>>>>            End
88413>>>>>>>>
88413>>>>>>>            If (iSegment10 <> -1) Begin
88415>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex 10 to iSegment10
88418>>>>>>>            End
88418>>>>>>>>
88418>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88419>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88421>>>>>>>
88421>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88422>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88423>>>>>>>
88423>>>>>>>        Function_Return (Err = False)
88424>>>>>>>    End_Function
88425>>>>>>>
88425>>>>>>>    // Example:
88425>>>>>>>    // Get ApiIndexCreateEx hTable 1 (StrSplitToArray("1,5,6,7,8,2,3,4,10,9,11", ",")) to bOk
88425>>>>>>>    // Note: The StrSplitToArray function was introduced with DataFlex 18.2
88425>>>>>>>    Function ApiIndexCreateEx Handle hTable Integer iIndex Integer[] iSgmnts Returns Boolean
88427>>>>>>>        Integer iTableNo iNumSgmnt iNumSgmnts
88427>>>>>>>        String sDriverID
88427>>>>>>>        Boolean bOK bIsSQLTable
88427>>>>>>>
88427>>>>>>>        Get AutoConnectionIDLogin to bOK
88428>>>>>>>
88428>>>>>>>        Move False to Err
88429>>>>>>>        Move hTable to iTableNo
88430>>>>>>>        Get OpenTableExclusive hTable to bOK
88431>>>>>>>        If (bOK = False) Begin
88433>>>>>>>            Function_Return False
88434>>>>>>>        End
88434>>>>>>>>
88434>>>>>>>
88434>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88437>>>>>>>            Get UtilTableIsSQL hTable to bIsSQLTable
88438>>>>>>>            If (bIsSQLTable = True) Begin
88440>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88443>>>>>>>            End
88443>>>>>>>>
88443>>>>>>>
88443>>>>>>>        // We start by deleting the index
88443>>>>>>>        Structure_Start hTable sDriverID
88444>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88445>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
88446>>>>>>>            Delete_Index iTableNo iIndex
88447>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
88448>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
88449>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
88451>>>>>>>
88451>>>>>>>        Move False to Err
88452>>>>>>>        Move iTableNo to hTable
88453>>>>>>>        Get OpenTableExclusive hTable to bOK
88454>>>>>>>        If (bOK = False) Begin
88456>>>>>>>            Function_Return False
88457>>>>>>>        End
88457>>>>>>>>
88457>>>>>>>
88457>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88458>>>>>>>        Structure_Start hTable sDriverID
88459>>>>>>>            Move (SizeOfArray(iSgmnts)) to iNumSgmnts
88460>>>>>>>
88460>>>>>>>            Create_Index hTable at iIndex
88461>>>>>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSgmnts
88464>>>>>>>
88464>>>>>>>            for iNumSgmnt from 0 to (iNumSgmnts - 1)
88470>>>>>>>>
88470>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD of hTable iIndex (iNumSgmnt + 1) to iSgmnts[iNumSgmnt]
88473>>>>>>>            Loop
88474>>>>>>>>
88474>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE
88476>>>>>>>
88476>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
88477>>>>>>>
88477>>>>>>>        Function_Return (Err = False)
88478>>>>>>>    End_Function
88479>>>>>>>
88479>>>>>>>    Function APIIndexCreateByFieldNames Handle hTable tAPIIndex APIIndex tAPIIndex[] APIIndexTo tAPIIndexSegment[] aIndexSegments Returns Boolean
88481>>>>>>>        Integer iCount iSegmentsFrom iFieldFrom iSegmentsTo iSQLIndexType iTableNo
88481>>>>>>>        String sDriverID sSQLIndexName
88481>>>>>>>        Boolean bOK bIsSQLTable bIsOpen bIsSQLPrimaryKey bIsSQLClustered bIsSQLTemporaryIndex bExists
88481>>>>>>>
88481>>>>>>>        Move (SizeOfArray(aIndexSegments)) to iSegmentsFrom
88482>>>>>>>        If (iSegmentsFrom = 0) Begin
88484>>>>>>>            Function_Return False
88485>>>>>>>        End
88485>>>>>>>>
88485>>>>>>>
88485>>>>>>>        Get AutoConnectionIDLogin to bOK
88486>>>>>>>        Move False to Err
88487>>>>>>>        Get OpenTableExclusive hTable to bIsOpen
88488>>>>>>>        If (bIsOpen = False) Begin
88490>>>>>>>            Function_Return False
88491>>>>>>>        End
88491>>>>>>>>
88491>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88494>>>>>>>        Get UtilTableIsSql hTable to bIsSQLTable
88495>>>>>>>            If (bIsSQLTable = True) Begin
88497>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88500>>>>>>>            End
88500>>>>>>>>
88500>>>>>>>
88500>>>>>>>        Move 0     to iSegmentsTo
88501>>>>>>>        Move 0     to iSQLIndexType
88502>>>>>>>        Move ""    to sSQLIndexName
88503>>>>>>>        Move False to bIsSQLTemporaryIndex
88504>>>>>>>        Move False to bIsSQLPrimaryKey
88505>>>>>>>        Move False to bIsSQLClustered
88506>>>>>>>
88506>>>>>>>            Get UtilIndexTempRenameSQLName hTable APIIndex.sSQLIndexName sDriverID          to bOK
88507>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber              to iSegmentsTo
88510>>>>>>>        Move (iSegmentsTo > 0) to bExists
88511>>>>>>>        If (bExists = True) Begin
88513>>>>>>>            If (bIsSQLTable = True and iSegmentsTo > 0) Begin
88515>>>>>>>                Get_Attribute DF_INDEX_NAME of hTable APIIndex.iIndexNumber                 to sSQLIndexName
88518>>>>>>>                    Get_Attribute DF_INDEX_SQL_TYPE of hTable APIIndex.iIndexNumber         to iSQLIndexType
88521>>>>>>>                    Move (iSQLIndexType = DF_INDEX_TEMPORARY)                               to bIsSQLTemporaryIndex
88522>>>>>>>                    Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex.iIndexNumber  to bIsSQLPrimaryKey
88525>>>>>>>                    Get_Attribute DF_INDEX_CLUSTERED       of hTable APIIndex.iIndexNumber  to bIsSQLClustered
88528>>>>>>>            End
88528>>>>>>>>
88528>>>>>>>        End
88528>>>>>>>>
88528>>>>>>>
88528>>>>>>>        Move hTable to iTableNo
88529>>>>>>>        Move False to Err
88530>>>>>>>        Move 0 to LastErr
88531>>>>>>>
88531>>>>>>>        // Note: If the SQL index type = DF_INDEX_TEMPORARY, we _must_ set the DF_INDEX_SQL_TYPE
88531>>>>>>>        //       _outside_ the Structure_Start/End construct.
88531>>>>>>>//        Move False to bIsSQLTemporaryIndex
88531>>>>>>>//        #IF (!@ > 170)
88531>>>>>>>//            If (bIsSQLTemporaryIndex = True and APIIndex.iIndexNumber <= iLastIndex) Begin
88531>>>>>>>//                If (APIIndex.iSQLIndexType <> iSQLIndexType) Begin
88531>>>>>>>//                    Set_Attribute DF_INDEX_SQL_TYPE of hTable APIIndex.iIndexNumber to APIIndex.iSQLIndexType // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
88531>>>>>>>//                End
88531>>>>>>>//            End
88531>>>>>>>//        #ENDIF
88531>>>>>>>
88531>>>>>>>        Structure_Start hTable sDriverID
88532>>>>>>>            If (bExists = True) Begin
88534>>>>>>>                Delete_Index iTableNo APIIndex.iIndexNumber
88535>>>>>>>            End
88535>>>>>>>>
88535>>>>>>>
88535>>>>>>>            Create_Index hTable At APIIndex.iIndexNumber
88536>>>>>>>
88536>>>>>>>            If (bIsSQLTable = True) Begin // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
88538>>>>>>>                Set_Attribute DF_INDEX_SQL_TYPE        of hTable APIIndex.iIndexNumber to APIIndex.iSQLIndexType
88541>>>>>>>                Set_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex.iIndexNumber to APIIndex.bIsSQLPrimaryKey
88544>>>>>>>                Set_Attribute DF_INDEX_CLUSTERED       of hTable APIIndex.iIndexNumber to APIIndex.bIsSQLClustered
88547>>>>>>>                Set_Attribute DF_INDEX_NAME            of hTable APIIndex.iIndexNumber to APIIndex.sSQLIndexName
88550>>>>>>>            End
88550>>>>>>>>
88550>>>>>>>
88550>>>>>>>                    Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable APIIndex.iIndexNumber to iSegmentsFrom
88553>>>>>>>
88553>>>>>>>            for iCount from 0 to (iSegmentsFrom -1)
88559>>>>>>>>
88559>>>>>>>                Move aIndexSegments[iCount].iFieldNumber to iFieldFrom
88560>>>>>>>                If (iFieldFrom <> -1 ) Begin
88562>>>>>>>                        Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable APIIndex.iIndexNumber (iCount +1) to iFieldFrom
88565>>>>>>>                        Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable APIIndex.iIndexNumber (iCount +1) to aIndexSegments[iCount].bAscending
88568>>>>>>>                        Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable APIIndex.iIndexNumber (iCount +1) to aIndexSegments[iCount].bUppercase
88571>>>>>>>                End
88571>>>>>>>>
88571>>>>>>>            Loop
88572>>>>>>>>
88572>>>>>>>
88572>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88573>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88575>>>>>>>
88575>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88576>>>>>>>
88576>>>>>>>        Function_Return (Err = False)
88577>>>>>>>    End_Function
88578>>>>>>>
88578>>>>>>>    // If an SQL index is to be renamed we need to check that the name doesn't exist already, but
88578>>>>>>>    // with another index number. If we find one we temporarily renames it by adding "TMP" to the SQL name.
88578>>>>>>>    Function UtilIndexTempRenameSQLName Handle hTable String sSQLIndexName String sDriverID Returns Boolean
88580>>>>>>>        Integer iLastIndex iCount iTableNo iSegments
88580>>>>>>>        String sSQLIndexNameCompare sTmpIndexName
88580>>>>>>>        Boolean bIsOpen bExists bIsSQLDriver bIsMertechDriver
88580>>>>>>>
88580>>>>>>>        // The Mertech drivers DF_INDEX_NAME property is read_only,
88580>>>>>>>        // so we can then not rename the index.
88580>>>>>>>        Get IsMertechDriver sDriverID to bIsMertechDriver
88581>>>>>>>        If (bIsMertechDriver = True) Begin
88583>>>>>>>            Function_Return False
88584>>>>>>>        End    
88584>>>>>>>>
88584>>>>>>>        Get IsSQLDriver sDriverID to bIsSQLDriver
88585>>>>>>>        
88585>>>>>>>        If (bIsSQLDriver = False) Begin
88587>>>>>>>            Function_Return False
88588>>>>>>>        End
88588>>>>>>>>
88588>>>>>>>
88588>>>>>>>        Move False to Err
88589>>>>>>>        Move hTable to iTableNo
88590>>>>>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
88593>>>>>>>        for iCount from 0 to iLastIndex
88599>>>>>>>>
88599>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iCount to iSegments
88602>>>>>>>            Move (iSegments > 0) to bExists
88603>>>>>>>            If (bExists = True) Begin
88605>>>>>>>                Get_Attribute DF_INDEX_NAME of hTable iCount to sSQLIndexNameCompare
88608>>>>>>>                If (Lowercase(sSQLIndexName) = Lowercase(sSQLIndexNameCompare)) Begin
88610>>>>>>>                    Move (sSQLIndexNameCompare + String("_TMP")) to sTmpIndexName
88611>>>>>>>                    Structure_Start iTableNo sDriverID
88612>>>>>>>                        Set_Attribute DF_INDEX_NAME of iTableNo iCount to sTmpIndexName
88615>>>>>>>                    Structure_End iTableNo DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88617>>>>>>>                    Open hTable
88619>>>>>>>                End
88619>>>>>>>>
88619>>>>>>>            End
88619>>>>>>>>
88619>>>>>>>        Loop
88620>>>>>>>>
88620>>>>>>>
88620>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
88623>>>>>>>        If (bIsOpen = False) Begin
88625>>>>>>>            Get OpenTableExclusive hTable to bIsOpen
88626>>>>>>>        End
88626>>>>>>>>
88626>>>>>>>        If (bIsOpen = False) Begin
88628>>>>>>>            Function_Return False
88629>>>>>>>        End
88629>>>>>>>>
88629>>>>>>>
88629>>>>>>>        Function_Return (Err = False)
88630>>>>>>>    End_Function
88631>>>>>>>
88631>>>>>>>    // Checks if an SQL Index name for the "FROM" database already exists in the TO database,
88631>>>>>>>    // but with another Index number. We can then not rename the SQL index name for the TO database table.
88631>>>>>>>    Function UtilIndexSQLIndexNameExists Handle hTable Integer iIndexNumberFrom String sSQLIndexNameFrom tAPIIndex[] APIIndexTo Returns Integer
88633>>>>>>>        Integer iSize iCount
88633>>>>>>>        Integer iRetVal
88633>>>>>>>
88633>>>>>>>        Move 0 to iRetVal
88634>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndexNumberFrom to iRetVal
88637>>>>>>>        If (iRetVal = 0) Begin
88639>>>>>>>            Function_Return 0
88640>>>>>>>        End
88640>>>>>>>>
88640>>>>>>>        Move (SizeOfArray(APIIndexTo)) to iSize
88641>>>>>>>        Decrement iSize
88642>>>>>>>        for iCount from 0 to iSize
88648>>>>>>>>
88648>>>>>>>            If (Uppercase(sSQLIndexNameFrom) = Uppercase(APIIndexTo[iCount].sSQLIndexName)) Begin
88650>>>>>>>                If (iIndexNumberFrom <> APIIndexTo[iCount].iIndexNumber) Begin
88652>>>>>>>                    Move APIIndexTo[iCount].iIndexNumber to iRetVal
88653>>>>>>>                End
88653>>>>>>>>
88653>>>>>>>            End
88653>>>>>>>>
88653>>>>>>>        Loop
88654>>>>>>>>
88654>>>>>>>
88654>>>>>>>        Function_Return iRetVal
88655>>>>>>>    End_Function
88656>>>>>>>
88656>>>>>>>    Function ApiIndexDeleteSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
88658>>>>>>>        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
88658>>>>>>>        Boolean bIsSQLTable
88658>>>>>>>        
88658>>>>>>>            Get UtilTableIsSQL hTable to bIsSQLTable
88659>>>>>>>            If (bIsSQLTable = True) Begin
88661>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88664>>>>>>>            End
88664>>>>>>>>
88664>>>>>>>
88664>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88667>>>>>>>        If (iSegment = iNumSegments) Begin
88669>>>>>>>//            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
88669>>>>>>>        End
88669>>>>>>>>
88669>>>>>>>
88669>>>>>>>        Else If (iSegment > 0 and iSegment < iNumSegments) Begin
88672>>>>>>>            for iCurSegment from iSegment to (iNumSegments - 1)
88678>>>>>>>>
88678>>>>>>>                //*** Move index segment attributes
88678>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
88681>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
88684>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
88687>>>>>>>
88687>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment to iSegmentCase
88690>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment to iSegmentDirection
88693>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment to iSegmentColumn
88696>>>>>>>            Loop
88697>>>>>>>>
88697>>>>>>>
88697>>>>>>>            Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
88700>>>>>>>        End
88700>>>>>>>>
88700>>>>>>>
88700>>>>>>>        Function_Return (Err = False)
88701>>>>>>>    End_Function
88702>>>>>>>
88702>>>>>>>    Function APIIndexRemoveAllIndexes Handle hTable tAPIIndex[] APIIndex Returns Boolean
88704>>>>>>>        Integer iCount iSize iIndex
88704>>>>>>>        String sDriverID
88704>>>>>>>        Boolean bOK bIsSQLTable bIsOpen
88704>>>>>>>
88704>>>>>>>        Move (SizeOfArray(APIIndex)) to iSize
88705>>>>>>>        If (iSize = 0) Begin
88707>>>>>>>            Function_Return True
88708>>>>>>>        End
88708>>>>>>>>
88708>>>>>>>
88708>>>>>>>        Get AutoConnectionIDLogin to bOK
88709>>>>>>>        Move False to Err
88710>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
88713>>>>>>>        If (bIsOpen = False) Begin
88715>>>>>>>            Get OpenTableExclusive hTable to bIsOpen
88716>>>>>>>            If (bIsOpen = False) Begin
88718>>>>>>>                Function_Return False
88719>>>>>>>            End
88719>>>>>>>>
88719>>>>>>>        End
88719>>>>>>>>
88719>>>>>>>
88719>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88722>>>>>>>        Get UtilTableIsSql hTable to bIsSQLTable
88723>>>>>>>            If (bIsSQLTable = True) Begin
88725>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88728>>>>>>>            End
88728>>>>>>>>
88728>>>>>>>
88728>>>>>>>        Move False to Err
88729>>>>>>>        Move 0 to LastErr
88730>>>>>>>        Decrement iSize
88731>>>>>>>
88731>>>>>>>        Structure_Start hTable sDriverID
88732>>>>>>>            for iCount from 0 to iSize
88738>>>>>>>>
88738>>>>>>>//                Move False to bIsSQLPrimaryKey
88738>>>>>>>//                #IF (!@ > 180)   // DF 18.1 and up
88738>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_NO_REPORT
88738>>>>>>>//                    Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable APIIndex[iCount].iIndexNumber to bIsSQLPrimaryKey
88738>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
88738>>>>>>>//                #ENDIF
88738>>>>>>>                // We can't delete if this is a primary key index:
88738>>>>>>>//                If (bIsSQLPrimaryKey = False) Begin
88738>>>>>>>                    Move APIIndex[iCount].iIndexNumber to iIndex
88739>>>>>>>                    Delete_Index hTable iIndex
88740>>>>>>>//                    Set Error_Report_Mode to DUF_ERROR_REPORT
88740>>>>>>>//                End
88740>>>>>>>            Loop
88741>>>>>>>>
88741>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88742>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88744>>>>>>>//        Move False to Err
88744>>>>>>>        Move 0 to LastErr
88745>>>>>>>
88745>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88746>>>>>>>        Function_Return (Err = False)
88747>>>>>>>    End_Function
88748>>>>>>>
88748>>>>>>>    Function ApiIndexChangeDirection Handle hTable Integer iIndex Integer iSegment Integer iDirection Returns Boolean
88750>>>>>>>        Boolean bOK
88750>>>>>>>
88750>>>>>>>        Get AutoConnectionIDLogin to bOK
88751>>>>>>>        Move False to Err
88752>>>>>>>        Get OpenTableExclusive hTable to bOK
88753>>>>>>>        If (bOK = False) Begin
88755>>>>>>>            Function_Return False
88756>>>>>>>        End
88756>>>>>>>>
88756>>>>>>>        Structure_Start hTable
88757>>>>>>>            Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to iDirection
88760>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88761>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88763>>>>>>>
88763>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88764>>>>>>>        Function_Return (Err = False)
88765>>>>>>>    End_Function
88766>>>>>>>
88766>>>>>>>    Function ApiIndexChangeUppercase Handle hTable Integer iIndex Integer iSegment Boolean bUppercase Returns Boolean
88768>>>>>>>        Integer iCase
88768>>>>>>>        Boolean bOK
88768>>>>>>>
88768>>>>>>>        If (bUppercase = True) Begin
88770>>>>>>>            Move DF_CASE_IGNORED to iCase
88771>>>>>>>        End
88771>>>>>>>>
88771>>>>>>>        Else Begin
88772>>>>>>>            Move DF_CASE_USED to iCase
88773>>>>>>>        End
88773>>>>>>>>
88773>>>>>>>
88773>>>>>>>        Get AutoConnectionIDLogin to bOK
88774>>>>>>>        Move False to Err
88775>>>>>>>        Get OpenTableExclusive hTable to bOK
88776>>>>>>>        If (bOK = False) Begin
88778>>>>>>>            Function_Return False
88779>>>>>>>        End
88779>>>>>>>>
88779>>>>>>>        Structure_Start hTable
88780>>>>>>>            Set_Attribute DF_INDEX_SEGMENT_CASE of hTable iIndex iSegment to iCase
88783>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88784>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88786>>>>>>>
88786>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88787>>>>>>>        Function_Return (Err = False)
88788>>>>>>>    End_Function
88789>>>>>>>
88789>>>>>>>    // To delete an index
88789>>>>>>>    Function ApiIndexRemove Handle hTable Integer iIndex Returns Boolean
88791>>>>>>>        Integer iTableNo iNumSegments
88791>>>>>>>        String sDriverID
88791>>>>>>>        Boolean bOK bIsSQLTable
88791>>>>>>>
88791>>>>>>>        Get AutoConnectionIDLogin to bOK
88792>>>>>>>        Move False to Err
88793>>>>>>>        Move hTable to iTableNo
88794>>>>>>>        Get OpenTableExclusive hTable to bOK
88795>>>>>>>        If (bOK = False) Begin
88797>>>>>>>            Function_Return False
88798>>>>>>>        End
88798>>>>>>>>
88798>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
88801>>>>>>>            Get UtilTableIsSQL hTable to bIsSQLTable
88802>>>>>>>            If (bIsSQLTable = True) Begin
88804>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88807>>>>>>>            End
88807>>>>>>>>
88807>>>>>>>
88807>>>>>>>        // Check to see if the index exists or not...
88807>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88810>>>>>>>        If (iNumSegments = 0) Begin
88812>>>>>>>            Function_Return True // Then nothing to do.
88813>>>>>>>        End
88813>>>>>>>>
88813>>>>>>>
88813>>>>>>>        Structure_Start hTable sDriverID
88814>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_PARAMETER
88815>>>>>>>            Delete_Index iTableNo iIndex
88816>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_PARAMETER
88817>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
88818>>>>>>>        Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88820>>>>>>>
88820>>>>>>>        Set Action_Text of ghoStatusPanel to ""
88821>>>>>>>        Function_Return (Err = False)
88822>>>>>>>    End_Function
88823>>>>>>>
88823>>>>>>>    // Delete an Index Segment
88823>>>>>>>    Function ApiIndexRemoveSegment Handle hTable Integer iIndex Integer iSegment Returns Boolean
88825>>>>>>>        Boolean bOK bSQLDriver bIndexTemporary bIsSQLTable
88825>>>>>>>        Integer iNumSegments iCurSegment iSegmentCase iSegmentDirection iSegmentColumn
88825>>>>>>>        Integer iIndexType
88825>>>>>>>        String sDriverID
88825>>>>>>>
88825>>>>>>>        Get AutoConnectionIDLogin to bOK
88826>>>>>>>        Move False to Err
88827>>>>>>>
88827>>>>>>>        Get OpenTableExclusive hTable to bOK
88828>>>>>>>        If (bOK = False) Begin
88830>>>>>>>            Function_Return False
88831>>>>>>>        End
88831>>>>>>>>
88831>>>>>>>
88831>>>>>>>            Get UtilTableIsSQL hTable to bIsSQLTable
88832>>>>>>>            If (bIsSQLTable = True) Begin
88834>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88837>>>>>>>            End
88837>>>>>>>>
88837>>>>>>>
88837>>>>>>>        // Check to see if the index exists or not...
88837>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88840>>>>>>>        If (iNumSegments = 0) Begin
88842>>>>>>>            Function_Return False
88843>>>>>>>        End
88843>>>>>>>>
88843>>>>>>>
88843>>>>>>>        Move False to bIndexTemporary
88844>>>>>>>        Get psDriverID to sDriverID
88845>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
88846>>>>>>>        If (bSQLDriver) Begin
88848>>>>>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
88851>>>>>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
88854>>>>>>>                Move True to bIndexTemporary
88855>>>>>>>        End
88855>>>>>>>>
88855>>>>>>>
88855>>>>>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
88855>>>>>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
88857>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88860>>>>>>>            If (iSegment = iNumSegments) Begin
88862>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
88865>>>>>>>            End
88865>>>>>>>>
88865>>>>>>>            Else If (iSegment > 0 and iSegment < iNumSegments) Begin
88868>>>>>>>                For iCurSegment from iSegment to (iNumSegments - 1)
88874>>>>>>>>
88874>>>>>>>                    //*** Move index segment attributes
88874>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
88877>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
88880>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
88883>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
88886>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
88889>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
88892>>>>>>>                Loop
88893>>>>>>>>
88893>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
88896>>>>>>>            End
88896>>>>>>>>
88896>>>>>>>        End
88896>>>>>>>>
88896>>>>>>>
88896>>>>>>>        Else Begin
88897>>>>>>>           Structure_Start hTable
88898>>>>>>>               Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88901>>>>>>>               If (iSegment = iNumSegments) Begin
88903>>>>>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
88906>>>>>>>               End
88906>>>>>>>>
88906>>>>>>>               Else If (iSegment > 0 and iSegment < iNumSegments) Begin
88909>>>>>>>                   for iCurSegment from iSegment to (iNumSegments - 1)
88915>>>>>>>>
88915>>>>>>>                       //*** Move index segment attributes
88915>>>>>>>                       Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment + 1) to iSegmentCase
88918>>>>>>>                       Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment + 1) to iSegmentDirection
88921>>>>>>>                       Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment + 1) to iSegmentColumn
88924>>>>>>>                       Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
88927>>>>>>>                       Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
88930>>>>>>>                       Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
88933>>>>>>>                   Loop
88934>>>>>>>>
88934>>>>>>>                   Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments - 1)
88937>>>>>>>               End
88937>>>>>>>>
88937>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
88938>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
88940>>>>>>>            Set Action_Text of ghoStatusPanel to ""
88941>>>>>>>        End
88941>>>>>>>>
88941>>>>>>>
88941>>>>>>>        Function_Return (Err = False)
88942>>>>>>>    End_Function
88943>>>>>>>
88943>>>>>>>    // Add/Insert an Index Segment
88943>>>>>>>    Function ApiIndexInsertSegment Handle hTable Integer iIndex Integer iSegment Integer iSegmentColumn Integer iSegmentCase Integer iSegmentDirection Returns Boolean
88945>>>>>>>        Boolean bOK bSQLDriver bIndexTemporary bIsSQLTable
88945>>>>>>>        Integer iNumSegments iCurSegment iCurSegmentColumn iCurSegmentCase iCurSegmentDirection
88945>>>>>>>        Integer iIndexType
88945>>>>>>>        String sDriverId
88945>>>>>>>
88945>>>>>>>        Get AutoConnectionIDLogin to bOK
88946>>>>>>>        Move False to Err
88947>>>>>>>
88947>>>>>>>        Get OpenTableExclusive hTable to bOK
88948>>>>>>>        If (bOK = False) Begin
88950>>>>>>>            Function_Return False
88951>>>>>>>        End
88951>>>>>>>>
88951>>>>>>>
88951>>>>>>>            Get UtilTableIsSQL hTable to bIsSQLTable
88952>>>>>>>            If (bIsSQLTable = True) Begin
88954>>>>>>>                Set_Attribute DF_FILE_ALLOWED_STRUCTURE_CHANGES of hTable to ALL_TABLE_CHANGES_ALLOWED
88957>>>>>>>            End
88957>>>>>>>>
88957>>>>>>>
88957>>>>>>>        Move False to bIndexTemporary
88958>>>>>>>        // Check to see if the index exists or not...
88958>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88961>>>>>>>        If (iNumSegments = 0) Begin
88963>>>>>>>            Function_Return False
88964>>>>>>>        End
88964>>>>>>>>
88964>>>>>>>
88964>>>>>>>        Get psDriverID to sDriverID
88965>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
88966>>>>>>>        If (bSQLDriver) Begin
88968>>>>>>>           Get_Attribute DF_INDEX_TYPE of hTable iIndex to iIndexType
88971>>>>>>>                Get_Attribute DF_INDEX_TYPE to iIndexType
88974>>>>>>>                Move True to bIndexTemporary
88975>>>>>>>        End
88975>>>>>>>>
88975>>>>>>>
88975>>>>>>>        // If SQL and Temporary Index must not use Structure_Start/Structure_End
88975>>>>>>>        If (bSQLDriver = True and bIndexTemporary = True) Begin
88977>>>>>>>           Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
88980>>>>>>>
88980>>>>>>>           If (iSegment > iNumSegments) Begin
88982>>>>>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
88985>>>>>>>               Move (iNumSegments + 1) to iCurSegment
88986>>>>>>>           End
88986>>>>>>>>
88986>>>>>>>           Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
88989>>>>>>>               Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
88992>>>>>>>               Move iNumSegments to iCurSegment
88993>>>>>>>
88993>>>>>>>               While (iCurSegment > iSegment)
88997>>>>>>>                   //*** Move index segment attributes
88997>>>>>>>                   Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iCurSegmentCase
89000>>>>>>>                   Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iCurSegmentDirection
89003>>>>>>>                   Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
89006>>>>>>>                   Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iCurSegmentCase
89009>>>>>>>                   Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iCurSegmentDirection
89012>>>>>>>                   Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iCurSegmentColumn
89015>>>>>>>                   Decrement iCurSegment
89016>>>>>>>               Loop
89017>>>>>>>>
89017>>>>>>>
89017>>>>>>>               //*** Now set new segment attributes
89017>>>>>>>               Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
89020>>>>>>>               Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
89023>>>>>>>               Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
89026>>>>>>>           End
89026>>>>>>>>
89026>>>>>>>        End
89026>>>>>>>>
89026>>>>>>>
89026>>>>>>>        Else Begin
89027>>>>>>>        Structure_Start hTable
89028>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
89031>>>>>>>
89031>>>>>>>            If (iSegment > iNumSegments) Begin
89033>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
89036>>>>>>>                Move (iNumSegments + 1) to iCurSegment
89037>>>>>>>            End
89037>>>>>>>>
89037>>>>>>>            Else If (iSegment > 0 and iSegment <= iNumSegments) Begin
89040>>>>>>>                Set_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to (iNumSegments + 1)
89043>>>>>>>                Move iNumSegments to iCurSegment
89044>>>>>>>
89044>>>>>>>                While (iCurSegment > iSegment)
89048>>>>>>>                    //*** Move index segment attributes
89048>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex (iCurSegment - 1) to iSegmentCase
89051>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex (iCurSegment - 1) to iSegmentDirection
89054>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex (iCurSegment - 1) to iSegmentColumn
89057>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iCurSegment       to iSegmentCase
89060>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iCurSegment       to iSegmentDirection
89063>>>>>>>                    Set_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iCurSegment       to iSegmentColumn
89066>>>>>>>                    Decrement iCurSegment
89067>>>>>>>                Loop
89068>>>>>>>>
89068>>>>>>>
89068>>>>>>>                //*** Now set new segment attributes
89068>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_CASE          of hTable iIndex iCurSegment       to iSegmentCase
89071>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_DIRECTION     of hTable iIndex iCurSegment       to iSegmentDirection
89074>>>>>>>                Set_Attribute DF_INDEX_SEGMENT_FIELD         of hTable iIndex iCurSegment       to iSegment
89077>>>>>>>            End
89077>>>>>>>>
89077>>>>>>>            Set Action_Text of ghoStatusPanel to "Restructures table..."
89078>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
89080>>>>>>>            Set Action_Text of ghoStatusPanel to ""
89081>>>>>>>        End
89081>>>>>>>>
89081>>>>>>>
89081>>>>>>>        Function_Return (Err = False)
89082>>>>>>>    End_Function
89083>>>>>>>
89083>>>>>>>    // * Dummy function for the Studio's Code Explorer *
89083>>>>>>>    Function TABLE_UTILITY_FUNCTIONS Returns Boolean
89085>>>>>>>        Function_Return False
89086>>>>>>>    End_Function  
89087>>>>>>>    
89087>>>>>>>    // Preparation message before an SQL onversion. It will check and wash all embedded data tables and prepare them
89087>>>>>>>    // for an SQL conversion.
89087>>>>>>>    Function UtilPrepareDataFolderForSQLConversion Boolean bMoveMiscFilesToBackup Boolean bFixALLBogusFilelistEntries Boolean bConvertTo30Format Boolean bRepairAndReindex Boolean bFixBogusDates Returns Boolean
89089>>>>>>>        Boolean bConvertTo30FormatbOK bRepairAndReindexOK bFixBogusDatesOK bMoveMiscFilesToBackupOK
89089>>>>>>>        
89089>>>>>>>        Move True to bConvertTo30FormatbOK
89090>>>>>>>        Move True to bRepairAndReindexOK
89091>>>>>>>        Move True to bFixBogusDatesOK
89092>>>>>>>        Move True to bMoveMiscFilesToBackupOK
89093>>>>>>>        
89093>>>>>>>        If (bMoveMiscFilesToBackup = True) Begin   
89095>>>>>>>            Set Message_Text of ghoStatusPanel to "Moving misc. files to backup..."
89096>>>>>>>            Get UtilMoveMiscFilesToBackupFolder to bMoveMiscFilesToBackupOK
89097>>>>>>>        End                                                                                
89097>>>>>>>>
89097>>>>>>>        If (bFixALLBogusFilelistEntries = True) Begin
89099>>>>>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus Filelist.cfg entries..."
89100>>>>>>>            Get UtilTableFixALLBogusFilelistEntries to bFixALLBogusFilelistEntries
89101>>>>>>>        End
89101>>>>>>>>
89101>>>>>>>        If (bConvertTo30Format = True) Begin
89103>>>>>>>            Set Message_Text of ghoStatusPanel to "Converting .dat files from 2.3->..."
89104>>>>>>>            Get UtilTableConvertALLTablesFrom23Format to bConvertTo30FormatbOK
89105>>>>>>>        End                                                 
89105>>>>>>>>
89105>>>>>>>        If (bRepairAndReindex = True) Begin
89107>>>>>>>            Set Message_Text of ghoStatusPanel to "Repairing and reindexing..."
89108>>>>>>>            Get UtilTableRepairAndReindexALL to bRepairAndReindexOK
89109>>>>>>>        End  
89109>>>>>>>>
89109>>>>>>>        If (bFixBogusDates = True) Begin
89111>>>>>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus date values..."
89112>>>>>>>            Get UtilTablesFixAllDateBogusValues True False to bFixBogusDatesOK
89113>>>>>>>        End                                    
89113>>>>>>>>
89113>>>>>>>        
89113>>>>>>>        Function_Return (bConvertTo30FormatbOK = True and bFixALLBogusFilelistEntries = True and bRepairAndReindexOK = True and bFixBogusDatesOK = True and bMoveMiscFilesToBackupOK = True)
89114>>>>>>>    End_Function
89115>>>>>>>
89115>>>>>>>    Function UtilTableConvertALLTablesFrom23Format Returns Boolean
89117>>>>>>>        Boolean bOK bFlexErrs bTemp
89117>>>>>>>        Handle hTable
89117>>>>>>>        String sTableName
89117>>>>>>>        Integer iCount iSize
89117>>>>>>>        
89117>>>>>>>        Move True to bOK
89118>>>>>>>        Move 0 to hTable    
89119>>>>>>>
89119>>>>>>>        Get UtilFilelistNoOfTables to iSize
89120>>>>>>>        Set pbVisible    of ghoProgressBarOverall to True
89121>>>>>>>        Set piPosition   of ghoProgressBarOverall to 0
89122>>>>>>>        Set piMaximum    of ghoProgressBarOverall to iSize
89123>>>>>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
89124>>>>>>>
89124>>>>>>>        Repeat
89124>>>>>>>>
89124>>>>>>>            Set Action_Text of ghoStatusPanel to "Checking if table is in 2.3 format..."
89125>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount  
89126>>>>>>>            Increment iCount
89127>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89130>>>>>>>            If (hTable > 0) Begin
89132>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
89135>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
89136>>>>>>>                If (bFlexErrs = False) Begin
89138>>>>>>>                    Get UtilTableConvertFrom23Format hTable to bTemp
89139>>>>>>>                    If (bTemp = False) Begin
89141>>>>>>>                        Move False to bOK
89142>>>>>>>                    End
89142>>>>>>>>
89142>>>>>>>                End
89142>>>>>>>>
89142>>>>>>>            End
89142>>>>>>>>
89142>>>>>>>        Until (hTable = 0)
89144>>>>>>>        
89144>>>>>>>        Set Action_Text of ghoStatusPanel to ""
89145>>>>>>>        Function_Return bOK
89146>>>>>>>    End_Function
89147>>>>>>>    
89147>>>>>>>    // Converts an embedded table from 2.3 -> 3.0.
89147>>>>>>>    // Returns: FALSE only if the table can't be opened or the conversion fails.
89147>>>>>>>    // It will return a TRUE if successful or the table is an SQL table.
89147>>>>>>>    Function UtilTableConvertFrom23Format Handle hTable Returns Boolean
89149>>>>>>>        Boolean bOK bIsEmbedded bIsAlias
89149>>>>>>>        String sRevision
89149>>>>>>>        
89149>>>>>>>        Get AutoConnectionIDLogin to bOK
89150>>>>>>>        If (bOK = False) Begin
89152>>>>>>>            Function_Return True
89153>>>>>>>        End
89153>>>>>>>>
89153>>>>>>>        Get OpenTableExclusive hTable to bOK
89154>>>>>>>        If (bOK = False) Begin
89156>>>>>>>            Function_Return True
89157>>>>>>>        End
89157>>>>>>>>
89157>>>>>>>        Get UtilTableIsEmbedded hTable to bIsEmbedded
89158>>>>>>>        If (bIsEmbedded = False) Begin
89160>>>>>>>            Function_Return True
89161>>>>>>>        End                             
89161>>>>>>>>
89161>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias
89162>>>>>>>        If (bIsAlias = True) Begin
89164>>>>>>>            Function_Return True
89165>>>>>>>        End                     
89165>>>>>>>>
89165>>>>>>>        
89165>>>>>>>        Move False to Err
89166>>>>>>>        Get_Attribute DF_FILE_REVISION of hTable to sRevision
89169>>>>>>>        If (sRevision contains "2.3") Begin
89171>>>>>>>            Move False to Err
89172>>>>>>>            Set Private.phCurrentTable to hTable
89173>>>>>>>            Structure_Start hTable    
89174>>>>>>>                Set_Attribute DF_FILE_INTEGRITY_CHECK of hTable to True
89177>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table to 3.0/4.0"
89178>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_FORCE "." ghoDbUpdateHandler
89180>>>>>>>            Set Action_Text of ghoStatusPanel to ""
89181>>>>>>>        End
89181>>>>>>>>
89181>>>>>>>        
89181>>>>>>>        Function_Return (Err = False)
89182>>>>>>>    End_Function
89183>>>>>>>
89183>>>>>>>    Function UtilTableFixALLBogusFilelistEntries Returns Boolean
89185>>>>>>>        Boolean bIgnore bExists bOK bResponse
89185>>>>>>>        Handle hTable   
89185>>>>>>>        String sTableName
89185>>>>>>>        
89185>>>>>>>        Move False to Err 
89186>>>>>>>        Move True to bOK
89187>>>>>>>        Move 0 to hTable
89188>>>>>>>        Repeat
89188>>>>>>>>
89188>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89191>>>>>>>            If (hTable > 0) Begin
89193>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
89196>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS" or Uppercase(sTableName) = "CODETYPE" or Uppercase(sTableName) = "CODEMAST")  to bIgnore
89197>>>>>>>                If (bIgnore = False) Begin
89199>>>>>>>                    Get UtilTableExists hTable to bExists
89200>>>>>>>                    If (bExists = False) Begin
89202>>>>>>>                        Get ApiTableChangeFileListSlot "" "" "" hTable DATAFLEX_ID to bResponse
89203>>>>>>>                        If (bResponse = False) Begin
89205>>>>>>>                            Move False to bOK
89206>>>>>>>                        End
89206>>>>>>>>
89206>>>>>>>                        
89206>>>>>>>                    End
89206>>>>>>>>
89206>>>>>>>                End
89206>>>>>>>>
89206>>>>>>>            End
89206>>>>>>>>
89206>>>>>>>        Until (hTable = 0)                     
89208>>>>>>>        
89208>>>>>>>        Set Action_Text of ghoStatusPanel to "" 
89209>>>>>>>        Function_Return bOK
89210>>>>>>>    End_Function
89211>>>>>>>    
89211>>>>>>>    // Replaces all date values with CS_DUFLowestAllowedDateValue for all tables in Filelist.cfg,
89211>>>>>>>    // _except_ those tables that has been excluded with the "ApiTableDateCorrectionAddException" message.
89211>>>>>>>    // If the passed bAllowZeroDates = True, date columns that are = 0 will not be changed.
89211>>>>>>>    // This is for prepairing embedded tables (*.dat) before an SQL conversion.
89211>>>>>>>    //
89211>>>>>>>    // The root of the problem is the following:
89211>>>>>>>    // The data type Date in SQL has a range of accepted values from 01-01-0001 through 12-31-9999
89211>>>>>>>    // while the data type DateTime has a range of accepted values from 01-01-1753 through 12-31-9999
89211>>>>>>>    // So if you happen to have a Date from before 1753, or an empty / NULL value - this will be outside
89211>>>>>>>    // the range that DateTime can handle and if you then try to change a Date column to a DateTime,
89211>>>>>>>    // an SQL error will be thrown;
89211>>>>>>>    // "The conversion of a date data type to a datetime data type resulted in an out-of-range value".
89211>>>>>>>    Function UtilTablesFixAllDateBogusValues Boolean bFixZeroDates Boolean bResetIndexesToOnLine Returns Boolean
89213>>>>>>>        Boolean bOK bIsAlias bIsSQL
89213>>>>>>>        Integer iCount iSize iDateSize
89213>>>>>>>        Handle hTable
89213>>>>>>>        String sLogicalName
89213>>>>>>>        Integer[] aTablesToCheck aDateFields
89215>>>>>>>
89215>>>>>>>        Get _AllTablesDateCorrections to aTablesToCheck
89216>>>>>>>        Move (SizeOfArray(aTablesToCheck)) to iSize
89217>>>>>>>        Set pbVisible    of ghoProgressBarOverall to True
89218>>>>>>>        Set piPosition   of ghoProgressBarOverall to 0
89219>>>>>>>        Set piMaximum    of ghoProgressBarOverall to iSize
89220>>>>>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
89221>>>>>>>
89221>>>>>>>        Move True to bOK
89222>>>>>>>        Decrement iSize
89223>>>>>>>        for iCount from 0 to iSize
89229>>>>>>>>
89229>>>>>>>            Move aTablesToCheck[iCount] to hTable
89230>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount
89231>>>>>>>            Get UtilTableIsAlias hTable to bIsAlias
89232>>>>>>>            Get UtilTableIsSql   hTable to bIsSQL
89233>>>>>>>
89233>>>>>>>            Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
89236>>>>>>>            Set TableName_Text of ghoStatusPanel to ("Processing Table Number:" * String(hTable) * "Name:" * String(sLogicalName))
89237>>>>>>>            Set Message_Text of ghoStatusPanel to "Fixing bogus date values..."
89238>>>>>>>
89238>>>>>>>            If (bIsAlias = False and bIsSQL = False) Begin
89240>>>>>>>                Get UtilCheckForDateFields hTable to aDateFields
89241>>>>>>>                Move (SizeOfArray(aDateFields)) to iDateSize
89242>>>>>>>                If (iDateSize > 0) Begin
89244>>>>>>>                    Get UtilTableCorrectBogusDateValues hTable aDateFields bFixZeroDates bResetIndexesToOnLine to bOK
89245>>>>>>>                    Close hTable
89246>>>>>>>                End
89246>>>>>>>>
89246>>>>>>>            End
89246>>>>>>>>
89246>>>>>>>        Loop
89247>>>>>>>>
89247>>>>>>>
89247>>>>>>>        Close DF_ALL
89248>>>>>>>        Function_Return bOK
89249>>>>>>>    End_Function
89250>>>>>>>
89250>>>>>>>    // Returns all fields of type Date or DateTime in an integer array with the field numbers.
89250>>>>>>>    Function UtilCheckForDateFields Handle hTable Returns Integer[]
89252>>>>>>>        Integer[] aDateFields aDateFieldsEmpty
89254>>>>>>>        Integer iSize iCount iType
89254>>>>>>>        Boolean bOpen bOK
89254>>>>>>>        
89254>>>>>>>        Get UtilTableExists hTable to bOK
89255>>>>>>>        If (bOK = False) Begin
89257>>>>>>>            Set Private.phCurrentTable to hTable
89258>>>>>>>            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
89259>>>>>>>>
89259>>>>>>>            Function_Return aDateFieldsEmpty
89260>>>>>>>        End
89260>>>>>>>>
89260>>>>>>>        Set Private.phCurrentTable to hTable
89261>>>>>>>        Set Private.piCurrentField to 0
89262>>>>>>>
89262>>>>>>>//        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89262>>>>>>>        Open hTable
89264>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
89267>>>>>>>//        Set Error_Report_Mode to DUF_ERROR_REPORT
89267>>>>>>>        If (bOpen = False) Begin
89269>>>>>>>//            Error DFERR_PROGRAM ("Table could not be opened." * String(hTable))
89269>>>>>>>            Function_Return aDateFieldsEmpty
89270>>>>>>>        End
89270>>>>>>>>
89270>>>>>>>
89270>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iSize
89273>>>>>>>        For iCount from 1 to iSize
89279>>>>>>>>
89279>>>>>>>            Get_Attribute DF_FIELD_TYPE of hTable iCount to iType
89282>>>>>>>            If (iType = DF_DATE or iType = DF_DATETIME) Begin
89284>>>>>>>                Move iCount to aDateFields[SizeOfArray(aDateFields)]
89285>>>>>>>            End
89285>>>>>>>>
89285>>>>>>>        Loop
89286>>>>>>>>
89286>>>>>>>
89286>>>>>>>        Function_Return aDateFields
89287>>>>>>>    End_Function
89288>>>>>>>
89288>>>>>>>    // Loops through all records for the passed hTable, and checks that all Date values
89288>>>>>>>    // for the passed aDateFields array are OK. Else the Data value is set to CS_DUFLowestAllowedDateValue
89288>>>>>>>    // and the record is saved
89288>>>>>>>    // If the passed bAllowZeroDates = True, date columns that are = 0 will not be changed.
89288>>>>>>>    // Note: It first sets all indexes to BATCH and reset them at the end.
89288>>>>>>>    Function UtilTableCorrectBogusDateValues Handle hTable Integer[] aDateFields Boolean bFixZeroDates Boolean bResetIndexesToOnLine Returns Boolean
89290>>>>>>>        Integer iSize iCount iField iRecord iTotalRecords iDateFormat iDriverIndex
89290>>>>>>>        String sDriverID sDateMin
89290>>>>>>>        Boolean bCancel bFound bOK bChange bOpened bSaveChanges 
89290>>>>>>>        Date dDate dDateMin
89290>>>>>>>        Integer[] iaChangeField
89291>>>>>>>
89291>>>>>>>        Get UtilTableExists hTable to bOK
89292>>>>>>>        // I believe we should just skip files not found and not report an error.
89292>>>>>>>        // This is because a filelist may have entries but no files/tables on disk, but
89292>>>>>>>        // this may be adjusted by other calls to DUF in a later update package. 
89292>>>>>>>        // Especially considering that this call is probably done at the very
89292>>>>>>>        // beginning of a DUF update.
89292>>>>>>>        If (bOK = False) Begin
89294>>>>>>>//            Set Private.phCurrentTable to hTable
89294>>>>>>>//            Error DFERR_PROGRAM "Table exists in Filelist.cfg but not on disk or SQL back-end."
89294>>>>>>>//            Function_Return False
89294>>>>>>>            Function_Return True
89295>>>>>>>        End
89295>>>>>>>>
89295>>>>>>>
89295>>>>>>>        // The CS_DUFLowestAllowedDateValue is defined as "01/01/1753", so we first set the
89295>>>>>>>        // date format to "USA" = "MM/DD/YYYY"
89295>>>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
89298>>>>>>>        Set_Attribute DF_DATE_FORMAT to DF_DATE_USA
89301>>>>>>>
89301>>>>>>>//        Send SetAllIndexesToBatch hTable True
89301>>>>>>>        Open hTable
89303>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
89306>>>>>>>        If (bOpened = False) Begin
89308>>>>>>>            Function_Return False
89309>>>>>>>        End
89309>>>>>>>>
89309>>>>>>>        
89309>>>>>>>        Set Private.phCurrentTable to hTable
89310>>>>>>>        Move 0 to iRecord
89311>>>>>>>        Move (SizeOfArray(aDateFields)) to iSize
89312>>>>>>>        Decrement iSize
89313>>>>>>>
89313>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
89316>>>>>>>        Get DriverIndex sDriverID to iDriverIndex
89317>>>>>>>        If (iDriverIndex <> 0) Begin
89319>>>>>>>            Get_Attribute DF_DRIVER_DUMMY_ZERO_DATE_VALUE of iDriverIndex to sDateMin
89322>>>>>>>            If (sDateMin = "") Begin
89324>>>>>>>                Move CS_DUFLowestAllowedDateValue to dDateMin
89325>>>>>>>            End
89325>>>>>>>>
89325>>>>>>>            Else Begin
89326>>>>>>>                If (IsDate(sDateMin)) Begin
89328>>>>>>>                    Move sDateMin to dDateMin
89329>>>>>>>                End
89329>>>>>>>>
89329>>>>>>>                Else Begin
89330>>>>>>>                    Move CS_DUFLowestAllowedDateValue to dDateMin
89331>>>>>>>                End
89331>>>>>>>>
89331>>>>>>>            End
89331>>>>>>>>
89331>>>>>>>        End
89331>>>>>>>>
89331>>>>>>>        Else Begin
89332>>>>>>>            Move CS_DUFLowestAllowedDateValue to dDateMin
89333>>>>>>>        End
89333>>>>>>>>
89333>>>>>>>
89333>>>>>>>        Get_Attribute DF_FILE_RECORDS_USED of hTable to iTotalRecords
89336>>>>>>>        Set piPosition   of ghoProgressBar to 0
89337>>>>>>>        Set piAdvanceBy  of ghoProgressBar to 100
89338>>>>>>>        Set piMaximum    of ghoProgressBar to iTotalRecords
89339>>>>>>>        Move False to Err
89340>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89341>>>>>>>
89341>>>>>>>        Clear hTable
89342>>>>>>>        Repeat
89342>>>>>>>>
89342>>>>>>>            Vfind hTable 0 GT
89344>>>>>>>            Move Found to bFound
89345>>>>>>>            If (bFound = True) Begin
89347>>>>>>>                Move False to bSaveChanges
89348>>>>>>>                Move (ResizeArray(iaChangeField, 0)) to iaChangeField
89349>>>>>>>                Move (SizeOfArray(aDateFields)) to iSize
89350>>>>>>>                Decrement iSize
89351>>>>>>>                For iCount from 0 to iSize
89357>>>>>>>>
89357>>>>>>>                    Move aDateFields[iCount] to iField
89358>>>>>>>                    Get_Field_Value hTable iField to dDate
89361>>>>>>>                    If (bFixZeroDates = True) Begin
89363>>>>>>>                        Move (dDate = 0 or dDate < dDateMin) to bChange
89364>>>>>>>                    End
89364>>>>>>>>
89364>>>>>>>                    Else Begin
89365>>>>>>>                        Move (dDate <> 0 and dDate < dDateMin) to bChange
89366>>>>>>>                    End
89366>>>>>>>>
89366>>>>>>>                    If (bChange = True) Begin
89368>>>>>>>                        Move iField to iaChangeField[SizeOfArray(iaChangeField)]
89369>>>>>>>                    End
89369>>>>>>>>
89369>>>>>>>                Loop
89370>>>>>>>>
89370>>>>>>>
89370>>>>>>>                // Only change Date fields that needs to be changed.
89370>>>>>>>                If (SizeOfArray(iaChangeField)) Begin
89372>>>>>>>                    Reread hTable
89376>>>>>>>                        Move (SizeOfArray(iaChangeField)) to iSize
89377>>>>>>>                        Decrement iSize
89378>>>>>>>                        For iCount from 0 to iSize
89384>>>>>>>>
89384>>>>>>>                            Move iaChangeField[iCount] to iField
89385>>>>>>>                            Set Private.piCurrentField to iField
89386>>>>>>>                            Set_Field_Value hTable iField to dDateMin
89389>>>>>>>                        Loop
89390>>>>>>>>
89390>>>>>>>                        Move False to Err
89391>>>>>>>                        SaveRecord hTable
89392>>>>>>>                    Unlock
89393>>>>>>>>
89393>>>>>>>                End
89393>>>>>>>>
89393>>>>>>>
89393>>>>>>>                Increment iRecord
89394>>>>>>>                // Increment the StatusPanel counter and check the
89394>>>>>>>                // cancel status every 100 records rather than every
89394>>>>>>>                // record, it's way faster.
89394>>>>>>>                If (Mod(iRecord, 100) = 0) Begin
89396>>>>>>>                    Send DoAdvance of ghoProgressBar
89397>>>>>>>                    Set Action_Text of ghoStatusPanel to ("Record:" * String(iRecord))
89398>>>>>>>                    Get Check_StatusPanel of ghoStatusPanel to bCancel
89399>>>>>>>                End
89399>>>>>>>>
89399>>>>>>>            End
89399>>>>>>>>
89399>>>>>>>        Until (bFound = False)
89401>>>>>>>
89401>>>>>>>        Set_Attribute DF_DATE_FORMAT to iDateFormat
89404>>>>>>>        If (bResetIndexesToOnLine = True) Begin
89406>>>>>>>            Send SetAllIndexesToBatch hTable False
89407>>>>>>>        End
89407>>>>>>>>
89407>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
89408>>>>>>>
89408>>>>>>>        Function_Return (Err = False)
89409>>>>>>>    End_Function
89410>>>>>>>
89410>>>>>>>    // Compares the RootName, LogicalName & DisplayName and returns True if they are equal.
89410>>>>>>>    // Note that it first removes any driver prefixes in the rootname.
89410>>>>>>>    Function UtilTableInfoCompare Boolean bCompareFilelistUppercase tAPITableNameInfoCompare APITableInfoCompare Returns Boolean
89412>>>>>>>        Boolean bIsSame
89412>>>>>>>        String sRootNameFrom sRootNameTo sLogicalNameFrom sLogicalNameTo sDisplayNameFrom sDisplayNameTo
89412>>>>>>>
89412>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sRootNameFrom    to sRootNameFrom
89413>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sRootNameTo      to sRootNameTo
89414>>>>>>>        Move APITableInfoCompare.sLogicalNameFrom               to sLogicalNameFrom
89415>>>>>>>        Move APITableInfoCompare.sLogicalNameTo                 to sLogicalNameTo
89416>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sDisplayNameFrom to sDisplayNameFrom
89417>>>>>>>        Get _TableNoPrefix APITableInfoCompare.sDisplayNameTo   to sDisplayNameTo
89418>>>>>>>
89418>>>>>>>        If (bCompareFilelistUppercase = True) Begin
89420>>>>>>>            Move (Uppercase(sRootNameFrom) = Uppercase(sRootNameTo) and Uppercase(sLogicalNameFrom) = Uppercase(sLogicalNameTo)) to bIsSame
89421>>>>>>>        End
89421>>>>>>>>
89421>>>>>>>        Else Begin
89422>>>>>>>            Move (sRootNameFrom = sRootNameTo and sLogicalNameFrom = sLogicalNameTo and sDisplayNameFrom = sDisplayNameTo) to bIsSame
89423>>>>>>>        End
89423>>>>>>>>
89423>>>>>>>        If (bIsSame = False) Begin
89425>>>>>>>            Function_Return False
89426>>>>>>>        End
89426>>>>>>>>
89426>>>>>>>
89426>>>>>>>        Move (APITableInfoCompare.bIsAliasFrom = APITableInfoCompare.bIsAliasTo) to bIsSame
89427>>>>>>>        If (bIsSame = False) Begin
89429>>>>>>>            Function_Return False
89430>>>>>>>        End
89430>>>>>>>>
89430>>>>>>>
89430>>>>>>>        Move (APITableInfoCompare.bIsSQLFrom = APITableInfoCompare.bIsSQLTo) to bIsSame
89431>>>>>>>        If (bIsSame = False) Begin
89433>>>>>>>            Function_Return False
89434>>>>>>>        End
89434>>>>>>>>
89434>>>>>>>
89434>>>>>>>        Move (APITableInfoCompare.bIsSystemFileFrom = APITableInfoCompare.bIsSystemFileTo) to bIsSame
89435>>>>>>>        If (bIsSame = False) Begin
89437>>>>>>>            Function_Return False
89438>>>>>>>        End
89438>>>>>>>>
89438>>>>>>>
89438>>>>>>>        Function_Return bIsSame
89439>>>>>>>    End_Function
89440>>>>>>>
89440>>>>>>>    Function UtilTableCompare tAPITable APITableFrom tAPITable APITableTo Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
89442>>>>>>>        Handle hTableFrom hTableTo
89442>>>>>>>        Boolean bIsSame bIsSQLFrom bIsSQLTo
89442>>>>>>>        Boolean bCompareDate_DateTime bCompareIndexAscending bCompareIndexUppercase
89442>>>>>>>        String sRootName sDriverIDFrom sDriverIDTo
89442>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
89442>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
89443>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
89443>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
89444>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
89444>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
89445>>>>>>>
89445>>>>>>>        Move (IsSameStruct(APITableFrom, APITableTo)) to bIsSame
89446>>>>>>>        If (bIsSame = True) Begin
89448>>>>>>>            Function_Return True
89449>>>>>>>        End
89449>>>>>>>>
89449>>>>>>>
89449>>>>>>>        Move False to bFilelistError
89450>>>>>>>        Move True to bIsSame
89451>>>>>>>        Get pbCompareDate_DateTime  to bCompareDate_DateTime
89452>>>>>>>        Get pbCompareIndexAscending to bCompareIndexAscending
89453>>>>>>>        Get pbCompareIndexUppercase to bCompareIndexUppercase
89454>>>>>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
89455>>>>>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo
89456>>>>>>>
89456>>>>>>>        Move APITableFrom.ApiTableInfo.sRootName to sRootName
89457>>>>>>>        Get _TableNameOnly sRootName             to sRootName
89458>>>>>>>        Move sRootName to APITableTo.ApiTableInfo.sRootName
89459>>>>>>>
89459>>>>>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg is the same).
89459>>>>>>>        // bCodeGenerateMode = True = Code Generation mode.
89459>>>>>>>        If (bCodeGenerateMode = True) Begin
89461>>>>>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
89461>>>>>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
89463>>>>>>>                Function_Return False
89464>>>>>>>            End
89464>>>>>>>>
89464>>>>>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
89465>>>>>>>            If (bIsSame = False) Begin
89467>>>>>>>                Send UserError ("Yikes! There is a serious problem with the Filelist.cfg slot number:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * ".\nThis needs to be fixed before you can generate code for this table number.")
89468>>>>>>>                Move True to bFilelistError
89469>>>>>>>                Function_Return False
89470>>>>>>>            End
89470>>>>>>>>
89470>>>>>>>        End
89470>>>>>>>>
89470>>>>>>>
89470>>>>>>>        If (bCodeGenerateMode = False) Begin
89472>>>>>>>            // Then we want to create this table
89472>>>>>>>            If (Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName)) = "") Begin
89474>>>>>>>                Function_Return False
89475>>>>>>>            End
89475>>>>>>>>
89475>>>>>>>
89475>>>>>>>            Move (Trim(Uppercase(APITableFrom.ApiTableInfo.sLogicalName)) = Trim(Uppercase(APITableTo.ApiTableInfo.sLogicalName))) to bIsSame
89476>>>>>>>            If (bIsSame = False) Begin
89478>>>>>>>                Error DFERR_PROGRAM ("'UtilTableCompare function' problem in Filelist.cfg! Table No:" * String(hTableFrom) + ".\nThe FROM table logical name is:" * String(APITableFrom.ApiTableInfo.sLogicalName) * "\nwhile the TO table logical name is:" * String(APITableTo.ApiTableInfo.sLogicalName) * "No changes was made for this entry.")
89479>>>>>>>>
89479>>>>>>>                Move True to bFilelistError
89480>>>>>>>                Function_Return False
89481>>>>>>>            End
89481>>>>>>>>
89481>>>>>>>        End
89481>>>>>>>>
89481>>>>>>>
89481>>>>>>>        // Check columns:
89481>>>>>>>        Move APITableFrom.ApiTableInfo.iTableNumber to hTableFrom
89482>>>>>>>        Move APITableFrom.ApiTableInfo.bIsSQL       to bIsSQLFrom
89483>>>>>>>        Move APITableFrom.ApiTableInfo.sDriverID    to sDriverIDFrom
89484>>>>>>>        Move APITableTo.ApiTableInfo.iTableNumber   to hTableTo
89485>>>>>>>        Move APITableTo.ApiTableInfo.bIsSQL         to bIsSQLTo
89486>>>>>>>        Move APITableTo.ApiTableInfo.sDriverID      to sDriverIDTo
89487>>>>>>>        Get UtilColumnsStructFill hTableTo          to APITableTo.aApiColumns
89488>>>>>>>        Get UtilColumnCombineFromAndToArrays APITableFrom.aApiColumns APITableTo.aApiColumns to aAPIColumnCompare
89489>>>>>>>        Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare bCompareDate_DateTime to bIsSame
89490>>>>>>>        If (bIsSame = False) Begin
89492>>>>>>>            Function_Return False
89493>>>>>>>        End
89493>>>>>>>>
89493>>>>>>>
89493>>>>>>>        // ...then check indexes:
89493>>>>>>>        Get UtilIndexesStructFill hTableFrom to APITableTo.aApiIndexes
89494>>>>>>>        Get UtilIndexCombineFromAndToArrays APITableFrom.aApiIndexes APITableTo.aApiIndexes to aAPIIndexCompare
89495>>>>>>>        Get UtilIndexesCompare bIsSQLFrom bIsSQLTo aAPIIndexCompare bCompareIndexUppercase bCompareIndexAscending to bIsSame
89496>>>>>>>        If (bIsSame = False) Begin
89498>>>>>>>            Function_Return False
89499>>>>>>>        End
89499>>>>>>>>
89499>>>>>>>
89499>>>>>>>        // ...and finally relationships:
89499>>>>>>>        Get UtilRelationsStructFill hTableFrom to APITableTo.aApiRelations
89500>>>>>>>        Get UtilRelationCombineFromAndToArrays APITableFrom.aApiRelations APITableTo.aApiRelations to aAPIRelationCompare
89501>>>>>>>        Move (IsSameArray(APITableFrom.aApiRelations, APITableTo.aApiRelations)) to bIsSame
89502>>>>>>>        Get UtilRelationsCompare hTableFrom aAPIRelationCompare to bIsSame
89503>>>>>>>
89503>>>>>>>        Function_Return (bIsSame = True)
89504>>>>>>>    End_Function
89505>>>>>>>
89505>>>>>>>    // Similar to UtilTableCompare, but takes a tAPITableCompare struct array and a tAPITableBooleans struct as params.
89505>>>>>>>    Function UtilTableCompare_Ex tAPITableCompare APITableCompare tAPITableBooleans CompareTableBooleans Boolean bCodeGenerateMode Boolean ByRef bFilelistError Returns Boolean
89507>>>>>>>        Handle hTable
89507>>>>>>>        Boolean bIsSame bIsSQLFrom bIsSQLTo
89507>>>>>>>        String sRootName sDriverIDFrom sDriverIDTo
89507>>>>>>>
89507>>>>>>>        If (APITableCompare.APITableNameInfoCompare.bExistsFrom = False and APITableCompare.APITableNameInfoCompare.bExistsTo = False) Begin
89509>>>>>>>            Move True to bFilelistError
89510>>>>>>>            Function_Return False
89511>>>>>>>        End
89511>>>>>>>>
89511>>>>>>>
89511>>>>>>>        Move APITableCompare.hTable to hTable
89512>>>>>>>        Move True  to bIsSame
89513>>>>>>>        Move False to bFilelistError
89514>>>>>>>
89514>>>>>>>        If (APITableCompare.bExistsFrom = True) Begin
89516>>>>>>>            Move APITableCompare.APITableNameInfoCompare.sRootNameFrom to sRootName
89517>>>>>>>        End
89517>>>>>>>>
89517>>>>>>>        Else Begin
89518>>>>>>>            Move APITableCompare.APITableNameInfoCompare.sRootNameTo   to sRootName
89519>>>>>>>        End
89519>>>>>>>>
89519>>>>>>>        Get _TableNameOnly sRootName                                   to sRootName
89520>>>>>>>
89520>>>>>>>        Move APITableCompare.APITableNameInfoCompare.sDriverIDFrom     to sDriverIDFrom
89521>>>>>>>        Move APITableCompare.APITableNameInfoCompare.sDriverIDTo       to sDriverIDTo
89522>>>>>>>        Move APITableCompare.APITableNameInfoCompare.bIsSQLFrom        to bIsSQLFrom
89523>>>>>>>        Move APITableCompare.APITableNameInfoCompare.bIsSQLTo          to bIsSQLTo
89524>>>>>>>
89524>>>>>>>        // First we need to check that the logical table names are the same (so the order of tables in the Filelist.cfg are the same).
89524>>>>>>>        // bCodeGenerateMode = True = Code Generation mode.
89524>>>>>>>        If (bCodeGenerateMode = True) Begin
89526>>>>>>>            // If table doesn't exist in the TO database we want to create 'ApiTableUpdate' code for it.
89526>>>>>>>            If (APITableCompare.bExistsTo = False) Begin
89528>>>>>>>                Function_Return False
89529>>>>>>>            End
89529>>>>>>>>
89529>>>>>>>            Move (Uppercase(APITableCompare.APITableNameInfoCompare.sLogicalNameFrom) = Uppercase(APITableCompare.APITableNameInfoCompare.sLogicalNameTo)) to bIsSame
89530>>>>>>>            If (bIsSame = False) Begin
89532>>>>>>>                Send UserError ("Yikes! There is a problem with the Filelist.cfg slot number:" * String(hTable) + ;                    ".\nThe FROM table logical name is:" * String(APITableCompare.APITableNameInfoCompare.sLogicalNameFrom) * "\nwhile the TO table logical name is:" * ;                    String(APITableCompare.APITableNameInfoCompare.sLogicalNameTo) * ".\nThis needs to be fixed before you can generate code for this table number.")
89533>>>>>>>                Move True to bFilelistError
89534>>>>>>>                Function_Return False
89535>>>>>>>            End
89535>>>>>>>>
89535>>>>>>>        End
89535>>>>>>>>
89535>>>>>>>
89535>>>>>>>        If (bCodeGenerateMode = False) Begin
89537>>>>>>>            If (APITableCompare.bExistsTo = False) Begin
89539>>>>>>>                // Then we might want to create this table
89539>>>>>>>                Function_Return False
89540>>>>>>>            End
89540>>>>>>>>
89540>>>>>>>
89540>>>>>>>            Move (APITableCompare.APITableNameInfoCompare.bIsAliasFrom = APITableCompare.APITableNameInfoCompare.bIsAliasTo) to bIsSame
89541>>>>>>>            If (bIsSame = False) Begin
89543>>>>>>>                Function_Return False
89544>>>>>>>            End
89544>>>>>>>>
89544>>>>>>>
89544>>>>>>>            Move (APITableCompare.APITableNameInfoCompare.bIsSQLFrom = APITableCompare.APITableNameInfoCompare.bIsSQLTo) to bIsSame
89545>>>>>>>            If (bIsSame = False) Begin
89547>>>>>>>                Function_Return False
89548>>>>>>>            End
89548>>>>>>>>
89548>>>>>>>
89548>>>>>>>            Move (APITableCompare.APITableNameInfoCompare.bIsSystemFileFrom = APITableCompare.APITableNameInfoCompare.bIsSystemFileTo) to bIsSame
89549>>>>>>>            If (bIsSame = False) Begin
89551>>>>>>>                Function_Return False
89552>>>>>>>            End
89552>>>>>>>>
89552>>>>>>>
89552>>>>>>>            // Check table names et al.
89552>>>>>>>            Get UtilTableInfoCompare CompareTableBooleans.bCompareFilelistUppercase APITableCompare.APITableNameInfoCompare to bIsSame
89553>>>>>>>            If (bIsSame = False) Begin
89555>>>>>>>                Function_Return False
89556>>>>>>>            End
89556>>>>>>>>
89556>>>>>>>        End
89556>>>>>>>>
89556>>>>>>>
89556>>>>>>>        // Check Columns:
89556>>>>>>>        Get UtilColumnsCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo APITableCompare.aAPIColumnsCompare CompareTableBooleans.bCompareDate_DateTime to bIsSame
89557>>>>>>>        If (bIsSame = False) Begin
89559>>>>>>>            Function_Return False
89560>>>>>>>        End
89560>>>>>>>>
89560>>>>>>>
89560>>>>>>>        // ...then check Indexes:
89560>>>>>>>        Get UtilIndexesCompare bIsSQLFrom bIsSQLTo APITableCompare.aAPIIndexesCompare CompareTableBooleans.bCompareIndexUppercase CompareTableBooleans.bCompareIndexAscending to bIsSame
89561>>>>>>>        If (bIsSame = False) Begin
89563>>>>>>>            Function_Return False
89564>>>>>>>        End
89564>>>>>>>>
89564>>>>>>>
89564>>>>>>>        // ...and finally Relationships:
89564>>>>>>>        Get UtilRelationsCompare hTable APITableCompare.aAPIRelationsCompare to bIsSame
89565>>>>>>>
89565>>>>>>>        Function_Return (bIsSame = True)
89566>>>>>>>    End_Function
89567>>>>>>>
89567>>>>>>>    // To fill a complete Table array structure (tAPITable[]) with data.
89567>>>>>>>    // The data + filelist.cfg path, login et al must have been setup properly first.
89567>>>>>>>    // Pass a True as first parameter if the ghoStatusPanel is active and progress info should be shown.
89567>>>>>>>    // Pass a second True if this is a comparison and the text should either reflect "FROM" or "TO" database.
89567>>>>>>>    Function UtilTablesStructArrayFill Boolean bStatusPanel Boolean bCompareUtil Boolean bFromTables Returns tAPITable[]
89569>>>>>>>        tAPITableNameInfo ApiTableNameInfo
89569>>>>>>>        tAPITableNameInfo ApiTableNameInfo
89569>>>>>>>        tAPITable[]     aApiTables aApiTablesEmpty
89569>>>>>>>        tAPITable[]     aApiTables aApiTablesEmpty
89571>>>>>>>        tAPIColumn[]    aApiColumns
89571>>>>>>>        tAPIColumn[]    aApiColumns
89572>>>>>>>        tAPIIndex[]     aApiIndexes
89572>>>>>>>        tAPIIndex[]     aApiIndexes
89573>>>>>>>        tAPIRelation[]  aApiRelations
89573>>>>>>>        tAPIRelation[]  aApiRelations
89574>>>>>>>        Handle hTable
89574>>>>>>>        Integer iCount
89574>>>>>>>        Boolean bUserCancel bOK
89574>>>>>>>        String sLogicalName sMessageText
89574>>>>>>>
89574>>>>>>>        Get AutoConnectionIDLogin to bOK
89575>>>>>>>        Move 0 to hTable
89576>>>>>>>        If (bFromTables = True) Begin
89578>>>>>>>            Move "Reading 'FROM' Table Structure:" to sMessageText
89579>>>>>>>            If (bCompareUtil = True) Begin
89581>>>>>>>                Move (sMessageText * "(1 of 3)") to sMessageText
89582>>>>>>>            End
89582>>>>>>>>
89582>>>>>>>        End
89582>>>>>>>>
89582>>>>>>>        Else Begin
89583>>>>>>>            Move "Reading 'TO' Table Structure:" to sMessageText
89584>>>>>>>            If (bCompareUtil = True) Begin
89586>>>>>>>                Move (sMessageText * "(2 of 3)") to sMessageText
89587>>>>>>>            End
89587>>>>>>>>
89587>>>>>>>        End
89587>>>>>>>>
89587>>>>>>>        Set Message_Text of ghoStatusPanel to sMessageText
89588>>>>>>>
89588>>>>>>>        Get UtilFilelistNoOfTables to iCount
89589>>>>>>>        Set piMaximum of ghoProgressBar to iCount
89590>>>>>>>        Move 0 to iCount
89591>>>>>>>
89591>>>>>>>        Repeat
89591>>>>>>>>
89591>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89594>>>>>>>            If (hTable > 0 and hTable <> 50) Begin
89596>>>>>>>
89596>>>>>>>                Open hTable
89598>>>>>>>                // ToDo: Needs to be revised
89598>>>>>>>                // For some reason tables may be reported as "unopened", while in
89598>>>>>>>                // fact the open was successful (!)
89598>>>>>>>//                Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89598>>>>>>>//                If (bIsOpen = False) Begin
89598>>>>>>>//                    Move True to aApiTablesEmpty[0].bError
89598>>>>>>>//                    Move hTable to aApiTablesEmpty[0].ApiTableInfo.iTableNumber
89598>>>>>>>//                    Function_Return aApiTablesEmpty
89598>>>>>>>//                End
89598>>>>>>>
89598>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
89601>>>>>>>                Set piPosition of ghoProgressBar to iCount
89602>>>>>>>                Send DoAdvance of ghoProgressBarOverall
89603>>>>>>>                Set Action_Text of ghoStatusPanel to ("Number:" * String(hTable) * String(sLogicalName))
89604>>>>>>>
89604>>>>>>>                Get UtilTableStructFill hTable bFromTables to aApiTables[iCount]
89605>>>>>>>//                Close hTable DF_PERMANENT
89605>>>>>>>                Increment iCount
89606>>>>>>>            End
89606>>>>>>>>
89606>>>>>>>
89606>>>>>>>            If (bStatusPanel = True) Begin
89608>>>>>>>                Get Check_StatusPanel of ghoStatusPanel to bUserCancel
89609>>>>>>>                If (bUserCancel = True) Begin
89611>>>>>>>                    Move True to aApiTablesEmpty[0].bCancel
89612>>>>>>>                    Function_Return aApiTablesEmpty
89613>>>>>>>                End
89613>>>>>>>>
89613>>>>>>>            End
89613>>>>>>>>
89613>>>>>>>
89613>>>>>>>        Until (hTable = 0)
89615>>>>>>>
89615>>>>>>>        Function_Return aApiTables
89616>>>>>>>    End_Function
89617>>>>>>>
89617>>>>>>>    // Returns a 'single' table APITable struct.
89617>>>>>>>    Function UtilTableStructFill Handle hTable Boolean bFromTables Returns tAPITable
89619>>>>>>>        tAPITableNameInfo ApiTableNameInfo
89619>>>>>>>        tAPITableNameInfo ApiTableNameInfo
89619>>>>>>>        tAPITable         ApiTable ApiTableEmpty
89619>>>>>>>        tAPITable         ApiTable ApiTableEmpty
89619>>>>>>>        tAPIColumn[]     aApiColumns
89619>>>>>>>        tAPIColumn[]     aApiColumns
89620>>>>>>>        tAPIIndex[]      aApiIndexes
89620>>>>>>>        tAPIIndex[]      aApiIndexes
89621>>>>>>>        tAPIRelation[]   aApiRelations
89621>>>>>>>        tAPIRelation[]   aApiRelations
89622>>>>>>>        Boolean bIsOpen
89622>>>>>>>
89622>>>>>>>        Open hTable
89624>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89627>>>>>>>        If (bIsOpen = False) Begin
89629>>>>>>>            Move True to ApiTableEmpty.bError
89630>>>>>>>            Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
89631>>>>>>>            Function_Return ApiTableEmpty
89632>>>>>>>        End
89632>>>>>>>>
89632>>>>>>>
89632>>>>>>>        // Fill Table Name Info
89632>>>>>>>        Get UtilTableNameInfoStructFill hTable to ApiTableNameInfo
89633>>>>>>>
89633>>>>>>>        // Fill columns
89633>>>>>>>        Get UtilColumnsStructFill hTable to aApiColumns
89634>>>>>>>        If (SizeOfArray(aApiColumns)) Begin
89636>>>>>>>            If (aApiColumns[0].bCancel = True) Begin
89638>>>>>>>                Move True to ApiTableEmpty.bError
89639>>>>>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
89640>>>>>>>                Function_Return ApiTableEmpty
89641>>>>>>>            End
89641>>>>>>>>
89641>>>>>>>        End
89641>>>>>>>>
89641>>>>>>>
89641>>>>>>>        // Fill indexes
89641>>>>>>>        Get UtilIndexesStructFill hTable to aApiIndexes
89642>>>>>>>        If (SizeOfArray(aApiIndexes)) Begin
89644>>>>>>>            If (aApiIndexes[0].bCancel = True) Begin
89646>>>>>>>                Move True to ApiTableEmpty.bError
89647>>>>>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
89648>>>>>>>                Function_Return ApiTableEmpty
89649>>>>>>>            End
89649>>>>>>>>
89649>>>>>>>        End
89649>>>>>>>>
89649>>>>>>>
89649>>>>>>>        // Fill relationships
89649>>>>>>>        Get UtilRelationsStructFill hTable to aApiRelations
89650>>>>>>>        If (SizeOfArray(aApiRelations)) Begin
89652>>>>>>>            If (aApiRelations[0].bCancel = True) Begin
89654>>>>>>>                Move True to ApiTableEmpty.bError
89655>>>>>>>                Move hTable to ApiTableEmpty.ApiTableInfo.iTableNumber
89656>>>>>>>                Function_Return ApiTableEmpty
89657>>>>>>>            End
89657>>>>>>>>
89657>>>>>>>        End
89657>>>>>>>>
89657>>>>>>>
89657>>>>>>>        Move hTable             to ApiTable.hTable
89658>>>>>>>        Move bFromTables        to ApiTable.bFromTable
89659>>>>>>>        Move (not(bFromTables)) to ApiTable.bToTable
89660>>>>>>>
89660>>>>>>>        Move ApiTableNameInfo   to ApiTable.ApiTableInfo
89661>>>>>>>        Move aApiColumns        to ApiTable.aApiColumns
89662>>>>>>>        Move aApiIndexes        to ApiTable.aApiIndexes
89663>>>>>>>        Move aApiRelations      to ApiTable.aApiRelations
89664>>>>>>>
89664>>>>>>>        Function_Return ApiTable
89665>>>>>>>    End_Function
89666>>>>>>>
89666>>>>>>>    Function UtilTableNameInfoStructFill Handle hTable Returns tAPITableNameInfo
89668>>>>>>>        tAPITableNameInfo APITableNameInfo APITableNameInfoEmpty
89668>>>>>>>        tAPITableNameInfo APITableNameInfo APITableNameInfoEmpty
89668>>>>>>>        Boolean bIsOpen
89668>>>>>>>
89668>>>>>>>        Open hTable
89670>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
89673>>>>>>>        If (bIsOpen = False) Begin
89675>>>>>>>            Move True   to APITableNameInfoEmpty.bError
89676>>>>>>>            Move hTable to APITableNameInfoEmpty.iTableNumber
89677>>>>>>>            Function_Return APITableNameInfoEmpty
89678>>>>>>>        End
89678>>>>>>>>
89678>>>>>>>
89678>>>>>>>        Move hTable                                  to APITableNameInfo.iTableNumber
89679>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to APITableNameInfo.sRootName
89682>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to APITableNameInfo.sLogicalName
89685>>>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME of hTable to APITableNameInfo.sDisplayName
89688>>>>>>>        Get_Attribute DF_FILE_DRIVER       of hTable to APITableNameInfo.sDriverID
89691>>>>>>>
89691>>>>>>>        Get UtilTableIsAlias                  hTable to APITableNameInfo.bIsAlias
89692>>>>>>>        Get UtilTableIsSQL                    hTable to APITableNameInfo.bIsSQL
89693>>>>>>>
89693>>>>>>>        Function_Return APITableNameInfo
89694>>>>>>>    End_Function
89695>>>>>>>
89695>>>>>>>    Function UtilFindTableArrayItem tAPITable[] ByRef aTableStructure String sLogicalTableName Returns Integer
89697>>>>>>>        Integer iSize iCount iItem
89697>>>>>>>        tAPITableNameInfo ApiTableNameInfo
89697>>>>>>>        tAPITableNameInfo ApiTableNameInfo
89697>>>>>>>
89697>>>>>>>        Move -1 to iItem
89698>>>>>>>        Move (SizeOfArray(aTableStructure)) to iSize
89699>>>>>>>        Decrement iSize
89700>>>>>>>        for iCount from 0 to iSize
89706>>>>>>>>
89706>>>>>>>            Move aTableStructure[iCount].ApiTableInfo to ApiTableNameInfo
89707>>>>>>>            If (Uppercase(ApiTableNameInfo.sLogicalName) = Uppercase(sLogicalTableName)) Begin
89709>>>>>>>                Move iCount to iItem
89710>>>>>>>                Move iSize  to iCount // We're done.
89711>>>>>>>            End
89711>>>>>>>>
89711>>>>>>>        Loop
89712>>>>>>>>
89712>>>>>>>
89712>>>>>>>        Function_Return iItem
89713>>>>>>>    End_Function
89714>>>>>>>
89714>>>>>>>    Function UtilTableArrayCompare tAPITable APITableFrom tAPITable APITableTo Returns Integer
89716>>>>>>>        If (APITableFrom.hTable  > APITableTo.hTable) ;            Function_Return (GT)
89719>>>>>>>        If (APITableFrom.hTable  < APITableTo.hTable) ;            Function_Return (LT)
89722>>>>>>>
89722>>>>>>>        If (APITableFrom.bFromTable = True)  ;            Function_Return (LT)
89725>>>>>>>        If (APITableFrom.bFromTable = False) ;            Function_Return (GT)
89728>>>>>>>
89728>>>>>>>        Function_Return (EQ)
89729>>>>>>>    End_Function
89730>>>>>>>
89730>>>>>>>    Function UtilTableCombineFromAndToArrays tAPITable[] aAPITableFrom tAPITable[] aAPITableTo Returns tAPITableCompare[]
89732>>>>>>>        Integer iCount iSize iSizeFrom iSizeTo iItemFrom iItemTo iItem
89732>>>>>>>        Handle hTable
89732>>>>>>>        tAPITable[] aAPITableFromAndTo
89732>>>>>>>        tAPITable[] aAPITableFromAndTo
89733>>>>>>>        tAPITable   APITableFrom APITableTo APITableEmpty
89733>>>>>>>        tAPITable   APITableFrom APITableTo APITableEmpty
89733>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
89733>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
89733>>>>>>>        tAPITableCompare[]    aAPITableCompare // This is the result set for this function
89733>>>>>>>        tAPITableCompare[]    aAPITableCompare // This is the result set for this function
89734>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
89734>>>>>>>        tAPIColumnCompare[]   aAPIColumnCompare
89735>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
89735>>>>>>>        tAPIIndexCompare[]    aAPIIndexCompare
89736>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
89736>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
89737>>>>>>>        tAPITableNameInfo ApiTableInfoEmpty ApiTableInfoFrom ApiTableInfoTo
89737>>>>>>>        tAPITableNameInfo ApiTableInfoEmpty ApiTableInfoFrom ApiTableInfoTo
89737>>>>>>>        tAPIColumn[]   aApiColumnsEmpty aApiColumnsFrom aApiColumnsTo
89737>>>>>>>        tAPIColumn[]   aApiColumnsEmpty aApiColumnsFrom aApiColumnsTo
89740>>>>>>>        tAPIIndex[]    aApiIndexEmpty aApiIndexFrom aApiIndexTo
89740>>>>>>>        tAPIIndex[]    aApiIndexEmpty aApiIndexFrom aApiIndexTo
89743>>>>>>>        tAPIRelation[] aApiRelationEmpty aApiRelationFrom aApiRelationTo
89743>>>>>>>        tAPIRelation[] aApiRelationEmpty aApiRelationFrom aApiRelationTo
89746>>>>>>>
89746>>>>>>>        Move (SizeOfArray(aAPITableFrom)) to iSizeFrom
89747>>>>>>>        Move (SizeOfArray(aAPITableTo))   to iSizeTo
89748>>>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
89750>>>>>>>            Function_Return aAPITableCompare
89751>>>>>>>        End
89751>>>>>>>>
89751>>>>>>>
89751>>>>>>>        Move (AppendArray(aAPITableFrom, aAPITableTo)) to aAPITableFromAndTo
89752>>>>>>>        Move (SortArray(aAPITableFromAndTo, Self, RefFunc(UtilTableArrayCompare))) to aAPITableFromAndTo
89753>>>>>>>
89753>>>>>>>        Move 0 to iItem
89754>>>>>>>        Move (SizeOfArray(aAPITableFromAndTo)) to iSize
89755>>>>>>>        Decrement iSize
89756>>>>>>>        for iCount from 0 to iSize
89762>>>>>>>>
89762>>>>>>>
89762>>>>>>>            Move iCount to iItemFrom
89763>>>>>>>            Move iCount to iItemTo
89764>>>>>>>            Move APITableEmpty to APITableFrom
89765>>>>>>>            Move APITableEmpty to APITableTo
89766>>>>>>>
89766>>>>>>>            If (aAPITableFromAndTo[iCount].bFromTable = True) Begin
89768>>>>>>>                Move aAPITableFromAndTo[iCount]     to APITableFrom
89769>>>>>>>            End
89769>>>>>>>>
89769>>>>>>>            If (aAPITableFromAndTo[iCount].bToTable = True) Begin
89771>>>>>>>                Move aAPITableFromAndTo[iCount]     to APITableTo
89772>>>>>>>            End
89772>>>>>>>>
89772>>>>>>>            If (aAPITableFromAndTo[iCount].hTable = aAPITableFromAndTo[iCount + 1].hTable) Begin
89774>>>>>>>                Move aAPITableFromAndTo[iCount]     to APITableFrom
89775>>>>>>>                Move (iCount + 1) to iItemTo
89776>>>>>>>                Move aAPITableFromAndTo[iItemTo]    to APITableTo
89777>>>>>>>            End
89777>>>>>>>>
89777>>>>>>>            If (APITableFrom.hTable > APITableTo.hTable) Begin
89779>>>>>>>                Get FindTableNumber aAPITableTo APITableFrom.hTable to iItemTo
89780>>>>>>>                If (iItemTo <> -1) Begin
89782>>>>>>>                    Move aAPITableTo[iItemTo] to APITableTo
89783>>>>>>>                End
89783>>>>>>>>
89783>>>>>>>                Else Begin
89784>>>>>>>                    Move APITableEmpty to APITableTo
89785>>>>>>>                End
89785>>>>>>>>
89785>>>>>>>            End
89785>>>>>>>>
89785>>>>>>>
89785>>>>>>>            Move APITableFrom.ApiTableInfo  to ApiTableInfoFrom
89786>>>>>>>            Move APITableFrom.aApiColumns   to aApiColumnsFrom
89787>>>>>>>            Move APITableFrom.aApiIndexes   to aApiIndexFrom
89788>>>>>>>            Move APITableFrom.aApiRelations to aApiRelationFrom
89789>>>>>>>
89789>>>>>>>            Move APITableTo.ApiTableInfo    to ApiTableInfoTo
89790>>>>>>>            Move APITableTo.aApiColumns     to aApiColumnsTo
89791>>>>>>>            Move APITableTo.aApiIndexes     to aApiIndexTo
89792>>>>>>>            Move APITableTo.aApiRelations   to aApiRelationTo
89793>>>>>>>
89793>>>>>>>            Move aAPITableFromAndTo[iCount].hTable to hTable
89794>>>>>>>
89794>>>>>>>            If (hTable > 0) Begin
89796>>>>>>>
89796>>>>>>>                // Table info:
89796>>>>>>>                Get UtilTableINFOCombineFromAndToArrays ApiTableInfoFrom ApiTableInfoTo to APITableNameInfoCompare
89797>>>>>>>                Move APITableNameInfoCompare.iTableNumber                               to aAPITableCompare[iItem].hTable
89798>>>>>>>                Move APITableNameInfoCompare.bExistsFrom                                to aAPITableCompare[iItem].bExistsFrom
89799>>>>>>>                Move APITableNameInfoCompare.bExistsTo                                  to aAPITableCompare[iItem].bExistsTo
89800>>>>>>>                Move APITableNameInfoCompare                                            to aAPITableCompare[iItem].APITableNameInfoCompare
89801>>>>>>>
89801>>>>>>>                // Column info:
89801>>>>>>>                Get UtilColumnCombineFromAndToArrays aApiColumnsFrom aApiColumnsTo      to aAPIColumnCompare
89802>>>>>>>                Move aAPIColumnCompare                                                  to aAPITableCompare[iItem].aAPIColumnsCompare
89803>>>>>>>
89803>>>>>>>                // Index info:
89803>>>>>>>                Get UtilIndexCombineFromAndToArrays aApiIndexFrom aApiIndexTo           to aAPIIndexCompare
89804>>>>>>>                Move aAPIIndexCompare                                                   to aAPITableCompare[iItem].aAPIIndexesCompare
89805>>>>>>>
89805>>>>>>>                // Relation info:
89805>>>>>>>                Get UtilRelationCombineFromAndToArrays aApiRelationFrom aApiRelationTo  to aAPIRelationCompare
89806>>>>>>>                Move aAPIRelationCompare                                                to aAPITableCompare[iItem].aAPIRelationsCompare
89807>>>>>>>
89807>>>>>>>                Move False                                                              to aAPITableCompare[iItem].bShouldChange
89808>>>>>>>                Move False                                                              to aAPITableCompare[iItem].bCancel
89809>>>>>>>                Move False                                                              to aAPITableCompare[iItem].bError
89810>>>>>>>                If (iItemTo > iItemFrom) Begin
89812>>>>>>>                    Increment iCount
89813>>>>>>>                End
89813>>>>>>>>
89813>>>>>>>                Increment iItem
89814>>>>>>>            End
89814>>>>>>>>
89814>>>>>>>
89814>>>>>>>        Loop
89815>>>>>>>>
89815>>>>>>>
89815>>>>>>>        Function_Return aAPITableCompare
89816>>>>>>>    End_Function
89817>>>>>>>
89817>>>>>>>    Function FindTableNumber tAPITable[] ByRef aTableStructure Handle hTable Returns Integer
89819>>>>>>>        Integer iSize iCount iItem
89819>>>>>>>        tAPITableNameInfo ApiTableNameInfo
89819>>>>>>>        tAPITableNameInfo ApiTableNameInfo
89819>>>>>>>
89819>>>>>>>        Move -1 to iItem
89820>>>>>>>        Move (SizeOfArray(aTableStructure)) to iSize
89821>>>>>>>        Decrement iSize
89822>>>>>>>        For iCount from 0 to iSize
89828>>>>>>>>
89828>>>>>>>            Move aTableStructure[iCount].ApiTableInfo to ApiTableNameInfo
89829>>>>>>>            If (ApiTableNameInfo.iTableNumber = hTable) Begin
89831>>>>>>>                Move iCount to iItem
89832>>>>>>>                Move iSize  to iCount // We're done.
89833>>>>>>>            End
89833>>>>>>>>
89833>>>>>>>        Loop
89834>>>>>>>>
89834>>>>>>>
89834>>>>>>>        Function_Return iItem
89835>>>>>>>    End_Function
89836>>>>>>>
89836>>>>>>>    Function UtilTableInfoCombineFromAndToArrays tAPITableNameInfo APITableNameInfoFrom tAPITableNameInfo APITableNameInfoTo Returns tAPITableNameInfoCompare
89838>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
89838>>>>>>>        tAPITableNameInfoCompare APITableNameInfoCompare
89838>>>>>>>
89838>>>>>>>        If (APITableNameInfoFrom.iTableNumber = 0 and APITableNameInfoTo.iTableNumber = 0) Begin
89840>>>>>>>            Function_Return APITableNameInfoCompare
89841>>>>>>>        End
89841>>>>>>>>
89841>>>>>>>
89841>>>>>>>        // FROM database info:
89841>>>>>>>        If (APITableNameInfoFrom.iTableNumber > 0) Begin
89843>>>>>>>            Move APITableNameInfoFrom.iTableNumber  to APITableNameInfoCompare.iTableNumber
89844>>>>>>>            Move APITableNameInfoFrom.sRootName     to APITableNameInfoCompare.sRootNameFrom
89845>>>>>>>            Move APITableNameInfoFrom.sLogicalName  to APITableNameInfoCompare.sLogicalNameFrom
89846>>>>>>>            Move APITableNameInfoFrom.sDisplayName  to APITableNameInfoCompare.sDisplayNameFrom
89847>>>>>>>            Move APITableNameInfoFrom.sDriverID     to APITableNameInfoCompare.sDriverIDFrom
89848>>>>>>>            Move APITableNameInfoFrom.bIsAlias      to APITableNameInfoCompare.bIsAliasFrom
89849>>>>>>>            Move APITableNameInfoFrom.bIsSQL        to APITableNameInfoCompare.bIsSQLFrom
89850>>>>>>>            Move True                               to APITableNameInfoCompare.bExistsFrom
89851>>>>>>>        End
89851>>>>>>>>
89851>>>>>>>
89851>>>>>>>        // TO database info:
89851>>>>>>>        If (APITableNameInfoTo.iTableNumber > 0) Begin
89853>>>>>>>            Move APITableNameInfoTo.iTableNumber    to APITableNameInfoCompare.iTableNumber
89854>>>>>>>            Move APITableNameInfoTo.sRootName       to APITableNameInfoCompare.sRootNameTo
89855>>>>>>>            Move APITableNameInfoTo.sLogicalName    to APITableNameInfoCompare.sLogicalNameTo
89856>>>>>>>            Move APITableNameInfoTo.sDisplayName    to APITableNameInfoCompare.sDisplayNameTo
89857>>>>>>>            Move APITableNameInfoTo.sDriverID       to APITableNameInfoCompare.sDriverIDTo
89858>>>>>>>            Move APITableNameInfoTo.bIsAlias        to APITableNameInfoCompare.bIsAliasTo
89859>>>>>>>            Move APITableNameInfoTo.bIsSQL          to APITableNameInfoCompare.bIsSQLTo
89860>>>>>>>            Move True                               to APITableNameInfoCompare.bExistsTo
89861>>>>>>>        End
89861>>>>>>>>
89861>>>>>>>
89861>>>>>>>        Function_Return APITableNameInfoCompare
89862>>>>>>>    End_Function
89863>>>>>>>
89863>>>>>>>    // Note:
89863>>>>>>>    // The DF_FILE_TABLE_NAME attribute holds the name of the table at the back end. Depending on the back end, table
89863>>>>>>>    // names may be case sensitive, contain spaces or other special characters. This attribute is used to determine a table's
89863>>>>>>>    // back end name when using Embedded SQL. Since Embedded SQL works on the back end directly, the back end's name must be used.
89863>>>>>>>    // In most cases the back end name will be the same as the table name used in DataFlex.
89863>>>>>>>    // To do the opposite; To get the file handle from a table name string use the UtilTableNameToHandle function.
89863>>>>>>>    Function UtilTableHandleToString Handle hTable Returns String
89865>>>>>>>        String sTableName
89865>>>>>>>        Boolean bOpen bExists bOK
89865>>>>>>>
89865>>>>>>>        Get UtilTableNumberIsInUse hTable to bExists
89866>>>>>>>        If (bExists = False) Begin
89868>>>>>>>            Function_Return ""
89869>>>>>>>        End
89869>>>>>>>>
89869>>>>>>>
89869>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
89870>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
89873>>>>>>>        If (bOpen = False) Begin
89875>>>>>>>            Get AutoConnectionIDLogin to bOK
89876>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
89877>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
89878>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_GENERAL_ERROR
89879>>>>>>>            Open hTable
89881>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
89882>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_INTERMEDIATE_FILE
89883>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_GENERAL_ERROR
89884>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
89887>>>>>>>        End
89887>>>>>>>>
89887>>>>>>>        If (bOpen = True) Begin
89889>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
89890>>>>>>>            Get_Attribute DF_FILE_TABLE_NAME of hTable to sTableName
89893>>>>>>>            // If blank it is an embedded table:
89893>>>>>>>            If (sTableName = "") Begin
89895>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
89898>>>>>>>                Move 0 to LastErr
89899>>>>>>>                Move False to Err
89900>>>>>>>            End
89900>>>>>>>>
89900>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
89901>>>>>>>        End
89901>>>>>>>>
89901>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
89902>>>>>>>        Move 0 to LastErr
89903>>>>>>>
89903>>>>>>>        Function_Return sTableName
89904>>>>>>>    End_Function
89905>>>>>>>
89905>>>>>>>    // Returns the filenumber for the passed Table name from Filelist.cfg.
89905>>>>>>>    // Returns 0 if unsuccessful.
89905>>>>>>>    // To do the opposite; To get the string value from a table handle string use the UtilTableHandleToString function.
89905>>>>>>>    Function UtilTableNameToHandle String sTableName Returns Integer
89907>>>>>>>        String sValue sPrefixTableName sDriverID
89907>>>>>>>        Handle hTable hRetval
89907>>>>>>>
89907>>>>>>>        Get psDriverID to sDriverID
89908>>>>>>>        If (sDriverID <> DATAFLEX_ID and not(sTableName contains ":")) Begin
89910>>>>>>>            Move (sDriverID + ":" + sTableName) to sPrefixTableName
89911>>>>>>>        End
89911>>>>>>>>
89911>>>>>>>        Move 0 to hTable
89912>>>>>>>        Move 0 to hRetval
89913>>>>>>>        Repeat
89913>>>>>>>>
89913>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89916>>>>>>>            If (hTable <> 0) Begin
89918>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sValue
89921>>>>>>>                If (Uppercase(sValue) = Uppercase(sTableName) or Uppercase(sValue) = Uppercase(sPrefixTableName)) Begin
89923>>>>>>>                    Move hTable to hRetval
89924>>>>>>>                    Move 0 to hTable
89925>>>>>>>                End
89925>>>>>>>>
89925>>>>>>>            End
89925>>>>>>>>
89925>>>>>>>        Until (hTable = 0)
89927>>>>>>>
89927>>>>>>>        Function_Return hRetval
89928>>>>>>>    End_Function
89929>>>>>>>
89929>>>>>>>    // Use function to move all *.dat, *.k?? & *.hdr files to a "Data\Backup" folder
89929>>>>>>>    // _after_ all tables have successfully been converted to SQL (.int files)
89929>>>>>>>    Function UtilMoveAllEmbeddedToBackupFolder Returns Boolean
89931>>>>>>>        Boolean bOK bExists
89931>>>>>>>        String sDataPath sBackupFolder
89931>>>>>>>
89931>>>>>>>        Close DF_ALL DF_PERMANENT
89932>>>>>>>        Send DoAdvance of ghoProgressBar
89933>>>>>>>
89933>>>>>>>        Set Message_Text of ghoStatusPanel to "Moving Embedded (*.dat) files to Backup folder."
89934>>>>>>>        Move CS_DUFBackupDataFolder to sBackupFolder
89935>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
89936>>>>>>>        Get vFolderFormat sDataPath to sDataPath
89937>>>>>>>
89937>>>>>>>        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
89938>>>>>>>        If (bExists = False) Begin
89940>>>>>>>            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
89941>>>>>>>            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
89942>>>>>>>            If (bExists = False) Begin
89944>>>>>>>                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all *.dat and *.k?? files to. You need to move them somewhere manually.")
89945>>>>>>>>
89945>>>>>>>                Function_Return False
89946>>>>>>>            End
89946>>>>>>>>
89946>>>>>>>        End
89946>>>>>>>>
89946>>>>>>>
89946>>>>>>>        Get vMoveFile (sDataPath + "*.dat") (sDataPath + sBackupFolder) to bOK
89947>>>>>>>        Get vMoveFile (sDataPath + "*.hdr") (sDataPath + sBackupFolder) to bOK
89948>>>>>>>        Get vMoveFile (sDataPath + "*.k??") (sDataPath + sBackupFolder) to bOK
89949>>>>>>>        Get vMoveFile (sDataPath + "*.vld") (sDataPath + sBackupFolder) to bOK
89950>>>>>>>        // We need to wait for Windows before we can copy files back
89950>>>>>>>        Sleep 2  
89951>>>>>>>        
89951>>>>>>>        //...except for these files that needs to be copied back to the Data folder:
89951>>>>>>>        Get vCopyFile (sBackupFolder + "\CodeMast.*")  sDataPath to bOK 
89952>>>>>>>        Get vCopyFile (sBackupFolder + "\CodeType.*")  sDataPath to bOK                                 
89953>>>>>>>        Get vCopyFile (sBackupFolder + "\Flexerrs.*")  sDataPath to bOK                                 
89954>>>>>>>        Get vCopyFile (sBackupFolder + "\DFErr001.*")  sDataPath to bOK                                 
89955>>>>>>>        Get vCopyFile (sBackupFolder + "\DFErr002.*")  sDataPath to bOK                                 
89956>>>>>>>        Get vCopyFile (sBackupFolder + "\DFErr003.*")  sDataPath to bOK                                 
89957>>>>>>>//            Get vCopyFile (sBackupFolder + "\DbVersion.*") sDataPath to bOK  
89957>>>>>>>        
89957>>>>>>>
89957>>>>>>>        Set Message_Text of ghoStatusPanel to ""
89958>>>>>>>        Function_Return True
89959>>>>>>>    End_Function
89960>>>>>>>    
89960>>>>>>>    Function UtilTableRepairAndReindexALL Returns Boolean
89962>>>>>>>        Boolean bOK bRetval
89962>>>>>>>        Handle hTable
89962>>>>>>>        Integer iSize iCount
89962>>>>>>>        
89962>>>>>>>        Move True to bOK
89963>>>>>>>        Get UtilFilelistNoOfTables to iSize
89964>>>>>>>        Set pbVisible    of ghoProgressBarOverall to True
89965>>>>>>>        Set piPosition   of ghoProgressBarOverall to 0
89966>>>>>>>        Set piMaximum    of ghoProgressBarOverall to iSize
89967>>>>>>>        Set piAdvanceBy  of ghoProgressBarOverall to 1
89968>>>>>>>
89968>>>>>>>        Repeat
89968>>>>>>>>
89968>>>>>>>            Set piPosition of ghoProgressBarOverall to iCount
89969>>>>>>>            Increment iCount
89970>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
89973>>>>>>>            If (hTable <> 0 and hTable <> 50) Begin // 50 = Flexerrs.
89975>>>>>>>                Get UtilTableRepairAndReindex hTable to bRetval
89976>>>>>>>                If (bRetval = False) Begin
89978>>>>>>>                    Move False to bOK
89979>>>>>>>                End
89979>>>>>>>>
89979>>>>>>>            End
89979>>>>>>>>
89979>>>>>>>        Until (hTable = 0)
89981>>>>>>>                
89981>>>>>>>        Function_Return bOK
89982>>>>>>>    End_Function           
89983>>>>>>>    
89983>>>>>>>    // Checks if an Embedded (DataFlex) data-file needs to be repaired.
89983>>>>>>>    // After the header has been repaired - also makes a re-index.  
89983>>>>>>>    // Returns TRUE if successful OR the table was an an ALIAS or SQL table in case we do nothing.
89983>>>>>>>    Function UtilTableRepairAndReindex Handle hTable Returns Boolean
89985>>>>>>>        Boolean bOK bIsAlias bIsEmbedded bIsOpen bBadExists
89985>>>>>>>        Integer iRetval
89985>>>>>>>        String sRootName sFileName sDataPath
89985>>>>>>>        
89985>>>>>>>        Move False to Err
89986>>>>>>>        Move 0 to LastErr 
89987>>>>>>>        Move True to bOK
89988>>>>>>>        
89988>>>>>>>        Get UtilTableIsEmbedded hTable to bIsEmbedded
89989>>>>>>>        If (bIsEmbedded = False or hTable = 50) Begin // 50 = Flexerrs
89991>>>>>>>            Function_Return True
89992>>>>>>>        End
89992>>>>>>>>
89992>>>>>>>        Get UtilTableIsAlias hTable to bIsAlias 
89993>>>>>>>        If (bIsAlias = True) Begin
89995>>>>>>>            Function_Return True
89996>>>>>>>        End
89996>>>>>>>>
89996>>>>>>>        
89996>>>>>>>        // Check for bad file and remove if exists
89996>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
89999>>>>>>>        Set private.phCurrentTable to hTable  
90000>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT  
90001>>>>>>>        
90001>>>>>>>        // This is important! Else it can happen that the table can't be opened,
90001>>>>>>>        // with a "4077 - File in use" error.
90001>>>>>>>        Close DF_ALL DF_PERMANENT    
90002>>>>>>>        Open hTable
90004>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90007>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90008>>>>>>>        If (bIsOpen = False) Begin
90010>>>>>>>            Error DFERR_PROGRAM ("Could not open table to be repaired and reindexed:" * String(sRootName))
90011>>>>>>>>
90011>>>>>>>            Function_Return False        
90012>>>>>>>        End
90012>>>>>>>>
90012>>>>>>>
90012>>>>>>>        Get vFilePathExists (sRootName + ".BAD")  to bBadExists
90013>>>>>>>        If (bBadExists = True) Begin
90015>>>>>>>            Get_File_Path (sRootName + ".BAD") to sFileName
90016>>>>>>>            Get vDeleteFile sFileName to iRetval
90017>>>>>>>        End
90017>>>>>>>>
90017>>>>>>>        
90017>>>>>>>        Set TableName_Text of ghoStatusPanel to ("Repairing and reindex Table Name:" * sRootName * "Number:" * String(hTable))
90018>>>>>>>        
90018>>>>>>>        Move False to Err
90019>>>>>>>        // **** Repair and reindex the table. ****
90019>>>>>>>        Get UtilTableRepairEmbedded hTable sRootName to bOK
90020>>>>>>>
90020>>>>>>>        // Check for bad file: if it exists, something went wrong
90020>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
90021>>>>>>>        Get vFolderFormat sDataPath to sDataPath
90022>>>>>>>        Get vFilePathExists (sDataPath + sRootName + ".BAD") to bBadExists
90023>>>>>>>        If (bBadExists = True) Begin
90025>>>>>>>            Error DFERR_PROGRAM ("Error while sorting data. .BAD file created:"  * String(sRootName) + ".BAD")
90026>>>>>>>>
90026>>>>>>>            Move False to bOK
90027>>>>>>>        End
90027>>>>>>>>
90027>>>>>>>        Close hTable
90028>>>>>>>
90028>>>>>>>        Function_Return bOK
90029>>>>>>>    End_Function
90030>>>>>>>
90030>>>>>>>    // Repair and reindex the named DataFlex data-table.
90030>>>>>>>    // No checks are done if the passed table name is an embedded or SQL,
90030>>>>>>>    // so use with care (make sure you only pass embedded table names).
90030>>>>>>>    Function UtilTableRepairEmbedded Handle hTable String sTableName Returns Boolean
90032>>>>>>>        String sMode
90032>>>>>>>        Integer iVoid
90032>>>>>>>
90032>>>>>>>        Set Message_Text of ghoStatusPanel to "Repair/Reindex in progress..."
90033>>>>>>>        Move "0" to sMode   // 0=Reindex after repair!    
90034>>>>>>>        Close hTable        // The table needs to be closed, else error 4177 "Table in use".
90035>>>>>>>        Call_Driver 0 DATAFLEX_ID Function FLEX_REPAIR_FILE Callback ghoDbUpdateHandler Passing sTableName sMode 0 Result iVoid 
90040>>>>>>>        Set Message_Text of ghoStatusPanel to ""
90041>>>>>>>        Function_Return (iVoid = 0)
90042>>>>>>>    End_Function
90043>>>>>>>
90043>>>>>>>    // Returns _two_ arrays.
90043>>>>>>>    // Returns all files that are Master files in array ByRef iaFileIsMaster
90043>>>>>>>    // Also returns all files that are Alias files in a second array.
90043>>>>>>>    // IMPORTANT: All master & alias files _must_ have been included into
90043>>>>>>>    //            the DoSetAllMasterAndAlias message.
90043>>>>>>>    Function UtilTableAllMasterAndAliasFiles Integer[] ByRef iaFileIsMaster Returns Integer[]
90045>>>>>>>        Integer[] iaFileIsAlias
90046>>>>>>>        Integer hTable iFileAlias iSize
90046>>>>>>>        Boolean bOpen
90046>>>>>>>
90046>>>>>>>        Move 0 to hTable
90047>>>>>>>        Repeat
90047>>>>>>>>
90047>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
90050>>>>>>>            If (hTable <> 0) Begin
90052>>>>>>>                Open hTable
90054>>>>>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
90057>>>>>>>                If (bOpen = True) Begin
90059>>>>>>>                    Get_Attribute DF_FILE_ALIAS of hTable to iFileAlias
90062>>>>>>>                    If (iFileAlias = DF_FILE_IS_MASTER) Begin
90064>>>>>>>                        Move (SizeOfArray(iaFileIsMaster)) to iSize
90065>>>>>>>                        Move hTable to iaFileIsMaster[iSize]
90066>>>>>>>                    End
90066>>>>>>>>
90066>>>>>>>                    Else If (iFileAlias = DF_FILE_IS_ALIAS) Begin
90069>>>>>>>                        Move (SizeOfArray(iaFileIsAlias)) to iSize
90070>>>>>>>                        Move hTable to iaFileIsAlias[iSize]
90071>>>>>>>                    End
90071>>>>>>>>
90071>>>>>>>                End
90071>>>>>>>>
90071>>>>>>>            End
90071>>>>>>>>
90071>>>>>>>        Until (hTable = 0)
90073>>>>>>>
90073>>>>>>>        Function_Return iaFileIsAlias
90074>>>>>>>    End_Function  
90075>>>>>>>    
90075>>>>>>>    // Is a repair of the data-header necessary? (Embedded tables only)
90075>>>>>>>    Function UtilTableRepairIsNeeded Handle hTable String sTableName Returns Integer
90077>>>>>>>        String sMode
90077>>>>>>>        Integer iRepairNeeded bIsOpen
90077>>>>>>>
90077>>>>>>>        Move "0" to sMode
90078>>>>>>>        Set private.phCurrentTable to hTable 
90079>>>>>>>        Close hTable
90080>>>>>>>        Open hTable
90082>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90085>>>>>>>        Call_Driver hTable DATAFLEX_ID Function FLEX_GET_REPAIRS_NEEDED Callback 0 Passing sTableName sMode 0 Result iRepairNeeded
90090>>>>>>>
90090>>>>>>>        Function_Return iRepairNeeded
90091>>>>>>>    End_Function
90092>>>>>>>
90092>>>>>>>
90092>>>>>>>    // Helper function
90092>>>>>>>    // Takes two params:
90092>>>>>>>    //   1. An array with all master table numbers  (Function UtilTableAllMasterAndAliasFiles)
90092>>>>>>>    //   2. An array with all alias table numbers   (Function UtilTableAllMasterAndAliasFiles)
90092>>>>>>>    // Returns:
90092>>>>>>>    //  DF_FILE_ALIAS_DEFAULT if no master or alias
90092>>>>>>>    //  DF_FILE_IS_MASTER if master
90092>>>>>>>    //  DF_FILE_IS_ALIAS if alias
90092>>>>>>>    Function UtilTableIsMasterAlias Handle hTable Integer[] iaFileIsMaster Integer[] iaFileIsAlias Returns Integer
90094>>>>>>>        Integer i iSize
90094>>>>>>>
90094>>>>>>>        Move (SizeOfArray(iaFileIsMaster)) to iSize
90095>>>>>>>        Decrement iSize
90096>>>>>>>        for i from 0 to iSize
90102>>>>>>>>
90102>>>>>>>            If (hTable = iaFileIsMaster[i]) Begin
90104>>>>>>>                Function_Return DF_FILE_IS_MASTER
90105>>>>>>>            End
90105>>>>>>>>
90105>>>>>>>        Loop
90106>>>>>>>>
90106>>>>>>>
90106>>>>>>>        Move (SizeOfArray(iaFileIsAlias)) to iSize
90107>>>>>>>        Decrement iSize
90108>>>>>>>        for i from 0 to iSize
90114>>>>>>>>
90114>>>>>>>            If (hTable = iaFileIsAlias[i]) Begin
90116>>>>>>>                Function_Return DF_FILE_IS_ALIAS
90117>>>>>>>            End
90117>>>>>>>>
90117>>>>>>>        Loop
90118>>>>>>>>
90118>>>>>>>
90118>>>>>>>        Function_Return DF_FILE_ALIAS_DEFAULT
90119>>>>>>>    End_Function
90120>>>>>>>
90120>>>>>>>    // Determine the available indexes of a table.
90120>>>>>>>    //
90120>>>>>>>    // Arguments:
90120>>>>>>>    //   Handle hTable - The number of the table
90120>>>>>>>    //
90120>>>>>>>    // Returns:
90120>>>>>>>    //   String - A string to be used with the sort command
90120>>>>>>>    //   to re-index all indexes of a table.
90120>>>>>>>    Function UtilTableIndexString Handle hTable Returns String
90122>>>>>>>        String  sSortString
90122>>>>>>>        Integer iLastIndex iNumSegments iCount
90122>>>>>>>
90122>>>>>>>        Move "" to sSortString
90123>>>>>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
90126>>>>>>>
90126>>>>>>>        for iCount from 1 to iLastIndex
90132>>>>>>>>
90132>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iCount to iNumSegments
90135>>>>>>>            If iNumSegments Begin
90137>>>>>>>                If (Length(sSortString)) ;                    Move (Append(sSortString, " ")) to sSortString
90140>>>>>>>                Move (Append(sSortString, iCount)) to sSortString
90141>>>>>>>            End
90141>>>>>>>>
90141>>>>>>>        Loop
90142>>>>>>>>
90142>>>>>>>
90142>>>>>>>        Function_Return sSortString
90143>>>>>>>    End_Function
90144>>>>>>>
90144>>>>>>>    
90144>>>>>>>    // * Dummy function for the Studio's Code Explorer *
90144>>>>>>>    Function API_COLUMN_UTILITY_FUNCTIONS Returns Boolean
90146>>>>>>>        Function_Return False
90147>>>>>>>    End_Function
90148>>>>>>>
90148>>>>>>>    // Compare multiple columns. (For 'FROM' & 'TO' tables)
90148>>>>>>>    Function UtilColumnsCompare String sDriverIDFrom String sDriverIDTo Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare[] aAPIColumnCompare Boolean bCompareDate_DataTime Returns Boolean
90150>>>>>>>        Boolean bIsSame
90150>>>>>>>        Integer iCount iColumns iColumn
90150>>>>>>>
90150>>>>>>>        Move True to bIsSame
90151>>>>>>>        Move (SizeOfArray(aAPIColumnCompare)) to iColumns
90152>>>>>>>        Set piMaximum of ghoProgressBar  to iColumns
90153>>>>>>>        Decrement iColumns
90154>>>>>>>
90154>>>>>>>        for iCount from 0 to iColumns
90160>>>>>>>>
90160>>>>>>>            Set piPosition of ghoProgressBar to iCount
90161>>>>>>>            Get UtilColumnCompare sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare[iCount] bCompareDate_DataTime to bIsSame
90162>>>>>>>            If (bIsSame = False) Begin
90164>>>>>>>                Function_Return False
90165>>>>>>>            End
90165>>>>>>>>
90165>>>>>>>        Loop
90166>>>>>>>>
90166>>>>>>>
90166>>>>>>>        Function_Return (bIsSame = True)
90167>>>>>>>    End_Function
90168>>>>>>>
90168>>>>>>>    // Compares a single column (For 'FROM' & 'TO' tables)
90168>>>>>>>    Function UtilColumnCompare String sDriverIDFrom String sDriverIDTo Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare APIColumnCompare Boolean bCompareDate_DataTime Returns Boolean
90170>>>>>>>        Integer iFromType iToType iDbType
90170>>>>>>>        tColumnType ColumnType
90170>>>>>>>        tColumnType ColumnType
90170>>>>>>>        Boolean bIsDateTypeFrom bIsDateTypeTo
90170>>>>>>>
90170>>>>>>>        If (APIColumnCompare.bCancelFrom = True or APIColumnCompare.bCancelTo = True) Begin
90172>>>>>>>            Function_Return False
90173>>>>>>>        End
90173>>>>>>>>
90173>>>>>>>        If (APIColumnCompare.bExistsFrom = False or APIColumnCompare.bExistsTo = False) Begin
90175>>>>>>>            Function_Return False
90176>>>>>>>        End
90176>>>>>>>>
90176>>>>>>>        If (Uppercase(APIColumnCompare.sFieldNameFrom) <> Uppercase(APIColumnCompare.sFieldNameTo)) Begin
90178>>>>>>>            Function_Return False
90179>>>>>>>        End                                                                
90179>>>>>>>>
90179>>>>>>>
90179>>>>>>>        If (bIsSQLFrom = True and bIsSQLTo = True) Begin
90181>>>>>>>            If (APIColumnCompare.bAllowNULLFrom <> APIColumnCompare.bAllowNULLTo) Begin
90183>>>>>>>                Function_Return False
90184>>>>>>>            End
90184>>>>>>>>
90184>>>>>>>            If (APIColumnCompare.sDefaultValueFrom <> APIColumnCompare.sDefaultValueTo) Begin
90186>>>>>>>                If ((APIColumnCompare.sDefaultValueFrom = ""   and APIColumnCompare.sDefaultValueTo = "''") or ;                    (APIColumnCompare.sDefaultValueFrom = "''" and APIColumnCompare.sDefaultValueTo = "")) Begin
90188>>>>>>>                    End
90188>>>>>>>>
90188>>>>>>>                Else Begin
90189>>>>>>>                    Function_Return False
90190>>>>>>>                End
90190>>>>>>>>
90190>>>>>>>            End
90190>>>>>>>>
90190>>>>>>>        End
90190>>>>>>>>
90190>>>>>>>
90190>>>>>>>        Get piDbType                       to iDbType
90191>>>>>>>        Move APIColumnCompare.iTypeFrom    to iFromType
90192>>>>>>>        Move APIColumnCompare.iTypeTo      to iToType
90193>>>>>>>
90193>>>>>>>        // If one of the two tables are SQL and the other Embedded we need to "translate"
90193>>>>>>>        // data types between Embedded and SQL.
90193>>>>>>>        If (bIsSQLFrom = True and bIsSQLTo = False) Begin
90195>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDFrom iDbType iFromType APIColumnCompare.iLengthFrom to iFromType
90196>>>>>>>        End
90196>>>>>>>>
90196>>>>>>>        If (bIsSQLFrom = False and bIsSQLTo = True) Begin
90198>>>>>>>            Get UtilSQLColumnTypeToDataFlexType sDriverIDTo iDbType iToType APIColumnCompare.iLengthTo to iToType
90199>>>>>>>        End
90199>>>>>>>>
90199>>>>>>>
90199>>>>>>>        Get UtilColumnIsDateType iFromType bIsSQLFrom to bIsDateTypeFrom
90200>>>>>>>        Get UtilColumnIsDateType iToType   bIsSQLTo   to bIsDateTypeTo
90201>>>>>>>
90201>>>>>>>        // Make Date and DateTime comparison?
90201>>>>>>>        If (bCompareDate_DataTime = True) Begin
90203>>>>>>>            If (iFromType <> iToType) Begin
90205>>>>>>>                Function_Return False
90206>>>>>>>            End
90206>>>>>>>>
90206>>>>>>>        End
90206>>>>>>>>
90206>>>>>>>
90206>>>>>>>        // This is when not checking for Date/DateTime differences but all other other field types...
90206>>>>>>>        If (bCompareDate_DataTime = False and bIsDateTypeFrom = False) Begin
90208>>>>>>>            If (iFromType <> iToType) Begin
90210>>>>>>>                Function_Return False
90211>>>>>>>            End
90211>>>>>>>>
90211>>>>>>>        End
90211>>>>>>>>
90211>>>>>>>
90211>>>>>>>        // Only if the field is not a Date type (any of them) we compare length & precision.
90211>>>>>>>        If (bIsDateTypeFrom = False) Begin
90213>>>>>>>            If (APIColumnCompare.iLengthFrom <> APIColumnCompare.iLengthTo) Begin
90215>>>>>>>                Function_Return False
90216>>>>>>>            End
90216>>>>>>>>
90216>>>>>>>            If (APIColumnCompare.iPrecisionFrom <> APIColumnCompare.iPrecisionTo) Begin
90218>>>>>>>                Function_Return False
90219>>>>>>>            End
90219>>>>>>>>
90219>>>>>>>        End
90219>>>>>>>>
90219>>>>>>>
90219>>>>>>>        If (APIColumnCompare.iOptionsFrom <> APIColumnCompare.iOptionsTo) Begin
90221>>>>>>>            Function_Return False
90222>>>>>>>        End
90222>>>>>>>>
90222>>>>>>>
90222>>>>>>>        Function_Return True
90223>>>>>>>    End_Function
90224>>>>>>>
90224>>>>>>>    Function UtilColumnsStructFill Handle hTable Returns tAPIColumn[]
90226>>>>>>>        Integer iNumColumns iColumn iCount iOptions iDbType iType iCheckFieldNumber
90226>>>>>>>        Boolean bIdentityKey bDawSqlDriver bSqlDriver bIsOpen bExists bIsSqlTable bUserCancel
90226>>>>>>>        tAPIColumn[] APIColumns APIColumnsEmpty
90226>>>>>>>        tAPIColumn[] APIColumns APIColumnsEmpty
90228>>>>>>>        String sDriverID sRootName sLogicalName
90228>>>>>>>
90228>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90229>>>>>>>        Get piDbType to iDbType
90230>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
90233>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME    of hTable to sRootName
90236>>>>>>>
90236>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90239>>>>>>>        If (bIsOpen = False) Begin
90241>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90242>>>>>>>            Open hTable
90244>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90245>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90248>>>>>>>            If (bIsOpen = False) Begin
90250>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
90251>>>>>>>                Move True to APIColumnsEmpty[0].bError
90252>>>>>>>                Function_Return APIColumnsEmpty
90253>>>>>>>            End
90253>>>>>>>>
90253>>>>>>>        End
90253>>>>>>>>
90253>>>>>>>
90253>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
90256>>>>>>>        Get IsSQLDriver    sDriverID to bSqlDriver
90257>>>>>>>        Get IsDAWSQLDriver sDriverID to bDawSqlDriver
90258>>>>>>>
90258>>>>>>>        Get UtilTableIsSQLByRootName sRootName to bIsSqlTable
90259>>>>>>>        If (bIsSqlTable = True) Begin
90261>>>>>>>            Get UtilTableExists hTable to bExists
90262>>>>>>>            If (bExists = False) Begin
90264>>>>>>>                Move True to APIColumnsEmpty[0].bError
90265>>>>>>>                Function_Return APIColumnsEmpty
90266>>>>>>>            End
90266>>>>>>>>
90266>>>>>>>        End
90266>>>>>>>>
90266>>>>>>>
90266>>>>>>>        Move 0 to iCount
90267>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
90270>>>>>>>        Set piMaximum of ghoProgressBar to iNumColumns
90271>>>>>>>
90271>>>>>>>        for iColumn from 1 to iNumColumns
90277>>>>>>>>
90277>>>>>>>            Move 0 to iOptions
90278>>>>>>>            Move False to bIdentityKey
90279>>>>>>>            Move False to Err
90280>>>>>>>            Move 0     to LastErr
90281>>>>>>>            Move bIsSqlTable to APIColumns[iCount].bIsSQLType
90282>>>>>>>            Set piPosition of ghoProgressBar to iColumn
90283>>>>>>>            If (bDawSqlDriver = True) Begin
90285>>>>>>>                Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
90286>>>>>>>                If (bIsSqlTable = True) Begin
90288>>>>>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE      of hTable iColumn to iType
90291>>>>>>>                    Move iType                                                to APIColumns[iCount].iType
90292>>>>>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE_NAME of hTable iColumn to APIColumns[iCount].sType
90295>>>>>>>                    Get_Attribute DF_FIELD_NULL_ALLOWED     of hTable iColumn to APIColumns[iCount].bAllowNULL
90298>>>>>>>                    Get_Attribute DF_FIELD_DEFAULT_VALUE    of hTable iColumn to APIColumns[iCount].sDefaultValue
90301>>>>>>>                End
90301>>>>>>>>
90301>>>>>>>                Else Begin
90302>>>>>>>                    Get_Attribute DF_FIELD_TYPE             of hTable iColumn to APIColumns[iCount].iType
90305>>>>>>>                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
90306>>>>>>>                End
90306>>>>>>>>
90306>>>>>>>
90306>>>>>>>                // If the array value is out of bounce it means that this column doesn't exist on the backend.
90306>>>>>>>                Get_Attribute DF_Field_Number of hTable iColumn to iCheckFieldNumber
90309>>>>>>>                Move (iCheckFieldNumber >= 0) to bExists
90310>>>>>>>                If (bExists = False) Begin
90312>>>>>>>                    Move 0 to APIColumns[iCount].iType
90313>>>>>>>                End
90313>>>>>>>>
90313>>>>>>>                If (bExists = True) Begin
90315>>>>>>>                    Get_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to bIdentityKey
90318>>>>>>>                End
90318>>>>>>>>
90318>>>>>>>                Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
90319>>>>>>>                If (bIdentityKey = True) Begin
90321>>>>>>>                    Move C_tAPIColumn_Identity to APIColumns[iCount].iOptions
90322>>>>>>>                End
90322>>>>>>>>
90322>>>>>>>            End
90322>>>>>>>>
90322>>>>>>>            Else Begin
90323>>>>>>>                Move False to Err
90324>>>>>>>                Move 0     to LastErr
90325>>>>>>>                If (bIsSqlTable = True) Begin
90327>>>>>>>                    Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to APIColumns[iCount].iType
90330>>>>>>>                End
90330>>>>>>>>
90330>>>>>>>                Else Begin
90331>>>>>>>                    Get_Attribute DF_FIELD_TYPE        of hTable iColumn to APIColumns[iCount].iType
90334>>>>>>>                    Get UtilColumnTypeToString sDriverID iDbType APIColumns[iCount].iType to APIColumns[iCount].sType
90335>>>>>>>                End
90335>>>>>>>>
90335>>>>>>>                // If the array value is out of bounce it means that this column doesn't exist on the backend.
90335>>>>>>>                Move (LastErr <> DFERR_ARRAY_INDEX_OUT_OF_BOUNDS) to bExists
90336>>>>>>>                If (bExists = False) Begin
90338>>>>>>>                    Move 0 to APIColumns[iCount].iType
90339>>>>>>>                End
90339>>>>>>>>
90339>>>>>>>            End
90339>>>>>>>>
90339>>>>>>>
90339>>>>>>>            If (bExists = True) Begin
90341>>>>>>>                Move iColumn to APIColumns[iCount].iFieldNumber
90342>>>>>>>                Get_Attribute DF_FIELD_NAME        of hTable iColumn to APIColumns[iCount].sFieldName
90345>>>>>>>                // ToDo: Can't use native_size as it can get way to big and causes "out of memory" problems.
90345>>>>>>>//                If (bIsSqlTable = True) Begin
90345>>>>>>>//                    Get_Attribute DF_FIELD_NATIVE_SIZE of hTable iColumn to APIColumns[iCount].iLength
90345>>>>>>>//                    Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
90345>>>>>>>//                End
90345>>>>>>>                Get_Attribute DF_FIELD_LENGTH      of hTable iColumn to APIColumns[iCount].iLength
90348>>>>>>>                Get_Attribute DF_FIELD_PRECISION   of hTable iColumn to APIColumns[iCount].iPrecision
90351>>>>>>>
90351>>>>>>>                // If the length was zero we might have an Overlap(!) field.
90351>>>>>>>                // We then need check the DF_FIELD_TYPE if it really is and reset data for this array item.
90351>>>>>>>                If (APIColumns[iCount].iLength = 0) Begin
90353>>>>>>>                    Get_Attribute DF_FIELD_TYPE    of hTable iColumn to iType
90356>>>>>>>                    If (iType = DF_OVERLAP) Begin
90358>>>>>>>                        Move 0 to APIColumns[iCount].iFieldNumber
90359>>>>>>>                        Move 0 to APIColumns[iCount].iLength
90360>>>>>>>                        Move 0 to APIColumns[iCount].iOptions
90361>>>>>>>                        Move 0 to APIColumns[iCount].iPrecision
90362>>>>>>>                        Move DF_OVERLAP to APIColumns[iCount].iType
90363>>>>>>>                        Move "" to APIColumns[iCount].sFieldName
90364>>>>>>>                        Decrement iCount
90365>>>>>>>                    End
90365>>>>>>>>
90365>>>>>>>                End
90365>>>>>>>>
90365>>>>>>>            End
90365>>>>>>>>
90365>>>>>>>            Get Check_StatusPanel of ghoStatusPanel to bUserCancel
90366>>>>>>>            If (bUserCancel = True) Begin
90368>>>>>>>                Move True to APIColumnsEmpty[0].bCancel
90369>>>>>>>                Function_Return APIColumnsEmpty
90370>>>>>>>            End
90370>>>>>>>>
90370>>>>>>>            Increment iCount
90371>>>>>>>        Loop
90372>>>>>>>>
90372>>>>>>>
90372>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90373>>>>>>>        Function_Return APIColumns
90374>>>>>>>    End_Function
90375>>>>>>>
90375>>>>>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
90375>>>>>>>    // The combined data will be sorted on the first struct member: iIndexNumber
90375>>>>>>>    // This is needed because index numbers can start at any number. The range for a particular table might also
90375>>>>>>>    // have "holes" in the series of index numbers.
90375>>>>>>>    Function UtilColumnCombineFromAndToArrays tAPIColumn[] APIColumnFrom tAPIColumn[] APIColumnTo Returns tAPIIndexCompare[]
90377>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
90377>>>>>>>        tAPIColumnCompare[] aAPIColumnCompare
90378>>>>>>>        tAPIColumnCompare   APIColumnCompare
90378>>>>>>>        tAPIColumnCompare   APIColumnCompare
90378>>>>>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
90378>>>>>>>
90378>>>>>>>        Move (SizeOfArray(APIColumnFrom)) to iSizeFrom
90379>>>>>>>        Decrement iSizeFrom
90380>>>>>>>        for iCount from 0 to iSizeFrom
90386>>>>>>>>
90386>>>>>>>            Move APIColumnFrom[iCount].iFieldNumber     to aAPIColumnCompare[iCount].iFieldNumber
90387>>>>>>>            Move APIColumnFrom[iCount].sFieldName       to aAPIColumnCompare[iCount].sFieldNameFrom
90388>>>>>>>            Move APIColumnFrom[iCount].iType            to aAPIColumnCompare[iCount].iTypeFrom
90389>>>>>>>            Move APIColumnFrom[iCount].sType            to aAPIColumnCompare[iCount].sTypeFrom
90390>>>>>>>            Move APIColumnFrom[iCount].iLength          to aAPIColumnCompare[iCount].iLengthFrom
90391>>>>>>>            Move APIColumnFrom[iCount].iPrecision       to aAPIColumnCompare[iCount].iPrecisionFrom
90392>>>>>>>            Move APIColumnFrom[iCount].iOptions         to aAPIColumnCompare[iCount].iOptionsFrom
90393>>>>>>>            Move APIColumnFrom[iCount].bIsSQLType       to aAPIColumnCompare[iCount].bIsSQLTypeFrom
90394>>>>>>>            Move APIColumnFrom[iCount].bAllowNULL       to aAPIColumnCompare[iCount].bAllowNULLFrom
90395>>>>>>>            Move APIColumnFrom[iCount].sDefaultValue    to aAPIColumnCompare[iCount].sDefaultValueFrom
90396>>>>>>>            Move APIColumnFrom[iCount].bShouldChange    to aAPIColumnCompare[iCount].bShouldChangeFrom
90397>>>>>>>            Move APIColumnFrom[iCount].bCancel          to aAPIColumnCompare[iCount].bCancelFrom
90398>>>>>>>            Move APIColumnFrom[iCount].bError           to aAPIColumnCompare[iCount].bErrorFrom
90399>>>>>>>            Move True                                   to aAPIColumnCompare[iCount].bExistsFrom
90400>>>>>>>        Loop
90401>>>>>>>>
90401>>>>>>>
90401>>>>>>>        Move (SizeOfArray(APIColumnTo)) to iSizeTo
90402>>>>>>>        Decrement iSizeTo
90403>>>>>>>        for iCount from 0 to iSizeTo
90409>>>>>>>>
90409>>>>>>>            Move APIColumnTo[iCount].iFieldNumber       to APIColumnCompare.iFieldNumber
90410>>>>>>>            // Search if the field number already exists in the array; else add it.
90410>>>>>>>            Move (SearchArray(APIColumnCompare, aAPIColumnCompare)) to iItem
90411>>>>>>>            If (iItem = -1) Begin
90413>>>>>>>                Move (SizeOfArray(aAPIColumnCompare))   to iItem
90414>>>>>>>            End
90414>>>>>>>>
90414>>>>>>>
90414>>>>>>>            Move APIColumnCompare.iFieldNumber          to aAPIColumnCompare[iItem].iFieldNumber
90415>>>>>>>            Move APIColumnTo[iCount].iFieldNumber       to aAPIColumnCompare[iItem].iFieldNumberTo
90416>>>>>>>            Move APIColumnTo[iCount].sFieldName         to aAPIColumnCompare[iItem].sFieldNameTo
90417>>>>>>>            Move APIColumnTo[iCount].iType              to aAPIColumnCompare[iItem].iTypeTo
90418>>>>>>>            Move APIColumnTo[iCount].sType              to aAPIColumnCompare[iItem].sTypeTo
90419>>>>>>>            Move APIColumnTo[iCount].iLength            to aAPIColumnCompare[iItem].iLengthTo
90420>>>>>>>            Move APIColumnTo[iCount].iPrecision         to aAPIColumnCompare[iItem].iPrecisionTo
90421>>>>>>>            Move APIColumnTo[iCount].iOptions           to aAPIColumnCompare[iItem].iOptionsTo
90422>>>>>>>            Move APIColumnTo[iCount].bIsSQLType         to aAPIColumnCompare[iItem].bIsSQLTypeTo
90423>>>>>>>            Move APIColumnTo[iCount].bAllowNULL         to aAPIColumnCompare[iItem].bAllowNULLTo
90424>>>>>>>            Move APIColumnTo[iCount].sDefaultValue      to aAPIColumnCompare[iItem].sDefaultValueTo
90425>>>>>>>            Move APIColumnTo[iCount].bShouldChange      to aAPIColumnCompare[iItem].bShouldChangeTo
90426>>>>>>>            Move APIColumnTo[iCount].bCancel            to aAPIColumnCompare[iItem].bCancelTo
90427>>>>>>>            Move APIColumnTo[iCount].bError             to aAPIColumnCompare[iItem].bErrorTo
90428>>>>>>>            Move True                                   to aAPIColumnCompare[iItem].bExistsTo
90429>>>>>>>        Loop
90430>>>>>>>>
90430>>>>>>>
90430>>>>>>>        Move (SortArray(aAPIColumnCompare)) to aAPIColumnCompare
90431>>>>>>>
90431>>>>>>>        Function_Return aAPIColumnCompare
90432>>>>>>>    End_Function
90433>>>>>>>
90433>>>>>>>    // Checks if a field name exists in a table definition
90433>>>>>>>    // Returns True if it does
90433>>>>>>>    // Sample:
90433>>>>>>>    //   Get UtilColumnExists MyTable.File_Number "MyColumnName" to iExists
90433>>>>>>>    Function UtilColumnExists Handle hTable String sFieldName Returns Boolean
90435>>>>>>>        Integer iNumColumns iColumn
90435>>>>>>>        String sColumn
90435>>>>>>>        Boolean bExists bOK bOpen
90435>>>>>>>
90435>>>>>>>        Get AutoConnectionIDLogin to bOK
90436>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90437>>>>>>>        Open hTable
90439>>>>>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90440>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
90443>>>>>>>        If (bOpen = False) Begin
90445>>>>>>>            Function_Return False
90446>>>>>>>        End
90446>>>>>>>>
90446>>>>>>>
90446>>>>>>>        Move False to bExists
90447>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
90450>>>>>>>        for iColumn from 1 to iNumColumns
90456>>>>>>>>
90456>>>>>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
90459>>>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
90461>>>>>>>                Move iNumColumns to iColumn
90462>>>>>>>                Move True to bExists
90463>>>>>>>            End
90463>>>>>>>>
90463>>>>>>>        Loop
90464>>>>>>>>
90464>>>>>>>        Close hTable
90465>>>>>>>
90465>>>>>>>        Function_Return bExists
90466>>>>>>>    End_Function
90467>>>>>>>
90467>>>>>>>    // Returns the field/column number for the passed FieldName as an integer.
90467>>>>>>>    Function UtilColumnNameToColumnNumber Handle hTable String sFieldName Returns Integer
90469>>>>>>>        Integer iNumColumns iColumn iRetval
90469>>>>>>>        String sColumn
90469>>>>>>>        Boolean bOK bOpen
90469>>>>>>>
90469>>>>>>>        Get AutoConnectionIDLogin to bOK
90470>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90471>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90472>>>>>>>        Open hTable
90474>>>>>>>        Send Trap_Error   of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90475>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
90478>>>>>>>        If (bOpen = False) Begin
90480>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
90481>>>>>>>            Function_Return False
90482>>>>>>>        End
90482>>>>>>>>
90482>>>>>>>
90482>>>>>>>        Move 0 to iColumn
90483>>>>>>>        Move 0 to iRetval
90484>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
90487>>>>>>>        for iColumn from 1 to iNumColumns
90493>>>>>>>>
90493>>>>>>>            Get_Attribute DF_FIELD_NAME of hTable iColumn to sColumn
90496>>>>>>>            If (Uppercase(sFieldName) = Uppercase(sColumn)) Begin
90498>>>>>>>                Move iColumn to iRetval
90499>>>>>>>                Move iNumColumns to iColumn
90500>>>>>>>            End
90500>>>>>>>>
90500>>>>>>>        Loop
90501>>>>>>>>
90501>>>>>>>        Close hTable
90502>>>>>>>
90502>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90503>>>>>>>        Function_Return iRetval
90504>>>>>>>    End_Function
90505>>>>>>>
90505>>>>>>>    // To convert between a data type string name and its integer constant declaration. E.g."VarChar" -> SQL_VarChar
90505>>>>>>>    // The reciprocal function is UtilColumnTypeToInteger.
90505>>>>>>>    Function UtilColumnTypeToInteger String sDriverID Integer iDbType String sDataType Returns Integer
90507>>>>>>>        tColumnType RetvalType
90507>>>>>>>        tColumnType RetvalType
90507>>>>>>>
90507>>>>>>>        Get _UtilColumnType sDriverID iDbType 0 sDataType False to RetvalType
90508>>>>>>>        Function_Return RetvalType.iSQLType
90509>>>>>>>    End_Function
90510>>>>>>>
90510>>>>>>>    // To convert between an integer data type constant and its string value. E.g. SQL_VarChar -> "VarChar".
90510>>>>>>>    // The reciprocal function is UtilColumnTypeToString.
90510>>>>>>>    Function UtilColumnTypeToString String sDriverID Integer iDbType Integer iDataType Returns String
90512>>>>>>>        tColumnType RetvalType
90512>>>>>>>        tColumnType RetvalType
90512>>>>>>>
90512>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90513>>>>>>>        Function_Return RetvalType.sSQLType
90514>>>>>>>    End_Function
90515>>>>>>>
90515>>>>>>>    Function UtilColumnTypePrecision String sDriverID Integer iDbType Integer iDataType Returns String
90517>>>>>>>        tColumnType RetvalType
90517>>>>>>>        tColumnType RetvalType
90517>>>>>>>
90517>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90518>>>>>>>        Function_Return RetvalType.sPrecision
90519>>>>>>>    End_Function
90520>>>>>>>
90520>>>>>>>    Function UtilColumnTypeFixed String sDriverID Integer iDbType Integer iDataType Returns Boolean
90522>>>>>>>        tColumnType RetvalType
90522>>>>>>>        tColumnType RetvalType
90522>>>>>>>
90522>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90523>>>>>>>        // Nils 2019-02-15. This return value seems to have been wrong. The function should return False
90523>>>>>>>        // if the column type length is _not_ fixed.
90523>>>>>>>        Function_Return (RetvalType.bCanEditSize = False)
90524>>>>>>>    End_Function
90525>>>>>>>
90525>>>>>>>    Function UtilColumnTypePrecisionSize String sDriverID Integer iDbType Integer iDataType Returns Integer
90527>>>>>>>        tColumnType RetvalType
90527>>>>>>>        tColumnType RetvalType
90527>>>>>>>        String sValue
90527>>>>>>>        Integer iRetval iPos
90527>>>>>>>
90527>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90528>>>>>>>        Move RetvalType.sPrecision to sValue
90529>>>>>>>        Move (Pos(".", sValue)) to iPos
90530>>>>>>>        If (iPos <> 0) Begin
90532>>>>>>>            Move (Left(sValue, (iPos -1))) to iRetval
90533>>>>>>>        End
90533>>>>>>>>
90533>>>>>>>        Else Begin
90534>>>>>>>            Move sValue to iRetval
90535>>>>>>>        End
90535>>>>>>>>
90535>>>>>>>        Function_Return iRetval
90536>>>>>>>    End_Function
90537>>>>>>>
90537>>>>>>>    Function UtilColumnTypePrecisionDec String sDriverID Integer iDbType Integer iDataType Returns Integer
90539>>>>>>>        tColumnType RetvalType
90539>>>>>>>        tColumnType RetvalType
90539>>>>>>>        String sValue
90539>>>>>>>        Integer iRetval iPos
90539>>>>>>>
90539>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
90540>>>>>>>        Move RetvalType.sPrecision to sValue
90541>>>>>>>        Move (Pos(".", sValue)) to iPos
90542>>>>>>>        If (iPos = 0) Begin
90544>>>>>>>            Function_Return 0
90545>>>>>>>        End
90545>>>>>>>>
90545>>>>>>>        Move (Mid(sValue, 99, (iPos + 1))) to iRetval
90546>>>>>>>
90546>>>>>>>        Function_Return iRetval
90547>>>>>>>    End_Function
90548>>>>>>>
90548>>>>>>>    // * Dummy function for the Studio's Code Explorer *
90548>>>>>>>    Function API_INDEX_UTILITY_FUNCTIONS Returns Boolean
90550>>>>>>>        Function_Return False
90551>>>>>>>    End_Function
90552>>>>>>>
90552>>>>>>>    // Compares multiple indexes for a 'FROM' and a 'TO' table.
90552>>>>>>>    Function UtilIndexesCompare Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndexCompare[] aAPIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
90554>>>>>>>        Boolean bIsSame
90554>>>>>>>        Integer iCount iSize
90554>>>>>>>
90554>>>>>>>        Move True to bIsSame
90555>>>>>>>        Move (SizeOfArray(aAPIIndexCompare)) to iSize
90556>>>>>>>        Decrement iSize
90557>>>>>>>        For iCount from 0 to iSize
90563>>>>>>>>
90563>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90564>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
90565>>>>>>>            Get UtilIndexCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
90566>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
90567>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
90568>>>>>>>            If (bIsSame = False) Begin
90570>>>>>>>                Function_Return False
90571>>>>>>>            End
90571>>>>>>>>
90571>>>>>>>        Loop
90572>>>>>>>>
90572>>>>>>>
90572>>>>>>>        Function_Return bIsSame
90573>>>>>>>    End_Function
90574>>>>>>>
90574>>>>>>>    // Compares a single index for a 'FROM' and a 'TO' table.
90574>>>>>>>    Function UtilIndexCompare Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndexCompare APIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
90576>>>>>>>        Boolean bIsSame
90576>>>>>>>        Integer iSegment
90576>>>>>>>
90576>>>>>>>        Move (APIIndexCompare.bExistsFrom = APIIndexCompare.bExistsTo) to bIsSame
90577>>>>>>>        If (bIsSame = False) Begin
90579>>>>>>>            Function_Return False
90580>>>>>>>        End
90580>>>>>>>>
90580>>>>>>>        Move (APIIndexCompare.iPrimaryIndexFrom = APIIndexCompare.iPrimaryIndexTo) to bIsSame
90581>>>>>>>        If (bIsSame = False) Begin
90583>>>>>>>            Function_Return False
90584>>>>>>>        End
90584>>>>>>>>
90584>>>>>>>
90584>>>>>>>        If (bIsSqlTableFrom = True and bIsSqlTableTo = True) Begin
90586>>>>>>>            // * We should probably not compare SQL index names?
90586>>>>>>>            // Move (Uppercase(aIndexFrom.sSQLIndexName) = Uppercase(aIndexTo.sSQLIndexName)) to bIsSame
90586>>>>>>>            // If (bIsSame = False) Begin   DF_INDEX_SERVER_ONLY
90586>>>>>>>            //     Function_Return False
90586>>>>>>>            // End
90586>>>>>>>            Move (APIIndexCompare.bIsSQLPrimaryKeyFrom = APIIndexCompare.bIsSQLPrimaryKeyTo) to bIsSame
90587>>>>>>>            If (bIsSame = False) Begin
90589>>>>>>>                Function_Return False
90590>>>>>>>            End
90590>>>>>>>>
90590>>>>>>>            Move (APIIndexCompare.bIsSQLClusteredFrom = APIIndexCompare.bIsSQLClusteredTo) to bIsSame
90591>>>>>>>            If (bIsSame = False) Begin
90593>>>>>>>                Function_Return False
90594>>>>>>>            End
90594>>>>>>>>
90594>>>>>>>            Move (APIIndexCompare.iSQLIndexTypeFrom = APIIndexCompare.iSQLIndexTypeTo) to bIsSame
90595>>>>>>>            If (bIsSame = False) Begin
90597>>>>>>>                Function_Return False
90598>>>>>>>            End
90598>>>>>>>>
90598>>>>>>>            Move (Uppercase(APIIndexCompare.sSQLIndexNameFrom) = Uppercase(APIIndexCompare.sSQLIndexNameTo)) to bIsSame
90599>>>>>>>            If (bIsSame = False) Begin
90601>>>>>>>                Function_Return False
90602>>>>>>>            End
90602>>>>>>>>
90602>>>>>>>        End
90602>>>>>>>>
90602>>>>>>>
90602>>>>>>>        Get UtilIndexSegmentsCompare APIIndexCompare.IndexSegmentArrayFrom APIIndexCompare.IndexSegmentArrayTo bCompareIndexUppercase bCompareIndexAscending to iSegment
90603>>>>>>>        Move (iSegment = -1) to bIsSame
90604>>>>>>>
90604>>>>>>>        Function_Return (bIsSame = True)
90605>>>>>>>    End_Function
90606>>>>>>>
90606>>>>>>>    // Compares each segment for the passed index.
90606>>>>>>>    // Returns -1 if same; else returns the index segment that differs.
90606>>>>>>>    Function UtilIndexSegmentsCompare tAPIIndexSegment[] aIndexSegmentFrom tAPIIndexSegment[] aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
90608>>>>>>>        Integer iNumSegmentsFrom iNumSegmentsTo iNumSegments iSegment
90608>>>>>>>        Boolean bIsSame
90608>>>>>>>
90608>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
90609>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90610>>>>>>>        Move (SizeOfArray(aIndexSegmentFrom))      to iNumSegmentsFrom
90611>>>>>>>        Move (SizeOfArray(aIndexSegmentTo))        to iNumSegmentsTo
90612>>>>>>>        Move (iNumSegmentsFrom max iNumSegmentsTo) to iNumSegments
90613>>>>>>>
90613>>>>>>>        Decrement iNumSegments
90614>>>>>>>        for iSegment from 0 to iNumSegments
90620>>>>>>>>
90620>>>>>>>            Move False to bIsSame
90621>>>>>>>            If (iSegment < iNumSegmentsFrom and iSegment < iNumSegmentsTo) Begin
90623>>>>>>>                Get UtilIndexSegmentCompare aIndexSegmentFrom[iSegment] aIndexSegmentTo[iSegment] bCompareIndexUppercase bCompareIndexAscending to bIsSame
90624>>>>>>>            End
90624>>>>>>>>
90624>>>>>>>            If (bIsSame = False) Begin
90626>>>>>>>                Send Trap_Error of Error_Object_Id DFERR_ARRAY_INDEX_OUT_OF_BOUNDS
90627>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
90628>>>>>>>                Function_Return iSegment
90629>>>>>>>            End
90629>>>>>>>>
90629>>>>>>>        Loop
90630>>>>>>>>
90630>>>>>>>
90630>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90631>>>>>>>        Function_Return -1 // This means bIsSame = True
90632>>>>>>>    End_Function
90633>>>>>>>
90633>>>>>>>    Function UtilIndexSegmentCompare tAPIIndexSegment aIndexSegmentFrom tAPIIndexSegment aIndexSegmentTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Integer
90635>>>>>>>        Boolean bIsSame
90635>>>>>>>
90635>>>>>>>        Move (aIndexSegmentFrom.iFieldNumber = aIndexSegmentTo.iFieldNumber) to bIsSame
90636>>>>>>>        If (bIsSame = False) Begin
90638>>>>>>>            Function_Return False
90639>>>>>>>        End
90639>>>>>>>>
90639>>>>>>>        If (bCompareIndexUppercase = True) Begin
90641>>>>>>>            Move (aIndexSegmentFrom.bUppercase = aIndexSegmentTo.bUppercase) to bIsSame
90642>>>>>>>            If (bIsSame = False) Begin
90644>>>>>>>                Function_Return False
90645>>>>>>>            End
90645>>>>>>>>
90645>>>>>>>        End
90645>>>>>>>>
90645>>>>>>>        If (bCompareIndexAscending = True) Begin
90647>>>>>>>            Move (aIndexSegmentFrom.bAscending = aIndexSegmentTo.bAscending) to bIsSame
90648>>>>>>>            If (bIsSame = False) Begin
90650>>>>>>>                Function_Return False
90651>>>>>>>            End
90651>>>>>>>>
90651>>>>>>>        End
90651>>>>>>>>
90651>>>>>>>
90651>>>>>>>        Function_Return True
90652>>>>>>>    End_Function
90653>>>>>>>
90653>>>>>>>    Function UtilIndexesUpdate Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo tAPIIndex[] aIndexesFrom tAPIIndex[] aIndexesTo Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Returns Boolean
90655>>>>>>>        Boolean bIsSame bOK
90655>>>>>>>        Integer iSize iSizeTo iCount
90655>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
90655>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
90656>>>>>>>
90656>>>>>>>        Move (SizeOfArray(aIndexesFrom)) to iSize
90657>>>>>>>        If (iSize = 0) Begin
90659>>>>>>>            Function_Return True
90660>>>>>>>        End
90660>>>>>>>>
90660>>>>>>>        Move (SizeOfArray(aIndexesTo)) to iSizeTo
90661>>>>>>>        Get UtilTableIsSql hTable to bIsSQLTableTo
90662>>>>>>>        Get UtilIndexCombineFromAndToArrays aIndexesFrom aIndexesTo to aAPIIndexCompare
90663>>>>>>>
90663>>>>>>>        for iCount from 0 to (iSize - 1)
90669>>>>>>>>
90669>>>>>>>            Get UtilIndexCompare bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexUppercase bCompareIndexAscending to bIsSame
90670>>>>>>>            If (bIsSame = False) Begin
90672>>>>>>>                Get APIIndexCreateByFieldNames hTable aIndexesFrom[iCount] aIndexesTo aIndexesFrom[iCount].IndexSegmentArray to bOK
90673>>>>>>>            End
90673>>>>>>>>
90673>>>>>>>        Loop
90674>>>>>>>>
90674>>>>>>>
90674>>>>>>>        // We probably should delete other indexes if they exists.
90674>>>>>>>        for iCount from (iSize +1) to iSizeTo
90680>>>>>>>>
90680>>>>>>>            Get ApiIndexRemove hTable iCount to bOK
90681>>>>>>>        Loop
90682>>>>>>>>
90682>>>>>>>
90682>>>>>>>        Function_Return bOK
90683>>>>>>>    End_Function
90684>>>>>>>
90684>>>>>>>//    Function UtilIsSameColumnDefinitions Handle hTable tAPIColumn[] aColumns Returns Boolean
90684>>>>>>>//        Boolean bEqual bIdentityKey bSqlDriver bDawSqlDriver bIsOpen
90684>>>>>>>//        Integer iCount iColumn iSize iOptions iLength iPrecision iType
90684>>>>>>>//        String sFieldName sDriverID
90684>>>>>>>//
90684>>>>>>>//        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90684>>>>>>>//        If (bIsOpen = False) Begin
90684>>>>>>>//            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90684>>>>>>>//            Open hTable
90684>>>>>>>//            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90684>>>>>>>//            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90684>>>>>>>//            If (bIsOpen = False) Begin
90684>>>>>>>//                Function_Return False
90684>>>>>>>//            End
90684>>>>>>>//        End
90684>>>>>>>//
90684>>>>>>>//        Move True to bEqual
90684>>>>>>>//        Get psDriverID to sDriverID
90684>>>>>>>//        Get IsSQLDriver    sDriverID to bSqlDriver
90684>>>>>>>//        Get IsDAWSQLDriver sDriverID to bDawSqlDriver
90684>>>>>>>//        Move (SizeOfArray(aColumns)) to iSize
90684>>>>>>>//        Decrement iSize
90684>>>>>>>//
90684>>>>>>>//        For iCount from 0 to iSize
90684>>>>>>>//            Move 0 to iOptions
90684>>>>>>>//            Move False to bIdentityKey
90684>>>>>>>//            Move aColumns[iCount].sFieldName to sFieldName
90684>>>>>>>//
90684>>>>>>>//            // We need to use the column name - not the column integer as
90684>>>>>>>//            // the order does not need to be the same, and the logic should still work.
90684>>>>>>>//            Get UtilColumnNameToColumnNumber hTable sFieldName to iColumn
90684>>>>>>>//            If (iColumn > 0) Begin
90684>>>>>>>//                If (bDawSqlDriver = True) Begin
90684>>>>>>>//                    Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
90684>>>>>>>//                    Get_Attribute DF_FIELD_NATIVE_TYPE of hTable iColumn to iType
90684>>>>>>>//                    If (iType <> aColumns[iCount].iSQLType) Begin
90684>>>>>>>//                        Move False to bEqual
90684>>>>>>>//                    End
90684>>>>>>>//                    Get_Attribute DF_FIELD_IS_IDENTITY of hTable iColumn to bIdentityKey
90684>>>>>>>//                    If (bIdentityKey = True) Begin
90684>>>>>>>//                        Move C_tAPIColumn_Identity to iOptions
90684>>>>>>>//                    End
90684>>>>>>>//                    If (iOptions <> aColumns[iCount].iOptions) Begin
90684>>>>>>>//                        Move False to bEqual
90684>>>>>>>//                    End
90684>>>>>>>//                    Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
90684>>>>>>>//                End
90684>>>>>>>//                Else Begin
90684>>>>>>>//                    Get_Attribute DF_FIELD_TYPE     of hTable iColumn to iType
90684>>>>>>>//                    If (iType <> aColumns[iCount].iSQLType) Begin
90684>>>>>>>//                        Move False to bEqual
90684>>>>>>>//                    End
90684>>>>>>>//                End
90684>>>>>>>//                Get_Attribute DF_FIELD_LENGTH       of hTable iColumn to iLength
90684>>>>>>>//                If (iLength <> aColumns[iCount].iLength) Begin
90684>>>>>>>//                    Move False to bEqual
90684>>>>>>>//                End
90684>>>>>>>//                Get_Attribute DF_FIELD_PRECISION    of hTable iColumn to iPrecision
90684>>>>>>>//                If (iPrecision <> aColumns[iCount].iPrecision) Begin
90684>>>>>>>//                    Move False to bEqual
90684>>>>>>>//                End
90684>>>>>>>//                If (bEqual = False) Begin
90684>>>>>>>//                    Function_Return False
90684>>>>>>>//                End
90684>>>>>>>//            End
90684>>>>>>>//
90684>>>>>>>//            Else Begin
90684>>>>>>>//                Function_Return False
90684>>>>>>>//            End
90684>>>>>>>//        Loop
90684>>>>>>>//
90684>>>>>>>//        Function_Return bEqual
90684>>>>>>>//    End_Function
90684>>>>>>>
90684>>>>>>>    Function UtilIndexesStructFill Handle hTable Returns tAPIIndex[]
90686>>>>>>>        tAPIIndex[] APIIndexes
90686>>>>>>>        tAPIIndex[] APIIndexes
90687>>>>>>>        Integer iCount iIndex iIndexes iSegment iSegmentCount iNumSegments iColumn
90687>>>>>>>        String sDriverID
90687>>>>>>>        Boolean bDAWSQLDriver bIsOpen bIsSQLTable
90687>>>>>>>
90687>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90688>>>>>>>        Get psDriverID to sDriverID
90689>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
90690>>>>>>>        Get UtilTableIsSQL hTable to bIsSQLTable
90691>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90694>>>>>>>        If (bIsOpen = False) Begin
90696>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90697>>>>>>>            Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90698>>>>>>>            Open hTable
90700>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
90701>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90702>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90705>>>>>>>            If (bIsOpen = False) Begin
90707>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
90708>>>>>>>                Move True to APIIndexes[0].bError
90709>>>>>>>                Function_Return APIIndexes
90710>>>>>>>            End
90710>>>>>>>>
90710>>>>>>>        End
90710>>>>>>>>
90710>>>>>>>
90710>>>>>>>        Move 0 to iCount
90711>>>>>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iIndexes
90714>>>>>>>        for iIndex from 1 to iIndexes
90720>>>>>>>>
90720>>>>>>>            // This is a test that the index exists as there might be "holes" aka the index
90720>>>>>>>            // numbers doesn't not need to be consequitive:
90720>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
90723>>>>>>>            If (iNumSegments > 0) Begin
90725>>>>>>>
90725>>>>>>>                Move iIndex                                                     to APIIndexes[iCount].iIndexNumber
90726>>>>>>>                Get_Attribute DF_FILE_PRIMARY_INDEX of hTable                   to APIIndexes[iCount].iPrimaryIndex
90729>>>>>>>                If (bIsSQLTable = True) Begin
90731>>>>>>>                    Get_Attribute DF_INDEX_NAME         of hTable iIndex        to APIIndexes[iCount].sSQLIndexName
90734>>>>>>>                        Get_Attribute DF_INDEX_SQL_PRIMARY_KEY of hTable iIndex to APIIndexes[iCount].bIsSQLPrimaryKey
90737>>>>>>>                        Get_Attribute DF_INDEX_CLUSTERED of hTable iIndex       to APIIndexes[iCount].bIsSQLClustered
90740>>>>>>>                        Get_Attribute DF_INDEX_SQL_TYPE of hTable iIndex        to APIIndexes[iCount].iSQLIndexType // (DF_INDEX_SQL_TYPE = DF_INDEX_SERVER, DF_INDEX_CLIENT, DF_INDEX_SERVER_ONLY or DF_INDEX_TEMPORARY)
90743>>>>>>>                End
90743>>>>>>>>
90743>>>>>>>
90743>>>>>>>                Move 0 to iSegmentCount
90744>>>>>>>                Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
90747>>>>>>>                For iSegment from 1 to iNumSegments
90753>>>>>>>>
90753>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTable iIndex iSegment to iColumn
90756>>>>>>>                    Move iColumn                                                       to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].iFieldNumber
90757>>>>>>>                    Get_Attribute DF_FIELD_NAME              of hTable iColumn         to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].sFieldName
90760>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_CASE      of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bUppercase
90763>>>>>>>                    Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTable iIndex iSegment to APIIndexes[iCount].IndexSegmentArray[iSegmentCount].bAscending
90766>>>>>>>                    Increment iSegmentCount
90767>>>>>>>                Loop
90768>>>>>>>>
90768>>>>>>>                Increment iCount
90769>>>>>>>            End
90769>>>>>>>>
90769>>>>>>>        Loop
90770>>>>>>>>
90770>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
90771>>>>>>>
90771>>>>>>>        Function_Return APIIndexes
90772>>>>>>>    End_Function
90773>>>>>>>
90773>>>>>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
90773>>>>>>>    // The combined data will be sorted on the first struct member: iIndexNumber
90773>>>>>>>    // This is needed because index numbers can start at any number. The range for a particular table might also
90773>>>>>>>    // have "holes" in the series of index numbers.
90773>>>>>>>    Function UtilIndexCombineFromAndToArrays tAPIIndex[] APIIndexFrom tAPIIndex[] APIIndexTo Returns tAPIIndexCompare[]
90775>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
90775>>>>>>>        tAPIIndexCompare[] aAPIIndexCompare
90776>>>>>>>        tAPIIndexCompare   APIIndexCompare
90776>>>>>>>        tAPIIndexCompare   APIIndexCompare
90776>>>>>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
90776>>>>>>>
90776>>>>>>>        Move (SizeOfArray(APIIndexFrom)) to iSizeFrom
90777>>>>>>>        Move (SizeOfArray(APIIndexTo)) to iSizeTo
90778>>>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
90780>>>>>>>            Function_Return aAPIIndexCompare
90781>>>>>>>        End
90781>>>>>>>>
90781>>>>>>>
90781>>>>>>>        Decrement iSizeFrom
90782>>>>>>>        for iCount from 0 to iSizeFrom
90788>>>>>>>>
90788>>>>>>>            Move APIIndexFrom[iCount].iIndexNumber      to aAPIIndexCompare[iCount].iIndexNumber
90789>>>>>>>            Move APIIndexFrom[iCount].iPrimaryIndex     to aAPIIndexCompare[iCount].iPrimaryIndexFrom
90790>>>>>>>            Move APIIndexFrom[iCount].sSQLIndexName     to aAPIIndexCompare[iCount].sSQLIndexNameFrom
90791>>>>>>>            Move APIIndexFrom[iCount].iSQLIndexType     to aAPIIndexCompare[iCount].iSQLIndexTypeFrom
90792>>>>>>>            Move APIIndexFrom[iCount].bIsSQLClustered   to aAPIIndexCompare[iCount].bIsSQLClusteredFrom
90793>>>>>>>            Move APIIndexFrom[iCount].bIsSQLPrimaryKey  to aAPIIndexCompare[iCount].bIsSQLPrimaryKeyFrom
90794>>>>>>>            Move APIIndexFrom[iCount].IndexSegmentArray to aAPIIndexCompare[iCount].IndexSegmentArrayFrom
90795>>>>>>>            Move APIIndexFrom[iCount].bShouldChange     to aAPIIndexCompare[iCount].bShouldChangeFrom
90796>>>>>>>            Move APIIndexFrom[iCount].bCancel           to aAPIIndexCompare[iCount].bCancelFrom
90797>>>>>>>            Move APIIndexFrom[iCount].bError            to aAPIIndexCompare[iCount].bErrorFrom
90798>>>>>>>            Move True                                   to aAPIIndexCompare[iCount].bExistsFrom
90799>>>>>>>        Loop
90800>>>>>>>>
90800>>>>>>>
90800>>>>>>>        Decrement iSizeTo
90801>>>>>>>        for iCount from 0 to iSizeTo
90807>>>>>>>>
90807>>>>>>>            Move APIIndexTo[iCount].iIndexNumber        to APIIndexCompare.iIndexNumber
90808>>>>>>>            // Search if the Index number already exists in the array; else add it.
90808>>>>>>>            Move (SearchArray(APIIndexCompare, aAPIIndexCompare)) to iItem
90809>>>>>>>            If (iItem = -1) Begin
90811>>>>>>>                Move (SizeOfArray(aAPIIndexCompare))    to iItem
90812>>>>>>>            End
90812>>>>>>>>
90812>>>>>>>
90812>>>>>>>            Move APIIndexCompare.iIndexNumber           to aAPIIndexCompare[iItem].iIndexNumber
90813>>>>>>>            Move APIIndexTo[iCount].iPrimaryIndex       to aAPIIndexCompare[iItem].iPrimaryIndexTo
90814>>>>>>>            Move APIIndexTo[iCount].sSQLIndexName       to aAPIIndexCompare[iItem].sSQLIndexNameTo
90815>>>>>>>            Move APIIndexTo[iCount].iSQLIndexType       to aAPIIndexCompare[iItem].iSQLIndexTypeTo
90816>>>>>>>            Move APIIndexTo[iCount].bIsSQLClustered     to aAPIIndexCompare[iItem].bIsSQLClusteredTo
90817>>>>>>>            Move APIIndexTo[iCount].bIsSQLPrimaryKey    to aAPIIndexCompare[iItem].bIsSQLPrimaryKeyTo
90818>>>>>>>            Move APIIndexTo[iCount].IndexSegmentArray   to aAPIIndexCompare[iItem].IndexSegmentArrayTo
90819>>>>>>>            Move APIIndexTo[iCount].bShouldChange       to aAPIIndexCompare[iItem].bShouldChangeTo
90820>>>>>>>            Move APIIndexTo[iCount].bCancel             to aAPIIndexCompare[iItem].bCancelTo
90821>>>>>>>            Move APIIndexTo[iCount].bError              to aAPIIndexCompare[iItem].bErrorTo
90822>>>>>>>            Move True                                   to aAPIIndexCompare[iItem].bExistsTo
90823>>>>>>>        Loop
90824>>>>>>>>
90824>>>>>>>
90824>>>>>>>        Move (SortArray(aAPIIndexCompare)) to aAPIIndexCompare
90825>>>>>>>
90825>>>>>>>        Function_Return aAPIIndexCompare
90826>>>>>>>    End_Function
90827>>>>>>>
90827>>>>>>>    // This is the same as the UtilIndexCompare function but it takes tAPIIndex structs as params.
90827>>>>>>>    Function UtilIndexTypeNumberCompare Handle hTable tAPIIndex aIndexFrom tAPIIndex aIndexTo Returns Boolean
90829>>>>>>>        Boolean bIsSame bDAWSQLDriver bIsSqlTable
90829>>>>>>>        String sDriverID
90829>>>>>>>
90829>>>>>>>        Get psDriverID to sDriverID
90830>>>>>>>        Get IsDAWSQLDriver sDriverID to bDAWSQLDriver
90831>>>>>>>        Get IsSQLDriver sDriverID to bIsSqlTable
90832>>>>>>>        If (bIsSqlTable = True) Begin
90834>>>>>>>            Get UtilTableIsSQL hTable to bIsSqlTable
90835>>>>>>>        End
90835>>>>>>>>
90835>>>>>>>
90835>>>>>>>        Move (aIndexFrom.iIndexNumber = aIndexTo.iIndexNumber) to bIsSame
90836>>>>>>>        If (bIsSame = False) Begin
90838>>>>>>>            Function_Return False
90839>>>>>>>        End
90839>>>>>>>>
90839>>>>>>>
90839>>>>>>>        If (bDAWSQLDriver = True and bIsSqlTable = True) Begin
90841>>>>>>>            // Don't think we should do this. Or should we?
90841>>>>>>>            // Move (aIndexesFrom[iCount].sSQLIndexName = aIndexesTo[iCount].sSQLIndexName) to bIsSame
90841>>>>>>>
90841>>>>>>>            Move (aIndexFrom.iSQLIndexType = aIndexTo.iSQLIndexType) to bIsSame
90842>>>>>>>            If (bIsSame = False) Begin
90844>>>>>>>                Function_Return False
90845>>>>>>>            End
90845>>>>>>>>
90845>>>>>>>            Move (aIndexFrom.iPrimaryIndex = aIndexTo.iPrimaryIndex) to bIsSame
90846>>>>>>>            If (bIsSame = False) Begin
90848>>>>>>>                Function_Return False
90849>>>>>>>            End
90849>>>>>>>>
90849>>>>>>>            Move (aIndexFrom.bIsSQLPrimaryKey = aIndexTo.bIsSQLPrimaryKey) to bIsSame
90850>>>>>>>            If (bIsSame = False) Begin
90852>>>>>>>                Function_Return False
90853>>>>>>>            End
90853>>>>>>>>
90853>>>>>>>            Move (aIndexFrom.bIsSQLClustered = aIndexTo.bIsSQLClustered) to bIsSame
90854>>>>>>>            If (bIsSame = False) Begin
90856>>>>>>>                Function_Return False
90857>>>>>>>            End
90857>>>>>>>>
90857>>>>>>>        End
90857>>>>>>>>
90857>>>>>>>
90857>>>>>>>        Function_Return bIsSame
90858>>>>>>>    End_Function
90859>>>>>>>
90859>>>>>>>    // DF_INDEX_SQL_TYPE values
90859>>>>>>>    // Pass one of the DF_INDEX_XXX integer constants and the function
90859>>>>>>>    // returns a string with the name.
90859>>>>>>>    Function UtilIndexTypeToString Integer iIndexType Returns String
90861>>>>>>>        String sRetval
90861>>>>>>>        Case Begin
90861>>>>>>>            Case (iIndexType = DF_INDEX_CLIENT)
90863>>>>>>>                Move "DF_INDEX_CLIENT" to sRetval
90864>>>>>>>                Case Break
90865>>>>>>>            Case (iIndexType = DF_INDEX_SERVER)
90868>>>>>>>                Move "DF_INDEX_SERVER" to sRetval
90869>>>>>>>                Case Break
90870>>>>>>>            Case (iIndexType = DF_INDEX_SERVER_ONLY)
90873>>>>>>>                Move "DF_INDEX_SERVER_ONLY" to sRetval
90874>>>>>>>                Case Break
90875>>>>>>>            Case (iIndexType = DF_INDEX_TEMPORARY)
90878>>>>>>>                Move "DF_INDEX_TEMPORARY" to sRetval
90879>>>>>>>                Case Break
90880>>>>>>>            Case Else
90880>>>>>>>                Move "UNKNOWN INDEX TYPE" to sRetval
90881>>>>>>>        Case End
90881>>>>>>>        Function_Return sRetval
90882>>>>>>>    End_Function
90883>>>>>>>
90883>>>>>>>    // * Dummy function for the Studio's Code Explorer *
90883>>>>>>>    Function API_RELATION_UTILITY_FUNCTIONS Returns Boolean
90885>>>>>>>        Function_Return False
90886>>>>>>>    End_Function
90887>>>>>>>
90887>>>>>>>    // Compares multiple relationships for a 'FROM' and a 'TO' databases
90887>>>>>>>    Function UtilRelationsCompare Handle hTable tAPIRelationCompare[] aAPIRelationCompare Returns Boolean
90889>>>>>>>        Boolean bIsSame
90889>>>>>>>        Integer iSize iCount
90889>>>>>>>
90889>>>>>>>        Move True to bIsSame
90890>>>>>>>        Move (SizeOfArray(aAPIRelationCompare)) to iSize
90891>>>>>>>        Decrement iSize
90892>>>>>>>        For iCount from 0 to iSize
90898>>>>>>>>
90898>>>>>>>            Get UtilRelationCompare hTable aAPIRelationCompare[iCount] to bIsSame
90899>>>>>>>            If (bIsSame = False) Begin
90901>>>>>>>                Function_Return False
90902>>>>>>>            End
90902>>>>>>>>
90902>>>>>>>        Loop
90903>>>>>>>>
90903>>>>>>>
90903>>>>>>>        Function_Return bIsSame
90904>>>>>>>    End_Function
90905>>>>>>>
90905>>>>>>>    // Compares a single relationship for a 'FROM' and a 'TO' table
90905>>>>>>>    Function UtilRelationCompare Handle hTable tAPIRelationCompare APIRelationCompare Returns Boolean
90907>>>>>>>        Boolean bIsSame
90907>>>>>>>
90907>>>>>>>        Move True to bIsSame
90908>>>>>>>        If (APIRelationCompare.bExistsFrom <> APIRelationCompare.bExistsTo) Begin
90910>>>>>>>            Function_Return False
90911>>>>>>>        End
90911>>>>>>>>
90911>>>>>>>        If (APIRelationCompare.hTableFrom = 0 or APIRelationCompare.hTableTo = 0) Begin
90913>>>>>>>            Function_Return False
90914>>>>>>>        End
90914>>>>>>>>
90914>>>>>>>
90914>>>>>>>        // We could also compare field names, but I don't think that is necessary...
90914>>>>>>>
90914>>>>>>>        Function_Return bIsSame
90915>>>>>>>    End_Function
90916>>>>>>>
90916>>>>>>>    // This message is different from ApiTableCreate in that it will not do a function_return if the table
90916>>>>>>>    // already exists.
90916>>>>>>>    Function UtilRelationsUpdate Handle hTable tAPIRelation[] aRelationsFrom tAPIRelation[] aRelationsTo Returns Boolean
90918>>>>>>>        Boolean bOK
90918>>>>>>>        Integer iSizeTo iSize iCount iColumn
90918>>>>>>>        String sDriverID
90918>>>>>>>
90918>>>>>>>        Move True to bOK
90919>>>>>>>        Move (SizeOfArray(aRelationsTo))   to iSizeTo
90920>>>>>>>        If (iSizeTo > 0) Begin
90922>>>>>>>            Get AutoConnectionIDLogin to bOK
90923>>>>>>>            Move False to Err
90924>>>>>>>            Open hTable Mode DF_EXCLUSIVE
90926>>>>>>>            Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
90929>>>>>>>            Decrement iSizeTo
90930>>>>>>>
90930>>>>>>>            // We should probably not make any comparison between "FROM" and "TO" database; instead just create all "FROM" relations
90930>>>>>>>            // for the "TO" database. But start by deleting all current "TO" relations:
90930>>>>>>>            Structure_Start hTable sDriverID
90931>>>>>>>                for iCount from 0 to iSizeTo
90937>>>>>>>>
90937>>>>>>>                    Move aRelationsTo[iCount].iColumnFrom to iColumn
90938>>>>>>>                    Set_Attribute DF_FIELD_RELATED_FILE  of hTable iColumn to 0
90941>>>>>>>                    Set_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn to 0
90944>>>>>>>                Loop
90945>>>>>>>>
90945>>>>>>>                Set Action_Text of ghoStatusPanel to "Restructures table..."
90946>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
90948>>>>>>>            Set Action_Text of ghoStatusPanel to ""
90949>>>>>>>        End
90949>>>>>>>>
90949>>>>>>>
90949>>>>>>>        Move (SizeOfArray(aRelationsFrom)) to iSize
90950>>>>>>>        Decrement iSize
90951>>>>>>>        for iCount from 0 to iSize
90957>>>>>>>>
90957>>>>>>>            Get ApiTableRelate aRelationsFrom[iCount].hTableFrom aRelationsFrom[iCount].hTableTo aRelationsFrom[iCount].iColumnFrom aRelationsFrom[iCount].iColumnTo aRelationsTo to bOK
90958>>>>>>>        Loop
90959>>>>>>>>
90959>>>>>>>
90959>>>>>>>        Function_Return bOK
90960>>>>>>>    End_Function
90961>>>>>>>
90961>>>>>>>    Function UtilRelationsStructFill Handle hTable Returns tAPIRelation[]
90963>>>>>>>        tAPIRelation[] APIRelations
90963>>>>>>>        tAPIRelation[] APIRelations
90964>>>>>>>        Integer iColumn iColumnTo iNumColumns iCount
90964>>>>>>>        Handle hParent
90964>>>>>>>        Boolean bIsOpen
90964>>>>>>>
90964>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
90965>>>>>>>        Move 0 to iCount
90966>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90969>>>>>>>        If (bIsOpen = False) Begin
90971>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90972>>>>>>>            Open hTable
90974>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
90975>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bIsOpen
90978>>>>>>>            If (bIsOpen = False) Begin
90980>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
90981>>>>>>>                Move True to APIRelations[0].bError
90982>>>>>>>                Function_Return APIRelations
90983>>>>>>>            End
90983>>>>>>>>
90983>>>>>>>        End
90983>>>>>>>>
90983>>>>>>>
90983>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iNumColumns
90986>>>>>>>        For iColumn from 1 to iNumColumns
90992>>>>>>>>
90992>>>>>>>            Get_Attribute DF_FIELD_RELATED_FILE of hTable iColumn to hParent
90995>>>>>>>            If (hParent <> 0) Begin
90997>>>>>>>                Open hParent
90999>>>>>>>                Move hTable                                             to APIRelations[iCount].hTableFrom
91000>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable            to APIRelations[iCount].sLogicalNameFrom
91003>>>>>>>                Move iColumn                                            to APIRelations[iCount].iColumnFrom
91004>>>>>>>                Get_Attribute DF_FIELD_NAME of hTable iColumn           to APIRelations[iCount].sFieldNameFrom
91007>>>>>>>
91007>>>>>>>                Move hParent                                            to APIRelations[iCount].hTableTo
91008>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hParent           to APIRelations[iCount].sLogicalNameTo
91011>>>>>>>                Get_Attribute DF_FIELD_RELATED_FIELD of hTable iColumn  to iColumnTo
91014>>>>>>>                Move iColumnTo                                          to APIRelations[iCount].iColumnTo
91015>>>>>>>                Get_Attribute DF_FIELD_NAME of hParent iColumnTo        to APIRelations[iCount].sFieldNameTo
91018>>>>>>>                Move False                                              to APIRelations[iCount].bShouldChange
91019>>>>>>>                Move False                                              to APIRelations[iCount].bCancel
91020>>>>>>>                Move False                                              to APIRelations[iCount].bError
91021>>>>>>>                Close hParent
91022>>>>>>>                Increment iCount
91023>>>>>>>            End
91023>>>>>>>>
91023>>>>>>>        Loop
91024>>>>>>>>
91024>>>>>>>
91024>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
91025>>>>>>>        Function_Return APIRelations
91026>>>>>>>    End_Function
91027>>>>>>>
91027>>>>>>>    Function UtilRelationArrayCompare tAPIRelation RelationCurrent tAPIRelation RelationNew Returns Integer
91029>>>>>>>        If (RelationCurrent.hTableFrom  = RelationNew.hTableFrom and ;            RelationCurrent.iColumnFrom = RelationNew.iColumnFrom and ;            RelationCurrent.hTableTo    = RelationNew.hTableTo and ;            RelationCurrent.iColumnTo   = RelationNew.iColumnTo) Begin
91031>>>>>>>            Function_Return (EQ)
91032>>>>>>>        End
91032>>>>>>>>
91032>>>>>>>
91032>>>>>>>        Function_Return (GT)
91033>>>>>>>    End_Function
91034>>>>>>>
91034>>>>>>>    Function SearchRelationCompare tAPIRelationCompare RelationCompareCurrent tAPIRelationCompare RelationCompareNew Returns Integer
91036>>>>>>>        If (RelationCompareCurrent.hTableFrom  = RelationCompareNew.hTableFrom and ;            RelationCompareCurrent.iColumnFrom = RelationCompareNew.iColumnFrom and ;            RelationCompareCurrent.hTableTo    = RelationCompareNew.hTableTo and ;            RelationCompareCurrent.iColumnTo   = RelationCompareNew.iColumnTo) ;            Function_Return (EQ)
91039>>>>>>>
91039>>>>>>>        Function_Return (GT)
91040>>>>>>>    End_Function
91041>>>>>>>
91041>>>>>>>    // This will return a struct array with the combined data for the passed FROM and TO index arrays.
91041>>>>>>>    // The combined data will be sorted on the first 4 struct members: hTableFrom, iColumnFrom, hTableTo and iColumnTo
91041>>>>>>>    Function UtilRelationCombineFromAndToArrays tAPIRelation[] aAPIRelationFrom tAPIRelation[] aAPIRelationTo Returns tAPIIndexCompare[]
91043>>>>>>>        tAPIRelation[] aAPIRelationFromAndTo
91043>>>>>>>        tAPIRelation[] aAPIRelationFromAndTo
91044>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
91044>>>>>>>        tAPIRelationCompare[] aAPIRelationCompare
91045>>>>>>>        tAPIRelationCompare   APIRelationCompare
91045>>>>>>>        tAPIRelationCompare   APIRelationCompare
91045>>>>>>>        Integer iSizeFrom iSizeTo iSize iCount iItem
91045>>>>>>>
91045>>>>>>>        Move (SizeOfArray(aAPIRelationFrom)) to iSizeFrom
91046>>>>>>>        Move (SizeOfArray(aAPIRelationTo))   to iSizeTo
91047>>>>>>>        If (iSizeFrom = 0 and iSizeTo = 0) Begin
91049>>>>>>>            Function_Return aAPIRelationCompare
91050>>>>>>>        End
91050>>>>>>>>
91050>>>>>>>
91050>>>>>>>        Move (AppendArray(aAPIRelationFrom, aAPIRelationTo)) to aAPIRelationFromAndTo
91051>>>>>>>        Move (SortArray(aAPIRelationFromAndTo, Self, RefFunc(UtilRelationArrayCompare))) to aAPIRelationFromAndTo
91052>>>>>>>
91052>>>>>>>        Decrement iSizeFrom
91053>>>>>>>        for iCount from 0 to iSizeFrom
91059>>>>>>>>
91059>>>>>>>            Move aAPIRelationFrom[iCount].hTableFrom        to aAPIRelationCompare[iCount].hTableFrom
91060>>>>>>>            Move aAPIRelationFrom[iCount].iColumnFrom       to aAPIRelationCompare[iCount].iColumnFrom
91061>>>>>>>            Move aAPIRelationFrom[iCount].hTableTo          to aAPIRelationCompare[iCount].hTableTo
91062>>>>>>>            Move aAPIRelationFrom[iCount].iColumnTo         to aAPIRelationCompare[iCount].iColumnTo
91063>>>>>>>            Move aAPIRelationFrom[iCount].sLogicalNameFrom  to aAPIRelationCompare[iCount].sLogicalNameFrom_From
91064>>>>>>>            Move aAPIRelationFrom[iCount].sLogicalNameTo    to aAPIRelationCompare[iCount].sLogicalNameTo_From
91065>>>>>>>            Move aAPIRelationFrom[iCount].sFieldNameFrom    to aAPIRelationCompare[iCount].sFieldNameFrom_From
91066>>>>>>>            Move aAPIRelationFrom[iCount].sFieldNameTo      to aAPIRelationCompare[iCount].sFieldNameTo_From
91067>>>>>>>            Move aAPIRelationFrom[iCount].bShouldChange     to aAPIRelationCompare[iCount].bShouldChange_From
91068>>>>>>>            Move aAPIRelationFrom[iCount].bCancel           to aAPIRelationCompare[iCount].bCancel_From
91069>>>>>>>            Move aAPIRelationFrom[iCount].bError            to aAPIRelationCompare[iCount].bError_From
91070>>>>>>>            Move True                                       to aAPIRelationCompare[iCount].bExistsFrom
91071>>>>>>>        Loop
91072>>>>>>>>
91072>>>>>>>
91072>>>>>>>        Decrement iSizeTo
91073>>>>>>>        for iCount from 0 to iSizeTo
91079>>>>>>>>
91079>>>>>>>            Move aAPIRelationTo[iCount].hTableFrom          to APIRelationCompare.hTableFrom
91080>>>>>>>            Move aAPIRelationTo[iCount].iColumnFrom         to APIRelationCompare.iColumnFrom
91081>>>>>>>            Move aAPIRelationTo[iCount].hTableTo            to APIRelationCompare.hTableTo
91082>>>>>>>            Move aAPIRelationTo[iCount].iColumnTo           to APIRelationCompare.iColumnTo
91083>>>>>>>
91083>>>>>>>            // Search if the relation already exists in the array; else add it.
91083>>>>>>>            Move (SearchArray(APIRelationCompare, aAPIRelationCompare, Self, RefFunc(SearchRelationCompare))) to iItem
91084>>>>>>>            If (iItem = -1) Begin
91086>>>>>>>                Move (SizeOfArray(aAPIRelationCompare))     to iItem
91087>>>>>>>            End
91087>>>>>>>>
91087>>>>>>>
91087>>>>>>>            Move APIRelationCompare.hTableFrom              to aAPIRelationCompare[iItem].hTableFrom
91088>>>>>>>            Move APIRelationCompare.iColumnFrom             to aAPIRelationCompare[iItem].iColumnFrom
91089>>>>>>>            Move APIRelationCompare.hTableTo                to aAPIRelationCompare[iItem].hTableTo
91090>>>>>>>            Move APIRelationCompare.iColumnTo               to aAPIRelationCompare[iItem].iColumnTo
91091>>>>>>>            Move aAPIRelationTo[iCount].sLogicalNameFrom    to aAPIRelationCompare[iItem].sLogicalNameFrom_To
91092>>>>>>>            Move aAPIRelationTo[iCount].sLogicalNameTo      to aAPIRelationCompare[iItem].sLogicalNameTo_To
91093>>>>>>>            Move aAPIRelationTo[iCount].sFieldNameFrom      to aAPIRelationCompare[iItem].sFieldNameFrom_To
91094>>>>>>>            Move aAPIRelationTo[iCount].sFieldNameTo        to aAPIRelationCompare[iItem].sFieldNameTo_To
91095>>>>>>>            Move aAPIRelationTo[iCount].bShouldChange       to aAPIRelationCompare[iItem].bShouldChange_To
91096>>>>>>>            Move aAPIRelationTo[iCount].bCancel             to aAPIRelationCompare[iItem].bCancel_To
91097>>>>>>>            Move aAPIRelationTo[iCount].bError              to aAPIRelationCompare[iItem].bError_To
91098>>>>>>>            Move True                                       to aAPIRelationCompare[iItem].bExistsTo
91099>>>>>>>        Loop
91100>>>>>>>>
91100>>>>>>>
91100>>>>>>>        Move (SortArray(aAPIRelationCompare, Self, RefFunc(SearchRelationCompare))) to aAPIRelationCompare
91101>>>>>>>
91101>>>>>>>        Function_Return aAPIRelationCompare
91102>>>>>>>    End_Function
91103>>>>>>>
91103>>>>>>>    // * Dummy function for the Studio's Code Explorer *
91103>>>>>>>    Function CODEMAST_UTILITY_FUNCTIONS Returns Boolean
91105>>>>>>>        Function_Return False
91106>>>>>>>    End_Function
91107>>>>>>>
91107>>>>>>>    // To add a value to the CodeMast & CodeType tables. Pass; a) bCodeType if it is CodeType that should be updated.
91107>>>>>>>    // Else it is CodeMast. b) sTypeValue; either to be added If bCodeType = True, or it will be used to find the correct
91107>>>>>>>    // CodeType record. c) sValue1 and d) sValue2 is the CodeType Description & Comment, or CodeMast Type and Code values.
91107>>>>>>>    Function UtilCodeMasterAddValue Boolean bCodeType String sTypeValue String sValue2 String sValue3 Returns Boolean
91109>>>>>>>        Boolean bFound
91109>>>>>>>
91109>>>>>>>        Move False to Err
91110>>>>>>>        Open CodeMast
91112>>>>>>>        Open CodeType
91114>>>>>>>
91114>>>>>>>        If (bCodeType = True) Begin
91116>>>>>>>            Set Private.phCurrentTable to CODETYPE.File_Number
91117>>>>>>>            Clear CodeType
91118>>>>>>>            Move sTypeValue to CODETYPE.Type
91119>>>>>>>            Find eq CODETYPE by 1
91120>>>>>>>>
91120>>>>>>>            Move Found to bFound
91121>>>>>>>            If (bFound = True) Begin
91123>>>>>>>                Reread CodeType
91127>>>>>>>            End
91127>>>>>>>>
91127>>>>>>>            Else Begin
91128>>>>>>>                Clear CodeType
91129>>>>>>>            End
91129>>>>>>>>
91129>>>>>>>
91129>>>>>>>            Move sTypeValue to CODETYPE.Type
91130>>>>>>>            Move sValue2    to CODETYPE.Description
91131>>>>>>>            Move sValue3    to CODETYPE.Comment
91132>>>>>>>            SaveRecord CODETYPE
91133>>>>>>>
91133>>>>>>>            If (bFound = True) Begin
91135>>>>>>>                Unlock
91136>>>>>>>>
91136>>>>>>>            End
91136>>>>>>>>
91136>>>>>>>        End
91136>>>>>>>>
91136>>>>>>>
91136>>>>>>>        If (bCodeType = False) Begin
91138>>>>>>>            Set Private.phCurrentTable to CODEMAST.File_Number
91139>>>>>>>            Clear CODEMAST
91140>>>>>>>            Move sTypeValue to CODEMAST.Type
91141>>>>>>>            Move sValue2    to CODEMAST.Code
91142>>>>>>>            Find eq CODEMAST by 1
91143>>>>>>>>
91143>>>>>>>            Move Found to bFound
91144>>>>>>>            If (bFound = True) Begin
91146>>>>>>>                Reread CODEMAST
91150>>>>>>>            End
91150>>>>>>>>
91150>>>>>>>            Else Begin
91151>>>>>>>                Clear CODEMAST
91152>>>>>>>            End
91152>>>>>>>>
91152>>>>>>>
91152>>>>>>>            Move sTypeValue to CODEMAST.Type
91153>>>>>>>            Move sValue2    to CODEMAST.Code
91154>>>>>>>            Move sValue3    to CODEMAST.Description
91155>>>>>>>            SaveRecord CODEMAST
91156>>>>>>>
91156>>>>>>>            If (bFound = True) Begin
91158>>>>>>>                Unlock
91159>>>>>>>>
91159>>>>>>>            End
91159>>>>>>>>
91159>>>>>>>        End
91159>>>>>>>>
91159>>>>>>>
91159>>>>>>>        Close CodeMast
91160>>>>>>>        Close CodeType
91161>>>>>>>
91161>>>>>>>        Function_Return (Err = False)
91162>>>>>>>    End_Function
91163>>>>>>>
91163>>>>>>>    // Changes values in CodeType & CodeMast - From type value To type value. It first changes the type value in
91163>>>>>>>    // CodeType and then spins through all CodeMast records to change all related records.
91163>>>>>>>    Function UtilCodeMasterChangeValue String sFromValue String sToValue Returns Boolean
91165>>>>>>>        Boolean bFound
91165>>>>>>>
91165>>>>>>>        Move False to Err
91166>>>>>>>        Open CodeMast
91168>>>>>>>        Open CodeType
91170>>>>>>>
91170>>>>>>>        Clear CodeType
91171>>>>>>>        Move sFromValue to CODETYPE.Type
91172>>>>>>>        Find eq CODETYPE.Type
91173>>>>>>>>
91173>>>>>>>        If (Found = True) Begin
91175>>>>>>>            Reread CODETYPE
91179>>>>>>>                Move sToValue to CODETYPE.Type
91180>>>>>>>                SaveRecord CODETYPE
91181>>>>>>>            Unlock
91182>>>>>>>>
91182>>>>>>>        End
91182>>>>>>>>
91182>>>>>>>
91182>>>>>>>        Clear CODEMAST
91183>>>>>>>        Find gt CODEMAST by Recnum
91184>>>>>>>>
91184>>>>>>>        While (Found = True)
91188>>>>>>>            Move (Trim(Uppercase(CODEMAST.Type) = Trim(Uppercase(sFromValue)))) to bFound
91189>>>>>>>            If (bFound = True) Begin
91191>>>>>>>                Reread CODEMAST
91195>>>>>>>                    Move sToValue to CODEMAST.Type
91196>>>>>>>                    SaveRecord CODEMAST
91197>>>>>>>                Unlock
91198>>>>>>>>
91198>>>>>>>            End
91198>>>>>>>>
91198>>>>>>>            Find gt CODEMAST by Recnum
91199>>>>>>>>
91199>>>>>>>        Loop
91200>>>>>>>>
91200>>>>>>>
91200>>>>>>>        Close CodeMast
91201>>>>>>>        Close CodeType
91202>>>>>>>
91202>>>>>>>        Function_Return (Err = False)
91203>>>>>>>    End_Function
91204>>>>>>>
91204>>>>>>>    // Removes a value from CodeMast. Pass the sTypeValue and the sValue2 to remove.
91204>>>>>>>    Function UtilCodeMasterRemoveValue String sTypeValue String sValue2 Returns Boolean
91206>>>>>>>        Boolean bFound
91206>>>>>>>
91206>>>>>>>        Move False to Err
91207>>>>>>>        Open CodeMast
91209>>>>>>>
91209>>>>>>>        Clear CODEMAST
91210>>>>>>>        Move sTypeValue to CODEMAST.Type
91211>>>>>>>        Move sValue2    to CODEMAST.Code
91212>>>>>>>        Find eq CODEMAST.Code
91213>>>>>>>>
91213>>>>>>>        Move Found to bFound
91214>>>>>>>        If (bFound = True) Begin
91216>>>>>>>            Delete CODEMAST
91217>>>>>>>        End
91217>>>>>>>>
91217>>>>>>>
91217>>>>>>>        Close CodeMast
91218>>>>>>>
91218>>>>>>>        Function_Return (Err = False)
91219>>>>>>>    End_Function
91220>>>>>>>
91220>>>>>>>    Function UtilTableCreateCodeMastCodeTypeIntFiles String sDataPath Returns Boolean
91222>>>>>>>        Boolean bRecnum bToAnsi
91222>>>>>>>        Integer iCh
91222>>>>>>>        String sFileName sDriverID sConnectionID sSchemaName sANSI_OEM
91222>>>>>>>
91222>>>>>>>        If (Trim(sDataPath) = "") Begin
91224>>>>>>>            Function_Return False
91225>>>>>>>        End
91225>>>>>>>>
91225>>>>>>>
91225>>>>>>>        Move False to Err
91226>>>>>>>        Get psDriverID     to sDriverID
91227>>>>>>>        Get psConnectionID to sConnectionID
91228>>>>>>>        Get psSchema       to sSchemaName
91229>>>>>>>        Get True           to bRecnum
91230>>>>>>>        Get pbToANSI       to bToAnsi
91231>>>>>>>        Move CS_ANSI_Txt to sANSI_OEM
91232>>>>>>>        If (bToAnsi = False) Begin
91234>>>>>>>            Move CS_OEM_Txt to sANSI_OEM
91235>>>>>>>        End
91235>>>>>>>>
91235>>>>>>>
91235>>>>>>>        Get vFolderFormat sDataPath to sDataPath
91236>>>>>>>        Move "CodeMast.int"         to sFileName
91237>>>>>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
91238>>>>>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
91241>>>>>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
91244>>>>>>>            Writeln channel iCh ("DATABASE_NAME CODEMAST")
91247>>>>>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
91250>>>>>>>            Writeln channel iCh ("")
91253>>>>>>>            Writeln channel iCh ("RECNUM_TABLE YES")
91256>>>>>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
91259>>>>>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
91262>>>>>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
91265>>>>>>>            Writeln channel iCh ("")
91268>>>>>>>            Writeln channel iCh ("INDEX_NUMBER 1")
91271>>>>>>>            Writeln channel iCh ("INDEX_NAME CODEMAST001_PK")
91274>>>>>>>            Writeln channel iCh ("")
91277>>>>>>>        Send Seq_Close_Channel iCh
91278>>>>>>>
91278>>>>>>>        Get vFolderFormat sDataPath to sDataPath
91279>>>>>>>        Move "CodeType.int"         to sFileName
91280>>>>>>>        Get Seq_Open_Output_Channel (sDataPath + sFileName) to iCh
91281>>>>>>>            Writeln channel iCh ("DRIVER_NAME" * sDriverID)
91284>>>>>>>            Writeln channel iCh ("SERVER_NAME DFCONNID=" + sConnectionID)
91287>>>>>>>            Writeln channel iCh ("DATABASE_NAME CODETYPE")
91290>>>>>>>            Writeln channel iCh ("SCHEMA_NAME" * sSchemaName)
91293>>>>>>>            Writeln channel iCh ("")
91296>>>>>>>            Writeln channel iCh ("RECNUM_TABLE YES")
91299>>>>>>>            Writeln channel iCh ("PRIMARY_INDEX 0")
91302>>>>>>>            Writeln channel iCh ("TABLE_CHARACTER_FORMAT" * sANSI_OEM)
91305>>>>>>>            Writeln channel iCh ("USE_DUMMY_ZERO_DATE YES")
91308>>>>>>>            Writeln channel iCh ("")
91311>>>>>>>            Writeln channel iCh ("INDEX_NUMBER 0")
91314>>>>>>>            Writeln channel iCh ("INDEX_NAME CODETYPE000")
91317>>>>>>>            Writeln channel iCh ("")
91320>>>>>>>            Writeln channel iCh ("INDEX_NUMBER 1")
91323>>>>>>>            Writeln channel iCh ("INDEX_NAME CODETYPE001_PK")
91326>>>>>>>            Writeln channel iCh ("")
91329>>>>>>>        Send Seq_Close_Channel iCh
91330>>>>>>>
91330>>>>>>>        Function_Return (Err = False)
91331>>>>>>>    End_Function
91332>>>>>>>
91332>>>>>>>    // * Dummy function for the Studio's Code Explorer *
91332>>>>>>>    Function OTHER_UTILITY_FUNCTIONS Returns Boolean
91334>>>>>>>        Function_Return False
91335>>>>>>>    End_Function
91336>>>>>>>
91336>>>>>>>    // Use function to move *.fd, termlist.*, collate.*, dfcollate.* files to a "Data\Backup" folder,
91336>>>>>>>    // and to remove all *.cch files (DAW SQL driver cache files. They will get recreated when needed.)
91336>>>>>>>    Function UtilMoveMiscFilesToBackupFolder Returns Boolean
91338>>>>>>>        Boolean bOK bExists
91338>>>>>>>        String sDataPath sBackupFolder
91338>>>>>>>
91338>>>>>>>        Set Message_Text of ghoStatusPanel to "Moving misc. files to Backup folder."
91339>>>>>>>        Move CS_DUFBackupDataFolder to sBackupFolder
91340>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
91341>>>>>>>        Get vFolderFormat sDataPath to sDataPath
91342>>>>>>>
91342>>>>>>>        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
91343>>>>>>>        If (bExists = False) Begin
91345>>>>>>>            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
91346>>>>>>>            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
91347>>>>>>>            If (bExists = False) Begin
91349>>>>>>>                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all misc. files to. You need to move them somewhere manually.")
91350>>>>>>>>
91350>>>>>>>                Function_Return False
91351>>>>>>>            End
91351>>>>>>>>
91351>>>>>>>            Get vMoveFile (sDataPath + "*.fd")         (sDataPath + sBackupFolder) to bOK  
91352>>>>>>>            Get vMoveFile (sDataPath + "*.bad")        (sDataPath + sBackupFolder) to bOK  
91353>>>>>>>            Get vMoveFile (sDataPath + "*.err")        (sDataPath + sBackupFolder) to bOK  
91354>>>>>>>            Get vMoveFile (sDataPath + "*.bak")        (sDataPath + sBackupFolder) to bOK
91355>>>>>>>            Get vMoveFile (sDataPath + "*.def")        (sDataPath + sBackupFolder) to bOK
91356>>>>>>>            Get vMoveFile (sDataPath + "*.fil")        (sDataPath + sBackupFolder) to bOK
91357>>>>>>>            Get vMoveFile (sDataPath + "*.hlp")        (sDataPath + sBackupFolder) to bOK
91358>>>>>>>            Get vMoveFile (sDataPath + "*.old")        (sDataPath + sBackupFolder) to bOK           
91359>>>>>>>            Get vMoveFile (sDataPath + "*.prn")        (sDataPath + sBackupFolder) to bOK           
91360>>>>>>>            Get vMoveFile (sDataPath + "*.sts")        (sDataPath + sBackupFolder) to bOK           
91361>>>>>>>            Get vMoveFile (sDataPath + "*.td")         (sDataPath + sBackupFolder) to bOK           
91362>>>>>>>            Get vMoveFile (sDataPath + "*.log")        (sDataPath + sBackupFolder) to bOK           
91363>>>>>>>            Get vMoveFile (sDataPath + "*.bat")        (sDataPath + sBackupFolder) to bOK           
91364>>>>>>>            Get vMoveFile (sDataPath + "*.cmd")        (sDataPath + sBackupFolder) to bOK           
91365>>>>>>>            Get vMoveFile (sDataPath + "*.zip")        (sDataPath + sBackupFolder) to bOK           
91366>>>>>>>            Get vMoveFile (sDataPath + "*.abs")        (sDataPath + sBackupFolder) to bOK           
91367>>>>>>>            Get vMoveFile (sDataPath + "termlist.*")   (sDataPath + sBackupFolder) to bOK
91368>>>>>>>            Get vMoveFile (sDataPath + "*.dfr")        (sDataPath + sBackupFolder) to bOK
91369>>>>>>>            Get vMoveFile (sDataPath + "vsutil.cfg")   (sDataPath + sBackupFolder) to bOK
91370>>>>>>>            Get vMoveFile (sDataPath + "collate.*")    (sDataPath + sBackupFolder) to bOK
91371>>>>>>>            Get vMoveFile (sDataPath + "df_collate.*") (sDataPath + sBackupFolder) to bOK
91372>>>>>>>            Get vDeleteFile (sDataPath + "*.cch")                                  to bOK
91373>>>>>>>        End
91373>>>>>>>>
91373>>>>>>>
91373>>>>>>>        Set Message_Text of ghoStatusPanel to ""
91374>>>>>>>        Function_Return True
91375>>>>>>>    End_Function
91376>>>>>>>    
91376>>>>>>>    // Check if the file exists in the Data folder,
91376>>>>>>>    // else creates it from memory as it has been compiled into the program as a resource:
91376>>>>>>>    Function UtilCheckCreateIfFileExists String sFileName String sResourceName Boolean bDataFile Returns Boolean
91378>>>>>>>        String sPath
91378>>>>>>>        Boolean bExists
91378>>>>>>>
91378>>>>>>>        Get psDataPathFirstPart to sPath
91379>>>>>>>        Move (sPath + sFileName) to sFileName
91380>>>>>>>        Get vFilePathExists sFileName to bExists
91381>>>>>>>
91381>>>>>>>        If (bExists = False) Begin
91383>>>>>>>            // Read from memory & create file on disk.
91383>>>>>>>            Send SqlUtilCreateFileFromMemory sResourceName sFileName
91384>>>>>>>            Get vFilePathExists sFileName to bExists
91385>>>>>>>        End
91385>>>>>>>>
91385>>>>>>>        Function_Return bExists
91386>>>>>>>    End_Function
91387>>>>>>>
91387>>>>>>>    Function UtilSqlColumnTypeToDataFlexType String sDriverID Integer iDbType Integer iDataType Integer iLength Returns Integer
91389>>>>>>>        tColumnType RetvalType
91389>>>>>>>        tColumnType RetvalType
91389>>>>>>>        Integer iRetval
91389>>>>>>>
91389>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
91390>>>>>>>        Move RetvalType.iDataFlexType to iRetval
91391>>>>>>>        If (RetvalType.iDataFlexType = DF_TEXT) Begin
91393>>>>>>>            If (iLength <= 255) Begin
91395>>>>>>>                Move DF_ASCII to iRetval
91396>>>>>>>            End
91396>>>>>>>>
91396>>>>>>>        End
91396>>>>>>>>
91396>>>>>>>        Function_Return iRetval
91397>>>>>>>    End_Function
91398>>>>>>>
91398>>>>>>>    Function UtilDataFlexDataTypeToString Integer iDataType Returns String
91400>>>>>>>        String sRetval
91400>>>>>>>
91400>>>>>>>        Case Begin
91400>>>>>>>            Case (iDataType = DF_ASCII)
91402>>>>>>>                Move "DF_ASCII" to sRetval
91403>>>>>>>                Case Break
91404>>>>>>>            Case (iDataType = DF_BCD)
91407>>>>>>>                Move "DF_BCD" to sRetval
91408>>>>>>>                Case Break
91409>>>>>>>            Case (iDataType = DF_BINARY)
91412>>>>>>>                Move "DF_BINARY" to sRetval
91413>>>>>>>                Case Break
91414>>>>>>>            Case (iDataType = DF_DATE)
91417>>>>>>>                Move "DF_DATE" to sRetval
91418>>>>>>>                Case Break
91419>>>>>>>            Case (iDataType = DF_DATETIME)
91422>>>>>>>                Move "DF_DATETIME" to sRetval
91423>>>>>>>                Case Break
91424>>>>>>>            Case (iDataType = DF_TEXT)
91427>>>>>>>                Move "DF_TEXT" to sRetval
91428>>>>>>>                Case Break
91429>>>>>>>            Case Else
91429>>>>>>>                Move "" to sRetval
91430>>>>>>>        Case End
91430>>>>>>>
91430>>>>>>>        Function_Return sRetval
91431>>>>>>>    End_Function
91432>>>>>>>
91432>>>>>>>    // The default value used for a datatype as specified in the driver int file.
91432>>>>>>>    Function UtilDataTypeDefaultValue String sDriverID Integer iDbType Integer iDataType Returns String
91434>>>>>>>        String sRetval sServer
91434>>>>>>>        tColumnType RetvalType
91434>>>>>>>        tColumnType RetvalType
91434>>>>>>>        Integer iDriver iDataFlexType
91434>>>>>>>        Handle hDatabase
91434>>>>>>>
91434>>>>>>>        Get _UtilColumnType sDriverID iDbType iDataType "" True to RetvalType
91435>>>>>>>        Move RetvalType.iDataFlexType to iDataFlexType
91436>>>>>>>        Get DriverIndex sDriverID to iDriver
91437>>>>>>>        Get psServer to sServer
91438>>>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
91439>>>>>>>        If (hDatabase = 0) Begin
91441>>>>>>>            Function_Return ""
91442>>>>>>>        End
91442>>>>>>>>
91442>>>>>>>
91442>>>>>>>        Case Begin
91442>>>>>>>            Case (iDataFlexType = DF_ASCII)
91444>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_ASCII     of iDriver hDatabase to sRetval
91447>>>>>>>                Case Break
91448>>>>>>>            Case (iDataFlexType = DF_BCD)
91451>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_NUMERIC   of iDriver hDatabase to sRetval
91454>>>>>>>                Case Break
91455>>>>>>>            Case (iDataFlexType = DF_BINARY)
91458>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_BINARY    of iDriver hDatabase to sRetval
91461>>>>>>>                Case Break
91462>>>>>>>            Case (iDataFlexType = DF_DATE)
91465>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE      of iDriver hDatabase to sRetval
91468>>>>>>>                Case Break
91469>>>>>>>            Case (iDataFlexType = DF_DATETIME)
91472>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME  of iDriver hDatabase to sRetval
91475>>>>>>>                Case Break
91476>>>>>>>            Case (iDataFlexType = DF_TEXT)
91479>>>>>>>                Get_Attribute DF_DATABASE_DEFAULT_DEFAULT_TEXT      of iDriver hDatabase to sRetval
91482>>>>>>>                Case Break
91483>>>>>>>            Case Else
91483>>>>>>>                Move "" to sRetval
91484>>>>>>>        Case End
91484>>>>>>>
91484>>>>>>>        Function_Return sRetval
91485>>>>>>>    End_Function
91486>>>>>>>
91486>>>>>>>    Procedure Set Df_Database_Default_Default_Date_DUF String sDateValue
91488>>>>>>>        String sDriverID sServer
91488>>>>>>>        tColumnType RetvalType
91488>>>>>>>        tColumnType RetvalType
91488>>>>>>>        Integer iDbType iDriver
91488>>>>>>>        Handle hDatabase
91488>>>>>>>
91488>>>>>>>        Get psDriverID to sDriverID
91489>>>>>>>        Get piDbType   to iDbType
91490>>>>>>>        Get DriverIndex sDriverID to iDriver
91491>>>>>>>        Get psServer to sServer
91492>>>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
91493>>>>>>>        If (hDatabase = 0) Begin
91495>>>>>>>            Error DFERR_PROGRAM "Could not change the Default Date Value. Could not get a handle to the database. (Check that at least one connection is 'Enabled')"
91496>>>>>>>>
91496>>>>>>>            Procedure_Return
91497>>>>>>>        End
91497>>>>>>>>
91497>>>>>>>
91497>>>>>>>        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATE of iDriver hDatabase to sDateValue
91500>>>>>>>
91500>>>>>>>    End_Procedure
91501>>>>>>>
91501>>>>>>>    Procedure Set Df_Database_Default_Default_Datetime_DUF String sDateValue
91503>>>>>>>        String sDriverID sServer
91503>>>>>>>        tColumnType RetvalType
91503>>>>>>>        tColumnType RetvalType
91503>>>>>>>        Integer iDbType iDriver
91503>>>>>>>        Handle hDatabase
91503>>>>>>>
91503>>>>>>>        Get psDriverID to sDriverID
91504>>>>>>>        Get piDbType   to iDbType
91505>>>>>>>        Get DriverIndex sDriverID to iDriver
91506>>>>>>>        Get psServer to sServer
91507>>>>>>>        Get SqlUtilDatabaseHandle sDriverID sServer to hDatabase
91508>>>>>>>        If (hDatabase = 0) Begin
91510>>>>>>>            Error DFERR_PROGRAM "Could not change the Default DateTime Value. Could not get a handle to the database."
91511>>>>>>>>
91511>>>>>>>            Procedure_Return
91512>>>>>>>        End
91512>>>>>>>>
91512>>>>>>>
91512>>>>>>>        Set_Attribute DF_DATABASE_DEFAULT_DEFAULT_DATETIME of iDriver hDatabase to sDateValue
91515>>>>>>>
91515>>>>>>>    End_Procedure
91516>>>>>>>
91516>>>>>>>    // Returns a struct array with the default column types for the SQL back-end and how they
91516>>>>>>>    // are mapped to the standard DataFlex data types.
91516>>>>>>>    // The DataFlex data types are: "ASCII", "BINARY", "DATE", "DATETIME", "NUMERIC" and "TEXT".
91516>>>>>>>    Function UtilDefaultSqlTypeMappings String sDriverID Integer iDbType Returns tColumnType[]
91518>>>>>>>        tColumnType[] ColumnTypeArray EmptyArray
91518>>>>>>>        tColumnType[] ColumnTypeArray EmptyArray
91520>>>>>>>        String sDataType
91520>>>>>>>        Integer iDataType iDriverID iCount
91520>>>>>>>        Boolean bSQLDriver
91520>>>>>>>
91520>>>>>>>        Move 0 to iCount
91521>>>>>>>        Get DriverIndex sDriverID to iDriverID
91522>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
91523>>>>>>>        If (bSQLDriver = False) Begin
91525>>>>>>>            Function_Return EmptyArray
91526>>>>>>>        End
91526>>>>>>>>
91526>>>>>>>
91526>>>>>>>        // DF_ASCII
91526>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
91528>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
91531>>>>>>>        End
91531>>>>>>>>
91531>>>>>>>        Else Begin
91532>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
91535>>>>>>>        End
91535>>>>>>>>
91535>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
91536>>>>>>>        Move DF_ASCII    to ColumnTypeArray[iCount].iDataFlexType
91537>>>>>>>        Move "ASCII"     to ColumnTypeArray[iCount].sDataFlexType
91538>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
91539>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
91540>>>>>>>        Increment iCount
91541>>>>>>>
91541>>>>>>>        // DF_BINARY
91541>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
91543>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
91546>>>>>>>        End
91546>>>>>>>>
91546>>>>>>>        Else Begin
91547>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
91550>>>>>>>        End
91550>>>>>>>>
91550>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
91551>>>>>>>        Move DF_BINARY   to ColumnTypeArray[iCount].iDataFlexType
91552>>>>>>>        Move "Binary"    to ColumnTypeArray[iCount].sDataFlexType
91553>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
91554>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
91555>>>>>>>        Increment iCount
91556>>>>>>>
91556>>>>>>>        // DF_DATE
91556>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
91558>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
91561>>>>>>>        End
91561>>>>>>>>
91561>>>>>>>        Else Begin
91562>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
91565>>>>>>>        End
91565>>>>>>>>
91565>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
91566>>>>>>>        Move DF_DATE     to ColumnTypeArray[iCount].iDataFlexType
91567>>>>>>>        Move "Date"      to ColumnTypeArray[iCount].sDataFlexType
91568>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
91569>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
91570>>>>>>>        Increment iCount
91571>>>>>>>
91571>>>>>>>        // DF_DATETIME
91571>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
91573>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
91576>>>>>>>        End
91576>>>>>>>>
91576>>>>>>>        Else Begin
91577>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
91580>>>>>>>        End
91580>>>>>>>>
91580>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
91581>>>>>>>        Move DF_DATETIME to ColumnTypeArray[iCount].iDataFlexType
91582>>>>>>>        Move "DateTime"  to ColumnTypeArray[iCount].sDataFlexType
91583>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
91584>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
91585>>>>>>>        Increment iCount
91586>>>>>>>
91586>>>>>>>        // DF_NUMERIC
91586>>>>>>>        // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
91586>>>>>>>        // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
91586>>>>>>>        // we make them here all "Numeric"...
91586>>>>>>>        Case Begin
91586>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
91588>>>>>>>                Move SQL_NUMERIC to iDataType
91589>>>>>>>                Move "numeric"   to sDataType
91590>>>>>>>                Case Break
91591>>>>>>>            Case (sDriverID = DB2_DRV_ID)
91594>>>>>>>                Move SQL_NUMERIC to iDataType
91595>>>>>>>                Move "NUMERIC"   to sDataType
91596>>>>>>>                Case Break
91597>>>>>>>            Case (sDriverID = SQLFLEX)
91600>>>>>>>                Move eSQLServer_NUMERIC to iDataType
91601>>>>>>>                Move "numeric"   to sDataType
91602>>>>>>>                Case Break
91603>>>>>>>            Case (sDriverID = MDSMySQL)
91606>>>>>>>                Move eMySQL_DECIMAL to iDataType
91607>>>>>>>                Move "decimal"   to sDataType
91608>>>>>>>                Case Break
91609>>>>>>>            Case (sDriverID = ORAFLEX)
91612>>>>>>>                Move eOracle_NUMBER to iDataType
91613>>>>>>>                Move "NUMBER"   to sDataType
91614>>>>>>>                Case Break
91615>>>>>>>            Case (sDriverID = MDSPgSQL)
91618>>>>>>>                Move ePgSQL_FLOAT4 to iDataType
91619>>>>>>>                Move "decimal"   to sDataType
91620>>>>>>>                Case Break
91621>>>>>>>            Case Else
91621>>>>>>>                Move DF_BCD      to iDataType
91622>>>>>>>                Move "Numeric"   to sDataType
91623>>>>>>>        Case End
91623>>>>>>>        Move DF_BCD      to ColumnTypeArray[iCount].iDataFlexType
91624>>>>>>>        Move "Numeric"   to ColumnTypeArray[iCount].sDataFlexType
91625>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
91626>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
91627>>>>>>>        Increment iCount
91628>>>>>>>
91628>>>>>>>        // DF_TEXT
91628>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
91630>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
91633>>>>>>>        End
91633>>>>>>>>
91633>>>>>>>        Else Begin
91634>>>>>>>            Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
91637>>>>>>>        End
91637>>>>>>>>
91637>>>>>>>        Get UtilColumnTypeToInteger sDriverID iDbType sDataType to iDataType
91638>>>>>>>        Move DF_TEXT     to ColumnTypeArray[iCount].iDataFlexType
91639>>>>>>>        Move "Text"      to ColumnTypeArray[iCount].sDataFlexType
91640>>>>>>>        Move sDataType   to ColumnTypeArray[iCount].sSQLType
91641>>>>>>>        Move iDataType   to ColumnTypeArray[iCount].iSQLType
91642>>>>>>>
91642>>>>>>>        Function_Return ColumnTypeArray
91643>>>>>>>    End_Function
91644>>>>>>>
91644>>>>>>>    Function UtilDFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
91646>>>>>>>        tColumnType[] ColumnTypeArray
91646>>>>>>>        tColumnType[] ColumnTypeArray
91647>>>>>>>        tColumnType   ColumnType
91647>>>>>>>        tColumnType   ColumnType
91647>>>>>>>        Integer iCount iSize
91647>>>>>>>
91647>>>>>>>        Get UtilDefaultSqlTypeMappings sDriverID iDbType iType to ColumnTypeArray
91648>>>>>>>        Move (SizeOfArray(ColumnTypeArray)) to iSize
91649>>>>>>>        Decrement iSize
91650>>>>>>>
91650>>>>>>>        for iCount from 0 to iSize
91656>>>>>>>>
91656>>>>>>>            If (iType = ColumnTypeArray[iCount].iDataFlexType) Begin
91658>>>>>>>                Move ColumnTypeArray[iCount].bCanEditSize   to ColumnType.bCanEditSize
91659>>>>>>>                Move ColumnTypeArray[iCount].iDataFlexType  to ColumnType.iDataFlexType
91660>>>>>>>                Move ColumnTypeArray[iCount].iSQLType       to ColumnType.iSQLType
91661>>>>>>>                Move ColumnTypeArray[iCount].sDataFlexType  to ColumnType.sDataFlexType
91662>>>>>>>                Move ColumnTypeArray[iCount].sPrecision     to ColumnType.sPrecision
91663>>>>>>>                Move ColumnTypeArray[iCount].sSQLType       to ColumnType.sSQLType
91664>>>>>>>                Move iSize to iCount
91665>>>>>>>            End
91665>>>>>>>>
91665>>>>>>>        Loop
91666>>>>>>>>
91666>>>>>>>
91666>>>>>>>        Function_Return ColumnType
91667>>>>>>>    End_Function
91668>>>>>>>
91668>>>>>>>    // Returns a struct with the default column types for the SQL back-end and how they
91668>>>>>>>    // are mapped to a DUF data type.
91668>>>>>>>    Function UtilDUFDataTypeToSqlTypeMapping String sDriverID Integer iDbType Integer iType Returns tColumnType
91670>>>>>>>        tColumnType ColumnType
91670>>>>>>>        tColumnType ColumnType
91670>>>>>>>        String sDataType
91670>>>>>>>        Integer iDriverID iCount
91670>>>>>>>
91670>>>>>>>        Move 0 to iCount
91671>>>>>>>        Get DriverIndex sDriverID to iDriverID
91672>>>>>>>
91672>>>>>>>        Case Begin
91672>>>>>>>            // DF_ASCII
91672>>>>>>>            Case (iType = DF_ASCII_DUF)
91674>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
91676>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE of iDriverID to sDataType
91679>>>>>>>                End
91679>>>>>>>>
91679>>>>>>>                Else Begin
91680>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFASCII_TO_SQLTYPE  of iDriverID to sDataType
91683>>>>>>>                End
91683>>>>>>>>
91683>>>>>>>                Move DF_ASCII    to ColumnType.iDataFlexType
91684>>>>>>>                Move "ASCII"     to ColumnType.sDataFlexType
91685>>>>>>>                Move sDataType   to ColumnType.sSQLType
91686>>>>>>>                Move DF_ASCII    to ColumnType.iSQLType
91687>>>>>>>                Move False       to ColumnType.bCanEditSize
91688>>>>>>>                Case Break
91689>>>>>>>
91689>>>>>>>            // DF_BINARY
91689>>>>>>>            Case (iType = DF_BINARY_DUF)
91692>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
91694>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE of iDriverID to sDataType
91697>>>>>>>                End
91697>>>>>>>>
91697>>>>>>>                Else Begin
91698>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE  of iDriverID to sDataType
91701>>>>>>>                End
91701>>>>>>>>
91701>>>>>>>                Move DF_BINARY   to ColumnType.iDataFlexType
91702>>>>>>>                Move "Binary"    to ColumnType.sDataFlexType
91703>>>>>>>                Move sDataType   to ColumnType.sSQLType
91704>>>>>>>                Move DF_BINARY   to ColumnType.iSQLType
91705>>>>>>>                Move False       to ColumnType.bCanEditSize
91706>>>>>>>                Case Break
91707>>>>>>>
91707>>>>>>>            // DF_DATE
91707>>>>>>>            Case (iType = DF_DATE_DUF)
91710>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
91712>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
91715>>>>>>>                End
91715>>>>>>>>
91715>>>>>>>                Else Begin
91716>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
91719>>>>>>>                End
91719>>>>>>>>
91719>>>>>>>                Move DF_DATE     to ColumnType.iDataFlexType
91720>>>>>>>                Move "Date"      to ColumnType.sDataFlexType
91721>>>>>>>                Move sDataType   to ColumnType.sSQLType
91722>>>>>>>                Move DF_DATE     to ColumnType.iSQLType
91723>>>>>>>                Move True        to ColumnType.bCanEditSize
91724>>>>>>>                Case Break
91725>>>>>>>
91725>>>>>>>            // DF_DATETIME
91725>>>>>>>            Case (iType = DF_DATETIME_DUF)
91728>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
91730>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE of iDriverID to sDataType
91733>>>>>>>                End
91733>>>>>>>>
91733>>>>>>>                Else Begin
91734>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE  of iDriverID to sDataType
91737>>>>>>>                End
91737>>>>>>>>
91737>>>>>>>                Move DF_DATETIME to ColumnType.iDataFlexType
91738>>>>>>>                Move "DateTime"  to ColumnType.sDataFlexType
91739>>>>>>>                Move sDataType   to ColumnType.sSQLType
91740>>>>>>>                Move DF_DATETIME to ColumnType.iSQLType
91741>>>>>>>                Move True        to ColumnType.bCanEditSize
91742>>>>>>>                Case Break
91743>>>>>>>
91743>>>>>>>            // DF_NUMERIC
91743>>>>>>>            // *** Why is there no DF_DRIVER_MAP available for BCD/Numeric??? ***
91743>>>>>>>            // DF_BCD can in SQL be either of "SmallInt", "Int", or "Numeric", but
91743>>>>>>>            // we make them here all "Numeric"...
91743>>>>>>>            // If (sDriverID = ODBC_DRV_ID) Begin
91743>>>>>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE of iDriverID to sDataType
91743>>>>>>>            // End
91743>>>>>>>            // Else Begin
91743>>>>>>>            //     Get_Attribute DF_DRIVER_MAP_DFDATE_TO_SQLTYPE  of iDriverID to sDataType
91743>>>>>>>            // End
91743>>>>>>>            // ToDo: How should we find the best "Numeric" data type here?
91743>>>>>>>            Case (iType = DF_BCD_DUF)
91746>>>>>>>                Move DF_BCD      to ColumnType.iDataFlexType
91747>>>>>>>                Move "Numeric"   to ColumnType.sDataFlexType
91748>>>>>>>                Move "Numeric"   to ColumnType.sSQLType
91749>>>>>>>                Move SQL_NUMERIC to ColumnType.iSQLType
91750>>>>>>>                Move False       to ColumnType.bCanEditSize
91751>>>>>>>                Case Break
91752>>>>>>>
91752>>>>>>>            // DF_TEXT
91752>>>>>>>            Case (iType = DF_TEXT_DUF)
91755>>>>>>>                If (sDriverID = ODBC_DRV_ID) Begin
91757>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE of iDriverID to sDataType
91760>>>>>>>                End
91760>>>>>>>>
91760>>>>>>>                Else Begin
91761>>>>>>>                    Get_Attribute DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE  of iDriverID to sDataType
91764>>>>>>>                End
91764>>>>>>>>
91764>>>>>>>                Move DF_TEXT     to ColumnType.iDataFlexType
91765>>>>>>>                Move "Text"      to ColumnType.sDataFlexType
91766>>>>>>>                Move sDataType   to ColumnType.sSQLType
91767>>>>>>>                Move DF_TEXT     to ColumnType.iSQLType
91768>>>>>>>                Move False       to ColumnType.bCanEditSize
91769>>>>>>>                Case Break
91770>>>>>>>
91770>>>>>>>            Case Else
91770>>>>>>>                Move -1999       to ColumnType.iDataFlexType
91771>>>>>>>                Move "Undefined" to ColumnType.sDataFlexType
91772>>>>>>>                Move "Undefined" to ColumnType.sSQLType
91773>>>>>>>                Move -1999       to ColumnType.iSQLType
91774>>>>>>>                Move True        to ColumnType.bCanEditSize
91775>>>>>>>
91775>>>>>>>        Case End
91775>>>>>>>
91775>>>>>>>        Function_Return ColumnType
91776>>>>>>>    End_Function
91777>>>>>>>
91777>>>>>>>    Function UtilDeleteCacheFile String sTableName Returns Boolean
91779>>>>>>>        String sDataPath sDriverID
91779>>>>>>>        Boolean bMertechDriver bOK
91779>>>>>>>        Integer iPos
91779>>>>>>>
91779>>>>>>>        If (sTableName contains ".") Begin
91781>>>>>>>            Move (Pos(".", sTableName)) to iPos
91782>>>>>>>            Move (Mid(sTableName, 999, (iPos +1))) to sTableName
91783>>>>>>>        End
91783>>>>>>>>
91783>>>>>>>
91783>>>>>>>        Get psDriverID to sDriverID
91784>>>>>>>        Get psDataPathFirstPart to sDataPath
91785>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
91786>>>>>>>        // First delete the cache file:
91786>>>>>>>        If (bMertechDriver = False) Begin
91788>>>>>>>            Get vDeleteFile (sDataPath + sTableName + ".cch") to bOK
91789>>>>>>>        End
91789>>>>>>>>
91789>>>>>>>        Else Begin
91790>>>>>>>            Get _MertechDeleteTDFile sTableName to bOK
91791>>>>>>>        End
91791>>>>>>>>
91791>>>>>>>
91791>>>>>>>        Function_Return bOK
91792>>>>>>>    End_Function
91793>>>>>>>
91793>>>>>>>    // Changes source code files.
91793>>>>>>>    // Pass a file name with full path and a value to search for, together with the value
91793>>>>>>>    // to change to. Can e.g. be used for changing all .int files from using a fixed server name,
91793>>>>>>>    // to use a Connection ID.
91793>>>>>>>    // Sample: Get UtilChangeSourceCodeLine "C:\DataFlex 18.2 Examples\Order Entry\Data\Order.int" "SERVER_NAME SERVER=(local)\SQLEXPRESS1" "SERVER_NAME DFCONNID=ChinookDb"
91793>>>>>>>    // Pass "True" for the bShowResult if you want to see the result while it works. Showln will then be used for output
91793>>>>>>>    // Returns True if no errors occured.
91793>>>>>>>    Function UtilChangeSourceCodeLine String sFileName String sChangeFrom String sChangeTo Boolean bShowResult Returns Boolean
91795>>>>>>>        Integer iCh iRow iItems iCount
91795>>>>>>>        String sValue sRow
91795>>>>>>>        String[] sFileArray
91796>>>>>>>        Boolean bExists bIsActive
91796>>>>>>>
91796>>>>>>>        Move False to Err
91797>>>>>>>        Move 0 to iRow
91798>>>>>>>
91798>>>>>>>        If (ghoStatusPanel <> 0) Begin
91800>>>>>>>            Get Active_state of ghoStatusPanel to bIsActive
91801>>>>>>>        End
91801>>>>>>>>
91801>>>>>>>
91801>>>>>>>        Get vFilePathExists sFileName to bExists
91802>>>>>>>        If (bExists = False) Begin
91804>>>>>>>            If (bShowResult = True) Begin
91806>>>>>>>                If (bIsActive = True) Begin
91808>>>>>>>                    Send Update_StatusPanel of ghoStatusPanel ("File does not exist:" * String(sFileName))
91809>>>>>>>                End
91809>>>>>>>>
91809>>>>>>>                Else Begin
91810>>>>>>>                    Showln "File does not exist: " sFileName
91813>>>>>>>                End
91813>>>>>>>>
91813>>>>>>>            End
91813>>>>>>>>
91813>>>>>>>            Function_Return False
91814>>>>>>>        End
91814>>>>>>>>
91814>>>>>>>
91814>>>>>>>        Get Seq_Open_Input_Channel sFileName to iCh
91815>>>>>>>        If (iCh < 1) Begin
91817>>>>>>>            Function_Return False
91818>>>>>>>        End
91818>>>>>>>>
91818>>>>>>>
91818>>>>>>>        If (bShowResult = True) Begin
91820>>>>>>>            If (ghoStatusPanel <> 0) Begin
91822>>>>>>>                Get Active_state of ghoStatusPanel to bIsActive
91823>>>>>>>                If (bIsActive = True) Begin
91825>>>>>>>                    Set Message_Text of ghoStatusPanel to sFileName
91826>>>>>>>                    Send Update_StatusPanel of ghoStatusPanel ("sChangeFrom =" * String(sChangeFrom) * "sChangeTo =" * String(sChangeTo))
91827>>>>>>>                    Send DoAdvance of ghoProgressBar
91828>>>>>>>                End
91828>>>>>>>>
91828>>>>>>>            End
91828>>>>>>>>
91828>>>>>>>            Else Begin
91829>>>>>>>                Showln ""
91831>>>>>>>                Showln "sFileName = " sFileName
91834>>>>>>>                Showln "sChangeFrom = " sChangeFrom " sChangeTo = " sChangeTo
91839>>>>>>>            End
91839>>>>>>>>
91839>>>>>>>        End
91839>>>>>>>>
91839>>>>>>>
91839>>>>>>>        While (not(SeqEof))
91843>>>>>>>            Readln channel iCh sRow
91845>>>>>>>            If (Uppercase(sRow) contains Uppercase(sChangeFrom)) Begin
91847>>>>>>>//                If (bShowResult = True) Begin
91847>>>>>>>//                    If (bIsActive = True) Begin
91847>>>>>>>//                        Send Update_StatusPanel of ghoStatusPanel ("Changed from:" * String(sRow) * "to:" * String(sChangeTo))
91847>>>>>>>//                    End
91847>>>>>>>//                    Else Begin
91847>>>>>>>//                        Showln "Changed from: " sRow " to: " sChangeTo
91847>>>>>>>//                    End
91847>>>>>>>//                End
91847>>>>>>>                // Change the whole line to the new connection id:
91847>>>>>>>                Move sChangeTo to sRow
91848>>>>>>>                // Move (Replaces(sChangeFrom, sRow, sChangeTo)) to sValue
91848>>>>>>>            End
91848>>>>>>>>
91848>>>>>>>            Move sRow to sFileArray[iRow]
91849>>>>>>>            Increment iRow
91850>>>>>>>        Loop
91851>>>>>>>>
91851>>>>>>>        Send Seq_Close_Channel iCh
91852>>>>>>>
91852>>>>>>>        Sleep 1 // Wait for Windows to close the file
91853>>>>>>>
91853>>>>>>>        Get Seq_Open_Output_Channel sFileName to iCh
91854>>>>>>>        If (iCh < 1) Begin
91856>>>>>>>            Function_Return False
91857>>>>>>>        End
91857>>>>>>>>
91857>>>>>>>        Move (SizeOfArray(sFileArray)) to iItems
91858>>>>>>>        Decrement iItems
91859>>>>>>>
91859>>>>>>>        For iCount from 0 to iItems
91865>>>>>>>>
91865>>>>>>>            Move sFileArray[iCount] to sValue
91866>>>>>>>            Writeln channel iCh sValue
91869>>>>>>>        Loop
91870>>>>>>>>
91870>>>>>>>        Send Seq_Close_Channel iCh
91871>>>>>>>
91871>>>>>>>        Function_Return (Err = False)
91872>>>>>>>    End_Function
91873>>>>>>>
91873>>>>>>>    Function AutoSetConnectionID String sConnectionID Returns Boolean
91875>>>>>>>        Integer iRetval
91875>>>>>>>        Move 1 to iRetval
91876>>>>>>>        If (ghoSQLConnectionHandler <> 0) Begin
91878>>>>>>>            Set psConnectionID of ghoSQLConnectionHandler to sConnectionID
91879>>>>>>>            Get AutoSetConnectionID of ghoSQLConnectionHandler to iRetval
91880>>>>>>>        End
91880>>>>>>>>
91880>>>>>>>        Function_Return (iRetval = 0)
91881>>>>>>>    End_Function
91882>>>>>>>
91882>>>>>>>    // *** DEPRECIATED ***
91882>>>>>>>    // Use the AutoSetConnectionID function instead.
91882>>>>>>>    // This might be needed by API-methods when a connection id is to be used and
91882>>>>>>>    // the connection ID hasn't been established with the driver's CLI interface.
91882>>>>>>>    // NOTE: Only applicable for DAW drivers, as Mertech drivers doesn't use connection ID's.
91882>>>>>>>//    Function UtilCreateConnectionID String sConnectionID Returns Boolean
91882>>>>>>>//        String sConnectionString sDriverID
91882>>>>>>>//        Boolean bOK bSilent bDawDriver
91882>>>>>>>//        Handle hoCLI
91882>>>>>>>//
91882>>>>>>>//        Move False to bOK
91882>>>>>>>//        Get psDriverID to sDriverID
91882>>>>>>>//        Get IsDAWSQLDriver sDriverID to bDawDriver
91882>>>>>>>//        If (bDawDriver = False) Begin
91882>>>>>>>//            Error DFERR_PROGRAM "The UtilCreateConnectionID function is only available for DAW drivers. (Not Mertech)."
91882>>>>>>>//            Function_Return False
91882>>>>>>>//        End
91882>>>>>>>//
91882>>>>>>>//        Get psConnectionString to sConnectionString
91882>>>>>>>//        Get pbSilentLogin      to bSilent
91882>>>>>>>//
91882>>>>>>>//        Get phoCLIHandler to hoCLI
91882>>>>>>>//        If (hoCLI <> 0) Begin
91882>>>>>>>//            Set psDriverID of hoCLI to sDriverID
91882>>>>>>>//            Get CreateConnectionID of hoCLI sConnectionID sConnectionString bSilent to bOK
91882>>>>>>>//        End
91882>>>>>>>//
91882>>>>>>>//        Function_Return (bOK = False)
91882>>>>>>>//    End_Function
91882>>>>>>>
91882>>>>>>>    // This message creates an error log in the "Home" folder named "SQLErrorLog.txt",
91882>>>>>>>    // and opens it in "notepad.exe".
91882>>>>>>>    // Note: This is _not_ used by the cDbUpdateHandler & cDbUpdateVersion classes!
91882>>>>>>>    //       Instead the cDbUpdateLogFile's WriteErrorLog & ShowErrorLog are used.
91882>>>>>>>    Procedure UtilShowErrorList
91884>>>>>>>        tSqlErrorArray aSqlErrorArray
91884>>>>>>>        tSqlErrorArray aSqlErrorArray
91884>>>>>>>        Integer iRows iCount iCh iErrorNum
91884>>>>>>>        String sPath sFileName sErrorTxt sStatement
91884>>>>>>>
91884>>>>>>>        Get psHome of (phoWorkspace(ghoApplication)) to sPath
91885>>>>>>>        Get vFolderFormat sPath to sPath
91886>>>>>>>        Move "SQLErrorLog.txt"  to sFileName
91887>>>>>>>        Get Seq_Open_Output_Channel (sPath + sFileName) to iCh
91888>>>>>>>            Get paSqlErrorArray to aSqlErrorArray
91889>>>>>>>            Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iRows
91890>>>>>>>            If (iRows > 0) Begin
91892>>>>>>>                Decrement iRows
91893>>>>>>>                for iCount from 0 to iRows
91899>>>>>>>>
91899>>>>>>>                    Move aSqlErrorArray.sSqlErrorArray[iCount]      to sErrorTxt
91900>>>>>>>                    Move aSqlErrorArray.sSqlStatementArray[iCount]  to sStatement
91901>>>>>>>                    Move aSqlErrorArray.iSqlErrorArray[iCount]      to iErrorNum
91902>>>>>>>                    Writeln channel iCh "Error No: " iErrorNum " Error Text: " sErrorTxt
91908>>>>>>>                    Writeln channel iCh "SQL Statement: " sStatement
91912>>>>>>>                Loop
91913>>>>>>>>
91913>>>>>>>            End
91913>>>>>>>>
91913>>>>>>>        Send Seq_Close_Channel iCh
91914>>>>>>>
91914>>>>>>>        If (iRows > 0) Begin
91916>>>>>>>            Runprogram Shell Background (sPath + sFileName)
91917>>>>>>>        End
91917>>>>>>>>
91917>>>>>>>    End_Procedure
91918>>>>>>>
91918>>>>>>>    // For this to be returning a True value, the table number needs to be in the Filelist.cfg,
91918>>>>>>>    // and the table needs to exist as an SQL table.
91918>>>>>>>    Function UtilTableIsSql Handle hTable Returns Boolean
91920>>>>>>>        String sRootName sDriverID
91920>>>>>>>        Boolean bIsSQL
91920>>>>>>>
91920>>>>>>>        Move False to bIsSQL
91921>>>>>>>        If (hTable > 0) Begin
91923>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
91926>>>>>>>            Get UtilTableIsSqlByRootName sRootName to bIsSQL
91927>>>>>>>            If (bIsSQL = True) Begin
91929>>>>>>>                Get psDriverID to sDriverID
91930>>>>>>>                Get _TableNameOnly sRootName to sRootName
91931>>>>>>>                Get SqlUtilCheckIfTableNameExists sRootName sDriverID to bIsSQL
91932>>>>>>>            End
91932>>>>>>>>
91932>>>>>>>        End
91932>>>>>>>>
91932>>>>>>>
91932>>>>>>>        Function_Return bIsSQL
91933>>>>>>>    End_Function
91934>>>>>>>
91934>>>>>>>    Function UtilTableIsSqlByRootName String sRootName Returns Boolean
91936>>>>>>>        Boolean bIsSQL
91936>>>>>>>        Move (sRootName contains ":") to bIsSQL
91937>>>>>>>        Function_Return bIsSQL
91938>>>>>>>    End_Function
91939>>>>>>>
91939>>>>>>>    // Checks that the passed hTable number both exists in Filelist.cfg and
91939>>>>>>>    // that the embedded .dat file exists on disk.
91939>>>>>>>    Function UtilTableIsEmbedded Handle hTable Returns Boolean
91941>>>>>>>        Boolean bExists bIsEmbedded
91941>>>>>>>        String sDataPath sRootName
91941>>>>>>>
91941>>>>>>>        Get UtilTableNumberIsInUse hTable to bExists
91942>>>>>>>        If (bExists = False) Begin
91944>>>>>>>            Function_Return False
91945>>>>>>>        End
91945>>>>>>>>
91945>>>>>>>
91945>>>>>>>        Move False to bIsEmbedded
91946>>>>>>>        If (hTable > 0) Begin
91948>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
91951>>>>>>>            Move (not(sRootName contains ":")) to bIsEmbedded
91952>>>>>>>        End
91952>>>>>>>>
91952>>>>>>>        If (bIsEmbedded = True) Begin
91954>>>>>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
91955>>>>>>>            Get vFolderFormat sDataPath to sDataPath
91956>>>>>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bIsEmbedded
91957>>>>>>>        End
91957>>>>>>>>
91957>>>>>>>
91957>>>>>>>        Function_Return bIsEmbedded
91958>>>>>>>    End_Function
91959>>>>>>>
91959>>>>>>>
91959>>>>>>>    // Returns True if the passed hTable (filelist slot number) is an Alias table.
91959>>>>>>>    // An Alias file/table is a filelist number that share the same Physical filename
91959>>>>>>>    // but the Logical name is different.
91959>>>>>>>    // Note: If the table cannot be opened; the table is not considered to be an Alias.
91959>>>>>>>    Function UtilTableIsAlias Handle hTable Returns Boolean
91961>>>>>>>        String sRootName sRootNameCompare sLogicalName sLogicalNameCompare
91961>>>>>>>        Handle hInTable hMasterTable 
91961>>>>>>>        Boolean bIsAlias
91961>>>>>>>        
91961>>>>>>>        Move hTable to hInTable
91962>>>>>>>        Move False to bIsAlias
91963>>>>>>>        Move 0 to hMasterTable
91964>>>>>>>        
91964>>>>>>>        Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
91967>>>>>>>        // Remove any prefix with a driver name.
91967>>>>>>>        Get _TableNameOnly sRootName to sRootName     
91968>>>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalName
91971>>>>>>>        Get _TableNameOnly sLogicalName to sLogicalName     
91972>>>>>>>        
91972>>>>>>>        // If the table has the same root and logical name it can't be an alias,
91972>>>>>>>        // so we can safely return a "False".
91972>>>>>>>        If (Uppercase(sRootName) = Uppercase(sLogicalName)) Begin
91974>>>>>>>            Function_Return False
91975>>>>>>>        End
91975>>>>>>>>
91975>>>>>>>        
91975>>>>>>>        // Now we need to find a master table with the same root name (sRootName above),
91975>>>>>>>        // as the passed hTable root name.
91975>>>>>>>        // A master table always has the same root and logical name.
91975>>>>>>>        Move 0 to hTable
91976>>>>>>>        Repeat
91976>>>>>>>>
91976>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
91979>>>>>>>            If (hTable > 0 and hTable <> 50) Begin
91981>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootNameCompare
91984>>>>>>>                Get _TableNameOnly sRootNameCompare to sRootNameCompare
91985>>>>>>>                // If we found another table with the same root and logical name
91985>>>>>>>                // we have found a master table.
91985>>>>>>>                If (Uppercase(sRootName) = Uppercase(sRootNameCompare)) Begin
91987>>>>>>>                    Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sLogicalNameCompare
91990>>>>>>>                    Get _TableNameOnly sLogicalNameCompare to sLogicalNameCompare     
91991>>>>>>>                    If (Uppercase(sRootNameCompare) = Uppercase(sLogicalNameCompare)) Begin
91993>>>>>>>                        Move hTable to hMasterTable   
91994>>>>>>>                        Move 0 to hTable // To end the loop.
91995>>>>>>>                    End
91995>>>>>>>>
91995>>>>>>>                End
91995>>>>>>>>
91995>>>>>>>            End
91995>>>>>>>>
91995>>>>>>>        Until (hTable = 0)
91997>>>>>>>        
91997>>>>>>>        If (hMasterTable <> 0 and hMasterTable <> hInTable) Begin
91999>>>>>>>            Move True to bIsAlias
92000>>>>>>>        End
92000>>>>>>>>
92000>>>>>>>        
92000>>>>>>>        Function_Return bIsAlias
92001>>>>>>>    End_Function
92002>>>>>>>
92002>>>>>>>    // To Open a table with any driver.
92002>>>>>>>    // Note: If the driver is <> DATAFLEX_ID  - login credentials are used; it is then assumed
92002>>>>>>>    //       that the proper login properties has been setup properly with the cSQLConnections object.
92002>>>>>>>    //
92002>>>>>>>    // If the open command fails the Err flag will be reset to false, at the end of the function!
92002>>>>>>>    // The found flag is still used to indicate if the open was successful or not. The function
92002>>>>>>>    // returns a True if successful (table could be opened).
92002>>>>>>>    //
92002>>>>>>>    // Using the "Open As" syntax with drivers means that we don't need to rely on .int file settings.
92002>>>>>>>    // This is good because with DFConnectionID's those credentials doesn't need to be available in
92002>>>>>>>    // the .int file (and probably aren't). As long as the login properties of this object have been
92002>>>>>>>    // set properly we can open the table.
92002>>>>>>>    //
92002>>>>>>>    // DAW Driver Syntax:
92002>>>>>>>    //  <CKId>:<Schema>#<Table>@<ConnectString>|<Filename>.int
92002>>>>>>>    //  Now the @<ConnectString> can be followed by a pipe character '|' followed by the name of the INT file.
92002>>>>>>>    //  Doing so, the driver will apply the information from the .INT file to the passed direct Open String.
92002>>>>>>>    //  Note that when an INT file has been passed, it will skip the keyword DRIVER_NAME, SERVER_NAME,
92002>>>>>>>    //  DATABASE_NAME and SCHEMA_NAME from the INT file because those are supposed to be supplied in the String already.
92002>>>>>>>    //  Open mode; iMode = DF_SHARE or DF_EXCLUSIVE.
92002>>>>>>>    //
92002>>>>>>>    // DAW Driver Sample:
92002>>>>>>>    //   Open "MSSQLDRV:dbo#MyFile@SERVER=(local)\SQLEXPRESS;Trusted_Connection=yes;DATABASE=OrderEntry|options|intfile=MyFile.int"
92002>>>>>>>    //
92002>>>>>>>    // Mertech Driver Samples:
92002>>>>>>>    //   SQLFlex:   Open "sql_drv:\\<serverName>\<database>*<owner>*<tableName>=<numberFieds>" as table
92002>>>>>>>    //   MySQLFlex: Open "mdsmysql:\\<serverName>\<database>*<tableName>=<numberFieds>" as table
92002>>>>>>>    //   PgFlex:    Open "mdspgsql:\\<serverName>\<database>*<schema>*<tableName>=<numberFieds>" as table
92002>>>>>>>    //   ORAFlex:   Open "ora_drv:\\<serverName>\<owner>*<tableName>=<numberFieds>" as table
92002>>>>>>>    Function UtilTableOpen Integer hTable String sTableName Integer iMode Returns Boolean
92004>>>>>>>        String sTableNameOrg
92004>>>>>>>        Boolean bOpen bOK
92004>>>>>>>        tSQLConnection SQLConnection
92004>>>>>>>        tSQLConnection SQLConnection
92004>>>>>>>        
92004>>>>>>>        Move False to bOpen
92005>>>>>>>        Move sTableName to sTableNameOrg
92006>>>>>>>        If (hTable > 0) Begin
92008>>>>>>>            Send Ignore_Error of Error_Object_Id 20529
92009>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
92010>>>>>>>            Send Ignore_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
92011>>>>>>>            Send Ignore_Error of Error_Object_Id 10
92012>>>>>>>            Open hTable Mode iMode
92014>>>>>>>            Send Trap_Error of Error_Object_Id 20529
92015>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_OPEN_DATA_FILE
92016>>>>>>>            Send Trap_Error of Error_Object_Id CLIERR_CONNECTIONIDNOTFOUND
92017>>>>>>>            Send Trap_Error of Error_Object_Id 10
92018>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
92021>>>>>>>            If (bOpen = True) Begin
92023>>>>>>>                Function_Return True
92024>>>>>>>            End
92024>>>>>>>>
92024>>>>>>>        End
92024>>>>>>>>
92024>>>>>>>
92024>>>>>>>        Get UtilTableOpenAsIntFile hTable sTableName iMode to bOK 
92025>>>>>>>        If (hTable > 0) Begin
92027>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpen
92030>>>>>>>        End
92030>>>>>>>>
92030>>>>>>>
92030>>>>>>>        Function_Return bOpen
92031>>>>>>>    End_Function
92032>>>>>>>
92032>>>>>>>    Function UtilTableOpenAsIntFile Integer hTable String sTableName Integer iMode Returns Boolean
92034>>>>>>>        String sDriverID sConnection sSchema sExt sTableNameShort sTableNameOrg
92034>>>>>>>        Boolean bOpen bMertechDriver bOK
92034>>>>>>>        tSQLConnection SQLConnection
92034>>>>>>>        tSQLConnection SQLConnection
92034>>>>>>>
92034>>>>>>>        If (hTable < 1) Begin
92036>>>>>>>            Function_Return False
92037>>>>>>>        End
92037>>>>>>>>
92037>>>>>>>
92037>>>>>>>        Move sTableName to sTableNameOrg
92038>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
92039>>>>>>>        Move SQLConnection.sDriverID to sDriverID
92040>>>>>>>        Get IsMertechDriver sDriverID to bMertechDriver
92041>>>>>>>        Move SQLConnection.sConnectionString to sConnection
92042>>>>>>>        Move SQLConnection.sSchema to sSchema
92043>>>>>>>        If (sSchema = "") Begin
92045>>>>>>>            Get _SqlFindKeyWord CI_SQLDBO to sSchema
92046>>>>>>>        End
92046>>>>>>>>
92046>>>>>>>
92046>>>>>>>        // We need to remove the ".int" part of the table name because
92046>>>>>>>        // the table name after the "#" in the connection syntax below wants the
92046>>>>>>>        // "bare" table name without any extension.
92046>>>>>>>        If (sDriverID <> DATAFLEX_ID) Begin
92048>>>>>>>            If (Lowercase(sTableName) contains ".int") Begin
92050>>>>>>>                Get ParseFileExtension sTableName to sExt
92051>>>>>>>                Move (Replace(("." + sExt), sTableName, "")) to sTableNameShort
92052>>>>>>>            End
92052>>>>>>>>
92052>>>>>>>            Else Begin
92053>>>>>>>                Move sTableName to sTableNameShort
92054>>>>>>>                Move (Append(sTableName, ".int")) to sTableName
92055>>>>>>>            End
92055>>>>>>>>
92055>>>>>>>            If (bMertechDriver = False) Begin
92057>>>>>>>                Move (sDriverID + ":" + sSchema + "#" + sTableNameShort + "@" + sConnection + "|options|intfile=" + sTableName) to sConnection
92058>>>>>>>                Move sConnection to sTableName
92059>>>>>>>            End
92059>>>>>>>>
92059>>>>>>>        End
92059>>>>>>>>
92059>>>>>>>
92059>>>>>>>        Send Ignore_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
92060>>>>>>>        Send Ignore_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
92061>>>>>>>        If (hTable = 0) Begin
92063>>>>>>>            Get NextFreeFilelistSlot to hTable
92064>>>>>>>        End
92064>>>>>>>>
92064>>>>>>>
92064>>>>>>>        Case Begin
92064>>>>>>>            Case (sDriverID = MSSQLDRV_ID)
92066>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
92066>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
92068>>>>>>>                    Close hTable
92069>>>>>>>                    Open sTableName as hTable
92071>>>>>>>                End
92071>>>>>>>>
92071>>>>>>>                Else Begin
92072>>>>>>>                    Get OpenTableExclusive hTable to bOK
92073>>>>>>>                    If (bOK = False) Begin
92075>>>>>>>                        Function_Return False
92076>>>>>>>                    End
92076>>>>>>>>
92076>>>>>>>                End
92076>>>>>>>>
92076>>>>>>>                Case Break
92077>>>>>>>
92077>>>>>>>            Case (sDriverID = DB2_DRV_ID)
92080>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
92080>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
92082>>>>>>>                    Close hTable
92083>>>>>>>                    Open sTableName as hTable
92085>>>>>>>                End
92085>>>>>>>>
92085>>>>>>>                Else Begin
92086>>>>>>>                    Get OpenTableExclusive hTable to bOK
92087>>>>>>>                    If (bOK = False) Begin
92089>>>>>>>                        Function_Return False
92090>>>>>>>                    End
92090>>>>>>>>
92090>>>>>>>                End
92090>>>>>>>>
92090>>>>>>>                Case Break
92091>>>>>>>
92091>>>>>>>            Case (sDriverID = ODBC_DRV_ID)
92094>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
92094>>>>>>>                If (iMode = DF_SHARE) Begin
92096>>>>>>>                    Close hTable
92097>>>>>>>                    Open sTableName as hTable
92099>>>>>>>                End
92099>>>>>>>>
92099>>>>>>>                Else Begin
92100>>>>>>>                    Get OpenTableExclusive hTable to bOK
92101>>>>>>>                    If (bOK = False) Begin
92103>>>>>>>                        Function_Return False
92104>>>>>>>                    End
92104>>>>>>>>
92104>>>>>>>                End
92104>>>>>>>>
92104>>>>>>>                Case Break
92105>>>>>>>
92105>>>>>>>            Case (sDriverID = SQLFLEX)
92108>>>>>>>                // ToDo: What is the <owner>? Same as Schema?
92108>>>>>>>                // SQLFlex:   Open "sql_drv:\\<serverName>\<database>*<owner>*<tableName>=<numberFieds>" as table
92108>>>>>>>                Move (SQLFLEX + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sDatabase + SQLConnection.sSchema + "*" + sTableNameOrg) to sTableName
92109>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
92109>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
92111>>>>>>>                    Close hTable
92112>>>>>>>                    Open sTableName as hTable
92114>>>>>>>                End
92114>>>>>>>>
92114>>>>>>>                Else Begin
92115>>>>>>>                    Get OpenTableExclusive hTable to bOK
92116>>>>>>>                    If (bOK = False) Begin
92118>>>>>>>                        Function_Return False
92119>>>>>>>                    End
92119>>>>>>>>
92119>>>>>>>                End
92119>>>>>>>>
92119>>>>>>>                Case Break
92120>>>>>>>
92120>>>>>>>            Case (sDriverID = MDSMySQL)
92123>>>>>>>                // MySQLFlex: Open "mdsmysql:\\<serverName>\<database>*<tableName>=<numberFieds>" as table
92123>>>>>>>                Move (MDSMySQL + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sDatabase + "*" + sTableNameOrg) to sTableName
92124>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
92124>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
92126>>>>>>>                    Close hTable
92127>>>>>>>                    Open sTableName as hTable
92129>>>>>>>                End
92129>>>>>>>>
92129>>>>>>>                Else Begin
92130>>>>>>>                    Get OpenTableExclusive hTable to bOK
92131>>>>>>>                    If (bOK = False) Begin
92133>>>>>>>                        Function_Return False
92134>>>>>>>                    End
92134>>>>>>>>
92134>>>>>>>                End
92134>>>>>>>>
92134>>>>>>>                Case Break
92135>>>>>>>
92135>>>>>>>            Case (sDriverID = MDSPgSQL)
92138>>>>>>>                // PgFlex: Open "mdspgsql:\\<serverName>\<database>*<schema>*<tableName>=<numberFieds>" as table
92138>>>>>>>                Move (MDSPgSQL + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sDatabase + "*" + SQLConnection.sSchema + "*" + sTableNameOrg) to sTableName
92139>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
92139>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
92141>>>>>>>                    Close hTable
92142>>>>>>>                    Open sTableName as hTable
92144>>>>>>>                End
92144>>>>>>>>
92144>>>>>>>                Else Begin
92145>>>>>>>                    Get OpenTableExclusive hTable to bOK
92146>>>>>>>                    If (bOK = False) Begin
92148>>>>>>>                        Function_Return False
92149>>>>>>>                    End
92149>>>>>>>>
92149>>>>>>>                End
92149>>>>>>>>
92149>>>>>>>                Case Break
92150>>>>>>>
92150>>>>>>>            Case (sDriverID = ORAFLEX)
92153>>>>>>>                // ToDo: What is the <owner>? Same as Schema?
92153>>>>>>>                // ORAFlex: Open "ora_drv:\\<serverName>\<owner>*<tableName>=<numberFieds>" as table
92153>>>>>>>                Move (ORAFLEX + ":\\" + SQLConnection.sServer + "\" + SQLConnection.sSchema + "*" + sTableName) to sTableName
92154>>>>>>>                // If not df_exclusive mode, we use the "Open As" syntax.
92154>>>>>>>                If (iMode <> DF_EXCLUSIVE) Begin
92156>>>>>>>                    Close hTable
92157>>>>>>>                    Open sTableName as hTable
92159>>>>>>>                End
92159>>>>>>>>
92159>>>>>>>                Else Begin
92160>>>>>>>                    Get OpenTableExclusive hTable to bOK
92161>>>>>>>                    If (bOK = False) Begin
92163>>>>>>>                        Function_Return False
92164>>>>>>>                    End
92164>>>>>>>>
92164>>>>>>>                End
92164>>>>>>>>
92164>>>>>>>                Case Break
92165>>>>>>>
92165>>>>>>>            Case (sDriverID = DATAFLEX_ID)
92168>>>>>>>                If (sTableName <> "" and iMode <> DF_EXCLUSIVE) Begin
92170>>>>>>>                    Close hTable
92171>>>>>>>                    Open sTableName as hTable
92173>>>>>>>                End
92173>>>>>>>>
92173>>>>>>>                Else If (iMode = DF_EXCLUSIVE) Begin
92176>>>>>>>                    Get OpenTableExclusive hTable to bOK
92177>>>>>>>                    If (bOK = False) Begin
92179>>>>>>>                        Function_Return False
92180>>>>>>>                    End
92180>>>>>>>>
92180>>>>>>>                End
92180>>>>>>>>
92180>>>>>>>                Else Begin
92181>>>>>>>                    Open hTable
92183>>>>>>>                End
92183>>>>>>>>
92183>>>>>>>                Case Break
92184>>>>>>>
92184>>>>>>>            Case Else
92184>>>>>>>                Error DFERR_PROGRAM ("Invalid driver:" * sDriverID)
92185>>>>>>>>
92185>>>>>>>        Case End
92185>>>>>>>
92185>>>>>>>        Send Trap_Error of Error_Object_Id CLIERR_LOGIN_UNSUCCESSFUL
92186>>>>>>>        Send Trap_Error of Error_Info_Object DFERR_FILE_ACCESS_VIOLATION
92187>>>>>>>        If (LastErr = CLIERR_LOGIN_UNSUCCESSFUL) Begin
92189>>>>>>>            Move False to Found
92190>>>>>>>        End
92190>>>>>>>>
92190>>>>>>>        // If open failed, the Err is set to true,
92190>>>>>>>        // but we don't want that because it could end our loop.
92190>>>>>>>        Move False to Err
92191>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
92194>>>>>>>
92194>>>>>>>        Function_Return bOpen
92195>>>>>>>    End_Function
92196>>>>>>>
92196>>>>>>>    // Checks that the passed hTable number both exists in Filelist.cfg and
92196>>>>>>>    // that the embedded .dat file exists on disk _or_ that the SQL table exists
92196>>>>>>>    // if it is an SQL table
92196>>>>>>>    Function UtilTableExists Handle hTable Returns Boolean
92198>>>>>>>        Boolean bExists bIsSQLTable
92198>>>>>>>        String sDataPath sRootName
92198>>>>>>>
92198>>>>>>>        Get UtilTableNumberIsInUse hTable to bExists
92199>>>>>>>        If (bExists = False) Begin
92201>>>>>>>            Function_Return False
92202>>>>>>>        End
92202>>>>>>>>
92202>>>>>>>
92202>>>>>>>        Move False to bIsSQLTable
92203>>>>>>>        If (hTable > 0) Begin
92205>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
92208>>>>>>>            Move (sRootName contains ":") to bIsSQLTable
92209>>>>>>>        End
92209>>>>>>>>
92209>>>>>>>        If (bIsSQLTable = True) Begin
92211>>>>>>>            Get UtilTableIsSQL hTable to bExists
92212>>>>>>>            Function_Return bExists
92213>>>>>>>        End
92213>>>>>>>>
92213>>>>>>>        Else Begin
92214>>>>>>>            Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
92215>>>>>>>            Get vFolderFormat sDataPath to sDataPath
92216>>>>>>>            Get vFilePathExists (sDataPath + sRootName + ".dat") to bExists
92217>>>>>>>        End
92217>>>>>>>>
92217>>>>>>>
92217>>>>>>>        Function_Return bExists
92218>>>>>>>    End_Function
92219>>>>>>>
92219>>>>>>>    // Pass a table handle
92219>>>>>>>    // Returns True if the table exists in filelist.cfg.
92219>>>>>>>    Function UtilTableNumberIsInUse Handle hCheckTable Returns Boolean
92221>>>>>>>        Handle hTable
92221>>>>>>>        Boolean bFound
92221>>>>>>>
92221>>>>>>>        Move False to bFound
92222>>>>>>>        Move 0 to hTable
92223>>>>>>>        Repeat
92223>>>>>>>>
92223>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92226>>>>>>>            If (hTable > 0) Begin
92228>>>>>>>                If (hTable = hCheckTable) Begin
92230>>>>>>>                    Move True to bFound
92231>>>>>>>                End
92231>>>>>>>>
92231>>>>>>>            End
92231>>>>>>>>
92231>>>>>>>            If (bFound = True) ;                Break
92234>>>>>>>        Until (hTable = 0)
92236>>>>>>>
92236>>>>>>>        Function_Return (bFound = True)
92237>>>>>>>    End_Function
92238>>>>>>>
92238>>>>>>>    // Pass a table's logical name
92238>>>>>>>    // Returns True if the table exists in filelist.cfg.
92238>>>>>>>    Function UtilTableLogicalNameIsInUse String sCheckTable Returns Boolean
92240>>>>>>>        Handle hTable
92240>>>>>>>        Boolean bFound
92240>>>>>>>        String sCompareTable
92240>>>>>>>
92240>>>>>>>        Move False to bFound
92241>>>>>>>        Move 0 to hTable
92242>>>>>>>        Repeat
92242>>>>>>>>
92242>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92245>>>>>>>            If (hTable > 0) Begin
92247>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sCompareTable
92250>>>>>>>                If (Uppercase(sCompareTable) = Uppercase(sCheckTable)) Begin
92252>>>>>>>                    Move True to bFound
92253>>>>>>>                End
92253>>>>>>>>
92253>>>>>>>            End
92253>>>>>>>>
92253>>>>>>>            If (bFound = True) ;                Break
92256>>>>>>>        Until (hTable = 0)
92258>>>>>>>
92258>>>>>>>        Function_Return (bFound = True)
92259>>>>>>>    End_Function
92260>>>>>>>
92260>>>>>>>    // Function will report the default driver "DATAFLEX" if table can't be opened
92260>>>>>>>    Function UtilDriverFromTableNumber Handle hTable Returns String
92262>>>>>>>        Boolean bOK bExists
92262>>>>>>>        String sDriverID
92262>>>>>>>
92262>>>>>>>        Get UtilTableExists hTable to bExists
92263>>>>>>>        If (bExists = False) Begin
92265>>>>>>>            Function_Return DATAFLEX_ID
92266>>>>>>>        End
92266>>>>>>>>
92266>>>>>>>        Get OpenTableExclusive hTable to bOK
92267>>>>>>>        If (bOK = False) Begin
92269>>>>>>>            Function_Return DATAFLEX_ID
92270>>>>>>>        End
92270>>>>>>>>
92270>>>>>>>        Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
92273>>>>>>>        Function_Return sDriverID
92274>>>>>>>    End_Function
92275>>>>>>>
92275>>>>>>>    // Number of tables in Filelist.cfg. Returns integger
92275>>>>>>>    Function UtilFilelistNoOfTables Returns Integer
92277>>>>>>>        Handle hTable
92277>>>>>>>        Integer iRetval
92277>>>>>>>
92277>>>>>>>        Move 0 to hTable
92278>>>>>>>        Move 0 to iRetval
92279>>>>>>>
92279>>>>>>>        Repeat
92279>>>>>>>>
92279>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92282>>>>>>>            If (hTable > 0) Begin
92284>>>>>>>                Increment iRetval
92285>>>>>>>            End
92285>>>>>>>>
92285>>>>>>>        Until (hTable = 0)
92287>>>>>>>
92287>>>>>>>        Function_Return iRetval
92288>>>>>>>    End_Function
92289>>>>>>>
92289>>>>>>>    // Checks if any of the tables in Filelist.cfg is an SQL driver and returns the first Driver ID.
92289>>>>>>>    Function UtilIsAnyFilelistEntrySQLtable Returns String
92291>>>>>>>        Handle hTable
92291>>>>>>>        String sRoot sDriverID
92291>>>>>>>        Boolean bIsSQLTable
92291>>>>>>>        Integer iPos
92291>>>>>>>
92291>>>>>>>        Move 0 to hTable
92292>>>>>>>        Move "" to sDriverID
92293>>>>>>>        Move False to bIsSQLTable
92294>>>>>>>
92294>>>>>>>        Repeat
92294>>>>>>>>
92294>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92297>>>>>>>            If (hTable > 0) Begin
92299>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRoot
92302>>>>>>>                If (sRoot contains ":") Begin
92304>>>>>>>                    Move (Pos(":", sRoot)) to iPos
92305>>>>>>>                    Move (Left(sRoot, (iPos -1))) to sDriverID
92306>>>>>>>                End
92306>>>>>>>>
92306>>>>>>>                Get IsSQLDriver sDriverID to bIsSQLTable
92307>>>>>>>            End
92307>>>>>>>>
92307>>>>>>>
92307>>>>>>>        Until (hTable = 0 or bIsSQLTable = True)
92309>>>>>>>
92309>>>>>>>        Function_Return sDriverID
92310>>>>>>>    End_Function
92311>>>>>>>
92311>>>>>>>    Function UtilIsAllFilelistEntriesDataFlexTables Returns Boolean
92313>>>>>>>        String sRootName
92313>>>>>>>        Boolean bIsSQL
92313>>>>>>>        Handle hTable
92313>>>>>>>
92313>>>>>>>        Move False to bIsSQL
92314>>>>>>>        Move 0 to hTable
92315>>>>>>>        Repeat
92315>>>>>>>>
92315>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
92318>>>>>>>            If (hTable > 0) Begin
92320>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
92323>>>>>>>                Get UtilTableIsSqlByRootName sRootName to bIsSQL
92324>>>>>>>                If (bIsSQL = True) Begin
92326>>>>>>>                    Move 0 to hTable
92327>>>>>>>                End
92327>>>>>>>>
92327>>>>>>>            End
92327>>>>>>>>
92327>>>>>>>        Until (hTable = 0)
92329>>>>>>>
92329>>>>>>>        Function_Return (bIsSQL = False)
92330>>>>>>>    End_Function
92331>>>>>>>
92331>>>>>>>    // * Dummy function for the Studio's Code Explorer *
92331>>>>>>>    Function UTIL_ENUMERATION_FUNCTIONS Returns Boolean
92333>>>>>>>        Function_Return False
92334>>>>>>>    End_Function
92335>>>>>>>
92335>>>>>>>    Function UtilEnumerateOverlapFields Integer hTable Integer iField Returns String[]
92337>>>>>>>        String  sRetval
92337>>>>>>>        String[] sOverlapFieldsArray
92338>>>>>>>        Integer iType iColumn iColumns
92338>>>>>>>        Boolean bOpen bOverlap
92338>>>>>>>
92338>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpen
92341>>>>>>>        If (bOpen = False) Begin
92343>>>>>>>            Open hTable
92345>>>>>>>        End
92345>>>>>>>>
92345>>>>>>>
92345>>>>>>>        Move "" to sRetval
92346>>>>>>>
92346>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTable to iColumns
92349>>>>>>>
92349>>>>>>>        for iColumn from 0 to iColumns
92355>>>>>>>>
92355>>>>>>>            Get_Attribute DF_FIELD_TYPE of hTable iColumn to iType
92358>>>>>>>            If (iField <> iColumn and iType <> DF_OVERLAP) Begin
92360>>>>>>>                Get_Attribute DF_FIELD_OVERLAP of hTable iField iColumn to bOverlap
92363>>>>>>>                If (bOverlap) Begin
92365>>>>>>>                    If (sRetval <> "") Begin
92367>>>>>>>                        Append sRetval ","
92368>>>>>>>                    End
92368>>>>>>>>
92368>>>>>>>                    Append sRetval iColumn
92369>>>>>>>                End
92369>>>>>>>>
92369>>>>>>>            End
92369>>>>>>>>
92369>>>>>>>        Loop
92370>>>>>>>>
92370>>>>>>>
92370>>>>>>>        If (bOpen = False) Begin
92372>>>>>>>            Close hTable
92373>>>>>>>        End
92373>>>>>>>>
92373>>>>>>>
92373>>>>>>>        Get StrSplitToArray sRetval "," to sOverlapFieldsArray
92374>>>>>>>
92374>>>>>>>        Function_Return sOverlapFieldsArray
92375>>>>>>>    End_Function
92376>>>>>>>
92376>>>>>>>    // Returns a struct array with all data types for the passed driver & dbtype.
92376>>>>>>>    Function UtilEnumerateColumnTypes String sDriverID Integer iDbType Returns tColumnType[]
92378>>>>>>>        tColumnType[] ColumnType
92378>>>>>>>        tColumnType[] ColumnType
92379>>>>>>>
92379>>>>>>>        // We need to treat DAW's ODBC driver a bit different, as the output depends on
92379>>>>>>>        // the dbType.
92379>>>>>>>        If (sDriverID = ODBC_DRV_ID) Begin
92381>>>>>>>            If (iDbType = EN_DbTypeMySQL) Begin
92383>>>>>>>                Move MDSMySQL to sDriverID
92384>>>>>>>            End
92384>>>>>>>>
92384>>>>>>>            If (iDbType = EN_DbTypeMSSQL) Begin
92386>>>>>>>                Move MSSQLDRV_ID to sDriverID
92387>>>>>>>            End
92387>>>>>>>>
92387>>>>>>>            If (iDbType = EN_DbTypeDB2) Begin
92389>>>>>>>                Move DB2_DRV_ID to sDriverID
92390>>>>>>>            End
92390>>>>>>>>
92390>>>>>>>            If (iDbType = EN_DbTypePostgre) Begin
92392>>>>>>>                Move MDSPgSQL to sDriverID
92393>>>>>>>            End
92393>>>>>>>>
92393>>>>>>>        End
92393>>>>>>>>
92393>>>>>>>
92393>>>>>>>        Case Begin
92393>>>>>>>            Case (iDbType = EN_dbTypeDataFlex)
92395>>>>>>>                Get _UtilEnumerateDataFlexTypes to ColumnType
92396>>>>>>>                Case Break
92397>>>>>>>
92397>>>>>>>            Case (iDbType = EN_DbTypeDB2)
92400>>>>>>>                Get _UtilEnumerateDB2Types to ColumnType
92401>>>>>>>                Case Break
92402>>>>>>>
92402>>>>>>>            Case (iDbType = EN_DbTypeMSSQL)
92405>>>>>>>                Get _UtilEnumerateMSSQLTypes sDriverID to ColumnType
92406>>>>>>>                Case Break
92407>>>>>>>
92407>>>>>>>            Case (sDriverID = MDSMySQL)
92410>>>>>>>                Get _UtilEnumerateMySQLTypes to ColumnType
92411>>>>>>>                Case Break
92412>>>>>>>
92412>>>>>>>            Case (sDriverID = ORAFLEX)
92415>>>>>>>                Get _UtilEnumerateOracleTypes to ColumnType
92416>>>>>>>                Case Break
92417>>>>>>>
92417>>>>>>>            Case (sDriverID = MDSPgSQL)
92420>>>>>>>                Get _UtilEnumeratePostgreSQLTypes to ColumnType
92421>>>>>>>                Case Break
92422>>>>>>>        Case End
92422>>>>>>>
92422>>>>>>>        Function_Return ColumnType
92423>>>>>>>    End_Function
92424>>>>>>>
92424>>>>>>>    Function UtilEnumerateODBCDrivers Returns String
92426>>>>>>>        Handle hoRegistry hoODBCDriverNames
92426>>>>>>>        Boolean bExists bKeyOpened
92426>>>>>>>        String sKey
92426>>>>>>>        String[] sDrivers
92427>>>>>>>        Integer iDriverNames iDriverName
92427>>>>>>>
92427>>>>>>>        Get Create (RefClass (cRegistry)) to hoRegistry
92428>>>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
92429>>>>>>>        Set pfAccessRights of hoRegistry to Key_Read
92430>>>>>>>        Move "SOFTWARE\ODBC\ODBCINST.INI\ODBC Drivers" to sKey
92431>>>>>>>        Get KeyExists of hoRegistry sKey to bExists
92432>>>>>>>        If (bExists) Begin
92434>>>>>>>            Get OpenKey of hoRegistry sKey to bKeyOpened
92435>>>>>>>            If (bKeyOpened) Begin
92437>>>>>>>                Get Create (RefClass (Array)) to hoODBCDriverNames
92438>>>>>>>                Get GetValues of hoRegistry hoODBCDriverNames to iDriverNames
92439>>>>>>>                If (iDriverNames > 0) Begin
92441>>>>>>>                    Move (ResizeArray (sDrivers, iDriverNames)) to sDrivers
92442>>>>>>>                    Decrement iDriverNames
92443>>>>>>>                    for iDriverName from 0 to iDriverNames
92449>>>>>>>>
92449>>>>>>>                        Get Value of hoODBCDriverNames iDriverName to sDrivers[iDriverName]
92450>>>>>>>                    Loop
92451>>>>>>>>
92451>>>>>>>                End
92451>>>>>>>>
92451>>>>>>>                Send CloseKey of hoRegistry
92452>>>>>>>            End
92452>>>>>>>>
92452>>>>>>>        End
92452>>>>>>>>
92452>>>>>>>        Send Destroy of hoRegistry
92453>>>>>>>
92453>>>>>>>        Function_Return sDrivers
92454>>>>>>>    End_Function
92455>>>>>>>
92455>>>>>>>    // DataFlex Embedded Database Data Types:
92455>>>>>>>    // Helper function for UtilEnumerateColumnTypes
92455>>>>>>>    Function _UtilEnumerateDataFlexTypes Returns tColumnType[]
92457>>>>>>>        tColumnType[] ColumnType
92457>>>>>>>        tColumnType[] ColumnType
92458>>>>>>>        Integer i
92458>>>>>>>
92458>>>>>>>        Move DF_ASCII           to ColumnType[i].iSQLType
92459>>>>>>>        Move "ASCII"            to ColumnType[i].sSQLType
92460>>>>>>>        Move DF_ASCII           to ColumnType[i].iDataFlexType
92461>>>>>>>        Move "ASCII"            to ColumnType[i].sDataFlexType
92462>>>>>>>        Move "254"              to ColumnType[i].sPrecision
92463>>>>>>>        Increment i
92464>>>>>>>
92464>>>>>>>        Move DF_BCD             to ColumnType[i].iSQLType
92465>>>>>>>        Move "Numeric"          to ColumnType[i].sSQLType
92466>>>>>>>        Move DF_BCD             to ColumnType[i].iDataFlexType
92467>>>>>>>        Move "Numeric"          to ColumnType[i].sDataFlexType
92468>>>>>>>        Move "14.8"             to ColumnType[i].sPrecision
92469>>>>>>>        Increment i
92470>>>>>>>
92470>>>>>>>        Move DF_DATE            to ColumnType[i].iSQLType
92471>>>>>>>        Move "Date"             to ColumnType[i].sSQLType
92472>>>>>>>        Move DF_DATE            to ColumnType[i].iDataFlexType
92473>>>>>>>        Move "Date"             to ColumnType[i].sDataFlexType
92474>>>>>>>        Move "6.0"              to ColumnType[i].sPrecision
92475>>>>>>>        Move True               to ColumnType[i].bCanEditSize
92476>>>>>>>        Increment i
92477>>>>>>>
92477>>>>>>>        Move DF_TEXT            to ColumnType[i].iSQLType
92478>>>>>>>        Move "Text"             to ColumnType[i].sSQLType
92479>>>>>>>        Move DF_TEXT            to ColumnType[i].iDataFlexType
92480>>>>>>>        Move "Text"             to ColumnType[i].sDataFlexType
92481>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
92482>>>>>>>        Increment i
92483>>>>>>>
92483>>>>>>>        Move DF_BINARY          to ColumnType[i].iSQLType
92484>>>>>>>        Move "Binary"           to ColumnType[i].sSQLType
92485>>>>>>>        Move DF_BINARY          to ColumnType[i].iDataFlexType
92486>>>>>>>        Move "Binary"           to ColumnType[i].sDataFlexType
92487>>>>>>>        Move "16384"            to ColumnType[i].sPrecision
92488>>>>>>>        Increment i
92489>>>>>>>
92489>>>>>>>        Move DF_DATETIME        to ColumnType[i].iSQLType
92490>>>>>>>        Move "DateTime"         to ColumnType[i].sSQLType
92491>>>>>>>        Move DF_DATETIME        to ColumnType[i].iDataFlexType
92492>>>>>>>        Move "DateTime"         to ColumnType[i].sDataFlexType
92493>>>>>>>        Move "23"               to ColumnType[i].sPrecision
92494>>>>>>>        Move True               to ColumnType[i].bCanEditSize
92495>>>>>>>        Increment i
92496>>>>>>>
92496>>>>>>>        Move DF_OVERLAP         to ColumnType[i].iSQLType
92497>>>>>>>        Move "Overlap"          to ColumnType[i].sSQLType
92498>>>>>>>        Move DF_OVERLAP         to ColumnType[i].iDataFlexType
92499>>>>>>>        Move "Overlap"          to ColumnType[i].sDataFlexType
92500>>>>>>>        Move "0.0"              to ColumnType[i].sPrecision
92501>>>>>>>
92501>>>>>>>        Function_Return ColumnType
92502>>>>>>>    End_Function
92503>>>>>>>
92503>>>>>>>    Function _UtilEnumerateDB2Types Returns tColumnType[]
92505>>>>>>>        tColumnType[] aColumnType
92505>>>>>>>        tColumnType[] aColumnType
92506>>>>>>>        Integer i
92506>>>>>>>
Including file: DB2_DRV_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DB2_DRV_DriverDef.inc)
92506>>>>>>>>// Generated By The Database Update Framework
92506>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.1\bin\MSSQLDRV_DriverDef.xml
92506>>>>>>>>// Driver COLUMN DATA TYPES
92506>>>>>>>>//
92506>>>>>>>>// Created: 2019-07-18 18:57:13.935
92506>>>>>>>>
92506>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
92507>>>>>>>>            Move -5                                      to aColumnType[i].iSQLType
92508>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
92509>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
92510>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
92511>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
92512>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
92513>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
92514>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
92515>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
92516>>>>>>>>            Increment i
92517>>>>>>>>
92517>>>>>>>>            Move "binary"                                to aColumnType[i].sSQLType
92518>>>>>>>>            Move -2                                      to aColumnType[i].iSQLType
92519>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
92520>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
92521>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
92522>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
92523>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
92524>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92525>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92526>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
92527>>>>>>>>            Increment i
92528>>>>>>>>
92528>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
92529>>>>>>>>            Move -7                                      to aColumnType[i].iSQLType
92530>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
92531>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
92532>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
92533>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
92534>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
92535>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92536>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92537>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
92538>>>>>>>>            Increment i
92539>>>>>>>>
92539>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
92540>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
92541>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
92542>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
92543>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
92544>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
92545>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
92546>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92547>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92548>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
92549>>>>>>>>            Increment i
92550>>>>>>>>
92550>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
92551>>>>>>>>            Move 91                                      to aColumnType[i].iSQLType
92552>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
92553>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
92554>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
92555>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
92556>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
92557>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92558>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92559>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
92560>>>>>>>>            Increment i
92561>>>>>>>>
92561>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
92562>>>>>>>>            Move 93                                      to aColumnType[i].iSQLType
92563>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
92564>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
92565>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
92566>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
92567>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
92568>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92569>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92570>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
92571>>>>>>>>            Increment i
92572>>>>>>>>
92572>>>>>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
92573>>>>>>>>            Move -200                                    to aColumnType[i].iSQLType
92574>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
92575>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
92576>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
92577>>>>>>>>            Move 23                                      to aColumnType[i].iMinSize
92578>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
92579>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92580>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92581>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
92582>>>>>>>>            Increment i
92583>>>>>>>>
92583>>>>>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
92584>>>>>>>>            Move -155                                    to aColumnType[i].iSQLType
92585>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
92586>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
92587>>>>>>>>            Move 34                                      to aColumnType[i].iDefaultSize
92588>>>>>>>>            Move 34                                      to aColumnType[i].iMinSize
92589>>>>>>>>            Move 34                                      to aColumnType[i].nMaxSize
92590>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92591>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92592>>>>>>>>            Move 34                                      to aColumnType[i].sPrecision
92593>>>>>>>>            Increment i
92594>>>>>>>>
92594>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
92595>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
92596>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
92597>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
92598>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
92599>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
92600>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
92601>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
92602>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
92603>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
92604>>>>>>>>            Increment i
92605>>>>>>>>
92605>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
92606>>>>>>>>            Move 6                                       to aColumnType[i].iSQLType
92607>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
92608>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
92609>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
92610>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
92611>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
92612>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
92613>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
92614>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
92615>>>>>>>>            Increment i
92616>>>>>>>>
92616>>>>>>>>            Move "image"                                 to aColumnType[i].sSQLType
92617>>>>>>>>            Move -4                                      to aColumnType[i].iSQLType
92618>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
92619>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
92620>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
92621>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
92622>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
92623>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92624>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92625>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
92626>>>>>>>>            Increment i
92627>>>>>>>>
92627>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
92628>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
92629>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
92630>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
92631>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
92632>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
92633>>>>>>>>            Move 10                                      to aColumnType[i].nMaxSize
92634>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
92635>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
92636>>>>>>>>            Move 10                                      to aColumnType[i].sPrecision
92637>>>>>>>>            Increment i
92638>>>>>>>>
92638>>>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
92639>>>>>>>>            Move -204                                    to aColumnType[i].iSQLType
92640>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
92641>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
92642>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
92643>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
92644>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
92645>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92646>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92647>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
92648>>>>>>>>            Increment i
92649>>>>>>>>
92649>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
92650>>>>>>>>            Move -8                                      to aColumnType[i].iSQLType
92651>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
92652>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
92653>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
92654>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
92655>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
92656>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92657>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92658>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
92659>>>>>>>>            Increment i
92660>>>>>>>>
92660>>>>>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
92661>>>>>>>>            Move -10                                     to aColumnType[i].iSQLType
92662>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
92663>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
92664>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
92665>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
92666>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
92667>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92668>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92669>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
92670>>>>>>>>            Increment i
92671>>>>>>>>
92671>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
92672>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
92673>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
92674>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
92675>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
92676>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
92677>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
92678>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
92679>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
92680>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
92681>>>>>>>>            Increment i
92682>>>>>>>>
92682>>>>>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
92683>>>>>>>>            Move -9                                      to aColumnType[i].iSQLType
92684>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
92685>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
92686>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
92687>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
92688>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
92689>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92690>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92691>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
92692>>>>>>>>            Increment i
92693>>>>>>>>
92693>>>>>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
92694>>>>>>>>            Move -202                                    to aColumnType[i].iSQLType
92695>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
92696>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
92697>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
92698>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
92699>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
92700>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92701>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92702>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
92703>>>>>>>>            Increment i
92704>>>>>>>>
92704>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
92705>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
92706>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
92707>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
92708>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
92709>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
92710>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
92711>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
92712>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
92713>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
92714>>>>>>>>            Increment i
92715>>>>>>>>
92715>>>>>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
92716>>>>>>>>            Move -206                                    to aColumnType[i].iSQLType
92717>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
92718>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
92719>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
92720>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
92721>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
92722>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92723>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92724>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
92725>>>>>>>>            Increment i
92726>>>>>>>>
92726>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
92727>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
92728>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
92729>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
92730>>>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
92731>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
92732>>>>>>>>            Move 5                                       to aColumnType[i].nMaxSize
92733>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
92734>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
92735>>>>>>>>            Move 5                                       to aColumnType[i].sPrecision
92736>>>>>>>>            Increment i
92737>>>>>>>>
92737>>>>>>>>            Move "smallmoney"                            to aColumnType[i].sSQLType
92738>>>>>>>>            Move -205                                    to aColumnType[i].iSQLType
92739>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
92740>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
92741>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
92742>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
92743>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
92744>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92745>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92746>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
92747>>>>>>>>            Increment i
92748>>>>>>>>
92748>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
92749>>>>>>>>            Move -1                                      to aColumnType[i].iSQLType
92750>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
92751>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
92752>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
92753>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
92754>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
92755>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92756>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92757>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
92758>>>>>>>>            Increment i
92759>>>>>>>>
92759>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
92760>>>>>>>>            Move -154                                    to aColumnType[i].iSQLType
92761>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
92762>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
92763>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
92764>>>>>>>>            Move 10                                      to aColumnType[i].iMinSize
92765>>>>>>>>            Move 19                                      to aColumnType[i].nMaxSize
92766>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92767>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92768>>>>>>>>            Move 19                                      to aColumnType[i].sPrecision
92769>>>>>>>>            Increment i
92770>>>>>>>>
92770>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
92771>>>>>>>>            Move -6                                      to aColumnType[i].iSQLType
92772>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
92773>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
92774>>>>>>>>            Move 3                                       to aColumnType[i].iDefaultSize
92775>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
92776>>>>>>>>            Move 3                                       to aColumnType[i].nMaxSize
92777>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92778>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92779>>>>>>>>            Move 3                                       to aColumnType[i].sPrecision
92780>>>>>>>>            Increment i
92781>>>>>>>>
92781>>>>>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
92782>>>>>>>>            Move -11                                     to aColumnType[i].iSQLType
92783>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
92784>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
92785>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
92786>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
92787>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
92788>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92789>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92790>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
92791>>>>>>>>            Increment i
92792>>>>>>>>
92792>>>>>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
92793>>>>>>>>            Move -3                                      to aColumnType[i].iSQLType
92794>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
92795>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
92796>>>>>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
92797>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
92798>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
92799>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92800>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92801>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
92802>>>>>>>>            Increment i
92803>>>>>>>>
92803>>>>>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
92804>>>>>>>>            Move -203                                    to aColumnType[i].iSQLType
92805>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
92806>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
92807>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
92808>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
92809>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
92810>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92811>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92812>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
92813>>>>>>>>            Increment i
92814>>>>>>>>
92814>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
92815>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
92816>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
92817>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
92818>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
92819>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
92820>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
92821>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92822>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92823>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
92824>>>>>>>>            Increment i
92825>>>>>>>>
92825>>>>>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
92826>>>>>>>>            Move -201                                    to aColumnType[i].iSQLType
92827>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
92828>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
92829>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
92830>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
92831>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
92832>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92833>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92834>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
92835>>>>>>>>            Increment i
92836>>>>>>>>
92836>>>>>>>>            Move "xml"                                   to aColumnType[i].sSQLType
92837>>>>>>>>            Move -152                                    to aColumnType[i].iSQLType
92838>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
92839>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
92840>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
92841>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
92842>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
92843>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92844>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92845>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
92846>>>>>>>>            Increment i
92847>>>>>>>>
92847>>>>>>>>
92847>>>>>>>//        Move SQL_DBCLOB         to ColumnType[i].iSQLType
92847>>>>>>>//        Move "DBCLOB"           to ColumnType[i].sSQLType
92847>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
92847>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
92847>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
92847>>>>>>>//        Increment i
92847>>>>>>>//
92847>>>>>>>//        Move SQL_BIGINT         to ColumnType[i].iSQLType
92847>>>>>>>//        Move "BIGINT"           to ColumnType[i].sSQLType
92847>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
92847>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
92847>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
92847>>>>>>>//        Increment i
92847>>>>>>>//
92847>>>>>>>//        Move SQL_BLOB           to ColumnType[i].iSQLType
92847>>>>>>>//        Move "BLOB"             to ColumnType[i].sSQLType
92847>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
92847>>>>>>>//        Move "BINARY"           to ColumnType[i].sDataFlexType
92847>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
92847>>>>>>>//        Increment i
92847>>>>>>>//
92847>>>>>>>//        Move SQL_CHAR           to ColumnType[i].iSQLType
92847>>>>>>>//        Move "CHAR"             to ColumnType[i].sSQLType
92847>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
92847>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
92847>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
92847>>>>>>>//        Increment i
92847>>>>>>>//
92847>>>>>>>//        // ToDo: We need to change the sType when using this!
92847>>>>>>>//        Move SQL_CHARBIT            to ColumnType[i].iSQLType
92847>>>>>>>//        Move "CHAR FOR BIT DATA"    to ColumnType[i].sSQLType
92847>>>>>>>//        Move DF_BINARY              to ColumnType[i].iDataFlexType
92847>>>>>>>//        Move "Binary"               to ColumnType[i].sDataFlexType
92847>>>>>>>//        Move "254"                  to ColumnType[i].sPrecision
92847>>>>>>>//        Increment i
92847>>>>>>>//
92847>>>>>>>//        Move SQL_DATE           to ColumnType[i].iSQLType
92847>>>>>>>//        Move "DATE"             to ColumnType[i].sSQLType
92847>>>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
92847>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
92847>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
92847>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
92847>>>>>>>//        Increment i
92847>>>>>>>//
92847>>>>>>>//        Move SQL_CLOB           to ColumnType[i].iSQLType
92847>>>>>>>//        Move "CLOB"             to ColumnType[i].sSQLType
92847>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
92847>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
92847>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
92847>>>>>>>//        Increment i
92847>>>>>>>//
92847>>>>>>>//        Move SQL_DECIMAL        to ColumnType[i].iSQLType
92847>>>>>>>//        Move "DECIMAL"          to ColumnType[i].sSQLType
92847>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
92847>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
92847>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
92847>>>>>>>//        Increment i
92847>>>>>>>//
92847>>>>>>>//        Move SQL_DOUBLE         to ColumnType[i].iSQLType
92847>>>>>>>//        Move "DOUBLE"           to ColumnType[i].sSQLType
92847>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
92847>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
92847>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
92847>>>>>>>//        Increment i
92847>>>>>>>//
92847>>>>>>>//        Move SQL_FLOAT          to ColumnType[i].iSQLType
92847>>>>>>>//        Move "FLOAT"            to ColumnType[i].sSQLType
92847>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
92847>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
92847>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
92847>>>>>>>//        Increment i
92847>>>>>>>//
92847>>>>>>>//        Move SQL_GRAPHIC        to ColumnType[i].iSQLType
92847>>>>>>>//        Move "GRAPHIC"          to ColumnType[i].sSQLType
92847>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
92847>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
92847>>>>>>>//        Move "255"              to ColumnType[i].sPrecision
92847>>>>>>>//        Increment i
92847>>>>>>>//
92847>>>>>>>//        Move SQL_INTEGER        to ColumnType[i].iSQLType
92847>>>>>>>//        Move "INTEGER"          to ColumnType[i].sSQLType
92847>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
92847>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
92847>>>>>>>//        Move "9.0"              to ColumnType[i].sPrecision
92847>>>>>>>//        Increment i
92847>>>>>>>//
92847>>>>>>>//        Move SQL_LONGVARCHAR    to ColumnType[i].iSQLType
92847>>>>>>>//        Move "LONG VARCHAR"     to ColumnType[i].sSQLType
92847>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
92847>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
92847>>>>>>>//        Move "32000"            to ColumnType[i].sPrecision
92847>>>>>>>//        Increment i
92847>>>>>>>//
92847>>>>>>>//        Move SQL_LONGVARCHARBIT to ColumnType[i].iSQLType
92847>>>>>>>//        Move "LONG VARCHAR BIT" to ColumnType[i].sSQLType
92847>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
92847>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
92847>>>>>>>//        Move "32000"            to ColumnType[i].sPrecision
92847>>>>>>>//        Increment i
92847>>>>>>>//
92847>>>>>>>//        Move SQL_LONGVARGRAPHIC to ColumnType[i].iSQLType
92847>>>>>>>//        Move "LONG VARGRAPHIC"  to ColumnType[i].sSQLType
92847>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
92847>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
92847>>>>>>>//        Move "32000"            to ColumnType[i].sPrecision
92847>>>>>>>//        Increment i
92847>>>>>>>//
92847>>>>>>>//        Move SQL_NUMERIC        to ColumnType[i].iSQLType
92847>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sSQLType
92847>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
92847>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
92847>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
92847>>>>>>>//        Increment i
92847>>>>>>>//
92847>>>>>>>//        Move SQL_REAL           to ColumnType[i].iSQLType
92847>>>>>>>//        Move "REAL"             to ColumnType[i].sSQLType
92847>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
92847>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
92847>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
92847>>>>>>>//        Increment i
92847>>>>>>>//
92847>>>>>>>//        Move SQL_SMALLINT       to ColumnType[i].iSQLType
92847>>>>>>>//        Move "SMALLINT"         to ColumnType[i].sSQLType
92847>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
92847>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
92847>>>>>>>//        Move "5.0"              to ColumnType[i].sPrecision
92847>>>>>>>//        Increment i
92847>>>>>>>//
92847>>>>>>>//        Move SQL_TIME           to ColumnType[i].iSQLType
92847>>>>>>>//        Move "TIME"             to ColumnType[i].sSQLType
92847>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
92847>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
92847>>>>>>>//        Move "19.0"             to ColumnType[i].sPrecision
92847>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
92847>>>>>>>//        Increment i
92847>>>>>>>//
92847>>>>>>>//        Move SQL_TIMESTAMP      to ColumnType[i].iSQLType
92847>>>>>>>//        Move "TIMESTAMP"        to ColumnType[i].sSQLType
92847>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
92847>>>>>>>//        Move "DATETIME"         to ColumnType[i].sDataFlexType
92847>>>>>>>//        Move "23.6"             to ColumnType[i].sPrecision
92847>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
92847>>>>>>>//        Increment i
92847>>>>>>>//
92847>>>>>>>//        Move SQL_VARCHAR        to ColumnType[i].iSQLType
92847>>>>>>>//        Move "VARCHAR"          to ColumnType[i].sSQLType
92847>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
92847>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
92847>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
92847>>>>>>>//        Increment i
92847>>>>>>>//
92847>>>>>>>//        // ToDo: We need to change the sType when using this!
92847>>>>>>>//        Move SQL_VARCHARBIT         to ColumnType[i].iSQLType
92847>>>>>>>//        Move "VARCHAR FOR BIT DATA" to ColumnType[i].sSQLType
92847>>>>>>>//        Move DF_TEXT                to ColumnType[i].iDataFlexType
92847>>>>>>>//        Move "TEXT"                 to ColumnType[i].sDataFlexType
92847>>>>>>>//        Move "16384"                to ColumnType[i].sPrecision
92847>>>>>>>//        Increment i
92847>>>>>>>//
92847>>>>>>>//        Move SQL_VARGRAPHIC     to ColumnType[i].iSQLType
92847>>>>>>>//        Move "VARGRAPHIC"       to ColumnType[i].sSQLType
92847>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
92847>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
92847>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
92847>>>>>>>//
92847>>>>>>>//        Move SQL_XML            to ColumnType[i].iSQLType
92847>>>>>>>//        Move "XML"              to ColumnType[i].sSQLType
92847>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
92847>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
92847>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
92847>>>>>>>
92847>>>>>>>        Function_Return aColumnType
92848>>>>>>>    End_Function
92849>>>>>>>
92849>>>>>>>    // Microsoft SQL Server Database Data Types:
92849>>>>>>>    // Helper function for UtilEnumerateColumnTypes
92849>>>>>>>    Function _UtilEnumerateMSSQLTypes String sDriverID Returns tColumnType[]
92851>>>>>>>        tColumnType[] aColumnType
92851>>>>>>>        tColumnType[] aColumnType
92852>>>>>>>        Integer i
92852>>>>>>>
92852>>>>>>>        If (sDriverID = MSSQLDRV_ID) Begin
Including file: MSSQLDRV_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\MSSQLDRV_DriverDef.inc)
92854>>>>>>>>// Generated By The Database Update Framework
92854>>>>>>>>// Driver XML File: C:\Program Files\DataFlex 20.0\Lib\MSSQLDRV_DriverDef.xml
92854>>>>>>>>// Driver COLUMN DATA TYPES
92854>>>>>>>>//
92854>>>>>>>>// Created: 2019-11-15 21:57:51.001
92854>>>>>>>>
92854>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
92855>>>>>>>>            Move -5                                      to aColumnType[i].iSQLType
92856>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
92857>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
92858>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
92859>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
92860>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
92861>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
92862>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
92863>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
92864>>>>>>>>            Increment i
92865>>>>>>>>
92865>>>>>>>>            Move "binary"                                to aColumnType[i].sSQLType
92866>>>>>>>>            Move -2                                      to aColumnType[i].iSQLType
92867>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
92868>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
92869>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
92870>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
92871>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
92872>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
92873>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
92874>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
92875>>>>>>>>            Increment i
92876>>>>>>>>
92876>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
92877>>>>>>>>            Move -7                                      to aColumnType[i].iSQLType
92878>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
92879>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
92880>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
92881>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
92882>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
92883>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92884>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92885>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
92886>>>>>>>>            Increment i
92887>>>>>>>>
92887>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
92888>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
92889>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
92890>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
92891>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
92892>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
92893>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
92894>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
92895>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
92896>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
92897>>>>>>>>            Increment i
92898>>>>>>>>
92898>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
92899>>>>>>>>            Move 91                                      to aColumnType[i].iSQLType
92900>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
92901>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
92902>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
92903>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
92904>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
92905>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
92906>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
92907>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
92908>>>>>>>>            Increment i
92909>>>>>>>>
92909>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
92910>>>>>>>>            Move 93                                      to aColumnType[i].iSQLType
92911>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
92912>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
92913>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
92914>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
92915>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
92916>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
92917>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
92918>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
92919>>>>>>>>            Increment i
92920>>>>>>>>
92920>>>>>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
92921>>>>>>>>            Move -200                                    to aColumnType[i].iSQLType
92922>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
92923>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
92924>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
92925>>>>>>>>            Move 23                                      to aColumnType[i].iMinSize
92926>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
92927>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
92928>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
92929>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
92930>>>>>>>>            Increment i
92931>>>>>>>>
92931>>>>>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
92932>>>>>>>>            Move -155                                    to aColumnType[i].iSQLType
92933>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
92934>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
92935>>>>>>>>            Move 34                                      to aColumnType[i].iDefaultSize
92936>>>>>>>>            Move 34                                      to aColumnType[i].iMinSize
92937>>>>>>>>            Move 34                                      to aColumnType[i].nMaxSize
92938>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
92939>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
92940>>>>>>>>            Move 34                                      to aColumnType[i].sPrecision
92941>>>>>>>>            Increment i
92942>>>>>>>>
92942>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
92943>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
92944>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
92945>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
92946>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
92947>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
92948>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
92949>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
92950>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
92951>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
92952>>>>>>>>            Increment i
92953>>>>>>>>
92953>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
92954>>>>>>>>            Move 6                                       to aColumnType[i].iSQLType
92955>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
92956>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
92957>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
92958>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
92959>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
92960>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
92961>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
92962>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
92963>>>>>>>>            Increment i
92964>>>>>>>>
92964>>>>>>>>            Move "image"                                 to aColumnType[i].sSQLType
92965>>>>>>>>            Move -4                                      to aColumnType[i].iSQLType
92966>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
92967>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
92968>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
92969>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
92970>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
92971>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
92972>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
92973>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
92974>>>>>>>>            Increment i
92975>>>>>>>>
92975>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
92976>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
92977>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
92978>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
92979>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
92980>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
92981>>>>>>>>            Move 10                                      to aColumnType[i].nMaxSize
92982>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
92983>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
92984>>>>>>>>            Move 10                                      to aColumnType[i].sPrecision
92985>>>>>>>>            Increment i
92986>>>>>>>>
92986>>>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
92987>>>>>>>>            Move -204                                    to aColumnType[i].iSQLType
92988>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
92989>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
92990>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
92991>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
92992>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
92993>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
92994>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
92995>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
92996>>>>>>>>            Increment i
92997>>>>>>>>
92997>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
92998>>>>>>>>            Move -8                                      to aColumnType[i].iSQLType
92999>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93000>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93001>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
93002>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93003>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
93004>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93005>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93006>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
93007>>>>>>>>            Increment i
93008>>>>>>>>
93008>>>>>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
93009>>>>>>>>            Move -10                                     to aColumnType[i].iSQLType
93010>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93011>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93012>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
93013>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93014>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
93015>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
93016>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
93017>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
93018>>>>>>>>            Increment i
93019>>>>>>>>
93019>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
93020>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
93021>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93022>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93023>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
93024>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93025>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
93026>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93027>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93028>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
93029>>>>>>>>            Increment i
93030>>>>>>>>
93030>>>>>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
93031>>>>>>>>            Move -9                                      to aColumnType[i].iSQLType
93032>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93033>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93034>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
93035>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93036>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
93037>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93038>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93039>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
93040>>>>>>>>            Increment i
93041>>>>>>>>
93041>>>>>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
93042>>>>>>>>            Move -202                                    to aColumnType[i].iSQLType
93043>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93044>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93045>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
93046>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93047>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
93048>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93049>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93050>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
93051>>>>>>>>            Increment i
93052>>>>>>>>
93052>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
93053>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
93054>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93055>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93056>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
93057>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93058>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
93059>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93060>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93061>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
93062>>>>>>>>            Increment i
93063>>>>>>>>
93063>>>>>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
93064>>>>>>>>            Move -206                                    to aColumnType[i].iSQLType
93065>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
93066>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93067>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
93068>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
93069>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
93070>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
93071>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
93072>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
93073>>>>>>>>            Increment i
93074>>>>>>>>
93074>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
93075>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
93076>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93077>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93078>>>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
93079>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93080>>>>>>>>            Move 5                                       to aColumnType[i].nMaxSize
93081>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93082>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93083>>>>>>>>            Move 5                                       to aColumnType[i].sPrecision
93084>>>>>>>>            Increment i
93085>>>>>>>>
93085>>>>>>>>            Move "smallmoney"                            to aColumnType[i].sSQLType
93086>>>>>>>>            Move -205                                    to aColumnType[i].iSQLType
93087>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
93088>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93089>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
93090>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
93091>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
93092>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93093>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93094>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
93095>>>>>>>>            Increment i
93096>>>>>>>>
93096>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
93097>>>>>>>>            Move -1                                      to aColumnType[i].iSQLType
93098>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93099>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93100>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
93101>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93102>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
93103>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
93104>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
93105>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
93106>>>>>>>>            Increment i
93107>>>>>>>>
93107>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
93108>>>>>>>>            Move -154                                    to aColumnType[i].iSQLType
93109>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93110>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93111>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
93112>>>>>>>>            Move 10                                      to aColumnType[i].iMinSize
93113>>>>>>>>            Move 19                                      to aColumnType[i].nMaxSize
93114>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93115>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93116>>>>>>>>            Move 19                                      to aColumnType[i].sPrecision
93117>>>>>>>>            Increment i
93118>>>>>>>>
93118>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
93119>>>>>>>>            Move -6                                      to aColumnType[i].iSQLType
93120>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93121>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93122>>>>>>>>            Move 3                                       to aColumnType[i].iDefaultSize
93123>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93124>>>>>>>>            Move 3                                       to aColumnType[i].nMaxSize
93125>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93126>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93127>>>>>>>>            Move 3                                       to aColumnType[i].sPrecision
93128>>>>>>>>            Increment i
93129>>>>>>>>
93129>>>>>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
93130>>>>>>>>            Move -11                                     to aColumnType[i].iSQLType
93131>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
93132>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93133>>>>>>>>            Move 0                                       to aColumnType[i].iDefaultSize
93134>>>>>>>>            Move 0                                       to aColumnType[i].iMinSize
93135>>>>>>>>            Move 0                                       to aColumnType[i].nMaxSize
93136>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93137>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93138>>>>>>>>            Move 1                                       to aColumnType[i].sPrecision
93139>>>>>>>>            Increment i
93140>>>>>>>>
93140>>>>>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
93141>>>>>>>>            Move -3                                      to aColumnType[i].iSQLType
93142>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93143>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93144>>>>>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
93145>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93146>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
93147>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
93148>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
93149>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
93150>>>>>>>>            Increment i
93151>>>>>>>>
93151>>>>>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
93152>>>>>>>>            Move -203                                    to aColumnType[i].iSQLType
93153>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93154>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93155>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
93156>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93157>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
93158>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93159>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93160>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
93161>>>>>>>>            Increment i
93162>>>>>>>>
93162>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
93163>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
93164>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93165>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93166>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
93167>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93168>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
93169>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93170>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93171>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
93172>>>>>>>>            Increment i
93173>>>>>>>>
93173>>>>>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
93174>>>>>>>>            Move -201                                    to aColumnType[i].iSQLType
93175>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93176>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93177>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
93178>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93179>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
93180>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
93181>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
93182>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
93183>>>>>>>>            Increment i
93184>>>>>>>>
93184>>>>>>>>            Move "xml"                                   to aColumnType[i].sSQLType
93185>>>>>>>>            Move -152                                    to aColumnType[i].iSQLType
93186>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93187>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93188>>>>>>>>            Move 16383                                   to aColumnType[i].iDefaultSize
93189>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93190>>>>>>>>            Move 2000000000                              to aColumnType[i].nMaxSize
93191>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
93192>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
93193>>>>>>>>            Move 2000000000                              to aColumnType[i].sPrecision
93194>>>>>>>>            Increment i
93195>>>>>>>>
93195>>>>>>>>
93195>>>>>>>
93195>>>>>>>//            Move SQL_BIGINT         to ColumnType[i].iSQLType
93195>>>>>>>//            Move "bigint"           to ColumnType[i].sSQLType
93195>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
93195>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
93195>>>>>>>//            Move "14.0"             to ColumnType[i].sPrecision
93195>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
93195>>>>>>>//            Increment i
93195>>>>>>>//
93195>>>>>>>//            Move SQL_BINARY         to ColumnType[i].iSQLType
93195>>>>>>>//            Move "binary"           to ColumnType[i].sSQLType
93195>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
93195>>>>>>>//            Move "Binary"           to ColumnType[i].sDataFlexType
93195>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
93195>>>>>>>//            Increment i
93195>>>>>>>//
93195>>>>>>>//            Move SQL_BIT            to ColumnType[i].iSQLType
93195>>>>>>>//            Move "bit"              to ColumnType[i].sSQLType
93195>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
93195>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
93195>>>>>>>//            Move "1.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
93195>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
93195>>>>>>>//            Increment i
93195>>>>>>>//
93195>>>>>>>//            Move SQL_CHAR           to ColumnType[i].iSQLType
93195>>>>>>>//            Move "char"             to ColumnType[i].sSQLType
93195>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
93195>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
93195>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
93195>>>>>>>//            Increment i
93195>>>>>>>//
93195>>>>>>>//            Move SQL_DATE           to ColumnType[i].iSQLType
93195>>>>>>>//            Move "date"             to ColumnType[i].sSQLType
93195>>>>>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
93195>>>>>>>//            Move "Date"             to ColumnType[i].sDataFlexType
93195>>>>>>>//            Move "6.0"              to ColumnType[i].sPrecision
93195>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
93195>>>>>>>//            Increment i
93195>>>>>>>//
93195>>>>>>>//            Move SQL_DATETIME       to ColumnType[i].iSQLType
93195>>>>>>>//            Move "datetime"         to ColumnType[i].sSQLType
93195>>>>>>>//            Move DF_DATETIME        to ColumnType[i].iDataFlexType
93195>>>>>>>//            Move "DateTime"         to ColumnType[i].sDataFlexType
93195>>>>>>>//            Move "23.3"             to ColumnType[i].sPrecision
93195>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
93195>>>>>>>//            Increment i
93195>>>>>>>//
93195>>>>>>>//            Move SQL_TYPE_TIMESTAMP2 to ColumnType[i].iSQLType
93195>>>>>>>//            Move "datetime2"         to ColumnType[i].sSQLType
93195>>>>>>>//            Move DF_DATETIME         to ColumnType[i].iDataFlexType
93195>>>>>>>//            Move "DateTime"          to ColumnType[i].sDataFlexType
93195>>>>>>>//            Move "23.6"              to ColumnType[i].sPrecision
93195>>>>>>>//            Move True                to ColumnType[i].bCanEditSize
93195>>>>>>>//            Increment i
93195>>>>>>>//
93195>>>>>>>//            Move SQL_SS_TIMESTAMPOFFSET to ColumnType[i].iSQLType
93195>>>>>>>//            Move "datetimeoffset"       to ColumnType[i].sSQLType
93195>>>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
93195>>>>>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
93195>>>>>>>//            Move "34.0"                 to ColumnType[i].sPrecision
93195>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
93195>>>>>>>//            Increment i
93195>>>>>>>//
93195>>>>>>>//            Move SQL_DECIMAL        to ColumnType[i].iSQLType
93195>>>>>>>//            Move "decimal"          to ColumnType[i].sSQLType
93195>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
93195>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
93195>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
93195>>>>>>>//            Increment i
93195>>>>>>>//
93195>>>>>>>//            Move SQL_FLOAT          to ColumnType[i].iSQLType
93195>>>>>>>//            Move "float"            to ColumnType[i].sSQLType
93195>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
93195>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
93195>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
93195>>>>>>>//            Increment i
93195>>>>>>>//
93195>>>>>>>//            Move SQL_INTEGER        to ColumnType[i].iSQLType
93195>>>>>>>//            Move "int"              to ColumnType[i].sSQLType
93195>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
93195>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
93195>>>>>>>//            Move "8.0"              to ColumnType[i].sPrecision
93195>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
93195>>>>>>>//            Increment i
93195>>>>>>>//
93195>>>>>>>//            Move SQL_TYPE_MONEY     to ColumnType[i].iSQLType
93195>>>>>>>//            Move "money"            to ColumnType[i].sSQLType
93195>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
93195>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
93195>>>>>>>//            Move "15.4"             to ColumnType[i].sPrecision // Studio 18.0 (!)
93195>>>>>>>//            Increment i
93195>>>>>>>//
93195>>>>>>>//            Move SQL_WCHAR          to ColumnType[i].iSQLType
93195>>>>>>>//            Move "nchar"            to ColumnType[i].sSQLType
93195>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
93195>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
93195>>>>>>>//            Move "4000"             to ColumnType[i].sPrecision
93195>>>>>>>//            Increment i
93195>>>>>>>//
93195>>>>>>>//            Move SQL_WLONGVARCHAR   to ColumnType[i].iSQLType
93195>>>>>>>//            Move "ntext"            to ColumnType[i].sSQLType
93195>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
93195>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
93195>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
93195>>>>>>>//            Increment i
93195>>>>>>>//
93195>>>>>>>//            Move SQL_NUMERIC        to ColumnType[i].iSQLType
93195>>>>>>>//            Move "numeric"          to ColumnType[i].sSQLType
93195>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
93195>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
93195>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
93195>>>>>>>//            Increment i
93195>>>>>>>//
93195>>>>>>>//            Move SQL_WVARCHAR       to ColumnType[i].iSQLType
93195>>>>>>>//            Move "nvarchar"         to ColumnType[i].sSQLType
93195>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
93195>>>>>>>//            Move "Text"             to ColumnType[i].sDataFlexType
93195>>>>>>>//            Move "4000"             to ColumnType[i].sPrecision
93195>>>>>>>//            Increment i
93195>>>>>>>//
93195>>>>>>>//            Move SQL_VARCHARMAX     to ColumnType[i].iSQLType
93195>>>>>>>//            Move "nvarchar(max)"    to ColumnType[i].sSQLType
93195>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
93195>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
93195>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
93195>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
93195>>>>>>>//            Increment i
93195>>>>>>>//
93195>>>>>>>//            Move SQL_REAL           to ColumnType[i].iSQLType
93195>>>>>>>//            Move "real"             to ColumnType[i].sSQLType
93195>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
93195>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
93195>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
93195>>>>>>>//            Increment i
93195>>>>>>>//
93195>>>>>>>//            Move SQL_TYPE_SMALLDATETIME to ColumnType[i].iSQLType
93195>>>>>>>//            Move "smalldatetime"        to ColumnType[i].sSQLType
93195>>>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
93195>>>>>>>//            Move "DATETIME"             to ColumnType[i].sDataFlexType
93195>>>>>>>//            Move "23.0"                 to ColumnType[i].sPrecision
93195>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
93195>>>>>>>//            Increment i
93195>>>>>>>//
93195>>>>>>>//            Move SQL_SMALLINT       to ColumnType[i].iSQLType
93195>>>>>>>//            Move "smallint"         to ColumnType[i].sSQLType
93195>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
93195>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
93195>>>>>>>//            Move "4.0"              to ColumnType[i].sPrecision
93195>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
93195>>>>>>>//            Increment i
93195>>>>>>>//
93195>>>>>>>//            Move SQL_TYPE_SMALLMONEY to ColumnType[i].iSQLType
93195>>>>>>>//            Move "smallmoney"        to ColumnType[i].sSQLType
93195>>>>>>>//            Move DF_BCD              to ColumnType[i].iDataFlexType
93195>>>>>>>//            Move "NUMERIC"           to ColumnType[i].sDataFlexType
93195>>>>>>>//            Move "10.0"              to ColumnType[i].sPrecision
93195>>>>>>>//            Increment i
93195>>>>>>>//
93195>>>>>>>//            Move SQL_TEXT           to ColumnType[i].iSQLType
93195>>>>>>>//            Move "text"             to ColumnType[i].sSQLType
93195>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
93195>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
93195>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
93195>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
93195>>>>>>>//            Increment i
93195>>>>>>>//
93195>>>>>>>//            Move SQL_TIME           to ColumnType[i].iSQLType
93195>>>>>>>//            Move "time"             to ColumnType[i].sSQLType
93195>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
93195>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
93195>>>>>>>//            Move "19.0"             to ColumnType[i].sPrecision
93195>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
93195>>>>>>>//            Increment i
93195>>>>>>>//
93195>>>>>>>//            Move SQL_TINYINT        to ColumnType[i].iSQLType
93195>>>>>>>//            Move "tinyint"          to ColumnType[i].sSQLType
93195>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
93195>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
93195>>>>>>>//            Move "2.0"              to ColumnType[i].sPrecision
93195>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
93195>>>>>>>//            Increment i
93195>>>>>>>//
93195>>>>>>>//            Move SQL_GUID           to ColumnType[i].iSQLType
93195>>>>>>>//            Move "uniqueidentifier" to ColumnType[i].sSQLType
93195>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
93195>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
93195>>>>>>>//            Move "36"               to ColumnType[i].sPrecision
93195>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
93195>>>>>>>//            Increment i
93195>>>>>>>//
93195>>>>>>>//            Move SQL_VARBINARY      to ColumnType[i].iSQLType
93195>>>>>>>//            Move "varbinary"        to ColumnType[i].sSQLType
93195>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
93195>>>>>>>//            Move "BINARY"           to ColumnType[i].sDataFlexType
93195>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
93195>>>>>>>//            Increment i
93195>>>>>>>//
93195>>>>>>>//            Move SQL_LONGVARBINARY  to ColumnType[i].iSQLType
93195>>>>>>>//            Move "varbinary(max)"   to ColumnType[i].sSQLType
93195>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
93195>>>>>>>//            Move "BINARY"           to ColumnType[i].sDataFlexType
93195>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
93195>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
93195>>>>>>>//            Increment i
93195>>>>>>>//
93195>>>>>>>//            Move SQL_VARCHAR        to ColumnType[i].iSQLType
93195>>>>>>>//            Move "varchar"          to ColumnType[i].sSQLType
93195>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType // ToDo: Under 255 = ASCII type! How to deal with this?
93195>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
93195>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
93195>>>>>>>//            Increment i
93195>>>>>>>//
93195>>>>>>>//            Move SQL_LONGVARCHAR    to ColumnType[i].iSQLType
93195>>>>>>>//            Move "varchar(max)"     to ColumnType[i].sSQLType
93195>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
93195>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
93195>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
93195>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
93195>>>>>>>//            Increment i
93195>>>>>>>//
93195>>>>>>>//            Move SQL_SS_XML         to ColumnType[i].iSQLType
93195>>>>>>>//            Move "xml"              to ColumnType[i].sSQLType
93195>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
93195>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
93195>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
93195>>>>>>>//            Increment i
93195>>>>>>>//
93195>>>>>>>//            Move SQL_TYPE_DATE      to ColumnType[i].iSQLType
93195>>>>>>>//            Move "DATE"             to ColumnType[i].sSQLType
93195>>>>>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
93195>>>>>>>//            Move "date"             to ColumnType[i].sDataFlexType
93195>>>>>>>//            Move "6.0"              to ColumnType[i].sPrecision
93195>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
93195>>>>>>>//            Increment i
93195>>>>>>>//
93195>>>>>>>//            Move SQL_TYPE_TIME      to ColumnType[i].iSQLType
93195>>>>>>>//            Move "time"             to ColumnType[i].sSQLType
93195>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
93195>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
93195>>>>>>>//            Move "8.7"              to ColumnType[i].sPrecision
93195>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
93195>>>>>>>//            Increment i
93195>>>>>>>//
93195>>>>>>>//            Move SQL_TYPE_TIMESTAMP to ColumnType[i].iSQLType
93195>>>>>>>//            Move "datetime"         to ColumnType[i].sSQLType
93195>>>>>>>//            Move DF_DATETIME        to ColumnType[i].iDataFlexType
93195>>>>>>>//            Move "DateTime"         to ColumnType[i].sDataFlexType
93195>>>>>>>//            Move "23.6"             to ColumnType[i].sPrecision
93195>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
93195>>>>>>>//            Increment i
93195>>>>>>>
93195>>>>>>>        End
93195>>>>>>>>
93195>>>>>>>
93195>>>>>>>        // Mertech SQLFlex driver
93195>>>>>>>        If (sDriverID = SQLFLEX) Begin
93197>>>>>>>
Including file: sql_drv_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\sql_drv_DriverDef.inc)
93197>>>>>>>>// Generated By The Database Update Framework
93197>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\sql_drv_DriverDef.xml
93197>>>>>>>>// Driver COLUMN DATA TYPES
93197>>>>>>>>//
93197>>>>>>>>// Created: 2018-03-14 23:47:46.885
93197>>>>>>>>
93197>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
93198>>>>>>>>            Move -5                                      to aColumnType[i].iSQLType
93199>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93200>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93201>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
93202>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93203>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
93204>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93205>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93206>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
93207>>>>>>>>            Increment i
93208>>>>>>>>
93208>>>>>>>>            Move "binary"                                to aColumnType[i].sSQLType
93209>>>>>>>>            Move -2                                      to aColumnType[i].iSQLType
93210>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93211>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93212>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
93213>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93214>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
93215>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
93216>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
93217>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
93218>>>>>>>>            Increment i
93219>>>>>>>>
93219>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
93220>>>>>>>>            Move -7                                      to aColumnType[i].iSQLType
93221>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
93222>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93223>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
93224>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
93225>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
93226>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93227>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93228>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
93229>>>>>>>>            Increment i
93230>>>>>>>>
93230>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
93231>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
93232>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93233>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93234>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
93235>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93236>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
93237>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93238>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93239>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
93240>>>>>>>>            Increment i
93241>>>>>>>>
93241>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
93242>>>>>>>>            Move 40                                      to aColumnType[i].iSQLType
93243>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
93244>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93245>>>>>>>>            Move 12                                      to aColumnType[i].iDefaultSize
93246>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
93247>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
93248>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93249>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93250>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
93251>>>>>>>>            Increment i
93252>>>>>>>>
93252>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
93253>>>>>>>>            Move 11                                      to aColumnType[i].iSQLType
93254>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93255>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93256>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
93257>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
93258>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
93259>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93260>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93261>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
93262>>>>>>>>            Increment i
93263>>>>>>>>
93263>>>>>>>>            Move "datetime2"                             to aColumnType[i].sSQLType
93264>>>>>>>>            Move 42                                      to aColumnType[i].iSQLType
93265>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93266>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93267>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
93268>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
93269>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
93270>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93271>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93272>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
93273>>>>>>>>            Increment i
93274>>>>>>>>
93274>>>>>>>>            Move "datetimeoffset"                        to aColumnType[i].sSQLType
93275>>>>>>>>            Move 43                                      to aColumnType[i].iSQLType
93276>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93277>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93278>>>>>>>>            Move 12                                      to aColumnType[i].iDefaultSize
93279>>>>>>>>            Move 12                                      to aColumnType[i].iMinSize
93280>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
93281>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93282>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93283>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
93284>>>>>>>>            Increment i
93285>>>>>>>>
93285>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
93286>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
93287>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93288>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93289>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
93290>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93291>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
93292>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93293>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93294>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
93295>>>>>>>>            Increment i
93296>>>>>>>>
93296>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
93297>>>>>>>>            Move 6                                       to aColumnType[i].iSQLType
93298>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93299>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93300>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
93301>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93302>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
93303>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93304>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93305>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
93306>>>>>>>>            Increment i
93307>>>>>>>>
93307>>>>>>>>            Move "geography"                             to aColumnType[i].sSQLType
93308>>>>>>>>            Move 130                                     to aColumnType[i].iSQLType
93309>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
93310>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93311>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93312>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
93313>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
93314>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93315>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93316>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
93317>>>>>>>>            Increment i
93318>>>>>>>>
93318>>>>>>>>            Move "geometry"                              to aColumnType[i].sSQLType
93319>>>>>>>>            Move 129                                     to aColumnType[i].iSQLType
93320>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
93321>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93322>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93323>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
93324>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
93325>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93326>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93327>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
93328>>>>>>>>            Increment i
93329>>>>>>>>
93329>>>>>>>>            Move "hierarchyid"                           to aColumnType[i].sSQLType
93330>>>>>>>>            Move 128                                     to aColumnType[i].iSQLType
93331>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
93332>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93333>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93334>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
93335>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
93336>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93337>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93338>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
93339>>>>>>>>            Increment i
93340>>>>>>>>
93340>>>>>>>>            Move "image"                                 to aColumnType[i].sSQLType
93341>>>>>>>>            Move -4                                      to aColumnType[i].iSQLType
93342>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93343>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93344>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93345>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93346>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
93347>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
93348>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
93349>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
93350>>>>>>>>            Increment i
93351>>>>>>>>
93351>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
93352>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
93353>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93354>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93355>>>>>>>>            Move 11                                      to aColumnType[i].iDefaultSize
93356>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93357>>>>>>>>            Move 11                                      to aColumnType[i].nMaxSize
93358>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93359>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93360>>>>>>>>            Move 11                                      to aColumnType[i].sPrecision
93361>>>>>>>>            Increment i
93362>>>>>>>>
93362>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
93363>>>>>>>>            Move -8                                      to aColumnType[i].iSQLType
93364>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93365>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93366>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
93367>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93368>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
93369>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93370>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93371>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
93372>>>>>>>>            Increment i
93373>>>>>>>>
93373>>>>>>>>            Move "ntext"                                 to aColumnType[i].sSQLType
93374>>>>>>>>            Move -10                                     to aColumnType[i].iSQLType
93375>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93376>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93377>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93378>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93379>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
93380>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
93381>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
93382>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
93383>>>>>>>>            Increment i
93384>>>>>>>>
93384>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
93385>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
93386>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93387>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93388>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
93389>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93390>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
93391>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93392>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93393>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
93394>>>>>>>>            Increment i
93395>>>>>>>>
93395>>>>>>>>            Move "nvarchar"                              to aColumnType[i].sSQLType
93396>>>>>>>>            Move -9                                      to aColumnType[i].iSQLType
93397>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93398>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93399>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
93400>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93401>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
93402>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93403>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93404>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
93405>>>>>>>>            Increment i
93406>>>>>>>>
93406>>>>>>>>            Move "nvarchar(max)"                         to aColumnType[i].sSQLType
93407>>>>>>>>            Move -100                                    to aColumnType[i].iSQLType
93408>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93409>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93410>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93411>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93412>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
93413>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93414>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93415>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
93416>>>>>>>>            Increment i
93417>>>>>>>>
93417>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
93418>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
93419>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93420>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93421>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
93422>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93423>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
93424>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93425>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93426>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
93427>>>>>>>>            Increment i
93428>>>>>>>>
93428>>>>>>>>            Move "smalldatetime"                         to aColumnType[i].sSQLType
93429>>>>>>>>            Move 58                                      to aColumnType[i].iSQLType
93430>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93431>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93432>>>>>>>>            Move 12                                      to aColumnType[i].iDefaultSize
93433>>>>>>>>            Move 12                                      to aColumnType[i].iMinSize
93434>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
93435>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93436>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93437>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
93438>>>>>>>>            Increment i
93439>>>>>>>>
93439>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
93440>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
93441>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93442>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93443>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
93444>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
93445>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
93446>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93447>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93448>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
93449>>>>>>>>            Increment i
93450>>>>>>>>
93450>>>>>>>>            Move "sql_variant"                           to aColumnType[i].sSQLType
93451>>>>>>>>            Move -150                                    to aColumnType[i].iSQLType
93452>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
93453>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93454>>>>>>>>            Move 8016                                    to aColumnType[i].iDefaultSize
93455>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
93456>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
93457>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93458>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93459>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
93460>>>>>>>>            Increment i
93461>>>>>>>>
93461>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
93462>>>>>>>>            Move -1                                      to aColumnType[i].iSQLType
93463>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93464>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93465>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93466>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93467>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
93468>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
93469>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
93470>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
93471>>>>>>>>            Increment i
93472>>>>>>>>
93472>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
93473>>>>>>>>            Move 41                                      to aColumnType[i].iSQLType
93474>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93475>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93476>>>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
93477>>>>>>>>            Move 8                                       to aColumnType[i].iMinSize
93478>>>>>>>>            Move 16                                      to aColumnType[i].nMaxSize
93479>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93480>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93481>>>>>>>>            Move 16                                      to aColumnType[i].sPrecision
93482>>>>>>>>            Increment i
93483>>>>>>>>
93483>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
93484>>>>>>>>            Move 93                                      to aColumnType[i].iSQLType
93485>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
93486>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93487>>>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
93488>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
93489>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
93490>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
93491>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
93492>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
93493>>>>>>>>            Increment i
93494>>>>>>>>
93494>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
93495>>>>>>>>            Move -6                                      to aColumnType[i].iSQLType
93496>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93497>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93498>>>>>>>>            Move 3                                       to aColumnType[i].iDefaultSize
93499>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
93500>>>>>>>>            Move 3                                       to aColumnType[i].nMaxSize
93501>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93502>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93503>>>>>>>>            Move 3                                       to aColumnType[i].sPrecision
93504>>>>>>>>            Increment i
93505>>>>>>>>
93505>>>>>>>>            Move "uniqueidentifier"                      to aColumnType[i].sSQLType
93506>>>>>>>>            Move -11                                     to aColumnType[i].iSQLType
93507>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
93508>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93509>>>>>>>>            Move 38                                      to aColumnType[i].iDefaultSize
93510>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
93511>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
93512>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93513>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93514>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
93515>>>>>>>>            Increment i
93516>>>>>>>>
93516>>>>>>>>            Move "varbinary"                             to aColumnType[i].sSQLType
93517>>>>>>>>            Move -3                                      to aColumnType[i].iSQLType
93518>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93519>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93520>>>>>>>>            Move 8000                                    to aColumnType[i].iDefaultSize
93521>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93522>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
93523>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
93524>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
93525>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
93526>>>>>>>>            Increment i
93527>>>>>>>>
93527>>>>>>>>            Move "varbinary(max)"                        to aColumnType[i].sSQLType
93528>>>>>>>>            Move -98                                     to aColumnType[i].iSQLType
93529>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93530>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93531>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93532>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93533>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
93534>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93535>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93536>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
93537>>>>>>>>            Increment i
93538>>>>>>>>
93538>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
93539>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
93540>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93541>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93542>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
93543>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93544>>>>>>>>            Move 8000                                    to aColumnType[i].nMaxSize
93545>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93546>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93547>>>>>>>>            Move 8000                                    to aColumnType[i].sPrecision
93548>>>>>>>>            Increment i
93549>>>>>>>>
93549>>>>>>>>            Move "varchar(max)"                          to aColumnType[i].sSQLType
93550>>>>>>>>            Move -99                                     to aColumnType[i].iSQLType
93551>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93552>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93553>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93554>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93555>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
93556>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93557>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93558>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
93559>>>>>>>>            Increment i
93560>>>>>>>>
93560>>>>>>>>            Move "xml"                                   to aColumnType[i].sSQLType
93561>>>>>>>>            Move -370                                    to aColumnType[i].iSQLType
93562>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93563>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93564>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93565>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93566>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
93567>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93568>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93569>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
93570>>>>>>>>            Increment i
93571>>>>>>>>
93571>>>>>>>>
93571>>>>>>>
93571>>>>>>>//            Move eSQLServer_BIGINT  to ColumnType[i].iSQLType
93571>>>>>>>//            Move "BigInt"           to ColumnType[i].sSQLType
93571>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
93571>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
93571>>>>>>>//            Move "14.0"             to ColumnType[i].sPrecision
93571>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
93571>>>>>>>//            Increment i
93571>>>>>>>//
93571>>>>>>>//            Move eSQLServer_BINARY  to ColumnType[i].iSQLType
93571>>>>>>>//            Move "Binary"           to ColumnType[i].sSQLType
93571>>>>>>>//            Move DF_BINARY          to ColumnType[i].iDataFlexType
93571>>>>>>>//            Move "Binary"           to ColumnType[i].sDataFlexType
93571>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
93571>>>>>>>//            Increment i
93571>>>>>>>//
93571>>>>>>>//            Move eSQLServer_BIT     to ColumnType[i].iSQLType
93571>>>>>>>//            Move "Bit"              to ColumnType[i].sSQLType
93571>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
93571>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
93571>>>>>>>//            Move "1.0"              to ColumnType[i].sPrecision
93571>>>>>>>//            Move True               to ColumnType[i].bCanEditSize // In SQL allows 1, 0, or "NULL"
93571>>>>>>>//            Increment i
93571>>>>>>>//
93571>>>>>>>//            Move eSQLServer_CHAR    to ColumnType[i].iSQLType
93571>>>>>>>//            Move "Char"             to ColumnType[i].sSQLType
93571>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
93571>>>>>>>//            Move "Text"             to ColumnType[i].sDataFlexType
93571>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
93571>>>>>>>//            Increment i
93571>>>>>>>//
93571>>>>>>>//            Move eSQLServer_DATE    to ColumnType[i].iSQLType
93571>>>>>>>//            Move "Date"             to ColumnType[i].sSQLType
93571>>>>>>>//            Move DF_DATE            to ColumnType[i].iDataFlexType
93571>>>>>>>//            Move "Date"             to ColumnType[i].sDataFlexType
93571>>>>>>>//            Move "6.0"              to ColumnType[i].sPrecision
93571>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
93571>>>>>>>//            Increment i
93571>>>>>>>//
93571>>>>>>>//            Move eSQLServer_DATETIME    to ColumnType[i].iSQLType
93571>>>>>>>//            Move "DateTime"             to ColumnType[i].sSQLType
93571>>>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
93571>>>>>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
93571>>>>>>>//            Move "23.3"                 to ColumnType[i].sPrecision
93571>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
93571>>>>>>>//            Increment i
93571>>>>>>>//
93571>>>>>>>//            Move eSQLServer_DATETIME2   to ColumnType[i].iSQLType
93571>>>>>>>//            Move "DateTime2"            to ColumnType[i].sSQLType
93571>>>>>>>//            Move DF_DATETIME            to ColumnType[i].iDataFlexType
93571>>>>>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
93571>>>>>>>//            Move "23.6"                 to ColumnType[i].sPrecision
93571>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
93571>>>>>>>//            Increment i
93571>>>>>>>//
93571>>>>>>>//            Move eSQLServer_DATETIMEOFFSET  to ColumnType[i].iSQLType
93571>>>>>>>//            Move "DateTimeOffest"           to ColumnType[i].sSQLType
93571>>>>>>>//            Move DF_DATETIME                to ColumnType[i].iDataFlexType
93571>>>>>>>//            Move "DateTime"                 to ColumnType[i].sDataFlexType
93571>>>>>>>//            Move "23.0"                     to ColumnType[i].sPrecision
93571>>>>>>>//            Move True                       to ColumnType[i].bCanEditSize
93571>>>>>>>//            Increment i
93571>>>>>>>//
93571>>>>>>>//            Move eSQLServer_DECIMAL to ColumnType[i].iSQLType
93571>>>>>>>//            Move "Decimal"          to ColumnType[i].sSQLType
93571>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
93571>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
93571>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
93571>>>>>>>//            Increment i
93571>>>>>>>//
93571>>>>>>>//            Move eSQLServer_DOUBLE  to ColumnType[i].iSQLType
93571>>>>>>>//            Move "Double"           to ColumnType[i].sSQLType
93571>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
93571>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
93571>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
93571>>>>>>>//            Increment i
93571>>>>>>>//
93571>>>>>>>//            Move eSQLServer_FLOAT   to ColumnType[i].iSQLType
93571>>>>>>>//            Move "Float"            to ColumnType[i].sSQLType
93571>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
93571>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
93571>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
93571>>>>>>>//            Increment i
93571>>>>>>>//
93571>>>>>>>//            Move eSQLServer_INT     to ColumnType[i].iSQLType
93571>>>>>>>//            Move "Int"              to ColumnType[i].sSQLType
93571>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
93571>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
93571>>>>>>>//            Move "11.0"             to ColumnType[i].sPrecision
93571>>>>>>>//            Increment i
93571>>>>>>>//
93571>>>>>>>//            Move eSQLServer_NCHAR   to ColumnType[i].iSQLType
93571>>>>>>>//            Move "Nchar"            to ColumnType[i].sSQLType
93571>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
93571>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
93571>>>>>>>//            Move "4000"             to ColumnType[i].sPrecision
93571>>>>>>>//            Increment i
93571>>>>>>>//
93571>>>>>>>//            Move eSQLServer_NTEXT   to ColumnType[i].iSQLType
93571>>>>>>>//            Move "Ntext"            to ColumnType[i].sSQLType
93571>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
93571>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
93571>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
93571>>>>>>>//            Increment i
93571>>>>>>>//
93571>>>>>>>//            Move eSQLServer_NUMERIC to ColumnType[i].iSQLType
93571>>>>>>>//            Move "Numeric"          to ColumnType[i].sSQLType
93571>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
93571>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
93571>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
93571>>>>>>>//            Increment i
93571>>>>>>>//
93571>>>>>>>//            Move eSQLServer_NVARCHAR    to ColumnType[i].iSQLType
93571>>>>>>>//            Move "NvarChar"             to ColumnType[i].sSQLType
93571>>>>>>>//            Move DF_TEXT                to ColumnType[i].iDataFlexType
93571>>>>>>>//            Move "Text"                 to ColumnType[i].sDataFlexType
93571>>>>>>>//            Move "4000"                 to ColumnType[i].sPrecision
93571>>>>>>>//            Increment i
93571>>>>>>>//
93571>>>>>>>//            Move eSQLServer_NVARCHARMAX to ColumnType[i].iSQLType
93571>>>>>>>//            Move "NvarCharMax"          to ColumnType[i].sSQLType
93571>>>>>>>//            Move DF_TEXT                to ColumnType[i].iDataFlexType
93571>>>>>>>//            Move "Text"                 to ColumnType[i].sDataFlexType
93571>>>>>>>//            Move "16384"                to ColumnType[i].sPrecision
93571>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
93571>>>>>>>//            Increment i
93571>>>>>>>//
93571>>>>>>>//            Move eSQLServer_REAL    to ColumnType[i].iSQLType
93571>>>>>>>//            Move "Real"             to ColumnType[i].sSQLType
93571>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
93571>>>>>>>//            Move "NUMERIC"          to ColumnType[i].sDataFlexType
93571>>>>>>>//            Move "14.8"             to ColumnType[i].sPrecision
93571>>>>>>>//            Increment i
93571>>>>>>>//
93571>>>>>>>//            Move eSQLServer_SMALLDATETIME   to ColumnType[i].iSQLType
93571>>>>>>>//            Move "SmallDateTime"            to ColumnType[i].sSQLType
93571>>>>>>>//            Move DF_DATETIME                to ColumnType[i].iDataFlexType
93571>>>>>>>//            Move "DATETIME"                 to ColumnType[i].sDataFlexType
93571>>>>>>>//            Move "23.0"                     to ColumnType[i].sPrecision
93571>>>>>>>//            Move True                       to ColumnType[i].bCanEditSize
93571>>>>>>>//            Increment i
93571>>>>>>>//
93571>>>>>>>//            Move eSQLServer_SMALLINT    to ColumnType[i].iSQLType
93571>>>>>>>//            Move "SmallInt"             to ColumnType[i].sSQLType
93571>>>>>>>//            Move DF_BCD                 to ColumnType[i].iDataFlexType
93571>>>>>>>//            Move "NUMERIC"              to ColumnType[i].sDataFlexType
93571>>>>>>>//            Move "6.0"                  to ColumnType[i].sPrecision
93571>>>>>>>//            Increment i
93571>>>>>>>//
93571>>>>>>>//            Move eSQLServer_TEXT    to ColumnType[i].iSQLType
93571>>>>>>>//            Move "Text"             to ColumnType[i].sSQLType
93571>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
93571>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
93571>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
93571>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
93571>>>>>>>//            Increment i
93571>>>>>>>//
93571>>>>>>>//            Move eSQLServer_TIME    to ColumnType[i].iSQLType
93571>>>>>>>//            Move "Time"             to ColumnType[i].sSQLType
93571>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
93571>>>>>>>//            Move "Date"             to ColumnType[i].sDataFlexType
93571>>>>>>>//            Move "16.0"             to ColumnType[i].sPrecision
93571>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
93571>>>>>>>//            Increment i
93571>>>>>>>//
93571>>>>>>>//            Move eSQLServer_TIMESTAMP   to ColumnType[i].iSQLType
93571>>>>>>>//            Move "TimeStamp"            to ColumnType[i].sSQLType
93571>>>>>>>//            Move DF_ASCII               to ColumnType[i].iDataFlexType
93571>>>>>>>//            Move "DateTime"             to ColumnType[i].sDataFlexType
93571>>>>>>>//            Move "8.0"                  to ColumnType[i].sPrecision
93571>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
93571>>>>>>>//            Increment i
93571>>>>>>>//
93571>>>>>>>//            Move eSQLServer_TINYINT to ColumnType[i].iSQLType
93571>>>>>>>//            Move "TinyInt"          to ColumnType[i].sSQLType
93571>>>>>>>//            Move DF_BCD             to ColumnType[i].iDataFlexType
93571>>>>>>>//            Move "Numeric"          to ColumnType[i].sDataFlexType
93571>>>>>>>//            Move "3.0"              to ColumnType[i].sPrecision
93571>>>>>>>//            Increment i
93571>>>>>>>//
93571>>>>>>>//            Move eSQLServer_GUID    to ColumnType[i].iSQLType
93571>>>>>>>//            Move "UniqueIdentifier" to ColumnType[i].sSQLType
93571>>>>>>>//            Move DF_ASCII           to ColumnType[i].iDataFlexType
93571>>>>>>>//            Move "ASCII"            to ColumnType[i].sDataFlexType
93571>>>>>>>//            Move "38"               to ColumnType[i].sPrecision
93571>>>>>>>//            Move True               to ColumnType[i].bCanEditSize
93571>>>>>>>//            Increment i
93571>>>>>>>//
93571>>>>>>>//            Move eSQLServer_VARBINARY   to ColumnType[i].iSQLType
93571>>>>>>>//            Move "VarBinary"            to ColumnType[i].sSQLType
93571>>>>>>>//            Move DF_BINARY              to ColumnType[i].iDataFlexType
93571>>>>>>>//            Move "BINARY"               to ColumnType[i].sDataFlexType
93571>>>>>>>//            Move "8000"                 to ColumnType[i].sPrecision
93571>>>>>>>//            Increment i
93571>>>>>>>//
93571>>>>>>>//            Move eSQLServer_VARBINARYMAX to ColumnType[i].iSQLType
93571>>>>>>>//            Move "VarBinary(Max)"        to ColumnType[i].sSQLType
93571>>>>>>>//            Move DF_BINARY               to ColumnType[i].iDataFlexType
93571>>>>>>>//            Move "BINARY"                to ColumnType[i].sDataFlexType
93571>>>>>>>//            Move "16384"                 to ColumnType[i].sPrecision
93571>>>>>>>//            Move True                    to ColumnType[i].bCanEditSize
93571>>>>>>>//            Increment i
93571>>>>>>>//
93571>>>>>>>//            Move eSQLServer_VARCHAR to ColumnType[i].iSQLType
93571>>>>>>>//            Move "VarChar"          to ColumnType[i].sSQLType
93571>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType // ToDo: Under 255 = ASCII type! How to deal with this?
93571>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
93571>>>>>>>//            Move "8000"             to ColumnType[i].sPrecision
93571>>>>>>>//            Increment i
93571>>>>>>>//
93571>>>>>>>//            Move eSQLServer_VARCHARMAX  to ColumnType[i].iSQLType
93571>>>>>>>//            Move "VarChar(Max)"         to ColumnType[i].sSQLType
93571>>>>>>>//            Move DF_TEXT                to ColumnType[i].iDataFlexType
93571>>>>>>>//            Move "TEXT"                 to ColumnType[i].sDataFlexType
93571>>>>>>>//            Move "16384"                to ColumnType[i].sPrecision
93571>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
93571>>>>>>>//            Increment i
93571>>>>>>>//
93571>>>>>>>//            Move eSQLServer_SQLVARIANT  to ColumnType[i].iSQLType
93571>>>>>>>//            Move "SQL_Variant"          to ColumnType[i].sSQLType
93571>>>>>>>//            Move DF_BINARY              to ColumnType[i].iDataFlexType
93571>>>>>>>//            Move "Binary"               to ColumnType[i].sDataFlexType
93571>>>>>>>//            Move "8016"                 to ColumnType[i].sPrecision
93571>>>>>>>//            Move True                   to ColumnType[i].bCanEditSize
93571>>>>>>>//            Increment i
93571>>>>>>>//
93571>>>>>>>//            Move eSQLServer_XML     to ColumnType[i].iSQLType
93571>>>>>>>//            Move "XML"              to ColumnType[i].sSQLType
93571>>>>>>>//            Move DF_TEXT            to ColumnType[i].iDataFlexType
93571>>>>>>>//            Move "TEXT"             to ColumnType[i].sDataFlexType
93571>>>>>>>//            Move "16384"            to ColumnType[i].sPrecision
93571>>>>>>>        End
93571>>>>>>>>
93571>>>>>>>
93571>>>>>>>        Function_Return aColumnType
93572>>>>>>>    End_Function
93573>>>>>>>
93573>>>>>>>    // MySQL Data Types
93573>>>>>>>    Function _UtilEnumerateMySQLTypes Returns tColumnType[]
93575>>>>>>>        tColumnType[] aColumnType
93575>>>>>>>        tColumnType[] aColumnType
93576>>>>>>>        Integer i
93576>>>>>>>
Including file: mdsmysql_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\mdsmysql_DriverDef.inc)
93576>>>>>>>>// Generated By The Database Update Framework
93576>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\mdsmysql_DriverDef.xml
93576>>>>>>>>// Driver COLUMN DATA TYPES
93576>>>>>>>>//
93576>>>>>>>>// Created: 2018-03-14 23:46:49.593
93576>>>>>>>>
93576>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
93577>>>>>>>>            Move 8                                       to aColumnType[i].iSQLType
93578>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93579>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93580>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
93581>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93582>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
93583>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93584>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93585>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
93586>>>>>>>>            Increment i
93587>>>>>>>>
93587>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
93588>>>>>>>>            Move 16                                      to aColumnType[i].iSQLType
93589>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93590>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93591>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
93592>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
93593>>>>>>>>            Move 64                                      to aColumnType[i].nMaxSize
93594>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93595>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93596>>>>>>>>            Move 64                                      to aColumnType[i].sPrecision
93597>>>>>>>>            Increment i
93598>>>>>>>>
93598>>>>>>>>            Move "blob"                                  to aColumnType[i].sSQLType
93599>>>>>>>>            Move 252                                     to aColumnType[i].iSQLType
93600>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93601>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93602>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93603>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93604>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
93605>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
93606>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
93607>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
93608>>>>>>>>            Increment i
93609>>>>>>>>
93609>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
93610>>>>>>>>            Move 254                                     to aColumnType[i].iSQLType
93611>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93612>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93613>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
93614>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93615>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
93616>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93617>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93618>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
93619>>>>>>>>            Increment i
93620>>>>>>>>
93620>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
93621>>>>>>>>            Move 10                                      to aColumnType[i].iSQLType
93622>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
93623>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93624>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
93625>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
93626>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
93627>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
93628>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
93629>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
93630>>>>>>>>            Increment i
93631>>>>>>>>
93631>>>>>>>>            Move "datetime"                              to aColumnType[i].sSQLType
93632>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
93633>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93634>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93635>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
93636>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
93637>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
93638>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
93639>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
93640>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
93641>>>>>>>>            Increment i
93642>>>>>>>>
93642>>>>>>>>            Move "decimal"                               to aColumnType[i].sSQLType
93643>>>>>>>>            Move 246                                     to aColumnType[i].iSQLType
93644>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93645>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93646>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
93647>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
93648>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
93649>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93650>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93651>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
93652>>>>>>>>            Increment i
93653>>>>>>>>
93653>>>>>>>>            Move "decimal-MySQL4"                        to aColumnType[i].sSQLType
93654>>>>>>>>            Move 0                                       to aColumnType[i].iSQLType
93655>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93656>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93657>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
93658>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
93659>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
93660>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93661>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93662>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
93663>>>>>>>>            Increment i
93664>>>>>>>>
93664>>>>>>>>            Move "double"                                to aColumnType[i].sSQLType
93665>>>>>>>>            Move 5                                       to aColumnType[i].iSQLType
93666>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93667>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93668>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
93669>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
93670>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
93671>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93672>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93673>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
93674>>>>>>>>            Increment i
93675>>>>>>>>
93675>>>>>>>>            Move "enum"                                  to aColumnType[i].sSQLType
93676>>>>>>>>            Move 247                                     to aColumnType[i].iSQLType
93677>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93678>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93679>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
93680>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
93681>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
93682>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93683>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93684>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
93685>>>>>>>>            Increment i
93686>>>>>>>>
93686>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
93687>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
93688>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93689>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93690>>>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
93691>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
93692>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
93693>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93694>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93695>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
93696>>>>>>>>            Increment i
93697>>>>>>>>
93697>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
93698>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
93699>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93700>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93701>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
93702>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
93703>>>>>>>>            Move 11                                      to aColumnType[i].nMaxSize
93704>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93705>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93706>>>>>>>>            Move 11                                      to aColumnType[i].sPrecision
93707>>>>>>>>            Increment i
93708>>>>>>>>
93708>>>>>>>>            Move "longblob"                              to aColumnType[i].sSQLType
93709>>>>>>>>            Move 251                                     to aColumnType[i].iSQLType
93710>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93711>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93712>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93713>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93714>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
93715>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
93716>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
93717>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
93718>>>>>>>>            Increment i
93719>>>>>>>>
93719>>>>>>>>            Move "longtext"                              to aColumnType[i].sSQLType
93720>>>>>>>>            Move -251                                    to aColumnType[i].iSQLType
93721>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93722>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93723>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93724>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93725>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
93726>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
93727>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
93728>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
93729>>>>>>>>            Increment i
93730>>>>>>>>
93730>>>>>>>>            Move "mediumblob"                            to aColumnType[i].sSQLType
93731>>>>>>>>            Move 250                                     to aColumnType[i].iSQLType
93732>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93733>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93734>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93735>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93736>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
93737>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
93738>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
93739>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
93740>>>>>>>>            Increment i
93741>>>>>>>>
93741>>>>>>>>            Move "mediumint"                             to aColumnType[i].sSQLType
93742>>>>>>>>            Move 9                                       to aColumnType[i].iSQLType
93743>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93744>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93745>>>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
93746>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93747>>>>>>>>            Move 9                                       to aColumnType[i].nMaxSize
93748>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93749>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93750>>>>>>>>            Move 9                                       to aColumnType[i].sPrecision
93751>>>>>>>>            Increment i
93752>>>>>>>>
93752>>>>>>>>            Move "mediumtext"                            to aColumnType[i].sSQLType
93753>>>>>>>>            Move -250                                    to aColumnType[i].iSQLType
93754>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93755>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93756>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93757>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93758>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
93759>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
93760>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
93761>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
93762>>>>>>>>            Increment i
93763>>>>>>>>
93763>>>>>>>>            Move "set"                                   to aColumnType[i].sSQLType
93764>>>>>>>>            Move 248                                     to aColumnType[i].iSQLType
93765>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93766>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93767>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
93768>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
93769>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
93770>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93771>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93772>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
93773>>>>>>>>            Increment i
93774>>>>>>>>
93774>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
93775>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
93776>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93777>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93778>>>>>>>>            Move 5                                       to aColumnType[i].iDefaultSize
93779>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93780>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
93781>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93782>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93783>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
93784>>>>>>>>            Increment i
93785>>>>>>>>
93785>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
93786>>>>>>>>            Move -252                                    to aColumnType[i].iSQLType
93787>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93788>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93789>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93790>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93791>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
93792>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
93793>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
93794>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
93795>>>>>>>>            Increment i
93796>>>>>>>>
93796>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
93797>>>>>>>>            Move 11                                      to aColumnType[i].iSQLType
93798>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
93799>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93800>>>>>>>>            Move 10                                      to aColumnType[i].iDefaultSize
93801>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
93802>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
93803>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93804>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93805>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
93806>>>>>>>>            Increment i
93807>>>>>>>>
93807>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
93808>>>>>>>>            Move 7                                       to aColumnType[i].iSQLType
93809>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93810>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93811>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
93812>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
93813>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
93814>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
93815>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
93816>>>>>>>>            Move 23                                      to aColumnType[i].sPrecision
93817>>>>>>>>            Increment i
93818>>>>>>>>
93818>>>>>>>>            Move "tinyblob"                              to aColumnType[i].sSQLType
93819>>>>>>>>            Move 249                                     to aColumnType[i].iSQLType
93820>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93821>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93822>>>>>>>>            Move 255                                     to aColumnType[i].iDefaultSize
93823>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93824>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
93825>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
93826>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
93827>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
93828>>>>>>>>            Increment i
93829>>>>>>>>
93829>>>>>>>>            Move "tinyint"                               to aColumnType[i].sSQLType
93830>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
93831>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93832>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93833>>>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
93834>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93835>>>>>>>>            Move 4                                       to aColumnType[i].nMaxSize
93836>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93837>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93838>>>>>>>>            Move 4                                       to aColumnType[i].sPrecision
93839>>>>>>>>            Increment i
93840>>>>>>>>
93840>>>>>>>>            Move "tinytext"                              to aColumnType[i].sSQLType
93841>>>>>>>>            Move -249                                    to aColumnType[i].iSQLType
93842>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93843>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93844>>>>>>>>            Move 255                                     to aColumnType[i].iDefaultSize
93845>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93846>>>>>>>>            Move 255                                     to aColumnType[i].nMaxSize
93847>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93848>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93849>>>>>>>>            Move 255                                     to aColumnType[i].sPrecision
93850>>>>>>>>            Increment i
93851>>>>>>>>
93851>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
93852>>>>>>>>            Move 253                                     to aColumnType[i].iSQLType
93853>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93854>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93855>>>>>>>>            Move -1                                      to aColumnType[i].iDefaultSize
93856>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
93857>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
93858>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93859>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93860>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
93861>>>>>>>>            Increment i
93862>>>>>>>>
93862>>>>>>>>            Move "year"                                  to aColumnType[i].sSQLType
93863>>>>>>>>            Move 13                                      to aColumnType[i].iSQLType
93864>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
93865>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93866>>>>>>>>            Move 4                                       to aColumnType[i].iDefaultSize
93867>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
93868>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
93869>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93870>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93871>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
93872>>>>>>>>            Increment i
93873>>>>>>>>
93873>>>>>>>>
93873>>>>>>>
93873>>>>>>>//        Move eMySQL_LONGLONG    to ColumnType[i].iSQLType
93873>>>>>>>//        Move "bigint"           to ColumnType[i].sSQLType
93873>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
93873>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
93873>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
93873>>>>>>>//        Increment i
93873>>>>>>>//
93873>>>>>>>//        Move eMySQL_BIT         to ColumnType[i].iSQLType
93873>>>>>>>//        Move "bit"              to ColumnType[i].sSQLType
93873>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
93873>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
93873>>>>>>>//        Move "4.0"              to ColumnType[i].sPrecision // In SQL allows "1, 0, or NULL"
93873>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
93873>>>>>>>//        Increment i
93873>>>>>>>//
93873>>>>>>>//        Move eMySQL_BLOB        to ColumnType[i].iSQLType
93873>>>>>>>//        Move "blob"             to ColumnType[i].sSQLType
93873>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
93873>>>>>>>//        Move "BINARY"           to ColumnType[i].sDataFlexType
93873>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
93873>>>>>>>//        Increment i
93873>>>>>>>//
93873>>>>>>>//        Move eMySQL_STRING      to ColumnType[i].iSQLType
93873>>>>>>>//        Move "char"             to ColumnType[i].sSQLType
93873>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
93873>>>>>>>//        Move "TEXT"             to ColumnType[i].sDataFlexType
93873>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
93873>>>>>>>//        Increment i
93873>>>>>>>//
93873>>>>>>>//        Move eMySQL_DATE        to ColumnType[i].iSQLType
93873>>>>>>>//        Move "date"             to ColumnType[i].sSQLType
93873>>>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
93873>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
93873>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
93873>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
93873>>>>>>>//        Increment i
93873>>>>>>>//
93873>>>>>>>//        Move eMySQL_DATETIME    to ColumnType[i].iSQLType
93873>>>>>>>//        Move "datetime"         to ColumnType[i].sSQLType
93873>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
93873>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
93873>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
93873>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
93873>>>>>>>//        Increment i
93873>>>>>>>//
93873>>>>>>>//        Move eMySQL_DECIMAL     to ColumnType[i].iSQLType
93873>>>>>>>//        Move "decimal"          to ColumnType[i].sSQLType
93873>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
93873>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
93873>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
93873>>>>>>>//        Increment i
93873>>>>>>>//
93873>>>>>>>//        Move eMySQL_DOUBLE      to ColumnType[i].iSQLType
93873>>>>>>>//        Move "double"           to ColumnType[i].sSQLType
93873>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
93873>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
93873>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
93873>>>>>>>//        Increment i
93873>>>>>>>//
93873>>>>>>>//        Move eMySQL_ENUM        to ColumnType[i].iSQLType
93873>>>>>>>//        Move "enum"             to ColumnType[i].sSQLType
93873>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
93873>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
93873>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
93873>>>>>>>//        Increment i
93873>>>>>>>//
93873>>>>>>>//        Move eMySQL_FLOAT       to ColumnType[i].iSQLType
93873>>>>>>>//        Move "float"            to ColumnType[i].sSQLType
93873>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
93873>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
93873>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
93873>>>>>>>//        Increment i
93873>>>>>>>//
93873>>>>>>>//        Move eMySQL_INT24       to ColumnType[i].iSQLType
93873>>>>>>>//        Move "int"              to ColumnType[i].sSQLType
93873>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
93873>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
93873>>>>>>>//        Move "11.0"             to ColumnType[i].sPrecision
93873>>>>>>>//        Increment i
93873>>>>>>>//
93873>>>>>>>//        Move eMySQL_LONG_BLOB   to ColumnType[i].iSQLType
93873>>>>>>>//        Move "longblob"         to ColumnType[i].sSQLType
93873>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
93873>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
93873>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
93873>>>>>>>//        Increment i
93873>>>>>>>//
93873>>>>>>>//        Move eMySQL_LONG_TEXT   to ColumnType[i].iSQLType
93873>>>>>>>//        Move "longtext"         to ColumnType[i].sSQLType
93873>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
93873>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
93873>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
93873>>>>>>>//        Increment i
93873>>>>>>>//
93873>>>>>>>//        Move eMySQL_MEDIUM_BLOB to ColumnType[i].iSQLType
93873>>>>>>>//        Move "mediumblob"       to ColumnType[i].sSQLType
93873>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
93873>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
93873>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
93873>>>>>>>//        Increment i
93873>>>>>>>//
93873>>>>>>>//        Move eMySQL_INT24       to ColumnType[i].iSQLType
93873>>>>>>>//        Move "mediumint"        to ColumnType[i].sSQLType
93873>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
93873>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
93873>>>>>>>//        Move "9.0"              to ColumnType[i].sPrecision
93873>>>>>>>//
93873>>>>>>>//        Move eMySQL_MEDIUM_TEXT to ColumnType[i].iSQLType
93873>>>>>>>//        Move "mediumtext"       to ColumnType[i].sSQLType
93873>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
93873>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
93873>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
93873>>>>>>>//        Increment i
93873>>>>>>>//
93873>>>>>>>//        Move eMySQL_SET         to ColumnType[i].iSQLType
93873>>>>>>>//        Move "set"              to ColumnType[i].sSQLType
93873>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
93873>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
93873>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
93873>>>>>>>//        Increment i
93873>>>>>>>//
93873>>>>>>>//        Move eMySQL_SHORT       to ColumnType[i].iSQLType
93873>>>>>>>//        Move "smallint"         to ColumnType[i].sSQLType
93873>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
93873>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
93873>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
93873>>>>>>>//        Increment i
93873>>>>>>>//
93873>>>>>>>//        Move eMySQL_TEXT        to ColumnType[i].iSQLType
93873>>>>>>>//        Move "text"             to ColumnType[i].sSQLType
93873>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
93873>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
93873>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
93873>>>>>>>//        Increment i
93873>>>>>>>//
93873>>>>>>>//        Move eMySQL_TIME        to ColumnType[i].iSQLType
93873>>>>>>>//        Move "time"             to ColumnType[i].sSQLType
93873>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
93873>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
93873>>>>>>>//        Move "10.0"             to ColumnType[i].sPrecision
93873>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
93873>>>>>>>//        Increment i
93873>>>>>>>//
93873>>>>>>>//        Move eMySQL_TIMESTAMP   to ColumnType[i].iSQLType
93873>>>>>>>//        Move "timestamp"        to ColumnType[i].sSQLType
93873>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
93873>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
93873>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
93873>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
93873>>>>>>>//        Increment i
93873>>>>>>>//
93873>>>>>>>//        Move eMySQL_TINY_BLOB   to ColumnType[i].iSQLType
93873>>>>>>>//        Move "tinyblob"         to ColumnType[i].sSQLType
93873>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
93873>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
93873>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
93873>>>>>>>//        Increment i
93873>>>>>>>//
93873>>>>>>>//        Move eMySQL_TINY        to ColumnType[i].iSQLType
93873>>>>>>>//        Move "tinyint"          to ColumnType[i].sSQLType
93873>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
93873>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
93873>>>>>>>//        Move "4.0"              to ColumnType[i].sPrecision
93873>>>>>>>//        Increment i
93873>>>>>>>//
93873>>>>>>>//        Move eMySQL_TINY_TEXT   to ColumnType[i].iSQLType
93873>>>>>>>//        Move "tinytext"         to ColumnType[i].sSQLType
93873>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
93873>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
93873>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
93873>>>>>>>//        Increment i
93873>>>>>>>//
93873>>>>>>>//        Move eMySQL_VAR_STRING  to ColumnType[i].iSQLType
93873>>>>>>>//        Move "varchar"          to ColumnType[i].sSQLType
93873>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
93873>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
93873>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
93873>>>>>>>//        Increment i
93873>>>>>>>//
93873>>>>>>>//        Move eMySQL_YEAR        to ColumnType[i].iSQLType
93873>>>>>>>//        Move "year"             to ColumnType[i].sSQLType
93873>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
93873>>>>>>>//        Move "NUMERIC"          to ColumnType[i].sDataFlexType
93873>>>>>>>//        Move "4.0"              to ColumnType[i].sPrecision
93873>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
93873>>>>>>>//        Increment i
93873>>>>>>>
93873>>>>>>>        Function_Return aColumnType
93874>>>>>>>    End_Function
93875>>>>>>>
93875>>>>>>>    // Oracle Data Types
93875>>>>>>>    Function _UtilEnumerateOracleTypes Returns tColumnType[]
93877>>>>>>>        tColumnType[] aColumnType
93877>>>>>>>        tColumnType[] aColumnType
93878>>>>>>>        Integer i
93878>>>>>>>
Including file: ora_drv_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ora_drv_DriverDef.inc)
93878>>>>>>>>// Generated By The Database Update Framework
93878>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\ora_drv_DriverDef.xml
93878>>>>>>>>// Driver COLUMN DATA TYPES
93878>>>>>>>>//
93878>>>>>>>>// Created: 2018-03-14 23:47:34.82
93878>>>>>>>>
93878>>>>>>>>            Move "blob"                                  to aColumnType[i].sSQLType
93879>>>>>>>>            Move 113                                     to aColumnType[i].iSQLType
93880>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93881>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93882>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93883>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93884>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
93885>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
93886>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
93887>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
93888>>>>>>>>            Increment i
93889>>>>>>>>
93889>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
93890>>>>>>>>            Move 96                                      to aColumnType[i].iSQLType
93891>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93892>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93893>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
93894>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93895>>>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
93896>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93897>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93898>>>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
93899>>>>>>>>            Increment i
93900>>>>>>>>
93900>>>>>>>>            Move "clob"                                  to aColumnType[i].sSQLType
93901>>>>>>>>            Move 112                                     to aColumnType[i].iSQLType
93902>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93903>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93904>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93905>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93906>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
93907>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
93908>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
93909>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
93910>>>>>>>>            Increment i
93911>>>>>>>>
93911>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
93912>>>>>>>>            Move 12                                      to aColumnType[i].iSQLType
93913>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93914>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93915>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
93916>>>>>>>>            Move 6                                       to aColumnType[i].iMinSize
93917>>>>>>>>            Move 23                                      to aColumnType[i].nMaxSize
93918>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
93919>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
93920>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
93921>>>>>>>>            Increment i
93922>>>>>>>>
93922>>>>>>>>            Move "float"                                 to aColumnType[i].sSQLType
93923>>>>>>>>            Move 4                                       to aColumnType[i].iSQLType
93924>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93925>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93926>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
93927>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93928>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
93929>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93930>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93931>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
93932>>>>>>>>            Increment i
93933>>>>>>>>
93933>>>>>>>>            Move "int"                                   to aColumnType[i].sSQLType
93934>>>>>>>>            Move 3                                       to aColumnType[i].iSQLType
93935>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93936>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93937>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
93938>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93939>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
93940>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
93941>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
93942>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
93943>>>>>>>>            Increment i
93944>>>>>>>>
93944>>>>>>>>            Move "intervalds"                            to aColumnType[i].sSQLType
93945>>>>>>>>            Move 190                                     to aColumnType[i].iSQLType
93946>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
93947>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93948>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
93949>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
93950>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
93951>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
93952>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
93953>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
93954>>>>>>>>            Increment i
93955>>>>>>>>
93955>>>>>>>>            Move "intervalym"                            to aColumnType[i].sSQLType
93956>>>>>>>>            Move 189                                     to aColumnType[i].iSQLType
93957>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
93958>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93959>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
93960>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
93961>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
93962>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
93963>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
93964>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
93965>>>>>>>>            Increment i
93966>>>>>>>>
93966>>>>>>>>            Move "long"                                  to aColumnType[i].sSQLType
93967>>>>>>>>            Move 8                                       to aColumnType[i].iSQLType
93968>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93969>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93970>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93971>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93972>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
93973>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93974>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93975>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
93976>>>>>>>>            Increment i
93977>>>>>>>>
93977>>>>>>>>            Move "longraw"                               to aColumnType[i].sSQLType
93978>>>>>>>>            Move 24                                      to aColumnType[i].iSQLType
93979>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93980>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93981>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
93982>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93983>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
93984>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
93985>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
93986>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
93987>>>>>>>>            Increment i
93988>>>>>>>>
93988>>>>>>>>            Move "nchar"                                 to aColumnType[i].sSQLType
93989>>>>>>>>            Move 286                                     to aColumnType[i].iSQLType
93990>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
93991>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
93992>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
93993>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
93994>>>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
93995>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
93996>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
93997>>>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
93998>>>>>>>>            Increment i
93999>>>>>>>>
93999>>>>>>>>            Move "nclob"                                 to aColumnType[i].sSQLType
94000>>>>>>>>            Move 288                                     to aColumnType[i].iSQLType
94001>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94002>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94003>>>>>>>>            Move 16384                                   to aColumnType[i].iDefaultSize
94004>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94005>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
94006>>>>>>>>            Move "DF_TEXT"                               to aColumnType[i].sDataFlexType
94007>>>>>>>>            Move DF_TEXT                                 to aColumnType[i].iDataFlexType
94008>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
94009>>>>>>>>            Increment i
94010>>>>>>>>
94010>>>>>>>>            Move "number"                                to aColumnType[i].sSQLType
94011>>>>>>>>            Move 2                                       to aColumnType[i].iSQLType
94012>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94013>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94014>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
94015>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94016>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
94017>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
94018>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
94019>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
94020>>>>>>>>            Increment i
94021>>>>>>>>
94021>>>>>>>>            Move "nvarchar2"                             to aColumnType[i].sSQLType
94022>>>>>>>>            Move 287                                     to aColumnType[i].iSQLType
94023>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94024>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94025>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
94026>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94027>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
94028>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94029>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94030>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
94031>>>>>>>>            Increment i
94032>>>>>>>>
94032>>>>>>>>            Move "raw"                                   to aColumnType[i].sSQLType
94033>>>>>>>>            Move 23                                      to aColumnType[i].iSQLType
94034>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94035>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94036>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
94037>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94038>>>>>>>>            Move 2000                                    to aColumnType[i].nMaxSize
94039>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
94040>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
94041>>>>>>>>            Move 2000                                    to aColumnType[i].sPrecision
94042>>>>>>>>            Increment i
94043>>>>>>>>
94043>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
94044>>>>>>>>            Move 187                                     to aColumnType[i].iSQLType
94045>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
94046>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94047>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
94048>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
94049>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
94050>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
94051>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
94052>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
94053>>>>>>>>            Increment i
94054>>>>>>>>
94054>>>>>>>>            Move "timestampltz"                          to aColumnType[i].sSQLType
94055>>>>>>>>            Move 232                                     to aColumnType[i].iSQLType
94056>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
94057>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94058>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
94059>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
94060>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
94061>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
94062>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
94063>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
94064>>>>>>>>            Increment i
94065>>>>>>>>
94065>>>>>>>>            Move "timestamptz"                           to aColumnType[i].sSQLType
94066>>>>>>>>            Move 188                                     to aColumnType[i].iSQLType
94067>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
94068>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94069>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
94070>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
94071>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
94072>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
94073>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
94074>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
94075>>>>>>>>            Increment i
94076>>>>>>>>
94076>>>>>>>>            Move "varchar2"                              to aColumnType[i].sSQLType
94077>>>>>>>>            Move 1                                       to aColumnType[i].iSQLType
94078>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94079>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94080>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
94081>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94082>>>>>>>>            Move 4000                                    to aColumnType[i].nMaxSize
94083>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94084>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94085>>>>>>>>            Move 4000                                    to aColumnType[i].sPrecision
94086>>>>>>>>            Increment i
94087>>>>>>>>
94087>>>>>>>>
94087>>>>>>>
94087>>>>>>>//        Move eOracle_BLOB       to ColumnType[i].iSQLType
94087>>>>>>>//        Move "BLOB"             to ColumnType[i].sSQLType
94087>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
94087>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
94087>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
94087>>>>>>>//        Increment i
94087>>>>>>>//
94087>>>>>>>//        Move eOracle_CHAR       to ColumnType[i].iSQLType
94087>>>>>>>//        Move "CHAR"             to ColumnType[i].sSQLType
94087>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
94087>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
94087>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
94087>>>>>>>//        Increment i
94087>>>>>>>//
94087>>>>>>>//        Move eOracle_CLOB       to ColumnType[i].iSQLType
94087>>>>>>>//        Move "CLOB"             to ColumnType[i].sSQLType
94087>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
94087>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
94087>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
94087>>>>>>>//        Increment i
94087>>>>>>>//
94087>>>>>>>//        Move eOracle_DATE       to ColumnType[i].iSQLType
94087>>>>>>>//        Move "DATE"             to ColumnType[i].sSQLType
94087>>>>>>>//        Move DF_Date            to ColumnType[i].iDataFlexType
94087>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
94087>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
94087>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
94087>>>>>>>//        Increment i
94087>>>>>>>//
94087>>>>>>>//        Move eOracle_FLOAT      to ColumnType[i].iSQLType
94087>>>>>>>//        Move "FLOAT"            to ColumnType[i].sSQLType
94087>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
94087>>>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
94087>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
94087>>>>>>>//        Increment i
94087>>>>>>>//
94087>>>>>>>//        Move eOracle_INT        to ColumnType[i].iSQLType
94087>>>>>>>//        Move "INT"              to ColumnType[i].sSQLType
94087>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
94087>>>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
94087>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
94087>>>>>>>//        Increment i
94087>>>>>>>//
94087>>>>>>>//        Move eOracle_INTERVALDS to ColumnType[i].iSQLType
94087>>>>>>>//        Move "INTERVALDAYTOSEC" to ColumnType[i].sSQLType
94087>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
94087>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
94087>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
94087>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
94087>>>>>>>//        Increment i
94087>>>>>>>//
94087>>>>>>>//        Move eOracle_INTERVALYM  to ColumnType[i].iSQLType
94087>>>>>>>//        Move "INTERVALYEARTOMON" to ColumnType[i].sSQLType
94087>>>>>>>//        Move DF_DATETIME         to ColumnType[i].iDataFlexType
94087>>>>>>>//        Move "DateTime"          to ColumnType[i].sDataFlexType
94087>>>>>>>//        Move "23.0"              to ColumnType[i].sPrecision
94087>>>>>>>//        Move True                to ColumnType[i].bCanEditSize
94087>>>>>>>//        Increment i
94087>>>>>>>//
94087>>>>>>>//        Move eOracle_RAW        to ColumnType[i].iSQLType
94087>>>>>>>//        Move "LONG"             to ColumnType[i].sSQLType
94087>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
94087>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
94087>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
94087>>>>>>>//        Increment i
94087>>>>>>>//
94087>>>>>>>//        Move eOracle_LONGRAW    to ColumnType[i].iSQLType
94087>>>>>>>//        Move "LONG RAW"         to ColumnType[i].sSQLType
94087>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
94087>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
94087>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
94087>>>>>>>//        Increment i
94087>>>>>>>//
94087>>>>>>>//        Move eOracle_NCHAR      to ColumnType[i].iSQLType
94087>>>>>>>//        Move "NCHAR"            to ColumnType[i].sSQLType
94087>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
94087>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
94087>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
94087>>>>>>>//        Increment i
94087>>>>>>>//
94087>>>>>>>//        Move eOracle_NCLOB      to ColumnType[i].iSQLType
94087>>>>>>>//        Move "NCLOB"            to ColumnType[i].sSQLType
94087>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
94087>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
94087>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
94087>>>>>>>//        Increment i
94087>>>>>>>//
94087>>>>>>>//        Move eOracle_NUMBER     to ColumnType[i].iSQLType
94087>>>>>>>//        Move "NUMBER"           to ColumnType[i].sSQLType
94087>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
94087>>>>>>>//        Move "Number"           to ColumnType[i].sDataFlexType
94087>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
94087>>>>>>>//        Increment i
94087>>>>>>>//
94087>>>>>>>//        Move eOracle_NVARCHAR2  to ColumnType[i].iSQLType
94087>>>>>>>//        Move "NVARCHAR2"        to ColumnType[i].sSQLType
94087>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
94087>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
94087>>>>>>>//        Move "4000"             to ColumnType[i].sPrecision
94087>>>>>>>//        Increment i
94087>>>>>>>//
94087>>>>>>>//        Move eOracle_RAW        to ColumnType[i].iSQLType
94087>>>>>>>//        Move "RAW"              to ColumnType[i].sSQLType
94087>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
94087>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
94087>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
94087>>>>>>>//        Increment i
94087>>>>>>>//
94087>>>>>>>//        Move eOracle_ROWID      to ColumnType[i].iSQLType
94087>>>>>>>//        Move "ROWID"            to ColumnType[i].sSQLType
94087>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
94087>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
94087>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
94087>>>>>>>//        Increment i
94087>>>>>>>//
94087>>>>>>>//        Move eOracle_TIMESTAMP  to ColumnType[i].iSQLType
94087>>>>>>>//        Move "TimeStamp"        to ColumnType[i].sSQLType
94087>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
94087>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
94087>>>>>>>//        Move "11.0"             to ColumnType[i].sPrecision
94087>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
94087>>>>>>>//        Increment i
94087>>>>>>>//
94087>>>>>>>//        Move eOracle_TIMESTAMPLTZ   to ColumnType[i].iSQLType
94087>>>>>>>//        Move "TIMESTAMPLOCALTZ"     to ColumnType[i].sSQLType
94087>>>>>>>//        Move DF_DATETIME            to ColumnType[i].iDataFlexType
94087>>>>>>>//        Move "DateTime"             to ColumnType[i].sDataFlexType
94087>>>>>>>//        Move "13.0"                 to ColumnType[i].sPrecision
94087>>>>>>>//        Move True                   to ColumnType[i].bCanEditSize
94087>>>>>>>//        Increment i
94087>>>>>>>//
94087>>>>>>>//        Move eOracle_TIMESTAMPTZ    to ColumnType[i].iSQLType
94087>>>>>>>//        Move "TIMEZONETIMEZONE"     to ColumnType[i].sSQLType
94087>>>>>>>//        Move DF_DATETIME            to ColumnType[i].iDataFlexType
94087>>>>>>>//        Move "DateTime"             to ColumnType[i].sDataFlexType
94087>>>>>>>//        Move "11.0"                 to ColumnType[i].sPrecision
94087>>>>>>>//        Move True                   to ColumnType[i].bCanEditSize
94087>>>>>>>//        Increment i
94087>>>>>>>//
94087>>>>>>>//        Move eOracle_VARCHAR2   to ColumnType[i].iSQLType
94087>>>>>>>//        Move "VARCHAR"          to ColumnType[i].sSQLType
94087>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
94087>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
94087>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
94087>>>>>>>
94087>>>>>>>        Function_Return aColumnType
94088>>>>>>>    End_Function
94089>>>>>>>
94089>>>>>>>    // PostgreSQL Data Types
94089>>>>>>>    Function _UtilEnumeratePostgreSQLTypes Returns tColumnType[]
94091>>>>>>>        tColumnType[] aColumnType
94091>>>>>>>        tColumnType[] aColumnType
94092>>>>>>>        Integer i
94092>>>>>>>
Including file: mdspgsql_DriverDef.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\mdspgsql_DriverDef.inc)
94092>>>>>>>>// Generated By The Database Update Framework
94092>>>>>>>>// Driver XML File: C:\Program Files (x86)\DataFlex 19.0\Bin\mdspgsql_DriverDef.xml
94092>>>>>>>>// Driver COLUMN DATA TYPES
94092>>>>>>>>//
94092>>>>>>>>// Created: 2018-03-14 23:47:02.984
94092>>>>>>>>
94092>>>>>>>>            Move "bigint"                                to aColumnType[i].sSQLType
94093>>>>>>>>            Move 20                                      to aColumnType[i].iSQLType
94094>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94095>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94096>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
94097>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94098>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
94099>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
94100>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
94101>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
94102>>>>>>>>            Increment i
94103>>>>>>>>
94103>>>>>>>>            Move "bit"                                   to aColumnType[i].sSQLType
94104>>>>>>>>            Move 1560                                    to aColumnType[i].iSQLType
94105>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94106>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94107>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
94108>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94109>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
94110>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
94111>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
94112>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
94113>>>>>>>>            Increment i
94114>>>>>>>>
94114>>>>>>>>            Move "boolean"                               to aColumnType[i].sSQLType
94115>>>>>>>>            Move 16                                      to aColumnType[i].iSQLType
94116>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
94117>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94118>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
94119>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
94120>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
94121>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94122>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94123>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
94124>>>>>>>>            Increment i
94125>>>>>>>>
94125>>>>>>>>            Move "bytea"                                 to aColumnType[i].sSQLType
94126>>>>>>>>            Move 17                                      to aColumnType[i].iSQLType
94127>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94128>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94129>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
94130>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94131>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
94132>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
94133>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
94134>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
94135>>>>>>>>            Increment i
94136>>>>>>>>
94136>>>>>>>>            Move "char"                                  to aColumnType[i].sSQLType
94137>>>>>>>>            Move 18                                      to aColumnType[i].iSQLType
94138>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94139>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94140>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
94141>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94142>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
94143>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94144>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94145>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
94146>>>>>>>>            Increment i
94147>>>>>>>>
94147>>>>>>>>            Move "citext"                                to aColumnType[i].sSQLType
94148>>>>>>>>            Move -25                                     to aColumnType[i].iSQLType
94149>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94150>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94151>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
94152>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94153>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
94154>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94155>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94156>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
94157>>>>>>>>            Increment i
94158>>>>>>>>
94158>>>>>>>>            Move "date"                                  to aColumnType[i].sSQLType
94159>>>>>>>>            Move 1082                                    to aColumnType[i].iSQLType
94160>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
94161>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94162>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
94163>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
94164>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
94165>>>>>>>>            Move "DF_DATE"                               to aColumnType[i].sDataFlexType
94166>>>>>>>>            Move DF_DATE                                 to aColumnType[i].iDataFlexType
94167>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
94168>>>>>>>>            Increment i
94169>>>>>>>>
94169>>>>>>>>            Move "double"                                to aColumnType[i].sSQLType
94170>>>>>>>>            Move 701                                     to aColumnType[i].iSQLType
94171>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94172>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94173>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
94174>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94175>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
94176>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94177>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94178>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
94179>>>>>>>>            Increment i
94180>>>>>>>>
94180>>>>>>>>            Move "integer"                               to aColumnType[i].sSQLType
94181>>>>>>>>            Move 23                                      to aColumnType[i].iSQLType
94182>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94183>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94184>>>>>>>>            Move 11                                      to aColumnType[i].iDefaultSize
94185>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94186>>>>>>>>            Move 11                                      to aColumnType[i].nMaxSize
94187>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
94188>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
94189>>>>>>>>            Move 11                                      to aColumnType[i].sPrecision
94190>>>>>>>>            Increment i
94191>>>>>>>>
94191>>>>>>>>            Move "money"                                 to aColumnType[i].sSQLType
94192>>>>>>>>            Move 790                                     to aColumnType[i].iSQLType
94193>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94194>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94195>>>>>>>>            Move 30                                      to aColumnType[i].iDefaultSize
94196>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94197>>>>>>>>            Move 30                                      to aColumnType[i].nMaxSize
94198>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
94199>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
94200>>>>>>>>            Move 30                                      to aColumnType[i].sPrecision
94201>>>>>>>>            Increment i
94202>>>>>>>>
94202>>>>>>>>            Move "numeric"                               to aColumnType[i].sSQLType
94203>>>>>>>>            Move 1700                                    to aColumnType[i].iSQLType
94204>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94205>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94206>>>>>>>>            Move 14                                      to aColumnType[i].iDefaultSize
94207>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94208>>>>>>>>            Move 14                                      to aColumnType[i].nMaxSize
94209>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94210>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94211>>>>>>>>            Move 14                                      to aColumnType[i].sPrecision
94212>>>>>>>>            Increment i
94213>>>>>>>>
94213>>>>>>>>            Move "oid"                                   to aColumnType[i].sSQLType
94214>>>>>>>>            Move 26                                      to aColumnType[i].iSQLType
94215>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
94216>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94217>>>>>>>>            Move 20                                      to aColumnType[i].iDefaultSize
94218>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
94219>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
94220>>>>>>>>            Move "DF_BINARY"                             to aColumnType[i].sDataFlexType
94221>>>>>>>>            Move DF_BINARY                               to aColumnType[i].iDataFlexType
94222>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
94223>>>>>>>>            Increment i
94224>>>>>>>>
94224>>>>>>>>            Move "real"                                  to aColumnType[i].sSQLType
94225>>>>>>>>            Move 700                                     to aColumnType[i].iSQLType
94226>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94227>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94228>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
94229>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94230>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
94231>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
94232>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
94233>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
94234>>>>>>>>            Increment i
94235>>>>>>>>
94235>>>>>>>>            Move "regproc"                               to aColumnType[i].sSQLType
94236>>>>>>>>            Move 24                                      to aColumnType[i].iSQLType
94237>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
94238>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94239>>>>>>>>            Move 64                                      to aColumnType[i].iDefaultSize
94240>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
94241>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
94242>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94243>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94244>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
94245>>>>>>>>            Increment i
94246>>>>>>>>
94246>>>>>>>>            Move "smallint"                              to aColumnType[i].sSQLType
94247>>>>>>>>            Move 21                                      to aColumnType[i].iSQLType
94248>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94249>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94250>>>>>>>>            Move 6                                       to aColumnType[i].iDefaultSize
94251>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94252>>>>>>>>            Move 6                                       to aColumnType[i].nMaxSize
94253>>>>>>>>            Move "DF_BCD"                                to aColumnType[i].sDataFlexType
94254>>>>>>>>            Move DF_BCD                                  to aColumnType[i].iDataFlexType
94255>>>>>>>>            Move 6                                       to aColumnType[i].sPrecision
94256>>>>>>>>            Increment i
94257>>>>>>>>
94257>>>>>>>>            Move "text"                                  to aColumnType[i].sSQLType
94258>>>>>>>>            Move 25                                      to aColumnType[i].iSQLType
94259>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94260>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94261>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
94262>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94263>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
94264>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94265>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94266>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
94267>>>>>>>>            Increment i
94268>>>>>>>>
94268>>>>>>>>            Move "time"                                  to aColumnType[i].sSQLType
94269>>>>>>>>            Move 1083                                    to aColumnType[i].iSQLType
94270>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94271>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94272>>>>>>>>            Move 8                                       to aColumnType[i].iDefaultSize
94273>>>>>>>>            Move 8                                       to aColumnType[i].iMinSize
94274>>>>>>>>            Move 15                                      to aColumnType[i].nMaxSize
94275>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94276>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94277>>>>>>>>            Move 15                                      to aColumnType[i].sPrecision
94278>>>>>>>>            Increment i
94279>>>>>>>>
94279>>>>>>>>            Move "timestamp"                             to aColumnType[i].sSQLType
94280>>>>>>>>            Move 1114                                    to aColumnType[i].iSQLType
94281>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
94282>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94283>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
94284>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
94285>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
94286>>>>>>>>            Move "DF_DATETIME"                           to aColumnType[i].sDataFlexType
94287>>>>>>>>            Move DF_DATETIME                             to aColumnType[i].iDataFlexType
94288>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
94289>>>>>>>>            Increment i
94290>>>>>>>>
94290>>>>>>>>            Move "timestamptz"                           to aColumnType[i].sSQLType
94291>>>>>>>>            Move 1184                                    to aColumnType[i].iSQLType
94292>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
94293>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94294>>>>>>>>            Move 23                                      to aColumnType[i].iDefaultSize
94295>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
94296>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
94297>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94298>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94299>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
94300>>>>>>>>            Increment i
94301>>>>>>>>
94301>>>>>>>>            Move "uuid"                                  to aColumnType[i].sSQLType
94302>>>>>>>>            Move 2950                                    to aColumnType[i].iSQLType
94303>>>>>>>>            Move False                                   to aColumnType[i].bCanEditSize
94304>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94305>>>>>>>>            Move 40                                      to aColumnType[i].iDefaultSize
94306>>>>>>>>            Move -1                                      to aColumnType[i].iMinSize
94307>>>>>>>>            Move -1                                      to aColumnType[i].nMaxSize
94308>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94309>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94310>>>>>>>>            Move -1                                      to aColumnType[i].sPrecision
94311>>>>>>>>            Increment i
94312>>>>>>>>
94312>>>>>>>>            Move "varbit"                                to aColumnType[i].sSQLType
94313>>>>>>>>            Move 1562                                    to aColumnType[i].iSQLType
94314>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94315>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94316>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
94317>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94318>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
94319>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94320>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94321>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
94322>>>>>>>>            Increment i
94323>>>>>>>>
94323>>>>>>>>            Move "varchar"                               to aColumnType[i].sSQLType
94324>>>>>>>>            Move 1043                                    to aColumnType[i].iSQLType
94325>>>>>>>>            Move True                                    to aColumnType[i].bCanEditSize
94326>>>>>>>>            Move True                                    to aColumnType[i].bNativeDataType
94327>>>>>>>>            Move 1                                       to aColumnType[i].iDefaultSize
94328>>>>>>>>            Move 1                                       to aColumnType[i].iMinSize
94329>>>>>>>>            Move 16384                                   to aColumnType[i].nMaxSize
94330>>>>>>>>            Move "DF_ASCII"                              to aColumnType[i].sDataFlexType
94331>>>>>>>>            Move DF_ASCII                                to aColumnType[i].iDataFlexType
94332>>>>>>>>            Move 16384                                   to aColumnType[i].sPrecision
94333>>>>>>>>            Increment i
94334>>>>>>>>
94334>>>>>>>>
94334>>>>>>>
94334>>>>>>>//        Move ePgSQL_INT8        to ColumnType[i].iSQLType
94334>>>>>>>//        Move "bigint"           to ColumnType[i].sSQLType
94334>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
94334>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
94334>>>>>>>//        Move "14.0"             to ColumnType[i].sPrecision
94334>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
94334>>>>>>>//        Increment i
94334>>>>>>>//
94334>>>>>>>//        Move ePgSQL_BIT         to ColumnType[i].iSQLType
94334>>>>>>>//        Move "bit"              to ColumnType[i].sSQLType
94334>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
94334>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
94334>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
94334>>>>>>>//        Increment i
94334>>>>>>>//
94334>>>>>>>//        Move ePgSQL_BOOL        to ColumnType[i].iSQLType
94334>>>>>>>//        Move "boolean"          to ColumnType[i].sSQLType
94334>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
94334>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
94334>>>>>>>//        Move "1"                to ColumnType[i].sPrecision
94334>>>>>>>//        Increment i
94334>>>>>>>//
94334>>>>>>>//        Move ePgSQL_BYTEA       to ColumnType[i].iSQLType
94334>>>>>>>//        Move "bytea"            to ColumnType[i].sSQLType
94334>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
94334>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
94334>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
94334>>>>>>>//        Increment i
94334>>>>>>>//
94334>>>>>>>//        Move ePgSQL_CHAR        to ColumnType[i].iSQLType
94334>>>>>>>//        Move "char"             to ColumnType[i].sSQLType
94334>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
94334>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
94334>>>>>>>//        Move "2000"             to ColumnType[i].sPrecision
94334>>>>>>>//        Increment i
94334>>>>>>>//
94334>>>>>>>//        Move ePgSQL_CITEXT      to ColumnType[i].iSQLType
94334>>>>>>>//        Move "citext"           to ColumnType[i].sSQLType
94334>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
94334>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
94334>>>>>>>//        Move "254"              to ColumnType[i].sPrecision
94334>>>>>>>//        Increment i
94334>>>>>>>//
94334>>>>>>>//        Move ePgSQL_DATE        to ColumnType[i].iSQLType
94334>>>>>>>//        Move "date"             to ColumnType[i].sSQLType
94334>>>>>>>//        Move DF_DATE            to ColumnType[i].iDataFlexType
94334>>>>>>>//        Move "Date"             to ColumnType[i].sDataFlexType
94334>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
94334>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
94334>>>>>>>//        Increment i
94334>>>>>>>//
94334>>>>>>>//        Move ePgSQL_FLOAT4      to ColumnType[i].iSQLType
94334>>>>>>>//        Move "decimal"          to ColumnType[i].sSQLType
94334>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
94334>>>>>>>//        Move "Decimal"          to ColumnType[i].sDataFlexType
94334>>>>>>>//        Move "14.8"             to ColumnType[i].sPrecision
94334>>>>>>>//        Increment i
94334>>>>>>>//
94334>>>>>>>//        Move ePgSQL_FLOAT8      to ColumnType[i].iSQLType
94334>>>>>>>//        Move "double"           to ColumnType[i].sSQLType
94334>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
94334>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
94334>>>>>>>//        Move "22"               to ColumnType[i].sPrecision
94334>>>>>>>//        Increment i
94334>>>>>>>//
94334>>>>>>>//        Move ePgSQL_INT4        to ColumnType[i].iSQLType
94334>>>>>>>//        Move "integer"          to ColumnType[i].sSQLType
94334>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
94334>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
94334>>>>>>>//        Move "8.0"              to ColumnType[i].sPrecision
94334>>>>>>>//        Increment i
94334>>>>>>>//
94334>>>>>>>//        Move ePgSQL_MONEY       to ColumnType[i].iSQLType
94334>>>>>>>//        Move "money"            to ColumnType[i].sSQLType
94334>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
94334>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
94334>>>>>>>//        Move "8.0"              to ColumnType[i].sPrecision
94334>>>>>>>//        Increment i
94334>>>>>>>//
94334>>>>>>>//        Move ePgSQL_OID         to ColumnType[i].iSQLType
94334>>>>>>>//        Move "oid"              to ColumnType[i].sSQLType
94334>>>>>>>//        Move DF_BINARY          to ColumnType[i].iDataFlexType
94334>>>>>>>//        Move "Binary"           to ColumnType[i].sDataFlexType
94334>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
94334>>>>>>>//        Increment i
94334>>>>>>>//
94334>>>>>>>//        Move ePgSQL_FLOAT4      to ColumnType[i].iSQLType
94334>>>>>>>//        Move "real"             to ColumnType[i].sSQLType
94334>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
94334>>>>>>>//        Move "Real"             to ColumnType[i].sDataFlexType
94334>>>>>>>//        Move "6.6"              to ColumnType[i].sPrecision
94334>>>>>>>//        Increment i
94334>>>>>>>//
94334>>>>>>>//        Move ePgSQL_REGPROC     to ColumnType[i].iSQLType
94334>>>>>>>//        Move "regproc"          to ColumnType[i].sSQLType
94334>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
94334>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
94334>>>>>>>//        Move "64"               to ColumnType[i].sPrecision
94334>>>>>>>//        Increment i
94334>>>>>>>//
94334>>>>>>>//        Move ePgSQL_INT2        to ColumnType[i].iSQLType
94334>>>>>>>//        Move "smallint"         to ColumnType[i].sSQLType
94334>>>>>>>//        Move DF_BCD             to ColumnType[i].iDataFlexType
94334>>>>>>>//        Move "Numeric"          to ColumnType[i].sDataFlexType
94334>>>>>>>//        Move "6.0"              to ColumnType[i].sPrecision
94334>>>>>>>//        Increment i
94334>>>>>>>//
94334>>>>>>>//        Move ePgSQL_TEXT        to ColumnType[i].iSQLType
94334>>>>>>>//        Move "text"             to ColumnType[i].sSQLType
94334>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
94334>>>>>>>//        Move "Text"             to ColumnType[i].sDataFlexType
94334>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
94334>>>>>>>//        Increment i
94334>>>>>>>//
94334>>>>>>>//        Move ePgSQL_TIME        to ColumnType[i].iSQLType
94334>>>>>>>//        Move "time"             to ColumnType[i].sSQLType
94334>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
94334>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
94334>>>>>>>//        Move "15.0"             to ColumnType[i].sPrecision
94334>>>>>>>//        Increment i
94334>>>>>>>//
94334>>>>>>>//        Move ePgSQL_TIMESTAMP   to ColumnType[i].iSQLType
94334>>>>>>>//        Move "timestamp"        to ColumnType[i].sSQLType
94334>>>>>>>//        Move DF_DATETIME        to ColumnType[i].iDataFlexType
94334>>>>>>>//        Move "DateTime"         to ColumnType[i].sDataFlexType
94334>>>>>>>//        Move "23.0"             to ColumnType[i].sPrecision
94334>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
94334>>>>>>>//        Increment i
94334>>>>>>>//
94334>>>>>>>//        Move ePgSQL_UUID        to ColumnType[i].iSQLType
94334>>>>>>>//        Move "uuid"             to ColumnType[i].sSQLType
94334>>>>>>>//        Move DF_ASCII           to ColumnType[i].iDataFlexType
94334>>>>>>>//        Move "ASCII"            to ColumnType[i].sDataFlexType
94334>>>>>>>//        Move "40"               to ColumnType[i].sPrecision
94334>>>>>>>//        Move True               to ColumnType[i].bCanEditSize
94334>>>>>>>//        Increment i
94334>>>>>>>//
94334>>>>>>>//        Move ePgSQL_VARCHAR     to ColumnType[i].iSQLType
94334>>>>>>>//        Move "varchar"          to ColumnType[i].sSQLType
94334>>>>>>>//        Move DF_TEXT            to ColumnType[i].iDataFlexType
94334>>>>>>>//        Move "DF_TEXT"          to ColumnType[i].sDataFlexType
94334>>>>>>>//        Move "16384"            to ColumnType[i].sPrecision
94334>>>>>>>//        Increment i
94334>>>>>>>
94334>>>>>>>        Function_Return aColumnType
94335>>>>>>>    End_Function
94336>>>>>>>
94336>>>>>>>    // Internal usage. Use the UtilColumnTypeXXX functions instead.
94336>>>>>>>    Function _UtilColumnType String sDriverID Integer iDbType Integer iType String sType Boolean bIntegerInputType Returns tColumnType
94338>>>>>>>        Integer iValue iSize iCount iStart
94338>>>>>>>        tColumnType[] ColumnTypeArray
94338>>>>>>>        tColumnType[] ColumnTypeArray
94339>>>>>>>        tColumnType RetvalType
94339>>>>>>>        tColumnType RetvalType
94339>>>>>>>        String sValue
94339>>>>>>>        Boolean bFrameworkDataFlexType
94339>>>>>>>
94339>>>>>>>        Move "Undefined" to RetvalType.sSQLType
94340>>>>>>>        Move -1999       to RetvalType.iSQLType
94341>>>>>>>
94341>>>>>>>        Move 0 to iStart
94342>>>>>>>        Move (Uppercase(sType)) to sType
94343>>>>>>>        Move (iType <= -1490) to bFrameworkDataFlexType
94344>>>>>>>        If (bFrameworkDataFlexType = True) Begin
94346>>>>>>>            Get UtilDUFDataTypeToSqlTypeMapping sDriverID iDbType iType to RetvalType
94347>>>>>>>            Function_Return RetvalType
94348>>>>>>>        End
94348>>>>>>>>
94348>>>>>>>
94348>>>>>>>        Get UtilEnumerateColumnTypes sDriverID iDbType to ColumnTypeArray
94349>>>>>>>
94349>>>>>>>        Move (SizeOfArray(ColumnTypeArray)) to iSize
94350>>>>>>>        Decrement iSize
94351>>>>>>>
94351>>>>>>>        for iCount from iStart to iSize
94357>>>>>>>>
94357>>>>>>>            Move ColumnTypeArray[iCount].iSQLType to iValue
94358>>>>>>>            Move ColumnTypeArray[iCount].sSQLType to sValue
94359>>>>>>>            If (bIntegerInputType = True) Begin
94361>>>>>>>                If (iValue = iType) Begin
94363>>>>>>>                    Move ColumnTypeArray[iCount].sSQLType       to RetvalType.sSQLType
94364>>>>>>>                    Move iType                                  to RetvalType.iSQLType
94365>>>>>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
94366>>>>>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
94367>>>>>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
94368>>>>>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
94369>>>>>>>                    Move iSize to iCount // We're done!
94370>>>>>>>                End
94370>>>>>>>>
94370>>>>>>>            End
94370>>>>>>>>
94370>>>>>>>            Else Begin
94371>>>>>>>                Move (Uppercase(sValue)) to sValue
94372>>>>>>>                If (sValue = sType) Begin
94374>>>>>>>                    Move sType                                  to RetvalType.sSQLType
94375>>>>>>>                    Move ColumnTypeArray[iCount].iSQLType       to RetvalType.iSQLType
94376>>>>>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
94377>>>>>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
94378>>>>>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
94379>>>>>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
94380>>>>>>>                    Move iSize to iCount // We're done!
94381>>>>>>>                End
94381>>>>>>>>
94381>>>>>>>            End
94381>>>>>>>>
94381>>>>>>>        Loop
94382>>>>>>>>
94382>>>>>>>
94382>>>>>>>        // If no match was found it was probably because it was a DataFlex standard type that was passed.
94382>>>>>>>        // In which case we search for a match in DataFlex standard types:
94382>>>>>>>        If (RetvalType.sSQLType = "Undefined") Begin
94384>>>>>>>            Get _UtilEnumerateDataFlexTypes to ColumnTypeArray
94385>>>>>>>            Move (SizeOfArray(ColumnTypeArray)) to iSize
94386>>>>>>>            Decrement iSize
94387>>>>>>>
94387>>>>>>>            for iCount from iStart to iSize
94393>>>>>>>>
94393>>>>>>>                Move ColumnTypeArray[iCount].iSQLType to iValue
94394>>>>>>>                Move ColumnTypeArray[iCount].sSQLType to sValue
94395>>>>>>>                If (iValue = iType) Begin
94397>>>>>>>                    Move ColumnTypeArray[iCount].sSQLType       to RetvalType.sSQLType
94398>>>>>>>                    Move iType                                  to RetvalType.iSQLType
94399>>>>>>>                    Move ColumnTypeArray[iCount].sDataFlexType  to RetvalType.sDataFlexType
94400>>>>>>>                    Move ColumnTypeArray[iCount].iDataFlexType  to RetvalType.iDataFlexType
94401>>>>>>>                    Move ColumnTypeArray[iCount].sPrecision     to RetvalType.sPrecision
94402>>>>>>>                    Move ColumnTypeArray[iCount].bCanEditSize   to RetvalType.bCanEditSize
94403>>>>>>>                    Move iSize to iCount // We're done!
94404>>>>>>>                End
94404>>>>>>>>
94404>>>>>>>            Loop
94405>>>>>>>>
94405>>>>>>>        End
94405>>>>>>>>
94405>>>>>>>
94405>>>>>>>        Function_Return RetvalType
94406>>>>>>>    End_Function
94407>>>>>>>
94407>>>>>>>    Function _AllTablesToConvert Returns Integer[]
94409>>>>>>>        Integer[] aTableConvertExceptions iTablesArray
94411>>>>>>>        Handle hTable
94411>>>>>>>        Integer iIndex
94411>>>>>>>        String sTableName
94411>>>>>>>        Boolean bFlexErrs
94411>>>>>>>
94411>>>>>>>        // a) Get the exception table array the developer has specified
94411>>>>>>>        Get paTableConvertExceptions to aTableConvertExceptions
94412>>>>>>>
94412>>>>>>>        // b) Add CodeMast, CodeType & DbVersion to exceptions
94412>>>>>>>        Repeat
94412>>>>>>>>
94412>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
94415>>>>>>>            If (hTable <> 0) Begin
94417>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
94420>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
94421>>>>>>>                If (bFlexErrs = False) Begin
94423>>>>>>>                    If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE" or Uppercase(sTableName) = "DBVERSION") Begin
94425>>>>>>>                        Move (SearchArray(hTable, aTableConvertExceptions)) to iIndex
94426>>>>>>>                        If (iIndex = -1) Begin
94428>>>>>>>                            Move hTable to aTableConvertExceptions[SizeOfArray(aTableConvertExceptions)]
94429>>>>>>>                        End
94429>>>>>>>>
94429>>>>>>>                    End
94429>>>>>>>>
94429>>>>>>>                End
94429>>>>>>>>
94429>>>>>>>            End
94429>>>>>>>>
94429>>>>>>>        Until (hTable = 0)
94431>>>>>>>
94431>>>>>>>        Move 0 to hTable
94432>>>>>>>
94432>>>>>>>        // c) Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
94432>>>>>>>        Repeat
94432>>>>>>>>
94432>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
94435>>>>>>>            If (hTable > 0) Begin
94437>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
94440>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
94441>>>>>>>                If (bFlexErrs = False) Begin
94443>>>>>>>                    Move (SearchArray(hTable, aTableConvertExceptions)) to iIndex
94444>>>>>>>                    If (iIndex = -1) Begin
94446>>>>>>>                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
94447>>>>>>>                    End
94447>>>>>>>>
94447>>>>>>>                End
94447>>>>>>>>
94447>>>>>>>            End
94447>>>>>>>>
94447>>>>>>>        Until (hTable = 0)
94449>>>>>>>
94449>>>>>>>        Function_Return iTablesArray
94450>>>>>>>    End_Function
94451>>>>>>>
94451>>>>>>>    Function _AllTablesDateCorrections Returns Integer[]
94453>>>>>>>        Integer[] aTableDateCorrectionExceptions iTablesArray
94455>>>>>>>        Handle hTable
94455>>>>>>>        Integer iIndex
94455>>>>>>>        String sTableName
94455>>>>>>>        Boolean bFlexErrs
94455>>>>>>>
94455>>>>>>>        Get paTableDateCorrectionExceptions to aTableDateCorrectionExceptions
94456>>>>>>>        Move 0 to hTable
94457>>>>>>>
94457>>>>>>>        // Spin through filelist.cfg and add all tables except those from the exception array, to the return array.
94457>>>>>>>        Repeat
94457>>>>>>>>
94457>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
94460>>>>>>>            If (hTable > 0) Begin
94462>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
94465>>>>>>>                Move (Uppercase(sTableName) = "FLEXERRS")  to bFlexErrs
94466>>>>>>>                If (bFlexErrs = False) Begin
94468>>>>>>>                    Move (SearchArray(hTable, aTableDateCorrectionExceptions)) to iIndex
94469>>>>>>>                    If (iIndex = -1) Begin
94471>>>>>>>                        Move hTable to iTablesArray[SizeOfArray(iTablesArray)]
94472>>>>>>>                    End
94472>>>>>>>>
94472>>>>>>>                End
94472>>>>>>>>
94472>>>>>>>            End
94472>>>>>>>>
94472>>>>>>>        Until (hTable = 0)
94474>>>>>>>
94474>>>>>>>        Function_Return iTablesArray
94475>>>>>>>    End_Function
94476>>>>>>>
94476>>>>>>>    Function _AppendAPIColumn tAPIColumn[] aCurrent String sFieldName Integer iType Integer iLength Integer iPrecision Integer iOptions Returns tAPIColumn[]
94478>>>>>>>        tAPIColumn NewAPIColumn
94478>>>>>>>        tAPIColumn NewAPIColumn
94478>>>>>>>
94478>>>>>>>        Move sFieldName to NewAPIColumn.sFieldName
94479>>>>>>>        Move iType      to NewAPIColumn.iType
94480>>>>>>>        Move iLength    to NewAPIColumn.iLength
94481>>>>>>>        Move iPrecision to NewAPIColumn.iPrecision
94482>>>>>>>        Move iOptions   to NewAPIColumn.iOptions
94483>>>>>>>
94483>>>>>>>        Move NewAPIColumn to aCurrent[SizeOfArray(aCurrent)]
94484>>>>>>>
94484>>>>>>>        Function_Return aCurrent
94485>>>>>>>    End_Function
94486>>>>>>>
94486>>>>>>>    Function _UtilIndexAppendSegmentFieldNames tAPIIndexSegment[] APIIndexSegment Returns String
94488>>>>>>>        String sRetval sFieldName
94488>>>>>>>        Integer iCount iSize
94488>>>>>>>
94488>>>>>>>        Move (SizeOfArray(APIIndexSegment)) to iSize
94489>>>>>>>        Decrement iSize
94490>>>>>>>        for iCount from 0 to iSize
94496>>>>>>>>
94496>>>>>>>            Move APIIndexSegment[iCount].sFieldName to sFieldName
94497>>>>>>>            Move (sRetval * (String(sFieldName))) to sRetval
94498>>>>>>>        Loop
94499>>>>>>>>
94499>>>>>>>        Move (Trim(sRetval)) to sRetval
94500>>>>>>>
94500>>>>>>>        Function_Return sRetval
94501>>>>>>>    End_Function
94502>>>>>>>
94502>>>>>>>    // *** Miscellaneous other functions ***
94502>>>>>>>    // Some of which can be used by both "Sqlxxx" and "Apixxx" functions.
94502>>>>>>>    //
94502>>>>>>>
94502>>>>>>>    // Callback functionality used when e.g. calling driver functions directly.
94502>>>>>>>    Function Callback String sCallback_Text Integer iCallback_Type Returns Integer
94504>>>>>>>        Integer iPerc
94504>>>>>>>        Number nReady nTotal
94504>>>>>>>
94504>>>>>>>        Send DoAdvance of ghoProgressBar
94505>>>>>>>
94505>>>>>>>        If (sCallback_Text contains "Copy records") Begin
94507>>>>>>>            Move CS_DUF_CopyingData to sCallback_Text
94508>>>>>>>        End
94508>>>>>>>>
94508>>>>>>>        If (sCallback_Text contains "Dropping index" or sCallback_Text contains "Temporary delete of all indices of table") Begin
94510>>>>>>>            Move (Replace("Dropping index", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
94511>>>>>>>            Move (Replace("Temporary delete of all indices of table", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
94512>>>>>>>        End
94512>>>>>>>>
94512>>>>>>>        If (sCallback_Text contains "Creating index") Begin
94514>>>>>>>            Move (Replace("Creating index", sCallback_Text, CS_DUF_CreatingIndex)) to sCallback_Text
94515>>>>>>>        End
94515>>>>>>>>
94515>>>>>>>
94515>>>>>>>        Case Begin
94515>>>>>>>            Case (iCallback_Type = DF_Message_Text)
94517>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
94518>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
94519>>>>>>>                Case Break
94520>>>>>>>            Case (iCallback_Type = DF_Message_Heading_1)
94523>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
94524>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
94525>>>>>>>                Case Break
94526>>>>>>>            Case (iCallback_Type = DF_Message_Heading_2)
94529>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
94530>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
94531>>>>>>>                Case Break
94532>>>>>>>            Case (iCallback_Type = DF_Message_Heading_3)
94535>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
94536>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
94537>>>>>>>                Case Break
94538>>>>>>>            Case (iCallback_Type = DF_Message_Heading_4)
94541>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
94542>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
94543>>>>>>>                Case Break
94544>>>>>>>            Case (iCallback_Type = DF_Message_Heading_5)
94547>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
94548>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
94549>>>>>>>                Case Break
94550>>>>>>>            Case (iCallback_Type = DF_Message_Warning)
94553>>>>>>>                Send None
94554>>>>>>>                Case Break
94555>>>>>>>            Case (iCallback_Type = DF_Message_Progress_Title)
94558>>>>>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
94559>>>>>>>                Set Action_Text  of ghoStatusPanel to ""
94560>>>>>>>                Case Break
94561>>>>>>>            Case (iCallback_Type = DF_Message_Progress_Value)
94564>>>>>>>                //*** Interpret numbers
94564>>>>>>>                Move (Left(sCallback_Text, (Pos(",", sCallback_Text) - 1)))                       to nReady
94565>>>>>>>                Move (Right(sCallback_Text, (Length(sCallback_Text) - Pos(",", sCallback_Text)))) to nTotal
94566>>>>>>>                Move ((nReady / nTotal) * 100)                                                    to iPerc
94567>>>>>>>                Set Action_Text of ghoStatusPanel to (String(iPerc) * String("% Done (Total Number of Records:") * String(nTotal) + ")")
94568>>>>>>>                Case Break
94569>>>>>>>            Case Else
94569>>>>>>>                Set Message_Text to ""
94570>>>>>>>                Set Action_Text  to ""
94571>>>>>>>        Case End
94571>>>>>>>
94571>>>>>>>        Send ProcessEvents of ghoStatusPanel
94572>>>>>>>        Function_Return False
94573>>>>>>>    End_Function
94574>>>>>>>
94574>>>>>>>    Procedure IncreaseSortBufferSize
94576>>>>>>>        String sNull
94576>>>>>>>        Integer iSortBufferSize
94576>>>>>>>        Boolean bBufferSet
94576>>>>>>>
94576>>>>>>>        Move "" to sNull
94577>>>>>>>        Move (1024 * 128) to iSortBufferSize
94578>>>>>>>        Call_Driver 0 DATAFLEX_ID Function FLEX_SET_MAX_SORT_BUFFER Callback ghoDbUpdateHandler Passing sNull sNull iSortBufferSize Result bBufferSet
94583>>>>>>>
94583>>>>>>>    End_Procedure
94584>>>>>>>
94584>>>>>>>    Procedure SetAllIndexesToBatch Handle hTable Boolean bSetToBatch
94586>>>>>>>        Integer iLastIndex iIndex iNumSegments
94586>>>>>>>        Boolean bOK
94586>>>>>>>        String sDriverID
94586>>>>>>>
94586>>>>>>>        If (hTable > 0) Begin
94588>>>>>>>            Get UtilDriverFromTableNumber hTable to sDriverID
94589>>>>>>>            Close hTable
94590>>>>>>>            Get OpenTableExclusive hTable to bOK
94591>>>>>>>            If (bOK = False) Begin
94593>>>>>>>                Procedure_Return
94594>>>>>>>            End
94594>>>>>>>>
94594>>>>>>>            Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTable to iLastIndex
94597>>>>>>>            Structure_Start hTable sDriverID
94598>>>>>>>                for iIndex from 1 to iLastIndex
94604>>>>>>>>
94604>>>>>>>                    Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTable iIndex to iNumSegments
94607>>>>>>>                    If (iNumSegments > 0) Begin
94609>>>>>>>                        If (bSetToBatch = True) Begin
94611>>>>>>>                            Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_BATCH
94614>>>>>>>                        End
94614>>>>>>>>
94614>>>>>>>                        Else Begin
94615>>>>>>>                            Set_Attribute DF_INDEX_TYPE of hTable iIndex to DF_INDEX_TYPE_ONLINE
94618>>>>>>>                        End
94618>>>>>>>>
94618>>>>>>>                    End
94618>>>>>>>>
94618>>>>>>>                Loop
94619>>>>>>>>
94619>>>>>>>            Structure_End hTable DF_STRUCTEND_OPT_NONE "." ghoDbUpdateHandler
94621>>>>>>>        End
94621>>>>>>>>
94621>>>>>>>    End_Procedure
94622>>>>>>>
94622>>>>>>>    Function NextFreeFilelistSlot Returns Handle
94624>>>>>>>        Handle hTable
94624>>>>>>>
94624>>>>>>>        Move 0 to hTable
94625>>>>>>>        Get_Attribute DF_FILE_NEXT_EMPTY of hTable to hTable
94628>>>>>>>
94628>>>>>>>        Function_Return hTable
94629>>>>>>>    End_Function
94630>>>>>>>
94630>>>>>>>    // For debugging purposes. To print Sql statements as they are build...
94630>>>>>>>    Procedure DebugPrint String sStmt String sFileName
94632>>>>>>>        Integer iCh
94632>>>>>>>        Get Seq_Append_Output_Channel sFileName to iCh
94633>>>>>>>            Write channel iCh sStmt
94635>>>>>>>        Send Seq_Close_Channel iCh
94636>>>>>>>    End_Procedure
94637>>>>>>>
94637>>>>>>>    // Returns the integer number for the passed Driver ID that is
94637>>>>>>>    // needed by some database API calls.
94637>>>>>>>    Function DriverIndex String sDriverID Returns Integer
94639>>>>>>>        String  sCurrentDriver
94639>>>>>>>        Integer iNumberOfDrivers iDriver iCount
94639>>>>>>>
94639>>>>>>>        Move 0 to iDriver
94640>>>>>>>
94640>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
94643>>>>>>>        for iCount from 1 to iNumberOfDrivers
94649>>>>>>>>
94649>>>>>>>
94649>>>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
94652>>>>>>>            If ( Uppercase(sCurrentDriver) = Uppercase(sDriverID) ) Begin
94654>>>>>>>                Move iCount to iDriver
94655>>>>>>>            End
94655>>>>>>>>
94655>>>>>>>        Loop
94656>>>>>>>>
94656>>>>>>>
94656>>>>>>>        // In case it was not found, it wasn't loaded so we do that now.
94656>>>>>>>        If (iDriver = 0) Begin
94658>>>>>>>            Move False to Err
94659>>>>>>>            Load_Driver sDriverID
94660>>>>>>>            If (Err = False) Begin
94662>>>>>>>                Get_Attribute DF_NUMBER_DRIVERS to iDriver
94665>>>>>>>            End
94665>>>>>>>>
94665>>>>>>>        End
94665>>>>>>>>
94665>>>>>>>
94665>>>>>>>        Function_Return iDriver
94666>>>>>>>    End_Function
94667>>>>>>>
94667>>>>>>>    
94667>>>>>>>    Function MinMSSQLDRV_And_ClientVersion String sMSSQLDRVVersion Integer iClientVersion Boolean bShowErrorDialog Boolean bExitProgram Returns String
94669>>>>>>>        String sDriverID sVersion sClient sClientLowest sRetval
94669>>>>>>>        Integer iNumberOfDrivers iDriver iClient
94669>>>>>>>        Handle hoCLIHandler hoMSSQLHandler   
94669>>>>>>>        Boolean bOK
94669>>>>>>>        
94669>>>>>>>        Move "" to sRetval
94670>>>>>>>        Get Create (RefClass(cCLIHandler)) to hoCLIHandler
94671>>>>>>>        Get Create (RefClass(cMSSQLHandler)) to hoMSSQLHandler
94672>>>>>>>        Load_Driver MSSQLDRV_ID
94673>>>>>>>
94673>>>>>>>        // Loop through all loaded drivers.
94673>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
94676>>>>>>>        For iDriver from 1 to iNumberOfDrivers
94682>>>>>>>>
94682>>>>>>>            Get_Attribute DF_DRIVER_NAME of iDriver to sDriverID
94685>>>>>>>            If (sDriverID = MSSQLDRV_ID) Begin
94687>>>>>>>                Set psDriverID of hoCLIHandler to sDriverID
94688>>>>>>>                Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClient   
94691>>>>>>>                Get SqlServerClientVersionName of hoMSSQLHandler iClientVersion to sClientLowest 
94692>>>>>>>                Get SqlServerClientVersionName of hoMSSQLHandler iClient to sClient 
94693>>>>>>>                Get CKRevision of hoCLIHandler to sVersion
94694>>>>>>>                Move (SFormat (String(C_$DatabaseDriver), (sDriverID * "-" * (String(C_$Version) + ": " + String(sVersion))))) to sRetval
94695>>>>>>>                If (sClient <> "" and sRetval <> "") Begin
94697>>>>>>>                    Move (String(sRetval) + "\n" + String(C_$SQL_Client_Text) + "\n" + Trim(sClient)) to sRetval
94698>>>>>>>                End                                
94698>>>>>>>>
94698>>>>>>>                Else Begin
94699>>>>>>>                    Move (String(C_$SQL_Client_Text) + "\n" + Trim(sClient) * "(" + String(iClient) + ")") to sRetval
94700>>>>>>>                End
94700>>>>>>>>
94700>>>>>>>            End
94700>>>>>>>>
94700>>>>>>>        Loop
94701>>>>>>>>
94701>>>>>>>        Send Destroy of hoCLIHandler  
94702>>>>>>>        Send Destroy of hoMSSQLHandler  
94703>>>>>>>        If (bShowErrorDialog = True) Begin
94705>>>>>>>            Get IsFirstStringGreaterThanSecond sVersion sMSSQLDRVVersion to bOK
94706>>>>>>>            If (bOK = False or (iClient < iClientVersion)) Begin
94708>>>>>>>                Move (MSSQLDRV_ID + ".dll" * String(C_$SQL_Driver_Version_Min_Text) *  String(sMSSQLDRVVersion) + String("\n") + String(C_$SQL_Client_Version_Min_Text) + "\n" + String(sClientLowest) + String("\n\n") + String(C_$SQL_Versions_Are_Text) + String("\n") + String(sRetval)) to sRetval
94709>>>>>>>                If (bExitProgram = True) Begin
94711>>>>>>>                    Move (String(sRetval) + String("\n\n") + String(C_$PleaseAdjustTxt) * String(C_$ProgramWillExit_Text)) to sRetval
94712>>>>>>>                End
94712>>>>>>>>
94712>>>>>>>                Send Stop_Box sRetval  
94713>>>>>>>                If (bExitProgram = True) Begin
94715>>>>>>>                    Send Exit_Application
94716>>>>>>>                End
94716>>>>>>>>
94716>>>>>>>            End
94716>>>>>>>>
94716>>>>>>>        End
94716>>>>>>>>
94716>>>>>>>        
94716>>>>>>>        Function_Return sRetval
94717>>>>>>>    End_Function  
94718>>>>>>>    
94718>>>>>>>    // Returns True if first "." separated string is greater than the second.
94718>>>>>>>    // It checks from left to right, one part of the string at a time.
94718>>>>>>>    // E.g. if sVersion="20.1.31.10 and sSQLVersion="6.3.0.13" the function would return TRUE.
94718>>>>>>>    Function IsFirstStringGreaterThanSecond Global String sVersion String sSQLVersion Returns Boolean
94720>>>>>>>        String[] asVersion asSQLVersion          
94722>>>>>>>        Integer iSize iCount iVersion iSQLVersion
94722>>>>>>>        
94722>>>>>>>        Move (StrSplitToArray(sVersion, "."))    to asVersion
94723>>>>>>>        Move (StrSplitToArray(sSQLVersion, ".")) to asSQLVersion
94724>>>>>>>        Move (SizeOfArray(asVersion)) to iSize
94725>>>>>>>        // Make sure the two arrays are of the same size:
94725>>>>>>>        If (SizeOfArray(asSQLVersion) < iSize) Begin
94727>>>>>>>            Move (ResizeArray(asSQLVersion, iSize, 0)) to asSQLVersion
94728>>>>>>>        End
94728>>>>>>>>
94728>>>>>>>        Decrement iSize
94729>>>>>>>        for iCount from 0 to iSize
94735>>>>>>>>
94735>>>>>>>            Move asVersion[iCount]    to iVersion
94736>>>>>>>            Move asSQLVersion[iCount] to iSQLVersion
94737>>>>>>>            CompilerWarnings Off
94737>>>>>>>            If (iVersion > iSQLVersion) Break
94740>>>>>>>            CompilerWarnings On
94740>>>>>>>        Loop
94741>>>>>>>>
94741>>>>>>>        
94741>>>>>>>        Function_Return (iVersion > iSQLVersion)
94742>>>>>>>    End_Function
94743>>>>>>>
94743>>>>>>>    // Returns TRUE if table is opened exclusive, otherwise FALSE
94743>>>>>>>    // Note: If run from the Studio, CodeMast & CodeType _is_ open by the Studio,
94743>>>>>>>    //       so in that case we "cheat" and report those tables were opened OK.
94743>>>>>>>    Function OpenTableExclusive Handle hTable Returns Boolean
94745>>>>>>>        Integer iMode
94745>>>>>>>        Boolean bOpened
94745>>>>>>>        String sTableName
94745>>>>>>>
94745>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
94746>>>>>>>        // Can't open a table properly if run through the Debugger/Studio,
94746>>>>>>>        // so we generate an error here:
94746>>>>>>>        If (IsDebuggerPresent()) Begin
94748>>>>>>>            Error DFERR_OPERATOR "It is not possible to make structural changes to the database when running through the Debugger/Studio"
94749>>>>>>>>
94749>>>>>>>            Set Error_Report_Mode to DUF_ERROR_REPORT
94750>>>>>>>            Function_Return False
94751>>>>>>>        End
94751>>>>>>>>
94751>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
94754>>>>>>>        If (bOpened) Begin
94756>>>>>>>            If (IsDebuggerPresent()) Begin
94758>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
94761>>>>>>>                If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE") Begin
94763>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
94764>>>>>>>                    Function_Return True
94765>>>>>>>                End
94765>>>>>>>>
94765>>>>>>>            End
94765>>>>>>>>
94765>>>>>>>            Get_Attribute DF_FILE_OPEN_MODE of hTable to iMode
94768>>>>>>>            If (iMode=DF_EXCLUSIVE) Begin
94770>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
94771>>>>>>>                Function_Return True
94772>>>>>>>            End
94772>>>>>>>>
94772>>>>>>>            Close hTable
94773>>>>>>>        End
94773>>>>>>>>
94773>>>>>>>        Else Begin
94774>>>>>>>            Open hTable
94776>>>>>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpened
94779>>>>>>>            If (bOpened and IsDebuggerPresent()) Begin
94781>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of hTable to sTableName
94784>>>>>>>                If (Uppercase(sTableName) = "CODEMAST" or Uppercase(sTableName) = "CODETYPE") Begin
94786>>>>>>>                    Set Error_Report_Mode to DUF_ERROR_REPORT
94787>>>>>>>                    Function_Return True
94788>>>>>>>                End
94788>>>>>>>>
94788>>>>>>>            End
94788>>>>>>>>
94788>>>>>>>
94788>>>>>>>        End
94788>>>>>>>>
94788>>>>>>>
94788>>>>>>>        Close hTable
94789>>>>>>>        Open hTable Mode DF_EXCLUSIVE
94791>>>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
94794>>>>>>>
94794>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
94795>>>>>>>        Function_Return bOpened
94796>>>>>>>    End_Function
94797>>>>>>>
94797>>>>>>>    Function AutoConnectionIDLogin Returns Boolean
94799>>>>>>>        String sConnectionID sConnectionString sDriverID
94799>>>>>>>        Boolean bExists bOK bSQLDriver bMertech
94799>>>>>>>        Handle hoCLI hoDriver
94799>>>>>>>        Integer iRetval
94799>>>>>>>        tSQLConnection SQLConnection
94799>>>>>>>        tSQLConnection SQLConnection
94799>>>>>>>
94799>>>>>>>        Get psDriverID to sDriverID
94800>>>>>>>        Get IsSQLDriver sDriverID to bSQLDriver
94801>>>>>>>        If (bSQLDriver = False) Begin
94803>>>>>>>            Function_Return True
94804>>>>>>>        End
94804>>>>>>>>
94804>>>>>>>
94804>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
94805>>>>>>>        Move SQLConnection.sDriverID                  to sDriverID
94806>>>>>>>        Move SQLConnection.sConnectionString          to sConnectionString
94807>>>>>>>        Get IsMertechDriver sDriverID to bMertech
94808>>>>>>>        If (bMertech = True) Begin
94810>>>>>>>            Get _MertechSQLManagerHandle to hoCLI
94811>>>>>>>            Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
94812>>>>>>>            Set psDriverID of hoDriver to SQLConnection.sDriverID
94813>>>>>>>            Get DbLogin  of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
94814>>>>>>>            Send Destroy of hoDriver
94815>>>>>>>            Function_Return bOK
94816>>>>>>>        End
94816>>>>>>>>
94816>>>>>>>
94816>>>>>>>        Move SQLConnection.sConnectionID to sConnectionID
94817>>>>>>>
94817>>>>>>>        Get IsConnectionID sConnectionID sDriverID to bExists
94818>>>>>>>        If (bExists = False) Begin
94820>>>>>>>            // We always start by deleting the current connection - if any - because the
94820>>>>>>>            // login details my have changed.
94820>>>>>>>            Get phoCLIHandler to hoCLI
94821>>>>>>>            Set psDriverID    of hoCLI to sDriverID
94822>>>>>>>            Get DeleteConnectionID of hoCLI sConnectionID -1 to iRetval
94823>>>>>>>            Get AutoSetConnectionID sConnectionID to bOk
94824>>>>>>>            If (bOk = False) Begin
94826>>>>>>>                Error DFERR_PROGRAM ("The Connection ID:" * sConnectionID * "could not be created and therefor the table can't be changed.")
94827>>>>>>>>
94827>>>>>>>                Function_Return False
94828>>>>>>>            End
94828>>>>>>>>
94828>>>>>>>            Move bOK to bExists
94829>>>>>>>        End
94829>>>>>>>>
94829>>>>>>>
94829>>>>>>>        Get Create (RefClass(cDbUpdateDatabaseDriver)) to hoDriver
94830>>>>>>>        Set psDriverID of hoDriver to SQLConnection.sDriverID
94831>>>>>>>        Get DbLogin of hoDriver sConnectionString SQLConnection.sServer SQLConnection.sDatabase SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to bOK
94832>>>>>>>        Send Destroy of hoDriver
94833>>>>>>>
94833>>>>>>>        Function_Return (bExists = True)
94834>>>>>>>    End_Function
94835>>>>>>>
94835>>>>>>>    // Scans to see if all tables can be opened exclusivly. I.e. that nobody else is running the application.
94835>>>>>>>    // Returns: False if nobody else is running
94835>>>>>>>    //          True if at least one table is open by another process (e.g. another user is running the application)
94835>>>>>>>    // N.B! Only works for Embedded DataFlex Tables! It will _not_ work for Sql tables because; these
94835>>>>>>>    //      tables are not locked as DataFlex tables are.
94835>>>>>>>    Function IsDatabaseInUse Returns Boolean
94837>>>>>>>        Handle  hTable
94837>>>>>>>        String  sRootName
94837>>>>>>>        Boolean bOpen bErr bAlias bOK bIsSQLTable bFlexErrs bExists
94837>>>>>>>        Integer iCount iTables
94837>>>>>>>
94837>>>>>>>        Move 0 to iTables
94838>>>>>>>        Set Action_Text of ghoStatusPanel to "Database in use check..."
94839>>>>>>>        Get AutoConnectionIDLogin to bOK
94840>>>>>>>        Get UtilFilelistNoOfTables to iTables
94841>>>>>>>        Set piPosition   of ghoProgressBar to 0
94842>>>>>>>        Set piAdvanceBy  of ghoProgressBar to 1
94843>>>>>>>        Set piMaximum    of ghoProgressBar to iTables
94844>>>>>>>        Move 0 to hTable
94845>>>>>>>        Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
94848>>>>>>>        Move False to bErr
94849>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
94850>>>>>>>
94850>>>>>>>        Repeat
94850>>>>>>>>
94850>>>>>>>            Set piPosition of ghoProgressBar to iCount
94851>>>>>>>            Increment iCount
94852>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
94855>>>>>>>            Move (Uppercase(sRootName) = "FLEXERRS")  to bFlexErrs
94856>>>>>>>
94856>>>>>>>            // This test is only applicable for DataFlex embedded tables; so skip test if driver based table.
94856>>>>>>>            Get UtilTableIsSQLByRootName sRootName to bIsSQLTable
94857>>>>>>>            Move False to bOpen
94858>>>>>>>            Get UtilTableExists hTable to bExists
94859>>>>>>>            // Don't bother about CodeType (253, CodeMast (254) or) FlexErrs (Normally table 50)
94859>>>>>>>            If (bIsSQLTable = False and bExists = True and hTable <> 0 and hTable <> 253 and hTable <> 254 and bFlexErrs = False) Begin
94861>>>>>>>                Set Error_Report_Mode to DUF_ERROR_NO_REPORT
94862>>>>>>>                Open hTable
94864>>>>>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
94867>>>>>>>                Set Error_Report_Mode to DUF_ERROR_REPORT
94868>>>>>>>                If (bOpen = True) Begin
94870>>>>>>>                    // We cannot open an Alias file exclusive as it will generate an error (4177 - "File in use")
94870>>>>>>>                    Get UtilTableIsAlias hTable to bAlias
94871>>>>>>>                    If (bAlias = False) Begin
94873>>>>>>>                        Close hTable
94874>>>>>>>                        Get OpenTableExclusive hTable to bOpen
94875>>>>>>>                        If (bOpen = False) Begin
94877>>>>>>>                            Move True to bErr
94878>>>>>>>                        End
94878>>>>>>>>
94878>>>>>>>                    End
94878>>>>>>>>
94878>>>>>>>                End
94878>>>>>>>>
94878>>>>>>>                Close hTable
94879>>>>>>>            End
94879>>>>>>>>
94879>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
94882>>>>>>>            If (bErr = True ) ;                Break
94885>>>>>>>        Until (not(hTable))
94887>>>>>>>
94887>>>>>>>        Set Action_Text of ghoStatusPanel to ""
94888>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_FILE_ACCESS_VIOLATION
94889>>>>>>>        Move False to Err
94890>>>>>>>
94890>>>>>>>        Function_Return bErr
94891>>>>>>>    End_Function
94892>>>>>>>
94892>>>>>>>    // Checks if the passed connection id exists in the CLI interface.
94892>>>>>>>    // This might be needed by API-methods when a connection id is to be used and
94892>>>>>>>    // the connection id hasn't been established with the driver's CLI interface.
94892>>>>>>>    // NOTE: Only applicable for DAW drivers.
94892>>>>>>>    Function IsConnectionID String sConnectionID String sDriverID Returns Boolean
94894>>>>>>>        String sID sConnString
94894>>>>>>>        Integer iDriver iNumConn iCount
94894>>>>>>>        Handle hoCLI
94894>>>>>>>        Boolean bOK
94894>>>>>>>
94894>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
94895>>>>>>>        If (bOK = False) Begin
94897>>>>>>>            Error DFERR_PROGRAM "Connection ID's can only be used with DAW drivers (not Mertech)."
94898>>>>>>>>
94898>>>>>>>            Function_Return False
94899>>>>>>>        End
94899>>>>>>>>
94899>>>>>>>
94899>>>>>>>        Move False to bOK
94900>>>>>>>        Get phoCLIHandler to hoCLI
94901>>>>>>>        If (hoCLI <> 0) Begin
94903>>>>>>>            Set psDriverID of hoCLI to sDriverID
94904>>>>>>>            Get DriverIndex of hoCLI sDriverID to iDriver
94905>>>>>>>
94905>>>>>>>            // If driver not loaded; load it.
94905>>>>>>>            If (iDriver = 0) Begin
94907>>>>>>>                Load_Driver sDriverID
94908>>>>>>>                Get DriverIndex sDriverID to iDriver
94909>>>>>>>            End
94909>>>>>>>>
94909>>>>>>>            If (iDriver <> 0) Begin
94911>>>>>>>                Get_Attribute DF_DRIVER_NUMBER_CONNECTION_IDS of iDriver to iNumConn
94914>>>>>>>                Decrement iNumConn
94915>>>>>>>                for iCount from 0 to iNumConn
94921>>>>>>>>
94921>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID_STRING of iDriver iCount to sConnString
94924>>>>>>>                    Get_Attribute DF_DRIVER_CONNECTION_ID of iDriver iCount to sID
94927>>>>>>>                    If (sID = sConnectionID) Begin
94929>>>>>>>                        Move True to bOK
94930>>>>>>>                    End
94930>>>>>>>>
94930>>>>>>>                Loop
94931>>>>>>>>
94931>>>>>>>            End
94931>>>>>>>>
94931>>>>>>>        End
94931>>>>>>>>
94931>>>>>>>
94931>>>>>>>        Function_Return bOK
94932>>>>>>>    End_Function
94933>>>>>>>
94933>>>>>>>    Function IsDAWSQLDriver String sDriverID Returns Boolean
94935>>>>>>>        Boolean bOK
94935>>>>>>>        Move (sDriverID = MSSQLDRV_ID or sDriverID = DB2_DRV_ID or sDriverID = ODBC_DRV_ID or sDriverID = DFBTRDRV_ID) to bOK
94936>>>>>>>        Function_Return bOK
94937>>>>>>>    End_Function
94938>>>>>>>
94938>>>>>>>    Function IsMertechDriver String sDriverID Returns Boolean
94940>>>>>>>        Boolean bOK
94940>>>>>>>        Move False to bOK
94941>>>>>>>        Move (sDriverID = SQLFLEX or sDriverID = ORAFLEX or sDriverID = MDSPgSQL or sDriverID = MDSMySQL) to bOK
94942>>>>>>>        Function_Return bOK
94943>>>>>>>    End_Function
94944>>>>>>>
94944>>>>>>>    Function IsMSSQLDriver Returns Boolean
94946>>>>>>>        Integer iDriverIndex
94946>>>>>>>
94946>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriverIndex
94947>>>>>>>
94947>>>>>>>        Function_Return (iDriverIndex <> 0)
94948>>>>>>>    End_Function
94949>>>>>>>
94949>>>>>>>    // Similar to _SqlCheckCurrentDriver but generates no error and it doesn't
94949>>>>>>>    // attempt to load the driver.
94949>>>>>>>    // Returns true if the passed driver is SQL based.
94949>>>>>>>    Function IsSQLDriver String sDriverID Returns Boolean
94951>>>>>>>        Boolean bOK
94951>>>>>>>
94951>>>>>>>        Get IsDAWSQLDriver sDriverID to bOK
94952>>>>>>>
94952>>>>>>>        If (bOK = False) Begin
94954>>>>>>>            Get IsMertechDriver sDriverID to bOK
94955>>>>>>>        End
94955>>>>>>>>
94955>>>>>>>
94955>>>>>>>        Function_Return bOK
94956>>>>>>>    End_Function
94957>>>>>>>
94957>>>>>>>    // *** Error Handler ***
94957>>>>>>>    //
94957>>>>>>>    // Note: If the cDbUpdateHandler & cDbUpdateVersion classes are used this error handler is _not_
94957>>>>>>>    //       used. Instead the Error_Report in the cDbUpdateHandler i used.
94957>>>>>>>    Procedure Error_Report Integer iErrorNumber Integer iErrorLine String sErrorText
94959>>>>>>>        Integer iSize iErrorMode
94959>>>>>>>        tSqlErrorArray aSqlErrorArray
94959>>>>>>>        tSqlErrorArray aSqlErrorArray
94959>>>>>>>
94959>>>>>>>        If (pbProcessingError(Self)) Begin
94961>>>>>>>            Procedure_Return
94962>>>>>>>        End
94962>>>>>>>>
94962>>>>>>>
94962>>>>>>>        Get Error_Report_Mode to iErrorMode
94963>>>>>>>        If (iErrorMode = DUF_ERROR_NO_REPORT) Begin
94965>>>>>>>            Procedure_Return
94966>>>>>>>        End
94966>>>>>>>>
94966>>>>>>>
94966>>>>>>>        Set pbProcessingError to True
94967>>>>>>>        Set pbSqlError to True
94968>>>>>>>        Get paSqlErrorArray      to aSqlErrorArray
94969>>>>>>>        Move (SizeOfArray(aSqlErrorArray.sSqlErrorArray)) to iSize
94970>>>>>>>        Move sErrorText          to aSqlErrorArray.sSqlErrorArray[iSize]
94971>>>>>>>        Get psSQLStatementString to aSqlErrorArray.sSqlStatementArray[iSize]
94972>>>>>>>        Move iErrorNumber        to aSqlErrorArray.iSqlErrorArray[iSize]
94973>>>>>>>        Set paSqlErrorArray      to aSqlErrorArray
94974>>>>>>>        Set pbProcessingError to False
94975>>>>>>>    End_Procedure
94976>>>>>>>
94976>>>>>>>    // *** Miscellanous Helper Functions ***
94976>>>>>>>    //
94976>>>>>>>    // Helper function. Takes a DF_FILE_XXXX_NAME value as parameter and
94976>>>>>>>    // returns the table name only; stripped of any path or filename extension.
94976>>>>>>>    Function _TableNameOnly String sName Returns String
94978>>>>>>>        String sPath sExt
94978>>>>>>>
94978>>>>>>>        Get ParseFolderName sName to sPath
94979>>>>>>>        If (sPath <> "") Begin
94981>>>>>>>            Move (Replace(sPath, sName, "")) to sName
94982>>>>>>>        End
94982>>>>>>>>
94982>>>>>>>        Get ParseFileExtension sName to sExt
94983>>>>>>>        If (sExt <> "") Begin
94985>>>>>>>            Move (Replace(("." + sExt), sName, "")) to sName
94986>>>>>>>        End
94986>>>>>>>>
94986>>>>>>>
94986>>>>>>>        Function_Return sName
94987>>>>>>>    End_Function
94988>>>>>>>
94988>>>>>>>    // Removes any prefix to a table name.
94988>>>>>>>    // Example mssqldrv:mytable returns mytable
94988>>>>>>>    //         dbo.mytable returns mytable
94988>>>>>>>    Function _TableNoPrefix String sName Returns String
94990>>>>>>>        Integer iPos
94990>>>>>>>
94990>>>>>>>        Move (Pos(":", sName)) to iPos
94991>>>>>>>        If (iPos <> 0) Begin
94993>>>>>>>            Move (Mid(sName, 999, (iPos + 1))) to sName
94994>>>>>>>        End
94994>>>>>>>>
94994>>>>>>>        Move (Pos(".", sName)) to iPos
94995>>>>>>>        If (iPos <> 0) Begin
94997>>>>>>>            Move (Mid(sName, 999, (iPos + 1))) to sName
94998>>>>>>>        End
94998>>>>>>>>
94998>>>>>>>
94998>>>>>>>        Function_Return sName
94999>>>>>>>    End_Function
95000>>>>>>>
95000>>>>>>>    // Returns the first datapath found in the psDataPath property.
95000>>>>>>>    // The returned path always ends with a "\"
95000>>>>>>>    Function psDataPathFirstPart Returns String
95002>>>>>>>        String sDataPath
95002>>>>>>>        Integer iCount
95002>>>>>>>
95002>>>>>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
95003>>>>>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sDataPath to iCount
95004>>>>>>>        If (iCount > 1) Begin
95006>>>>>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sDataPath 1 to sDataPath
95007>>>>>>>        End
95007>>>>>>>>
95007>>>>>>>        If (sDataPath <> "") Begin
95009>>>>>>>            Get vFolderFormat sDataPath to sDataPath
95010>>>>>>>        End
95010>>>>>>>>
95010>>>>>>>
95010>>>>>>>        Function_Return sDataPath
95011>>>>>>>    End_Function
95012>>>>>>>
95012>>>>>>>    Function psLogTextFileWithPath Returns String
95014>>>>>>>        String sFileName
95014>>>>>>>        Handle hoLogFile
95014>>>>>>>        Get phoLogFile to hoLogFile
95015>>>>>>>        Get psLogTextFileWithPath of hoLogFile to sFileName
95016>>>>>>>        Function_Return sFileName
95017>>>>>>>    End_Function
95018>>>>>>>
95018>>>>>>>    // *** Property Messages ***
95018>>>>>>>    //
95018>>>>>>>    // These "properties" are settings for the cSQLConnectionHandler class, but have been
95018>>>>>>>    // "duplicated" here so connection properties can be relayed to the ghoSQLConnectionHandler object
95018>>>>>>>    //
95018>>>>>>>
95018>>>>>>>    Function pSQLConnection Returns tSQLConnection
95020>>>>>>>        tSQLConnection SQLConnection
95020>>>>>>>        tSQLConnection SQLConnection
95020>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95022>>>>>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
95022>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95023>>>>>>>>
95023>>>>>>>            Function_Return
95024>>>>>>>        End
95024>>>>>>>>
95024>>>>>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
95025>>>>>>>        Function_Return SQLConnection
95026>>>>>>>    End_Function
95027>>>>>>>
95027>>>>>>>    // * Dummy function for the Studio's Code Explorer *
95027>>>>>>>    Function OTHER_CLASS_PROPERTIES Returns Boolean
95029>>>>>>>        Function_Return False
95030>>>>>>>    End_Function
95031>>>>>>>
95031>>>>>>>    Procedure Set psServer String sValue
95033>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95035>>>>>>>            // Note: No point in translating as the programmer will see this immediately after compiling the program...
95035>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95036>>>>>>>>
95036>>>>>>>            Procedure_Return
95037>>>>>>>        End
95037>>>>>>>>
95037>>>>>>>        Set psServer of ghoSQLConnectionHandler to sValue
95038>>>>>>>    End_Procedure
95039>>>>>>>
95039>>>>>>>    Function psServer Returns String
95041>>>>>>>        String sValue
95041>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95043>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95044>>>>>>>>
95044>>>>>>>            Function_Return
95045>>>>>>>        End
95045>>>>>>>>
95045>>>>>>>        Get psServer of ghoSQLConnectionHandler to sValue
95046>>>>>>>        Function_Return sValue
95047>>>>>>>    End_Function
95048>>>>>>>
95048>>>>>>>    Procedure Set psDatabase String sValue
95050>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95052>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95053>>>>>>>>
95053>>>>>>>            Procedure_Return
95054>>>>>>>        End
95054>>>>>>>>
95054>>>>>>>        Set psDatabase of ghoSQLConnectionHandler to sValue
95055>>>>>>>    End_Procedure
95056>>>>>>>
95056>>>>>>>    Function psDatabase Returns String
95058>>>>>>>        String sValue
95058>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95060>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95061>>>>>>>>
95061>>>>>>>            Function_Return
95062>>>>>>>        End
95062>>>>>>>>
95062>>>>>>>        Get psDatabase of ghoSQLConnectionHandler to sValue
95063>>>>>>>        Function_Return sValue
95064>>>>>>>    End_Function
95065>>>>>>>
95065>>>>>>>    Procedure Set psUserID String sValue
95067>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95069>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95070>>>>>>>>
95070>>>>>>>            Procedure_Return
95071>>>>>>>        End
95071>>>>>>>>
95071>>>>>>>        Set psUserID of ghoSQLConnectionHandler to sValue
95072>>>>>>>    End_Procedure
95073>>>>>>>
95073>>>>>>>    Function psUserID Returns String
95075>>>>>>>        String sValue
95075>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95077>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95078>>>>>>>>
95078>>>>>>>            Function_Return
95079>>>>>>>        End
95079>>>>>>>>
95079>>>>>>>        Get psUserID of ghoSQLConnectionHandler to sValue
95080>>>>>>>        Function_Return sValue
95081>>>>>>>    End_Function
95082>>>>>>>
95082>>>>>>>    Procedure Set psPassword String sValue
95084>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95086>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95087>>>>>>>>
95087>>>>>>>            Procedure_Return
95088>>>>>>>        End
95088>>>>>>>>
95088>>>>>>>        Set psPassword of ghoSQLConnectionHandler to sValue
95089>>>>>>>    End_Procedure
95090>>>>>>>
95090>>>>>>>    Function psPassword Returns String
95092>>>>>>>        String sValue
95092>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95094>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95095>>>>>>>>
95095>>>>>>>            Function_Return
95096>>>>>>>        End
95096>>>>>>>>
95096>>>>>>>        Get psPassword of ghoSQLConnectionHandler to sValue
95097>>>>>>>        Function_Return sValue
95098>>>>>>>    End_Function
95099>>>>>>>
95099>>>>>>>    Procedure Set pbTrusted Boolean bValue
95101>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95103>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95104>>>>>>>>
95104>>>>>>>            Procedure_Return
95105>>>>>>>        End
95105>>>>>>>>
95105>>>>>>>        Set pbTrusted of ghoSQLConnectionHandler to bValue
95106>>>>>>>    End_Procedure
95107>>>>>>>
95107>>>>>>>    Function pbTrusted Returns Boolean
95109>>>>>>>        Boolean bValue
95109>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95111>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95112>>>>>>>>
95112>>>>>>>            Function_Return
95113>>>>>>>        End
95113>>>>>>>>
95113>>>>>>>        Get pbTrusted of ghoSQLConnectionHandler to bValue
95114>>>>>>>        Function_Return bValue
95115>>>>>>>    End_Function
95116>>>>>>>
95116>>>>>>>    Procedure Set pbSilentLogin Boolean bValue
95118>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95120>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95121>>>>>>>>
95121>>>>>>>            Procedure_Return
95122>>>>>>>        End
95122>>>>>>>>
95122>>>>>>>        Set pbSilentLogin of ghoSQLConnectionHandler to bValue
95123>>>>>>>    End_Procedure
95124>>>>>>>
95124>>>>>>>    Function pbSilentLogin Returns Boolean
95126>>>>>>>        Boolean bValue
95126>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95128>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95129>>>>>>>>
95129>>>>>>>            Function_Return
95130>>>>>>>        End
95130>>>>>>>>
95130>>>>>>>        Get pbSilentLogin of ghoSQLConnectionHandler to bValue
95131>>>>>>>        Function_Return bValue
95132>>>>>>>    End_Function
95133>>>>>>>
95133>>>>>>>    Procedure Set psConnectionID String sValue
95135>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95137>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95138>>>>>>>>
95138>>>>>>>            Procedure_Return
95139>>>>>>>        End
95139>>>>>>>>
95139>>>>>>>        Set psConnectionID of ghoSQLConnectionHandler to sValue
95140>>>>>>>    End_Procedure
95141>>>>>>>
95141>>>>>>>    Function psConnectionID Returns String
95143>>>>>>>        String sValue
95143>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95145>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95146>>>>>>>>
95146>>>>>>>            Function_Return
95147>>>>>>>        End
95147>>>>>>>>
95147>>>>>>>        Get psConnectionID of ghoSQLConnectionHandler to sValue
95148>>>>>>>        Function_Return sValue
95149>>>>>>>    End_Function
95150>>>>>>>
95150>>>>>>>    Procedure Set psConnectionString String sValue
95152>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95154>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95155>>>>>>>>
95155>>>>>>>            Procedure_Return
95156>>>>>>>        End
95156>>>>>>>>
95156>>>>>>>        Set psConnectionString of ghoSQLConnectionHandler to sValue
95157>>>>>>>    End_Procedure
95158>>>>>>>
95158>>>>>>>    Function psConnectionString Returns String
95160>>>>>>>        String sValue
95160>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95162>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95163>>>>>>>>
95163>>>>>>>            Function_Return
95164>>>>>>>        End
95164>>>>>>>>
95164>>>>>>>        Get psConnectionString of ghoSQLConnectionHandler to sValue
95165>>>>>>>        Function_Return sValue
95166>>>>>>>    End_Function
95167>>>>>>>
95167>>>>>>>    // The normal connection string looks something like this;
95167>>>>>>>    // SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
95167>>>>>>>    // ...and the full connection string looks like this;
95167>>>>>>>    // DFConnectionId OrderEntry, SERVER=.\SQLEXPRESS; DATABASE=OrderEntry; TRUSTED_CONNECTION=Yes; ,0
95167>>>>>>>    Function psFullConnectionString Returns String
95169>>>>>>>        String sConnectionID sConnectionString
95169>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95171>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95172>>>>>>>>
95172>>>>>>>            Function_Return
95173>>>>>>>        End
95173>>>>>>>>
95173>>>>>>>        Get psConnectionID     of ghoSQLConnectionHandler to sConnectionID
95174>>>>>>>        Move (Trim(sConnectionID)) to sConnectionID
95175>>>>>>>        Get psConnectionString of ghoSQLConnectionHandler to sConnectionString
95176>>>>>>>        Function_Return (CS_SQLConnectionIDText * sConnectionID + "," * String(sConnectionString))
95177>>>>>>>    End_Function
95178>>>>>>>
95178>>>>>>>    Function piConnectionOptions Returns Integer
95180>>>>>>>        Integer iValue
95180>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95182>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95183>>>>>>>>
95183>>>>>>>            Function_Return
95184>>>>>>>        End
95184>>>>>>>>
95184>>>>>>>        Get piConnectionOptions of ghoSQLConnectionHandler to iValue
95185>>>>>>>        Function_Return iValue
95186>>>>>>>    End_Function
95187>>>>>>>
95187>>>>>>>    Procedure Set psSchema String sValue
95189>>>>>>>        tSQLConnection SQLConnection
95189>>>>>>>        tSQLConnection SQLConnection
95189>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95191>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95192>>>>>>>>
95192>>>>>>>            Procedure_Return
95193>>>>>>>        End
95193>>>>>>>>
95193>>>>>>>        Set psSchema of ghoSQLConnectionHandler to sValue
95194>>>>>>>    End_Procedure
95195>>>>>>>
95195>>>>>>>    Function psSchema Returns String
95197>>>>>>>        String sRetval
95197>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95199>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95200>>>>>>>>
95200>>>>>>>            Function_Return
95201>>>>>>>        End
95201>>>>>>>>
95201>>>>>>>        Get psSchema of ghoSQLConnectionHandler to sRetval
95202>>>>>>>        Function_Return sRetval
95203>>>>>>>    End_Function
95204>>>>>>>
95204>>>>>>>    Procedure Set psBaseTableSpace String sValue
95206>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95208>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95209>>>>>>>>
95209>>>>>>>            Procedure_Return
95210>>>>>>>        End
95210>>>>>>>>
95210>>>>>>>        Set psBaseTableSpace of ghoSQLConnectionHandler to sValue
95211>>>>>>>    End_Procedure
95212>>>>>>>
95212>>>>>>>    Function psBaseTableSpace Returns String
95214>>>>>>>        String sRetval
95214>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95216>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95217>>>>>>>>
95217>>>>>>>            Function_Return
95218>>>>>>>        End
95218>>>>>>>>
95218>>>>>>>        Get psBaseTableSpace of ghoSQLConnectionHandler to sRetval
95219>>>>>>>        Function_Return sRetval
95220>>>>>>>    End_Function
95221>>>>>>>
95221>>>>>>>    Procedure Set psLongTableSpace String sValue
95223>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95225>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95226>>>>>>>>
95226>>>>>>>            Procedure_Return
95227>>>>>>>        End
95227>>>>>>>>
95227>>>>>>>        Set psLongTableSpace of ghoSQLConnectionHandler to sValue
95228>>>>>>>    End_Procedure
95229>>>>>>>
95229>>>>>>>    Function psLongTableSpace Returns String
95231>>>>>>>        String sRetval
95231>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95233>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95234>>>>>>>>
95234>>>>>>>            Function_Return
95235>>>>>>>        End
95235>>>>>>>>
95235>>>>>>>        Get psLongTableSpace of ghoSQLConnectionHandler to sRetval
95236>>>>>>>        Function_Return sRetval
95237>>>>>>>    End_Function
95238>>>>>>>
95238>>>>>>>    Procedure Set psIndexTableSpace String sValue
95240>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95242>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95243>>>>>>>>
95243>>>>>>>            Procedure_Return
95244>>>>>>>        End
95244>>>>>>>>
95244>>>>>>>        Set psIndexTableSpace of ghoSQLConnectionHandler to sValue
95245>>>>>>>    End_Procedure
95246>>>>>>>
95246>>>>>>>    Function psIndexTableSpace Returns String
95248>>>>>>>        String sRetval
95248>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95250>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95251>>>>>>>>
95251>>>>>>>            Function_Return
95252>>>>>>>        End
95252>>>>>>>>
95252>>>>>>>        Get psIndexTableSpace of ghoSQLConnectionHandler to sRetval
95253>>>>>>>        Function_Return sRetval
95254>>>>>>>    End_Function
95255>>>>>>>
95255>>>>>>>    Procedure Set pbUseConnectionID Boolean bState
95257>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95259>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95260>>>>>>>>
95260>>>>>>>            Procedure_Return
95261>>>>>>>        End
95261>>>>>>>>
95261>>>>>>>        Set pbUseConnectionID of ghoSQLConnectionHandler to bState
95262>>>>>>>    End_Procedure
95263>>>>>>>
95263>>>>>>>    Function pbUseConnectionID Returns Boolean
95265>>>>>>>        Boolean bState
95265>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95267>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95268>>>>>>>>
95268>>>>>>>            Function_Return
95269>>>>>>>        End
95269>>>>>>>>
95269>>>>>>>        Get pbUseConnectionID of ghoSQLConnectionHandler to bState
95270>>>>>>>        Function_Return bState
95271>>>>>>>    End_Function
95272>>>>>>>
95272>>>>>>>    Procedure Set pbToANSI Boolean bState
95274>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95276>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95277>>>>>>>>
95277>>>>>>>            Procedure_Return
95278>>>>>>>        End
95278>>>>>>>>
95278>>>>>>>        Set pbToANSI of ghoSQLConnectionHandler to bState
95279>>>>>>>    End_Procedure
95280>>>>>>>
95280>>>>>>>    Function pbToANSI Returns Boolean
95282>>>>>>>        Boolean bState
95282>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95284>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95285>>>>>>>>
95285>>>>>>>            Function_Return
95286>>>>>>>        End
95286>>>>>>>>
95286>>>>>>>        Get pbToANSI of ghoSQLConnectionHandler to bState
95287>>>>>>>        Function_Return bState
95288>>>>>>>    End_Function
95289>>>>>>>
95289>>>>>>>    Procedure Set pbRecnum Boolean bState
95291>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95293>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95294>>>>>>>>
95294>>>>>>>            Procedure_Return
95295>>>>>>>        End
95295>>>>>>>>
95295>>>>>>>        Set pbRecnum of ghoSQLConnectionHandler to bState
95296>>>>>>>    End_Procedure
95297>>>>>>>
95297>>>>>>>    Function pbRecnum Returns Boolean
95299>>>>>>>        Boolean bState
95299>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95301>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95302>>>>>>>>
95302>>>>>>>            Function_Return
95303>>>>>>>        End
95303>>>>>>>>
95303>>>>>>>        Get pbRecnum of ghoSQLConnectionHandler to bState
95304>>>>>>>        Function_Return bState
95305>>>>>>>    End_Function
95306>>>>>>>
95306>>>>>>>    Procedure Set pbCopyData Boolean bState
95308>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95310>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95311>>>>>>>>
95311>>>>>>>            Procedure_Return
95312>>>>>>>        End
95312>>>>>>>>
95312>>>>>>>        Set pbCopyData of ghoSQLConnectionHandler to bState
95313>>>>>>>    End_Procedure
95314>>>>>>>
95314>>>>>>>    Function pbCopyData Returns Boolean
95316>>>>>>>        Boolean bState
95316>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95318>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95319>>>>>>>>
95319>>>>>>>            Function_Return
95320>>>>>>>        End
95320>>>>>>>>
95320>>>>>>>        Get pbCopyData of ghoSQLConnectionHandler to bState
95321>>>>>>>        Function_Return bState
95322>>>>>>>    End_Function
95323>>>>>>>
95323>>>>>>>    Procedure Set pbApiTableUpdateAuto Boolean bState
95325>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95327>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95328>>>>>>>>
95328>>>>>>>            Procedure_Return
95329>>>>>>>        End
95329>>>>>>>>
95329>>>>>>>        Set pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
95330>>>>>>>    End_Procedure
95331>>>>>>>
95331>>>>>>>    Function pbApiTableUpdateAuto Returns Boolean
95333>>>>>>>        Boolean bState
95333>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95335>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95336>>>>>>>>
95336>>>>>>>            Function_Return
95337>>>>>>>        End
95337>>>>>>>>
95337>>>>>>>        Get pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
95338>>>>>>>        Function_Return bState
95339>>>>>>>    End_Function
95340>>>>>>>
95340>>>>>>>    Procedure Set pbCompareDate_DateTime Boolean bState
95342>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95344>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95345>>>>>>>>
95345>>>>>>>            Procedure_Return
95346>>>>>>>        End
95346>>>>>>>>
95346>>>>>>>        Set pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
95347>>>>>>>    End_Procedure
95348>>>>>>>
95348>>>>>>>    Function pbCompareDate_DateTime Returns Boolean
95350>>>>>>>        Boolean bState
95350>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95352>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95353>>>>>>>>
95353>>>>>>>            Function_Return
95354>>>>>>>        End
95354>>>>>>>>
95354>>>>>>>        Get pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
95355>>>>>>>        Function_Return bState
95356>>>>>>>    End_Function
95357>>>>>>>
95357>>>>>>>    Procedure Set pbCompareIndexAscending Boolean bState
95359>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95361>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95362>>>>>>>>
95362>>>>>>>            Procedure_Return
95363>>>>>>>        End
95363>>>>>>>>
95363>>>>>>>        Set pbCompareIndexAscending of ghoSQLConnectionHandler to bState
95364>>>>>>>    End_Procedure
95365>>>>>>>
95365>>>>>>>    Function pbCompareIndexAscending Returns Boolean
95367>>>>>>>        Boolean bState
95367>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95369>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95370>>>>>>>>
95370>>>>>>>            Function_Return
95371>>>>>>>        End
95371>>>>>>>>
95371>>>>>>>        Get pbCompareIndexAscending of ghoSQLConnectionHandler to bState
95372>>>>>>>        Function_Return bState
95373>>>>>>>    End_Function
95374>>>>>>>
95374>>>>>>>    Procedure Set pbCompareIndexUppercase Boolean bState
95376>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95378>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95379>>>>>>>>
95379>>>>>>>            Procedure_Return
95380>>>>>>>        End
95380>>>>>>>>
95380>>>>>>>        Set pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
95381>>>>>>>    End_Procedure
95382>>>>>>>
95382>>>>>>>    Function pbCompareIndexUppercase Returns Boolean
95384>>>>>>>        Boolean bState
95384>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95386>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO ConnectionID has been setup by the programmer."
95387>>>>>>>>
95387>>>>>>>            Function_Return
95388>>>>>>>        End
95388>>>>>>>>
95388>>>>>>>        Get pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
95389>>>>>>>        Function_Return bState
95390>>>>>>>    End_Function
95391>>>>>>>
95391>>>>>>>    Procedure Set psDriverDefaultValueASCII String sValue
95393>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95395>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95396>>>>>>>>
95396>>>>>>>            Procedure_Return
95397>>>>>>>        End
95397>>>>>>>>
95397>>>>>>>        Set psDriverDefaultValueASCII of ghoSQLConnectionHandler to sValue
95398>>>>>>>    End_Procedure
95399>>>>>>>
95399>>>>>>>    Function psDriverDefaultValueASCII Returns String
95401>>>>>>>        String sRetval
95401>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95403>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95404>>>>>>>>
95404>>>>>>>            Function_Return
95405>>>>>>>        End
95405>>>>>>>>
95405>>>>>>>        Get psDriverDefaultValueASCII of ghoSQLConnectionHandler to sRetval
95406>>>>>>>        Function_Return sRetval
95407>>>>>>>    End_Function
95408>>>>>>>
95408>>>>>>>    Procedure Set psDriverDefaultValueBinary String sValue
95410>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95412>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95413>>>>>>>>
95413>>>>>>>            Procedure_Return
95414>>>>>>>        End
95414>>>>>>>>
95414>>>>>>>        Set psDriverDefaultValueBinary of ghoSQLConnectionHandler to sValue
95415>>>>>>>    End_Procedure
95416>>>>>>>
95416>>>>>>>    Function psDriverDefaultValueBinary Returns String
95418>>>>>>>        String sRetval
95418>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95420>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95421>>>>>>>>
95421>>>>>>>            Function_Return
95422>>>>>>>        End
95422>>>>>>>>
95422>>>>>>>        Get psDriverDefaultValueBinary of ghoSQLConnectionHandler to sRetval
95423>>>>>>>        Function_Return sRetval
95424>>>>>>>    End_Function
95425>>>>>>>
95425>>>>>>>    Procedure Set psDriverDefaultValueDate String sValue
95427>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95429>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95430>>>>>>>>
95430>>>>>>>            Procedure_Return
95431>>>>>>>        End
95431>>>>>>>>
95431>>>>>>>        Set psDriverDefaultValueDate of ghoSQLConnectionHandler to sValue
95432>>>>>>>    End_Procedure
95433>>>>>>>
95433>>>>>>>    Function psDriverDefaultValueDate Returns String
95435>>>>>>>        String sRetval
95435>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95437>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95438>>>>>>>>
95438>>>>>>>            Function_Return
95439>>>>>>>        End
95439>>>>>>>>
95439>>>>>>>        Get psDriverDefaultValueDate of ghoSQLConnectionHandler to sRetval
95440>>>>>>>        Function_Return sRetval
95441>>>>>>>    End_Function
95442>>>>>>>
95442>>>>>>>    Procedure Set psDriverDefaultValueDateTime String sValue
95444>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95446>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95447>>>>>>>>
95447>>>>>>>            Procedure_Return
95448>>>>>>>        End
95448>>>>>>>>
95448>>>>>>>        Set psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sValue
95449>>>>>>>    End_Procedure
95450>>>>>>>
95450>>>>>>>    Function psDriverDefaultValueDateTime Returns String
95452>>>>>>>        String sRetval
95452>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95454>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95455>>>>>>>>
95455>>>>>>>            Function_Return
95456>>>>>>>        End
95456>>>>>>>>
95456>>>>>>>        Get psDriverDefaultValueDateTime of ghoSQLConnectionHandler to sRetval
95457>>>>>>>        Function_Return sRetval
95458>>>>>>>    End_Function
95459>>>>>>>
95459>>>>>>>    Procedure Set psDriverDefaultValueNumeric String sValue
95461>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95463>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95464>>>>>>>>
95464>>>>>>>            Procedure_Return
95465>>>>>>>        End
95465>>>>>>>>
95465>>>>>>>        Set psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sValue
95466>>>>>>>    End_Procedure
95467>>>>>>>
95467>>>>>>>    Function psDriverDefaultValueNumeric Returns String
95469>>>>>>>        String sRetval
95469>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95471>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95472>>>>>>>>
95472>>>>>>>            Function_Return
95473>>>>>>>        End
95473>>>>>>>>
95473>>>>>>>        Get psDriverDefaultValueNumeric of ghoSQLConnectionHandler to sRetval
95474>>>>>>>        Function_Return sRetval
95475>>>>>>>    End_Function
95476>>>>>>>
95476>>>>>>>    Procedure Set psDriverDefaultValueText String sValue
95478>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95480>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95481>>>>>>>>
95481>>>>>>>            Procedure_Return
95482>>>>>>>        End
95482>>>>>>>>
95482>>>>>>>        Set psDriverDefaultValueText of ghoSQLConnectionHandler to sValue
95483>>>>>>>    End_Procedure
95484>>>>>>>
95484>>>>>>>    Function psDriverDefaultValueText Returns String
95486>>>>>>>        String sRetval
95486>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95488>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95489>>>>>>>>
95489>>>>>>>            Function_Return
95490>>>>>>>        End
95490>>>>>>>>
95490>>>>>>>        Get psDriverDefaultValueText of ghoSQLConnectionHandler to sRetval
95491>>>>>>>        Function_Return sRetval
95492>>>>>>>    End_Function
95493>>>>>>>
95493>>>>>>>    Procedure Set pbDriverDefaultNullableASCII Boolean bState
95495>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95497>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95498>>>>>>>>
95498>>>>>>>            Procedure_Return
95499>>>>>>>        End
95499>>>>>>>>
95499>>>>>>>        Set pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
95500>>>>>>>    End_Procedure
95501>>>>>>>
95501>>>>>>>    Function pbDriverDefaultNullableASCII Returns Boolean
95503>>>>>>>        Boolean bState
95503>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95505>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95506>>>>>>>>
95506>>>>>>>            Function_Return
95507>>>>>>>        End
95507>>>>>>>>
95507>>>>>>>        Get pbDriverDefaultNullableASCII of ghoSQLConnectionHandler to bState
95508>>>>>>>        Function_Return bState
95509>>>>>>>    End_Function
95510>>>>>>>
95510>>>>>>>    Procedure Set pbDriverDefaultNullableBinary Boolean bState
95512>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95514>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95515>>>>>>>>
95515>>>>>>>            Procedure_Return
95516>>>>>>>        End
95516>>>>>>>>
95516>>>>>>>        Set pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
95517>>>>>>>    End_Procedure
95518>>>>>>>
95518>>>>>>>    Function pbDriverDefaultNullableBinary Returns Boolean
95520>>>>>>>        Boolean bState
95520>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95522>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95523>>>>>>>>
95523>>>>>>>            Function_Return
95524>>>>>>>        End
95524>>>>>>>>
95524>>>>>>>        Get pbDriverDefaultNullableBinary of ghoSQLConnectionHandler to bState
95525>>>>>>>        Function_Return bState
95526>>>>>>>    End_Function
95527>>>>>>>
95527>>>>>>>    Procedure Set pbDriverDefaultNullableDate Boolean bState
95529>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95531>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95532>>>>>>>>
95532>>>>>>>            Procedure_Return
95533>>>>>>>        End
95533>>>>>>>>
95533>>>>>>>        Set pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
95534>>>>>>>    End_Procedure
95535>>>>>>>
95535>>>>>>>    Function pbDriverDefaultNullableDate Returns Boolean
95537>>>>>>>        Boolean bState
95537>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95539>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95540>>>>>>>>
95540>>>>>>>            Function_Return
95541>>>>>>>        End
95541>>>>>>>>
95541>>>>>>>        Get pbDriverDefaultNullableDate of ghoSQLConnectionHandler to bState
95542>>>>>>>        Function_Return bState
95543>>>>>>>    End_Function
95544>>>>>>>
95544>>>>>>>    Procedure Set pbDriverDefaultNullableDateTime Boolean bState
95546>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95548>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95549>>>>>>>>
95549>>>>>>>            Procedure_Return
95550>>>>>>>        End
95550>>>>>>>>
95550>>>>>>>        Set pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
95551>>>>>>>    End_Procedure
95552>>>>>>>
95552>>>>>>>    Function pbDriverDefaultNullableDateTime Returns Boolean
95554>>>>>>>        Boolean bState
95554>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95556>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95557>>>>>>>>
95557>>>>>>>            Function_Return
95558>>>>>>>        End
95558>>>>>>>>
95558>>>>>>>        Get pbDriverDefaultNullableDateTime of ghoSQLConnectionHandler to bState
95559>>>>>>>        Function_Return bState
95560>>>>>>>    End_Function
95561>>>>>>>
95561>>>>>>>    Procedure Set pbDriverDefaultNullableNumeric Boolean bState
95563>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95565>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95566>>>>>>>>
95566>>>>>>>            Procedure_Return
95567>>>>>>>        End
95567>>>>>>>>
95567>>>>>>>        Set pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
95568>>>>>>>    End_Procedure
95569>>>>>>>
95569>>>>>>>    Function pbDriverDefaultNullableNumeric Returns Boolean
95571>>>>>>>        Boolean bState
95571>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95573>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95574>>>>>>>>
95574>>>>>>>            Function_Return
95575>>>>>>>        End
95575>>>>>>>>
95575>>>>>>>        Get pbDriverDefaultNullableNumeric of ghoSQLConnectionHandler to bState
95576>>>>>>>        Function_Return bState
95577>>>>>>>    End_Function
95578>>>>>>>
95578>>>>>>>    Procedure Set pbDriverDefaultNullableText Boolean bState
95580>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95582>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95583>>>>>>>>
95583>>>>>>>            Procedure_Return
95584>>>>>>>        End
95584>>>>>>>>
95584>>>>>>>        Set pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
95585>>>>>>>    End_Procedure
95586>>>>>>>
95586>>>>>>>    Function pbDriverDefaultNullableText Returns Boolean
95588>>>>>>>        Boolean bState
95588>>>>>>>        If (ghoSQLConnectionHandler = 0) Begin
95590>>>>>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that NO SQL connection has been setup by the programmer."
95591>>>>>>>>
95591>>>>>>>            Function_Return
95592>>>>>>>        End
95592>>>>>>>>
95592>>>>>>>        Get pbDriverDefaultNullableText of ghoSQLConnectionHandler to bState
95593>>>>>>>        Function_Return bState
95594>>>>>>>    End_Function
95595>>>>>>>
95595>>>>>>>    // Note: If the psDriverID + other connection properties are to be changed,
95595>>>>>>>    //       the psDriverID *must* be the first property that gets changed!
95595>>>>>>>    //       Otherwise errors might be raised by the driver when e.g. the format
95595>>>>>>>    //       for a connection string has the wrong format for that driver.
95595>>>>>>>    Procedure Set psDriverID String sValue
95597>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
95598>>>>>>>        Delegate Set psDriverID to sValue
95600>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
95601>>>>>>>        Set psDriverID of ghoSQLConnectionHandler to sValue
95602>>>>>>>    End_Procedure
95603>>>>>>>
95603>>>>>>>    Function psDriverID Returns String
95605>>>>>>>        String sDriverID
95605>>>>>>>
95605>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
95606>>>>>>>        // This should get it from the parent object (when using the cDbUpdateHandler class)
95606>>>>>>>        Delegate Get psDriverID to sDriverID
95608>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
95609>>>>>>>        Move False to Err
95610>>>>>>>
95610>>>>>>>        // ...and in case it didn't use property of this class. Then the library is
95610>>>>>>>        // probably used as "utilites" from a special made program and
95610>>>>>>>        // the ghoSQLConnectionHandler must have been setup
95610>>>>>>>        If (sDriverID = "") Begin
95612>>>>>>>            Get psDriverID of ghoSQLConnectionHandler to sDriverID
95613>>>>>>>        End
95613>>>>>>>>
95613>>>>>>>        Function_Return sDriverID
95614>>>>>>>    End_Function
95615>>>>>>>
95615>>>>>>>    Procedure Set piDbType Integer iValue
95617>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
95618>>>>>>>        Delegate Set piDbType to iValue
95620>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
95621>>>>>>>        Set piDbType of ghoSQLConnectionHandler to iValue
95622>>>>>>>    End_Procedure
95623>>>>>>>
95623>>>>>>>    Function piDbType Returns Integer
95625>>>>>>>        Integer iRetval
95625>>>>>>>        Get piDbType of ghoSQLConnectionHandler to iRetval
95626>>>>>>>        Function_Return iRetval
95627>>>>>>>    End_Function
95628>>>>>>>
95628>>>>>>>    Function phoLogFile Returns Handle
95630>>>>>>>        Handle hoLogFile   
95630>>>>>>>        Boolean bErr
95630>>>>>>>        
95630>>>>>>>        Move Err to bErr
95631>>>>>>>        Move 0 to hoLogFile
95632>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT  
95633>>>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
95634>>>>>>>        Delegate Get phoLogFile to hoLogFile
95636>>>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
95637>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
95638>>>>>>>        Move bErr to Err
95639>>>>>>>        
95639>>>>>>>        Function_Return hoLogFile
95640>>>>>>>    End_Function
95641>>>>>>>
95641>>>>>>>    Function pnCurrentVersionUpdate Returns Number
95643>>>>>>>        Number nCurrentVersionUpdate
95643>>>>>>>
95643>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
95644>>>>>>>        Delegate Get pnCurrentVersionUpdate to nCurrentVersionUpdate
95646>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
95647>>>>>>>
95647>>>>>>>        Function_Return nCurrentVersionUpdate
95648>>>>>>>    End_Function
95649>>>>>>>
95649>>>>>>>    Procedure LogError String sText Boolean bError
95651>>>>>>>        Handle hoLogFile
95651>>>>>>>        Number nCurrentVersionUpdate
95651>>>>>>>
95651>>>>>>>        Get phoLogFile to hoLogFile
95652>>>>>>>        If (hoLogFile = 0) Begin
95654>>>>>>>            Procedure_Return
95655>>>>>>>        End
95655>>>>>>>>
95655>>>>>>>        Get pnCurrentVersionUpdate to nCurrentVersionUpdate
95656>>>>>>>
95656>>>>>>>        Set Error_Report_Mode to DUF_ERROR_NO_REPORT
95657>>>>>>>        Send LogError of hoLogFile nCurrentVersionUpdate 0 sText 0 bError
95658>>>>>>>        Set Error_Report_Mode to DUF_ERROR_REPORT
95659>>>>>>>    End_Procedure
95660>>>>>>>
95660>>>>>>>    Function pbContinueOnError Returns Boolean
95662>>>>>>>        Boolean bContinueOnError
95662>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
95664>>>>>>>            Get pbContinueOnError of ghoDbUpdateHandler to bContinueOnError
95665>>>>>>>        End
95665>>>>>>>>
95665>>>>>>>        Function_Return bContinueOnError
95666>>>>>>>    End_Function
95667>>>>>>>
95667>>>>>>>    // Latin1_General_CI_AS = General Insensitive collation
95667>>>>>>>    // Latin1_General_CS_AS = General Case Sensitive collation, AS= Accent Sensitive.
95667>>>>>>>    // For MS-SQL See: https://docs.microsoft.com/en-us/sql/t-sql/statements/windows-collation-name-transact-sql?view=sql-server-2017
95667>>>>>>>    // Good read about which collation to select:
95667>>>>>>>    // https://social.msdn.microsoft.com/Forums/sqlserver/en-US/bfdc32d3-3d36-4d63-8d87-6ee972fd8130/on-sqllatin1generalcp1cias-sql-server-2008-default-collation?forum=transactsql
95667>>>>>>>    Procedure Set psCollation String sCollation
95669>>>>>>>        Set private.psCollation to sCollation
95670>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
95672>>>>>>>            Set psCollation of ghoDbUpdateHandler to sCollation
95673>>>>>>>        End
95673>>>>>>>>
95673>>>>>>>    End_Procedure
95674>>>>>>>
95674>>>>>>>    Function psCollation Returns String
95676>>>>>>>        String sCollation
95676>>>>>>>        If (ghoDbUpdateHandler > 0) Begin
95678>>>>>>>            Get psCollation of ghoDbUpdateHandler to sCollation
95679>>>>>>>        End   
95679>>>>>>>>
95679>>>>>>>        Else Begin
95680>>>>>>>            Get private.psCollation to sCollation
95681>>>>>>>        End
95681>>>>>>>>
95681>>>>>>>        Function_Return sCollation
95682>>>>>>>    End_Function
95683>>>>>>>
95683>>>>>>>
95683>>>>>>>    Function StrToFieldNumber Integer iFile String sField Returns Integer
95685>>>>>>>        Integer iMax iPos
95685>>>>>>>        String sName
95685>>>>>>>
95685>>>>>>>        Move (Lowercase(sField)) to sField
95686>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iFile to iMax
95689>>>>>>>        for iPos from 0 to iMax
95695>>>>>>>>
95695>>>>>>>            Get_Attribute DF_FIELD_NAME of iFile iPos to sName
95698>>>>>>>            Move (Lowercase(sName)) to sName
95699>>>>>>>            If (sName = sField) Begin
95701>>>>>>>                Function_Return iPos
95702>>>>>>>            End
95702>>>>>>>>
95702>>>>>>>        Loop
95703>>>>>>>>
95703>>>>>>>        Function_Return -1
95704>>>>>>>    End_Function
95705>>>>>>>
95705>>>>>>>
95705>>>>>>>    // * Dummy function for the Studio's Code Explorer *
95705>>>>>>>    Function PRIVATE_SUB_FUNCTIONS Returns Boolean
95707>>>>>>>        Function_Return False
95708>>>>>>>    End_Function
95709>>>>>>>
95709>>>>>>>    // *** Helper functions with compiled sql script code ***
95709>>>>>>>    //
95709>>>>>>>    // When dropping columns on some SQL back-ends they doesn't reclaim the space taken up by the columns dropped.
95709>>>>>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
95709>>>>>>>    // the new rows added after the alter statement. to get around this you need to create a clustered
95709>>>>>>>    // index on the table _or_ rebuild the clustered Index if it already has one. Rebuilding the index
95709>>>>>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
95709>>>>>>>    //   ALTER TABLE MyTable
95709>>>>>>>    //       REBUILD
95709>>>>>>>    Function _SqlUtilRemoveTableColumnMSSQL String sTableName String sColumnName Returns Boolean
95711>>>>>>>        Boolean bOK
95711>>>>>>>
95711>>>>>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
95713>>>>>>>            Function_Return False
95714>>>>>>>        End
95714>>>>>>>>
95714>>>>>>>
95714>>>>>>>        SQLIncludeScriptFile ..\Scripts\DropConstraintAndColumnNameMSSQL.sql as DropConstraintAndColumnNameMSSQL.sql
95714>>>>>>>        Get _SqlUtilRemoveTableColumnByScript "DropConstraintAndColumnNameMSSQL.sql" sTableName sColumnName to bOK
95715>>>>>>>
95715>>>>>>>        Function_Return (bOK = True)
95716>>>>>>>    End_Function
95717>>>>>>>
95717>>>>>>>    // When dropping columns SQL Sever does not reclaim the space taken up by the columns dropped.
95717>>>>>>>    // For data types that are stored inline in the rows (int for example) it may even take up space on
95717>>>>>>>    // the new rows added after the alter statement. To get around this you need to create a clustered
95717>>>>>>>    // index on the table or rebuild the clustered Index if it already has one. Rebuilding the index
95717>>>>>>>    // can be done with a REBUILD command after modifying the table. But be warned this can be slow on very big tables.
95717>>>>>>>    //   ALTER TABLE MyTable
95717>>>>>>>    //       REBUILD
95717>>>>>>>    Function _SqlUtilRemoveTableColumnByScript String sMemScriptFile String sTableName String sColumnName Returns Boolean
95719>>>>>>>        tSQLScriptArray SQLScriptArray
95719>>>>>>>        tSQLScriptArray SQLScriptArray
95719>>>>>>>        String sDriverID
95719>>>>>>>        Boolean bOK
95719>>>>>>>        Integer iSize iCount
95719>>>>>>>
95719>>>>>>>        If (Trim(sTableName) = "" or Trim(sColumnName) = "") Begin
95721>>>>>>>            Function_Return False
95722>>>>>>>        End
95722>>>>>>>>
95722>>>>>>>
95722>>>>>>>        Get psDriverID to sDriverID
95723>>>>>>>        Get SqlUtilReadResource sMemScriptFile to SQLScriptArray
95724>>>>>>>        If (SQLScriptArray.bError = True) Begin
95726>>>>>>>            Function_Return False
95727>>>>>>>        End
95727>>>>>>>>
95727>>>>>>>
95727>>>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
95728>>>>>>>        Decrement iSize
95729>>>>>>>
95729>>>>>>>        for iCount from 0 to iSize
95735>>>>>>>>
95735>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "TABLE_NAME_XXX") Begin
95737>>>>>>>                Move (Replaces("TABLE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sTableName))) to SQLScriptArray.sSQLScriptArray[iCount]
95738>>>>>>>            End
95738>>>>>>>>
95738>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLUMN_NAME_XXX") Begin
95740>>>>>>>                Move (Replaces("COLUMN_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sColumnName))) to SQLScriptArray.sSQLScriptArray[iCount]
95741>>>>>>>            End
95741>>>>>>>>
95741>>>>>>>        Loop
95742>>>>>>>>
95742>>>>>>>
95742>>>>>>>        Get SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
95743>>>>>>>
95743>>>>>>>        Function_Return (bOK = True)
95744>>>>>>>    End_Function
95745>>>>>>>
95745>>>>>>>    Function _SqlUtilCreatePostGreSQLDatabaseByScript String sMemScriptFile String sDatabaseName Returns Boolean
95747>>>>>>>        tSQLScriptArray SQLScriptArray
95747>>>>>>>        tSQLScriptArray SQLScriptArray
95747>>>>>>>        String sDriverID sCollation
95747>>>>>>>        Boolean bOK
95747>>>>>>>        Integer iSize iCount
95747>>>>>>>
95747>>>>>>>        If (Trim(sDatabaseName) = "") Begin
95749>>>>>>>            Function_Return False
95750>>>>>>>        End
95750>>>>>>>>
95750>>>>>>>
95750>>>>>>>        Get psDriverID  to sDriverID
95751>>>>>>>        Get psCollation to sCollation
95752>>>>>>>        Get SqlUtilReadResource sMemScriptFile to SQLScriptArray
95753>>>>>>>        If (SQLScriptArray.bError = True) Begin
95755>>>>>>>            Function_Return False
95756>>>>>>>        End
95756>>>>>>>>
95756>>>>>>>
95756>>>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
95757>>>>>>>        Decrement iSize
95758>>>>>>>
95758>>>>>>>        for iCount from 0 to iSize
95764>>>>>>>>
95764>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "DATABASE_NAME_XXX") Begin
95766>>>>>>>                Move (Replaces("DATABASE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sDatabaseName))) to SQLScriptArray.sSQLScriptArray[iCount]
95767>>>>>>>            End
95767>>>>>>>>
95767>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLLATION_NAME_XXX") Begin
95769>>>>>>>                Move (Replaces("COLLATION_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sCollation))) to SQLScriptArray.sSQLScriptArray[iCount]
95770>>>>>>>            End
95770>>>>>>>>
95770>>>>>>>        Loop
95771>>>>>>>>
95771>>>>>>>
95771>>>>>>>        Get SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
95772>>>>>>>
95772>>>>>>>        Function_Return (bOK = True)
95773>>>>>>>    End_Function
95774>>>>>>>
95774>>>>>>>    Function _SqlUtilCreateMySQLDatabaseByScript String sMemScriptFile String sDatabaseName Returns Boolean
95776>>>>>>>        tSQLScriptArray SQLScriptArray
95776>>>>>>>        tSQLScriptArray SQLScriptArray
95776>>>>>>>        String sDriverID sCollation
95776>>>>>>>        Boolean bOK
95776>>>>>>>        Integer iSize iCount
95776>>>>>>>
95776>>>>>>>        If (Trim(sDatabaseName) = "") Begin
95778>>>>>>>            Function_Return False
95779>>>>>>>        End
95779>>>>>>>>
95779>>>>>>>
95779>>>>>>>        Get psDriverID  to sDriverID
95780>>>>>>>        Get psCollation to sCollation
95781>>>>>>>        Get SqlUtilReadResource sMemScriptFile to SQLScriptArray
95782>>>>>>>        If (SQLScriptArray.bError = True) Begin
95784>>>>>>>            Function_Return False
95785>>>>>>>        End
95785>>>>>>>>
95785>>>>>>>
95785>>>>>>>        Move (SizeOfArray(SQLScriptArray.sSQLScriptArray)) to iSize
95786>>>>>>>        Decrement iSize
95787>>>>>>>
95787>>>>>>>        for iCount from 0 to iSize
95793>>>>>>>>
95793>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "DATABASE_NAME_XXX") Begin
95795>>>>>>>                Move (Replaces("DATABASE_NAME_XXX",  SQLScriptArray.sSQLScriptArray[iCount], String(sDatabaseName))) to SQLScriptArray.sSQLScriptArray[iCount]
95796>>>>>>>            End
95796>>>>>>>>
95796>>>>>>>            If (SQLScriptArray.sSQLScriptArray[iCount] contains "COLLATION_NAME_XXX") Begin
95798>>>>>>>                Move (Replaces("COLLATION_NAME_XXX", SQLScriptArray.sSQLScriptArray[iCount], String(sCollation))) to SQLScriptArray.sSQLScriptArray[iCount]
95799>>>>>>>            End
95799>>>>>>>>
95799>>>>>>>        Loop
95800>>>>>>>>
95800>>>>>>>        // ToDo: THIS FAILS BUT THE SQL SCRIPT WORKS IN MYSQL!
95800>>>>>>>        Get SqlUtilExecuteEmbeddedScript SQLScriptArray sDriverID False "" to bOK
95801>>>>>>>
95801>>>>>>>        Function_Return (bOK = True)
95802>>>>>>>    End_Function
95803>>>>>>>
95803>>>>>>>    // *** Helper functions for Mertech Drivers ***
95803>>>>>>>    // Created to not clutter up the standard function code with lots of #IFDEF's
95803>>>>>>>    // and commands that the Studio editor knows nothing about.
95803>>>>>>>    Function _MertechDeleteTDFile String sTableName Returns Boolean
95805>>>>>>>        Integer iRetval
95805>>>>>>>        String sPath
95805>>>>>>>
95805>>>>>>>            SQL_GET_LOCAL_TD_PATH to sPath
95843>>>>>>>>
95843>>>>>>>        If (sPath = "" or sTableName = "") Begin
95845>>>>>>>            Function_Return True
95846>>>>>>>        End
95846>>>>>>>>
95846>>>>>>>
95846>>>>>>>        Get vFolderFormat sPath to sPath
95847>>>>>>>        Get vDeleteFile (sPath + String(sTableName) + ".td") to iRetval
95848>>>>>>>        Function_Return (iRetval = 0)
95849>>>>>>>    End_Function
95850>>>>>>>
95850>>>>>>>    Function _MertechSqlUtilCreateIntFile Handle hTable String sTableName String sDataPath String sPhysicalFileName Returns Boolean
95852>>>>>>>        Boolean bOpen bOK
95852>>>>>>>        Move False to Err
95853>>>>>>>            Close hTable
95854>>>>>>>            Get UtilTableOpenAsIntFile hTable sTableName DF_SHARE to bOpen
95855>>>>>>>            Set_Attribute DF_FILE_SUPPRESS_SERVERNAME_OUTPUT   of hTable to True
95858>>>>>>>            Set_Attribute DF_FILE_SUPPRESS_DATABASENAME_OUTPUT of hTable to True
95861>>>>>>>            Set_Attribute DF_FILE_SUPPRESS_SCHEMANAME_OUTPUT   of hTable to True
95864>>>>>>>            Get UtilDeleteCacheFile sTableName to bOK
95865>>>>>>>            CLEAR_INT_CACHE
95901>>>>>>>>
95901>>>>>>>            Move (sDataPath + sPhysicalFileName) to sTableName
95902>>>>>>>            OUTPUT_INT_FILE for hTable to sTableName
95947>>>>>>>>
95947>>>>>>>        Function_Return (Err = False)
95948>>>>>>>    End_Function
95949>>>>>>>
95949>>>>>>>    Function _MertechEnumerateSQLFlexServers Returns String[]
95951>>>>>>>        Integer iNumItems iCount
95951>>>>>>>        String[] sReturnArray
95952>>>>>>>        String sServer
95952>>>>>>>
95952>>>>>>>        Get SQL_AVAILABLE_SQL_SERVERS to iNumItems
95953>>>>>>>        For iCount from 1 to iNumItems
95959>>>>>>>>
95959>>>>>>>            Get SQL_AVAILABLE_SQL_SERVER_NAME iCount to sServer
95960>>>>>>>            Move sServer to sReturnArray[iCount -1]
95961>>>>>>>        Loop
95962>>>>>>>>
95962>>>>>>>
95962>>>>>>>        Function_Return sReturnArray
95963>>>>>>>    End_Function
95964>>>>>>>
95964>>>>>>>    Function _MertechEnumerateORAFLEXServers Returns String[]
95966>>>>>>>        String[] sReturnArray
95967>>>>>>>        String sServer
95967>>>>>>>
95967>>>>>>>        GET_CURRENT_SQL_SERVER to sServer
96011>>>>>>>>
96011>>>>>>>        Move sServer to sReturnArray[0]
96012>>>>>>>
96012>>>>>>>        Function_Return sReturnArray
96013>>>>>>>    End_Function
96014>>>>>>>
96014>>>>>>>    Function _MertechSQLConnect String sDriverID String sServer String sUserID String sPassword Returns Handle
96016>>>>>>>        Handle hoSQLHandler hoSQLConnect
96016>>>>>>>
96016>>>>>>>        Move 0 to hoSQLConnect
96017>>>>>>>            Get _MertechSQLManagerHandle to hoSQLHandler
96018>>>>>>>            Get SQLConnect of hoSqlHandler sDriverID sServer sUserID sPassword to hoSQLConnect
96019>>>>>>>
96019>>>>>>>        Function_Return hoSQLConnect
96020>>>>>>>    End_Function
96021>>>>>>>
96021>>>>>>>    // Returns the handle of the Mertech SQL handler.
96021>>>>>>>    // It also ensures that the correct Server & Database attributes are set both for
96021>>>>>>>    // embedded SQL calls and "normal" database commands like e.g. "Open".
96021>>>>>>>    Function _MertechSQLManagerHandle Returns Handle
96023>>>>>>>        Handle hoSQLHandler
96023>>>>>>>        String sDriverID sServer sDatabase
96023>>>>>>>
96023>>>>>>>        Move 0 to hoSQLHandler
96024>>>>>>>        Get psDriverID to sDriverID
96025>>>>>>>        Get psServer   to sServer
96026>>>>>>>        Get psDatabase to sDatabase
96027>>>>>>>        // This command is used to set the server to be used when opening tables
96027>>>>>>>        SET_CURRENT_SQL_SERVER            to sServer
96070>>>>>>>>
96070>>>>>>>        // This command is used to specify which server to use for embedded SQL statements,
96070>>>>>>>        // but it has been constructed rather studidly as only constants and not variables
96070>>>>>>>        // are allowed...
96070>>>>>>>        If (sDriverID = MDSPgSQL) Begin
96072>>>>>>>            SET_CURRENT_SQL_SERVER_CONNECTION of MDSPgSQL to sServer
96088>>>>>>>        End
96088>>>>>>>>
96088>>>>>>>        If (sDriverID = MDSMySQL) Begin
96090>>>>>>>            SET_CURRENT_SQL_SERVER_CONNECTION of MDSMySQL to sServer
96106>>>>>>>        End
96106>>>>>>>>
96106>>>>>>>        If (sDriverID = ORAFLEX) Begin
96108>>>>>>>            SET_CURRENT_SQL_SERVER_CONNECTION of ORAFLEX to sServer
96124>>>>>>>        End
96124>>>>>>>>
96124>>>>>>>        If (sDriverID = SQLFLEX) Begin
96126>>>>>>>            SET_CURRENT_SQL_SERVER_CONNECTION of SQLFLEX to sServer
96142>>>>>>>        End
96142>>>>>>>>
96142>>>>>>>
96142>>>>>>>        // This command is used to specify which database is used for SQL statements only.
96142>>>>>>>        SQL_USE_DATABASE sDatabase
96180>>>>>>>>
96180>>>>>>>        SET_DATABASE_NAME to sDatabase
96218>>>>>>>>
96218>>>>>>>
96218>>>>>>>        Get phoSQLManagerMT to hoSQLHandler
96219>>>>>>>
96219>>>>>>>        Function_Return hoSQLHandler
96220>>>>>>>    End_Function
96221>>>>>>>
96221>>>>>>>    // For Mertech drivers we cannot use Structure_Start/End. Instead we must use
96221>>>>>>>    // macro-commands <sigh!>
96221>>>>>>>    // Note: The function sets the Err flag.
96221>>>>>>>    Function _MertechApiTableConvertToSQL Handle hTable String sRootName String sDatabase String sDriverID String sBaseTableSpace String sIndexTableSpace Boolean bToAnsi Boolean bCopyData Returns Boolean
96223>>>>>>>
96223>>>>>>>        Move False to Err
96224>>>>>>>            SET_DATABASE_NAME to sDatabase
96262>>>>>>>>
96262>>>>>>>            If (sBaseTableSpace <> "") Begin
96264>>>>>>>                SET_DEFAULT_TABLESPACE to sBaseTableSpace
96301>>>>>>>>
96301>>>>>>>            End
96301>>>>>>>>
96301>>>>>>>            If (sIndexTableSpace <> "") Begin
96303>>>>>>>                SET_DEFAULT_INDEX_TABLESPACE to sIndexTableSpace
96340>>>>>>>>
96340>>>>>>>            End
96340>>>>>>>>
96340>>>>>>>
96340>>>>>>>            MERTECH_WARNING_MESSAGE Disabled
96373>>>>>>>>
96373>>>>>>>            CONVERT_DAT_FILE hTable DF_STRUCTEND_OPT_FORCE_INVK sRootName
96411>>>>>>>>
96411>>>>>>>            MERTECH_WARNING_MESSAGE Enabled
96444>>>>>>>>
96444>>>>>>>
96444>>>>>>>//            Move hTable to iFile
96444>>>>>>>//            Structure_Start iFile sDriverID
96444>>>>>>>//                Set_Attribute DF_FILE_OEM_TRANSLATION of iFile to (bToAnsi = True)
96444>>>>>>>//            Structure_End iFile
96444>>>>>>>
96444>>>>>>>
96444>>>>>>>        Function_Return (Err = False)
96445>>>>>>>    End_Function
96446>>>>>>>
96446>>>>>>>    Function _MertechCopyDataToSQL Handle hTable String sRootName String sDriverID Returns Boolean
96448>>>>>>>        Move False to Err
96449>>>>>>>            MERTECH_WARNING_MESSAGE Disabled
96482>>>>>>>>
96482>>>>>>>            COPY_DATA sRootName to (sDriverID + ":" + sRootName) CALLBACK (Callback(Self))
96521>>>>>>>>
96521>>>>>>>            MERTECH_WARNING_MESSAGE Enabled
96554>>>>>>>>
96554>>>>>>>        Function_Return (Err = False)
96555>>>>>>>    End_Function
96556>>>>>>>
96556>>>>>>>End_Class
96557>>>>>Use for_all.pkg // Handy to have available in the OnUpdate event.
Including file: for_all.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\for_all.pkg)
96557>>>>>>>// This module contains the command definitions for the FOR_ALL construct.
96557>>>>>>>//
96557>>>>>>>// FOR_ALL is used to select and process a set of records in a database file;
96557>>>>>>>// FOR_ALL constructs may be nested. FOR_ALL is intended to work in
96557>>>>>>>// conjunction with constraint-clauses.
96557>>>>>>>//
96557>>>>>>>// SYNTAX:
96557>>>>>>>//
96557>>>>>>>//  For_All <File> BY|DOWN <Index> {AS QUE|QUEUE} {DO}
96557>>>>>>>//    <Constraints...>
96557>>>>>>>//    {DO}
96557>>>>>>>//      <loop body>
96557>>>>>>>//  End_For_All
96557>>>>>>>//
96557>>>>>>>// This set of macros implements a constraint-oriented file enumeration
96557>>>>>>>// syntax.  For example, to list all Customers by name in reverse order:
96557>>>>>>>//
96557>>>>>>>//   For_All Customer DOWN Customer.Customer_Name DO
96557>>>>>>>//     showln "Customer: " Customer.RecNum "  " Customer.Customer_Name
96557>>>>>>>//   End_For_All
96557>>>>>>>//
96557>>>>>>>// To list only Customers with a Balance greater than their credit limit:
96557>>>>>>>//
96557>>>>>>>//   For_All Customer BY Index.1
96557>>>>>>>//     CONSTRAIN Customer.Balance GT Customer.Credit_Limit
96557>>>>>>>//     DO
96557>>>>>>>//       showln "Customer: " Customer.RecNum "  " Customer.Customer_Name
96557>>>>>>>//   End_For_All
96557>>>>>>>//
96557>>>>>>>// Constraint clauses are:
96557>>>>>>>//
96557>>>>>>>//   CONSTRAIN <File> RELATES TO <File> ...
96557>>>>>>>//   CONSTRAIN <File> AS <Expression>
96557>>>>>>>//   CONSTRAIN <File.Field> AS <Expression>
96557>>>>>>>//   CONSTRAIN <File.Field> BETWEEN <lowBound> AND <highBound>
96557>>>>>>>//
96557>>>>>>>// For example, to list all customers with a bad status whose names start
96557>>>>>>>// with "A" and which have not made a payment in thirty days:
96557>>>>>>>//
96557>>>>>>>//    For_All Customer BY Index.2       //Index.2 = <Status>+<Name>
96557>>>>>>>//      CONSTRAIN Customer.Status EQ BAD
96557>>>>>>>//      CONSTRAIN Customer.Customer_Name GE "A"
96557>>>>>>>//      CONSTRAIN Customer.Customer_Name LT "B"
96557>>>>>>>//      CONSTRAIN Customer.Last_Pymt_Date LE (Today - 30)
96557>>>>>>>//      DO
96557>>>>>>>//        showln "Customer: " Customer.RecNum "  " Customer.Customer_Name
96557>>>>>>>//    End_For_All
96557>>>>>>>//
96557>>>>>>>
96557>>>>>>>
96557>>>>>>>//This command starts the loop process body when constraints are used;
96557>>>>>>>//If no constraints are required, DO should be specified on the FOR_ALL
96557>>>>>>>//command line, and not on a line by itself
96557>>>>>>>//
96557>>>>>>>
96557>>>>>>>//Ends a For_All loop
96557>>>>>>>//
96557>>>>>>>
96557>>>>>>>
96557>>>>>
96557>>>>>
96557>>>>>Class cDbUpdateVersion is a cObject
96558>>>>>
96558>>>>>    Procedure Construct_Object    
96560>>>>>        Boolean bOnCreateExecuted bUseCustomDbVersion
96560>>>>>        String[] aSQLQueryMessages
96561>>>>>        
96561>>>>>        Forward Send Construct_Object
96563>>>>>
96563>>>>>        // cDbUpdateHandler object event.
96563>>>>>        Delegate Get Private.pbOnCreateExecuted to bOnCreateExecuted
96565>>>>>        If (bOnCreateExecuted = False) Begin    
96567>>>>>            Delegate Get pbUseCustomDbVersion to bUseCustomDbVersion
96569>>>>>            If (bUseCustomDbVersion = False) Begin
96571>>>>>                Delegate Send CheckAutoCreateDbVersionTable 
96573>>>>>            End
96573>>>>>>
96573>>>>>            Delegate Send CheckIntFilesIntegrity
96575>>>>>            Delegate Send OnCreate
96577>>>>>            Delegate Set Private.pbOnCreateExecuted to True
96579>>>>>        End
96579>>>>>>
96579>>>>>
96579>>>>>        // Don't touch! It is used by class logic to indicate if the OnUpdate
96579>>>>>        // event was triggered, thus an actual change of the database was made.
96579>>>>>        Property Boolean pbVersionUpdate False
96580>>>>>
96580>>>>>        // This property must be manually set within each cDbUpdateVersion object
96580>>>>>        // by the programmer, to a consecutive number.
96580>>>>>        Property Number pnVersionNumber
96581>>>>>
96581>>>>>        Property Boolean pbUseConnectionID True
96582>>>>>        Property Boolean private.pbToANSI   True
96583>>>>>        Property Boolean private.pbRecnum   True
96584>>>>>        Property Boolean private.pbCopyData True
96585>>>>>        Property Boolean private.pbApiTableUpdateAuto False
96586>>>>>        Property Boolean private.pbCompareDate_DateTime False
96587>>>>>        Property Boolean private.pbCompareIndexAscending False
96588>>>>>        Property Boolean private.pbCompareIndexUppercase False
96589>>>>>        Property String private.psSchema
96590>>>>>        Property String private.psBaseTableSpace
96591>>>>>        Property String private.psLongTableSpace
96592>>>>>        Property String private.psIndexTableSpace
96593>>>>>
96593>>>>>        // Driver default value settings:
96593>>>>>        Property String private.psDriverDefaultValueASCII    ""
96594>>>>>        Property String private.psDriverDefaultValueBinary   ""
96595>>>>>        Property String private.psDriverDefaultValueDate     ""
96596>>>>>        Property String private.psDriverDefaultValueDateTime ""
96597>>>>>        Property String private.psDriverDefaultValueNumeric  ""
96598>>>>>        Property String private.psDriverDefaultValueText     ""
96599>>>>>
96599>>>>>        // Driver "nullability" settings:
96599>>>>>        Property Boolean private.pbDriverDefaultNullableASCII    False
96600>>>>>        Property Boolean private.pbDriverDefaultNullableBinary   False
96601>>>>>        Property Boolean private.pbDriverDefaultNullableDate     False
96602>>>>>        Property Boolean private.pbDriverDefaultNullableDateTime False
96603>>>>>        Property Boolean private.pbDriverDefaultNullableNumeric  False
96604>>>>>        Property Boolean private.pbDriverDefaultNullableText     False
96605>>>>>
96605>>>>>        // paSQLQueryMessages is a property of the container class cDbUpdateHandler.
96605>>>>>        // It is being used to gather ESQL message replies, and is output to the log file
96605>>>>>        // if pbVerboseState = True in the cDbUpdateHandler object.
96605>>>>>        // (See: Procedure Set pbDatabaseWasUpdated in the cDbUpdateHandler class)
96605>>>>>        // We reset it here for each cDbUpdateVersion object
96605>>>>>        Delegate Set paSQLQueryMessages to aSQLQueryMessages
96607>>>>>    End_Procedure
96608>>>>>
96608>>>>>    // *** Main hook event message ***
96608>>>>>    // Place your database update logic here!
96608>>>>>    Procedure OnUpdate
96610>>>>>    End_Procedure
96611>>>>>
96611>>>>>    // These properties also exists in the cDbUpdateFunctionLibray that is
96611>>>>>    // imported to the cDbUpdateHandler container class which should be a
96611>>>>>    // parent object to this object. To have the Studio's Property Panel
96611>>>>>    // "behave" aka show these properties we need to duplicate them in this
96611>>>>>    // class and "relay" them to the parent object.
96611>>>>>    Procedure Set pbToANSI Boolean bState
96613>>>>>        Set private.pbToANSI  to bState
96614>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96615>>>>>        Delegate Set pbToANSI to bState
96617>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96618>>>>>    End_Procedure
96619>>>>>
96619>>>>>    Function pbToANSI Returns Boolean
96621>>>>>        Function_Return (private.pbToAnsi(Self))
96622>>>>>    End_Function
96623>>>>>
96623>>>>>    Procedure Set pbRecnum Boolean bState
96625>>>>>        Set private.pbRecnum  to bState
96626>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96627>>>>>        Delegate Set pbRecnum to bState
96629>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96630>>>>>    End_Procedure
96631>>>>>
96631>>>>>    Function pbRecnum Returns Boolean
96633>>>>>        Function_Return (private.pbRecnum(Self))
96634>>>>>    End_Function
96635>>>>>
96635>>>>>    Procedure Set pbCopyData Boolean bState
96637>>>>>        Set private.pbCopyData  to bState
96638>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96639>>>>>        Delegate Set pbCopyData to bState
96641>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96642>>>>>    End_Procedure
96643>>>>>
96643>>>>>    Function pbCopyData Returns Boolean
96645>>>>>        Function_Return (private.pbCopyData(Self))
96646>>>>>    End_Function
96647>>>>>
96647>>>>>    // ToDo: Should we put these four properties under another "Property Panel" section?
96647>>>>>    Procedure Set pbApiTableUpdateAuto Boolean bState
96649>>>>>        Set private.pbApiTableUpdateAuto  to bState
96650>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96651>>>>>        Set pbApiTableUpdateAuto of ghoSQLConnectionHandler to bState
96652>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96653>>>>>    End_Procedure
96654>>>>>
96654>>>>>    Function pbApiTableUpdateAuto Returns Boolean
96656>>>>>        Function_Return (private.pbApiTableUpdateAuto(Self))
96657>>>>>    End_Function
96658>>>>>
96658>>>>>    Procedure Set pbCompareDate_DateTime Boolean bState
96660>>>>>        Set private.pbCompareDate_DateTime  to bState
96661>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96662>>>>>        Set pbCompareDate_DateTime of ghoSQLConnectionHandler to bState
96663>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96664>>>>>    End_Procedure
96665>>>>>
96665>>>>>    Function pbCompareDate_DateTime Returns Boolean
96667>>>>>        Function_Return (private.pbCompareDate_DateTime(Self))
96668>>>>>    End_Function
96669>>>>>
96669>>>>>    Procedure Set pbCompareIndexAscending Boolean bState
96671>>>>>        Set private.pbCompareIndexAscending  to bState
96672>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96673>>>>>        Set pbCompareIndexAscending of ghoSQLConnectionHandler to bState
96674>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96675>>>>>    End_Procedure
96676>>>>>
96676>>>>>    Function pbCompareIndexAscending Returns Boolean
96678>>>>>        Function_Return (private.pbCompareIndexAscending(Self))
96679>>>>>    End_Function
96680>>>>>
96680>>>>>    Procedure Set pbCompareIndexUppercase Boolean bState
96682>>>>>        Set private.pbCompareIndexUppercase  to bState
96683>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96684>>>>>        Set pbCompareIndexUppercase of ghoSQLConnectionHandler to bState
96685>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96686>>>>>    End_Procedure
96687>>>>>
96687>>>>>    Function pbCompareIndexUppercase Returns Boolean
96689>>>>>        Function_Return (private.pbCompareIndexUppercase(Self))
96690>>>>>    End_Function
96691>>>>>
96691>>>>>    Procedure Set psSchema String sValue
96693>>>>>        Set private.psSchema  to sValue
96694>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96695>>>>>        Delegate Set psSchema to sValue
96697>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96698>>>>>    End_Procedure
96699>>>>>
96699>>>>>    // First retrieve the private value that might have been set in the object.
96699>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
96699>>>>>    // it might have been specified in the SQLConnections.ini file.
96699>>>>>    Function psSchema Returns String
96701>>>>>        String sValue
96701>>>>>        Get private.psSchema to sValue
96702>>>>>        If (sValue = "") Begin
96704>>>>>            Get psSchema of ghoSQLConnectionHandler to sValue
96705>>>>>        End
96705>>>>>>
96705>>>>>        Function_Return sValue
96706>>>>>    End_Function
96707>>>>>
96707>>>>>    Procedure Set psBaseTableSpace String sValue
96709>>>>>        Set private.psBaseTableSpace  to sValue
96710>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96711>>>>>        Delegate Set psBaseTableSpace to sValue
96713>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96714>>>>>    End_Procedure
96715>>>>>
96715>>>>>    // First retrieve the private value that might have been set in the object.
96715>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
96715>>>>>    // it might have been specified in the SQLConnections.ini file.
96715>>>>>    Function psBaseTableSpace Returns String
96717>>>>>        String sValue
96717>>>>>        Get private.psBaseTableSpace to sValue
96718>>>>>        If (sValue = "") Begin
96720>>>>>            Get psBaseTableSpace of ghoSQLConnectionHandler to sValue
96721>>>>>        End
96721>>>>>>
96721>>>>>        Function_Return sValue
96722>>>>>    End_Function
96723>>>>>
96723>>>>>    Procedure Set psLongTableSpace String sValue
96725>>>>>        Set private.psLongTableSpace  to sValue
96726>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96727>>>>>        Delegate Set psLongTableSpace to sValue
96729>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96730>>>>>    End_Procedure
96731>>>>>
96731>>>>>    // First retrieve the private value that might have been set in the object.
96731>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
96731>>>>>    // it might have been specified in the SQLConnections.ini file.
96731>>>>>    Function psLongTableSpace Returns String
96733>>>>>        String sValue
96733>>>>>        Get private.psLongTableSpace to sValue
96734>>>>>        If (sValue = "") Begin
96736>>>>>            Get psLongTableSpace of ghoSQLConnectionHandler to sValue
96737>>>>>        End
96737>>>>>>
96737>>>>>        Function_Return sValue
96738>>>>>    End_Function
96739>>>>>
96739>>>>>    Procedure Set psIndexTableSpace String sValue
96741>>>>>        Set private.psIndexTableSpace  to sValue
96742>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96743>>>>>        Delegate Set psIndexTableSpace to sValue
96745>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96746>>>>>    End_Procedure
96747>>>>>
96747>>>>>    // First retrieve the private value that might have been set in the object.
96747>>>>>    // If blank; get it from the ghoSQLConnectionHandler object as
96747>>>>>    // it might have been specified in the SQLConnections.ini file.
96747>>>>>    Function psIndexTableSpace Returns String
96749>>>>>        String sValue
96749>>>>>        Get private.psIndexTableSpace to sValue
96750>>>>>        If (sValue = "") Begin
96752>>>>>            Get psIndexTableSpace of ghoSQLConnectionHandler to sValue
96753>>>>>        End
96753>>>>>>
96753>>>>>        Function_Return sValue
96754>>>>>    End_Function
96755>>>>>
96755>>>>>    Procedure Set psDriverDefaultValueASCII String sValue
96757>>>>>        Set private.psDriverDefaultValueASCII  to sValue
96758>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96759>>>>>        Delegate Set psDriverDefaultValueASCII to sValue
96761>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96762>>>>>    End_Procedure
96763>>>>>
96763>>>>>    // First retrieve the private value that might have been set in the object.
96763>>>>>    // If blank; get it from the parent object
96763>>>>>    Function psDriverDefaultValueASCII Returns String
96765>>>>>        String sValue
96765>>>>>        Get private.psDriverDefaultValueASCII to sValue
96766>>>>>        If (sValue = "") Begin
96768>>>>>            Delegate Get psDriverDefaultValueASCII to sValue
96770>>>>>        End
96770>>>>>>
96770>>>>>        Function_Return sValue
96771>>>>>    End_Function
96772>>>>>
96772>>>>>    Procedure Set psDriverDefaultValueBinary String sValue
96774>>>>>        Set private.psDriverDefaultValueBinary  to sValue
96775>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96776>>>>>        Delegate Set psDriverDefaultValueBinary to sValue
96778>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96779>>>>>    End_Procedure
96780>>>>>
96780>>>>>    // First retrieve the private value that might have been set in the object.
96780>>>>>    // If blank; get it from the parent object
96780>>>>>    Function psDriverDefaultValueBinary Returns String
96782>>>>>        String sValue
96782>>>>>        Get private.psDriverDefaultValueBinary to sValue
96783>>>>>        If (sValue = "") Begin
96785>>>>>            Delegate Get psDriverDefaultValueBinary to sValue
96787>>>>>        End
96787>>>>>>
96787>>>>>        Function_Return sValue
96788>>>>>    End_Function
96789>>>>>
96789>>>>>    Procedure Set psDriverDefaultValueDate String sValue
96791>>>>>        Set private.psDriverDefaultValueDate  to sValue
96792>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96793>>>>>        Delegate Set psDriverDefaultValueDate to sValue
96795>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96796>>>>>    End_Procedure
96797>>>>>
96797>>>>>    // First retrieve the private value that might have been set in the object.
96797>>>>>    // If blank; get it from the parent object
96797>>>>>    Function psDriverDefaultValueDate Returns String
96799>>>>>        String sValue
96799>>>>>        Get private.psDriverDefaultValueDate to sValue
96800>>>>>        If (sValue = "") Begin
96802>>>>>            Delegate Get psDriverDefaultValueDate to sValue
96804>>>>>        End
96804>>>>>>
96804>>>>>        Function_Return sValue
96805>>>>>    End_Function
96806>>>>>
96806>>>>>    Procedure Set psDriverDefaultValueDateTime String sValue
96808>>>>>        Set private.psDriverDefaultValueDateTime  to sValue
96809>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96810>>>>>        Delegate Set psDriverDefaultValueDateTime to sValue
96812>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96813>>>>>    End_Procedure
96814>>>>>
96814>>>>>    // First retrieve the private value that might have been set in the object.
96814>>>>>    // If blank; get it from the parent object
96814>>>>>    Function psDriverDefaultValueDateTime Returns String
96816>>>>>        String sValue
96816>>>>>        Get private.psDriverDefaultValueDateTime to sValue
96817>>>>>        If (sValue = "") Begin
96819>>>>>            Delegate Get psDriverDefaultValueDateTime to sValue
96821>>>>>        End
96821>>>>>>
96821>>>>>        Function_Return sValue
96822>>>>>    End_Function
96823>>>>>
96823>>>>>    Procedure Set psDriverDefaultValueNumeric String sValue
96825>>>>>        Set private.psDriverDefaultValueNumeric  to sValue
96826>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96827>>>>>        Delegate Set psDriverDefaultValueNumeric to sValue
96829>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96830>>>>>    End_Procedure
96831>>>>>
96831>>>>>    // First retrieve the private value that might have been set in the object.
96831>>>>>    // If blank; get it from the parent object
96831>>>>>    Function psDriverDefaultValueNumeric Returns String
96833>>>>>        String sValue
96833>>>>>        Get private.psDriverDefaultValueNumeric to sValue
96834>>>>>        If (sValue = "") Begin
96836>>>>>            Delegate Get psDriverDefaultValueNumeric to sValue
96838>>>>>        End
96838>>>>>>
96838>>>>>        Function_Return sValue
96839>>>>>    End_Function
96840>>>>>
96840>>>>>    Procedure Set psDriverDefaultValueText String sValue
96842>>>>>        Set private.psDriverDefaultValueText  to sValue
96843>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96844>>>>>        Delegate Set psDriverDefaultValueText to sValue
96846>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96847>>>>>    End_Procedure
96848>>>>>
96848>>>>>    // First retrieve the private value that might have been set in the object.
96848>>>>>    // If blank; get it from the parent object
96848>>>>>    Function psDriverDefaultValueText Returns String
96850>>>>>        String sValue
96850>>>>>        Get private.psDriverDefaultValueText to sValue
96851>>>>>        If (sValue = "") Begin
96853>>>>>            Delegate Get psDriverDefaultValueText to sValue
96855>>>>>        End
96855>>>>>>
96855>>>>>        Function_Return sValue
96856>>>>>    End_Function
96857>>>>>
96857>>>>>    Procedure Set pbDriverDefaultNullableASCII Boolean bState
96859>>>>>        Set private.pbDriverDefaultNullableASCII  to bState
96860>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96861>>>>>        Delegate Set pbDriverDefaultNullableASCII to bState
96863>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96864>>>>>    End_Procedure
96865>>>>>
96865>>>>>    // First retrieve the private value that might have been set in the object.
96865>>>>>    // If blank; get it from the parent object
96865>>>>>    Function pbDriverDefaultNullableASCII Returns Boolean
96867>>>>>        Boolean bState
96867>>>>>        Get private.pbDriverDefaultNullableASCII to bState
96868>>>>>        If (bState = False) Begin
96870>>>>>            Delegate Get pbDriverDefaultNullableASCII to bState
96872>>>>>        End
96872>>>>>>
96872>>>>>        Function_Return bState
96873>>>>>    End_Function
96874>>>>>
96874>>>>>    Procedure Set pbDriverDefaultNullableBinary Boolean bState
96876>>>>>        Set private.pbDriverDefaultNullableBinary  to bState
96877>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96878>>>>>        Delegate Set pbDriverDefaultNullableBinary to bState
96880>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96881>>>>>    End_Procedure
96882>>>>>
96882>>>>>    // First retrieve the private value that might have been set in the object.
96882>>>>>    // If blank; get it from the parent object
96882>>>>>    Function pbDriverDefaultNullableBinary Returns Boolean
96884>>>>>        Boolean bState
96884>>>>>        Get private.pbDriverDefaultNullableBinary to bState
96885>>>>>        If (bState = False) Begin
96887>>>>>            Delegate Get pbDriverDefaultNullableBinary to bState
96889>>>>>        End
96889>>>>>>
96889>>>>>        Function_Return bState
96890>>>>>    End_Function
96891>>>>>
96891>>>>>    Procedure Set pbDriverDefaultNullableDate Boolean bState
96893>>>>>        Set private.pbDriverDefaultNullableDate  to bState
96894>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96895>>>>>        Delegate Set pbDriverDefaultNullableDate to bState
96897>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96898>>>>>    End_Procedure
96899>>>>>
96899>>>>>    // First retrieve the private value that might have been set in the object.
96899>>>>>    // If blank; get it from the parent object
96899>>>>>    Function pbDriverDefaultNullableDate Returns Boolean
96901>>>>>        Boolean bState
96901>>>>>        Get private.pbDriverDefaultNullableDate to bState
96902>>>>>        If (bState = False) Begin
96904>>>>>            Delegate Get pbDriverDefaultNullableDate to bState
96906>>>>>        End
96906>>>>>>
96906>>>>>        Function_Return bState
96907>>>>>    End_Function
96908>>>>>
96908>>>>>    Procedure Set pbDriverDefaultNullableDateTime Boolean bState
96910>>>>>        Set private.pbDriverDefaultNullableDateTime  to bState
96911>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96912>>>>>        Delegate Set pbDriverDefaultNullableDateTime to bState
96914>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96915>>>>>    End_Procedure
96916>>>>>
96916>>>>>    // First retrieve the private value that might have been set in the object.
96916>>>>>    // If blank; get it from the parent object
96916>>>>>    Function pbDriverDefaultNullableDateTime Returns Boolean
96918>>>>>        Boolean bState
96918>>>>>        Get private.pbDriverDefaultNullableDateTime to bState
96919>>>>>        If (bState = False) Begin
96921>>>>>            Delegate Get pbDriverDefaultNullableDateTime to bState
96923>>>>>        End
96923>>>>>>
96923>>>>>        Function_Return bState
96924>>>>>    End_Function
96925>>>>>
96925>>>>>    Procedure Set pbDriverDefaultNullableNumeric Boolean bState
96927>>>>>        Set private.pbDriverDefaultNullableNumeric  to bState
96928>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96929>>>>>        Delegate Set pbDriverDefaultNullableNumeric to bState
96931>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96932>>>>>    End_Procedure
96933>>>>>
96933>>>>>    // First retrieve the private value that might have been set in the object.
96933>>>>>    // If blank; get it from the parent object
96933>>>>>    Function pbDriverDefaultNullableNumeric Returns Boolean
96935>>>>>        Boolean bState
96935>>>>>        Get private.pbDriverDefaultNullableNumeric to bState
96936>>>>>        If (bState = False) Begin
96938>>>>>            Delegate Get pbDriverDefaultNullableNumeric to bState
96940>>>>>        End
96940>>>>>>
96940>>>>>        Function_Return bState
96941>>>>>    End_Function
96942>>>>>
96942>>>>>    Procedure Set pbDriverDefaultNullableText Boolean bState
96944>>>>>        Set private.pbDriverDefaultNullableText  to bState
96945>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96946>>>>>        Delegate Set pbDriverDefaultNullableText to bState
96948>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96949>>>>>    End_Procedure
96950>>>>>
96950>>>>>    // First retrieve the private value that might have been set in the object.
96950>>>>>    // If blank; get it from the parent object
96950>>>>>    Function pbDriverDefaultNullableText Returns Boolean
96952>>>>>        Boolean bState
96952>>>>>        Get private.pbDriverDefaultNullableText to bState
96953>>>>>        If (bState = False) Begin
96955>>>>>            Delegate Get pbDriverDefaultNullableText to bState
96957>>>>>        End
96957>>>>>>
96957>>>>>        Function_Return bState
96958>>>>>    End_Function
96959>>>>>
96959>>>>>    Function ApiTableConvertToSQL Handle hTable Returns Boolean
96961>>>>>        Boolean bUseConnectionID bToANSI bRecnum bCopyData bOK
96961>>>>>        String sDriverID sSchema sBaseTableSpace sLongTableSpace sIndexTableSpace
96961>>>>>
96961>>>>>        Get psDriverID to sDriverID
96962>>>>>        Get psSchema to sSchema
96963>>>>>
96963>>>>>        Get psBaseTableSpace to sBaseTableSpace
96964>>>>>        If (sBaseTableSpace <> "") Begin
96966>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96967>>>>>            Delegate Set psBaseTableSpace to sBaseTableSpace
96969>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96970>>>>>        End
96970>>>>>>
96970>>>>>
96970>>>>>        Get psLongTableSpace to sLongTableSpace
96971>>>>>        If (sLongTableSpace <> "") Begin
96973>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96974>>>>>            Delegate Set psLongTableSpace to sLongTableSpace
96976>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96977>>>>>        End
96977>>>>>>
96977>>>>>
96977>>>>>        Get psIndexTableSpace to sIndexTableSpace
96978>>>>>        If (sIndexTableSpace <> "") Begin
96980>>>>>            Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
96981>>>>>            Delegate Set psIndexTableSpace to sIndexTableSpace
96983>>>>>            Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
96984>>>>>        End
96984>>>>>>
96984>>>>>
96984>>>>>        Get pbUseConnectionID to bUseConnectionID
96985>>>>>        Get pbToANSI          to bToANSI
96986>>>>>        Get pbRecnum          to bRecnum
96987>>>>>        Get pbCopyData        to bCopyData
96988>>>>>
96988>>>>>        Get ApiTableConvertToSQL_Ex hTable sDriverID bUseConnectionID bToANSI bRecnum bCopyData to bOK
96989>>>>>
96989>>>>>        Function_Return bOK
96990>>>>>    End_Function
96991>>>>>
96991>>>>>//    Function ApiTableMoveAllToBackupFolder Returns Boolean
96991>>>>>//        Boolean bOK bExists
96991>>>>>//        String sDataPath sBackupFolder
96991>>>>>//        
96991>>>>>//        Set Message_Text of ghoStatusPanel to "Moving Embedded (*.dat) files to Backup folder."
96991>>>>>//        Move CS_DUFBackupDataFolder to sBackupFolder
96991>>>>>//        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
96991>>>>>//        Get vFolderFormat sDataPath to sDataPath
96991>>>>>//        
96991>>>>>//        Get vFilePathExists (sDataPath + sBackupFolder) to bExists
96991>>>>>//        If (bExists = False) Begin
96991>>>>>//            Get vCreateDirectory (sDataPath + sBackupFolder) to bOK
96991>>>>>//            Get vFilePathExists (sDataPath + sBackupFolder) to bExists
96991>>>>>//            If (bExists = False) Begin
96991>>>>>//                Error DFERR_PROGRAM ("Could not create the the backup data folder to move all *.dat and *.k?? files to. You need to move them somewhere manually.")
96991>>>>>//                Function_Return False
96991>>>>>//            End                                                                                                                                            
96991>>>>>//            Get vMoveFile (sDataPath + "*.dat") (sDataPath + sBackupFolder) to bOK
96991>>>>>//            Get vMoveFile (sDataPath + "*.hdr") (sDataPath + sBackupFolder) to bOK
96991>>>>>//            Get vMoveFile (sDataPath + "*.k??") (sDataPath + sBackupFolder) to bOK
96991>>>>>//            Get vMoveFile (sDataPath + "*.vld") (sDataPath + sBackupFolder) to bOK
96991>>>>>//        End
96991>>>>>//        
96991>>>>>//        Set Message_Text of ghoStatusPanel to ""
96991>>>>>//        Function_Return bOK
96991>>>>>//    End_Function
96991>>>>>//
96991>>>>>    // This is automatically called after the OnUpdate
96991>>>>>    // event has been executed. It will automatically update the
96991>>>>>    // version database field/column with the "pnVersionNumber"
96991>>>>>    // value of the parent cDbUpdateHandler class - if it has been changed.
96991>>>>>    Procedure UpdateVersionColumnValue
96993>>>>>        Number nVersion nCurrentValue
96993>>>>>        Integer hTable iColumn
96993>>>>>        Boolean bVersionUpdate bDbUpdateErrorHasOccured bUseCustomDbVersion
96993>>>>>
96993>>>>>        // This is a property of the container class; cDbUpdateHandler that gets set when
96993>>>>>        // an error occurres when processing ESQL or database API messages of the cDbUpdateFunctionLibrary.
96993>>>>>        Delegate Get pbDbUpdateErrorHasOccured to bDbUpdateErrorHasOccured
96995>>>>>        Get pbVersionUpdate to bVersionUpdate
96996>>>>>
96996>>>>>        If (bVersionUpdate = True and bDbUpdateErrorHasOccured = False) Begin
96998>>>>>            Get pnVersionNumber to nVersion
96999>>>>>            Delegate Get piDbVersionFileNumber  to hTable
97001>>>>>            Delegate Get piDbVersionFieldNumber to iColumn
97003>>>>>            // NB! We need to permanently close tables as they e.g. now might no longer be embedded
97003>>>>>            // but instead SQL tables. If we don't the "old" embedded table will be opened instead.
97003>>>>>            Close DF_ALL DF_PERMANENT
97004>>>>>
97004>>>>>            Open hTable
97006>>>>>
97006>>>>>            // It is then the developer responsibility to take care of finding
97006>>>>>            // the correct record that is to be updated (The DbVersion table is not used). 
97006>>>>>            Delegate Get pbUseCustomDbVersion to bUseCustomDbVersion
97008>>>>>            If (bUseCustomDbVersion = True) Begin
97010>>>>>                Delegate Send OnFindVersionRecord   // cDbUpdateHandler object event (Programmer's hook!).
97012>>>>>            End
97012>>>>>>
97012>>>>>
97012>>>>>            Get_Field_Value hTable iColumn to nCurrentValue
97015>>>>>            If (nCurrentValue < nVersion) Begin
97017>>>>>                Lock
97018>>>>>>
97018>>>>>                    If (bUseCustomDbVersion = False) Begin
97020>>>>>                        Vfind hTable Recnum GE                            
97022>>>>>                    End
97022>>>>>>
97022>>>>>                    Set_Field_Value hTable iColumn to nVersion
97025>>>>>                    SaveRecord hTable
97026>>>>>                Unlock
97027>>>>>>
97027>>>>>            End
97027>>>>>>
97027>>>>>            Close hTable
97028>>>>>        End
97028>>>>>>
97028>>>>>    End_Procedure
97029>>>>>
97029>>>>>// Property of the container object (cDbUpdateHandler)
97029>>>>>Register_Function piCurrentErrorHandlerID Returns Integer
97029>>>>>
97029>>>>>    Procedure End_Construct_Object
97031>>>>>        Forward Send End_Construct_Object
97033>>>>>        Send ProcessUpdate True
97034>>>>>    End_Procedure
97035>>>>>    
97035>>>>>    Procedure ProcessUpdate Boolean bShouldTestForDuplicateVersionNumbers
97037>>>>>        Number nVersion nCurrentValue
97037>>>>>        Integer hTable iColumn iSize iDbVersionFileNumber iStatus
97037>>>>>        Boolean bStopOnFirstError bDbUpdateErrorHasOccured bContinueOnError bOpened bSystemTable bUseCustomDbVersion bTableExists bOnPreUpdateExecuted
97037>>>>>        String sObjectName
97037>>>>>        tDbVersionInfo[] dbVersionInfoArray
97037>>>>>        tDbVersionInfo[] dbVersionInfoArray
97038>>>>>
97038>>>>>        Delegate Set Private.pbUpdateVersionObjectError to False
97040>>>>>
97040>>>>>        // If the programmer forgot to set the version number we do not allow for the application
97040>>>>>        // to continue to run, as this potentially could endanger the integrity of the database. E.g. if
97040>>>>>        // one database update is depended on an earlier update and that earlier version
97040>>>>>        // update was never executed it could lead to disastrous results.
97040>>>>>        // This is a programmer error and should be discovered before any customer sees it. Thus no point in translating...
97040>>>>>        Get pnVersionNumber to nVersion
97041>>>>>        If (nVersion = 0) Begin
97043>>>>>            Get piCurrentErrorHandlerID to Error_Object_Id
97044>>>>>            Move (Name(Self)) to sObjectName
97045>>>>>            Error DFERR_PROGRAM ("The pnVersionNumber property was not set properly by the programmer for the following object; Program will now exit!\n\n" + sObjectName)
97046>>>>>>
97046>>>>>            Send Exit_Application
97047>>>>>        End
97047>>>>>>
97047>>>>>
97047>>>>>        // These are send to the parent container object (cDbUpdateHandler). The order is very sensitive!
97047>>>>>        // Hook event for the developer to e.g. create a database before the update events starts.
97047>>>>>        Delegate Get Private.pbOnPreUpdateExecuted to bOnPreUpdateExecuted
97049>>>>>        If (bOnPreUpdateExecuted = False) Begin
97051>>>>>            Delegate Send OnPreUpdate
97053>>>>>            Delegate Set Private.pbOnPreUpdateExecuted to True
97055>>>>>        End
97055>>>>>>
97055>>>>>        
97055>>>>>        Delegate Get piDbVersionFileNumber to iDbVersionFileNumber
97057>>>>>        
97057>>>>>        Delegate Get pbUseCustomDbVersion to bUseCustomDbVersion
97059>>>>>        If (bUseCustomDbVersion = False) Begin
97061>>>>>//            Delegate Send CheckAutoCreateDbVersionTable // cDbUpdateHandler object event.
97061>>>>>        End
97061>>>>>>
97061>>>>>        Else Begin
97062>>>>>            Get UtilTableExists of ghoDbUpdateFunctionLibrary iDbVersionFileNumber to bTableExists
97063>>>>>            If (bTableExists = False) Begin
97065>>>>>                Delegate Send OnCreateCustomDbVersionTable
97067>>>>>            End
97067>>>>>>
97067>>>>>        End
97067>>>>>>
97067>>>>>        
97067>>>>>        // We now check that two or more cDbVersion objects does not have the same pnVersionNumber.
97067>>>>>        // Note that the paDbVersionInfoArray is a property of the container object (cDbUpdateHandler)
97067>>>>>        If (bShouldTestForDuplicateVersionNumbers = True) Begin
97069>>>>>            Delegate Get paDbVersionInfoArray to dbVersionInfoArray
97071>>>>>            Move (SizeOfArray(dbVersionInfoArray)) to iSize
97072>>>>>            Move nVersion to dbVersionInfoArray[iSize].nVersionNumber
97073>>>>>            Move (Self)   to dbVersionInfoArray[iSize].hObject
97074>>>>>            Delegate Set paDbVersionInfoArray to dbVersionInfoArray
97076>>>>>            Delegate Send CheckForDuplicates nVersion   // cDbUpdateHandler object event.
97078>>>>>        End
97078>>>>>>
97078>>>>>
97078>>>>>        Delegate Get piDbVersionFileNumber  to hTable
97080>>>>>        Delegate Get piDbVersionFieldNumber to iColumn
97082>>>>>
97082>>>>>        Open hTable
97084>>>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
97087>>>>>        If (bOpened = False) Begin
97089>>>>>            Send Stop_Box CS_DUF_DbUpdateTableMissing
97090>>>>>            Send Exit_Application
97091>>>>>        End
97091>>>>>>
97091>>>>>        
97091>>>>>        // It can happen that the table isn't initialized with a record even though it is a system table,
97091>>>>>        // in case we take care of it here.
97091>>>>>        Get_Attribute DF_FILE_STATUS of hTable to iStatus
97094>>>>>        If (iStatus = DF_FILE_INACTIVE) Begin
97096>>>>>            Vfind hTable 0 GT
97098>>>>>        End
97098>>>>>>
97098>>>>>        Get_Attribute DF_FILE_IS_SYSTEM_FILE of hTable to bSystemTable
97101>>>>>        If (bSystemTable = True) Begin
97103>>>>>            Get_Field_Value hTable iColumn to nCurrentValue
97106>>>>>        End
97106>>>>>>
97106>>>>>        Else Begin
97107>>>>>            If (bUseCustomDbVersion = True) Begin
97109>>>>>                Send OnFindVersionRecord
97110>>>>>                Get_Field_Value hTable iColumn to nCurrentValue
97113>>>>>            End
97113>>>>>>
97113>>>>>        End
97113>>>>>>
97113>>>>>
97113>>>>>        Close hTable
97114>>>>>
97114>>>>>        // We also guard from missing 'DatabaseVersionInfoTable' and column properties settings.
97114>>>>>        // If not set we do nothing.
97114>>>>>        If (nCurrentValue < nVersion) Begin
97116>>>>>
97116>>>>>            // If pbStopOnFirstError is True in the parent, the idea is that we do _no_ further
97116>>>>>            // execution of database update code. So if true _and_ one error
97116>>>>>            // has already occured; we're out of here.
97116>>>>>            Delegate Get pbStopOnFirstError        to bStopOnFirstError
97118>>>>>            Delegate Get pbDbUpdateErrorHasOccured to bDbUpdateErrorHasOccured
97120>>>>>            If (bStopOnFirstError = True) Begin
97122>>>>>                If (bDbUpdateErrorHasOccured = True) Begin
97124>>>>>                    Procedure_Return
97125>>>>>                End
97125>>>>>>
97125>>>>>            End
97125>>>>>>
97125>>>>>
97125>>>>>            // This is send to the parent container object (cDbUpdateHandler)
97125>>>>>            Delegate Send InitDatabaseUpdate (Self)    // cDbUpdateHandler object event.
97127>>>>>
97127>>>>>            // If the parent property pbContinueOnError = False, an update
97127>>>>>            // of a following cDbUpdateVersion object should not take place and we're out of here.
97127>>>>>            Delegate Get pbContinueOnError to bContinueOnError
97129>>>>>            If (bContinueOnError = False and bDbUpdateErrorHasOccured = True) Begin
97131>>>>>                Procedure_Return
97132>>>>>            End
97132>>>>>>
97132>>>>>
97132>>>>>            Delegate Set pnCurrentVersionUpdate to nVersion
97134>>>>>
97134>>>>>            Set Title_Text of ghoStatusPanel to (CS_DUF_UpdateVersion * CS_DUF_UpdateFromVersion * String(nCurrentValue) * CS_DUF_UpdateToVersion * String(nVersion))
97135>>>>>
97135>>>>>            // *** Programmer's main hook event for database update functions:
97135>>>>>            Send OnUpdate
97136>>>>>
97136>>>>>            Set pbVersionUpdate to True
97137>>>>>            Send UpdateVersionColumnValue
97138>>>>>            Delegate Set pbDatabaseWasUpdated to True   // cDbUpdateHandler property.
97140>>>>>        End
97140>>>>>>
97140>>>>>
97140>>>>>    End_Procedure
97141>>>>>
97141>>>>>End_Class
97142>>>Use cDbUpdateUserCount.pkg
Including file: cDbUpdateUserCount.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateUserCount.pkg)
97142>>>>>//****************************************************************************
97142>>>>>// $Module type: Class
97142>>>>>// $Module name: cDbUpdateUserCount.pkg
97142>>>>>// $Author     : Emil Stojanov Quantaris B.V.
97142>>>>>//
97142>>>>>//               Collected from DAW's newsgroups.
97142>>>>>//
97142>>>>>// Description : It uses the windows API to lock bytes in a file.
97142>>>>>//               If the application or PC craches it will release the lock
97142>>>>>//               automatically.
97142>>>>>//
97142>>>>>// Note 1      : It will count the number of running app's, so if a
97142>>>>>//               user starts the app twice on one machine it will count as two users.
97142>>>>>// Note 2      : The class was originally named cUserCount by Emil Stojanov.
97142>>>>>//               However, to not conflict with any other usage of this class it was
97142>>>>>//               renamed to "fit" into the "Database Update Framework" (cDbUpdateHandler
97142>>>>>//               and cDbUpdateVersion classes)
97142>>>>>//
97142>>>>>// $Rev History:
97142>>>>>//    2008-10-17  Module header created (Militaty data format)
97142>>>>>//    2008-10-17  Minor changes by Nils G Svedmyr. Created UI text constants
97142>>>>>//                for easy translation to other languages.
97142>>>>>//                Added the tUserCount struct for easier passing of parameters.
97142>>>>>//                Added the ApplicationPath message.
97142>>>>>//****************************************************************************
97142>>>>>Use LanguageText.pkg
97142>>>>>Use cDbUpdateUserCount.inc
Including file: cDbUpdateUserCount.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbUpdateUserCount.inc)
97142>>>>>>>Use GlobalFunctionsProcedures.pkg
97142>>>>>>>// Sample:
97142>>>>>>>// Get DoSetDefaultPrinter "HP LaserJet 4" to bVoid
97142>>>>>>>
97142>>>>>>>
97142>>>>>>>// Symbols used by UserCounting
97142>>>>>>>    Define GENERIC_READ         for |CI$80000000
97142>>>>>>>    Define GENERIC_WRITE        for |CI$40000000
97142>>>>>>>    Define GENERIC_EXECUTE      for |CI$20000000
97142>>>>>>>    Define GENERIC_ALL          for |CI$10000000
97142>>>>>>>    Define CREATE_NEW           for 1
97142>>>>>>>    Define CREATE_ALWAYS        for 2
97142>>>>>>>    Define OPEN_EXISTING        for 3
97142>>>>>>>    Define OPEN_ALWAYS          for 4
97142>>>>>>>    Define TRUNCATE_EXISTING    for 5
97142>>>>>>>    Define FILE_BEGIN           for 0
97142>>>>>>>    Define FILE_CURRENT         for 1
97142>>>>>>>    Define FILE_END             for 2
97142>>>>>>>    Define FILE_SHARE_READ      for |CI$00000001
97142>>>>>>>    Define FILE_SHARE_WRITE     for |CI$00000002
97142>>>>>>>    Define FILE_SHARE_DELETE    for |CI$00000004
97142>>>>>>>    Define FILE_FLAG_WRITE_THROUGH            for |CI$80000000
97142>>>>>>>    Define _MAX_PATH  for 260
97142>>>>>>>    Define _MAX_DRIVE for 3
97142>>>>>>>    Define _MAX_DIR   for 256
97142>>>>>>>    Define _MAX_FNAME for 256
97142>>>>>>>    Define _MAX_EXT   for 256
97142>>>>>>>
97142>>>>>>>External_Function Win32_CreateFile "CreateFileA" KERNEL32.DLL ;    Pointer lpFileName ;              // file name    DWord dwDesiredAccess ;           // access mode    DWord dwShareMode ;               // share mode    Pointer lpSecurityAttributes ;    // SD    DWord dwCreationDisposition ;     // how to create    DWord dwFlagsAndAttributes ;      // file attributes    Handle hTemplateFile ;            // handle to template file    Returns Handle
97143>>>>>>>
97143>>>>>>>External_Function Win32_ReadFile "ReadFile" KERNEL32.DLL ;    Handle hFile ;                  // handle to file    Pointer lpBuffer ;              // pointer to the buffer that receives the data    dWord nNumberOfBytesToRead ;    // number of bytes to read    Pointer lpNumberOfBytesRead ;   // number of bytes read    Pointer lpOverlapped ;          // pointer to an overlapped structure    Returns Integer
97144>>>>>>>
97144>>>>>>>External_Function Win32_WriteFile "WriteFile" KERNEL32.DLL ;    Handle hFile ;                      // handle to file    Pointer lpBuffer ;                  // pointer to buffer containing data to write    dWord nNumberOfBytesToWrite ;       // number of bytes to write    Pointer lpNumberOfBytesWritten ;    // number of bytes written    Pointer lpOverlapped ;              // pointer to an overlapped structure    Returns Integer
97145>>>>>>>
97145>>>>>>>External_Function Win32_LockFile "LockFile" KERNEL32.DLL ;    Handle hFile ;                      // handle to file    dWord dwFileOffsetLow ;             // low-order word of startposition    dWord dwFileOffsetHigh ;            // high-order word of startposition    dWord nNumberOfBytesToLockLow ;     // low-order word of length    dWord nNumberOfBytesToLockHigh ;    // high-order word of length    Returns Integer
97146>>>>>>>
97146>>>>>>>External_Function Win32_UnlockFile "UnlockFile" KERNEL32.DLL ;    Handle hFile ;                      // handle to file    dWord dwFileOffsetLow ;             // low-order word of startposition    dWord dwFileOffsetHigh ;            // high-order word of startposition    dWord nNumberOfBytesToUnLockLow ;   // low-order word of length    dWord nNumberOfBytesToUnLockHigh ;  // high-order word of length    Returns Integer
97147>>>>>>>
97147>>>>>>>External_Function Win32_SetFilePointer "SetFilePointer" KERNEL32.DLL ;    Handle hFile ;                  // handle to file    Integer lDistanceToMove ;       // bytes to move pointer (low-order 32-bits)    Pointer lpDistanceToMoveHigh ;  // bytes to move pointer (high-order 32-bits)    dWord dwMoveMethod ;            // starting point    Returns dWord
97148>>>>>>>
97148>>>>>>>External_Function Win32_CloseHandle "CloseHandle" KERNEL32.DLL ;    Handle hObject ;    // handle to object    Returns Integer
97149>>>>>>>
97149>>>>>>>External_Function SetDefaultPrinterEf "SetDefaultPrinterA" winspool.drv Pointer lpPrinter Returns Boolean
97150>>>>>>>// Sample:
97150>>>>>>>// Get DoSetDefaultPrinter "HP LaserJet 4" to bVoid
97150>>>>>>>Function DoSetDefaultPrinter String sPrinter Returns Boolean
97152>>>>>>>    Boolean bReturn
97152>>>>>>>    Move (ToANSI(sPrinter)) to sPrinter
97153>>>>>>>    Move (sPrinter + (Character(0))) to sPrinter
97154>>>>>>>    Move (SetDefaultPrinterEf(AddressOf(sPrinter))) to bReturn
97155>>>>>>>    Function_Return bReturn
97156>>>>>>>End_Function
97157>>>>>Use vWin32fh.pkg
97157>>>>>Use seq_chnl.pkg
97157>>>>>
97157>>>>>// User interface constant strings:
97157>>>>>    Define CS_UserCountError            for "User count error:"
97157>>>>>    Define CS_UnableToInitUserCountSys  for "Unable to initialize user counting system!"
97157>>>>>    Define CS_UnableResetUserCountSys   for "Error resetting usercounting system!"
97157>>>>>    Define CS_ErrorAdvancingPointer     for "Error advancing file pointer!"
97157>>>>>    Define CS_MaxNoOfUserExceeded       for "Maximum number of users exceeded!"
97157>>>>>
97157>>>>>
97157>>>>>
97157>>>>>
97157>>>>>
97157>>>>>
97157>>>>>
97157>>>>>
97157>>>>>
97157>>>>>
97157>>>>>
97157>>>>>
97157>>>>>
97157>>>>>    Struct tUserCount
97157>>>>>        Integer iUserCount
97157>>>>>        Integer iError
97157>>>>>        String  sErrorTxt
97157>>>>>    End_Struct
97157>>>>>
97157>>>>>    Define CI_UserCountMaxUsers for 9999
97157>>>>>
97157>>>>>Class cDbUpdateUserCount is a cObject
97158>>>>>    Procedure Construct_Object
97160>>>>>        Forward Send Construct_Object
97162>>>>>
97162>>>>>        Property String  psLockFileName
97163>>>>>        Property Integer piMaxUsers
97164>>>>>        Property Boolean pbCheckDataFlexUserCount True
97165>>>>>
97165>>>>>        Property Handle  phUserCountFile
97166>>>>>        Property Integer pdwLockPosition
97167>>>>>    End_Procedure
97168>>>>>
97168>>>>>    Function IsProgramRunning Returns Boolean
97170>>>>>        tUserCount UserCount
97170>>>>>        tUserCount UserCount
97170>>>>>
97170>>>>>        Get CheckUserCount to UserCount
97171>>>>>
97171>>>>>        Function_Return (UserCount.iUserCount > 1)
97172>>>>>    End_Function
97173>>>>>
97173>>>>>    // Returns the full path of the Application (no trailing "\")
97173>>>>>    Function ApplicationPath Returns String
97175>>>>>        String sApplicationFileName sPath
97175>>>>>        Integer iNumChars iRetval
97175>>>>>
97175>>>>>        Move (Repeat(Character(0), 1024))    to sApplicationFileName
97176>>>>>        Move (GetModuleFileName(0, AddressOf(sApplicationFileName), 1024)) to iNumChars
97177>>>>>        Move (CString(sApplicationFileName)) to sApplicationFileName
97178>>>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to iRetval
97179>>>>>        Move (CString(sApplicationFileName)) to sPath
97180>>>>>
97180>>>>>        Function_Return sPath
97181>>>>>    End_Function
97182>>>>>
97182>>>>>    Function OpenUserCountFile String sFileName Returns Handle
97184>>>>>        Handle  hFile
97184>>>>>        Pointer pFileName
97184>>>>>        String sPath sFile
97184>>>>>        Integer iCh
97184>>>>>
97184>>>>>        Move (Addressof(sFileName)) to pFileName
97185>>>>>        Move (Win32_CreateFile(pFileName, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, (FILE_ATTRIBUTE_NORMAL ior FILE_FLAG_WRITE_THROUGH), 0)) to hFile
97186>>>>>
97186>>>>>        // If lock file doesn't exist, create it.
97186>>>>>        If (hFile = INVALID_HANDLE_VALUE) Begin
97188>>>>>            Get ApplicationPath to sPath
97189>>>>>            Get vFolderFormat sPath to sPath
97190>>>>>            Move (sPath + psLockFileName(Self)) to sFile
97191>>>>>            Get Seq_Open_Output_Channel sFile to iCh
97192>>>>>            If (iCh = DF_SEQ_CHANNEL_ERROR) Begin
97194>>>>>                Function_Return 0
97195>>>>>            End
97195>>>>>>
97195>>>>>            Direct_Output channel iCh sFile
97197>>>>>                Write channel iCh ""
97199>>>>>            Send Seq_Close_Channel iCh
97200>>>>>            Move (Win32_CreateFile(pFileName, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, (FILE_ATTRIBUTE_NORMAL ior FILE_FLAG_WRITE_THROUGH), 0)) to hFile
97201>>>>>        End
97201>>>>>>
97201>>>>>
97201>>>>>        Function_Return hFile
97202>>>>>    End_Function
97203>>>>>
97203>>>>>    Function CloseUserCountFile Handle hFile Returns Integer
97205>>>>>        Integer iReturnValue 
97205>>>>>        Boolean bOK
97205>>>>>
97205>>>>>        Move (Win32_CloseHandle(hFile)) to iReturnValue
97206>>>>>        If (iReturnValue = 0) Begin
97208>>>>>            Move False to bOK
97209>>>>>        End
97209>>>>>>
97209>>>>>        Else Begin
97210>>>>>            Move True to bOK
97211>>>>>        End
97211>>>>>>
97211>>>>>        Function_Return bOK
97212>>>>>    End_Function
97213>>>>>
97213>>>>>    Function UnlockUserCountFile Handle hFile dWord dwLockPos Returns Integer
97215>>>>>        Integer iReturnValue
97215>>>>>        Boolean bOK
97215>>>>>
97215>>>>>        Move (Win32_UnLockFile(hFile, dwLockPos, 0, 1, 0)) to iReturnValue
97216>>>>>        If (iReturnValue = 0) Begin
97218>>>>>            Move False to bOK
97219>>>>>        End
97219>>>>>>
97219>>>>>        Else Begin
97220>>>>>            Move True to bOK
97221>>>>>        End           
97221>>>>>>
97221>>>>>        Function_Return bOK
97222>>>>>    End_Function
97223>>>>>
97223>>>>>    Function ReSetUserCountPointer Handle hFile Returns dWord
97225>>>>>        dWord dwCurrPos
97225>>>>>
97225>>>>>        Move (Win32_SetFilePointer(hFile, 0, 0, FILE_BEGIN)) to dwCurrPos
97226>>>>>        Function_Return dwCurrPos
97227>>>>>    End_Function
97228>>>>>
97228>>>>>    Function SetUserCountPointer Handle hFile Integer iAdvance Returns dWord
97230>>>>>        DWord dwCurrPos
97230>>>>>
97230>>>>>        Move (Win32_SetFilePointer(hFile, iAdvance, 0, FILE_CURRENT)) to dwCurrPos
97231>>>>>        Function_Return dwCurrPos
97232>>>>>    End_Function
97233>>>>>
97233>>>>>    Function ReadUserCountFile Handle hFile Returns Boolean
97235>>>>>        Integer iReturnValue                               
97235>>>>>        Boolean bOK
97235>>>>>        String  sBuffer
97235>>>>>        Pointer pBuffer
97235>>>>>        String  sSize
97235>>>>>        Pointer pSize
97235>>>>>
97235>>>>>        Move (Repeat((Character(0)),5)) to sBuffer
97236>>>>>        Move (AddressOf(sBuffer)) to pBuffer
97237>>>>>
97237>>>>>        Move (Repeat((Character(0)),4)) to sSize
97238>>>>>        Move (AddressOf(sSize)) to pSize
97239>>>>>
97239>>>>>        Move (Win32_ReadFile(hFile, pBuffer, 1, pSize, 0)) to iReturnValue
97240>>>>>        If (iReturnValue = 0) Begin
97242>>>>>            Move False to bOK
97243>>>>>        End
97243>>>>>>
97243>>>>>        Else Begin
97244>>>>>            Move True to bOK
97245>>>>>        End                 
97245>>>>>>
97245>>>>>        Function_Return bOK
97246>>>>>    End_Function
97247>>>>>
97247>>>>>    Function LockUserCountFile Handle hFile dWord dwFilePos Returns Integer
97249>>>>>        Integer iReturnValue
97249>>>>>
97249>>>>>        Move (Win32_LockFile(hFile, dwFilePos, 0, 1, 0)) to iReturnValue
97250>>>>>        Function_Return iReturnValue
97251>>>>>    End_Function
97252>>>>>
97252>>>>>    Procedure DoCheckUserCount
97254>>>>>        tUserCount UserCount
97254>>>>>        tUserCount UserCount
97254>>>>>
97254>>>>>        Get CheckUserCount to UserCount
97255>>>>>        // If all is fine, we're done.
97255>>>>>        If (UserCount.iError = 0) Begin
97257>>>>>            Procedure_Return
97258>>>>>        End
97258>>>>>>
97258>>>>>
97258>>>>>        Send UserError (CS_UserCountError * String(UserCount.iError) + "\n" + UserCount.sErrorTxt)
97259>>>>>
97259>>>>>        If (UserCount.iUserCount = CI_UserCountMaxUsers) Begin
97261>>>>>            Abort
97262>>>>>>
97262>>>>>        End
97262>>>>>>
97262>>>>>    End_Procedure
97263>>>>>
97263>>>>>    Function CheckUserCount Returns tUserCount
97265>>>>>        Handle  hFile
97265>>>>>        String  sPath sFile
97265>>>>>        Integer iResult
97265>>>>>        DWord   dwFilePos
97265>>>>>        Integer bLocked
97265>>>>>        Integer iMaxUsers
97265>>>>>        Integer iCurUser
97265>>>>>        tUserCount UserCount
97265>>>>>        tUserCount UserCount
97265>>>>>
97265>>>>>        Move 0 to UserCount.iError
97266>>>>>
97266>>>>>        Get phUserCountFile to hFile
97267>>>>>        If (not(hFile)) Begin
97269>>>>>            Get ApplicationPath to sPath
97270>>>>>            Get vFolderFormat sPath to sPath
97271>>>>>            Move (sPath + psLockFileName(Self)) to sFile
97272>>>>>            Get OpenUserCountFile sFile to hFile
97273>>>>>            If (hFile = INVALID_HANDLE_VALUE) Begin
97275>>>>>                Move 1 to UserCount.iUserCount
97276>>>>>                Move 1 to UserCount.iError
97277>>>>>                Move CS_UnableToInitUserCountSys to UserCount.sErrorTxt
97278>>>>>                Function_Return UserCount
97279>>>>>            End
97279>>>>>>
97279>>>>>            Else Begin
97280>>>>>                Move False to bLocked
97281>>>>>                Set phUserCountFile to hFile
97282>>>>>                Get piMaxUsers to iMaxUsers
97283>>>>>
97283>>>>>                // Set Filepointer to beginning of the file
97283>>>>>                Get ResetUserCountPointer hFile to dwFilePos
97284>>>>>                If (dwFilePos = -1) Begin
97286>>>>>                    Move 1 to UserCount.iUserCount
97287>>>>>                    Move 2 to UserCount.iError
97288>>>>>                    Move CS_UnableResetUserCountSys to UserCount.sErrorTxt
97289>>>>>                    Function_Return UserCount
97290>>>>>                End
97290>>>>>>
97290>>>>>                For iCurUser from 1 to iMaxUsers
97296>>>>>>
97296>>>>>                    Get LockUserCountFile hFile dwFilePos to iResult
97297>>>>>                    If (not(iResult)) Begin  // byte is locked
97299>>>>>                        Get SetUserCountPointer hFile 10 to dwFilePos
97300>>>>>                        If (dwFilePos = -1) Begin
97302>>>>>                            Move 1 to UserCount.iUserCount
97303>>>>>                            Move 3 to UserCount.iError
97304>>>>>                            Move CS_ErrorAdvancingPointer to UserCount.sErrorTxt
97305>>>>>                            Function_Return UserCount
97306>>>>>                        End
97306>>>>>>
97306>>>>>                    End
97306>>>>>>
97306>>>>>                    Else Begin  // byte is not locked
97307>>>>>                        Set pdwLockPosition to dwFilePos
97308>>>>>                        Move True to bLocked
97309>>>>>                        Move iMaxUsers to iCurUser
97310>>>>>                    End
97310>>>>>>
97310>>>>>                Loop
97311>>>>>>
97311>>>>>                If (not(bLocked)) Begin
97313>>>>>                    Move CI_UserCountMaxUsers to UserCount.iUserCount
97314>>>>>                    Move 4 to UserCount.iError
97315>>>>>                    Move CS_MaxNoOfUserExceeded to UserCount.sErrorTxt
97316>>>>>                    Function_Return UserCount
97317>>>>>                End
97317>>>>>>
97317>>>>>            End
97317>>>>>>
97317>>>>>        End
97317>>>>>>
97317>>>>>
97317>>>>>        Function_Return UserCount
97318>>>>>    End_Function
97319>>>>>
97319>>>>>
97319>>>>>    Procedure DoReleaseUserCount
97321>>>>>        Integer iResult
97321>>>>>        Handle  hFile
97321>>>>>        DWord   dwLockPos
97321>>>>>
97321>>>>>        Get phUserCountFile to hFile
97322>>>>>        Get pdwLockPosition to dwLockPos
97323>>>>>        If (hFile) Begin
97325>>>>>            If (dwLockPos) Begin
97327>>>>>                Get UnlockUserCountFile hFile dwLockPos to iResult
97328>>>>>            End
97328>>>>>>
97328>>>>>            Get CloseUserCountFile hFile to iResult
97329>>>>>        End
97329>>>>>>
97329>>>>>    End_Procedure
97330>>>>>
97330>>>>>    Function CurrentNumberOfUsers Returns Integer
97332>>>>>        Handle  hFile
97332>>>>>        Integer iMaxUsers
97332>>>>>        DWord   dwFilePos
97332>>>>>        Integer iCurUser
97332>>>>>        Integer iResult
97332>>>>>        Integer iNumberOfLocks
97332>>>>>        String  sPath sFile
97332>>>>>
97332>>>>>        Move 0 to iNumberOfLocks
97333>>>>>
97333>>>>>        Get ApplicationPath to sPath
97334>>>>>        Get vFolderFormat sPath to sPath
97335>>>>>        Move (sPath + psLockFileName(Self)) to sFile
97336>>>>>        Get OpenUserCountFile sFile to hFile
97337>>>>>        If (hFile = INVALID_HANDLE_VALUE) Begin
97339>>>>>            Send UserError CS_UnableToInitUserCountSys
97340>>>>>            Abort
97341>>>>>>
97341>>>>>        End
97341>>>>>>
97341>>>>>
97341>>>>>        If (hFile > 0) Begin
97343>>>>>            Get piMaxUsers To iMaxUsers
97344>>>>>
97344>>>>>            // Set Filepointer to beginning of the file
97344>>>>>            Get ResetUserCountPointer hFile to dwFilePos
97345>>>>>            If (dwFilePos = -1) Begin
97347>>>>>                Send UserError CS_UnableResetUserCountSys
97348>>>>>                Abort
97349>>>>>>
97349>>>>>            End
97349>>>>>>
97349>>>>>            For iCurUser from 1 to iMaxUsers
97355>>>>>>
97355>>>>>                Get LockUserCountFile hFile dwFilePos to iResult
97356>>>>>                If (Not(iResult)) Begin  // byte is locked
97358>>>>>                    Increment iNumberOfLocks
97359>>>>>                End
97359>>>>>>
97359>>>>>                Else Begin  // byte is not locked
97360>>>>>                    Get UnlockUserCountFile hFile dwFilePos to iResult
97361>>>>>                End
97361>>>>>>
97361>>>>>                Get SetUserCountPointer hFile 10 to dwFilePos
97362>>>>>                If (dwFilePos = -1) Begin
97364>>>>>                    Send UserError CS_ErrorAdvancingPointer
97365>>>>>                    Abort
97366>>>>>>
97366>>>>>                End
97366>>>>>>
97366>>>>>            Loop
97367>>>>>>
97367>>>>>        End
97367>>>>>>
97367>>>>>        Get CloseUserCountFile hFile to iResult
97368>>>>>        Function_Return iNumberOfLocks
97369>>>>>    End_Function
97370>>>>>
97370>>>>>End_Class
97371>>>Use cDbUpdateFunctionLibrary.pkg
97371>>>
97371>>>//{ DataBindable=True }
97371>>>    // Note: We import all functionality of the DatabaseFunctionLibrary into the class:
97371>>>Class cDbUpdateHandler is a cObject
97372>>>    Import_Class_Protocol cDbUpdateFunctionLibrary
97373>>>    Import_Class_Protocol cDbUpdateFunctionLibrary_Mixin
97374>>>
97374>>>    Procedure Construct_Object
97376>>>        tUserCount UserCount
97376>>>        tUserCount UserCount
97376>>>        Integer iUserCount
97376>>>        Handle ho                     
97376>>>
97376>>>        Forward Send Construct_Object
97378>>>        Move Self to ghoDbUpdateHandler  
97379>>>        
97379>>>        // Latin1_General_CI_AS = General Insensitive collation
97379>>>        // Latin1_General_CS_AS = General Case Sensitive collation, AS= Accent Sensitive.   
97379>>>        // For MS-SQL See: https://docs.microsoft.com/en-us/sql/t-sql/statements/windows-collation-name-transact-sql?view=sql-server-2017
97379>>>        // Good read about which collation to select:
97379>>>        // https://social.msdn.microsoft.com/Forums/sqlserver/en-US/bfdc32d3-3d36-4d63-8d87-6ee972fd8130/on-sqllatin1generalcp1cias-sql-server-2008-default-collation?forum=transactsql
97379>>>        Property String psCollation "Latin1_General_CS_AS" //"SQL_Latin1_General_Cp1_CS_AS"
97380>>>
97380>>>        // Struct array that will contain pnVersionNumbers & object id's of
97380>>>        // all child cDbVersion objects.
97380>>>        Property tDbVersionInfo[] paDbVersionInfoArray
97381>>>
97381>>>        Property Integer Error_Processing_State False  // internal use
97382>>>        
97382>>>        Property Boolean Private.pbDbVersionCheckDone False
97383>>>
97383>>>        Property Boolean pbUseCustomDbVersion False  
97384>>>        
97384>>>        // If this property = True _and_ no DbVersion table exists 
97384>>>        // when the framework is started, a DbVersion table will be created automatically.
97384>>>        Property Boolean pbAutoCreateDbVersionTable True
97385>>>
97385>>>        // Connected to the pbAutoCreateDbVersionTable property. If it is true,
97385>>>        // the Filelist.cfg slot number indicated by this property will be used
97385>>>        // if a DbVersion table is to be created. If this value = -1 at runtime
97385>>>        // an Unhandled Exception Error will be genereted and the program halted. So
97385>>>        // this property _must_ be set in the cDbUpdateHandler object if pbAutoCreateDbVersionTable = True,
97385>>>        // to a value that corresponds to a free Filelist.cfg slot number.
97385>>>        Property Integer Private.piDbVersionFileNumber -1
97386>>>        Property Integer Private.piDbVersionFieldNumber 1
97387>>>
97387>>>        // This is a message of the cDbUpdateFunctionLibrary_Mixin class
97387>>>        // that creates all library properties
97387>>>        Send CreateDbUpdateLibraryProperties
97388>>>
97388>>>        Property tDbUpdateHandlerMasterAlias[] paDbUpdateHandlerMasterAlias
97389>>>
97389>>>        // Error handling:
97389>>>        Property Boolean Private.pbOnCreateExecuted False
97390>>>        Property Boolean Private.pbOnPreUpdateExecuted False
97391>>>        Property Boolean Private.pbProcessingError False
97392>>>        Property Boolean pbDbUpdateErrorHasOccured False
97393>>>        // Don't touch. It is being used by the cDbUpdateVersion
97393>>>        // subclass to tell if that particular update went OK or not.
97393>>>        Property Boolean Private.pbUpdateVersionObjectError False
97394>>>        Property String[] paSQLQueryMessages
97395>>>
97395>>>        Property Integer piOrgErrorHandlerID Error_Object_Id
97396>>>        Move Self to Error_Object_Id
97397>>>        // Error handling:
97397>>>        // Temporarily redirect all errors to this object so we can silently
97397>>>        // log all errors that might appear while updating the database.
97397>>>        // We temporarily redirect all errors to this object so we can
97397>>>        // log and write errors to the log file. It will be reset after
97397>>>        // the database updates have been finished.
97397>>>        Property Integer piCurrentErrorHandlerID Error_Object_Id
97398>>>
97398>>>        Property Handle phoLogFile (Create(Self,RefClass(cDbUpdateLogFile)))
97399>>>
97399>>>        // Error Reporting Related
97399>>>        // If DUF_ERROR_NO_REPORT errors are supressed (only ERR gets set)
97399>>>        Property Integer Error_Report_Mode DUF_ERROR_REPORT
97400>>>
97400>>>        // If the pbContinueOnError = False, an update
97400>>>        // of another cDbUpdateVersion object will _not_ be
97400>>>        // performed if an error occured in a previous
97400>>>        // cDbUpdateVersion object.
97400>>>        Property Boolean pbContinueOnError False
97401>>>        // Stops execution in other cDbUpdateVersion objecs,
97401>>>        // if errors occurred in one cDbUpdateVersion object.
97401>>>        Property Boolean pbStopOnFirstError False
97402>>>        // If True errors that occured while updating the database
97402>>>        // will be shown in the default app for .txt files when done.
97402>>>        // Note: The log file will _always_ be created in the Data folder.
97402>>>        Property Boolean pbShowErrorLogPostRun True
97403>>>
97403>>>        // Be _very_ careful to set this property to true!
97403>>>        // If = True, no question will be asked if the update
97403>>>        // should begin. Also, even if the pbShowErrorLogPostRun=True,
97403>>>        // the error log won't be shown. The logfile itself will still be created though.
97403>>>        // You have to know what you're doing!
97403>>>        Property Boolean pbSilentMode False
97404>>>        
97404>>>        Property Boolean pbEnableCancelButton False
97405>>>
97405>>>        // Don't touch! Very private. The value is used by the error log to write for which
97405>>>        // cDbUpdateVersion object an error occured.
97405>>>        Property Number pnCurrentVersionUpdate 0
97406>>>
97406>>>        // The user counting logic is used to safe-guard agains anybody else is
97406>>>        // using the application when a database update is to be performed.
97406>>>        // (Garters & suspenders!)
97406>>>        Property Handle phoUserCountSystem (Create(Self,RefClass(cDbUpdateUserCount)))
97407>>>        Set psLockFileName of (phoUserCountSystem(Self)) to "DbUpdateUserCount.ucf"
97408>>>        Set piMaxUsers     of (phoUserCountSystem(Self)) to (CI_UserCountMaxUsers -1) // Large number!
97409>>>
97409>>>        // This lock file is used to guard against somebody else tries to start the
97409>>>        // application while updates are in progress.
97409>>>        Property Handle phoDatabaseUpdateLock (Create(Self,RefClass(cDbUpdateUserCount)))
97410>>>        Set psLockFileName of (phoDatabaseUpdateLock(Self)) to "DbUpdateLock.ucf"
97411>>>        Set piMaxUsers     of (phoDatabaseUpdateLock(Self)) to 1
97412>>>                                                                                      // Only the current user allowed.
97412>>>        // Properties for the table & column of a system file field/column where
97412>>>        // the database version update number gets saved.
97412>>>        Property Integer Private.Data_File  0
97413>>>        Property Integer Private.Data_Field 0
97414>>>
97414>>>        // Property that is used to indicate that we have already
97414>>>        // started the database update.
97414>>>        Property Boolean Private.pbDatabaseUpdateStarted False
97415>>>
97415>>>        // Don't touch! It is used by the child class cDbUpdateVersion logic to indicate that
97415>>>        // at least one OnUpdate child event has been triggered. Thus at least one active
97415>>>        // change of the database has been made.
97415>>>        Property Boolean Private.pbDatabaseWasUpdated False
97416>>>
97416>>>        // We need to trigger the user counting system so that a bit in the
97416>>>        // user counting file is locked. This is to guard that not more than one user
97416>>>        // is currently runnning the program.
97416>>>        Get CheckUserCount of (phoUserCountSystem(Self)) to UserCount
97417>>>
97417>>>        Get CurrentNumberOfUsers of (phoDatabaseUpdateLock(Self)) to iUserCount
97418>>>        If (iUserCount > 0) Begin
97420>>>            Send Stop_Box CS_DUF_UpdateInProgressTxt
97421>>>            Send Exit_Application
97422>>>        End
97422>>>>
97422>>>
97422>>>        Set pbHandleQueryErrors to False
97423>>>            
97423>>>        // This can't be right?    
97423>>>//        If (ghoDbUpdateFunctionLibrary = 0) Begin
97423>>>//            Move Self to ghoDbUpdateFunctionLibrary
97423>>>//        End
97423>>>
97423>>>        Property Handle phoSQLConnectionHandler 0
97424>>>        // If no ghoSQLConnectionHandler object has been created prior to this object,
97424>>>        // we will create one as it is used for all ConnectionID, ConnectionString
97424>>>        // etc information.
97424>>>        If (ghoSQLConnectionHandler = 0) Begin
97426>>>            Get Create (RefClass(cSQLConnectionHandler)) to ho
97427>>>            Set phoSQLConnectionHandler to ho
97428>>>        End             
97428>>>>
97428>>>        
97428>>>        Property Boolean pbCheckIntFiles False   
97429>>>        Property Handle  phIntFilesTable 2048
97430>>>        Property Boolean Private.pbIntFilesTablesCheckDone False
97431>>>        
97431>>>        Set Icon to "Default.ico"
97432>>>    End_Procedure
97433>>>
97433>>>    Procedure End_Construct_Object
97435>>>        Boolean bCheckIntFiles
97435>>>        
97435>>>        Forward Send End_Construct_Object
97437>>>        If (Private.pbOnCreateExecuted(Self) = False) Begin  
97439>>>            Send OnCreate
97440>>>            Set Private.pbOnCreateExecuted to True
97441>>>        End
97441>>>>
97441>>>        Send Cleanup
97442>>>    End_Procedure
97443>>>    
97443>>>    // Programmers hook event.
97443>>>    Procedure OnCreate
97445>>>    End_Procedure        
97446>>>                                 
97446>>>    // *** MAIN .Int file (and Filelist.cfg) Check Integrity Message ***
97446>>>    //                                                
97446>>>    // The logic is activated by setting the property "pbCheckIntFiles = True" in the
97446>>>    // cDbUpdateHandler object.
97446>>>    //
97446>>>    // Checks that all .int files are intact, or else writes new copies to disk. 
97446>>>    // Also checks that there is a Filelist.cfg, and if missing writes a new copy to disk.
97446>>>    //
97446>>>    // If not done previously the phIntFilesTable will be created and filled with data
97446>>>    // from the current set of .int files - iif (if-and-only-if) this is a development
97446>>>    // machine. Which is decided by checking if the DdSrc folder exists. And a copy
97446>>>    // of Filelist.cfg is made for backup purposes.
97446>>>    //
97446>>>    // Note: If an error occurrs the application will exit, as it means that at least one
97446>>>    // .int file is in error or the Filelist.cfg was missing and couldn't be recreated.
97446>>>    Procedure CheckIntFilesIntegrity
97448>>>        Boolean bCheckIntFiles bExists bOK bSaved bIsSQL bFileListExist bResult bDevelop bZipExists
97448>>>        String sPaths sDataPath sIntFileName sRootFileNname sFileListName sDDSrcPath sCurrentFolder
97448>>>        String sFileListZipFile sParam sProgram sFile 
97448>>>        Integer iDataPaths iCount
97448>>>        Handle hTable hIntFilesTable                    
97448>>>        UChar[] asFileListArray 
97449>>>        String[] asSavedIntFile
97450>>>        tDUFIntFile[] DUFIntFiles
97450>>>        tDUFIntFile[] DUFIntFiles
97451>>>        
97451>>>        Get pbCheckIntFiles to bCheckIntFiles
97452>>>        If (bCheckIntFiles = False) Begin
97454>>>            Procedure_Return
97455>>>        End
97455>>>>
97455>>>        
97455>>>        Move True to bResult        
97456>>>        
97456>>>        // Note: Include_Resource is a compiler directive!
97456>>>        // It will embedd the Filelist.cfg from the developers machine
97456>>>        // into the executable. Thus the file _must_ be named "Filelist.cfg", or you
97456>>>        // need to change the next code line.         
97456>>>        //
97456>>>        // This is a pickle (!) with the Filelist.cfg as it is "busy" as it is open in the Studio,
97456>>>        // when we get here and then it seems the compiler can't embedd it!        
97456>>>        // ToDo: Change compiler directives in Project properties (?)
97456>>>//        Include_Resource Filelist2.cfg as res_EmbeddedFilelistCfg type DF_RESOURCE_TYPE_BINARY
97456>>>//        Get ReadFileListResource "res_EmbeddedFilelistCfg" to asFileListArray
97456>>>        
97456>>>        Get psFileList of (phoWorkspace(ghoApplication)) to sFileListName
97457>>>        Get vFilePathExists sFileListName to bExists 
97458>>>        If (bExists = True) Begin
97460>>>            Get ParseFolderName sFileListName to sDataPath    
97461>>>            Get vFolderFormat sDataPath to sDataPath                              
97462>>>            Get ParseFileName sFileListName to sFile
97463>>>            // We need to create a backup copy of Filelist.cfg.
97463>>>            Get vCopyFile sFileListName (sDataPath + CS_FilelistBackupFile) to bOK
97464>>>            Get vFilePathExists (sDataPath + CS_FilelistBackupFile) to bOK
97465>>>            If (bOK = False) Begin
97467>>>                Move False to bResult
97468>>>                Error DFERR_PROGRAM ("Could not create a copy of Filelist.cfg for backup purposed! ***Please investigte the reason why this happened ***")
97469>>>>
97469>>>            End
97469>>>>
97469>>>        End
97469>>>>
97469>>>        // If the Filelist.cfg is missing - create it from a previous backup copy.
97469>>>        Else Begin
97470>>>            Get vCopyFile (sDataPath + CS_FilelistBackupFile) sFileListName to bOK
97471>>>//            Get WriteFileListResource asFileListArray sFileListName to bOK  
97471>>>            If (bOK = False) Begin   
97473>>>                Move False to bResult
97474>>>                Error DFERR_PROGRAM ("Filelist.cfg file is missing and couldn't be created!" * String(sFileListName))
97475>>>>
97475>>>            End
97475>>>>
97475>>>        End
97475>>>>
97475>>>        
97475>>>        Get phIntFilesTable to hIntFilesTable
97476>>>        Get_Attribute DF_FILE_ROOT_NAME of hIntFilesTable to sRootFileNname
97479>>>        Get _TableNoPrefix sRootFileNname to sRootFileNname
97480>>>        // This will automatically create the phIntFilesTable if not exists.
97480>>>        // It is used to save data from the current set of .int files.
97480>>>        If (sRootFileNname <> CS_IntFilesTableRootName) Begin
97482>>>            Send AutoCreateIntFilesTable
97483>>>        End                                                       
97483>>>>
97483>>>        
97483>>>        // Check if this is a development machine. *Only* then we will attempt to read .int files to the internal table. 
97483>>>        // ToDo: Or should this always be attempted? Else the 
97483>>>        Get psDdSrcPath of (phoWorkspace(ghoApplication)) to sDDSrcPath
97484>>>        Move (IsDebuggerPresent()) to bDevelop
97485>>>        If (bDevelop = False) Begin
97487>>>            Get vFolderExists sDDSrcPath to bDevelop
97488>>>        End
97488>>>>
97488>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sPaths
97489>>>        Get CountOfPaths of (phoWorkspace(ghoApplication)) sPaths to iDataPaths
97490>>>        For iCount from 1 to iDataPaths
97496>>>>
97496>>>            Get PathAtIndex of (phoWorkspace(ghoApplication)) sPaths iCount to sDataPath   
97497>>>            Get vFolderFormat sDataPath to sDataPath 
97498>>>            Get vFolderExists sDataPath to bExists
97499>>>            If (bExists = True) Begin                  
97501>>>                Move 0 to hTable
97502>>>                Repeat
97502>>>>
97502>>>                    Get_Attribute DF_FILE_NEXT_USED of hTable to hTable    
97505>>>                    If (hTable <> 0) Begin
97507>>>                        Get_Attribute DF_FILE_ROOT_NAME of hTable to sIntFileName 
97510>>>                        Get UtilTableIsSqlByRootName sIntFileName to bIsSQL
97511>>>                        If (bIsSQL = True) Begin
97513>>>                            Get _TableNoPrefix sIntFileName to sIntFileName
97514>>>                            Move (sIntFileName + ".int")    to sIntFileName
97515>>>                            Get IsIntFileSaved sIntFileName to bSaved  
97516>>>                            Move True to bOK            
97517>>>                            
97517>>>                            // Save .int file to database if not done previously.
97517>>>                            // We only attempt to read .int files on a development machine.
97517>>>                            If (bDevelop = True) Begin
97519>>>                                If (bSaved = False) Begin
97521>>>                                    Get SaveIntFileData sDataPath sIntFileName to bOK
97522>>>                                    If (bOK = False) Begin
97524>>>                                        Move False to bResult    
97525>>>                                    End
97525>>>>
97525>>>                                End         
97525>>>>
97525>>>                                If (bOK = True) Begin
97527>>>                                    Get HasIntFileChanged sDataPath sIntFileName to asSavedIntFile
97528>>>                                    If (SizeOfArray(asSavedIntFile)) Begin
97530>>>                                        Get UpdateIntFileData sDataPath sIntFileName asSavedIntFile to bOK
97531>>>                                        If (bOK = False) Begin
97533>>>                                            Move False to bResult
97534>>>                                            Error DFERR_PROGRAM ("Could not update .int file data to the internal database table:" * String(sIntFileName))
97535>>>>
97535>>>                                        End
97535>>>>
97535>>>                                    End
97535>>>>
97535>>>                                End
97535>>>>
97535>>>                            End
97535>>>>
97535>>>                            
97535>>>                            Get vFilePathExists (sDataPath + sIntFileName) to bExists
97536>>>                            If (bExists = False) Begin                           
97538>>>                                // If the .int file is missing on disk; create it from database.
97538>>>                                Get CreateIntFileFromSavedData hIntFilesTable sIntFileName sDataPath to bOK
97539>>>                                If (bOK = False) Begin         
97541>>>                                    Move False to bResult
97542>>>                                    Error DFERR_PROGRAM ("Could not create .int file:" * String(sIntFileName))
97543>>>>
97543>>>                                End
97543>>>>
97543>>>                            End
97543>>>>
97543>>>                        End
97543>>>>
97543>>>                    End
97543>>>>
97543>>>                Until (hTable = 0)
97545>>>            End
97545>>>>
97545>>>        Loop       
97546>>>>
97546>>>        
97546>>>        // If an error occured we need to exit the application.
97546>>>        If (bResult = False) Begin  
97548>>>            Send Info_Box CS_DUF_DbUpdatedErrorText 
97549>>>            Send Exit_Application
97550>>>        End
97550>>>>
97550>>>        
97550>>>    End_Procedure               
97551>>>
97551>>>    // To update currently saved IntFile data to the database.
97551>>>    // Because it is much easier, we first delete all current records and
97551>>>    // then saves the changed .int file to the database.
97551>>>    Function UpdateIntFileData String sDataPath String sIntFileName String[] asSavedIntFile Returns Boolean
97553>>>        Boolean bOK
97553>>>        
97553>>>        Move False to bOK
97554>>>
97554>>>        Get DeleteIntFileData sDataPath sIntFileName to bOK
97555>>>        If (bOK = True) Begin
97557>>>            Get SaveIntFileData sDataPath sIntFileName to bOK
97558>>>        End
97558>>>>
97558>>>        
97558>>>        Function_Return bOK
97559>>>    End_Function
97560>>>    
97560>>>    Function IsIntFileSaved String sIntFileName Returns Boolean
97562>>>        Handle hTable
97562>>>        Boolean bOK
97562>>>        Integer iColumn iIndex   
97562>>>        String sFileName
97562>>>        
97562>>>        Move False to bOK
97563>>>        Get phIntFilesTable to hTable
97564>>>        Move 2              to iColumn // This is the "InfFileName" field no.
97565>>>        Move 2              to iIndex  // This is the IntFileName + ID index.
97566>>>
97566>>>        Open hTable
97568>>>        Set_Field_Value hTable iColumn to sIntFileName
97571>>>        Vfind hTable iIndex GE
97573>>>        Get_Field_Value hTable iColumn to sFileName
97576>>>        If (Trim(sIntFileName) = Trim(sFileName)) Begin
97578>>>            Move True to bOK    
97579>>>        End
97579>>>>
97579>>>        Close hTable
97580>>>        
97580>>>        Function_Return bOK       
97581>>>    End_Function   
97582>>>    
97582>>>    // Checks that the passed .int file is the same as what is saved in the database.
97582>>>    // If not same, the return string array will contain the read .int file,
97582>>>    // else the returned array will be empty.
97582>>>    Function HasIntFileChanged String sDataPath String sIntFileName Returns String[]
97584>>>        String[] asIntFileOrg asIntFile asSavedIntFile asReturnIntFile
97588>>>        Boolean bIsSame
97588>>>        
97588>>>        Get ReadIntFileData    sDataPath sIntFileName to asIntFileOrg   
97589>>>        Get CurrentIntFileData sDataPath sIntFileName to asSavedIntFile
97590>>>        Get RemoveBlankLines asIntFileOrg   to asIntFile
97591>>>        Get RemoveBlankLines asSavedIntFile to asSavedIntFile
97592>>>        
97592>>>        Move (IsSameArray(asIntFile, asSavedIntFile)) to bIsSame
97593>>>        If (bIsSame = False) Begin
97595>>>            Move asIntFileOrg to asReturnIntFile    
97596>>>        End
97596>>>>
97596>>>        
97596>>>        Function_Return asReturnIntFile    
97597>>>    End_Function                                   
97598>>>    
97598>>>    // Takes a string array as parameter and returns a new
97598>>>    // string array without any empty rows and all rows trimmed.
97598>>>    // This is e.g. used by the HasIntFileChanged message to compare
97598>>>    // two .int file arrays. 
97598>>>    Function RemoveBlankLines String[] asIntFile Returns String[]
97600>>>        Integer iSize iCount iRow
97600>>>        String sVal        
97600>>>        String[] asRetValArray
97601>>>        
97601>>>        Move (SizeOfArray(asIntFile)) to iSize
97602>>>        If (iSize = 0) Begin
97604>>>            Function_Return asRetValArray
97605>>>        End                          
97605>>>>
97605>>>        Decrement iSize         
97606>>>        Move 0 to iRow
97607>>>        
97607>>>        For iCount from 0  to iSize
97613>>>>
97613>>>            Move asIntFile[iCount] to sVal
97614>>>            Move (Trim(sVal)) to sVal
97615>>>            If (sVal <> "") Begin
97617>>>                Move sVal to asRetValArray[iRow]
97618>>>                Increment iRow        
97619>>>            End
97619>>>>
97619>>>        Loop
97620>>>>
97620>>>        
97620>>>        Function_Return asRetValArray
97621>>>    End_Function
97622>>>    
97622>>>    Function SaveIntFileData String sPath String sIntFileName Returns Boolean
97624>>>        Handle hTable
97624>>>        Boolean bOK bErr
97624>>>        Integer iIDCol iFileCol iTextCol iIndex iIDIdx iSize iCount 
97624>>>        Number iID
97624>>>        String sFileName
97624>>>        String[] asIntFile
97625>>>        
97625>>>        Move Err to bErr
97626>>>        Move False to Err
97627>>>        Move False to bOK
97628>>>        Get phIntFilesTable to hTable  
97629>>>        Move 1              to iIDCol
97630>>>        Move 2              to iFileCol
97631>>>        Move 3              to iTextCol // This is the "InfFileName" field no.
97632>>>        Move 1              to iIDIdx   // Main ID index.
97633>>>        Move 2              to iIndex   // This is the IntFileName + ID index.
97634>>>
97634>>>        Get ReadIntFileData sPath sIntFileName to asIntFile
97635>>>        Move (SizeOfArray(asIntFile)) to iSize
97636>>>        If (iSize = 0) Begin
97638>>>            Function_Return False
97639>>>        End
97639>>>>
97639>>>        Decrement iSize
97640>>>        Open hTable  
97642>>>                  
97642>>>        // Find the last used ID no:
97642>>>        Fill_Field hTable iIDCol with DF_HIGH
97644>>>        Vfind hTable iIDIdx LE
97646>>>        Get_Field_Value hTable iIDCol to iID 
97649>>>        // This only happens the very first time we save a record.
97649>>>        If (iID = 999999999999) Begin
97651>>>            Move 0 to iID
97652>>>        End
97652>>>>
97652>>>        Increment iID        
97653>>>        
97653>>>        Lock
97654>>>>
97654>>>            For iCount from 0 to iSize
97660>>>>
97660>>>                Clear hTable
97661>>>                Set_Field_Value hTable iIDCol   to iID     
97664>>>                Set_Field_Value hTable iFileCol to sIntFileName
97667>>>                Set_Field_Value hTable iTextCol to asIntFile[iCount]
97670>>>                SaveRecord hTable
97671>>>                Increment iID
97672>>>            Loop
97673>>>>
97673>>>        Unlock
97674>>>>
97674>>>        Close hTable
97675>>>        
97675>>>        Move (not(Err)) to bOK
97676>>>        Move bErr to Err
97677>>>        
97677>>>        Function_Return bOK
97678>>>    End_Function
97679>>>    
97679>>>    // Deletes all records for the passed sIntFileName value,
97679>>>    // from the phIntFilesTable.
97679>>>    // Returns True if no errors occured.
97679>>>    Function DeleteIntFileData String sPath String sIntFileName Returns Boolean
97681>>>        Handle hTable
97681>>>        Boolean bOK bErr bFound
97681>>>        Integer iFileCol iIndex
97681>>>        String sVal
97681>>>        String[] asIntFile
97682>>>        
97682>>>        Move Err to bErr
97683>>>        Move False to Err
97684>>>        Move False to bOK
97685>>>        Move 2              to iFileCol
97686>>>        Move 2              to iIndex  // This is the IntFileName + ID index.
97687>>>        Get phIntFilesTable to hTable  
97688>>>        Open hTable  
97690>>>                  
97690>>>        // Find the first record
97690>>>        Set_Field_Value hTable iFileCol to sIntFileName
97693>>>        Vfind hTable iIndex GE
97695>>>        Get_Field_Value hTable iFileCol to sVal
97698>>>        Move (Found and Trim(sVal) = Trim(sIntFileName)) to bFound
97699>>>        While (bFound = True)
97703>>>            Delete hTable
97704>>>            Vfind hTable iIndex GT
97706>>>            Get_Field_Value hTable iFileCol to sVal
97709>>>            Move (Found and Trim(sVal) = Trim(sIntFileName)) to bFound
97710>>>        Loop
97711>>>>
97711>>>        Unlock
97712>>>>
97712>>>        Close hTable
97713>>>        
97713>>>        Move (not(Err)) to bOK
97714>>>        Move bErr to Err
97715>>>        
97715>>>        Function_Return bOK
97716>>>    End_Function
97717>>>
97717>>>    // Returns all saved phIntFilesTable records for the passed 
97717>>>    // sIntFileName value as a string array.
97717>>>    Function CurrentIntFileData String sPath String sIntFileName Returns String[]
97719>>>        Handle hTable
97719>>>        Boolean bOK bErr bFound
97719>>>        Integer iFileCol iTextCol iIndex
97719>>>        String sVal sFileName
97719>>>        String[] asIntFile asEmptyArray
97721>>>        
97721>>>        Move Err to bErr
97722>>>        Move False to Err
97723>>>        Move False to bOK
97724>>>        Move 2              to iFileCol
97725>>>        Move 3              to iTextCol // This is the "InfFileName" field no.
97726>>>        Move 2              to iIndex  // This is the IntFileName + ID index.
97727>>>        Get phIntFilesTable to hTable  
97728>>>        Open hTable  
97730>>>
97730>>>        // Find the first record
97730>>>        Set_Field_Value hTable iFileCol to sIntFileName
97733>>>        Vfind hTable iIndex GE
97735>>>        Get_Field_Value hTable iFileCol to sFileName
97738>>>        Move (Found and Trim(sFileName) = Trim(sIntFileName)) to bFound
97739>>>        While (bFound = True)
97743>>>            Get_Field_Value hTable iFileCol to sFileName
97746>>>            Move (Found and Trim(sFileName) = Trim(sIntFileName)) to bFound
97747>>>            If (bFound = True) Begin
97749>>>                Get_Field_Value hTable iTextCol to sVal
97752>>>                Move (Trim(sVal)) to asIntFile[SizeOfArray(asIntFile)]
97753>>>            End
97753>>>>
97753>>>            Vfind hTable iIndex GT
97755>>>        Loop
97756>>>>
97756>>>        
97756>>>        Close hTable
97757>>>        Move (not(Err)) to bOK
97758>>>        If (bOK = False) Begin
97760>>>            Move asEmptyArray to asIntFile
97761>>>        End
97761>>>>
97761>>>        Move bErr to Err               
97762>>>        
97762>>>        Function_Return asIntFile
97763>>>    End_Function
97764>>>
97764>>>    // Reads the passed sIntFileName from disk and returns its value
97764>>>    // as a string array.
97764>>>    Function ReadIntFileData String sPath String sIntFileName Returns String[]
97766>>>        String[] asIntFile       
97767>>>        String sFileName sLine
97767>>>        Integer iCh iSize iCount
97767>>>        
97767>>>        Get vFolderFormat sPath to sPath
97768>>>        If (not(sIntFileName contains ".")) Begin
97770>>>            Move (sIntFileName + ".int") to sIntFileName
97771>>>        End
97771>>>>
97771>>>        Move (sPath + sIntFileName) to sFileName
97772>>>        Get Seq_Open_input_Channel sFileName to iCh
97773>>>        If (iCh < 0) Begin
97775>>>            Function_Return asIntFile
97776>>>        End                                 
97776>>>>
97776>>>        
97776>>>        Repeat
97776>>>>
97776>>>            Readln channel iCh sLine
97778>>>            If (SeqEof = False) Begin
97780>>>                Move sLine to asIntFile[SizeOfArray(asIntFile)]
97781>>>            End
97781>>>>
97781>>>        Until (SeqEof = True)
97783>>>        Send Seq_Close_Channel iCh    
97784>>>        
97784>>>        Function_Return asIntFile
97785>>>    End_Function
97786>>>    
97786>>>    // Reads the Filelist.cfg from memeory as a resource.
97786>>>    // The Filelist.cfg has been compiled into the program.
97786>>>    Function ReadFileListResource String sMemFileName Returns UChar[]
97788>>>        Integer iCh iCount
97788>>>        Number nByteCount
97788>>>        String[] asFileListArray sEmptyArray
97790>>>        String sLine
97790>>>        UChar[] uCharData
97791>>>        
97791>>>        Move False to Err
97792>>>        Get Seq_New_Channel to iCh
97793>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
97795>>>            Error DFERR_PROGRAM 'No channel available...'
97796>>>>
97796>>>            Function_Return sEmptyArray
97797>>>        End
97797>>>>
97797>>>
97797>>>        // First decide the size of the script
97797>>>        Direct_Input channel iCh ("Resource: " + sMemFileName)
97799>>>        Read_Block channel iCh uCharData -1 // -1 means that all data should be read.
97801>>>        Close_Input channel iCh
97803>>>        Send Seq_Release_Channel iCh
97804>>>
97804>>>        Function_Return uCharData
97805>>>    End_Function    
97806>>>    
97806>>>    // Writes a copy of the workspace Filelist.cfg to disk.
97806>>>    // It does so by reading from a memory resource, as the file has
97806>>>    // been compiled into the program.
97806>>>    Function WriteFileListResource UChar[] asFileListArray String sFileListName Returns Boolean
97808>>>        Boolean bOK bErr
97808>>>        Integer iSize iCh
97808>>>        
97808>>>        Move Err to bErr
97809>>>        Move False to Err
97810>>>        Move False to bOK
97811>>>        Move (SizeOfArray(asFileListArray)) to iSize
97812>>>        If (iSize = 0) Begin
97814>>>            Function_Return False
97815>>>        End
97815>>>>
97815>>>
97815>>>        Get Seq_New_Channel to iCh
97816>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
97818>>>            Error DFERR_PROGRAM 'No channel available...'
97819>>>>
97819>>>            Function_Return False
97820>>>        End                      
97820>>>>
97820>>>        
97820>>>        Direct_Output channel iCh sFileListName
97822>>>        Writeln channel iCh asFileListArray
97825>>>                
97825>>>        Close_Input channel iCh
97827>>>        Send Seq_Release_Channel iCh
97828>>>        Move (not(Err)) to bOK
97829>>>        Move bErr to Err
97830>>>        
97830>>>        Function_Return bOK
97831>>>    End_Function
97832>>>
97832>>>    // Writes an .int for the passed sIntFileName file to disk by reading data from the phIntFilesTable data table.
97832>>>    // It first deletes the .cch file (if any).
97832>>>    Function CreateIntFileFromSavedData Handle hTable String sIntFileName String sDataPath Returns Boolean
97834>>>        Boolean bOK bFound bExists bErr
97834>>>        Integer iCh iSize iCount
97834>>>        String sFileName sCCHFileName sVal
97834>>>        String[] asIntFile
97835>>>        
97835>>>        Move Err to bErr   
97836>>>        Move False to Err
97837>>>        Move False to bOK
97838>>>
97838>>>        Get CurrentIntFileData sDataPath sIntFileName to asIntFile
97839>>>        Move (SizeOfArray(asIntFile)) to iSize
97840>>>        If (iSize = 0) Begin
97842>>>            Function_Return False        
97843>>>        End                      
97843>>>>
97843>>>        Decrement iSize
97844>>>        
97844>>>        Get Seq_New_Channel to iCh
97845>>>        If (iCh = DF_SEQ_CHANNEL_NOT_AVAILABLE) Begin
97847>>>            Function_Return False
97848>>>        End   
97848>>>>
97848>>>        
97848>>>        // Before we start to actually create the new .int file, make sure we delete
97848>>>        // the .cch file first.                                     
97848>>>        Move (Uppercase(sIntFileName)) to sCCHFileName
97849>>>        Move (Replace(".INT", sCCHFileName, ".CCH")) to sCCHFileName
97850>>>        Get vFilePathExists (sDataPath + sCCHFileName) to bExists
97851>>>        If (bExists = True) Begin
97853>>>            Get vDeleteFile (sDataPath + sCCHFileName) to bOK
97854>>>            If (bOK = False) Begin
97856>>>                Function_Return False
97857>>>            End
97857>>>>
97857>>>        End
97857>>>>
97857>>>        
97857>>>        Direct_Output channel iCh (sDataPath + sIntFileName)
97859>>>        For iCount from 0 to iSize
97865>>>>
97865>>>            Writeln channel iCh asIntFile[iCount]
97868>>>        Loop
97869>>>>
97869>>>        
97869>>>        Close_Input channel iCh
97871>>>        Send Seq_Release_Channel iCh
97872>>>        Move (not(Err)) to bOK
97873>>>        Move bErr to Err
97874>>>        
97874>>>        Function_Return bOK
97875>>>    End_Function   
97876>>>              
97876>>>    // Automatically writes .int files to disk that is missing.
97876>>>    // We only need to make this test this once, but because the message is called
97876>>>    // from each child cDbUpdateVersion object (and it needs to be called from there),
97876>>>    // we use property Private.pbIntFilesTablesCheckDone to ensure it is only run once.
97876>>>    Procedure AutoCreateIntFilesTable 
97878>>>        Integer hTable 
97878>>>        Boolean bIntFilesTablesCheckDone bTableExists
97878>>>        String sInfoTxt 
97878>>>        
97878>>>        Get phIntFilesTable to hTable  
97879>>>        Get Private.pbIntFilesTablesCheckDone to bIntFilesTablesCheckDone
97880>>>        If (bIntFilesTablesCheckDone = True) Begin
97882>>>            Procedure_Return
97883>>>        End
97883>>>>
97883>>>
97883>>>        If (hTable < 1) Begin
97885>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
97886>>>            Error DFERR_PROGRAM "The phIntFilesTable has been set to 0 (!). The default value is 2048 and if changed MUST be set to a free Filelist.cfg slot in the cDbUpdateHandler object.\nProgram will now exit!"
97887>>>>
97887>>>            Procedure_Return
97888>>>        End
97888>>>>
97888>>>
97888>>>        Get UtilTableExists of ghoDbUpdateFunctionLibrary hTable to bTableExists
97889>>>        If (bTableExists = True) Begin
97891>>>            Set Private.pbIntFilesTablesCheckDone to True
97892>>>            Procedure_Return
97893>>>        End
97893>>>>
97893>>>
97893>>>        Send CreateIntFilesTable hTable
97894>>>
97894>>>        Set Private.pbIntFilesTablesCheckDone to True
97895>>>    End_Function
97896>>>                
97896>>>    Procedure CreateIntFilesTable Handle hTable
97898>>>        String sTableName sColumnName sInfoTxt sDriverID sDataPath
97898>>>        Boolean bTableExists bOK bUseConnectionID bExists
97898>>>        tAPIColumn[] APIColumn
97898>>>        tAPIColumn[] APIColumn
97899>>>
97899>>>        Get UtilTableNumberIsInUse of ghoDbUpdateFunctionLibrary hTable to bTableExists
97900>>>        If (bTableExists = True) Begin
97902>>>            Procedure_Return
97903>>>        End
97903>>>>
97903>>>
97903>>>        Move False to Err
97904>>>        Get psDriverID to sDriverID
97905>>>        Get IsSQLDriver of ghoDbUpdateFunctionLibrary sDriverID to bUseConnectionID
97906>>>
97906>>>        Move CS_IntFilesTableRootName to sTableName
97907>>>
97907>>>        Move 1                  to APIColumn[0].iFieldNumber
97908>>>        Move "ID"               to APIColumn[0].sFieldName
97909>>>        Move DF_BCD             to APIColumn[0].iType
97910>>>        Move False              to APIColumn[0].bIsSQLType
97911>>>        Move 12                 to APIColumn[0].iLength
97912>>>        Move 0                  to APIColumn[0].iPrecision
97913>>>
97913>>>        Move 2                  to APIColumn[1].iFieldNumber
97914>>>        Move "IntFileName"      to APIColumn[1].sFieldName
97915>>>        Move DF_ASCII           to APIColumn[1].iType
97916>>>        Move False              to APIColumn[1].bIsSQLType
97917>>>        Move 50                 to APIColumn[1].iLength
97918>>>        Move 0                  to APIColumn[1].iPrecision
97919>>>
97919>>>        Move 3                  to APIColumn[2].iFieldNumber
97920>>>        Move "IntLineText"      to APIColumn[2].sFieldName
97921>>>        Move DF_ASCII           to APIColumn[2].iType
97922>>>        Move False              to APIColumn[2].bIsSQLType
97923>>>        Move 100                to APIColumn[2].iLength
97924>>>        Move 0                  to APIColumn[2].iPrecision
97925>>>
97925>>>        Get ApiTableCreate of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True APIColumn to bOk
97926>>>        
97926>>>        If (bOK = True and Err = False) Begin
97928>>>            Move ("Int Files Table:" + sTableName * "was successfully created" * "at filelist slot:" * String(hTable)) to sInfoTxt
97929>>>        End
97929>>>>
97929>>>        Else Begin
97930>>>            Move ("ERROR" * "Int Files Table:" + sTableName * "could NOT be created" * "at filelist slot:" * String(hTable) * "\Program will now exit.") to sInfoTxt
97931>>>            Error sInfoTxt
97932>>>>
97932>>>            Procedure_Return
97933>>>        End
97933>>>>
97933>>>        Send LogError of (phoLogFile(Self)) 0 0 sInfoTxt 0 False
97934>>>
97934>>>        Get ApiIndexCreate hTable 1 1 1   to bOK     // Index 1 = ID
97935>>>        If (bOK = True) Begin
97937>>>            Get ApiIndexCreate hTable 2 2 2 1 to bOK // Index 2 = InteFileName, ID.
97938>>>        End
97938>>>>
97938>>>        If (bOK = False) Begin
97940>>>            Move ("ERROR" * "Indexes for Int Files Table:" + sTableName * "could NOT be created" * "at filelist slot:" * String(hTable) * "\Program will now exit.") to sInfoTxt
97941>>>            Error sInfoTxt
97942>>>>
97942>>>            Procedure_Return
97943>>>        End                    
97943>>>>
97943>>>        
97943>>>        // Check if the new .int file was created. If so and a .dat file exists - delete it.
97943>>>        Get psDataPath of (phoWorkspace(ghoApplication)) to sDataPath
97944>>>        Get vFolderFormat sDataPath to sDataPath
97945>>>        Move (CS_IntFilesTableRootName + ".int") to sTableName
97946>>>        Get vFilePathExists (sDataPath + sTableName) to bExists
97947>>>        If (bExists = True) Begin
97949>>>            Move CS_IntFilesTableRootName to sTableName
97950>>>            Get vFilePathExists (sDataPath + sTableName + ".dat") to bExists
97951>>>            If (bExists = True) Begin
97953>>>                Get vDeleteFile (sDataPath + sTableName + ".dat") to bOK
97954>>>                Get vDeleteFile (sDataPath + sTableName + ".hdr") to bOK
97955>>>                Get vDeleteFile (sDataPath + sTableName + ".k??") to bOK
97956>>>            End
97956>>>>
97956>>>        End
97956>>>>
97956>>>        
97956>>>    End_Procedure
97957>>>
97957>>>    Procedure CheckAutoCreateDbVersionTable
97959>>>        Boolean bDbVersionCheckDone bUseCustomDbVersion bAutoCreateDbVersionTable bTableExists
97959>>>        Integer iDbVersionFileNumber
97959>>>
97959>>>        Get Private.pbDbVersionCheckDone to bDbVersionCheckDone
97960>>>        If (bDbVersionCheckDone = True) Begin
97962>>>            Procedure_Return
97963>>>        End
97963>>>>
97963>>>        Get pbUseCustomDbVersion to bUseCustomDbVersion
97964>>>        If (bUseCustomDbVersion = True) Begin
97966>>>            Procedure_Return
97967>>>        End
97967>>>>
97967>>>
97967>>>        Get pbAutoCreateDbVersionTable to bAutoCreateDbVersionTable
97968>>>        If (bAutoCreateDbVersionTable = True and iDbVersionFileNumber = -1) Begin
97970>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
97971>>>            Error DFERR_PROGRAM "The iDbVersionFileSlotNumber = -1. It MUST be set to a free Filelist.cfg slot in the cDbUpdateHandler object. Could not auto-create the DbVersion table.\nProgram will now exit!"
97972>>>>
97972>>>            Send Exit_Application
97973>>>        End
97973>>>>
97973>>>
97973>>>        Get piDbVersionFileNumber to iDbVersionFileNumber
97974>>>        Get UtilTableExists of ghoDbUpdateFunctionLibrary iDbVersionFileNumber to bTableExists
97975>>>        If (bTableExists = True) Begin
97977>>>            Set Private.pbDbVersionCheckDone to True
97978>>>            Procedure_Return
97979>>>        End
97979>>>>
97979>>>
97979>>>        Send CreateDbVersionTable iDbVersionFileNumber
97980>>>
97980>>>        // We only need to these DbVersion checks once, but because this message is called
97980>>>        // from each child cDbUpdateVersion object (and it needs to be called from there),
97980>>>        // we use a property to only run these tests once.
97980>>>        Set Private.pbDbVersionCheckDone to True
97981>>>    End_Procedure
97982>>>
97982>>>    Procedure CreateDbVersionTable Handle hTable
97984>>>        String sTableName sColumnName sInfoTxt sDriverID 
97984>>>        Boolean bTableExists bOK bUseConnectionID
97984>>>        tAPIColumn[] APIColumn
97984>>>        tAPIColumn[] APIColumn
97985>>>
97985>>>        Get UtilTableNumberIsInUse of ghoDbUpdateFunctionLibrary hTable to bTableExists
97986>>>        If (bTableExists = True) Begin
97988>>>            Procedure_Return
97989>>>        End
97989>>>>
97989>>>
97989>>>        Get psDriverID to sDriverID
97990>>>        Get IsSQLDriver of ghoDbUpdateFunctionLibrary sDriverID to bUseConnectionID
97991>>>
97991>>>        Move "DbVersion"        to sTableName
97992>>>        Move 1                  to APIColumn[0].iFieldNumber
97993>>>        Move "DatabaseVersion"  to APIColumn[0].sFieldName
97994>>>        Move DF_BCD             to APIColumn[0].iType
97995>>>        Move False              to APIColumn[0].bIsSQLType
97996>>>        Move 4                  to APIColumn[0].iLength
97997>>>        Move 2                  to APIColumn[0].iPrecision
97998>>>
97998>>>        Move False to Err                                
97999>>>        
97999>>>        // Note: We always create an embedded DbVersion table. To do this we temporarily need to set the psDriverID to "DATAFLEX".
97999>>>        // To convert the DbVersion table to SQL, use the 'ApiTableConvertToSQL' function.
97999>>>        Set psDriverID to DATAFLEX_ID
98000>>>        Get ApiTableCreate of ghoDbUpdateFunctionLibrary hTable sTableName sTableName sTableName True True True APIColumn to bOk
98001>>>        Get ApiTableChangeAttribute of ghoDbUpdateFunctionLibrary hTable DF_FILE_IS_SYSTEM_FILE True to bOK
98002>>>        Set psDriverID to sDriverID
98003>>>        
98003>>>        If (bOK = True and Err = False) Begin
98005>>>//            Move ("Column '" + APIColumn[0].sFieldName + "'" * "NUMERIC" * String(APIColumn[0].iLength) + ", was successfully added to '" + sTableName + "'" * "(at filelist slot:" * String(hTable) + ")") to sInfoTxt
98005>>>            Move ("DbVersion table:" + sTableName * "was successfully created" * "at filelist slot:" * String(hTable)) to sInfoTxt
98006>>>        End
98006>>>>
98006>>>        Else Begin
98007>>>            Move ("The column could NOT be added. Either column" * sColumnName * "already exists or the Table name is incorrect?") to sInfoTxt
98008>>>        End
98008>>>>
98008>>>
98008>>>        Send LogError of (phoLogFile(Self)) 0 0 sInfoTxt 0 False
98009>>>    End_Procedure
98010>>>
98010>>>    Procedure Set pbVerboseState Boolean bVerboseState
98012>>>        Handle ho
98012>>>        Get phoLogFile to ho
98013>>>        Set pbVerboseState of ho to bVerboseState
98014>>>    End_Procedure
98015>>>
98015>>>    Function pbVerboseState Returns Boolean
98017>>>        Boolean bVerboseState
98017>>>        Handle ho
98017>>>        Get phoLogFile to ho
98018>>>        Get pbVerboseState of ho to bVerboseState
98019>>>        Function_Return bVerboseState
98020>>>    End_Function
98021>>>
98021>>>    // Callback functionality used when e.g. calling driver functions directly.
98021>>>    // Note that this overrules the callback function of the cDbUpdateFunctionLibrary class.
98021>>>    Function Callback String sCallback_Text Integer iCallback_Type Returns Integer
98023>>>        Integer iPerc
98023>>>        Number nReady nTotal nVersion
98023>>>        Boolean bVerboseState
98023>>>        Handle hoLogFile
98023>>>
98023>>>        Get pbVerboseState to bVerboseState
98024>>>        Get pnCurrentVersionUpdate to nVersion
98025>>>        Get phoLogFile     to hoLogFile
98026>>>        Send DoAdvance of ghoProgressBar
98027>>>
98027>>>        If (sCallback_Text contains "Dropping index" or sCallback_Text contains "Temporary delete of all indices of table") Begin
98029>>>            Move (Replace("Dropping index", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
98030>>>            Move (Replace("Temporary delete of all indices of table", sCallback_Text, CS_DUF_DeletingIndex)) to sCallback_Text
98031>>>        End
98031>>>>
98031>>>        If (sCallback_Text contains "Creating index") Begin
98033>>>            Move (Replace("Creating index", sCallback_Text, CS_DUF_CreatingIndex)) to sCallback_Text
98034>>>        End
98034>>>>
98034>>>
98034>>>        Case Begin
98034>>>            Case (iCallback_Type = DF_Message_Text)
98036>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
98037>>>                Set Action_Text  of ghoStatusPanel to ""
98038>>>                If (bVerboseState = True) Begin
98040>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
98041>>>                End
98041>>>>
98041>>>                Case Break
98042>>>            Case (iCallback_Type = DF_Message_Heading_1)
98045>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
98046>>>                If (bVerboseState = True) Begin
98048>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
98049>>>                End
98049>>>>
98049>>>                Case Break
98050>>>            Case (iCallback_Type = DF_Message_Heading_2)
98053>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
98054>>>                Set Action_Text  of ghoStatusPanel to ""
98055>>>                If (bVerboseState = True) Begin
98057>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
98058>>>                End
98058>>>>
98058>>>                Case Break
98059>>>            Case (iCallback_Type = DF_Message_Heading_3)
98062>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
98063>>>                Set Action_Text  of ghoStatusPanel to ""
98064>>>                If (bVerboseState = True) Begin
98066>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
98067>>>                End
98067>>>>
98067>>>                Case Break
98068>>>            Case (iCallback_Type = DF_Message_Heading_4)
98071>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
98072>>>                Set Action_Text  of ghoStatusPanel to ""
98073>>>                If (bVerboseState = True) Begin
98075>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
98076>>>                End
98076>>>>
98076>>>                Case Break
98077>>>            Case (iCallback_Type = DF_Message_Heading_5)
98080>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
98081>>>                Set Action_Text  of ghoStatusPanel to ""
98082>>>                If (bVerboseState = True) Begin
98084>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
98085>>>                End
98085>>>>
98085>>>                Case Break
98086>>>            Case (iCallback_Type = DF_Message_Warning)
98089>>>                If (bVerboseState = True) Begin
98091>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
98092>>>                End
98092>>>>
98092>>>                Case Break
98093>>>            Case (iCallback_Type = DF_Message_Progress_Title)
98096>>>                Set Message_Text of ghoStatusPanel to sCallback_Text
98097>>>                Set Action_Text  of ghoStatusPanel to ""
98098>>>                If (bVerboseState = True) Begin
98100>>>                    Send LogError of hoLogFile nVersion 0 sCallback_Text 0 False True
98101>>>                End
98101>>>>
98101>>>                Case Break
98102>>>            Case (iCallback_Type = DF_Message_Progress_Value)
98105>>>                //*** Interpret numbers
98105>>>                Move (Left(sCallback_Text, (Pos(",", sCallback_Text) - 1)))                       to nReady
98106>>>                Move (Right(sCallback_Text, (Length(sCallback_Text) - Pos(",", sCallback_Text)))) to nTotal
98107>>>                Move ((nReady/nTotal) * 100)                                                      to iPerc
98108>>>                Set Action_Text of ghoStatusPanel to (String(iPerc) * String("% (Total:") * String(nTotal) + ")")
98109>>>                Set piPosition of ghoProgressBar to iPerc
98110>>>                Case Break
98111>>>            Case Else
98111>>>                Set Message_Text to ""
98112>>>                Set Action_Text  to ""
98113>>>        Case End
98113>>>
98113>>>        Send ProcessEvents of ghoStatusPanel
98114>>>        Function_Return False
98115>>>    End_Function
98116>>>
98116>>>    // This was made to be a procedure/function pair so we
98116>>>    // at the same time can set the property of the cDbUpdateFunctionLibrary
98116>>>
98116>>>    Procedure Set piDbType Integer iDbType
98118>>>        If (ghoSQLConnectionHandler = 0) Begin
98120>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
98121>>>>
98121>>>            Procedure_Return
98122>>>        End
98122>>>>
98122>>>        Set piDbType of ghoSQLConnectionHandler to iDbType
98123>>>    End_Procedure
98124>>>
98124>>>    Function piDbType Returns Integer
98126>>>        Integer iDbType
98126>>>        If (ghoSQLConnectionHandler = 0) Begin
98128>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
98129>>>>
98129>>>            Function_Return ""
98130>>>        End
98130>>>>
98130>>>        Get piDbType of ghoSQLConnectionHandler to iDbType
98131>>>        Function_Return iDbType
98132>>>    End_Function
98133>>>
98133>>>    Procedure Set psDriverID String sDriverID
98135>>>        If (ghoSQLConnectionHandler = 0) Begin
98137>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
98138>>>>
98138>>>            Procedure_Return
98139>>>        End
98139>>>>
98139>>>        Set psDriverID of ghoSQLConnectionHandler to sDriverID
98140>>>    End_Procedure
98141>>>
98141>>>    Function psDriverID Returns String
98143>>>        String sValue
98143>>>        If (ghoSQLConnectionHandler = 0) Begin
98145>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
98146>>>>
98146>>>            Function_Return ""
98147>>>        End
98147>>>>
98147>>>        Get psDriverID of ghoSQLConnectionHandler to sValue
98148>>>        Function_Return sValue
98149>>>    End_Function
98150>>>
98150>>>    Procedure CreateSQLConnection String sDriverID String sConnectionID String sServer String sDatabase Boolean bTrusted String sUserID String sPassword Boolean bSilent
98152>>>        If (ghoSQLConnectionHandler = 0) Begin
98154>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
98155>>>>
98155>>>            Procedure_Return
98156>>>        End
98156>>>>
98156>>>        Send CreateSQLConnection of ghoSQLConnectionHandler sDriverID sConnectionID sServer sDatabase bTrusted sUserID sPassword bSilent
98157>>>    End_Procedure
98158>>>
98158>>>    Function RedirectConnection String sOldConnection String sNewConnection Returns Integer
98160>>>        Integer iRetval
98160>>>        If (ghoSQLConnectionHandler = 0) Begin
98162>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
98163>>>>
98163>>>            Function_Return 2
98164>>>        End
98164>>>>
98164>>>
98164>>>        Get RedirectConnection of ghoSQLConnectionHandler to iRetval
98165>>>        Function_Return iRetval
98166>>>    End_Function
98167>>>
98167>>>    Procedure Set psConnectionID String sValue
98169>>>        If (ghoSQLConnectionHandler = 0) Begin
98171>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
98172>>>>
98172>>>            Procedure_Return
98173>>>        End
98173>>>>
98173>>>        Set psConnectionID of ghoSQLConnectionHandler to sValue
98174>>>    End_Procedure
98175>>>
98175>>>    Function psConnectionID Returns String
98177>>>        String sValue
98177>>>        If (ghoSQLConnectionHandler = 0) Begin
98179>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
98180>>>>
98180>>>            Function_Return ""
98181>>>        End
98181>>>>
98181>>>        Get psConnectionID of ghoSQLConnectionHandler to sValue
98182>>>
98182>>>        Function_Return sValue
98183>>>    End_Function
98184>>>
98184>>>    // These "properties" are settings of the cCLIHandler class, but are being
98184>>>    // relayed to the ghoSQLConnectionHandler object
98184>>>    // simply by changing one of its parameters.
98184>>>    Procedure Set psServer String sValue
98186>>>        If (ghoSQLConnectionHandler = 0) Begin
98188>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
98189>>>>
98189>>>            Procedure_Return
98190>>>        End
98190>>>>
98190>>>        Set psServer of ghoSQLConnectionHandler to sValue
98191>>>    End_Procedure
98192>>>
98192>>>    Function psServer Returns String
98194>>>        String sValue
98194>>>        If (ghoSQLConnectionHandler = 0) Begin
98196>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
98197>>>>
98197>>>            Function_Return ""
98198>>>        End
98198>>>>
98198>>>        Get psServer of ghoSQLConnectionHandler to sValue
98199>>>
98199>>>        Function_Return sValue
98200>>>    End_Function
98201>>>
98201>>>    Procedure Set psDatabase String sValue
98203>>>        If (ghoSQLConnectionHandler = 0) Begin
98205>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
98206>>>>
98206>>>            Procedure_Return
98207>>>        End
98207>>>>
98207>>>        Set psDatabase of ghoSQLConnectionHandler to sValue
98208>>>    End_Procedure
98209>>>
98209>>>    Function psDatabase Returns String
98211>>>        String sValue
98211>>>        If (ghoSQLConnectionHandler = 0) Begin
98213>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
98214>>>>
98214>>>            Function_Return ""
98215>>>        End
98215>>>>
98215>>>        Get psDatabase of ghoSQLConnectionHandler to sValue
98216>>>
98216>>>        Function_Return sValue
98217>>>    End_Function
98218>>>
98218>>>    Procedure Set psUserID String sValue
98220>>>        If (ghoSQLConnectionHandler = 0) Begin
98222>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
98223>>>>
98223>>>            Procedure_Return
98224>>>        End
98224>>>>
98224>>>        Set psUserID of ghoSQLConnectionHandler to sValue
98225>>>    End_Procedure
98226>>>
98226>>>    Function psUserID Returns String
98228>>>        String sValue
98228>>>        If (ghoSQLConnectionHandler = 0) Begin
98230>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
98231>>>>
98231>>>            Function_Return ""
98232>>>        End
98232>>>>
98232>>>        Get psUserID of ghoSQLConnectionHandler to sValue
98233>>>
98233>>>        Function_Return sValue
98234>>>    End_Function
98235>>>
98235>>>    Procedure Set psPassword String sValue
98237>>>        If (ghoSQLConnectionHandler = 0) Begin
98239>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
98240>>>>
98240>>>            Procedure_Return
98241>>>        End
98241>>>>
98241>>>        Set psPassword of ghoSQLConnectionHandler to sValue
98242>>>    End_Procedure
98243>>>
98243>>>    Function psPassword Returns String
98245>>>        String sValue
98245>>>        If (ghoSQLConnectionHandler = 0) Begin
98247>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
98248>>>>
98248>>>            Function_Return ""
98249>>>        End
98249>>>>
98249>>>        Get psPassword of ghoSQLConnectionHandler to sValue
98250>>>
98250>>>        Function_Return sValue
98251>>>    End_Function
98252>>>
98252>>>    Procedure Set pbTrusted Boolean bValue
98254>>>        If (ghoSQLConnectionHandler = 0) Begin
98256>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
98257>>>>
98257>>>            Procedure_Return
98258>>>        End
98258>>>>
98258>>>        Set pbTrusted of ghoSQLConnectionHandler to bValue
98259>>>    End_Procedure
98260>>>
98260>>>    Function pbTrusted Returns Boolean
98262>>>        Boolean bValue
98262>>>        If (ghoSQLConnectionHandler = 0) Begin
98264>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
98265>>>>
98265>>>            Function_Return False
98266>>>        End
98266>>>>
98266>>>        Get pbTrusted of ghoSQLConnectionHandler to bValue
98267>>>
98267>>>        Function_Return bValue
98268>>>    End_Function
98269>>>
98269>>>    Procedure Set psConnectionString String sValue
98271>>>        If (ghoSQLConnectionHandler = 0) Begin
98273>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
98274>>>>
98274>>>            Procedure_Return
98275>>>        End
98275>>>>
98275>>>        Set psConnectionString of ghoSQLConnectionHandler to sValue
98276>>>    End_Procedure
98277>>>
98277>>>    Function psConnectionString Returns String
98279>>>        String sValue
98279>>>        If (ghoSQLConnectionHandler = 0) Begin
98281>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
98282>>>>
98282>>>            Function_Return ""
98283>>>        End
98283>>>>
98283>>>        Get psConnectionString of ghoSQLConnectionHandler to sValue
98284>>>
98284>>>        Function_Return sValue
98285>>>    End_Function
98286>>>
98286>>>    Function piConnectionOptions Returns Integer
98288>>>        Integer iValue
98288>>>        If (ghoSQLConnectionHandler = 0) Begin
98290>>>            Error DFERR_PROGRAM "ghoSQLConnectionHandler = 0! This indicates that no ConnectionID has been setup by the programmer."
98291>>>>
98291>>>            Function_Return 0
98292>>>        End
98292>>>>
98292>>>        Get piConnectionOptions of ghoSQLConnectionHandler to iValue
98293>>>
98293>>>        Function_Return iValue
98294>>>    End_Function
98295>>>
98295>>>
98295>>>    Procedure Set pbCheckDataFlexUserCount Boolean bState
98297>>>        Set pbCheckDataFlexUserCount of (phoUserCountSystem(Self)) to bState
98298>>>    End_Procedure
98299>>>
98299>>>    Function pbCheckDataFlexUserCount Returns Boolean
98301>>>        Boolean bState
98301>>>        Get pbCheckDataFlexUserCount of (phoUserCountSystem(Self)) to bState
98302>>>        Function_Return bState
98303>>>    End_Function
98304>>>
98304>>>    Procedure Set psLogTextFile String sValue
98306>>>        Set psLogTextFile of (phoLogFile(Self)) to sValue
98307>>>    End_Procedure
98308>>>
98308>>>    Function psLogTextFile Returns String
98310>>>        String sValue
98310>>>        Get psLogTextFile of (phoLogFile(Self)) to sValue
98311>>>        Function_Return sValue
98312>>>    End_Function
98313>>>
98313>>>    Procedure Set psEditorProgram String sValue
98315>>>        Set psEditorProgram of (phoLogFile(Self)) to sValue
98316>>>    End_Procedure
98317>>>
98317>>>    Function psEditorProgram Returns String
98319>>>        String sValue
98319>>>        Get psEditorProgram of (phoLogFile(Self)) to sValue
98320>>>        Function_Return sValue
98321>>>    End_Function
98322>>>
98322>>>    Procedure Set pbUseDataTableLog Boolean bState
98324>>>        Set pbUseDataTableLog of (phoLogFile(Self)) to bState
98325>>>    End_Procedure
98326>>>
98326>>>    Function pbUseDataTableLog Returns Boolean
98328>>>        Boolean bState
98328>>>        Get pbUseDataTableLog of (phoLogFile(Self)) to bState
98329>>>        Function_Return bState
98330>>>    End_Function
98331>>>
98331>>>    Procedure Set pbQuickWrite Boolean bState
98333>>>        Set pbQuickWrite of (phoLogFile(Self)) to bState
98334>>>    End_Procedure
98335>>>
98335>>>    Function pbQuickWrite Returns Boolean
98337>>>        Boolean bState
98337>>>        Get pbQuickWrite of (phoLogFile(Self)) to bState
98338>>>        Function_Return bState
98339>>>    End_Function
98340>>>
98340>>>    Procedure Set pbDatabaseWasUpdated Boolean bState
98342>>>        Boolean bUpdateVersionObjectError bVerboseState
98342>>>        Integer iSize iCount
98342>>>        Number nVersion
98342>>>        String[] aSQLQueryMessages
98343>>>
98343>>>        Get Private.pbUpdateVersionObjectError to bUpdateVersionObjectError
98344>>>        Set Private.pbDatabaseWasUpdated to bState
98345>>>        // If no errors occurred in the current cDbUpdateVersion object - write
98345>>>        // to the log that it was OK.
98345>>>        If (bUpdateVersionObjectError = False) Begin
98347>>>            Get pnCurrentVersionUpdate to nVersion
98348>>>            Send LogError of (phoLogFile(Self)) nVersion 0 CS_SuccessfulUpdate 0 False
98349>>>        End
98349>>>>
98349>>>
98349>>>        Get pbVerboseState to bVerboseState
98350>>>        If (bVerboseState = True) Begin
98352>>>            Get paSQLQueryMessages to aSQLQueryMessages
98353>>>            Move (SizeOfArray(aSQLQueryMessages)) to iSize
98354>>>            Decrement iSize
98355>>>            For iCount from 0 to iSize
98361>>>>
98361>>>                Send LogError of (phoLogFile(Self)) nVersion 0 aSQLQueryMessages[iCount] 0 False
98362>>>            Loop
98363>>>>
98363>>>        End
98363>>>>
98363>>>
98363>>>    End_Procedure 
98364>>>    
98364>>>    Procedure Set piDbVersionFileNumber Integer iFileNumber
98366>>>        Set Private.piDbVersionFileNumber to iFileNumber
98367>>>    End_Procedure                                         
98368>>>    
98368>>>    Function piDbVersionFileNumber Returns Integer
98370>>>        Function_Return (Private.piDbVersionFileNumber(Self))
98371>>>    End_Function
98372>>>
98372>>>    Procedure Set piDbVersionFieldNumber Integer iFieldNumber
98374>>>        Set Private.piDbVersionFieldNumber to iFieldNumber
98375>>>    End_Procedure                                         
98376>>>    
98376>>>    Function piDbVersionFieldNumber Returns Integer
98378>>>        Function_Return (Private.piDbVersionFieldNumber(Self))
98379>>>    End_Function
98380>>>
98380>>>    Function pbDatabaseWasUpdated Returns Boolean
98382>>>        Function_Return (Private.pbDatabaseWasUpdated(Self))
98383>>>    End_Function
98384>>>    
98384>>>    //
98384>>>    Procedure ReinitializeFramework  
98386>>>        tDbVersionInfo[] aDbVersionInfoArray
98386>>>        tDbVersionInfo[] aDbVersionInfoArray
98387>>>        Handle hoDbVersionObject
98387>>>        Integer iSize iCount
98387>>>        
98387>>>        Set Private.pbDatabaseUpdateStarted to False
98388>>>        Get paDbVersionInfoArray to aDbVersionInfoArray
98389>>>        Move (SizeOfArray(aDbVersionInfoArray)) to iSize
98390>>>        Decrement iSize
98391>>>        
98391>>>        For iCount from 0 to iSize
98397>>>>
98397>>>            Move aDbVersionInfoArray[0].hObject to hoDbVersionObject
98398>>>            Send ProcessUpdate                  of hoDbVersionObject False
98399>>>        Loop
98400>>>>
98400>>>        Send Cleanup
98401>>>    End_Procedure
98402>>>    
98402>>>    // This event is triggered by the cDbUpdateVersion child class when
98402>>>    // a database change is to be started, and is considered private.
98402>>>    // It is only executed once for the first cDbUpateVersion object!
98402>>>    Procedure InitDatabaseUpdate Handle hDbUpdateVersionObject
98404>>>        Boolean bDatabaseUpdateStarted bInUse bExists bCheckDataFlexUserCount
98404>>>        Integer iRetval iDataFlexUsers iUserCount
98404>>>        Handle hoUserCountSystem
98404>>>        tUserCount UserCount
98404>>>        tUserCount UserCount
98404>>>        DateTime dtUpdateStarted
98404>>>        tSQLConnection SQLConnection
98404>>>        tSQLConnection SQLConnection
98404>>>
98404>>>        // *Important:* If we already started the update; we do no further checking.
98404>>>        Get Private.pbDatabaseUpdateStarted to bDatabaseUpdateStarted
98405>>>        If (bDatabaseUpdateStarted = True) Begin
98407>>>            Procedure_Return
98408>>>        End
98408>>>>
98408>>>
98408>>>        // If not silent mode; Ask user if OK to start database update.
98408>>>        If (pbSilentMode(Self) = False) Begin
98410>>>            Get YesNo_Box CS_DUF_DatabaseNeedsUpdate CS_DUF_HeaderUpdateText to iRetval
98411>>>            If (iRetval <> MBR_Yes) Begin
98413>>>                Send Exit_Application
98414>>>            End
98414>>>>
98414>>>        End
98414>>>>
98414>>>        
98414>>>        Send EnableCancelButton     of ghoStatusPanel (pbEnableCancelButton(Self))
98415>>>        Send Initialize_StatusPanel of ghoStatusPanel ("   " + CS_DUF_WorkingUpdateText) CS_DUF_WorkingHeaderText ""
98416>>>        Send Start_StatusPanel      of ghoStatusPanel
98417>>>
98417>>>        // This will save the status of all open tables including Master/Alias settings,
98417>>>        // so we can restore them later;
98417>>>        Send SaveOpenTables
98418>>>
98418>>>        Move 0 to iDataFlexUsers
98419>>>        // Make various tests to check that the database is not in use.
98419>>>        Get IsDatabaseInUse of hDbUpdateVersionObject to bInUse
98420>>>        // We also use our own user counting mechanism to guard against the
98420>>>        // database isn't opened already as we need exclusive access to the tables.:
98420>>>        Get phoUserCountSystem to hoUserCountSystem
98421>>>        Get CheckUserCount of hoUserCountSystem to UserCount
98422>>>        Get CurrentNumberOfUsers of hoUserCountSystem to iUserCount
98423>>>
98423>>>        Get pbCheckDataFlexUserCount of hoUserCountSystem to bCheckDataFlexUserCount
98424>>>        // Check DataFlex user count to see if anybody else is using the DataFlex license...
98424>>>        If (bCheckDataFlexUserCount = True) Begin
98426>>>            Get_Current_User_Count to iDataFlexUsers
98427>>>            // For some reason DataFlex - in some cases - might think that 2 users
98427>>>            // are in use while debugging from the Studio.
98427>>>            If (IsDebuggerPresent() and iDataFlexUsers = 2) Begin
98429>>>                Decrement iDataFlexUsers
98430>>>            End
98430>>>>
98430>>>        End 
98430>>>>
98430>>>        Else Begin
98431>>>            Move 1 to iDataFlexUsers 
98432>>>            Move 1 to iUserCount
98433>>>            Move False to bInUse
98434>>>        End
98434>>>>
98434>>>
98434>>>        If (pbSilentMode(Self) = False and iDataFlexUsers > 1) Begin
98436>>>            Get YesNo_Box CS_DUF_DatabaseInUseShort to iRetval
98437>>>            If (iRetval <> MBR_Yes) Begin
98439>>>                Send Exit_Application
98440>>>            End
98440>>>>
98440>>>        End
98440>>>>
98440>>>
98440>>>        If (bInUse = True or (UserCount.iError <> 0) or (iUserCount > 1)) Begin
98442>>>            Send Stop_Box CS_DUF_DatabaseInUseText
98443>>>            Send Exit_Application
98444>>>        End
98444>>>>
98444>>>
98444>>>        // This will put a look on the DbUpdateLock.ucf file.
98444>>>        // It is released when the update process is finished
98444>>>        Get CheckUserCount of (phoDatabaseUpdateLock(Self)) to UserCount
98445>>>
98445>>>        Move (CurrentDateTime()) to dtUpdateStarted
98446>>>        Set pdtUpdateStart of (phoLogFile(Self)) to dtUpdateStarted
98447>>>        Set Private.pbDatabaseUpdateStarted to True
98448>>>
98448>>>        // We need to close all tables before starting to make changes.
98448>>>        Close DF_ALL DF_PERMANENT
98449>>>
98449>>>        // If these properties has not exclicitly been set in the object, set them
98449>>>        // to settings from the SQLConnections.ini file;
98449>>>        Get pSQLConnection of ghoSQLConnectionHandler to SQLConnection
98450>>>        If (psSchema(Self) = "") Begin
98452>>>            Set psSchema            to SQLConnection.sSchema
98453>>>        End
98453>>>>
98453>>>        If (psBaseTableSpace(Self) = "") Begin
98455>>>            Set psBaseTableSpace    to SQLConnection.sBaseTableSpace
98456>>>        End
98456>>>>
98456>>>        If (psLongTableSpace(Self) = "") Begin
98458>>>            Set psLongTableSpace    to SQLConnection.sLongTableSpace
98459>>>        End
98459>>>>
98459>>>        If (psIndexTableSpace(Self) = "") Begin
98461>>>            Set psIndexTableSpace   to SQLConnection.sIndexTableSpace
98462>>>        End
98462>>>>
98462>>>        If (SQLConnection.sDriverID = "" or SQLConnection.sDriverID = DATAFLEX_ID) Begin
98464>>>            Procedure_Return
98465>>>        End
98465>>>>
98465>>>
98465>>>        Get SQLUtilCheckIfDatabaseExists of hDbUpdateVersionObject SQLConnection.sDatabase to bExists
98466>>>        If (SQLConnection.sDatabase <> "" and bExists = False) Begin
98468>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
98469>>>            Send Stop_StatusPanel of ghoStatusPanel
98470>>>            // ToDo: NS 2019-09-23 I think we should always show an error message to the user if this occur (!)
98470>>>            Send Stop_Box (CS_DUF_DatabaseConnStringSpec + SQLConnection.sDatabase + CS_DUF_DatabaseDoesntExist )
98471>>>//            Error DFERR_PROGRAM ("The database specified in the connection string: '" + SQLConnection.sDatabase + "' doesn't exist!\n\nYou need to create it with a database management software or by using the 'SqlDatabaseCreate' function, which can be used in the 'OnPreUpdate' event of the cDbUpdateHandler object.\n\nThe program will now exit.")
98471>>>            Send Exit_Application
98472>>>        End
98472>>>>
98472>>>    End_Procedure
98473>>>
98473>>>    // *** Hook message for pre-processing ***
98473>>>    // Event to be used to auto-create a version table when "DUF_Use_Custom_DbVersion" is used.
98473>>>    // Aka, when another table than the standard "DbVersion" is used.
98473>>>    Procedure OnCreateCustomDbVersionTable
98475>>>    End_Procedure
98476>>>    
98476>>>    // *** Hook message for pre-processing ***
98476>>>    // The programmer can use this event for putting code that
98476>>>    // needs to be executed _before_ code in any of the cDbUpdateVersion
98476>>>    // child objects are executed.
98476>>>    Procedure OnPreUpdate
98478>>>    End_Procedure
98479>>>
98479>>>    // *** Hook message for post-processing ***
98479>>>    // The programmer should use this event for putting code that
98479>>>    // needs to be executed _after_ all database updates have finished.
98479>>>    Procedure OnPostUpdate
98481>>>    End_Procedure
98482>>>
98482>>>    // *** Hook message for custom DbVersion record find ***
98482>>>    // The programmer can use this event for putting code that
98482>>>    // needs to be executed to find a *custom* DbVersion table record.
98482>>>    // By default the DbVersion table is used but this can be
98482>>>    // customized by adding this line to the code;
98482>>>    // "Define DUF_Use_Custom_DbVersion" before the line "Use cDbUpdateHandler.pkg"
98482>>>    // Note: You do _not_ need to use this event if the DbVersion table is used
98482>>>    //       to save the current database version to. Only if you use your own
98482>>>    //       table _and_ it is not a system table (contains only one record).
98482>>>    Procedure OnFindVersionRecord
98484>>>        // Open MyTable
98484>>>        // Move xx to MyTable.Field1
98484>>>        // Move yy to MyTable.Field2
98484>>>        // Find le MyTable by Index.x
98484>>>    End_Procedure
98485>>>
98485>>>    // Hook event for writing header error text (pre-update) to
98485>>>    // a datatable. Only called if the pbUseDataTableLog property = True.
98485>>>    // Don't forget to Open the table first (!) as all
98485>>>    // tables have been closed at this stage.
98485>>>    // The start date & time is passed.
98485>>>    Procedure OnErrorWriteHeader_DataTable DateTime dtUpdateStart
98487>>>    End_Procedure
98488>>>
98488>>>    // Hook event to log errors to a database table.
98488>>>    // Only called if the pbUseDataTableLog = True.
98488>>>    // Don't forget to Open the table first (!) as all
98488>>>    // tables have been closed at this stage.
98488>>>    // If pbQuickWrite = True the DbUpdateErrorArray
98488>>>    // will contain just one row, as it is called for each error
98488>>>    // that occurred. Else it is called once at the end after all updates
98488>>>    // have run and contains all errors.
98488>>>    Procedure OnErrorWriteRow_DataTable tDbUpdateError[] DbUpdateErrorArray
98490>>>    End_Procedure
98491>>>
98491>>>    // Automatically send after all processing is done, but before the OnPostUpdate event.
98491>>>    Procedure Cleanup
98493>>>        Boolean bDatabaseWasUpdated bError
98493>>>
98493>>>        Send CheckAutoCreateDbVersionTable
98494>>>        Send RestoreOpenTables
98495>>>
98495>>>        // The function library have two purposes; one is to use it in the
98495>>>        // Database Update Framework, but it can also be used on its own.
98495>>>        // If that is the case it has its own error handling system, which
98495>>>        // we temporarily disbled when running updates because we have
98495>>>        // error handling/logging here too... We now restore its setting.
98495>>>        If (ghoDbUpdateFunctionLibrary > 0) Begin
98497>>>            Set pbHandleQueryErrors of ghoDbUpdateFunctionLibrary to True
98498>>>        End
98498>>>>
98498>>>        Set pbHandleQueryErrors to True
98499>>>
98499>>>        Get pbDatabaseWasUpdated to bDatabaseWasUpdated
98500>>>        Get pbDbUpdateErrorHasOccured to bError
98501>>>        If (bDatabaseWasUpdated = True or bError = True) Begin
98503>>>
98503>>>            // We should always create the log as it also contains info about
98503>>>            // the update being successful.
98503>>>            Send WriteErrorLog of (phoLogFile(Self))
98504>>>
98504>>>            // This is a programmer's hook message:
98504>>>            Send OnPostUpdate
98505>>>
98505>>>            Send Stop_StatusPanel of ghoStatusPanel
98506>>>
98506>>>            If (pbSilentMode(Self) = False) Begin
98508>>>                If (bError = True) Begin
98510>>>                    If (pbShowErrorLogPostRun(Self) = True) Begin
98512>>>                        Send ShowErrorLog of (phoLogFile(Self))
98513>>>                    End
98513>>>>
98513>>>                    Send Info_Box CS_DUF_DbUpdatedErrorText
98514>>>                    Send Exit_Application
98515>>>                End
98515>>>>
98515>>>                Else Begin
98516>>>                    If (Private.pbDatabaseWasUpdated(Self) = True) Begin
98518>>>                        Send Info_Box CS_DUF_DatabaseUpdatedText
98519>>>                    End
98519>>>>
98519>>>                    Else Begin
98520>>>                        Send Info_Box CS_DUF_DatabaseCheckedText
98521>>>                    End
98521>>>>
98521>>>
98521>>>                End
98521>>>>
98521>>>            End
98521>>>>
98521>>>        End
98521>>>>
98521>>>
98521>>>        // Restore the standard error handler:
98521>>>        Get piOrgErrorHandlerID to Error_Object_Id
98522>>>    End_Procedure
98523>>>
98523>>>    // We do this _before_ we close the database to make changes, and save
98523>>>    // all 'Master' & 'Alias' tables settings so we can restore when
98523>>>    // we reopen the database.
98523>>>    Procedure SaveOpenTables
98525>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
98525>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
98526>>>        Get _MasterAndAliasFiles to aDbUpdateHandlerMasterAlias
98527>>>        Set paDbUpdateHandlerMasterAlias to aDbUpdateHandlerMasterAlias
98528>>>    End_Procedure
98529>>>
98529>>>    // Returns a struct array with all currently open tables and a "state" that indicates if the table
98529>>>    // was opened DF_FILE_ALIAS_DEFAULT, DF_FILE_IS_MASTER or DF_FILE_IS_ALIAS
98529>>>    Function _MasterAndAliasFiles Returns tDbUpdateHandlerMasterAlias[]
98531>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
98531>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
98532>>>        Integer hTable iMasterAliasType iSize
98532>>>        Boolean bOpen
98532>>>
98532>>>        Move 0 to hTable
98533>>>        Repeat
98533>>>>
98533>>>            Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
98536>>>            If (hTable <> 0) Begin
98538>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
98541>>>                If (bOpen = True) Begin
98543>>>                    Get_Attribute DF_FILE_ALIAS of hTable to iMasterAliasType
98546>>>                    Move (SizeOfArray(aDbUpdateHandlerMasterAlias)) to iSize
98547>>>                    Move hTable to aDbUpdateHandlerMasterAlias[iSize].hTable
98548>>>                    Move iMasterAliasType to aDbUpdateHandlerMasterAlias[iSize].iMode
98549>>>                End
98549>>>>
98549>>>            End
98549>>>>
98549>>>        Until (hTable = 0)
98551>>>
98551>>>        Function_Return aDbUpdateHandlerMasterAlias
98552>>>    End_Function
98553>>>
98553>>>    // Message that re-opens all files in the filelist.cfg and restores any master & alias attributes.
98553>>>    // Takes one parameter:
98553>>>    //   A struct array with all master & alias
98553>>>    Procedure RestoreOpenTables
98555>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
98555>>>        tDbUpdateHandlerMasterAlias[] aDbUpdateHandlerMasterAlias
98556>>>        Integer hTable iFileAlias iSize iCount
98556>>>        Boolean bOpen
98556>>>        String sRootName
98556>>>
98556>>>        Move 0 to hTable
98557>>>        Get paDbUpdateHandlerMasterAlias to aDbUpdateHandlerMasterAlias
98558>>>        Move (SizeOfArray(aDbUpdateHandlerMasterAlias)) to iSize
98559>>>        Decrement iSize
98560>>>        For iCount from 0 to iSize
98566>>>>
98566>>>            Move aDbUpdateHandlerMasterAlias[iCount].hTable to hTable
98567>>>            // We also need to check that the table hasn't been removed...
98567>>>            Get_Attribute DF_FILE_ROOT_NAME of hTable to sRootName
98570>>>            If (hTable <> 0 and sRootName <> "") Begin
98572>>>                Open hTable
98574>>>                Get_Attribute DF_FILE_OPENED of hTable to bOpen
98577>>>                If (bOpen = True) Begin
98579>>>                    Move aDbUpdateHandlerMasterAlias[iCount].iMode to iFileAlias
98580>>>                    If (iFileAlias = DF_FILE_IS_MASTER) Begin
98582>>>                        Set_Attribute DF_FILE_ALIAS of hTable to DF_FILE_IS_MASTER
98585>>>                    End
98585>>>>
98585>>>                    Else If (iFileAlias = DF_FILE_IS_ALIAS) Begin
98588>>>                        Set_Attribute DF_FILE_ALIAS of hTable to DF_FILE_IS_ALIAS
98591>>>                    End
98591>>>>
98591>>>                End
98591>>>>
98591>>>            End
98591>>>>
98591>>>        Loop
98592>>>>
98592>>>    End_Procedure
98593>>>
98593>>>    // This checks for both duplicate pnVersionNumbers _and_ that
98593>>>    // the cDbVersion object pnVersionNumber's all are consecutive (higher than the previous).
98593>>>    Procedure CheckForDuplicates Number nVersion
98595>>>        tDbVersionInfo[] DbVersionInfoArray
98595>>>        tDbVersionInfo[] DbVersionInfoArray
98596>>>        Integer iCount iSize iHits iDuplicateIndex
98596>>>        Number nCompare
98596>>>        Handle hObject1 hObject2
98596>>>        String sObjectName1 sObjectName2
98596>>>        Boolean bObjectOrderError
98596>>>
98596>>>        Get paDbVersionInfoArray to DbVersionInfoArray
98597>>>        Move (SizeOfArray(DbVersionInfoArray)) to iSize
98598>>>        Decrement iSize
98599>>>        Move 0 to iHits
98600>>>        Move 0 to nCompare
98601>>>        Move False to bObjectOrderError
98602>>>        For iCount from 0 to iSize
98608>>>>
98608>>>            If (nVersion = DbVersionInfoArray[iCount].nVersionNumber) Begin
98610>>>                Increment iHits
98611>>>                If (iHits > 1) Begin
98613>>>                    Move iCount to iDuplicateIndex
98614>>>                    If (nCompare <> 0) Begin
98616>>>                        Move (nCompare >= DbVersionInfoArray[iCount].nVersionNumber) to bObjectOrderError
98617>>>                    End
98617>>>>
98617>>>                End
98617>>>>
98617>>>            End
98617>>>>
98617>>>            Move DbVersionInfoArray[iCount].nVersionNumber to nCompare
98618>>>        Loop
98619>>>>
98619>>>        If (iHits > 1) Begin
98621>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
98622>>>            Move DbVersionInfoArray[(iDuplicateIndex   )].hObject to hObject1
98623>>>            Move DbVersionInfoArray[(iDuplicateIndex -1)].hObject to hObject2
98624>>>            Move (Name(hObject1)) to sObjectName1
98625>>>            Move (Name(hObject2)) to sObjectName2
98626>>>            Error DFERR_PROGRAM ("Duplicate version numbers! The SAME pnVersionNumber value was set for the following two objects; Program will now exit!\n\n" + sObjectName1 + "\n" + sObjectName2)
98627>>>>
98627>>>            Send Exit_Application
98628>>>        End
98628>>>>
98628>>>        Else If (bObjectOrderError = True) Begin
98631>>>            Move (piCurrentErrorHandlerID(Self)) to Error_Object_Id
98632>>>            Error DFERR_PROGRAM ("cDbVersion objects out of order! One or more of the cDbVersion objects has been placed out of order. This means that at least one pnVersionNumber is HIGHER than the following object's pnVersionNumber.\nProgram will now exit!")
98633>>>>
98633>>>            Send Exit_Application
98634>>>        End
98634>>>>
98634>>>    End_Procedure
98635>>>
98635>>>    // We take care of all errors in the Error_Report below and
98635>>>    // collect them all to an array property. So just ignore any
98635>>>    // "Ignore_Error" & "Trap_Error" messages that might be send/used
98635>>>    // in some other package.
98635>>>    Procedure Ignore_Error Integer iError
98637>>>    End_Procedure
98638>>>
98638>>>    Procedure Trap_Error Integer iError
98640>>>    End_Procedure
98641>>>
98641>>>    // Build complete error description from Flexerrs and user error message.
98641>>>    Function Error_Description Integer Error# String ErrMsg Returns String
98643>>>        String Full_Error_Text
98643>>>        
98643>>>        Move (Trim(ErrMsg)) to ErrMsg
98644>>>        Move (Trim(Error_Text(DESKTOP, Error#))) to Full_Error_Text
98645>>>        
98645>>>        If (ErrMsg <> "") Begin
98647>>>            
98647>>>            If ((Full_Error_Text<>"" ) and ;                Error_Text_Available( DESKTOP, Error# ) ) Begin
98649>>>                // Make sure last character of error text is a separating symbol.
98649>>>                // if not, add a "." So we have format of "error-text. error-detail"
98649>>>                If (Pos(Right(Full_Error_Text,1),".,:;") =0) ;                    Move (Full_Error_Text - ".") to Full_Error_Text
98652>>>                Move (Full_Error_Text * ErrMsg)  to Full_Error_Text
98653>>>            End
98653>>>>
98653>>>            Else ;                Move ErrMsg to Full_Error_Text
98655>>>            
98655>>>        End
98655>>>>
98655>>>        
98655>>>        Function_Return Full_Error_Text
98656>>>    End_Function
98657>>>
98657>>>    // While we update the database we collect all errors in
98657>>>    // the struct array paDbUpdateErrorArray.
98657>>>    Procedure Error_Report Integer iErrorNumber Integer iErrorLine String sErrorText
98659>>>        Number nVersion
98659>>>        Handle hoLogFile 
98659>>>//        String sErrExtraText
98659>>>        
98659>>>        If (Private.pbProcessingError(Self)) Begin
98661>>>            Procedure_Return
98662>>>        End
98662>>>>
98662>>>
98662>>>        // The UtilTableNameFromHandleToString function does a:
98662>>>        // "Get_Attribute DF_FILE_TABLE_NAME of hTable to sTableName" call
98662>>>        // and it generates an error if the table is of the embedded type.
98662>>>        // As we don't want to trigger an error in that very specific case,
98662>>>        // we just ignore it here.
98662>>>        //
98662>>>        // If no report mode, just set the err indicator to true.
98662>>>        If (Error_Report_Mode(Self) = DUF_ERROR_NO_REPORT) Begin
98664>>>            Move False to Err
98665>>>            Procedure_Return
98666>>>        End
98666>>>>
98666>>>
98666>>>        If (iErrorNumber = DFERR_UNSUPPORTED_ATTRIBUTE) Begin
98668>>>            Procedure_Return
98669>>>        End
98669>>>>
98669>>>
98669>>>        Set Private.pbProcessingError to True
98670>>>        Set Private.pbUpdateVersionObjectError to True
98671>>>
98671>>>        Set pbDbUpdateErrorHasOccured to True
98672>>>        Get pnCurrentVersionUpdate to nVersion
98673>>>        Get phoLogFile to hoLogFile
98674>>>//        Get Error_Description iErrorLine sErrorText to sErrorText
98674>>>        Send LogError of hoLogFile nVersion iErrorNumber sErrorText iErrorLine True
98675>>>
98675>>>        Set Private.pbProcessingError to False
98676>>>    End_Procedure
98677>>>
98677>>>End_Class
98678>Use vWin32fh.pkg
98678>Use cDbUpdateVersion.pkg
98678>
98678>Object oHtmlHelp is a cHtmlHelp
98680>    Set pbAlwaysOnTop to False
98681>End_Object
98682>
98682>Define CS_PropertiesKeyWord     for "Properties"
98682>Define CS_ThemeKeyWord          for "Theme"
98682>
98682>//#IF (!@ < 190)
98682>//    Send Stop_Box "Nope, that won't work. You need at least DataFlex 19.0 to run this program."
98682>//    Send Exit_Application
98682>//#ENDIF
98682>
98682>Object oApplication is a cApplication
98684>    Set psCompany to "RDC Tools International"
98685>    Set psProduct to "DUF - Code Generator"
98686>    Set peHelpType to htHtmlHelp
98687>    // Note: The help file settings gets changed by the Help toolbar button(s).
98687>    Set psHelpFile to "Developer5.chm"
98688>
98688>    Property Handle phoDbUpdateHandler 0
98690>    Property Handle phoTableDUFCodeGenerator_vw 0
98692>    Property String private.psFilelistFromOrg ""
98694>    Property String psFilelistFrom ""
98696>    Property Integer[] piaDifferences
98698>    Property String psOrgOpenPath ""
98700>
98700>    // Set psOrgOpenPath at startup
98700>    Procedure Save_DF_OPEN_PATH
98703>        String sOrgOpenPath sDataPath sFileListPath
98703>        
98703>        Get psFileList of (phoWorkspace(ghoApplication)) to sFileListPath
98704>        Set private.psFilelistFromOrg to sFileListPath
98705>        Get_Attribute DF_OPEN_PATH to sOrgOpenPath
98708>        // First remove the current Data folder path
98708>        Get PathAtIndex of (phoWorkspace(Self)) sOrgOpenPath 1 to sDataPath
98709>        Move (Replace(sDataPath, sOrgOpenPath, "")) to sOrgOpenPath
98710>        If (Left(sOrgOpenPath, 2) = "\;") Begin
98712>            Move (Replace("\;", sOrgOpenPath, "")) to sOrgOpenPath
98713>        End
98713>        Set psOrgOpenPath to sOrgOpenPath
98714>    End_Procedure
98715>
98715>    Procedure OnWorkspaceOpened
98718>        Forward Send OnWorkspaceOpened
98720>        Send Save_DF_OPEN_PATH
98721>    End_Procedure
98722>
98722>    Procedure Restore_DF_OPEN_PATH
98725>        String sOrgOpenpath
98725>        Get psOrgOpenPath to sOrgOpenpath
98726>        Set_Attribute DF_OPEN_PATH to sOrgOpenPath
98729>    End_Procedure
98730>
98730>    Procedure ResetFilelistPathing
98733>        String sDriverID sServer sFileList sDataPath
98733>        Send Restore_DF_OPEN_PATH
98734>        Close DF_ALL DF_PERMANENT
98735>        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98736>        Get psServer   of ghoDbUpdateFunctionLibrary to sServer  
98737>        If (sDriverID <> "") Begin
98739>            Logout sDriverID sServer
98740>        End
98740>        Set psDriverID of ghoDbUpdateFunctionLibrary to DATAFLEX_ID
98741>        Set psServer   of ghoDbUpdateFunctionLibrary to ""
98742>        Get private.psFilelistFromOrg to sFileList
98743>        Get ParseFolderName sFileList                      to sDataPath
98744>        If (Right(sDataPath, 1) = "\") Begin
98746>            Move (Left(sDataPath, (Length(sDataPath) -1))) to sDataPath
98747>        End
98747>        Set psDataPath of (phoWorkspace(Self))  to sDataPath
98748>        Set psFileList of (phoWorkspace(Self))  to sFileList
98749>        Set_Attribute DF_FILELIST_NAME          to sFileList
98752>    End_Procedure
98753>
98753>    Function ChangeFilelistPathing String sFileList Returns Boolean
98756>        String sPath sSQLConnectionsIniName sDataPath sDriverID sServer sOrgOpenPath
98756>        Boolean bExists bEmbedded bIsSQLDriver bErr
98756>        Handle hoDbUpdateHandler hoSQLConnectionHandler hoSQLConnectionIniFile
98756>        tSQLConnection SQLConnection
98756>        tSQLConnection SQLConnection
98756>        Integer iRetval iDriverID
98756>
98756>        Move False to Err
98757>        Move (Trim(sFileList)) to sFileList
98758>        Get vFilePathExists sFileList to bExists
98759>        If (bExists = False) Begin
98761>            Send Info_Box "Can't find Filelist.cfg"
98762>            Function_Return False
98763>        End
98763>
98763>        Send Cursor_Wait of Cursor_Control
98764>        Get psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
98765>        Get psServer   of ghoDbUpdateFunctionLibrary to sServer
98766>        Send Restore_DF_OPEN_PATH
98767>        Close DF_ALL DF_PERMANENT
98768>        Logout sDriverID sServer
98769>
98769>        Get ParseFolderName sFileList                      to sDataPath
98770>        If (Right(sDataPath, 1) = "\") Begin
98772>            Move (Left(sDataPath, (Length(sDataPath) -1))) to sDataPath
98773>        End
98773>        Set psDataPath of (phoWorkspace(Self))  to sDataPath
98774>        Set psFileList of (phoWorkspace(Self))  to sFileList
98775>
98775>        // Temporarily "redirect" the Open path to the current Data folder
98775>        Get psOrgOpenPath to sOrgOpenPath
98776>        Set_Attribute DF_OPEN_PATH to (sDataPath + ";" + sOrgOpenPath)
98779>        Set_Attribute DF_FILELIST_NAME to sFileList
98782>        Get UtilIsAnyFilelistEntrySQLtable of ghoDbUpdateFunctionLibrary to sDriverID
98783>        Get IsSQLDriver of ghoDbUpdateFunctionLibrary sDriverID to bIsSQLDriver
98784>        
98784>        // If none of the tables in the Filelist.cfg are SQL, we're done. Let's get out of here!
98784>        If (bIsSQLDriver = False) Begin
98786>            Send Cursor_Ready of Cursor_Control
98787>            Function_Return True
98788>        End
98788>
98788>        // Note: We delete all cache files (*.cch) before attempting to open any
98788>        // tables as a precausion, in case a table has been changed at the SQL back-end,
98788>        // because then the .cch file is out-of-sync with the SQL table.
98788>        Get DriverIndex of ghoDbUpdateFunctionLibrary sDriverID to iDriverID
98789>        Move Err to bErr 
98790>        Send Ignore_Error of Error_Object_Id DFERR_OPERATION_NOT_ALLOWED
98791>        Get_Attribute DF_DRIVER_CACHE_PATH of iDriverID to sPath
98794>        If (sPath = "") Begin 
98796>            If (LastErr = DFERR_OPERATION_NOT_ALLOWED and bErr = False) Begin
98798>                Move False to Err
98799>            End
98799>            Move sDataPath to sPath
98800>        End
98800>        Get vFolderFormat sPath to sPath
98801>        Get vDeleteFile (sPath + "*.cch") to iRetval
98802>
98802>        // Try to make a database connection by reading the SQLConnections.ini file:
98802>        Get vFolderFormat sDataPath to sPath
98803>        Get vParentPath sDataPath   to sPath
98804>        Get vFolderFormat sPath     to sPath
98805>        Move (sPath + "Programs")   to sPath
98806>        Get vFolderFormat sPath     to sPath
98807>        Move CS_SQLIniFileName to sSQLConnectionsIniName
98808>        Get vFilePathExists (sPath + sSQLConnectionsIniName) to bExists
98809>        If (bExists = False) Begin
98811>            Get UtilIsAllFilelistEntriesDataFlexTables of ghoDbUpdateFunctionLibrary to bEmbedded
98812>            If (bEmbedded = False) Begin
98814>                Send Cursor_Ready of Cursor_Control
98815>                Get YesNo_Box ("Couldn't find the DUF SQLConnections.ini file in the workspace Programs folder. Is there a DataFlex DFConnId.ini file in the Data folder that you want to open instead?") to iRetval
98816>                If (iRetval = MBR_Yes) Begin
98818>                    Send Cursor_Wait of Cursor_Control
98819>                    Move "DFConnId.ini" to sSQLConnectionsIniName
98820>                        Send UnRegisterAllConnections of ghoConnection
98821>                        Get AddAllConnections of ghoConnection to bExists
98822>                        Set psIniFileName of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) to sSQLConnectionsIniName
98823>                        Set psIniFilePath of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) to sPath
98824>                        Get SetupSQLConnection of ghoSQLConnectionHandler True False to SQLConnection
98825>                End
98825>            End
98825>        End
98825>        Else Begin
98826>            Get phoDbUpdateHandler to hoDbUpdateHandler
98827>            Get phoSQLConnectionHandler of hoDbUpdateHandler to hoSQLConnectionHandler
98828>            Get phoSQLConnectionIniFile of hoSQLConnectionHandler to hoSQLConnectionIniFile
98829>            Set psIniFilePath of hoSQLConnectionIniFile to sPath
98830>            Set psIniFileName of hoSQLConnectionIniFile to sSQLConnectionsIniName
98831>
98831>            Get SetupSQLConnection of hoSQLConnectionHandler True True to SQLConnection
98832>            Set pSQLConnection     of hoSQLConnectionHandler to SQLConnection
98833>        End
98833>
98833>        Send Cursor_Ready of Cursor_Control
98834>        Function_Return (Err = False)
98835>    End_Function
98836>
98836>    Object oConnection is a cConnection
98838>        Use LoginEncryption.pkg
Including file: LoginEncryption.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\LoginEncryption.pkg)
98838>>>Use cLoginEncryption.pkg
98838>>>
98838>>>Object oLoginEncryption is a cLoginEncryption
98840>>>
98840>>>    // this must be created in your appsrc directory and must contain an encryption
98840>>>    // key that is set to psEncryptPassword. It will look something like this
98840>>>    //
98840>>>    // Set psEncryptPassword to "JchUAo7W@r.b{<Yk~OONi0nq=sMi[*Rn[A-`Vo)q"
98840>>>    //  
Including file: LoginEncryptionKey.inc    (C:\Projects\DF20\DbUpdateFramework\AppSrc\LoginEncryptionKey.inc)
98840>>>>// Studio generated login encryption key
98840>>>>Set psEncryptPassword to "%sLm*XHVF>f0yB.:.PHrBx6L)8x70i7zAN{q._WC"
98841>>>>
98841>>>    
98841>>>    // use this to register this object to your cConnection Object. This object
98841>>>    // must be created after the cConnection object
98841>>>    Move Self to ghoLoginEncryption
98842>>>End_Object
98843>        Use DatabaseLoginDialog.dg
Including file: DatabaseLoginDialog.dg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\DatabaseLoginDialog.dg)
98843>>>
98843>>>Use Windows.pkg
98843>>>Use cConnection.pkg
98843>>>Use dfLine.pkg
98843>>>
98843>>>Object oDatabaseLoginDialog is a ModalPanel
98845>>>    Set Label to "Database Login"
98846>>>    Set Location to 2 2
98847>>>    Set Size to 110 211
98848>>>    
98848>>>    Property String psId
98850>>>    Property Boolean pbOk False
98852>>>    Property Boolean pbChanged False
98854>>>    Property Boolean pbAllowRemember True
98856>>>    
98856>>>    // this registers this object with the cConnection object.
98856>>>    Move Self to ghoLoginConnectDialog
98857>>>    
98857>>>    Object oUserIDForm is a Form
98859>>>        Set Label to "User Name"
98860>>>        Set Size to 12 85
98861>>>        Set Location to 34 79
98862>>>        Set Label_Col_Offset to 64
98863>>>        Set peAnchors to anTopLeftRight
98864>>>    End_Object
98865>>>    
98865>>>    Object oPwdForm is a Form
98867>>>        Set Size to 12 85
98868>>>        Set Location to 49 79
98869>>>        Set Label_Col_Offset to 64
98870>>>        Set Password_State to True
98871>>>        Set peAnchors to anTopLeftRight
98872>>>        Set Label to "Password"
98873>>>    End_Object
98874>>>    
98874>>>    Object oTrustedConnection is a CheckBox
98876>>>        Set Size to 10 50
98877>>>        Set Location to 65 79
98878>>>        Set Label to "Trusted Connection"
98879>>>    End_Object
98880>>>    
98880>>>    Object oRemember is a CheckBox
98882>>>        Set Size to 10 50
98883>>>        Set Location to 79 14
98884>>>        Set Label to "Remember and don't ask again"
98885>>>        Set Checked_State to True
98886>>>    End_Object
98887>>>    
98887>>>    Object oLogin_btn is a Button
98889>>>        Set Label to "&Login"
98890>>>        Set Location to 92 102
98891>>>        Set peAnchors to anBottomRight
98892>>>        Set Default_State to True
98893>>>        
98893>>>        Procedure OnClick
98896>>>            Boolean bTrust
98896>>>            String sUser sPwd sConn sErr sId
98896>>>            Integer iError
98896>>>            Get psId to sId
98897>>>            Get Value of oUserIDForm to sUser
98898>>>            Get Value of oPwdForm to sPwd
98899>>>            Get Checked_State of oTrustedConnection to bTrust
98900>>>            
98900>>>            Get LoginConnectIdNewCredentials of ghoConnection sId sUser sPwd bTrust to iError
98901>>>            If (iError=0) Begin
98903>>>                Set pbOk to True
98904>>>                Set pbChanged to True
98905>>>                Send Close_Panel
98906>>>            End
98906>>>>
98906>>>            Else Begin
98907>>>                Get psErrorText of ghoConnection to sErr
98908>>>                Send UserError sErr "Login Error"
98909>>>            End
98909>>>>
98909>>>        End_Procedure
98910>>>    End_Object
98911>>>    
98911>>>    Object oCancel_btn is a Button
98913>>>        Set Label to "&Cancel"
98914>>>        Set Location to 92 157
98915>>>        Set peAnchors to anBottomRight
98916>>>        
98916>>>        Procedure OnClick
98919>>>            Send Close_Panel
98920>>>        End_Procedure
98921>>>    End_Object
98922>>>    
98922>>>    Object oConnectionIdInfo is a TextBox
98924>>>        Set Size to 10 50
98925>>>        Set Location to 4 14
98926>>>        Set Label to 'Connection Id='
98927>>>    End_Object
98928>>>    
98928>>>    Object oConnectionServerInfo is a TextBox
98930>>>        Set Size to 10 50
98931>>>        Set Location to 16 14
98932>>>        Set Label to 'Server'
98933>>>    End_Object
98934>>>    
98934>>>    Object oLineControl1 is a LineControl
98936>>>        Set Size to 2 202
98937>>>        Set Location to 29 5
98938>>>    End_Object
98939>>>    
98939>>>    Function LoginConnectIdDialog String sId Returns Boolean
98942>>>        Boolean bOk bChanged bTrusted bAllowRemember bRemember
98942>>>        String sUser sPwd sDescription
98942>>>        tConnection Connect
98942>>>        tConnection Connect
98942>>>        
98942>>>        Get pbAllowRemember to bAllowRemember
98943>>>        
98943>>>        
98943>>>        If not bAllowRemember Begin
98945>>>            Set Enabled_State of oRemember to bRemember
98946>>>            Set Visible_State of oRemember to bRemember
98947>>>        End
98947>>>>
98947>>>        
98947>>>        Get ConnectionIdInfo of ghoConnection sId to Connect
98948>>>        Set Value of oConnectionIdInfo to ("Connection ID="+Connect.sId)
98949>>>        Set Value of oConnectionServerInfo to Connect.sString
98950>>>        
98950>>>        Set psId to sId
98951>>>        Set pbOk to False
98952>>>        Set pbChanged to False
98953>>>        Set Value of oUserIDForm to Connect.sUID
98954>>>        Set Value of oPwdForm to ""
98955>>>        
98955>>>        Send Popup
98956>>>        
98956>>>        Get pbOk to bOk
98957>>>        Get pbChanged to bChanged
98958>>>        If (bChanged and bOk) Begin
98960>>>            If bAllowRemember Begin
98962>>>                Get Checked_State of oRemember to bRemember
98963>>>                If bRemember Begin
98965>>>                    Get Checked_State of oTrustedConnection to bTrusted
98966>>>                    If not (bTrusted) Begin
98968>>>                        Get Value of oUserIDForm to sUser
98969>>>                        Get Value of oPwdForm to sPwd
98970>>>                    End
98970>>>>
98970>>>                    Get StoreConnectionIdCredentials of ghoConnection sId sUser sPwd bTrusted to bOk
98971>>>                End
98971>>>>
98971>>>            End
98971>>>>
98971>>>        End
98971>>>>
98971>>>        Function_Return bOk
98972>>>    End_Function
98973>>>    
98973>>>    
98973>>>    On_Key Key_Alt+Key_O Send KeyAction of oLogin_btn
98974>>>    On_Key Key_Alt+Key_L Send KeyAction of oCancel_btn
98975>>>End_Object
98976>>>
98976>    End_Object
98977>
98977>End_Object
98978>
98978>Object oDbUpdateHandler is a cDbUpdateHandler
98980>    Set piDbVersionFileNumber  to 1
98981>    Set piDbVersionFieldNumber to 1
98982>    Set phoDbUpdateHandler of ghoApplication to Self
98983>
98983>    Procedure OnPreUpdate
98986>        String sVersionInfo                     // DF 18.2 MSSQLDRV
98986>//        Get MinMSSQLDRV_And_ClientVersion "6.1.0.32"  SQLSERVER2012CLIENT True True to sVersionInfo
98986>                                                // DF 19.1 MSSQLDRV
98986>        Get MinMSSQLDRV_And_ClientVersion "6.3.0.13" SQLSERVER2016CLIENT True True to sVersionInfo
98987>    End_Procedure  
98988>
98988>    Object oDbUpdateVersion1_0 is a cDbUpdateVersion
98990>        Set pnVersionNumber to 1.0
98991>//        Procedure OnUpdate
98991>//            Boolean bOK 
98991>//        End_Procedure
98991>    End_Object
98992>
98992>End_Object
98993>
98993>Object oToolTipController is a cToolTipController
98995>    Move Self to ghoToolTipController
98996>    Set pbBalloonStyle to False
98997>    Set piIcon to TTI_INFO
98998>    Set psTitle to "Information"
98999>    Set piMaxWidth to 400
99000>    Set piDurationPopup to 14000    // 14 seconds, needed for long tooltips.
99001>End_Object
99002>
99002>Use oEditContextMenu.pkg
Including file: oEditContextMenu.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\oEditContextMenu.pkg)
99002>>>Use cCJStandardMenuItemClasses.pkg
99002>>>
99002>>>Object oEditContextMenu is a cCJContextMenu
99004>>>    
99004>>>    Move Self to Default_Form_Floating_Menu_ID
99005>>>    
99005>>>    Object oUndoMenuItem is a cCJUndoMenuItem
99007>>>    End_Object
99008>>>    
99008>>>    Object oCutMenuItem is a cCJCutMenuItem
99010>>>        Set pbControlBeginGroup to True
99011>>>    End_Object
99012>>>    
99012>>>    Object oCopyMenuItem is a cCJCopyMenuItem
99014>>>    End_Object
99015>>>
99015>>>    Object oPasteMenuItem is a cCJPasteMenuItem
99017>>>    End_Object
99018>>>
99018>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
99020>>>    End_Object
99021>>>
99021>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
99023>>>        Set pbControlBeginGroup to True
99024>>>    End_Object
99025>>>
99025>>>End_Object
99026>>>
99026>Use oDEOEditContextMenu17.pkg
Including file: oDEOEditContextMenu17.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\oDEOEditContextMenu17.pkg)
99026>>>Use Windows.pkg
99026>>>Use cCJStandardMenuItemClasses.pkg
99026>>>Use cCJDeoMenuItemClasses.pkg
99026>>>
99026>>>
99026>>>Object oDEOEditContextMenu17 is a cCJContextMenu
99028>>>    
99028>>>    Move Self to Default_dbFloating_Menu_ID
99029>>>    
99029>>>    Object oUndoMenuItem is a cCJUndoMenuItem
99031>>>    End_Object
99032>>>    
99032>>>    Object oCutMenuItem is a cCJCutMenuItem
99034>>>        Set pbControlBeginGroup to True
99035>>>    End_Object
99036>>>    
99036>>>    Object oCopyMenuItem is a cCJCopyMenuItem
99038>>>    End_Object
99039>>>
99039>>>    Object oPasteMenuItem is a cCJPasteMenuItem
99041>>>    End_Object
99042>>>
99042>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
99044>>>    End_Object
99045>>>
99045>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
99047>>>        Set pbControlBeginGroup to True
99048>>>    End_Object
99049>>>
99049>>>    Object oPromptMenuItem is a cCJPromptMenuItem
99051>>>        Set pbControlBeginGroup to True
99052>>>    End_Object
99053>>>
99053>>>    Object oFindNextMenu is a cCJFindNextMenuItem
99055>>>        Set pbControlBeginGroup to True
99056>>>    End_Object
99057>>>
99057>>>    Object oFindPreviousMenu is a cCJFindPreviousMenuItem
99059>>>    End_Object
99060>>>
99060>>>    Object oClearMenuItem is a cCJClearMenuItem
99062>>>        Set pbControlBeginGroup to True
99063>>>    End_Object
99064>>>
99064>>>    Object oClearAllMenu is a cCJClearAllMenuItem
99066>>>    End_Object
99067>>>
99067>>>    Object oSaveMenu is a cCJSaveMenuItem
99069>>>    End_Object
99070>>>    
99070>>>    Object oDeleteMenu is a cCJDeleteMenuItem
99072>>>    End_Object
99073>>>
99073>>>    Object oRememberitem is a cCJRememberFieldMenuItem
99075>>>        Set pbControlBeginGroup to True
99076>>>    End_Object
99077>>>
99077>>>    Object oRetainItem is a cCJRememberLastFieldMenuItem
99079>>>    End_Object
99080>>>
99080>>>    Object oUnRememberitem is a cCJUnRememberFieldMenuItem
99082>>>    End_Object
99083>>>
99083>>>    Object oCJClearAllDynamicDefaults is a cCJUnRememberFieldAllMenuItem
99085>>>    End_Object
99086>>>
99086>>>End_Object
99087>Use CaptureWindow.pkg
Including file: CaptureWindow.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\CaptureWindow.pkg)
99087>>>Use CaptureWindow.h
Including file: CaptureWindow.h    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\CaptureWindow.h)
99087>>>>>Define C_CaptureFolderKey  for "CaptureFolder"
99087>>>>>Define C_CaptureFolderName for "Capture"
99087>>>>>Define SRCCOPY           for |CI$00CC0020
99087>>>>>Define CF_BITMAP         for |CI2
99087>>>>>
99087>>>>>Enum_List   //Enum DEVCAP_INDEX As Integer  
99087>>>>>   Define DRIVERVERSION for 0 
99087>>>>>   Define TECHNOLOGY for 2 
99087>>>>>   Define HORZSIZE for 4 
99087>>>>>   Define VERTSIZE for 6 
99087>>>>>   Define HORZRES for 8 
99087>>>>>   Define VERTRES for 10 
99087>>>>>   Define BITSPIXEL for 12 
99087>>>>>   Define PLANES for 14 
99087>>>>>   Define NUMBRUSHES for 16 
99087>>>>>   Define NUMPENS for 18 
99087>>>>>   Define NUMMARKERS for 20 
99087>>>>>   Define NUMFONTS for 22 
99087>>>>>   Define NUMCOLORS for 24 
99087>>>>>   Define PDEVICESIZE for 26 
99087>>>>>   Define CURVECAPS for 28 
99087>>>>>   Define LINECAPS for 30 
99087>>>>>   Define POLYGONALCAPS for 32 
99087>>>>>   Define TEXTCAPS for 34 
99087>>>>>   Define CLIPCAPS for 36 
99087>>>>>   Define RASTERCAPS for 38 
99087>>>>>   Define ASPECTX for 40 
99087>>>>>   Define ASPECTY for 42 
99087>>>>>   Define ASPECTXY for 44 
99087>>>>>   Define SHADEBLENDCAPS for 45 
99087>>>>>   Define SIZEPALETTE for 104 
99087>>>>>   Define NUMRESERVED for 106 
99087>>>>>   Define COLORRES for 108 
99087>>>>>   Define PHYSICALWIDTH for 110 
99087>>>>>   Define PHYSICALHEIGHT for 111 
99087>>>>>   Define PHYSICALOFFSETX for 112 
99087>>>>>   Define PHYSICALOFFSETY for 113 
99087>>>>>   Define SCALINGFACTORX for 114 
99087>>>>>   Define SCALINGFACTORY for 115 
99087>>>>>   Define VREFRESH for 116 
99087>>>>>   Define DESKTOPVERTRES for 117 
99087>>>>>   Define DESKTOPHORZRES for 118 
99087>>>>>   Define BLTALIGNMENT for 119 
99087>>>>>End_Enum_List  
99087>>>>>
99087>>>>>Enum_List   //Enum compression
99087>>>>>   Define bi_rgb for 0       //- none (also identified by bi_rgb)
99087>>>>>   Define bi_rle4 for 1      //- rle 8-bit / pixel (also identified by bi_rle4)
99087>>>>>   Define bi_rle8 for 2      //- rle 4-bit / pixel (also identified by bi_rle8)
99087>>>>>   Define bi_bitfields for 3 //- bitfields (also identified by bi_bitfields)
99087>>>>>End_Enum_List  
99087>>>>>
99087>>>>>
99087>>>>>
99087>>>>>Define DIB_PAL_COLORS for 1
99087>>>>>Define DIB_RGB_COLORS for 0
99087>>>>>
99087>>>>>Struct RECT_TYPE
99087>>>>>   Integer ileft
99087>>>>>   Integer itop
99087>>>>>   Integer iright
99087>>>>>   Integer ibottom
99087>>>>>End_Struct
99087>>>>>
99087>>>>>Struct BITMAPINFOHEADER
99087>>>>>  DWORD biSize                    // DWORD=integer
99087>>>>>  Integer biWidth                    // LONG =integer
99087>>>>>  Integer biHeight                   // LONG 
99087>>>>>  short biPlanes                   // WORD =short
99087>>>>>  short biBitCount                 // WORD 
99087>>>>>  DWORD biCompression             // DWORD
99087>>>>>  DWORD biSizeImage               // DWORD
99087>>>>>  Integer biXPelsPerMeter            // LONG 
99087>>>>>  Integer biYPelsPerMeter            // LONG 
99087>>>>>  DWORD biClrUsed                 // DWORD
99087>>>>>  DWORD biClrImportant            // DWORD
99087>>>>>end_struct
99087>>>>>
99087>>>>>struct RGBQUAD
99087>>>>>  CHAR rgbBlue            //BYTE=CHAR
99087>>>>>  CHAR rgbGreen
99087>>>>>  CHAR rgbRed
99087>>>>>  CHAR rgbReserved
99087>>>>>end_struct
99087>>>>>
99087>>>>>struct BITMAPINFO 
99087>>>>>  BITMAPINFOHEADER bmiHeader 
99087>>>>>  BITMAPINFOHEADER bmiHeader 
99087>>>>>  RGBQUAD[] bmiColors
99087>>>>>  RGBQUAD[] bmiColors
99087>>>>>end_struct
99087>>>>>
99087>>>>>struct BITMAPFILEHEADER
99087>>>>>  Short bfType         //WORD  //BM (0x4D42)
99087>>>>>  DWord bfSize        //DWORD
99087>>>>>  Short bfReserved1    //WORD 
99087>>>>>  Short bfReserved2    //WORD 
99087>>>>>  DWord bfOffBits     //DWORD
99087>>>>>end_struct
99087>>>>>
99087>>>>>Struct BITMAP 
99087>>>>>  Integer   bmType
99087>>>>>  Integer   bmWidth
99087>>>>>  Integer   bmHeight
99087>>>>>  Integer   bmWidthBytes
99087>>>>>  Short   bmPlanes
99087>>>>>  Short   bmBitsPixel
99087>>>>>  Pointer bmBits
99087>>>>>end_struct
99087>>>>>
99087>>>>>Struct DIBSECTION 
99087>>>>>  BITMAP           dsBm
99087>>>>>  BITMAP           dsBm
99087>>>>>  BITMAPINFOHEADER dsBmih
99087>>>>>  BITMAPINFOHEADER dsBmih
99087>>>>>  DWord[3]         dsBitfields
99087>>>>>  Handle           dshSection
99087>>>>>  DWord            dsOffset
99087>>>>>end_struct
99087>>>Use vWin32fh.pkg
99087>>>Use cApplication.pkg
99087>>>Use cIniFile.pkg
99087>>>
99087>>>Define CS_CaptureSection for "Capture"
99087>>>Define CS_CaptureFolder  for "Capture Folder"
99087>>>
99087>>>//   Declare Function GetActiveWindow% Lib "User" ()
99087>>>External_Function GetActiveWindow "GetActiveWindow" User32.dll ;    Returns Handle
99088>>>
99088>>>//   Declare Function GetDesktopWindow% Lib "User" ()
99088>>>
99088>>>//   Declare Sub GetWindowRect Lib "User" (ByVal Hwnd%, lpRect As RECT_Type)
99088>>>
99088>>>//   Declare Function GetDC% Lib "User" (ByVal Hwnd%)
99088>>>
99088>>>//   Declare Function CreateCompatibleDC% Lib "GDI" (ByVal hdc%)
99088>>>
99088>>>//   Declare Function CreateCompatibleBitmap% Lib "GDI" (ByVal hdc%, ByVal nWidth%, ByVal nHeight%)
99088>>>External_Function CreateCompatibleBitmap "CreateCompatibleBitmap" gdi32.dll ;    Handle hDC ;    Integer nWidth ;    Integer nHeight ;    Returns Handle
99089>>>
99089>>>//   Declare Function SelectObject% Lib "GDI" (ByVal hdc%, ByVal hObject%)
99089>>>
99089>>>//   Declare Function BitBlt% Lib "GDI" (ByVal hDestDC%, ByVal X%, ByVal Y%, ByVal nWidth%, ;
99089>>>//                     ByVal nHeight%, ByVal hSrcDC%, ByVal XSrc%, ByVal YSrc%, ByVal dwRop&)
99089>>>External_Function BitBlt "BitBlt" gdi32.dll ;    Handle hdcDest ;    Integer nXDest ;    Integer nYDest ;    Integer nWidth ;    Integer nHeight ;    Handle hdcSrc ;    Integer nXSrc ;    Integer nYSrc ;    Integer dwRop ;    Returns Boolean
99090>>>
99090>>>//   Declare Function OpenClipboard% Lib "User" (ByVal Hwnd%)
99090>>>External_Function OpenClipboard "OpenClipboard" User32.dll  ;    Handle hWnd  Returns Integer
99091>>>
99091>>>//   Declare Function EmptyClipboard% Lib "User" ()
99091>>>External_Function EmptyClipboard "EmptyClipboard" User32.dll ;    Returns Integer
99092>>>
99092>>>//   Declare Function SetClipboardData% Lib "User" (ByVal wFormat%, ByVal hMem%)
99092>>>External_Function SetClipboardData "SetClipboardData" User32.dll ;    Integer wFormat Handle hMem Returns Integer
99093>>>
99093>>>//   Declare Function CloseClipboard% Lib "User" ()
99093>>>External_Function CloseClipboard "CloseClipboard" User32.dll ;    Returns Integer
99094>>>
99094>>>//   Declare Function ReleaseDC% Lib "User" (ByVal Hwnd%, ByVal hdc%)
99094>>>
99094>>>//   Declare Function DeleteDC% Lib "GDI" (ByVal hdc%)
99094>>>
99094>>>    External_Function CreateDIBSection "CreateDIBSection" Gdi32.dll ;        Handle hdc ;     // Handle to the device context        pointer pbmi ; //puntero a BITMAPINFO        UInteger iUsage ;        Pointer ppvBits ;        Handle hSection ;        DWord dwOffset ;        Returns Handle // HBITMAP
99095>>>
99095>>>    External_Function GetDIBits "GetDIBits" Gdi32.dll ;        handle hdc ;        handle hbmp ;        Uinteger uStartScan ;        uinteger cScanLines ;        pointer lpvBits ;        pointer lpbi ;  // LPBITMAPINFO        uinteger uUsage ;        Returns Integer
99096>>>
99096>>>External_Function Createfile "CreateFileA" kernel32.dll ;    Pointer lpFile ;      //filename    DWord dwDesAccess ;   // access mode    DWord dwShare ;       // share mode    Pointer lpSecAtt ;    // SD    DWord dwCrDisp ;      // how to create    DWord dwFlags ;       // file attributes    Handle hTempFile ;   // handle to template fil    Returns Integer      //Returns handle that can be used to access the object
99097>>>
99097>>>    External_Function WriteFile "WriteFile" Kernel32.dll ;        Handle hFile ;     // Handle to the file        Pointer lpBuffer ;  // data buffer        DWord nNumberOfBytesToWrite ;        Pointer lpNumberOfBytesWritten ;        Pointer lpOverlapped ;        Returns Boolean
99098>>>
99098>>>External_Function CloseHandle "CloseHandle" kernel32.dll ;    Handle hObject ;        // handle to object    Returns Integer
99099>>>
99099>>>
99099>>>     External_Function GetDIBColorTable "GetDIBColorTable" Gdi32.dll ;        handle hdc ;        uinteger uStartIndex ;        uinteger cEntries ;        pointer pColors ;        Returns Integer
99100>>>
99100>>>     External_Function GetObject "GetObjectA" Gdi32.dll ;        handle hgdiobj ;        integer cbBuffer ;        pointer lpvObject ;        Returns Integer
99101>>>
99101>>>
99101>>>// Check if focus is what you search or a child of it
99101>>>Function Find_Parent Global Handle hofocus Handle hofind Returns Boolean
99103>>>    If (hoFocus = hoFind) Begin
99105>>>        Function_Return True
99106>>>    End
99106>>>>
99106>>>   While (hofocus>Desktop)
99110>>>        If (Parent(hoFocus) = hoFind) Begin
99112>>>            Function_Return True
99113>>>        End
99113>>>>
99113>>>      Move (Parent(hofocus)) to hofocus
99114>>>   Loop
99115>>>>
99115>>>   Function_Return False
99116>>>End_Function
99117>>>
99117>>>// Returns the view object (outmost container) of the currently focused object.
99117>>>Function Current_View Global Returns Integer
99119>>>    Integer Obj#
99119>>>
99119>>>    Move (Focus(Self)) to Obj#
99120>>>    Repeat
99120>>>>
99120>>>        Move (Parent(Obj#)) to Obj#
99121>>>    Until (Scope_State(Obj#) = True)
99123>>>
99123>>>    Function_Return Obj#
99124>>>End_Function
99125>>>
99125>>>// Helper function. See also main message TakeSnapshot.
99125>>>// Capture an bitmap image of the current object and saves it to disk.
99125>>>Function CaptureImage Global Handle hVent String sFile Returns Integer
99127>>>    Handle hwnd deskhwnd hfile hnulo
99127>>>    Handle hdcScreen
99127>>>    Handle hdcWindow
99127>>>    Handle hdcMemDC
99127>>>    Handle hbmScreen
99127>>>    BITMAP bmpScreen
99127>>>    BITMAP bmpScreen
99127>>>    BITMAPFILEHEADER   bmfHeader
99127>>>    BITMAPFILEHEADER   bmfHeader
99127>>>    BITMAPINFOHEADER   bi
99127>>>    BITMAPINFOHEADER   bi
99127>>>    RECT_Type rcClient
99127>>>    RECT_Type rcClient
99127>>>    Integer junk fwidth fheight iret
99127>>>    DWord dwSizeofDIB dwBytesWritten dwBmpSize
99127>>>    Boolean baux
99127>>>    Pointer lpbitmap pnulo
99127>>>
99127>>>    //---------------------------------------------------
99127>>>    // Get window handle to Windows and our View
99127>>>    //---------------------------------------------------
99127>>>    Move (GetDesktopWindow()) to DeskHwnd
99128>>>    Get Window_Handle of hVent to hwnd
99129>>>
99129>>>    // Retrieve the handle to a display device context for the client
99129>>>    // area of the window.
99129>>>    Move (GetDC(hwnd)) to hdcScreen //what you want to paint (getdc(null)=full screen)
99130>>>    Move (GetDC(deskhwnd)) to hdcWindow //context = GetDC(hWnd);
99131>>>
99131>>>    // Create a compatible DC which is used in a BitBlt from the window DC
99131>>>    Move (CreateCompatibleDC(hdcWindow)) to hdcMemDC
99132>>>    Move 0 to iret
99133>>>    If (hdcMemDC) Begin
99135>>>       // Get the client area for size calculation
99135>>>       Move (GetWindowRect(hwnd,AddressOf(rcClient))) to junk
99136>>>       Move (rcClient.iright-rcClient.ileft) to fwidth
99137>>>       Move (rcClient.ibottom-rcClient.itop) to fheight
99138>>>
99138>>>       // Create a compatible bitmap from the Window DC
99138>>>       Move (CreateCompatibleBitmap(hdcWindow, fwidth, fheight)) to hbmScreen
99139>>>
99139>>>       If hbmScreen Begin
99141>>>          // Select the compatible bitmap into the compatible memory DC.
99141>>>          Move (SelectObject(hdcMemDC,hbmScreen)) to junk
99142>>>
99142>>>          // Bit block transfer into our compatible memory DC.
99142>>>          If (BitBlt(hdcMemDC,0,0, fwidth, fheight,hdcWindow, rcClient.ileft,rcClient.itop,SRCCOPY)) Begin
99144>>>             // Get the BITMAP from the HBITMAP
99144>>>             Move (GetObject(hbmScreen,SizeOfType(BITMAP),AddressOf(bmpScreen))) to junk
99145>>>             Move (SizeOfType(BITMAPINFOHEADER)) to bi.biSize
99146>>>             Move bmpScreen.bmWidth to bi.biWidth
99147>>>             Move bmpScreen.bmHeight to bi.biHeight
99148>>>             Move 1 to bi.biPlanes
99149>>>             Move 32 to bi.biBitCount
99150>>>             Move bi_rgb to bi.biCompression
99151>>>             Move 0 to bi.biSizeImage
99152>>>             Move 0 to bi.biXPelsPerMeter
99153>>>             Move 0 to bi.biYPelsPerMeter
99154>>>             Move 0 to bi.biClrUsed
99155>>>             Move 0 to bi.biClrImportant
99156>>>
99156>>>             Move (((bmpScreen.bmWidth * bi.biBitCount + 31) / 32) * 4 * bmpScreen.bmHeight ) to dwBmpSize
99157>>>             Move (Alloc(dwBmpSize+100)) to lpbitmap
99158>>>
99158>>>             // Gets the "bits" from the bitmap and copies them into a buffer
99158>>>             // which is pointed to by lpbitmap.
99158>>>             Move (GetDIBits(hdcWindow, hbmScreen, 0,bmpScreen.bmHeight, ;                 lpbitmap,AddressOf(bi), DIB_RGB_COLORS) ) to junk
99159>>>
99159>>>             // A file is created, this is where we will save the screen capture.
99159>>>             Move (CreateFile(AddressOf(sFile),GENERIC_WRITE, 0, ;                 hnulo,CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL, hnulo)) to hfile
99160>>>
99160>>>             // Add the size of the headers to the size of the bitmap to get the total file size
99160>>>             Move (dwBmpSize + SizeOfType(BITMAPFILEHEADER) + SizeOfType(BITMAPINFOHEADER)) to dwSizeofDIB
99161>>>
99161>>>             // Offset to where the actual bitmap bits start.
99161>>>             Move (SizeOfType(BITMAPFILEHEADER) + SizeOfType(BITMAPINFOHEADER)) to bmfHeader.bfOffBits
99162>>>
99162>>>             // Size of the file
99162>>>             Move dwSizeofDIB to bmfHeader.bfSize
99163>>>
99163>>>             // bfType must always be BM for Bitmaps
99163>>>             Move 19778 to bmfHeader.bfType //= 0x4D42; //BM   19778
99164>>>
99164>>>             Move 0 to dwBytesWritten
99165>>>             Move (WriteFile(hFile, AddressOf(bmfHeader), SizeOfType(BITMAPFILEHEADER), AddressOf(dwBytesWritten), pnulo)) to baux
99166>>>             Move (WriteFile(hFile, AddressOf(bi), SizeOfType(BITMAPINFOHEADER), AddressOf(dwBytesWritten), pnulo)) to baux
99167>>>             Move (WriteFile(hFile, lpbitmap, dwBmpSize, AddressOf(dwBytesWritten), pnulo))  to baux
99168>>>
99168>>>             //Close the handle for the file that was created
99168>>>             Move (CloseHandle(hFile)) to junk
99169>>>
99169>>>             // Write image from clipboard
99169>>>             Move (OpenClipboard(DeskHwnd)) to junk
99170>>>             Move (EmptyClipboard()) to junk
99171>>>             Move (SetClipboardData(CF_BITMAP,hbmScreen)) to junk
99172>>>             Move (CloseClipboard()) to junk
99173>>>
99173>>>             Move (DeleteObject(hbmScreen)) to baux
99174>>>             Move (Free(lpbitmap)) to baux
99175>>>             Move 1 to iret
99176>>>          End
99176>>>>
99176>>>       End
99176>>>>
99176>>>    End
99176>>>>
99176>>>    Move (ReleaseDC(hWnd, hdcMemDC)) to junk
99177>>>    Move (ReleaseDC(hwnd,hdcScreen)) to junk
99178>>>    Move (ReleaseDC(deskhwnd,hdcWindow)) to junk
99179>>>
99179>>>    Function_Return iret
99180>>>End_Function
99181>>>
99181>>>// *** MAIN MESSAGE ***
99181>>>// Takes a snapshot of the currently active view and saves it as a bitmap file,
99181>>>// in the current workspace's Capture folder. If that folder doesn't exist,
99181>>>// it will be created.
99181>>>// Pass False to take snapshot of the currently active view, or pass True
99181>>>// to take snapshot of the entire application.
99181>>>Procedure TakeSnapshot Global Boolean bApplicationShot
99183>>>    Integer iRetval
99183>>>    String sPath sToday sFileName
99183>>>    Handle hObjTo
99183>>>
99183>>>    Sysdate sToday
99184>>>    Move (Replace("/", sToday, "-")) to sToday
99185>>>
99185>>>    // Select the view to capture
99185>>>    If (bApplicationShot = False) Begin
99187>>>        Get Current_View to hObjTo
99188>>>    End
99188>>>>
99188>>>    Else Begin
99189>>>        Move (Parent(ghoCommandBars)) to hObjTo
99190>>>    End
99190>>>>
99190>>>
99190>>>    Get SnapShotFolder to sPath
99191>>>    Get vFolderFormat sPath to sPath
99192>>>
99192>>>    Move (sPath + (Object_Label(hObjTo)) + sToday + ".bmp") to sFileName
99193>>>    Get CaptureImage hObjTo sFileName to iRetval
99194>>>    If (iRetval <> 0) Begin
99196>>>//        Send Info_Box ("The snapshot image was saved here:\n" + sPath)
99196>>>        Move ("/select, " + sFileName) to sFileName
99197>>>        Send vShellExecute "open" "explorer.exe" sFileName ""
99198>>>//        Runprogram Shell Background sFileName
99198>>>    End
99198>>>>
99198>>>End_Procedure
99199>>>
99199>>>// Function to get the folder where snapshots are saved.
99199>>>// The pathing is read from the esqtid.ini file.
99199>>>// Returns the full folder path. If the folder doesn't exist
99199>>>// it will be created.
99199>>>// Returns: The full snapshot folder path.
99199>>>Function SnapShotFolder Global Returns String
99201>>>    String sHome sPath sWorkSpaceFile
99201>>>    Boolean bExist
99201>>>    Integer iRetval
99201>>>    Handle hoIniFile
99201>>>
99201>>>    Get psWorkspaceWSFile of (phoWorkspace(ghoApplication)) to sWorkSpaceFile
99202>>>    Get psHome of (phoWorkspace(ghoApplication)) to sHome
99203>>>    Get vFolderFormat sHome to sHome
99204>>>
99204>>>    Get Create (RefClass(cIniFile)) to hoIniFile
99205>>>    Set psFileName of hoIniFile to sWorkSpaceFile
99206>>>    Get ReadString of hoIniFile CS_CaptureSection CS_CaptureFolder CS_CaptureSection to sPath
99207>>>    Send Destroy of hoIniFile
99208>>>
99208>>>    If (Pos("..\", sPath)) Begin
99210>>>        Move (Replace("..\", sPath, "")) to sPath
99211>>>        Move (sHome + sPath) to sPath
99212>>>    End
99212>>>>
99212>>>    Else If (Pos(".\", sPath)) Begin
99215>>>        Move (Replace(".\", sPath, "")) to sPath
99216>>>        Move (sHome + sPath) to sPath
99217>>>    End
99217>>>>
99217>>>    Else Begin
99218>>>        Move (sHome + sPath) to sPath
99219>>>    End
99219>>>>
99219>>>
99219>>>    Get vFolderExists sPath to bExist
99220>>>    If (bExist = False) Begin
99222>>>        If (sPath = "") Begin
99224>>>            Get vSHGetFolderPath vCSIDL_MYPICTURES to sPath  // E.g. "C:\Documents and Settings\username\My Documents\My Pictures"
99225>>>        End
99225>>>>
99225>>>        Else Begin
99226>>>            Get vCreateDirectory sPath to iRetval
99227>>>            If (iRetval <> 0) Begin
99229>>>                Send Info_Box ("Could not create the 'Capture' folder for saving shapshots to." * sPath)
99230>>>                Function_Return ""
99231>>>            End
99231>>>>
99231>>>        End
99231>>>>
99231>>>    End
99231>>>>
99231>>>
99231>>>    Function_Return sPath
99232>>>End_Function
99233>
99233>Object oMain is a Panel
99235>    Set Label to (psProduct(ghoApplication))
99236>    Set Location to 4 3
99237>    Set Size to 350 602
99238>    Set piMinSize to 400 515
99239>    Set Icon to "DUFUpdateCodeGenerator1.ico"
99240>
99240>    Object oCommandBarSystem is a cCJCommandBarSystem
99242>        Set pbTimerUpdate to True
99243>            Set pbAutoResizeIcons to True
99244>            Set pbTabbedWorkspaces to True
99245>//            Set pbLargeIcons to True
99245>            Set peVisualTheme to xtpThemeOffice2013Publisher
99246>        Set pbLargeIcons to True
99247>
99247>        Procedure OnCreateCommandBars
99250>            Integer eTheme
99250>            Forward Send OnCreateCommandBars
99252>
99252>            Get ReadDword of ghoApplication CS_PropertiesKeyWord CS_ThemeKeyWord xtpThemeOffice2013Publisher to eTheme
99253>            Send SetTheTheme eTheme
99254>            Send DisplayTabWorkspace
99255>        End_Procedure
99256>
99256>        Procedure DisplayTabWorkspace
99259>            Variant vTab vPaintManager
99259>            Handle hoTab hoPaintManager hoOptions
99259>            Integer iSize
99259>
99259>            If (not(IsComObjectCreated(Self))) Begin
99261>                Procedure_Return
99262>            End
99262>
99262>            Get OptionsObject to hoOptions
99263>
99263>            // Create the tab workspace object. It will get created for the Client_Area so
99263>            // each view will be displayd on a separate tab-page (instead of the standard VDF MDI-interface)
99263>            Get Create (RefClass(cCJTabWorkspace)) to hoTab
99264>            Get ComShowTabWorkspace True to vTab
99265>            // Connect the CodeJock side to the DataFlex proxy object.
99265>            Set pvComObject  of hoTab to vTab
99266>
99266>            // We don't allow to close tabs as we have no menu system.
99266>            Set ComFlags of hoTab to xtpWorkspaceHideAll //xtpWorkspaceHideClose //xtpWorkspaceShowCloseTab
99267>            Send ComEnableGroups of hoTab
99268>
99268>            // Create a paint manager object that is needed to set some
99268>            // of the tab-workspace properties.
99268>            Get Create (RefClass(cCJTabPaintManager)) to hoPaintManager
99269>            Get ComPaintManager of hoTab          to vPaintManager
99270>            Set pvComObject     of hoPaintManager to vPaintManager
99271>
99271>            // Sets the tab-pages to display on the left side, instead of at the top:
99271>            Set ComPosition     of hoPaintManager to xtpTabPositionLeft
99272>
99272>            // This will truncate the middle part of long items
99272>            Set ComDrawTextPathEllipsis of hoPaintManager to True
99273>            Set ComLayout               of hoPaintManager to xtpTabLayoutMultiRow
99274>
99274>//            #IF (!@ < 190)
99274>                Move 32 to iSize
99275>                Send ComSetIconSize     of hoOptions False iSize iSize  // Set icon size for Toolbar buttons.
99276>//                Move 24 to iSize
99276>//                Send ComSetIconSize     of hoPaintManager  iSize iSize  // Set icon size for Tab-workspace.
99276>//            #ENDIF
99276>            Get Create (RefClass(cCJPaintManager)) to hoPaintManager
99277>            Get ComPaintManager of hoPaintManager  to vPaintManager
99278>            Set pvComObject     of hoPaintManager  to vPaintManager
99279>            Set ComAutoResizeIcons of hoPaintManager to True
99280>            Send Destroy of hoPaintManager
99281>            Send ComRecalcLayout
99282>            Send Destroy of hoTab
99283>        End_Procedure
99284>
99284>        Procedure OnCreateTabbedWorkspace Handle hoTabWorkspace Handle hoTabPaintManager
99287>//            Set ComShowIcons of hoTabPaintManager to True
99287>//            Send ComSetIconSize of hoTabPaintManager 24 24
99287>
99287>            // This will truncate the middle part of long text items
99287>            Set ComDrawTextPathEllipsis of hoTabPaintManager to True
99288>            Set ComFlags of hoTabWorkspace to xtpWorkspaceHideAll //xtpWorkspaceHideClose //xtpWorkspaceShowCloseTab
99289>        End_Procedure
99290>
99290>        Procedure SetTheTheme Integer eTheme
99293>            Integer iColor
99293>            Set peVisualTheme of ghoCommandBars to eTheme
99294>            Send ComRecalcLayout of ghoCommandBars
99295>            Get ComGetSpecialColor of ghoCommandBars XPCOLOR_TOOLBAR_FACE to iColor
99296>            Broadcast Recursive Set Color of (Client_Id(phoMainPanel(ghoApplication))) to iColor
99298>        End_Procedure
99299>
99299>        Object oActions_Toolbar is a cCJToolbar
99301>            Set pbCloseable to False
99302>            Set pbCustomizable to False
99303>            Set pbShowExpandButton to False
99304>            Set psTitle to "Actions"
99305>
99305>            Object oCodeGenerator_MenuItem is a cCJMenuItem
99307>                Set psCaption to "Code &Generator"
99308>                Set psImage to "SqlScript1.ico"
99309>                Set peControlStyle to xtpButtonIconAndCaption
99310>                Procedure OnExecute Variant vCommandBarControl
99313>                    Forward Send OnExecute vCommandBarControl
99315>                    Set pbChecked to True
99316>                    Set pbChecked of (oCompareDatabases_MenuItem(ghoCommandBars)) to False
99317>                    Send Activate_oTableDUFCodeGenerator of (Client_Id(phoMainPanel(ghoApplication)))
99318>                End_Procedure
99319>            End_Object
99320>
99320>            Object oCompareDatabases_MenuItem is a cCJMenuItem
99322>                Set psCaption to "Compare &Databases"
99323>                Set psImage to "DbCompare1.ico"
99324>                Set peControlStyle to xtpButtonIconAndCaption
99325>                Set pbChecked to True
99326>
99326>                Procedure OnExecute Variant vCommandBarControl  
99329>                    Forward Send OnExecute vCommandBarControl
99331>                    Set pbChecked to True
99332>                    Set pbChecked of (oCodeGenerator_MenuItem(ghoCommandBars)) to False
99333>                    Send Activate_oCompareDatabases_vw of (Client_Id(phoMainPanel(ghoApplication)))
99334>                End_Procedure
99335>            End_Object
99336>
99336>        End_Object
99337>
99337>        // This is needed to get the "Key_Shift+Key_Tab" key combination to activate
99337>        // the previous tab workspace view.
99337>
99337>        Object oEditToolBar is a cCJToolbar
99339>            Set psTitle to "Edit Toolbar"
99340>            Set pbCloseable to False
99341>            Set pbCustomizable to False
99342>            Set pbShowExpandButton to False
99343>
99343>            Object oCutToolbarItem is a cCJCutMenuItem
99345>                Set psImage to "ActionCut1.ico"
99346>            End_Object
99347>
99347>            Object oCopyToolbarItem is a cCJCopyMenuItem
99349>                Set psImage to "ActionCopy1.ico"
99350>
99350>            End_Object
99351>
99351>            Object oPasteToolbarItem is a cCJPasteMenuItem
99353>                Set psImage to "ActionPaste1.ico"
99354>            End_Object
99355>
99355>//            Object oDeleteEditToolbarItem is a cCJDeleteEditMenuItem
99355>//                Set psImage to "ActionDelete1.ico"
99355>//                Set pbControlBeginGroup to True
99355>//            End_Object
99355>
99355>            Object oPromptToolItem is a cCJPromptMenuItem
99357>                Set psImage to "ActionPrompt1.ico"
99358>                Set pbControlBeginGroup to True
99359>            End_Object
99360>
99360>            Object oClearToolItem is a cCJClearMenuItem
99362>                Set peControlStyle to xtpButtonIconAndCaption
99363>                Set psCaption      to "Clear/Add"
99364>                Set pbControlBeginGroup to True
99365>                Set psImage to "ActionClear1.ico"  
99366>                
99366>                Function IsEnabled Returns Boolean
99369>                    Function_Return True
99370>                End_Function
99371>
99371>            End_Object
99372>
99372>            Object oOpenContainingFolder_MenuItem is a cCJMenuItem
99374>                Set psImage to "ActionOpenContainingFolder1.ico"
99375>                Set psCaption to "Containing Folder"
99376>                Set psToolTip to "Open containing folder"
99377>                Set psDescription to "Open Containing Folder"
99378>                Set pbActiveUpdate to True
99379>                Set pbControlBeginGroup to True
99380>
99380>                Procedure OnExecute Variant vCommandBarControl
99383>                    String sPath sFile       
99383>                    Boolean bExists
99383>
99383>                    Forward Send OnExecute vCommandBarControl
99385>                    Get psFilelistFrom of ghoApplication to sFile
99386>                    Get ParseFolderName sFile to sPath
99387>                    Get vFilePathExists sFile to bExists
99388>                    // We want to have that file to be selected in Windows Explorer;
99388>                    If (bExists = True) Begin
99390>                        Move ("/select, " + sFile) to sPath
99391>                    End
99391>                    Send vShellExecute "open" "explorer.exe" sPath ""
99392>                End_Procedure
99393>
99393>                Function IsEnabled Returns Boolean
99396>                    String sFile
99396>                    Boolean bExists
99396>                    Get psFilelistFrom of ghoApplication to sFile
99397>                    Get vFilePathExists sFile to bExists
99398>                    Function_Return (bExists = True)
99399>                End_Function
99400>
99400>            End_Object
99401>
99401>            Object oCompareToolItem is a cCJMenuItem
99403>//                Set peControlStyle to xtpButtonIconAndCaption
99403>//                Set psCaption to "&Connection" 
99403>                Set psToolTip to "Show SQL Settings dialog"
99404>                Set psImage to "SQLSettings1.ico"
99405>                Set piShortCutKey to xtpKey_Alt VK_S
99406>                Set pbControlBeginGroup to True
99407>                Set pbActiveUpdate to True
99408>
99408>                Procedure OnExecute Variant vCommandBarControl
99411>                    tSQLConnection Connection
99411>                    tSQLConnection Connection
99411>                    String sFileListFrom sCurrentFilelist
99411>                    Handle hoFocus
99411>                    Boolean bExists bOK
99411>
99411>                    Move (Focus(Desktop)) to hoFocus
99412>                    Forward Send OnExecute vCommandBarControl
99414>
99414>                    // First change the "current" filelist depending on which
99414>                    // Filelist form is active.
99414>                    Get Value of hoFocus to sCurrentFilelist
99415>                    Get vFilePathExists sCurrentFilelist to bExists
99416>                    Get psFilelistFrom of ghoApplication to sFileListFrom
99417>                    If (sFileListFrom = "") Begin
99419>                        Procedure_Return
99420>                    End
99420>                    If (bExists = True and sCurrentFilelist <> "") Begin
99422>                        Get ChangeFilelistPathing of ghoApplication sCurrentFilelist to bOK
99423>                        Get psFilelistFrom of ghoApplication to sFileListFrom
99424>                    End
99424>
99424>                    If (sFileListFrom <> "") Begin
99426>                        Get pSQLConnection of ghoSQLConnectionHandler to Connection
99427>                    End
99427>
99427>                    Send Activate_ReadOnlySQLMaintainConnections_dg of (Client_Id(ghoCommandBars)) Connection
99428>                End_Procedure  
99429>                
99429>                Function IsEnabled Returns Boolean
99432>                    tSQLConnection Connection
99432>                    tSQLConnection Connection
99432>                    Get pSQLConnection of ghoSQLConnectionHandler to Connection
99433>                    Function_Return (Connection.sDriverID <> DATAFLEX_ID and Connection.sDriverID <> "")
99434>                End_Function
99435>
99435>            End_Object
99436>
99436>            Object oAddToStudio_MenuItem is a cCJMenuItem
99438>                Set psCaption to "Add to Studio"
99439>                Set psDescription to "Add to Studio"
99440>                Set psToolTip to "Add this tool to the DataFlex Studio's 'Tools' menu"
99441>                Set psImage to "ActionAddStudio1.ico"
99442>                Set pbControlBeginGroup to True   
99443>                
99443>                Procedure OnExecute Variant vCommandBarControl
99446>                    Forward Send OnExecute vCommandBarControl
99448>                    Send Popup of (oAddToStudio_dg(Client_Id(phoMainPanel(ghoApplication))))
99449>                End_Procedure
99450>                
99450>            End_Object
99451>
99451>//            Object oCaptureViewMenuItem is a cCJMenuItem
99451>//                Set psCaption to "E&ditor Settings"
99451>//                Set psToolTip to "Editor"
99451>//                Set psDescription to "Editor Settings (Alt+D)"
99451>//
99451>//                Set psCaption to "Take shapshot"
99451>//                Set psToolTip to "Take shapshot"
99451>//                Set psDescription to "Take a snapshot image of the current view/panel. (F10)"
99451>//                Set psImage to "Camera1.ico"
99451>//                
99451>//                Procedure OnExecute Variant vCommandBarControl
99451>//                    Send TakeSnapshot False
99451>//                End_Procedure
99451>//
99451>//                Function IsEnabled Returns Boolean
99451>//                    Function_Return
99451>//                End_Function   
99451>//            End_Object
99451>
99451>//            #IF (!@ > 182)
99451>//
99451>//            Use DatabaseSelection.pkg
99451>//    
99451>//            Object oThemeItem is a cCJMenuItem
99451>//                Set peControlType to xtpControlComboBox
99451>//                Set psToolTip to "Theme"
99451>//                Set psCaption to "Theme:"
99451>//                Set psDescription to "Select a theme from the drop down list"
99451>//                Set pbControlBeginGroup to True
99451>//                Set pbVisible to False
99451>//
99451>//                Procedure OnCreateControl Handle hoObj
99451>//                    Integer iItem eTheme
99451>//                    Set ComWidth of hoObj to 250
99451>//                    Send FillComboList hoObj
99451>//                    Get peVisualTheme to eTheme
99451>//                    Get FindDataItem hoObj eTheme to iItem
99451>//                    Set ComListIndex of hoObj to (If(iItem, iItem, 1))
99451>//                End_Procedure
99451>//
99451>//                Function FindDataItem Handle hoCombo Integer eVal Returns Integer
99451>//                    Integer iCount i eTheme
99451>//                    Get ComListCount of hoCombo to iCount
99451>//                    For i from 1 to iCount
99451>//                        Get ComItemData of hoCombo i to eTheme
99451>//                        If (eTheme = eVal) Begin
99451>//                            Send SetTheTheme eTheme
99451>//                            Function_Return i
99451>//                        End
99451>//                    Loop
99451>//                    Function_Return 0
99451>//                End_Function
99451>//
99451>//                Procedure AddTheme Handle hoCombo String sText Integer eTheme
99451>//                    Integer iCount
99451>//                    Get ComListCount of hoCombo to iCount
99451>//                    Increment iCount
99451>//                    Send ComAddItem  of hoCombo sText iCount
99451>//                    Set ComItemData  of hoCombo iCount to  eTheme
99451>//                End_Procedure
99451>//
99451>//                Procedure FillComboList Handle hoCombo
99451>//                    Send ComClear     of hoCombo
99451>//
99451>//                    #IF (!@ > 190)
99451>//                    Send AddTheme hoCombo "xtpThemeOffice2016Access" xtpThemeOffice2016Access
99451>//                    Send AddTheme hoCombo "xtpThemeOffice2016Excel" xtpThemeOffice2016Excel
99451>//                    Send AddTheme hoCombo "xtpThemeOffice2016OneNote" xtpThemeOffice2016OneNote
99451>//                    Send AddTheme hoCombo "xtpThemeOffice2016Outlook" xtpThemeOffice2016Outlook
99451>//                    Send AddTheme hoCombo "xtpThemeOffice2016PowerPoint" xtpThemeOffice2016PowerPoint
99451>//                    Send AddTheme hoCombo "xtpThemeOffice2016Publisher" xtpThemeOffice2016OneNote
99451>//                    Send AddTheme hoCombo "xtpThemeOffice2016Word" xtpThemeOffice2016Word
99451>//                    #ENDIF
99451>//
99451>//                    Send AddTheme hoCombo "xtpThemeOffice2013Word" xtpThemeOffice2013Word
99451>//                    Send AddTheme hoCombo "xtpThemeOffice2013Outlook" xtpThemeOffice2013Outlook
99451>//                    Send AddTheme hoCombo "xtpThemeOffice2013Excel" xtpThemeOffice2013Excel
99451>//                    Send AddTheme hoCombo "xtpThemeOffice2013PowerPoint" xtpThemeOffice2013PowerPoint
99451>//                    Send AddTheme hoCombo "xtpThemeOffice2013Publisher" xtpThemeOffice2013Publisher
99451>//                    Send AddTheme hoCombo "xtpThemeOffice2013OneNote" xtpThemeOffice2013OneNote
99451>//                    Send AddTheme hoCombo "xtpThemeOffice2013Access" xtpThemeOffice2013Access
99451>//                    Send AddTheme hoCombo "xtpThemeOffice2003" xtpThemeOffice2003
99451>//                    Send AddTheme hoCombo "xtpThemeOffice2000" xtpThemeOffice2000
99451>//                    Send AddTheme hoCombo "xtpThemeOfficeXP" xtpThemeOfficeXP
99451>//
99451>//                    Send AddTheme hoCombo "xtpThemeOffice2010Blue" xtpThemeOffice2010Blue
99451>//                    Send AddTheme hoCombo "xtpThemeOffice2010Black" xtpThemeOffice2010Black
99451>//                    Send AddTheme hoCombo "xtpThemeOffice2010Silver" xtpThemeOffice2010Silver
99451>//
99451>//                    Send AddTheme hoCombo "xtpThemeOffice2007Aqua" xtpThemeOffice2007Aqua
99451>//                    Send AddTheme hoCombo "xtpThemeOffice2007Black" xtpThemeOffice2007Black
99451>//                    Send AddTheme hoCombo "xtpThemeOffice2007Blue" xtpThemeOffice2007Blue
99451>//                    Send AddTheme hoCombo "xtpThemeOffice2007Silver" xtpThemeOffice2007Silver
99451>//
99451>//                    Send AddTheme hoCombo "xtpThemeVisualStudio2015Blue" xtpThemeVisualStudio2015Blue
99451>//                    Send AddTheme hoCombo "xtpThemeVisualStudio2015Light" xtpThemeVisualStudio2015Light
99451>//                    Send AddTheme hoCombo "xtpThemeVisualStudio2015Dark" xtpThemeVisualStudio2015Dark
99451>//
99451>//                    Send AddTheme hoCombo "xtpThemeVisualStudio2012Light" xtpThemeVisualStudio2012Light
99451>//                    Send AddTheme hoCombo "xtpThemeVisualStudio2012Dark" xtpThemeVisualStudio2012Dark
99451>//
99451>//                    Send AddTheme hoCombo "xtpThemeVisualStudio2008" xtpThemeVisualStudio2008
99451>//                    Send AddTheme hoCombo "xtpThemeVisualStudio6" xtpThemeVisualStudio6
99451>//
99451>//                    Send AddTheme hoCombo "xtpThemeWindows7" xtpThemeWindows7
99451>//
99451>//                    Send AddTheme hoCombo "xtpThemeWhidbey" xtpThemeWhidbey
99451>//
99451>//                    Send AddTheme hoCombo "xtpThemeNativeWinXP" xtpThemeNativeWinXP
99451>//                End_Procedure
99451>//
99451>//                Function CurrentTheme Handle vCommandBarControl Returns Integer
99451>//                    Handle hMessage hoCombo
99451>//                    Integer iIndex
99451>//                    // create and bind  proxy control
99451>//                    Get CreateProxyControl vCommandBarControl to hoCombo
99451>//                    // get the current selection
99451>//                    Get ComListIndex of hoCombo to iIndex
99451>//                    // note the index selections are 1 based
99451>//                    If (iIndex > 0) Begin
99451>//                        // get the ItemData for the selected item and send that message
99451>//                        Get ComItemData of hoCombo iIndex to hMessage
99451>//                        Function_Return hMessage
99451>//                    End
99451>//                    // dispose of the proxy control
99451>//                    Send Destroy of hoCombo 
99451>//                    Function_Return 0
99451>//                End_Function
99451>//
99451>//                Procedure OnExecute Variant vCommandBarControl
99451>//                    Integer eTheme
99451>//                    Integer iColor
99451>//                    Get CurrentTheme vCommandBarControl to eTheme
99451>//                    Set peVisualTheme of ghoCommandBars to eTheme
99451>//                    Send ComRecalcLayout of ghoCommandBars
99451>//                    Send WriteDword of ghoApplication CS_PropertiesKeyWord CS_ThemeKeyWord eTheme
99451>//                    Get ComGetSpecialColor of ghoCommandBars XPCOLOR_TOOLBAR_FACE to iColor
99451>//                    Broadcast Recursive Set Color of (Client_Id(phoMainPanel(ghoApplication))) to iColor
99451>//                End_Procedure
99451>//
99451>//                Procedure SetTheTheme Integer eTheme
99451>//                    Integer iColor
99451>//                    Set peVisualTheme of ghoCommandBars to eTheme
99451>//                    Send ComRecalcLayout of ghoCommandBars
99451>//                    Get ComGetSpecialColor of ghoCommandBars XPCOLOR_TOOLBAR_FACE to iColor
99451>//                    Broadcast Recursive Set Color of (Client_Id(phoMainPanel(ghoApplication))) to iColor
99451>//                End_Procedure
99451>//
99451>//                Function ConvertSystemColor Integer iColor Returns Integer
99451>//                    Integer iSysColor
99451>//                    If (iColor = clDefault or iColor = clNone) Begin    // If default color then use -1
99451>//                        Move clNone to iColor
99451>//                    End
99451>//                    Else If (iColor < 0) Begin    // If it is a system color (<0) then convert this into an RGB value
99451>//                        Move (iColor iand |CI$7FFFFFFF) to iSysColor    // extract the system color constant
99451>//                        Move (GetSysColor(iSysColor)) to iColor
99451>//                    End
99451>//                    Function_Return iColor
99451>//                End_Function
99451>//
99451>//                Procedure OnCreateAction
99451>//                    Integer eTheme
99451>//                    Forward Send OnCreateAction
99451>//                    Get peVisualTheme of ghoCommandBars to eTheme
99451>//                    Get ReadDword of ghoApplication CS_PropertiesKeyWord CS_ThemeKeyWord eTheme to eTheme
99451>//                    Set peVisualTheme to eTheme
99451>//                End_Procedure
99451>//
99451>//            End_Object
99451>//            #ENDIF
99451>
99451>//            Object oColorSelection_TextItem is a cCJMenuItem
99451>//                Set peControlType to xtpControlLabel
99451>//                Set pbControlBeginGroup to True
99451>//                Set psCaption to "Hotspot Color:"
99451>//            End_Object
99451>//
99451>//            Object oColorSelection_Item is a cCJMenuItem
99451>//                Set psImage to "ColorSelectorBlack1.ico"
99451>//
99451>//                Object oColorDialog is a ColorDialog
99451>//                    Function SelectColor Returns Integer
99451>//                        Integer iRgbColor
99451>//                        Boolean bColorSelected
99451>//
99451>//                        Move -1 to iRgbColor
99451>//                        Get Show_Dialog to bColorSelected
99451>//                        If (bColorSelected) Begin
99451>//                            Get SelectedColor to iRgbColor
99451>//                        End
99451>//
99451>//                        Function_Return iRgbColor
99451>//                    End_Function
99451>//                End_Object
99451>//
99451>//                Procedure OnExecute Variant vCommandBarControl
99451>//                    Integer iColor
99451>//                    Forward Send OnExecute vCommandBarControl
99451>//                    Get SelectColor of oColorDialog to iColor
99451>//                    If (iColor <> -1) Begin
99451>//                        Broadcast Recursive Set piHeaderHotspotColor of (Client_Id(phoMainPanel(ghoApplication))) to iColor
99451>//                    End
99451>//                End_Procedure
99451>//
99451>//            End_Object
99451>
99451>            Object oAbout_MenuItem is a cCJMenuItem
99453>                Set psCaption to "About"
99454>                Set psToolTip to "About Info"
99455>                Set psDescription to "About the program"
99456>                Set psImage to "ActionAbout1.ico"
99457>                Set pbControlBeginGroup to True
99458>                Procedure OnExecute Variant vCommandBarControl
99461>                    Forward Send OnExecute vCommandBarControl
99463>                    Send Activate_About of (Client_Id(ghoCommandBars))
99464>                End_Procedure
99465>            End_Object
99466>
99466>            Object oHelpMenuItem is a cCJHelpMenuItem
99468>                Set peControlType to xtpControlSplitButtonPopup
99469>                Set psImage to "ActionHelp1.ico"
99470>
99470>                Procedure OnExecute Variant vCommandBarControl
99473>                    Send ShowProgramHelp
99474>                End_Procedure
99475>
99475>                Object oHelpMenuItemLocal is a cCJMenuItem
99477>                    Set psCaption to "Local HTML Help"
99478>                    Set psImage to "ActionHelp1.ico"
99479>                    Procedure OnExecute Variant vCommandBarControl
99482>                        Send ShowProgramHelp
99483>                    End_Procedure
99484>                End_Object
99485>
99485>                Object oHelpMenuItemInternetBrowser is a cCJMenuItem
99487>                    Set psCaption to "Online HTML Help"
99488>                    Set psImage to "ActionHelpInternet1.ico"
99489>                    Procedure OnExecute Variant vCommandBarControl
99492>                        Runprogram Shell Background "http://www.rdctools.com/HTMLHelpDUF/Developer5.htm"
99493>                    End_Procedure
99494>
99494>                End_Object
99495>
99495>                Object oCheckforUpdatesMenuItem is a cCJMenuItem
99497>                    Set psCaption to "Check for Updates"
99498>                    Set psDescription to "Check for Updates..."
99499>                    Set psImage to "InternetUpdate1.ico"
99500>                    Set pbControlBeginGroup to True
99501>                    
99501>                    Procedure OnExecute Variant vCommandBarControl
99504>                        String sPath sUpdateProgram sParam
99504>                        Get psProgramPath of (phoWorkspace(ghoApplication)) to sPath
99505>                        Get vFolderFormat sPath to sPath
99506>                        Move "updater.exe" to sUpdateProgram
99507>                        Move "/checknow"   to sParam
99508>                        Runprogram Shell Wait ('"' + sPath + sUpdateProgram + '"') sParam
99509>                    End_Procedure
99510>                
99510>                End_Object
99511>                
99511>            End_Object
99512>
99512>            Object oExitMenuItem is a cCJExitMenuItem
99514>                Set psToolTip to "Exit application"
99515>                Set psDescription to "Exit the program (Alt+F4)"
99516>                Set psImage to "ActionExit1.ico"
99517>                Set pbControlBeginGroup to True
99518>            End_Object
99519>
99519>        End_Object
99520>
99520>        Object oPreviousTabAction is a cCJAction
99522>            Set piShortCutKey to (xtpKey_Shift + xtpKey_Ctrl) VK_TAB
99523>            Procedure OnExecute Variant vCommandBarControl
99526>                Handle hoCommandBars hoClientArea
99526>                Forward Send OnExecute vCommandBarControl
99528>                Get CommandBarSystemObject to hoCommandBars
99529>                Get ClientAreaObject of hoCommandBars to hoClientArea
99530>                If hoClientArea Begin
99532>                    Send Switch_Next_View of hoClientArea
99533>                End
99533>            End_Procedure
99534>        End_Object
99535>
99535>        Object oStatusBar is a cCJStatusBar
99537>
99537>            Object oStatusPane1 is a cCJStatusBarPane
99539>                Set piID to sbpIDIdlePane
99540>                Set pbStyleStretch to True
99541>            End_Object
99542>
99542>            Object oStatusPane2 is a cCJStatusBarPane
99544>                Set phoViewPane to Self
99545>                Set pbStyleStretch to True
99546>            End_Object
99547>
99547>        End_Object
99548>
99548>    End_Object
99549>
99549>    Object oClientArea is a ClientArea
99551>        Use ManageSQLConnections.dg
Including file: ManageSQLConnections.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ManageSQLConnections.dg)
99551>>>Use Windows.pkg
99551>>>Use Cursor.pkg
99551>>>Use cCJCommandBarSystem.pkg
99551>>>Use cRDCButtonDPI.pkg
Including file: cRDCButtonDPI.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cRDCButtonDPI.pkg)
99551>>>>>//****************************************************************************
99551>>>>>// $Module type: Package
99551>>>>>// $Module name: cRDCButtonDPI.pkg
99551>>>>>//
99551>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
99551>>>>>// Copyright (c) 2013 RDC Tools International
99551>>>>>// E-mail      : support@rdctools.com
99551>>>>>// Web-site    : http://www.rdctools.com
99551>>>>>//
99551>>>>>// Created     : 2013-01-05 @ 19:04 (Military date format - Year-Month-Day)
99551>>>>>//
99551>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
99551>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
99551>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
99551>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
99551>>>>>// in the help folder for more details.
99551>>>>>//
99551>>>>>//****************************************************************************
99551>>>>>Use cRDCButton.pkg
Including file: cRDCButton.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cRDCButton.pkg)
99551>>>>>>>//****************************************************************************
99551>>>>>>>// $Module type: Package
99551>>>>>>>// $Module name: cRDCButton.pkg
99551>>>>>>>//
99551>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
99551>>>>>>>// Copyright (c) 2013 RDC Tools International
99551>>>>>>>// E-mail      : support@rdctools.com
99551>>>>>>>// Web-site    : http://www.rdctools.com
99551>>>>>>>//
99551>>>>>>>// Created     : 2013-01-05 @ 19:04 (Military date format - Year-Month-Day)
99551>>>>>>>//
99551>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
99551>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
99551>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
99551>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
99551>>>>>>>// in the help folder for more details.
99551>>>>>>>//
99551>>>>>>>//****************************************************************************
99551>>>>>>>Use Windows.pkg
99551>>>>>>>Use Enclient.pkg
99551>>>>>>>Use errornum.inc
99551>>>>>>>
99551>>>>>>>Class cButtonIdleHandler is a cIdleHandler
99552>>>>>>>    Procedure Construct_Object
99554>>>>>>>        Forward Send Construct_Object
99556>>>>>>>
99556>>>>>>>    End_Procedure
99557>>>>>>>
99557>>>>>>>    Procedure OnIdle
99559>>>>>>>        Delegate Send DoUpdate
99561>>>>>>>    End_Procedure
99562>>>>>>>
99562>>>>>>>End_Class
99563>>>>>>>
99563>>>>>>>Class cRDCButton is a Button
99564>>>>>>>
99564>>>>>>>    Procedure Construct_Object
99566>>>>>>>        Forward Send Construct_Object
99568>>>>>>>
99568>>>>>>>        Property Boolean pbAutoEnable False
99569>>>>>>>
99569>>>>>>>        Property Boolean pbEnabled True
99570>>>>>>>
99570>>>>>>>        Property Handle phoIdleHandler (Create(Self, RefClass(cButtonIdleHandler)))
99571>>>>>>>
99571>>>>>>>        On_Key kCancel Send CancelIfPopupObject
99572>>>>>>>    End_Procedure
99573>>>>>>>
99573>>>>>>>    Procedure CancelIfPopupObject
99575>>>>>>>        Boolean bIsInPopupObject
99575>>>>>>>        Delegate Get Popup_State to bIsInPopupObject
99577>>>>>>>        If (bIsInPopupObject = True) Begin
99579>>>>>>>            Send Close_Panel
99580>>>>>>>        End
99580>>>>>>>>
99580>>>>>>>    End_Procedure
99581>>>>>>>
99581>>>>>>>    Procedure End_Construct_Object
99583>>>>>>>        String sTooltip sStatus_Help
99583>>>>>>>
99583>>>>>>>        Forward Send End_Construct_Object
99585>>>>>>>
99585>>>>>>>        Get psToolTip   to sTooltip
99586>>>>>>>        Get Status_Help to sStatus_Help
99587>>>>>>>        If (sTooltip = "" and sStatus_Help <> "") Begin
99589>>>>>>>            Set psToolTip to sStatus_Help
99590>>>>>>>        End
99590>>>>>>>>
99590>>>>>>>        If (sTooltip <> "" and sStatus_Help = "") Begin
99592>>>>>>>            Set Status_Help to sToolTip
99593>>>>>>>        End
99593>>>>>>>>
99593>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to (pbAutoEnable(Self))
99594>>>>>>>    End_Procedure
99595>>>>>>>
99595>>>>>>>    Procedure DoUpdate
99597>>>>>>>        If (pbAutoEnable(Self) = False) Begin
99599>>>>>>>            Procedure_Return
99600>>>>>>>        End
99600>>>>>>>>
99600>>>>>>>        Set Enabled_State to (IsEnabled(Self))
99601>>>>>>>    End_Procedure
99602>>>>>>>
99602>>>>>>>    Function IsEnabled Returns Boolean
99604>>>>>>>        Boolean bEnabled
99604>>>>>>>        Get pbEnabled to bEnabled
99605>>>>>>>        Function_Return bEnabled
99606>>>>>>>    End_Function
99607>>>>>>>
99607>>>>>>>    // Enable the idle handler timer when the button is activated
99607>>>>>>>    Procedure Activating
99609>>>>>>>        Forward Send Activating
99611>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to True
99612>>>>>>>    End_Procedure
99613>>>>>>>
99613>>>>>>>    // Disable the idle handler when the button is deactivated
99613>>>>>>>    Procedure Deactivating
99615>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to False
99616>>>>>>>        Forward Send Deactivating
99618>>>>>>>    End_Procedure
99619>>>>>>>
99619>>>>>>>End_Class
99620>>>>>
99620>>>>>// Button class that automatically shows the correct icon size for the current DPI-setting:
99620>>>>>Class cRDCButtonDPI is a cRDCButton
99621>>>>>    Procedure Construct_Object
99623>>>>>        Integer iIconSize
99623>>>>>        Forward Send Construct_Object
99625>>>>>        Set piImageMarginLeft to 10
99626>>>>>    End_Procedure
99627>>>>>
99627>>>>>    // Returns: DPI setting as an integer.
99627>>>>>    //  Normal DPI setting: iDPI=96  is "Normal setting" 100%
99627>>>>>    //                      iDPI=120 is "Medium setting" 125%
99627>>>>>    //                      iDPI= 144 is "Large setting" 150%
99627>>>>>    Function GetCurrentDPI Returns Integer
99629>>>>>        Handle hDC
99629>>>>>        Integer iPixelsX
99629>>>>>        Move (GetDC(0)) to hDC
99630>>>>>        Move (GetDeviceCaps(hDC, LOGPIXELSX)) to iPixelsX
99631>>>>>        Move (ReleaseDC(0, hDC)) to hDC
99632>>>>>        Function_Return iPixelsX
99633>>>>>    End_Function
99634>>>>>
99634>>>>>    Function GetCorrectIconSize Returns Integer
99636>>>>>        Integer iPixelsX iIndex iSize
99636>>>>>        Integer[] iaSizes
99637>>>>>
99637>>>>>        Move 16 to iaSizes[0]
99638>>>>>        Move 24 to iaSizes[1]
99639>>>>>        Move 32 to iaSizes[2]
99640>>>>>        Move 48 to iaSizes[3]
99641>>>>>        Move 64 to iaSizes[4]
99642>>>>>
99642>>>>>        Get piImageSize to iSize  // the "100%" size
99643>>>>>        Move (SearchArray(iSize,iaSizes)) to iIndex
99644>>>>>        Move (0 max iIndex) to iIndex
99645>>>>>        Get GetCurrentDPI to iPixelsX
99646>>>>>        // Use a Case Statement here. Wherever we jump in we will continue onwards, regardless of whether
99646>>>>>        // we match the remaining Case statements or not. So list our Cases in reverse order, meaning we
99646>>>>>        // will increment iIndex as many times as we need here.
99646>>>>>        Case Begin
99646>>>>>            Case (iPixelsX > 144)
99648>>>>>                Increment iIndex
99649>>>>>            Case (iPixelsX = 144)
99652>>>>>                Increment iIndex
99653>>>>>            Case (iPixelsX = 120)
99656>>>>>                Increment iIndex
99657>>>>>        Case End
99657>>>>>        Move (iIndex min 4) to iIndex
99658>>>>>        Function_Return iaSizes[iIndex]
99659>>>>>    End_Function
99660>>>>>
99660>>>>>    Procedure Set psToolTip String sToolTip
99662>>>>>        String sStatusHelp
99662>>>>>
99662>>>>>        Get Status_Help to sStatusHelp
99663>>>>>        If (sStatusHelp = "") Begin
99665>>>>>            Set Status_Help to sToolTip
99666>>>>>        End
99666>>>>>>
99666>>>>>
99666>>>>>        Forward Set psToolTip to sToolTip
99668>>>>>    End_Procedure
99669>>>>>
99669>>>>>End_Class
99670>>>Use cSQLCheckBox.pkg
Including file: cSQLCheckBox.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLCheckBox.pkg)
99670>>>>>Use Windows.pkg
99670>>>>>
99670>>>>>// Used by the "Page" message below to show
99670>>>>>// a rectangle around ComboForm and Checkbox objects.
99670>>>>>    Define WM_CHANGEUISTATE for |CI$0127
99670>>>>>    Define WM_UPDATEUISTATE for |CI$0128
99670>>>>>    Define WM_QUERYUISTATE  for |CI$0129
99670>>>>>    Define UIS_SET          for 1
99670>>>>>    Define UIS_CLEAR        for 2
99670>>>>>    Define UIS_INITIALIZE   for 3
99670>>>>>    Define UISF_HIDEFOCUS   for |CI$1
99670>>>>>    Define UISF_HIDEACCEL   for |CI$2
99670>>>>>    Define UISF_ACTIVE      for |CI$4
99670>>>>>
99670>>>>>// Note: Can't use cRDCCheckbox as then the OnChange event isn't called (Don't know why)
99670>>>>>Class cSQLCheckBox is a CheckBox
99671>>>>>    Procedure Construct_Object
99673>>>>>        Forward Send Construct_Object
99675>>>>>        // The piItem should be set to the object's corresponding tSQLConnection member (One based)
99675>>>>>        Property Integer piItem
99676>>>>>    End_Procedure
99677>>>>>
99677>>>>>    Procedure DbTypeUpdate Integer iDbType String sDriverID
99679>>>>>    End_Procedure
99680>>>>>
99680>>>>>    Procedure ReadConnectionData String[] sConnectionData
99682>>>>>        Integer iItem
99682>>>>>        Get piItem to iItem
99683>>>>>        Set Checked_State to (sConnectionData[iItem] = "1")
99684>>>>>    End_Procedure
99685>>>>>
99685>>>>>    Procedure WriteConnectionData String[] ByRef sConnectionData
99687>>>>>        Boolean bState
99687>>>>>        Integer iItem
99687>>>>>        Get piItem to iItem
99688>>>>>        Get Checked_State to bState
99689>>>>>        Move bState to sConnectionData[iItem]
99690>>>>>    End_Procedure
99691>>>>>
99691>>>>>    Procedure Set psToolTip String sToolTip
99693>>>>>        String sStatusHelp
99693>>>>>
99693>>>>>        Get Status_Help to sStatusHelp
99694>>>>>        If (sStatusHelp = "") Begin
99696>>>>>            Set Status_Help to sToolTip
99697>>>>>        End
99697>>>>>>
99697>>>>>
99697>>>>>        Forward Set psToolTip to sToolTip
99699>>>>>    End_Procedure
99700>>>>>
99700>>>>>    // Fix for a bug when using manifest files & running Vista and above.
99700>>>>>    // The bug being that the focus rectangle doesn't show.
99700>>>>>    Procedure Page Integer iPageObject
99702>>>>>        Handle hWnd
99702>>>>>        Integer iRet iState
99702>>>>>
99702>>>>>        Forward Send Page iPageObject
99704>>>>>
99704>>>>>        If (iPageObject) Begin
99706>>>>>            Get Window_Handle to hWnd
99707>>>>>            If (hWnd) Begin
99709>>>>>                Move (SendMessage(hWnd, WM_QUERYUISTATE, 0, 0)) to iRet
99710>>>>>                If (iRet iand UISF_HIDEFOCUS) Begin
99712>>>>>                    Move (UIS_CLEAR + (UISF_HIDEFOCUS * 65536)) to iState
99713>>>>>                    Move (SendMessage(hWnd, WM_UPDATEUISTATE, iState, 0)) to iRet
99714>>>>>                End
99714>>>>>>
99714>>>>>            End
99714>>>>>>
99714>>>>>        End
99714>>>>>>
99714>>>>>    End_Procedure
99715>>>>>
99715>>>>>End_Class
99716>>>Use cSQLComboForm.pkg
Including file: cSQLComboForm.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLComboForm.pkg)
99716>>>>>Use Windows.pkg
99716>>>>>Use cRDCComboForm.pkg
Including file: cRDCComboForm.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cRDCComboForm.pkg)
99716>>>>>>>//****************************************************************************
99716>>>>>>>// $Module type: Package
99716>>>>>>>// $Module name: cRDCComboform.pkg
99716>>>>>>>//
99716>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
99716>>>>>>>// Copyright (c) 2014 RDC Tools International
99716>>>>>>>// E-mail      : support@rdctools.com
99716>>>>>>>// Web-site    : http://www.rdctools.com
99716>>>>>>>//
99716>>>>>>>// Created     : 2014-03-17 @ 12:35 (Military date format - Year-Month-Day)
99716>>>>>>>//
99716>>>>>>>// Portions by : Raveen Sundram, Excellent Software Ltd
99716>>>>>>>//               The auto-size combo width logic was developed by Raveen.
99716>>>>>>>//
99716>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
99716>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
99716>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
99716>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
99716>>>>>>>// in the help folder for more details.
99716>>>>>>>//
99716>>>>>>>//****************************************************************************
99716>>>>>>>Use Windows.pkg
99716>>>>>>>
99716>>>>>>>// Used by the "Page" message below to show
99716>>>>>>>// a focus rectangle around ComboForm and Checkbox objects.
99716>>>>>>>
99716>>>>>>>Class cComboFormIdleHandler is a cIdleHandler
99717>>>>>>>    Procedure Construct_Object
99719>>>>>>>        Forward Send Construct_Object
99721>>>>>>>
99721>>>>>>>    End_Procedure
99722>>>>>>>
99722>>>>>>>    Procedure OnIdle
99724>>>>>>>        Delegate Send DoUpdate
99726>>>>>>>    End_Procedure
99727>>>>>>>
99727>>>>>>>End_Class
99728>>>>>>>
99728>>>>>>>Class cRDCComboForm is a ComboForm
99729>>>>>>>    Procedure Construct_Object
99731>>>>>>>        Forward Send Construct_Object
99733>>>>>>>
99733>>>>>>>        Property Boolean pbAutoListWidth True
99734>>>>>>>
99734>>>>>>>        Property Boolean pbAutoShadowLabelObject True
99735>>>>>>>
99735>>>>>>>        Property Boolean pbAutoEnable False
99736>>>>>>>        Set Label_Col_Offset to 2
99737>>>>>>>        Property Boolean pbEnabled True
99738>>>>>>>        Set Label_Justification_Mode to JMode_Right
99739>>>>>>>        Property Handle phoIdleHandler (Create(Self, RefClass(cComboFormIdleHandler)))
99740>>>>>>>
99740>>>>>>>    End_Procedure
99741>>>>>>>
99741>>>>>>>    Procedure End_Construct_Object
99743>>>>>>>        Boolean bAutoShadowLabelObject
99743>>>>>>>        String sTooltip sStatus_Help
99743>>>>>>>
99743>>>>>>>        Get pbAutoShadowLabelObject to bAutoShadowLabelObject
99744>>>>>>>        If (bAutoShadowLabelObject = True) Begin
99746>>>>>>>            Set Private.Label_Shadow_Display_Mode to TBSHADOW_ON_LOCAL
99747>>>>>>>        End
99747>>>>>>>>
99747>>>>>>>
99747>>>>>>>        Forward Send End_Construct_Object
99749>>>>>>>
99749>>>>>>>        Get psToolTip   to sTooltip
99750>>>>>>>        Get Status_Help to sStatus_Help
99751>>>>>>>        If (sTooltip = "" and sStatus_Help <> "") Begin
99753>>>>>>>            Set psToolTip to sStatus_Help
99754>>>>>>>        End
99754>>>>>>>>
99754>>>>>>>        Else If (sTooltip <> "" and sStatus_Help = "") Begin
99757>>>>>>>            Set Status_Help to sTooltip
99758>>>>>>>        End
99758>>>>>>>>
99758>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to (pbAutoEnable(Self))
99759>>>>>>>
99759>>>>>>>    End_Procedure
99760>>>>>>>
99760>>>>>>>    Procedure DoUpdate
99762>>>>>>>        If (pbAutoEnable(Self) = False) Begin
99764>>>>>>>            Procedure_Return
99765>>>>>>>        End
99765>>>>>>>>
99765>>>>>>>        Set Enabled_State to (IsEnabled(Self))
99766>>>>>>>    End_Procedure
99767>>>>>>>
99767>>>>>>>    Function IsEnabled Returns Boolean
99769>>>>>>>        Boolean bEnabled
99769>>>>>>>        Get pbEnabled to bEnabled
99770>>>>>>>        Function_Return bEnabled
99771>>>>>>>    End_Function
99772>>>>>>>
99772>>>>>>>    // Enable the idle handler timer when the object is activated
99772>>>>>>>    Procedure Activating
99774>>>>>>>        Forward Send Activating
99776>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to True
99777>>>>>>>    End_Procedure
99778>>>>>>>
99778>>>>>>>    // Disable the idle handler when the object is deactivated
99778>>>>>>>    Procedure Deactivating
99780>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to False
99781>>>>>>>        Forward Send Deactivating
99783>>>>>>>    End_Procedure
99784>>>>>>>
99784>>>>>>>    // To "un-select" the text in the comboform on startup
99784>>>>>>>    Procedure DoApplyAnchors Integer Arg1 Integer Arg2
99786>>>>>>>        Integer iStart iEnd
99786>>>>>>>
99786>>>>>>>        If (Focus(Desktop)=Self) Begin
99788>>>>>>>            Get SelStart to iStart
99789>>>>>>>            Get SelEnd   to iEnd
99790>>>>>>>        End
99790>>>>>>>>
99790>>>>>>>        Forward Send DoApplyAnchors Arg1 Arg2
99792>>>>>>>        Send SetSel iStart iEnd
99793>>>>>>>    End_Procedure
99794>>>>>>>
99794>>>>>>>    // Message that will drop down the list without the user clicking it,
99794>>>>>>>    // so you can send "DropDownList" to the combo to show the list.
99794>>>>>>>    Procedure DropDownList
99796>>>>>>>        Send Windows_Message CB_SHOWDROPDOWN 1 0
99797>>>>>>>    End_Procedure
99798>>>>>>>
99798>>>>>>>    Procedure SizeComboWidth
99800>>>>>>>        Integer iCount iItem iTextExt iRows iWd iNewWd iVertAdj
99800>>>>>>>        String sVal
99800>>>>>>>
99800>>>>>>>        // Initialise Width
99800>>>>>>>        Set ListWidth to 0
99801>>>>>>>        Send DoSetListWidth
99802>>>>>>>
99802>>>>>>>        Get ListRowCount     to iRows
99803>>>>>>>        Get Combo_Item_Count to iCount
99804>>>>>>>
99804>>>>>>>        // Vertical scroll-bar adjustment is needed
99804>>>>>>>        Move (iRows > 0 and iCount > iRows) to iVertAdj
99805>>>>>>>        If (iVertAdj) Begin
99807>>>>>>>            Move (GetSystemMetrics(SM_CXVSCROLL)+GetSystemMetrics(SM_CXEDGE)) to iVertAdj
99808>>>>>>>        End
99808>>>>>>>>
99808>>>>>>>        Else Begin
99809>>>>>>>            Move (GetSystemMetrics(SM_CXEDGE)) to iVertAdj
99810>>>>>>>        End
99810>>>>>>>>
99810>>>>>>>
99810>>>>>>>        // Calculate New Width
99810>>>>>>>        Decrement iCount
99811>>>>>>>        For iItem from 0 to iCount
99817>>>>>>>>
99817>>>>>>>            Get Combo_Value iItem to sVal
99818>>>>>>>            If (sVal <> "") Begin
99820>>>>>>>                Get Text_Extent sVal to iTextExt
99821>>>>>>>                Move (Low(iTextExt) + iVertAdj) to iWd
99822>>>>>>>                If (iWd > iNewWd) Begin
99824>>>>>>>                    Move (iWd + GetSystemMetrics(SM_CXFIXEDFRAME) + GetSystemMetrics(SM_CXEDGE)) to iNewWd
99825>>>>>>>                End
99825>>>>>>>>
99825>>>>>>>            End
99825>>>>>>>>
99825>>>>>>>        Loop
99826>>>>>>>>
99826>>>>>>>
99826>>>>>>>        // Set New Width
99826>>>>>>>        Set ListWidth to iNewWd
99827>>>>>>>        Send DoSetListWidth
99828>>>>>>>    End_Procedure
99829>>>>>>>
99829>>>>>>>    Procedure Combo_Add_Item String sValue
99831>>>>>>>        Forward Send Combo_Add_Item sValue
99833>>>>>>>        If (pbAutoListWidth(Self)) Begin
99835>>>>>>>            Send SizeComboWidth
99836>>>>>>>        End
99836>>>>>>>>
99836>>>>>>>    End_Procedure
99837>>>>>>>
99837>>>>>>>    Procedure Combo_Fill_List
99839>>>>>>>        Forward Send Combo_Fill_List
99841>>>>>>>        If (pbAutoListWidth(Self)) Begin
99843>>>>>>>            Send SizeComboWidth
99844>>>>>>>        End
99844>>>>>>>>
99844>>>>>>>    End_Procedure
99845>>>>>>>
99845>>>>>>>    // Fix for a bug when using manifest files & running Vista and above.
99845>>>>>>>    // The bug being that the focus rectangle doesn't show.
99845>>>>>>>    Procedure Page Integer iPageObject
99847>>>>>>>        Handle hWnd
99847>>>>>>>        Integer iRet iState
99847>>>>>>>
99847>>>>>>>        Forward Send Page iPageObject
99849>>>>>>>
99849>>>>>>>        If (iPageObject) Begin
99851>>>>>>>            Get Window_Handle to hWnd
99852>>>>>>>            If (hWnd) Begin
99854>>>>>>>                Move (SendMessage(hWnd, WM_QUERYUISTATE, 0, 0)) to iRet
99855>>>>>>>                If (iRet iand UISF_HIDEFOCUS) Begin
99857>>>>>>>                    Move (UIS_CLEAR + (UISF_HIDEFOCUS * 65536)) to iState
99858>>>>>>>                    Move (SendMessage(hWnd, WM_UPDATEUISTATE, iState, 0)) to iRet
99859>>>>>>>                End
99859>>>>>>>>
99859>>>>>>>            End
99859>>>>>>>>
99859>>>>>>>        End
99859>>>>>>>>
99859>>>>>>>
99859>>>>>>>        // To "un-select" the text in the comboform
99859>>>>>>>        If (iPageObject = 1 and Focus(Desktop) <> Self) Begin
99861>>>>>>>            Send SetSel 0 0
99862>>>>>>>        End
99862>>>>>>>>
99862>>>>>>>    End_Procedure
99863>>>>>>>
99863>>>>>>>End_Class
99864>>>>>
99864>>>>>// Used by the "Page" message below to show
99864>>>>>// a rectangle around ComboForm and Checkbox objects.
99864>>>>>//#IFNDEF WM_CHANGEUISTATE
99864>>>>>//    Define WM_CHANGEUISTATE for |CI$0127
99864>>>>>//    Define WM_UPDATEUISTATE for |CI$0128
99864>>>>>//    Define WM_QUERYUISTATE  for |CI$0129
99864>>>>>//    Define UIS_SET          for 1
99864>>>>>//    Define UIS_CLEAR        for 2
99864>>>>>//    Define UIS_INITIALIZE   for 3
99864>>>>>//    Define UISF_HIDEFOCUS   for |CI$1
99864>>>>>//    Define UISF_HIDEACCEL   for |CI$2
99864>>>>>//    Define UISF_ACTIVE      for |CI$4
99864>>>>>//#ENDIF
99864>>>>>
99864>>>>>Class cSQLComboForm is a cRDCComboForm
99865>>>>>    Procedure Construct_Object
99867>>>>>        Forward Send Construct_Object
99869>>>>>
99869>>>>>        // This will shadow the label if the form itself has its Enabled_State=False
99869>>>>>//        Property Boolean pbAutoShadowLabelObject True
99869>>>>>
99869>>>>>        // The piItem should be set to the object's corresponding tSQLConnection member (One based)
99869>>>>>        Property Integer piItem
99870>>>>>
99870>>>>>//        Set Label_Col_Offset to 2
99870>>>>>//        Set Label_Justification_Mode to JMode_Right
99870>>>>>    End_Procedure
99871>>>>>
99871>>>>>    Procedure End_Construct_Object
99873>>>>>//        Boolean bAutoShadowLabelObject
99873>>>>>//        Get pbAutoShadowLabelObject to bAutoShadowLabelObject
99873>>>>>//        If (bAutoShadowLabelObject = True) Begin
99873>>>>>//            Set Private.Label_Shadow_Display_Mode to TBSHADOW_ON_LOCAL
99873>>>>>//        End
99873>>>>>        Forward Send End_Construct_Object
99875>>>>>    End_Procedure
99876>>>>>
99876>>>>>    Procedure DbTypeUpdate Integer iDbType String sDriverID
99878>>>>>    End_Procedure
99879>>>>>
99879>>>>>    Procedure ReadConnectionData String[] sConnectionData
99881>>>>>        Integer iItem
99881>>>>>        Get piItem to iItem
99882>>>>>        Set Value to sConnectionData[iItem]
99883>>>>>    End_Procedure
99884>>>>>
99884>>>>>    Procedure WriteConnectionData String[] ByRef sConnectionData
99886>>>>>        String sValue
99886>>>>>        Integer iItem
99886>>>>>        Get piItem to iItem
99887>>>>>        Get Value to sValue
99888>>>>>        Move sValue to sConnectionData[iItem]
99889>>>>>    End_Procedure
99890>>>>>
99890>>>>>//    Procedure Set psToolTip String sToolTip
99890>>>>>//        String sStatusHelp
99890>>>>>//
99890>>>>>//        Get Status_Help to sStatusHelp
99890>>>>>//        If (sStatusHelp = "") Begin
99890>>>>>//            Set Status_Help to sToolTip
99890>>>>>//        End
99890>>>>>//
99890>>>>>//        Forward Set psToolTip to sToolTip
99890>>>>>//    End_Procedure
99890>>>>>//
99890>>>>>//    // Fix for a bug when using manifest files & running Vista and above.
99890>>>>>//    // The bug being that the focus rectangle doesn't show.
99890>>>>>//    Procedure Page Integer iPageObject
99890>>>>>//        Handle hWnd
99890>>>>>//        Integer iRet iState
99890>>>>>//
99890>>>>>//        Forward Send Page iPageObject
99890>>>>>//
99890>>>>>//        If (iPageObject) Begin
99890>>>>>//            Get Window_Handle to hWnd
99890>>>>>//            If (hWnd) Begin
99890>>>>>//                Move (SendMessage(hWnd, WM_QUERYUISTATE, 0, 0)) to iRet
99890>>>>>//                If (iRet iand UISF_HIDEFOCUS) Begin
99890>>>>>//                    Move (UIS_CLEAR + (UISF_HIDEFOCUS * 65536)) to iState
99890>>>>>//                    Move (SendMessage(hWnd, WM_UPDATEUISTATE, iState, 0)) to iRet
99890>>>>>//                End
99890>>>>>//            End
99890>>>>>//        End
99890>>>>>//    End_Procedure
99890>>>>>
99890>>>>>End_Class
99891>>>Use cSQLForm.pkg
Including file: cSQLForm.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cSQLForm.pkg)
99891>>>>>Use Windows.pkg
99891>>>>>
99891>>>>>Class cSQLForm is a Form
99892>>>>>    Procedure Construct_Object
99894>>>>>        Forward Send Construct_Object
99896>>>>>
99896>>>>>        // This will shadow the label if the form itself has its Enabled_State=False
99896>>>>>        Property Boolean pbAutoShadowLabelObject True
99897>>>>>
99897>>>>>        // The piItem should be set to the object's corresponding tSQLConnection member (One based)
99897>>>>>        Property Integer piItem
99898>>>>>
99898>>>>>        Set Label_Justification_Mode to JMode_Right
99899>>>>>        Set Label_Col_Offset to 2
99900>>>>>    End_Procedure
99901>>>>>
99901>>>>>    Procedure End_Construct_Object
99903>>>>>        Boolean bAutoShadowLabelObject
99903>>>>>        Get pbAutoShadowLabelObject to bAutoShadowLabelObject
99904>>>>>        If (bAutoShadowLabelObject = True) Begin
99906>>>>>            Set Private.Label_Shadow_Display_Mode to TBSHADOW_ON_LOCAL
99907>>>>>        End
99907>>>>>>
99907>>>>>        Forward Send End_Construct_Object
99909>>>>>    End_Procedure
99910>>>>>
99910>>>>>    Procedure DbTypeUpdate Integer iDbType String sDriverID
99912>>>>>    End_Procedure
99913>>>>>
99913>>>>>    Procedure ReadConnectionData String[] sConnectionData
99915>>>>>        Integer iItem
99915>>>>>        Get piItem to iItem
99916>>>>>        Set Value to sConnectionData[iItem]
99917>>>>>    End_Procedure
99918>>>>>
99918>>>>>    Procedure WriteConnectionData String[] ByRef sConnectionData
99920>>>>>        String sValue
99920>>>>>        Integer iItem
99920>>>>>        Get piItem to iItem
99921>>>>>        Get Value to sValue
99922>>>>>        Move sValue to sConnectionData[iItem]
99923>>>>>    End_Procedure
99924>>>>>
99924>>>>>    Procedure Set psToolTip String sToolTip
99926>>>>>        String sStatusHelp
99926>>>>>
99926>>>>>        Get Status_Help to sStatusHelp
99927>>>>>        If (sStatusHelp = "") Begin
99929>>>>>            Set Status_Help to sToolTip
99930>>>>>        End
99930>>>>>>
99930>>>>>
99930>>>>>        Forward Set psToolTip to sToolTip
99932>>>>>    End_Procedure
99933>>>>>
99933>>>>>End_Class
99934>>>Use cSQLConnectionHandler.pkg
99934>>>Use cDbUpdateFunctionLibrary.pkg
99934>>>Use cDbUpdateDatabaseDriver.pkg
99934>>>Use DatabaseSelection.dg
Including file: DatabaseSelection.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DatabaseSelection.dg)
99934>>>>>Use Windows.pkg
99934>>>>>Use cCJGridPromptList.pkg
Including file: cCJGridPromptList.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCJGridPromptList.pkg)
99934>>>>>>>Use Windows.pkg
99934>>>>>>>Use cCJGrid.pkg
99934>>>>>>>
99934>>>>>>>
99934>>>>>>>
99934>>>>>>>Class cCJGridPromptList is a cCJGrid
99935>>>>>>>    
99935>>>>>>>    Procedure Construct_Object
99937>>>>>>>        Forward Send Construct_Object
99939>>>>>>>        
99939>>>>>>>        Property Boolean pbAutoSeed True     // if we should seed list from invoking data
99940>>>>>>>        Property Boolean Private_pbAutoOrdering True
99941>>>>>>>        Property Boolean pbAutoSearch True  // pops up search window
99942>>>>>>>        Property Integer peUpdateMode umPromptValue
99943>>>>>>>        Property Integer piUpdateColumn 0
99944>>>>>>>        Property Integer piInitialColumn -1
99945>>>>>>>        Property String  psSeedValue ''
99946>>>>>>>        Property Handle phmPromptUpdateCallback 0
99947>>>>>>>        Property Integer phoInvokingObject
99948>>>>>>>        
99948>>>>>>>        Property Boolean pbStoredAutoSeed
99949>>>>>>>        Property Boolean pbStoredAutoOrdering
99950>>>>>>>        Property Boolean pbStoredAutoSearch
99951>>>>>>>        Property Integer peStoredUpdateMode
99952>>>>>>>        Property Integer piStoredUpdateColumn
99953>>>>>>>        Property Integer piStoredInitialColumn
99954>>>>>>>        Property Handle  phmStoredPromptUpdateCallback
99955>>>>>>>        Property Boolean pbStoredSelectionEnable
99956>>>>>>>        Property Boolean pbStoredMultipleSelection
99957>>>>>>>        
99957>>>>>>>        // internally set by list
99957>>>>>>>        // these must be set upon closing the list and can be used for manual list updates
99957>>>>>>>        Property Boolean pbCanceled
99958>>>>>>>        Property Integer[] pSelectedRows
99959>>>>>>>        
99959>>>>>>>        Property Boolean pbNeedsNewOrdering
99960>>>>>>>        Property Boolean pbRequestSearch
99961>>>>>>>        Property tGridKeyPair[] pSearchKeys
99962>>>>>>>        
99962>>>>>>>        // these properties makes a prompt list a prompt list
99962>>>>>>>        // and should not be changed.
99962>>>>>>>        Set pbEditOnKeyNavigation to False
99963>>>>>>>        Set pbEditOnClick to False
99964>>>>>>>        Set pbReadOnly to True
99965>>>>>>>        Set pbFocusSubItems to True
99966>>>>>>>        
99966>>>>>>>        // these could maybe be changed
99966>>>>>>>        Set pbShadeSortColumn to True
99967>>>>>>>        Set pbHeaderReorders to True
99968>>>>>>>        Set pbHeaderTogglesDirection to True
99969>>>>>>>        Set pbHeaderSelectsColumn to True
99970>>>>>>>        Set peHorizontalGridStyle to xtpGridNoLines
99971>>>>>>>        Set piFocusCellBackColor to clNone
99972>>>>>>>        Set piFocusCellForeColor to clNone
99973>>>>>>>        Set piFocusCellRectangleColor to clBlack
99974>>>>>>>        Set pbUseFocusCellRectangle to False
99975>>>>>>>        Set pbSelectionEnable to True
99976>>>>>>>        
99976>>>>>>>        On_Key kEnter Send Ok
99977>>>>>>>        On_Key kCancel Send Cancel
99978>>>>>>>        
99978>>>>>>>    End_Procedure
99979>>>>>>>    
99979>>>>>>>    // reorder list automatically on column change
99979>>>>>>>    // this also set pbFocusSubItems which is required to make the two states work
99979>>>>>>>    Procedure Set pbAutoOrdering Boolean bAutoOrder
99981>>>>>>>        Set Private_pbAutoOrdering to bAutoOrder
99982>>>>>>>        Set pbFocusSubItems to bAutoOrder
99983>>>>>>>    End_Procedure
99984>>>>>>>    
99984>>>>>>>    Function pbAutoOrdering Returns Boolean
99986>>>>>>>        Boolean bAutoOrder
99986>>>>>>>        Get Private_pbAutoOrdering to bAutoOrder
99987>>>>>>>        Function_Return bAutoOrder
99988>>>>>>>    End_Function
99989>>>>>>>    
99989>>>>>>>    // augmented to handle auto-ordering and invoking the search popup list
99989>>>>>>>    Procedure OnIdle
99991>>>>>>>        Boolean bNeedsReorder bSearch bOldToggle
99991>>>>>>>        Handle hoCol
99991>>>>>>>        Integer iKy1 iKy2 iCol
99991>>>>>>>        
99991>>>>>>>        Get pbNeedsNewOrdering to bNeedsReorder
99992>>>>>>>        If bNeedsReorder Begin
99994>>>>>>>            Get SelectedColumn to iCol
99995>>>>>>>            If (iCol<>-1) Begin
99997>>>>>>>                
99997>>>>>>>                Get pbHeaderTogglesDirection to bOldToggle
99998>>>>>>>                Set pbHeaderTogglesDirection to False
99999>>>>>>>                Send HeaderReorder iCol
100000>>>>>>>                Set pbHeaderTogglesDirection to bOldToggle
100001>>>>>>>                
100001>>>>>>>                Set pbNeedsNewOrdering to False
100002>>>>>>>            End
100002>>>>>>>>
100002>>>>>>>        End
100002>>>>>>>>
100002>>>>>>>        
100002>>>>>>>        Get pbRequestSearch to bSearch
100003>>>>>>>        If bSearch Begin
100005>>>>>>>            Send Request_SearchEx // will use the keys pSearchKeys as eed
100006>>>>>>>        End
100006>>>>>>>>
100006>>>>>>>        
100006>>>>>>>        Forward Send OnIdle
100008>>>>>>>    End_Procedure
100009>>>>>>>    
100009>>>>>>>    Procedure OnStoreDefaults
100011>>>>>>>        Integer iVal
100011>>>>>>>        Boolean bVal
100011>>>>>>>        
100011>>>>>>>        Get pbAutoSeed to bVal
100012>>>>>>>        Set pbStoredAutoSeed to bVal
100013>>>>>>>        
100013>>>>>>>        Get pbAutoOrdering to bVal
100014>>>>>>>        Set pbStoredAutoOrdering to bVal
100015>>>>>>>        
100015>>>>>>>        Get pbAutoSearch to bVal
100016>>>>>>>        Set pbStoredAutoSearch to bVal
100017>>>>>>>        
100017>>>>>>>        Get peUpdateMode to iVal
100018>>>>>>>        Set peStoredUpdateMode to iVal
100019>>>>>>>        
100019>>>>>>>        Get piUpdateColumn to iVal
100020>>>>>>>        Set piStoredUpdateColumn to iVal
100021>>>>>>>        
100021>>>>>>>        Get piInitialColumn to iVal
100022>>>>>>>        Set piStoredInitialColumn to iVal
100023>>>>>>>        
100023>>>>>>>        Get phmPromptUpdateCallback to iVal
100024>>>>>>>        Set phmStoredPromptUpdateCallback to iVal
100025>>>>>>>        
100025>>>>>>>        Get pbSelectionEnable to bVal
100026>>>>>>>        Set pbStoredSelectionEnable to bVal
100027>>>>>>>        
100027>>>>>>>        Get pbMultipleSelection to bVal
100028>>>>>>>        Set pbStoredMultipleSelection to bVal
100029>>>>>>>        
100029>>>>>>>    End_Procedure
100030>>>>>>>    
100030>>>>>>>    Procedure OnRestoreDefaults
100032>>>>>>>        Integer iVal
100032>>>>>>>        Boolean bVal
100032>>>>>>>        
100032>>>>>>>        Get pbStoredAutoSeed to bVal
100033>>>>>>>        Set pbAutoSeed to bVal
100034>>>>>>>        
100034>>>>>>>        Get pbStoredAutoOrdering to bVal
100035>>>>>>>        Set pbAutoOrdering to bVal
100036>>>>>>>        
100036>>>>>>>        Get pbStoredAutoSearch to bVal
100037>>>>>>>        Set pbAutoSearch to bVal
100038>>>>>>>        
100038>>>>>>>        Get peStoredUpdateMode to iVal
100039>>>>>>>        Set peUpdateMode to iVal
100040>>>>>>>        
100040>>>>>>>        Get piStoredInitialColumn to iVal
100041>>>>>>>        Set piInitialColumn to iVal
100042>>>>>>>        
100042>>>>>>>        Get phmStoredPromptUpdateCallback to iVal
100043>>>>>>>        Set phmPromptUpdateCallback to iVal
100044>>>>>>>        
100044>>>>>>>        Get pbStoredSelectionEnable to bVal
100045>>>>>>>        Set pbSelectionEnable to bVal
100046>>>>>>>        
100046>>>>>>>        Get pbStoredMultipleSelection to bVal
100047>>>>>>>        Set pbMultipleSelection to bVal
100048>>>>>>>        
100048>>>>>>>    End_Procedure
100049>>>>>>>    
100049>>>>>>>    // finds the target seed value in the updatecolumn. If we autoseed and there is a
100049>>>>>>>    // seed value (psSeedValue), attempt to find GE that value, else move to first row
100049>>>>>>>    // Suitable for augmentation
100049>>>>>>>    Procedure OnSeedData
100051>>>>>>>        Integer iUpdateColumn iSortColumn
100051>>>>>>>        Boolean bSeed bAuto
100051>>>>>>>        String sValue
100051>>>>>>>        Handle hoCol
100051>>>>>>>        
100051>>>>>>>        Get piUpdateColumn to iUpdateColumn
100052>>>>>>>        Get psSeedValue to sValue
100053>>>>>>>        Get pbAutoSeed to bSeed
100054>>>>>>>        Get piSortColumn to iSortColumn
100055>>>>>>>        Get pbAutoOrdering to bAuto
100056>>>>>>>        // if not yet sorted and this is auto ordering we will
100056>>>>>>>        // sort the data for the search column. We do this to make the
100056>>>>>>>        // column search GE logic work properly.
100056>>>>>>>        If (bSeed and bAuto and iUpdateColumn<>-1 and iSortColumn<>iUpdateColumn) Begin
100058>>>>>>>            Get ColumnObject iUpdateColumn to hoCol
100059>>>>>>>            Send SortGridByColumn hoCol False
100060>>>>>>>        End
100060>>>>>>>>
100060>>>>>>>        
100060>>>>>>>        If (bSeed and sValue<>"" and iUpdateColumn<>-1) Begin
100062>>>>>>>            Send RequestFindColumnValue iUpdateColumn sValue True 0
100063>>>>>>>        End
100063>>>>>>>>
100063>>>>>>>        Else Begin
100064>>>>>>>            Send MovetoFirstRow
100065>>>>>>>        End
100065>>>>>>>>
100065>>>>>>>        
100065>>>>>>>    End_Procedure
100066>>>>>>>    
100066>>>>>>>    Procedure OnMoveValueOutByValue
100068>>>>>>>        String sValue
100068>>>>>>>        Handle hoInvokingObject hoCol  hoDataSource
100068>>>>>>>        Integer iRow iCol
100068>>>>>>>        Integer[] SelRowsIndexes
100069>>>>>>>        
100069>>>>>>>        Get phoInvokingObject to hoInvokingObject
100070>>>>>>>        Get pSelectedRows to SelRowsIndexes
100071>>>>>>>        If (SizeOfArray(SelRowsIndexes)>0) Begin
100073>>>>>>>            Get piUpdateColumn to iCol
100074>>>>>>>            Get ColumnObject iCol to hoCol
100075>>>>>>>            Get RowValue of hoCol SelRowsIndexes[0] to sValue
100076>>>>>>>            Set Value of hoInvokingObject to sValue
100077>>>>>>>            Set Item_Changed_State of hoInvokingObject to True
100078>>>>>>>        End
100078>>>>>>>>
100078>>>>>>>    End_Procedure
100079>>>>>>>    
100079>>>>>>>    Procedure OnMoveValueOutByCustom
100081>>>>>>>    End_Procedure
100082>>>>>>>    
100082>>>>>>>    // augment to popup a search window when allowed
100082>>>>>>>    Procedure OnComKeyDown Short ByRef llKeyCode Short llShift
100084>>>>>>>        Boolean bSubFocus bAutoSearch bChar
100084>>>>>>>        Integer iVal
100084>>>>>>>        
100084>>>>>>>        Get pbFocusSubItems to bSubFocus
100085>>>>>>>        Get pbAutoSearch to bAutoSearch
100086>>>>>>>        Forward Send OnComKeyDown llKeyCode llShift
100088>>>>>>>        If (bAutoSearch and not(bSubFocus)) Begin
100090>>>>>>>            If ((llShift iand 6)=0) Begin // skip alt and ctrl
100092>>>>>>>                Get GetVKeyToAnsi llKeyCode llShift to iVal
100093>>>>>>>                Move (iVal<>0) to bChar
100094>>>>>>>            End
100094>>>>>>>>
100094>>>>>>>            If bChar Begin
100096>>>>>>>                // this can get called multiple times before a search dialog pops up
100096>>>>>>>                Send AddToSearchKeys llKeyCode llShift
100097>>>>>>>            End
100097>>>>>>>>
100097>>>>>>>        End
100097>>>>>>>>
100097>>>>>>>    End_Procedure
100098>>>>>>>    
100098>>>>>>>    Procedure OnComRequestEdit Variant llRow Variant llColumn Variant llItem Boolean ByRef llCancel
100100>>>>>>>        Boolean bAutoSearch
100100>>>>>>>        Integer iKeyCode iShiftCode
100100>>>>>>>        Get pbAutoSearch to bAutoSearch
100101>>>>>>>        If bAutoSearch Begin
100103>>>>>>>            // this can get called multiple times before a search dialog pops up
100103>>>>>>>            Get piLastKey to iKeyCode
100104>>>>>>>            Get piLastKey2 to iShiftCode
100105>>>>>>>            Send AddToSearchKeys iKeyCode iShiftCode
100106>>>>>>>        End
100106>>>>>>>>
100106>>>>>>>        Move True to llCancel
100107>>>>>>>    End_Procedure
100108>>>>>>>    
100108>>>>>>>    Procedure OnComRowDblClick Variant llRow Variant llItem
100110>>>>>>>        Send ClearSearchRequest // kill any deferred search popup
100111>>>>>>>        Forward Send OnComRowDblClick llRow llItem
100113>>>>>>>    End_Procedure
100114>>>>>>>    
100114>>>>>>>    Procedure OnRowDoubleClick Integer iRow Integer iCol
100116>>>>>>>        Send Ok
100117>>>>>>>    End_Procedure
100118>>>>>>>    
100118>>>>>>>    
100118>>>>>>>    // we don't want a menu for prompt lists
100118>>>>>>>    Function CreateContextMenu Returns Handle
100120>>>>>>>        Function_Return 0
100121>>>>>>>    End_Function
100122>>>>>>>    
100122>>>>>>>    // if we use auto-ordering, change the order when the column changes
100122>>>>>>>    Procedure ColumnChanged Integer iOld Integer iNew
100124>>>>>>>        Boolean bAutoOrder
100124>>>>>>>        Forward Send ColumnChanged iOld iNew
100126>>>>>>>        Get pbAutoOrdering to bAutoOrder
100127>>>>>>>        If bAutoOrder Begin
100129>>>>>>>            // will be reordered in idle event
100129>>>>>>>            Set pbNeedsNewOrdering to True
100130>>>>>>>        End
100130>>>>>>>>
100130>>>>>>>    End_Procedure
100131>>>>>>>    
100131>>>>>>>    
100131>>>>>>>    Procedure Add_Focus Handle hoParent Returns Integer
100133>>>>>>>        Integer eMode
100133>>>>>>>        Integer[] SelRowsIndexes
100134>>>>>>>        Set pbCanceled to True // assume cancel unless changed
100135>>>>>>>        Set pSelectedRows to SelRowsIndexes // empty
100136>>>>>>>        Get peUpdateMode to eMode
100137>>>>>>>        If (eMode<>umPromptNonInvoking) Begin
100139>>>>>>>            Send OnStoreDefaults
100140>>>>>>>        End
100140>>>>>>>>
100140>>>>>>>        Send InitializePromptList
100141>>>>>>>        Forward Send Add_Focus hoParent
100143>>>>>>>        Send LoadData
100144>>>>>>>        Set psSeedValue to ""
100145>>>>>>>    End_Procedure
100146>>>>>>>    
100146>>>>>>>    // called before the list is activated.
100146>>>>>>>    Procedure InitializePromptList
100148>>>>>>>        Integer hoInvokingObject
100148>>>>>>>        Boolean bAutoColumn bAutoSeed
100148>>>>>>>        Integer i iOldMode eUpdateMode
100148>>>>>>>        String sValue
100148>>>>>>>        
100148>>>>>>>        Get peUpdateMode to eUpdateMode
100149>>>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
100151>>>>>>>            Get Focus of Desktop to hoInvokingObject
100152>>>>>>>            If (hoInvokingObject<=Desktop) Begin
100154>>>>>>>                Error DFERR_PROGRAM "Prompt list has no invoking object"
100155>>>>>>>>
100155>>>>>>>                Procedure_Return
100156>>>>>>>            End
100156>>>>>>>>
100156>>>>>>>            
100156>>>>>>>            Set phoInvokingObject to hoInvokingObject
100157>>>>>>>            
100157>>>>>>>            Send Prompt_Callback to hoInvokingObject Self
100158>>>>>>>            Get peUpdateMode to eUpdateMode
100159>>>>>>>        End
100159>>>>>>>>
100159>>>>>>>        
100159>>>>>>>        Send ClearSearchRequest // clear the search keys
100160>>>>>>>        Set pbNeedsNewOrdering to False
100161>>>>>>>        
100161>>>>>>>        Get pbAutoSeed to bAutoSeed
100162>>>>>>>        
100162>>>>>>>        If (eUpdateMode=umPromptValue) Begin // else not used here intentionally
100164>>>>>>>            Get Value of hoInvokingObject to sValue
100165>>>>>>>            Set psSeedValue to sValue
100166>>>>>>>        End
100166>>>>>>>>
100166>>>>>>>        
100166>>>>>>>    End_Procedure
100167>>>>>>>    
100167>>>>>>>    // called after list is created and active. Load Data, seed list, select start column, etc.
100167>>>>>>>    Procedure LoadData
100169>>>>>>>        Handle hoInvokingObject hoDataSource hoInitialColumn
100169>>>>>>>        Integer iUpdateColumn iRows iInitialColumn iInitialOrder
100169>>>>>>>        Integer eUpdateMode
100169>>>>>>>        Boolean bAutoSeed bAutoColumn bCancel bSubFocus bAutoOrder
100169>>>>>>>        
100169>>>>>>>        Get phoDataSource to hoDataSource
100170>>>>>>>        Get peUpdateMode to eUpdateMode
100171>>>>>>>        Get phoInvokingObject to hoInvokingObject
100172>>>>>>>        Get pbAutoSeed to bAutoSeed
100173>>>>>>>        Get piInitialColumn to iInitialColumn
100174>>>>>>>        Get piUpdateColumn to iUpdateColumn
100175>>>>>>>        Get RowCount of hoDataSource to iRows
100176>>>>>>>        
100176>>>>>>>        // We need an initial column. if you specified an initial column that will get used for the start column
100176>>>>>>>        // and the initial sort order. If you did not, which is typical, it will use the update column
100176>>>>>>>        If (iInitialColumn=-1) Begin
100178>>>>>>>            Move iUpdateColumn to iInitialColumn
100179>>>>>>>        End
100179>>>>>>>>
100179>>>>>>>        If (iInitialColumn>=0) Begin
100181>>>>>>>            Get ColumnObject iInitialColumn to hoInitialColumn
100182>>>>>>>            Set pbVisible of hoInitialColumn to True // initial column should be visible
100183>>>>>>>        End
100183>>>>>>>>
100183>>>>>>>        Send OnSeedData // find a good starting place for the row
100184>>>>>>>        Get pbFocusSubItems to bSubFocus
100185>>>>>>>        If bSubFocus Begin
100187>>>>>>>            // if column focus, which is normal, go to initialcolumn
100187>>>>>>>            If hoInitialColumn Begin
100189>>>>>>>                Get MoveToColumnObject hoInitialColumn to bCancel
100190>>>>>>>            End
100190>>>>>>>>
100190>>>>>>>            Else Begin
100191>>>>>>>                Send MoveToFirstEnterableColumn
100192>>>>>>>            End
100192>>>>>>>>
100192>>>>>>>        End
100192>>>>>>>>
100192>>>>>>>        
100192>>>>>>>    End_Procedure
100193>>>>>>>    
100193>>>>>>>    // This is only called in a successful close
100193>>>>>>>    Procedure ClosePromptList
100195>>>>>>>        Handle hoDataSource hoInvokingObject
100195>>>>>>>        Handle hmCallBack
100195>>>>>>>        Integer iRow eUpdateMode
100195>>>>>>>        Integer[] SelRowsIndexes
100196>>>>>>>        
100196>>>>>>>        Get phoDataSource to hoDataSource
100197>>>>>>>        Get phoInvokingObject to hoInvokingObject
100198>>>>>>>        
100198>>>>>>>        If (pbMultipleSelection(Self)) Begin
100200>>>>>>>            Get GetIndexesForSelectedRows to SelRowsIndexes
100201>>>>>>>        End
100201>>>>>>>>
100201>>>>>>>        Else Begin
100202>>>>>>>            Get SelectedRow of hoDataSource to iRow
100203>>>>>>>            If (iRow<>-1) Begin
100205>>>>>>>                Move iRow to SelRowsIndexes[0]
100206>>>>>>>            End
100206>>>>>>>>
100206>>>>>>>        End
100206>>>>>>>>
100206>>>>>>>        
100206>>>>>>>        Set pbCanceled to False
100207>>>>>>>        Set pSelectedRows to SelRowsIndexes
100208>>>>>>>        
100208>>>>>>>        Get peUpdateMode to eUpdateMode
100209>>>>>>>        // if non-invoking there is by definition, no move value out
100209>>>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
100211>>>>>>>            
100211>>>>>>>            If (eUpdateMode=umPromptValue) Begin
100213>>>>>>>                Send OnMoveValueOutByValue
100214>>>>>>>            End
100214>>>>>>>>
100214>>>>>>>            Else If (eUpdateMode=umPromptCustom) Begin
100217>>>>>>>                Send OnMoveValueOutByCustom
100218>>>>>>>            End
100218>>>>>>>>
100218>>>>>>>            Get phmPromptUpdateCallback to hmCallBack
100219>>>>>>>            If hmCallBack Begin
100221>>>>>>>                Send hmCallBack of hoInvokingObject Self
100222>>>>>>>            End
100222>>>>>>>>
100222>>>>>>>        End
100222>>>>>>>>
100222>>>>>>>        
100222>>>>>>>        Send Close_Panel
100223>>>>>>>    End_Procedure
100224>>>>>>>    
100224>>>>>>>    // augment to send OnRestoreDefaults.
100224>>>>>>>    Procedure Release_Focus
100226>>>>>>>        Integer eUpdateMode
100226>>>>>>>        Get peUpdateMode to eUpdateMode
100227>>>>>>>        Forward Send Release_Focus
100229>>>>>>>        If (eUpdateMode<>umPromptNonInvoking) Begin
100231>>>>>>>            Send OnRestoreDefaults
100232>>>>>>>        End
100232>>>>>>>>
100232>>>>>>>    End_Procedure
100233>>>>>>>    
100233>>>>>>>    Function SelectedRowIds Returns RowID[]
100235>>>>>>>        RowID[] SelectedRowids
100236>>>>>>>        Integer[] SelectedRows
100237>>>>>>>        Integer i iRows
100237>>>>>>>        Handle hoDataSource
100237>>>>>>>        Get phoDataSource to hoDataSource
100238>>>>>>>        Get pSelectedRows to SelectedRows
100239>>>>>>>        Move (SizeOfArray(SelectedRows)) to iRows
100240>>>>>>>        For i from 0 to (iRows-1)
100246>>>>>>>>
100246>>>>>>>            Get RowTag of hoDataSource SelectedRows[i] to SelectedRowIds[i]
100247>>>>>>>        Loop
100248>>>>>>>>
100248>>>>>>>        Function_Return SelectedRowids
100249>>>>>>>    End_Function
100250>>>>>>>    
100250>>>>>>>    Function SelectedColumnValues Integer iCol Returns String[]
100252>>>>>>>        String[] SelectedValues
100253>>>>>>>        Integer[] SelectedRows
100254>>>>>>>        Integer i iRows
100254>>>>>>>        Handle hoCol
100254>>>>>>>        Get ColumnObject iCol to hoCol
100255>>>>>>>        Get pSelectedRows to SelectedRows
100256>>>>>>>        Move (SizeOfArray(SelectedRows)) to iRows
100257>>>>>>>        For i from 0 to (iRows-1)
100263>>>>>>>>
100263>>>>>>>            Get RowValue of hoCol SelectedRows[i] to SelectedValues[i]
100264>>>>>>>        Loop
100265>>>>>>>>
100265>>>>>>>        Function_Return SelectedValues
100266>>>>>>>    End_Function
100267>>>>>>>    
100267>>>>>>>    Procedure Ok Returns Integer
100269>>>>>>>        Send ClosePromptList
100270>>>>>>>    End_Procedure
100271>>>>>>>    
100271>>>>>>>    Procedure Cancel Returns Integer
100273>>>>>>>        Send Close_Panel
100274>>>>>>>    End_Procedure
100275>>>>>>>    
100275>>>>>>>    Procedure Search
100277>>>>>>>        Send Activate // give focus back to list so focus things are correct
100278>>>>>>>        Send Request_Search 0 0
100279>>>>>>>    End_Procedure
100280>>>>>>>    
100280>>>>>>>    // do a search using the current keys in the search key buffer for the sort column.
100280>>>>>>>    // Becaue this is called via an OnIdle it is possible to have multiple keys pressed before
100280>>>>>>>    // the OnIdle. These have been stored in pSearchKeys and will be passed to the popup dialog
100280>>>>>>>    Procedure Request_SearchEx
100282>>>>>>>        tGridKeyPair[] Keys
100282>>>>>>>        tGridKeyPair[] Keys
100283>>>>>>>        Integer iCol
100283>>>>>>>        Handle hoCol hoSearchDialog
100283>>>>>>>        Boolean bOk
100283>>>>>>>        String sValue
100283>>>>>>>        
100283>>>>>>>        Get piSortColumn to iCol
100284>>>>>>>        If (iCol<>-1) Begin
100286>>>>>>>            Get ColumnObject iCol to hoCol
100287>>>>>>>            Get pSearchKeys to Keys
100288>>>>>>>            Get CreateGridSearchDialogObject to hoSearchDialog
100289>>>>>>>            Get RequestGridSearchEx of hoSearchDialog Keys hoCol (&sValue) to bOk
100290>>>>>>>            If bOk Begin
100292>>>>>>>                Send RequestFindColumnValue iCol sValue True 0
100293>>>>>>>            End
100293>>>>>>>>
100293>>>>>>>            Send Destroy of hoSearchDialog
100294>>>>>>>        End
100294>>>>>>>>
100294>>>>>>>        Send ClearSearchRequest // clear the search keys
100295>>>>>>>    End_Procedure
100296>>>>>>>    
100296>>>>>>>    // set pbRequestSearch to true and add the keys to the search buffer.
100296>>>>>>>    Procedure AddToSearchKeys Integer iKeyCode Integer iShiftCode
100298>>>>>>>        tGridKeyPair[] Keys
100298>>>>>>>        tGridKeyPair[] Keys
100299>>>>>>>        tGridKeyPair KeyPair
100299>>>>>>>        tGridKeyPair KeyPair
100299>>>>>>>        Set pbRequestSearch to True
100300>>>>>>>        Move iKeyCode to KeyPair.KeyCode
100301>>>>>>>        Move iShiftCode to KeyPair.ShiftCode
100302>>>>>>>        Get pSearchKeys to Keys
100303>>>>>>>        Move KeyPair to Keys[SizeOfArray(Keys)]
100304>>>>>>>        Set pSearchKeys to Keys
100305>>>>>>>    End_Procedure
100306>>>>>>>    
100306>>>>>>>    Procedure ClearSearchRequest
100308>>>>>>>        tGridKeyPair[] SearchKeys
100308>>>>>>>        tGridKeyPair[] SearchKeys
100309>>>>>>>        Set pSearchKeys to SearchKeys
100310>>>>>>>        Set pbRequestSearch to False
100311>>>>>>>    End_Procedure
100312>>>>>>>    
100312>>>>>>>End_Class
100313>>>>>>>
100313>>>>>Use cDbUpdateFunctionLibrary.pkg
100313>>>>>Use MSSqldrv.pkg
100313>>>>>Use db2_drv.pkg
100313>>>>>Use odbc_drv.pkg
100313>>>>>Use cRDCModalPanel.pkg
Including file: cRDCModalPanel.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\DFAbout\cRDCModalPanel.pkg)
100313>>>>>>>//****************************************************************************
100313>>>>>>>// $Module type: Class
100313>>>>>>>// $Module name: cRDCModalPanel
100313>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International
100313>>>>>>>// Created     : 2014-03-17 @ 12:33
100313>>>>>>>//
100313>>>>>>>// Description :
100313>>>>>>>//
100313>>>>>>>// $Rev History:
100313>>>>>>>//    2014-03-17  Module header created
100313>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
100313>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
100313>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
100313>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
100313>>>>>>>// in the help folder for more details.
100313>>>>>>>//
100313>>>>>>>//****************************************************************************
100313>>>>>>>Use Windows.pkg
100313>>>>>>>Use cCJCommandBarSystem.pkg   
100313>>>>>>>Use cCJSkinFramework.pkg
100313>>>>>>>
100313>>>>>>>Class cRDCModalPanel is a ModalPanel
100314>>>>>>>
100314>>>>>>>    Procedure Construct_Object
100316>>>>>>>        Forward Send Construct_Object
100318>>>>>>>
100318>>>>>>>        Set Maximize_Icon to True
100319>>>>>>>        Set Minimize_Icon to False
100320>>>>>>>        Set Border_Style to Border_Thick
100321>>>>>>>        Set Locate_Mode to Center_On_Parent
100322>>>>>>>
100322>>>>>>>        Property String Private_Icon
100323>>>>>>>        Property Handle phoDialogCommandbar
100324>>>>>>>    End_Procedure
100325>>>>>>>
100325>>>>>>>    Procedure Set Icon String sIcon
100327>>>>>>>        Forward Set Icon to sIcon
100329>>>>>>>        Set Private_Icon to sIcon
100330>>>>>>>    End_Procedure
100331>>>>>>>
100331>>>>>>>    Function Icon Returns String
100333>>>>>>>        String sIcon
100333>>>>>>>        Get Private_Icon to sIcon
100334>>>>>>>        Function_Return sIcon
100335>>>>>>>    End_Function
100336>>>>>>>
100336>>>>>>>    Procedure Page Integer iPageObject
100338>>>>>>>        String sIcon
100338>>>>>>>        Integer hWnd
100338>>>>>>>        
100338>>>>>>>        Forward Send Page iPageObject
100340>>>>>>>        Get Private_Icon to sIcon
100341>>>>>>>        If (sIcon <> "") Begin
100343>>>>>>>            Set Icon to sIcon
100344>>>>>>>        End
100344>>>>>>>>
100344>>>>>>>
100344>>>>>>>        Get Window_Handle to hWnd
100345>>>>>>>
100345>>>>>>>        If ((ghoSkinFramework <> 0) and (hWnd <> 0)) Begin
100347>>>>>>>            Send ComRemoveWindow to ghoSkinFramework hWnd
100348>>>>>>>            Send ComApplyWindow  to ghoSkinFramework hWnd
100349>>>>>>>        End
100349>>>>>>>>
100349>>>>>>>    End_Procedure
100350>>>>>>>
100350>>>>>>>    // Put a status bar at the bottom of the panel, which makes
100350>>>>>>>    // status_help work and puts a gripper in the lower right corner.
100350>>>>>>>    Procedure End_Construct_Object
100352>>>>>>>        Integer iStyle iSize iOffset
100352>>>>>>>
100352>>>>>>>        Forward Send End_Construct_Object
100354>>>>>>>
100354>>>>>>>        Get Border_Style to iStyle
100355>>>>>>>        Move 8 to iOffset
100356>>>>>>>        If (iStyle = Border_Thick) Begin
100358>>>>>>>            Object oDialogCommandbar is a cCJCommandBarSystem
100360>>>>>>>                Object oStatusBar is a cCJStatusBar
100362>>>>>>>                    Set phoDialogCommandbar to Self
100363>>>>>>>                    Object oStatusIdle is a cCJStatusBarPane
100365>>>>>>>                        Set piId to sbpIDIdlePane
100366>>>>>>>                        Set pbStyleStretch to True
100367>>>>>>>                    End_Object
100368>>>>>>>                End_Object
100369>>>>>>>            End_Object
100370>>>>>>>            Get Size to iSize
100371>>>>>>>            Set Size to (Hi(iSize) + iOffset) (Low(iSize))
100372>>>>>>>            Set piMinSize to (Hi(iSize) + iOffset) (Low(iSize))
100373>>>>>>>        End
100373>>>>>>>>
100373>>>>>>>
100373>>>>>>>    End_Procedure
100374>>>>>>>
100374>>>>>>>    Procedure Popup
100376>>>>>>>        Set Statusbar_Id to (phoDialogCommandbar(Self))
100377>>>>>>>        Forward Send Popup
100379>>>>>>>    End_Procedure
100380>>>>>>>
100380>>>>>>>End_Class
100381>>>>>
100381>>>>>Object oDatabaseSelection_sl is a cRDCModalPanel
100383>>>>>    Set Label to "SQL Database Selection"
100384>>>>>    Set Size to 119 183
100385>>>>>    Set piMinSize to 89 170
100386>>>>>    Set Location to 2 2
100387>>>>>    Set Border_Style to Border_Thick
100388>>>>>    Set Icon to "DatabaseLookup1.ico"
100389>>>>>
100389>>>>>    Property String[] psTheData
100391>>>>>
100391>>>>>    If (ghoDbUpdateFunctionLibrary = 0) Begin
100393>>>>>        Object oDbUpateFunctionLibrary is a cDbUpdateFunctionLibrary
100395>>>>>        End_Object
100396>>>>>    End
100396>>>>>>
100396>>>>>
100396>>>>>    Object oSelList is a cCJGridPromptList
100398>>>>>        Set Size to 89 167
100399>>>>>        Set Location to 6 6
100400>>>>>        Set peAnchors to anAll
100401>>>>>        Set pbAllowColumnRemove to False
100402>>>>>        Set pbUseAlternateRowBackgroundColor to True
100403>>>>>        Set pbGrayIfDisable to False
100404>>>>>        Set pbHeaderReorders to False
100405>>>>>        Set pbHeaderSelectsColumn to False
100406>>>>>        Set pbHeaderTogglesDirection to False
100407>>>>>        Set pbShadeSortColumn to False
100408>>>>>        Set piFocusCellBackColor to clDkGray
100409>>>>>
100409>>>>>        Object oName is a cCJGridColumn
100411>>>>>            Set piWidth to 334
100412>>>>>            Set psCaption to "Database Name"
100413>>>>>        End_Object
100414>>>>>
100414>>>>>        Procedure Activating
100417>>>>>            tDataSourceRow[] MyData
100417>>>>>            tDataSourceRow[] MyData
100418>>>>>            Handle hoDataSource
100418>>>>>            String[] sTheData
100419>>>>>            Integer iCount iSize
100419>>>>>
100419>>>>>            Send Cursor_Wait of Cursor_Control
100420>>>>>            Forward Send Activating
100422>>>>>
100422>>>>>            Get psTheData to sTheData
100423>>>>>            Move (SizeOfArray(sTheData)) to iSize
100424>>>>>            Decrement iSize
100425>>>>>            For iCount from 0 to iSize
100431>>>>>>
100431>>>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
100432>>>>>            Loop
100433>>>>>>
100433>>>>>
100433>>>>>            Get phoDataSource to hoDataSource
100434>>>>>            Send InitializeData of hoDataSource MyData
100435>>>>>            Send Cursor_Ready of Cursor_Control
100436>>>>>        End_Procedure
100437>>>>>
100437>>>>>    End_Object
100438>>>>>
100438>>>>>    Object oOK_Btn is a Button
100440>>>>>        Set Size to 14 50
100441>>>>>        Set Label    to "&OK"
100442>>>>>        Set Location to 98 68
100443>>>>>        Set peAnchors To anBottomRight
100444>>>>>
100444>>>>>        Procedure OnClick
100447>>>>>            Send Ok of oSelList
100448>>>>>        End_Procedure
100449>>>>>
100449>>>>>    End_Object
100450>>>>>
100450>>>>>    Object oCancel_Btn is a Button
100452>>>>>        Set Size to 14 50
100453>>>>>        Set Label    to "&Cancel"
100454>>>>>        Set Location to 98 123
100455>>>>>        Set peAnchors to anBottomRight
100456>>>>>
100456>>>>>        Procedure OnClick
100459>>>>>            Send Close_Panel
100460>>>>>        End_Procedure
100461>>>>>
100461>>>>>    End_Object
100462>>>>>
100462>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
100463>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
100464>>>>>End_Object
100465>>>Use ServerSelection.dg
Including file: ServerSelection.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ServerSelection.dg)
100465>>>>>Use Windows.pkg
100465>>>>>Use cCJGridPromptList.pkg
100465>>>>>Use MSSqldrv.pkg
100465>>>>>Use db2_drv.pkg
100465>>>>>Use odbc_drv.pkg    
100465>>>>>Use cRDCModalPanel.pkg
100465>>>>>Use cDbUpdateFunctionLibrary.pkg
100465>>>>>
100465>>>>>Object oServerSelection_sl is a cRDCModalPanel
100467>>>>>    Set Size to 105 225
100468>>>>>    Set Label to "Database Server/DSN Selection"
100469>>>>>    Set piMinSize to 89 211
100470>>>>>    Set Location to 2 2
100471>>>>>    Set Icon to "ServerLookup1.ico"
100472>>>>>
100472>>>>>    Property String[] psTheData
100474>>>>>
100474>>>>>    Object oSelList is a cCJGridPromptList
100476>>>>>        Set Size to 72 215
100477>>>>>        Set Location to 6 6
100478>>>>>        Set peAnchors to anAll
100479>>>>>        Set pbAllowColumnRemove to False
100480>>>>>        Set pbUseAlternateRowBackgroundColor to True
100481>>>>>        Set pbGrayIfDisable to False
100482>>>>>        Set pbHeaderReorders to False
100483>>>>>        Set pbHeaderSelectsColumn to False
100484>>>>>        Set pbHeaderTogglesDirection to False
100485>>>>>        Set pbShadeSortColumn to False
100486>>>>>        Set piFocusCellBackColor to clDkGray
100487>>>>>
100487>>>>>        Object oName is a cCJGridColumn
100489>>>>>            Set piWidth to 358
100490>>>>>            Set psCaption to "Name"
100491>>>>>        End_Object
100492>>>>>
100492>>>>>        Procedure Activating
100495>>>>>            tDataSourceRow[] MyData
100495>>>>>            tDataSourceRow[] MyData
100496>>>>>            Handle hoDataSource
100496>>>>>            String[] sTheData
100497>>>>>            Integer iCount iSize
100497>>>>>
100497>>>>>            Send Cursor_Wait of Cursor_Control
100498>>>>>            Get psTheData to sTheData
100499>>>>>            Move (SizeOfArray(sTheData)) to iSize
100500>>>>>            Decrement iSize
100501>>>>>            For iCount from 0 to iSize
100507>>>>>>
100507>>>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
100508>>>>>            Loop
100509>>>>>>
100509>>>>>
100509>>>>>            Forward Send Activating
100511>>>>>
100511>>>>>            Get phoDataSource to hoDataSource
100512>>>>>            Send InitializeData of hoDataSource MyData
100513>>>>>            Send Cursor_Ready of Cursor_Control
100514>>>>>        End_Procedure
100515>>>>>
100515>>>>>    End_Object
100516>>>>>
100516>>>>>    Object oOK_Btn is a Button
100518>>>>>        Set Size to 14 50
100519>>>>>        Set Label    to "&OK"
100520>>>>>        Set Location to 85 116
100521>>>>>        Set peAnchors To anBottomRight
100522>>>>>
100522>>>>>        Procedure OnClick
100525>>>>>            Send Ok of oSelList
100526>>>>>        End_Procedure
100527>>>>>
100527>>>>>    End_Object
100528>>>>>
100528>>>>>    Object oCancel_Btn is a Button
100530>>>>>        Set Size to 14 50
100531>>>>>        Set Label    to "&Cancel"
100532>>>>>        Set Location to 85 171
100533>>>>>        Set peAnchors to anBottomRight
100534>>>>>
100534>>>>>        Procedure OnClick
100537>>>>>            Send Close_Panel
100538>>>>>        End_Procedure
100539>>>>>
100539>>>>>    End_Object
100540>>>>>
100540>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
100541>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
100542>>>>>End_Object
100543>>>Use TableSpaceSelection.dg
Including file: TableSpaceSelection.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\TableSpaceSelection.dg)
100543>>>>>Use Windows.pkg
100543>>>>>Use cCJGridPromptList.pkg     
100543>>>>>Use cRDCModalPanel.pkg
100543>>>>>Use cDbUpdateFunctionLibrary.pkg
100543>>>>>
100543>>>>>Object oTableSpaceSelection_sl is a cRDCModalPanel
100545>>>>>    Set Size to 118 177
100546>>>>>    Set Label to "SQL Tablespace Selection"
100547>>>>>    Set piMinSize to 89 177
100548>>>>>    Set Location to 2 2
100549>>>>>    Set Icon to "DatabaseLookup1.ico"
100550>>>>>
100550>>>>>    Property String[] psTheData
100552>>>>>
100552>>>>>    If (ghoDbUpdateFunctionLibrary = 0) Begin
100554>>>>>        Object oDbUpateFunctionLibrary is a cDbUpdateFunctionLibrary
100556>>>>>        End_Object
100557>>>>>    End
100557>>>>>>
100557>>>>>
100557>>>>>    Object oSelList is a cCJGridPromptList
100559>>>>>        Set Size to 89 167
100560>>>>>        Set Location to 6 6
100561>>>>>        Set peAnchors to anAll
100562>>>>>        Set pbAllowColumnRemove to False
100563>>>>>        Set pbUseAlternateRowBackgroundColor to True
100564>>>>>        Set pbGrayIfDisable to False
100565>>>>>        Set pbHeaderReorders to False
100566>>>>>        Set pbHeaderSelectsColumn to False
100567>>>>>        Set pbHeaderTogglesDirection to False
100568>>>>>        Set pbShadeSortColumn to False
100569>>>>>        Set piFocusCellBackColor to clDkGray
100570>>>>>
100570>>>>>        Object oName is a cCJGridColumn
100572>>>>>            Set piWidth to 334
100573>>>>>            Set psCaption to "Table Space Name"
100574>>>>>        End_Object
100575>>>>>
100575>>>>>        Procedure Activating
100578>>>>>            tDataSourceRow[] MyData
100578>>>>>            tDataSourceRow[] MyData
100579>>>>>            Handle hoDataSource
100579>>>>>            String[] sTheData
100580>>>>>            Integer iCount iSize
100580>>>>>
100580>>>>>            Send Cursor_Wait of Cursor_Control
100581>>>>>            Forward Send Activating
100583>>>>>
100583>>>>>            Get psTheData to sTheData
100584>>>>>            Move (SizeOfArray(sTheData)) to iSize
100585>>>>>            Decrement iSize
100586>>>>>            For iCount from 0 to iSize
100592>>>>>>
100592>>>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
100593>>>>>            Loop
100594>>>>>>
100594>>>>>
100594>>>>>            Get phoDataSource to hoDataSource
100595>>>>>            Send InitializeData of hoDataSource MyData
100596>>>>>            Send Cursor_Ready of Cursor_Control
100597>>>>>        End_Procedure
100598>>>>>
100598>>>>>    End_Object
100599>>>>>
100599>>>>>    Object oOK_Btn is a Button
100601>>>>>        Set Size to 14 50
100602>>>>>        Set Label    to "&OK"
100603>>>>>        Set Location to 98 68
100604>>>>>        Set peAnchors To anBottomRight
100605>>>>>
100605>>>>>        Procedure OnClick
100608>>>>>            Send Ok of oSelList
100609>>>>>        End_Procedure
100610>>>>>
100610>>>>>    End_Object
100611>>>>>
100611>>>>>    Object oCancel_Btn is a Button
100613>>>>>        Set Size to 14 50
100614>>>>>        Set Label    to "&Cancel"
100615>>>>>        Set Location to 98 123
100616>>>>>        Set peAnchors to anBottomRight
100617>>>>>
100617>>>>>        Procedure OnClick
100620>>>>>            Send Close_Panel
100621>>>>>        End_Procedure
100622>>>>>
100622>>>>>    End_Object
100623>>>>>
100623>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
100624>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
100625>>>>>End_Object
100626>>>Use SchemasSelection.dg
Including file: SchemasSelection.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\SchemasSelection.dg)
100626>>>>>Use Windows.pkg
100626>>>>>Use cCJGridPromptList.pkg  
100626>>>>>Use cRDCModalPanel.pkg
100626>>>>>Use cDbUpdateFunctionLibrary.pkg
100626>>>>>
100626>>>>>Object oSchemasSelection_sl is a cRDCModalPanel
100628>>>>>    Set Size to 118 177
100629>>>>>    Set Label to "SQL Schemas Selection"
100630>>>>>    Set piMinSize to 89 177
100631>>>>>    Set Location to 2 2
100632>>>>>    Set Icon to "DatabaseLookup1.ico"
100633>>>>>
100633>>>>>    Property String[] psTheData
100635>>>>>
100635>>>>>    If (ghoDbUpdateFunctionLibrary = 0) Begin
100637>>>>>        Object oDbUpateFunctionLibrary is a cDbUpdateFunctionLibrary
100639>>>>>        End_Object
100640>>>>>    End
100640>>>>>>
100640>>>>>
100640>>>>>    Object oSelList is a cCJGridPromptList
100642>>>>>        Set Size to 89 167
100643>>>>>        Set Location to 6 6
100644>>>>>        Set peAnchors to anAll
100645>>>>>        Set pbAllowColumnRemove to False
100646>>>>>        Set pbUseAlternateRowBackgroundColor to True
100647>>>>>        Set pbGrayIfDisable to False
100648>>>>>        Set pbHeaderReorders to False
100649>>>>>        Set pbHeaderSelectsColumn to False
100650>>>>>        Set pbHeaderTogglesDirection to False
100651>>>>>        Set pbShadeSortColumn to False
100652>>>>>        Set piFocusCellBackColor to clDkGray
100653>>>>>
100653>>>>>        Object oName is a cCJGridColumn
100655>>>>>            Set piWidth to 334
100656>>>>>            Set psCaption to "Schema Name"
100657>>>>>        End_Object
100658>>>>>
100658>>>>>        Procedure Activating
100661>>>>>            tDataSourceRow[] MyData
100661>>>>>            tDataSourceRow[] MyData
100662>>>>>            Handle hoDataSource
100662>>>>>            String[] sTheData
100663>>>>>            Integer iCount iSize
100663>>>>>
100663>>>>>            Send Cursor_Wait of Cursor_Control
100664>>>>>            Forward Send Activating
100666>>>>>
100666>>>>>            Get psTheData to sTheData
100667>>>>>
100667>>>>>            Move (SizeOfArray(sTheData)) to iSize
100668>>>>>            Decrement iSize
100669>>>>>            For iCount from 0 to iSize
100675>>>>>>
100675>>>>>                Move sTheData[iCount] to MyData[iCount].sValue[0]
100676>>>>>            Loop
100677>>>>>>
100677>>>>>
100677>>>>>            Get phoDataSource to hoDataSource
100678>>>>>            Send InitializeData of hoDataSource MyData
100679>>>>>            Send Cursor_Ready of Cursor_Control
100680>>>>>        End_Procedure
100681>>>>>
100681>>>>>    End_Object
100682>>>>>
100682>>>>>    Object oOK_Btn is a Button
100684>>>>>        Set Size to 14 50
100685>>>>>        Set Label    to "&OK"
100686>>>>>        Set Location to 98 68
100687>>>>>        Set peAnchors To anBottomRight
100688>>>>>
100688>>>>>        Procedure OnClick
100691>>>>>            Send Ok of oSelList
100692>>>>>        End_Procedure
100693>>>>>
100693>>>>>    End_Object
100694>>>>>
100694>>>>>    Object oCancel_Btn is a Button
100696>>>>>        Set Size to 14 50
100697>>>>>        Set Label    to "&Cancel"
100698>>>>>        Set Location to 98 123
100699>>>>>        Set peAnchors to anBottomRight
100700>>>>>
100700>>>>>        Procedure OnClick
100703>>>>>            Send Close_Panel
100704>>>>>        End_Procedure
100705>>>>>
100705>>>>>    End_Object
100706>>>>>
100706>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
100707>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
100708>>>>>End_Object
100709>>>Use cRDCHeaderGroup.pkg  
Including file: cRDCHeaderGroup.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cRDCHeaderGroup.pkg)
100709>>>>>//****************************************************************************
100709>>>>>// $Module type: Package
100709>>>>>// $Module name: cRDCHeaderGroup.pkg
100709>>>>>//
100709>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
100709>>>>>// Copyright (c) 2017 RDC Tools International
100709>>>>>// E-mail      : support@rdctools.com
100709>>>>>// Web-site    : http://www.rdctools.com
100709>>>>>//
100709>>>>>// Created     : 2017-01-05 @ 19:04 (Military date format - Year-Month-Day)
100709>>>>>//
100709>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
100709>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
100709>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
100709>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
100709>>>>>// in the help folder for more details.
100709>>>>>//
100709>>>>>//****************************************************************************
100709>>>>>Use Windows.pkg
100709>>>>>Use cCommandLinkButton.pkg
Including file: cCommandLinkButton.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCommandLinkButton.pkg)
100709>>>>>>>// This requires version 6 of common controls (vista or windows server 2008). If used with
100709>>>>>>>// older versions you will just get a regular great big button.
100709>>>>>>>
100709>>>>>>>Use Windows.pkg
100709>>>>>>>Use CharTranslate.pkg
100709>>>>>>>
100709>>>>>>>Class cCommandLinkButton is a Button
100710>>>>>>>    
100710>>>>>>>    Procedure Construct_Object
100712>>>>>>>        Forward Send Construct_Object
100714>>>>>>>        Property String psPrivateNote
100715>>>>>>>    End_Procedure
100716>>>>>>>    
100716>>>>>>>    Procedure Set psNote String sNote
100718>>>>>>>        Boolean bSupported
100718>>>>>>>        Set psPrivateNote to sNote
100719>>>>>>>        Get IsExControlSupported to bSupported
100720>>>>>>>        If bSupported Begin
100722>>>>>>>            Send SetWinNote
100723>>>>>>>        End
100723>>>>>>>>
100723>>>>>>>    End_Procedure
100724>>>>>>>    
100724>>>>>>>    Procedure SetWinNote
100726>>>>>>>        String sNote
100726>>>>>>>        Handle hWnd
100726>>>>>>>        Integer i
100726>>>>>>>        Address aVar
100726>>>>>>>        Get Form_Window_Handle 0 to hWnd
100727>>>>>>>        If hWnd Begin
100729>>>>>>>            Get psNote to sNote
100730>>>>>>>            Move (OemToUtf16Buffer(AddressOf(sNote),Length(sNote))) to aVar
100731>>>>>>>            Move (SendMessage(hwnd, BCM_SETNOTE, 0, aVar)) to i
100732>>>>>>>            Move (Free(aVar)) to i
100733>>>>>>>        End
100733>>>>>>>>
100733>>>>>>>    End_Procedure
100734>>>>>>>    
100734>>>>>>>    
100734>>>>>>>    Function psNote Returns String
100736>>>>>>>        Function_Return (psPrivateNote(Self))
100737>>>>>>>    End_Function
100738>>>>>>>    
100738>>>>>>>    
100738>>>>>>>    Procedure Page Integer iState
100740>>>>>>>        Integer i hWnd
100740>>>>>>>        Boolean bSupported
100740>>>>>>>        Get IsExControlSupported to bSupported
100741>>>>>>>        If (iState=1 and bSupported) Begin
100743>>>>>>>            Get form_style i to i
100744>>>>>>>            Set Form_Style 0 to (i ior (BS_COMMANDLINK + BS_FLAT))
100745>>>>>>>            Forward Send Page iState
100747>>>>>>>            Send SetWinNote
100748>>>>>>>        End
100748>>>>>>>>
100748>>>>>>>        Else Begin
100749>>>>>>>            Forward Send Page iState
100751>>>>>>>        End
100751>>>>>>>>
100751>>>>>>>    End_Procedure
100752>>>>>>>    
100752>>>>>>>End_Class
100753>>>>>
100753>>>>>Define clGreenGrey      for (RGB(64, 84, 93))
100753>>>>>Define clGreenGreyLight for (RGB(7, 117, 104))
100753>>>>>
100753>>>>>Class cRDCHeaderGroupImage is a cCommandLinkButton
100754>>>>>    Procedure Construct_Object
100756>>>>>        Forward Send Construct_Object
100758>>>>>
100758>>>>>        Set Size to 18 19
100759>>>>>        Set Focus_Mode to NonFocusable
100760>>>>>        Set peImageAlign to Button_ImageList_Align_Top
100761>>>>>        Set pbAutoResizeIcons to True
100762>>>>>    End_Procedure
100763>>>>>
100763>>>>>    Procedure OnClick
100765>>>>>        Broadcast Send Prompt of (Parent(Self))
100767>>>>>    End_Procedure
100768>>>>>
100768>>>>>    Procedure Set Bitmap String sBitmapName
100770>>>>>        Forward Set psImage to sBitmapName
100772>>>>>    End_Procedure
100773>>>>>
100773>>>>>    Procedure End_Construct_Object
100775>>>>>        Set pbShield to False
100776>>>>>        Forward Send End_Construct_Object
100778>>>>>    End_Procedure
100779>>>>>
100779>>>>>End_Class
100780>>>>>
100780>>>>>// Intermediate class - don't use.
100780>>>>>Class _cRDCHeaderGroup is a Container3d
100781>>>>>
100781>>>>>    Procedure Construct_Object
100783>>>>>        Forward Send Construct_Object
100785>>>>>
100785>>>>>        Property String private.psImage
100786>>>>>        Property String private.psLabel
100787>>>>>
100787>>>>>    End_Procedure
100788>>>>>
100788>>>>>    Procedure Set psImage String sImage
100790>>>>>        Set private.psImage to sImage
100791>>>>>    End_Procedure
100792>>>>>
100792>>>>>    Function psImage Returns String
100794>>>>>        Function_Return (private.psImage(Self))
100795>>>>>    End_Function
100796>>>>>
100796>>>>>    Procedure Set psLabel String sLabel
100798>>>>>        Set private.psLabel to sLabel
100799>>>>>    End_Procedure
100800>>>>>
100800>>>>>    Function psLabel Returns String
100802>>>>>        Function_Return (private.psLabel(Self))
100803>>>>>    End_Function
100804>>>>>
100804>>>>>    // Don't display but allow to use old "Label" syntax to set the value of the oInfo_tb object (header text)
100804>>>>>    Procedure Set Label String sLabel
100806>>>>>        Set psLabel to sLabel
100807>>>>>    End_Procedure
100808>>>>>
100808>>>>>    Function Label Returns String
100810>>>>>        Function_Return (private.psLabel(Self))
100811>>>>>    End_Function
100812>>>>>
100812>>>>>End_Class
100813>>>>>
100813>>>>>Register_Procedure NavigatePrevious
100813>>>>>Register_Procedure NavigateNext
100813>>>>>
100813>>>>>Class cRDCHeaderGroup is a _cRDCHeaderGroup
100814>>>>>
100814>>>>>    Procedure Construct_Object
100816>>>>>        Forward Send Construct_Object
100818>>>>>
100818>>>>>        Set peAnchors to anTopLeftRight
100819>>>>>        Set pbAcceptDropFiles to True
100820>>>>>        Set Border_Style to Border_Normal
100821>>>>>
100821>>>>>        Property Integer private.piColorOrg
100822>>>>>        Property Boolean private.pbIsHeaderGroup True // Don't touch!
100823>>>>>        Property String private.psToolTip ""
100824>>>>>
100824>>>>>        Property Integer piImageColOffset 4
100825>>>>>        Property Integer piImageRowOffset 0
100826>>>>>        Property String psNote ""
100827>>>>>        Property Boolean pbLargeImageSize True
100828>>>>>        Property Integer private.piLargeImageSize 24
100829>>>>>        Property Integer private.piSmallImageSize 16
100830>>>>>        Property Boolean pbUseHotspotColor False
100831>>>>>        Property Integer piHeaderHotspotColor clAqua
100832>>>>>        Property String private.psLabel ""
100833>>>>>        Property Integer piLabelColor clGreenGrey
100834>>>>>        Property Boolean pbLabelFontItalics False
100835>>>>>        Property Integer piLabelLargeFontHeight 12
100836>>>>>        Property Integer piLabelSmallFontHeight 10
100837>>>>>        Property Boolean pbUseLargeFontHeight False
100838>>>>>
100838>>>>>        Property Integer piLabelFontPointWeight fw_Bold
100839>>>>>        Property Integer piLabelColOffset 28
100840>>>>>        Property Integer piLabelRowOffset 4
100841>>>>>        Property Boolean pbCreateTooltipItem True
100842>>>>>
100842>>>>>        Set pbAcceptDropFiles to True
100843>>>>>
100843>>>>>        Send Define_ToolTip_Support_Mixin
100844>>>>>
100844>>>>>        // For the Studio to render the header image
100844>>>>>        Set Bitmap to "Default32x32.bmp"
100845>>>>>        // This doesn't work... I wonder if there's a way to "trick" the Studio
100845>>>>>        // to render some text in the header when in design mode?
100845>>>>>        Set Label to "HEADER TEXT"
100846>>>>>
100846>>>>>        On_Key kLeftArrow  Send NavigatePrevious
100847>>>>>        On_Key kUpArrow    Send NavigatePrevious
100848>>>>>        On_Key kRightArrow Send NavigateNext
100849>>>>>        On_Key kDownArrow  Send NavigateNext
100850>>>>>        On_Key kSwitch     Send Switch_Next_Area
100851>>>>>    End_Procedure
100852>>>>>
100852>>>>>    Import_Class_Protocol ToolTip_Support_Mixin
100853>>>>>
100853>>>>>    Procedure Set psImage String sImage
100855>>>>>        Set Bitmap to ""
100856>>>>>        Forward Set psImage to sImage
100858>>>>>    End_Procedure
100859>>>>>
100859>>>>>    Function psImage Returns String
100861>>>>>        Function_Return (psImage(Self))
100862>>>>>    End_Function
100863>>>>>
100863>>>>>    Procedure Set Label String sLabel
100865>>>>>        Forward Set psLabel to sLabel
100867>>>>>    End_Procedure
100868>>>>>
100868>>>>>    Procedure Set psToolTip String sToolTip
100870>>>>>        Set private.psToolTip to sToolTip
100871>>>>>    End_Procedure
100872>>>>>
100872>>>>>    Function psToolTip Returns String
100874>>>>>        Function_Return (private.psToolTip(Self))
100875>>>>>    End_Function
100876>>>>>
100876>>>>>    Procedure End_Construct_Object
100878>>>>>        String sNote sLabel
100878>>>>>        Boolean bUseLargeFontHeight bLargeImageSize bCreateTooltipItem
100878>>>>>        Integer iFontHeight iImageSize iLabelRowOffset iLabelColOffset iSize iTextOffset
100878>>>>>
100878>>>>>        Forward Send End_Construct_Object
100880>>>>>
100880>>>>>        Get piLabelColOffset to iLabelColOffset
100881>>>>>        Get pbUseLargeFontHeight to bUseLargeFontHeight
100882>>>>>        If (bUseLargeFontHeight = True) Begin
100884>>>>>            Get piLabelLargeFontHeight to iFontHeight
100885>>>>>            Move 8 to iLabelRowOffset
100886>>>>>        End
100886>>>>>>
100886>>>>>        Else Begin
100887>>>>>            Get piLabelSmallFontHeight to iFontHeight
100888>>>>>            Move 6 to iLabelRowOffset
100889>>>>>        End
100889>>>>>>
100889>>>>>
100889>>>>>        Get pbLargeImageSize to bLargeImageSize
100890>>>>>        If (bLargeImageSize = True) Begin
100892>>>>>            Get private.piLargeImageSize to iImageSize
100893>>>>>        End
100893>>>>>>
100893>>>>>        Else Begin
100894>>>>>            Get private.piSmallImageSize to iImageSize
100895>>>>>            Move (iLabelColOffset - 6) to iLabelColOffset
100896>>>>>        End
100896>>>>>>
100896>>>>>
100896>>>>>        Object oHeaderGroupImage is a cRDCHeaderGroupImage
100898>>>>>            Set piImageSize to iImageSize
100899>>>>>            Set Location to (piImageRowOffset(Self)) (piImageColOffset(Self))
100900>>>>>            Set psImage to (private.psImage(Self))
100901>>>>>            Set peImageAlign to Button_ImageList_Align_Center
100902>>>>>            Set psToolTip to (private.psToolTip(Self))
100903>>>>>        End_Object
100904>>>>>
100904>>>>>        Object oHeaderGroupInfo_tb is a TextBox
100906>>>>>            Set Size to 12 100
100907>>>>>            Set Location to (piLabelRowOffset(Self)) iLabelColOffset
100908>>>>>            Set FontWeight to (piLabelFontPointWeight(Self))
100909>>>>>            Set FontItalics to (pbLabelFontItalics(Self))
100910>>>>>            Set FontPointHeight to iFontHeight
100911>>>>>            Set Label to (private.psLabel(Self))
100912>>>>>            Set TextColor to (piLabelColor(Self))
100913>>>>>            Set psToolTip to (private.psToolTip(Self))
100914>>>>>            Get Size to iSize
100915>>>>>        End_Object
100916>>>>>
100916>>>>>        // ToDo: The positioning logic for placing the info image to the right of the header text is flawed.
100916>>>>>        // How can it be improved?
100916>>>>>        Get pbCreateTooltipItem to bCreateTooltipItem
100917>>>>>        If (bCreateTooltipItem = True and private.psToolTip(Self) <> "") Begin
100919>>>>>            Get private.psLabel to sLabel
100920>>>>>            Get Text_Extent sLabel to iTextOffset
100921>>>>>            Move (Low(iTextOffset) -0)  to iTextOffset
100922>>>>>            Object oHeaderGroupTooltip_tb is a TextBox
100924>>>>>                Set Size to 10 10
100925>>>>>                If (bUseLargeFontHeight = True) Begin
100927>>>>>//                    Set Location to (piLabelRowOffset(Self)) iTextOffset //(Low(iSize) + (iTextOffset))
100927>>>>>                    Set Location to (piLabelRowOffset(Self)) (Low(iSize) + (iLabelColOffset * 2) + 10)
100928>>>>>                End
100928>>>>>>
100928>>>>>                Else Begin
100929>>>>>//                    Set Location to (piLabelRowOffset(Self)) iTextOffset
100929>>>>>                    Set Location to (piLabelRowOffset(Self)) (Low(iSize) + iLabelColOffset + 25)
100930>>>>>                End
100930>>>>>>
100930>>>>>                Set psToolTip to (private.psToolTip(Self))
100931>>>>>                Set Bitmap to "ActionAbout.bmp"
100932>>>>>            End_Object
100933>>>>>        End
100933>>>>>>
100933>>>>>
100933>>>>>        Get psNote to sNote
100934>>>>>        If (Trim(sNote) <> "") Begin
100936>>>>>            Object oHeaderGroupNote_tb is a TextBox
100938>>>>>                Set Size to 12 100
100939>>>>>                Set Location to (Hi(iSize) + iLabelRowOffset) (iLabelColOffset + 8)
100940>>>>>                Set Label to ("-" * String(sNote))
100941>>>>>                Set TextColor to (piLabelColor(Self))
100942>>>>>                Set FontPointHeight to 9
100943>>>>>                Set psToolTip to (private.psToolTip(Self))
100944>>>>>            End_Object
100945>>>>>        End
100945>>>>>>
100945>>>>>
100945>>>>>    End_Procedure
100946>>>>>
100946>>>>>    Function Popup_State Returns Boolean
100948>>>>>        Boolean bIsPopup
100948>>>>>        Get Popup_State of (Parent(Self)) to bIsPopup
100949>>>>>        Function_Return bIsPopup
100950>>>>>    End_Function
100951>>>>>
100951>>>>>    Procedure OnEnterArea Handle hoFrom
100953>>>>>        Integer iColor
100953>>>>>        Forward Send OnEnterArea hoFrom
100955>>>>>        // Not ideal, but works most of the time.
100955>>>>>        //       When navigating to i.e a popup we don't want
100955>>>>>        //       the coloring to appear. Else there will be 2
100955>>>>>        //       cRDCHeaderGroup's with the highlight color...
100955>>>>>        // Is there a better way?
100955>>>>>        If (hoFrom <> Desktop and hoFrom < Parent(Self)) Begin
100957>>>>>            Procedure_Return
100958>>>>>        End
100958>>>>>>
100958>>>>>        If (pbUseHotspotColor(Self) = True) Begin
100960>>>>>            Get Color to iColor
100961>>>>>            Set private.piColorOrg to iColor
100962>>>>>            Get piHeaderHotspotColor to iColor
100963>>>>>            Set Color to iColor
100964>>>>>            Broadcast Recursive Set Color to iColor
100966>>>>>        End
100966>>>>>>
100966>>>>>    End_Procedure
100967>>>>>
100967>>>>>    Procedure OnExitArea Handle hoFrom
100969>>>>>        Integer iColor
100969>>>>>        Forward Send OnExitArea hoFrom
100971>>>>>        If (pbUseHotspotColor(Self) = True) Begin
100973>>>>>            Get private.piColorOrg to iColor
100974>>>>>            Set Color to iColor
100975>>>>>            Broadcast Recursive Set Color to iColor
100977>>>>>        End
100977>>>>>>
100977>>>>>    End_Procedure
100978>>>>>
100978>>>>>    // Public access message to change the group header text color at runtime.
100978>>>>>    Procedure Set Label_Color Integer iColor
100980>>>>>        Set TextColor of (oHeaderGroupInfo_tb(Self)) to iColor
100981>>>>>    End_Procedure
100982>>>>>
100982>>>>>    Procedure NavigatePrevious
100984>>>>>        Integer iMulti ivoid iLastErr
100984>>>>>        Handle hWnd
100984>>>>>        Boolean bErr
100984>>>>>
100984>>>>>        Move Err to bErr
100985>>>>>        Move LastErr to iLastErr
100986>>>>>
100986>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
100987>>>>>        Get Select_Mode of (Focus(Self)) to iMulti
100988>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
100989>>>>>        If (Err) Begin
100991>>>>>            Move bErr to Err
100992>>>>>            Move iLastErr to LastErr
100993>>>>>            Procedure_Return
100994>>>>>        End
100994>>>>>>
100994>>>>>
100994>>>>>        Move bErr to Err
100995>>>>>        Move iLastErr to LastErr
100996>>>>>        If (iMulti = Multi_Select) Begin
100998>>>>>            Send Previous
100999>>>>>        End
100999>>>>>>
100999>>>>>        Else Begin
101000>>>>>            Get Form_Window_Handle of (Focus(Self)) to hWnd
101001>>>>>            Move (Sendmessage(hWnd, WM_KEYDOWN, Ascii(VK_LEFT), 0)) to iVoid
101002>>>>>        End
101002>>>>>>
101002>>>>>    End_Procedure
101003>>>>>
101003>>>>>    Procedure NavigateNext
101005>>>>>        Integer iMulti iVoid iLastErr
101005>>>>>        Handle hWnd
101005>>>>>        Boolean bErr
101005>>>>>
101005>>>>>        Move Err to bErr
101006>>>>>        Move LastErr to iLastErr
101007>>>>>
101007>>>>>        Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
101008>>>>>        Get Select_Mode of (Focus(Self)) to iMulti
101009>>>>>        Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
101010>>>>>        If (Err) Begin
101012>>>>>            Move bErr to Err
101013>>>>>            Move iLastErr to LastErr
101014>>>>>            Procedure_Return
101015>>>>>        End
101015>>>>>>
101015>>>>>
101015>>>>>        Move bErr to Err
101016>>>>>        Move iLastErr to LastErr
101017>>>>>        If (iMulti = Multi_Select) Begin
101019>>>>>            Send Next
101020>>>>>        End
101020>>>>>>
101020>>>>>        Else Begin
101021>>>>>            Get Form_Window_Handle of (Focus(Self)) to hWnd
101022>>>>>            Move (Sendmessage(hWnd, WM_KEYDOWN, Ascii(VK_LEFT), 0)) to iVoid
101023>>>>>        End
101023>>>>>>
101023>>>>>
101023>>>>>    End_Procedure
101024>>>>>
101024>>>>>    Procedure Enable_Window Integer iState
101026>>>>>        Handle hWnd
101026>>>>>        Get Window_Handle to hWnd
101027>>>>>        If hWnd Begin
101029>>>>>            Move (EnableWindow(hWnd, iState)) to hWnd
101030>>>>>        End
101030>>>>>>
101030>>>>>    End_Procedure
101031>>>>>
101031>>>>>    Procedure Page_Object Integer iState
101033>>>>>        Handle hWnd
101033>>>>>        Get Window_Handle to hWnd
101034>>>>>        Forward Send Page_Object iState
101036>>>>>        If (hWnd = 0 and iState) Begin
101038>>>>>            Send Shadow_Display
101039>>>>>        End
101039>>>>>>
101039>>>>>    End_Procedure
101040>>>>>
101040>>>>>    Procedure Shadow_Display
101042>>>>>        Send Enable_Window (not(Object_Shadow_State(Self)))
101043>>>>>    End_Procedure
101044>>>>>
101044>>>>>    Function Explicit_Shadow_State Returns Boolean
101046>>>>>        Function_Return (Private.Explicit_Shadow_State(Self))
101047>>>>>    End_Function
101048>>>>>
101048>>>>>    // For some reason we need to augment this event to allow
101048>>>>>    // files to be dropped on a cRDCHeaderGroup object; else nothing will
101048>>>>>    // happen.
101048>>>>>    Procedure OnFileDropped String sFilename Boolean bLast
101050>>>>>        Delegate Send OnFileDropped sFilename bLast
101052>>>>>    End_Procedure
101053>>>>>
101053>>>>>End_Class
101054>>>>>
101054>>>>>// We don't want the broadcast of setting color to set the background
101054>>>>>// color for forms that are within a cRDCHeaderGroup object.
101054>>>>>// If the Form is not within a cRDCHeaderGroup the Form class should
101054>>>>>// behave as it always has. But if you don't like this; just comment
101054>>>>>// it out.
101054>>>>>//Procedure Set Color for Form Integer eColor
101054>>>>>//    Boolean bIsHeaderGroup bErr bEnabled_State
101054>>>>>//    Integer iLastErr
101054>>>>>//
101054>>>>>//    Move Err to bErr
101054>>>>>//    Move LastErr to iLastErr
101054>>>>>//
101054>>>>>//    Send Ignore_Error of Error_Object_Id DFERR_BAD_MESSAGE
101054>>>>>//    Delegate Get private.pbIsHeaderGroup to bIsHeaderGroup
101054>>>>>//    Send Trap_Error of Error_Object_Id DFERR_BAD_MESSAGE
101054>>>>>//    Move bErr to Err
101054>>>>>//    Move iLastErr to LastErr
101054>>>>>//    If (bIsHeaderGroup = False) Begin
101054>>>>>//        Forward Set Color to eColor
101054>>>>>//    End
101054>>>>>//End_Procedure
101054>>>Use DriverSettings.dg
Including file: DriverSettings.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\DriverSettings.dg)
101054>>>>>Use cApplication.pkg
101054>>>>>Use Dfline.pkg
101054>>>>>Use cRichEdit.pkg
101054>>>>>Use cScrollingContainer.pkg
Including file: cScrollingContainer.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cScrollingContainer.pkg)
101054>>>>>>>// Provides support for scrolling containers.
101054>>>>>>>// Scrolling containers is provided by creating two objects,
101054>>>>>>>// a host (cScrollingContainer) and a scrolling clientarea (cScrollingClientArea)
101054>>>>>>>// The host has no public interface, you just drop the object. It should have only one child object
101054>>>>>>>// and that should be a scrolling client-area. If it is not, it is an error. It is also considered
101054>>>>>>>// an error to place a scrolling client area in any object other than a scrolling container.
101054>>>>>>>
101054>>>>>>>Use Windows.pkg
101054>>>>>>>Use cScrollingContainerMixin.pkg
Including file: cScrollingContainerMixin.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cScrollingContainerMixin.pkg)
101054>>>>>>>>>// Mixin classes for scrolling container support:
101054>>>>>>>>>// cScrollingContainerMixin & cScrollingClientAreaMixin
101054>>>>>>>>>// These are used by cSrollingContainer / cScrollingClientArea and
101054>>>>>>>>>// dbScrollingContainer / dbScrollingClientArea.
101054>>>>>>>>>// The scrolling container has no public interface, you just drop the object. It should have only one child object
101054>>>>>>>>>// and that should be a scrolling client-area. If it is not, it is an error. It is also considered
101054>>>>>>>>>// an error to place a scrolling client area in any object other than a scrolling container.
101054>>>>>>>>>
101054>>>>>>>>>Use Windows.pkg
101054>>>>>>>>>Use Winuser.pkg
101054>>>>>>>>>Use tWinStructs.pkg
101054>>>>>>>>>
101054>>>>>>>>>Register_Function pbTabbedWorkspaces Returns Boolean
101054>>>>>>>>>Register_Function pbCenterTabbedViews Returns Boolean
101054>>>>>>>>>// support for the scrolling client area mixin object.
101054>>>>>>>>>
101054>>>>>>>>>Class cScrollingClientAreaMixin is a Mixin
101055>>>>>>>>>    
101055>>>>>>>>>    Procedure Define_cScrollingClientAreaMixin
101057>>>>>>>>>        
101057>>>>>>>>>        Set pbSizeToClientArea to False // should already be set to this, but just in case.
101058>>>>>>>>>        Set Border_Style to Border_None
101059>>>>>>>>>        
101059>>>>>>>>>        Property Boolean pbAutoScroll True
101060>>>>>>>>>        Property Boolean pbAutoScrollFocus True
101061>>>>>>>>>        Property Integer piAutoScrollMarginX 5
101062>>>>>>>>>        Property Integer piAutoScrollMarginY 5
101063>>>>>>>>>        Property Integer piAutoScrollMinX 0
101064>>>>>>>>>        Property Integer piAutoScrollMinY 0
101065>>>>>>>>>        Property Boolean pbShowDisabledScrollBar False
101066>>>>>>>>>        
101066>>>>>>>>>        
101066>>>>>>>>>        Property Integer piLineScrollUnit  5 // minimum scrolling unit for line up/down and mouse wheel
101067>>>>>>>>>        Property Integer piMinimumHeight 0 // the minimum height that doesn't need scrolling
101068>>>>>>>>>        Property Integer piMinimumWidth 0 //(the minimum width that doesn't need scrolling
101069>>>>>>>>>        // keeps track of scrolling
101069>>>>>>>>>        Property Integer piCurrentVertScrolled 0
101070>>>>>>>>>        Property Integer piCurrentHorzScrolled 0
101071>>>>>>>>>        Property Integer piWheelDelta 0               // internal, accumulates mouse wheel clicks
101072>>>>>>>>>        Delegate Set phoScrollingClientArea to Self
101074>>>>>>>>>        
101074>>>>>>>>>        // set this true to make this a tabbed workspace view (design time)
101074>>>>>>>>>        Property Boolean pbTabWorkspaceView False
101075>>>>>>>>>        // set this false to stop auto-determination of pbTabWorkspaceView (design time)
101075>>>>>>>>>        Property Boolean pbAutoSetTabWorkspaceView True
101076>>>>>>>>>    End_Procedure
101077>>>>>>>>>    
101077>>>>>>>>>    // low level event sent from windows.
101077>>>>>>>>>    Procedure OnWmMouseWheel Integer wParam Integer lParam
101079>>>>>>>>>        Integer iWheelDelta iKeys iDelta iClicks
101079>>>>>>>>>        Move (low(abs(wParam))) to iKeys           // any keys down when pressed
101080>>>>>>>>>        Move (hi(abs(wParam))) to iDelta           // number of click units
101081>>>>>>>>>        If (wParam<0) Begin
101083>>>>>>>>>            Move (-iDelta) to iDelta     // can be up or down
101084>>>>>>>>>        End
101084>>>>>>>>>>
101084>>>>>>>>>        Get  piWheelDelta to iWheelDelta           // Current accumulated micro clicks
101085>>>>>>>>>        Move (iWheelDelta+iDelta) to iWheelDelta
101086>>>>>>>>>        // C_WHEELDATA is 120 as defined by MS as the delta to react to. Once click is usually 120
101086>>>>>>>>>        Move (iWheelDelta/C_WHEELDELTA) to iClicks // Number of clicks to react to
101087>>>>>>>>>        Set  piWheelDelta to (mod(iWheelDelta,C_WHEELDELTA)) // remainder unused microclicks
101088>>>>>>>>>        // If we have enough Clicks send OnMouseWheel
101088>>>>>>>>>        If (iClicks<>0) Begin
101090>>>>>>>>>            Send OnMouseWheel iClicks iKeys
101091>>>>>>>>>        End
101091>>>>>>>>>>
101091>>>>>>>>>        // tell windows that we've handled the event.
101091>>>>>>>>>        Set Windows_Override_State to True
101092>>>>>>>>>    End_Procedure
101093>>>>>>>>>    
101093>>>>>>>>>    
101093>>>>>>>>>    // should be sent by DF message OnWMMouseWheel , which is sent by WM_MOUSEWHEEL
101093>>>>>>>>>    Procedure OnMouseWheel Integer iClicks Integer iKey
101095>>>>>>>>>        Integer iLineScrollUnit
101095>>>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
101096>>>>>>>>>        Send VScroll (-iClicks*iLineScrollUnit*2) // (If(iClicks>0,False,True)) (abs(iClicks))
101097>>>>>>>>>    End_Procedure
101098>>>>>>>>>    
101098>>>>>>>>>    // should be sent by WM_VSCROLL
101098>>>>>>>>>    Procedure SetVScrollbox Integer iType Integer iNewPos
101100>>>>>>>>>        Boolean bOk
101100>>>>>>>>>        tWinScrollInfo ScrollInfo
101100>>>>>>>>>        tWinScrollInfo ScrollInfo
101100>>>>>>>>>        Integer iLineScrollUnit
101100>>>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
101101>>>>>>>>>        Get GetScrollBarInfo True (&ScrollInfo) to bOk
101102>>>>>>>>>        If bOk Begin
101104>>>>>>>>>            
101104>>>>>>>>>            Case Begin
101104>>>>>>>>>                Case (iType=SB_PAGEDOWN)
101106>>>>>>>>>                    Send VScroll ScrollInfo.nPage
101107>>>>>>>>>                    Case Break
101108>>>>>>>>>                
101108>>>>>>>>>                Case (iType=SB_PAGEUP)
101111>>>>>>>>>                    Send VScroll (-ScrollInfo.nPage)
101112>>>>>>>>>                    Case Break
101113>>>>>>>>>                
101113>>>>>>>>>                Case (iType=SB_LINEDOWN)
101116>>>>>>>>>                    Send VScroll iLineScrollUnit
101117>>>>>>>>>                    Case Break
101118>>>>>>>>>                
101118>>>>>>>>>                Case (iType=SB_LINEUP)
101121>>>>>>>>>                    Send VScroll (-iLineScrollUnit)
101122>>>>>>>>>                    Case Break
101123>>>>>>>>>                
101123>>>>>>>>>                Case (iType=SB_BOTTOM)
101126>>>>>>>>>                    Send VScroll (ScrollInfo.nMax-ScrollInfo.nPos)
101127>>>>>>>>>                    Case Break
101128>>>>>>>>>                
101128>>>>>>>>>                Case (iType=SB_Top)
101131>>>>>>>>>                    Send VScroll (-ScrollInfo.nPos)
101132>>>>>>>>>                    Case Break
101133>>>>>>>>>                
101133>>>>>>>>>                Case (iType=SB_THUMBPOSITION)
101136>>>>>>>>>                    Case Break
101137>>>>>>>>>                
101137>>>>>>>>>                Case (iType=SB_THUMBTRACK)
101140>>>>>>>>>                    Send VScroll (ScrollInfo.nTrackPos-ScrollInfo.nPos)
101141>>>>>>>>>                    Case Break
101142>>>>>>>>>            Case End
101142>>>>>>>>>        End
101142>>>>>>>>>>
101142>>>>>>>>>    End_Procedure
101143>>>>>>>>>    
101143>>>>>>>>>    // should be sent by WM_HSCROLL
101143>>>>>>>>>    Procedure SetHScrollbox Integer iType Integer iNewPos
101145>>>>>>>>>        Boolean bOk
101145>>>>>>>>>        tWinScrollInfo ScrollInfo
101145>>>>>>>>>        tWinScrollInfo ScrollInfo
101145>>>>>>>>>        Integer iLineScrollUnit
101145>>>>>>>>>        Get piLineScrollUnit to iLineScrollUnit
101146>>>>>>>>>        Get GetScrollBarInfo False (&ScrollInfo) to bOk
101147>>>>>>>>>        If bOk Begin
101149>>>>>>>>>            
101149>>>>>>>>>            Case Begin
101149>>>>>>>>>                Case (iType=SB_PAGEDOWN)
101151>>>>>>>>>                    Send hScroll ScrollInfo.nPage
101152>>>>>>>>>                    Case Break
101153>>>>>>>>>                
101153>>>>>>>>>                Case (iType=SB_PAGEUP)
101156>>>>>>>>>                    Send hScroll (-ScrollInfo.nPage)
101157>>>>>>>>>                    Case Break
101158>>>>>>>>>                
101158>>>>>>>>>                Case (iType=SB_LINEDOWN)
101161>>>>>>>>>                    Send hScroll iLineScrollUnit
101162>>>>>>>>>                    Case Break
101163>>>>>>>>>                
101163>>>>>>>>>                Case (iType=SB_LINEUP)
101166>>>>>>>>>                    Send hScroll (-iLineScrollUnit)
101167>>>>>>>>>                    Case Break
101168>>>>>>>>>                
101168>>>>>>>>>                Case (iType=SB_BOTTOM)
101171>>>>>>>>>                    Send hScroll (ScrollInfo.nMax-ScrollInfo.nPos)
101172>>>>>>>>>                    Case Break
101173>>>>>>>>>                
101173>>>>>>>>>                Case (iType=SB_Top)
101176>>>>>>>>>                    Send hScroll (-ScrollInfo.nPos)
101177>>>>>>>>>                    Case Break
101178>>>>>>>>>                
101178>>>>>>>>>                Case (iType=SB_THUMBPOSITION)
101181>>>>>>>>>                    Case Break
101182>>>>>>>>>                
101182>>>>>>>>>                Case (iType=SB_THUMBTRACK)
101185>>>>>>>>>                    Send hScroll (ScrollInfo.nTrackPos-ScrollInfo.nPos)
101186>>>>>>>>>                    Case Break
101187>>>>>>>>>            Case End
101187>>>>>>>>>        End
101187>>>>>>>>>>
101187>>>>>>>>>    End_Procedure
101188>>>>>>>>>    
101188>>>>>>>>>    
101188>>>>>>>>>    // this calls SetScrollInfo with proper info
101188>>>>>>>>>    Procedure SetScrollBarInfo Boolean bVert Integer iRangeMin Integer iRangeMax Integer iPageSize
101190>>>>>>>>>        tWinScrollInfo ScrollInfo
101190>>>>>>>>>        tWinScrollInfo ScrollInfo
101190>>>>>>>>>        Integer iVoid
101190>>>>>>>>>        Handle hWnd
101190>>>>>>>>>        Boolean bShow
101190>>>>>>>>>        
101190>>>>>>>>>        Delegate Get Window_Handle to hWnd
101192>>>>>>>>>        If (hWnd <> 0) Begin
101194>>>>>>>>>            Move (SizeOfType (tWinScrollInfo)) to ScrollInfo.cbSize
101195>>>>>>>>>            
101195>>>>>>>>>            Move (SIF_RANGE ior SIF_POS ior SIF_PAGE ) to ScrollInfo.fMask
101196>>>>>>>>>            Get pbShowDisabledScrollBar to bShow
101197>>>>>>>>>            If bShow Begin
101199>>>>>>>>>                Move (ScrollInfo.fMask ior SIF_DISABLENOSCROLL) to ScrollInfo.fMask
101200>>>>>>>>>            End
101200>>>>>>>>>>
101200>>>>>>>>>            Move iRangeMin to ScrollInfo.nMin
101201>>>>>>>>>            Move iRangeMax to ScrollInfo.nMax
101202>>>>>>>>>            Move iPageSize to ScrollInfo.nPage
101203>>>>>>>>>            Move 0 to ScrollInfo.nPos
101204>>>>>>>>>            Move (SetScrollInfo (hWnd, If(bVert,SB_VERT,SB_HORZ), AddressOf (ScrollInfo), True)) to iVoid
101205>>>>>>>>>            
101205>>>>>>>>>        End
101205>>>>>>>>>>
101205>>>>>>>>>    End_Procedure
101206>>>>>>>>>    
101206>>>>>>>>>    // this wraps GetScrollInfo
101206>>>>>>>>>    Function GetScrollBarInfo Boolean bVert tWinScrollInfo ByRef ScrollInfo Returns Boolean
101208>>>>>>>>>        Boolean bOk
101208>>>>>>>>>        Handle hWnd
101208>>>>>>>>>        
101208>>>>>>>>>        Delegate Get Window_Handle to hWnd
101210>>>>>>>>>        If (hWnd <> 0) Begin
101212>>>>>>>>>            Move (SizeOfType (tWinScrollInfo)) to ScrollInfo.cbSize
101213>>>>>>>>>            Move (SIF_ALL) to ScrollInfo.fMask
101214>>>>>>>>>            Move (GetScrollInfo (hWnd, If(bVert,SB_VERT,SB_HORZ), AddressOf (ScrollInfo))) to bOk
101215>>>>>>>>>        End
101215>>>>>>>>>>
101215>>>>>>>>>        Function_Return bOk
101216>>>>>>>>>    End_Function
101217>>>>>>>>>    
101217>>>>>>>>>    // this wraps SetScrollPos
101217>>>>>>>>>    Procedure SetScrollBarPosInfo Boolean bVert Integer iPos
101219>>>>>>>>>        Integer iVoid
101219>>>>>>>>>        Handle hWnd
101219>>>>>>>>>        
101219>>>>>>>>>        Delegate Get Window_Handle to hWnd
101221>>>>>>>>>        If (hWnd <> 0) Begin
101223>>>>>>>>>            Move (SetScrollPos(hWnd, If(bVert,SB_VERT,SB_HORZ), iPos, True)) to iVoid
101224>>>>>>>>>        End
101224>>>>>>>>>>
101224>>>>>>>>>    End_Procedure
101225>>>>>>>>>    
101225>>>>>>>>>    // scrolling containers don't do anhcors. However, this gets called every time the parent's
101225>>>>>>>>>    // guiSize changes. We can use that to scroll or resize the scrolling client as needed.
101225>>>>>>>>>    Procedure DoapplyAnchors Integer Arg1 Integer Arg2
101227>>>>>>>>>        Send ScrollClientArea
101228>>>>>>>>>    End_Procedure
101229>>>>>>>>>    
101229>>>>>>>>>    // augment to handle the scrolling area initialization.
101229>>>>>>>>>    Procedure Add_Focus Handle hoParent
101231>>>>>>>>>        Forward Send Add_Focus hoParent
101233>>>>>>>>>        // at this the scrolling container and client area should both be paged.
101233>>>>>>>>>        // child objects ae also paged with initial anchors applied
101233>>>>>>>>>        Send CalculateAutoScrollMinimums
101234>>>>>>>>>    End_Procedure
101235>>>>>>>>>    
101235>>>>>>>>>    Procedure Page Integer iPage
101237>>>>>>>>>        Forward Send Page iPage
101239>>>>>>>>>        If iPage Begin
101241>>>>>>>>>            // at this the scrolling container and client area should both be paged
101241>>>>>>>>>            // but the child controls are not paged. We don't want scrollbars when
101241>>>>>>>>>            // the child items are paged (else they may get anchored oddly)
101241>>>>>>>>>            // Prior to 19.0 these were set in Add_focus which meant that the child objects were
101241>>>>>>>>>            // already paged with scrollbars present. This would result in scrollbars appearing
101241>>>>>>>>>            // before they were really needed. This should be more accurate
101241>>>>>>>>>            Send SetScrollBarInfo True 0 0 0
101242>>>>>>>>>            Send SetScrollBarInfo False 0 0 0
101243>>>>>>>>>        End
101243>>>>>>>>>>
101243>>>>>>>>>    End_Procedure
101244>>>>>>>>>    
101244>>>>>>>>>    // determine scrolling minimums and set the client area as required.
101244>>>>>>>>>    
101244>>>>>>>>>    Procedure CalculateAutoScrollMinimums
101246>>>>>>>>>        Integer iMinX iMinY iSiz iLoc iMargin
101246>>>>>>>>>        Integer iAutoMinX iAutoMinY
101246>>>>>>>>>        Boolean bAutoScroll
101246>>>>>>>>>        Handle hoNext hoFirst
101246>>>>>>>>>        
101246>>>>>>>>>        Get pbAutoScroll to bAutoScroll
101247>>>>>>>>>        Get piAutoScrollMinX to iAutoMinX
101248>>>>>>>>>        Get piAutoScrollMinY to iAutoMinY
101249>>>>>>>>>        Get DialogToGui iAutoMinY iAutoMinX to iSiz
101250>>>>>>>>>        Move (Hi(iSiz)) to iAutoMinY
101251>>>>>>>>>        Move (Low(iSiz)) to iAutoMinX
101252>>>>>>>>>        Set piMinimumHeight to iAutoMinY
101253>>>>>>>>>        Set piMinimumWidth to iAutoMinX
101254>>>>>>>>>        
101254>>>>>>>>>        If (bAutoScroll and (iAutoMinX=0 or iAutoMinY=0)) Begin
101256>>>>>>>>>            
101256>>>>>>>>>            Get Next_Level to hoFirst
101257>>>>>>>>>            Move hoFirst to hoNext
101258>>>>>>>>>            If (hoFirst) Begin
101260>>>>>>>>>                Repeat
101260>>>>>>>>>>
101260>>>>>>>>>                    Get GuiWindowSize of hoNext to iSiz
101261>>>>>>>>>                    Get GuiLocation of hoNext to iLoc
101262>>>>>>>>>                    Move (Hi(iLoc)+Hi(iSiz) max iMinY) to iMinY
101263>>>>>>>>>                    Move (Low(iLoc)+Low(iSiz) max iMinX) to iMinx
101264>>>>>>>>>                    Get Next_Focus of hoNext to hoNext
101265>>>>>>>>>                Until (hoNext=0 or hoNext=hoFirst)
101267>>>>>>>>>                
101267>>>>>>>>>                If (iAutoMinY=0) Begin
101269>>>>>>>>>                    Get piAutoScrollMarginY to iMargin
101270>>>>>>>>>                    Set piMinimumHeight to (iMinY+iMargin)
101271>>>>>>>>>                End
101271>>>>>>>>>>
101271>>>>>>>>>                
101271>>>>>>>>>                If (iAutoMinX=0) Begin
101273>>>>>>>>>                    Get piAutoScrollMarginX to iMargin
101274>>>>>>>>>                    Set piMinimumWidth to (iMinX+iMargin)
101275>>>>>>>>>                    
101275>>>>>>>>>                End
101275>>>>>>>>>>
101275>>>>>>>>>            End
101275>>>>>>>>>>
101275>>>>>>>>>        End
101275>>>>>>>>>>
101275>>>>>>>>>        
101275>>>>>>>>>        // before setting the client area, unset all anchors so DoApplyAnchors will not do anything
101275>>>>>>>>>        Broadcast Set pbAnchorCreated to False
101277>>>>>>>>>        Send ScrollClientArea
101278>>>>>>>>>        // after the scroll set up, reinitialize all anchors.
101278>>>>>>>>>        Broadcast Send DoCreateAnchors
101280>>>>>>>>>    End_Procedure
101281>>>>>>>>>    
101281>>>>>>>>>    // Scroll the client area and adjust the client area size as needed. This does all the
101281>>>>>>>>>    // work of scrolling.
101281>>>>>>>>>    
101281>>>>>>>>>    Procedure ScrollClientArea
101283>>>>>>>>>        Integer iSiz
101283>>>>>>>>>        Integer iHeight iHCur iHCuriDelta iOrig iRange bOk
101283>>>>>>>>>        Integer iWidth iWCur iWDelta iWOrig
101283>>>>>>>>>        Integer iSzY iSzX iLocX iLocY
101283>>>>>>>>>        
101283>>>>>>>>>        Delegate Get GuiClientSize to iSiz
101285>>>>>>>>>        Move (Hi(iSiz)) to iHeight
101286>>>>>>>>>        Move (Low(iSiz)) to iWidth
101287>>>>>>>>>        
101287>>>>>>>>>        // Vertical scrolling
101287>>>>>>>>>        
101287>>>>>>>>>        Get piMinimumHeight to iOrig
101288>>>>>>>>>        Get piMinimumWidth to iWOrig
101289>>>>>>>>>        
101289>>>>>>>>>        If (iOrig<>0 or iWOrig<>0) Begin
101291>>>>>>>>>            
101291>>>>>>>>>            If (iOrig<>0) Begin
101293>>>>>>>>>                Get piCurrentVertScrolled to iHCur
101294>>>>>>>>>                // If the size got bigger and we've scrolled, we want to scroll up
101294>>>>>>>>>                If (iHCur<>0 and (iHCur+iHeight>iOrig)) Begin
101296>>>>>>>>>                    Move (iOrig-iHeight max 0) to iHCur
101297>>>>>>>>>                    Set piCurrentVertScrolled to iHCur
101298>>>>>>>>>                End
101298>>>>>>>>>>
101298>>>>>>>>>                If (iHCur<>0 or iOrig>iHeight) Begin
101300>>>>>>>>>                    Send SetScrollBarInfo True 0 iOrig (iHeight min iOrig)
101301>>>>>>>>>                    Send SetScrollBarPosInfo True iHCur
101302>>>>>>>>>                End
101302>>>>>>>>>>
101302>>>>>>>>>                Else Begin
101303>>>>>>>>>                    Send SetScrollBarInfo True 0 0 0 //iOrig (iHeight min iOrig)
101304>>>>>>>>>                End
101304>>>>>>>>>>
101304>>>>>>>>>            End
101304>>>>>>>>>>
101304>>>>>>>>>            
101304>>>>>>>>>            // Horiz scrolling
101304>>>>>>>>>            
101304>>>>>>>>>            Get piCurrentHorzScrolled to iWCur
101305>>>>>>>>>            // If the size got bigger and we've scrolled, we want to scroll left
101305>>>>>>>>>            If (iWCur<>0 and (iWCur+iWidth>iWOrig)) Begin
101307>>>>>>>>>                Move (iWOrig-iWidth max 0) to iWCur
101308>>>>>>>>>                Set piCurrentHorzScrolled to iWCur
101309>>>>>>>>>            End
101309>>>>>>>>>>
101309>>>>>>>>>            If (iWCur<>0 or iWOrig>iWidth) Begin
101311>>>>>>>>>                Send SetScrollBarInfo False 0 iWOrig (iWidth min iWOrig)
101312>>>>>>>>>                Send SetScrollBarPosInfo False iWCur
101313>>>>>>>>>            End
101313>>>>>>>>>>
101313>>>>>>>>>            Else Begin
101314>>>>>>>>>                Send SetScrollBarInfo False 0 0 0
101315>>>>>>>>>            End
101315>>>>>>>>>>
101315>>>>>>>>>        End
101315>>>>>>>>>>
101315>>>>>>>>>        
101315>>>>>>>>>        // this could change depending on scrollbars appearing or not
101315>>>>>>>>>        Delegate Get GuiClientSize to iSiz
101317>>>>>>>>>        
101317>>>>>>>>>        // size of container is the the minimum allowed size (if scrolling is needed)
101317>>>>>>>>>        // or it is the actual size of the container (if scrolling not needed and it is bigger)
101317>>>>>>>>>        // This is required to make anchors work sensibly
101317>>>>>>>>>        Move (hi(iSiz) max iOrig) to iSzY
101318>>>>>>>>>        Move (low(iSiz) max iWOrig) to iSzX
101319>>>>>>>>>        Move (-iHCur) to iLocY
101320>>>>>>>>>        Move (-iWCur) to iLocX
101321>>>>>>>>>        
101321>>>>>>>>>        // Allow chance to make modifications
101321>>>>>>>>>        Send AdjustSizesLocs (&iSzY) (&iSzX) (&iLocY) (&iLocX)
101322>>>>>>>>>        
101322>>>>>>>>>        Set GuiSize to iSzY iSzX
101323>>>>>>>>>        // if we've scrolled, we need to reposition the container
101323>>>>>>>>>        Set GuiLocation to iLocY iLocX
101324>>>>>>>>>    End_Procedure
101325>>>>>>>>>    
101325>>>>>>>>>    // note that scrolling never changes the size of the scrolling client.
101325>>>>>>>>>    // this way, it does not interfere with anchors.
101325>>>>>>>>>    
101325>>>>>>>>>    Procedure VScroll Integer iDelta
101327>>>>>>>>>        Integer iHeight iCur iOrig iSiz
101327>>>>>>>>>        Delegate Get GuiClientSize to iSiz
101329>>>>>>>>>        Move (hi(iSiz)) to iHeight
101330>>>>>>>>>        Get piCurrentVertScrolled to iCur
101331>>>>>>>>>        Get piMinimumHeight to iOrig
101332>>>>>>>>>        If (iOrig=0 or  Hi(iSiz)>=iOrig) Begin
101334>>>>>>>>>            Procedure_Return
101335>>>>>>>>>        End
101335>>>>>>>>>>
101335>>>>>>>>>        // make sure delta is within range
101335>>>>>>>>>        If (iDelta+iCur<0) Begin
101337>>>>>>>>>            Move (-iCur) to iDelta
101338>>>>>>>>>        End
101338>>>>>>>>>>
101338>>>>>>>>>        Else If (iDelta+iCur>iOrig - iHeight) Begin
101341>>>>>>>>>            Move (iOrig - iHeight - iCur) to iDelta
101342>>>>>>>>>        End
101342>>>>>>>>>>
101342>>>>>>>>>        If (iDelta=0) ;            Procedure_Return
101345>>>>>>>>>        
101345>>>>>>>>>        Move (iCur + iDelta) to iCur
101346>>>>>>>>>        Set piCurrentVertScrolled to iCur
101347>>>>>>>>>        Send SetScrollBarPosInfo True iCur
101348>>>>>>>>>        Get GuiLocation to iSiz
101349>>>>>>>>>        Set GuiLocation to (cast(hi(iSiz),Short)-iDelta) (cast(low(iSiz),Short))
101350>>>>>>>>>        Send ScrollClientArea
101351>>>>>>>>>    End_Procedure
101352>>>>>>>>>    
101352>>>>>>>>>    
101352>>>>>>>>>    Procedure HScroll Integer iDelta
101354>>>>>>>>>        Integer iHeight iCur iOrig iSiz
101354>>>>>>>>>        Delegate Get GuiClientSize to iSiz
101356>>>>>>>>>        Move (low(iSiz)) to iHeight
101357>>>>>>>>>        Get piCurrentHorzScrolled to iCur
101358>>>>>>>>>        Get piMinimumWidth to iOrig
101359>>>>>>>>>        If (iOrig=0 or  low(iSiz)>=iOrig) Begin
101361>>>>>>>>>            Procedure_Return
101362>>>>>>>>>        End
101362>>>>>>>>>>
101362>>>>>>>>>        If (iDelta+iCur<0) Begin
101364>>>>>>>>>            Move (-iCur) to iDelta
101365>>>>>>>>>        End
101365>>>>>>>>>>
101365>>>>>>>>>        Else If (iDelta+iCur>iOrig - iHeight) Begin
101368>>>>>>>>>            Move (iOrig - iHeight - iCur) to iDelta
101369>>>>>>>>>        End
101369>>>>>>>>>>
101369>>>>>>>>>        If (iDelta=0) ;            Procedure_Return
101372>>>>>>>>>        
101372>>>>>>>>>        Move (iCur + iDelta) to iCur
101373>>>>>>>>>        Set piCurrentHorzScrolled to iCur
101374>>>>>>>>>        Send SetScrollBarPosInfo False iCur
101375>>>>>>>>>        Get GuiLocation to iSiz
101376>>>>>>>>>        Set GuiLocation to (cast(hi(iSiz),Short)) (cast(low(iSiz),Short) -iDelta)
101377>>>>>>>>>        Send ScrollClientArea
101378>>>>>>>>>    End_Procedure
101379>>>>>>>>>    
101379>>>>>>>>>    // make sure client is a 0,0
101379>>>>>>>>>    Procedure ScrollHome
101381>>>>>>>>>        Send SetVScrollbox SB_TOP 0
101382>>>>>>>>>        Send SetHScrollbox SB_TOP 0
101383>>>>>>>>>    End_Procedure
101384>>>>>>>>>    
101384>>>>>>>>>    // get relative GUI location of this object to the parent one passed.
101384>>>>>>>>>    Procedure LocationRelativeTo Handle hoContainer Handle hoControl Integer ByRef iLocY Integer ByRef iLocX
101386>>>>>>>>>        Integer ivoid
101386>>>>>>>>>        tWinRect Rect0 Rect1
101386>>>>>>>>>        tWinRect Rect0 Rect1
101386>>>>>>>>>        Move (GetWindowRect(window_handle(hoContainer),addressof(Rect0))) to ivoid
101387>>>>>>>>>        Move (GetWindowRect(window_handle(hoControl),addressof(Rect1))) to ivoid
101388>>>>>>>>>        Move ((Rect1.top) - (Rect0.top)) to iLocY
101389>>>>>>>>>        Move ((rect1.left) - (rect0.left)) to iLocX
101390>>>>>>>>>    End_Procedure
101391>>>>>>>>>    
101391>>>>>>>>>    // This scrolls this object into visual range.
101391>>>>>>>>>    Procedure ScrollObjectInRange Handle hoControl
101393>>>>>>>>>        Handle hoScrollingContainer
101393>>>>>>>>>        Integer iCurrentVertScrolled iCurrentHorzScrolled
101393>>>>>>>>>        Integer iViewHeight iViewWidth
101393>>>>>>>>>        Integer iRelLocHeight iRelLocWidth
101393>>>>>>>>>        Integer iSize iControlHeight iControlWidth
101393>>>>>>>>>        Integer iScroll
101393>>>>>>>>>        Integer iMarginX iMarginY
101393>>>>>>>>>        Integer iScrollingContainerWindowSize iScrollingContainerClientSize
101393>>>>>>>>>        
101393>>>>>>>>>        Get piAutoScrollMarginX to iMarginX
101394>>>>>>>>>        Get piAutoScrollMarginY to iMarginY
101395>>>>>>>>>        
101395>>>>>>>>>        // the scrolling container
101395>>>>>>>>>        Move Self to hoScrollingContainer
101396>>>>>>>>>        // the amount the SC is currently scrolled
101396>>>>>>>>>        Get piCurrentVertScrolled of hoScrollingContainer to iCurrentVertScrolled
101397>>>>>>>>>        Get piCurrentHorzScrolled of hoScrollingContainer to iCurrentHorzScrolled
101398>>>>>>>>>        
101398>>>>>>>>>        // size of view's client area (this is the viewport area)
101398>>>>>>>>>        Get GuiClientSize of (Parent(hoScrollingContainer)) to iSize
101399>>>>>>>>>        Move (hi(iSize)) to iViewHeight
101400>>>>>>>>>        Move (low(iSize)) to iViewWidth
101401>>>>>>>>>        
101401>>>>>>>>>        // get this object's location relative to the scrolling container
101401>>>>>>>>>        Send LocationRelativeTo hoScrollingContainer hoControl (&iRelLocHeight) (&iRelLocWidth)
101402>>>>>>>>>        
101402>>>>>>>>>        // we expect that the client size is the window size but just in case
101402>>>>>>>>>        Get GuiWindowSize of hoScrollingContainer to iScrollingContainerWindowSize
101403>>>>>>>>>        Get GuiClientSize of hoScrollingContainer to iScrollingContainerClientSize
101404>>>>>>>>>        Move (iRelLocHeight - (Hi(iScrollingContainerWindowSize)-Hi(iScrollingContainerClientSize))) to iRelLocHeight
101405>>>>>>>>>        Move (iRelLocWidth - (Low(iScrollingContainerWindowSize)-Low(iScrollingContainerClientSize))) to iRelLocWidth
101406>>>>>>>>>        
101406>>>>>>>>>        // the outer size of the control object
101406>>>>>>>>>        Get GUIWindowSize of hoControl to iSize
101407>>>>>>>>>        Move (hi(iSize)) to iControlHeight
101408>>>>>>>>>        Move (low(iSize)) to iControlWidth
101409>>>>>>>>>        
101409>>>>>>>>>        // the general idea is to make the control fully visible but to scroll as little as possible.
101409>>>>>>>>>        
101409>>>>>>>>>        // Vertical Scroll
101409>>>>>>>>>        
101409>>>>>>>>>        // Vertical Scroll down
101409>>>>>>>>>        // if the bottom of the control plus a bottom margin does not fit make it fit at the bottom
101409>>>>>>>>>        If (iRelLocHeight + iControlHeight + iMarginY - iCurrentVertScrolled >iViewHeight) Begin
101411>>>>>>>>>            
101411>>>>>>>>>            // set scroll amount so that the bottom of the control is visible
101411>>>>>>>>>            Move (iRelLocHeight + iControlHeight + iMarginY - iCurrentVertScrolled - iViewHeight ) to iScroll
101412>>>>>>>>>            
101412>>>>>>>>>            // See if this amount, scrolls the top out of range. If so just scroll enough so that the
101412>>>>>>>>>            // top of the object appears at the bottom
101412>>>>>>>>>            If (iRelLocHeight - iCurrentVertScrolled < iScroll) Begin
101414>>>>>>>>>                Move (iRelLocHeight + iMarginY  - iCurrentVertScrolled - iViewHeight  ) to iScroll
101415>>>>>>>>>            End
101415>>>>>>>>>>
101415>>>>>>>>>            // if the scroll amnt is negative it's best to just keep it where it is.
101415>>>>>>>>>            If (iScroll>0) Begin
101417>>>>>>>>>                Send VScroll of hoScrollingContainer iScroll
101418>>>>>>>>>            End
101418>>>>>>>>>>
101418>>>>>>>>>        End
101418>>>>>>>>>>
101418>>>>>>>>>        // else vertical scroll up
101418>>>>>>>>>        // We scroll if the top of the object is not visible.
101418>>>>>>>>>        Else If (iRelLocHeight + iMarginY < iCurrentVertScrolled) Begin
101421>>>>>>>>>            // if we scroll we will scroll enough to see the top of the object.
101421>>>>>>>>>            Move (iRelLocHeight -iMarginY - iCurrentVertScrolled ) to iScroll
101422>>>>>>>>>            If (iScroll<0) Begin
101424>>>>>>>>>                Send VScroll of hoScrollingContainer (iScroll max (-iCurrentVertScrolled))
101425>>>>>>>>>            End
101425>>>>>>>>>>
101425>>>>>>>>>        End
101425>>>>>>>>>>
101425>>>>>>>>>        
101425>>>>>>>>>        // Horizonal Scroll
101425>>>>>>>>>        
101425>>>>>>>>>        // if the right side of the control does not fit, scroll it so it fits
101425>>>>>>>>>        If (iRelLocWidth + iControlWidth + iMarginX - iCurrentHorzScrolled >iViewWidth) Begin
101427>>>>>>>>>            Move (iRelLocWidth + iControlWidth + iMarginX - iCurrentHorzScrolled - iViewWidth ) to iScroll
101428>>>>>>>>>            If (iRelLocWidth - iCurrentHorzScrolled - iScroll<0) Begin
101430>>>>>>>>>                Move (iRelLocWidth  - iCurrentHorzScrolled - iMarginX ) to iScroll
101431>>>>>>>>>            End
101431>>>>>>>>>>
101431>>>>>>>>>            If (iScroll>0) Begin
101433>>>>>>>>>                Send HScroll of hoScrollingContainer iScroll
101434>>>>>>>>>            End
101434>>>>>>>>>>
101434>>>>>>>>>        End
101434>>>>>>>>>>
101434>>>>>>>>>        If (iRelLocWidth - iMarginX  - iCurrentHorzScrolled <0) Begin
101436>>>>>>>>>            // if this can fit by moving all the way to left, do so.
101436>>>>>>>>>            If (iRelLocWidth + iControlWidth + iMarginX <= iViewWidth) Begin
101438>>>>>>>>>                Move (-iCurrentHorzScrolled) to iScroll
101439>>>>>>>>>            End
101439>>>>>>>>>>
101439>>>>>>>>>            Else Begin
101440>>>>>>>>>                Move (iRelLocWidth - iCurrentHorzScrolled - iMarginX) to iScroll
101441>>>>>>>>>            End
101441>>>>>>>>>>
101441>>>>>>>>>            If (iScroll<0) Begin
101443>>>>>>>>>                Send HScroll of hoScrollingContainer (iScroll max (-iCurrentHorzScrolled))
101444>>>>>>>>>            End
101444>>>>>>>>>>
101444>>>>>>>>>        End
101444>>>>>>>>>>
101444>>>>>>>>>        
101444>>>>>>>>>        
101444>>>>>>>>>    End_Procedure
101445>>>>>>>>>    
101445>>>>>>>>>    // when we receive this message, we might need to scroll to bring the new focus in to view.
101445>>>>>>>>>    Procedure NotifyFocusSetInContainer Handle hoControl
101447>>>>>>>>>        Boolean bScrollOnFocus
101447>>>>>>>>>        Get pbAutoScrollFocus to bScrollOnFocus
101448>>>>>>>>>        If bScrollOnFocus Begin
101450>>>>>>>>>            Send ScrollObjectInRange hoControl
101451>>>>>>>>>        End
101451>>>>>>>>>>
101451>>>>>>>>>        Delegate Send NotifyFocusSetInContainer hoControl
101453>>>>>>>>>    End_Procedure
101454>>>>>>>>>    
101454>>>>>>>>>    
101454>>>>>>>>>    Function CenterTabWorkspaceView Returns Boolean
101456>>>>>>>>>        Boolean bCenter
101456>>>>>>>>>        Get pbCenterTabbedViews of ghoCommandBars to bCenter
101457>>>>>>>>>        Function_Return bCenter
101458>>>>>>>>>    End_Function
101459>>>>>>>>>    
101459>>>>>>>>>    Procedure AdjustSizesLocs Integer ByRef iHeight Integer ByRef iWidth Integer ByRef iLocY Integer ByRef iLocX
101461>>>>>>>>>        Boolean bTabWorkspaceView
101461>>>>>>>>>        Get pbTabWorkspaceView to bTabWorkspaceView
101462>>>>>>>>>        If bTabWorkspaceView Begin
101464>>>>>>>>>            Send AdjustTabWorkspaceView (&iHeight) (&iWidth) (&iLocY) (&iLocX)
101465>>>>>>>>>        End
101465>>>>>>>>>>
101465>>>>>>>>>    End_Procedure
101466>>>>>>>>>    
101466>>>>>>>>>    Function ParentView Returns Handle
101468>>>>>>>>>        Function_Return (Parent(Parent(Self)))
101469>>>>>>>>>    End_Function
101470>>>>>>>>>    
101470>>>>>>>>>    Procedure AdjustTabWorkspaceView Integer ByRef iHeight Integer ByRef iWidth Integer ByRef iLocY Integer ByRef iLocX
101472>>>>>>>>>        Integer iSize iMax iDiff
101472>>>>>>>>>        Handle hoView
101472>>>>>>>>>        Boolean bCenter bModal
101472>>>>>>>>>        Get ParentView to hoView
101473>>>>>>>>>        Get Block_Mouse_State of hoView to bModal
101474>>>>>>>>>        If not bModal Begin
101476>>>>>>>>>            Get CenterTabWorkspaceView to bCenter
101477>>>>>>>>>            Get GuiSize of hoView to iSize
101478>>>>>>>>>            Get piMaxSize of hoView to iMax
101479>>>>>>>>>            Get DialogToGui (Hi(iMax)) (Low(iMax)) to iMax
101480>>>>>>>>>            If (Low(iMax) and Low(iMax)<=Low(isize)) Begin
101482>>>>>>>>>                If bCenter Begin
101484>>>>>>>>>                    Move ((Low(iSize)-Low(iMax))/2) to iLocX
101485>>>>>>>>>                End
101485>>>>>>>>>>
101485>>>>>>>>>                Move (Low(iMax)) to iWidth
101486>>>>>>>>>            End
101486>>>>>>>>>>
101486>>>>>>>>>            If (Hi(iMax) and Hi(iMax)<=Hi(iSize)) Begin
101488>>>>>>>>>                If bCenter Begin
101490>>>>>>>>>                    Move ((Hi(iSize)-Hi(iMax))/2) to iLocY
101491>>>>>>>>>                    Move (iLocy min 25) to  iLocY
101492>>>>>>>>>                End
101492>>>>>>>>>>
101492>>>>>>>>>                Move (Hi(imax)) to iHeight
101493>>>>>>>>>            End
101493>>>>>>>>>>
101493>>>>>>>>>        End
101493>>>>>>>>>>
101493>>>>>>>>>    End_Procedure
101494>>>>>>>>>    
101494>>>>>>>>>    // Automatically determine if this is a scrolling tabbed workspace view
101494>>>>>>>>>    // If determines this by checking pbAutoSetTabWorkspaceView is set (it can be
101494>>>>>>>>>    // set to stop this), if we have a global commandbar object and we are using tabbed
101494>>>>>>>>>    // workspaces. We also make sure that the expected view object is a framework view class
101494>>>>>>>>>    // This should almost always yield the right answer.
101494>>>>>>>>>    // This is called by the scrolling container's end_constructor
101494>>>>>>>>>    Procedure AutoSetTabWorkspaceView
101496>>>>>>>>>        Boolean bTabView bIsView bAutoSetTabWorkspaceView
101496>>>>>>>>>        Handle hoParent
101496>>>>>>>>>        Integer iSize
101496>>>>>>>>>        Get pbAutoSetTabWorkspaceView to bAutoSetTabWorkspaceView
101497>>>>>>>>>        If (ghoCommandBars and bAutoSetTabWorkspaceView) Begin
101499>>>>>>>>>            Get pbTabbedWorkspaces of ghoCommandBars to bTabView
101500>>>>>>>>>            // not that pbTabbedWorkspaces is a designtime only property. You can not
101500>>>>>>>>>            // change this after the commandbar is paged.
101500>>>>>>>>>            If (bTabView) Begin
101502>>>>>>>>>                Get ParentView to hoParent
101503>>>>>>>>>                Get IsObjectOfClass of hoParent (RefClass(MdiDialog)) to bIsView
101504>>>>>>>>>                If (bIsView) Begin
101506>>>>>>>>>                    // set this as a tab workspace view
101506>>>>>>>>>                    Set pbTabWorkspaceView to True
101507>>>>>>>>>                    // when tab workspaces are enabled we always enable auto-scrolling
101507>>>>>>>>>                    // when tab workspaces are not enabled, pbScroll is whatever it is
101507>>>>>>>>>                    Set pbAutoScroll to True
101508>>>>>>>>>                    
101508>>>>>>>>>                End
101508>>>>>>>>>>
101508>>>>>>>>>            End
101508>>>>>>>>>>
101508>>>>>>>>>        End
101508>>>>>>>>>>
101508>>>>>>>>>    End_Procedure
101509>>>>>>>>>    
101509>>>>>>>>>End_Class
101510>>>>>>>>>
101510>>>>>>>>>// Container scrolling class support. Nothing in here is public
101510>>>>>>>>>Class cScrollingContainerMixin is a Mixin
101511>>>>>>>>>    
101511>>>>>>>>>    Procedure Define_cScrollingContainerMixin
101513>>>>>>>>>        Forward Set Border_Style to Border_None
101515>>>>>>>>>        Set pbSizeToClientArea to False // scrollbars and clientsize do not mix
101516>>>>>>>>>        Forward Set peAnchors to anAll
101518>>>>>>>>>        
101518>>>>>>>>>        // forcing scrollbars right away seems to make painting better
101518>>>>>>>>>        Set Window_Style WS_HSCROLL to True
101519>>>>>>>>>        Set Window_Style WS_VSCROLL to True
101520>>>>>>>>>        
101520>>>>>>>>>        Property Handle phoScrollingClientArea 0
101521>>>>>>>>>    End_Procedure
101522>>>>>>>>>    
101522>>>>>>>>>    // if anchors are changed, it will not work. We won't let that happen
101522>>>>>>>>>    Procedure Set peAnchors Integer eAnchors
101524>>>>>>>>>    End_Procedure
101525>>>>>>>>>    
101525>>>>>>>>>    // if a border style is set, it will not work. We won't let that happen
101525>>>>>>>>>    Procedure Set Border_Style Integer eStyle
101527>>>>>>>>>    End_Procedure
101528>>>>>>>>>    
101528>>>>>>>>>    // redirect scrollbar events and wheel events to the scrolling client area
101528>>>>>>>>>    Procedure OnWmMouseWheel Integer wParam Integer lParam
101530>>>>>>>>>        Handle hoClient
101530>>>>>>>>>        Get phoScrollingClientArea to hoClient
101531>>>>>>>>>        If hoClient Begin
101533>>>>>>>>>            Send OnMouseWheel of hoClient wParam lParam
101534>>>>>>>>>        End
101534>>>>>>>>>>
101534>>>>>>>>>    End_Procedure
101535>>>>>>>>>    
101535>>>>>>>>>    // should be sent by WM_VSCROLL
101535>>>>>>>>>    Procedure SetVScrollbox Integer iType Integer iNewPos
101537>>>>>>>>>        Handle hoClient
101537>>>>>>>>>        Get phoScrollingClientArea to hoClient
101538>>>>>>>>>        If hoClient Begin
101540>>>>>>>>>            Send SetVScrollbox of hoClient iType iNewPos
101541>>>>>>>>>        End
101541>>>>>>>>>>
101541>>>>>>>>>    End_Procedure
101542>>>>>>>>>    
101542>>>>>>>>>    // should be sent by WM_HSCROLL
101542>>>>>>>>>    Procedure SetHScrollbox Integer iType Integer iNewPos
101544>>>>>>>>>        Handle hoClient
101544>>>>>>>>>        Get phoScrollingClientArea to hoClient
101545>>>>>>>>>        If hoClient Begin
101547>>>>>>>>>            Send SetHScrollbox of hoClient iType iNewPos
101548>>>>>>>>>        End
101548>>>>>>>>>>
101548>>>>>>>>>    End_Procedure
101549>>>>>>>>>    
101549>>>>>>>>>    // augmented to adjust its size to the size of the parent client area.
101549>>>>>>>>>    // After this is set, anchors will handle any further resizing.
101549>>>>>>>>>    Procedure Page Integer iState
101551>>>>>>>>>        Integer iSiz iHeight iWidth
101551>>>>>>>>>        Integer iTop iBottom iLeft iRight iFontSize
101551>>>>>>>>>        Boolean bGroup
101551>>>>>>>>>        Handle hoClient
101551>>>>>>>>>        If (iState =1) Begin
101553>>>>>>>>>            Delegate Get Window_Style BS_GROUPBOX to bGroup
101555>>>>>>>>>            // We have special code to support groups because they
101555>>>>>>>>>            // draw a border inside of the client rectangle
101555>>>>>>>>>            If bGroup Begin
101557>>>>>>>>>                Get Physical_FontSize to iFontSize
101558>>>>>>>>>                Move (Hi(iFontSize)) to iTop
101559>>>>>>>>>                Move 2 to iLeft
101560>>>>>>>>>                Move 2 to iRight
101561>>>>>>>>>                Move 2 to iBottom
101562>>>>>>>>>            End
101562>>>>>>>>>>
101562>>>>>>>>>            // We use GetContainerClientSize instead of GuiClientSize because
101562>>>>>>>>>            // GetContainerClientSize has a special augmentation in tab pages that
101562>>>>>>>>>            // makes anchors work properly with unpaged tab-pages
101562>>>>>>>>>            Delegate Get GetContainerClientSize to iSiz
101564>>>>>>>>>            Set GuiSize to (Hi(iSiz)-(iTop+iBottom)) (Low(iSiz)-(iLeft+iRight))
101565>>>>>>>>>            Set GuiLocation to iTop iLeft
101566>>>>>>>>>            Send Adjust_Logicals
101567>>>>>>>>>        End
101567>>>>>>>>>>
101567>>>>>>>>>        Forward Send Page iState
101569>>>>>>>>>    End_Procedure
101570>>>>>>>>>    
101570>>>>>>>>>    Procedure End_Construct_Object
101572>>>>>>>>>        Handle hoClient
101572>>>>>>>>>        Forward Send End_Construct_Object
101574>>>>>>>>>        Get phoScrollingClientArea to hoClient
101575>>>>>>>>>        If (hoClient) Begin
101577>>>>>>>>>            Send AutoSetTabWorkspaceView of hoClient
101578>>>>>>>>>        End
101578>>>>>>>>>>
101578>>>>>>>>>    End_Procedure
101579>>>>>>>>>    
101579>>>>>>>>>End_Class
101580>>>>>>>
101580>>>>>>>Class cScrollingClientArea is a Container3d
101581>>>>>>>    Import_Class_Protocol cScrollingClientAreaMixin
101582>>>>>>>    Procedure Construct_Object
101584>>>>>>>        Forward Send Construct_Object
101586>>>>>>>        Send Define_cScrollingClientAreaMixin
101587>>>>>>>    End_Procedure
101588>>>>>>>End_Class
101589>>>>>>>
101589>>>>>>>
101589>>>>>>>
101589>>>>>>>Class cScrollingContainer is a Container3d
101590>>>>>>>    Import_Class_Protocol cScrollingContainerMixin
101591>>>>>>>    Procedure Construct_Object
101593>>>>>>>        Forward Send Construct_Object
101595>>>>>>>        Send Define_cScrollingContainerMixin
101596>>>>>>>    End_Procedure
101597>>>>>>>End_Class
101598>>>>>Use cRDCModalPanel.pkg
101598>>>>>Use cRDCForm.pkg
Including file: cRDCForm.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cRDCForm.pkg)
101598>>>>>>>//****************************************************************************
101598>>>>>>>// $Module type: Class
101598>>>>>>>// $Module name: cForm
101598>>>>>>>// $Author     : Nils G. Svedmyr, RDC Tools International
101598>>>>>>>// Created     : 2014-03-17 @ 12:34
101598>>>>>>>//
101598>>>>>>>// Description :
101598>>>>>>>//
101598>>>>>>>// $Rev History:
101598>>>>>>>//    2014-03-17  Module header created
101598>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
101598>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
101598>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
101598>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
101598>>>>>>>// in the help folder for more details.
101598>>>>>>>//
101598>>>>>>>//****************************************************************************
101598>>>>>>>Use Windows.pkg
101598>>>>>>>
101598>>>>>>>Class cFormIdleHandler is a cIdleHandler
101599>>>>>>>    Procedure Construct_Object
101601>>>>>>>        Forward Send Construct_Object
101603>>>>>>>
101603>>>>>>>    End_Procedure
101604>>>>>>>
101604>>>>>>>    Procedure OnIdle
101606>>>>>>>        Delegate Send DoUpdate
101608>>>>>>>    End_Procedure
101609>>>>>>>
101609>>>>>>>End_Class
101610>>>>>>>
101610>>>>>>>Class cRDCForm is a Form
101611>>>>>>>
101611>>>>>>>    Procedure Construct_Object
101613>>>>>>>        Forward Send Construct_Object
101615>>>>>>>
101615>>>>>>>        Property Boolean pbAutoEnable False
101616>>>>>>>
101616>>>>>>>        Property Boolean pbEnabled True
101617>>>>>>>
101617>>>>>>>        Property Handle phoIdleHandler (Create(Self, RefClass(cFormIdleHandler)))
101618>>>>>>>
101618>>>>>>>        Set Label_Justification_mode to JMode_Right
101619>>>>>>>        Set Label_Col_Offset to 2
101620>>>>>>>        Set Label_Row_Offset to 0
101621>>>>>>>    End_Procedure
101622>>>>>>>
101622>>>>>>>    Procedure End_Construct_Object
101624>>>>>>>        String sTooltip sStatus_Help
101624>>>>>>>
101624>>>>>>>        Forward Send End_Construct_Object
101626>>>>>>>
101626>>>>>>>        Get psToolTip   to sTooltip
101627>>>>>>>        Get Status_Help to sStatus_Help
101628>>>>>>>        If (sTooltip = "" and sStatus_Help <> "") Begin
101630>>>>>>>            Set psToolTip to sStatus_Help
101631>>>>>>>        End
101631>>>>>>>>
101631>>>>>>>        Else If (sTooltip <> "" and sStatus_Help = "") Begin
101634>>>>>>>            Set Status_Help to sTooltip
101635>>>>>>>        End
101635>>>>>>>>
101635>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to (pbAutoEnable(Self))
101636>>>>>>>    End_Procedure
101637>>>>>>>
101637>>>>>>>    Procedure DoUpdate
101639>>>>>>>        If (pbAutoEnable(Self) = False) Begin
101641>>>>>>>            Procedure_Return
101642>>>>>>>        End
101642>>>>>>>>
101642>>>>>>>        Set Enabled_State to (IsEnabled(Self))
101643>>>>>>>    End_Procedure
101644>>>>>>>
101644>>>>>>>    Function IsEnabled Returns Boolean
101646>>>>>>>        Boolean bEnabled
101646>>>>>>>        Get pbEnabled to bEnabled
101647>>>>>>>        Function_Return bEnabled
101648>>>>>>>    End_Function
101649>>>>>>>
101649>>>>>>>    // Enable the idle handler timer when the object is activated
101649>>>>>>>    Procedure Activating
101651>>>>>>>        Forward Send Activating
101653>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to True
101654>>>>>>>    End_Procedure
101655>>>>>>>
101655>>>>>>>    // Disable the idle handler when the object is deactivated
101655>>>>>>>    Procedure Deactivating
101657>>>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to False
101658>>>>>>>        Forward Send Deactivating
101660>>>>>>>    End_Procedure
101661>>>>>>>
101661>>>>>>>End_Class
101662>>>>>Use cRDCComboForm.pkg
101662>>>>>Use cRDCButton.pkg
101662>>>>>Use cRDCHeaderGroup.pkg
101662>>>>>Use cDbDriverSettingsForm.pkg
Including file: cDbDriverSettingsForm.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\cDbDriverSettingsForm.pkg)
101662>>>>>>>//****************************************************************************
101662>>>>>>>// $Module type: Class
101662>>>>>>>// $Module name: cDbDriverSettingsForm
101662>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International
101662>>>>>>>// Created     : 2014-03-17 @ 12:34
101662>>>>>>>//
101662>>>>>>>// Description :
101662>>>>>>>//
101662>>>>>>>// $Rev History:
101662>>>>>>>//    2014-03-17  Module header created
101662>>>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
101662>>>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
101662>>>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
101662>>>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
101662>>>>>>>// in the help folder for more details.
101662>>>>>>>//
101662>>>>>>>//****************************************************************************
101662>>>>>>>Use Windows.pkg
101662>>>>>>>Use seq_chnl.pkg
101662>>>>>>>
101662>>>>>>>Class cDbDriverSettingsForm is a Form
101663>>>>>>>
101663>>>>>>>    Procedure Construct_Object
101665>>>>>>>        Forward Send Construct_Object
101667>>>>>>>
101667>>>>>>>        Property Boolean private.pbDriverLoadingError False
101668>>>>>>>        
101668>>>>>>>        Set Label_Col_Offset to 2
101669>>>>>>>        Set Label_Justification_Mode to JMode_Right
101670>>>>>>>        Set Size to 11 125 
101671>>>>>>>        // We use these settings and not enabled_state to be able
101671>>>>>>>        // to show tooltips.
101671>>>>>>>        Set Color to clBtnFace
101672>>>>>>>        Set Focus_Mode to NonFocusable
101673>>>>>>>        Set peAnchors to anTopLeftRight
101674>>>>>>>
101674>>>>>>>        Property String psDriverIniFile ""
101675>>>>>>>    End_Procedure
101676>>>>>>>
101676>>>>>>>    Procedure Set psToolTip String sText
101678>>>>>>>        If (Trim(sText) = "") Begin
101680>>>>>>>            Move "No info available" to sText
101681>>>>>>>        End
101681>>>>>>>>
101681>>>>>>>        Forward Set psToolTip to sText
101683>>>>>>>    End_Procedure
101684>>>>>>>
101684>>>>>>>    Function psToolTip Returns String
101686>>>>>>>        String sTooltip sSearchValue
101686>>>>>>>
101686>>>>>>>        Get Label to sSearchValue
101687>>>>>>>        Get ExtractIniFileComment sSearchValue to sTooltip
101688>>>>>>>
101688>>>>>>>        Function_Return sTooltip
101689>>>>>>>    End_Function
101690>>>>>>>
101690>>>>>>>    Procedure SetValue String sDriver String sLabel Integer iAttribute
101692>>>>>>>        Integer iDriver
101692>>>>>>>        String sValue
101692>>>>>>>
101692>>>>>>>        // Sadly driver API attributes are only supported by the CLI-drivers,
101692>>>>>>>        // and the Pervasive driver is not amongst them. So do nothing if Pervasive.
101692>>>>>>>        If (sDriver <> DFBTRDRV_ID and sDriver <> DATAFLEX_ID) Begin
101694>>>>>>>            Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
101695>>>>>>>            Get DriverIndex of ghoSQLConnectionHandler sDriver to iDriver
101696>>>>>>>            Set private.pbDriverLoadingError to (iDriver = -1)
101697>>>>>>>            Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
101698>>>>>>>            If (iDriver <= 0) Begin
101700>>>>>>>                Procedure_Return
101701>>>>>>>            End
101701>>>>>>>>
101701>>>>>>>            // Set indicator to false prior asking for the driver attribute.
101701>>>>>>>            // This way we can decide to show the object or not, based on success/failure.
101701>>>>>>>            Move False to Err
101702>>>>>>>            Get_Attribute iAttribute of iDriver to sValue
101705>>>>>>>            If (sValue = "0") Begin
101707>>>>>>>                Move "0 (False)" to sValue
101708>>>>>>>            End
101708>>>>>>>>
101708>>>>>>>            If (sValue = "1") Begin
101710>>>>>>>                Move "1 (True)"  to sValue
101711>>>>>>>            End
101711>>>>>>>>
101711>>>>>>>            Set Value to sValue
101712>>>>>>>
101712>>>>>>>            Move (Replace("DF_DRIVER_", Uppercase(sLabel), "")) to sLabel
101713>>>>>>>            // Its a bit annoying reading all caps, so "proper" case
101713>>>>>>>            // all labels (DF_DRIVER_XXX values).
101713>>>>>>>            Get Propercase sLabel to sLabel
101714>>>>>>>            Set Label to sLabel
101715>>>>>>>
101715>>>>>>>            Get ExtractIniFileComment sLabel to sValue
101716>>>>>>>            Set Status_Help to sValue
101717>>>>>>>            Set psToolTip to sValue
101718>>>>>>>        End
101718>>>>>>>>
101718>>>>>>>    End_Procedure
101719>>>>>>>
101719>>>>>>>    // Pass a driver ini filename with path & a comment value to search for.
101719>>>>>>>    // Returns: The comments in the file as a string.
101719>>>>>>>    Function ExtractIniFileComment String sSearchValue Returns String
101721>>>>>>>        String sIniFile sValue sRetval sComment sCommentMarker
101721>>>>>>>        Boolean bCommentRow bStart
101721>>>>>>>        Integer iCh
101721>>>>>>>
101721>>>>>>>        Get psDriverIniFile to sIniFile
101722>>>>>>>        Move ";" to sCommentMarker
101723>>>>>>>        Get Seq_Open_Input_Channel sIniFile to iCh
101724>>>>>>>        While (SeqEof = False)
101728>>>>>>>            Readln channel iCh sValue
101730>>>>>>>            Move (Trim(sValue)) to sValue
101731>>>>>>>
101731>>>>>>>            // Check for a ";" at pos 1 & if the line contains the passed search value (driver attribute).
101731>>>>>>>            Move (Left(sValue, 1)) to sComment
101732>>>>>>>            If (bStart = False) Begin
101734>>>>>>>                Move (sComment = sCommentMarker and Lowercase(sValue) contains Lowercase(sSearchValue)) to bStart
101735>>>>>>>            End
101735>>>>>>>>
101735>>>>>>>            If (bStart = True) Begin
101737>>>>>>>                // Have we read past end of the comment for the driver attribute? If so, quit.
101737>>>>>>>                If (sComment <> sCommentMarker) Begin
101739>>>>>>>                    Move True to SeqEof
101740>>>>>>>                End
101740>>>>>>>>
101740>>>>>>>                Else Begin
101741>>>>>>>                    Move (sComment = sCommentMarker) to bCommentRow
101742>>>>>>>                    If (bCommentRow = True) Begin
101744>>>>>>>                        Move (Replace(sCommentMarker, sValue, "")) to sValue
101745>>>>>>>
101745>>>>>>>                        // Replace all double spaces with a single space character.
101745>>>>>>>                        Move (Replaces("  ", sValue, " ")) to sValue
101746>>>>>>>
101746>>>>>>>                        If (sRetval = "") Begin
101748>>>>>>>                            Move sValue to sRetval
101749>>>>>>>                        End
101749>>>>>>>>
101749>>>>>>>                        Else Begin
101750>>>>>>>                            Move (sRetval + " " + sValue) to sRetval
101751>>>>>>>                        End
101751>>>>>>>>
101751>>>>>>>                    End
101751>>>>>>>>
101751>>>>>>>                End
101751>>>>>>>>
101751>>>>>>>            End
101751>>>>>>>>
101751>>>>>>>        Loop
101752>>>>>>>>
101752>>>>>>>        Send Seq_Close_Channel iCh
101753>>>>>>>
101753>>>>>>>CompilerWarnings Off
101753>>>>>>>        // Replaces all double spaces with a single space character.
101753>>>>>>>        // The Replaces function doesn't quite work for this.
101753>>>>>>>        Repeat
101753>>>>>>>>
101753>>>>>>>            Replace "  " in sRetval with " "
101755>>>>>>>        Until (FindErr)
101757>>>>>>>        
101757>>>>>>>        Function_Return sRetval
101758>>>>>>>    End_Function
101759>>>>>>>CompilerWarnings On
101759>>>>>>>
101759>>>>>>>    Function Propercase String sText Returns String 
101761>>>>>>>        String[] sDelimiters
101762>>>>>>>        Integer iPos
101762>>>>>>>        
101762>>>>>>>        //Lowercase everything and we'll handle uppercase by exception
101762>>>>>>>        Move (Lowercase(sText)) to sText
101763>>>>>>>        
101763>>>>>>>        Move " " to sDelimiters[SizeOfArray(sDelimiters)]
101764>>>>>>>        Move "-" to sDelimiters[SizeOfArray(sDelimiters)]
101765>>>>>>>        Move "_" to sDelimiters[SizeOfArray(sDelimiters)]
101766>>>>>>>        
101766>>>>>>>        For iPos from 1 to (Length(sText)) // 1 based loop to match MID and OVERSTRIKE
101772>>>>>>>>
101772>>>>>>>            //If the previous character is a space, uppercase the current one (alway upper the first char)
101772>>>>>>>            If ((iPos = 1) or (SearchArray( Mid(sText, 1, (iPos - 1)), sDelimiters) <> -1)) ;                Move (Overstrike( Uppercase(Mid(sText, 1, iPos)), sText, iPos )) to sText
101775>>>>>>>        Loop
101776>>>>>>>>
101776>>>>>>>        
101776>>>>>>>        Function_Return sText
101777>>>>>>>    End_Function
101778>>>>>>>
101778>>>>>>>End_Class
101779>>>>>Use cDbUpdateFunctionLibrary.pkg
101779>>>>>
101779>>>>>Register_Procedure psOrgToolTip String sTooltip
101779>>>>>
101779>>>>>Object oDriverSettings_dg is a cRDCModalPanel
101781>>>>>    Set Size to 291 345
101782>>>>>    Set Label to "Driver Configuration File Info"
101783>>>>>    Set Location to 2 2
101784>>>>>    Set Maximize_Icon to False
101785>>>>>    Set Locate_Mode to CENTER_ON_PARENT
101786>>>>>    Set Icon to "DriverSettings1.ico"
101787>>>>>    
101787>>>>>    Property String psDriverID MSSQLDRV_ID
101789>>>>>    Property Boolean pbDriverLoadingError False
101791>>>>>    
101791>>>>>    Object oCancel_Btn is a cRDCButton
101793>>>>>        Set Label    to "&Close"
101794>>>>>        Set Location to 269 287
101795>>>>>        Set peAnchors to anBottomRight
101796>>>>>
101796>>>>>        Procedure OnClick
101799>>>>>            Send Close_Panel
101800>>>>>        End_Procedure
101801>>>>>
101801>>>>>    End_Object
101802>>>>>
101802>>>>>    Object oDriver_cf is a cRDCComboForm
101804>>>>>        Set Label to "Database Driver"
101805>>>>>        Set Size to 13 80
101806>>>>>        Set Location to 8 90
101807>>>>>        Set Form_Border to 0
101808>>>>>        Set Label_Col_Offset to 2
101809>>>>>        Set Label_Justification_Mode to JMode_Right
101810>>>>>        Set Status_Help to "Database driver."
101811>>>>>        Set Enabled_State to False
101812>>>>>        Set Skip_State to True
101813>>>>>
101813>>>>>        Procedure Combo_Fill_List
101816>>>>>            Send Combo_Add_Item DATAFLEX_ID
101817>>>>>            Send Combo_Add_Item DFBTRDRV_ID
101818>>>>>            Send Combo_Add_Item ODBC_DRV_ID
101819>>>>>            Send Combo_Add_Item MSSQLDRV_ID
101820>>>>>            Send Combo_Add_Item DB2_DRV_ID
101821>>>>>        End_Procedure
101822>>>>>
101822>>>>>    End_Object
101823>>>>>
101823>>>>>    Object oDriverFileName_cf is a cRDCForm
101825>>>>>        Set Label to "Database Driver File"
101826>>>>>        Set Size to 12 193
101827>>>>>        Set Location to 24 90
101828>>>>>        Set Label_Col_Offset to 2
101829>>>>>        Set Label_Justification_Mode to JMode_Right
101830>>>>>        Set Status_Help to "Database driver to be used when creating new tables."
101831>>>>>        Set Color to clBtnFace
101832>>>>>        Set Focus_Mode to NonFocusable
101833>>>>>        Set peAnchors to anTopLeftRight
101834>>>>>
101834>>>>>        Procedure OnChange
101837>>>>>            String sDriverID sValue sDriverIntFileName sTooltip sPath
101837>>>>>
101837>>>>>            Forward Send OnChange
101839>>>>>            Get Value to sValue
101840>>>>>            Set Status_Help to sValue
101841>>>>>
101841>>>>>            Get psDriverID to sDriverID
101842>>>>>            If (sDriverID <> DATAFLEX_ID) Begin
101844>>>>>                Get DatabaseDriverIniFilePath sDriverID to sPath
101845>>>>>                If (sPath <> "") Begin
101847>>>>>                    Move (sPath + sDriverID + ".int") to sDriverIntFileName
101848>>>>>                End
101848>>>>>>
101848>>>>>            End
101848>>>>>>
101848>>>>>            Else Begin
101849>>>>>                Move sDriverID to sDriverIntFileName
101850>>>>>            End
101850>>>>>>
101850>>>>>
101850>>>>>            Set Value of oDriverIniFile_fm to sDriverIntFileName
101851>>>>>            Get psOrgToolTip of oDriverIniFile_fm to sTooltip
101852>>>>>            Set Status_Help of oDriverIniFile_fm to (sTooltip * sDriverIntFileName)
101853>>>>>
101853>>>>>            // In case driver attribute objects already exists; destroy them
101853>>>>>            Broadcast Send Destroy    of oScrollingClientArea
101855>>>>>            // Then recreate them to show driver attributes
101855>>>>>            Send DoReadDriverSettings of oScrollingClientArea sDriverID
101856>>>>>        End_Procedure  
101857>>>>>        
101857>>>>>    End_Object
101858>>>>>
101858>>>>>    Object oDriverInfo_btn is a cRDCButton
101860>>>>>        Set Size to 13 50
101861>>>>>        Set Location to 24 287
101862>>>>>        Set Label to "Version Info"
101863>>>>>        Set Status_Help to "Shows a dialog with driver properties and SQL client software version(s), license info and more."
101864>>>>>        Set peAnchors to anTopRight
101865>>>>>
101865>>>>>        Procedure OnClick
101868>>>>>            Object oSysInfoDialog is a SysInfoDialog
101870>>>>>            End_Object
101871>>>>>
101871>>>>>            Send Popup of oSysInfoDialog
101872>>>>>        End_Procedure
101873>>>>>    End_Object
101874>>>>>
101874>>>>>    Object oDriverIniFile_fm is a cRDCForm
101876>>>>>        Set Size to 13 193
101877>>>>>        Set Location to 39 90
101878>>>>>        Set Label_Col_Offset to 2
101879>>>>>        Set Label_Justification_Mode to JMode_Right
101880>>>>>        Set Label to "Driver Configuration File"
101881>>>>>        Set peAnchors to anTopLeftRight
101882>>>>>        Set Color to clBtnFace
101883>>>>>        Set Focus_Mode to NonFocusable
101884>>>>>        Property String psOrgToolTip "The file is the first found in the DF_OPEN_PATH path string."
101886>>>>>        Set Status_Help to (psOrgToolTip(Self))
101887>>>>>    End_Object
101888>>>>>
101888>>>>>    Object oOpenDriverFile_Btn is a cRDCButton
101890>>>>>        Set Size to 13 50
101891>>>>>        Set Label to "Edit File"
101892>>>>>        Set Location to 39 287
101893>>>>>        Set Status_Help to "Opens the driver configuration file that contains configuration settings that are used when tables are restructured, in Notepad."
101894>>>>>        Set psImage to "ActionEdit1.ico"
101895>>>>>        Set peAnchors to anTopRight
101896>>>>>        Set pbAutoEnable to True
101897>>>>>
101897>>>>>        Procedure OnClick
101900>>>>>            String sFileName
101900>>>>>            Get Value of oDriverIniFile_fm to sFileName
101901>>>>>            If (sFileName <> DATAFLEX_ID) Begin
101903>>>>>                Runprogram Background "Notepad.exe" sFileName
101904>>>>>            End
101904>>>>>>
101904>>>>>            Else Begin
101905>>>>>                Send Info_Box "Sorry, there exist no driver ini file for the DataFlex database driver, so nothing to show here."
101906>>>>>            End
101906>>>>>>
101906>>>>>        End_Procedure   
101907>>>>>        
101907>>>>>        Function IsEnabled Returns Boolean
101910>>>>>            String sFileName
101910>>>>>            Get Value of oDriverFileName_cf to sFileName
101911>>>>>            Function_Return (sFileName <> "")
101912>>>>>        End_Function
101913>>>>>
101913>>>>>    End_Object
101914>>>>>
101914>>>>>    Object oDumpDriverData_Btn is a cRDCButton
101916>>>>>        Set Size to 13 50
101917>>>>>        Set Label to "Dump"
101918>>>>>        Set Location to 54 233
101919>>>>>        Set peAnchors to anTopRight
101920>>>>>        Set psToolTip to "Dumps the current status of the Connectivity Kit driver to an ASCII disk file."
101921>>>>>        Set psImage to "ActionExport1.ico"
101922>>>>>        Set pbAutoEnable to True
101923>>>>>        
101923>>>>>        Procedure OnClick
101926>>>>>            Handle hoCLI
101926>>>>>            String sDriver sPath sFileName
101926>>>>>            Integer iRetval
101926>>>>>
101926>>>>>            Get psDriverID to sDriver
101927>>>>>            Get Create (RefClass(cCLIHandler)) to hoCLI
101928>>>>>            Set psDriverID of hoCLI  to sDriver
101929>>>>>            If (sDriver = DATAFLEX_ID or sDriver = DFBTRDRV_ID) Begin
101931>>>>>                Send Destroy of hoCLI
101932>>>>>                Send Info_Box "Sorry, no attributes can be shown for the selected database driver."
101933>>>>>                Procedure_Return
101934>>>>>            End
101934>>>>>>
101934>>>>>
101934>>>>>            Get psHome of (phoWorkspace(ghoApplication)) to sPath
101935>>>>>            Get vFolderFormat sPath to sPath
101936>>>>>            Move (sDriver + "dump.txt") to sFileName
101937>>>>>            Send DumpStatus of hoCLI (sPath + sFileName)
101938>>>>>            Send Destroy of hoCLI
101939>>>>>
101939>>>>>            Send vShellExecute "open" sFileName "" sPath
101940>>>>>            Sleep 1
101941>>>>>            Get vDeleteFile (sPath + sFileName) to iRetval
101942>>>>>        End_Procedure
101943>>>>>
101943>>>>>        Function IsEnabled Returns Boolean
101946>>>>>            String sFileName
101946>>>>>            Boolean bDriverLoadingError 
101946>>>>>            Get pbDriverLoadingError to bDriverLoadingError
101947>>>>>            Get Value of oDriverFileName_cf to sFileName
101948>>>>>            Function_Return (sFileName <> "" and bDriverLoadingError = False)
101949>>>>>        End_Function
101950>>>>>
101950>>>>>    End_Object
101951>>>>>
101951>>>>>    Object oReset_Btn is a cRDCButton
101953>>>>>        Set Size to 13 50
101954>>>>>        Set Label to "Refresh"
101955>>>>>        Set Status_Help to "If you edit the driver configuration file, the display of attributes above needs to be refreshed. Click here to refresh."
101956>>>>>        Set Location to 54 287
101957>>>>>        Set psImage to "ActionRefresh1.ico"
101958>>>>>        Set peAnchors to anTopRight
101959>>>>>        Set pbAutoEnable to True
101960>>>>>
101960>>>>>        Procedure OnClick
101963>>>>>            String sDriver
101963>>>>>            Get psDriverID to sDriver
101964>>>>>            Unload_Driver sDriver
101965>>>>>            Load_Driver sDriver
101966>>>>>            Send Info_Box "This dialog needs to be re-opened to display the refreshed values. Dialog will now close and you need to re-open it manually."
101967>>>>>            Send Close_Panel
101968>>>>>        End_Procedure
101969>>>>>
101969>>>>>        Function IsEnabled Returns Boolean
101972>>>>>            String sFileName
101972>>>>>            Boolean bDriverLoadingError 
101972>>>>>            Get pbDriverLoadingError to bDriverLoadingError
101973>>>>>            Get Value of oDriverFileName_cf to sFileName
101974>>>>>            Function_Return (sFileName <> "" and bDriverLoadingError = False)
101975>>>>>        End_Function
101976>>>>>
101976>>>>>    End_Object
101977>>>>>
101977>>>>>    Object oDriverSetings_grp is a cRDCHeaderGroup
101979>>>>>        Set Size to 125 328
101980>>>>>        Set Location to 74 9
101981>>>>>        Set psImage to "DriverSettings1.ico"
101982>>>>>        Set Label to "Driver Configuration File Settings"   
101983>>>>>        Set psNote to "Hover the mouse over an attribute field to read information about it."
101984>>>>>        Set peAnchors to anAll
101985>>>>>
101985>>>>>        Object oInvisible_Container is a Container3d
101987>>>>>            Set Size to 100 327
101988>>>>>            Set Location to 24 0
101989>>>>>            Set Border_Style to Border_None
101990>>>>>            Set peAnchors to anAll
101991>>>>>    
101991>>>>>            Object oScrollingContainer is a cScrollingContainer
101993>>>>>               
101993>>>>>                Object oScrollingClientArea is a cScrollingClientArea
101995>>>>>
101995>>>>>                    // Just fill the array with all available driver attributes from Cli.pkg,
101995>>>>>                    // and one object will automatically be created for each attribute
101995>>>>>                    // for the current driver by the DoReadDriverSettings procedure.
101995>>>>>                    Function GeneralDriverAttributes Returns String[]
101998>>>>>                        String[] sAttributesArray
101999>>>>>    
101999>>>>>                        Move "DF_DRIVER_DEFAULT_DEFAULT_ASCII             |CI1101" to sAttributesArray[SizeOfArray(sAttributesArray)]
102000>>>>>                        Move "DF_DRIVER_DEFAULT_NULLABLE_ASCII            |CI1102" to sAttributesArray[SizeOfArray(sAttributesArray)]
102001>>>>>                        Move "DF_DRIVER_DEFAULT_DEFAULT_NUMERIC           |CI1103" to sAttributesArray[SizeOfArray(sAttributesArray)]
102002>>>>>                        Move "DF_DRIVER_DEFAULT_NULLABLE_NUMERIC          |CI1104" to sAttributesArray[SizeOfArray(sAttributesArray)]
102003>>>>>                        Move "DF_DRIVER_DEFAULT_DEFAULT_DATE              |CI1105" to sAttributesArray[SizeOfArray(sAttributesArray)]
102004>>>>>                        Move "DF_DRIVER_DEFAULT_NULLABLE_DATE             |CI1106" to sAttributesArray[SizeOfArray(sAttributesArray)]
102005>>>>>                        Move "DF_DRIVER_DEFAULT_DEFAULT_TEXT              |CI1107" to sAttributesArray[SizeOfArray(sAttributesArray)]
102006>>>>>                        Move "DF_DRIVER_DEFAULT_NULLABLE_TEXT             |CI1108" to sAttributesArray[SizeOfArray(sAttributesArray)]
102007>>>>>                        Move "DF_DRIVER_DEFAULT_DEFAULT_BINARY            |CI1109" to sAttributesArray[SizeOfArray(sAttributesArray)]
102008>>>>>                        Move "DF_DRIVER_DEFAULT_NULLABLE_BINARY           |CI1110" to sAttributesArray[SizeOfArray(sAttributesArray)]
102009>>>>>                        Move "DF_DRIVER_DUMMY_ZERO_DATE_VALUE             |CI1111" to sAttributesArray[SizeOfArray(sAttributesArray)]
102010>>>>>                        Move "DF_DRIVER_MAX_ACTIVE_STATEMENTS             |CI1112" to sAttributesArray[SizeOfArray(sAttributesArray)]
102011>>>>>                        Move "DF_DRIVER_CACHE_PATH                        |CI1113" to sAttributesArray[SizeOfArray(sAttributesArray)]
102012>>>>>                        Move "DF_DRIVER_DRIVER_DECIMAL_SEPARATOR          |CI1114" to sAttributesArray[SizeOfArray(sAttributesArray)]
102013>>>>>                        Move "DF_DRIVER_DEFAULT_TABLE_CHARACTER_FORMAT    |CI1115" to sAttributesArray[SizeOfArray(sAttributesArray)]
102014>>>>>                        Move "DF_DRIVER_DRIVER_THOUSANDS_SEPARATOR        |CI1116" to sAttributesArray[SizeOfArray(sAttributesArray)]
102015>>>>>                        Move "DF_DRIVER_APPLICATION_CHARACTER_FORMAT      |CI1117" to sAttributesArray[SizeOfArray(sAttributesArray)]
102016>>>>>                        Move "DF_DRIVER_DRIVER_DATE_FORMAT                |CI1118" to sAttributesArray[SizeOfArray(sAttributesArray)]
102017>>>>>                        Move "DF_DRIVER_LAST_ERROR_TEXT                   |CI1119" to sAttributesArray[SizeOfArray(sAttributesArray)]
102018>>>>>                        Move "DF_DRIVER_DRIVER_DATE_SEPARATOR             |CI1120" to sAttributesArray[SizeOfArray(sAttributesArray)]
102019>>>>>    
102019>>>>>                        // Exception to the rule!
102019>>>>>                        // Someone - in its infinite wisdome - decided that the keyword in the ini file should be "DFConnectionId",
102019>>>>>                        // and not "Connection_ID" that is the API attribute name. This brakes the cDriverSettingsForm tooltip logic.
102019>>>>>                        // We fix it by changing the attribute constant string here (removed the _ (underscore) before the "ID" part.
102019>>>>>                        Move "DF_DRIVER_CONNECTIONID                      |CI1121" to sAttributesArray[SizeOfArray(sAttributesArray)]
102020>>>>>                        Move "DF_DRIVER_IGNORE_UCASE_SUPPORT              |CI1122" to sAttributesArray[SizeOfArray(sAttributesArray)]
102021>>>>>                        Move "DF_DRIVER_CONNECTION_ID_STRING              |CI1123" to sAttributesArray[SizeOfArray(sAttributesArray)]
102022>>>>>    
102022>>>>>                        Move "DF_DRIVER_IGNORE_WARNINGS                   |CI1124" to sAttributesArray[SizeOfArray(sAttributesArray)]
102023>>>>>                        Move "DF_DRIVER_USE_DF_LOCKERROR                  |CI1126" to sAttributesArray[SizeOfArray(sAttributesArray)]
102024>>>>>                        Move "DF_DRIVER_FIND_CACHE_TIMEOUT                |CI1128" to sAttributesArray[SizeOfArray(sAttributesArray)]
102025>>>>>                        Move "DF_DRIVER_JIT_TRESHOLD                      |CI1130" to sAttributesArray[SizeOfArray(sAttributesArray)]
102026>>>>>                        Move "DF_DRIVER_TRUNCATE_BINARY_ZEROES            |CI1132" to sAttributesArray[SizeOfArray(sAttributesArray)]
102027>>>>>                        Move "DF_DRIVER_ERROR_DEBUG_MODE                  |CI1134" to sAttributesArray[SizeOfArray(sAttributesArray)]
102028>>>>>                        Move "DF_DRIVER_USE_CACHE                         |CI1136" to sAttributesArray[SizeOfArray(sAttributesArray)]
102029>>>>>                        Move "DF_DRIVER_REPORT_CACHE_ERRORS               |CI1138" to sAttributesArray[SizeOfArray(sAttributesArray)]
102030>>>>>                        Move "DF_DRIVER_USE_CACHE_EXPIRATION              |CI1140" to sAttributesArray[SizeOfArray(sAttributesArray)]
102031>>>>>                        Move "DF_DRIVER_DEFAULT_USE_DUMMY_ZERO_DATE       |CI1142" to sAttributesArray[SizeOfArray(sAttributesArray)]
102032>>>>>                        Move "DF_DRIVER_DEFAULT_RECORD_IDENTITY_HIDING    |CI1144" to sAttributesArray[SizeOfArray(sAttributesArray)]
102033>>>>>                        Move "DF_DRIVER_REPORT_ACTIVE_COLUMN_ERRORS       |CI1146" to sAttributesArray[SizeOfArray(sAttributesArray)]
102034>>>>>                        Move "DF_DRIVER_SILENT_LOGIN                      |CI1148" to sAttributesArray[SizeOfArray(sAttributesArray)]
102035>>>>>                        Move "DF_DRIVER_DEFAULT_MAP_TO_RECNUM             |CI1150" to sAttributesArray[SizeOfArray(sAttributesArray)]
102036>>>>>                        Move "DF_DRIVER_CONNECTION_ID_OPTIONS             |CI1152" to sAttributesArray[SizeOfArray(sAttributesArray)]
102037>>>>>                        Move "DF_DRIVER_NUMBER_CONNECTION_IDS             |CI1154" to sAttributesArray[SizeOfArray(sAttributesArray)]
102038>>>>>                        Move "DF_DRIVER_DEFAULT_DEFAULT_DATETIME          |CI1155" to sAttributesArray[SizeOfArray(sAttributesArray)]
102039>>>>>                        Move "DF_DRIVER_DEFAULT_NULLABLE_DATETIME         |CI1156" to sAttributesArray[SizeOfArray(sAttributesArray)]
102040>>>>>                        Move "DF_DRIVER_MATCH_CLIENT_SERVER_VERSION       |CI1158" to sAttributesArray[SizeOfArray(sAttributesArray)]
102041>>>>>                        Move "DF_DRIVER_SQLSERVER_CLIENT_VERSION          |CI1160" to sAttributesArray[SizeOfArray(sAttributesArray)]
102042>>>>>                        Move "DF_DRIVER_MAP_DFDATE_TO_ODBCTYPE            |CI1168" to sAttributesArray[SizeOfArray(sAttributesArray)]
102043>>>>>                        Move "DF_DRIVER_MAP_DFDATE_TO_SQLTYPE             |CI1169" to sAttributesArray[SizeOfArray(sAttributesArray)]
102044>>>>>                        Move "DF_DRIVER_MAP_DFDATETIME_TO_ODBCTYPE        |CI1170" to sAttributesArray[SizeOfArray(sAttributesArray)]
102045>>>>>                        Move "DF_DRIVER_MAP_DFDATETIME_TO_SQLTYPE         |CI1171" to sAttributesArray[SizeOfArray(sAttributesArray)]
102046>>>>>                        Move "DF_DRIVER_MAP_DFASCII_TO_ODBCTYPE           |CI1172" to sAttributesArray[SizeOfArray(sAttributesArray)]
102047>>>>>                        Move "DF_DRIVER_MAP_DFASCII_TO_SQLTYPE            |CI1173" to sAttributesArray[SizeOfArray(sAttributesArray)]
102048>>>>>                        Move "DF_DRIVER_MAP_DFTEXT_TO_ODBCTYPE            |CI1174" to sAttributesArray[SizeOfArray(sAttributesArray)]
102049>>>>>                        Move "DF_DRIVER_MAP_DFTEXT_TO_SQLTYPE             |CI1175" to sAttributesArray[SizeOfArray(sAttributesArray)]
102050>>>>>                        Move "DF_DRIVER_MAP_DFBINARY_TO_ODBCTYPE          |CI1176" to sAttributesArray[SizeOfArray(sAttributesArray)]
102051>>>>>                        Move "DF_DRIVER_MAP_DFBINARY_TO_SQLTYPE           |CI1177" to sAttributesArray[SizeOfArray(sAttributesArray)]
102052>>>>>                        Move "DF_DRIVER_DEFAULT_MAP_DF_TO_SQL_TYPE_SCHEMA |CI1178" to sAttributesArray[SizeOfArray(sAttributesArray)]
102053>>>>>                        Move "DF_DRIVER_LOGIN_ON_OPEN                     |CI1180" to sAttributesArray[SizeOfArray(sAttributesArray)]
102054>>>>>                        Move "DF_DRIVER_MINIMUM_CLIENT_VERSION            |CI1182" to sAttributesArray[SizeOfArray(sAttributesArray)]
102055>>>>>    
102055>>>>>                        // Sort items alphabetically
102055>>>>>                        Move (SortArray(sAttributesArray)) to sAttributesArray
102056>>>>>                        Function_Return sAttributesArray
102057>>>>>                    End_Function
102058>>>>>    
102058>>>>>                    Function SplitValue String sValue Integer ByRef iAttribute Returns String
102061>>>>>                        String sAttribute sTmp
102061>>>>>                        Integer iPos
102061>>>>>    
102061>>>>>                        Move (Pos("|", sValue)) to iPos
102062>>>>>                        Move (Left(sValue, (iPos -1))) to sAttribute
102063>>>>>                        Move (Mid(sValue, Length(sValue), iPos)) to sTmp
102064>>>>>                        Move (Trim(sAttribute)) to sAttribute
102065>>>>>                        Move (Eval(sTmp)) to iAttribute
102066>>>>>    
102066>>>>>                        Function_Return sAttribute
102067>>>>>                    End_Function
102068>>>>>    
102068>>>>>                    // Note: Creates dynamic objects.
102068>>>>>                    // They are not being destroyed by this method.
102068>>>>>                    // It is the reponsibility of the calling method to do that,
102068>>>>>                    // prior calling this method.
102068>>>>>                    Procedure DoReadDriverSettings String sDriver
102071>>>>>                        Integer iLocW iLocH iHfactor iFirstLineOffset iCount iItems iAttribute
102071>>>>>                        Handle ho hoParent
102071>>>>>                        String[] sAttributesArray
102072>>>>>                        String sValue sAttribute sDriverIniFile 
102072>>>>>                        Boolean bDriverLoadingError
102072>>>>>    
102072>>>>>                        Move (Self) to hoParent
102073>>>>>                        Move 13  to iHfactor // Height offset between form
102074>>>>>                        Move 120 to iLocW
102075>>>>>                        Move 10  to iLocH                            
102076>>>>>                        Move  0  to iFirstLineOffset // Offset from the top for the very first object.
102077>>>>>    
102077>>>>>                        Get Value of oDriverIniFile_fm to sDriverIniFile
102078>>>>>                        If (Trim(sDriverIniFile) = "") Begin
102080>>>>>                            Get Create (RefClass(cDbDriverSettingsForm)) to ho
102081>>>>>                            Move (iFirstLineOffset + iLocH) to iLocH
102082>>>>>                            Set Location of ho to iLocH (iLocW + 30)
102083>>>>>                            Set Label of ho to "No Driver Configuration File found!"
102084>>>>>                            Set Value of ho to "No attributes to display..."   
102085>>>>>                            Procedure_Return
102086>>>>>                        End
102086>>>>>>
102086>>>>>                            
102086>>>>>                        // Driver attributes aren't supported by the Pervasive driver,
102086>>>>>                        // so notify and quite.
102086>>>>>                        If (sDriver = DFBTRDRV_ID or sDriver = DATAFLEX_ID) Begin
102088>>>>>                            Get Create (RefClass(cDbDriverSettingsForm)) to ho
102089>>>>>                            Move (iFirstLineOffset + iLocH) to iLocH
102090>>>>>                            Set Location of ho to iLocH (iLocW + 30)
102091>>>>>                            Set Label of ho to "Query of driver attributes unsupported!"
102092>>>>>                            Set Value of ho to "Sorry, no attributes to display"
102093>>>>>                            Procedure_Return
102094>>>>>                        End
102094>>>>>>
102094>>>>>    
102094>>>>>                        Get GeneralDriverAttributes to sAttributesArray
102095>>>>>                        Move (SizeOfArray(sAttributesArray)) to iItems
102096>>>>>                        Decrement iItems
102097>>>>>                        Send Ignore_Error of Error_Object_Id CLIERR_CONNECTIONIDOUTOFRANGE 
102098>>>>>                        Send Ignore_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE  // Invalid driver value
102099>>>>>    
102099>>>>>                        For iCount from 0 to iItems
102105>>>>>>
102105>>>>>                            Move sAttributesArray[iCount] to sValue
102106>>>>>                            Get SplitValue sValue (&iAttribute) to sAttribute
102107>>>>>    
102107>>>>>                            Get Create (RefClass(cDbDriverSettingsForm)) to ho 
102108>>>>>                            Set psDriverIniFile of ho to sDriverIniFile
102109>>>>>                            Send SetValue of ho sDriver sAttribute iAttribute
102110>>>>>                            Get private.pbDriverLoadingError of ho to bDriverLoadingError
102111>>>>>                            If (bDriverLoadingError = True) Begin
102113>>>>>                                Set Label of ho to "Driver could not be loaded!"   
102114>>>>>                                If (Trim(sDriverIniFile) = "") Begin
102116>>>>>                                    Set Value of ho to "Driver .dll file not found!"
102117>>>>>                                End
102117>>>>>>
102117>>>>>                                Else Begin
102118>>>>>                                    Set Value of ho to "No attributes to display..."   
102119>>>>>                                End
102119>>>>>>
102119>>>>>                                Set psToolTip of ho to "Check that the database engine for the selected driver is installed and is running correctly!"  
102120>>>>>                                Delegate Set pbDriverLoadingError to True
102122>>>>>                                Move iItems to iCount // We're out of here.   
102123>>>>>                                Move False to Err
102124>>>>>                            End
102124>>>>>>
102124>>>>>                            If (Err = True) Begin
102126>>>>>                                Send Destroy of ho
102127>>>>>                            End
102127>>>>>>
102127>>>>>                            Else Begin
102128>>>>>                                If (iCount = 0) Begin
102130>>>>>                                    Move (iFirstLineOffset + iLocH) to iLocH
102131>>>>>                                End
102131>>>>>>
102131>>>>>                                Set Location of ho to iLocH (iLocW + 30)
102132>>>>>                                Move (iLocH + iHfactor) to iLocH
102133>>>>>                            End
102133>>>>>>
102133>>>>>                        Loop
102134>>>>>>
102134>>>>>    
102134>>>>>                        Send Trap_Error of Error_Object_Id CLIERR_CONNECTIONIDOUTOFRANGE
102135>>>>>                        Send Trap_Error of Error_Object_Id DFERR_UNSUPPORTED_ATTRIBUTE
102136>>>>>                    End_Procedure
102137>>>>>    
102137>>>>>                End_Object
102138>>>>>
102138>>>>>            End_Object
102139>>>>>    
102139>>>>>        End_Object
102140>>>>>
102140>>>>>    End_Object
102141>>>>>
102141>>>>>    Object oInfo_edt is a cRichEdit
102143>>>>>        Set Size to 49 328
102144>>>>>        Set Location to 213 9
102145>>>>>        Set Label to "General Connectivity Kit Information:"
102146>>>>>        Set Value to "It is possible to configure the behavior of a Connectivity Kit through configuration files. Configuration files can be located anywhere in DFPATH. In general, one configuration file per install is enough. There are situations where there is a need to have different configurations for different deploy environments on one machine/network. In that case the configuration file should be placed in the deployment environment rather than in the overall DataFlex environment."
102147>>>>>        Set Skip_State to True
102148>>>>>        Set Read_Only_State to True
102149>>>>>        Set pbItalics to True
102150>>>>>        Set peAnchors to anBottomLeftRight
102151>>>>>
102151>>>>>        Procedure DoIndent
102154>>>>>            Integer iTwipsPerInch iCurrentIndent
102154>>>>>        
102154>>>>>            // number of twips per inch
102154>>>>>            Move 1440 to iTwipsPerInch
102155>>>>>        
102155>>>>>            Set piSpacingBefore to (1440 * 0.05)
102156>>>>>            // indent 0.1 inches from current indentation
102156>>>>>            Get piParagraphIndent to iCurrentIndent
102157>>>>>            Set piParagraphIndent to (iCurrentIndent + (iTwipsPerInch * 0.1))
102158>>>>>        End_Procedure
102159>>>>>        Send DoIndent
102160>>>>>
102160>>>>>    End_Object
102161>>>>>
102161>>>>>    Procedure Activating
102164>>>>>        Forward Send Activating
102166>>>>>        Send Cursor_Ready of Cursor_Control
102167>>>>>    End_Procedure
102168>>>>>
102168>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
102169>>>>>    On_Key kCancel       Send KeyAction of oCancel_Btn
102170>>>>>End_Object
102171>>>>>
102171>>>>>// General purpose access method for the dialog above:
102171>>>>>Procedure PopupDriverSettings String sDriverID 
102174>>>>>    Handle ho
102174>>>>>    String sDriverFile sPath
102174>>>>>
102174>>>>>    Send Cursor_Wait of Cursor_Control
102175>>>>>    Move (oDriverSettings_dg(Self)) to ho
102176>>>>>    Set psDriverID of ho to sDriverID
102177>>>>>    Set pbDriverLoadingError of ho to False
102178>>>>>
102178>>>>>    Set Value of (oDriver_cf(ho)) to sDriverID
102179>>>>>    Get DatabaseDriverPath sDriverID to sPath
102180>>>>>    If (sPath <> "") Begin
102182>>>>>        Move (sDriverID + ".dll")  to sDriverFile
102183>>>>>    End
102183>>>>>>
102183>>>>>    Set Value of (oDriverFileName_cf(ho)) to (sPath + sDriverFile)
102184>>>>>    Send Cursor_Ready of Cursor_Control
102185>>>>>
102185>>>>>    Send Popup of ho
102186>>>>>End_Procedure
102187>>>>>
102187>>>>>Function DatabaseDriverPath String sDriverID Returns String
102190>>>>>    String sPath sDriverFileName
102190>>>>>
102190>>>>>    Move "" to sPath
102191>>>>>    If (sDriverID = DATAFLEX_ID) Begin
102193>>>>>        Function_Return sPath
102194>>>>>    End                   
102194>>>>>>
102194>>>>>    
102194>>>>>    Move (sDriverID + ".dll") to sDriverFileName
102195>>>>>    Get SearchLocallyThenGloballyForFile of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDriverFileName to sPath
102196>>>>>    
102196>>>>>    Function_Return sPath
102197>>>>>End_Function      
102198>>>>>
102198>>>>>Function DatabaseDriverIniFilePath String sDriverID Returns String
102201>>>>>    String sPath sDriverFileName
102201>>>>>
102201>>>>>    Move "" to sPath
102202>>>>>    If (sDriverID = DATAFLEX_ID) Begin
102204>>>>>        Function_Return sPath
102205>>>>>    End                   
102205>>>>>>
102205>>>>>    
102205>>>>>    Move (sDriverID + ".int") to sDriverFileName
102206>>>>>    Get SearchLocallyThenGloballyForFile of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) sDriverFileName to sPath
102207>>>>>    
102207>>>>>    Function_Return sPath
102208>>>>>End_Function      
102209>>>Use CreateDatabase.dg
Including file: CreateDatabase.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\CreateDatabase.dg)
102209>>>>>Use Windows.pkg
102209>>>>>Use cRDCModalPanel.pkg
102209>>>>>Use cRDCForm.pkg 
102209>>>>>Use cRDCComboForm.pkg
102209>>>>>Use cRDCSuggestionIniForm.pkg
Including file: cRDCSuggestionIniForm.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cRDCSuggestionIniForm.pkg)
102209>>>>>>>//****************************************************************************
102209>>>>>>>// $Module type: Class
102209>>>>>>>// $Module name: cRDCSuggestionIniForm
102209>>>>>>>// $Author     : Nils Svedmyr, RDC Tools International, <mailto:support@rdctools.com>
102209>>>>>>>// Web-site    : http://www.rdctools.com
102209>>>>>>>// Created     : 2018-09-05 @ 09:50 (Military date format: YY-MM-DD)
102209>>>>>>>//
102209>>>>>>>// Description : The class consists of a variant of DataAccess Worldwide's cSuggestionFormList
102209>>>>>>>//               It has the added ability to save/retrieve values to the workspace .ws file.
102209>>>>>>>//
102209>>>>>>>// $Rev History:
102209>>>>>>>//    2018-09-05  Module header created
102209>>>>>>>//
102209>>>>>>>//****************************************************************************
102209>>>>>>>Use Windows.pkg
102209>>>>>>>Use Windows.pkg
102209>>>>>>>Use WinSuggestion.pkg
Including file: WinSuggestion.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\WinSuggestion.pkg)
102209>>>>>>>>>Use Windows.pkg
102209>>>>>>>>>Use tWinStructs.pkg
102209>>>>>>>>>Use tSuggestion.pkg
Including file: tSuggestion.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\tSuggestion.pkg)
102209>>>>>>>>>>>// struct used for suggestion forms, representing an item of data
102209>>>>>>>>>>>Enum_List 
102209>>>>>>>>>>>    Define smFind
102209>>>>>>>>>>>    Define smValidationTable
102209>>>>>>>>>>>    Define smCustom
102209>>>>>>>>>>>End_Enum_List
102209>>>>>>>>>>>
102209>>>>>>>>>>>Struct tSuggestion
102209>>>>>>>>>>>    String sRowId
102209>>>>>>>>>>>    String[] aValues
102209>>>>>>>>>>>End_Struct
102209>>>>>>>>>>>
102209>>>>>>>>>Use cTimer.pkg
Including file: cTimer.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cTimer.pkg)
102209>>>>>>>>>>>// This supercedes the DFTimer class.
102209>>>>>>>>>>>// It is simpler and more flexible
102209>>>>>>>>>>>
102209>>>>>>>>>>>Use Dftimer.pkg // we still use the Timer Manager classes and global objects
Including file: Dftimer.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\Dftimer.pkg)
102209>>>>>>>>>>>>>Use LanguageText.pkg
102209>>>>>>>>>>>>>Use Windows.pkg
102209>>>>>>>>>>>>>Use WinUser.pkg
102209>>>>>>>>>>>>>
102209>>>>>>>>>>>>>External_Function SetTimer "SetTimer" User32.DLL ;    Handle  hWnd ;    Longptr idTimer ;    Integer idTimeout ;    Pointer tmprc ;    Returns Longptr     // return type is UINT_PTR
102210>>>>>>>>>>>>>
102210>>>>>>>>>>>>>External_Function KillTimer "KillTimer" User32.DLL ;    Handle  hWnd ;    Longptr idTimer ;    Returns Integer
102211>>>>>>>>>>>>>
102211>>>>>>>>>>>>>// This global integer holds the ID of the object
102211>>>>>>>>>>>>>// that manages all timers.
102211>>>>>>>>>>>>>Integer giTimerManager
102211>>>>>>>>>>>>>
102211>>>>>>>>>>>>>// This class is used to store the object IDs
102211>>>>>>>>>>>>>// of the active timer objects. It augments
102211>>>>>>>>>>>>>// the Destroy_Object procedure to notify
102211>>>>>>>>>>>>>// the DFTimerManager to kill all its active
102211>>>>>>>>>>>>>// timers.
102211>>>>>>>>>>>>>// NOTE: This class looks very much like the
102211>>>>>>>>>>>>>// Set class. I didn't want to use Set because
102211>>>>>>>>>>>>>// Remove_Element shifts items which I don't
102211>>>>>>>>>>>>>// want to happen because item numbers are used
102211>>>>>>>>>>>>>// as timerIDs.
102211>>>>>>>>>>>>>
102211>>>>>>>>>>>>>Class TimersArray is an Array
102212>>>>>>>>>>>>>    
102212>>>>>>>>>>>>>    Function Find_Object Integer iObj Returns Integer
102214>>>>>>>>>>>>>        Integer iMax
102214>>>>>>>>>>>>>        Integer iItem
102214>>>>>>>>>>>>>        Integer iValue
102214>>>>>>>>>>>>>        Get Item_count to iMax
102215>>>>>>>>>>>>>        Decrement iMax
102216>>>>>>>>>>>>>        For iItem from 1 to iMax
102222>>>>>>>>>>>>>>
102222>>>>>>>>>>>>>            Get Integer_Value iItem to iValue
102223>>>>>>>>>>>>>            If (iValue = iObj) ;                Function_Return iItem
102226>>>>>>>>>>>>>        Loop
102227>>>>>>>>>>>>>>
102227>>>>>>>>>>>>>        Function_Return -1
102228>>>>>>>>>>>>>    End_Function
102229>>>>>>>>>>>>>    
102229>>>>>>>>>>>>>    Procedure Add_Object Integer iObj Returns Integer
102231>>>>>>>>>>>>>        Integer iItem
102231>>>>>>>>>>>>>        Get Find_Object iObj to iItem
102232>>>>>>>>>>>>>        If (iItem < 0) Begin
102234>>>>>>>>>>>>>            Get Find_Object 0 to iItem
102235>>>>>>>>>>>>>            If (iItem < 0) ;                Get Item_Count to iItem
102238>>>>>>>>>>>>>        End
102238>>>>>>>>>>>>>>
102238>>>>>>>>>>>>>        Set Array_Value iItem to iObj
102239>>>>>>>>>>>>>        Procedure_Return iItem
102240>>>>>>>>>>>>>    End_Procedure
102241>>>>>>>>>>>>>    
102241>>>>>>>>>>>>>    Procedure Remove_Object Integer iObj
102243>>>>>>>>>>>>>        Integer iItem
102243>>>>>>>>>>>>>        Get Find_Object iObj to iItem
102244>>>>>>>>>>>>>        If (iItem > 0) ;            Set Array_Value iItem to 0
102247>>>>>>>>>>>>>    End_Procedure
102248>>>>>>>>>>>>>    
102248>>>>>>>>>>>>>    Procedure Destroy_Object
102250>>>>>>>>>>>>>        Delegate Send Kill_All_Timers
102252>>>>>>>>>>>>>        Forward Send Destroy_Object
102254>>>>>>>>>>>>>    End_Procedure
102255>>>>>>>>>>>>>    
102255>>>>>>>>>>>>>End_Class
102256>>>>>>>>>>>>>
102256>>>>>>>>>>>>>// This class is the actual timer manager
102256>>>>>>>>>>>>>// A timer will be created when Message Set_Timer_Active_State
102256>>>>>>>>>>>>>// has been send. This message needs two arguments. The first
102256>>>>>>>>>>>>>// is the objectID of the object to receive the timer event,
102256>>>>>>>>>>>>>// and the second is state. The object which ID has been passed,
102256>>>>>>>>>>>>>// needs to have a Timeout property to return the timeout for the
102256>>>>>>>>>>>>>// timer and it also needs to handle the MSG_OnTimer whenever a
102256>>>>>>>>>>>>>// timer event occurs.
102256>>>>>>>>>>>>>// The objectID of the Object will be placed in an array which contains
102256>>>>>>>>>>>>>// the objectIDs of all active timers. The Windows timer ID of a timer
102256>>>>>>>>>>>>>// is the itemnumber of the object in the array.
102256>>>>>>>>>>>>>//
102256>>>>>>>>>>>>>Class DFTimerManager is a DfBaseControl
102257>>>>>>>>>>>>>    
102257>>>>>>>>>>>>>    Procedure Construct_Object
102259>>>>>>>>>>>>>        
102259>>>>>>>>>>>>>        Forward Send Construct_Object
102261>>>>>>>>>>>>>        
102261>>>>>>>>>>>>>        Set Visible_State to False
102262>>>>>>>>>>>>>        
102262>>>>>>>>>>>>>        Set External_Class_Name "cVdfTimer" to "static"
102263>>>>>>>>>>>>>        Set External_Message WM_TIMER to OnTimer
102264>>>>>>>>>>>>>        
102264>>>>>>>>>>>>>        Object TimersArray is a TimersArray
102266>>>>>>>>>>>>>            Set Array_Value 0 to -9999 // So we don't use item 0
102267>>>>>>>>>>>>>        End_Object
102268>>>>>>>>>>>>>        
102268>>>>>>>>>>>>>        Move Self to giTimerManager
102269>>>>>>>>>>>>>        
102269>>>>>>>>>>>>>    End_Procedure
102270>>>>>>>>>>>>>    
102270>>>>>>>>>>>>>    Procedure Set Timer_Active_State Integer iObj Integer iState
102272>>>>>>>>>>>>>        Integer iTimerID
102272>>>>>>>>>>>>>        Integer iTimeout
102272>>>>>>>>>>>>>        Integer iResult
102272>>>>>>>>>>>>>        Integer iSet
102272>>>>>>>>>>>>>        DWord   nResult
102272>>>>>>>>>>>>>        Handle  hWnd
102272>>>>>>>>>>>>>        
102272>>>>>>>>>>>>>        // Get the handle of this object
102272>>>>>>>>>>>>>        Get Window_Handle to hWnd
102273>>>>>>>>>>>>>        If (not(hWnd)) Begin
102275>>>>>>>>>>>>>            Error DFERR_DFTIMER C_$TimerNoHandle
102276>>>>>>>>>>>>>>
102276>>>>>>>>>>>>>            Procedure_Return
102277>>>>>>>>>>>>>        End
102277>>>>>>>>>>>>>>
102277>>>>>>>>>>>>>        
102277>>>>>>>>>>>>>        // Test if handle is valid. If not, we leave.
102277>>>>>>>>>>>>>        If (not(IsWindow(hWnd))) ;            Procedure_Return
102280>>>>>>>>>>>>>        
102280>>>>>>>>>>>>>        Move (TimersArray(Self)) to iSet
102281>>>>>>>>>>>>>        
102281>>>>>>>>>>>>>        If (iSet) Begin
102283>>>>>>>>>>>>>            
102283>>>>>>>>>>>>>            // Let's create or modify a timer
102283>>>>>>>>>>>>>            If iState Begin
102285>>>>>>>>>>>>>                
102285>>>>>>>>>>>>>                // Get the exising to new TimerID
102285>>>>>>>>>>>>>                Get MSG_Add_Object of iSet iObj to iTimerID
102286>>>>>>>>>>>>>                
102286>>>>>>>>>>>>>                // Set/Modify the timer
102286>>>>>>>>>>>>>                Get Timeout of iObj to iTimeout
102287>>>>>>>>>>>>>                Move (SetTimer(hWnd, iTimerID, iTimeout, 0)) to iResult
102288>>>>>>>>>>>>>                If not iResult Begin
102290>>>>>>>>>>>>>                    Error DFERR_DFTIMER C_$TooManyTimers
102291>>>>>>>>>>>>>>
102291>>>>>>>>>>>>>                    Procedure_Return
102292>>>>>>>>>>>>>                End
102292>>>>>>>>>>>>>>
102292>>>>>>>>>>>>>                
102292>>>>>>>>>>>>>            End
102292>>>>>>>>>>>>>>
102292>>>>>>>>>>>>>            
102292>>>>>>>>>>>>>            // Let's kill an existing timer
102292>>>>>>>>>>>>>            Else Begin
102293>>>>>>>>>>>>>                
102293>>>>>>>>>>>>>                // Look up the object in the set
102293>>>>>>>>>>>>>                Get Find_Object of iSet iObj to iTimerID
102294>>>>>>>>>>>>>                
102294>>>>>>>>>>>>>                If (iTimerID = -1) ;                    Procedure_Return
102297>>>>>>>>>>>>>                
102297>>>>>>>>>>>>>                // Kill the timer
102297>>>>>>>>>>>>>                Move (KillTimer(hWnd, iTimerID)) to iResult
102298>>>>>>>>>>>>>                If not iResult Begin
102300>>>>>>>>>>>>>                    Move (GetLastError()) to nResult
102301>>>>>>>>>>>>>                    Error DFERR_DFTIMER (C_$CantKillTimer * String(nResult) - "!")
102302>>>>>>>>>>>>>>
102302>>>>>>>>>>>>>                    Procedure_Return
102303>>>>>>>>>>>>>                End
102303>>>>>>>>>>>>>>
102303>>>>>>>>>>>>>                
102303>>>>>>>>>>>>>                // Remove the objectID
102303>>>>>>>>>>>>>                Send Remove_Object to iSet iObj
102304>>>>>>>>>>>>>            End
102304>>>>>>>>>>>>>>
102304>>>>>>>>>>>>>        End
102304>>>>>>>>>>>>>>
102304>>>>>>>>>>>>>    End_Procedure
102305>>>>>>>>>>>>>    
102305>>>>>>>>>>>>>    Function Timer_Active_State Integer iObj Returns Integer
102307>>>>>>>>>>>>>        Integer iResult
102307>>>>>>>>>>>>>        Get Find_Object of (TimersArray(Self)) iObj to iResult
102308>>>>>>>>>>>>>        Function_Return (iResult<>-1) // note: -1= not found
102309>>>>>>>>>>>>>    End_Function
102310>>>>>>>>>>>>>    
102310>>>>>>>>>>>>>    // Will be called by the Set when it is being destroyed.
102310>>>>>>>>>>>>>    Procedure Kill_All_Timers
102312>>>>>>>>>>>>>        Integer iMax
102312>>>>>>>>>>>>>        Integer iSet
102312>>>>>>>>>>>>>        Integer iItem
102312>>>>>>>>>>>>>        Integer iObj
102312>>>>>>>>>>>>>        Integer iResult
102312>>>>>>>>>>>>>        Handle  hWnd
102312>>>>>>>>>>>>>        
102312>>>>>>>>>>>>>        // Get the handle of this object
102312>>>>>>>>>>>>>        Get Window_Handle to hWnd
102313>>>>>>>>>>>>>        If (not(hWnd)) Begin
102315>>>>>>>>>>>>>            Error DFERR_DFTIMER C_$TimerNoHandle
102316>>>>>>>>>>>>>>
102316>>>>>>>>>>>>>            Procedure_Return
102317>>>>>>>>>>>>>        End
102317>>>>>>>>>>>>>>
102317>>>>>>>>>>>>>        
102317>>>>>>>>>>>>>        // If the window handle is no longer valid, we
102317>>>>>>>>>>>>>        // leave this procedure. This can happen when the
102317>>>>>>>>>>>>>        // program is begin aborted using Exit_Application
102317>>>>>>>>>>>>>        If (not(IsWindow(hWnd))) ;            Procedure_Return
102320>>>>>>>>>>>>>        
102320>>>>>>>>>>>>>        // Scan the set and kill all known timers
102320>>>>>>>>>>>>>        Move (TimersArray(Self)) to iSet
102321>>>>>>>>>>>>>        If (iSet) Begin
102323>>>>>>>>>>>>>            Get Item_Count of iSet to iMax
102324>>>>>>>>>>>>>            Decrement iMax
102325>>>>>>>>>>>>>            For iItem from 1 to iMax
102331>>>>>>>>>>>>>>
102331>>>>>>>>>>>>>                Get Integer_Value of iSet iItem to iObj
102332>>>>>>>>>>>>>                If iObj Begin
102334>>>>>>>>>>>>>                    Move (KillTimer(hWnd, iItem)) to iResult
102335>>>>>>>>>>>>>                    Set Array_Value of iSet iItem to 0
102336>>>>>>>>>>>>>                End
102336>>>>>>>>>>>>>>
102336>>>>>>>>>>>>>            Loop
102337>>>>>>>>>>>>>>
102337>>>>>>>>>>>>>        End
102337>>>>>>>>>>>>>>
102337>>>>>>>>>>>>>        
102337>>>>>>>>>>>>>    End_Procedure
102338>>>>>>>>>>>>>    
102338>>>>>>>>>>>>>    Procedure OnTimer Integer wParam Integer lParam
102340>>>>>>>>>>>>>        Integer iObj
102340>>>>>>>>>>>>>        Get Integer_Value of (TimersArray(Self)) wParam to iObj
102341>>>>>>>>>>>>>        If not iObj Begin
102343>>>>>>>>>>>>>            Error DFERR_DFTIMER C_$TimerWithoutObject
102344>>>>>>>>>>>>>>
102344>>>>>>>>>>>>>            Procedure_Return
102345>>>>>>>>>>>>>        End
102345>>>>>>>>>>>>>>
102345>>>>>>>>>>>>>        Send OnTimer to iObj wParam lParam
102346>>>>>>>>>>>>>    End_Procedure
102347>>>>>>>>>>>>>    
102347>>>>>>>>>>>>>    Procedure Destroy_Object
102349>>>>>>>>>>>>>        Send Kill_All_Timers
102350>>>>>>>>>>>>>        Forward Send Destroy_Object
102352>>>>>>>>>>>>>        Move 0 to giTimerManager
102353>>>>>>>>>>>>>    End_Procedure
102354>>>>>>>>>>>>>    
102354>>>>>>>>>>>>>End_Class
102355>>>>>>>>>>>>>
102355>>>>>>>>>>>>>
102355>>>>>>>>>>>>>
102355>>>>>>>>>>>>>
102355>>>>>>>>>>>>>// This class acts as a container for the
102355>>>>>>>>>>>>>// timer manager object. This is needed because
102355>>>>>>>>>>>>>// A DFTimerManager object created directly at the
102355>>>>>>>>>>>>>// desktop doesn't have a Window_Handle which we
102355>>>>>>>>>>>>>// need to create a Windoows timer. By placing
102355>>>>>>>>>>>>>// this non-visual container around the timer
102355>>>>>>>>>>>>>// manager, it does get a Window_Handle.
102355>>>>>>>>>>>>>// The procedure End_Construct_Object has been
102355>>>>>>>>>>>>>// augmented to create a window and also
102355>>>>>>>>>>>>>// automatically page all children, which will
102355>>>>>>>>>>>>>// be the timer manager.
102355>>>>>>>>>>>>>//
102355>>>>>>>>>>>>>Class DFTimerManagerPanel is a dfBasePanel
102356>>>>>>>>>>>>>    
102356>>>>>>>>>>>>>    Procedure Construct_Object
102358>>>>>>>>>>>>>        Forward Send Construct_Object
102360>>>>>>>>>>>>>        Set Visible_State to False
102361>>>>>>>>>>>>>        Object DFTimerManager is a DFTimerManager
102363>>>>>>>>>>>>>        End_Object
102364>>>>>>>>>>>>>    End_Procedure
102365>>>>>>>>>>>>>    
102365>>>>>>>>>>>>>    Procedure End_Construct_Object
102367>>>>>>>>>>>>>        Forward Send End_Construct_Object
102369>>>>>>>>>>>>>        Send Page_Object True
102370>>>>>>>>>>>>>        Broadcast Send Page_Object True
102372>>>>>>>>>>>>>    End_Procedure
102373>>>>>>>>>>>>>    
102373>>>>>>>>>>>>>End_Class
102374>>>>>>>>>>>>>
102374>>>>>>>>>>>>>// This is the class the user uses to create DFTimer objects
102374>>>>>>>>>>>>>
102374>>>>>>>>>>>>>
102374>>>>>>>>>>>>>//{ OverrideProperty=Skip_State DesignTime=False }
102374>>>>>>>>>>>>>//{ OverrideProperty=TypeFace DesignTime=False }
102374>>>>>>>>>>>>>Class DFTimer is a Textbox
102375>>>>>>>>>>>>>    
102375>>>>>>>>>>>>>    Procedure Construct_Object
102377>>>>>>>>>>>>>        Forward Send Construct_Object
102379>>>>>>>>>>>>>        
102379>>>>>>>>>>>>>        // Make sure this object never appears
102379>>>>>>>>>>>>>        Set Visible_State to False
102380>>>>>>>>>>>>>        
102380>>>>>>>>>>>>>        Property Integer Private.Timeout    1000
102381>>>>>>>>>>>>>        
102381>>>>>>>>>>>>>        Property Integer Timer_Message      0
102382>>>>>>>>>>>>>        Property Integer Timer_Object       0
102383>>>>>>>>>>>>>        Property Integer Auto_Start_State   True
102384>>>>>>>>>>>>>        Property Integer Auto_Stop_State    True
102385>>>>>>>>>>>>>    End_Procedure
102386>>>>>>>>>>>>>    
102386>>>>>>>>>>>>>    Procedure Set Timer_Active_State Integer iState
102388>>>>>>>>>>>>>        Integer iObj
102388>>>>>>>>>>>>>        Move Self to iObj
102389>>>>>>>>>>>>>        If giTimerManager ;            Set Timer_Active_State of giTimerManager iObj to iState
102392>>>>>>>>>>>>>    End_Procedure
102393>>>>>>>>>>>>>    
102393>>>>>>>>>>>>>    Function Timer_Active_State Returns Integer
102395>>>>>>>>>>>>>        Integer iState
102395>>>>>>>>>>>>>        Integer iObj
102395>>>>>>>>>>>>>        Move Self to iObj
102396>>>>>>>>>>>>>        If giTimerManager ;            Get Timer_Active_State of giTimerManager iObj to iState
102399>>>>>>>>>>>>>        Function_Return iState
102400>>>>>>>>>>>>>    End_Function
102401>>>>>>>>>>>>>    
102401>>>>>>>>>>>>>    Procedure Set Timeout Integer iTimeout
102403>>>>>>>>>>>>>        Integer iActive
102403>>>>>>>>>>>>>        Set Private.Timeout to iTimeout
102404>>>>>>>>>>>>>        Get Timer_Active_State to iActive
102405>>>>>>>>>>>>>        If iActive ;            Set Timer_Active_State to True
102408>>>>>>>>>>>>>    End_Procedure
102409>>>>>>>>>>>>>    
102409>>>>>>>>>>>>>    Function Timeout Returns Integer
102411>>>>>>>>>>>>>        Integer iTimeout
102411>>>>>>>>>>>>>        Get Private.Timeout to iTimeout
102412>>>>>>>>>>>>>        Function_Return iTimeout
102413>>>>>>>>>>>>>    End_Function
102414>>>>>>>>>>>>>    
102414>>>>>>>>>>>>>    Procedure OnTimer Integer iwParam Integer ilParam
102416>>>>>>>>>>>>>        Integer iMsg
102416>>>>>>>>>>>>>        Integer iObj
102416>>>>>>>>>>>>>        Get Timer_Message to iMsg
102417>>>>>>>>>>>>>        If (iMsg) Begin
102419>>>>>>>>>>>>>            Get Timer_Object  to iObj
102420>>>>>>>>>>>>>            If iObj ;                Send iMsg to iObj iwParam ilParam
102423>>>>>>>>>>>>>            Else ;                Send iMsg iwParam ilParam
102425>>>>>>>>>>>>>        End
102425>>>>>>>>>>>>>>
102425>>>>>>>>>>>>>    End_Procedure
102426>>>>>>>>>>>>>    
102426>>>>>>>>>>>>>    // Augmented to Auto_Start a timer
102426>>>>>>>>>>>>>    //
102426>>>>>>>>>>>>>    Procedure Page_Object Integer iState
102428>>>>>>>>>>>>>        Forward Send Page_Object iState
102430>>>>>>>>>>>>>        If (iState and Auto_Start_State(Self)) ;            Set Timer_Active_State to True
102433>>>>>>>>>>>>>    End_Procedure
102434>>>>>>>>>>>>>    
102434>>>>>>>>>>>>>    // Augmented to Auto_Stop a timer
102434>>>>>>>>>>>>>    //
102434>>>>>>>>>>>>>    Procedure Page_Delete
102436>>>>>>>>>>>>>        If (Auto_Stop_State(Self)) ;            Set Timer_Active_State to False
102439>>>>>>>>>>>>>        Forward Send Page_Delete
102441>>>>>>>>>>>>>    End_Procedure
102442>>>>>>>>>>>>>    
102442>>>>>>>>>>>>>    // Augmented to stop the timer
102442>>>>>>>>>>>>>    //
102442>>>>>>>>>>>>>    Procedure Destroy_Object
102444>>>>>>>>>>>>>        Set Timer_Active_State to False
102445>>>>>>>>>>>>>        Forward Send Destroy_Object
102447>>>>>>>>>>>>>    End_Procedure
102448>>>>>>>>>>>>>    
102448>>>>>>>>>>>>>End_Class
102449>>>>>>>>>>>>>
102449>>>>>>>>>>>>>//
102449>>>>>>>>>>>>>// This was moved into a method so it can be reliable created
102449>>>>>>>>>>>>>// at the desktop. Note that cDesktop adds method to cDesktop class (class of desktop)
102449>>>>>>>>>>>>>//
102449>>>>>>>>>>>>>Procedure CreateDfTimerManagerPanel for cDesktop
102451>>>>>>>>>>>>>    // Create the Desktop Timer Manager Object.
102451>>>>>>>>>>>>>    Object DFTimerManagerPanel is a DFTimerManagerPanel
102453>>>>>>>>>>>>>    End_Object
102454>>>>>>>>>>>>>End_Procedure
102455>>>>>>>>>>>>>
102455>>>>>>>>>>>>>Send CreateDfTimerManagerPanel of DESKTOP
102456>>>>>>>>>>>
102456>>>>>>>>>>>Class cTimer is a cObject
102457>>>>>>>>>>>    
102457>>>>>>>>>>>    Procedure Construct_Object
102459>>>>>>>>>>>        Forward Send Construct_Object
102461>>>>>>>>>>>        Property Integer piPrivate_Timeout 1000
102462>>>>>>>>>>>    End_Procedure
102463>>>>>>>>>>>    
102463>>>>>>>>>>>    Procedure Set pbEnabled Boolean bEnabled
102465>>>>>>>>>>>        If giTimerManager Begin
102467>>>>>>>>>>>            Set Timer_Active_State of giTimerManager Self to bEnabled
102468>>>>>>>>>>>        End
102468>>>>>>>>>>>>
102468>>>>>>>>>>>    End_Procedure
102469>>>>>>>>>>>    
102469>>>>>>>>>>>    Function pbEnabled Returns Boolean
102471>>>>>>>>>>>        Boolean bEnabled
102471>>>>>>>>>>>        If giTimerManager Begin
102473>>>>>>>>>>>            Get Timer_Active_State of giTimerManager Self to bEnabled
102474>>>>>>>>>>>        End
102474>>>>>>>>>>>>
102474>>>>>>>>>>>        Function_Return bEnabled
102475>>>>>>>>>>>    End_Function
102476>>>>>>>>>>>    
102476>>>>>>>>>>>    Procedure Set piTimeout Integer iTimeout
102478>>>>>>>>>>>        Boolean bEnabled
102478>>>>>>>>>>>        Set piPrivate_Timeout to iTimeout
102479>>>>>>>>>>>        Get pbEnabled to bEnabled
102480>>>>>>>>>>>        If bEnabled Begin
102482>>>>>>>>>>>            Set pbEnabled to True
102483>>>>>>>>>>>        End
102483>>>>>>>>>>>>
102483>>>>>>>>>>>    End_Procedure
102484>>>>>>>>>>>    
102484>>>>>>>>>>>    Function piTimeout Returns Integer
102486>>>>>>>>>>>        Integer iTimeout
102486>>>>>>>>>>>        Get piPrivate_Timeout to iTimeout
102487>>>>>>>>>>>        Function_Return iTimeout
102488>>>>>>>>>>>    End_Function
102489>>>>>>>>>>>    
102489>>>>>>>>>>>    Procedure OnTimer
102491>>>>>>>>>>>    End_Procedure
102492>>>>>>>>>>>    
102492>>>>>>>>>>>    // this is needed by the timer manager
102492>>>>>>>>>>>    Function Timeout Returns Integer
102494>>>>>>>>>>>        Integer iTimeout
102494>>>>>>>>>>>        Get piPrivate_Timeout to iTimeout
102495>>>>>>>>>>>        Function_Return iTimeout
102496>>>>>>>>>>>    End_Function
102497>>>>>>>>>>>    
102497>>>>>>>>>>>    Procedure Destroy_Object
102499>>>>>>>>>>>        Set pbEnabled to False
102500>>>>>>>>>>>        Forward Send Destroy_Object
102502>>>>>>>>>>>    End_Procedure
102503>>>>>>>>>>>    
102503>>>>>>>>>>>End_Class
102504>>>>>>>>>Use cRichEdit.pkg
102504>>>>>>>>>Use sql.pkg
102504>>>>>>>>>
102504>>>>>>>>>// defines interface for cWindowMesageHook - currently a private runtime class
102504>>>>>>>>>Define     U_DFWINDOWSMESSAGEHOOK  for |CI0106
102504>>>>>>>>>Define     GET_ENABLEWINDOWSHOOK   for |CI$0542
102504>>>>>>>>>Define     MSG_DISABLEWINDOWSHOOK  for |CI$0543
102504>>>>>>>>>Define     GET_ONWINDOWSHOOK       for |CI$0544
102504>>>>>>>>>Define     WH_MOUSE for 7
102504>>>>>>>>>Define     WH_KEYBOARD for 2
102504>>>>>>>>>
102504>>>>>>>>>
102504>>>>>>>>>// suggestion lists use a global timer and a global suggestion list
102504>>>>>>>>>Global_Variable Handle ghoSuggestionList
102504>>>>>>>>>Move 0 to ghoSuggestionList
102505>>>>>>>>>
102505>>>>>>>>>Global_Variable Handle ghoSuggestionTimer
102505>>>>>>>>>Move 0 to ghoSuggestionTimer
102506>>>>>>>>>
102506>>>>>>>>>// this will get created the first time it is needed.
102506>>>>>>>>>Class cSuggestionTimer is a cTimer
102507>>>>>>>>>    
102507>>>>>>>>>    Procedure Construct_Object
102509>>>>>>>>>        Forward Send Construct_Object
102511>>>>>>>>>        Property Handle phoTimerOwner 0
102512>>>>>>>>>        Set piTimeout to 50
102513>>>>>>>>>    End_Procedure
102514>>>>>>>>>    
102514>>>>>>>>>    Procedure OnTimer
102516>>>>>>>>>        Handle hoOwner
102516>>>>>>>>>        Get phoTimerOwner to hoOwner
102517>>>>>>>>>        // do this in case progam close destroys owner before timer
102517>>>>>>>>>        Get Object_Id of hoOwner to hoOwner
102518>>>>>>>>>        If hoOwner Begin
102520>>>>>>>>>            Send OnSuggestionTimer to hoOwner
102521>>>>>>>>>        End
102521>>>>>>>>>>
102521>>>>>>>>>        Else Begin
102522>>>>>>>>>            // something wrong, shut off timer
102522>>>>>>>>>            Set pbEnabled to False
102523>>>>>>>>>        End
102523>>>>>>>>>>
102523>>>>>>>>>    End_Procedure
102524>>>>>>>>>    
102524>>>>>>>>>End_Class
102525>>>>>>>>>
102525>>>>>>>>>Class cSuggestionHookMouse is a DFWindowsMessageHook
102526>>>>>>>>>    
102526>>>>>>>>>    // If mouse not in suggestion list or form, close suggestionlist
102526>>>>>>>>>    Function OnWindowsHook Integer i1 Integer i2 Integer i3 Returns Integer
102528>>>>>>>>>        tWinMouseHookStruct MouseHook
102528>>>>>>>>>        tWinMouseHookStruct MouseHook
102528>>>>>>>>>        Integer ivoid hObj
102528>>>>>>>>>        Handle hoOwner hoParent
102528>>>>>>>>>        If (i1=0 and (i2=WM_LBUTTONDOWN or i2=WM_RBUTTONDOWN or i2=WM_MBUTTONDOWN or ;            i2=WM_NCLBUTTONDOWN or i2=WM_NCRBUTTONDOWN or i2=WM_NCMBUTTONDOWN)) Begin
102530>>>>>>>>>            Move (CopyMemory(AddressOf(MouseHook), i3, SizeOfType(tWinMouseHookStruct))) to iVoid
102531>>>>>>>>>            GET_OBJECT_FROM_WINDOW MouseHook.hwnd to hObj
102532>>>>>>>>>            Get Parent to hoParent
102533>>>>>>>>>            Get phoOwner of hoParent to hoOwner
102534>>>>>>>>>            If (not(hObj) or (hObj<>hoParent and hObj<>hoOwner)) Begin
102536>>>>>>>>>                Send DisableWindowsHook
102537>>>>>>>>>                Send DeActivateSuggestionList of hoOwner
102538>>>>>>>>>            End
102538>>>>>>>>>>
102538>>>>>>>>>        End
102538>>>>>>>>>>
102538>>>>>>>>>    End_Function
102539>>>>>>>>>    
102539>>>>>>>>>    Procedure End_Construct_Object
102541>>>>>>>>>        Boolean bOk
102541>>>>>>>>>        Forward Send End_Construct_Object
102543>>>>>>>>>        Get EnableWindowsHook WH_MOUSE to bOk
102544>>>>>>>>>    End_Procedure
102545>>>>>>>>>    
102545>>>>>>>>>End_Class
102546>>>>>>>>>
102546>>>>>>>>>Class cSuggestionHookKbd is a DFWindowsMessageHook
102547>>>>>>>>>    
102547>>>>>>>>>    // If menu key, close suggestionlist
102547>>>>>>>>>    Function OnWindowsHook Integer i1 Integer i2 Integer i3 Returns Integer
102549>>>>>>>>>        Handle hoOwner
102549>>>>>>>>>        If (i1=0 and i2=VK_MENU) Begin
102551>>>>>>>>>            Delegate Get phoOwner to hoOwner
102553>>>>>>>>>            Send DisableWindowsHook
102554>>>>>>>>>            Send DeActivateSuggestionList of hoOwner
102555>>>>>>>>>        End
102555>>>>>>>>>>
102555>>>>>>>>>    End_Function
102556>>>>>>>>>    
102556>>>>>>>>>    Procedure End_Construct_Object
102558>>>>>>>>>        Boolean bOk
102558>>>>>>>>>        Forward Send End_Construct_Object
102560>>>>>>>>>        Get EnableWindowsHook WH_KEYBOARD  to bOk
102561>>>>>>>>>    End_Procedure
102562>>>>>>>>>    
102562>>>>>>>>>End_Class
102563>>>>>>>>>
102563>>>>>>>>>Class cSuggestionList is a cRichEdit
102564>>>>>>>>>    
102564>>>>>>>>>    Procedure Construct_Object
102566>>>>>>>>>        Handle hoObj
102566>>>>>>>>>        Forward Send Construct_Object
102568>>>>>>>>>        Property Handle phoOwner
102569>>>>>>>>>        Set Focus_Mode to NonFocusable
102570>>>>>>>>>        Set Attach_Parent_State to True
102571>>>>>>>>>        Set pbWrap to False
102572>>>>>>>>>        If (ghoSuggestionList) Begin
102574>>>>>>>>>            Send Destroy of ghoSuggestionList
102575>>>>>>>>>        End
102575>>>>>>>>>>
102575>>>>>>>>>        Get CreateNamed (RefClass(cSuggestionHookMouse)) "oMouseHook" to hoObj
102576>>>>>>>>>        Get CreateNamed (RefClass(cSuggestionHookKbd))"oKbdHook" to hoObj
102577>>>>>>>>>    End_Procedure
102578>>>>>>>>>    
102578>>>>>>>>>    Procedure Destroy_Object
102580>>>>>>>>>        Forward Send Destroy_Object
102582>>>>>>>>>        Move 0 to ghoSuggestionList
102583>>>>>>>>>    End_Procedure
102584>>>>>>>>>    
102584>>>>>>>>>    Procedure DeactivateList
102586>>>>>>>>>        Set pbEnabled of ghoSuggestionTimer to False
102587>>>>>>>>>        Send Deactivate
102588>>>>>>>>>        Send Destroy
102589>>>>>>>>>    End_Procedure
102590>>>>>>>>>    
102590>>>>>>>>>    Procedure InitList Handle hoForm
102592>>>>>>>>>        Integer iSize iLoc iLoc2
102592>>>>>>>>>        Get GuiSize of hoForm to iSize
102593>>>>>>>>>        Set GuiSize to (Hi(iSize)) (1000)
102594>>>>>>>>>        Get Absolute_GUIOrigin of hoForm to iLoc
102595>>>>>>>>>        Delegate Get Absolute_GUIOrigin to iLoc2
102597>>>>>>>>>        Set GuiLocation to (Hi(iLoc)-Hi(iLoc2)+Hi(iSize)+2) (Low(iLoc)+2-Low(iLoc2))
102598>>>>>>>>>        Set Visible_State to False
102599>>>>>>>>>    End_Procedure
102600>>>>>>>>>    
102600>>>>>>>>>    // scroll up one line
102600>>>>>>>>>    Procedure ScrollUp
102602>>>>>>>>>        Integer iLine
102602>>>>>>>>>        Get SelectedRow to iLine
102603>>>>>>>>>        If (iLine) Begin
102605>>>>>>>>>            Send SelectRow (iLine-1)
102606>>>>>>>>>        End
102606>>>>>>>>>>
102606>>>>>>>>>    End_Procedure
102607>>>>>>>>>    
102607>>>>>>>>>    // scroll down one line
102607>>>>>>>>>    Procedure ScrollDown
102609>>>>>>>>>        Integer iLine iLines
102609>>>>>>>>>        Get Line_Count to iLines
102610>>>>>>>>>        Get SelectedRow to iLine
102611>>>>>>>>>        // there can be an extra line at the end
102611>>>>>>>>>        If (iLine<iLines-1) Begin
102613>>>>>>>>>            Send SelectRow (iLine+1)
102614>>>>>>>>>        End
102614>>>>>>>>>>
102614>>>>>>>>>    End_Procedure
102615>>>>>>>>>    
102615>>>>>>>>>    // sets the current line to iLine and highlights it
102615>>>>>>>>>    Procedure SelectRow Integer iLine
102617>>>>>>>>>        Integer iPos iLen
102617>>>>>>>>>        Get FirstCharInLinePos iLine to iPos
102618>>>>>>>>>        Get LineLength iLine to iLen
102619>>>>>>>>>        Send SetSel iPos (iPos+iLen)
102620>>>>>>>>>    End_Procedure
102621>>>>>>>>>    
102621>>>>>>>>>    // get the current selected Line
102621>>>>>>>>>    Function SelectedRow Returns Integer
102623>>>>>>>>>        Integer iLine
102623>>>>>>>>>        Get LineFromChar -1 to iLine
102624>>>>>>>>>        Function_Return iLine
102625>>>>>>>>>    End_Function
102626>>>>>>>>>    
102626>>>>>>>>>    // select the current row
102626>>>>>>>>>    Procedure Mouse_Up Handle hCell Integer iPos
102628>>>>>>>>>        Handle hoObj
102628>>>>>>>>>        Get phoOwner to hoObj
102629>>>>>>>>>        Send Activate of hoObj // move focus to owner, which will close the list
102630>>>>>>>>>        Send SelectSuggestion of hoObj
102631>>>>>>>>>    End_Procedure
102632>>>>>>>>>    
102632>>>>>>>>>End_Class
102633>>>>>>>>>
102633>>>>>>>>>// This contains mixin support for suggestion logic and contains the interface that
102633>>>>>>>>>// is accessed publicly. This should be mixed into the form or column DEO object
102633>>>>>>>>>Class cSuggestion_mixin is a Mixin
102634>>>>>>>>>    
102634>>>>>>>>>    Procedure Define_cSuggestion_mixin
102636>>>>>>>>>        
102636>>>>>>>>>        Property Integer peSuggestionMode smFind
102637>>>>>>>>>        Property Boolean pbFullText False
102638>>>>>>>>>        Property Boolean pbCaseSensitive False
102639>>>>>>>>>        Property Integer piMaxResults 15
102640>>>>>>>>>        Property Integer piStartAtChar 2
102641>>>>>>>>>        Property Boolean pbFullWidth True
102642>>>>>>>>>        Property Integer piFindIndex 0
102643>>>>>>>>>        Property Boolean pbFindOnSelect True
102644>>>>>>>>>        Property Integer piPopupTimeout 50
102645>>>>>>>>>        
102645>>>>>>>>>        Property tSuggestion[] pSearchResults
102646>>>>>>>>>        
102646>>>>>>>>>        Property Handle phcSuggestionListClass (RefClass(cSuggestionList))
102647>>>>>>>>>        
102647>>>>>>>>>    End_Procedure
102648>>>>>>>>>    
102648>>>>>>>>>    // Display one Suggestion Line in Suggestion List. Good for augmentation although
102648>>>>>>>>>    // this must be done carefully as you must know the suggestionlist interface, which
102648>>>>>>>>>    // if private
102648>>>>>>>>>    Procedure ShowSuggestion tSuggestion SuggestionData String sSearch
102650>>>>>>>>>        Integer i iCols iPos
102650>>>>>>>>>        String sValue
102650>>>>>>>>>        Integer eSuggestionMode
102650>>>>>>>>>        Boolean bFullText
102650>>>>>>>>>        
102650>>>>>>>>>        Get peSuggestionMode to eSuggestionMode
102651>>>>>>>>>        Get pbFullText to bFullText
102652>>>>>>>>>        
102652>>>>>>>>>        Move SuggestionData.aValues[0] to sValue
102653>>>>>>>>>        If (not(bFullText)) Begin
102655>>>>>>>>>            Set pbBold of ghoSuggestionList to True
102656>>>>>>>>>            Send AppendText of ghoSuggestionList (Left(sValue,Length(sSearch)))
102657>>>>>>>>>            Set pbBold of ghoSuggestionList to False
102658>>>>>>>>>            Send AppendText of ghoSuggestionList (Mid(sValue,255,Length(sSearch)+1))
102659>>>>>>>>>        End
102659>>>>>>>>>>
102659>>>>>>>>>        Else Begin
102660>>>>>>>>>            Set pbBold of ghoSuggestionList to False
102661>>>>>>>>>            Move (Pos(Uppercase(sSearch),Uppercase(sValue))) to iPos
102662>>>>>>>>>            If (iPos) Begin
102664>>>>>>>>>                Send AppendText of ghoSuggestionList (Left(sValue,iPos-1))
102665>>>>>>>>>                Set pbBold of ghoSuggestionList to True
102666>>>>>>>>>                Send AppendText of ghoSuggestionList (Mid(sValue,Length(sSearch),iPos))
102667>>>>>>>>>                Set pbBold of ghoSuggestionList to False
102668>>>>>>>>>            End
102668>>>>>>>>>>
102668>>>>>>>>>            Send AppendText of ghoSuggestionList (Mid(sValue,255,iPos+Length(sSearch)))
102669>>>>>>>>>        End
102669>>>>>>>>>>
102669>>>>>>>>>        
102669>>>>>>>>>        // if addiitonal columns (usually validation) we assume the first value is the one that is
102669>>>>>>>>>        // matched and we display all other values (usually just one) to the
102669>>>>>>>>>        // right of it.
102669>>>>>>>>>        Move (SizeOfArray(SuggestionData.aValues)) to iCols
102670>>>>>>>>>        If (iCols>1) Begin
102672>>>>>>>>>            Move "" to sValue
102673>>>>>>>>>            For i from 1 to (iCols-1)
102679>>>>>>>>>>
102679>>>>>>>>>                Move (sValue + If(i=1," - ","  ") + SuggestionData.aValues[i]) to sValue
102680>>>>>>>>>            Loop
102681>>>>>>>>>>
102681>>>>>>>>>            Send AppendText of ghoSuggestionList sValue
102682>>>>>>>>>        End
102682>>>>>>>>>>
102682>>>>>>>>>    End_Procedure
102683>>>>>>>>>    
102683>>>>>>>>>    // used to catch a set_field_value_Error
102683>>>>>>>>>    Procedure Error_Report Integer iError Integer iLine String sErr
102685>>>>>>>>>    End_Procedure
102686>>>>>>>>>    
102686>>>>>>>>>    // does a Set_Field_Value with error testing around it.
102686>>>>>>>>>    Function SafeSetFieldValue Integer iFile Integer iField String sValue Returns Boolean
102688>>>>>>>>>        Handle hoOldError
102688>>>>>>>>>        Boolean bErr
102688>>>>>>>>>        Move Error_Object_Id to hoOldError
102689>>>>>>>>>        Move Self to Error_Object_Id
102690>>>>>>>>>        Move False to Err
102691>>>>>>>>>        Set_Field_Value iFile iField to sValue
102694>>>>>>>>>        Move Err to bErr
102695>>>>>>>>>        Move hoOldError to Error_Object_Id
102696>>>>>>>>>        Function_Return bErr
102697>>>>>>>>>    End_Function
102698>>>>>>>>>    
102698>>>>>>>>>    
102698>>>>>>>>>    Procedure SuggestionsFindIncremental String sSearch tSuggestion[] ByRef aSuggestions
102700>>>>>>>>>        Integer iFile iField iIndex iLen iRow iMax eType iLength iDec
102700>>>>>>>>>        Handle hoServer
102700>>>>>>>>>        Boolean bContinue bCase bOldRelate bNeedsRelate bInvalid
102700>>>>>>>>>        String sVal sLowSearch
102700>>>>>>>>>        RowID riTest
102700>>>>>>>>>        
102700>>>>>>>>>        Get Server to hoServer
102701>>>>>>>>>        Get Data_File  to iFile
102702>>>>>>>>>        Get Data_Field to iField
102703>>>>>>>>>        
102703>>>>>>>>>        If ((hoServer <> 0) and (iFile <> 0)) Begin
102705>>>>>>>>>            Get piFindIndex to iIndex
102706>>>>>>>>>            Get piMaxResults to iMax
102707>>>>>>>>>            Get pbCaseSensitive to bCase
102708>>>>>>>>>            
102708>>>>>>>>>            Get_Attribute DF_FIELD_TYPE of iFile iField to eType
102711>>>>>>>>>            Get_Attribute DF_FIELD_LENGTH of iFile iField to iLength
102714>>>>>>>>>            Get_Attribute DF_FIELD_PRECISION of iFile iField to iDec
102717>>>>>>>>>            
102717>>>>>>>>>            Move (iLength - iDec) to iLength
102718>>>>>>>>>            
102718>>>>>>>>>            If (iIndex <= 0) Begin
102720>>>>>>>>>                Get_Attribute DF_FIELD_INDEX of iFile iField to iIndex
102723>>>>>>>>>            End
102723>>>>>>>>>>
102723>>>>>>>>>            
102723>>>>>>>>>            
102723>>>>>>>>>            
102723>>>>>>>>>            If (iIndex > 0) Begin
102725>>>>>>>>>                Get No_Relate_State of hoServer to bOldRelate
102726>>>>>>>>>                Get DDOConstraintNeedsRelate of hoServer iIndex to bNeedsRelate
102727>>>>>>>>>                Set No_Relate_State of hoServer to (not(bNeedsRelate))
102728>>>>>>>>>                
102728>>>>>>>>>                Move True to bContinue
102729>>>>>>>>>                Move (Length(sSearch)) to iLen
102730>>>>>>>>>                Move (Lowercase(sSearch)) to sLowSearch
102731>>>>>>>>>                Move 0 to iRow
102732>>>>>>>>>                
102732>>>>>>>>>                //  Find first record
102732>>>>>>>>>                Send Request_Read of hoServer FIRST_RECORD iFile iIndex
102733>>>>>>>>>                Get SafeSetFieldValue iFile iField sSearch to bInvalid
102734>>>>>>>>>                If bInvalid Begin
102736>>>>>>>>>                    Move False to bContinue
102737>>>>>>>>>                End
102737>>>>>>>>>>
102737>>>>>>>>>                
102737>>>>>>>>>                If (bContinue) Begin
102739>>>>>>>>>                    Send Request_Read of hoServer GE iFile iIndex
102740>>>>>>>>>                End
102740>>>>>>>>>>
102740>>>>>>>>>                
102740>>>>>>>>>                While (Found and bContinue)
102744>>>>>>>>>                    Get_Field_Value iFile iField to sVal
102747>>>>>>>>>                    
102747>>>>>>>>>                    If ((not(bCase) and Lowercase(Left(sVal, iLen)) = sLowSearch) or (bCase and Left(sVal, iLen) = sSearch)) Begin
102749>>>>>>>>>                        
102749>>>>>>>>>                        Move (SerializeRowID(GetRowID(iFile)))  to aSuggestions[iRow].sRowId
102750>>>>>>>>>                        Move (Trim(sVal))                       to aSuggestions[iRow].aValues[0]
102751>>>>>>>>>                        Increment iRow
102752>>>>>>>>>                        
102752>>>>>>>>>                        Move (iRow < iMax) to bContinue
102753>>>>>>>>>                        
102753>>>>>>>>>                        Send Request_Read of hoServer GT iFile iIndex
102754>>>>>>>>>                    End
102754>>>>>>>>>>
102754>>>>>>>>>                    Else Begin
102755>>>>>>>>>                        If (eType = DF_BCD and Length(sSearch) < iLength) Begin
102757>>>>>>>>>                            //  For numeric fields we'll jump in the index to the next possible value (for example from 40 to 400)
102757>>>>>>>>>                            
102757>>>>>>>>>                            Move (GetRowID(iFile)) to riTest
102758>>>>>>>>>                            
102758>>>>>>>>>                            Move (sSearch * 10) to sSearch
102759>>>>>>>>>                            
102759>>>>>>>>>                            Get SafeSetFieldValue iFile iField sSearch to bInvalid
102760>>>>>>>>>                            If bInvalid Begin
102762>>>>>>>>>                                Move False to bContinue
102763>>>>>>>>>                            End
102763>>>>>>>>>>
102763>>>>>>>>>                            Else Begin
102764>>>>>>>>>                                Send Request_Read of hoServer GE iFile iIndex
102765>>>>>>>>>                                Move (not(IsSameRowID(riTest, GetRowID(iFile)))) to bContinue
102766>>>>>>>>>                            End
102766>>>>>>>>>>
102766>>>>>>>>>                        End
102766>>>>>>>>>>
102766>>>>>>>>>                        Else Begin
102767>>>>>>>>>                            Move False to bContinue
102768>>>>>>>>>                        End
102768>>>>>>>>>>
102768>>>>>>>>>                    End
102768>>>>>>>>>>
102768>>>>>>>>>                    
102768>>>>>>>>>                Loop
102769>>>>>>>>>>
102769>>>>>>>>>                Set No_Relate_State of hoServer to bOldRelate
102770>>>>>>>>>            End
102770>>>>>>>>>>
102770>>>>>>>>>        End
102770>>>>>>>>>>
102770>>>>>>>>>    End_Procedure
102771>>>>>>>>>    
102771>>>>>>>>>    Procedure SuggestionsFindFullText String sSearch tSuggestion[] ByRef aSuggestions
102773>>>>>>>>>        Integer iFile iField iIndex iRow iMax
102773>>>>>>>>>        Handle hoServer
102773>>>>>>>>>        Boolean bContinue bCase  bOldRelate bNeedsRelate
102773>>>>>>>>>        String sVal sLowSearch
102773>>>>>>>>>        
102773>>>>>>>>>        Get Server to hoServer
102774>>>>>>>>>        Get Data_File  to iFile
102775>>>>>>>>>        Get Data_Field to iField
102776>>>>>>>>>        
102776>>>>>>>>>        If ((hoServer <> 0) and (iFile <> 0)) Begin
102778>>>>>>>>>            Get piMaxResults to iMax
102779>>>>>>>>>            Get pbCaseSensitive to bCase
102780>>>>>>>>>            
102780>>>>>>>>>            Get piFindIndex to iIndex
102781>>>>>>>>>            If (iIndex <= 0) Begin
102783>>>>>>>>>                Get_Attribute DF_FIELD_INDEX of iFile iField to iIndex
102786>>>>>>>>>            End
102786>>>>>>>>>>
102786>>>>>>>>>            
102786>>>>>>>>>            Get No_Relate_State of hoServer to bOldRelate
102787>>>>>>>>>            Get DDOConstraintNeedsRelate of hoServer iIndex to bNeedsRelate
102788>>>>>>>>>            Set No_Relate_State of hoServer to (not(bNeedsRelate))
102789>>>>>>>>>            
102789>>>>>>>>>            
102789>>>>>>>>>            Move (Lowercase(sSearch)) to sLowSearch
102790>>>>>>>>>            Move True to bContinue
102791>>>>>>>>>            Move 0 to iRow
102792>>>>>>>>>            
102792>>>>>>>>>            //  Find first record
102792>>>>>>>>>            Send Request_Read of hoServer FIRST_RECORD iFile iIndex
102793>>>>>>>>>            
102793>>>>>>>>>            While (Found and (iRow < iMax))
102797>>>>>>>>>                Get_Field_Value iFile iField to sVal
102800>>>>>>>>>                
102800>>>>>>>>>                If ((bCase and sVal contains sSearch) or (not(bCase) and Lowercase(sVal) contains sLowSearch)) Begin
102802>>>>>>>>>                    Move (SerializeRowID(GetRowID(iFile)))  to aSuggestions[iRow].sRowId
102803>>>>>>>>>                    Move (Trim(sVal))                       to aSuggestions[iRow].aValues[0]
102804>>>>>>>>>                    Increment iRow
102805>>>>>>>>>                End
102805>>>>>>>>>>
102805>>>>>>>>>                
102805>>>>>>>>>                Send Request_Read of hoServer GT iFile iIndex
102806>>>>>>>>>            Loop
102807>>>>>>>>>>
102807>>>>>>>>>            Set No_Relate_State of hoServer to bOldRelate
102808>>>>>>>>>        End
102808>>>>>>>>>>
102808>>>>>>>>>    End_Procedure
102809>>>>>>>>>    
102809>>>>>>>>>    Procedure SuggestionsSQLFullText String sSearch tSuggestion[] ByRef aSuggestions
102811>>>>>>>>>        Integer iFile iField iIndex iRow iMax
102811>>>>>>>>>        Handle hoServer
102811>>>>>>>>>        Boolean bContinue bOrigActive  bOldRelate bNeedsRelate
102811>>>>>>>>>        String sVal sOrigFilter sFilter sFile sField
102811>>>>>>>>>        
102811>>>>>>>>>        Get Server to hoServer
102812>>>>>>>>>        Get Data_File  to iFile
102813>>>>>>>>>        Get Data_Field to iField
102814>>>>>>>>>        
102814>>>>>>>>>        If ((hoServer <> 0) and (iFile <> 0)) Begin
102816>>>>>>>>>            
102816>>>>>>>>>            // make sure we send DD messages to owner DDO
102816>>>>>>>>>            Get Which_Data_Set of hoServer iFile to hoServer
102817>>>>>>>>>            If (hoServer=0) Begin
102819>>>>>>>>>                Procedure_Return
102820>>>>>>>>>            End
102820>>>>>>>>>>
102820>>>>>>>>>            
102820>>>>>>>>>            Get piMaxResults to iMax
102821>>>>>>>>>            Get piFindIndex to iIndex
102822>>>>>>>>>            If (iIndex <= 0) Begin
102824>>>>>>>>>                Get_Attribute DF_FIELD_INDEX of iFile iField to iIndex
102827>>>>>>>>>            End
102827>>>>>>>>>>
102827>>>>>>>>>            
102827>>>>>>>>>            //  Determine current filter settings
102827>>>>>>>>>            Get psSQLFilter of hoServer to sOrigFilter
102828>>>>>>>>>            Get pbUseDDSqlFilters of hoServer to bOrigActive
102829>>>>>>>>>            
102829>>>>>>>>>            // generate the Like filter string
102829>>>>>>>>>            Get SQLStrLike of hoServer iField sSearch to sFilter
102830>>>>>>>>>            // If filtering was active append this to what's there
102830>>>>>>>>>            If (bOrigActive) Begin
102832>>>>>>>>>                Get SQLStrAppend of hoServer sOrigFilter sFilter to sFilter
102833>>>>>>>>>            End
102833>>>>>>>>>>
102833>>>>>>>>>            
102833>>>>>>>>>            //  Set filter
102833>>>>>>>>>            Set psSQLFilter of hoServer to sFilter
102834>>>>>>>>>            Set pbUseDDSqlFilters of hoServer to True
102835>>>>>>>>>            
102835>>>>>>>>>            
102835>>>>>>>>>            // this will optimize No_relate. If your DF constraint does not
102835>>>>>>>>>            // need a post-relate test, we will disabled relates for this
102835>>>>>>>>>            Get No_Relate_State of hoServer to bOldRelate
102836>>>>>>>>>            Get DDOConstraintNeedsRelate of hoServer iIndex to bNeedsRelate
102837>>>>>>>>>            Set No_Relate_State of hoServer to (not(bNeedsRelate))
102838>>>>>>>>>            
102838>>>>>>>>>            //  Find records
102838>>>>>>>>>            Move True to bContinue
102839>>>>>>>>>            Move 0 to iRow
102840>>>>>>>>>            
102840>>>>>>>>>            Send Request_Read of hoServer FIRST_RECORD iFile iIndex
102841>>>>>>>>>            
102841>>>>>>>>>            While (bContinue)
102845>>>>>>>>>                Get_Field_Value iFile iField to sVal
102848>>>>>>>>>                
102848>>>>>>>>>                If (Found) Begin // and ((bCase and sVal contains sSearch) or (not(bCase) and Lowercase(sVal) contains sLowSearch))) Begin
102850>>>>>>>>>                    Move (SerializeRowID(GetRowID(iFile)))  to aSuggestions[iRow].sRowId
102851>>>>>>>>>                    Move (Trim(sVal))                       to aSuggestions[iRow].aValues[0]
102852>>>>>>>>>                    Increment iRow
102853>>>>>>>>>                    
102853>>>>>>>>>                    Move (iRow < iMax) to bContinue
102854>>>>>>>>>                    
102854>>>>>>>>>                    Send Request_Read of hoServer GT iFile iIndex
102855>>>>>>>>>                End
102855>>>>>>>>>>
102855>>>>>>>>>                Else Begin
102856>>>>>>>>>                    Move False to bContinue
102857>>>>>>>>>                End
102857>>>>>>>>>>
102857>>>>>>>>>                
102857>>>>>>>>>            Loop
102858>>>>>>>>>>
102858>>>>>>>>>            
102858>>>>>>>>>            //  Restore filters
102858>>>>>>>>>            Set psSQLFilter of hoServer to sOrigFilter
102859>>>>>>>>>            Set pbUseDDSqlFilters of hoServer to bOrigActive
102860>>>>>>>>>            Set No_Relate_State of hoServer to bOldRelate
102861>>>>>>>>>        End
102861>>>>>>>>>>
102861>>>>>>>>>    End_Procedure
102862>>>>>>>>>    
102862>>>>>>>>>    Procedure SuggestionsValidation String sSearch tSuggestion[] ByRef aSuggestions Boolean bFullText
102864>>>>>>>>>        Handle hoServer hoTable
102864>>>>>>>>>        Integer iFile iField iRow iCount iFound iMax iLen
102864>>>>>>>>>        Variant[][] aData
102865>>>>>>>>>        Boolean bCaseSensitive bContinue
102865>>>>>>>>>        String sDescr sVal
102865>>>>>>>>>        
102865>>>>>>>>>        Get Server to hoServer
102866>>>>>>>>>        Get Data_File  to iFile
102867>>>>>>>>>        Get Data_Field to iField
102868>>>>>>>>>        
102868>>>>>>>>>        If ((hoServer <> 0) and (iFile <> 0)) Begin
102870>>>>>>>>>            Get File_Field_Table_Object of hoServer iFile iField to hoTable
102871>>>>>>>>>            If (hoTable <> 0) Begin
102873>>>>>>>>>                Get tabledata of hoTable to aData
102874>>>>>>>>>                
102874>>>>>>>>>                Get piMaxResults to iMax
102875>>>>>>>>>                Get pbCaseSensitive to bCaseSensitive
102876>>>>>>>>>                
102876>>>>>>>>>                If (not(bCaseSensitive)) Begin
102878>>>>>>>>>                    Move (Lowercase(sSearch)) to sSearch
102879>>>>>>>>>                End
102879>>>>>>>>>>
102879>>>>>>>>>                
102879>>>>>>>>>                
102879>>>>>>>>>                Move (SizeOfArray(aData)) to iCount
102880>>>>>>>>>                Move 0 to iRow
102881>>>>>>>>>                Move (Length(sSearch)) to iLen
102882>>>>>>>>>                Move True to bContinue
102883>>>>>>>>>                
102883>>>>>>>>>                
102883>>>>>>>>>                While (iFound < iMax and iRow < iCount and bContinue)
102887>>>>>>>>>                    If (not(bCaseSensitive)) Begin
102889>>>>>>>>>                        Move (Lowercase(aData[iRow][0])) to sVal
102890>>>>>>>>>                        Move (Lowercase(aData[iRow][1])) to sDescr
102891>>>>>>>>>                    End
102891>>>>>>>>>>
102891>>>>>>>>>                    Else Begin
102892>>>>>>>>>                        Move aData[iRow][0] to sVal
102893>>>>>>>>>                        Move aData[iRow][1] to sDescr
102894>>>>>>>>>                    End
102894>>>>>>>>>>
102894>>>>>>>>>                    
102894>>>>>>>>>                    If ((bFullText and (sVal contains sSearch)) or (not(bFullText) and (Left(sVal, iLen) = sSearch))) Begin
102896>>>>>>>>>                        Move aData[iRow][0] to aSuggestions[iFound].sRowId
102897>>>>>>>>>                        Move aData[iRow][0] to aSuggestions[iFound].aValues[0]
102898>>>>>>>>>                        Move aData[iRow][1] to aSuggestions[iFound].aValues[1]
102899>>>>>>>>>                        Increment iFound
102900>>>>>>>>>                    End
102900>>>>>>>>>>
102900>>>>>>>>>                    Else Begin
102901>>>>>>>>>                        Move (bFullText or iFound = 0) to bContinue
102902>>>>>>>>>                    End
102902>>>>>>>>>>
102902>>>>>>>>>                    
102902>>>>>>>>>                    Increment iRow
102903>>>>>>>>>                Loop
102904>>>>>>>>>>
102904>>>>>>>>>            End
102904>>>>>>>>>>
102904>>>>>>>>>        End
102904>>>>>>>>>>
102904>>>>>>>>>        
102904>>>>>>>>>    End_Procedure
102905>>>>>>>>>    
102905>>>>>>>>>    
102905>>>>>>>>>    Procedure OnFindSuggestions String sSearch tSuggestion[] ByRef aSuggestions
102907>>>>>>>>>        Integer iMode iFile
102907>>>>>>>>>        Boolean bFullText bResult bSupportsSQL
102907>>>>>>>>>        Handle hoServer
102907>>>>>>>>>        
102907>>>>>>>>>        Get Server to hoServer
102908>>>>>>>>>        Get Data_File  to iFile
102909>>>>>>>>>        
102909>>>>>>>>>        If ((hoServer <> 0) and (iFile <> 0)) Begin
102911>>>>>>>>>            
102911>>>>>>>>>            Get peSuggestionMode to iMode
102912>>>>>>>>>            Get pbFullText to bFullText
102913>>>>>>>>>            
102913>>>>>>>>>            If (iMode = smFind) Begin
102915>>>>>>>>>                If (not(bFullText)) Begin
102917>>>>>>>>>                    Send SuggestionsFindIncremental sSearch (&aSuggestions)
102918>>>>>>>>>                End
102918>>>>>>>>>>
102918>>>>>>>>>                Else Begin
102919>>>>>>>>>                    Get SupportsSQLFilters of hoServer to bSupportsSQL
102920>>>>>>>>>                    If (bSupportsSQL) Begin
102922>>>>>>>>>                        Send SuggestionsSQLFullText sSearch (&aSuggestions)
102923>>>>>>>>>                    End
102923>>>>>>>>>>
102923>>>>>>>>>                    Else Begin
102924>>>>>>>>>                        Send SuggestionsFindFullText sSearch (&aSuggestions)
102925>>>>>>>>>                    End
102925>>>>>>>>>>
102925>>>>>>>>>                End
102925>>>>>>>>>>
102925>>>>>>>>>            End
102925>>>>>>>>>>
102925>>>>>>>>>            Else If (iMode = smValidationTable) Begin
102928>>>>>>>>>                Send SuggestionsValidation sSearch (&aSuggestions) bFullText
102929>>>>>>>>>            End
102929>>>>>>>>>>
102929>>>>>>>>>        End
102929>>>>>>>>>>
102929>>>>>>>>>    End_Procedure
102930>>>>>>>>>    
102930>>>>>>>>>    Procedure OnSelectSuggestion String sSearch tSuggestion Suggestion
102932>>>>>>>>>        Handle hoServer
102932>>>>>>>>>        Integer iFile iField iMode
102932>>>>>>>>>        Boolean bFind
102932>>>>>>>>>        RowID rRowId
102932>>>>>>>>>        
102932>>>>>>>>>        Get Server to hoServer
102933>>>>>>>>>        Get Data_File  to iFile
102934>>>>>>>>>        Get Data_Field to iField
102935>>>>>>>>>        
102935>>>>>>>>>        If ((hoServer <> 0) and (iFile <> 0)) Begin
102937>>>>>>>>>            Get peSuggestionMode to iMode
102938>>>>>>>>>            
102938>>>>>>>>>            If (iMode = smFind) Begin
102940>>>>>>>>>                Get pbFindOnSelect to bFind
102941>>>>>>>>>                If (bFind) Begin
102943>>>>>>>>>                    Move (DeserializeRowID(Suggestion.sRowId)) to rRowId
102944>>>>>>>>>                    
102944>>>>>>>>>                    If (not(IsNullRowID(rRowId))) Begin
102946>>>>>>>>>                        Send FindByRowId of hoServer iFile rRowId
102947>>>>>>>>>                    End
102947>>>>>>>>>>
102947>>>>>>>>>                End
102947>>>>>>>>>>
102947>>>>>>>>>                Else Begin
102948>>>>>>>>>                    Set Value to Suggestion.aValues[0]
102949>>>>>>>>>                    Set Item_Changed_State to True
102950>>>>>>>>>                End
102950>>>>>>>>>>
102950>>>>>>>>>            End
102950>>>>>>>>>>
102950>>>>>>>>>            Else If (imode = smValidationTable) Begin
102953>>>>>>>>>                Set Value to Suggestion.sRowId
102954>>>>>>>>>                Set Item_Changed_State to True
102955>>>>>>>>>            End
102955>>>>>>>>>>
102955>>>>>>>>>            
102955>>>>>>>>>        End
102955>>>>>>>>>>
102955>>>>>>>>>    End_Procedure
102956>>>>>>>>>    
102956>>>>>>>>>    // Return true if Suggestion should be invoked. Can be augmented
102956>>>>>>>>>    Function ShouldSuggestion String sValue Boolean bChanged Returns Boolean
102958>>>>>>>>>        Integer iStartAtChar
102958>>>>>>>>>        Get piStartAtChar to iStartAtChar
102959>>>>>>>>>        Function_Return (bChanged and Length(sValue)>=iStartAtChar)
102960>>>>>>>>>    End_Function
102961>>>>>>>>>    
102961>>>>>>>>>    
102961>>>>>>>>>End_Class
102962>>>>>>>>>
102962>>>>>>>>>
102962>>>>>>>>>// This contains logic that deals with the Windows object. It relies on the interface in
102962>>>>>>>>>// sSuggestion_mixin, which means it must be mixed in as a sibling of this object (as is done
102962>>>>>>>>>// in dbSuggestionForm or as a child of this object (as is done in cDbCJGridColumnSuggestion), which
102962>>>>>>>>>// means messages are resolved via delegation. sSuggestion_mixin does not send messages to this class.
102962>>>>>>>>>// Note that cSuggestion_mixin and cSuggestionControl_mixin are designed so they can be mixed in at
102962>>>>>>>>>// the same level or mixed in such that cSuggestionControl_mixin is in the child object and cSuggestion_mixin
102962>>>>>>>>>// is in the parent
102962>>>>>>>>>
102962>>>>>>>>>Class cSuggestionControl_mixin is a Mixin
102963>>>>>>>>>    
102963>>>>>>>>>    Procedure Define_cSuggestionControl_mixin
102965>>>>>>>>>        
102965>>>>>>>>>        Property Integer piTimeOutTicks 0
102966>>>>>>>>>        
102966>>>>>>>>>        On_Key kEnter Send SelectSuggestion
102967>>>>>>>>>        On_Key Key_Escape Send DeActivateSuggestionList
102968>>>>>>>>>        On_Key Key_Up_Arrow Send Up
102969>>>>>>>>>        On_Key Key_Down_Arrow Send Down
102970>>>>>>>>>        
102970>>>>>>>>>    End_Procedure
102971>>>>>>>>>    
102971>>>>>>>>>    Procedure AdjustSuggestionListSize Integer iLines
102973>>>>>>>>>        Integer i  iX iMax iY
102973>>>>>>>>>        String sTxt
102973>>>>>>>>>        Boolean bFullWidth
102973>>>>>>>>>        For i from 0 to (iLines-1)
102979>>>>>>>>>>
102979>>>>>>>>>            Get Line of ghoSuggestionList i to sTxt
102980>>>>>>>>>            Get Text_Extent of ghoSuggestionList sTxt to iX
102981>>>>>>>>>            Move (Low(iX) max iMax) to iMax
102982>>>>>>>>>            Move (Hi(iX)) to iY
102983>>>>>>>>>        Loop
102984>>>>>>>>>>
102984>>>>>>>>>        Move (iMax + 20) to imax
102985>>>>>>>>>        Get pbFullWidth to bFullWidth
102986>>>>>>>>>        If bFullWidth Begin
102988>>>>>>>>>            Move (iMax max (Low(GuiSize(Self)))) to iMax
102989>>>>>>>>>        End
102989>>>>>>>>>>
102989>>>>>>>>>        If (iLines) Begin
102991>>>>>>>>>            Set GuiSize of ghoSuggestionList to (iY*(iLines)+8) iMax
102992>>>>>>>>>            Send SelectRow of ghoSuggestionList 0 // go to first line
102993>>>>>>>>>        End
102993>>>>>>>>>>
102993>>>>>>>>>        Else Begin
102994>>>>>>>>>            Set GuiSize of ghoSuggestionList to (Hi(GuiSize(Self))) (low(GuiSize(Self)))
102995>>>>>>>>>        End
102995>>>>>>>>>>
102995>>>>>>>>>    End_Procedure
102996>>>>>>>>>    
102996>>>>>>>>>    // show all suggestions
102996>>>>>>>>>    Procedure ShowSuggestions
102998>>>>>>>>>        tSuggestion[] aResults
102998>>>>>>>>>        tSuggestion[] aResults
102999>>>>>>>>>        Integer i iLines
102999>>>>>>>>>        String sSearch
102999>>>>>>>>>        Get pSearchResults to aResults
103000>>>>>>>>>        Get Value to sSearch
103001>>>>>>>>>        Send Delete_Data of ghoSuggestionList
103002>>>>>>>>>        Move (SizeOfArray(aResults)) to iLines
103003>>>>>>>>>        For i from 0 to (iLines-1)
103009>>>>>>>>>>
103009>>>>>>>>>            Send ShowSuggestion aResults[i] sSearch
103010>>>>>>>>>            If ((iLines-1)<>i) Begin
103012>>>>>>>>>                Send AppendTextLn of ghoSuggestionList ""
103013>>>>>>>>>            End
103013>>>>>>>>>>
103013>>>>>>>>>        Loop
103014>>>>>>>>>>
103014>>>>>>>>>        Send AdjustSuggestionListSize iLines
103015>>>>>>>>>    End_Procedure
103016>>>>>>>>>    
103016>>>>>>>>>    Procedure FindSuggestions
103018>>>>>>>>>        String sSearch
103018>>>>>>>>>        tSuggestion[] aResults
103018>>>>>>>>>        tSuggestion[] aResults
103019>>>>>>>>>        String[] aParams
103020>>>>>>>>>        Get Value to sSearch
103021>>>>>>>>>        Send OnFindSuggestions sSearch (&aResults)
103022>>>>>>>>>        Set pSearchResults to aResults
103023>>>>>>>>>        // if an error was raised, the suggestion list will be gone
103023>>>>>>>>>        If (ghoSuggestionList) Begin
103025>>>>>>>>>            Send ShowSuggestions
103026>>>>>>>>>        End
103026>>>>>>>>>>
103026>>>>>>>>>    End_Procedure
103027>>>>>>>>>    
103027>>>>>>>>>    Procedure SelectSuggestion
103029>>>>>>>>>        String sSearch
103029>>>>>>>>>        tSuggestion[] aData
103029>>>>>>>>>        tSuggestion[] aData
103030>>>>>>>>>        Integer iSelRow
103030>>>>>>>>>        If ghoSuggestionList Begin
103032>>>>>>>>>            Get SelectedRow of ghoSuggestionList to iSelRow
103033>>>>>>>>>            Get Value to sSearch
103034>>>>>>>>>            Get pSearchResults to aData
103035>>>>>>>>>            Send DeActivateSuggestionList
103036>>>>>>>>>            Send CancelEditIfGrid
103037>>>>>>>>>            If (iSelRow>=0 and SizeOfArray(aData)>iSelRow) Begin
103039>>>>>>>>>                Send OnSelectSuggestion sSearch aData[iSelRow]
103040>>>>>>>>>            End
103040>>>>>>>>>>
103040>>>>>>>>>        End
103040>>>>>>>>>>
103040>>>>>>>>>        Else Begin
103041>>>>>>>>>            Send Default_Action
103042>>>>>>>>>        End
103042>>>>>>>>>>
103042>>>>>>>>>    End_Procedure
103043>>>>>>>>>    
103043>>>>>>>>>    Procedure CancelEditIfGrid
103045>>>>>>>>>        // do nothing with forms, remember
103045>>>>>>>>>        // to replace or augment with grid to
103045>>>>>>>>>        // cancel the edit control
103045>>>>>>>>>    End_Procedure
103046>>>>>>>>>    
103046>>>>>>>>>    
103046>>>>>>>>>    Function ParentForSuggestion Returns Handle
103048>>>>>>>>>        Handle hoMain hoMainPanel
103048>>>>>>>>>        
103048>>>>>>>>>        // we must have an application object and a main panel object
103048>>>>>>>>>        If ghoApplication Begin
103050>>>>>>>>>            Get phoMainPanel of ghoApplication to hoMainPanel
103051>>>>>>>>>        End
103051>>>>>>>>>>
103051>>>>>>>>>        If (hoMainPanel=0 or Self<=Desktop) Begin
103053>>>>>>>>>            Function_Return 0
103054>>>>>>>>>        End
103054>>>>>>>>>>
103054>>>>>>>>>        
103054>>>>>>>>>        Move Self to hoMain
103055>>>>>>>>>        Repeat
103055>>>>>>>>>>
103055>>>>>>>>>            Get Parent of hoMain to hoMain
103056>>>>>>>>>        Until (hoMain=Desktop or Block_Mouse_State(hoMain) or hoMainPanel=hoMain)
103058>>>>>>>>>        
103058>>>>>>>>>        Function_Return (If(hoMain>Desktop,hoMain,0))
103059>>>>>>>>>        
103059>>>>>>>>>    End_Function
103060>>>>>>>>>    
103060>>>>>>>>>    Procedure ActivateSuggestionList
103062>>>>>>>>>        Handle hoView hcSuggest
103062>>>>>>>>>        Get ParentForSuggestion to hoView
103063>>>>>>>>>        If hoView Begin
103065>>>>>>>>>            Get phcSuggestionListClass to hcSuggest
103066>>>>>>>>>            Get CreateNamed of hoView hcSuggest "oSuggestList" to ghoSuggestionList
103067>>>>>>>>>            Send InitList of ghoSuggestionList Self
103068>>>>>>>>>            Set Focus_Mode of ghoSuggestionList to Focusable
103069>>>>>>>>>            Set phoOwner of ghoSuggestionList to Self
103070>>>>>>>>>            Send Add_Focus of ghoSuggestionList hoView
103071>>>>>>>>>        End
103071>>>>>>>>>>
103071>>>>>>>>>    End_Procedure
103072>>>>>>>>>    
103072>>>>>>>>>    Procedure DeActivateSuggestionList
103074>>>>>>>>>        If ghoSuggestionList Begin
103076>>>>>>>>>            Send DeactivateList of ghoSuggestionList
103077>>>>>>>>>        End
103077>>>>>>>>>>
103077>>>>>>>>>    End_Procedure
103078>>>>>>>>>    
103078>>>>>>>>>    // augment to kill suggest list if focus is not moving to it
103078>>>>>>>>>    // customized for grid
103078>>>>>>>>>    Procedure OnKillFocus
103080>>>>>>>>>        // note focus has already changed here
103080>>>>>>>>>        If (ghoSuggestionList) Begin
103082>>>>>>>>>            If (Focus(Self)<>ghoSuggestionList) Begin
103084>>>>>>>>>                Send DeActivateSuggestionList
103085>>>>>>>>>                Forward Send OnKillFocus
103087>>>>>>>>>            End
103087>>>>>>>>>>
103087>>>>>>>>>            Else Begin
103088>>>>>>>>>                // giving focus to the suggestion list here
103088>>>>>>>>>            End
103088>>>>>>>>>>
103088>>>>>>>>>        End
103088>>>>>>>>>>
103088>>>>>>>>>        Else Begin
103089>>>>>>>>>            Forward Send OnKillFocus
103091>>>>>>>>>        End
103091>>>>>>>>>>
103091>>>>>>>>>    End_Procedure
103092>>>>>>>>>    
103092>>>>>>>>>    Procedure Up
103094>>>>>>>>>        If (Focus(Desktop) = Self and ghoSuggestionList) Begin
103096>>>>>>>>>            Send ScrollUp of ghoSuggestionList
103097>>>>>>>>>        End
103097>>>>>>>>>>
103097>>>>>>>>>    End_Procedure
103098>>>>>>>>>    
103098>>>>>>>>>    Procedure Down
103100>>>>>>>>>        If (Focus(Desktop) = Self and ghoSuggestionList) Begin
103102>>>>>>>>>            Send ScrollDown of ghoSuggestionList
103103>>>>>>>>>        End
103103>>>>>>>>>>
103103>>>>>>>>>    End_Procedure
103104>>>>>>>>>    
103104>>>>>>>>>    
103104>>>>>>>>>    Procedure Key Integer iKey
103106>>>>>>>>>        Integer iEndTicks
103106>>>>>>>>>        
103106>>>>>>>>>        If (Focus(Desktop) <> Self) Begin
103108>>>>>>>>>            Forward Send Key iKey
103110>>>>>>>>>            Procedure_Return
103111>>>>>>>>>        End
103111>>>>>>>>>>
103111>>>>>>>>>        
103111>>>>>>>>>        Send DeActivateSuggestionList
103112>>>>>>>>>        Move (GetTickCount()) to iEndTicks
103113>>>>>>>>>        // record the time of key press
103113>>>>>>>>>        If (piTimeOutTicks(Self) = 0) Begin
103115>>>>>>>>>            
103115>>>>>>>>>            If (ghoSuggestionTimer=0) Begin
103117>>>>>>>>>                Send CreateSuggestionTimer
103118>>>>>>>>>            End
103118>>>>>>>>>>
103118>>>>>>>>>            
103118>>>>>>>>>            Set pbEnabled of ghoSuggestionTimer to True
103119>>>>>>>>>            Set phoTimerOwner of ghoSuggestionTimer to Self
103120>>>>>>>>>        End
103120>>>>>>>>>>
103120>>>>>>>>>        Set piTimeOutTicks to iEndTicks
103121>>>>>>>>>        
103121>>>>>>>>>        Forward Send Key iKey
103123>>>>>>>>>    End_Procedure
103124>>>>>>>>>    
103124>>>>>>>>>    Procedure CreateSuggestionTimer
103126>>>>>>>>>        Handle hoMainPanel
103126>>>>>>>>>        // we must have an application object and a main panel object
103126>>>>>>>>>        If ghoApplication Begin
103128>>>>>>>>>            Get phoMainPanel of ghoApplication to hoMainPanel
103129>>>>>>>>>        End
103129>>>>>>>>>>
103129>>>>>>>>>        If (hoMainPanel=0) Begin
103131>>>>>>>>>            Error DFERR_PROGRAM "Auto-suggest requires an application object and a main panel object"
103132>>>>>>>>>>
103132>>>>>>>>>            Procedure_Return
103133>>>>>>>>>        End
103133>>>>>>>>>>
103133>>>>>>>>>        Get CreateNamed of hoMainPanel (RefClass(cSuggestionTimer)) "oSuggestionTimer" to ghoSuggestionTimer
103134>>>>>>>>>    End_Procedure
103135>>>>>>>>>    
103135>>>>>>>>>    // sent by Auto Suggest Timer. Invoke suggestion list as needed
103135>>>>>>>>>    Procedure OnSuggestionTimer
103137>>>>>>>>>        Boolean bDoIt
103137>>>>>>>>>        Integer iEndTicks iStartTicks iTicks iTimeOut iChanged
103137>>>>>>>>>        String sValue
103137>>>>>>>>>        
103137>>>>>>>>>        If (Focus(Desktop) <> Self) Begin
103139>>>>>>>>>            // focus out of whack. Stop the timer
103139>>>>>>>>>            Set pbEnabled of ghoSuggestionTimer to False
103140>>>>>>>>>            Send DeActivateSuggestionList
103141>>>>>>>>>            Procedure_Return
103142>>>>>>>>>        End
103142>>>>>>>>>>
103142>>>>>>>>>        
103142>>>>>>>>>        Get piTimeOutTicks to iStartTicks
103143>>>>>>>>>        If (iStartTicks <> 0) Begin
103145>>>>>>>>>            Move (GetTickCount()) to iEndTicks
103146>>>>>>>>>            Move (iEndTicks - iStartTicks) to iTicks
103147>>>>>>>>>            // If tick count rolled over
103147>>>>>>>>>            If (iTicks < 0) Begin
103149>>>>>>>>>                Move (-iTicks) to iTicks
103150>>>>>>>>>            End
103150>>>>>>>>>>
103150>>>>>>>>>        End
103150>>>>>>>>>>
103150>>>>>>>>>        Get piPopupTimeout to iTimeOut
103151>>>>>>>>>        If (iTicks >= iTimeOut) Begin
103153>>>>>>>>>            // If time delay has been met, launch autocomplete
103153>>>>>>>>>            Set pbEnabled  of ghoSuggestionTimer to False
103154>>>>>>>>>            Get Value to sValue
103155>>>>>>>>>            Get Item_Changed_State 0 to iChanged
103156>>>>>>>>>            Get ShouldSuggestion sValue iChanged to bDoIt
103157>>>>>>>>>            If bDoIt Begin
103159>>>>>>>>>                Send ActivateSuggestionList
103160>>>>>>>>>                Send FindSuggestions
103161>>>>>>>>>                Set Visible_State of ghoSuggestionList to True
103162>>>>>>>>>            End
103162>>>>>>>>>>
103162>>>>>>>>>            Set piTimeOutTicks to 0
103163>>>>>>>>>        End
103163>>>>>>>>>>
103163>>>>>>>>>    End_Procedure
103164>>>>>>>>>    
103164>>>>>>>>>End_Class
103165>>>>>>>>>
103165>>>>>>>>>
103165>>>>>>>Use cIniFile.pkg            
103165>>>>>>>Use cRDCForm.pkg
103165>>>>>>>Use vWin32fh.pkg
103165>>>>>>>
103165>>>>>>>    Define CS_cRDCSuggestionFormList       for "Suggestion Form List"  // [Section Name]
103165>>>>>>>    Define CS_cRDCSuggestionSaveItem       for "Saved Item"            // Key=Value
103165>>>>>>>    Define CS_cRDCSuggestionFormTooltip    for "This is a suggestion form - start typing what you're looking for. Previously entered values are saved automatically."
103165>>>>>>>
103165>>>>>>>Class cRDCSuggestionIniForm is a cRDCForm
103166>>>>>>>
103166>>>>>>>    Procedure Define_cRDCSuggestionControl_mixin
103168>>>>>>>
103168>>>>>>>        Property Integer piTimeOutTicks 0
103169>>>>>>>
103169>>>>>>>        On_Key kEnter            Send SelectSuggestion
103170>>>>>>>        On_Key Key_Escape        Send DeActivateSuggestionList
103171>>>>>>>        On_Key Key_Up_Arrow      Send Up
103172>>>>>>>        On_Key Key_Down_Arrow    Send Down
103173>>>>>>>
103173>>>>>>>        // Added 'Home' & 'End' navigation keys for the drop-down list and the form object (and Ctrl+Home & Ctrl+End).
103173>>>>>>>        On_Key Key_Home          Send Home
103174>>>>>>>        On_Key Key_Ctrl+Key_Home Send Home
103175>>>>>>>        On_Key Key_End           Send End
103176>>>>>>>        On_Key Key_Ctrl+Key_End  Send End // Need this as well; else the Ctrl+Home/End keys generates a runtime error (always has).
103177>>>>>>>
103177>>>>>>>        // Just can't seem to get the popup of the suggestion list with F4 to work.
103177>>>>>>>        On_Key kPrompt           Send Prompt
103178>>>>>>>    End_Procedure
103179>>>>>>>
103179>>>>>>>    Import_Class_Protocol cSuggestionControl_mixin
103180>>>>>>>    Import_Class_Protocol cSuggestion_mixin
103181>>>>>>>
103181>>>>>>>    Procedure Construct_Object
103183>>>>>>>        Forward Send Construct_Object
103185>>>>>>>        Send Define_cRDCSuggestionControl_mixin
103186>>>>>>>        Send Define_cSuggestion_mixin
103187>>>>>>>
103187>>>>>>>        Set peSuggestionMode to smCustom
103188>>>>>>>        Set pbFullText to True
103189>>>>>>>        Set piStartAtChar to 1
103190>>>>>>>
103190>>>>>>>        Property String[] psSavedFormValues
103191>>>>>>>        Property String psIniFileSection
103192>>>>>>>        Property Integer piSuggestionListMaxItems 99 // Max no of values saved/read to ini file
103193>>>>>>>        Property Boolean pbUseWorkspaceIniFile True
103194>>>>>>>        Property Boolean pbAutoCheckValueExistsAsFile True
103195>>>>>>>        Property Boolean pbAskToRemoveMissingFile True
103196>>>>>>>        // Note: pbUseWorkspaceIniFile has presedence over the psIniFileName setting.
103196>>>>>>>        //       That means that if pbUseWorkspaceIniFile=True, psIniFilename will be set to the
103196>>>>>>>        //       worspace .ws file on program startup.
103196>>>>>>>        Property String psIniFileName "RDCSuggestionForm.ini"
103197>>>>>>>    End_Procedure
103198>>>>>>>
103198>>>>>>>    Procedure ShowSuggestions
103200>>>>>>>        tSuggestion[] aResults
103200>>>>>>>        tSuggestion[] aResults
103201>>>>>>>        Integer i iLines
103201>>>>>>>        String sSearch
103201>>>>>>>
103201>>>>>>>
103201>>>>>>>        Get pSearchResults to aResults
103202>>>>>>>        Get Value to sSearch
103203>>>>>>>
103203>>>>>>>        If (ghoSuggestionList <> 0) Begin
103205>>>>>>>            Send Delete_Data of ghoSuggestionList
103206>>>>>>>            Move (SizeOfArray(aResults)) to iLines
103207>>>>>>>            For i from 0 to (iLines-1)
103213>>>>>>>>
103213>>>>>>>                Send ShowSuggestion aResults[i] sSearch
103214>>>>>>>                If ((iLines-1)<>i) Begin
103216>>>>>>>                    Send AppendTextLn of ghoSuggestionList ""
103217>>>>>>>                End
103217>>>>>>>>
103217>>>>>>>            Loop
103218>>>>>>>>
103218>>>>>>>            Send AdjustSuggestionListSize iLines
103219>>>>>>>        End
103219>>>>>>>>
103219>>>>>>>
103219>>>>>>>        Set Cursor of Cursor_Control to IDC_ARROW
103220>>>>>>>        Send Activate of (Self)
103221>>>>>>>        Send Release_Mouse_Capture
103222>>>>>>>    End_Procedure
103223>>>>>>>
103223>>>>>>>    Procedure Home
103225>>>>>>>        If (Focus(Desktop) = Self and ghoSuggestionList) Begin
103227>>>>>>>           Send ScrollHome
103228>>>>>>>        End
103228>>>>>>>>
103228>>>>>>>        Else Begin
103229>>>>>>>            Send Key VK_HOME
103230>>>>>>>        End
103230>>>>>>>>
103230>>>>>>>    End_Procedure
103231>>>>>>>
103231>>>>>>>    Procedure ScrollHome
103233>>>>>>>        Send SelectRow of ghoSuggestionList 0
103234>>>>>>>    End_Procedure
103235>>>>>>>
103235>>>>>>>    Procedure End
103237>>>>>>>        If (Focus(Desktop) = Self and ghoSuggestionList) Begin
103239>>>>>>>           Send ScrollEnd
103240>>>>>>>        End
103240>>>>>>>>
103240>>>>>>>        Else Begin
103241>>>>>>>            Send Key VK_END
103242>>>>>>>        End
103242>>>>>>>>
103242>>>>>>>    End_Procedure
103243>>>>>>>
103243>>>>>>>    Procedure ScrollEnd
103245>>>>>>>        Integer iLine iLines
103245>>>>>>>        Get Line_Count of ghoSuggestionList  to iLines
103246>>>>>>>        Get SelectedRow of ghoSuggestionList to iLine
103247>>>>>>>        // there can be an extra line at the end
103247>>>>>>>        If (iLine < iLines - 1) Begin
103249>>>>>>>            Send SelectRow of ghoSuggestionList (iLines - 1)
103250>>>>>>>        End
103250>>>>>>>>
103250>>>>>>>    End_Procedure
103251>>>>>>>
103251>>>>>>>    Procedure Activating
103253>>>>>>>        String[] sSavedFormValues
103254>>>>>>>        If (pbUseWorkspaceIniFile(Self) = True) Begin
103256>>>>>>>            Get ReadWorkspaceIniFile to sSavedFormValues
103257>>>>>>>            Set psSavedFormValues    to sSavedFormValues
103258>>>>>>>        End
103258>>>>>>>>
103258>>>>>>>    End_Procedure
103259>>>>>>>
103259>>>>>>>    Procedure Set psToolTip String sToolTip
103261>>>>>>>        String sStatusHelp
103261>>>>>>>
103261>>>>>>>        Get Status_Help to sStatusHelp
103262>>>>>>>        If (sStatusHelp = "") Begin
103264>>>>>>>            Set Status_Help to sToolTip
103265>>>>>>>        End
103265>>>>>>>>
103265>>>>>>>
103265>>>>>>>        Move (sToolTip + String(Character(10)) + String(CS_cRDCSuggestionFormTooltip)) to sToolTip
103266>>>>>>>        Forward Set psToolTip to sToolTip
103268>>>>>>>    End_Procedure
103269>>>>>>>
103269>>>>>>>    Function ReadWorkspaceIniFile Returns String[]
103271>>>>>>>        String sWorkspaceFile sObjectName sValue
103271>>>>>>>        String[] sSavedFormValues
103272>>>>>>>        Handle hoIniFile
103272>>>>>>>        Integer iItem iCount iSize
103272>>>>>>>        Boolean bExists
103272>>>>>>>
103272>>>>>>>        If (pbUseWorkspaceIniFile(Self) = False) Begin
103274>>>>>>>            Function_Return sSavedFormValues
103275>>>>>>>        End
103275>>>>>>>>
103275>>>>>>>
103275>>>>>>>        Move 0 to iItem
103276>>>>>>>        Get Object_Label to sObjectName
103277>>>>>>>        Move (psWorkspaceWSFile(phoWorkspace(ghoApplication))) to sWorkspaceFile
103278>>>>>>>        Set psIniFileName to sWorkspaceFile
103279>>>>>>>        Get Create (RefClass(cIniFile)) to hoIniFile
103280>>>>>>>        Set psFileName of hoIniFile to sWorkspaceFile
103281>>>>>>>        Get piSuggestionListMaxItems to iSize
103282>>>>>>>
103282>>>>>>>        For iCount from 0 to iSize
103288>>>>>>>>
103288>>>>>>>            Get KeyExists of hoIniFile (CS_cRDCSuggestionFormList * String(sObjectName)) (CS_cRDCSuggestionSaveItem + String(iCount)) to bExists
103289>>>>>>>            // We need to loop through all possible values because the list of items may not start at zero.
103289>>>>>>>            Get ReadString of hoIniFile (CS_cRDCSuggestionFormList * String(sObjectName)) (CS_cRDCSuggestionSaveItem + String(iCount)) "" to sValue
103290>>>>>>>            If (Trim(sValue) <> "") Begin
103292>>>>>>>                Move sValue to sSavedFormValues[iItem]
103293>>>>>>>                Increment iItem
103294>>>>>>>            End
103294>>>>>>>>
103294>>>>>>>        Loop
103295>>>>>>>>
103295>>>>>>>
103295>>>>>>>        Send Destroy of hoIniFile
103296>>>>>>>        Function_Return sSavedFormValues
103297>>>>>>>    End_Function
103298>>>>>>>
103298>>>>>>>    Procedure WriteWorkspaceIniFile
103300>>>>>>>        String sWorkspaceFile sObjectName sValue
103300>>>>>>>        String[] sSavedFormValues
103301>>>>>>>        Handle hoIniFile
103301>>>>>>>        Integer iSize iCount
103301>>>>>>>        Boolean bExists
103301>>>>>>>
103301>>>>>>>        If (pbUseWorkspaceIniFile(Self) = False) Begin
103303>>>>>>>            Procedure_Return
103304>>>>>>>        End
103304>>>>>>>>
103304>>>>>>>
103304>>>>>>>        Get Object_Label  to sObjectName
103305>>>>>>>        Get psIniFileName to sWorkspaceFile
103306>>>>>>>        Get Create (RefClass(cIniFile)) to hoIniFile
103307>>>>>>>        Set psFileName    of hoIniFile to sWorkspaceFile
103308>>>>>>>        Get SectionExists of hoIniFile (CS_cRDCSuggestionFormList * String(sObjectName)) to bExists
103309>>>>>>>        If (bExists = True) Begin
103311>>>>>>>            Send DeleteSection of hoIniFile (CS_cRDCSuggestionFormList * String(sObjectName))
103312>>>>>>>        End
103312>>>>>>>>
103312>>>>>>>
103312>>>>>>>        Get psSavedFormValues to sSavedFormValues
103313>>>>>>>        Move (SizeOfArray(sSavedFormValues)) to iSize
103314>>>>>>>        Decrement iSize
103315>>>>>>>
103315>>>>>>>        For iCount from 0 to iSize
103321>>>>>>>>
103321>>>>>>>            Move sSavedFormValues[iCount] to sValue
103322>>>>>>>            Move (Trim(sValue)) to sValue
103323>>>>>>>            Get vFilePathExists sValue to bExists
103324>>>>>>>            If (bExists = True) Begin
103326>>>>>>>                Send WriteString of hoIniFile (CS_cRDCSuggestionFormList * String(sObjectName)) (CS_cRDCSuggestionSaveItem + String(iCount)) sSavedFormValues[iCount]
103327>>>>>>>            End
103327>>>>>>>>
103327>>>>>>>        Loop
103328>>>>>>>>
103328>>>>>>>
103328>>>>>>>        Send Destroy of hoIniFile
103329>>>>>>>    End_Procedure
103330>>>>>>>
103330>>>>>>>    Procedure Prompt      
103332>>>>>>>        If (ghoSuggestionTimer=0) Begin
103334>>>>>>>            Send CreateSuggestionTimer
103335>>>>>>>        End
103335>>>>>>>>
103335>>>>>>>        Send ActivateSuggestionList
103336>>>>>>>        Send FindSuggestions
103337>>>>>>>        Set Visible_State of ghoSuggestionList to True
103338>>>>>>>    End_Procedure 
103339>>>>>>>    
103339>>>>>>>    Procedure OnExitObject
103341>>>>>>>        String sValue
103341>>>>>>>        Boolean bExists
103341>>>>>>>        String[] sSavedFormValues
103342>>>>>>>        Integer iSize iIndex
103342>>>>>>>
103342>>>>>>>        Forward Send OnExitObject
103344>>>>>>>
103344>>>>>>>        If (pbUseWorkspaceIniFile(Self) = False) Begin
103346>>>>>>>            Procedure_Return
103347>>>>>>>        End
103347>>>>>>>>
103347>>>>>>>
103347>>>>>>>        Get Value to sValue
103348>>>>>>>        Move (Trim(sValue)) to sValue
103349>>>>>>>        Get psSavedFormValues to sSavedFormValues
103350>>>>>>>        Move (SearchArray(sValue, sSavedFormValues)) to iIndex
103351>>>>>>>        // Does it exist in the array already?
103351>>>>>>>        If (iIndex <> -1) Begin
103353>>>>>>>            Procedure_Return
103354>>>>>>>        End
103354>>>>>>>>
103354>>>>>>>        Get vFilePathExists sValue to bExists
103355>>>>>>>        If (bExists = False) Begin
103357>>>>>>>            Procedure_Return
103358>>>>>>>        End
103358>>>>>>>>
103358>>>>>>>        Move (SizeOfArray(sSavedFormValues)) to iSize
103359>>>>>>>        Move sValue to sSavedFormValues[iSize]
103360>>>>>>>        Set psSavedFormValues to sSavedFormValues
103361>>>>>>>        Send WriteWorkspaceIniFile
103362>>>>>>>    End_Procedure
103363>>>>>>>
103363>>>>>>>    // Custom code to find all matches for the search
103363>>>>>>>    Procedure OnFindSuggestions String sSearch tSuggestion[] ByRef aSuggestions
103365>>>>>>>        String[] sSavedFormValues
103366>>>>>>>        Integer i iLen iSize iCount
103366>>>>>>>
103366>>>>>>>        Move (Lowercase(sSearch)) to sSearch
103367>>>>>>>        Move (Length(sSearch)) to iLen
103368>>>>>>>        Get psSavedFormValues to sSavedFormValues
103369>>>>>>>        Move (SizeOfArray(sSavedFormValues)) to iSize
103370>>>>>>>        Decrement iSize
103371>>>>>>>        For i from 0 to iSize
103377>>>>>>>>
103377>>>>>>>            If (Lowercase(sSavedFormValues[i]) contains sSearch) Begin
103379>>>>>>>                Move sSavedFormValues[i] to aSuggestions[iCount].sRowId
103380>>>>>>>                Move sSavedFormValues[i] to aSuggestions[iCount].aValues[0]
103381>>>>>>>                Increment iCount
103382>>>>>>>            End
103382>>>>>>>>
103382>>>>>>>        Loop
103383>>>>>>>>
103383>>>>>>>    End_Procedure
103384>>>>>>>
103384>>>>>>>    Procedure OnSelectSuggestion String sSearch tSuggestion Suggestion
103386>>>>>>>        Boolean bExists bAutoCheckValueExistsAsFile bAskToRemoveMissingFile
103386>>>>>>>        Integer iRetval iIndex
103386>>>>>>>        String[] sSavedFormValues
103387>>>>>>>        String sValue
103387>>>>>>>
103387>>>>>>>//        Send Release_Mouse_Capture
103387>>>>>>>        Move Suggestion.sRowId to sValue
103388>>>>>>>        Move (Trim(sValue)) to sValue
103389>>>>>>>        Get pbAutoCheckValueExistsAsFile to bAutoCheckValueExistsAsFile
103390>>>>>>>
103390>>>>>>>        If (bAutoCheckValueExistsAsFile = True) Begin
103392>>>>>>>            Get pbAskToRemoveMissingFile to bAskToRemoveMissingFile
103393>>>>>>>            Get vFilePathExists sValue to bExists
103394>>>>>>>            If (bExists = False) Begin
103396>>>>>>>                If (bAskToRemoveMissingFile = True) Begin
103398>>>>>>>                    Get YesNo_Box ("The file" * String(sValue) + "\nDoesn't exist. Do you want to remove it from the suggestion list?") to iRetval
103399>>>>>>>                End
103399>>>>>>>>
103399>>>>>>>                // This will happen if bAskToRemoveMissingFile = False, and bAutoCheckValueExistsAsFile = True.
103399>>>>>>>                // Then the missing file will just be removed from the saved list.
103399>>>>>>>                Else Begin
103400>>>>>>>                    Move MBR_Yes to iRetval
103401>>>>>>>                End
103401>>>>>>>>
103401>>>>>>>
103401>>>>>>>                If (iRetval = MBR_Yes) Begin
103403>>>>>>>                    Get psSavedFormValues to sSavedFormValues
103404>>>>>>>                    Move (SearchArray(sValue, sSavedFormValues)) to iIndex
103405>>>>>>>                    If (iIndex <> -1) Begin
103407>>>>>>>                        Move (RemoveFromArray(sSavedFormValues, iIndex)) to sSavedFormValues
103408>>>>>>>                        Set psSavedFormValues to sSavedFormValues
103409>>>>>>>                        Send WriteWorkspaceIniFile
103410>>>>>>>                        Set Value to ""
103411>>>>>>>                        Procedure_Return
103412>>>>>>>                    End
103412>>>>>>>>
103412>>>>>>>                End
103412>>>>>>>>
103412>>>>>>>            End
103412>>>>>>>>
103412>>>>>>>        End
103412>>>>>>>>
103412>>>>>>>
103412>>>>>>>        Set Value to Suggestion.sRowId
103413>>>>>>>        Set Item_Changed_State to False
103414>>>>>>>    End_Procedure
103415>>>>>>>
103415>>>>>>>//    { MethodType=Event  NoDoc=True }
103415>>>>>>>//    Procedure Mouse_Click Integer i1 Integer i2
103415>>>>>>>//        Send Release_Mouse_Capture
103415>>>>>>>//        Forward Send Mouse_click i1 i2
103415>>>>>>>//    End_Procedure
103415>>>>>>>
103415>>>>>>>End_Class
103416>>>>>>>
103416>>>>>>>//    Procedure Mouse_Up for cRDCSuggestionList Integer iWindowNumber Integer iPosition
103416>>>>>>>//        Handle hoObj
103416>>>>>>>//        Send Release_Mouse_Capture
103416>>>>>>>//        Get phoOwner to hoObj
103416>>>>>>>//        Send Activate of hoObj // move focus to owner, which will close the list
103416>>>>>>>//        Send SelectSuggestion of hoObj
103416>>>>>>>//    End_Procedure // Mouse_Up
103416>>>>>>>
103416>>>>>>>//    Function OnWindowsHook for cRDCSuggestionHookMouse Integer i1 Integer i2 Integer i3 Returns Integer
103416>>>>>>>//        tWinMouseHookStruct MouseHook
103416>>>>>>>//        Integer ivoid hObj
103416>>>>>>>//        Handle hoOwner hoParent
103416>>>>>>>//        If (i1=0 and (i2=WM_LBUTTONDOWN or i2=WM_RBUTTONDOWN or i2=WM_MBUTTONDOWN or ;
103416>>>>>>>//                      i2=WM_NCLBUTTONDOWN or i2=WM_NCRBUTTONDOWN or i2=WM_NCMBUTTONDOWN)) Begin
103416>>>>>>>//            Send Release_Mouse_Capture
103416>>>>>>>//            Move (CopyMemory(AddressOf(MouseHook), i3, SizeOfType(tWinMouseHookStruct))) to iVoid
103416>>>>>>>//            GET_OBJECT_FROM_WINDOW MouseHook.hwnd to hObj
103416>>>>>>>//            If (hObj = Cursor_Control) Begin
103416>>>>>>>//                Move (Focus(Desktop)) to hObj
103416>>>>>>>//            End
103416>>>>>>>//            Get Parent to hoParent
103416>>>>>>>//            Get phoOwner of hoParent to hoOwner
103416>>>>>>>//            If (not(hObj) or (hObj<>hoParent and hObj<>hoOwner)) Begin
103416>>>>>>>//                Send DisableWindowsHook
103416>>>>>>>//                Send DeActivateSuggestionList of hoOwner
103416>>>>>>>//            End
103416>>>>>>>//        End
103416>>>>>>>//    End_Function
103416>>>>>>>
103416>>>>>Use cDbUpdateFunctionLibrary.pkg
103416>>>>>Use cRDCHeaderGroup.pkg
103416>>>>>Use cCommandLinkButton.pkg
103416>>>>>
103416>>>>>Object oCreateDatabase_dg is a cRDCModalPanel
103418>>>>>    Set Size to 151 312
103419>>>>>    Set Label to "Create New Database"
103420>>>>>    Set piMinSize to 53 211
103421>>>>>    Set Location to 2 2
103422>>>>>    Set Icon to "ActionCreateDatabase1.ico"
103423>>>>>    
103423>>>>>    Property String psDriverID                   
103425>>>>>    Property String psCollation 
103427>>>>>    Property String psDatabaseName 
103429>>>>>
103429>>>>>//    Object oCollate_cf is a cRDCComboForm
103429>>>>>//        Set Size to 13 216
103429>>>>>//        Set Location to 42 63
103429>>>>>//        Set Label to "Use Collation:"  
103429>>>>>//        Set psToolTip to "Select/Enter the collation to use when creating the database. If none is specified the default SQL server collation above will be used. Note: Collations starting with 'SQL_' is obsolete and should not be used."
103429>>>>>//        // This must be set to False; else the filling takes for ever.
103429>>>>>//        Set pbAutoListWidth to False
103429>>>>>//        
103429>>>>>//        Procedure Combo_Fill_List
103429>>>>>//            String[] asCollations   
103429>>>>>//            Integer iCount iSize      
103429>>>>>//            String sDriverID sCollation
103429>>>>>//            
103429>>>>>//            Get psDriverID to sDriverID      
103429>>>>>//            
103429>>>>>//            // The SqlEnumerateDatabaseCollations function is *at current* for MSSQLDRV_ID only.
103429>>>>>//            If (sDriverID = MSSQLDRV_ID) Begin
103429>>>>>//                Send Cursor_Wait of Cursor_Control
103429>>>>>//                Get SqlEnumerateDatabaseCollations of ghoDbUpdateFunctionLibrary sDriverID to asCollations
103429>>>>>//                Move (SizeOfArray(asCollations)) to iSize
103429>>>>>//                Decrement iSize
103429>>>>>//                For iCount from 0 to iSize
103429>>>>>//                    Send Combo_Add_Item asCollations[iCount]
103429>>>>>//                Loop
103429>>>>>//                
103429>>>>>//                Get psCollation of ghoDbUpdateFunctionLibrary to sCollation
103429>>>>>//                Set Value to sCollation
103429>>>>>//                Send Cursor_Ready of Cursor_Control
103429>>>>>//            End
103429>>>>>//        End_Procedure
103429>>>>>//    
103429>>>>>//        Procedure OnChange
103429>>>>>//            String sValue
103429>>>>>//            Get Value to sValue
103429>>>>>//            Set psCollation to sValue
103429>>>>>//        End_Procedure
103429>>>>>//     
103429>>>>>//    End_Object
103429>>>>>
103429>>>>>    Object oInfo_tb is a TextBox
103431>>>>>        Set Auto_Size_State to False
103432>>>>>        Set Size to 8 50
103433>>>>>        Set Location to 133 120
103434>>>>>        Set TextColor to clGreen
103435>>>>>        Set Justification_Mode to JMode_Right
103436>>>>>        Set peAnchors to anBottomRight
103437>>>>>    End_Object
103438>>>>>
103438>>>>>    Object oMain_RDCHeaderGroup is a cRDCHeaderGroup
103440>>>>>        Set Size to 108 293
103441>>>>>        Set Location to 8 10
103442>>>>>        Set psImage to "ActionCreateDatabase1.ico"
103443>>>>>        Set Label to "Create Database"
103444>>>>>        Set psNote to "Enter collation and database name"
103445>>>>>        Set peAnchors to anTopBottom
103446>>>>>
103446>>>>>        Object oDriver_fm is a cRDCForm
103448>>>>>            Set Size to 13 100
103449>>>>>            Set Location to 34 63
103450>>>>>            Set Label to "Driver"
103451>>>>>            Set Enabled_State to False  
103452>>>>>        End_Object  
103453>>>>>        
103453>>>>>        Object oServerCurrentCollating_fm is a cRDCForm
103455>>>>>            Set Size to 13 216
103456>>>>>            Set Location to 49 63
103457>>>>>            Set Label to "Default Collation"
103458>>>>>            Set psToolTip to "The SQL server's default collation. It will be used when creating a new database, if nothing else is specified."
103459>>>>>            Set Enabled_State to False  
103460>>>>>            
103460>>>>>            Procedure InitializeCollation 
103463>>>>>                String sCollation
103463>>>>>                
103463>>>>>                Move False to Err
103464>>>>>                Send Ignore_All of Error_Object_Id
103465>>>>>                // Fetch the SQL server's default collation:
103465>>>>>                // It will be used when creating a new database, if nothing else is specified.
103465>>>>>                Get SqlDatabaseCollationQuery of ghoDbUpdateFunctionLibrary "master" False to sCollation
103466>>>>>                Send Trap_All of Error_Object_Id
103467>>>>>                If (Err = True) Begin
103469>>>>>                    Move "" to sCollation
103470>>>>>                End
103470>>>>>>
103470>>>>>                Set Value to sCollation
103471>>>>>            End_Procedure     
103472>>>>>    
103472>>>>>        End_Object  
103473>>>>>        
103473>>>>>        Object oCollate_fm is a cRDCSuggestionIniForm 
103475>>>>>            Set Size to 13 216
103476>>>>>            Set Location to 65 63
103477>>>>>            Set Label to "Collation"
103478>>>>>            Set psToolTip to "Suggestion list. Select/Enter the collation to use when creating the database. If none is specified the default SQL server collation above will be used. Note: Collations starting with 'SQL_' is obsolete and should not be used."
103479>>>>>            Set pbAskToRemoveMissingFile to False
103480>>>>>            Set pbAutoCheckValueExistsAsFile to False
103481>>>>>            Set pbUseWorkspaceIniFile to True
103482>>>>>            Set piStartAtChar to 3
103483>>>>>            Set Prompt_Button_Mode to PB_PromptOn
103484>>>>>            
103484>>>>>            Function ReadWorkspaceIniFile Returns String[]
103487>>>>>                String[] asCollations   
103488>>>>>                Integer iCount iSize      
103488>>>>>                String sDriverID sCollation
103488>>>>>                
103488>>>>>                Get psDriverID to sDriverID      
103489>>>>>                // The SqlEnumerateDatabaseCollations function is at current for MSSQLDRV_ID only.
103489>>>>>                If (sDriverID <> MSSQLDRV_ID) Begin
103491>>>>>                    Function_Return asCollations
103492>>>>>                End                 
103492>>>>>>
103492>>>>>                
103492>>>>>                Send Cursor_Wait of Cursor_Control
103493>>>>>                Get SqlEnumerateDatabaseCollations of ghoDbUpdateFunctionLibrary sDriverID to asCollations
103494>>>>>                Set psSavedFormValues to asCollations
103495>>>>>                    
103495>>>>>                If (sDriverID = MSSQLDRV_ID) Begin
103497>>>>>                    Get psCollation of ghoDbUpdateFunctionLibrary to sCollation
103498>>>>>                    Set Value to sCollation
103499>>>>>                End
103499>>>>>>
103499>>>>>                Send Cursor_Ready of Cursor_Control
103500>>>>>                Function_Return asCollations
103501>>>>>            End_Function
103502>>>>>    
103502>>>>>            Procedure OnChange
103505>>>>>                String sValue
103505>>>>>                Get Value to sValue
103506>>>>>                Set psCollation to sValue
103507>>>>>            End_Procedure
103508>>>>>         
103508>>>>>            Procedure WriteWorkspaceIniFile
103511>>>>>            End_Procedure             
103512>>>>>            
103512>>>>>//            Procedure Prompt      
103512>>>>>//                If (ghoSuggestionTimer=0) Begin
103512>>>>>//                    Send CreateSuggestionTimer
103512>>>>>//                End
103512>>>>>//                Send ActivateSuggestionList
103512>>>>>//                Send FindSuggestions
103512>>>>>//                Set Visible_State of ghoSuggestionList to True
103512>>>>>//            End_Procedure 
103512>>>>>            
103512>>>>>            Procedure OnEnterObject
103515>>>>>                Set pbUseWorkspaceIniFile to True
103516>>>>>                Forward Send OnEnterObject
103518>>>>>            End_Procedure
103519>>>>>
103519>>>>>            Procedure OnExitObject
103522>>>>>                Set pbUseWorkspaceIniFile to False
103523>>>>>                Forward Send OnExitObject
103525>>>>>            End_Procedure
103526>>>>>        
103526>>>>>            On_Key kCancel Send KeyAction of oCancel_Btn   
103527>>>>>//            On_Key kPrompt Send Prompt
103527>>>>>        End_Object   
103528>>>>>        
103528>>>>>        Object oDatabaseName_fm is a cRDCForm
103530>>>>>            Set Size to 13 216
103531>>>>>            Set Location to 81 63
103532>>>>>            Set Label_Col_Offset to 2
103533>>>>>            Set Label_Justification_Mode to JMode_Right
103534>>>>>            Set Label to "Database Name"
103535>>>>>            Set psToolTip to "Specify the name of the database to be created."
103536>>>>>        End_Object
103537>>>>>    
103537>>>>>    End_Object
103538>>>>>
103538>>>>>    Object oOK_Btn is a Button
103540>>>>>        Set Label    to "&OK"
103541>>>>>        Set Location to 130 198
103542>>>>>        Set peAnchors to anBottomRight   
103543>>>>>        
103543>>>>>        Property String psWorkingText "Working..."
103545>>>>>        Property String psIdleText    ""
103547>>>>>
103547>>>>>        Procedure OnClick
103550>>>>>            String sDatabase sDriverID sCollation
103550>>>>>            Boolean bOK bExists
103550>>>>>        
103550>>>>>            Get Value of oDatabaseName_fm to sDatabase    
103551>>>>>            Get psDriverID to sDriverID
103552>>>>>            Set psDatabaseName to ""
103553>>>>>
103553>>>>>            If (sDatabase <> "" and sDriverID <> "") Begin    
103555>>>>>                Set Value of oInfo_tb to (psWorkingText(Self))
103556>>>>>                If (sDriverID <> DATAFLEX_ID) Begin
103558>>>>>                    Get psCollation to sCollation
103559>>>>>                    Set psCollation of ghoDbUpdateFunctionLibrary to sCollation
103560>>>>>                End
103560>>>>>>
103560>>>>>
103560>>>>>                Get SqlUtilCheckIfDatabaseExists of ghoDbUpdateFunctionLibrary sDatabase to bExists
103561>>>>>                If (bExists = True) Begin
103563>>>>>                    Set Value of oInfo_tb to ""
103564>>>>>                    Send Info_Box "The database already exists. No changes made."
103565>>>>>                    Procedure_Return
103566>>>>>                End
103566>>>>>>
103566>>>>>                Send Cursor_Wait of Cursor_Control     
103567>>>>>                Get SqlDatabaseCreate of ghoDbUpdateFunctionLibrary sDriverID sDatabase False False to bOK
103568>>>>>                Send Cursor_Ready of Cursor_Control
103569>>>>>                Set Value of oInfo_tb to (psIdleText(Self))
103570>>>>>                If (bOK = False) Begin
103572>>>>>                    Send Info_Box ("Something went wrong and the database could NOT be created. Please check your database manager.")
103573>>>>>                    Procedure_Return
103574>>>>>                End 
103574>>>>>>
103574>>>>>                Set psDatabaseName to sDatabase
103575>>>>>                Send Close_Panel
103576>>>>>            End                                 
103576>>>>>>
103576>>>>>            Else If (sDatabase = "") Begin
103579>>>>>                Send Info_Box ("Please enter a database name and try again.")
103580>>>>>            End
103580>>>>>>
103580>>>>>        End_Procedure
103581>>>>>
103581>>>>>    End_Object
103582>>>>>
103582>>>>>    Object oCancel_Btn is a Button
103584>>>>>        Set Label    to "&Cancel"
103585>>>>>        Set Location to 130 253
103586>>>>>        Set peAnchors to anBottomRight
103587>>>>>
103587>>>>>        Procedure OnClick
103590>>>>>            Send Close_Panel
103591>>>>>        End_Procedure
103592>>>>>
103592>>>>>    End_Object
103593>>>>>
103593>>>>>    Object oHelp_btn is a Button
103595>>>>>        Set Location to 130 75
103596>>>>>        Set Label to "Help"
103597>>>>>        Set psImage to "ActionHelpInternet1.ico"
103598>>>>>        Set psToolTip to "Show a Full List of Collations Supported in SQL Server 2017"
103599>>>>>        Set peAnchors to anBottomLeft
103600>>>>>    
103600>>>>>        Procedure OnClick
103603>>>>>            Runprogram Shell Background "https://database.guide/full-list-of-collations-supported-in-sql-server-2017/"
103604>>>>>        End_Procedure
103605>>>>>    
103605>>>>>    End_Object
103606>>>>>    
103606>>>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
103607>>>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
103608>>>>>    On_Key kCancel       Send KeyAction of oCancel_Btn
103609>>>>>End_Object
103610>>>>>
103610>>>>>Function Create_DataBase_Dialog String sDriverID Returns String
103613>>>>>    String sDatabaseName         
103613>>>>>    Handle ho
103613>>>>>    
103613>>>>>    Move (oCreateDatabase_dg(Self)) to ho
103614>>>>>    Set psDriverID of ho to sDriverID
103615>>>>>    Set Value of (oDriver_fm(ho)) to sDriverID
103616>>>>>    Set Value of (oDatabaseName_fm(ho)) to ""
103617>>>>>    Send InitializeCollation of (oServerCurrentCollating_fm(ho))
103618>>>>>    Send Popup of ho
103619>>>>>    
103619>>>>>    Get psDatabaseName of ho to sDatabaseName
103620>>>>>    Function_Return sDatabaseName
103621>>>>>End_Function                         
103622>>>
103622>>>Define CS_LoadingServers        for "Enumerating servers..."
103622>>>Define CS_LoadingDatabases      for "Enumerating databases..."
103622>>>Define CS_LoadingTableSpaces    for "Enumerating table spaces..."
103622>>>Define CS_LoadingSchemas        for "Enumerating schemas..."
103622>>>Define CS_LoginAttempt          for "Connecting..."
103622>>>Define CS_LoginSuccessful       for "Login successful!"
103622>>>Define CS_LoginFailed           for "Login failed!"
103622>>>Define CS_DF_File_Schema        for "Schema"
103622>>>Define CS_DF_File_Owner         for "Owner"
103622>>>
103622>>>Object oSQLMaintainConnections_dg is a ModalPanel
103624>>>    Set Label to "Edit SQL Connection"
103625>>>    Set Size to 315 324 //309 324
103626>>>    Set Location to 4 6
103627>>>    Set piMaxSize to (Hi(Size(Self))) (Low(Size(Self)) + 300)
103628>>>    Set piMinSize to (Hi(Size(Self))) (Low(Size(Self)))
103629>>>    Set Locate_Mode to CENTER_ON_PARENT
103630>>>    Set Border_Style to Border_Thick
103631>>>    
103631>>>    Property Boolean pbReadOnly  False
103633>>>    Property Boolean pbNew       False // First time for a workspace, which means the .ini-file is empty.
103635>>>    Property Integer piCurrentRow -1   // The current row of the grid that was passed to this dialog.
103637>>>    Property Boolean pbChanged   False // If any change was made to the data.
103639>>>    Property Handle phoDialogCommandbar
103641>>>    Property tSQLConnection pSQLConnectionData
103643>>>    Property tDataSourceRow[] pTheData
103645>>>    Property Boolean pbDFConnId  False // Is set to True if this is a DAW "DFConnId.ini" file; in which case we warn to not encrypt/decrypt password. (different algorithms and don't touch password)
103647>>>    Property String psUncryptedPw      // Used if  pbDFConnId = True to temporary save the un-encrypted password.
103649>>>
103649>>>    Object oSettings_grp is a cRDCHeaderGroup
103651>>>        Set Size to 202 303
103652>>>        Set Location to 77 11 //71 11
103653>>>        Set psImage to "Settings1.ico"
103654>>>        Set psLabel to "SQL Connection Settings"
103655>>>        Set peAnchors to anTopLeftRight
103656>>>        Set psToolTip to "Setup the SQL connection."
103657>>>
103657>>>        Object oConnectionID_fm is a cSQLForm
103659>>>            Set Size to 13 115
103660>>>            Set Location to 22 82
103661>>>            Set Label to "Connection ID"
103662>>>            Set psToolTip to "The DFConnectionID keyword to set a default connection id for the driver. This is the connection ID that appear in database table .int files with the format; 'SERVER_NAME DFCONNID=MyConnID'"
103663>>>            Set piItem to 2
103664>>>            Set peAnchors to anTopLeftRight
103665>>>        End_Object
103666>>>
103666>>>        Object oEnabled_cb is a cSQLCheckBox
103668>>>            Set Size to 10 36
103669>>>            Set Location to 25 210
103670>>>            Set Label to "Enabled"
103671>>>            Set psToolTip to "Check to indicate that this is the enabled connection. Note: There can only be one enabled connection at a time."
103672>>>            Set piItem to 1
103673>>>            Set peAnchors to anTopRight
103674>>>
103674>>>            Procedure OnChange
103677>>>                Boolean bChecked bNew
103677>>>                tSQLConnection SQLConnection
103677>>>                tSQLConnection SQLConnection
103677>>>
103677>>>                Get pbNew to bNew
103678>>>                Get Checked_State to bChecked
103679>>>                If (bNew = False and bChecked = True) Begin
103681>>>                    Get pSQLConnectionData to SQLConnection
103682>>>                    Move True to SQLConnection.bEnabled
103683>>>                End
103683>>>>
103683>>>
103683>>>            End_Procedure
103684>>>
103684>>>        End_Object
103685>>>
103685>>>        Object oODBC_rgp is a RadioGroup
103687>>>            Set Location to 38 24
103688>>>            Set Size to 32 173
103689>>>//            Set psToolTip to "Only available if the ODBC_DRV has been selected. Depending on the radio button that is selected the 'Server/DSN' selection list shows different values."
103689>>>            Set peAnchors to anTopLeftRight
103690>>>            Set Label to "ODBC Source Type"
103691>>>
103691>>>            Object oRadio0 is a Radio
103693>>>                Set Label to "User data"
103694>>>                Set Size to 10 44
103695>>>                Set Location to 12 5
103696>>>            End_Object
103697>>>
103697>>>            Object oRadio1 is a Radio
103699>>>                Set Label to "System data"
103700>>>                Set Size to 10 52
103701>>>                Set Location to 12 52
103702>>>            End_Object
103703>>>
103703>>>            Object oRadio2 is a Radio
103705>>>                Set Label to "Both"
103706>>>                Set Size to 10 26
103707>>>                Set Location to 13 109
103708>>>            End_Object
103709>>>
103709>>>            Object oRadio3 is a Radio
103711>>>                Set Label to "File"
103712>>>                Set Size to 10 25
103713>>>                Set Location to 13 141
103714>>>            End_Object
103715>>>
103715>>>            Procedure Notify_Select_State Integer iToItem Integer iFromItem
103718>>>                Forward Send Notify_Select_State iToItem iFromItem 
103720>>>                If (oFileDSN_btn(Self) <> 0) Begin
103722>>>                    Set Enabled_State of oFileDSN_btn to (iToItem = 3)
103723>>>                End
103723>>>>
103723>>>            End_Procedure
103724>>>
103724>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
103727>>>                Set Enabled_State to (sDriverID = ODBC_DRV_ID)
103728>>>                Set Enabled_State of oODBC_rgp to (sDriverID = ODBC_DRV_ID)
103729>>>            End_Procedure
103730>>>
103730>>>            Set Current_Radio to 2
103731>>>        End_Object
103732>>>
103732>>>        Object oFileDSN_btn is a cRDCButton
103734>>>            Set Size to 13 78
103735>>>            Set Location to 42 210
103736>>>            Set Label to "Select File DSN..."
103737>>>            Set pbAutoEnable to True
103738>>>            Set peAnchors to anTopRight
103739>>>
103739>>>            Procedure OnClick
103742>>>                String sFileName
103742>>>                Get vSelect_File ("Data Sources (*.dsn)|*.dsn|All Files (*.*)|*.*") "Select a file data source" "" to sFileName
103743>>>                If (sFileName <> "") Begin
103745>>>                    Set Value of oServer_fm to sFileName
103746>>>                End
103746>>>>
103746>>>            End_Procedure     
103747>>>            
103747>>>            Function IsEnabled Returns Boolean
103750>>>                String sDriverID
103750>>>                Integer iRadio
103750>>>                Get Value of oDriverID_cf to sDriverID
103751>>>                Get Current_Radio of oODBC_rgp to iRadio
103752>>>                Function_Return (sDriverID = ODBC_DRV_ID and iRadio = 3)
103753>>>            End_Function
103754>>>
103754>>>        End_Object
103755>>>
103755>>>        Object oODBCAdmin_btn is a cRDCButton
103757>>>            Set Size to 13 78
103758>>>            Set Location to 57 210
103759>>>            Set Label to "ODBC Admin" 
103760>>>            Set psImage to "ODBCAD32.ico"
103761>>>            Set pbAutoEnable to True
103762>>>            Set peAnchors to anTopRight
103763>>>            
103763>>>            Procedure OnClick
103766>>>                Handle hWnd
103766>>>                Get Window_Handle to hWnd
103767>>>                If (hWnd <> 0) Begin
103769>>>                    Call_Driver 0 ODBC_DRV_ID Function ODBC_MANAGE_DATA_SOURCES Callback 0 Passing CLI$StrDummy CLI$StrDummy !1 Result CLI$IntDummy
103774>>>                End
103774>>>>
103774>>>                Else Begin
103775>>>                    Send Stop_Box "Could not get a Windows handle.."
103776>>>                End
103776>>>>
103776>>>            End_Procedure
103777>>>
103777>>>            Function IsEnabled Returns Boolean
103780>>>                String sDriverID
103780>>>                Get Value of oDriverID_cf to sDriverID
103781>>>                Function_Return (sDriverID = ODBC_DRV_ID)
103782>>>            End_Function
103783>>>
103783>>>        End_Object
103784>>>
103784>>>        Object oServer_fm is a cSQLForm
103786>>>            Set Size to 13 114
103787>>>            Set Location to 74 82
103788>>>            Set Label to "Server"
103789>>>            Set psToolTip to "Server/DSN: Depending on the selected database type the label can either display as 'Server' or 'DSN'. Either enter the name - if you know it - or by using the selection list (F4). Tip: If you are using Microsoft SQL Server and you are testing on the same machine as the MS SQL Server instance is running and you are using SQLEXPRESS you can enter e.g. '.\SQLEXPRESS'. That will mean use the SQLEXPRESS instance of Microsoft SQL Server running on this machine. If you press [F4] and the selection list comes up empty for Microsoft SQL Server it probably is because the service hasn't been started. Type 'Services' in Windows menu system to start Windows Services app. Type 'SQL' to jump to the SQL Server services. Check that the 'SQL Server Browser' service is started and set to 'Automatic'."
103790>>>            Set piItem to 5
103791>>>            Set peAnchors to anTopLeftRight
103792>>>
103792>>>            Property Handle phoPromptObject (oServerSelection_sl(Self))
103794>>>
103794>>>            Procedure Prompt
103797>>>                String sDriverID sValue
103797>>>                String[] sTheData
103798>>>                Integer iDbType iODBCType iRadio iPos
103798>>>                Handle ho
103798>>>
103798>>>                Get Prompt_Object to ho
103799>>>                If (ho = 0) Begin
103801>>>                    Procedure_Return
103802>>>                End
103802>>>>
103802>>>
103802>>>                Set Label of oShowInfo_tb to CS_LoadingServers
103803>>>                Send Cursor_Wait of Cursor_Control
103804>>>                Get SelectedDbType of oDbType_cf to iDbType
103805>>>                Get Value of oDriverID_cf to sDriverID
103806>>>                Move (Trim(sDriverID)) to sDriverID
103807>>>                Get Current_Radio of oODBC_rgp to iRadio
103808>>>                If (iRadio = 0) Begin
103810>>>                    Move SQL_FETCH_USER   to iODBCType
103811>>>                End
103811>>>>
103811>>>                If (iRadio = 1) Begin
103813>>>                    Move SQL_FETCH_SYSTEM to iODBCType
103814>>>                End
103814>>>>
103814>>>                If (iRadio = 2) Begin
103816>>>                    Move SQL_FETCH_ALL    to iODBCType
103817>>>                End
103817>>>>
103817>>>
103817>>>                Send Ignore_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
103818>>>                Load_Driver sDriverID
103819>>>                Send Trap_Error of Error_Object_Id DFERR_CANT_LOAD_DLL
103820>>>                If (LastErr = DFERR_CANT_LOAD_DLL) Begin
103822>>>                    Send Cursor_Ready of Cursor_Control
103823>>>                    Send Info_Box ("Can't display any items because the database driver could not be loaded. (" + sDriverID + ")")
103824>>>                    Procedure_Return
103825>>>                End
103825>>>>
103825>>>
103825>>>                Get SqlUtilEnumerateServers of ghoDbUpdateFunctionLibrary sDriverID iODBCType to sTheData
103826>>>                Set psTheData  of ho to sTheData
103827>>>                Set Label of oShowInfo_tb to ""
103828>>>
103828>>>                Forward Send Prompt
103830>>>
103830>>>                // The selection list will show the ODBC DataSource name + a comma (,) + a description.
103830>>>                // We need to remove those parts from the comma and to the end of string.
103830>>>                If (sDriverID = ODBC_DRV_ID) Begin
103832>>>                    Get Value to sValue
103833>>>                    Move (Pos(",", sValue)) to iPos
103834>>>                    Move (Left(sValue, (iPos - 1))) to sValue
103835>>>                    Set Value to sValue
103836>>>                End
103836>>>>
103836>>>            End_Procedure
103837>>>
103837>>>            Procedure OnChange
103840>>>                tSQLIntTableInfo[] sReturnStructArray
103840>>>                tSQLIntTableInfo[] sReturnStructArray
103841>>>                String sServer sDatabaseName sVal sDriverID
103841>>>                Integer iSize iCount iPos 
103841>>>                Boolean bFileDSN
103841>>>                
103841>>>                Move False to bFileDSN
103842>>>                Get Value of oDriverID_cf to sDriverID
103843>>>                If (sDriverID = "") Begin
103845>>>                    Procedure_Return
103846>>>                End
103846>>>>
103846>>>                If (sDriverID = ODBC_DRV_ID) Begin
103848>>>                    Move "" to sDatabaseName
103849>>>                    Get Value to sServer 
103850>>>                    Move (Pos(",", sServer)) to iPos
103851>>>                    If (iPos <> 0) Begin
103853>>>                        Move (Left(sServer, (iPos -1))) to sServer
103854>>>                    End
103854>>>>
103854>>>                    If (sServer <> "") Begin
103856>>>                        Set psServer of ghoDbUpdateFunctionLibrary to sServer
103857>>>                    End
103857>>>>
103857>>>                    Get _SqlDatabasesArrayODBC of ghoDbUpdateFunctionLibrary to sReturnStructArray
103858>>>                    If (SizeOfArray(sReturnStructArray)) Begin
103860>>>                        If (SizeOfArray(sReturnStructArray) = 1 and sReturnStructArray[0].sServerName = "") Begin
103862>>>                            // If a FILEDSN: (can only be one database name)
103862>>>                            Move sReturnStructArray[0].sDatabaseName to sDatabaseName
103863>>>                            Move True to bFileDSN
103864>>>                        End
103864>>>>
103864>>>                        Else Begin
103865>>>                            // Else the DSN's were read from the registry.
103865>>>                            Move (SizeOfArray(sReturnStructArray)) to iSize
103866>>>                            Decrement iSize
103867>>>                            For iCount from 0 to iSize
103873>>>>
103873>>>                                Move (sReturnStructArray[iCount].sServerName) to sVal
103874>>>                                If (Uppercase(sServer) = Uppercase(sVal)) Begin
103876>>>                                    Move sReturnStructArray[iCount].sDatabaseName to sDatabaseName
103877>>>                                    Move iSize to iCount // We're done.
103878>>>                                End
103878>>>>
103878>>>                            Loop
103879>>>>
103879>>>                        End
103879>>>>
103879>>>                    End
103879>>>>
103879>>>                    Set Value of oDatabase_fm to sDatabaseName
103880>>>                    If (bFileDSN = True) Begin
103882>>>                        Set Current_Radio of oODBC_rgp to 3
103883>>>                    End    
103883>>>>
103883>>>                    Else Begin
103884>>>                        Set Current_Radio of oODBC_rgp to 2
103885>>>                    End
103885>>>>
103885>>>                End
103885>>>>
103885>>>
103885>>>            End_Procedure
103886>>>
103886>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
103889>>>                String sLabel
103889>>>                Handle ho
103889>>>
103889>>>                Get phoPromptObject to ho
103890>>>                Set Prompt_Button_Mode to PB_PromptOn
103891>>>                Case Begin
103891>>>                    Case (iDbType = EN_dbTypeDB2)
103893>>>                        Move "DSN" to sLabel
103894>>>                        Case Break
103895>>>                    Case (iDbType = EN_dbTypeMSSQL)
103898>>>                        If (sDriverID = ODBC_DRV_ID) Begin
103900>>>                            Move "ODBC Data Source" to sLabel
103901>>>                        End
103901>>>>
103901>>>                        Else Begin
103902>>>                            Move "Server" to sLabel
103903>>>                        End
103903>>>>
103903>>>                        Case Break
103904>>>                    Case (iDbType = EN_dbTypeMySQL)
103907>>>                        If (sDriverID = ODBC_DRV_ID) Begin
103909>>>                            Move "ODBC Data Source" to sLabel
103910>>>                        End
103910>>>>
103910>>>                        Else Begin
103911>>>                            Move "DSN" to sLabel
103912>>>                        End
103912>>>>
103912>>>                        Case Break
103913>>>                    Case (iDbType = EN_dbTypeOracle)
103916>>>                        If (sDriverID = ODBC_DRV_ID) Begin
103918>>>                            Move "ODBC Data Source" to sLabel
103919>>>                        End
103919>>>>
103919>>>                        Else Begin
103920>>>                            Move "Server" to sLabel
103921>>>                        End
103921>>>>
103921>>>                        Case Break
103922>>>                    Case (iDbType = EN_dbTypePostgre)
103925>>>                        If (sDriverID = ODBC_DRV_ID) Begin
103927>>>                            Move "ODBC Data Source" to sLabel
103928>>>                        End
103928>>>>
103928>>>                        Else Begin
103929>>>                            Move "Server" to sLabel
103930>>>                        End
103930>>>>
103930>>>                        Case Break
103931>>>                    Case Else
103931>>>                Case End
103931>>>
103931>>>                Set Prompt_Object to ho
103932>>>                Set Label to sLabel
103933>>>            End_Procedure
103934>>>
103934>>>        End_Object
103935>>>
103935>>>        Object oSilentLogin_fm is a cSQLCheckBox
103937>>>            Set Size to 10 48
103938>>>            Set Location to 76 210
103939>>>            Set Label to "Silent Login"
103940>>>            Set psToolTip to "Silent login to database is to not show error if login was unsuccessive."
103941>>>            Set peAnchors to anTopRight
103942>>>            Set piItem to 15
103943>>>        End_Object
103944>>>
103944>>>        Object oTrusted_cb is a cSQLCheckbox
103946>>>            Set Size to 12 85
103947>>>            Set Location to 91 82
103948>>>            Set Label to "Use Trusted Connection"
103949>>>            Set psToolTip to "(Windows Authentication) When selected, SQL Server uses integrated login (Windows login information) security to establish connections using this data source, regardless of the current login security mode at the server."
103950>>>            Set piItem to 8
103951>>>
103951>>>            Procedure OnChange
103954>>>                Boolean bChecked
103954>>>                Get Checked_State to bChecked
103955>>>                Set Enabled_State of oUserID_fm   to (bChecked = False)
103956>>>                Set Enabled_State of oPassword_fm to (bChecked = False)
103957>>>                Set Enabled_State of oViewPassword_btn to (bChecked = False)
103958>>>            End_Procedure
103959>>>
103959>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
103962>>>                Boolean bChecked
103962>>>
103962>>>                Get Checked_State to bChecked
103963>>>                If (iDbType <> EN_dbTypeMSSQL) Begin
103965>>>                    Set Enabled_State to (iDbType = EN_dbTypeMSSQL)
103966>>>                    If (bChecked = True) Begin
103968>>>                        Set Checked_State to False
103969>>>                    End
103969>>>>
103969>>>                End
103969>>>>
103969>>>                Else Begin
103970>>>                    Set Enabled_State to True
103971>>>                End
103971>>>>
103971>>>
103971>>>                Send OnChange
103972>>>            End_Procedure
103973>>>
103973>>>        End_Object
103974>>>
103974>>>        Object oUserID_fm is a cSQLForm
103976>>>            Set Size to 13 114
103977>>>            Set Location to 103 82
103978>>>            Set Label to "User ID"
103979>>>            Set psToolTip to "Enter the user name to use for authentication when you log on to the database."
103980>>>            Set piItem to 9
103981>>>            Set peAnchors to anTopLeftRight
103982>>>        End_Object
103983>>>
103983>>>        Object oPassword_fm is a cSQLForm
103985>>>            Set Size to 13 61
103986>>>            Set Location to 103 210
103987>>>            Set Label to "Password"
103988>>>            Set psToolTip to "Enter the password for your user name. The password will automatically be encrypted & decrypted when writing/reading from the ini file. Of Special Note: If the cConnection class is used with DataFlex 19 or later and such an .ini file is edited with this program you will get a question if you would like the program to 'touch' the password or not. If you answer No, the ini-file will keep working with the DataFlex tools. You should probably never try to change the password with this program for a DFConnid.ini file as the two programs uses different encryption/decryption algorithms."
103989>>>            Set piItem to 10
103990>>>            Set Password_State to True
103991>>>            Set peAnchors to anTopRight
103992>>>            Set Label_Col_Offset to 0
103993>>>            Set Label_Justification_Mode to JMode_Top
103994>>>        End_Object
103995>>>
103995>>>        Object oShowInfo_tb is a TextBox
103997>>>            Set Auto_Size_State to False
103998>>>            Set Size to 10 114
103999>>>            Set Location to 119 82
104000>>>            Set TextColor to clGreen
104001>>>            Set Justification_Mode to JMode_Center
104002>>>            Set peAnchors to anTopRight
104003>>>        End_Object
104004>>>
104004>>>        Object oViewPassword_btn is a cRDCButton
104006>>>            Set Size to 13 15
104007>>>            Set Location to 103 273
104008>>>            Set psToolTip to "View/hide password"
104009>>>            Set psImage to "ViewPassword1.ico"
104010>>>            Set piImageMarginLeft to 2
104011>>>            Set peAnchors to anTopRight
104012>>>
104012>>>            Procedure OnClick
104015>>>                Handle ho
104015>>>                Boolean bState
104015>>>
104015>>>                Move (oPassword_fm(Self)) to ho
104016>>>                Get Password_State of ho 0 to bState
104017>>>                Send Deactivate of ho
104018>>>                Set Password_State of ho to (not(bState))
104019>>>                // Finally we need to re-add the object to the focus tree or it will be invisible.
104019>>>                Send Activate of ho (Parent(Self))
104020>>>            End_Procedure
104021>>>
104021>>>        End_Object
104022>>>
104022>>>        Object oCheckLogin_btn is a cRDCButton
104024>>>            Set Size to 13 78
104025>>>            Set Location to 119 210
104026>>>            Set Label to "Check &Login"
104027>>>            Set psImage to "ActionLogin1.ico"
104028>>>            Set psToolTip to "You should always use this button when adding a new SQL Connection to ensure that the entered credentials are correct. (Ctrl+L)"
104029>>>            Set piImageMarginLeft to 3
104030>>>            Set peAnchors to anTopRight
104031>>>
104031>>>            Procedure OnClick
104034>>>                String sConnectionString sDriverID sError //sServer sDatabase sUserId sPassword 
104034>>>                Boolean bLoginSuccessful bMertechDriver // bTrusted 
104034>>>                Integer iDriverID
104034>>>                Handle hoErrorObj
104034>>>
104034>>>                Send Cursor_Wait of Cursor_Control // Note: The Cursor_Wait changes the Err flag!
104035>>>                Move Error_Object_Id to hoErrorObj
104036>>>                Move Self to Error_Object_Id
104037>>>                Move False to Err
104038>>>
104038>>>                Set Value of oLoginInfo_tb to CS_LoginAttempt
104039>>>                Send PumpMsgQueue
104040>>>                
104040>>>                Get Value of oDriverID_cf to sDriverID
104041>>>                Move "" to sError
104042>>>                Get LoginString (&sError) to sConnectionString
104043>>>                If (sError <> "") Begin
104045>>>                    Set Value of oLoginInfo_tb to CS_LoginFailed
104046>>>                    Send Info_Box sError
104047>>>                    Procedure_Return
104048>>>                End
104048>>>>
104048>>>                
104048>>>                Get DriverIndex of ghoSQLConnectionHandler sDriverID to iDriverID
104049>>>                If (iDriverID = 0) Begin
104051>>>                    Set TextColor of oLoginInfo_tb to clRed
104052>>>                    Set Value of oLoginInfo_tb to CS_LoginFailed
104053>>>                    Send Info_Box ("The driver" * sDriverID * "could not be loaded. Is the driver installed? And equally imporant; Is the corresponding database server or client software installed?")
104054>>>                    Procedure_Return
104055>>>                End
104055>>>>
104055>>>
104055>>>                Get IsMertechDriver of ghoSQLConnectionHandler sDriverID to bMertechDriver
104056>>>                If (bMertechDriver = False) Begin
104058>>>                    Set_Attribute DF_DRIVER_SILENT_LOGIN of iDriverID to True
104061>>>                End
104061>>>>
104061>>>
104061>>>                Move False to Err
104062>>>                Send CreateConnParamsFromConnectionString of ghoSQLConnectionHandler sDriverID sConnectionString
104063>>>
104063>>>                Move (Err = False) to bLoginSuccessful
104064>>>                If bLoginSuccessful Begin
104066>>>                    Set TextColor of oLoginInfo_tb to clGreen
104067>>>                    Set Value of oLoginInfo_tb to CS_LoginSuccessful 
104068>>>                    Set psDriverID of ghoDbUpdateFunctionLibrary to sDriverID
104069>>>                    Set psConnectionString of ghoDbUpdateFunctionLibrary to sConnectionString
104070>>>                End
104070>>>>
104070>>>                Else Begin
104071>>>                    Set TextColor of oLoginInfo_tb to clRed
104072>>>                    Set Value of oLoginInfo_tb to CS_LoginFailed
104073>>>                End
104073>>>>
104073>>>
104073>>>                Move hoErrorObj to Error_Object_Id
104074>>>                Send Cursor_Ready of Cursor_Control
104075>>>            End_Procedure
104076>>>
104076>>>            // This method is here simply to intercept any error that may occur while logging in
104076>>>            // it does not have to do anything with the error, but it suppresses the normal error display
104076>>>            Procedure Error_Report Integer iErrNum Integer iErrLine String sErrMsg
104079>>>                    If (LastErr = 25000) Begin
104081>>>                        If (Trim(sErrMsg) <> "") Begin
104083>>>                            Send Info_Box sErrMsg
104084>>>                        End
104084>>>>
104084>>>                    End  
104084>>>>
104084>>>            End_Procedure   
104085>>>            
104085>>>        End_Object
104086>>>
104086>>>        Object oIndexTableSpace_fm is a cSQLForm
104088>>>            Set Size to 13 114
104089>>>            Set Location to 133 82
104090>>>            Set Label to "Index Table Space"
104091>>>            Set piItem to 14
104092>>>            Set psToolTip to "To set the name of the table space where indexes will be stored. Only applicable for IBM DB2, Oracle and PostgreSQL databases."
104093>>>            Set Prompt_Button_Mode to PB_PromptOn
104094>>>            Set Prompt_Object to (oTableSpaceSelection_sl(Self))
104095>>>            Set peAnchors to anTopLeftRight
104096>>>
104096>>>            Procedure Prompt
104099>>>                String[] sTheData
104100>>>                Handle ho
104100>>>                tSQLConnection SQLConnection
104100>>>                tSQLConnection SQLConnection
104100>>>
104100>>>                Set Label of oShowInfo_tb to CS_LoadingTableSpaces
104101>>>                Get ReadCurrentSQLSettings to SQLConnection
104102>>>
104102>>>                Get SqlUtilEnumerateTableSpaces of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType SQLConnection.sConnectionString to sTheData
104103>>>
104103>>>                Get Prompt_Object to ho
104104>>>                Set psTheData     of ho to sTheData
104105>>>                Set Label of oShowInfo_tb to ""
104106>>>
104106>>>                Forward Send Prompt
104108>>>            End_Procedure
104109>>>
104109>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
104112>>>                Set Enabled_State to ((iDbType = EN_dbTypeDB2 or iDbType = EN_dbTypeOracle or iDbType = EN_dbTypePostgre) and sDriverID <> ODBC_DRV_ID)
104113>>>            End_Procedure
104114>>>
104114>>>        End_Object
104115>>>
104115>>>        Object oLoginInfo_tb is a TextBox
104117>>>            Set Auto_Size_State to False
104118>>>            Set Size to 9 78
104119>>>            Set Location to 135 210
104120>>>            Set TextColor to clGreen
104121>>>            Set peAnchors to anTopRight
104122>>>            Set Justification_Mode to JMode_Left
104123>>>        End_Object
104124>>>
104124>>>        Object oBaseTableSpace_fm is a cSQLForm
104126>>>            Set Size to 13 114
104127>>>            Set Location to 148 82
104128>>>            Set Label to "Table Space"
104129>>>            Set piItem to 12
104130>>>            Set psToolTip to "Sets the name of the table space where the data will be stored. Applicable for IBM DB2, Oracle and PostgreSQL databases. Table spaces allow you to assign a physical location to logical objects (tables). They can be used to improve performance or to increase the page size, thus increasing the maximum size of a record that can be stored in the table space. You can specify what table space must be used to store table, index or long data. The index and long data table space will only be set when the table tables pace is also set."
104131>>>            Set Prompt_Button_Mode to PB_PromptOn
104132>>>            Set Prompt_Object to (oTableSpaceSelection_sl(Self))
104133>>>            Set peAnchors to anTopLeftRight
104134>>>
104134>>>            Procedure Prompt
104137>>>                String[] sTheData
104138>>>                Handle ho
104138>>>                tSQLConnection SQLConnection
104138>>>                tSQLConnection SQLConnection
104138>>>
104138>>>                Set Label of oShowInfo_tb to CS_LoadingTableSpaces
104139>>>                Get ReadCurrentSQLSettings to SQLConnection
104140>>>                Get SqlUtilEnumerateTableSpaces of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType SQLConnection.sConnectionString to sTheData
104141>>>
104141>>>                Get Prompt_Object to ho
104142>>>                Set psTheData  of ho to sTheData
104143>>>                Set Label of oShowInfo_tb to ""
104144>>>
104144>>>                Forward Send Prompt
104146>>>            End_Procedure
104147>>>
104147>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
104150>>>                Set Enabled_State to ((iDbType = EN_dbTypeDB2 or iDbType = EN_dbTypeOracle or iDbType = EN_dbTypePostgre) and sDriverID <> ODBC_DRV_ID)
104151>>>            End_Procedure
104152>>>
104152>>>        End_Object
104153>>>
104153>>>        Object oLongTableSpace_fm is a cSQLForm
104155>>>            Set Size to 13 114
104156>>>            Set Location to 163 82
104157>>>            Set Label to "Long Table Space"
104158>>>            Set piItem to 13
104159>>>            Set psToolTip to "Only applicable for IBM DB2 databases. If you are unsure on what to enter your best bet is to use the same value as for the 'Table Space' above."
104160>>>            Set Prompt_Button_Mode to PB_PromptOn
104161>>>            Set Prompt_Object to (oTableSpaceSelection_sl(Self))
104162>>>            Set peAnchors to anTopLeftRight
104163>>>
104163>>>            Procedure Prompt
104166>>>                String[] sTheData
104167>>>                Handle ho
104167>>>                tSQLConnection SQLConnection
104167>>>                tSQLConnection SQLConnection
104167>>>
104167>>>                Set Label of oShowInfo_tb to CS_LoadingTableSpaces
104168>>>                Get ReadCurrentSQLSettings to SQLConnection
104169>>>
104169>>>                Get SqlUtilEnumerateTableSpaces of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType SQLConnection.sConnectionString to sTheData
104170>>>
104170>>>                Get Prompt_Object to ho
104171>>>                Set psTheData     of ho to sTheData
104172>>>                Set Label of oShowInfo_tb to ""
104173>>>
104173>>>                Forward Send Prompt
104175>>>            End_Procedure
104176>>>
104176>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
104179>>>                Set Enabled_State to (iDbType = EN_dbTypeDB2)
104180>>>            End_Procedure
104181>>>
104181>>>        End_Object
104182>>>
104182>>>        Object oSchema_fm is a cSQLForm
104184>>>            Set Size to 13 78
104185>>>            Set Location to 163 210
104186>>>            Set Label to "Schema"
104187>>>            Set psToolTip to "The name of the schema the table belongs to. A schema is a collection of names or objects. A schema can contain tables, views, and triggers. Schemas provide a logical classification of objects in the database. It can have a slightly different meaning depending on the selected database type. Please consult your database manager to ensure the correct value is selected. Applicable for IBM DB2, Oracle and PostgreSQL databases. For IBM DB2 not specifying a schema will result in the user name being used. Microsoft SQL Server has a completely different approach to security and privileges and uses owners instead."
104188>>>            Set piItem to 11
104189>>>            Set Enabled_State to False
104190>>>
104190>>>            Property String psSchemaToolTip "The name of the schema the table belongs to. A schema is a collection of names or objects. A schema can contain tables, views, and triggers. Schemas provide a logical classification of objects in the database. It can have a slightly different meaning depending on the selected database type. Please consult a database manager to ensure the correct value is selected. Applicable for IBM DB2, Oracle and PostgreSQL databases. For IBM DB2 not specifying a schema will result in the user name being used. Microsoft SQL Server has a completely different approach to security and privileges and uses owners instead."
104192>>>            Property String psOwnerTooltip  "The owner name to use within the database where the tables must be placed. If you want to specify an owner of the table that will be converted you can do so, not specifying an owner will result in the default owner being used. The suggested owner name to use is 'dbo'"
104194>>>
104194>>>            Set peAnchors to anTopRight
104195>>>            Set Label_Justification_Mode to JMode_Top
104196>>>            Set Label_Col_Offset to 0
104197>>>
104197>>>            Procedure Prompt
104200>>>                String[] sTheData
104201>>>                Handle ho
104201>>>                tSQLConnection SQLConnection
104201>>>                tSQLConnection SQLConnection
104201>>>
104201>>>                Set Label of oShowInfo_tb to CS_LoadingSchemas
104202>>>                Get ReadCurrentSQLSettings to SQLConnection
104203>>>
104203>>>                Get SqlUtilEnumerateSchemas of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID SQLConnection.iDbType SQLConnection.sConnectionString to sTheData
104204>>>
104204>>>                Get Prompt_Object to ho
104205>>>                Set psTheData     of ho to sTheData
104206>>>                Set Label of oShowInfo_tb to ""
104207>>>
104207>>>                Forward Send Prompt
104209>>>            End_Procedure
104210>>>
104210>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
104213>>>                String sValue
104213>>>
104213>>>                Set Enabled_State to ((iDbType = EN_dbTypeMSSQL or iDbType = EN_dbTypeDB2 or iDbType = EN_dbTypeOracle or iDbType = EN_dbTypePostgre) and sDriverID <> ODBC_DRV_ID)
104214>>>                If (iDbType = EN_dbTypeMSSQL) Begin
104216>>>                    Set Label to CS_DF_File_Owner
104217>>>                    Set Prompt_Button_Mode to PB_PromptOff
104218>>>                    Set Prompt_Object to 0
104219>>>                    Set psToolTip to (psOwnerTooltip(Self))
104220>>>                    Get Value to sValue
104221>>>                    If (Trim(sValue) = "") Begin
104223>>>                        Set Value to "dbo"
104224>>>                    End
104224>>>>
104224>>>                End
104224>>>>
104224>>>                Else Begin
104225>>>                    Set Label to CS_DF_File_Schema
104226>>>                    Set Prompt_Button_Mode to PB_PromptOn
104227>>>                    Set Prompt_Object to (oSchemasSelection_sl(Self))
104228>>>                    Set psToolTip to (psSchemaToolTip(Self))
104229>>>                    If (Trim(sValue) = "dbo") Begin
104231>>>                        Set Value to ""
104232>>>                    End
104232>>>>
104232>>>                End
104232>>>>
104232>>>                If (Enabled_State(Self) = False) Begin
104234>>>                    Set Value to ""
104235>>>                End
104235>>>>
104235>>>            End_Procedure
104236>>>
104236>>>        End_Object
104237>>>
104237>>>        Object oDatabase_fm is a cSQLForm
104239>>>            Set Size to 13 114
104240>>>            Set Location to 178 82
104241>>>            Set Label to "Database"
104242>>>            Set peAnchors to anTopLeftRight
104243>>>            Set psToolTip to "Name of the SQL database. Note: If you are setting up your first connection for a workspace and your SQL database doesn't exist yet, leave the default 'Master' as it is always available. The 'SqlDatabaseCreate' function will take care of the rest when creating your new SQL database."
104244>>>            Set piItem to 6
104245>>>            Set Prompt_Button_Mode to PB_PromptOn
104246>>>
104246>>>            Procedure Prompt
104249>>>                String[] sTheData
104250>>>                Handle ho
104250>>>                tSQLConnection SQLConnection
104250>>>                tSQLConnection SQLConnection
104250>>>
104250>>>                Set Label of oShowInfo_tb to CS_LoadingDatabases
104251>>>                Get ReadCurrentSQLSettings to SQLConnection
104252>>>
104252>>>                Get SqlUtilEnumerateDatabases of ghoDbUpdateFunctionLibrary SQLConnection.sDriverID to sTheData
104253>>>
104253>>>                Get Prompt_Object to ho
104254>>>                Set psTheData     of ho to sTheData
104255>>>                Set Label of oShowInfo_tb to ""
104256>>>
104256>>>                Forward Send Prompt
104258>>>            End_Procedure
104259>>>
104259>>>            Procedure DbTypeUpdate Integer iDbType String sDriverID
104262>>>                Boolean bAdd
104262>>>                String sValue
104262>>>
104262>>>                If (sDriverID <> "") Begin
104264>>>                    Set Enabled_State to (sDriverID = MSSQLDRV_ID or sDriverID = SQLFLEX or sDriverID = MDSMySQL or sDriverID = MDSPgSQL or sDriverID = ORAFLEX or (sDriverID = ODBC_DRV_ID and iDbType <> EN_DbTypeOracle))
104265>>>                    If (Enabled_State(Self) = True) Begin
104267>>>                        Move (piCurrentRow(Self) = -1) to bAdd
104268>>>                        Get Value to sValue
104269>>>                        If (bAdd = True and sValue = "" and iDbType = EN_dbTypeMSSQL) Begin
104271>>>                            Set Value to "master"
104272>>>                        End
104272>>>>
104272>>>                        Else Begin
104273>>>                            Set Prompt_Button_Mode to PB_PromptOn
104274>>>                            Set Prompt_Object to (oDatabaseSelection_sl(Self))
104275>>>                            If (Value(Self) = "master") Begin
104277>>>                                Set Value to ""
104278>>>                            End
104278>>>>
104278>>>                        End
104278>>>>
104278>>>                    End
104278>>>>
104278>>>                    If (Enabled_State(Self) = False) Begin
104280>>>                        Set Value to ""
104281>>>                    End
104281>>>>
104281>>>                End
104281>>>>
104281>>>            End_Procedure
104282>>>
104282>>>        End_Object
104283>>>
104283>>>        Object oCreateDatabase_btn is a cRDCButton
104285>>>            Set Size to 13 78
104286>>>            Set Location to 178 210
104287>>>            Set Label to "Create Database..."
104288>>>            Set psImage to "ActionCreateDatabase1.ico"
104289>>>            Set pbAutoEnable to True
104290>>>            Set peAnchors to anTopRight
104291>>>        
104291>>>            Procedure OnClick                                                              
104294>>>                String sConnectionString sError sDriverID sLoginText sDatabaseName
104294>>>                
104294>>>                Get LoginString (&sError) to sConnectionString
104295>>>                If (sError <> "") Begin
104297>>>                    Send Info_Box sError
104298>>>                    Procedure_Return
104299>>>                End                         
104299>>>>
104299>>>                
104299>>>                Get Value of oDriverID_cf to sDriverID
104300>>>                Get Create_DataBase_Dialog of (Client_Id(phoMainPanel(ghoApplication))) sDriverID to sDatabaseName
104301>>>                If (sDatabaseName <> "") Begin
104303>>>                    Set Value of oDatabase_fm to sDatabaseName
104304>>>                End
104304>>>>
104304>>>            End_Procedure                
104305>>>            
104305>>>            Function IsEnabled Returns Boolean
104308>>>                Integer iDbType    
104308>>>                Boolean bReadOnly
104308>>>                Get SelectedDbType of oDbType_cf to iDbType
104309>>>                Get pbReadOnly to bReadOnly
104310>>>                Function_Return (bReadOnly = False and (iDbType = EN_DbTypeMSSQL or iDbType = EN_DbTypeDB2 or iDbType = EN_DbTypeMySQL or iDbType = EN_DbTypePostgre))
104311>>>            End_Function
104312>>>        
104312>>>        End_Object
104313>>>
104313>>>        Procedure DbTypeUpdate Integer iDbType String sDriverID
104316>>>            String sDbType
104316>>>            Get SqlUtilDbTypeToString of ghoDbUpdateFunctionLibrary iDbType to sDbType
104317>>>            Set Label to (sDbType * "Connection Details")
104318>>>        End_Procedure
104319>>>
104319>>>    End_Object
104320>>>
104320>>>    Object oOK_Btn is a cRDCButton
104322>>>        Set Label    to C_$OK
104323>>>        Set Location to 287 208 //281 208
104324>>>        Set peAnchors to anBottomRight
104325>>>
104325>>>        Procedure OnClick
104328>>>            String sLoginText
104328>>>            String[] sConnectionData
104329>>>            tSQLConnection SQLIniFileConnection
104329>>>            tSQLConnection SQLIniFileConnection
104329>>>            Boolean bNew bOK bShouldSave
104329>>>            Integer iRetval
104329>>>
104329>>>            Delegate Get Should_Save to bShouldSave
104331>>>            If (bShouldSave = False) Begin
104333>>>                Set pbChanged to False
104334>>>                Send Close_Panel
104335>>>                Procedure_Return
104336>>>            End
104336>>>>
104336>>>
104336>>>            Broadcast Recursive Send WriteConnectionData of (Parent(Self)) (&sConnectionData)
104338>>>
104338>>>            Get pbNew to bNew
104339>>>            Get MoveStringArrayToSQLConnection sConnectionData to SQLIniFileConnection
104340>>>            Case Begin
104340>>>                Case (SQLIniFileConnection.sDriverID = DB2_DRV_ID or SQLIniFileConnection.sDriverID = ODBC_DRV_ID)
104342>>>                    If (SQLIniFileConnection.sDriverID = DB2_DRV_ID) Begin
104344>>>                        Move "" to SQLIniFileConnection.sDatabase
104345>>>                    End
104345>>>>
104345>>>                    If (SQLIniFileConnection.bTrusted = True) Begin
104347>>>                        If (SQLIniFileConnection.bEnabled = True) Begin
104349>>>                        Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "") to bOK
104350>>>                        End
104350>>>>
104350>>>                        Else Begin
104351>>>                            Move (SQLIniFileConnection.sServer <> "") to bOK
104352>>>                        End
104352>>>>
104352>>>                    End
104352>>>>
104352>>>                    Else Begin
104353>>>                        // It should probably be allowed to use an UID but no password...
104353>>>                        If (SQLIniFileConnection.bEnabled = True) Begin
104355>>>                        Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sUserID <> "") to bOK
104356>>>                        End
104356>>>>
104356>>>                        Else Begin
104357>>>                            Move (SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sUserID <> "") to bOK
104358>>>                        End
104358>>>>
104358>>>                    End
104358>>>>
104358>>>                    Case Break
104359>>>                Case (SQLIniFileConnection.sDriverID = MSSQLDRV_ID or SQLIniFileConnection.sDriverID = SQLFLEX)
104362>>>                    If (SQLIniFileConnection.bTrusted = True) Begin
104364>>>                        If (SQLIniFileConnection.bEnabled = True) Begin
104366>>>                        Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sDatabase <> "") to bOK
104367>>>                        End
104367>>>>
104367>>>                        Else Begin
104368>>>                            Move (SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sDatabase <> "") to bOK
104369>>>                        End
104369>>>>
104369>>>                    End
104369>>>>
104369>>>                    Else Begin
104370>>>                        // It should probably be allowed to use an UID but no password...
104370>>>                        If (SQLIniFileConnection.bEnabled = True) Begin
104372>>>                        Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sDatabase <> "" and SQLIniFileConnection.sUserID <> "") to bOK
104373>>>                        End
104373>>>>
104373>>>                        Else Begin
104374>>>                            Move (SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sDatabase <> "" and SQLIniFileConnection.sUserID <> "") to bOK
104375>>>                        End
104375>>>>
104375>>>                    End
104375>>>>
104375>>>                    Case Break
104376>>>                Case (SQLIniFileConnection.sDriverID = ORAFLEX or SQLIniFileConnection.sDriverID = MDSPgSQL)
104379>>>                    // It should probably be allowed to use an UID but no password...
104379>>>                    If (SQLIniFileConnection.bEnabled = True) Begin
104381>>>                    Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sUserID <> "") to bOK
104382>>>                    End
104382>>>>
104382>>>                    Else Begin
104383>>>                        Move (SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sUserID <> "") to bOK
104384>>>                    End
104384>>>>
104384>>>                    Case Break
104385>>>                Case (SQLIniFileConnection.sDriverID = MDSPgSQL)
104388>>>                    // It should probably be allowed to use an UID but no password...
104388>>>                    If (SQLIniFileConnection.bEnabled = True) Begin
104390>>>                    Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sUserID <> "") to bOK
104391>>>                    End
104391>>>>
104391>>>                    Else Begin
104392>>>                        Move (SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sUserID <> "") to bOK
104393>>>                    End
104393>>>>
104393>>>                    Case Break
104394>>>                Case (SQLIniFileConnection.sDriverID = MDSMySQL)
104397>>>                    // It should probably be allowed to use an UID but no password...
104397>>>                    If (SQLIniFileConnection.bEnabled = True) Begin
104399>>>                    Move (SQLIniFileConnection.sConnectionID <> "" and SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sUserID <> "") to bOK
104400>>>                    End
104400>>>>
104400>>>                    Else Begin
104401>>>                        Move (SQLIniFileConnection.sServer <> "" and SQLIniFileConnection.sUserID <> "") to bOK
104402>>>                    End
104402>>>>
104402>>>                    Case Break
104403>>>            Case End
104403>>>
104403>>>            If (bOK = False) Begin
104405>>>                Send Info_Box "Please fill in all connection data."
104406>>>                Procedure_Return
104407>>>            End
104407>>>>
104407>>>
104407>>>            Move MBR_Yes to iRetval
104408>>>            Get Label of oLoginInfo_tb to sLoginText
104409>>>            If (sLoginText = CS_LoginFailed) Begin
104411>>>                Get YesNo_Box "The login failed. Are you sure you want to use these connection settings?" to iRetval
104412>>>            End
104412>>>>
104412>>>            Else If (sLoginText = "") Begin
104415>>>                Get YesNo_Box "The login has not been tested. Are you sure you want to use these connection settings?" to iRetval
104416>>>            End
104416>>>>
104416>>>            If (iRetval <> MBR_Yes) Begin
104418>>>                Procedure_Return
104419>>>            End
104419>>>>
104419>>>
104419>>>            Set pSQLConnectionData to SQLIniFileConnection
104420>>>            Set pbChanged to True
104421>>>            Send Close_Panel
104422>>>        End_Procedure
104423>>>
104423>>>    End_Object
104424>>>
104424>>>    Object oCancel_Btn is a cRDCButton
104426>>>        Set Label    to C_$Cancel
104427>>>        Set Location to 287 264 //281 264
104428>>>        Set peAnchors to anBottomRight
104429>>>
104429>>>        Procedure OnClick
104432>>>            Set pbChanged to False
104433>>>            Send Close_Panel
104434>>>        End_Procedure
104435>>>
104435>>>    End_Object
104436>>>
104436>>>    Object oHelp_Btn is a cRDCButton
104438>>>        Set Label to C_$Help
104439>>>        Set Location to 287 11 //281 11
104440>>>        Set peAnchors to anBottomLeft
104441>>>        Set psImage to "ActionHelp1.ico"
104442>>>
104442>>>        Procedure OnClick
104445>>>            Send DoDisplayKeyword of ghoHtmlHelp "SQLConnections Tool"
104446>>>        End_Procedure
104447>>>    End_Object
104448>>>
104448>>>    Object oConnectionType_grp is a cRDCHeaderGroup
104450>>>        Set Size to 60 303
104451>>>        Set Location to 8 11 //2 11
104452>>>        Set psImage to "SQLSettings1.ico"
104453>>>        Set psLabel to "Database Type Settings"
104454>>>
104454>>>        Object oDbType_cf is a cSQLComboForm
104456>>>            Set Size to 13 115
104457>>>            Set Location to 22 82
104458>>>            Set Label to "Database Type"
104459>>>            Set Entry_State to False
104460>>>            Set Combo_Sort_State to False
104461>>>            Set psToolTip to "Select a database type, then select a driver to use for the database"
104462>>>            Set piItem to 3
104463>>>            
104463>>>            Procedure Combo_Fill_List
104466>>>                Send Combo_Add_Item CS_dbTypeMSSQL
104467>>>                Send Combo_Add_Item CS_dbTypeMySQL
104468>>>                Send Combo_Add_Item CS_dbTypeOracle
104469>>>                Send Combo_Add_Item CS_dbTypeDB2
104470>>>                Send Combo_Add_Item CS_dbTypePostgre
104471>>>            End_Procedure
104472>>>
104472>>>            Procedure OnChange
104475>>>                Integer iDbType
104475>>>                String sDriverID
104475>>>    
104475>>>                Get SelectedDbType to iDbType
104476>>>                Send Refill_Comboform of oDriverID_cf iDbType
104477>>>                Get Value of oDriverID_cf to sDriverID
104478>>>                If (sDriverID = "") Begin
104480>>>                    Move MSSQLDRV_ID to sDriverID
104481>>>                End
104481>>>>
104481>>>                Send DbTypeUpdate of oSettings_grp iDbType sDriverID
104482>>>            End_Procedure
104483>>>    
104483>>>            Function SelectedDbType Returns Integer
104486>>>                Integer iRetval
104486>>>                String sDbType
104486>>>    
104486>>>                Get Value to sDbType
104487>>>                Get SqlUtilDbTypeToInteger of ghoDbUpdateFunctionLibrary sDbType to iRetval
104488>>>    
104488>>>                Function_Return iRetval
104489>>>            End_Function
104490>>>
104490>>>        End_Object
104491>>>
104491>>>        Object oStartSQLManager_btn is a cRDCButton
104493>>>            Set Size to 13 78
104494>>>            Set Location to 22 210
104495>>>            Set Label to "SQL Manager"
104496>>>            Set pbAutoEnable to True  
104497>>>            Set psImage to "SSMS1.ico" 
104498>>>            Set psToolTip to "Start Microsoft SQL Server Management Studio"
104499>>>            Set peAnchors to anTopRight
104500>>>        
104500>>>            Procedure OnClick
104503>>>                Runprogram Shell Background "Ssms.exe"    
104504>>>            End_Procedure  
104505>>>            
104505>>>            Function IsEnabled Returns Boolean
104508>>>                String sDbType
104508>>>                Get Value of oDbType_cf to sDbType
104509>>>                Function_Return (sDbType = CS_dbTypeMSSQL)
104510>>>            End_Function
104511>>>        
104511>>>        End_Object
104512>>>
104512>>>        Object oDriverID_cf is a cSQLComboForm
104514>>>            Set Size to 13 115
104515>>>            Set Location to 37 82
104516>>>            Set Label to "Driver ID"
104517>>>            Set Entry_State to False
104518>>>            Set Combo_Sort_State to False
104519>>>            Set psToolTip to "Depending on the database type selected and if Mertech drivers have been installed, the comboform list will vary."
104520>>>            Set piItem to 4
104521>>>
104521>>>            Procedure Refill_Comboform Integer iDbType
104524>>>                String sValue
104524>>>
104524>>>                Send Combo_Delete_Data
104525>>>                Send Combo_Add_Item MSSQLDRV_ID
104526>>>                Send Combo_Add_Item ODBC_DRV_ID
104527>>>                Send Combo_Add_Item SQLFLEX
104528>>>                Send Combo_Add_Item ODBC_DRV_ID
104529>>>                Send Combo_Add_Item MDSMySQL
104530>>>                Send Combo_Add_Item ODBC_DRV_ID
104531>>>                Send Combo_Add_Item ORAFLEX
104532>>>                Send Combo_Add_Item DB2_DRV_ID
104533>>>                Send Combo_Add_Item ODBC_DRV_ID
104534>>>                Send Combo_Add_Item MDSPgSQL
104535>>>                Send Combo_Add_Item DATAFLEX_ID
104536>>>
104536>>>                Case Begin
104536>>>                    Case (iDbType = EN_dbTypeMSSQL)
104538>>>                        Move MSSQLDRV_ID to sValue
104539>>>                        Case Break
104540>>>                    Case (iDbType = EN_dbTypeMySQL)
104543>>>                        Move ODBC_DRV_ID to sValue
104544>>>                        Case Break
104545>>>                    Case (iDbType = EN_dbTypeOracle)
104548>>>                        Move ODBC_DRV_ID to sValue
104549>>>                        Case Break
104550>>>                    Case (iDbType = EN_dbTypeDB2)
104553>>>                        Move DB2_DRV_ID to sValue
104554>>>                        Case Break
104555>>>                    Case (iDbType = EN_dbTypePostgre)
104558>>>                        Move ODBC_DRV_ID to sValue
104559>>>                        Case Break
104560>>>                    Case Else
104560>>>                        Move DATAFLEX_ID to sValue
104561>>>                Case End
104561>>>                Set Value to sValue
104562>>>            End_Procedure
104563>>>
104563>>>            Procedure OnChange
104566>>>                String sDriverID
104566>>>                Integer iDbType
104566>>>
104566>>>                Get Value to sDriverID
104567>>>                If (sDriverID = "") Begin
104569>>>//                    Move MSSQLDRV_ID to sDriverID 
104569>>>                    Procedure_Return
104570>>>                End
104570>>>>
104570>>>                Get SelectedDbType of oDbType_cf to iDbType
104571>>>                Broadcast Recursive Send DbTypeUpdate of oSettings_grp iDbType sDriverID
104573>>>            End_Procedure
104574>>>
104574>>>        End_Object
104575>>>
104575>>>        Object oShowDriverSettings_btn is a cRDCButton
104577>>>            Set Size to 13 78
104578>>>            Set Location to 37 210
104579>>>            Set Label to "Driver Settings"
104580>>>            Set Status_Help to "Shows settings for the selected driver."
104581>>>            Set psImage to "DriverSettings1.ico"
104582>>>            Set peAnchors to anTopRight
104583>>>
104583>>>            Procedure OnClick
104586>>>                String sDriver sPath 
104586>>>                
104586>>>                Get Value of oDriverID_cf to sDriver
104587>>>                Send PopupDriverSettings sDriver 
104588>>>            End_Procedure
104589>>>    
104589>>>        End_Object
104590>>>
104590>>>    End_Object
104591>>>
104591>>>    Function ReadCurrentSQLSettings Returns tSQLConnection
104594>>>        tSQLConnection SQLConnection
104594>>>        tSQLConnection SQLConnection
104594>>>
104594>>>        Get Value of oDriverID_cf        to SQLConnection.sDriverID
104595>>>        Get SelectedDbType of oDbType_cf to SQLConnection.iDbType
104596>>>
104596>>>        Get Checked_State of oTrusted_cb to SQLConnection.bTrusted
104597>>>        Get Value of oDriverID_cf        to SQLConnection.sDriverID
104598>>>        Get Value of oServer_fm          to SQLConnection.sServer
104599>>>        Get Value of oUserID_fm          to SQLConnection.sUserID
104600>>>        Get Value of oPassword_fm        to SQLConnection.sPassword     
104601>>>        Move False to Err
104602>>>        Get ConstructConnectionString of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) ;            SQLConnection.sDriverID SQLConnection.sServer "" SQLConnection.bTrusted SQLConnection.sUserID SQLConnection.sPassword to SQLConnection.sConnectionString
104603>>>        Set pSQLConnection of ghoSQLConnectionHandler to SQLConnection
104604>>>        Move Err to SQLConnection.bError
104605>>>        
104605>>>        Function_Return SQLConnection
104606>>>    End_Function
104607>>>
104607>>>    Function LoginString String ByRef sError Returns String
104610>>>        String sDriverID sServer sDatabase
104610>>>        tSQLConnection SQLConnection
104610>>>        tSQLConnection SQLConnection
104610>>>        
104610>>>        Get Value of oDriverID_cf to sDriverID
104611>>>        If (sDriverID = "") Begin
104613>>>            Move "Please select a driver first, then try again." to sError
104614>>>            Function_Return ""
104615>>>        End
104615>>>>
104615>>>
104615>>>        Get Value of oServer_fm   to sServer
104616>>>        If (sServer = "") Begin
104618>>>            Move "Please select a server first, then try again." to sError
104619>>>            Function_Return ""
104620>>>        End
104620>>>>
104620>>>
104620>>>        Get Value of oDatabase_fm to sDatabase
104621>>>        If (sDatabase = "" and sDriverID = MSSQLDRV_ID) Begin
104623>>>            Move "master" to sDatabase
104624>>>        End
104624>>>>
104624>>>
104624>>>        Get ReadCurrentSQLSettings to SQLConnection
104625>>>        If (SQLConnection.bError = True) Begin
104627>>>            Move "Login Error" to sError
104628>>>        End
104628>>>>
104628>>>
104628>>>        Function_Return SQLConnection.sConnectionString
104629>>>    End_Function
104630>>>
104630>>>    // Returns True if anything has changed.
104630>>>    Function Should_Save Returns Boolean
104633>>>        String[] sConnectionData sConnectionData2
104635>>>        tSQLConnection SQLConnectionData
104635>>>        tSQLConnection SQLConnectionData
104635>>>        Boolean bState
104635>>>
104635>>>        Broadcast Recursive Send WriteConnectionData (&sConnectionData)
104637>>>        Get pSQLConnectionData to SQLConnectionData
104638>>>        Get MoveSQLConnectionToStringArray SQLConnectionData to sConnectionData2
104639>>>        // We don't have a form here for the sConnectionString, so we "blank it out"
104639>>>        // to be able to compare properly.
104639>>>        Move "" to sConnectionData2[7]
104640>>>
104640>>>            Move (IsSameArray(sConnectionData, sConnectionData2)) to bState
104641>>>        Function_Return (bState = False)
104642>>>    End_Function
104643>>>
104643>>>    Function IsConnectionIDDuplicate tSQLConnection SQLConnection Returns Boolean
104646>>>        Integer iCount iSize iItems iCurrentRow
104646>>>        String sValue sConnectionID
104646>>>        Boolean bExists
104646>>>        tDataSourceRow[] TheData
104646>>>        tDataSourceRow[] TheData
104647>>>        tDataSourceRow TheRow
104647>>>        tDataSourceRow TheRow
104647>>>
104647>>>        Move 0 to iItems
104648>>>        Get piCurrentRow to iCurrentRow
104649>>>        Move SQLConnection.sConnectionID to sConnectionID
104650>>>        Get MoveSQLConnectionToGridRow SQLConnection to TheRow
104651>>>        Get pTheData to TheData
104652>>>        Move (SizeOfArray(TheData)) to iSize
104653>>>        If (iCurrentRow <> -1) Begin
104655>>>            // This is the sConnectionID:
104655>>>            Move TheRow.sValue[2] to TheData[iCurrentRow].sValue[2]
104656>>>        End
104656>>>>
104656>>>        Else Begin
104657>>>            Move TheRow to TheData[iSize]
104658>>>        End
104658>>>>
104658>>>        Move (SizeOfArray(TheData)) to iSize
104659>>>        Decrement iSize
104660>>>        For iCount from 0 to iSize
104666>>>>
104666>>>            Move TheData[iCount].sValue[2] to sValue
104667>>>            Move (sValue = sConnectionID) to bExists
104668>>>            If (bExists) Begin
104670>>>                Increment iItems
104671>>>            End
104671>>>>
104671>>>        Loop
104672>>>>
104672>>>
104672>>>        Function_Return (iItems > 1)
104673>>>    End_Function
104674>>>
104674>>>    // Transfers data between a tSQLConnection struct and a grid data row.
104674>>>    Function MoveSQLConnectionToGridRow tSQLConnection SQLConnection Returns tDataSourceRow
104677>>>        tDataSourceRow TheRow
104677>>>        tDataSourceRow TheRow
104677>>>        Integer iDbType
104677>>>        String sValue
104677>>>
104677>>>        Move 0                                  to TheRow.sValue[0]
104678>>>        Move SQLConnection.bEnabled             to TheRow.sValue[1]
104679>>>        Move SQLConnection.sConnectionID        to TheRow.sValue[2]
104680>>>        Move SQLConnection.sDriverID            to TheRow.sValue[3]
104681>>>
104681>>>        // We only show three asterisks ("***") instead of the password in the grid.
104681>>>        Move (Replace(SQLConnection.sPassword, SQLConnection.sConnectionString, "***")) to sValue
104682>>>        Move sValue                             to TheRow.sValue[4]
104683>>>
104683>>>        Move SQLConnection.iDbType to iDbType
104684>>>        Get SqlUtilDbTypeToString of ghoDbUpdateFunctionLibrary iDbType to sValue
104685>>>        Move sValue                             to TheRow.sValue[5]
104686>>>        Move SQLConnection.sServer              to TheRow.sValue[6]
104687>>>        Move SQLConnection.sDatabase            to TheRow.sValue[7]
104688>>>
104688>>>        // Hidden columns (to make Should_Save function work)
104688>>>        Move SQLConnection.sConnectionString    to TheRow.sValue[8] // "Untouched" connection string.
104689>>>        Move SQLConnection.bTrusted             to TheRow.sValue[9]
104690>>>        Move SQLConnection.sUserID              to TheRow.sValue[10]
104691>>>        Move SQLConnection.sPassword            to TheRow.sValue[11]
104692>>>        Move SQLConnection.sSchema              to TheRow.sValue[12]
104693>>>        Move SQLConnection.sBaseTableSpace      to TheRow.sValue[13]
104694>>>        Move SQLConnection.sLongTableSpace      to TheRow.sValue[14]
104695>>>        Move SQLConnection.sIndexTableSpace     to TheRow.sValue[15]
104696>>>        Move SQLConnection.bSilentLogin         to TheRow.sValue[16]
104697>>>//        Move SQLConnection.bDisabled            to TheRow.sValue[17]
104697>>>//        Move SQLConnection.iDriverIndex         to TheRow.sValue[18]
104697>>>
104697>>>        Function_Return TheRow
104698>>>    End_Function
104699>>>
104699>>>    Function MoveSQLConnectionToStringArray tSQLConnection SQLConnection Returns String[]
104702>>>        String[] sConnectionData
104703>>>        Integer iRetval
104703>>>
104703>>>        Move SQLConnection.bEnabled          to sConnectionData[1]
104704>>>        Move SQLConnection.sConnectionID     to sConnectionData[2]
104705>>>        Get SqlUtilDbTypeToString of ghoDbUpdateFunctionLibrary SQLConnection.iDbType to sConnectionData[3]
104706>>>        Move SQLConnection.sDriverID         to sConnectionData[4]
104707>>>        Move SQLConnection.sServer           to sConnectionData[5]
104708>>>        Move SQLConnection.sDatabase         to sConnectionData[6]
104709>>>        Move SQLConnection.sConnectionString to sConnectionData[7]
104710>>>        Move SQLConnection.bTrusted          to sConnectionData[8]
104711>>>        Move SQLConnection.sUserID           to sConnectionData[9]
104712>>>
104712>>>        If (SQLConnection.sPassword <> "") Begin
104714>>>            Move MBR_Yes to iRetval
104715>>>            If (pbDFConnId(Self) = True) Begin
104717>>>                Get YesNo_Box "You are working with a DAW 'DFConnId.ini' file. Although this program can both read/write to such a file, the password encryption/decryption algorithms are (obviously) different. Thus the password will not be touched. Continue?" to iRetval
104718>>>                If (iRetval = MBR_Yes) Begin
104720>>>                    Set psUncryptedPw to SQLConnection.sPassword
104721>>>                    Move "" to SQLConnection.sPassword 
104722>>>//                    Set Enabled_State of oCheckLogin_btn to False
104722>>>                End
104722>>>>
104722>>>                Else Begin
104723>>>                    Send Stop_UI
104724>>>                End
104724>>>>
104724>>>            End
104724>>>>
104724>>>            Else Begin
104725>>>                Move SQLConnection.sPassword to sConnectionData[10]
104726>>>            End
104726>>>>
104726>>>        End
104726>>>>
104726>>>
104726>>>        Move SQLConnection.sSchema           to sConnectionData[11]
104727>>>        Move SQLConnection.sBaseTableSpace   to sConnectionData[12]
104728>>>        Move SQLConnection.sLongTableSpace   to sConnectionData[13]
104729>>>        Move SQLConnection.sIndexTableSpace  to sConnectionData[14]
104730>>>        Move SQLConnection.bSilentLogin      to sConnectionData[15]
104731>>>
104731>>>        Function_Return sConnectionData
104732>>>    End_Function
104733>>>
104733>>>    Function MoveStringArrayToSQLConnection String[] sConnectionData Returns tSQLConnection
104736>>>        tSQLConnection SQLConnection
104736>>>        tSQLConnection SQLConnection
104736>>>
104736>>>        Move sConnectionData[1]  to SQLConnection.bEnabled
104737>>>        Move sConnectionData[2]  to SQLConnection.sConnectionID
104738>>>        Get SqlUtilDbTypeToInteger of ghoDbUpdateFunctionLibrary sConnectionData[3] to SQLConnection.iDbType
104739>>>        Move sConnectionData[4]  to SQLConnection.sDriverID
104740>>>        Move sConnectionData[5]  to SQLConnection.sServer
104741>>>        Move sConnectionData[6]  to SQLConnection.sDatabase
104742>>>
104742>>>        Move sConnectionData[8]  to SQLConnection.bTrusted
104743>>>        Move sConnectionData[9]  to SQLConnection.sUserID
104744>>>
104744>>>        If (sConnectionData[10] <> "" and pbDFConnId(Self) = False) Begin
104746>>>            Move sConnectionData[10] to SQLConnection.sPassword
104747>>>        End
104747>>>>
104747>>>        // In case of we're dealing with a DfConnID.ini file (DF 19+) we don't want to change the password
104747>>>        // as DAW's 'Managed Connections' program has a different password encryption/decryption algorithm.
104747>>>        If (pbDFConnId(Self) = True) Begin
104749>>>            Get psUncryptedPw to SQLConnection.sPassword
104750>>>        End
104750>>>>
104750>>>
104750>>>        Move sConnectionData[11] to SQLConnection.sSchema
104751>>>        Move sConnectionData[12] to SQLConnection.sBaseTableSpace
104752>>>        Move sConnectionData[13] to SQLConnection.sLongTableSpace
104753>>>        Move sConnectionData[14] to SQLConnection.sIndexTableSpace
104754>>>        Move sConnectionData[15] to SQLConnection.bSilentLogin
104755>>>
104755>>>        // Connection string:
104755>>>        Get ConstructConnectionString of ghoSQLConnectionHandler SQLConnection.sDriverID SQLConnection.sServer SQLConnection.sDatabase ;                                                                 SQLConnection.bTrusted  SQLConnection.sUserID SQLConnection.sPassword ;                                      to SQLConnection.sConnectionString
104756>>>
104756>>>        Function_Return SQLConnection
104757>>>    End_Function
104758>>>
104758>>>    Procedure Popup
104761>>>        tSQLConnection SQLIniFileConnection
104761>>>        tSQLConnection SQLIniFileConnection
104761>>>        String[] sConnectionData
104762>>>        String sDriverID
104762>>>        Integer iDbType
104762>>>        Boolean bAdd
104762>>>
104762>>>        Move (piCurrentRow(Self) = -1) to bAdd
104763>>>        Get pSQLConnectionData to SQLIniFileConnection             
104764>>>        // we need these as the oConnectionType_grp has been moved to be the last object(s) in the dialog.
104764>>>        Set Value of oDbType_cf   to SQLIniFileConnection.iDbType
104765>>>        Set Value of oDriverID_cf to ""
104766>>>        If (SQLIniFileConnection.bEnabled = False and bAdd = True) Begin
104768>>>            Move True to SQLIniFileConnection.bEnabled
104769>>>        End
104769>>>>
104769>>>        Get MoveSQLConnectionToStringArray SQLIniFileConnection to sConnectionData
104770>>>
104770>>>        Set Value of oDriverID_cf to SQLIniFileConnection.sDriverID
104771>>>        Set Value of oDbType_cf   to SQLIniFileConnection.iDbType
104772>>>        Broadcast Recursive Send ReadConnectionData sConnectionData
104774>>>
104774>>>        // We need this message to "auto-default" certain fields.
104774>>>        If (bAdd = True) Begin
104776>>>            Get SelectedDbType of oDbType_cf to iDbType
104777>>>            Get Value of oDriverID_cf to sDriverID
104778>>>            If (sDriverID = "") Begin
104780>>>                Move MSSQLDRV_ID to sDriverID
104781>>>            End
104781>>>>
104781>>>            Broadcast Recursive Send DbTypeUpdate of oSettings_grp iDbType sDriverID
104783>>>        End
104783>>>>
104783>>>
104783>>>        Set Password_State of oPassword_fm to True
104784>>>        Set Value of oLoginInfo_tb to ""
104785>>>        Set Statusbar_Id to (phoDialogCommandbar(Self))
104786>>>
104786>>>        Forward Send Popup
104788>>>    End_Procedure
104789>>>
104789>>>    Procedure Page Integer iPageObject
104792>>>        Boolean bNew bReadOnly
104792>>>        String sText
104792>>>        Handle hWnd
104792>>>
104792>>>        Send Cursor_Ready of Cursor_Control
104793>>>        Forward Send Page iPageObject
104795>>>
104795>>>        Set Icon to "SQLConnections1.ico"
104796>>>
104796>>>        Get pbNew to bNew
104797>>>        If (bNew = True) Begin
104799>>>            Move ("The" * CS_SQLIniFileName * "file doesn't exist yet for this workspace and needs to be created. Here's what you need to do:\n\n") to sText
104800>>>            Move (sText * "1. Enter a Connection ID (the same that is being used by your workspace .int files) and other data that is used to login to the database.\n") to sText
104801>>>            Move (sText * "2. Press the 'Test Login' button to ensure entered details are correct.\n") to sText
104802>>>            Move (sText * "3. Press the 'OK' button and then save your changes.\n") to sText
104803>>>            Send Info_Box sText
104804>>>        End
104804>>>>
104804>>>
104804>>>        If (ghoSkinFramework <> 0 and hWnd <> 0) Begin
104806>>>            Send ComRemoveWindow to ghoSkinFramework hWnd
104807>>>            Send ComApplyWindow  to ghoSkinFramework hWnd
104808>>>        End
104808>>>>
104808>>>
104808>>>        Get pbReadOnly to bReadOnly
104809>>>        If (bReadOnly = True) Begin
104811>>>            Broadcast Recursive Set Enabled_State    to (not(bReadOnly))
104813>>>            Set Enabled_State of oConnectionType_grp to True
104814>>>            Set Enabled_State of oSettings_grp       to True
104815>>>            Set Enabled_State of oPassword_fm        to True
104816>>>            Set Enabled_State of oViewPassword_btn   to True
104817>>>            Set Enabled_State of oCheckLogin_btn     to True
104818>>>            Set Enabled_State of oCancel_Btn         to True
104819>>>            Set Enabled_State of oHelp_Btn           to True
104820>>>            Set Enabled_State of oShowDriverSettings_btn to True
104821>>>            Set Enabled_State of oCreateDatabase_btn to False
104822>>>            Send Activate of oCancel_Btn
104823>>>        End
104823>>>>
104823>>>    End_Procedure
104824>>>
104824>>>    Function IniFileName Returns String
104827>>>        String sRetval
104827>>>        Function_Return sRetval
104828>>>    End_Function
104829>>>
104829>>>    // Put a status bar at the bottom of the panel, which makes
104829>>>    // status_help work and puts a gripper in the lower right corner.
104829>>>    Procedure End_Construct_Object
104832>>>        Integer iStyle iSize iOffset
104832>>>
104832>>>        Forward Send End_Construct_Object
104834>>>
104834>>>        Get Border_Style to iStyle
104835>>>        Move 8 to iOffset
104836>>>        If (iStyle = Border_Thick) Begin
104838>>>            Object oDialogCommandbar is a cCJCommandBarSystem
104840>>>                Object oStatusBar is a cCJStatusBar
104842>>>                    Set phoDialogCommandbar to Self
104843>>>                    Object oStatusIdle is a cCJStatusBarPane
104845>>>                        Set piId to sbpIDIdlePane
104846>>>                        Set pbStyleStretch to True
104847>>>                    End_Object
104848>>>                End_Object
104849>>>            End_Object
104850>>>
104850>>>            Get Size to iSize
104851>>>            Set Size to (Hi(iSize) + iOffset) (Low(iSize))
104852>>>        End
104852>>>>
104852>>>    End_Procedure
104853>>>
104853>>>    Procedure ShowProgramHelp
104856>>>        Send DoDisplayKeyword of ghoHtmlHelp "SQLConnections Tool"
104857>>>    End_Procedure
104858>>>
104858>>>    On_Key Key_F1         Send ShowProgramHelp
104859>>>    On_Key Key_Ctrl+Key_L Send KeyAction of oCheckLogin_btn
104860>>>    On_Key kCancel        Send KeyAction of oCancel_Btn
104861>>>End_Object
104862>>>
104862>>>// General purpose access message                                                                                                           // If ini-file= "DFConnId.ini" (DAW file)
104862>>>Procedure Activate_SQLMaintainConnections_dg Boolean bNew Integer iCurrentRow tSQLConnection ByRef SQLConnectionData Boolean ByRef bChanged Boolean bDFConnId tDataSourceRow[] TheData
104865>>>    Handle ho
104865>>>    String sPath sSQLConnectionsFileName
104865>>>    Boolean bExists
104865>>>    
104865>>>    Send Cursor_Wait of Cursor_Control
104866>>>    Move (oSQLMaintainConnections_dg(Self)) to ho
104867>>>    Set pbReadOnly              of ho to False
104868>>>    Set pbNew                   of ho to bNew
104869>>>    Set piCurrentRow            of ho to iCurrentRow
104870>>>    Set pbDFConnId              of ho to bDFConnId
104871>>>    Set pSQLConnectionData      of ho to SQLConnectionData
104872>>>    Get psIniFilePath of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) to sPath
104873>>>    Get psIniFileName of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) to sSQLConnectionsFileName
104874>>>    File_Exist (sPath + sSQLConnectionsFileName) bExists
104875>>>    If (bExists = True) Begin
104877>>>     Set Label  of ho to ("Connection Properties" * "[" + String(sPath) + String(sSQLConnectionsFileName) + "]")
104878>>>    End
104878>>>>
104878>>>    
104878>>>    Set pTheData                of ho to TheData
104879>>>
104879>>>    Send Popup                  of ho
104880>>>
104880>>>    Get pSQLConnectionData      of ho to SQLConnectionData
104881>>>    Get pbChanged               of ho to bChanged
104882>>>End_Procedure
104883>>>
104883>>>// Read-only access message
104883>>>Procedure Activate_ReadOnlySQLMaintainConnections_dg tSQLConnection SQLConnectionData
104886>>>    Handle ho
104886>>>    String sPath sSQLConnectionsFileName
104886>>>
104886>>>    Send Cursor_Wait of Cursor_Control
104887>>>    Move (oSQLMaintainConnections_dg(Self)) to ho
104888>>>    Set pbReadOnly              of ho to True
104889>>>
104889>>>    Set pSQLConnectionData      of ho to SQLConnectionData
104890>>>    Get psIniFilePath of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) to sPath
104891>>>    Get psIniFileName of (phoSQLConnectionIniFile(ghoSQLConnectionHandler)) to sSQLConnectionsFileName
104892>>>    Set Label  of ho to ("Connection Properties (Read-Only)" * "[" + String(sPath) + String(sSQLConnectionsFileName) + "]")
104893>>>
104893>>>    Send Popup of ho
104894>>>End_Procedure
104895>>>
104895>        Use AddToStudio.dg     
Including file: AddToStudio.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\AddToStudio.dg)
104895>>>Use Windows.pkg
104895>>>Use Dfspnfrm.pkg
104895>>>Use cRegistry.pkg
104895>>>Use vWin32fh.pkg
104895>>>
104895>>>Enum_List
104895>>>    Define cx_RegKeyAlreadyExist
104895>>>    Define cx_RegKeyCreated
104895>>>    Define cx_RegkeyFailed
104895>>>    Define cx_RegKeyVDFKeyDoesNotExist
104895>>>    Define CX_InstalledOkVdfUnder16
104895>>>End_Enum_List
104895>>>
104895>>>// Note: The "Visual" part will automatically be removed if
104895>>>// the current DataFlex version is above 17.
104895>>>Define CS_StudioPath        for "Software\Data Access Worldwide\Visual DataFlex Tools\"
104895>>>Define CS_StudioTools       for "\Studio\Tools"
104895>>>Define CS_RegApplication    for "<application>"
104895>>>Define CS_RegWorkspace      for "<workspace>"
104895>>>Define CS_CommandLine       for "CommandLine"
104895>>>Define CS_Name              for "Name"
104895>>>Define CS_Separator         for "Separator"
104895>>>Define CS_Command           for "Command"
104895>>>
104895>>>Object oAddToStudio_dg is a ModalPanel
104897>>>    Set Size to 79 330
104898>>>    Set Label to "Add Program To DataFlex Studio's Tools Menu"
104899>>>    Set piMinSize to 79 211
104900>>>    Set Location to 5 4
104901>>>    Set Locate_Mode to Center_On_Parent
104902>>>
104902>>>    Property String psTag CS_RegApplication
104904>>>
104904>>>    Object oStudioIntegration_grp is a Group
104906>>>        Set Size to 45 299
104907>>>        Set Location to 8 15
104908>>>        Set Label to "DataFlex Studio Integration"
104909>>>
104909>>>        Object oStudioMajorVersion_sf is a SpinForm
104911>>>            Set Size to 12 27
104912>>>            Set Location to 18 168
104913>>>            Set Maximum_Position to 30
104914>>>            Set Minimum_Position to 14
104915>>>            Set Label_Col_Offset to 2
104916>>>            Set Label_Justification_Mode to JMode_Right
104917>>>            Set Label to "Add to Studio's Tools Menu:     Major Version"
104918>>>            Set Status_Help to "DataFlex main version - e.g. '18'"
104919>>>            Set Value to FMAC_VERSION
104920>>>            Set peAnchors to anNone
104921>>>        End_Object
104922>>>
104922>>>        Object oStudioMinorVersion_sf is a SpinForm
104924>>>            Set Size to 12 27
104925>>>            Set Location to 18 254
104926>>>            Set Label_Col_Offset to 2
104927>>>            Set Label to "Minor Version"
104928>>>            Set Status_Help to "DataFlex minor version - e.g. '0'"
104929>>>            Set Maximum_Position to 9
104930>>>            Set Minimum_Position to 0
104931>>>            Set Value to FMAC_REVISION
104932>>>            Set Label_Justification_Mode to JMode_Right
104933>>>            Set peAnchors to anNone
104934>>>        End_Object
104935>>>
104935>>>    End_Object
104936>>>
104936>>>    Object oOK_btn is a Button
104938>>>        Set Location to 59 207
104939>>>        Set Label to "Add Now"
104940>>>        Set Status_Help to "Add to DataFlex Studio's Tools menu. The Studio version can be selected with the two spinforms. The program gets added to the Studios Tools menu."
104941>>>        Set peAnchors to anTopRight
104942>>>
104942>>>        Procedure OnClick
104945>>>            Integer iRetval iMajorVersion iMinorVersion
104945>>>            String sText sStudioVersion
104945>>>            Get Value of oStudioMajorVersion_sf to iMajorVersion
104946>>>            Get Value of oStudioMinorVersion_sf to iMinorVersion
104947>>>            Move (String(iMajorVersion) + "." + String(iMinorVersion)) to sStudioVersion
104948>>>            Get AddProgramToStudioToolsMenu sStudioVersion to iRetval
104949>>>            Case Begin
104949>>>                Case (iRetval = cx_RegKeyAlreadyExist)
104951>>>                    Move ("The program already exists in the" * sStudioVersion * "DataFlex Studios Tools menu.") to sText
104952>>>                    Break
104953>>>                Case (iRetval = cx_RegKeyCreated)
104956>>>                    Move ("Success. The tool was added to the" * sStudioVersion *  "DataFlex Studios Tools menu.") to sText
104957>>>                    Break
104958>>>                Case (iRetval = cx_RegkeyFailed)
104961>>>                    Move "Failed. Could not create the registry key for adding the program to the DataFlex Studio's Tools menu." to sText
104962>>>                    Break
104963>>>                Case (iRetval = cx_RegKeyVDFKeyDoesNotExist)
104966>>>                    Move ("Could not find the Studio registry key. Is DataFlex Studio version" * sStudioVersion * "really installed on this machine?") to sText
104967>>>                    Break
104968>>>                Case (iRetval = CX_InstalledOkVdfUnder16)
104971>>>                    Move ("The program was added to the" * sStudioVersion * "Studios Tools menu successfully, but because you installed for an earlier version of the Studio than 16.0 you need to compile the program under that same VDF version, else the Studio can't start the program properly. (Sorry, just a 'feature' of earlier versions of the Studio)") to sText
104972>>>                    Break
104973>>>            Case End
104973>>>
104973>>>            Send Info_Box sText
104974>>>        End_Procedure
104975>>>    End_Object
104976>>>
104976>>>    Object oCancel_Btn is a Button
104978>>>        Set Label to C_$Close
104979>>>        Set Location to 59 264
104980>>>        Set peAnchors to anBottomRight
104981>>>
104981>>>        Procedure OnClick
104984>>>            Send Close_Panel
104985>>>        End_Procedure
104986>>>
104986>>>    End_Object
104987>>>
104987>>>    Function AddProgramToStudioToolsMenu String sStudioVersion Returns Integer
104990>>>        Boolean bOk bExists bOpen
104990>>>        String sKey sValue sProgramPath sProgram sProduct sStudioPath
104990>>>        Handle hoReg hoArray
104990>>>        Integer i iItems iCreated iRetval
104990>>>
104990>>>        Move False to bOk
104991>>>        Move (CS_StudioPath + (Trim(sStudioVersion)))  to sStudioPath
104992>>>        If (sStudioVersion > "17.1") Begin
104994>>>            Move (Replace("Visual ", sStudioPath, "")) to sStudioPath
104995>>>        End
104995>>>>
104995>>>
104995>>>        Get psProgramPath of (phoWorkspace(ghoApplication)) to sProgramPath
104996>>>        Get PathAtIndex of (phoWorkspace(ghoApplication)) sProgramPath 1 to sProgramPath
104997>>>        Get vFolderFormat sProgramPath to sProgramPath
104998>>>        Get psProduct     of (phoWorkspace(ghoApplication)) to sProduct
104999>>>        Get Module_Name to sProgram
105000>>>        Get Create (RefClass(cRegistry)) to hoReg
105001>>>        Set phRootKey of hoReg to HKEY_CURRENT_USER
105002>>>
105002>>>        // First check if the VDF version is installed
105002>>>        Get KeyExists of hoReg sStudioPath to bExists
105003>>>        If (bExists = False) Begin
105005>>>            Send Destroy of hoReg
105006>>>            Function_Return cx_RegKeyVDFKeyDoesNotExist
105007>>>        End
105007>>>>
105007>>>
105007>>>        // Then check if any tools have been installed in the Tools Menu.
105007>>>        // If no tools created yet, create the Tools registry key.
105007>>>        Move (sStudioPath + CS_StudioTools) to sStudioPath
105008>>>        Get KeyExists of hoReg sStudioPath to bExists
105009>>>        If (bExists = False) Begin
105011>>>            Set pfAccessRights of hoReg to KEY_ALL_ACCESS
105012>>>            Get CreateKey of hoReg sStudioPath to iCreated
105013>>>            If (iCreated <> 0) Begin
105015>>>                Move cx_RegkeyFailed to iRetval
105016>>>            End
105016>>>>
105016>>>            Else Begin
105017>>>                Move True to bExists
105018>>>            End
105018>>>>
105018>>>        End
105018>>>>
105018>>>
105018>>>        If (bExists = True) Begin
105020>>>            Get OpenKey of hoReg sStudioPath to bOk
105021>>>            If (bOk = True) Begin
105023>>>                Get Create (RefClass(Array)) to hoArray
105024>>>                Get GetSubkeys of hoReg hoArray to iItems
105025>>>                Decrement iItems
105026>>>                Move False to bExists
105027>>>                Set pfAccessRights of hoReg to KEY_READ
105028>>>                // Check if the key already exists:
105028>>>                For i from 0 to iItems
105034>>>>
105034>>>                    Get Value of hoArray i to sKey
105035>>>                    Move (sStudioPath + "\" + sKey) to sKey
105036>>>                    Get OpenKey of hoReg sKey to bOpen
105037>>>                    If (bOpen = True) Begin
105039>>>                        Get ReadString of hoReg CS_Name to sValue
105040>>>                        If (sValue = sProduct) Begin
105042>>>                            Move True to bExists
105043>>>                        End
105043>>>>
105043>>>                    End
105043>>>>
105043>>>                Loop
105044>>>>
105044>>>                Send Destroy of hoArray
105045>>>                If (bExists = False) Begin
105047>>>                    Set pfAccessRights of hoReg to KEY_ALL_ACCESS
105048>>>                    // We need to create the next key number:
105048>>>                    // The studio expect tools menu items to be numbered 1,2,3...n
105048>>>                    Increment iItems
105049>>>                    Increment iItems
105050>>>                    Get CreateKey of hoReg (sStudioPath + "\" + String(iItems)) to iCreated
105051>>>                    If (iCreated = 0) Begin
105053>>>                        Send WriteString of hoReg CS_Name sProduct
105054>>>                        // From DataFlex 16 and up the params for the Studio's Tools menu changed slightly:
105054>>>                        If (sStudioVersion >= "16.0") Begin
105056>>>                            Send WriteString of hoReg CS_Command (sProgramPath + sProgram)
105057>>>                            Send WriteString of hoReg CS_CommandLine (psTag(Self))
105058>>>                        End
105058>>>>
105058>>>                        Else Begin
105059>>>                            Send WriteString of hoReg CS_CommandLine ('"' + sProgramPath + sProgram + ".exe" + '"' * psTag(Self))
105060>>>                            Move CX_InstalledOkVdfUnder16 to iRetval
105061>>>                        End
105061>>>>
105061>>>                        Send WriteDword  of hoReg CS_Separator 1
105062>>>                        Move cx_RegKeyCreated to iRetval
105063>>>                    End
105063>>>>
105063>>>                    Else Begin
105064>>>                        Move cx_RegkeyFailed to iRetval
105065>>>                    End
105065>>>>
105065>>>                End
105065>>>>
105065>>>                Else Begin
105066>>>                    Move cx_RegKeyAlreadyExist to iRetval
105067>>>                End
105067>>>>
105067>>>                Send CloseKey of hoReg
105068>>>            End
105068>>>>
105068>>>        End
105068>>>>
105068>>>
105068>>>        Send Destroy of hoReg
105069>>>        Function_Return iRetval
105070>>>    End_Function
105071>>>
105071>>>    Procedure Page Integer iPageObject
105074>>>        Forward Send Page iPageObject
105076>>>        Set Icon to "ActionAddStudio1.ico"
105077>>>    End_Procedure
105078>>>
105078>>>    On_Key Key_Alt+Key_O Send KeyAction of oOK_Btn
105079>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancel_Btn
105080>>>    On_Key kCancel       Send KeyAction of oCancel_Btn
105081>>>End_Object
105082>        Use ViewSourceCode.dg
Including file: ViewSourceCode.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\ViewSourceCode.dg)
105082>>>Use Windows.pkg
105082>>>Use cRDCButtonDPI.pkg
105082>>>Use cRichEdit.pkg
105082>>>Use seq_chnl.pkg
105082>>>Use vWin32fh.pkg
105082>>>
105082>>>Object oSourceCodeDialog_dg is a ModalPanel
105084>>>    Set Size to 214 395
105085>>>    Set Label to "View Source Code Dialog"
105086>>>    Set piMinSize to 89 211
105087>>>    Set Location to 2 2
105088>>>    Set Border_Style To Border_Thick
105089>>>    Set Locate_Mode to Center_On_Parent
105090>>>
105090>>>    Property String psSourceCode ""
105092>>>    Property Integer piIndent
105094>>>
105094>>>    Object oSourceCode_edt is a cRichEdit
105096>>>        Set Size to 169 373
105097>>>        Set Location to 16 11
105098>>>        Set TextColor to clBlack
105099>>>        Set peAnchors to anAll
105100>>>        Set Label_Row_Offset to 3
105101>>>        Set Label_TextColor to clGreenGreyLight
105102>>>        Set Label_FontItalics to True
105103>>>        Set piFontSize to 200
105104>>>        Set psTypeFace to 'Consolas'
105105>>>
105105>>>        Delegate Set piIndent to (piParagraphIndent(Self))
105107>>>
105107>>>        Procedure DoSaveDocument
105110>>>            String sSourceCode
105110>>>            Boolean bOk bOkToSave bChanged
105110>>>
105110>>>            Move False to bOkToSave
105111>>>            Get pbCanUndo to bChanged
105112>>>            If (bChanged = False) Begin
105114>>>                Procedure_Return
105115>>>            End
105115>>>>
105115>>>
105115>>>            Get psSourceCode to sSourceCode
105116>>>            Send Write sSourceCode
105117>>>            // clear undo buffer on save
105117>>>            // we want undo buffer to only apply to the new document
105117>>>            Send ClearUndoBuffer
105118>>>            Send Info_Box "Changes saved."
105119>>>        End_Procedure
105120>>>
105120>>>        Procedure LoadData
105123>>>            String sSourceCode
105123>>>            Integer iTwips iIndent
105123>>>
105123>>>            Get psSourceCode to sSourceCode
105124>>>            Set Label to sSourceCode
105125>>>            Move 1440 to iTwips
105126>>>            Get piIndent to iIndent
105127>>>            Set piParagraphIndent to (iIndent + (iTwips * 0.2))
105128>>>
105128>>>            Send Read sSourceCode
105129>>>        End_Procedure
105130>>>
105130>>>        On_Key Key_Ctrl+Key_S Send DoSaveDocument
105131>>>        On_Key kCancel Send Cancel
105132>>>    End_Object
105133>>>
105133>>>    Object oCancel_Btn is a cRDCButtonDPI
105135>>>        Set Label    to "&Close"
105136>>>        Set Location to 193 334
105137>>>        Set peAnchors to anBottomRight
105138>>>
105138>>>        Procedure OnClick
105141>>>            Send Close_Panel
105142>>>        End_Procedure
105143>>>
105143>>>    End_Object
105144>>>
105144>>>
105144>>>    Object oFirstRun_btn is a cRDCButtonDPI
105146>>>        Set Location to 193 220
105147>>>        Set Label to "View &Top"
105148>>>        Set peAnchors to anBottomRight
105149>>>
105149>>>        Procedure OnClick
105152>>>            Send Beginning_of_Data to oSourceCode_edt
105153>>>        End_Procedure
105154>>>
105154>>>    End_Object
105155>>>
105155>>>    Object oLatestRun_btn is a cRDCButtonDPI
105157>>>        Set Location to 193 277
105158>>>        Set Label to "View &Bottom"
105159>>>        Set peAnchors to anBottomRight
105160>>>
105160>>>        Procedure OnClick
105163>>>            Send End_of_Data to oSourceCode_edt
105164>>>        End_Procedure
105165>>>
105165>>>    End_Object
105166>>>
105166>>>    // Automatically load data into the grid when activating.
105166>>>    Procedure Activating
105169>>>        Handle ho
105169>>>        Move (oSourceCode_edt(Self)) to ho
105170>>>        Send LoadData    of ho
105171>>>        Send Activate    of ho
105172>>>    End_Procedure
105173>>>
105173>>>    Procedure Page Integer iPageObject
105176>>>        Forward Send Page iPageObject
105178>>>        Set Icon to "ViewSourceCode1.ico"
105179>>>    End_Procedure
105180>>>
105180>>>    // Put a status bar at the bottom of the panel to add a gripper in the lower right corner.
105180>>>    Procedure End_Construct_Object
105183>>>        Integer iStyle iSize iOffset
105183>>>
105183>>>        Forward Send End_Construct_Object
105185>>>
105185>>>        Get Border_Style to iStyle
105186>>>        Move 8 to iOffset
105187>>>        If (iStyle = Border_Thick) Begin
105189>>>            Object oDialogCommandbar is a cCJCommandBarSystem
105191>>>                Object oStatusBar is a cCJStatusBar
105193>>>                    Object oStatusIdle is a cCJStatusBarPane
105195>>>                        Set piId to sbpIDIdlePane
105196>>>                        Set pbStyleStretch to True
105197>>>                    End_Object
105198>>>                End_Object
105199>>>            End_Object
105200>>>
105200>>>            Get Size to iSize
105201>>>            Set Size to (Hi(iSize) + iOffset) (Low(iSize))
105202>>>        End
105202>>>>
105202>>>    End_Procedure
105203>>>
105203>>>    On_Key Key_Alt+Key_T  Send KeyAction of oFirstRun_btn
105204>>>    On_Key Key_Ctrl+Key_T Send KeyAction of oFirstRun_btn
105205>>>    On_Key Key_Alt+Key_B  Send KeyAction of oLatestRun_btn
105206>>>    On_Key Key_Ctrl+Key_B Send KeyAction of oLatestRun_btn
105207>>>    On_Key Key_Alt+Key_C  Send KeyAction of oCancel_Btn
105208>>>End_Object
105209>>>
105209>>>Procedure ActivateSourceCodeDialog String sSourceCode
105212>>>    Handle ho
105212>>>    Boolean bExists
105212>>>
105212>>>    Get vFilePathExists sSourceCode to bExists
105213>>>    If (bExists = False) Begin
105215>>>        Send Info_Box "The file doesn't exist."
105216>>>        Procedure_Return
105217>>>    End
105217>>>>
105217>>>    Move (oSourceCodeDialog_dg(Self)) to ho
105218>>>    Set psSourceCode of ho to sSourceCode
105219>>>    Send Popup of ho
105220>>>End_Procedure
105221>        Use TableDUFCodeGenerator.vw   
Including file: TableDUFCodeGenerator.vw    (C:\Projects\DF20\DbUpdateFramework\AppSrc\TableDUFCodeGenerator.vw)
105221>>>Use Windows.pkg
105221>>>Use DFClient.pkg
105221>>>Use Cursor.pkg
105221>>>Use Batchdd.pkg
105221>>>Use cCJGrid.pkg
105221>>>Use cCJGridColumnRowIndicator.pkg
Including file: cCJGridColumnRowIndicator.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCJGridColumnRowIndicator.pkg)
105221>>>>>Use cCJGridColumn.pkg
105221>>>>>
105221>>>>>Class cCJGridColumnRowIndicator is a cCJGridColumn
105222>>>>>    
105222>>>>>    Procedure Construct_Object
105224>>>>>        Forward Send Construct_Object
105226>>>>>        
105226>>>>>        Property Integer piImage 0
105227>>>>>        
105227>>>>>        Set psCaption to ""
105228>>>>>        Set piWidth to 20
105229>>>>>        Set pbResizable to False
105230>>>>>        Set pbEditable to False
105231>>>>>        Set pbFocusable to False
105232>>>>>        Set pbAllowDrag to False
105233>>>>>        Set psToolTip to "Row Indicator"
105234>>>>>    End_Procedure
105235>>>>>    
105235>>>>>    Procedure OnCreateColumn
105237>>>>>        Integer iImage
105237>>>>>        Delegate Get AddImage "GridColumnRowIndicator.bmp" 0 to iImage
105239>>>>>        Set piImage to iImage
105240>>>>>    End_Procedure
105241>>>>>    
105241>>>>>    Procedure OnSetDisplayMetrics Handle hoGridItemMetrics Integer iRow String ByRef sValue
105243>>>>>        Integer iImage iFocusedRow
105243>>>>>        Handle hoDataSource
105243>>>>>        
105243>>>>>        Get phoDataSource to hoDataSource
105244>>>>>        Get SelectedRow of hoDataSource to iFocusedRow
105245>>>>>        Move -1 to iImage
105246>>>>>        If (iRow = iFocusedRow) Begin
105248>>>>>            Get piImage to iImage
105249>>>>>            Set ComItemIcon of hoGridItemMetrics to iImage
105250>>>>>        End
105250>>>>>>
105250>>>>>    End_Procedure
105251>>>>>    
105251>>>>>End_Class
105252>>>Use cCJGridColumn.pkg
105252>>>Use dfLine.pkg
105252>>>Use cRDCButton.pkg
105252>>>Use cDbUpdateFunctionLibrary.pkg
105252>>>Use DUFStatusPanel.pkg
105252>>>Use seq_chnl.pkg
105252>>>Use vWin32fh.pkg
105252>>>Use cRDCHeaderGroup.pkg
105252>>>Use cRDCSuggestionIniForm.pkg
105252>>>Use cSQLCheckBox.pkg
105252>>>Use WriteTestProgram.pkg
Including file: WriteTestProgram.pkg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\WriteTestProgram.pkg)
105252>>>>>Use vWin32fh.pkg
105252>>>>>
105252>>>>>Define CS_DUFTestProgram for "DUFInternalUpdateProgram.src"
105252>>>>>
105252>>>>>Function WriteTestProgram String sSourcePackageName String sAppSrcPath Number nSourcePackageVersion Integer iDbVersionTable Integer iDbVersionField Returns Boolean
105255>>>>>    Integer iCh                                                               
105255>>>>>    
105255>>>>>    Get Seq_Open_Output_Channel sSourcePackageName to iCh
105256>>>>>    If (iCh = DF_SEQ_CHANNEL_ERROR) Begin
105258>>>>>        Send Info_Box "No free channel to write output to. Process interrupted" "Error"
105259>>>>>        Function_Return False
105260>>>>>    End  
105260>>>>>>
105260>>>>>    
105260>>>>>    Get vFolderFormat sAppSrcPath to sAppSrcPath
105261>>>>>    
105261>>>>>    Move False to Err
105262>>>>>    Direct_Output channel iCh (sAppSrcPath + CS_DUFTestProgram)
105264>>>>>        Send WriteProgramCode iCh sSourcePackageName nSourcePackageVersion iDbVersionTable iDbVersionField
105265>>>>>    Close_Output channel iCh
105267>>>>>    Send Seq_Release_Channel iCh    
105268>>>>>                                        
105268>>>>>    Function_Return (Err = False)
105269>>>>>End_Function                                   
105270>>>>>
105270>>>>>Procedure WriteProgramCode Integer iCh String sSourcePackageName Number nSourcePackageVersion Integer iDbVersionTable Integer iDbVersionField
105273>>>>>    Writeln channel iCh ("/" + "/ *** DUF Auto-Generated Program - For Internal Usage Only! ***")
105276>>>>>    Writeln channel iCh ("/" + "/ *** Use it to send to a collegue that is working on the same project, ***")
105279>>>>>    Writeln channel iCh ("/" + "/ *** to update his/her database with database changes you have made. ***")
105282>>>>>    Writeln channel iCh (SFormat("#IF (%1@ > 190)",Character(33)))
105285>>>>>    Writeln channel iCh "    CompilerLevelWarning All On"
105288>>>>>    Writeln channel iCh "#ENDIF"
105291>>>>>    Writeln channel iCh "Use cApplication.pkg"
105294>>>>>    Writeln channel iCh "Use cDbUpdateHandler.pkg"
105297>>>>>    Writeln channel iCh 
105299>>>>>    Writeln channel iCh "Object oApplication is a cApplication"
105302>>>>>    Writeln channel iCh "    Set psCompany to 'RDC Tools International'"
105305>>>>>    Writeln channel iCh "    Set psProduct to 'DUF Auto Update Program'"
105308>>>>>    Writeln channel iCh "    Set psProgram to 'Internal use/test of a DUF Update Package'"
105311>>>>>    Writeln channel iCh "    Set psVersion to '19.1'"
105314>>>>>    Writeln channel iCh "End_Object"
105317>>>>>    Writeln channel iCh 
105319>>>>>    Writeln channel iCh 'Get YesNo_Box ("This is a DUF test program written for INTERNAL usage only.\n\nUpdate your DEVELOPMENT DATABASE to version: ' (String(nSourcePackageVersion)) ' now?") to WindowIndex'
105324>>>>>    Writeln channel iCh "If (WindowIndex <> MBR_Yes) Begin"
105327>>>>>    Writeln channel iCh "    Send Exit_Application"
105330>>>>>    Writeln channel iCh "End"
105333>>>>>    Writeln channel iCh 
105335>>>>>    Writeln channel iCh "Object oDbUpdateHandler is a cDbUpdateHandler"
105338>>>>>    Writeln channel iCh "    Set piDbVersionFileNumber  to " iDbVersionTable
105342>>>>>    Writeln channel iCh "    Set piDbVersionFieldNumber to " iDbVersionField
105346>>>>>    Writeln channel iCh "    Set pbAutoCreateDbVersionTable to True"
105349>>>>>    Writeln channel iCh 
105351>>>>>    Writeln channel iCh "    Use " sSourcePackageName
105355>>>>>    Writeln channel iCh 
105357>>>>>    Writeln channel iCh "End_Object"
105360>>>>>    Writeln channel iCh 
105362>>>>>    Writeln channel ich "If (Private.pbDatabaseWasUpdated(ghoDbupdatehandler) = False) Begin"
105365>>>>>    Writeln channel ich "   Send Info_Box 'Nothing to update. (Version number has not changed)'"
105368>>>>>    Writeln channel ich "End"
105371>>>>>    Writeln channel iCh 
105373>>>>>    Writeln channel iCh "Send Exit_Application"
105376>>>>>    Writeln channel iCh ("/" + "/ *** End-Of-Program Code ***")
105379>>>>>
105379>>>>>//    Writeln channel iCh "Object oMainPanel is a BasicPanel"
105379>>>>>//    Writeln channel iCh "    Set Location to 59 173"
105379>>>>>//    Writeln channel iCh "    Set Size to 180 394"
105379>>>>>//    Writeln channel iCh "    Set piMinSize to 180 394"
105379>>>>>//    Writeln channel iCh "    Set Border_Style to Border_Thick"
105379>>>>>//    Writeln channel iCh "    Set Locate_Mode to Center_On_Screen"
105379>>>>>//    Writeln channel iCh "    Set Label to (psProduct(ghoApplication))"
105379>>>>>//    Writeln channel iCh "    Set Maximize_Icon to False"
105379>>>>>//    Writeln channel iCh "    Set peNeighborhood to nhPublic"
105379>>>>>//    Writeln channel iCh "End_Object"
105379>>>>>//    Writeln channel iCh "
105379>>>>>//    Writeln channel iCh "Start_UI oMainPanel
105379>>>>>End_Procedure
105380>>>Use cRDCCommandLinkButton.pkg
Including file: cRDCCommandLinkButton.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cRDCCommandLinkButton.pkg)
105380>>>>>//****************************************************************************
105380>>>>>// $Module type: Package
105380>>>>>// $Module name: cRDCCommandLinkButton.pkg
105380>>>>>//
105380>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
105380>>>>>// Copyright (c) 2018 RDC Tools International
105380>>>>>// E-mail      : support@rdctools.com
105380>>>>>// Web-site    : http://www.rdctools.com
105380>>>>>//
105380>>>>>// Created     : 2018-11-09 @ 17:04 (Military date format - Year-Month-Day)
105380>>>>>//
105380>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
105380>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
105380>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
105380>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
105380>>>>>// in the help folder for more details.
105380>>>>>//
105380>>>>>//****************************************************************************
105380>>>>>Use Windows.pkg
105380>>>>>Use cCommandLinkButton.pkg
105380>>>>>Use Enclient.pkg
105380>>>>>Use errornum.inc
105380>>>>>
105380>>>>>Class cRDCCommandLinkButtonIdleHandler is a cIdleHandler
105381>>>>>    Procedure Construct_Object
105383>>>>>        Forward Send Construct_Object
105385>>>>>
105385>>>>>    End_Procedure
105386>>>>>
105386>>>>>    Procedure OnIdle
105388>>>>>        Delegate Send DoUpdate
105390>>>>>    End_Procedure
105391>>>>>
105391>>>>>End_Class
105392>>>>>
105392>>>>>Class cRDCCommandLinkButton is a cCommandLinkButton
105393>>>>>
105393>>>>>    Procedure Construct_Object
105395>>>>>        Forward Send Construct_Object
105397>>>>>
105397>>>>>        Property Boolean pbAutoEnable True
105398>>>>>
105398>>>>>        Property Boolean pbEnabled True
105399>>>>>
105399>>>>>        Property Handle phoIdleHandler (Create(Self, RefClass(cRDCCommandLinkButtonIdleHandler)))
105400>>>>>
105400>>>>>        Set Border_Style to Border_Normal
105401>>>>>        Set piImageSize to 32
105402>>>>>        Set pbCenterToolTip to True
105403>>>>>
105403>>>>>    End_Procedure
105404>>>>>
105404>>>>>    Procedure End_Construct_Object
105406>>>>>        String sTooltip sStatus_Help
105406>>>>>
105406>>>>>        Forward Send End_Construct_Object
105408>>>>>
105408>>>>>        Get psToolTip   to sTooltip
105409>>>>>        Get Status_Help to sStatus_Help
105410>>>>>        If (sTooltip = "" and sStatus_Help <> "") Begin
105412>>>>>            Set psToolTip to sStatus_Help
105413>>>>>        End
105413>>>>>>
105413>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to (pbAutoEnable(Self))
105414>>>>>    End_Procedure
105415>>>>>
105415>>>>>    Procedure DoUpdate
105417>>>>>        If (pbAutoEnable(Self) = False) Begin
105419>>>>>            Procedure_Return
105420>>>>>        End
105420>>>>>>
105420>>>>>        Set Enabled_State to (IsEnabled(Self))
105421>>>>>    End_Procedure
105422>>>>>
105422>>>>>    Function IsEnabled Returns Boolean
105424>>>>>        Boolean bEnabled
105424>>>>>        Get pbEnabled to bEnabled
105425>>>>>        Function_Return bEnabled
105426>>>>>    End_Function
105427>>>>>
105427>>>>>    // Enable the idle handler timer when the button is activated
105427>>>>>    Procedure Activating
105429>>>>>        Forward Send Activating
105431>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to True
105432>>>>>    End_Procedure
105433>>>>>
105433>>>>>    // Disable the idle handler when the button is deactivated
105433>>>>>    Procedure Deactivating
105435>>>>>        Set pbEnabled of (phoIdleHandler(Self)) to False
105436>>>>>        Forward Send Deactivating
105438>>>>>    End_Procedure
105439>>>>>
105439>>>>>    Procedure Set Color Integer eColor
105441>>>>>        Forward Set Color to clBtnFace
105443>>>>>    End_Procedure
105444>>>>>
105444>>>>>End_Class
105445>>>Use cRDCSlideButton.pkg                                 
Including file: cRDCSlideButton.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cRDCSlideButton.pkg)
105445>>>>>//****************************************************************************
105445>>>>>// $Module type: Package
105445>>>>>// $Module name: cRDCSlideButton.pkg
105445>>>>>//
105445>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
105445>>>>>// Copyright (c) 2018 RDC Tools International
105445>>>>>// E-mail      : support@rdctools.com
105445>>>>>// Web-site    : http://www.rdctools.com
105445>>>>>//
105445>>>>>// Created     : 2018-01-04 @ 16:47 (Military date format - Year-Month-Day)
105445>>>>>//
105445>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
105445>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
105445>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
105445>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
105445>>>>>// in the help folder for more details.
105445>>>>>//
105445>>>>>//****************************************************************************
105445>>>>>Use Windows.pkg
105445>>>>>Use cCommandLinkButton.pkg
105445>>>>>
105445>>>>>
105445>>>>>Enum_List
105445>>>>>    Define RDCSlideButtonSmallImage  for 16
105445>>>>>    Define RDCSlideButtonMediumImage for 24
105445>>>>>End_Enum_List                  
105445>>>>>
105445>>>>>// Used by the "Page" message below to show
105445>>>>>// a rectangle around ComboForm and Checkbox objects.
105445>>>>>
105445>>>>>Class cRDCSlideButtonImage is a cCommandLinkButton
105446>>>>>    Procedure Construct_Object
105448>>>>>        Forward Send Construct_Object
105450>>>>>
105450>>>>>        Property Handle private.phoParent 0
105451>>>>>
105451>>>>>    End_Procedure
105452>>>>>
105452>>>>>    Procedure Mouse_Up Integer iWindowNumber Integer iPosition
105454>>>>>        Forward Send Mouse_Up iWindowNumber iPosition
105456>>>>>        Send OnChange of (private.phoParent(Self))
105457>>>>>        Send Activate of (private.phoParent(Self))
105458>>>>>    End_Procedure
105459>>>>>
105459>>>>>    Procedure End_Construct_Object
105461>>>>>        Forward Send End_Construct_Object
105463>>>>>    End_Procedure
105464>>>>>
105464>>>>>End_Class
105465>>>>>
105465>>>>>Class cRDCSlideTextbox is a CheckBox
105466>>>>>
105466>>>>>    Procedure Construct_Object
105468>>>>>        Forward Send Construct_Object
105470>>>>>
105470>>>>>        Set Auto_Size_State to True
105471>>>>>    End_Procedure
105472>>>>>
105472>>>>>    Procedure End_Construct_Object
105474>>>>>        Forward Send End_Construct_Object
105476>>>>>    End_Procedure
105477>>>>>
105477>>>>>    Procedure OnChange
105479>>>>>        Delegate Send OnChange
105481>>>>>    End_Procedure
105482>>>>>
105482>>>>>    Procedure Page Integer iState
105484>>>>>        Integer iStyle iRet
105484>>>>>        Handle hWnd
105484>>>>>
105484>>>>>        If (iState = 1) Begin
105486>>>>>            Get Form_Style iStyle to iStyle
105487>>>>>            Set Form_Style 0 to (iStyle ior BS_USERBUTTON)
105488>>>>>            Forward Send Page iState
105490>>>>>            Get Window_Handle to hWnd
105491>>>>>            If (hWnd) Begin
105493>>>>>                Move (SendMessage(hWnd, WM_QUERYUISTATE, 0, 0)) to iRet
105494>>>>>                If (iRet iand UISF_HIDEFOCUS) Begin
105496>>>>>                    Move (UIS_CLEAR + (UISF_HIDEFOCUS * 65536)) to iState
105497>>>>>                    Move (SendMessage(hWnd, WM_UPDATEUISTATE, iState, 0)) to iRet
105498>>>>>                End
105498>>>>>>
105498>>>>>            End
105498>>>>>>
105498>>>>>        End
105498>>>>>>
105498>>>>>        Else Begin
105499>>>>>            Forward Send Page iState
105501>>>>>        End
105501>>>>>>
105501>>>>>    End_Procedure
105502>>>>>
105502>>>>>End_Class
105503>>>>>
105503>>>>>// Intermediate class - don't use.
105503>>>>>Class _cRDCSlideButton is a Container3d
105504>>>>>
105504>>>>>    Procedure Construct_Object
105506>>>>>        Forward Send Construct_Object
105508>>>>>
105508>>>>>        Property String private.psLabel
105509>>>>>        Property String private.psToolTip
105510>>>>>        Property String private.Status_Help
105511>>>>>
105511>>>>>        Set Border_Style to Border_None
105512>>>>>    End_Procedure
105513>>>>>
105513>>>>>    Procedure End_Construct_Object
105515>>>>>        Forward Send End_Construct_Object
105517>>>>>
105517>>>>>    End_Procedure
105518>>>>>
105518>>>>>    // We support both the "Set Label" & "Set psLabel" interface.
105518>>>>>    Procedure Set psLabel String sLabel
105520>>>>>        Set private.psLabel to sLabel
105521>>>>>    End_Procedure
105522>>>>>
105522>>>>>    Function psLabel Returns String
105524>>>>>        Function_Return (private.psLabel(Self))
105525>>>>>    End_Function
105526>>>>>
105526>>>>>    Procedure Set Label String sLabel
105528>>>>>        Set psLabel to sLabel
105529>>>>>    End_Procedure
105530>>>>>
105530>>>>>    Function Label Returns String
105532>>>>>        Function_Return (private.psLabel(Self))
105533>>>>>    End_Function
105534>>>>>
105534>>>>>    Procedure Set psToolTip String sToolTip
105536>>>>>        Set private.psToolTip to sToolTip
105537>>>>>    End_Procedure
105538>>>>>
105538>>>>>    Function psToolTip Returns String
105540>>>>>        Function_Return (private.psToolTip(Self))
105541>>>>>    End_Function             
105542>>>>>    
105542>>>>>    Procedure Set Status_Help String sStatusHelp
105544>>>>>        Set private.Status_Help to sStatusHelp
105545>>>>>    End_Procedure
105546>>>>>
105546>>>>>    Function Status_Help Returns String
105548>>>>>        Function_Return (private.Status_Help(Self))
105549>>>>>    End_Function             
105550>>>>>    
105550>>>>>End_Class
105551>>>>>
105551>>>>>Class cRDCSlideButton is a _cRDCSlideButton
105552>>>>>
105552>>>>>    Procedure Construct_Object
105554>>>>>        Forward Send Construct_Object
105556>>>>>
105556>>>>>        Property Handle private.phoButton 0
105557>>>>>        Property String private.psImage    
105558>>>>>        
105558>>>>>        Property Boolean private.Checked_State False
105559>>>>>        Property Boolean private.Auto_Size_State True
105560>>>>>        Property Integer private.piButtonHeight 15
105561>>>>>        Property Integer private.piButtonWidth  14
105562>>>>>        Property Integer private.piButtonLocationOffset -5
105563>>>>>        Property String psToggleOnImage  "ToggleOn.ico"
105564>>>>>        Property String psToggleOffImage "ToggleOff.ico"
105565>>>>>        Property Integer piImageSize RDCSlideButtonMediumImage
105566>>>>>
105566>>>>>        On_Key kSwitch Send Switch_Next_Area
105567>>>>>    End_Procedure
105568>>>>>
105568>>>>>    // We support two syntaxes "Checked_State" and "pbChecked"
105568>>>>>    Procedure Set Checked_State Boolean bState
105570>>>>>        Set private.Checked_State to (not(bState))
105571>>>>>        Send OnChange
105572>>>>>    End_Procedure
105573>>>>>
105573>>>>>    Procedure Set pbChecked Boolean bState
105575>>>>>        Set private.Checked_State to bState
105576>>>>>        Send OnChange
105577>>>>>    End_Procedure
105578>>>>>
105578>>>>>    Function Checked_State Returns Boolean
105580>>>>>        Function_Return (private.Checked_State(Self))
105581>>>>>    End_Function
105582>>>>>
105582>>>>>    Function pbChecked Returns Boolean
105584>>>>>        Function_Return (private.Checked_State(Self))
105585>>>>>    End_Function
105586>>>>>
105586>>>>>    // This adjustment is so that the Studio layout is the same as when the
105586>>>>>    // program has been compiled and run.
105586>>>>>    Procedure Set Location Integer iRowPos Integer iColPos
105588>>>>>        If (iColPos > 4) Begin
105590>>>>>            Move (iColPos -4) to iColPos
105591>>>>>        End
105591>>>>>>
105591>>>>>
105591>>>>>        Forward Set Location to iRowPos iColPos
105593>>>>>    End_Procedure
105594>>>>>
105594>>>>>    // This slight adjustment is needed so the control doesn't
105594>>>>>    // "bump into" an object to the right of it that is located really close.
105594>>>>>//    Procedure Set Size Integer iHeight Integer iWidth
105594>>>>>//        If (iWidth > 5) Begin
105594>>>>>//            Move (iWidth -5) to iWidth
105594>>>>>//        End
105594>>>>>//
105594>>>>>//        Forward Set Size to iHeight iWidth
105594>>>>>//    End_Procedure
105594>>>>>
105594>>>>>    Procedure OnChange
105596>>>>>        Handle hoButton
105596>>>>>        Boolean bChecked
105596>>>>>        String sImage
105596>>>>>
105596>>>>>        Get private.Checked_State to bChecked
105597>>>>>        Set private.Checked_State to (not(bChecked))
105598>>>>>        Get psCurrentImage to sImage
105599>>>>>        Get private.phoButton to hoButton
105600>>>>>        If (hoButton <> 0) Begin
105602>>>>>            Set psImage of hoButton to sImage
105603>>>>>            If (Desktop <> Self) Begin
105605>>>>>                Send OnChangeEvent
105606>>>>>            End
105606>>>>>>
105606>>>>>        End
105606>>>>>>
105606>>>>>    End_Procedure
105607>>>>>
105607>>>>>    Function psCurrentImage Returns String
105609>>>>>        Boolean bChecked
105609>>>>>        String sImage
105609>>>>>
105609>>>>>        Get private.Checked_State to bChecked
105610>>>>>        If (bChecked = True) Begin
105612>>>>>            Get psToggleOnImage to sImage
105613>>>>>        End
105613>>>>>>
105613>>>>>        Else Begin
105614>>>>>            Get psToggleOffImage to sImage
105615>>>>>        End
105615>>>>>>
105615>>>>>        Function_Return sImage
105616>>>>>    End_Function
105617>>>>>
105617>>>>>    Procedure OnClick
105619>>>>>        Send OnChange
105620>>>>>    End_Procedure
105621>>>>>
105621>>>>>    Procedure OnChangeEvent
105623>>>>>    End_Procedure
105624>>>>>
105624>>>>>    Procedure DoToggle
105626>>>>>        Boolean bChecked
105626>>>>>        Get Checked_State to bChecked
105627>>>>>        Set Checked_State to (not(bChecked))
105628>>>>>    End_Procedure
105629>>>>>
105629>>>>>    Procedure End_Construct_Object
105631>>>>>        Integer iSize iLoc iHeight iWidth iOffset iTextOffset iIconIndex iImageSize
105631>>>>>        Handle ho hoParent
105631>>>>>        String sImage sLabel
105631>>>>>
105631>>>>>        Forward Send End_Construct_Object
105633>>>>>        
105633>>>>>        Get piImageSize to iImageSize
105634>>>>>        Case Begin
105634>>>>>            Case (iImageSize = RDCSlideButtonSmallImage)
105636>>>>>                Set private.piButtonHeight         to 14
105637>>>>>                Set private.piButtonWidth          to 14 
105638>>>>>                Set private.piButtonLocationOffset to -5
105639>>>>>                Case Break
105640>>>>>            Case (iImageSize = RDCSlideButtonMediumImage)
105643>>>>>                Set private.piButtonHeight         to 16
105644>>>>>                Set private.piButtonWidth          to 20 
105645>>>>>                Set private.piButtonLocationOffset to -6
105646>>>>>                Case Break
105647>>>>>        Case End               
105647>>>>>
105647>>>>>        Move Self to hoParent
105648>>>>>        Get Label of hoParent to sLabel
105649>>>>>        Get Text_Extent sLabel to iTextOffset
105650>>>>>        Get Size     to iSize
105651>>>>>        Get Location to iLoc
105652>>>>>        Get psCurrentImage to sImage
105653>>>>>        Get private.piButtonHeight to iHeight
105654>>>>>        Get private.piButtonWidth  to iWidth
105655>>>>>        Set Size to (Hi(iSize)) (Low(iSize) + iWidth -7)
105656>>>>>        Get private.piButtonLocationOffset to iOffset
105657>>>>>        Get GetCorrectIconIndex  to iIconIndex
105658>>>>>        Move (iOffset + iIconIndex -1) to iOffset
105659>>>>>
105659>>>>>        Get CreateNamed (RefClass(cRDCSlideButtonImage)) "oRDCSlideButtonImage" to ho
105660>>>>>            Set Size                of ho to iHeight iWidth
105661>>>>>            Set Location            of ho to iOffset 0
105662>>>>>            Set psToolTip           of ho to (private.psToolTip(hoParent))
105663>>>>>            If (private.Status_Help(hoParent) = "") Begin
105665>>>>>                Set Status_Help     of ho to (private.psToolTip(hoParent))
105666>>>>>            End                                                
105666>>>>>>
105666>>>>>            Else Begin
105667>>>>>                Set Status_Help     of ho to (private.Status_Help(hoParent))
105668>>>>>            End
105668>>>>>>
105668>>>>>            Set psImage             of ho to sImage
105669>>>>>            Set pbAutoResizeIcons   of ho to True
105670>>>>>            Set piImageSize         of ho to (piImageSize(Self))
105671>>>>>            Set Focus_Mode          of ho to NonFocusable
105672>>>>>            Set private.phoParent   of ho to hoParent
105673>>>>>        Set private.phoButton to ho
105674>>>>>
105674>>>>>        Get CreateNamed (RefClass(cRDCSlideTextbox)) "cRDCSlideTextbox" to ho
105675>>>>>            Set Size                of ho to (Hi(iSize)) (Low(iSize) + iWidth)
105676>>>>>            Set Location            of ho to 2 iWidth
105677>>>>>            Set Label               of ho to sLabel
105678>>>>>            Set psToolTip           of ho to (private.psToolTip(Parent(ho)))
105679>>>>>            If (private.Status_Help(hoParent) = "") Begin
105681>>>>>                Set Status_Help     of ho to (private.psToolTip(hoParent))
105682>>>>>            End
105682>>>>>>
105682>>>>>            Else Begin
105683>>>>>                Set Status_Help     of ho to (private.Status_Help(hoParent))
105684>>>>>            End
105684>>>>>>
105684>>>>>
105684>>>>>        Get psCurrentImage to sImage
105685>>>>>        Set psImage of ho to sImage
105686>>>>>        Send OnChangeEvent
105687>>>>>    End_Procedure
105688>>>>>
105688>>>>>    // Returns: DPI setting as an integer.
105688>>>>>    //  Normal DPI setting: iDPI=96  is "Normal setting" 100%
105688>>>>>    //                      iDPI=120 is "Medium setting" 125%
105688>>>>>    //                      iDPI= 144 is "Large setting" 150%
105688>>>>>    Function GetCurrentDPI Returns Integer
105690>>>>>        Handle hDC
105690>>>>>        Integer iPixelsX
105690>>>>>        Move (GetDC(0)) to hDC
105691>>>>>        Move (GetDeviceCaps(hDC, LOGPIXELSX)) to iPixelsX
105692>>>>>        Move (ReleaseDC(0, hDC)) to hDC
105693>>>>>        Function_Return iPixelsX
105694>>>>>    End_Function
105695>>>>>
105695>>>>>    Function GetCorrectIconSize Returns Integer
105697>>>>>        Integer iPixelsX iIndex iSize
105697>>>>>        Integer[] iaSizes
105698>>>>>
105698>>>>>        Move 16 to iaSizes[0]
105699>>>>>        Move 24 to iaSizes[1]
105700>>>>>        Move 32 to iaSizes[2]
105701>>>>>        Move 48 to iaSizes[3]
105702>>>>>        Move 64 to iaSizes[4]
105703>>>>>
105703>>>>>        Get piImageSize to iSize  // the "100%" size
105704>>>>>        Move (SearchArray(iSize,iaSizes)) to iIndex
105705>>>>>        Move (0 max iIndex) to iIndex
105706>>>>>        Get GetCurrentDPI to iPixelsX
105707>>>>>        // Use a Case Statement here. Wherever we jump in we will continue onwards, regardless of whether
105707>>>>>        // we match the remaining Case statements or not. So list our Cases in reverse order, meaning we
105707>>>>>        // will increment iIndex as many times as we need here.
105707>>>>>        Case Begin
105707>>>>>            Case (iPixelsX > 144)
105709>>>>>                Increment iIndex
105710>>>>>            Case (iPixelsX = 144)
105713>>>>>                Increment iIndex
105714>>>>>            Case (iPixelsX = 120)
105717>>>>>                Increment iIndex
105718>>>>>        Case End
105718>>>>>        Move (iIndex min 4) to iIndex
105719>>>>>        Function_Return iaSizes[iIndex]
105720>>>>>    End_Function
105721>>>>>
105721>>>>>    Function GetCorrectIconIndex Returns Integer
105723>>>>>        Integer iPixelsX iIndex iSize
105723>>>>>        Integer[] iaSizes
105724>>>>>
105724>>>>>        Move 16 to iaSizes[0]
105725>>>>>        Move 24 to iaSizes[1]
105726>>>>>        Move 32 to iaSizes[2]
105727>>>>>        Move 48 to iaSizes[3]
105728>>>>>        Move 64 to iaSizes[4]
105729>>>>>
105729>>>>>        Get piImageSize to iSize  // the "100%" size
105730>>>>>        Move (SearchArray(iSize,iaSizes)) to iIndex
105731>>>>>        Move (0 max iIndex) to iIndex
105732>>>>>        Get GetCurrentDPI to iPixelsX
105733>>>>>        // Use a Case Statement here. Wherever we jump in we will continue onwards, regardless of whether
105733>>>>>        // we match the remaining Case statements or not. So list our Cases in reverse order, meaning we
105733>>>>>        // will increment iIndex as many times as we need here.
105733>>>>>        Case Begin
105733>>>>>            Case (iPixelsX > 144)
105735>>>>>                Increment iIndex
105736>>>>>            Case (iPixelsX = 144)
105739>>>>>                Increment iIndex
105740>>>>>            Case (iPixelsX = 120)
105743>>>>>                Increment iIndex
105744>>>>>        Case End
105744>>>>>        Move (iIndex min 4) to iIndex
105745>>>>>        Function_Return iIndex
105746>>>>>    End_Function
105747>>>>>
105747>>>>>End_Class
105748>>>Use cRDCCJSelectionGrid.pkg
Including file: cRDCCJSelectionGrid.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\RDCToolsLib\AppSrc\cRDCCJSelectionGrid.pkg)
105748>>>>>//****************************************************************************
105748>>>>>// $Module type: Package
105748>>>>>// $Module name: cRDCCJSelectionGrid.pkg
105748>>>>>//
105748>>>>>// $Author     : Nils Svedmyr, RDC Tools International.
105748>>>>>// Copyright (c) 2018 RDC Tools International
105748>>>>>// E-mail      : support@rdctools.com
105748>>>>>// Web-site    : http://www.rdctools.com
105748>>>>>//
105748>>>>>// Created     : 2018-12-17 @ 08:04 (Military date format - Year-Month-Day)
105748>>>>>//
105748>>>>>// Note        : Grid class that uses a checkbox column for selecting items.
105748>>>>>//
105748>>>>>// The code is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
105748>>>>>// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
105748>>>>>// This is free software; you can redistribute it and/or modify it under the terms of the
105748>>>>>// GNU Lesser General Public License - see the "GNU Lesser General Public License.txt"
105748>>>>>// in the help folder for more details.
105748>>>>>//
105748>>>>>//****************************************************************************
105748>>>>>Use cCJGrid.pkg
105748>>>>>Use cCJGridColumn.pkg
105748>>>>>Use cCJGridColumnRowIndicator.pkg
105748>>>>>Use Cursor.pkg
105748>>>>>Use vWin32fh.pkg
105748>>>>>
105748>>>>>Define CS_Settings                for "Settings"
105748>>>>>Define CS_GridRowBackgroundColor  for "GridRowBackgroundColor"
105748>>>>>
105748>>>>>Struct tsSearchResult
105748>>>>>    String sFilename
105748>>>>>    String sAlternateFileName   // 8.3 format
105748>>>>>    DateTime dtCreationDateTime
105748>>>>>    DateTime dtLastAccessDateTime
105748>>>>>    DateTime dtLastWriteDateTime
105748>>>>>    BigInt biFileSize
105748>>>>>    Integer iFileAttributes
105748>>>>>End_Struct
105748>>>>>
105748>>>>>Enum_List
105748>>>>>    Define cx_Select_All
105748>>>>>    Define cx_Select_None
105748>>>>>    Define cx_Select_Invert
105748>>>>>End_Enum_List
105748>>>>>
105748>>>>>// Classes used by the cRDCCJSelectionGrid
105748>>>>>Class cRDCCJToggleSelectMenuItem is a cCJMenuItem
105749>>>>>
105749>>>>>    Procedure Construct_Object
105751>>>>>        Forward Send Construct_Object
105753>>>>>        Set psCaption to "Toggle Current Item"
105754>>>>>        Set psImage to "ToggleOn.ico"
105755>>>>>        Set psShortcut to "Space-Bar"
105756>>>>>    End_Procedure
105757>>>>>
105757>>>>>    Procedure OnExecute Variant vCommandBarControl
105759>>>>>        Forward Send OnExecute vCommandBarControl
105761>>>>>        Send ToggleCurrentItem
105762>>>>>    End_Procedure
105763>>>>>
105763>>>>>End_Class
105764>>>>>
105764>>>>>Class cRDCCJSelectAllMenuItem is a cCJMenuItem
105765>>>>>
105765>>>>>    Procedure Construct_Object
105767>>>>>        Forward Send Construct_Object
105769>>>>>        Set pbControlBeginGroup to True
105770>>>>>        Set psCaption to "Select All"
105771>>>>>        Set psImage to "SelectAll.ico"
105772>>>>>        Set psShortcut to "Ctrl+A"
105773>>>>>    End_Procedure
105774>>>>>
105774>>>>>    Procedure OnExecute Variant vCommandBarControl
105776>>>>>        Forward Send OnExecute vCommandBarControl
105778>>>>>        Set SelectItems to cx_Select_All
105779>>>>>    End_Procedure
105780>>>>>
105780>>>>>End_Class
105781>>>>>
105781>>>>>Class cRDCCJDeSelectAllMenuItem is a cCJMenuItem
105782>>>>>
105782>>>>>    Procedure Construct_Object
105784>>>>>        Forward Send Construct_Object
105786>>>>>        Set psCaption to "Select None"
105787>>>>>        Set psImage to "SelectNone.ico"
105788>>>>>        Set psShortcut to "Ctrl+N"
105789>>>>>    End_Procedure
105790>>>>>
105790>>>>>    Procedure OnExecute Variant vCommandBarControl
105792>>>>>        Forward Send OnExecute vCommandBarControl
105794>>>>>        Set SelectItems to cx_Select_None
105795>>>>>    End_Procedure
105796>>>>>
105796>>>>>End_Class
105797>>>>>
105797>>>>>Class cRDCCJInvertSelectionsMenuItem is a cCJMenuItem
105798>>>>>
105798>>>>>    Procedure Construct_Object
105800>>>>>        Forward Send Construct_Object
105802>>>>>        Set psCaption to "Invert Selection"
105803>>>>>        Set psImage to "SelectInvert.ico"
105804>>>>>        Set psShortcut to "Ctrl+I"
105805>>>>>    End_Procedure
105806>>>>>
105806>>>>>    Procedure OnExecute Variant vCommandBarControl
105808>>>>>        Forward Send OnExecute vCommandBarControl
105810>>>>>        Set SelectItems to cx_Select_Invert
105811>>>>>    End_Procedure
105812>>>>>
105812>>>>>End_Class
105813>>>>>
105813>>>>>Class cRDCCJAddFolderMenuItem is a cCJMenuItem
105814>>>>>
105814>>>>>    Procedure Construct_Object
105816>>>>>        Forward Send Construct_Object
105818>>>>>        Set psCaption to "Add Folder"
105819>>>>>        Set psImage to "AddFolder.ico"
105820>>>>>        Set psShortcut to "Ins"
105821>>>>>    End_Procedure
105822>>>>>
105822>>>>>    Procedure OnExecute Variant vCommandBarControl
105824>>>>>        Forward Send OnExecute vCommandBarControl
105826>>>>>        Send BrowseForFolder
105827>>>>>    End_Procedure
105828>>>>>
105828>>>>>End_Class
105829>>>>>
105829>>>>>Class cRDCCJRemoveItemMenuItem is a cCJMenuItem
105830>>>>>
105830>>>>>    Procedure Construct_Object
105832>>>>>        Forward Send Construct_Object
105834>>>>>        Set psCaption to "Remove From Grid"
105835>>>>>        Set psImage to "ActionDelete.ico"
105836>>>>>        Set psShortcut to "Del"
105837>>>>>    End_Procedure
105838>>>>>
105838>>>>>    Procedure OnExecute Variant vCommandBarControl
105840>>>>>        Forward Send OnExecute vCommandBarControl
105842>>>>>        Send Request_Delete
105843>>>>>    End_Procedure
105844>>>>>
105844>>>>>End_Class
105845>>>>>
105845>>>>>Register_Function pbShowAddFolderMenuItem Returns Boolean
105845>>>>>Register_Function pbShowRemoveFolderMenuItem Returns Boolean
105845>>>>>
105845>>>>>Class cGridContext_mnu is a cCJContextMenu
105846>>>>>    Procedure Construct_Object
105848>>>>>        Handle hoMenuItem
105848>>>>>        Forward Send Construct_Object
105850>>>>>
105850>>>>>        Get Create (RefClass(cRDCCJToggleSelectMenuItem))      to hoMenuItem
105851>>>>>        Get Create (RefClass(cRDCCJSelectAllMenuItem))         to hoMenuItem
105852>>>>>        Get Create (RefClass(cRDCCJDeSelectAllMenuItem))       to hoMenuItem
105853>>>>>        Get Create (RefClass(cRDCCJInvertSelectionsMenuItem))  to hoMenuItem
105854>>>>>        If (pbShowAddFolderMenuItem(Self) = True) Begin
105856>>>>>            Get Create (RefClass(cRDCCJAddFolderMenuItem))  to hoMenuItem
105857>>>>>            Set pbControlBeginGroup of hoMenuItem to True
105858>>>>>        End
105858>>>>>>
105858>>>>>        If (pbShowRemoveFolderMenuItem(Self) = True) Begin
105860>>>>>            Get Create (RefClass(cRDCCJRemoveItemMenuItem))  to hoMenuItem
105861>>>>>            If (pbShowAddFolderMenuItem(Self) = False) Begin
105863>>>>>                Set pbControlBeginGroup of hoMenuItem to True
105864>>>>>            End
105864>>>>>>
105864>>>>>        End
105864>>>>>>
105864>>>>>    End_Procedure
105865>>>>>
105865>>>>>End_Class
105866>>>>>
105866>>>>>Class cRDCCJSelectionGrid is a cCJGrid
105867>>>>>
105867>>>>>    Procedure Construct_Object
105869>>>>>        Forward Send Construct_Object
105871>>>>>
105871>>>>>        // This must be set manually in the grid column object for the 'data' column (or one of them):
105871>>>>>        Property Handle phoData_Col 0
105872>>>>>        Property Handle phoCheckbox_Col 0
105873>>>>>
105873>>>>>        Property Boolean pbShowAddFolderMenuItem False
105874>>>>>        Property Boolean pbShowRemoveFolderMenuItem False
105875>>>>>
105875>>>>>        Set pbRestoreLayout to True
105876>>>>>        Set psLayoutSection to (Name(Self) + "_grid")
105877>>>>>        Set psNoItemsText to "No data found..."
105878>>>>>        Set pbHeaderReorders to True
105879>>>>>        Set pbHeaderPrompts to False
105880>>>>>        Set pbHeaderTogglesDirection to True
105881>>>>>        Set pbSelectionEnable to True
105882>>>>>        Set pbAllowInsertRow to False
105883>>>>>        Set pbAllowAppendRow to False
105884>>>>>        Set pbShowRowFocus to True
105885>>>>>        Set pbShowFooter to True
105886>>>>>        Set pbMultipleSelection to True
105887>>>>>        Set pbHotTracking to True
105888>>>>>        Set pbEditOnClick to True
105889>>>>>        Set piLayoutBuild to 4
105890>>>>>        Set Status_Help to "Select with the spacebar"
105891>>>>>        Set pbUseAlternateRowBackgroundColor to True
105892>>>>>        Set peAnchors to anAll
105893>>>>>        // This makes the ticked checkboxes to appear as bold.
105893>>>>>        Set peVisualTheme to xtpReportThemeVisualStudio2012Light
105894>>>>>
105894>>>>>        On_Key Key_Space      Send ToggleCurrentItem
105895>>>>>        On_Key Key_Delete     Send Request_Delete
105896>>>>>        On_Key Key_Insert     Send BrowseForFolder
105897>>>>>        On_Key Key_Ctrl+Key_A Send SelectAll
105898>>>>>        On_Key Key_Ctrl+Key_N Send SelectNone
105899>>>>>        On_Key Key_Ctrl+Key_I Send SelectInvert
105900>>>>>        On_Key kCancel        Send CancelIfPopupObject
105901>>>>>    End_Procedure
105902>>>>>
105902>>>>>    Procedure CancelIfPopupObject
105904>>>>>        Boolean bIsInPopupObject
105904>>>>>        Delegate Get Popup_State to bIsInPopupObject
105906>>>>>        If (bIsInPopupObject = True) Begin
105908>>>>>            Send Close_Panel
105909>>>>>        End
105909>>>>>>
105909>>>>>    End_Procedure
105910>>>>>
105910>>>>>    Procedure End_Construct_Object
105912>>>>>        String sColor
105912>>>>>        Handle hoContextMenu
105912>>>>>        Forward Send End_Construct_Object
105914>>>>>
105914>>>>>        Object oCheckbox_col is a cCJGridColumn
105916>>>>>            Set phoCheckbox_Col to Self
105917>>>>>            Set piWidth to 60
105918>>>>>            Set pbResizable to False
105919>>>>>            Set psCaption to "Select"
105920>>>>>            Set psToolTip to "Select an item by using the space bar or click with the mouse."
105921>>>>>            Set pbCheckbox to True
105922>>>>>            Set peHeaderAlignment to xtpAlignmentCenter
105923>>>>>            Set peFooterAlignment to xtpAlignmentCenter
105924>>>>>            Set peDataType to Mask_Numeric_Window
105925>>>>>        End_Object
105926>>>>>
105926>>>>>        Get ReadString of ghoApplication CS_Settings CS_GridRowBackgroundColor clGreenGreyLight to sColor
105927>>>>>        If (sColor = "clBlueGreyLight") Begin
105929>>>>>            Move "clGreenGrey" to sColor
105930>>>>>        End
105930>>>>>>
105930>>>>>        Set piSelectedRowBackColor to sColor
105931>>>>>        Set piHighlightBackColor   to sColor
105932>>>>>
105932>>>>>        Get Create (RefClass(cGridContext_mnu)) to hoContextMenu
105933>>>>>        Set phoContextMenu to hoContextMenu
105934>>>>>    End_Procedure   
105935>>>>>    
105935>>>>>    Procedure OnCreateGridControl 
105937>>>>>        Handle hoObject  
105937>>>>>        Integer iToolTipStyle      
105937>>>>>        Boolean bIsBalloonStyleSupported
105937>>>>>        
105937>>>>>        Forward Send OnCreateGridControl
105939>>>>>
105939>>>>>        Get phoToolTipContext to hoObject
105940>>>>>        If (hoObject <> 0) Begin
105942>>>>>            Move xtpToolTipStandard to iToolTipStyle    
105943>>>>>            // Baloon tooltip style requires IE 5.0 or later, so check if installed.
105943>>>>>            // The ComShowTitleAndDescription also requires IE 5.0.
105943>>>>>            Get ComIsBalloonStyleSupported of hoObject to bIsBalloonStyleSupported
105944>>>>>            If (bIsBalloonStyleSupported = True) Begin
105946>>>>>                Send ComShowTitleAndDescription of hoObject True xtpToolTipIconInfo
105947>>>>>            End                                                   
105947>>>>>>
105947>>>>>            Set ComStyle             of hoObject to iToolTipStyle
105948>>>>>            Set ComShowOfficeBorder  of hoObject to True
105949>>>>>            Set ComShowShadow        of hoObject to True
105950>>>>>            // Set the max width for a tooltip. 250 just seems to be a good
105950>>>>>            // compromise. After 250 pixels the text will wrap to the next line automatically.
105950>>>>>            Set ComMaxTipWidth       of hoObject to 250 // In pixels
105951>>>>>        End 
105951>>>>>>
105951>>>>>    End_Procedure
105952>>>>>
105952>>>>>    Procedure AddItem String sDataValue
105954>>>>>        Handle hoDataSource
105954>>>>>        tDataSourceRow[] TheData
105954>>>>>        tDataSourceRow[] TheData
105955>>>>>        tsSearchResult[] asFolderArray
105955>>>>>        tsSearchResult[] asFolderArray
105956>>>>>        Integer iSize iData_Col iCheckbox_Col
105956>>>>>
105956>>>>>        If (not(IsComObjectCreated(Self))) Begin
105958>>>>>            Procedure_Return
105959>>>>>        End
105959>>>>>>
105959>>>>>
105959>>>>>        Get piColumnId of (phoData_Col(Self)) to iData_Col
105960>>>>>        Get piColumnId of (phoCheckbox_Col(Self)) to iCheckbox_Col
105961>>>>>        Get phoDataSource to hoDataSource
105962>>>>>        Get DataSource of hoDataSource to TheData
105963>>>>>        Move (SizeOfArray(TheData)) to iSize
105964>>>>>        Move sDataValue to TheData[iSize].sValue[iData_Col]
105965>>>>>        Move False      to TheData[iSize].sValue[iCheckbox_Col]
105966>>>>>
105966>>>>>        Send ReInitializeData TheData False
105967>>>>>        Send MoveToFirstRow
105968>>>>>    End_Procedure
105969>>>>>
105969>>>>>    Procedure BrowseForFolder
105971>>>>>        String sFolderName
105971>>>>>        Get vSHBrowseForFolder "Select Folder to Add" to sFolderName
105972>>>>>        If (sFolderName <> "") Begin
105974>>>>>            Send AddItem sFolderName
105975>>>>>        End
105975>>>>>>
105975>>>>>    End_Procedure
105976>>>>>
105976>>>>>    // We don't want columns to be editable. But setting
105976>>>>>    // pbEditable = False or pbReadOnly makes it very hard to read,
105976>>>>>    // and makes it impossible to select the checkbox column with the mouse.
105976>>>>>    // So we disable those columns instead.
105976>>>>>    Function CanEditColumn Integer iCol Returns Boolean
105978>>>>>        Handle hoCol
105978>>>>>        Boolean bRetval
105978>>>>>
105978>>>>>        Forward Get CanEditColumn iCol to bRetval
105980>>>>>
105980>>>>>        Get piColumnId of (phoCheckbox_Col(Self)) to hoCol
105981>>>>>        If (iCol <> hoCol) Begin
105983>>>>>            Move False to bRetval
105984>>>>>        End
105984>>>>>>
105984>>>>>        Else Begin
105985>>>>>            Move True to bRetval
105986>>>>>        End
105986>>>>>>
105986>>>>>
105986>>>>>        Function_Return bRetval
105987>>>>>    End_Function
105988>>>>>
105988>>>>>    Procedure Request_Clear_All
105990>>>>>        tDataSourceRow[] EmptyData
105990>>>>>        tDataSourceRow[] EmptyData
105991>>>>>        Handle hoGrid hoDataSource
105991>>>>>
105991>>>>>        Move Self  to hoGrid
105992>>>>>        If (IsComObjectCreated(hoGrid)) Begin
105994>>>>>            Get phoDataSource of hoGrid to hoDataSource
105995>>>>>            Send InitializeData of hoGrid EmptyData
105996>>>>>            Send DoSetCheckboxFooterText
105997>>>>>        End
105997>>>>>>
105997>>>>>    End_Procedure
105998>>>>>
105998>>>>>    // Set checkboxes of the first column as selected.
105998>>>>>    // iState can be one of the following:
105998>>>>>    // cx_Select_All, cx_Select_None or cx_Select_Invert
105998>>>>>    Procedure Set SelectItems Integer iState
106000>>>>>        Integer iCount iSize iCheckbox_Col
106000>>>>>        Boolean bChecked
106000>>>>>        Handle hoDataSource
106000>>>>>        tDataSourceRow[] TheData
106000>>>>>        tDataSourceRow[] TheData
106001>>>>>
106001>>>>>        Get piColumnId of (phoCheckbox_Col(Self)) to iCheckbox_Col
106002>>>>>        Get phoDataSource               to hoDataSource
106003>>>>>        Get DataSource of hoDataSource  to TheData
106004>>>>>        Move (SizeOfArray(TheData))     to iSize
106005>>>>>        Decrement iSize
106006>>>>>        For iCount from 0 to iSize
106012>>>>>>
106012>>>>>            Case Begin
106012>>>>>                Case (iState = cx_Select_All)
106014>>>>>                    Move True to TheData[iCount].sValue[iCheckbox_Col]
106015>>>>>                    Case Break
106016>>>>>                Case (iState = cx_Select_None)
106019>>>>>                    Move False to TheData[iCount].sValue[iCheckbox_Col]
106020>>>>>                    Case Break
106021>>>>>                Case (iState = cx_Select_Invert)
106024>>>>>                    Move TheData[iCount].sValue[iCheckbox_Col] to bChecked
106025>>>>>                    Move (not(bChecked)) to TheData[iCount].sValue[iCheckbox_Col]
106026>>>>>                    Case Break
106027>>>>>            Case End
106027>>>>>        Loop
106028>>>>>>
106028>>>>>
106028>>>>>        Send ReInitializeData TheData False
106029>>>>>        Send DoSetCheckboxFooterText
106030>>>>>    End_Procedure
106031>>>>>
106031>>>>>    // Returns a string array with selected values for the data column (phoData_Col).
106031>>>>>    Function SelectedItems Returns String[]
106033>>>>>        Integer i iItems iSize iCheckbox_Col iData_Col
106033>>>>>        String[] sDataArray
106034>>>>>        Handle hoDataSource
106034>>>>>        tDataSourceRow[] TheData
106034>>>>>        tDataSourceRow[] TheData
106035>>>>>        Boolean bChecked
106035>>>>>
106035>>>>>        Get piColumnId of (phoData_Col(Self)) to iData_Col
106036>>>>>        Get piColumnId of oCheckbox_Col to iCheckbox_Col
106037>>>>>
106037>>>>>        Get phoDataSource to hoDataSource
106038>>>>>        Get DataSource of hoDataSource to TheData
106039>>>>>        Move (SizeOfArray(TheData)) to iItems
106040>>>>>        Decrement iItems
106041>>>>>
106041>>>>>        For i from 0 to iItems
106047>>>>>>
106047>>>>>            Move TheData[i].sValue[iCheckbox_Col] to bChecked
106048>>>>>            If (bChecked = True) Begin
106050>>>>>                Move (SizeOfArray(sDataArray)) to iSize
106051>>>>>                Move TheData[i].sValue[iData_Col] to sDataArray[iSize]
106052>>>>>            End
106052>>>>>>
106052>>>>>        Loop
106053>>>>>>
106053>>>>>
106053>>>>>        Function_Return sDataArray
106054>>>>>    End_Function
106055>>>>>
106055>>>>>    Procedure SelectAll
106057>>>>>        Set SelectItems to cx_Select_All
106058>>>>>    End_Procedure
106059>>>>>
106059>>>>>    Procedure SelectNone
106061>>>>>        Set SelectItems to cx_Select_None
106062>>>>>    End_Procedure
106063>>>>>
106063>>>>>    Procedure SelectInvert
106065>>>>>        Set SelectItems to cx_Select_Invert
106066>>>>>    End_Procedure
106067>>>>>
106067>>>>>    // Returns number of items.
106067>>>>>    Function ItemCount Returns Integer
106069>>>>>        Integer iItems
106069>>>>>        Handle hoDataSource
106069>>>>>        tDataSourceRow[] TheData
106069>>>>>        tDataSourceRow[] TheData
106070>>>>>
106070>>>>>        Get phoDataSource to hoDataSource
106071>>>>>        Get DataSource of hoDataSource to TheData
106072>>>>>        Move (SizeOfArray(TheData)) to iItems
106073>>>>>
106073>>>>>        Function_Return iItems
106074>>>>>    End_Function
106075>>>>>
106075>>>>>    // Returns number of checked items.
106075>>>>>    Function CheckedItems Returns Integer
106077>>>>>        Integer iCount iItems iCheckbox_Col iRetval
106077>>>>>        Handle hoDataSource
106077>>>>>        tDataSourceRow[] TheData
106077>>>>>        tDataSourceRow[] TheData
106078>>>>>        Boolean bChecked
106078>>>>>
106078>>>>>        Get piColumnId of (phoCheckbox_Col(Self)) to iCheckbox_Col
106079>>>>>        Get phoDataSource to hoDataSource
106080>>>>>        Get DataSource of hoDataSource to TheData
106081>>>>>        Move (SizeOfArray(TheData)) to iItems
106082>>>>>        Decrement iItems
106083>>>>>
106083>>>>>        For iCount from 0 to iItems
106089>>>>>>
106089>>>>>            Move TheData[iCount].sValue[iCheckbox_Col] to bChecked
106090>>>>>            If (bChecked = True) Begin
106092>>>>>                Increment iRetval
106093>>>>>            End
106093>>>>>>
106093>>>>>        Loop
106094>>>>>>
106094>>>>>
106094>>>>>        Function_Return iRetval
106095>>>>>    End_Function
106096>>>>>
106096>>>>>    // Toggles the current row on/off (the checkbox)
106096>>>>>    Procedure ToggleCurrentItem
106098>>>>>        Boolean bChecked
106098>>>>>        Integer iCol
106098>>>>>        Handle hoCol
106098>>>>>
106098>>>>>        Get piColumnId of (phoCheckbox_Col(Self)) to iCol
106099>>>>>        Get ColumnObject iCol   to hoCol
106100>>>>>        Get SelectedRowValue    of hoCol to bChecked
106101>>>>>        Send UpdateCurrentValue of hoCol (not(bChecked))
106102>>>>>        Send Request_Save
106103>>>>>        Send DoSetCheckboxFooterText
106104>>>>>    End_Procedure
106105>>>>>
106105>>>>>    Procedure OnComMouseUp Short llButton Short llShift Integer llx Integer lly
106107>>>>>        Forward Send OnComMouseUp llButton llShift llx lly
106109>>>>>        Send Request_Save
106110>>>>>        Send DoSetCheckboxFooterText
106111>>>>>    End_Procedure
106112>>>>>
106112>>>>>    Procedure DoSetCheckboxFooterText
106114>>>>>        Integer iCol iSelected iItems
106114>>>>>        Handle hoCol
106114>>>>>
106114>>>>>        If ((phoData_Col(Self) = 0)) Begin
106116>>>>>            Move 1 to iCol
106117>>>>>        End
106117>>>>>>
106117>>>>>        Else Begin
106118>>>>>            Get piColumnId of (phoData_Col(Self)) to iCol
106119>>>>>        End
106119>>>>>>
106119>>>>>        Get ItemCount to iItems
106120>>>>>        Get ColumnObject iCol to hoCol
106121>>>>>        Get CheckedItems to iSelected
106122>>>>>        Set psFooterText of hoCol  to ("Selected:" * String(iSelected) * "of" * String(iItems))
106123>>>>>    End_Procedure
106124>>>>>
106124>>>>>    // Augment to load data to the grid. Is called automatically
106124>>>>>    // from procedure Activating
106124>>>>>    Procedure LoadData
106126>>>>>    End_Procedure
106127>>>>>
106127>>>>>    // Automatically load data into the grid when activating.
106127>>>>>    Procedure Activating
106129>>>>>        Send Cursor_Wait of Cursor_Control
106130>>>>>        Send LoadData
106131>>>>>        Send Cursor_Ready of Cursor_Control
106132>>>>>    End_Procedure
106133>>>>>
106133>>>>>End_Class
106134>>>Use cRDCForm.pkg
106134>>>
106134>>>Enum_List
106134>>>    Define GenerateOK
106134>>>    Define GenerateUserCancel
106134>>>    Define GenerateError
106134>>>    Define GenerateChannelError
106134>>>    Define GenerateUserInputError
106134>>>    Define GenerateOpenTableError
106134>>>End_Enum_List
106134>>>
106134>>>Struct tGeneratorRow
106134>>>    Handle hTable
106134>>>    String sLogicalName
106134>>>    String sRootName
106134>>>    String sDisplayName
106134>>>    Boolean bIsAlias
106134>>>    Boolean bSelected
106134>>>End_Struct
106134>>>
106134>>>Activate_View Activate_oTableDUFCodeGenerator for oTableDUFCodeGenerator
106144>>>>
106144>>>Object oTableDUFCodeGenerator is a dbView
106146>>>    Set Size to 328 501
106147>>>    Set Label to "Generator"
106148>>>    Set Border_Style to Border_Thick
106149>>>    Set pbAcceptDropFiles to True
106150>>>    Set pbAutoActivate to True
106151>>>
106151>>>    Set phoTableDUFCodeGenerator_vw of ghoApplication to Self
106152>>>
106152>>>    Property String psOrgOpenPath
106154>>>    Property Handle phtable
106156>>>    Property String psTableName
106158>>>    Property Integer piDbVersionFileNumber  -1
106160>>>    Property Integer piDbVersionFieldNumber -1
106162>>>    Property Number pnSourcePackageVersion -1
106164>>>    
106164>>>    // Set psOrgOpenPath at startup
106164>>>    Procedure StartUp
106167>>>        String sOrgOpenPath sDataPath
106167>>>        Get_Attribute DF_OPEN_PATH to sOrgOpenPath
106170>>>        // First remove the current Data folder path
106170>>>        Get PathAtIndex of (phoWorkspace(ghoApplication)) sOrgOpenPath 1 to sDataPath
106171>>>        Move (Replace(sDataPath, sOrgOpenPath, "")) to sOrgOpenPath
106172>>>        If (Left(sOrgOpenPath, 2) = "\;") Begin
106174>>>            Move (Replace("\;", sOrgOpenPath, "")) to sOrgOpenPath
106175>>>        End
106175>>>>
106175>>>        Set psOrgOpenPath to sOrgOpenPath
106176>>>    End_Procedure
106177>>>    Send StartUp
106178>>>
106178>>>    Object oFromFilelist_grp is a cRDCHeaderGroup
106180>>>        Set Size to 50 473
106181>>>        Set Location to 8 15
106182>>>        Set pbAcceptDropFiles to True
106183>>>        Set psImage to "FolderLeft1.ico"
106184>>>        Set Label to "Select FROM Filelist.cfg"
106185>>>        Set psNote to "The development/latest version of the database"   
106186>>>        Set psToolTip to "Select the Filelist.cfg for your development database. This is a suggestion form. So if used before - start typing what you're looking for."
106187>>>
106187>>>        Object oFilelistPath_fm is a cRDCSuggestionIniForm
106189>>>            Set Size to 12 424
106190>>>            Set Location to 29 29
106191>>>            Set Label_Col_Offset to 0
106192>>>            Set Label_Row_Offset to 1
106193>>>            Set Label_Justification_Mode to JMode_Top
106194>>>            Set Prompt_Button_Mode to PB_PromptOn
106195>>>            Set peAnchors to anTopLeftRight
106196>>>            Set psToolTip to "Select the FROM database Filelist.cfg. This should be the development workspace Data folder's Filelist.cfg"
106197>>>            Set Prompt_Object to Self
106198>>>
106198>>>            Procedure Prompt
106201>>>                String sFileName sPath sFileMask sRetval
106201>>>
106201>>>                Get Value to sFileName
106202>>>                Get ParseFolderName sFileName to sPath
106203>>>                Move "Filelist.cfg files (*.cfg)|*.cfg" to sFileMask
106204>>>                Get vSelect_File sFileMask "Please select a Filelist.cfg file" sPath to sRetval
106205>>>                If (sRetval <> "") Begin
106207>>>                    Set Value to sRetval
106208>>>                End
106208>>>>
106208>>>            End_Procedure
106209>>>
106209>>>            Procedure OnChange
106212>>>                String sFileList
106212>>>                Boolean bOK bExists bCfgFile bHasRecords
106212>>>                Handle hTable
106212>>>                Number nVersionNumber
106212>>>
106212>>>                Move 0 to nVersionNumber
106213>>>                Get Value to sFileList
106214>>>                Get vFilePathExists sFileList to bExists
106215>>>                Move (Lowercase(sFileList) contains ".cfg") to bCfgFile
106216>>>                If (bExists = True and bCfgFile) Begin
106218>>>                    // A little trick to show the filelist.cfg in the form before we start filling the grid.
106218>>>                    Send PumpMsgQueue of Desktop
106219>>>                    Get ChangeFilelistPathing of ghoApplication sFileList to bOK
106220>>>
106220>>>                    If (bOK = True) Begin
106222>>>                        Set psFilelistFrom of ghoApplication to sFileList
106223>>>
106223>>>                        // *** LOAD DATA ***
106223>>>                        Send LoadData to oFilelist_grd
106224>>>
106224>>>                        // It just seem logical to activate the grid after populating it.
106224>>>                        // At this point there is little use of still having the oFilelist_fm active.
106224>>>                        Get HasRecords of oFilelist_grd to bHasRecords
106225>>>                        If (bHasRecords = True) Begin
106227>>>                            Send Activate of oFilelist_grd
106228>>>                        End
106228>>>>
106228>>>
106228>>>                        If (bExists = True) Begin
106230>>>                            Get phDbVersion of oFilelist_grd to hTable
106231>>>                            If (hTable <> 0) Begin
106233>>>                                Open hTable
106235>>>                                Get_Field_Value hTable 1   to nVersionNumber 
106238>>>                                // ToDo: How to handle this if not the standard "DbVersion" table is used?
106238>>>                                Set pnSourcePackageVersion to nVersionNumber
106239>>>                                Set piDbVersionFileNumber  to hTable
106240>>>                                Set piDbVersionFieldNumber to 1
106241>>>                                Close hTable
106242>>>                            End
106242>>>>
106242>>>                        End
106242>>>>
106242>>>                        If (nVersionNumber = 0) Begin
106244>>>                            Move 1.0 to nVersionNumber
106245>>>                        End   
106245>>>>
106245>>>                        Else Begin
106246>>>                            Move (nVersionNumber + .1) to nVersionNumber
106247>>>                        End
106247>>>>
106247>>>                        Set Value of oPnVersionNumber_fm to nVersionNumber
106248>>>                    End
106248>>>>
106248>>>                End
106248>>>>
106248>>>            End_Procedure
106249>>>
106249>>>            Function Window_Handle Returns Handle
106252>>>                Integer rVal
106252>>>                Get Window_Handle of (Parent(Self)) to rVal
106253>>>                Function_Return rVal
106254>>>            End_Function
106255>>>
106255>>>            Function Next_Object_Id Boolean bNoDescend Returns Integer
106258>>>                Function_Return (oFilelist_grd(Self))
106259>>>            End_Function
106260>>>
106260>>>            On_Key Key_Ctrl+Key_W Send None
106261>>>            On_Key Key_Ctrl+Key_Q Send None
106262>>>        End_Object
106263>>>
106263>>>    End_Object
106264>>>
106264>>>    Object oSelectTables_grp is a cRDCHeaderGroup
106266>>>        Set Size to 92 473
106267>>>        Set Location to 69 15
106268>>>        Set peAnchors to anAll
106269>>>        Set psImage to "SelectTables1.ico"
106270>>>        Set psLabel to "Select Tables"
106271>>>        Set psNote to "Right click grid for options"  
106272>>>        Set psToolTip to "Select one or more tables to generate 'DUF' database update code for. (Ctrl+A = 'Select All Tables'. Right-click grid for selection options."
106273>>>
106273>>>        Object oFilelist_grd is a cRDCCJSelectionGrid
106275>>>            Set Size to 56 423
106276>>>            Set Location to 27 29
106277>>>            Set piLayoutBuild to 6
106278>>>            Set Status_Help to "Select with the spacebar, or use the selection buttons above the grid"
106279>>>                Set peVisualTheme to xtpReportThemeVisualStudio2012Light
106280>>>
106280>>>            Property Handle phDbVersion
106282>>>            Property Integer piCurrentRow -1
106284>>>
106284>>>            Object oCJGridColumnRowIndicator is a cCJGridColumnRowIndicator
106286>>>                Set piWidth to 26
106287>>>            End_Object
106288>>>                         
106288>>>            Object oFilelistNumber_col is a cCJGridColumn
106290>>>                Set piWidth to 74
106291>>>                Set psCaption to "Filelist No"
106292>>>                Set psToolTip to (psCaption(Self) * "(Read-Only)")
106293>>>                Set peDataType to Mask_Numeric_Window
106294>>>                Set pbEditable to False
106295>>>                Set peTextAlignment to xtpAlignmentCenter
106296>>>            End_Object
106297>>>
106297>>>            Object oLogicalName_col is a cCJGridColumn
106299>>>                Set piWidth to 121
106300>>>                Set psCaption to "Logical Name"
106301>>>                Set psToolTip to (psCaption(Self) * "(Read-Only)")
106302>>>                Set pbEditable to False
106303>>>                Set psFooterText to "No of Tables:"
106304>>>            End_Object
106305>>>
106305>>>            Object oRootName_col is a cCJGridColumn
106307>>>                // NOTE: This must be set at one of the columns!
106307>>>                Set phoData_Col to Self
106308>>>                Set piWidth to 191
106309>>>                Set psCaption to "Table Name (Rootname)"
106310>>>                Set psToolTip to (psCaption(Self) * "(Read-Only)")
106311>>>                Set pbEditable to False
106312>>>                Set psFooterText to "Selected:"
106313>>>            End_Object
106314>>>
106314>>>            Object oDisplayName_col is a cCJGridColumn
106316>>>                Set piWidth to 267
106317>>>                Set psCaption to "Display Name"
106318>>>                Set psToolTip to (psCaption(Self) * "(Read-Only)")
106319>>>                Set pbEditable to False
106320>>>            End_Object
106321>>>
106321>>>            Object oIsAlias_Col is a cCJGridColumn
106323>>>                Set piWidth to 85
106324>>>                Set psCaption to "Is Alias"
106325>>>                Set pbCheckbox to True
106326>>>                Set peHeaderAlignment to xtpAlignmentCenter
106327>>>                Set peFooterAlignment to xtpAlignmentCenter
106328>>>                Set pbVDFEditControl to False
106329>>>                Set psToolTip to "Is table an alias table? (Read-Only)"
106330>>>                Set psFooterText to "Alias:"
106331>>>            End_Object
106332>>>
106332>>>            Procedure LoadData
106335>>>                String sFileList sLogicalName
106335>>>                Handle hoDataSource hTable
106335>>>                tDataSourceRow[] TheData TheDataEmpty
106335>>>                tDataSourceRow[] TheData TheDataEmpty
106337>>>                Integer iRow iTableNo iRoot iLogical iDisplay iIsAlias iChecked iAliasCount iNoOfTables iCount
106337>>>                Boolean bExists bIsAlias bUserCancel
106337>>>
106337>>>                Get Value of oFilelistPath_fm to sFilelist
106338>>>                Get vFilePathExists sFileList to bExists
106339>>>                If (bExists = False) Begin
106341>>>                    Procedure_Return
106342>>>                End
106342>>>>
106342>>>
106342>>>                Send Initialize_StatusPanel of ghoStatusPanel "The Database Update Framework" "Loading Filelist.cfg data" "...and checking for Alias tables"
106343>>>                Send Start_StatusPanel of ghoStatusPanel
106344>>>                Get UtilFilelistNoOfTables of ghoDbUpdateFunctionLibrary to iNoOfTables
106345>>>                Set pbVisible of ghoProgressBar to True
106346>>>                Set pbVisible of ghoProgressBarOverall to False
106347>>>                Set piMaximum of ghoProgressBar to iNoOfTables
106348>>>                Move 0 to iCount
106349>>>                Get phoDataSource to hoDataSource
106350>>>                Get DataSource of hoDataSource to TheData
106351>>>                Move TheDataEmpty to TheData
106352>>>                Get piColumnId of oFilelistNumber_col to iTableNo
106353>>>                Get piColumnId of oRootName_col       to iRoot
106354>>>                Get piColumnid of oLogicalName_col    to iLogical
106355>>>                Get piColumnId of oDisplayName_col    to iDisplay
106356>>>                Get piColumnId of oIsAlias_Col        to iIsAlias
106357>>>                Get piColumnId of oCheckbox_Col       to iChecked
106358>>>
106358>>>                Move 0 to hTable
106359>>>                Move 0 to iRow
106360>>>                Repeat
106360>>>>
106360>>>                    Get_Attribute DF_FILE_NEXT_USED of hTable to hTable
106363>>>                    Set piPosition of ghoProgressBar to iCount
106364>>>
106364>>>                    If (hTable > 0 and hTable <> 50) Begin
106366>>>                        Move hTable                                   to TheData[iRow].sValue[iTableNo]
106367>>>                        Get_Attribute DF_FILE_ROOT_NAME     of hTable to TheData[iRow].sValue[iRoot]
106370>>>                        Get_Attribute DF_FILE_LOGICAL_NAME  of hTable to sLogicalName
106373>>>                        Move sLogicalName                             to TheData[iRow].sValue[iLogical]
106374>>>                        If (Uppercase(sLogicalName) = "DBVERSION") Begin
106376>>>                            Set phDbVersion to hTable
106377>>>                        End
106377>>>>
106377>>>                        Get_Attribute DF_FILE_DISPLAY_NAME  of hTable to TheData[iRow].sValue[iDisplay]
106380>>>                        Get UtilTableIsAlias of ghoDbUpdateFunctionLibrary hTable to bIsAlias
106381>>>                        Move bIsAlias                                 to TheData[iRow].sValue[iIsAlias]
106382>>>                        If (bIsAlias = True) Begin
106384>>>                            Increment iAliasCount
106385>>>                        End
106385>>>>
106385>>>                        Move False to TheData[iRow].sValue[iChecked]
106386>>>                        Increment iRow
106387>>>                    End
106387>>>>
106387>>>                    Increment iCount
106388>>>                    Get Check_StatusPanel of ghoStatusPanel to bUserCancel
106389>>>                    If (bUserCancel = True) Begin
106391>>>                        Move TheDataEmpty to TheData
106392>>>                        Move 0 to iRow
106393>>>                        Move 0 to iAliasCount
106394>>>                        Move 0 to hTable
106395>>>                    End
106395>>>>
106395>>>                Until (hTable = 0)
106397>>>                                    
106397>>>                Send InitializeData TheData
106398>>>                Set psFooterText of oLogicalName_col to ("No of Tables:" * String(iRow))
106399>>>                Set psFooterText of oIsAlias_Col     to ("Alias:" * String(iAliasCount))
106400>>>                Send Stop_StatusPanel of ghoStatusPanel
106401>>>            End_Procedure
106402>>>
106402>>>            Function SelectedTableNumber Returns Handle
106405>>>                Integer hTable iTableNo iRowNo
106405>>>                Handle hoDataSource
106405>>>                tDataSourceRow[] TheData
106405>>>                tDataSourceRow[] TheData
106406>>>
106406>>>                Get phoDataSource to hoDataSource
106407>>>                Get piColumnId of oFilelistNumber_col to iTableNo
106408>>>                Get DataSource of hoDataSource to TheData
106409>>>                Get SelectedRow of hoDataSource to iRowNo
106410>>>                Move TheData[iRowNo].sValue[iTableNo] to hTable
106411>>>
106411>>>                Function_Return hTable
106412>>>            End_Function
106413>>>
106413>>>            Function GenerateSourceFileName Returns String
106416>>>                String sRetval sPath sFileListName sTableName sVersionNumber
106416>>>                Boolean bExists
106416>>>                Integer iLogical iRowNo iSelected iPos
106416>>>                tDataSourceRow[] TheData
106416>>>                tDataSourceRow[] TheData
106417>>>                Handle hoDataSource
106417>>>                Number nVersionNumber
106417>>>
106417>>>                Get Value of oFilelistPath_fm to sFileListName
106418>>>                Get vFilePathExists sFileListName to bExists
106419>>>                If (bExists = False) Begin
106421>>>                    Function_Return ""
106422>>>                End
106422>>>>
106422>>>
106422>>>                Set_Attribute DF_DECIMAL_SEPARATOR to (Ascii('.'))
106425>>>                Get Value of oPnVersionNumber_fm to sVersionNumber
106426>>>//                Move nVersionNumber to sVersionNumber
106426>>>                Move (Pos(".", sVersionNumber)) to iPos
106427>>>                If (iPos = 0) Begin
106429>>>                    Move (sVersionNumber + String(".0")) to sVersionNumber
106430>>>                End
106430>>>>
106430>>>                Move (Replaces(".", sVersionNumber, "_")) to sVersionNumber
106431>>>                Move (Replaces(",", sVersionNumber, "_")) to sVersionNumber
106432>>>
106432>>>                Get ParseFolderName sFileListName to sPath
106433>>>                Get vParentPath sPath   to sPath
106434>>>                Get vFolderFormat sPath to sPath
106435>>>                Move (sPath + "AppSrc") to sPath
106436>>>                Get vFolderFormat sPath to sPath
106437>>>
106437>>>                Get phoDataSource to hoDataSource
106438>>>                Get piColumnid of oLogicalName_col to iLogical
106439>>>                Get DataSource of hoDataSource to TheData
106440>>>                Get CheckedItems to iSelected
106441>>>                If (iSelected > 1) Begin
106443>>>                    Move "MultipleTables" to sTableName
106444>>>                End
106444>>>>
106444>>>                Else Begin
106445>>>                    If (SizeOfArray(TheData) <> 0) Begin
106447>>>                        Get SelectedRow of hoDataSource to iRowNo
106448>>>                        Move TheData[iRowNo].sValue[iLogical] to sTableName
106449>>>                    End
106449>>>>
106449>>>                End
106449>>>>
106449>>>                Move ("DUF_" + sTableName + String(sVersionNumber) + ".pkg") to sTableName
106450>>>
106450>>>                Move (sPath + sTableName) to sRetval
106451>>>
106451>>>                Function_Return sRetval
106452>>>            End_Function
106453>>>
106453>>>            Function piCheckboxCol Returns Integer
106456>>>                Integer iIndex
106456>>>                Get piColumnId of oCheckbox_Col to iIndex
106457>>>                Function_Return iIndex
106458>>>            End_Function
106459>>>
106459>>>            // Returns a string array with the selected items.
106459>>>            Function SelectedItems Returns tGeneratorRow[]
106462>>>                Integer[] SelRows
106463>>>                Integer i iItems iSize iCheckbox_Col iFilelistNo_Col iLogical_Col iRoot_Col iDisplay_Col iIsAlias_Col
106463>>>                String sFileName
106463>>>                String[] sFilesArray
106464>>>                Handle hoDataSource
106464>>>                tDataSourceRow[] TheData
106464>>>                tDataSourceRow[] TheData
106465>>>                Boolean bChecked bIsAlias
106465>>>                tGeneratorRow[] GeneratorRowArray
106465>>>                tGeneratorRow[] GeneratorRowArray
106466>>>
106466>>>                Get piColumnId of oFilelistNumber_col to iFilelistNo_Col
106467>>>                Get piColumnId of oLogicalName_col    to iLogical_Col
106468>>>                Get piColumnId of oRootName_col       to iRoot_Col
106469>>>                Get piColumnId of oDisplayName_col    to iDisplay_Col
106470>>>                Get piColumnId of oIsAlias_Col        to iIsAlias_Col
106471>>>                Get piColumnId of oCheckbox_Col       to iCheckbox_Col
106472>>>
106472>>>                Get phoDataSource to hoDataSource
106473>>>                Get DataSource of hoDataSource to TheData
106474>>>                Move (SizeOfArray(TheData)) to iItems
106475>>>                Decrement iItems
106476>>>
106476>>>                For i from 0 to iItems
106482>>>>
106482>>>                    Move TheData[i].sValue[iCheckbox_Col] to bChecked
106483>>>                    If (bChecked = True) Begin
106485>>>                        Move (SizeOfArray(GeneratorRowArray)) to iSize
106486>>>                        Move TheData[i].sValue[iFilelistNo_Col] to GeneratorRowArray[iSize].hTable
106487>>>                        Move TheData[i].sValue[iLogical_Col]    to GeneratorRowArray[iSize].sLogicalName
106488>>>                        Move TheData[i].sValue[iRoot_Col]       to GeneratorRowArray[iSize].sRootName
106489>>>                        Move TheData[i].sValue[iDisplay_Col]    to GeneratorRowArray[iSize].sDisplayName
106490>>>                        Move TheData[i].sValue[iIsAlias_Col]    to GeneratorRowArray[iSize].bIsAlias
106491>>>                        Move TheData[i].sValue[iCheckbox_Col]   to GeneratorRowArray[iSize].bSelected
106492>>>                        Move sFileName to sFilesArray[iSize]
106493>>>                    End
106493>>>>
106493>>>                Loop
106494>>>>
106494>>>
106494>>>                Function_Return GeneratorRowArray
106495>>>            End_Function
106496>>>
106496>>>            Procedure Request_Clear
106499>>>                Delegate Send Request_Clear
106501>>>            End_Procedure   
106502>>>            
106502>>>            Function HasRecords Returns Boolean
106505>>>                Handle hoDataSource
106505>>>                tDataSourceRow[] TheData
106505>>>                tDataSourceRow[] TheData
106506>>>                Integer iItems
106506>>>
106506>>>                Get phoDataSource to hoDataSource
106507>>>                Get DataSource of hoDataSource to TheData
106508>>>                Move (SizeOfArray(TheData)) to iItems
106509>>>                Function_Return (iItems <> 0)
106510>>>            End_Function
106511>>>
106511>>>            Procedure Set SelectItems Integer iState
106514>>>                String sSourceFile
106514>>>
106514>>>                Forward Set SelectItems to iState
106516>>>                Get GenerateSourceFileName  to sSourceFile
106517>>>                Set Value of oSourceName_fm to sSourceFile
106518>>>            End_Procedure     
106519>>>            
106519>>>            Procedure ToggleCurrentItem 
106522>>>                String sSourceFile
106522>>>
106522>>>                Forward Send ToggleCurrentItem
106524>>>                Get GenerateSourceFileName  to sSourceFile
106525>>>                Set Value of oSourceName_fm to sSourceFile
106526>>>                
106526>>>            End_Procedure
106527>>>
106527>>>        End_Object
106528>>>
106528>>>        // Needed to not close the view when Esc is hit in the grid.
106528>>>        On_Key kCancel Send None
106529>>>    End_Object
106530>>>
106530>>>    Object oConfigureGeneration_grp is a cRDCHeaderGroup
106532>>>        Set Size to 48 473
106533>>>        Set Location to 172 15
106534>>>        Set peAnchors to anBottomLeftRight
106535>>>        Set psLabel to "Configure Code Generation"
106536>>>        Set psImage to "Settings1.ico"   
106537>>>        Set psToolTip to "Select how code is generated. If you are not sure what the flags does, leave the default settings."
106538>>>        
106538>>>        Object oUseConnectionID_cb is a cSQLCheckBox
106540>>>            Set Size to 9 78
106541>>>            Set Location to 19 30
106542>>>            Set Label to "Use Connection ID"
106543>>>            Set Checked_State to True
106544>>>            Set psToolTip to "If True (the default); uses the Connection ID of the connection string as defined by the SQLConnection.ini setting"
106545>>>        End_Object
106546>>>
106546>>>        Object oANSI_cb is a cSQLCheckBox
106548>>>            Set Size to 9 49
106549>>>            Set Location to 19 136
106550>>>            Set Label to "ANSI/OEM"
106551>>>            Set Checked_State to True  
106552>>>            Set psToolTip to "Set property 'pbToANSI' True/False. DataFlex data is stored in OEM format. Non-DataFlex back ends may expect the data to be stored in ANSI format. When defining the conversion options you can define the table character format to be used in the converted table."
106553>>>        End_Object
106554>>>
106554>>>        Object oCompareIndexAscending_cb is a cSQLCheckBox
106556>>>            Set Size to 9 93
106557>>>            Set Location to 19 200
106558>>>            Set Label to "Change Asc/Descending"
106559>>>            Set Checked_State to False
106560>>>            Set psToolTip to "Set property 'pbCompareIndexAscending' True/False. Check if Index is Ascending/Descending. (In SQL this setting is set for the whole database by selecting a 'Collation', so with SQL checking this per table doesn't make sense)"
106561>>>        End_Object
106562>>>
106562>>>        Object oApiTableUpdateAuto_cb is a cSQLCheckBox
106564>>>            Set Size to 9 137
106565>>>            Set Location to 19 316
106566>>>            Set Label to "Auto Update Table to SQL"
106567>>>            Set Checked_State to True
106568>>>            Set psToolTip to "Set property 'pbApiTableUpdateAuto' True/False. When set to True, 'TO' tables will get converted to the same database format as the 'FROM' tables. So if a 'FROM' table is an SQL table and the 'TO' table is in the embedded format (DataFlex table), it will be converted to SQL."
106569>>>        End_Object
106570>>>
106570>>>        Object oCompareDate_DataTime_cb is a cSQLCheckBox
106572>>>            Set Size to 9 91
106573>>>            Set Location to 32 30
106574>>>            Set Label to "Change Date/DataTime"
106575>>>            Set Checked_State to False
106576>>>            Set psToolTip to "Set property 'pbCompareDate_DateTime' True/False. Check if there are Date/DateTime column differences. Tick the box if the framework should create code to change e.g. a 'To' DateTime column to a Date column if the 'FROM' table column is defined as Date. Be careful as you might loose data!"
106577>>>        End_Object
106578>>>
106578>>>        Object oRecnum_cb is a cSQLCheckBox
106580>>>            Set Size to 9 57
106581>>>            Set Location to 32 136
106582>>>            Set Label to "Use Recnum"
106583>>>            Set Checked_State to True
106584>>>            Set psToolTip to "Set property 'pbRecnum' True/False. If the program that is using the source database uses the recnum programming style, the tables should be converted to recnum tables. If the program uses the RowId programming style, converting to standard tables is recommended."
106585>>>        End_Object
106586>>>
106586>>>        Object oCompareIndexUppercase_cb is a cSQLCheckBox
106588>>>            Set Size to 9 98
106589>>>            Set Location to 32 200
106590>>>            Set Label to "Change Upper/Lowercase"
106591>>>            Set Checked_State to False
106592>>>            Set psToolTip to "Set property 'pbCompareIndexUppercase' True/False. Check if Index is Uppercase/Lowercase. (In SQL this setting is set for the whole database by selecting a 'Collation', so then checking this per table doesn't make sense)"
106593>>>        End_Object
106594>>>
106594>>>        Object oIgnoreFilelistUppercase_cb is a cSQLCheckBox
106596>>>            Set Size to 9 142
106597>>>            Set Location to 32 316
106598>>>            Set Label to "Change Upper/Lowercase Table Names"
106599>>>            Set Checked_State to True
106600>>>            Set psToolTip to "Check Filelist.cfg RootName, LogicalName and DisplayName uppercase/lowercase differences"
106601>>>        End_Object
106602>>>
106602>>>        Procedure ToggleCurrentItem
106605>>>            Boolean bChecked
106605>>>            Handle hObject
106605>>>
106605>>>            Get Focus to hObject
106606>>>            Get Checked_State of hObject to bChecked
106607>>>            Set Checked_State of hObject to (not(bChecked))
106608>>>        End_Procedure
106609>>>
106609>>>    End_Object
106610>>>
106610>>>    Object oGenerateFilename_grp is a cRDCHeaderGroup
106612>>>        Set Size to 39 473
106613>>>        Set Location to 232 15
106614>>>        Set peAnchors to anBottomLeftRight
106615>>>        Set psImage to "ActionSaveCode1.ico"
106616>>>        Set psLabel to "Generated Package File Name"  
106617>>>        Set psToolTip to "A suggestion for the package file to be generated is shown. It can be changed if needed, but you are not encouraged to do so."
106618>>>
106618>>>        Object oPnVersionNumber_fm is a cRDCForm
106620>>>            Set Size to 12 22
106621>>>            Set Location to 17 108
106622>>>            Set Label to "Next pnVersionNumber"
106623>>>            Set psToolTip to "This value is the current DbVersion.DatabaseVersion value, with a value of 0.1 added to it."
106624>>>            Set peAnchors to anBottomLeft
106625>>>            Set Label_Justification_Mode to JMode_Right
106626>>>            Set Label_Col_Offset to 2
106627>>>            Set_Attribute DF_DECIMAL_SEPARATOR to (Ascii('.'))
106630>>>            Set Form_Datatype to 2
106631>>>            Set Value to 1.0
106632>>>
106632>>>            Procedure OnChange
106635>>>                String sSourceFile
106635>>>                Number nVersionNumber 
106635>>>                Integer iDecimalSeparator                     
106635>>>                
106635>>>                Set_Attribute DF_DECIMAL_SEPARATOR to (Ascii('.'))
106638>>>                Get Value to nVersionNumber
106639>>>//                If (nVersionNumber < 1) Begin
106639>>>//                    Move 1 to nVersionNumber   
106639>>>//                    Set Value to nVersionNumber     
106639>>>//                End
106639>>>                Set pnSourcePackageVersion to nVersionNumber
106640>>>                Get GenerateSourceFileName of oFilelist_grd  to sSourceFile
106641>>>                Set Value of oSourceName_fm to sSourceFile
106642>>>            End_Procedure
106643>>>
106643>>>        End_Object
106644>>>
106644>>>        Object oSourceName_fm is a cRDCForm
106646>>>            Set Size to 12 315
106647>>>            Set Location to 17 134
106648>>>            Set peAnchors to anBottomLeftRight
106649>>>            Set Label_Col_Offset to 0
106650>>>            Set Label_Justification_Mode to JMode_Top
106651>>>            Set Label_Row_Offset to 1
106652>>>            Set psToolTip to "The name of the output file to be generated. The suggested name can be changed if needed."
106653>>>        End_Object
106654>>>
106654>>>    End_Object
106655>>>
106655>>>    Object oBusinessProcess is a BusinessProcess
106657>>>        Set Status_Panel_Id to ghoStatusPanel
106658>>>        Set Allow_Cancel_State to True
106659>>>        Set Process_Caption to "The Database Update Framework"
106660>>>        Set Process_Title to "Generating Database Update Code..."
106661>>>        Set Process_Message to "For table:"
106662>>>
106662>>>        Procedure OnProcess
106665>>>            Send StartGenerateCode
106666>>>        End_Procedure
106667>>>
106667>>>        Procedure Ignore_Error Integer iError
106670>>>        End_Procedure
106671>>>        Procedure Trap_Error Integer iError
106674>>>        End_Procedure
106675>>>
106675>>>    End_Object
106676>>>
106676>>>    Object oGenerateCode_btn is a cRDCCommandLinkButton
106678>>>        Set Size to 36 166
106679>>>        Set Location to 281 63
106680>>>        Set Label to "Generate Code!"
106681>>>        Set psNote to "Create DUF update package for the selected tables."
106682>>>        Set psToolTip to "Start generating DUF code for all selected tables."
106683>>>        Set psImage to "SqlScript1.ico"    
106684>>>        Set Default_State to True
106685>>>        Set MultiLineState to True
106686>>>        Set piImageSize to 32 
106687>>>        Set pbAutoEnable to True
106688>>>        Set peAnchors to anBottomRight
106689>>>
106689>>>        Procedure OnClick
106692>>>            Boolean bExists
106692>>>            String sSourceFile sPath
106692>>>            Integer iSelected iRetval
106692>>>
106692>>>            Get Value of oSourceName_fm to sSourceFile
106693>>>            Get vFilePathExists sSourceFile to bExists
106694>>>            If (bExists = True) Begin
106696>>>                Get YesNo_Box ("Oops, the source file" * sSourceFile * "already exists!\n\nDo you want to overwrite it?") to iRetval
106697>>>                If (iRetval <> MBR_Yes) Begin
106699>>>                    Procedure_Return
106700>>>                End
106700>>>>
106700>>>            End                     
106700>>>>
106700>>>            
106700>>>            Get ExtractFilePath sSourceFile to sPath
106701>>>            Get vFilePathExists sPath       to bExists
106702>>>            If (bExists = False) Begin
106704>>>                Send Info_Box "Please check the source file path and try again. It doesn't exist!"
106705>>>                Procedure_Return
106706>>>            End
106706>>>>
106706>>>
106706>>>            Get CheckedItems  of oFilelist_grd to iSelected
106707>>>            If (iSelected = 0) Begin
106709>>>                Send Info_Box "No tables selected. Please adjust and try again."
106710>>>                Procedure_Return
106711>>>            End
106711>>>>
106711>>>
106711>>>            Send DoProcess of oBusinessProcess
106712>>>            Send Restore_DF_OPEN_PATH of ghoApplication
106713>>>        End_Procedure
106714>>>
106714>>>        Function IsEnabled Returns Boolean
106717>>>            Integer iSelected 
106717>>>            Get CheckedItems  of oFilelist_grd to iSelected
106718>>>            Function_Return (iSelected <> 0)
106719>>>        End_Function
106720>>>            
106720>>>    End_Object
106721>>>
106721>>>    Object oGenerateInternalUpdatetProgram_btn is a cRDCCommandLinkButton
106723>>>        Set Size to 36 77
106724>>>        Set Location to 281 239
106725>>>        Set Label to "Local"
106726>>>        Set psNote to "Create local helper program"
106727>>>        Set peAnchors to anBottomRight
106728>>>        Set psToolTip to "Generates a small basic program that Use's the generated package. To be be send to a fellow developer working on the same project, to make his/hers local database identical to the selected 'FROM' database."
106729>>>        Set psImage to "SqlScript1.ico"    
106730>>>        Set piImageSize to 16 // 24
106731>>>        Set pbAutoEnable to True
106732>>>        
106732>>>        Procedure OnClick
106735>>>            Integer iRetval
106735>>>            String sText
106735>>>        
106735>>>            Move "This generates a small basic program that Use's the generated package. To be be send to a fellow developer working on the same project, to make his/hers local database identical to the selected 'FROM' database. Continue?" to sText
106736>>>            Get YesNo_Box sText to iRetval
106737>>>            If (iRetval = MBR_Yes) Begin
106739>>>                Send GenerateInternalUpdateProgram
106740>>>            End
106740>>>>
106740>>>        End_Procedure
106741>>>        
106741>>>        Procedure GenerateInternalUpdateProgram
106744>>>            String sPath sSourcePackageName
106744>>>            Integer iDbVersionFileNumber iDbVersionFieldNumber
106744>>>            Number nSourcePackageVersion
106744>>>            Boolean bOK 
106744>>>            
106744>>>            Get piDbVersionFileNumber   to iDbVersionFileNumber
106745>>>            Get piDbVersionFieldNumber  to iDbVersionFieldNumber
106746>>>            Get pnSourcePackageVersion  to nSourcePackageVersion
106747>>>            
106747>>>            Get Value of oSourceName_fm to sSourcePackageName
106748>>>            Get ParseFolderName sSourcePackageName to sPath
106749>>>            Get ParseFileName sSourcePackageName to sSourcePackageName
106750>>>                        
106750>>>            Get WriteTestProgram sSourcePackageName sPath nSourcePackageVersion iDbVersionFileNumber iDbVersionFieldNumber to bOK
106751>>>            If (bOK = True) Begin
106753>>>                Send Info_Box ("Success! The source program" * CS_DUFTestProgram * "was created in:" * sPath)        
106754>>>            End 
106754>>>>
106754>>>            Else Begin
106755>>>                Send Info_Box "The creation of the source program failed..."
106756>>>            End
106756>>>>
106756>>>        End_Procedure
106757>>>        
106757>>>        Function IsEnabled Returns Boolean
106760>>>            String sPath sSourceName
106760>>>            Boolean bExists
106760>>>            Integer iSelected 
106760>>>
106760>>>            Get CheckedItems of oFilelist_grd to iSelected
106761>>>            Get Value of oSourceName_fm to sSourceName
106762>>>            Get ParseFolderName sSourceName to sPath
106763>>>            Get vFolderExists sPath to bExists
106764>>>            Function_Return (iSelected <> 0 and bExists = True)
106765>>>        End_Function
106766>>>
106766>>>    End_Object
106767>>>
106767>>>    Object oViewSoureCode_btn is a cRDCCommandLinkButton
106769>>>        Set Size to 36 76
106770>>>        Set Location to 281 326
106771>>>        Set Label to "View"
106772>>>        Set psNote to "View source code"
106773>>>        Set peAnchors to anBottomRight
106774>>>        Set psToolTip to "Open the source file in the editor"
106775>>>        Set MultiLineState to True
106776>>>        Set psImage to "ViewSourceCode1.ico" 
106777>>>        Set piImageSize to 16 
106778>>>        Set pbAutoEnable to True
106779>>>
106779>>>        Procedure OnClick
106782>>>            String sSourceName
106782>>>            
106782>>>            Get Value of oSourceName_fm to sSourceName
106783>>>            Send ActivateSourceCodeDialog sSourceName
106784>>>        End_Procedure
106785>>>
106785>>>        Function IsEnabled Returns Boolean
106788>>>            String sSourceName
106788>>>            Boolean bExists
106788>>>
106788>>>            Get Value of oSourceName_fm to sSourceName
106789>>>            Get vFilePathExists sSourceName to bExists
106790>>>            Function_Return (bExists = True)
106791>>>        End_Function
106792>>>
106792>>>    End_Object
106793>>>
106793>>>    Object oOpenAppSrcFolder_btn is a cRDCCommandLinkButton
106795>>>        Set Size to 36 76
106796>>>        Set Location to 281 413
106797>>>        Set Label to "F&older"
106798>>>        Set psNote to "Open containing folder"
106799>>>        Set peAnchors to anBottomRight
106800>>>        Set psToolTip to "Open the source location in Windows Explorer"
106801>>>        Set MultiLineState to True
106802>>>        Set psImage to "ActionOpenFolder1.ico" 
106803>>>        Set piImageSize to 16 // 24
106804>>>        Set pbAutoEnable to True
106805>>>
106805>>>        Procedure OnClick
106808>>>            String sPath sSourceName sFile  
106808>>>            Boolean bExists
106808>>>            
106808>>>            Get Value of oSourceName_fm to sSourceName
106809>>>            Get vFilePathExists sSourceName to bExists
106810>>>            Get ParseFolderName sSourceName to sPath
106811>>>            Get ParseFileName sSourceName to sFile
106812>>>            // We want to have that file to be selected in Windows Explorer when it opens
106812>>>            If (bExists = True) Begin
106814>>>                Move ("/select, " + '"' + sSourceName + '"') to sSourceName
106815>>>            End
106815>>>>
106815>>>            Runprogram Shell Background "Explorer.exe" sSourceName
106816>>>        End_Procedure
106817>>>
106817>>>        Function IsEnabled Returns Boolean
106820>>>            String sPath sSourceName
106820>>>            Boolean bExists
106820>>>
106820>>>            Get Value of oSourceName_fm to sSourceName
106821>>>            Get ParseFolderName sSourceName to sPath
106822>>>            Get vFolderExists sPath to bExists
106823>>>            Function_Return (bExists = True)
106824>>>        End_Function
106825>>>
106825>>>    End_Object
106826>>>
106826>>>    Procedure StartGenerateCode
106829>>>        String sSourceFile
106829>>>        Boolean bUseConnectionID bANSI bRecnum bCompareIndexUppercase bCompareIndexAscending
106829>>>        Handle hTable
106829>>>        Integer iErrors
106829>>>        Number nVersionNumber
106829>>>        tGeneratorRow[] TheData
106829>>>        tGeneratorRow[] TheData
106830>>>        tAPITableBooleans CompareTableBooleans
106830>>>        tAPITableBooleans CompareTableBooleans
106830>>>
106830>>>        Set_Attribute DF_DECIMAL_SEPARATOR to (Ascii('.'))
106833>>>        Get Value of oSourceName_fm                      to sSourceFile
106834>>>        Get Checked_State of oUseConnectionID_cb         to bUseConnectionID
106835>>>        Get Checked_State of oANSI_cb                    to bANSI
106836>>>        Get Checked_State of oRecnum_cb                  to bRecnum
106837>>>        Get Checked_State of oApiTableUpdateAuto_cb      to CompareTableBooleans.bApiTableUpdateAuto
106838>>>        Get Checked_State of oCompareDate_DataTime_cb    to CompareTableBooleans.bCompareDate_DateTime
106839>>>        Get Checked_State of oCompareIndexAscending_cb   to CompareTableBooleans.bCompareIndexAscending
106840>>>        Get Checked_State of oCompareIndexUppercase_cb   to CompareTableBooleans.bCompareIndexUppercase
106841>>>        Get Checked_State of oIgnoreFilelistUppercase_cb to CompareTableBooleans.bCompareFilelistUppercase
106842>>>
106842>>>        Get SelectedItems of oFilelist_grd to TheData
106843>>>        Get pnSourcePackageVersion to nVersionNumber
106844>>>        Get GenerateDUFSourceCode sSourceFile TheData nVersionNumber bUseConnectionID bANSI bRecnum CompareTableBooleans to iErrors
106845>>>
106845>>>        If (iErrors = GenerateChannelError) Begin
106847>>>            Send Info_Box "Sorry, couldn't retrieve a free channel number. Process halted."
106848>>>        End
106848>>>>
106848>>>        If (iErrors = GenerateUserInputError) Begin
106850>>>            Send Info_Box "Table number and pnVersionNumber both needs to be > 0. Please adjust and try again."
106851>>>        End
106851>>>>
106851>>>
106851>>>        Send Stop_StatusPanel of ghoStatusPanel
106852>>>        If (iErrors = GenerateOK) Begin
106854>>>            Send Info_Box "Ready!"
106855>>>        End
106855>>>>
106855>>>        If (iErrors = GenerateError) Begin
106857>>>            Send Info_Box ("Ready! But the code contains ERRORS because there were fields with length = 0! Search the generated code for the word 'ERROR!' to see those fields.")
106858>>>        End
106858>>>>
106858>>>        If (iErrors = GenerateOpenTableError) Begin
106860>>>            Send Info_Box ("Sorry, couldn't open the table! (Table No:" * String(phTable(Self)) * String(psFileName(Self)) + ") Process halted.")
106861>>>        End
106861>>>>
106861>>>        If (iErrors = GenerateUserCancel) Begin
106863>>>            Send Info_Box "Process cancelled by user."
106864>>>        End
106864>>>>
106864>>>    End_Procedure
106865>>>
106865>>>    Function GenerateDUFSourceCode String sSourceFile tGeneratorRow[] TheData Number nVersionNumber Boolean bUseConnectionID Boolean bANSI Boolean bRecnum tAPITableBooleans CompareTableBooleans Returns Integer
106868>>>        Boolean bApiTableUpdateAuto bCompare_DateTime bCompareIndexAscending bCompareIndexUppercase bCompareFilelistUppercase
106868>>>        Integer iCh iColumn iLength iPrecision iOptions iCount iSize iTable iTables
106868>>>        Integer iIndex iIndexes iSegment iNumSegments iType iErrors iStatus
106868>>>        Boolean bOpened bOK bDawSqlDriver bIsAlias bSqlDriver bSkipTable
106868>>>        String sRootName sLogicalName sDisplayName sTableName sFieldName sDataType sDriverID
106868>>>        Handle hTable
106868>>>        tAPITableNameInfo  APITableNameInfo
106868>>>        tAPITableNameInfo  APITableNameInfo
106868>>>        tAPIColumn[]   APIColumns
106868>>>        tAPIColumn[]   APIColumns
106869>>>        tAPIRelation[] APIRelations
106869>>>        tAPIRelation[] APIRelations
106870>>>        tAPIIndex[]    APIIndexes
106870>>>        tAPIIndex[]    APIIndexes
106871>>>        DateTime dtCreationTime
106871>>>
106871>>>        Move (CurrentDateTime()) to dtCreationTime
106872>>>        Move 0 to iErrors
106873>>>        Move (SizeOfArray(TheData)) to iTables
106874>>>        Decrement iTables
106875>>>        Move 0 to iTable
106876>>>        Move TheData[iTable].hTable to hTable
106877>>>
106877>>>        Get Seq_Open_Output_Channel sSourceFile to iCh
106878>>>        If (iCh = DF_SEQ_CHANNEL_ERROR) Begin
106880>>>            Function_Return GenerateChannelError
106881>>>        End
106881>>>>
106881>>>
106881>>>        If (hTable < 1 or nVersionNumber <= 0) Begin
106883>>>            Function_Return GenerateUserInputError
106884>>>        End
106884>>>>
106884>>>
106884>>>        Send Initialize_StatusPanel of ghoStatusPanel "The Database Update Framework" "Generating Update Code" ""
106885>>>        Send Start_StatusPanel of ghoStatusPanel
106886>>>        Set pbVisible of ghoProgressBar to True
106887>>>        Set pbVisible of ghoProgressBarOverall to True
106888>>>        Set piMaximum of ghoProgressBarOverall to iTables
106889>>>        
106889>>>        Move CompareTableBooleans.bApiTableUpdateAuto       to bApiTableUpdateAuto
106890>>>        Move CompareTableBooleans.bCompareDate_DateTime     to bCompare_DateTime
106891>>>        Move CompareTableBooleans.bCompareFilelistUppercase to bCompareFilelistUppercase
106892>>>        Move CompareTableBooleans.bCompareIndexAscending    to bCompareIndexAscending
106893>>>        Move CompareTableBooleans.bCompareIndexUppercase    to bCompareIndexUppercase
106894>>>
106894>>>        Get UtilTableOpen of ghoDbUpdateFunctionLibrary hTable "" DF_SHARE to bOpened
106895>>>        Get_Attribute DF_FILE_OPENED of hTable to bOpened
106898>>>        If (bOpened = False) Begin
106900>>>            Send Seq_Close_Channel iCh
106901>>>            Set phTable to hTable
106902>>>            Set psFileName to TheData[iTable].sLogicalName
106903>>>            Function_Return GenerateOpenTableError
106904>>>        End
106904>>>>
106904>>>
106904>>>        Writeln channel iCh "/" "/ " CS_DatabaseUpdateFramework
106909>>>        Writeln channel iCh ("/" + "/ Created by: 'DUF Update Code Generator'. Created:" * String(dtCreationTime))
106912>>>        Writeln channel iCh ("Use cDbUpdateVersion.pkg")
106915>>>        Writeln channel iCh
106917>>>        Writeln channel iCh ("Object oDbUpdateVersion" + String(nVersionNumber) * "is a cDbUpdateVersion")
106920>>>        Writeln channel iCh ("    Set pnVersionNumber to" * String(nVersionNumber))
106923>>>        Writeln channel iCh ("    Procedure OnUpdate")
106926>>>        Writeln channel iCh ("        Boolean bOK")
106929>>>        Writeln channel iCh ("        tAPITableNameInfo APITableNameInfo")
106932>>>        Writeln channel iCh ("        tAPIColumn[]   APIColumns APIColumnEmpty")
106935>>>        Writeln channel iCh ("        tAPIIndex[]    APIIndexes APIIndexEmpty")
106938>>>        Writeln channel iCh ("        tAPIRelation[] APIRelations APIRelationEmpty")
106941>>>        Writeln channel iCh ("        Integer iCount iSegment")
106944>>>        Writeln channel iCh ("        Handle hTable")
106947>>>        Writeln channel iCh
106949>>>        Writeln channel iCh ("        Set pbUseConnectionID       to" * If(bUseConnectionID, "True", "False"))
106952>>>        Writeln channel iCh ("        Set pbToAnsi                to" * If(bANSI, "True", "False"))
106955>>>        Writeln channel iCh ("        Set pbRecnum                to" * If(bRecnum, "True", "False"))
106958>>>        Writeln channel iCh ("        Set pbApiTableUpdateAuto    to" * If(bApiTableUpdateAuto, "True", "False"))
106961>>>        Writeln channel iCh ("        Set pbCompareDate_DateTime  to" * If(bCompare_DateTime, "True", "False"))
106964>>>        Writeln channel iCh ("        Set pbCompareIndexAscending to" * If(bCompareIndexAscending, "True", "False"))
106967>>>        Writeln channel iCh ("        Set pbCompareIndexUppercase to" * If(bCompareIndexUppercase, "True", "False"))
106970>>>        Writeln channel iCh
106972>>>        Writeln channel iCh ("        Set Allow_Cancel_State of ghoStatusPanel  to False")
106975>>>        Writeln channel iCh ("        Set pbVisible    of ghoProgressBarOverall to True")
106978>>>        Writeln channel iCh ("        Set piPosition   of ghoProgressBarOverall to 0")
106981>>>        Writeln channel iCh ("        Set piMaximum    of ghoProgressBarOverall to" * String(iTables))
106984>>>        Writeln channel iCh ("        Set piAdvanceBy  of ghoProgressBarOverall to 1")
106987>>>        Writeln channel iCh ("        Send DoAdvance   of ghoProgressBarOverall")   
106990>>>        Writeln channel iCh ("        Move 0 to iCount")
106993>>>        Writeln channel iCh
106995>>>
106995>>>        // Create Definitions:
106995>>>        Move 0 to iTable
106996>>>        For iTable from 0 to iTables
107002>>>>
107002>>>            Set piPosition of ghoProgressBarOverall to iTable
107003>>>            Move TheData[iTable].hTable to hTable
107004>>>            Get UtilTableOpen of ghoDbUpdateFunctionLibrary hTable "" DF_SHARE to bOpened
107005>>>            Get_Attribute DF_FILE_OPENED of hTable to bOpened
107008>>>            If (bOpened = False) Begin
107010>>>                Send Seq_Close_Channel iCh
107011>>>                Set phTable to hTable
107012>>>                Set psTableName to TheData[iTable].sLogicalName
107013>>>                Function_Return GenerateOpenTableError
107014>>>            End
107014>>>>
107014>>>            
107014>>>            Move (Uppercase(TheData[iTable].sLogicalName) = "DBVERSION") to bSkipTable
107015>>>
107015>>>            If (bSkipTable = False) Begin
107017>>>                Move TheData[iTable].sLogicalName to APITableNameInfo.sLogicalName
107018>>>                Set Action_Text of ghoStatusPanel to ("Number:" * String(APITableNameInfo.iTableNumber) * String(sLogicalName))
107019>>>
107019>>>                Move hTable                       to APITableNameInfo.iTableNumber
107020>>>                Move TheData[iTable].sRootName    to sRootName
107021>>>                Get _TableNameOnly of ghoDbUpdateFunctionLibrary sRootName to sTableName
107022>>>                Move sRootName                    to APITableNameInfo.sRootName
107023>>>
107023>>>                Move TheData[iTable].sDisplayName to APITableNameInfo.sDisplayName
107024>>>                Move TheData[iTable].bIsAlias     to bIsAlias
107025>>>                Move bIsAlias                     to APITableNameInfo.bIsAlias
107026>>>                Get UtilTableIsSQL of ghoDbUpdateFunctionLibrary hTable to APITableNameInfo.bIsSQL
107027>>>
107027>>>                // Get the Driver ID
107027>>>                Get_Attribute DF_FILE_DRIVER of hTable to sDriverID
107030>>>                Get IsDAWSQLDriver of ghoDbUpdateFunctionLibrary sDriverID to bDawSqlDriver
107031>>>                Get IsSQLDriver    of ghoDbUpdateFunctionLibrary sDriverID to bSqlDriver
107032>>>
107032>>>                If (bIsAlias = False) Begin
107034>>>                    Set Action_Text of ghoStatusPanel to ("Number:" * String(APITableNameInfo.iTableNumber) * String(APITableNameInfo.sLogicalName))
107035>>>                    Get UtilColumnsStructFill of ghoDbUpdateFunctionLibrary hTable to APIColumns
107036>>>                    If (APIColumns[0].bError = True) Begin
107038>>>                        Function_Return GenerateError
107039>>>                    End
107039>>>>
107039>>>                    If (APIColumns[0].bCancel = True) Begin
107041>>>                        Function_Return GenerateUserCancel
107042>>>                    End
107042>>>>
107042>>>                    Move (SizeOfArray(APIColumns)) to iSize
107043>>>                    Decrement iSize
107044>>>                    If (iSize >= 0) Begin
107046>>>                        Writeln channel iCh ("        // Logical Table Name:" * '"' + APITableNameInfo.sLogicalName + '"' * "Filelist.cfg Number:" * String(APITableNameInfo.iTableNumber))
107049>>>                        Writeln channel iCh ("        Move" * String(APITableNameInfo.iTableNumber)                    * "to APITableNameInfo.iTableNumber")
107052>>>                        Writeln channel iCh ("        Move" * '"' + String(APITableNameInfo.sRootName)    + '"'        * "to APITableNameInfo.sRootName")
107055>>>                        Writeln channel iCh ("        Move" * '"' + String(APITableNameInfo.sLogicalName) + '"'        * "to APITableNameInfo.sLogicalName")
107058>>>                        Writeln channel iCh ("        Move" * '"' + String(APITableNameInfo.sDisplayName) + '"'        * "to APITableNameInfo.sDisplayName")
107061>>>                        Writeln channel iCh ("        Move" * '"' + String(sDriverID)                     + '"'        * "to APITableNameInfo.sDriverID")
107064>>>                        Writeln channel iCh ("        Move" * String(If(APITableNameInfo.bIsAlias,      "True", "False")) * "to APITableNameInfo.bIsAlias")
107067>>>                        Writeln channel iCh ("        Move" * String(If(APITableNameInfo.bIsSQL,        "True", "False")) * "to APITableNameInfo.bIsSQL")
107070>>>                        Writeln channel iCh ("        Move" * String(If(APITableNameInfo.bIsSystemFile, "True", "False")) * "to APITableNameInfo.bIsSystemFile")
107073>>>                        Writeln channel iCh
107075>>>                        Writeln channel iCh ("        // Table:" * '"' + APITableNameInfo.sLogicalName + '"' * "Column: 1")
107078>>>                    End
107078>>>>
107078>>>
107078>>>                    For iCount from 0 to iSize
107084>>>>
107084>>>                        Writeln channel iCh ("        Move" *       String(APIColumns[iCount].iFieldNumber)       * "to APIColumns[iCount].iFieldNumber")
107087>>>                        Writeln channel iCh ("        Move" * '"' + String(APIColumns[iCount].sFieldName)   + '"' * "to APIColumns[iCount].sFieldName")
107090>>>                        Writeln channel iCh ("        Move" *       String(APIColumns[iCount].iType)              * "to APIColumns[iCount].iType")
107093>>>                        Writeln channel iCh ("        Move" * String(If(APIColumns[iCount].bIsSQLType, "True", "False")) * "to APIColumns[iCount].bIsSQLType")
107096>>>                        Writeln channel iCh ("        Move" * String(If(APIColumns[iCount].bAllowNULL, "True", "False")) * "to APIColumns[iCount].bAllowNULL")
107099>>>                        Writeln channel iCh ("        Move" * '"' + String(APIColumns[iCount].sDefaultValue) + '"'       * "to APIColumns[iCount].sDefaultValue")
107102>>>                        If (APIColumns[iCount].iFieldNumber = 0 and APIColumns[iCount].iLength = 0) Begin
107104>>>                            Writeln channel iCh ("        ERROR! This field has a length = 0! It must be corrected before running this code")
107107>>>                            Increment iErrors
107108>>>                        End
107108>>>>
107108>>>                        Move APIColumns[iCount].sType to sDataType
107109>>>                        If (Lowercase(sDataType) contains "identity") Begin
107111>>>                            Move (Replace("identity",sDataType, "")) to sDataType
107112>>>                            Move (Trim(sDataType)) to sDataType
107113>>>                        End
107113>>>>
107113>>>                        Writeln channel iCh ("        Move" * '"' + sDataType                               + '"' * "to APIColumns[iCount].sType")
107116>>>                        Writeln channel iCh ("        Move" *       String(APIColumns[iCount].iLength)            * "to APIColumns[iCount].iLength")
107119>>>                        Writeln channel iCh ("        Move" *       String(APIColumns[iCount].iPrecision)         * "to APIColumns[iCount].iPrecision")
107122>>>                        Writeln channel iCh ("        Move" *       String(APIColumns[iCount].iOptions)           * "to APIColumns[iCount].iOptions")
107125>>>
107125>>>                        If (iCount < iSize) Begin
107127>>>                            Writeln channel iCh ("        Increment iCount")
107130>>>                            Writeln channel iCh
107132>>>                            Writeln channel iCh ("        // Table:" * '"' + APITableNameInfo.sLogicalName + '"' * "Column:" * String(iCount + 2))
107135>>>                        End
107135>>>>
107135>>>                    Loop
107136>>>>
107136>>>
107136>>>                    // Create Index Definitions:
107136>>>                    Get UtilIndexesStructFill of ghoDbUpdateFunctionLibrary hTable to APIIndexes
107137>>>                    If (APIIndexes[0].bError = True) Begin
107139>>>                        Function_Return GenerateError
107140>>>                    End
107140>>>>
107140>>>                    If (APIIndexes[0].bCancel = True) Begin
107142>>>                        Function_Return GenerateUserCancel
107143>>>                    End
107143>>>>
107143>>>                    Move (SizeOfArray(APIIndexes)) to iIndexes
107144>>>                    Decrement iIndexes
107145>>>                    If (iIndexes >= 0) Begin
107147>>>                        Writeln channel iCh
107149>>>                        Writeln channel iCh ("        // Table:" * '"' + APITableNameInfo.sLogicalName + '"' * "Index: 1")
107152>>>                        Writeln channel iCh ("        Move 0 to iCount")
107155>>>                        Writeln channel iCh ("        Move 0 to iSegment")
107158>>>                    End
107158>>>>
107158>>>                    For iIndex from 0 to iIndexes
107164>>>>
107164>>>                        Writeln channel     iCh ("        Move" *       String(APIIndexes[iIndex].iIndexNumber)        * "to APIIndexes[iCount].iIndexNumber")
107167>>>                        Writeln channel     iCh ("        Move" *       String(APIIndexes[iIndex].iPrimaryIndex)       * "to APIIndexes[iCount].iPrimaryIndex")
107170>>>                        Writeln channel     iCh ("        Move" *       String(APIIndexes[iIndex].iSQLIndexType)       * "to APIIndexes[iCount].iSQLIndexType")
107173>>>                        Writeln channel     iCh ("        Move" *       If((APIIndexes[iIndex].bIsSQLClustered),  "True", "False") * "to APIIndexes[iCount].bIsSQLClustered")
107176>>>                        Writeln channel     iCh ("        Move" *       If((APIIndexes[iIndex].bIsSQLPrimaryKey), "True", "False") * "to APIIndexes[iCount].bIsSQLPrimaryKey")
107179>>>                        If (APIIndexes[iIndex].sSQLIndexName <> "") Begin
107181>>>                            Writeln channel iCh ("        Move" * '"' + String(APIIndexes[iIndex].sSQLIndexName) + '"' * "to APIIndexes[iCount].sSQLIndexName")
107184>>>                        End
107184>>>>
107184>>>
107184>>>                        Move (SizeOfArray(APIIndexes[iIndex].IndexSegmentArray)) to iNumSegments
107185>>>                        Decrement iNumSegments
107186>>>                        For iSegment from 0 to iNumSegments
107192>>>>
107192>>>                            Writeln channel iCh ("        Move" *       String(APIIndexes[iIndex].IndexSegmentArray[iSegment].iFieldNumber)              * "to APIIndexes[iCount].IndexSegmentArray[iSegment].iFieldNumber")
107195>>>                            Writeln channel iCh ("        Move" * '"' + String(APIIndexes[iIndex].IndexSegmentArray[iSegment].sFieldName)          + '"' * "to APIIndexes[iCount].IndexSegmentArray[iSegment].sFieldName")
107198>>>                            Writeln channel iCh ("        Move" *       If((APIIndexes[iIndex].IndexSegmentArray[iSegment].bUppercase), "True", "False") * "to APIIndexes[iCount].IndexSegmentArray[iSegment].bUppercase")
107201>>>                            Writeln channel iCh ("        Move" *       If((APIIndexes[iIndex].IndexSegmentArray[iSegment].bAscending), "True", "False") * "to APIIndexes[iCount].IndexSegmentArray[iSegment].bAscending")
107204>>>                            If (iSegment < iNumSegments) Begin
107206>>>                                Writeln channel iCh ("        Increment iSegment")
107209>>>                            End
107209>>>>
107209>>>                        Loop
107210>>>>
107210>>>
107210>>>                        If (iIndex < iIndexes) Begin
107212>>>                            Writeln channel iCh ("        Increment iCount")
107215>>>                            Writeln channel iCh
107217>>>                            Writeln channel iCh ("        // Table:" * '"' + APITableNameInfo.sLogicalName + '"' * "Index:" * String(iIndex + 2))
107220>>>                            Writeln channel iCh ("        Move 0 to iSegment")
107223>>>                        End
107223>>>>
107223>>>                    Loop
107224>>>>
107224>>>
107224>>>                    // Create Relation Definitions:
107224>>>                    Get UtilRelationsStructFill of ghoDbUpdateFunctionLibrary hTable to APIRelations
107225>>>                    If (APIRelations[0].bError = True) Begin
107227>>>                        Function_Return GenerateError
107228>>>                    End
107228>>>>
107228>>>                    If (APIRelations[0].bCancel = True) Begin
107230>>>                        Function_Return GenerateUserCancel
107231>>>                    End
107231>>>>
107231>>>                    Move (SizeOfArray(APIRelations)) to iSize
107232>>>                    Decrement iSize
107233>>>                    If (iSize >= 0) Begin
107235>>>                        Writeln channel iCh
107237>>>                        Writeln channel iCh ("        // Table:" * '"' + APITableNameInfo.sLogicalName + '"' * "Relation: 1")
107240>>>                        Writeln channel iCh ("        Move 0 to iCount")
107243>>>                    End
107243>>>>
107243>>>                    For iCount from 0 to iSize
107249>>>>
107249>>>                        Writeln channel iCh ("        Move" * String(APIRelations[iCount].hTableFrom)  * "to APIRelations[iCount].hTableFrom")
107252>>>                        Writeln channel iCh ("        Move" * String(APIRelations[iCount].iColumnFrom) * "to APIRelations[iCount].iColumnFrom")
107255>>>                        Writeln channel iCh ("        Move" * String(APIRelations[iCount].hTableTo)    * "to APIRelations[iCount].hTableTo")
107258>>>                        Writeln channel iCh ("        Move" * String(APIRelations[iCount].iColumnTo)   * "to APIRelations[iCount].iColumnTo")
107261>>>                        If (iCount < iSize) Begin
107263>>>                            Writeln channel iCh ("        Increment iCount")
107266>>>                            Writeln channel iCh
107268>>>                            Writeln channel iCh ("        // Table:" * '"' + APITableNameInfo.sLogicalName + '"' * "Relation:" * String(iCount + 2))
107271>>>                        End
107271>>>>
107271>>>                    Loop
107272>>>>
107272>>>
107272>>>                    // Create Table Update Definition:
107272>>>                    Writeln channel iCh
107274>>>                    Writeln channel iCh ("        Get ApiTableUpdate APITableNameInfo APIColumns APIIndexes APIRelations to bOK")
107277>>>                    Writeln channel iCh
107279>>>
107279>>>                    Writeln channel iCh ("        Move APIColumnEmpty   to APIColumns")
107282>>>                    Writeln channel iCh ("        Move APIRelationEmpty to APIRelations")
107285>>>                    Writeln channel iCh ("        Move APIIndexEmpty    to APIIndexes")
107288>>>                    Writeln channel iCh ("        Move 0 to iCount")
107291>>>                    Writeln channel iCh ("        Send DoAdvance of ghoProgressBarOverall")
107294>>>                    Writeln channel iCh
107296>>>                End
107296>>>>
107296>>>
107296>>>                If (bIsAlias = True) Begin
107298>>>                    // Create Alias Table Definition:
107298>>>                    Writeln channel iCh ("        // Create Alias Table Definition:")
107301>>>                    Writeln channel iCh ("        Move" * String(hTable) * "to hTable")
107304>>>                    If (bSqlDriver = True and not(APITableNameInfo.sRootName contains sDriverID)) Begin
107306>>>                        Writeln channel iCh ("        Set_Attribute DF_FILE_ROOT_NAME    of hTable to" * '"' + sDriverID + ":" + APITableNameInfo.sRootName    + '"')
107309>>>                    End
107309>>>>
107309>>>                    Else Begin
107310>>>                        Writeln channel iCh ("        Set_Attribute DF_FILE_ROOT_NAME    of hTable to" * '"' + APITableNameInfo.sRootName    + '"')
107313>>>                    End
107313>>>>
107313>>>
107313>>>                    Writeln channel iCh ("        Set_Attribute DF_FILE_LOGICAL_NAME of hTable to" * '"' + APITableNameInfo.sLogicalName + '"')
107316>>>                    Writeln channel iCh ("        Set_Attribute DF_FILE_DISPLAY_NAME of hTable to" * '"' + APITableNameInfo.sDisplayName + '"')
107319>>>                    Writeln channel iCh
107321>>>                End
107321>>>>
107321>>>            End
107321>>>>
107321>>>            Get Check_StatusPanel of ghoStatusPanel to iStatus
107322>>>            If (iStatus <> 0) Begin
107324>>>                Send Seq_Close_Channel iCh
107325>>>                Function_Return GenerateUserCancel
107326>>>            End         
107326>>>>
107326>>>            
107326>>>            Close hTable
107327>>>        Loop // Main TheData loop
107328>>>>
107328>>>
107328>>>        Writeln channel iCh ("    End_Procedure")
107331>>>        Writeln channel iCh ("End_Object")
107334>>>
107334>>>        Send Seq_Close_Channel iCh
107335>>>        Function_Return GenerateOK
107336>>>    End_Function
107337>>>
107337>>>    Function DFTypeToDUFType Integer iDataFlexDataType Returns String
107340>>>        String sRetval
107340>>>        Case Begin
107340>>>            Case (iDataFlexDataType = DF_ASCII)
107342>>>                Move DF_ASCII_DUF to sRetval
107343>>>                Case Break
107344>>>            Case (iDataFlexDataType = DF_BCD)
107347>>>                Move "DF_BCD_DUF" to sRetval
107348>>>                Case Break
107349>>>            Case (iDataFlexDataType = DF_BINARY)
107352>>>                Move "DF_BINARY_DUF" to sRetval
107353>>>                Case Break
107354>>>            Case (iDataFlexDataType = DF_DATE)
107357>>>                Move "DF_DATE_DUF" to sRetval
107358>>>                Case Break
107359>>>            Case (iDataFlexDataType = DF_DATETIME)
107362>>>                Move "DF_DATETIME_DUF" to sRetval
107363>>>                Case Break
107364>>>            Case (iDataFlexDataType = DF_TEXT)
107367>>>                Move "DF_TEXT_DUF" to sRetval
107368>>>                Case Break
107369>>>            Case Else
107369>>>                Move iDataFlexDataType to sRetval
107370>>>        Case End
107370>>>
107370>>>        Function_Return sRetval
107371>>>    End_Function
107372>>>
107372>>>    Procedure Request_Clear    
107375>>>        tSQLConnection Connection
107375>>>        tSQLConnection Connection
107375>>>        tDataSourceRow[] EmptyData
107375>>>        tDataSourceRow[] EmptyData
107376>>>        Handle hoGrid hoDataSource
107376>>>        Integer[] iDifferencesEmpty
107377>>>        
107377>>>        Move DATAFLEX_ID to Connection.sDriverID
107378>>>        Set pSQLConnection of ghoSQLConnectionHandler to Connection
107379>>>        Move (oFilelist_grd(Self))  to hoGrid
107380>>>        Get phoDataSource of hoGrid to hoDataSource
107381>>>        Send InitializeData of hoGrid EmptyData
107382>>>        Send ResetFilelistPathing of ghoApplication
107383>>>        Set Value of oFilelistPath_fm    to ""
107384>>>        Set Value of oPnVersionNumber_fm to 1.0
107385>>>        Set Value of oSourceName_fm      to ""
107386>>>        Set phDbVersion of oFilelist_grd to 0
107387>>>        Set psFilelistFrom of ghoApplication to ""
107388>>>        Set psFooterText of oLogicalName_col to "No of Tables:"
107389>>>        Set psFooterText of oRootName_col    to "Selected:"
107390>>>        Set psFooterText of oIsAlias_Col     to "Alias:"
107391>>>        Send Activate of oFilelistPath_fm    
107392>>>    End_Procedure
107393>>>
107393>>>    Procedure TagChangedTables String sFromFilelist Integer[] iaDifferences
107396>>>        Integer iSize iCount iItem iItems iTableNo iTableNo_Col iCheckbox_Col
107396>>>        Handle hoGrid hoDataSource
107396>>>        tDataSourceRow[] TheData
107396>>>        tDataSourceRow[] TheData
107397>>>
107397>>>        Set Value of oFilelistPath_fm to sFromFilelist
107398>>>        Move (oFilelist_grd(Self)) to hoGrid
107399>>>
107399>>>        Get piColumnId of (oFilelistNumber_col(hoGrid)) to iTableNo_Col
107400>>>        Get piColumnId of (oCheckbox_Col(hoGrid))       to iCheckbox_Col
107401>>>        Get phoDataSource of hoGrid to hoDataSource
107402>>>        Get DataSource of hoDataSource to TheData
107403>>>        Move (SizeOfArray(TheData)) to iItems
107404>>>        Decrement iItems
107405>>>
107405>>>        Move (SizeOfArray(iaDifferences)) to iSize
107406>>>        If (iSize = 0) Begin
107408>>>            Procedure_Return
107409>>>        End
107409>>>>
107409>>>        Decrement iSize
107410>>>        If (iSize > 0) Begin
107412>>>//            Send KeyAction of oDeSelectAll_btn  
107412>>>            Set SelectItems of oFilelist_grd to cx_Select_None
107413>>>        End
107413>>>>
107413>>>
107413>>>        For iCount from 0 to iSize
107419>>>>
107419>>>            Move iaDifferences[iCount] to iTableNo
107420>>>            If (iTableNo > 0) Begin
107422>>>                For iItem from 0 to iItems
107428>>>>
107428>>>                    If (TheData[iItem].sValue[iTableNo_Col] = iTableNo) Begin
107430>>>                        Move True to TheData[iItem].sValue[iCheckbox_Col]
107431>>>                        Move iItems to iItem // We found it and we're out of this loop.
107432>>>                    End
107432>>>>
107432>>>                Loop
107433>>>>
107433>>>            End
107433>>>>
107433>>>        Loop
107434>>>>
107434>>>
107434>>>        Send ReInitializeData of hoGrid TheData False
107435>>>        Send DoSetCheckboxFooterText of hoGrid
107436>>>    End_Procedure
107437>>>
107437>>>    Procedure OnSetFocus
107440>>>        If (SizeOfArray(phoActiveUpdates(ghoCommandBars)) <> 0) Begin
107442>>>            Send Execute of (oCodeGenerator_MenuItem(ghoCommandBars))
107443>>>        End
107443>>>>
107443>>>    End_Procedure
107444>>>    
107444>>>    Procedure OnFileDropped String sFilename Boolean bLast
107447>>>        String sTest
107447>>>        Forward Send OnFileDropped sFilename bLast
107449>>>        If (bLast = True) Begin
107451>>>            Get ParseFileName sFilename to sTest
107452>>>            If (Uppercase(sTest) <> "FILELIST.CFG") Begin
107454>>>                Send Info_Box "Sorry, only Filist.cfg files can be dropped here..."
107455>>>                Procedure_Return
107456>>>            End
107456>>>>
107456>>>            Set Value of oFilelistPath_fm to sFilename
107457>>>        End
107457>>>>
107457>>>    End_Procedure
107458>>>
107458>>>//    On_Key Key_Ctrl+Key_A  Send KeyAction of oSelectAll_btn
107458>>>//    On_Key Key_Ctrl+Key_N  Send KeyAction of oDeSelectAll_btn
107458>>>//    On_Key Key_Ctrl+Key_I  Send KeyAction of oInvertSelection_btn
107458>>>    On_Key Key_Ctrl+Key_G  Send KeyAction of oGenerateCode_btn
107459>>>    On_Key Key_Ctrl+Key_O  Send KeyAction of oOpenAppSrcFolder_btn
107460>>>    On_Key kClear          Send Request_Clear
107461>>>    On_Key kClear_All      Send Request_Clear
107462>>>    On_Key Key_Ctrl+Key_F4 Send None
107463>>>End_Object
107464>>>
107464>>>// General purpose access message to auto-fill grid with tables with
107464>>>// differences (after "Compare Databases" has been run).
107464>>>Procedure TagFileNamesForCodeGeneration
107467>>>    String sFileListFrom sCurrentFilelist
107467>>>    Integer[] iaDifferences
107468>>>    Handle ho
107468>>>
107468>>>    Send Activate_oTableDUFCodeGenerator
107469>>>    Move (oTableDUFCodeGenerator(Self)) to ho
107470>>>    Get Value of (oFilelistPath_fm(ho)) to sCurrentFilelist
107471>>>    If (sCurrentFilelist <> "") Begin
107473>>>        Send Request_Clear of ho
107474>>>    End
107474>>>>
107474>>>
107474>>>    Get psFilelistFrom of ghoApplication to sFileListFrom
107475>>>    Get piaDifferences of ghoApplication to iaDifferences
107476>>>    Send TagChangedTables of ho sFileListFrom iaDifferences
107477>>>    Send Info_Box ("Ready marking tables. Number of different tables:" * (String(SizeOfArray(iaDifferences))))
107478>>>End_Procedure
107479>        Use CompareDatabases.vw
Including file: CompareDatabases.vw    (C:\Projects\DF20\DbUpdateFramework\AppSrc\CompareDatabases.vw)
107479>>>Use Windows.pkg
107479>>>Use Dfclient.pkg
107479>>>Use Cursor.pkg
107479>>>Use Batchdd.pkg
107479>>>Use cRDCButton.pkg
107479>>>Use cDbUpdateFunctionLibrary.pkg
107479>>>Use DUFStatusPanel.pkg
107479>>>Use seq_chnl.pkg
107479>>>Use vWin32fh.pkg
107479>>>Use cRDCHeaderGroup.pkg
107479>>>Use cRDCSuggestionIniForm.pkg
107479>>>Use cSQLCheckBox.pkg
107479>>>Use cRDCCommandLinkButton.pkg
107479>>>Use LogFileDialog.dg
Including file: LogFileDialog.dg    (C:\Projects\DF20\DbUpdateFramework\AppSrc\LogFileDialog.dg)
107479>>>>>Use Windows.pkg
107479>>>>>Use cRDCButtonDPI.pkg
107479>>>>>Use cRichEdit.pkg
107479>>>>>Use seq_chnl.pkg
107479>>>>>Use vWin32fh.pkg
107479>>>>>
107479>>>>>Object oLogFileDialog_dg is a ModalPanel
107481>>>>>    Set Size to 230 435
107482>>>>>    Set Label to "Log File Dialog"
107483>>>>>    Set piMinSize to 89 211
107484>>>>>    Set Location to 2 2
107485>>>>>    Set Border_Style To Border_Thick
107486>>>>>    Set Locate_Mode to Center_On_Parent
107487>>>>>    
107487>>>>>    Property String psLogFileName ""  
107489>>>>>    Property Integer piIndent 
107491>>>>>    
107491>>>>>    Object oLogFile_edt is a cRichEdit
107493>>>>>        Set Size to 185 413
107494>>>>>        Set Location to 16 11
107495>>>>>        Set TextColor to clBlack
107496>>>>>        Set peAnchors to anAll
107497>>>>>        Set Label_Row_Offset to 3
107498>>>>>        Set Label_TextColor to clGreenGreyLight
107499>>>>>        Set Label_FontItalics to True
107500>>>>>        Set piFontSize to 200
107501>>>>>        Set psTypeFace to 'Consolas'
107502>>>>>        
107502>>>>>        Delegate Set piIndent to (piParagraphIndent(Self))
107504>>>>>        
107504>>>>>        Procedure DoSaveDocument
107507>>>>>            String sLogFileName
107507>>>>>            Boolean bOk bOkToSave bChanged
107507>>>>>        
107507>>>>>            Move False to bOkToSave       
107508>>>>>            Get pbCanUndo to bChanged
107509>>>>>            If (bChanged = False) Begin
107511>>>>>                Procedure_Return
107512>>>>>            End
107512>>>>>>
107512>>>>>        
107512>>>>>            Get psLogFileName to sLogFileName
107513>>>>>            Send Write sLogFileName
107514>>>>>            // clear undo buffer on save
107514>>>>>            // we want undo buffer to only apply to the new document
107514>>>>>            Send ClearUndoBuffer
107515>>>>>            Send Info_Box "Changes saved."
107516>>>>>        End_Procedure 
107517>>>>>        
107517>>>>>        Procedure LoadData
107520>>>>>            String sLogFileName
107520>>>>>            Integer iTwips iIndent
107520>>>>>    
107520>>>>>            Get psLogFileName to sLogFileName
107521>>>>>            Set Label to sLogFileName
107522>>>>>            Move 1440 to iTwips
107523>>>>>            Get piIndent to iIndent
107524>>>>>            Set piParagraphIndent to (iIndent + (iTwips * 0.2))
107525>>>>>            
107525>>>>>            Send Read sLogFileName
107526>>>>>        End_Procedure
107527>>>>>    
107527>>>>>        On_Key Key_Ctrl+Key_S Send DoSaveDocument
107528>>>>>        On_Key kCancel Send Cancel
107529>>>>>    End_Object
107530>>>>>
107530>>>>>    Object oCancel_Btn is a cRDCButtonDPI
107532>>>>>        Set Label    to "&Close"
107533>>>>>        Set Location to 209 374
107534>>>>>        Set peAnchors to anBottomRight
107535>>>>>
107535>>>>>        Procedure OnClick
107538>>>>>            Send Close_Panel
107539>>>>>        End_Procedure
107540>>>>>
107540>>>>>    End_Object
107541>>>>>
107541>>>>>
107541>>>>>    Object oFirstRun_btn is a cRDCButtonDPI
107543>>>>>        Set Location to 209 260
107544>>>>>        Set Label to "Beginning"
107545>>>>>        Set peAnchors to anBottomRight
107546>>>>>    
107546>>>>>        Procedure OnClick
107549>>>>>            Send Beginning_of_Data to oLogFile_edt    
107550>>>>>        End_Procedure
107551>>>>>    
107551>>>>>    End_Object
107552>>>>>    Object oLatestRun_btn is a cRDCButtonDPI
107554>>>>>        Set Location to 209 317
107555>>>>>        Set Label to "End"
107556>>>>>        Set peAnchors to anBottomRight
107557>>>>>    
107557>>>>>        Procedure OnClick
107560>>>>>            Send End_of_Data to oLogFile_edt    
107561>>>>>        End_Procedure
107562>>>>>    
107562>>>>>    End_Object
107563>>>>>
107563>>>>>    // Automatically load data into the grid when activating.
107563>>>>>    Procedure Activating 
107566>>>>>        Handle ho
107566>>>>>        Move (oLogFile_edt(Self)) to ho
107567>>>>>        Send LoadData    of ho
107568>>>>>        // We need to active before we can send end_of_data.
107568>>>>>        Send Activate    of ho
107569>>>>>//        Send End_of_Data to ho
107569>>>>>    End_Procedure
107570>>>>>
107570>>>>>    Procedure Page Integer iPageObject
107573>>>>>        Forward Send Page iPageObject
107575>>>>>        Set Icon to "ViewReportBlack1.ico"
107576>>>>>    End_Procedure      
107577>>>>>    
107577>>>>>    // Put a status bar at the bottom of the panel to add a gripper in the lower right corner.
107577>>>>>    Procedure End_Construct_Object
107580>>>>>        Integer iStyle iSize iOffset
107580>>>>>
107580>>>>>        Forward Send End_Construct_Object
107582>>>>>
107582>>>>>        Get Border_Style to iStyle
107583>>>>>        Move 8 to iOffset
107584>>>>>        If (iStyle = Border_Thick) Begin
107586>>>>>            Object oDialogCommandbar is a cCJCommandBarSystem
107588>>>>>                Object oStatusBar is a cCJStatusBar
107590>>>>>                    Object oStatusIdle is a cCJStatusBarPane
107592>>>>>                        Set piId to sbpIDIdlePane
107593>>>>>                        Set pbStyleStretch to True
107594>>>>>                    End_Object
107595>>>>>                End_Object
107596>>>>>            End_Object
107597>>>>>
107597>>>>>            Get Size to iSize
107598>>>>>            Set Size to (Hi(iSize) + iOffset) (Low(iSize))
107599>>>>>        End
107599>>>>>>
107599>>>>>    End_Procedure
107600>>>>>
107600>>>>>    On_Key Key_Alt+Key_F  Send KeyAction of oFirstRun_btn
107601>>>>>    On_Key Key_Ctrl+Key_F Send KeyAction of oFirstRun_btn
107602>>>>>    On_Key Key_Alt+Key_L  Send KeyAction of oLatestRun_btn
107603>>>>>    On_Key Key_Ctrl+Key_L Send KeyAction of oLatestRun_btn
107604>>>>>    On_Key Key_Alt+Key_C  Send KeyAction of oCancel_Btn
107605>>>>>End_Object
107606>>>>>
107606>>>>>Procedure ActivateLogFileDialog String sLogFile
107609>>>>>    Handle ho       
107609>>>>>    Boolean bExists
107609>>>>>    
107609>>>>>    Get vFilePathExists sLogFile to bExists
107610>>>>>    If (bExists = False) Begin
107612>>>>>        Send Info_Box "The logfile doesn't exist."
107613>>>>>        Procedure_Return
107614>>>>>    End
107614>>>>>>
107614>>>>>    Move (oLogFileDialog_dg(Self)) to ho
107615>>>>>    Set psLogFileName of ho to sLogFile
107616>>>>>    Send Popup of ho
107617>>>>>End_Procedure           
107618>>>
107618>>>Define CS_ReportFileName                for "DUFCompareReport"
107618>>>Define CS_ReportFileNameExtenstion      for ".txt"
107618>>>Define CS_ReportDifferenceNote          for "(*)"
107618>>>Define CS_ReportTableNotFound           for "Table doesn't exist!"
107618>>>Define CS_ReportFieldNotFound           for "Field doesn't exist!"
107618>>>Define CS_ReportIndexNotFound           for "Index doesn't exist!"
107618>>>Define CS_ReportIndexSegmentNotFound    for "Index segment doesn't exist!"
107618>>>Define CS_ReportIndexNotApplicable      for "N/A"
107618>>>Define CS_ReportRelationNotFound        for "Relationship doesn't exist!"
107618>>>Define CS_ReportHeaderUnderWrite        for "===================================================================================="
107618>>>
107618>>>Define CI_ReportColumn1                 for 17
107618>>>Define CI_ReportColumn2                 for 65
107618>>>//Define CI_ReportColumn3                 for 75
107618>>>//Define CI_ReportColumn4                 for 90
107618>>>
107618>>>Struct tRelationDiffs
107618>>>    String sFromFieldsRight
107618>>>    String sFromFields
107618>>>    String sToFields
107618>>>    String sFrom
107618>>>    String sTo
107618>>>End_Struct
107618>>>
107618>>>Global_Variable Integer giDifferenceTables
107618>>>
107618>>>Activate_View Activate_oCompareDatabases_vw for oCompareDatabases_vw
107628>>>>
107628>>>Object oCompareDatabases_vw is a dbView
107630>>>    Set Size to 323 490
107631>>>    Set Label to "Compare"
107632>>>    Set piMinSize to 89 211
107633>>>    Set Border_Style To Border_Thick
107634>>>    Set pbAutoActivate to True
107635>>>    Set pbAcceptDropFiles to True
107636>>>
107636>>>    Object oFromFilelist_grp is a cRDCHeaderGroup
107638>>>        Set Size to 50 462
107639>>>        Set Location to 8 15
107640>>>        Set psImage to "FolderLeft1.ico"
107641>>>        Set Label to "Select FROM Filelist.cfg"
107642>>>        Set psNote to "The development/latest version of the database"  
107643>>>        Set psToolTip to "Select the Filelist.cfg file for the development database"
107644>>>
107644>>>        Object oFilelistPathFrom_fm is a cRDCSuggestionIniForm
107646>>>            Set Size to 12 413
107647>>>            Set Location to 29 29
107648>>>            Set Label_Col_Offset to 0
107649>>>            Set Label_Row_Offset to 1
107650>>>            Set Label_Justification_Mode to JMode_Top
107651>>>            Set Prompt_Button_Mode to PB_PromptOn
107652>>>            Set peAnchors to anTopLeftRight
107653>>>            Set psToolTip to "Select the FROM database Filelist.cfg. This should be the development workspace Data folder's Filelist.cfg"
107654>>>            // This is needed for the toolbar's prompt icon to be active
107654>>>            Set Prompt_Object to Self
107655>>>
107655>>>            Procedure Prompt
107658>>>                String sFileName sPath sFileMask sRetval
107658>>>
107658>>>                Get Value to sFileName
107659>>>                Get ParseFolderName sFileName to sPath
107660>>>                Move "Filelist.cfg files (*.cfg)|*.cfg" to sFileMask
107661>>>                Get vSelect_File sFileMask "Please select a Filelist.cfg file" sPath to sRetval
107662>>>                If (sRetval <> "") Begin
107664>>>                    Set Value to sRetval
107665>>>                End
107665>>>>
107665>>>            End_Procedure
107666>>>
107666>>>            Procedure OnChange
107669>>>                String sValue
107669>>>                Boolean bOK bCfgFile
107669>>>
107669>>>                Get Value to sValue
107670>>>                Get vFilePathExists sValue to bOK
107671>>>                Move (Lowercase(sValue) contains ".cfg") to bCfgFile
107672>>>                If (bOK = True and bCfgFile) Begin
107674>>>                    Get ChangeFilelistPathing of ghoApplication sValue to bOK
107675>>>                    If (bOK = True) Begin
107677>>>                        Set psFilelistFrom of ghoApplication to sValue
107678>>>                    End
107678>>>>
107678>>>                End
107678>>>>
107678>>>
107678>>>            End_Procedure
107679>>>
107679>>>            On_Key Key_Ctrl+Key_W Send None
107680>>>            On_Key Key_Ctrl+Key_Q Send None
107681>>>        End_Object
107682>>>
107682>>>    End_Object
107683>>>
107683>>>    Object oToFilelist_grp is a cRDCHeaderGroup
107685>>>        Set Size to 50 462
107686>>>        Set Location to 69 15
107687>>>        Set psImage to "FolderRight1.ico"
107688>>>        Set Label to "Select TO Filelist.cfg"
107689>>>        Set psNote to "The customer/current version of the database"   
107690>>>        Set psToolTip to "Select the Filelist.cfg file for the database that needs to be updated"
107691>>>
107691>>>        Object oFilelistPathTo_fm is a cRDCSuggestionIniForm
107693>>>            Set Size to 12 413
107694>>>            Set Location to 29 28
107695>>>            Set Label_Col_Offset to 0
107696>>>            Set Label_Row_Offset to 1
107697>>>            Set Label_Justification_Mode to JMode_Top
107698>>>            Set Prompt_Button_Mode to PB_PromptOn
107699>>>            Set peAnchors to anTopLeftRight
107700>>>            Set psToolTip to "Select the TO database Filelist.cfg"
107701>>>            Set Prompt_Object to Self
107702>>>
107702>>>            Procedure Prompt
107705>>>                String sFileName sPath sFileMask sRetval
107705>>>
107705>>>                Get Value to sFileName
107706>>>                Get ParseFolderName sFileName to sPath
107707>>>                Move "Filelist.cfg files (*.cfg)|*.cfg" to sFileMask
107708>>>                Get vSelect_File sFileMask "Please select a Filelist.cfg file" sPath to sRetval
107709>>>                If (sRetval <> "") Begin
107711>>>                    Set Value to sRetval
107712>>>                End
107712>>>>
107712>>>            End_Procedure
107713>>>
107713>>>            Procedure OnChange
107716>>>                String sValue sPath sReportName sToday
107716>>>                Date dToday
107716>>>                Boolean bOK bCfgFile
107716>>>
107716>>>                Get Value to sValue
107717>>>                Get vFilePathExists sValue to bOK
107718>>>                Move (Lowercase(sValue) contains ".cfg") to bCfgFile
107719>>>                If (bOK = False or bCfgFile = False) Begin
107721>>>                    Procedure_Return
107722>>>                End
107722>>>>
107722>>>
107722>>>                Set psFilelistFrom of ghoApplication to sValue
107723>>>                Sysdate dToday  
107724>>>                Move dToday to sToday
107725>>>                Move (Replaces("/", sToday, "-")) to sToday
107726>>>                Move (Replaces(".", sToday, "-")) to sToday
107727>>>                Get Value to sPath
107728>>>                Get ParseFolderName sPath to sPath
107729>>>                Get vFolderFormat   sPath to sPath
107730>>>                Move (sPath + CS_ReportFileName + String(sToday) + CS_ReportFileNameExtenstion) to sReportName
107731>>>                Set Value of oReportFileName_fm to sReportName
107732>>>            End_Procedure
107733>>>
107733>>>            On_Key Key_Ctrl+Key_W Send None
107734>>>            On_Key Key_Ctrl+Key_Q Send None
107735>>>        End_Object
107736>>>
107736>>>    End_Object
107737>>>
107737>>>    Object oCompareProperties_grp is a cRDCHeaderGroup
107739>>>        Set Size to 59 462
107740>>>        Set Location to 130 15
107741>>>        Set Label to "Configure Database Compare"
107742>>>        Set psNote to "Select checkboxes to configure the comparison"
107743>>>        Set psImage to "Settings1.ico" 
107744>>>        Set psToolTip to "Configure what will be compared"
107745>>>        
107745>>>        Object oCompareDate_DataTime_cb is a cSQLCheckBox
107747>>>            Set Size to 9 123
107748>>>            Set Location to 28 30
107749>>>            Set Label to "Check Date/DataTime difference"
107750>>>            Set psToolTip to "Check Date to DateTime column differences"
107751>>>            Set Checked_State to False
107752>>>        End_Object
107753>>>
107753>>>        Object oCompareIndexAscending_cb is a cSQLCheckBox
107755>>>            Set Size to 9 134
107756>>>            Set Location to 28 199
107757>>>            Set Label to "Check Index Ascending/Descending"
107758>>>            Set Checked_State to False
107759>>>            Set psToolTip to "Compare if Index is Ascending/Descending. (In SQL this setting is set for the whole database by selecting a 'Collation', so then checking this per table doesn't make sense)"
107760>>>        End_Object
107761>>>
107761>>>        Object oCompareIndexUppercase_cb is a cSQLCheckBox
107763>>>            Set Size to 9 117
107764>>>            Set Location to 41 30
107765>>>            Set Label to "Check Index Lower/Uppercase"
107766>>>            Set Checked_State to False
107767>>>            Set psToolTip to "Compare if Index is Uppercase/Lowercase. (In SQL this setting is set for the whole database by selecting a 'Collation', so then checking this per table doesn't make sense)"
107768>>>        End_Object
107769>>>
107769>>>        Object oIgnoreFilelistUppercase_cb is a cSQLCheckBox
107771>>>            Set Size to 9 156
107772>>>            Set Location to 41 199
107773>>>            Set Label to "Ignore Filelist Entries Uppercase/Lowercase"
107774>>>            Set Checked_State to True
107775>>>            Set psToolTip to "Check Filelist.cfg RootName, LogicalName and DisplayName uppercase/lowercase differences"
107776>>>        End_Object
107777>>>
107777>>>    End_Object
107778>>>
107778>>>    Object oReportFilename_grp is a cRDCHeaderGroup
107780>>>        Set Size to 51 462
107781>>>        Set Location to 200 15
107782>>>        Set psImage to "ActionPrintSave1.ico"
107783>>>        Set Label to "Report File Name"
107784>>>        Set psNote to "Output file name"    
107785>>>        Set psToolTip to "The name of the report file that contains the compare result"
107786>>>        
107786>>>        Object oReportFileName_fm is a Form
107788>>>            Set Size to 12 413
107789>>>            Set Location to 29 29
107790>>>            Set Label_Col_Offset to 0
107791>>>            Set Label_Row_Offset to 1
107792>>>            Set Label_Justification_Mode to JMode_Top
107793>>>            Set Prompt_Button_Mode to PB_PromptOn
107794>>>            Set peAnchors to anTopLeftRight
107795>>>            Set psToolTip to "The name of the output text file for database differences that will be generated"
107796>>>            Set Status_Help to "The name of the output text file for database differences that will be generated"
107797>>>            Set Prompt_Object to Self
107798>>>
107798>>>            Procedure Prompt
107801>>>                String sFileName sPath sFileMask sRetval
107801>>>
107801>>>                Get Value to sFileName
107802>>>                Get ParseFolderName sFileName to sPath
107803>>>                Move "Text files (*.txt)|*.txt" to sFileMask
107804>>>                Get vSelect_File sFileMask "Please select a text file for the report" sPath to sRetval
107805>>>                If (sRetval <> "") Begin
107807>>>                    Set Value to sRetval
107808>>>                End
107808>>>>
107808>>>            End_Procedure
107809>>>
107809>>>            On_Key Key_Ctrl+Key_W Send None
107810>>>            On_Key Key_Ctrl+Key_Q Send None
107811>>>        End_Object
107812>>>
107812>>>    End_Object
107813>>>
107813>>>    Procedure MainProcess
107816>>>        String sFilelistFrom sFilelistTo
107816>>>        Integer[] iaDifferences
107817>>>        Integer iSize iRetval hTable
107817>>>        Boolean bFromExists bToExists
107817>>>        tAPITableBooleans CompareCheckBoxes
107817>>>        tAPITableBooleans CompareCheckBoxes
107817>>>        DateTime dtExecStart dtExecEnd
107817>>>        TimeSpan tsTotalTime
107817>>>
107817>>>        Move (CurrentDateTime()) to dtExecStart
107818>>>        Get Value of oFilelistPathFrom_fm to sFilelistFrom
107819>>>        Get vFilePathExists sFilelistFrom to bFromExists
107820>>>        Get Value of oFilelistPathTo_fm   to sFilelistTo
107821>>>        Get vFilePathExists sFilelistTo   to bToExists
107822>>>
107822>>>        If (bFromExists = False or bToExists = False) Begin
107824>>>            Send Info_Box "You first need to select a 'FROM' and a 'TO' Filelist.cfg."
107825>>>            Procedure_Return
107826>>>        End
107826>>>>
107826>>>
107826>>>        Move 0 to giDifferenceTables
107827>>>        Get Checked_State of oCompareDate_DataTime_cb    to CompareCheckBoxes.bCompareDate_DateTime
107828>>>        Get Checked_State of oCompareIndexAscending_cb   to CompareCheckBoxes.bCompareIndexAscending
107829>>>        Get Checked_State of oCompareIndexUppercase_cb   to CompareCheckBoxes.bCompareIndexUppercase
107830>>>        Get Checked_State of oIgnoreFilelistUppercase_cb to CompareCheckBoxes.bCompareFilelistUppercase
107831>>>
107831>>>        Get CompareAndOutputDiffs sFilelistFrom sFilelistTo CompareCheckBoxes dtExecStart to iaDifferences
107832>>>        Set piaDifferences of ghoApplication to iaDifferences
107833>>>
107833>>>        Send Stop_StatusPanel of ghoStatusPanel
107834>>>        Move (CurrentDateTime()) to dtExecEnd
107835>>>        Move (dtExecEnd - dtExecStart) to tsTotalTime
107836>>>        Move (SizeOfArray(iaDifferences)) to iSize
107837>>>
107837>>>        Case Begin
107837>>>            Case (iSize = 0)
107839>>>                Send Info_Box "No differences found. The two databases should be identical."
107840>>>                Case Break
107841>>>            Case (iaDifferences[0] >= 1)
107844>>>                Get YesNo_Box ("Ready! (Time elapsed:" * String(tsTotalTime) + ")\n" + String(iSize) * "Differences found. View the report now?") to iRetval
107845>>>                If (iRetval = MBR_Yes) Begin
107847>>>                    Send DoShowReport of oViewReport_Btn
107848>>>                End
107848>>>>
107848>>>                Case Break
107849>>>            Case (iaDifferences[0] = -1)
107852>>>                Send Info_Box "Process interrupted."
107853>>>                Case Break
107854>>>            Case (iaDifferences[0] < -1)
107857>>>                Move iaDifferences[0]  to hTable
107858>>>                Move (999999 + hTable * -1) to hTable
107859>>>                Send Info_Box ("Process not complete. Couldn't open table number:" * String(hTable))
107860>>>                Send DoShowReport of oViewReport_Btn
107861>>>                Case Break
107862>>>            Case Else
107862>>>                Send Info_Box "An unknown error occured. Process interrupted."
107863>>>        Case End
107863>>>
107863>>>        Send Activate of oFilelistPathFrom_fm
107864>>>    End_Procedure
107865>>>
107865>>>    Function CompareAndOutputDiffs String sFilelistFrom String sFilelistTo tAPITableBooleans CompareCheckBoxes DateTime dtExecStart Returns Integer[]
107868>>>        Integer iSize iCount iNoOfTablesFrom iNoOfTablesTo iCh
107868>>>        Boolean bIsSame bFilelistError bUserCancel bOK bCollationDiff bIsEmbedded
107868>>>        Handle hTable
107868>>>        String sLogicalName sDatabaseCollationFrom sDatabaseCollationTo sDatabase
107868>>>        tAPITable[] aFromStructure aToStructure
107868>>>        tAPITable[] aFromStructure aToStructure
107870>>>        tAPITableCompare[] aAPITableCompare
107870>>>        tAPITableCompare[] aAPITableCompare
107871>>>        Integer[] iaDifferences iaDifferencesEmpty 
107873>>>
107873>>>        Set Message_Text of ghoStatusPanel to ""
107874>>>        // Set up the pathing correctly for the 'FROM' Filelist.cfg so we can open tables:
107874>>>        Get ChangeFilelistPathing of ghoApplication sFilelistFrom to bOK
107875>>>        If (bOK = False) Begin
107877>>>            Move -1 to iaDifferencesEmpty[0]
107878>>>            Function_Return iaDifferencesEmpty
107879>>>        End       
107879>>>>
107879>>>        Get UtilIsAllFilelistEntriesDataFlexTables of ghoDbUpdateFunctionLibrary to bIsEmbedded
107880>>>        If (bIsEmbedded = False) Begin
107882>>>            Get psDatabase of ghoDbUpdateFunctionLibrary to sDatabase
107883>>>            Get SqlDatabaseCollationQuery of ghoDbUpdateFunctionLibrary sDatabase True to sDatabaseCollationFrom
107884>>>        End 
107884>>>>
107884>>>        Else Begin
107885>>>            Move "Embedded Database (DataFlex)" to sDatabaseCollationFrom
107886>>>        End
107886>>>>
107886>>>
107886>>>        Get UtilFilelistNoOfTables of ghoDbUpdateFunctionLibrary to iNoOfTablesFrom
107887>>>        Set pbVisible   of ghoProgressBar        to True
107888>>>        Set piPosition  of ghoProgressBar        to 0
107889>>>        Set piAdvanceBy of ghoProgressBar        to 1
107890>>>        Set pbVisible   of ghoProgressBarOverall to True
107891>>>        Set piPosition  of ghoProgressBarOverall to 0
107892>>>        Set piAdvanceBy of ghoProgressBarOverall to 1
107893>>>        Set piMaximum   of ghoProgressBarOverall to iNoOfTablesFrom
107894>>>        
107894>>>        // *** Fill the 'FROM' structure with data: (1 of 3)
107894>>>        Get UtilTablesStructArrayFill of ghoDbUpdateFunctionLibrary True True True to aFromStructure
107895>>>        
107895>>>        // Process cancelled by user?
107895>>>        If (aFromStructure[0].bCancel = True) Begin
107897>>>            Move -1 to iaDifferencesEmpty[0]
107898>>>            Function_Return iaDifferencesEmpty
107899>>>        End
107899>>>>
107899>>>        
107899>>>        // Error while filling struct array (Table could not be opened)?
107899>>>        If (aFromStructure[0].bError = True) Begin
107901>>>            Move aFromStructure[0].ApiTableInfo.iTableNumber to hTable
107902>>>            Move (-999999 - hTable) to iaDifferencesEmpty[0]
107903>>>            Function_Return iaDifferencesEmpty
107904>>>        End
107904>>>>
107904>>>
107904>>>        // Set up the pathing correctly for the 'TO' Filelist.cfg so we can open tables from the other workspace:
107904>>>        Get ChangeFilelistPathing of ghoApplication sFilelistTo to bOK
107905>>>        If (bOK = False) Begin
107907>>>            Move -1 to iaDifferencesEmpty[0]
107908>>>            Function_Return iaDifferencesEmpty
107909>>>        End
107909>>>>
107909>>>
107909>>>        If (bIsEmbedded = False) Begin
107911>>>            Get psDatabase of ghoDbUpdateFunctionLibrary to sDatabase
107912>>>            Get SqlDatabaseCollationQuery of ghoDbUpdateFunctionLibrary sDatabase True to sDatabaseCollationTo
107913>>>        End 
107913>>>>
107913>>>        Else Begin
107914>>>            Move "Embedded Database (DataFlex)" to sDatabaseCollationTo
107915>>>        End
107915>>>>
107915>>>
107915>>>        Get UtilFilelistNoOfTables of ghoDbUpdateFunctionLibrary to iNoOfTablesTo
107916>>>        Set piMaximum of ghoProgressBarOverall to iNoOfTablesTo
107917>>>        Set piAdvanceBy of ghoProgressBarOverall to 1
107918>>>
107918>>>        // *** Fill the 'TO' structure with data: (2 of 3)
107918>>>        Get UtilTablesStructArrayFill of ghoDbUpdateFunctionLibrary True True False to aToStructure
107919>>>        // Process cancelled by user?
107919>>>        If (aToStructure[0].bCancel = True) Begin
107921>>>            Move -1 to iaDifferencesEmpty[0]
107922>>>            Function_Return iaDifferencesEmpty
107923>>>        End
107923>>>>
107923>>>        // Error while filling struct array (Table could not be opened)?
107923>>>        If (aToStructure[0].bError = True) Begin
107925>>>            Move aToStructure[0].ApiTableInfo.iTableNumber to hTable
107926>>>            Move (-999999 - hTable) to iaDifferencesEmpty[0]
107927>>>//            Function_Return iaDifferencesEmpty
107927>>>        End
107927>>>>
107927>>>
107927>>>        Set Message_Text of ghoStatusPanel to "Comparing and Writing Differences: (3 of 3)"
107928>>>        Move 0 to hTable
107929>>>        Move 0 to iCount
107930>>>        Get WriteReportHeader sDatabaseCollationFrom sDatabaseCollationTo to iCh
107931>>>
107931>>>        Get UtilTableCombineFromAndToArrays of ghoDbUpdateFunctionLibrary aFromStructure aToStructure to aAPITableCompare
107932>>>        Move (SizeOfArray(aAPITableCompare))   to iSize
107933>>>        Set piMaximum of ghoProgressBar        to iSize
107934>>>        Set piMaximum of ghoProgressBarOverall to iSize
107935>>>        Decrement iSize
107936>>>
107936>>>        For iCount from 0 to iSize
107942>>>>
107942>>>            Move True to bIsSame
107943>>>            Set piPosition of ghoProgressBarOverall to iCount
107944>>>            Move aAPITableCompare[iCount].hTable to hTable
107945>>>
107945>>>            If (aAPITableCompare[iCount].bExistsFrom = True) Begin
107947>>>                Move aAPITableCompare[iCount].APITableNameInfoCompare.sLogicalNameFrom to sLogicalName
107948>>>            End
107948>>>>
107948>>>            Else Begin
107949>>>                Move aAPITableCompare[iCount].APITableNameInfoCompare.sLogicalNameTo   to sLogicalName
107950>>>            End
107950>>>>
107950>>>            Set Action_Text of ghoStatusPanel to ("Name:" * sLogicalName * String("Number:") * String(hTable))
107951>>>
107951>>>            Get UtilTableCompare_Ex of ghoDbUpdateFunctionLibrary aAPITableCompare[iCount] CompareCheckBoxes False (&bFilelistError) to bIsSame
107952>>>
107952>>>            If (bIsSame = False) Begin
107954>>>                Send MainReport (&aAPITableCompare[iCount]) (&CompareCheckBoxes) iCh
107955>>>                Move hTable to iaDifferences[SizeOfArray(iaDifferences)]
107956>>>            End
107956>>>>
107956>>>
107956>>>            Get Check_StatusPanel of ghoStatusPanel to bUserCancel
107957>>>            If (bUserCancel = True) Begin
107959>>>                Move -1 to iaDifferencesEmpty[0]
107960>>>                Function_Return iaDifferencesEmpty
107961>>>            End
107961>>>>
107961>>>        Loop
107962>>>>
107962>>>        
107962>>>        Move False to bCollationDiff
107963>>>        If (Uppercase(sDatabaseCollationFrom) <> Uppercase(sDatabaseCollationTo)) Begin
107965>>>            Move True to bCollationDiff
107966>>>        End
107966>>>>
107966>>>        Send WriteReportFooter (SizeOfArray(iaDifferences)) bCollationDiff iCh dtExecStart
107967>>>        Close DF_ALL DF_PERMANENT
107968>>>
107968>>>        Function_Return iaDifferences
107969>>>    End_Function
107970>>>
107970>>>    Procedure MainReport tAPITableCompare ByRef aAPITableCompare tAPITableBooleans ByRef CompareCheckBoxes Integer iCh
107973>>>        String sDriverIDFrom sDriverIDTo sLogicalName sFrom sTo
107973>>>        Handle hTable
107973>>>        Boolean bCompareDate_DateTime bCompareIndexUppercase bCompareIndexAscending bCompareFilelistUppercase
107973>>>        Boolean bExistsFrom bExistsTo bIsSQLFrom bIsSQLTo
107973>>>
107973>>>        Move CompareCheckBoxes.bCompareDate_DateTime     to bCompareDate_DateTime
107974>>>        Move CompareCheckBoxes.bCompareIndexAscending    to bCompareIndexAscending
107975>>>        Move CompareCheckBoxes.bCompareIndexUppercase    to bCompareIndexUppercase
107976>>>        Move CompareCheckBoxes.bCompareFilelistUppercase to bCompareFilelistUppercase
107977>>>
107977>>>        Move aAPITableCompare.bExistsFrom                            to bExistsFrom
107978>>>        Move aAPITableCompare.bExistsTo                              to bExistsTo
107979>>>        Move aAPITableCompare.APITableNameInfoCompare.bIsSQLFrom     to bIsSQLFrom
107980>>>        Move aAPITableCompare.APITableNameInfoCompare.bIsSQLTo       to bIsSQLTo
107981>>>        Move aAPITableCompare.APITableNameInfoCompare.sDriverIDFrom  to sDriverIDFrom
107982>>>        Move aAPITableCompare.APITableNameInfoCompare.sDriverIDTo    to sDriverIDTo
107983>>>        Move aAPITableCompare.APITableNameInfoCompare.iTableNumber   to hTable
107984>>>
107984>>>        If (aAPITableCompare.bExistsFrom = True) Begin
107986>>>            Move aAPITableCompare.APITableNameInfoCompare.sLogicalNameFrom to sLogicalName
107987>>>        End
107987>>>>
107987>>>        Else Begin
107988>>>            Move (aAPITableCompare.APITableNameInfoCompare.sLogicalNameTo) to sLogicalName
107989>>>        End
107989>>>>
107989>>>
107989>>>        Send WriteTableInfoDiff aAPITableCompare.APITableNameInfoCompare bCompareFilelistUppercase iCh
107990>>>        If (aAPITableCompare.bExistsFrom = True and aAPITableCompare.bExistsTo = True) Begin
107992>>>            Send WriteColumnDiffs sDriverIDFrom sDriverIDTo hTable sLogicalName bIsSQLFrom bIsSQLTo aAPITableCompare.aAPIColumnsCompare bCompareDate_DateTime iCh
107993>>>            Send WriteIndexDiffs hTable bIsSQLFrom bIsSQLTo sLogicalName aAPITableCompare.aAPIIndexesCompare bCompareIndexUppercase bCompareIndexAscending iCh
107994>>>            Send WriteRelationDiffs hTable aAPITableCompare.aAPIRelationsCompare iCh
107995>>>        End
107995>>>>
107995>>>
107995>>>    End_Procedure
107996>>>
107996>>>    Function WriteReportHeader String sDatabaseCollationFrom String sDatabaseCollationTo Returns Integer
107999>>>        Integer iCh
107999>>>        String sFilelistFrom sFilelistTo sReportName //sDriverIDFrom sDriverIDTo sLogicalName sFrom sTo sRootName sTableName
107999>>>        DateTime dtCreationTime    
107999>>>
107999>>>        Get Value of oReportFileName_fm to sReportName
108000>>>        Get Seq_Open_Output_Channel sReportName to iCh
108001>>>        If (iCh = DF_SEQ_CHANNEL_ERROR) Begin
108003>>>            Send Stop_Box "Sorry, couldn't retrieve a free channel number."
108004>>>            Function_Return 0
108005>>>        End                   
108005>>>>
108005>>>        
108005>>>        If (Uppercase(sDatabaseCollationFrom) <> Uppercase(sDatabaseCollationTo)) Begin
108007>>>            Move (sDatabaseCollationTo * String("(*)")) to sDatabaseCollationTo
108008>>>        End
108008>>>>
108008>>>
108008>>>        Get Value of oFilelistPathFrom_fm to sFilelistFrom
108009>>>        Get Value of oFilelistPathTo_fm   to sFilelistTo
108010>>>        Move (CurrentDateTime()) to dtCreationTime
108011>>>
108011>>>        Writeln channel iCh CS_ReportHeaderUnderWrite
108014>>>        Writeln channel iCh CS_DatabaseUpdateFramework
108017>>>        Writeln channel iCh (" ***  DATABASE DIFFERENCES REPORT  ***")
108020>>>        Writeln channel iCh ""
108023>>>        Writeln channel iCh ("      Date & Time Printed       :" * String(dtCreationTime))
108026>>>        Writeln channel iCh ("      FROM Database Filelist.cfg:" * String(sFilelistFrom))
108029>>>        Writeln channel iCh ("      TO   Database Filelist.cfg:" * String(sFilelistTo))
108032>>>        Writeln channel iCh ("      FROM Database Collation   :" * String(sDatabaseCollationFrom))
108035>>>        Writeln channel iCh ("      TO   Database Collation   :" * String(sDatabaseCollationTo))
108038>>>        Writeln channel iCh ""
108041>>>        Writeln channel iCh ("      Note: An asterisk in parenthesis (*) denotes a difference!")
108044>>>        Writeln channel iCh CS_ReportHeaderUnderWrite
108047>>>        Writeln channel iCh
108049>>>
108049>>>        Function_Return iCh
108050>>>    End_Function
108051>>>
108051>>>    // Note: The rootname will be first be stripped if it contains any driver id prefix.
108051>>>    Procedure WriteTableInfoDiff tAPITableNameInfoCompare APITableNameInfoCompare Boolean bCompareFilelistUppercase Integer iCh
108054>>>        String sLogicalName  sFrom sTo
108054>>>        Boolean bExistsFrom bExistsTo bIsSame
108054>>>        Handle hTable
108054>>>
108054>>>        Get UtilTableInfoCompare of ghoDbUpdateFunctionLibrary bCompareFilelistUppercase APITableNameInfoCompare to bIsSame
108055>>>        If (bIsSame = True) Begin
108057>>>            Procedure_Return
108058>>>        End
108058>>>>
108058>>>
108058>>>        Move APITableNameInfoCompare.iTableNumber to hTable
108059>>>        Move APITableNameInfoCompare.bExistsFrom  to bExistsFrom
108060>>>        Move APITableNameInfoCompare.bExistsTo    to bExistsTo
108061>>>        If (bExistsFrom = True) Begin
108063>>>            Move APITableNameInfoCompare.sLogicalNameFrom to sLogicalName
108064>>>        End
108064>>>>
108064>>>        If (bExistsTo = True) Begin
108066>>>            Move APITableNameInfoCompare.sLogicalNameTo   to sLogicalName
108067>>>        End
108067>>>>
108067>>>
108067>>>        Writeln channel iCh
108069>>>        Writeln channel iCh "Table Name Difference(s) Table Number: " hTable " - " sLogicalName
108075>>>        Writeln channel iCh CS_ReportHeaderUnderWrite
108078>>>
108078>>>        Move "FROM Database:" to sFrom
108079>>>        Get MakeStringLength sFrom CI_ReportColumn2 to sFrom
108080>>>        Move (sFrom + "TO Database:") to sFrom
108081>>>        Writeln channel iCh sFrom
108084>>>        Move (Repeat("-", Length(sFrom))) to sFrom
108085>>>        Writeln channel iCh sFrom
108088>>>
108088>>>        Move "Logical Name:"                                                to sFrom
108089>>>        Get MakeStringLength sFrom CI_ReportColumn1                         to sFrom
108090>>>        If (bExistsFrom = True) Begin
108092>>>            Move (sFrom + String(APITableNameInfoCompare.sLogicalNameFrom)) to sFrom
108093>>>        End
108093>>>>
108093>>>        If (bExistsFrom = False) Begin
108095>>>            Move (sFrom + CS_ReportTableNotFound * String(CS_ReportDifferenceNote)) to sFrom
108096>>>        End
108096>>>>
108096>>>        Get MakeStringLength sFrom CI_ReportColumn2                         to sFrom
108097>>>        If (bExistsTo = True) Begin
108099>>>            Move APITableNameInfoCompare.sLogicalNameTo                     to sTo
108100>>>        End
108100>>>>
108100>>>        If (bExistsTo = False) Begin
108102>>>            Move ""                                                         to sTo
108103>>>            Move (CS_ReportTableNotFound * String(CS_ReportDifferenceNote)) to sTo
108104>>>        End
108104>>>>
108104>>>        Writeln channel iCh sFrom sTo
108108>>>
108108>>>        Move "Root Name:"                                                   to sFrom
108109>>>        Get MakeStringLength sFrom CI_ReportColumn1                         to sFrom
108110>>>        If (bExistsFrom = True) Begin
108112>>>            Move (sFrom + String(APITableNameInfoCompare.sRootNameFrom))    to sFrom
108113>>>        End
108113>>>>
108113>>>        If (bExistsFrom = False) Begin
108115>>>            Move (sFrom + CS_ReportTableNotFound * String(CS_ReportDifferenceNote)) to sFrom
108116>>>        End
108116>>>>
108116>>>        Get MakeStringLength sFrom CI_ReportColumn2                         to sFrom
108117>>>        If (bExistsTo = True) Begin
108119>>>            Move APITableNameInfoCompare.sRootNameTo                        to sTo
108120>>>        End
108120>>>>
108120>>>        If (bExistsTo = False) Begin
108122>>>            Move ""                                                         to sTo
108123>>>            Move (CS_ReportTableNotFound * String(CS_ReportDifferenceNote)) to sTo
108124>>>        End
108124>>>>
108124>>>        Writeln channel iCh sFrom sTo
108128>>>
108128>>>        Move "Display Name:"                                                to sFrom
108129>>>        Get MakeStringLength sFrom CI_ReportColumn1                         to sFrom
108130>>>        If (bExistsFrom = True) Begin
108132>>>            Move (sFrom + String(APITableNameInfoCompare.sDisplayNameFrom)) to sFrom
108133>>>        End
108133>>>>
108133>>>        If (bExistsFrom = False) Begin
108135>>>            Move (sFrom + CS_ReportTableNotFound * String(CS_ReportDifferenceNote)) to sFrom
108136>>>        End
108136>>>>
108136>>>        Get MakeStringLength sFrom CI_ReportColumn2                         to sFrom
108137>>>        If (bExistsTo = True) Begin
108139>>>            Move APITableNameInfoCompare.sDisplayNameTo                     to sTo
108140>>>        End
108140>>>>
108140>>>        If (bExistsTo = False) Begin
108142>>>            Move ""                                                         to sTo
108143>>>            Move (CS_ReportTableNotFound * String(CS_ReportDifferenceNote)) to sTo
108144>>>        End
108144>>>>
108144>>>        Writeln channel iCh sFrom sTo
108148>>>
108148>>>        If (bExistsFrom = False or bExistsTo = False) Begin
108150>>>            Writeln channel iCh
108152>>>        End
108152>>>>
108152>>>        Writeln channel iCh
108154>>>    End_Procedure
108155>>>
108155>>>    Procedure WriteColumnDiffs String sDriverIDFrom String sDriverIDTo Handle hTable String sLogicalTableName Boolean bIsSQLFrom Boolean bIsSQLTo tAPIColumnCompare[] aAPIColumnCompare Boolean bCompareDate_DateTime Integer iCh
108158>>>        Integer iSize iCount
108158>>>        Boolean bIsSame bHeader
108158>>>        String sFrom sTo sTypeFrom sTypeTo
108158>>>
108158>>>        Move (SizeOfArray(aAPIColumnCompare)) to iSize
108159>>>        If (iSize = 0) Begin
108161>>>            Procedure_Return
108162>>>        End
108162>>>>
108162>>>
108162>>>        Decrement iSize
108163>>>        For iCount from 0 to iSize
108169>>>>
108169>>>            Get UtilColumnCompare of ghoDbUpdateFunctionLibrary sDriverIDFrom sDriverIDTo bIsSQLFrom bIsSQLTo aAPIColumnCompare[iCount] bCompareDate_DateTime to bIsSame
108170>>>            If (bIsSame = False) Begin
108172>>>
108172>>>                If (bHeader = False) Begin
108174>>>                    Writeln channel iCh "Field Difference(s) for Table Number: " (String(hTable)) " - " sLogicalTableName
108180>>>                    Writeln channel iCh CS_ReportHeaderUnderWrite
108183>>>                    Move "FROM Database:" to sFrom
108184>>>                    Get MakeStringLength sFrom CI_ReportColumn2 to sFrom
108185>>>                    Move (sFrom + "TO Database:") to sFrom
108186>>>                    Writeln channel iCh sFrom
108189>>>                    Move (Repeat("-", Length(sFrom))) to sFrom
108190>>>                    Writeln channel iCh sFrom
108193>>>                    Move True to bHeader
108194>>>                End
108194>>>>
108194>>>
108194>>>                Get MakeFromString "Field Number:" aAPIColumnCompare[iCount].iFieldNumber (CS_ReportFieldNotFound * CS_ReportDifferenceNote) ;                                 aAPIColumnCompare[iCount].bExistsFrom to sFrom
108195>>>                Get MakeToString aAPIColumnCompare[iCount].iFieldNumber "" (CS_ReportFieldNotFound * CS_ReportDifferenceNote) ;                                 aAPIColumnCompare[iCount].bExistsTo to sTo
108196>>>                Writeln channel iCh sFrom sTo
108200>>>
108200>>>                Get MakeFromString "Field Name" aAPIColumnCompare[iCount].sFieldNameFrom CS_ReportDifferenceNote aAPIColumnCompare[iCount].bExistsTo to sFrom
108201>>>                Get MakeToString aAPIColumnCompare[iCount].sFieldNameTo "" CS_ReportDifferenceNote (Uppercase(aAPIColumnCompare[iCount].sFieldNameFrom) = ;                                 Uppercase(aAPIColumnCompare[iCount].sFieldNameTo)) to sTo
108202>>>                Writeln channel iCh sFrom sTo
108206>>>
108206>>>                Get MakeFromString "Type:" aAPIColumnCompare[iCount].sTypeFrom CS_ReportDifferenceNote aAPIColumnCompare[iCount].bExistsFrom to sFrom
108207>>>                Get MakeToString aAPIColumnCompare[iCount].sTypeTo "" CS_ReportDifferenceNote (Uppercase(aAPIColumnCompare[iCount].sTypeFrom) = ;                                 Uppercase(aAPIColumnCompare[iCount].sTypeTo)) to sTo
108208>>>                Writeln channel iCh sFrom sTo
108212>>>
108212>>>                Get MakeFromString "Length:" aAPIColumnCompare[iCount].iLengthFrom CS_ReportDifferenceNote aAPIColumnCompare[iCount].bExistsFrom to sFrom
108213>>>                Get MakeToString aAPIColumnCompare[iCount].iLengthTo "" CS_ReportDifferenceNote (aAPIColumnCompare[iCount].iLengthFrom = ;                                 aAPIColumnCompare[iCount].iLengthTo) to sTo
108214>>>                Writeln channel iCh sFrom sTo
108218>>>
108218>>>                Get MakeFromString "Precision:" aAPIColumnCompare[iCount].iPrecisionFrom CS_ReportDifferenceNote aAPIColumnCompare[iCount].bExistsFrom to sFrom
108219>>>                Get MakeToString aAPIColumnCompare[iCount].iPrecisionTo "" CS_ReportDifferenceNote (aAPIColumnCompare[iCount].iPrecisionFrom = ;                                 aAPIColumnCompare[iCount].iPrecisionTo) to sTo
108220>>>                Writeln channel iCh sFrom sTo
108224>>>
108224>>>                Get MakeFromString "Default Value:" aAPIColumnCompare[iCount].sDefaultValueFrom CS_ReportDifferenceNote aAPIColumnCompare[iCount].bExistsFrom to sFrom
108225>>>                Get MakeToString aAPIColumnCompare[iCount].sDefaultValueTo "" CS_ReportDifferenceNote (aAPIColumnCompare[iCount].sDefaultValueFrom = ;                                 aAPIColumnCompare[iCount].sDefaultValueTo) to sTo
108226>>>                Writeln channel iCh sFrom sTo
108230>>>
108230>>>                Get MakeFromString "Allow NULL:" (If(aAPIColumnCompare[iCount].bAllowNULLFrom = True, "Yes", "No")) CS_ReportDifferenceNote ;                                 aAPIColumnCompare[iCount].bExistsTo to sFrom
108231>>>                Get MakeToString (If(aAPIColumnCompare[iCount].bAllowNULLTo = True, "Yes", "No")) "" CS_ReportDifferenceNote ;                                 aAPIColumnCompare[iCount].bExistsTo to sTo
108232>>>                Writeln channel iCh sFrom sTo
108236>>>
108236>>>                Get MakeFromString "Identity Field:" (If(aAPIColumnCompare[iCount].iOptionsFrom = C_tAPIColumn_Identity, "Yes", "No")) CS_ReportDifferenceNote ;                                 aAPIColumnCompare[iCount].bExistsTo to sFrom
108237>>>                Get MakeToString (If(aAPIColumnCompare[iCount].iOptionsTo = C_tAPIColumn_Identity, "Yes", "No")) "" CS_ReportDifferenceNote ;                                 aAPIColumnCompare[iCount].bExistsTo to sTo
108238>>>                Writeln channel iCh sFrom sTo
108242>>>                Writeln channel iCh
108244>>>            End
108244>>>>
108244>>>        Loop
108245>>>>
108245>>>
108245>>>        If (bHeader = True) Begin
108247>>>            Writeln channel iCh ""
108250>>>        End
108250>>>>
108250>>>    End_Procedure
108251>>>
108251>>>    Procedure WriteIndexDiffs Handle hTable Boolean bIsSQLTableFrom Boolean bIsSQLTableTo String sLogicalTableName tAPIIndexCompare[] aAPIIndexCompare Boolean bCompareIndexUppercase Boolean bCompareIndexAscending Integer iCh
108254>>>        Integer iSize iCount iSegmentSizeFrom iSegmentSizeTo iCount2 iSize2 iFieldNumberFrom iFieldNumberTo
108254>>>        Integer iIndexNumberFrom iIndexNumberTo iPrimaryIndexFrom iPrimaryIndexTo
108254>>>        tAPIIndexSegment[] aApiIndexSegmentsFrom aApiIndexSegmentsTo aApiIndexSegmentsEmpty
108254>>>        tAPIIndexSegment[] aApiIndexSegmentsFrom aApiIndexSegmentsTo aApiIndexSegmentsEmpty
108257>>>        String sFrom sTo sSQLIndexTypeFrom sSQLIndexTypeTo sSQLIndexNameFrom sSQLIndexNameTo sFieldNameFrom sFieldNameTo
108257>>>        Boolean bIsSame bIsSQLPrimaryFrom bIsSQLPrimaryTo bIsSQLClusteredFrom bIsSQLClusteredTo bHeader
108257>>>
108257>>>        Move (SizeOfArray(aAPIIndexCompare)) to iSize
108258>>>        Decrement iSize
108259>>>
108259>>>        For iCount from 0 to iSize
108265>>>>
108265>>>            Get UtilIndexCompare of ghoDbUpdateFunctionLibrary bIsSQLTableFrom bIsSQLTableTo aAPIIndexCompare[iCount] bCompareIndexAscending bCompareIndexUppercase to bIsSame
108266>>>            If (bIsSame = False) Begin
108268>>>                If (bHeader = False) Begin
108270>>>                    Writeln channel iCh "Index Difference(s) for Table Number: " (String(hTable)) " - " sLogicalTableName
108276>>>                    Writeln channel iCh CS_ReportHeaderUnderWrite
108279>>>                    Move "FROM Database:" to sFrom
108280>>>                    Get MakeStringLength sFrom CI_ReportColumn2 to sFrom
108281>>>                    Move (sFrom + "TO Database:") to sFrom
108282>>>                    Writeln channel iCh sFrom
108285>>>                    Move (Repeat("-", Length(sFrom))) to sFrom
108286>>>                    Writeln channel iCh sFrom
108289>>>                    Move True to bHeader
108290>>>                End
108290>>>>
108290>>>
108290>>>                // FROM Index:
108290>>>                If (aAPIIndexCompare[iCount].bExistsFrom = True) Begin
108292>>>                    Move aAPIIndexCompare[iCount].iIndexNumber              to iIndexNumberFrom
108293>>>                    Move aAPIIndexCompare[iCount].iPrimaryIndexFrom         to iPrimaryIndexFrom
108294>>>                    Move aAPIIndexCompare[iCount].sSQLIndexNameFrom         to sSQLIndexNameFrom
108295>>>                    Move aAPIIndexCompare[iCount].bIsSQLPrimaryKeyFrom      to bIsSQLPrimaryFrom
108296>>>                    Move aAPIIndexCompare[iCount].bIsSQLClusteredFrom       to bIsSQLClusteredFrom
108297>>>                    Get UtilIndexTypeToString of ghoDbUpdateFunctionLibrary ;                         aAPIIndexCompare[iCount].iSQLIndexTypeFrom         to sSQLIndexTypeFrom
108298>>>                    Move aAPIIndexCompare[iCount].IndexSegmentArrayFrom     to aApiIndexSegmentsFrom
108299>>>                End
108299>>>>
108299>>>                Else Begin
108300>>>                    Move -1                                                 to iIndexNumberFrom
108301>>>                    Move -1                                                 to iPrimaryIndexFrom
108302>>>                    Move (String(CS_ReportDifferenceNote))                  to sSQLIndexNameFrom
108303>>>                    Move False                                              to bIsSQLPrimaryFrom
108304>>>                    Move False                                              to bIsSQLClusteredFrom
108305>>>                    Move (String(CS_ReportDifferenceNote))                  to sSQLIndexTypeFrom
108306>>>                    Move aApiIndexSegmentsEmpty                             to aApiIndexSegmentsFrom
108307>>>                End
108307>>>>
108307>>>
108307>>>                If (aAPIIndexCompare[iCount].bExistsTo = True) Begin
108309>>>                    Move aAPIIndexCompare[iCount].iIndexNumber              to iIndexNumberTo
108310>>>                    Move aAPIIndexCompare[iCount].iPrimaryIndexTo           to iPrimaryIndexTo
108311>>>                    Move aAPIIndexCompare[iCount].sSQLIndexNameTo           to sSQLIndexNameTo
108312>>>                    Move aAPIIndexCompare[iCount].bIsSQLPrimaryKeyTo        to bIsSQLPrimaryTo
108313>>>                    Move aAPIIndexCompare[iCount].bIsSQLClusteredTo         to bIsSQLClusteredTo
108314>>>                    Get UtilIndexTypeToString of ghoDbUpdateFunctionLibrary ;                        aAPIIndexCompare[iCount].iSQLIndexTypeTo            to sSQLIndexTypeTo
108315>>>                    Move aAPIIndexCompare[iCount].IndexSegmentArrayTo       to aApiIndexSegmentsTo
108316>>>                End
108316>>>>
108316>>>                Else Begin
108317>>>                    Move -1                                                 to iIndexNumberTo
108318>>>                    Move -1                                                 to iPrimaryIndexTo
108319>>>                    Move (String(CS_ReportDifferenceNote))                  to sSQLIndexNameTo
108320>>>                    Move (String(CS_ReportDifferenceNote))                  to bIsSQLPrimaryTo
108321>>>                    Move (String(CS_ReportDifferenceNote))                  to bIsSQLClusteredTo
108322>>>                    Move (String(CS_ReportDifferenceNote))                  to sSQLIndexTypeTo
108323>>>                    Move (String(CS_ReportDifferenceNote))                  to bIsSQLPrimaryTo
108324>>>                    Move aApiIndexSegmentsEmpty                             to aApiIndexSegmentsTo
108325>>>                End
108325>>>>
108325>>>
108325>>>                Get MakeFromString "Index Number:" iIndexNumberFrom CS_ReportIndexNotFound (iIndexNumberFrom <> -1) to sFrom
108326>>>                Get MakeToString iIndexNumberTo "" (CS_ReportIndexNotFound * String(CS_ReportDifferenceNote)) (iIndexNumberTo <> -1) to sTo
108327>>>                Writeln channel iCh sFrom sTo
108331>>>
108331>>>                Get MakeFromString "Primary Idx #:" iPrimaryIndexFrom CS_ReportDifferenceNote (iPrimaryIndexFrom <> -1) to sFrom
108332>>>                Get MakeToString iPrimaryIndexTo "" CS_ReportDifferenceNote (iPrimaryIndexTo <> -1) to sTo
108333>>>                Writeln channel iCh sFrom sTo
108337>>>
108337>>>                // SQL Index info:
108337>>>                If (bIsSqlTableFrom = True and bIsSqlTableTo = True) Begin
108339>>>                    Get MakeFromString "SQL Name:" sSQLIndexNameFrom CS_ReportDifferenceNote (sSQLIndexNameFrom <> "") to sFrom
108340>>>                    Get MakeToString sSQLIndexNameTo "" CS_ReportDifferenceNote (iIndexNumberFrom <> -1 and Uppercase(sSQLIndexNameFrom) = Uppercase(sSQLIndexNameTo)) to sTo
108341>>>                    Writeln channel iCh sFrom sTo
108345>>>
108345>>>                    Get MakeFromString "SQL Primary:" (If(bIsSQLPrimaryFrom = True, "Yes", "No")) CS_ReportDifferenceNote aAPIIndexCompare[iCount].bExistsFrom to sFrom
108346>>>                    Get MakeToString (If(bIsSQLPrimaryTo = True, "Yes", "No")) "" CS_ReportDifferenceNote (iIndexNumberFrom <> -1 and bIsSQLPrimaryFrom = bIsSQLPrimaryTo) to sTo
108347>>>                    Writeln channel iCh sFrom sTo
108351>>>
108351>>>                    Get MakeFromString "SQL Clustered:" (If(bIsSQLClusteredFrom = True, "Yes", "No")) CS_ReportDifferenceNote aAPIIndexCompare[iCount].bExistsFrom to sFrom
108352>>>                    Get MakeToString (If(bIsSQLClusteredTo = True, "Yes", "No")) "" CS_ReportDifferenceNote (iIndexNumberFrom <> -1 and bIsSQLClusteredFrom = bIsSQLClusteredTo) to sTo
108353>>>                    Writeln channel iCh sFrom sTo
108357>>>
108357>>>                    Get MakeFromString "SQL Type:" sSQLIndexTypeFrom CS_ReportDifferenceNote True to sFrom
108358>>>                    Get MakeToString sSQLIndexTypeTo "" CS_ReportDifferenceNote True to sTo
108359>>>                    Writeln channel iCh sFrom sTo
108363>>>                End
108363>>>>
108363>>>
108363>>>                // Index Segments:
108363>>>                Move (SizeOfArray(aApiIndexSegmentsFrom)) to iSegmentSizeFrom
108364>>>                Move (SizeOfArray(aApiIndexSegmentsTo))   to iSegmentSizeTo
108365>>>
108365>>>                Move (iSegmentSizeFrom max iSegmentSizeTo)  to iSize2
108366>>>                Decrement iSize2
108367>>>                If (iSize2 > -1) Begin
108369>>>                    Writeln channel iCh
108371>>>                End
108371>>>>
108371>>>
108371>>>                For iCount2 from 0 to iSize2
108377>>>>
108377>>>                    Move "" to sFieldNameFrom
108378>>>                    Move "" to sFieldNameTo
108379>>>                    Get MakeStringLength "Field# & Name:" CI_ReportColumn1               to sFrom
108380>>>                    If (iCount2 < iSegmentSizeFrom) Begin
108382>>>                        Move aApiIndexSegmentsFrom[iCount2].iFieldNumber                 to iFieldNumberFrom
108383>>>                        Move (sFrom + String(iFieldNumberFrom))                          to sFrom
108384>>>                        Move (String(aApiIndexSegmentsFrom[iCount2].sFieldName))         to sFieldNameFrom
108385>>>                        Move (sFrom * String(sFieldNameFrom))                            to sFrom
108386>>>                    End
108386>>>>
108386>>>                    Else Begin
108387>>>                        Move 0                                                           to iFieldNumberFrom
108388>>>                        Move (sFrom + CS_ReportIndexSegmentNotFound)                     to sFrom
108389>>>                    End
108389>>>>
108389>>>                    Get MakeStringLength sFrom CI_ReportColumn2                          to sFrom
108390>>>
108390>>>                    Move ""                                                              to sTo
108391>>>                    If (iIndexNumberTo <> -1) Begin
108393>>>                        Move aApiIndexSegmentsTo[iCount2].iFieldNumber                   to iFieldNumberTo
108394>>>                        Move (String(iFieldNumberTo))                                    to sTo
108395>>>                        Move (String(aApiIndexSegmentsTo[iCount2].sFieldName))           to sFieldNameTo
108396>>>                        Move (sTo * String(sFieldNameTo))                                to sTo
108397>>>                    End
108397>>>>
108397>>>                    If (iFieldNumberFrom <> iFieldNumberTo or Uppercase(sFieldNameFrom) <> Uppercase(sFieldNameTo)) Begin
108399>>>                        Move (sTo + String(CS_ReportDifferenceNote))                     to sTo
108400>>>                    End
108400>>>>
108400>>>                    Writeln channel iCh sFrom sTo
108404>>>
108404>>>                    // Uppercase Index Segment:
108404>>>                    If (bCompareIndexUppercase = True) Begin
108406>>>                        Get MakeStringLength "Uppercase:" CI_ReportColumn1                                        to sFrom
108407>>>                        If (bIsSqlTableFrom = True) Begin
108409>>>                            Move (sFrom + CS_ReportIndexNotApplicable)                                            to sFrom
108410>>>                        End
108410>>>>
108410>>>                        Else If (iCount <= iSegmentSizeFrom) Begin
108413>>>                            Move (sFrom + String(If(aApiIndexSegmentsFrom[iCount2].bUppercase = 1, "Yes","No")))  to sFrom
108414>>>                        End
108414>>>>
108414>>>                        Get MakeStringLength sFrom CI_ReportColumn2                                               to sFrom
108415>>>                        Move "" to sTo
108416>>>                        If (bIsSqlTableFrom = True) Begin
108418>>>                            Move CS_ReportIndexNotApplicable                                                      to sTo
108419>>>                        End
108419>>>>
108419>>>                        Else If (iCount <= iSegmentSizeTo) Begin
108422>>>                            Move (String(If(aApiIndexSegmentsTo[iCount2].bUppercase = 1, "Yes", "No")))           to sTo
108423>>>                        End
108423>>>>
108423>>>                        Writeln channel iCh sFrom sTo
108427>>>                    End
108427>>>>
108427>>>
108427>>>                    // Ascending/Descending Index:
108427>>>                    If (bCompareIndexAscending = True) Begin
108429>>>                        Get MakeStringLength "Ascending:" CI_ReportColumn1                                        to sFrom
108430>>>                        If (bIsSqlTableFrom = True) Begin
108432>>>                            Move (sFrom + CS_ReportIndexNotApplicable)                                            to sFrom
108433>>>                        End
108433>>>>
108433>>>                        Else If (iCount <= iSegmentSizeFrom) Begin
108436>>>                            Move (sFrom + String(If(aApiIndexSegmentsFrom[iCount2].bAscending = 1, "Yes", "No"))) to sFrom
108437>>>                        End
108437>>>>
108437>>>                        Get MakeStringLength sFrom CI_ReportColumn2                                               to sFrom
108438>>>                        Move "" to sTo
108439>>>                        If (bIsSqlTableFrom = True) Begin
108441>>>                            Move CS_ReportIndexNotApplicable                                                      to sTo
108442>>>                        End
108442>>>>
108442>>>                        Else If (iCount <= iSegmentSizeTo) Begin
108445>>>                            Move (String(If(aApiIndexSegmentsTo[iCount2].bAscending = 1, "Yes", "No")))           to sTo
108446>>>                        End
108446>>>>
108446>>>                        Writeln channel iCh sFrom sTo
108450>>>                    End
108450>>>>
108450>>>                Loop
108451>>>>
108451>>>                Writeln channel iCh ""
108454>>>            End
108454>>>>
108454>>>        Loop
108455>>>>
108455>>>
108455>>>        If (bHeader = True) Begin
108457>>>            Writeln channel iCh ""
108460>>>        End
108460>>>>
108460>>>    End_Procedure
108461>>>
108461>>>    Procedure WriteRelationDiffs Handle hTable tAPIRelationCompare[] aAPIRelationCompare Integer iCh
108464>>>        Integer iSizeFrom iSize iCount iRow iItem
108464>>>        Boolean bExists bIsSame bHeader
108464>>>        String sFrom sTo sFromFieldsRight sFromFields sToFields sLogicalNameFrom
108464>>>        tRelationDiffs[] asRelationDiffs
108464>>>        tRelationDiffs[] asRelationDiffs
108465>>>
108465>>>
108465>>>        Move (SizeOfArray(aAPIRelationCompare)) to iSize
108466>>>        Decrement iSize
108467>>>        For iCount from 0 to iSize
108473>>>>
108473>>>            Get UtilRelationCompare of ghoDbUpdateFunctionLibrary hTable aAPIRelationCompare[iCount] to bIsSame
108474>>>            If (bIsSame = False) Begin
108476>>>                If (bHeader = False) Begin
108478>>>                    Move aAPIRelationCompare[iCount].sLogicalNameFrom_From   to sLogicalNameFrom
108479>>>                    If (sLogicalNameFrom = "") Begin
108481>>>                        Move aAPIRelationCompare[iCount].sLogicalNameFrom_To to sLogicalNameFrom
108482>>>                    End
108482>>>>
108482>>>                    Writeln channel iCh ""
108485>>>                    Writeln channel iCh "Relation Difference(s) for Table Number: " (String(hTable)) " - " sLogicalNameFrom
108491>>>                    Writeln channel iCh CS_ReportHeaderUnderWrite
108494>>>                    Move "FROM Database:" to sFrom
108495>>>                    Get MakeStringLength sFrom CI_ReportColumn2 to sFrom
108496>>>                    Move (sFrom + "TO Database:") to sFrom
108497>>>                    Writeln channel iCh sFrom
108500>>>                    Move (Repeat("-", Length(sFrom))) to sFrom
108501>>>                    Writeln channel iCh sFrom
108504>>>                    Move True to bHeader
108505>>>                End
108505>>>>
108505>>>
108505>>>                // FROM Relation:
108505>>>                Get MakeStringLength "Table.Field:" CI_ReportColumn1                            to sFrom
108506>>>                If (aAPIRelationCompare[iCount].bExistsFrom = True) Begin
108508>>>                    Move (sFrom + String(aAPIRelationCompare[iCount].hTableFrom)   + "." ;                                + String(aAPIRelationCompare[iCount].iColumnFrom)  * "->")      to sFrom
108509>>>                    Move (sFrom * String(aAPIRelationCompare[iCount].hTableTo)     + "." ;                                + String(aAPIRelationCompare[iCount].iColumnTo))                to sFrom
108510>>>                    Get MakeStringLength sFrom CI_ReportColumn2                                 to sFrom
108511>>>                    Move (String(aAPIRelationCompare[iCount].sLogicalNameFrom_From) + "." ;                        + String(aAPIRelationCompare[iCount].sFieldNameFrom_From)   * "->")     to sFromFields
108512>>>                    Move (String(aAPIRelationCompare[iCount].sLogicalNameTo_From)   + "." ;                        + String(aAPIRelationCompare[iCount].sFieldNameTo_From))                to sFromFieldsRight
108513>>>                End
108513>>>>
108513>>>                Else Begin
108514>>>                    Move (String(CS_ReportRelationNotFound) * String(CS_ReportDifferenceNote))  to sFrom
108515>>>                    Get MakeStringLength sFrom CI_ReportColumn2                                 to sFrom
108516>>>                    Move (String(CS_ReportDifferenceNote))                                      to sFromFields
108517>>>                    Move ""                                                                     to sFromFieldsRight
108518>>>                    Move iCount                                                                 to iItem
108519>>>                End
108519>>>>
108519>>>                Move (sFromFields * String(sFromFieldsRight))                                   to sFromFields
108520>>>                Get MakeStringLength sFromFields CI_ReportColumn2                               to sFromFields
108521>>>
108521>>>                // TO Relation:
108521>>>                If (aAPIRelationCompare[iCount].bExistsTo = True) Begin
108523>>>                    Move (String(aAPIRelationCompare[iCount].hTableFrom)           + "." ;                        + String(aAPIRelationCompare[iCount].iColumnFrom)          * "->")      to sTo
108524>>>                    Move (sTo * String(aAPIRelationCompare[iCount].hTableTo)       + "." ;                        + String(aAPIRelationCompare[iCount].iColumnTo))                        to sTo
108525>>>                    Move (String(aAPIRelationCompare[iCount].sLogicalNameFrom_To)  + "." ;                        + String(aAPIRelationCompare[iCount].sFieldNameFrom_To)    * "->")      to sToFields
108526>>>                    Move (sToFields * String(aAPIRelationCompare[iCount].sLogicalNameTo_To) + "." ;                        + String(aAPIRelationCompare[iCount].sFieldNameTo_To))                  to sToFields
108527>>>                End
108527>>>>
108527>>>                Else Begin
108528>>>                    Move (CS_ReportRelationNotFound * String(CS_ReportDifferenceNote))          to sTo
108529>>>                    Move (String(CS_ReportDifferenceNote))                                      to sToFields
108530>>>                End
108530>>>>
108530>>>
108530>>>                Move sFromFieldsRight to asRelationDiffs[iRow].sFromFieldsRight
108531>>>                Move sFrom to asRelationDiffs[iRow].sFrom
108532>>>                Move sTo   to asRelationDiffs[iRow].sTo
108533>>>                Move sFromFields to asRelationDiffs[iRow].sFromFields
108534>>>                Move sToFields   to asRelationDiffs[iRow].sToFields
108535>>>                If (iCount < iSize) Begin
108537>>>                    Increment iRow
108538>>>                    Move "" to asRelationDiffs[iRow].sFrom
108539>>>                    Move "" to asRelationDiffs[iRow].sTo
108540>>>                End
108540>>>>
108540>>>                Else Begin
108541>>>                    Increment iRow
108542>>>                End
108542>>>>
108542>>>            End
108542>>>>
108542>>>        Loop
108543>>>>
108543>>>
108543>>>        // We put all relations in an array struct so we can sort it alphatically.
108543>>>        // This is to show multiple field relations from one table to another next to each other, just as the Studio does.
108543>>>        Move (SortArray(asRelationDiffs))   to asRelationDiffs
108544>>>        Move (SizeOfArray(asRelationDiffs)) to iSizeFrom
108545>>>        Decrement iSizeFrom
108546>>>        For iCount from 0 to iSizeFrom
108552>>>>
108552>>>            Writeln channel iCh asRelationDiffs[iCount].sFrom       asRelationDiffs[iCount].sTo
108556>>>            Writeln channel iCh asRelationDiffs[iCount].sFromFields asRelationDiffs[iCount].sToFields
108560>>>            Writeln channel iCh
108562>>>        Loop
108563>>>>
108563>>>
108563>>>        If (bHeader = True) Begin
108565>>>            Writeln channel iCh ""
108568>>>        End
108568>>>>
108568>>>    End_Procedure
108569>>>
108569>>>    Procedure WriteReportFooter Integer iSize Boolean bCollationDiff Integer iCh DateTime dtExecStart
108572>>>        DateTime dtExecEnd
108572>>>        TimeSpan tsTotalTime
108572>>>
108572>>>        Move (CurrentDateTime()) to dtExecEnd
108573>>>        Move (dtExecEnd - dtExecStart) to tsTotalTime
108574>>>
108574>>>        Writeln channel iCh
108576>>>        Writeln channel iCh "SUMMARY:  [Total Elapsed Time: " tsTotalTime "]"
108581>>>        Writeln channel iCh CS_ReportHeaderUnderWrite               
108584>>>        If (bCollationDiff = False) Begin
108586>>>            Writeln channel iCh "Number of Tables with differences: " (String(iSize))
108590>>>        End 
108590>>>>
108590>>>        Else Begin
108591>>>            If (iSize <> 0) Begin
108593>>>                Writeln channel iCh "Number of Tables with differences: " (String(iSize))
108597>>>            End
108597>>>>
108597>>>            Writeln channel iCh "*** IMPORTANT: The SQL collation used for the 'FROM' and 'TO' database are different! ***"
108600>>>            Writeln channel iCh 
108602>>>        End
108602>>>>
108602>>>        
108602>>>        If (iSize = 0) Begin
108604>>>            Writeln channel iCh "*** No table differences found. All tables should be identical! ***"
108607>>>        End
108607>>>>
108607>>>
108607>>>        Send Seq_Close_Channel iCh
108608>>>    End_Procedure
108609>>>
108609>>>    Function MakeStringLength String sValue Integer iReportColumnPos Returns String
108612>>>        Move (Pad(sValue, (Length(sValue) + (iReportColumnPos - Length(sValue))))) to sValue
108613>>>
108613>>>        Function_Return sValue
108614>>>    End_Function
108615>>>
108615>>>    Function MakeFromString String sStartText String sText String sMissingText Boolean bExists Returns String
108618>>>        String sFrom
108618>>>
108618>>>        Get MakeStringLength sStartText CI_ReportColumn1 to sFrom
108619>>>        If (bExists = True) Begin
108621>>>            Move (sFrom + String(sText)) to sFrom
108622>>>        End
108622>>>>
108622>>>        Else Begin
108623>>>            Move (sFrom + String(sMissingText)) to sFrom
108624>>>        End
108624>>>>
108624>>>        Get MakeStringLength sFrom CI_ReportColumn2 to sFrom
108625>>>
108625>>>        Function_Return sFrom
108626>>>    End_Function
108627>>>
108627>>>    Function MakeToString String sStartText String sText String sMissingText Boolean bSame Returns String
108630>>>        String sTo
108630>>>
108630>>>        Move (String(sStartText) * String(sText)) to sTo
108631>>>        If (bSame = False) Begin
108633>>>            If (sTo <> "-1") Begin
108635>>>                Move (sTo * String(sMissingText)) to sTo
108636>>>            End
108636>>>>
108636>>>            Else Begin
108637>>>                Move (String(sMissingText)) to sTo
108638>>>            End
108638>>>>
108638>>>        End
108638>>>>
108638>>>
108638>>>        Function_Return sTo
108639>>>    End_Function
108640>>>
108640>>>    Function FindArrayItem tAPITable[] aFromStructure tAPITable[] aToStructure Integer iCount Handle ByRef hTable Integer ByRef iItemFrom Integer ByRef iItemTo Returns String
108643>>>        Integer iSizeFrom iSizeTo
108643>>>        Handle hTableFrom hTableTo
108643>>>        String sLogicalName
108643>>>
108643>>>        Move (SizeOfArray(aFromStructure)) to iSizeFrom
108644>>>        Move (SizeOfArray(aToStructure))   to iSizeTo
108645>>>
108645>>>        Move -1 to hTableFrom
108646>>>        Move -1 to hTableTo
108647>>>        Move iCount to iItemFrom
108648>>>        Move iCount to iItemTo
108649>>>
108649>>>        // The two struct arrays may be different in size (contain different number of items/tables).
108649>>>        //
108649>>>        // To avoid "Referenced Array Index Out of Bounds" error.
108649>>>        If (iCount < iSizeFrom) Begin
108651>>>            Move aFromStructure[iCount].ApiTableInfo.iTableNumber to hTableFrom
108652>>>        End
108652>>>>
108652>>>        If (iCount < iSizeTo) Begin
108654>>>            Move aToStructure[iCount].ApiTableInfo.iTableNumber   to hTableTo
108655>>>        End
108655>>>>
108655>>>        If (hTableFrom <> -1 and hTableTo <> -1) Begin
108657>>>            Move (hTableFrom min hTableTo)                to hTable
108658>>>        End
108658>>>>
108658>>>        Else Begin
108659>>>            Move (hTableFrom max hTableTo)                to hTable
108660>>>        End
108660>>>>
108660>>>
108660>>>        If (iCount < iSizeFrom and hTableFrom <= hTableTo) Begin
108662>>>            Move aFromStructure[iCount].ApiTableInfo.sLogicalName to sLogicalName
108663>>>            Get FindTableNumber (&aToStructure) hTable to iItemTo
108664>>>        End
108664>>>>
108664>>>
108664>>>        // If the 'TO' table number is lower than 'FROM'
108664>>>        Else If (iCount < iSizeTo) Begin
108667>>>            Move aToStructure[iCount].ApiTableInfo.sLogicalName to sLogicalName
108668>>>            Get FindTableNumber (&aFromStructure) hTable to iItemFrom
108669>>>        End
108669>>>>
108669>>>        Else If (iCount = iSizeTo) Begin
108672>>>            Get FindTableNumber (&aToStructure) hTable to iItemTo
108673>>>        End
108673>>>>
108673>>>
108673>>>        Function_Return sLogicalName
108674>>>    End_Function
108675>>>
108675>>>    Function FindTableNumber tAPITable[] ByRef aTableStructure Handle hTable Returns Integer
108678>>>        Integer iSize iCount iTable iItem
108678>>>        tAPITableNameInfo ApiTableNameInfo
108678>>>        tAPITableNameInfo ApiTableNameInfo
108678>>>
108678>>>        Move -1 to iItem
108679>>>        Move (SizeOfArray(aTableStructure)) to iSize
108680>>>        Decrement iSize
108681>>>        For iCount from 0 to iSize
108687>>>>
108687>>>            Move aTableStructure[iCount].ApiTableInfo to ApiTableNameInfo
108688>>>            If (ApiTableNameInfo.iTableNumber = hTable) Begin
108690>>>                Move iCount to iItem
108691>>>                Move iSize  to iCount // We're done.
108692>>>            End
108692>>>>
108692>>>        Loop
108693>>>>
108693>>>
108693>>>        Function_Return iItem
108694>>>    End_Function
108695>>>
108695>>>    // Pass one tAPIRelation for the FROM database and a struct array with relations for the TO database
108695>>>    // Returns the item number in the aAPIRelationsTO that equals the FROM relation struct data.
108695>>>    // If not found returns -1.
108695>>>//    Function FindEqualRelation tAPIRelation APIRelationFrom tAPIRelation[] aAPIRelationsTO Returns Integer
108695>>>//        Integer iRetval iSize iCount
108695>>>//
108695>>>//        Move -1 to iRetval
108695>>>//        Move (SizeOfArray(aAPIRelationsTO)) to iSize
108695>>>//        Decrement iSize
108695>>>//        For iCount from 0 to iSize
108695>>>//            If (APIRelationFrom.hTableFrom  = aAPIRelationsTO[iCount].hTableFrom  and ;
108695>>>//                APIRelationFrom.iColumnFrom = aAPIRelationsTO[iCount].iColumnFrom and ;
108695>>>//                APIRelationFrom.hTableTo    = aAPIRelationsTO[iCount].hTableTo    and ;
108695>>>//                APIRelationFrom.iColumnTo   = aAPIRelationsTO[iCount].iColumnTo) Begin
108695>>>//                    Move iCount to iRetval
108695>>>//                End
108695>>>//        Loop
108695>>>//
108695>>>//        Function_Return iRetval
108695>>>//    End_Function
108695>>>
108695>>>    // Returns a value <> -1 if the passed iIndex was found in the APIIndex struct array.
108695>>>    // The value returned is the item number, else a -1.
108695>>>//    Function FindIndexInArray Integer iIndex tAPIIndex[] APIIndex Returns Integer
108695>>>//        Integer iRetval iSize iCount iCompareIndex
108695>>>//
108695>>>//        Move -1 to iRetval
108695>>>//        Move (SizeOfArray(APIIndex)) to iSize
108695>>>//        Decrement iSize
108695>>>//        For iCount from 0 to iSize
108695>>>//            If (iIndex = APIIndex[iCount].iIndexNumber) Begin
108695>>>//                Move iCount to iRetval
108695>>>//            End
108695>>>//        Loop
108695>>>//        Function_Return iRetval
108695>>>//    End_Function
108695>>>
108695>>>    Procedure Request_Clear
108698>>>        tSQLConnection Connection
108698>>>        tSQLConnection Connection
108698>>>        Integer[] iDifferencesEmpty
108699>>>
108699>>>        Move DATAFLEX_ID to Connection.sDriverID
108700>>>        Set pSQLConnection of ghoSQLConnectionHandler to Connection
108701>>>        Set Value of oFilelistPathFrom_fm   to ""
108702>>>        Set Value of oFilelistPathTo_fm     to ""
108703>>>        Set Value of oReportFileName_fm     to ""
108704>>>        Set psFilelistFrom of ghoApplication to ""
108705>>>        Set piaDifferences of ghoApplication to iDifferencesEmpty
108706>>>
108706>>>        Send Activate of oFilelistPathFrom_fm
108707>>>    End_Procedure
108708>>>
108708>>>    Object oBusinessProcess is a BusinessProcess
108710>>>        Set Status_Panel_Id to ghoStatusPanel
108711>>>        Set Allow_Cancel_State to True
108712>>>        Set Process_Caption to "The Database Update Framework"
108713>>>        Set Process_Title to "Comparing Database Structures..."
108714>>>//        Set Display_Error_State to True // Temp!
108714>>>
108714>>>        Procedure OnProcess
108717>>>            Send MainProcess
108718>>>        End_Procedure
108719>>>
108719>>>        Procedure Ignore_Error Integer iError
108722>>>        End_Procedure
108723>>>        Procedure Trap_Error Integer iError
108726>>>        End_Procedure
108727>>>
108727>>>    End_Object
108728>>>
108728>>>    Object oCompare_btn is a cRDCCommandLinkButton
108730>>>        Set Size to 36 166
108731>>>        Set Location to 276 139
108732>>>        Set Label to "Co&mpare Databases!"
108733>>>        Set psNote to "Compare the two selected databases."
108734>>>        Set psImage to "DbCompare1.ico"
108735>>>        Set Default_State to True
108736>>>        Set psToolTip to "Start the compare process"
108737>>>        Set piImageSize to 32 // 48
108738>>>        Set peAnchors to anBottomRight
108739>>>
108739>>>        Procedure OnClick
108742>>>            String sFilelistFrom sFilelistTo
108742>>>            Integer[] iaDifferences
108743>>>            Boolean bFromExists bToExists
108743>>>
108743>>>            Get Value of oFilelistPathFrom_fm to sFilelistFrom
108744>>>            Get vFilePathExists sFilelistFrom to bFromExists
108745>>>            Get Value of oFilelistPathTo_fm   to sFilelistTo
108746>>>            Get vFilePathExists sFilelistTo   to bToExists
108747>>>            If (bFromExists = False or bToExists = False) Begin
108749>>>                Send Info_Box "You need to both select a FROM and a TO database Filelist.cfg. Please adjust and try again."
108750>>>                Procedure_Return
108751>>>            End
108751>>>>
108751>>>
108751>>>            Send DoProcess of oBusinessProcess
108752>>>            Send Restore_DF_OPEN_PATH of ghoApplication
108753>>>        End_Procedure
108754>>>
108754>>>        Function IsEnabled Returns Boolean
108757>>>            String sFileListFrom sFileListTo
108757>>>            Boolean bExists bState
108757>>>
108757>>>            Get Value of oFilelistPathFrom_fm to sFileListFrom
108758>>>            Get vFilePathExists sFileListFrom to bExists
108759>>>            If (bExists = False) Begin
108761>>>                Function_Return False
108762>>>            End
108762>>>>
108762>>>            Get Value of oFilelistPathTo_fm to sFileListTo
108763>>>            Get vFilePathExists sFileListTo to bExists
108764>>>            Get Enabled_State to bState
108765>>>            If (bState = False and bExists = False) Begin
108767>>>                Function_Return False
108768>>>            End
108768>>>>
108768>>>            Function_Return bExists
108769>>>        End_Function
108770>>>
108770>>>    End_Object
108771>>>
108771>>>    Object oViewReport_Btn is a cRDCCommandLinkButton
108773>>>        Set Size to 36 77
108774>>>        Set Location to 276 315
108775>>>        Set Label to "&Report"
108776>>>        Set psNote to "View report"
108777>>>        Set peAnchors to anBottomRight
108778>>>        Set psImage to "ViewReport1.ico"
108779>>>        Set psToolTip to "Open the folder where the report was generated. (Ctrl+R)"
108780>>>        Set piImageSize to 16 //24
108781>>>
108781>>>        Procedure OnClick
108784>>>            Send DoShowReport
108785>>>        End_Procedure
108786>>>        
108786>>>        Procedure DoShowReport
108789>>>            String sReportName
108789>>>            Get Value of oReportFileName_fm to sReportName
108790>>>            Send ActivateLogFileDialog of (Client_Id(ghoCommandBars)) sReportName
108791>>>//            Runprogram Shell Background sReportName
108791>>>        End_Procedure
108792>>>
108792>>>        Function IsEnabled Returns Boolean
108795>>>            String sReportName
108795>>>            Boolean bExists
108795>>>
108795>>>            Get Value of oReportFileName_fm to sReportName
108796>>>            Get vFilePathExists sReportName to bExists
108797>>>            Function_Return bExists
108798>>>        End_Function
108799>>>
108799>>>    End_Object
108800>>>
108800>>>    Object oTagFilelist_Btn is a cRDCCommandLinkButton
108802>>>        Set Size to 36 76
108803>>>        Set Location to 276 402
108804>>>        Set Label to "&Tag"
108805>>>        Set psNote to "Tag differences"
108806>>>        Set peAnchors to anBottomRight
108807>>>        Set MultiLineState to True
108808>>>        Set Border_Style to Border_Normal
108809>>>        Set peImageAlign to Button_ImageList_Align_Center
108810>>>        Set psImage to "SelectInvert1.ico"
108811>>>        Set psToolTip to "Tag Tables for the 'FROM' Filelist.cfg with differences - for code generation on the 'Code Generator' view page."
108812>>>        Set pbAutoEnable to True
108813>>>        Set piImageSize to 16 // 24
108814>>>
108814>>>        Procedure OnClick
108817>>>            String sFileListFrom
108817>>>            Get Value of oFilelistPathFrom_fm    to sFileListFrom
108818>>>            Set psFilelistFrom of ghoApplication to sFileListFrom
108819>>>            Send TagFileNamesForCodeGeneration
108820>>>        End_Procedure
108821>>>
108821>>>        Function IsEnabled Returns Boolean
108824>>>            Integer[] iaDifferences
108825>>>            Get piaDifferences of ghoApplication to iaDifferences
108826>>>            Function_Return (SizeOfArray(iaDifferences))
108827>>>        End_Function
108828>>>
108828>>>    End_Object
108829>>>
108829>>>    Procedure OnSetFocus
108832>>>        If (SizeOfArray(phoActiveUpdates(ghoCommandBars)) <> 0) Begin
108834>>>            Send Execute of (oCompareDatabases_MenuItem(ghoCommandBars))
108835>>>        End
108835>>>>
108835>>>    End_Procedure
108836>>>    
108836>>>    Procedure OnFileDropped String sFilename Boolean bLast
108839>>>        String sTest sFileListFrom sFileListTo
108839>>>
108839>>>        Forward Send OnFileDropped sFilename bLast
108841>>>        Get Value of oFilelistPathFrom_fm to sFileListFrom
108842>>>        Get Value of oFilelistPathTo_fm    to sFileListTo
108843>>>        If (bLast = True) Begin
108845>>>            Get ParseFileName sFilename to sTest
108846>>>            If (Uppercase(sTest) <> "FILELIST.CFG") Begin
108848>>>                Send Info_Box "Sorry, only Filist.cfg files can be dropped here..."
108849>>>                Procedure_Return
108850>>>            End                                           
108850>>>>
108850>>>            If (sFileListFrom = "") Begin
108852>>>                Set Value of oFilelistPathFrom_fm to sFilename
108853>>>            End 
108853>>>>
108853>>>            Else Begin
108854>>>                Set Value of oFilelistPathTo_fm to sFilename
108855>>>            End
108855>>>>
108855>>>                
108855>>>        End
108855>>>>
108855>>>    End_Procedure
108856>>>
108856>>>    On_Key Key_Ctrl+Key_M  Send KeyAction of oCompare_btn
108857>>>    On_Key Key_Ctrl+Key_R  Send KeyAction of oViewReport_Btn
108858>>>    On_Key Key_Ctrl+Key_T  Send KeyAction of oTagFilelist_Btn
108859>>>    On_Key kClear          Send Request_Clear
108860>>>    On_Key kClear_All      Send Request_Clear
108861>>>    On_Key Key_Ctrl+Key_F4 Send None
108862>>>End_Object
108863>
108863>        Use StdAbout.pkg
Including file: StdAbout.pkg    (C:\Projects\DF20\DbUpdateFramework\Libraries\DFAbout\StdAbout.pkg)
108863>>>//************************************************************************
108863>>>// Confidential Trade Secret.
108863>>>// Copyright (c) 1997 Data Access Corporation, Miami Florida
108863>>>// as an unpublished work.  All rights reserved.
108863>>>// DataFlex is a registered trademark of Data Access Corporation.
108863>>>//
108863>>>//************************************************************************
108863>>>//************************************************************************
108863>>>//
108863>>>// $File name  : StdAbout.pkg
108863>>>// $File title : Standard about object package for VDF
108863>>>// Notice      :
108863>>>// $Author(s)  : John Tuohy
108863>>>//
108863>>>// $Rev History
108863>>>//
108863>>>// JT 06/27/97   File created
108863>>>//************************************************************************
108863>>>
108863>>>// This provides a quick and simple way to create an about package for a program.
108863>>>// You need to create a message inside you client area called Activate_About.
108863>>>// Within this message you should send the message DoAbout passing needed
108863>>>// string information.
108863>>>//
108863>>>//       Procedure Activate_About
108863>>>//           Send DoAbout sTitle sVersion sCopyright sAuthor sBitmap
108863>>>//       End_Procedure
108863>>>//    where: sTitle =     Name of application. If none provided, uses caption
108863>>>//                        bar title
108863>>>//           sVersion   = Version Line. If none provided, will be blank
108863>>>//           sCopyRight = Copyright Line. If none provided, will be blank
108863>>>//           sAuthor    = Author name, blank if none provided
108863>>>//           sBitMap    = Bitmap logo. If none provided, standard VDF bitmap
108863>>>//                        is used.
108863>>>// It is expected that you will place this in your own object package. For
108863>>>// example an order about package may look like this:
108863>>>//
108863>>>//   // OrderAbout.pkg
108863>>>//   Use StdAbout.pkg
108863>>>//   Procedure Activate_About
108863>>>//      String sTitle sCopyright sVersion sAuthor
108863>>>//      Move "My Order Entry System" to sTitle
108863>>>//      Move "Version 2.1" to sVersion
108863>>>//      Move "Copyright 1997, Super Software Inc." to sCopyright
108863>>>//      Move "John Smith"  to sAuthor
108863>>>//      Send DoAbout sTitle sVersion sCopyright sAuthor ""
108863>>>//   end_procedure
108863>>>//   // end of file.
108863>>>
108863>>>Use DfAbout.pkg
108863>>>
108863>>>// *************************************************************************
108863>>>//  Public message. This is the default message. It is expected that you will
108863>>>//   create your own message to override this
108863>>>// *************************************************************************
108863>>>
108863>>>Procedure Activate_About
108866>>>    Send DoAbout "" "" "" "" "" "" "" "" "" ""
108867>>>End_Procedure
108868>>>
108868>>>// *************************************************************************
108868>>>//  Public message. It is expected that you will send this message (most
108868>>>//  likely from Activate_About. This creates an about object, activates it
108868>>>//  and destroys it when done. It is not exepected that you will augment this.
108868>>>// *************************************************************************
108868>>>// Sample usage:
108868>>>//   The first two params will automatically be filled from the application settings if not provided.
108868>>>//   Send DoAbout "" "" ("Copyright: 2013" * psCompany(ghoApplication)) "Created by: Your Name" "YourAppBitmap.bmp" "Internet: http://www.YourWebAddress.com" "E-mail: mailto:support@YourEmailAddress.com" "Some other description of choice" "9th param" "and last param"
108868>>>
108868>>>Procedure DoAbout String sTitle String sVersion String sCopyRight String sAuthor String sBitmap ;    String sParam6 String sParam7 String sParam8 String sParam9 String sParam10
108871>>>    Integer hoObj hoMain iArgs
108871>>>    String sValue
108871>>>
108871>>>    // Create object
108871>>>    Object About is an AboutDialog
108873>>>    // Uncomment these two lines if you would like to have a resizable About object.
108873>>>    //            Set Border_Style to Border_Thick
108873>>>    //            Set peAnchors to anAll
108873>>>
108873>>>    // Add checking for the number of arguments passed to avoid runtime errors
108873>>>    // if one of them is not passed. This makes the interface
108873>>>    // more flexible.
108873>>>        Move num_arguments to iArgs
108874>>>
108874>>>        // If no title is passed use the label of the main panel (if a main panel exists).
108874>>>        If (iArgs > 0 and sTitle = "") Begin
108876>>>            Get Main_Window of Desktop to hoMain
108877>>>            If hoMain Begin
108879>>>                Get Label of hoMain to sValue
108880>>>            End
108880>>>>
108880>>>        End
108880>>>>
108880>>>        Else If (iArgs > 0 and sTitle <> "") Begin
108883>>>            Move sTitle to sValue
108884>>>        End
108884>>>>
108884>>>        Else If (iArgs = 0) Begin
108887>>>            Get Main_Window of Desktop to hoMain
108888>>>            If hoMain Begin
108890>>>                Get Label of hoMain to sValue
108891>>>            End
108891>>>>
108891>>>        End
108891>>>>
108891>>>
108891>>>        If (sValue <> "") Begin
108893>>>            Send Add_LineLn sValue
108894>>>        End
108894>>>>
108894>>>        Move "" to sValue
108895>>>
108895>>>        // If the passed sVersion value is blank, the info will be retrieved from the cApplication object.
108895>>>        // For this to work the Project Properties Version must have been set in the Studio.
108895>>>        If (iArgs < 2) Begin
108897>>>            Move "" to sValue
108898>>>        End
108898>>>>
108898>>>        Else Begin
108899>>>            Move sVersion to sValue
108900>>>        End
108900>>>>
108900>>>        Set Version to sValue
108901>>>
108901>>>        If (iArgs > 2 and sCopyRight <> "") Begin
108903>>>            Send Add_LineLn sCopyRight
108904>>>        End
108904>>>>
108904>>>
108904>>>        // If only the five "standard" params were passed we don't add an extra linefeed;
108904>>>        // else we do.
108904>>>        If (iArgs > 3 and iArgs < 6 and sAuthor <> "") Begin
108906>>>            Send Add_Line sAuthor
108907>>>        End
108907>>>>
108907>>>        Else If (iArgs > 5 and sAuthor <> "") Begin
108910>>>            Send Add_LineLn sAuthor
108911>>>        End
108911>>>>
108911>>>
108911>>>        // Square bitmaps of 80x80 works best
108911>>>        If (iArgs > 4 and sBitmap <> "") Begin
108913>>>            Set Logo to sBitMap
108914>>>        End
108914>>>>
108914>>>
108914>>>        // Here starts handling of the five optional params:
108914>>>        If (iArgs = 6 and sParam6  <> "") Begin
108916>>>            Send Add_Line sParam6
108917>>>        End
108917>>>>
108917>>>        Else If (iArgs > 6 and sParam6  <> "") Begin
108920>>>            Send Add_LineLn sParam6
108921>>>        End
108921>>>>
108921>>>
108921>>>        If (iArgs = 7 and sParam7  <> "") Begin
108923>>>            Send Add_Line sParam7
108924>>>        End
108924>>>>
108924>>>        Else If (iArgs > 7 and sParam7  <> "") Begin
108927>>>            Send Add_LineLn sParam7
108928>>>        End
108928>>>>
108928>>>
108928>>>        If (iArgs = 8 and sParam8  <> "") Begin
108930>>>            Send Add_Line sParam8
108931>>>        End
108931>>>>
108931>>>        Else If (iArgs > 8 and sParam8  <> "") Begin
108934>>>            Send Add_LineLn sParam8
108935>>>        End
108935>>>>
108935>>>
108935>>>        If (iArgs = 9 and sParam9  <> "") Begin
108937>>>            Send Add_Line sParam9
108938>>>        End
108938>>>>
108938>>>        Else If (iArgs > 9 and sParam9  <> "") Begin
108941>>>            Send Add_LineLn sParam9
108942>>>        End
108942>>>>
108942>>>
108942>>>        If (iArgs = 10 and sParam10 <> "") Begin
108944>>>            Send Add_Line sParam10
108945>>>        End
108945>>>>
108945>>>
108945>>>        Move Self to hoObj
108946>>>    End_Object
108947>>>
108947>>>    Send Popup   of hoObj // Popup the about object
108948>>>    Send Destroy of hoObj // When done, it will be destroyed
108949>>>End_Procedure
108950>        Use CompareDatabases.rv
Including file: CompareDatabases.rv    (C:\Projects\DF20\DbUpdateFramework\AppSrc\CompareDatabases.rv)
108950>>>Use Windows.pkg
108950>>>Use DFRptVw.pkg
108950>>>Use DFRpt.pkg
108950>>>Use File_Dlg.Pkg
108950>>>Use CompareDatabases.img
Including file: CompareDatabases.img    (C:\Projects\DF20\DbUpdateFramework\AppSrc\CompareDatabases.img)
108950>>>>>// CompareDatabases Basic Report
108950>>>>>// Since report images, such as the one used here, are not fully supported by
108950>>>>>// the Studio, the images for this report are placed in a separate package.
108950>>>>>//
/HEADER
Image 1, HEADER
 ***  The Database Update Framework (DUF) DATABASE DIFFERENCES REPORT  ***
     
      Date & Time Printed       : ____________________
      FROM Database Filelist.cfg: ________________________________________________________________________________________________________________________
      TO   Database Filelist.cfg: ________________________________________________________________________________________________________________________
/Top
Image 2, TOP
                                                                           Page:___.
/SubHeader
Image 3, SUBHEADER
________ Difference(s) for Table: ____ - ______________________________    
====================================================================================
FROM Database:                                              TO Database:
------------------------------------------------------------------------
/BodyFields
Image 4, BODYFIELDS
Field Number:  ____                                         ____
Name:          ____________________________________________ ____________________________________________
Type:          ____________________________________________ ____________________________________________
Length:        ____                                         ____
Precision:     ____                                         ____
Identity Field:___                                          ___   
/Footer
Image 5, FOOTER
SUMMARY:
====================================================================================
Number of Tables with differences: ____
/*
108950>>>
108950>>>Activate_View Activate_oCompareDatabases for oCompareDatabases
108960>>>>
108960>>>Object oCompareDatabases is a ReportView
108962>>>    Set Location to 6 6
108963>>>    Set Size to 84 181
108964>>>    Set Label to "Compare Databases"
108965>>>
108965>>>    Property String psFilelistFrom
108967>>>    Property String psFilelistTo
108969>>>    Property Integer piDifferences
108971>>>
108971>>>    Object oDestination is a RadioGroup
108973>>>        Set Size to 59 171
108974>>>        Set Location to 5 5
108975>>>        Set Label to "Output Device:"
108976>>>
108976>>>        Object oScreen is a Radio
108978>>>            Set Label to "Screen"
108979>>>            Set Size to 10 39
108980>>>            Set Location to 15 10
108981>>>            Set Status_Help to "Preview the report to screen"
108982>>>        End_Object
108983>>>
108983>>>        Object oPrinter is a Radio
108985>>>            Set Label to "Printer"
108986>>>            Set Size to 10 37
108987>>>            Set Location to 30 10
108988>>>            Set Status_Help to "Send the report to the default printer"
108989>>>        End_Object
108990>>>
108990>>>        Object oFile is a Radio
108992>>>            Set Label to "File"
108993>>>            Set Size to 10 27
108994>>>            Set Location to 42 10
108995>>>            Set Status_Help to "Send the report to a file"
108996>>>        End_Object
108997>>>
108997>>>        Object oFileNameForm is a Form
108999>>>            Set Label to "FileName:"
109000>>>            Set Size to 13 116
109001>>>            Set Location to 40 50
109002>>>            Set Label_Col_Offset to 0
109003>>>            Set Label_Justification_Mode to jMode_Top
109004>>>            Set Prompt_Button_Mode to pb_PromptOn
109005>>>
109005>>>            Procedure Prompt
109008>>>                Boolean bOk
109008>>>                String sFileName sFilePath sDataPath
109008>>>                Integer hoWorkspace
109008>>>
109008>>>                Get Value To sFileName
109009>>>                If (sFileName <> "") Begin
109011>>>                    Set File_Name Of oSaveAsDialog to sFileName
109012>>>                    Get ExtractFilePath sFileName to sFilePath
109013>>>                End
109013>>>>
109013>>>                If (sFilePath = "") Begin
109015>>>                    Get phoWorkspace Of ghoApplication to hoWorkspace
109016>>>                    Get psDataPath Of hoWorkspace to sDataPath
109017>>>                    Get PathAtIndex Of hoWorkspace sDataPath 1 to sFilePath
109018>>>                End
109018>>>>
109018>>>
109018>>>                Set Initial_Folder Of oSaveAsDialog to sFilePath
109019>>>
109019>>>                Get Show_Dialog Of oSaveAsDialog to bOk
109020>>>                If (bOk) Begin
109022>>>                    Get File_Name Of oSaveAsDialog to sFileName
109023>>>                    Set Value To sFileName
109024>>>                End
109024>>>>
109024>>>            End_Procedure
109025>>>
109025>>>        End_Object
109026>>>
109026>>>        Procedure Notify_Select_State Integer iNewItem Integer iOldItem
109029>>>            Forward Send Notify_Select_State iNewItem iOldItem
109031>>>
109031>>>            Case Begin
109031>>>                Case (iNewItem = 0)
109033>>>                    Set Output_Device_Mode to PRINT_TO_WINDOW
109034>>>                    Case Break
109035>>>                Case (iNewItem = 1)
109038>>>                    Set Output_Device_Mode to PRINT_TO_PRINTER
109039>>>                    Case Break
109040>>>                Case (iNewItem = 2)
109043>>>                    Set Output_Device_Mode to PRINT_TO_FILE
109044>>>                    Case Break
109045>>>            Case End
109045>>>
109045>>>            Set Enabled_State Of oFileNameForm to (iNewItem = 2)
109046>>>        End_Procedure
109047>>>
109047>>>    End_Object
109048>>>
109048>>>    Object oOkButton is a Button
109050>>>        Set Label to "&OK"
109051>>>        Set Location to 66 71
109052>>>        Set Default_State to TRUE
109053>>>
109053>>>        Procedure OnClick
109056>>>            Send StartReport
109057>>>        End_Procedure
109058>>>
109058>>>    End_Object
109059>>>
109059>>>    Object oCancelButton is a Button
109061>>>        Set Label to "&Cancel"
109062>>>        Set Location to 66 126
109063>>>
109063>>>        Procedure OnClick
109066>>>            Send Request_Cancel
109067>>>        End_Procedure
109068>>>
109068>>>    End_Object
109069>>>
109069>>>    Object oSaveAsDialog is a SaveAsDialog
109071>>>    End_Object
109072>>>
109072>>>    Procedure StartReport
109075>>>        Integer iOutputDevice
109075>>>        Handle hoWorkspace
109075>>>        String sFileName sCurrentDirectory sDataPath
109075>>>
109075>>>        Get Output_Device_Mode to iOutputDevice
109076>>>
109076>>>        Case Begin
109076>>>            Case (iOutputDevice = PRINT_TO_WINDOW)
109078>>>                Get_Current_Directory to sCurrentDirectory
109079>>>                Get phoWorkspace Of ghoApplication to hoWorkspace
109080>>>                Get psDataPath Of hoWorkspace to sDataPath
109081>>>                Get PathAtIndex Of hoWorkspace sDataPath 1 to sDataPath
109082>>>                Set_Directory sDataPath
109083>>>                Make_Temp_File "TXT" sFileName
109084>>>                Set_Directory sCurrentDirectory
109085>>>                If (Right(sDataPath, 1) <> Sysconf(SYSCONF_DIR_SEPARATOR)) Begin
109087>>>                    Move (sDataPath - Sysconf(SYSCONF_DIR_SEPARATOR)) To sDataPath
109088>>>                End
109088>>>>
109088>>>                Move (sDataPath - sFileName) to sFileName
109089>>>                Set Output_Device_Name to sFileName
109090>>>                Case Break
109091>>>            Case (iOutputDevice = PRINT_TO_PRINTER)
109094>>>                Set Output_Device_Name to "WinLST:"
109095>>>                Case Break
109096>>>            Case (iOutputDevice = PRINT_TO_FILE)
109099>>>                Get Value Of oFileNameForm to sFileName
109100>>>                Set Output_Device_Name to sFileName
109101>>>                Case Break
109102>>>        Case End
109102>>>
109102>>>        Send Run_Report
109103>>>
109103>>>        If (iOutputDevice = PRINT_TO_WINDOW) Begin
109105>>>            //Runprogram Background "NotePad" sFileName
109105>>>            Runprogram Shell Background sFileName
109106>>>            EraseFile sFileName
109107>>>>
109107>>>        End
109107>>>>
109107>>>    End_Procedure
109108>>>
109108>>>    Object oBasicReport is a BasicReport
109110>>>
109110>>>        Function Starting_Main_Report Returns Integer
109113>>>            Integer iRetval
109113>>>
109113>>>            Forward Get Starting_Main_Report to iRetval
109115>>>
109115>>>            Function_Return iRetval
109116>>>        End_Function
109117>>>
109117>>>        Procedure_Section Report_Header as Header
109122>>>            DateTime dtCreationTime
109122>>>            String sFilelistFrom sFilelistTo
109122>>>
109122>>>            Get psFilelistFrom to sFilelistFrom
109123>>>            Get psFilelistTo   to sFilelistTo
109124>>>            Move (CurrentDateTime()) to dtCreationTime
109125>>>
109125>>>            Print sFilelistFrom
109126>>>            Print sFilelistTo
109127>>>            Print dtCreationTime
109128>>>            Output_PageCheck Header
109129>>>        End_Procedure
109130>>>
109130>>>        Procedure_Section Page_Top as Top
109135>>>            Integer iPage
109135>>>
109135>>>            Get Page_Count to iPage
109136>>>            Print iPage
109137>>>            OutPut_PageCheck
109138>>>        End_Procedure
109139>>>
109139>>>        Procedure_Section SubHeaderFields as SubHeader
109144>>>            Print "Field"
109145>>>            Print "Table#"
109146>>>            Print "Table Name"
109147>>>        End_Procedure
109148>>>
109148>>>        Procedure_Section Body as BodyFields
109153>>>            Forward Send Body
109155>>>            // Print File.Field // Gets printed at BodySection.1
109155>>>            // Print Variable // Gets printed at BodySection.2
109155>>>            // Output_PageCheck // Without this nothing gets printed
109155>>>        End_Procedure
109156>>>
109156>>>//        Procedure_Section Page_Bottom as FooterSection
109156>>>//            Forward Send Page_Bottom
109156>>>//            // Output_PageCheck // Without this nothing gets printed
109156>>>//        End_Procedure
109156>>>
109156>>>        Procedure_Section Total as Footer
109161>>>            Integer iDifferences
109161>>>            Get piDifferences to iDifferences
109162>>>            Print iDifferences
109163>>>        End_Procedure
109164>>>
109164>>>    End_Object
109165>>>
109165>>>    On_Key Key_Alt+Key_O Send KeyAction of oOkButton
109166>>>    On_Key Key_Alt+Key_C Send KeyAction of oCancelButton
109167>>>
109167>>>End_Object
109168>        Procedure Activate_About
109171>            Send DoAbout "" "" ("Copyright 2016-2020" * psCompany(ghoApplication)) "Author: Nils Svedmyr" "DUFUpdateCodeGenerator64x64.bmp" "E-mail: mailto:support@rdctools.com" "Web-site: www.rdctools.com" ("This tool was created with DataFlex" * String(C_DFVersion) * "from Data Access Worldwide. Please visit http://www.dataaccess.com for a free personal copy of DataFlex.")
109172>        End_Procedure
109173>
109173>        On_Key Key_Ctrl+Key_Tab           Send Switch_Next_View
109174>        On_Key Key_Ctrl+Key_Shift+Key_Tab Send Switch_Prior_View
109175>    End_Object
109176>
109176>    // Note that we have overriden the cHtmlHelp "GetHelpFile" function
109176>    // in the oHtmlHelp object, so we need to explitetly send the message
109176>    // to that object.
109176>    Procedure ShowProgramHelp
109179>        Set psHelpFile of ghoApplication to "Developer5.chm"
109180>        Send DoDisplayKeyword of oHtmlHelp "DUF Code Generator"
109181>    End_Procedure
109182>
109182>    Procedure ActivateCompareView
109185>        Send Execute of (oCompareDatabases_MenuItem(ghoCommandBars))
109186>    End_Procedure
109187>
109187>    Procedure ActivateGenerateView
109190>        Send Execute of (oCodeGenerator_MenuItem(ghoCommandBars))
109191>    End_Procedure
109192>
109192>    On_Key Key_Alt+Key_D   Send ActivateCompareView
109193>    On_Key Key_Ctrl+Key_D  Send ActivateCompareView
109194>    On_Key Key_Alt+Key_G   Send ActivateGenerateView
109195>    On_Key Key_Ctrl+Key_G  Send ActivateGenerateView    
109196>    On_Key Key_F1          Send ShowProgramHelp
109197>End_Object
109198>
109198>Send Execute of (oCodeGenerator_MenuItem(ghoCommandBars))
109199>Start_UI
109200>
Including Resources...
Summary
Memory Available: 2147483646
Total Warnings : 0
Total Errors   : 0
Total Symbols  : 55594
Total Resources: 6
Total Commands : 109199
Total Windows  : 20
Total Pages    : 5
Static Data    : 885513
Message area   : 650962
Total Blocks   : 38495
